= tszEmpty)
    {
        ZERO_PASSWORD(pAccountInfo->pwszPassword);
        delete pAccountInfo->pwszPassword;
        pAccountInfo->pwszPassword = (LPWSTR) tszEmpty;
    }
}
#endif // !defined(_CHICAGO_)

#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   InitializeAccountInfo
//
//  Synopsis:   Initializes account info fields.
//
//  Arguments:  [pAccountInfo]      -- Account info structure.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
InitializeAccountInfo(AccountInfo * pAccountInfo)
{
    pAccountInfo->pwszAccountName = NULL;

    //
    // If we haven't prompted for a password, pwszPassword points to the
    // global empty string variable.  This allows us to tell whether the
    // user intended the password to be an empty string, or we simply
    // haven't prompted for it.
    //

    pAccountInfo->pwszPassword    = (LPWSTR) tszEmpty;
}
#endif // !defined(_CHICAGO_)

//
// Helpers to launch Set/Change Password & Set Account Information dialogs.
//

#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   LaunchSetPasswordDlg
//
//  Synopsis:   Helper to launch the dialog to modify the account password.
//
//  Arguments:  [hWnd]         -- Parent window handle.
//              [pAccountInfo] -- Structure manipulated by the dialog.
//
//  Returns:    DialogBoxParam return code.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
INT_PTR
LaunchSetPasswordDlg(HWND hWnd, AccountInfo * pAccountInfo)
{
    return(DialogBoxParam(g_hInstance,
                          MAKEINTRESOURCE(set_passwd_dlg),
                          hWnd,
                          SetPasswordDlgProc,
                          (LPARAM)pAccountInfo));
}
#endif // !defined(_CHICAGO_)

#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   LaunchSetAccountInformationDlg
//
//  Synopsis:   Helper to launch the dialog to modify the account namd and
//              password.
//
//  Arguments:  [hWnd]         -- Parent window handle.
//              [pAccountInfo] -- Structure manipulated by the dialog.
//
//  Returns:    DialogBoxParam return code.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
INT_PTR
LaunchSetAccountInformationDlg(HWND hWnd, AccountInfo * pAccountInfo)
{
    return(DialogBoxParam(g_hInstance,
                          MAKEINTRESOURCE(set_account_info_dlg),
                          hWnd,
                          SetAccountInformationDlgProc,
                          (LPARAM)pAccountInfo));
}
#endif // !defined(_CHICAGO_)

//
// Set/Change Password & Set Account Information dialogs.
//

#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   SetPasswordDlgProc
//
//  Synopsis:   This dialog allows the user specify an account password.
//              The password is confirmed by a redundant confirmation edit
//              field.
//
//  Arguments:  [hDlg]   -- Dialog handle.
//              [uMsg]   -- Message.
//              [wParam] -- Command.
//              [lParam] -- Account information dialog ptr on WM_INITDIALOG.
//
//  Returns:    TRUE  -- Message processed by this dialog.
//              FALSE -- Message not processed (WM_INITDIALOG excepted).
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
INT_PTR APIENTRY
SetPasswordDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static AccountInfo * pai                      = NULL;
    TCHAR  tszPassword[MAX_PASSWORD + 1]          = TEXT("");
    TCHAR  tszConfirmedPassword[MAX_PASSWORD + 1] = TEXT("");
    LPWSTR pwszPassword;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        Win4Assert(lParam != NULL);
        pai = (AccountInfo *)lParam;
        Edit_LimitText(GetDlgItem(hDlg, edt_sp_passwd), MAX_PASSWORD);
        Edit_LimitText(GetDlgItem(hDlg, edt_sp_cfrmpasswd), MAX_PASSWORD);
        I_SetDlgItemText(hDlg, edt_sp_passwd, pai->pwszPassword);
        I_SetDlgItemText(hDlg, edt_sp_cfrmpasswd, pai->pwszPassword);

        //
        // Center the dialog.
        //

        CenterDialog(hDlg);
        return TRUE; // TRUE == let windows set focus

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            DWORD ccPassword;

            ccPassword = GetDlgItemText(hDlg,
                                        edt_sp_passwd,
                                        tszPassword,
                                        MAX_PASSWORD + 1);

            GetDlgItemText(hDlg,
                           edt_sp_cfrmpasswd,
                           tszConfirmedPassword,
                           MAX_PASSWORD + 1);

            if (lstrcmp(tszPassword, tszConfirmedPassword) != 0)
            {
                //
                // Passwords didn't match. Let the user know so he/she
                // can correct it.
                //

                ZeroMemory(tszPassword, sizeof tszPassword);
                ZeroMemory(tszConfirmedPassword, sizeof tszConfirmedPassword);
                SchedUIErrorDialog(hDlg, IERR_PASSWORD, (LPTSTR)NULL);
                return(TRUE);
            }

            if (ccPassword)
            {
                //
                // Non-NULL password.
                //

                ccPassword++;
                pwszPassword = new WCHAR[ccPassword];

                if (pwszPassword != NULL)
                {
#if !defined(UNICODE)
                    HRESULT hr = AnsiToUnicode(pwszPassword,
                                               tszPassword,
                                               ccPassword);

                    if (FAILED(hr))
                    {
                        SchedUIErrorDialog(hDlg,
                                           IERR_INTERNAL_ERROR,
                                           0);
                        ZERO_PASSWORD(pwszPassword);
                        delete [] pwszPassword;
                        ZeroMemory(tszPassword, sizeof tszPassword);
                        ZeroMemory(tszConfirmedPassword,
                                   sizeof tszConfirmedPassword);
                        return(TRUE);
                    }
#else
                    lstrcpy(pwszPassword, tszPassword);
#endif // !defined(UNICODE)
                }
                else
                {
                    SchedUIErrorDialog(hDlg, IERR_OUT_OF_MEMORY,
                                       (LPTSTR)NULL);
                }
            }
            else
            {
                //
                // Clear the password.
                //

                pwszPassword = new WCHAR[1];
                if (pwszPassword != NULL)
                {
                    *pwszPassword = L'\0';
                }
                else
                {
                    SchedUIErrorDialog(hDlg, IERR_OUT_OF_MEMORY,
                                       (LPTSTR)NULL);
                    EndDialog(hDlg, wParam);
                    return(TRUE);
                }
            }

            //
            // Zero, delete the previous password. But don't delete the
            // static empty string.
            //

            if (pai->pwszPassword != NULL &&
                pai->pwszPassword != tszEmpty)
            {
                ZERO_PASSWORD(pai->pwszPassword);
                delete pai->pwszPassword;
            }
            pai->pwszPassword = pwszPassword;

        case IDCANCEL:
            ZeroMemory(tszPassword, sizeof tszPassword);
            ZeroMemory(tszConfirmedPassword, sizeof tszConfirmedPassword);
            EndDialog(hDlg, wParam);
            return TRUE;

        default:
            return FALSE;
        }

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle,
                szMstaskHelp,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR)s_aSetPasswordDlgHelpIds);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                szMstaskHelp,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPSTR)s_aSetPasswordDlgHelpIds);
        return TRUE;

    default:
        return FALSE;
    }
}
#endif // !defined(_CHICAGO_)

#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   SetAccountInformationDlgProc
//
//  Synopsis:   This dialog allows the user to specify full account
//              information: the account name and password. The password
//              is confirmed by a redundant confirmation edit field.
//              Logic also ensures the user must specify an account name.
//
//  Arguments:  [hDlg]   -- Dialog handle.
//              [uMsg]   -- Message.
//              [wParam] -- Command.
//              [lParam] -- Account information dialog ptr on WM_INITDIALOG.
//
//  Returns:    TRUE  -- Message processed by this dialog.
//              FALSE -- Message not processed (WM_INITDIALOG excepted).
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
INT_PTR APIENTRY
SetAccountInformationDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                             LPARAM lParam)
{
    static AccountInfo * pai                      = NULL;
    TCHAR  tszAccountName[MAX_USERNAME + 1]       = TEXT("");
    TCHAR  tszPassword[MAX_PASSWORD + 1]          = TEXT("");
    TCHAR  tszConfirmedPassword[MAX_PASSWORD + 1] = TEXT("");
    DWORD  ccAccountName                          = MAX_USERNAME + 1;
    LPWSTR pwszPassword;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        Win4Assert(lParam != NULL);
        pai = (AccountInfo *)lParam;
        Edit_LimitText(GetDlgItem(hDlg, edt_sa_passwd), MAX_USERNAME);
        Edit_LimitText(GetDlgItem(hDlg, edt_sa_passwd), MAX_PASSWORD);
        Edit_LimitText(GetDlgItem(hDlg, edt_sa_cfrmpasswd), MAX_PASSWORD);
        if (pai->pwszAccountName != NULL)
        {
#if !defined(UNICODE)
            //
            // Even if conversion fails, tszAccountName will be terminated,
            // so put it in the UI regardless.
            //
            ZeroMemory(tszAccountName, ARRAYLEN(tszAccountName));
            (void) UnicodeToAnsi(tszAccountName, pai->pwszAccountName,
                            ccAccountName);
#else
            lstrcpy(tszAccountName, pai->pwszAccountName);
#endif // !defined(UNICODE)
        }
        else
        {
            GetDefaultDomainAndUserName(tszAccountName, ccAccountName);
        }
        SetDlgItemText(hDlg, txt_sa_run_as, tszAccountName);
        I_SetDlgItemText(hDlg, edt_sa_passwd, pai->pwszPassword);
        I_SetDlgItemText(hDlg, edt_sa_cfrmpasswd, pai->pwszPassword);

        //
        // Center the dialog.
        //

        CenterDialog(hDlg);
        return TRUE; // TRUE == let windows set focus

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            DWORD ccAccountName, ccPassword;
            tszAccountName[0] = _T('\0');

            ccAccountName = GetDlgItemText(hDlg, txt_sa_run_as,
                                           tszAccountName, MAX_USERNAME + 1);

            if (tszAccountName[0] != _T('\0'))
            {
                ccAccountName++;
                LPWSTR pwszAccountName = (LPWSTR)CoTaskMemAlloc(
                                     ccAccountName * sizeof(WCHAR));

                if (pwszAccountName != NULL)
                {
#if !defined(UNICODE)
                    HRESULT hr = AnsiToUnicode(pwszAccountName,
                                               tszAccountName,
                                               ccAccountName);

                    if (FAILED(hr))
                    {
                        CoTaskMemFree(pwszAccountName);
                        SchedUIErrorDialog(hDlg, IERR_INTERNAL_ERROR, 0);
                        break;
                    }
#else
                    lstrcpy(pwszAccountName, tszAccountName);
#endif // !defined(UNICODE)

                    ccPassword = GetDlgItemText(hDlg, edt_sa_passwd,
                                                tszPassword,
                                                MAX_PASSWORD + 1);

                    GetDlgItemText(hDlg, edt_sa_cfrmpasswd,
                                   tszConfirmedPassword, MAX_PASSWORD + 1);

                    if (lstrcmp(tszPassword, tszConfirmedPassword) != 0)
                    {
                        //
                        // Passwords didn't match. Let the user know so he/she
                        // can correct it.
                        //

                        CoTaskMemFree(pwszAccountName);
                        SchedUIErrorDialog(hDlg, IERR_PASSWORD,
                                           (LPTSTR)NULL);
                        return(TRUE);
                    }
                    else
                    {
                        if (ccPassword)
                        {
                            //
                            // Non-NULL password.
                            //

                            ccPassword++;
                            pwszPassword = new WCHAR[ccPassword];

                            if (pwszPassword != NULL)
                            {
#if !defined(UNICODE)
                                HRESULT hr = AnsiToUnicode(pwszPassword,
                                                           tszPassword,
                                                           ccPassword);
                                if (FAILED(hr))
                                {
                                    CoTaskMemFree(pwszAccountName);
                                    SchedUIErrorDialog(hDlg,
                                                       IERR_INTERNAL_ERROR,
                                                       0);
                                    return(TRUE);
                                }
#else
                                lstrcpy(pwszPassword, tszPassword);
#endif // !defined(UNICODE)
                            }
                            else
                            {
                                CoTaskMemFree(pwszAccountName);
                                SchedUIErrorDialog(hDlg, IERR_OUT_OF_MEMORY,
                                                   (LPTSTR)NULL);
                                EndDialog(hDlg, wParam);
                                return(TRUE);
                            }
                        }
                        else
                        {
                            //
                            // Clear the password.
                            //
                            pwszPassword = new WCHAR[1];
                            if (pwszPassword != NULL)
                            {
                                *pwszPassword = L'\0';
                            }
                            else
                            {
                                CoTaskMemFree(pwszAccountName);
                                SchedUIErrorDialog(hDlg, IERR_OUT_OF_MEMORY,
                                                   (LPTSTR)NULL);
                                EndDialog(hDlg, wParam);
                                return(TRUE);
                            }
                        }
                    }

                    if (pai->pwszAccountName != NULL)
                    {
                        CoTaskMemFree(pai->pwszAccountName);
                    }
                    if (pai->pwszPassword != NULL &&
                        pai->pwszPassword != tszEmpty)
                    {
                        ZERO_PASSWORD(pai->pwszPassword);
                        delete pai->pwszPassword;
                    }
                    pai->pwszAccountName = pwszAccountName;
                    pai->pwszPassword    = pwszPassword;
                }
                else
                {
                    SchedUIErrorDialog(hDlg, IERR_OUT_OF_MEMORY,
                                       (LPTSTR)NULL);
                }
            }
            else
            {
                //
                // User cannot specify an empty account name.
                //

                SchedUIErrorDialog(hDlg, IERR_ACCOUNTNAME, (LPTSTR)NULL);
                return(TRUE);
            }

        case IDCANCEL:
            EndDialog(hDlg, wParam);
            return TRUE;
        }

    default:
        return FALSE;
    }
}
#endif // !defined(_CHICAGO_)



#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   CenterDialog
//
//  Synopsis:   Helper to center a dialog on screen.
//
//  Arguments:  [hDlg]   -- Dialog handle.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CenterDialog(HWND hDlg)
{
    RECT rc;
    GetWindowRect(hDlg, &rc);

    SetWindowPos(hDlg,
                 NULL,
                 ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
                 ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
                 0,
                 0,
                 SWP_NOSIZE | SWP_NOACTIVATE);
}
#endif // !defined(_CHICAGO_)


//+---------------------------------------------------------------------------
//
//  Function:   SchedGetDlgItemTextLength
//
//  Synopsis:   Implements a GetDlgItemTextLength function since Win32 lacks it
//
//  Arguments:
//
//  Returns:
//
//----------------------------------------------------------------------------
int
SchedGetDlgItemTextLength(
    HWND hwnd,
    int id)
{
    if ((hwnd = GetDlgItem(hwnd, id)) != NULL)
    {
        return GetWindowTextLength(hwnd);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\dlg.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       dlg.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/4/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\inc\dll.hxx"
#include "dlg.hxx"
#include "..\inc\misc.hxx"
#include "..\inc\sadat.hxx"
#include "..\folderui\dbg.h"
#include "..\folderui\util.hxx"

//
//  extern EXTERN_C
//

extern HINSTANCE g_hInstance;

CPropPage::CPropPage(
    LPCTSTR szTmplt,
    LPTSTR  ptszTaskPath):
        m_hPage(NULL),
        m_fTaskInTasksFolder(FALSE),
        m_fSupportsSystemRequired(FALSE),
        m_bPlatformId(0),
        m_fDirty(FALSE),
        m_fInInit(FALSE)
{
    Win4Assert(ptszTaskPath != NULL && *ptszTaskPath);

    lstrcpyn(m_ptszTaskPath, ptszTaskPath, ARRAY_LEN(m_ptszTaskPath));

    ZeroMemory(&m_psp, sizeof(m_psp));

    m_psp.dwSize        = sizeof(PROPSHEETPAGE);
    m_psp.dwFlags       = PSP_USECALLBACK;
    m_psp.hInstance     = g_hInstance;
    m_psp.pszTemplate   = szTmplt;
    m_psp.pfnDlgProc    = StaticDlgProc;
    m_psp.pfnCallback   = PageRelease;
    m_psp.pcRefParent   = NULL; // do not set PSP_USEREFPARENT
    m_psp.lParam        = (LPARAM) this;
}


CPropPage::~CPropPage()
{
}


INT_PTR CALLBACK
CPropPage::StaticDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    CPropPage *pThis = (CPropPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;

        pThis = (CPropPage *) ppsp->lParam;

        pThis->m_hPage = hDlg;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
    }

    if (pThis != NULL)
    {
        return pThis->DlgProc(uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hDlg, uMsg, wParam, lParam);
    }
}


LRESULT
CPropPage::DlgProc(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    LRESULT lr;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        m_fInInit = TRUE;
        _BaseInit();
        lr = _OnInitDialog(lParam);
        m_fInInit = FALSE;
        return lr;

    case PSM_QUERYSIBLINGS:
        return _OnPSMQuerySibling(wParam, lParam);

    case WM_NOTIFY:
        return _OnNotify(uMsg, (UINT)wParam, lParam);

    case WM_WININICHANGE:
        return _OnWinIniChange(wParam, lParam);

    case WM_SETFOCUS:
        return _OnSetFocus((HWND)wParam);

    case WM_TIMER:
        return _OnTimer((UINT)wParam);

    case WM_HELP:
        return _OnHelp(((LPHELPINFO) lParam)->hItemHandle,
                       HELP_WM_HELP);

    case WM_CONTEXTMENU:
        return _OnHelp((HANDLE) wParam, HELP_CONTEXTMENU);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(_OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                          GET_WM_COMMAND_HWND(wParam, lParam),
                          GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return _OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

LRESULT
CPropPage::_OnNotify(
    UINT    uMessage,
    UINT    uParam,
    LPARAM  lParam)
{
    switch (((LPNMHDR)lParam)->code)
    {
    case PSN_APPLY:
        return _OnApply();

    case PSN_RESET:
        _OnCancel();
        return FALSE; // allow the property sheet to be destroyed.

    case PSN_SETACTIVE:
        return _OnPSNSetActive(lParam);

    case PSN_KILLACTIVE:
        return _OnPSNKillActive(lParam);

    case DTN_DATETIMECHANGE:
        return _OnDateTimeChange(lParam);

    case UDN_DELTAPOS:
        return _OnSpinDeltaPos((NM_UPDOWN *)lParam);

    default:
        return _ProcessListViewNotifications(uMessage, uParam, lParam);
    }

    return TRUE;
}


LRESULT
CPropPage::_OnPSMQuerySibling(
    WPARAM  wParam,
    LPARAM  lParam)
{
    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, 0);
    return 0;
}


LRESULT
CPropPage::_OnSpinDeltaPos(
    NM_UPDOWN * pnmud)
{
    _EnableApplyButton();

    // Return FALSE to allow the change in the control's position.
    return FALSE;
}



LRESULT
CPropPage::_OnCommand(
    int id,
    HWND hwndCtl,
    UINT codeNotify)
{
    return FALSE;
}

LRESULT
CPropPage::_OnWinIniChange(
    WPARAM  wParam,
    LPARAM  lParam)
{
    return FALSE;
}

LRESULT
CPropPage::_OnApply(void)
{
    return FALSE;
}

LRESULT
CPropPage::_OnCancel(void)
{
    return FALSE;
}


LRESULT
CPropPage::_OnSetFocus(
    HWND hwndLoseFocus)
{
    // An application should return zero if it processes this message.
    return 1;
}


LRESULT
CPropPage::_OnPSNSetActive(
    LPARAM lParam)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}


LRESULT
CPropPage::_OnPSNKillActive(
    LPARAM lParam)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}


LRESULT
CPropPage::_OnDateTimeChange(
    LPARAM lParam)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}


LRESULT
CPropPage::_OnDestroy(void)
{
    // If an application processes this message, it should return zero.
    return 1;
}

LRESULT
CPropPage::_OnTimer(
    UINT idTimer)
{
    // If an application processes this message, it should return zero.
    return 1;
}

BOOL
CPropPage::_ProcessListViewNotifications(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return FALSE;
}


UINT CALLBACK
CPropPage::PageRelease(
    HWND            hwnd,
    UINT            uMsg,
    LPPROPSHEETPAGE ppsp)
{
    if (uMsg == PSPCB_RELEASE)
    {
        //
        // Determine instance that invoked this static function
        //

        CPropPage *pThis = (CPropPage *) ppsp->lParam;

        //
        // If page was created using an indirect dialog template, delete
        // that.
        //

        if (pThis->m_psp.dwFlags & PSP_DLGINDIRECT)
        {
            delete [] (BYTE *)pThis->m_psp.pResource;
        }

        delete pThis;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropPage::_BaseInit, private
//
//  Synopsis:   Initialize scheduling-agent specific private data members,
//              m_fTaskInTasksFolder & m_bPlatformId. Do so by reading SA.DAT
//              in the folder containing the task.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CPropPage::_BaseInit(void)
{
    TCHAR tszFolder[MAX_PATH + 1];

    ::GetParentDirectory(m_ptszTaskPath, tszFolder);

    //
    // If running on the local system, we can determine whether resume
    // timers are supported directly instead of by checking sa.dat, which
    // might be stale.
    //

    BOOL fLocal = IsLocalFilename(m_ptszTaskPath);

    if (fLocal)
    {
        CheckSaDat(tszFolder);
    }

    //
    // Read sa.dat on target machine
    //

    HRESULT hr;
    DWORD dwVersion;
    BYTE  bSvcFlags;

    hr = SADatGetData(tszFolder, &dwVersion, &m_bPlatformId, &bSvcFlags);

    if (SUCCEEDED(hr))
    {
        m_fTaskInTasksFolder = TRUE;

        if (fLocal)
        {
            m_fSupportsSystemRequired = ResumeTimersSupported();
        }
        else
        {
            m_fSupportsSystemRequired =
                bSvcFlags & SA_DAT_SVCFLAG_RESUME_TIMERS;
        }
    }
    else
    {
        //
        // Default on error (the file doesn't exist or the read failed).
        // Assume the task is external to the task folder and it exists
        // on a non-NT machine that doesn't support the system required
        // flag.
        //

        m_fTaskInTasksFolder        = FALSE;
        m_bPlatformId               = VER_PLATFORM_WIN32_WINDOWS;
        m_fSupportsSystemRequired   = FALSE;
    }
}




//____________________________________________________________________________
//____________________________________________________________________________
//________________                   _________________________________________
//________________  class CDlg       _________________________________________
//________________                   _________________________________________
//____________________________________________________________________________
//____________________________________________________________________________


INT_PTR
CDlg::RealDlgProc(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    return(FALSE);
}


INT_PTR CALLBACK CDlg::DlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    CDlg *pThis = (CDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pThis = (CDlg *)lParam;
        pThis->m_hDlg = hDlg;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    }

    if (pThis != NULL)
    {
        return pThis->RealDlgProc(uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hDlg, uMsg, wParam, lParam);
    }
}


INT_PTR
CDlg::DoModal(
    UINT idRes,
    HWND hParent)
{
    return(DialogBoxParam(g_hInstance, MAKEINTRESOURCE(idRes),
                                        hParent, DlgProc, (LPARAM)this));
}


HWND
CDlg::DoModeless(
    UINT idRes,
    HWND hParent)
{
    return(CreateDialogParam(g_hInstance, MAKEINTRESOURCE(idRes),
                                        hParent, DlgProc, (LPARAM)this));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\helpids.h ===
///////////////////////////////////////////////////////////////////////////
//
//  HELPIDS FOR THE TASK FOLDER DETAILS VIEW COLUMNS
//

#define Hids_name                        100
#define Hids_next_run_time               101
#define Hids_last_run_time               102
#define Hids_last_result                 103
#define Hids_schedule                    104
#define Hids_status                      105
#define Hids_creator                     106



///////////////////////////////////////////////////////////////////////////
//
//  HELPIDS FOR PROPERTY PAGES
//

//
// Helpids for control(s) common to all three pages
//

#define Hidc_icon                        140

//
// Helpids for General page controls
//

#define Hlbl_job_name                    150
#define Hlbl_comments                    151
#define Htxt_comments                    152
#define Hlbl_app_name                    153
#define Htxt_app_name                    154
#define Hbtn_browse                      155
#define Hlbl_workingdir                  156
#define Htxt_workingdir                  157
#define Hlbl_execute_as                  158
#define Htxt_execute_as                  159
#define Hlbl_passwd                      160
#define Htxt_passwd                      161
#define Hlbl_passwd2                     162
#define Htxt_passwd2                     163
#define Hchk_enable_job                  164
#define Hbtn_settings                    165
#define Hbtn_passwd                      166
// used by Hgrp_power_management         168

//
// Helpids for Settings page controls
//

#define Hchk_start_on_idle               171
#define Hchk_stop_if_not_idle            172
#define Hchk_dont_start_if_on_batteries  173
#define Hchk_kill_if_going_on_batteries  174
#define Hchk_delete_when_done            175
#define Hchk_show_multiple_scheds        176
#define Hchk_stop_after                  177
#define Htxt_stop_after_hr               178
#define Hspin_stop_after_hr              179
#define Htxt_stop_after_min              180
#define Hspin_stop_after_min             181
// #define Hchk_interactive              182 // DELETED
#define Htxt_idle_min                    183
#define Hspin_idle_min                   184
#define Hlbl_settings_hours              185
#define Hlbl_settings_min                186
#define Hgrp_idle_time                   187
#define Htxt_idle_minutes                188
#define Hgrp_task_completed              189
#define Hgrp_power_management            168
#define Hlbl_idle_deadline               300
#define Htxt_idle_deadline               301
#define Hspin_idle_deadline              302
#define Hchk_system_required             303
// 304, etc are used below - do not reuse here

//
// Helpids for Schedule page controls (common to all triggers)
//

#define Hcbx_trigger_type                190
#define Hdp_start_time                   191
#define Hcbx_triggers                    192
#define Htxt_trigger                     193
#define Hbtn_new                         194
#define Hbtn_delete                      195
#define Hbtn_advanced                    196
#define Hgrp_schedule                    197


//
// Helpids for Schedule page controls for DAILY trigger
//

#define Hgrp_daily                       201
#define Hdaily_lbl_every                 202
#define Hdaily_txt_every                 203
#define Hdaily_spin_every                204
#define Hdaily_lbl_days                  205

//
// Helpids for Schedule page controls for WEEKLY trigger
//

#define Hgrp_weekly                      211
#define Hweekly_lbl_every                212
#define Hweekly_txt_every                213
#define Hweekly_spin_every               214
#define Hweekly_lbl_weeks_on             215
#define Hchk_mon                         216
#define Hchk_tue                         217
#define Hchk_wed                         218
#define Hchk_thu                         219
#define Hchk_fri                         220
#define Hchk_sat                         221
#define Hchk_sun                         222

//
// Helpids for Schedule page controls for MONTHLY trigger
//

#define Hgrp_monthly                     231
#define Hmd_rb                           232
#define Hmd_txt                          233
#define Hmd_spin                         234
#define Hmd_lbl                          235
#define Hdow_rb                          236
#define Hdow_cbx_week                    237
#define Hdow_cbx_day                     238
#define Hdow_lbl                         239
#define Hbtn_sel_months                  240

//
// Helpids for Schedule page controls for ONCE only trigger
//

#define Hgrp_once                        261
#define Honce_lbl_run_on                 262
#define Honce_dp_date                    263

//
// Helpids for Schedule page controls for WhenIdle trigger.
//

#define Hsch_txt_idle_min                264
#define Hgrp_idle                        265
#define Hidle_lbl_when                   266
#define Hsch_spin_idle_min               267
#define Hidle_lbl_mins                   268

//
// Helpids for Advanced Dialog controls
//

#define Hdlg_advanced                    271
#define Hlbl_start_date                  272
#define Hdp_start_date                   273
#define Hchk_repeat_task                 274
#define Htxt_repeat_task                 275
#define Hspin_repeat_task                276
#define Hcbx_time_unit                   277
#define Hdp_end_date                     278
#define Hchk_terminate_at_end            279
#define Hrb_end_time                     280
#define Hrb_end_duration                 281
#define Hdp_end_time                     282
#define Htxt_end_duration_hr             283
#define Hspin_end_duration_hr            284
#define Htxt_end_duration_min            285
#define Hspin_end_duration_min           286
#define Hgrp_repeat_until                287
#define Hlbl_hours                       288
#define Hlbl_min                         289
#define Hchk_end_date                    290
#define Hlbl_every                       291
#define Hlbl_until                       292

// used by settings page controls        300
//                                       301
//                                       302
//                                       303

//
// Helpids for Set Password dialog
//

#define Hset_passwd_dlg                  304
#define Hlbl_sp_passwd                   305
#define Hedt_sp_passwd                   306
#define Hlbl_sp_cfrmpasswd               307
#define Hedt_sp_cfrmpasswd               308

//
// Helpids for Select Months dialog
//

#define Hselect_month_dlg                309
#define Hchk_jan                         310
#define Hchk_feb                         311
#define Hchk_mar                         312
#define Hchk_apr                         313
#define Hchk_may                         314
#define Hchk_jun                         315
#define Hchk_jul                         316
#define Hchk_aug                         317
#define Hchk_sep                         318
#define Hchk_oct                         319
#define Hchk_nov                         320
#define Hchk_dec                         321
#define Hlbl_sel_months                  322
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\rc.h ===
//
// Dialogs
//

#define set_passwd_dlg                  102
#define set_account_info_dlg            103
#define IDD_AT_ACCOUNT_DLG              104
#define select_month_dlg                105

//
// Pages
//

#define general_page                     401
#define schedule_page                    402
#define settings_page                    403

#define idc_icon                         500

//
// General page controls
//

#define btn_passwd                      1000
#define lbl_job_name                    1650
#define lbl_comments                    1651
#define txt_comments                    1652
#define lbl_app_name                    1653
#define txt_app_name                    1654
#define btn_browse                      1655
#define lbl_run_as                      1658
#define txt_run_as                      1659
#define lbl_passwd                      1660
#define txt_passwd                      1661
#define lbl_passwd2                     1662
#define txt_passwd2                     1663
#define chk_enable_job                  1664
#define btn_settings                    1665
#define lbl_workingdir                  1666
#define txt_workingdir                  1667

//
// Set password dialog controls
//

#define edt_sp_cfrmpasswd               1001
#define edt_sp_passwd                   1002
#define lbl_sp_passwd                   1003
#define lbl_sp_cfrmpasswd               1004
#define btn_sp_ok                       1005
#define btn_sp_cancel                   1006

//
// Set account information dialog controls
//

#define lbl_sa_run_as                   1007
#define txt_sa_run_as                   1008
#define lbl_sa_passwd                   1009
#define lbl_sa_cfrmpasswd               1010
#define edt_sa_passwd                   1011
#define edt_sa_cfrmpasswd               1012

//
// Set AT account information controls
//

#define IDD_AT_USE_SYSTEM               100
#define IDD_AT_USE_CUSTOM               101
#define IDD_AT_CUSTOM_ACCT_NAME         102
#define IDD_AT_PWD_TXT                  103
#define IDD_AT_PASSWORD                 104
#define IDD_AT_CONFIRM_TXT              105
#define IDD_AT_CONFIRM_PASSWORD         106

//
// Settings page controls
//

#define chk_start_on_idle               1671
#define chk_stop_if_not_idle            1672
#define chk_dont_start_if_on_batteries  1673
#define chk_kill_if_going_on_batteries  1674
#define chk_delete_when_done            1675
#define chk_show_multiple_scheds        1676 // now on schedule page
#define chk_stop_after                  1677
#define txt_stop_after_hr               1678
#define spin_stop_after_hr              1679
#define txt_stop_after_min              1680
#define spin_stop_after_min             1681
#define lbl_idle_deadline1              1682
#define txt_idle_min                    1683
#define spin_idle_min                   1684
#define grp_idle_time                   1685
#define txt_idle_minutes                1686
#define grp_task_completed              1687
#define grp_power_management            1688
#define txt_idle_deadline               1689
#define spin_idle_deadline              1698
#define lbl_idle_deadline2              1699
#define chk_system_required             1700

//
// Schedule page controls (common to all triggers)
//

#define cbx_trigger_type                1690
#define dp_start_time                   1691

#define cbx_triggers                    1692
#define txt_trigger                     1693

#define btn_new                         1694
#define btn_delete                      1695
#define btn_advanced                    1696

#define grp_schedule                    1697
// used by spin_idle_deadline           1698

//  EDITTEXT
// Schedule page controls for DAILY trigger
//

#define grp_daily                       1701
#define daily_lbl_every                 1702
#define daily_txt_every                 1703
#define daily_spin_every                1704
#define daily_lbl_days                  1705

//
// Schedule page controls for WEEKLY trigger
//

#define grp_weekly                      1711
#define weekly_lbl_every                1712
#define weekly_txt_every                1713
#define weekly_spin_every               1714
#define weekly_lbl_weeks_on             1715
#define chk_mon                         1716
#define chk_tue                         1717
#define chk_wed                         1718
#define chk_thu                         1719
#define chk_fri                         1720
#define chk_sat                         1721
#define chk_sun                         1722

//
// Schedule page controls for MONTHLY trigger
//

#define grp_monthly                     1731
#define md_rb                           1732
#define md_txt                          1733
#define md_spin                         1734
#define md_lbl                          1735
#define dow_rb                          1736
#define dow_cbx_week                    1737
#define dow_cbx_day                     1738
#define dow_lbl                         1739
#define btn_sel_months                  1740
#define lbl_sel_months                  1741

//
// Select month dialog controls (invoked from MONTHLY trigger control
// btn_sel_months on schedule page).
//

#define chk_jan                         1742
#define chk_feb                         1743
#define chk_mar                         1744
#define chk_apr                         1745
#define chk_may                         1746
#define chk_jun                         1747
#define chk_jul                         1748
#define chk_aug                         1749
#define chk_sep                         1750
#define chk_oct                         1751
#define chk_nov                         1752
#define chk_dec                         1753

//
// Schedule page controls for ONCE only trigger
//

#define grp_once                        1761
#define once_lbl_run_on                 1762
#define once_dp_date                    1763

//
// Schedule page controls for WhenIdle trigger
//

#define grp_idle                        1764
#define idle_lbl_when                   1765
#define sch_txt_idle_min                1766
#define sch_spin_idle_min               1767
#define idle_lbl_mins                   1768

//
// Advanced page controls
//

#define dlg_advanced                    1771
#define lbl_start_date                  1772
#define dp_start_date                   1773
#define chk_repeat_task                 1774
#define txt_repeat_task                 1775
#define spin_repeat_task                1776
#define cbx_time_unit                   1777
#define dp_end_date                     1778
#define chk_terminate_at_end            1779
#define rb_end_time                     1780
#define rb_end_duration                 1781
#define dp_end_time                     1782
#define txt_end_duration_hr             1783
#define spin_end_duration_hr            1784
#define txt_end_duration_min            1785
#define spin_end_duration_min           1786
#define grp_repeat_until                1787
#define lbl_hours                       1788
#define lbl_min                         1789
#define chk_end_date                    1790
#define lbl_every                       1791
#define lbl_until                       1792


//
// String table
//

#define IDS_ONCE                        4101

#define IDS_SUNDAY                      4103
#define IDS_MONDAY                      4104
#define IDS_TUESDAY                     4105
#define IDS_WEDNESDAY                   4106
#define IDS_THURSDAY                    4107
#define IDS_FRIDAY                      4108
#define IDS_SATURDAY                    4109

#define IDS_EXE                         4110
#define IDS_PROGRAMSFILTER              4111
#define IDS_BROWSE                      4112
#define IDS_AT_STARTUP                  4113
#define IDS_AT_LOGON                    4114
#define IDS_NO_TRIGGERS                 4115
#define IDS_MSG_CAPTION                 4116

#define IERR_ENDDATE_LT_STARTDATE       4131
#define IERR_DURATION_LT_INTERVAL       4132
#define IERR_INTERNAL_ERROR             4133
#define IERR_PASSWORD                   4134
#define IERR_OUT_OF_MEMORY              4135
#define IERR_GENERAL_PAGE_INIT          4136
#define IERR_SCHEDULE_PAGE_INIT         4137
#define IERR_SETTINGS_PAGE_INIT         4138
#define IERR_INVALID_DAYILY_EVERY       4139
#define IERR_INVALID_WEEKLY_EVERY       4140
#define IERR_MONTHLY_DATE_LT0           4141
#define IERR_MONTHLY_DATE_GT31          4142
#define IERR_INVALID_WEEKLY_TASK        4143
#define IERR_INVALID_MONTHLY_TASK       4144
#define IERR_FILE_NOT_FOUND             4145
#define IERR_ACCESS_DENIED              4146
#define IERR_MAXRUNTIME                 4147
#define IERR_SECURITY_READ_ERROR        4148
#define IERR_ACCOUNTNAME                4149
#define IERR_APP_NOT_FOUND              4151
#define IERR_MONTHLY_DATE_INVALID       4152
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\sageset.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sageset.cxx
//
//  Contents:   Support for Sage Settings
//
//  History:    18-Jul-96 EricB created
//              3-06-1997   DavidMun   added code to create sagerun argument
//              4-16-1997   DavidMun   made it use strings from UI instead of
//                                      from job object.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <mstask.h>
#include <job_cls.hxx>
#include <debug.hxx>
#include <sage.hxx>
#include "sageset.hxx"
#include "..\inc\misc.hxx"
#include "..\folderui\macros.h" // get ARRAYLEN macro

const CHAR SAGE_KEY[] = "SOFTWARE\\Microsoft\\Plus!\\System Agent\\SAGE";
const CHAR PROGRAM_VALUE[] ="Program";
const CHAR SETTINGS_VALUE[] = "Settings";
const CHAR SAGESET_PARAM[] = " /SAGESET:";

BOOL GetAppNameFromPath(CHAR * pszFullPathName, CHAR * pszAppName);
BOOL AppNamesMatch(CHAR * pszCommand1, CHAR * pszCommand2);
BOOL fAppCantSupportMultipleInstances(CHAR * pszCmd);
BOOL AnsiToIntA(LPCSTR pszString, int * piRet);
HRESULT GetNextSageRunParam(HKEY hkSageApp, PINT pnSetNum);


//+----------------------------------------------------------------------------
//
//  Function:   DoSageSettings
//
//  Synopsis:   Invoke the Sage-aware app to alter its schedule settings.
//
//  Arguments:  [szCommand] - app name portion of command line
//              [szSageRun] - "" or contains /SAGERUN switch on input.
//                              contains /SAGERUN switch on output if app is
//                              sage-aware.
//
//  Modifies:   *[szSageRun]
//
//  Returns:    S_OK    - application launched
//              S_FALSE - application doesn't support sage settings
//              E_*
//
//  History:    3-06-1997   DavidMun   Added [szNewArg] & [cchNewArg].
//              4-16-1997   DavidMun   Take strings from UI instead of job
//                                       object.
//
//-----------------------------------------------------------------------------

HRESULT
DoSageSettings(
    LPSTR szCommand,
    LPSTR szSageRun)
{          
    int  nSetNum = 0;
                                                                                 
    if (!IsSageAware(szCommand, szSageRun, &nSetNum))
    {
        return S_FALSE;
    }

    //
    // We are here because the user hit the "Settings..." button, so if the
    // arguments don't include a sageset parameter, we need to add it.
    //

    if (!*szSageRun)
    {
        //
        // IsSageAware set nSetNum to the next valid number to use.
        //

        wsprintf(szSageRun, "%s%u", SAGERUN_PARAM, nSetNum);
    }

    //
    // Create a command line to invoke the sage-aware app with the sageset
    // parameter.
    //

    CHAR szSetCommand[MAX_PATH];
    CHAR szSetParams[MAX_PATH];

    lstrcpyn(szSetCommand, szCommand, MAX_PATH);
    lstrcpy(szSetParams, SAGESET_PARAM);

    wsprintf(&szSetParams[lstrlen(szSetParams)], "%u", nSetNum);
                           
    if (!GetAppNameFromPath(szSetCommand, NULL)) //got a path?
    {
        //
        // GetAppNameFromPath returns FALSE if szSetCommand is not a full 
        // path.  So, see if the app has registered a path. If it has, 
        // GetAppPath places the full path name in szFullyQualified.
        //
        CHAR szFullyQualified[MAX_PATH];

        GetAppPathInfo(szSetCommand,
                       szFullyQualified,
                       MAX_PATH,
                       NULL,
                       0);

        if (*szFullyQualified)
        {
            lstrcpy(szSetCommand, szFullyQualified);
        }
    }

    //
    // Prefix the system path with the directories listed by the application
    // in the app paths key.
    //

    BOOL  fChangedPath;
    LPSTR pszSavedPath;

    fChangedPath = SetAppPath(szSetCommand, &pszSavedPath);

    //
    // Put the SageSet param onto the command line.
    //
    if (szSetParams[0] != ' ')
    {
        lstrcat(szSetCommand, " ");
    }
    lstrcat(szSetCommand, szSetParams);

    DWORD dwErr = ERROR_SUCCESS;
    STARTUPINFO sui;
    PROCESS_INFORMATION pi;
    ZeroMemory(&sui, sizeof(sui));
    sui.cb = sizeof (STARTUPINFO);
                  
    if (CreateProcess(NULL,
                      szSetCommand,
                      NULL,
                      NULL,
                      FALSE,
                      CREATE_NEW_CONSOLE |
                      CREATE_NEW_PROCESS_GROUP,
                      NULL,
                      NULL,
                      &sui,
                      &pi))
    {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }
    else 
    {
        dwErr = GetLastError();
        ERR_OUT("DoSageSettings: CreateProcess", dwErr);
    }

    if (fChangedPath)
    {
        SetEnvironmentVariable(TEXT("PATH"), pszSavedPath);
        delete [] pszSavedPath;
    }

    return (dwErr == ERROR_SUCCESS) ? S_OK : HRESULT_FROM_WIN32(dwErr);
}

//+--------------------------------------------------------------------------
//
//  Function:   IsSageAwareW
//
//  Synopsis:   Unicode wrapper for IsSageAware
//
//  History:    10-27-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsSageAwareW(WCHAR *pwzCmd, WCHAR *pwzParams, int *pnSetNum)
{
    HRESULT hr;
    CHAR    szCmd[MAX_PATH+1];
    CHAR    szParam[MAX_PATH+1];
    BOOL    fResult = FALSE;

    do
    {
        hr = UnicodeToAnsi(szCmd, pwzCmd, ARRAYLEN(szCmd));
        BREAK_ON_FAIL(hr);

        hr = UnicodeToAnsi(szParam, pwzParams, ARRAYLEN(szParam));
        BREAK_ON_FAIL(hr);

        fResult = IsSageAware(szCmd, szParam, pnSetNum);
    } while (0);

    return fResult;
}


//+----------------------------------------------------------------------------
//
//  Function:   IsSageAware
//
//  Synopsis:   Does this app use Sage settings?
//
//  Arguments:  [pszCmd] - The task application name property.
//              [pszParams] - The task parameters, can be NULL if pnSetNum is
//                            NULL.
//              [pnSetNum] - the registry setting set number to return, can
//                           be NULL if not needed.
//
//  Returns:    TRUE if it does, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL
IsSageAware(CHAR * pszCmd, const CHAR * pszParams, int * pnSetNum)
{
    int index;
    HKEY hSageKey;
    HKEY hSageSubKey;
    CHAR szSubKey[MAXPATH];
    CHAR szSubKeyPath[MAXPATH];
    CHAR szRegValue[MAXCOMMANDLINE];
    long lRet;
    CHAR *p;
    BOOL fResult = FALSE;
    DWORD cb;

    if (pnSetNum != NULL)
    {
        *pnSetNum = 0;
    }

    if (RegOpenKey(HKEY_LOCAL_MACHINE, SAGE_KEY, &hSageKey))
    {
        return FALSE;
    }

#define MAXSAGEPROGS 0xffffff

    for (index = 0; index < MAXSAGEPROGS; index++)
    {
        //
        // Examine each subkey of the Sage key.
        //
        lRet = RegEnumKey(hSageKey, index, szSubKey, MAXPATH);

        if (lRet != ERROR_SUCCESS)
        {
            break;
        }

        lstrcpy(szSubKeyPath, SAGE_KEY);
        lstrcat(szSubKeyPath, "\\");
        lstrcat(szSubKeyPath, szSubKey);

        if (RegOpenKey(HKEY_LOCAL_MACHINE,
                       szSubKeyPath,
                       &hSageSubKey) != ERROR_SUCCESS)
        {
            continue; //no path
        }

        //
        // Look for a match on the application name.
        //
        cb = MAXPATH;
        if (RegQueryValueEx(hSageSubKey,
                            PROGRAM_VALUE,
                            NULL,
                            NULL,
                            (LPBYTE)szRegValue,
                            &cb) != ERROR_SUCCESS)
        {
            RegCloseKey(hSageSubKey);
            continue; //no path
        }

        schDebugOut((DEB_ITRACE,
                     "IsSageAware enum: pszCmd = %s, szRegValue = %s\n",
                     pszCmd, szRegValue));

        RegCloseKey(hSageSubKey);

        if (AppNamesMatch(pszCmd, szRegValue))
        {
            if (RegOpenKey(HKEY_LOCAL_MACHINE,
                           szSubKeyPath,
                           &hSageSubKey) != ERROR_SUCCESS)
            {
                continue; //no settings dialog
            }

            fResult = FALSE;

            if (RegQueryValueEx(hSageSubKey,
                                SETTINGS_VALUE,
                                NULL,
                                NULL,
                                (LPBYTE)szRegValue,
                                &cb) == ERROR_SUCCESS)
            {
                if (szRegValue[0] == 0)
                {
                    RegCloseKey(hSageSubKey);
                    break; // this means don't allow sage settings
                }
            }
            else
            {
                RegCloseKey(hSageSubKey);
                continue; //no settings registry key
            }

            // test for app that can't handle multiple instances
            //
            if (!fAppCantSupportMultipleInstances(pszCmd))
            {
                fResult = TRUE;
            }

            if (fResult && pnSetNum != NULL)
            {
                //
                // Extract the set number from the parameters, if requested.
                //
                p = _tcsstr(pszParams, SAGERUN_PARAM);

                if (p != NULL)
                {
                    AnsiToIntA(p + lstrlen(SAGERUN_PARAM), pnSetNum);
                }
                else 
                {
                    // 
                    // This job is for a sage-aware app which supports the 
                    // SAGERUN switch, but it lacks that switch in its 
                    // parameter property.  Since the caller wants to know
                    // what value to use, generate one.
                    //

                    HRESULT hr = GetNextSageRunParam(hSageSubKey, pnSetNum);

                    if (FAILED(hr))
                    {
                        fResult = FALSE;
                    }
                }
            }

            RegCloseKey(hSageSubKey);
            break;
        }
    }

    RegCloseKey(hSageKey);

    return fResult;
}



const CHAR SET_PREFIX[] = "Set";

//+--------------------------------------------------------------------------
//
//  Function:   CreateSageRunKey
//
//  Synopsis:   Create a registry key with string representation of 
//              value [uiKey] for app [szSageAwareExe].
//
//  Arguments:  [szSageAwareExe] - app for which to create key
//              [uiKey]          - numeric representation of key name
//
//  Returns:    S_OK or E_FAIL
//
//  History:    10-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CreateSageRunKey(
    LPCSTR szSageAwareExe,
    UINT uiKey)
{
    HRESULT hr = E_FAIL;  // init for failure
    int index;
    HKEY hSageKey;
    HKEY hSageSubKey;
    CHAR szSubKey[MAXPATH];
    CHAR szSubKeyPath[MAXPATH];
    CHAR szRegValue[MAXCOMMANDLINE];
    long lRet;
    DWORD cb;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, SAGE_KEY, &hSageKey))
    {
        return hr;
    }

    for (index = 0; index < MAXSAGEPROGS; index++)
    {
        //
        // Examine each subkey of the Sage key.
        //
        lRet = RegEnumKey(hSageKey, index, szSubKey, MAXPATH);

        if (lRet != ERROR_SUCCESS)
        {
            break;
        }

        lstrcpy(szSubKeyPath, SAGE_KEY);
        lstrcat(szSubKeyPath, "\\");
        lstrcat(szSubKeyPath, szSubKey);

        if (RegOpenKey(HKEY_LOCAL_MACHINE,
                       szSubKeyPath,
                       &hSageSubKey) != ERROR_SUCCESS)
        {
            continue; //no path
        }

        //
        // Look for a match on the application name.
        //
        cb = MAXPATH;
        if (RegQueryValueEx(hSageSubKey,
                            PROGRAM_VALUE,
                            NULL,
                            NULL,
                            (LPBYTE)szRegValue,
                            &cb) != ERROR_SUCCESS)
        {
            RegCloseKey(hSageSubKey);
            continue; //no path
        }

        RegCloseKey(hSageSubKey);

        if (AppNamesMatch((LPSTR)szSageAwareExe, szRegValue))
        {
            if (RegOpenKey(HKEY_LOCAL_MACHINE,
                           szSubKeyPath,
                           &hSageSubKey) != ERROR_SUCCESS)
            {
                continue; //no settings dialog
            }

            CHAR szKeyName[MAX_PATH];
            HKEY hkNewKey = NULL;

            wsprintf(szKeyName, "%s%u", SET_PREFIX, uiKey);
            lRet = RegCreateKey(hSageSubKey, szKeyName, &hkNewKey);

            if (hkNewKey)
            {
                RegCloseKey(hkNewKey);
            }
            RegCloseKey(hSageSubKey);

            if (lRet == ERROR_SUCCESS)
            {
                hr = S_OK;
            }
            else 
            {
                schDebugOut((DEB_ERROR,
                             "CreateSageRunKey: RegCreateKey %uL",
                             lRet));
            }
            break;
        }
    }

    RegCloseKey(hSageKey);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetNextSageRunParam
//
//  Synopsis:   Fill *[pnSetNum] with the next <n> value to use for a new
//              Set<n> subkey under [hSageAppSubKey].
//
//  Arguments:  [hSageAppSubKey] - handle to app's key under SAGE key
//              [pnSetNum]       - filled with next number to use
//
//  Returns:    HRESULT
//
//  Modifies:   *[pnSetNum]
//
//  History:    3-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT 
GetNextSageRunParam(
    HKEY hSageAppSubKey,
    PINT pnSetNum)
{
    HRESULT hr = S_OK;
    ULONG   idxKey;

    *pnSetNum = 0;

    for (idxKey = 0; TRUE; idxKey++)
    {
        LONG lr;
        CHAR szSubKey[MAX_PATH + 1];

        lr = RegEnumKey(hSageAppSubKey, idxKey, szSubKey, ARRAYLEN(szSubKey));

        //
        // Quit on error, including end of subkeys
        //

        if (lr != ERROR_SUCCESS)
        {
            if (lr != ERROR_NO_MORE_ITEMS)
            {
                hr = E_FAIL;
                schDebugOut((DEB_ERROR,
                             "GetNextSageRunParam: RegEnumKey %uL",
                             lr));
            }
            break;
        }

        //
        // Ignore this key if it doesn't start with "Set"
        //

        CHAR szSet[ARRAYLEN(SET_PREFIX)];
        lstrcpyn(szSet, szSubKey, ARRAYLEN(SET_PREFIX));

        if (lstrcmpi(szSet, SET_PREFIX))
        {
            continue;
        }

        //
        // Get the numeric value after the prefix.  If there's no valid
        // number, ignore this key.
        //

        BOOL fNumber;
        INT  iSetN;

        fNumber = AnsiToIntA(szSubKey + ARRAYLEN(SET_PREFIX) - 1, &iSetN);

        if (!fNumber)
        {
            continue;
        }

        //
        // If the number matches or exceeds the one we plan to use, make ours 
        // larger.
        //

        if (iSetN >= *pnSetNum)
        {
            *pnSetNum = iSetN + 1;
        }
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   GetAppNameFromPath
//
//  Synopsis:   
//
//  Arguments:  [pszFullPathName] - full or partial path
//              [pszAppName]      - buffer for app name, may be NULL
//
//  Returns:    TRUE  - [pszFullPathName] contained slashes
//              FALSE -  [pszFullPathName] didn't contain slashes
//
//  Modifies:   *[pszAppName]
//
//  History:    10-25-96   DavidMun   Made DBCS safe
//
//----------------------------------------------------------------------------

BOOL GetAppNameFromPath(CHAR * pszFullPathName, CHAR * pszAppName)
{
    LPSTR pszLastSlash;

    pszLastSlash = _tcsrchr(pszFullPathName, '\\');

    if (!pszAppName)
    {
        return pszLastSlash != NULL;
    }

    if (pszLastSlash)
    {
        lstrcpy(pszAppName, pszLastSlash + 1);
    }
    else
    {
        lstrcpy(pszAppName, pszFullPathName);
    }

    schDebugOut((DEB_ITRACE, "GetAppNameFromPath app name: %s\n", pszAppName));

    if (pszAppName[0] != '"')
    {
        LPSTR pszQuote = _tcschr(pszAppName, '"');

        if (pszQuote)
        {
            *pszQuote = '\0';
        }
    }
    return pszLastSlash != NULL;
}

BOOL AppNamesMatch(CHAR *pszCommand1, CHAR *pszCommand2)
{
    CHAR short1[MAXPATH];
    CHAR short2[MAXPATH];

    GetAppNameFromPath(pszCommand1, short1);
    GetAppNameFromPath(pszCommand2, short2);

    if (lstrcmpi(short1, short2) == 0)
    {
        return(TRUE);
    }
    return(FALSE);
}

BOOL fAppCantSupportMultipleInstances(CHAR * pszCmd)
{
    if (AppNamesMatch(pszCmd, "SCANDSKW.EXE") ||
        AppNamesMatch(pszCmd, "DEFRAG.EXE")   ||
        AppNamesMatch(pszCmd, "CMPAGENT.EXE"))
    {
        if (FindWindow("ScanDskWDlgClass", NULL))
            return TRUE;
        if (FindWindow("MSDefragWClass1", NULL))
            return TRUE;
        if (FindWindow("MSExtraPakWClass1", NULL))
            return TRUE;
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: ScottH's version of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number
*/
BOOL AnsiToIntA(LPCSTR pszString, int * piRet)
{
    #define InRange(id, idFirst, idLast) \
            ((UINT)(id-idFirst) <= (UINT)(idLast-idFirst))
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    BOOL bRet;
    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString;
         *psz == ' ' || *psz == '\n' || *psz == '\t';
         psz = NextChar(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
        }

    // Or is this hexadecimal?
    //
    pszAdj = NextChar(psz);
    if (*psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;
        psz = NextChar(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = NextChar(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }
    else
        {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGIT(*psz); psz = NextChar(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }

    *piRet = bNeg ? -n : n;

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\schedule.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       schedule.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Notes:      For the first release of the scheduling agent, all security
//              operations are disabled under Win95, even Win95 to NT.
//
//  History:    3/4/1996   RaviR   Created
//				11/16/00   DGrube	removed Win4Assert(m_indexCbxTriggers >= 0);
//						   since m_indexCbxTriggers is a DWORD (unsigned) causing
//							compiler errors.
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include <winuserp.h>
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"
#include "..\folderui\jobicons.hxx"
#include "..\folderui\util.hxx"
#include "..\inc\resource.h"
#if !defined(_CHICAGO_)
#include "..\inc\network.hxx"
#endif // !defined(_CHICAGO_)
#include "..\inc\dll.hxx"

#include "dlg.hxx"
#include "rc.h"
#include "defines.h"
#include <mstask.h>
#include "misc.hxx"
#include "uiutil.hxx"
#include "strings.hxx"
#include "cdlist.hxx"
#include "helpids.h"
#include "iconhlpr.hxx"
#include "schedui.hxx"
#include "selmonth.hxx"
#include "defines.hxx"

BOOL
IsValidMonthlyDateTrigger(
    PTASK_TRIGGER pTrigger);


typedef const unsigned char *LPCBYTE;

//#undef DEB_TRACE
//#define DEB_TRACE DEB_USER1


//
//  (Control id, help id) list for context sensitivity help.
//

ULONG s_aSchedulePageHelpIds[] =
{
// Helpids for Schedule page controls (common to all triggers)
    idc_icon,                   Hidc_icon,
    cbx_trigger_type,           Hcbx_trigger_type,
    dp_start_time,              Hdp_start_time,
    cbx_triggers,               Hcbx_triggers,
    txt_trigger,                Htxt_trigger,
    btn_new,                    Hbtn_new,
    btn_delete,                 Hbtn_delete,
    btn_advanced,               Hbtn_advanced,
    grp_schedule,               Hgrp_schedule,
    chk_show_multiple_scheds,   Hchk_show_multiple_scheds,

// Helpids for Schedule page controls for DAILY trigger
    grp_daily,                  Hgrp_daily,
    daily_lbl_every,            Hdaily_lbl_every,
    daily_txt_every,            Hdaily_txt_every,
    daily_spin_every,           Hdaily_spin_every,
    daily_lbl_days,             Hdaily_lbl_days,

// Helpids for Schedule page controls for WEEKLY trigger
    grp_weekly,                 Hgrp_weekly,
    weekly_lbl_every,           Hweekly_lbl_every,
    weekly_txt_every,           Hweekly_txt_every,
    weekly_spin_every,          Hweekly_spin_every,
    weekly_lbl_weeks_on,        Hweekly_lbl_weeks_on,
    chk_mon,                    Hchk_mon,
    chk_tue,                    Hchk_tue,
    chk_wed,                    Hchk_wed,
    chk_thu,                    Hchk_thu,
    chk_fri,                    Hchk_fri,
    chk_sat,                    Hchk_sat,
    chk_sun,                    Hchk_sun,

// Helpids for Schedule page controls for MONTHLY trigger
    grp_monthly,                Hgrp_monthly,
    md_rb,                      Hmd_rb,
    md_txt,                     Hmd_txt,
    md_spin,                    Hmd_spin,
    md_lbl,                     Hmd_lbl,
    dow_rb,                     Hdow_rb,
    dow_cbx_week,               Hdow_cbx_week,
    dow_cbx_day,                Hdow_cbx_day,
    dow_lbl,                    Hdow_lbl,
    btn_sel_months,             Hbtn_sel_months,

// Helpids for Schedule page controls for ONCE only trigger
    grp_once,                   Hgrp_once,
    once_lbl_run_on,            Honce_lbl_run_on,
    once_dp_date,               Honce_dp_date,

// Helpids for Schedule page controls for WhenIdle trigger
    grp_idle,                   Hgrp_idle,
    sch_txt_idle_min,           Hsch_txt_idle_min,
    idle_lbl_when,              Hidle_lbl_when,
    sch_spin_idle_min,          Hsch_spin_idle_min,
    idle_lbl_mins,              Hidle_lbl_mins,

    0,0
};

//
// Local constants
//
// DEFAULT_TIME_FORMAT - what to use if there's a problem getting format
//                       from system.
//

#define DEFAULT_TIME_FORMAT         TEXT("hh:mm tt")

//
//  extern
//

extern "C" TCHAR szMstaskHelp[];
extern HINSTANCE g_hInstance;


//+----------------------------------------------------------------------
//
// Class:   CJobTrigger
//
// Purpose: TASK_TRIGGER structure encapsulated with double link node.
//
//----------------------------------------------------------------------

class CJobTrigger : public CDLink
{
public:
    CJobTrigger(TASK_TRIGGER &jt) : m_jt(jt) {}
    virtual ~CJobTrigger() {}

    LPTSTR TriggerString(BOOL fPrependID, TCHAR tcBuff[]);

    WORD GetTriggerID(void) { return (m_jt.Reserved1 & 0x7fff); }
    void SetTriggerID(WORD wID)
            { m_jt.Reserved1 = (m_jt.Reserved1 & 0x8000) | wID; }

    void DirtyTrigger() { m_jt.Reserved1 |= 0x8000; }
    BOOL IsTriggerDirty() { return (m_jt.Reserved1 & 0x8000) ? TRUE : FALSE; }

    CJobTrigger *Prev() { return (CJobTrigger*) CDLink::Prev(); }
    CJobTrigger *Next() { return (CJobTrigger*) CDLink::Next(); }

    TASK_TRIGGER m_jt;
};



//+----------------------------------------------------------------------
//
// Class:   CJobTriggerList
//
// Purpose: A double linked list of CJobTriggers
//
//----------------------------------------------------------------------

DECLARE_DOUBLE_LINK_LIST_CLASS(CJobTrigger)



LPTSTR
CJobTrigger::TriggerString(
    BOOL  fPrependID,
    TCHAR tcBuff[])
{
    LPWSTR  pwsz = NULL;
    HRESULT hr = StringFromTrigger((const PTASK_TRIGGER)&m_jt, &pwsz, NULL);

    CHECK_HRESULT(hr);

    tcBuff[0] = TEXT('\0');

    if (SUCCEEDED(hr))
    {
        if (fPrependID == TRUE)
        {
            wsprintf(tcBuff, TEXT("%d. "), (this->GetTriggerID() + 1));
        }

#ifdef UNICODE
        lstrcat(tcBuff, pwsz);
#else
        // accept the best attempt from conversion
        ULONG cchOffset = lstrlen(tcBuff);
        ZeroMemory(&tcBuff[cchOffset], SCH_XBIGBUF_LEN - cchOffset);
        (void) UnicodeToAnsi(&tcBuff[cchOffset],
                             pwsz,
                             SCH_XBIGBUF_LEN - cchOffset);
#endif

        CoTaskMemFree(pwsz);
    }

    return tcBuff;
}

//____________________________________________________________________________
//____________________________________________________________________________
//________________                      ______________________________________
//________________  class CSchedulePage ______________________________________
//________________                      ______________________________________
//____________________________________________________________________________
//____________________________________________________________________________


class CSchedulePage : public CPropPage
{
public:

    CSchedulePage(ITask * pIJob,
                  LPTSTR  ptszTaskPath,
                  BOOL    fMultipleTriggers,
                  BOOL    fPersistChanges);

    ~CSchedulePage();

private:

    enum
    {
        IDT_UPDATE_TRIGGER_STRING = 1
    };

    virtual LRESULT _OnInitDialog(LPARAM lParam);
    virtual LRESULT _OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    virtual LRESULT _OnApply(void);
    virtual LRESULT _OnPSMQuerySibling(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnDestroy(void);
    virtual LRESULT _OnTimer(UINT idTimer);
    virtual LRESULT _OnSpinDeltaPos(NM_UPDOWN * pnmud);
    virtual LRESULT _OnWinIniChange(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnPSNSetActive(LPARAM lParam);
    virtual LRESULT _OnPSNKillActive(LPARAM lParam);
    virtual LRESULT _OnDateTimeChange(LPARAM lParam);
    virtual LRESULT _OnHelp(HANDLE hRequesting, UINT uiHelpCommand);

    void    _ShowControls(int index, int nCmdShow);
    void    _UpdateTriggerString(void);
    HRESULT _LoadTriggers(void);
    BOOL    _LoadTriggerStrings(void);
    BOOL    _InitPage(void);
    BOOL    _RefreshPage(void);
    void    _UpdateDailyControls(void);
    void    _UpdateWeeklyControls(void);
    void    _UpdateMonthlyControls(void);
    void    _CheckMonthlyRadio(TASK_TRIGGER_TYPE TriggerType);
    void    _UpdateOnceOnlyControls(void);
    void    _UpdateIdleControls(void);
    WORD    _GetDayFromRgfDays(DWORD rgfDays);
    int     _GetTriggerTypeIndex(void);
    void    _DisplayControls(int indexTrigger);
    void    _EnableTimeTriggerSpecificCtrls(BOOL fEnable);
    void    _SaveTriggerSettings(void);
    void    _ShowTriggerStringDispCtrls(void);
    void    _CreateTimerToUpdateTriggerStr(void);
    void    _DeleteTimerToUpdateTriggerStr(void);

    void    _ErrorDialog(int idsErr, LONG error = 0, UINT idsHelpHint = 0)
                { SchedUIErrorDialog(Hwnd(), idsErr, error, idsHelpHint); }

    BOOL    _PerformSanityChkOnCurrTrigger(void);

    void _EnableApplyButton(void);

    ITask         * m_pIJob;

    //
    //  icon helper
    //

    CIconHelper   * m_pIconHelper;

    //
    //  The list of triggers
    //

    CJobTriggerList m_cjtList;

    //
    //  The list of triggers deleted
    //

    CJobTriggerList m_cjtDeletedList;

    //
    //  The trigger for which the schedule is being displayed currently
    //

    CJobTrigger   * m_pcjtCurr;

    //
    //  The count of triggers at load time
    //

    WORD            m_cTriggersPrev;

    //
    //  The id to be assigned to the next trigger, when the user pushes
    //  the 'New' button for a multiple triggers schedule.
    //

    WORD            m_wNextTriggerId;

    //
    //  The current selection for the trigger type combo box.
    //

    int             m_indexCbxTriggerType;

    //
    //  The timer id of the timer used for trigger string update.
    //

    UINT_PTR        m_idTimer;

    //
    //  The current selection for the trigger strings combo box.
    //

    UINT            m_indexCbxTriggers;

    //
    //  Used by Set/KillActive
    //

    BOOL            m_fShowingMultiSchedsOnKillActive;

    BOOL            m_fShowMultiScheds;

    //
    //  Should we save on Apply or OK.
    //

    BOOL            m_fPersistChanges;

    //
    // Time format string for use with Date picker control
    //

    TCHAR           m_tszTimeFormat[MAX_DP_TIME_FORMAT];

    //
    // Selected months dialog
    //

    CSelectMonth    _SelectMonths;

    //
    // If one of the trigger comboboxes is dropped down, contains the
    // index of the item selected when the user dropped down the list.
    // Otherwise, contains -1.
    //
    // CAUTION: The _OnTimer method looks at this variable to determine
    // whether it is safe to ask the trigger controls for their values
    // and update the trigger string and settings.  If it has anything
    // other than -1, one of the comboboxes may not have a valid
    // selection.
    //

    static int      s_iCbx;

}; // class CSchedulePage

//
// CSchedulePage static.  Although it's possible multiple instances
// of the schedule page are running, only one can have the focus, therefore
// only one can be using s_iCbx at a time.
//

int CSchedulePage::s_iCbx = -1;

inline
CSchedulePage::CSchedulePage(
    ITask * pIJob,
    LPTSTR  ptszTaskPath,
    BOOL    fMultipleTriggers,
    BOOL    fPersistChanges)
        :
        m_pIJob(pIJob),
        m_pIconHelper(NULL),
        m_fShowMultiScheds(fMultipleTriggers),
        m_fPersistChanges(fPersistChanges),
        m_cjtList(),
        m_cjtDeletedList(),
        m_pcjtCurr(NULL),
        m_cTriggersPrev(0),
        m_wNextTriggerId(0),
        m_indexCbxTriggerType(-1),
        m_indexCbxTriggers(0),
        m_idTimer(0),
        CPropPage(MAKEINTRESOURCE(schedule_page), ptszTaskPath)
{
    TRACE(CSchedulePage, CSchedulePage);

    Win4Assert(m_pIJob != NULL);

    m_pIJob->AddRef();

    m_fShowingMultiSchedsOnKillActive = m_fShowMultiScheds;
}


inline
CSchedulePage::~CSchedulePage()
{
    TRACE(CSchedulePage, ~CSchedulePage);

    if (m_pIconHelper != NULL)
    {
        m_pIconHelper->Release();
    }

    if (m_pIJob != NULL)
    {
        m_pIJob->Release();
    }
}


LRESULT
CSchedulePage::_OnHelp(
    HANDLE hRequesting,
    UINT uiHelpCommand)
{
    WinHelp((HWND)hRequesting,
            szMstaskHelp,
            uiHelpCommand,
            (DWORD_PTR)(LPSTR)s_aSchedulePageHelpIds);
    return TRUE;
}

void
CSchedulePage::_EnableApplyButton(void)
{
    if (m_pcjtCurr)
    {
        m_pcjtCurr->DirtyTrigger();
    }

    CPropPage::_EnableApplyButton();
}


inline
void
CSchedulePage::_CreateTimerToUpdateTriggerStr(void)
{
    if (m_idTimer == 0)
    {
        m_idTimer = SetTimer(Hwnd(), IDT_UPDATE_TRIGGER_STRING, 1500, NULL);
        DEBUG_OUT((DEB_USER12, "Created timer (%d)\n", m_idTimer));
    }
}


inline
void
CSchedulePage::_DeleteTimerToUpdateTriggerStr(void)
{
    if (m_idTimer != 0)
    {
        KillTimer(Hwnd(), IDT_UPDATE_TRIGGER_STRING);
        m_idTimer = 0;
    }
}


void
CSchedulePage::_EnableTimeTriggerSpecificCtrls(BOOL fEnable)
{
    if (fEnable == TRUE)
    {
        DateTime_SetFormat(_hCtrl(dp_start_time), m_tszTimeFormat);
    }
    else
    {
        DateTime_SetFormat(_hCtrl(dp_start_time), tszBlank);
    }

    EnableWindow(_hCtrl(dp_start_time), fEnable);
    EnableWindow(_hCtrl(btn_advanced), fEnable);
}



int aCtrlsDaily[] = {
    grp_daily,
    daily_lbl_every, daily_txt_every, daily_spin_every,
    daily_lbl_days
};

int aCtrlsWeekly[] = {
    grp_weekly,
    weekly_lbl_every, weekly_txt_every, weekly_spin_every,
    weekly_lbl_weeks_on,
        chk_mon, chk_tue, chk_wed, chk_thu, chk_fri, chk_sat, chk_sun
};

int aCtrlsMonthly[] = {
    grp_monthly,
    md_rb, md_txt, md_spin, md_lbl,         // md => monthly date
    dow_rb,  dow_cbx_week, dow_cbx_day, dow_lbl,   // dow => day of week
    btn_sel_months
};

int aCtrlsOnce[] = {
    grp_once,
    once_lbl_run_on, once_dp_date
};

int aCtrlsIdle[] = {
    grp_idle,
    idle_lbl_when,
    sch_txt_idle_min, sch_spin_idle_min,
    idle_lbl_mins
};


typedef struct _STriggerTypeData
{
    int                 ids;
    int               * pCtrls;
    int                 cCtrls;
} STriggerTypeData;

STriggerTypeData ttd[] = {
  {IDS_DAILY,       aCtrlsDaily,    ARRAYLEN(aCtrlsDaily)},
  {IDS_WEEKLY,      aCtrlsWeekly,   ARRAYLEN(aCtrlsWeekly)},
  {IDS_MONTHLY,     aCtrlsMonthly,  ARRAYLEN(aCtrlsMonthly)},
  {IDS_ONCE,        aCtrlsOnce,     ARRAYLEN(aCtrlsOnce)},
  {IDS_AT_STARTUP,  NULL,           0},
  {IDS_AT_LOGON,    NULL,           0},
  {IDS_WHEN_IDLE,   aCtrlsIdle,     ARRAYLEN(aCtrlsIdle)}
};

const int INDEX_DAILY = 0;
const int INDEX_WEEKLY = 1;
const int INDEX_MONTHLY = 2;
const int INDEX_ONCE = 3;
const int INDEX_STARTUP = 4;
const int INDEX_LOGON = 5;
const int INDEX_IDLE = 6;


inline
void
CSchedulePage::_ShowControls(
    int index,
    int nCmdShow)
{
    int cCtrls = ttd[index].cCtrls;

    for (int i=0; i < cCtrls; i++)
    {
        ShowWindow(GetDlgItem(Hwnd(), ttd[index].pCtrls[i]), nCmdShow);
    }
}



SWeekData g_aWeekData[] =
{
    {IDS_FIRST,     TASK_FIRST_WEEK},
    {IDS_SECOND,    TASK_SECOND_WEEK},
    {IDS_THIRD,     TASK_THIRD_WEEK},
    {IDS_FORTH,     TASK_FOURTH_WEEK},
    {IDS_LAST,      TASK_LAST_WEEK}
};

SDayData g_aDayData[] =
{
    {chk_mon,   IDS_MONDAY,     TASK_MONDAY},
    {chk_tue,   IDS_TUESDAY,    TASK_TUESDAY},
    {chk_wed,   IDS_WEDNESDAY,  TASK_WEDNESDAY},
    {chk_thu,   IDS_THURSDAY,   TASK_THURSDAY},
    {chk_fri,   IDS_FRIDAY,     TASK_FRIDAY},
    {chk_sat,   IDS_SATURDAY,   TASK_SATURDAY},
    {chk_sun,   IDS_SUNDAY,     TASK_SUNDAY}
};


void
CSchedulePage::_ShowTriggerStringDispCtrls(void)
{
    TRACE(CSchedulePage, _ShowTriggerStringDispCtrls);

    if (m_fShowMultiScheds == TRUE)
    {
        ShowWindow(_hCtrl(txt_trigger), SW_HIDE);
        ShowWindow(_hCtrl(idc_icon), SW_HIDE);

        ShowWindow(_hCtrl(cbx_triggers), SW_SHOWNA);
        ShowWindow(_hCtrl(btn_new), SW_SHOWNA);
        ShowWindow(_hCtrl(btn_delete), SW_SHOWNA);

        EnableWindow(_hCtrl(btn_new), TRUE);

        // Handle the case where you open the page for the first time
        // and there is not a trigger on the job.

        EnableWindow(_hCtrl(btn_delete), (m_pcjtCurr) ? TRUE : FALSE);
    }
    else
    {
        ShowWindow(_hCtrl(cbx_triggers), SW_HIDE);
        ShowWindow(_hCtrl(btn_new), SW_HIDE);
        ShowWindow(_hCtrl(btn_delete), SW_HIDE);

        ShowWindow(_hCtrl(txt_trigger), SW_SHOWNA);
        ShowWindow(_hCtrl(idc_icon), SW_SHOWNA);

        EnableWindow(_hCtrl(btn_new), FALSE);
        EnableWindow(_hCtrl(btn_delete), FALSE);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   MoveControlGroup
//
//  Synopsis:   Move the controls with ids in [aidControls] left by
//              [xOffset] pixels.
//
//  Arguments:  [hdlg]        - window handle of dialog containing controls
//              [aidControls] - array of ids of controls to move
//              [cControls]   - number of elements in array
//              [xOffset]     - distance, in pixels, to move controls left
//
//  History:    08-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
MoveControlGroup(
    HWND hdlg,
    int aidControls[],
    ULONG cControls,
    long xOffset)
{
    ULONG   i;
    BOOL    fOk;

    for (i = 0; i < cControls; i++)
    {
        HWND hwnd = GetDlgItem(hdlg, aidControls[i]);
        Win4Assert(hwnd);

        RECT rc;
        BOOL fOk = GetWindowRect(hwnd, &rc);
        Win4Assert(fOk);

        fOk = MapWindowPoints(NULL, hdlg, (LPPOINT) &rc, 2);
        Win4Assert(fOk);

        fOk = SetWindowPos(hwnd,
                           NULL,
                           rc.left - xOffset,
                           rc.top,
                           0,
                           0,
                           SWP_NOACTIVATE       |
                            SWP_NOCOPYBITS      |
                            SWP_NOOWNERZORDER   |
                            SWP_NOREDRAW        |
                            SWP_NOSENDCHANGING  |
                            SWP_NOSIZE          |
                            SWP_NOZORDER);
        Win4Assert(fOk);
    }
}


#define TRIGGER_OFFSET      250

LRESULT
CSchedulePage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE(CSchedulePage, _OnInitDialog);

    HRESULT     hr = S_OK;

    do
    {
        //
        // Move the trigger settings for weekly, monthly, once, and idle over
        // to the left.  Each is offset by a multiple of TRIGGER_OFFSET DLUs.
        //

        RECT rc = { 0, 0, TRIGGER_OFFSET - 1, 1 };
        BOOL fOk = MapDialogRect(Hwnd(), &rc);
        Win4Assert(fOk);
        long xOffset = rc.right;

        MoveControlGroup(Hwnd(), aCtrlsWeekly,  ARRAYLEN(aCtrlsWeekly),  1 * xOffset);
        MoveControlGroup(Hwnd(), aCtrlsMonthly, ARRAYLEN(aCtrlsMonthly), 2 * xOffset);
        MoveControlGroup(Hwnd(), aCtrlsOnce,    ARRAYLEN(aCtrlsOnce),    3 * xOffset);
        MoveControlGroup(Hwnd(), aCtrlsIdle,    ARRAYLEN(aCtrlsIdle),    4 * xOffset);

        //
        // Initialize time format string m_tszTimeFormat
        //

        UpdateTimeFormat(m_tszTimeFormat, ARRAYLEN(m_tszTimeFormat));

        //
        // Set job flags
        //
        // See if the general page has already created the icon,
        // helper, if not create it here.

        m_pIconHelper = (CIconHelper *)PropSheet_QuerySiblings(
                                GetParent(Hwnd()), GET_ICON_HELPER, 0);

        if (m_pIconHelper == NULL)
        {
            m_pIconHelper = new CIconHelper();

            if (m_pIconHelper == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                break;
            }

            //
            // Get the application name and set the application icon.
            //

            LPWSTR pwszAppName = NULL;

            hr = m_pIJob->GetApplicationName(&pwszAppName);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

#ifdef UNICODE
            m_pIconHelper->SetAppIcon(pwszAppName);
#else
            //
            // Failure to get the name for the app icon is relatively benign
            // and shouldn't prevent prop sheet from appearing.
            //

            CHAR szBuf[MAX_PATH + 1];
            ZeroMemory(szBuf, ARRAYLEN(szBuf));
            (void) UnicodeToAnsi(szBuf, pwszAppName, MAX_PATH+1);
            m_pIconHelper->SetAppIcon(szBuf);
#endif
            CoTaskMemFree(pwszAppName);

            //
            //  Compute the job icon
            //

            BOOL fEnabled = FALSE;

            if (this->IsTaskInTasksFolder())
            {
                DWORD dwFlags;

                hr = m_pIJob->GetFlags(&dwFlags);

                fEnabled = (dwFlags & TASK_FLAG_DISABLED) ? FALSE : TRUE;
            }

            m_pIconHelper->SetJobIcon(fEnabled);
        }
        else
        {
            m_pIconHelper->AddRef();
        }

        hr = _LoadTriggers();

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        _InitPage();

        _RefreshPage();

        m_fDirty = FALSE;

    } while (0);

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else
        {
            _ErrorDialog(IERR_SCHEDULE_PAGE_INIT, hr);
        }

        EnableWindow(Hwnd(), FALSE);

        return FALSE;
    }

    return TRUE;
}

#define GET_LOCALE_INFO(lcid)                           \
        {                                               \
            cch = GetLocaleInfo(LOCALE_USER_DEFAULT,    \
                                (lcid),                 \
                                tszScratch,             \
                                ARRAYLEN(tszScratch));  \
            if (!cch)                                   \
            {                                           \
                DEBUG_OUT_LASTERROR;                    \
                break;                                  \
            }                                           \
        }

//+--------------------------------------------------------------------------
//
//  Function:   UpdateTimeFormat
//
//  Synopsis:   Construct a time format containing hour and minute for use
//              with the date picker control.
//
//  Arguments:  [tszTimeFormat] - buffer to fill with time format
//              [cchTimeFormat] - size in chars of buffer
//
//  Modifies:   *[tszTimeFormat]
//
//  History:    11-18-1996   DavidMun   Created
//
//  Notes:      This is called on initialization and for wininichange
//              processing.
//
//---------------------------------------------------------------------------

void
UpdateTimeFormat(
        LPTSTR tszTimeFormat,
        ULONG  cchTimeFormat)
{
    ULONG cch;
    TCHAR tszScratch[80];
    BOOL  fAmPm;
    BOOL  fAmPmPrefixes;
    BOOL  fLeadingZero;

    do
    {
        GET_LOCALE_INFO(LOCALE_ITIME);
        fAmPm = (*tszScratch == TEXT('0'));

        if (fAmPm)
        {
            GET_LOCALE_INFO(LOCALE_ITIMEMARKPOSN);
            fAmPmPrefixes = (*tszScratch == TEXT('1'));
        }

        GET_LOCALE_INFO(LOCALE_ITLZERO);
        fLeadingZero = (*tszScratch == TEXT('1'));

        GET_LOCALE_INFO(LOCALE_STIME);

        //
        // See if there's enough room in destination string
        //

        cch = 1                     +  // terminating nul
              1                     +  // first hour digit specifier "h"
              2                     +  // minutes specifier "mm"
              (fLeadingZero != 0)   +  // leading hour digit specifier "h"
              lstrlen(tszScratch)   +  // separator string
              (fAmPm ? 3 : 0);         // space and "tt" for AM/PM

        if (cch > cchTimeFormat)
        {
            cch = 0; // signal error
        }
    } while (0);

    //
    // If there was a problem in getting locale info for building time string
    // just use the default and bail.
    //

    if (!cch)
    {
        lstrcpy(tszTimeFormat, DEFAULT_TIME_FORMAT);
        return;
    }

    //
    // Build a time string that has hours and minutes but no seconds.
    //

    tszTimeFormat[0] = TEXT('\0');

    if (fAmPm)
    {
        if (fAmPmPrefixes)
        {
            lstrcpy(tszTimeFormat, TEXT("tt "));
        }

        lstrcat(tszTimeFormat, TEXT("h"));

        if (fLeadingZero)
        {
            lstrcat(tszTimeFormat, TEXT("h"));
        }
    }
    else
    {
        lstrcat(tszTimeFormat, TEXT("H"));

        if (fLeadingZero)
        {
            lstrcat(tszTimeFormat, TEXT("H"));
        }
    }

    lstrcat(tszTimeFormat, tszScratch); // separator
    lstrcat(tszTimeFormat, TEXT("mm"));

    if (fAmPm && !fAmPmPrefixes)
    {
        lstrcat(tszTimeFormat, TEXT(" tt"));
    }
}


HRESULT
CSchedulePage::_LoadTriggers(void)
{
    TRACE(CSchedulePage, _LoadTriggers);

    HRESULT      hr = S_OK;
    WORD         cTriggers = 0;
    TASK_TRIGGER jtTemp;

    do
    {
        hr = m_pIJob->GetTriggerCount(&cTriggers);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (cTriggers == 0)
        {
            break;
        }

        m_wNextTriggerId = m_cTriggersPrev = cTriggers;

        ITaskTrigger * pIJobTrigger = NULL;

        for (WORD wTrigger = 0; wTrigger < cTriggers; wTrigger++)
        {
            hr = m_pIJob->GetTrigger(wTrigger, &pIJobTrigger);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            hr = pIJobTrigger->GetTrigger(&jtTemp);

            CHECK_HRESULT(hr);

            pIJobTrigger->Release();

            BREAK_ON_FAIL(hr);

            // Set the trigger id
            jtTemp.Reserved1 = wTrigger;

            //
            //  Save it to the m_cjtList.
            //

            CJobTrigger * pcjt = new CJobTrigger(jtTemp);

            if (pcjt == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                break;
            }

            m_cjtList.Add(pcjt);
        }

        BREAK_ON_FAIL(hr);

        m_pcjtCurr = m_cjtList.First();

    } while (0);

    return hr;
}


BOOL
CSchedulePage::_LoadTriggerStrings(void)
{
    TCHAR   tcBuff[SCH_XBIGBUF_LEN];
    HWND    hCombo = _hCtrl(cbx_triggers);
    int     iNew;

    CJobTrigger * pcjt = m_cjtList.First();

    if (pcjt == NULL)
    {
        //
        // Job not scheduled
        //

        LoadString(g_hInstance, IDS_NO_TRIGGERS, tcBuff, ARRAYLEN(tcBuff));

        SetWindowText(_hCtrl(txt_trigger), tcBuff);

        iNew = ComboBox_AddString(hCombo, tcBuff);

        if (iNew < 0)
        {
            return FALSE;
        }

        ComboBox_SetItemData(hCombo, iNew, 0);

        return TRUE;
    }

    for (; pcjt != NULL; pcjt = pcjt->Next())
    {
        pcjt->TriggerString(TRUE, tcBuff);

        if (pcjt == m_cjtList.First())
        {
            // For single schedule set the static text box used to display
            // the schedule string.
            SetWindowText(_hCtrl(txt_trigger), tcBuff);

            m_pcjtCurr = pcjt;
        }

        iNew = ComboBox_AddString(hCombo, tcBuff);

        if (iNew < 0)
        {
            return FALSE;
        }

        ComboBox_SetItemData(hCombo, iNew, pcjt);
    }

    return TRUE;
}



BOOL
CSchedulePage::_InitPage(void)
{
    TRACE(CSchedulePage, _InitPage);

    TCHAR   tcBuff[SCH_XBIGBUF_LEN];
    HWND    hCombo;
    HWND    hTxt = _hCtrl(txt_trigger);

    //
    // set multiple schedules chk box
    //

    if (m_fShowMultiScheds == TRUE)
    {
        CheckDlgButton(m_hPage, chk_show_multiple_scheds, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(m_hPage, chk_show_multiple_scheds, BST_UNCHECKED);
    }

    ////////////////////////////////////////////////////////////////
    //
    // Init all the combo boxes
    //

    //
    //  The triggers combo-box for multiple schedules
    //

    CJobTrigger * pcjt;
    int  iNew, iTemp;

    //
    //  The cbx_trigger_type
    //

    hCombo = GetDlgItem(Hwnd(), cbx_trigger_type);

    for (WORD w = 0; w < ARRAYLEN(ttd); w++)
    {
        LoadString(g_hInstance, ttd[w].ids, tcBuff, SCH_XBIGBUF_LEN);

        ComboBox_AddString(hCombo, tcBuff);
    }

    //
    //  The triggers comb box for multiple schedules as well as
    //  static text box for single schedule.
    //

    if (_LoadTriggerStrings() == FALSE)
    {
        return FALSE;
    }

    //
    //  The combo-boxes in monthly control
    //

    hCombo = GetDlgItem(Hwnd(), dow_cbx_week);

    for (w = 0; w < ARRAYLEN(g_aWeekData); w++)
    {
        LoadString(g_hInstance, g_aWeekData[w].ids, tcBuff,
                                        SCH_XBIGBUF_LEN);

        ComboBox_AddString(hCombo, tcBuff);
    }


    hCombo = GetDlgItem(Hwnd(), dow_cbx_day);

    for (w = 0; w < ARRAYLEN(g_aDayData); w++)
    {
        LoadString(g_hInstance, g_aDayData[w].ids, tcBuff,
                                        SCH_XBIGBUF_LEN);

        ComboBox_AddString(hCombo, tcBuff);
    }

    SendDlgItemMessage(Hwnd(), daily_txt_every, EM_LIMITTEXT, 5, 0);
    SendDlgItemMessage(Hwnd(), weekly_txt_every, EM_LIMITTEXT, 5, 0);
    SendDlgItemMessage(Hwnd(), md_txt, EM_LIMITTEXT, 2, 0);
    SendDlgItemMessage(Hwnd(), sch_txt_idle_min, EM_LIMITTEXT, 5, 0);

    ////////////////////////////////////////////////////////////////
    //
    // Init all the spin controls
    //

    // daily_spin_every (1 to max), 1
    Spin_SetRange(Hwnd(), daily_spin_every, 1, UD_MAXVAL);
    Spin_SetPos(Hwnd(), daily_spin_every, 1);

    // weekly_spin_every (1 to max), 1
    Spin_SetRange(Hwnd(), weekly_spin_every, 1, UD_MAXVAL);
    Spin_SetPos(Hwnd(), weekly_spin_every, 1);

    // md_spin (1 to 31), 1
    Spin_SetRange(Hwnd(), md_spin, 1, 31);
    Spin_SetPos(Hwnd(), md_spin, 1);

    // sch_spin_idle_min (1 to max), 1
    Spin_SetRange(Hwnd(), sch_spin_idle_min, 1, MAX_IDLE_MINUTES);
    Spin_SetPos(Hwnd(), sch_spin_idle_min, 1);

    ////////////////////////////////////////////////////////////////
    //
    // Hide all controls
    //

    _ShowControls(INDEX_DAILY, SW_HIDE);
    _ShowControls(INDEX_WEEKLY, SW_HIDE);
    _ShowControls(INDEX_MONTHLY, SW_HIDE);
    _ShowControls(INDEX_ONCE, SW_HIDE);
    _ShowControls(INDEX_IDLE, SW_HIDE);
    return TRUE;
}


int
CSchedulePage::_GetTriggerTypeIndex(void)
{
    switch (m_pcjtCurr->m_jt.TriggerType)
    {
    case TASK_TIME_TRIGGER_ONCE:
        return INDEX_ONCE;

    case TASK_TIME_TRIGGER_DAILY:
        return INDEX_DAILY;

    case TASK_TIME_TRIGGER_WEEKLY:
        return INDEX_WEEKLY;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
    case TASK_TIME_TRIGGER_MONTHLYDOW:
        return INDEX_MONTHLY;

    case TASK_EVENT_TRIGGER_ON_IDLE:
        return INDEX_IDLE;

   case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
      return INDEX_STARTUP;

    case TASK_EVENT_TRIGGER_AT_LOGON:
        return INDEX_LOGON;

    default:
        Win4Assert(0 && "Unknown trigger type");
        return -1;
    }
}



BOOL
CSchedulePage::_RefreshPage(void)
{
    TRACE(CSchedulePage, _RefreshPage);

    //
    //  Special case if Job not scheduled.
    //

    if (m_pcjtCurr == NULL)
    {
        EnableWindow(_hCtrl(cbx_trigger_type), FALSE);
        EnableWindow(_hCtrl(btn_delete), FALSE);
        _EnableTimeTriggerSpecificCtrls(FALSE);

        _ShowTriggerStringDispCtrls();

        // Force multiple schedules view
        // and prevent disabling new trigger creation if #triggers == 0

        m_fShowMultiScheds = TRUE;

        ComboBox_SetCurSel(_hCtrl(cbx_triggers), 0);
        CheckDlgButton(m_hPage, chk_show_multiple_scheds, BST_CHECKED);
        EnableWindow(_hCtrl(chk_show_multiple_scheds), FALSE);

        return TRUE;
    }

    //
    // Disable the "show multiple schedules" checkbox if there
    // is already more than one trigger on the task.
    // This prevents users from hiding the fact that they might have
    // additional triggers which they can't see.
    //

    if (m_cjtList.Count() != 1)
    {
        m_fShowMultiScheds = TRUE;
        CheckDlgButton(m_hPage, chk_show_multiple_scheds, BST_CHECKED);
        EnableWindow(_hCtrl(chk_show_multiple_scheds), FALSE);
    }
    else
    {
        EnableWindow(_hCtrl(chk_show_multiple_scheds), TRUE);
    }

    //
    // Set the trigger type
    //

    int indexTrigger = _GetTriggerTypeIndex();

    if (indexTrigger == -1)
    {
        return FALSE;
    }

    if (m_indexCbxTriggerType != -1  && m_indexCbxTriggerType != indexTrigger)
    {
        _ShowControls(m_indexCbxTriggerType, SW_HIDE);
    }

    m_indexCbxTriggerType = indexTrigger;

    ComboBox_SetCurSel(_hCtrl(cbx_trigger_type), indexTrigger);

    //
    // Set the schedule
    //

    BOOL fTimeTrigger = TRUE;

    switch (m_pcjtCurr->m_jt.TriggerType)
    {
    case TASK_TIME_TRIGGER_DAILY:
        _ShowControls(INDEX_DAILY, SW_SHOWNA);
        _UpdateDailyControls();
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        _ShowControls(INDEX_WEEKLY, SW_SHOWNA);
        _UpdateWeeklyControls();
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
    case TASK_TIME_TRIGGER_MONTHLYDOW:
        _ShowControls(INDEX_MONTHLY, SW_SHOWNA);
        _UpdateMonthlyControls();
        break;

    case TASK_TIME_TRIGGER_ONCE:
        _ShowControls(INDEX_ONCE, SW_SHOWNA);
        _UpdateOnceOnlyControls();
        break;

    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
        fTimeTrigger = FALSE;
        ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_STARTUP);
        break;

    case TASK_EVENT_TRIGGER_AT_LOGON:
        fTimeTrigger = FALSE;
        ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_LOGON);
        break;

    case TASK_EVENT_TRIGGER_ON_IDLE:
        fTimeTrigger = FALSE;
        ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_IDLE);
        _ShowControls(INDEX_IDLE, SW_SHOWNA);
        _UpdateIdleControls();
        break;

    default:
        Win4Assert(0 && "Unknown trigger type");
        return FALSE;
    }

    _EnableTimeTriggerSpecificCtrls(fTimeTrigger);

    if (fTimeTrigger == TRUE)
    {
        //
        // Set start time
        //

        SYSTEMTIME st;
        GetSystemTime(&st);

        st.wHour = m_pcjtCurr->m_jt.wStartHour;
        st.wMinute = m_pcjtCurr->m_jt.wStartMinute;
        st.wSecond = 0;

        if (DateTime_SetSystemtime(_hCtrl(dp_start_time), GDT_VALID, &st)
            == FALSE)
        {
            DEBUG_OUT((DEB_USER1, "DateTime_SetSystemtime failed.\n"));
        }
    }

    //
    //  Finally update the trigger string
    //

    _UpdateTriggerString();
    _ShowTriggerStringDispCtrls();

    return TRUE;
}


void
CSchedulePage::_UpdateDailyControls(void)
{
    ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_DAILY);

    Spin_SetPos(Hwnd(), daily_spin_every, m_pcjtCurr->m_jt.Type.Daily.DaysInterval);
}


void
CSchedulePage::_UpdateWeeklyControls(void)
{
    ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_WEEKLY);

    Spin_SetPos(Hwnd(), weekly_spin_every,
                            m_pcjtCurr->m_jt.Type.Weekly.WeeksInterval);

    for (int i=0; i < 7; i++)
    {
        if (m_pcjtCurr->m_jt.Type.Weekly.rgfDaysOfTheWeek & g_aDayData[i].day)
        {
            CheckDlgButton(Hwnd(), g_aDayData[i].idCtrl, BST_CHECKED);
        }
        else
        {
            CheckDlgButton(Hwnd(), g_aDayData[i].idCtrl, BST_UNCHECKED);
        }
    }
}



WORD
CSchedulePage::_GetDayFromRgfDays(
    DWORD rgfDays)
{
    WORD wDay;
    WORD wTemp;
    BYTE bTemp;

    if (LOWORD(rgfDays))
    {
        wTemp = LOWORD(rgfDays);
        wDay = 0;
    }
    else
    {
        wTemp = HIWORD(rgfDays);
        wDay = 16;
    }

    if (LOBYTE(wTemp))
    {
        bTemp = LOBYTE(wTemp);
    }
    else
    {
        bTemp = HIBYTE(wTemp);
        wDay += 8;
    }

    if (bTemp & 0x01) return (wDay + 1);
    if (bTemp & 0x02) return (wDay + 2);
    if (bTemp & 0x04) return (wDay + 3);
    if (bTemp & 0x08) return (wDay + 4);
    if (bTemp & 0x10) return (wDay + 5);
    if (bTemp & 0x20) return (wDay + 6);
    if (bTemp & 0x40) return (wDay + 7);
    if (bTemp & 0x80) return (wDay + 8);

    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSchedulePage::_CheckMonthlyRadio
//
//  Synopsis:   Set the state of the monthly radio buttons to match
//              [TriggerType].
//
//  Arguments:  [TriggerType] - TASK_TIME_TRIGGER_MONTHLYDATE or
//                               TASK_TIME_TRIGGER_MONTHLYDOW.
//
//  History:    07-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CSchedulePage::_CheckMonthlyRadio(
    TASK_TRIGGER_TYPE TriggerType)
{
    if (TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE)
    {
        CheckDlgButton(Hwnd(), md_rb, BST_CHECKED);
        CheckDlgButton(Hwnd(), dow_rb, BST_UNCHECKED);
    }
    else
    {
        Win4Assert(TriggerType == TASK_TIME_TRIGGER_MONTHLYDOW);

        CheckDlgButton(Hwnd(), md_rb, BST_UNCHECKED);
        CheckDlgButton(Hwnd(), dow_rb, BST_CHECKED);
    }
}




void
CSchedulePage::_UpdateMonthlyControls(void)
{
    ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_MONTHLY);

    WORD rgfMonths = 0;

    _CheckMonthlyRadio(m_pcjtCurr->m_jt.TriggerType);

    if (m_pcjtCurr->m_jt.TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE)
    {
        WORD wDay = _GetDayFromRgfDays(m_pcjtCurr->m_jt.Type.MonthlyDate.rgfDays);

        Spin_SetPos(Hwnd(), md_spin, wDay);

        rgfMonths = m_pcjtCurr->m_jt.Type.MonthlyDate.rgfMonths;

        EnableWindow(_hCtrl(md_spin), TRUE);
        EnableWindow(_hCtrl(md_txt), TRUE);

        EnableWindow(_hCtrl(dow_cbx_week), FALSE);
        EnableWindow(_hCtrl(dow_cbx_day), FALSE);
    }
    else // monthly day-of-week
    {
        for (int i=0; i < ARRAYLEN(g_aWeekData); i++)
        {
            if (g_aWeekData[i].week ==
                m_pcjtCurr->m_jt.Type.MonthlyDOW.wWhichWeek)
            {
                break;
            }
        }

        ComboBox_SetCurSel(_hCtrl(dow_cbx_week), i);

        WORD &wDayOfWeek = m_pcjtCurr->m_jt.Type.MonthlyDOW.rgfDaysOfTheWeek;

        for (i=0; i < ARRAYLEN(g_aDayData); i++)
        {
            if (wDayOfWeek & g_aDayData[i].day)
            {
                break;
            }
        }

        ComboBox_SetCurSel(_hCtrl(dow_cbx_day), i);

        rgfMonths = m_pcjtCurr->m_jt.Type.MonthlyDOW.rgfMonths;

        EnableWindow(_hCtrl(dow_cbx_week), TRUE);
        EnableWindow(_hCtrl(dow_cbx_day), TRUE);

        EnableWindow(_hCtrl(md_txt), FALSE);
        EnableWindow(_hCtrl(md_spin), FALSE);
    }
}


void
CSchedulePage::_UpdateOnceOnlyControls(void)
{
    ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_ONCE);

    SYSTEMTIME st;

    ZeroMemory(&st, sizeof st);
    st.wYear        = m_pcjtCurr->m_jt.wBeginYear;
    st.wMonth       = m_pcjtCurr->m_jt.wBeginMonth;
    st.wDay         = m_pcjtCurr->m_jt.wBeginDay;

    if (DateTime_SetSystemtime(_hCtrl(once_dp_date), GDT_VALID, &st)
        == FALSE)
    {
        DEBUG_OUT((DEB_ERROR,
                  "DateTime_SetSystemtime err=%uL.\n",
                  GetLastError()));
    }
}

void
CSchedulePage::_UpdateIdleControls(void)
{
    WORD wIdleWait;
    WORD wIdleDeadline;

    m_pIJob->GetIdleWait(&wIdleWait, &wIdleDeadline);

    if (wIdleWait > MAX_IDLE_MINUTES)
    {
        wIdleWait = MAX_IDLE_MINUTES;
    }
    Spin_SetPos(Hwnd(), sch_spin_idle_min, wIdleWait);
}

INT_PTR
AdvancedDialog(
    HWND          hParent,
    PTASK_TRIGGER pjt);


LRESULT
CSchedulePage::_OnCommand(
    int     id,
    HWND    hwndCtl,
    UINT    codeNotify)
{
    TRACE(CSchedulePage, _OnCommand);

    HRESULT         hr = S_OK;
    CJobTrigger   * pcjt = NULL;
    BOOL            fUpdateTriggerStr = TRUE;
    SYSTEMTIME      st;
    HWND            hCombo;

    switch (id)
    {
    case cbx_trigger_type:
        fUpdateTriggerStr = FALSE;

        if (codeNotify == CBN_DROPDOWN)
        {
            s_iCbx = ComboBox_GetCurSel(_hCtrl(cbx_trigger_type));
        }
        else if (codeNotify == CBN_SELENDOK)
        {
            int iCur = ComboBox_GetCurSel(_hCtrl(cbx_trigger_type));

            if (iCur != s_iCbx)
            {
                _DisplayControls(iCur);

                _EnableApplyButton();

                fUpdateTriggerStr = TRUE;
            }
            s_iCbx = -1;
        }
        else if (codeNotify == CBN_SELENDCANCEL)
        {
            s_iCbx = -1;
        }
        break;

    case btn_advanced:
    {
        _SaveTriggerSettings();

        TASK_TRIGGER jt = m_pcjtCurr->m_jt;

        if (AdvancedDialog(Hwnd(), &jt) == TRUE)
        {
            if (memcmp(&jt, &m_pcjtCurr->m_jt, sizeof(jt)) != 0)
            {
                m_pcjtCurr->m_jt = jt;

                m_pcjtCurr->DirtyTrigger();

                _EnableApplyButton();
            }
            else
            {
                fUpdateTriggerStr = FALSE;
            }
        }

        break;
    }

    case btn_sel_months:
    {
        _SaveTriggerSettings();

        TASK_TRIGGER jt = m_pcjtCurr->m_jt;

        _SelectMonths.InitSelectionFromTrigger(&jt);
        INT_PTR fOk = _SelectMonths.DoModal(select_month_dlg, Hwnd());

        if (fOk)
        {
            _SelectMonths.UpdateTrigger(&jt);

            if (memcmp(&jt, &m_pcjtCurr->m_jt, sizeof(jt)) != 0)
            {
                m_pcjtCurr->m_jt = jt;

                m_pcjtCurr->DirtyTrigger();

                _EnableApplyButton();
            }
            else
            {
                fUpdateTriggerStr = FALSE;
            }
        }
        break;
    }

    // Daily controls - none to handle here
    case daily_txt_every:
        if (codeNotify == EN_CHANGE)
        {
            _EnableApplyButton();
        }
        break;

    // Weekly controls

    case weekly_txt_every:
        if (codeNotify == EN_CHANGE)
        {
            _EnableApplyButton();
        }
        break;

    case chk_mon: case chk_tue: case chk_wed: case chk_thu:
    case chk_fri: case chk_sat: case chk_sun:
        _EnableApplyButton();
        break;

    // Monthly controls

    case md_txt:
        if (codeNotify == EN_CHANGE)
        {
            _EnableApplyButton();
        }
        break;

    case md_rb:
        _CheckMonthlyRadio(TASK_TIME_TRIGGER_MONTHLYDATE);

        Spin_Enable(Hwnd(), md_spin, 1);

        EnableWindow(_hCtrl(dow_cbx_week), FALSE);
        EnableWindow(_hCtrl(dow_cbx_day), FALSE);

        _EnableApplyButton();

        break;

    case dow_rb:
        _CheckMonthlyRadio(TASK_TIME_TRIGGER_MONTHLYDOW);

        Spin_Disable(Hwnd(), md_spin);

        EnableWindow(_hCtrl(dow_cbx_week), TRUE);
        EnableWindow(_hCtrl(dow_cbx_day), TRUE);

        ComboBox_SetCurSel(_hCtrl(dow_cbx_week), 0);
        ComboBox_SetCurSel(_hCtrl(dow_cbx_day), 0);

        _EnableApplyButton();
        break;

    case dow_cbx_week:
    case dow_cbx_day:
        fUpdateTriggerStr = FALSE;

        if (codeNotify == CBN_DROPDOWN)
        {
            s_iCbx = ComboBox_GetCurSel(_hCtrl(id));
        }
        else if (codeNotify == CBN_SELENDOK)
        {
            int iCur = ComboBox_GetCurSel(_hCtrl(id));

            if (iCur != s_iCbx)
            {
                _EnableApplyButton();

                fUpdateTriggerStr = TRUE;
            }
            s_iCbx = -1;
        }
        else if (codeNotify == CBN_SELENDCANCEL)
        {
            s_iCbx = -1;
        }
        break;

    // When Idle controls

    case sch_txt_idle_min:
        if (codeNotify == EN_CHANGE)
        {
            _EnableApplyButton();
        }
        break;

    // Once only controls - none
    // At startup controls - none
    // At logon controls - none

    // Controls for multiple triggers
    case chk_show_multiple_scheds:
        if (IsDlgButtonChecked(m_hPage, chk_show_multiple_scheds)
            == BST_CHECKED)
        {
            m_fShowMultiScheds = TRUE;
        }
        else
        {
            m_fShowMultiScheds = FALSE;
        }
        _UpdateTriggerString();
        _ShowTriggerStringDispCtrls();
        break;

    case btn_new:
    {
        SetFocus(_hCtrl(btn_new));

        hCombo = _hCtrl(cbx_triggers);

        if (_PerformSanityChkOnCurrTrigger() == FALSE)
        {
            break;
        }

        if (m_pcjtCurr == NULL)
        {
            ComboBox_ResetContent(hCombo);
            m_wNextTriggerId = 0;
        }
        else
        {
            //
            //  Save the current trigger
            //

            _SaveTriggerSettings();
        }

        //
        //  Create a new trigger, with default settings as:
        //      daily trigger starting at 6:00 AM
        //

        TASK_TRIGGER jtDefault;
        GetSystemTime(&st);

        ZeroMemory(&jtDefault, sizeof(jtDefault));

        jtDefault.cbTriggerSize = sizeof(jtDefault);
        jtDefault.wBeginYear = st.wYear;
        jtDefault.wBeginMonth = st.wMonth;
        jtDefault.wBeginDay = st.wDay;
        jtDefault.wStartHour = 9; // 9 AM
        jtDefault.TriggerType = TASK_TIME_TRIGGER_DAILY;
        jtDefault.Type.Daily.DaysInterval = 1; // Every day

        jtDefault.Reserved1 = m_wNextTriggerId;
        jtDefault.Reserved2 = 0;
        jtDefault.wRandomMinutesInterval = 0;

        pcjt = m_cjtDeletedList.First();

        if (pcjt != NULL)
        {
            m_cjtDeletedList.Remove(pcjt);

            pcjt->m_jt = jtDefault;
        }
        else
        {
            pcjt = new CJobTrigger(jtDefault);

            if (pcjt == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                break;
            }
        }

        pcjt->DirtyTrigger();

        TCHAR tcBuff[SCH_XBIGBUF_LEN];

        pcjt->TriggerString(TRUE, tcBuff);

        int iNew = ComboBox_AddString(hCombo, tcBuff);

        if (iNew < 0)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        ComboBox_SetItemData(hCombo, iNew, pcjt);

        ComboBox_SetCurSel(hCombo, iNew);

        m_indexCbxTriggers = iNew;
        m_pcjtCurr = pcjt;

        m_cjtList.Add(pcjt);


        //
        //  Don't forget to increment m_wNextTriggerId
        //

        ++m_wNextTriggerId;

        //
        //  Refresh the page for the new trigger
        //

        _RefreshPage();

        //
        //  If count of triggers increased from 0 to 1 enable
        //  cbx_trigger_type & btn_delete.
        //

        if (m_cjtList.Count() == 1)
        {
            EnableWindow(_hCtrl(cbx_trigger_type), TRUE);
            EnableWindow(_hCtrl(btn_delete), TRUE);
                }

        _EnableApplyButton();

        break;
    }
    case btn_delete:
    {
        //
        //  Delete the current trigger.
        //

        //Win4Assert(m_cjtList.Count() > 1);

        HWND hCombo = _hCtrl(cbx_triggers);

        int iCur = ComboBox_GetCurSel(hCombo);

        pcjt = (CJobTrigger *) ComboBox_GetItemData(hCombo, iCur);

        ComboBox_DeleteString(hCombo, iCur);

        m_cjtList.Remove(pcjt);
        m_cjtDeletedList.Add(pcjt);

        //
        //  Update the triggers combo box
        //

        if (iCur >= ComboBox_GetCount(hCombo))
        {
            --iCur;
        }

        if (iCur >= 0)
        {
            ComboBox_SetCurSel(hCombo, iCur);

            m_indexCbxTriggers = iCur;
            m_pcjtCurr = (CJobTrigger *) ComboBox_GetItemData(hCombo, iCur);
        }
        else
        {
            _ShowControls(m_indexCbxTriggerType, SW_HIDE);
            _LoadTriggerStrings();

            ComboBox_SetCurSel(hCombo, 0);
            m_indexCbxTriggers = 0;
            m_pcjtCurr = NULL;

            fUpdateTriggerStr = FALSE;
        }

        //
        //  Refresh the page for the new trigger
        //

        _RefreshPage();


        //
        //  If we have zero items, disable the delete button.
        //

        if (m_cjtList.Count() == 0)
        {
            EnableWindow(_hCtrl(btn_delete), FALSE);
            SetFocus(_hCtrl(btn_new));
        }
        else
        {
           SetFocus(_hCtrl(btn_delete));
        }

        _EnableApplyButton();

        break;
    }

    case cbx_triggers:
        if (codeNotify == CBN_SELENDOK)
        {
            m_indexCbxTriggers = ComboBox_GetCurSel(_hCtrl(cbx_triggers));

            m_pcjtCurr = (CJobTrigger *) ComboBox_GetItemData(
                                    _hCtrl(cbx_triggers), m_indexCbxTriggers);

            _RefreshPage();
        }
        else
        {
            fUpdateTriggerStr = FALSE;
        }
        break;

    default:
        fUpdateTriggerStr = FALSE;
        return FALSE;
    }

    if (fUpdateTriggerStr == TRUE)
    {
        _CreateTimerToUpdateTriggerStr();
    }

    if (FAILED(hr))
    {
        _ErrorDialog(IERR_OUT_OF_MEMORY);
    }

    return TRUE;
}



void
CSchedulePage::_DisplayControls(int indexTrigger)
{
    TRACE(CSchedulePage, _DisplayControls);

    if (indexTrigger == m_indexCbxTriggerType)
    {
        return;
    }

    _ShowControls(m_indexCbxTriggerType, SW_HIDE);
    _ShowControls((m_indexCbxTriggerType = indexTrigger), SW_SHOWNA);

    BOOL fEnableEventControls = TRUE;
    UINT i;

    switch (indexTrigger)
    {
    case INDEX_DAILY:
        Spin_SetPos(Hwnd(), daily_spin_every, 1);
        break;

    case INDEX_WEEKLY:
        Spin_SetPos(Hwnd(), weekly_spin_every, 1);

        CheckDlgButton(Hwnd(), g_aDayData[0].idCtrl, BST_CHECKED);

        for (i = 1; i < ARRAYLEN(g_aDayData); i++)
        {
            CheckDlgButton(Hwnd(), g_aDayData[i].idCtrl, BST_UNCHECKED);
        }

        break;

    case INDEX_MONTHLY:
    {
        _CheckMonthlyRadio(TASK_TIME_TRIGGER_MONTHLYDATE);

        Spin_Enable(Hwnd(), md_spin, 1);
        m_pcjtCurr->m_jt.Type.MonthlyDate.rgfMonths = ALL_MONTHS;

        if( !EnableWindow(_hCtrl(dow_cbx_week), FALSE) )
		{
			DEBUG_OUT((DEB_USER1, "EnableWindow(_hCtrl(dow_cbx_week), FALSE) failed.\n"));
		}

        if( !EnableWindow(_hCtrl(dow_cbx_day), FALSE) )
		{
	        DEBUG_OUT((DEB_USER1, "EnableWindow(_hCtrl(dow_cbx_day), FALSE) failed.\n"));
		}

        break;
    }
    case INDEX_ONCE:
    {
        SYSTEMTIME st;
        GetLocalTime(&st);

        if (DateTime_SetSystemtime(_hCtrl(once_dp_date), GDT_VALID, &st)
            == FALSE)
        {
            DEBUG_OUT((DEB_USER1, "DateTime_SetSystemtime failed.\n"));
        }

        break;
    }
    case INDEX_IDLE:
    {
        WORD wIdleWait;
        WORD wDummy;
        HRESULT hr = m_pIJob->GetIdleWait(&wIdleWait, &wDummy);

        if (FAILED(hr) || !wIdleWait)
        {
            wIdleWait = SCH_DEFAULT_IDLE_TIME;
        }
        else if (wIdleWait > MAX_IDLE_MINUTES)
        {
            wIdleWait = MAX_IDLE_MINUTES;
        }
        Spin_SetPos(Hwnd(), sch_spin_idle_min, wIdleWait);
        fEnableEventControls = FALSE;
        break;
    }

    case INDEX_STARTUP:
    case INDEX_LOGON:
        fEnableEventControls = FALSE;
        break;
    }

    _EnableTimeTriggerSpecificCtrls(fEnableEventControls);
}


void
CSchedulePage::_SaveTriggerSettings(void)
{
    TRACE(CSchedulePage, _SaveTriggerSettings);

    if (m_pcjtCurr == 0)
    {
        // No triggers
        return;
    }

    int idxTriggerType = ComboBox_GetCurSel(_hCtrl(cbx_trigger_type));
    Win4Assert(idxTriggerType != CB_ERR);

    int i;

    // Get start time
    SYSTEMTIME st;

    if (DateTime_GetSystemtime(_hCtrl(dp_start_time), &st) == GDT_VALID)
    {
        m_pcjtCurr->m_jt.wStartHour = st.wHour;
        m_pcjtCurr->m_jt.wStartMinute = st.wMinute;
    }


    switch (idxTriggerType)
    {
    case INDEX_DAILY:
        m_pcjtCurr->m_jt.TriggerType = TASK_TIME_TRIGGER_DAILY;
        m_pcjtCurr->m_jt.Type.Daily.DaysInterval = (WORD)Spin_GetPos(Hwnd(),
                                                         daily_spin_every);
        break;

    case INDEX_WEEKLY:
        m_pcjtCurr->m_jt.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
        m_pcjtCurr->m_jt.Type.Weekly.WeeksInterval = (WORD)Spin_GetPos(Hwnd(),
                                                        weekly_spin_every);

        m_pcjtCurr->m_jt.Type.Weekly.rgfDaysOfTheWeek = 0;

        for (i=0; i < ARRAYLEN(g_aDayData); i++)
        {
            if (IsDlgButtonChecked(Hwnd(), g_aDayData[i].idCtrl)
                == BST_CHECKED)
            {
                m_pcjtCurr->m_jt.Type.Weekly.rgfDaysOfTheWeek |= g_aDayData[i].day;
            }
        }

        break;

    case INDEX_MONTHLY:
    {
        if (IsDlgButtonChecked(Hwnd(), md_rb) == BST_CHECKED)
        {
            m_pcjtCurr->m_jt.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;

            WORD wTemp = (WORD)Spin_GetPos(Hwnd(), md_spin);

            m_pcjtCurr->m_jt.Type.MonthlyDate.rgfDays = (1 << (wTemp - 1));
        }
        else // monthly day-of-week
        {
            m_pcjtCurr->m_jt.TriggerType = TASK_TIME_TRIGGER_MONTHLYDOW;

            i = ComboBox_GetCurSel(_hCtrl(dow_cbx_week));
            m_pcjtCurr->m_jt.Type.MonthlyDOW.wWhichWeek = (WORD)g_aWeekData[i].week;

            i = ComboBox_GetCurSel(_hCtrl(dow_cbx_day));
            m_pcjtCurr->m_jt.Type.MonthlyDOW.rgfDaysOfTheWeek = (WORD)g_aDayData[i].day;
        }
        break;
    }
    case INDEX_ONCE:
        m_pcjtCurr->m_jt.TriggerType = TASK_TIME_TRIGGER_ONCE;

        if (DateTime_GetSystemtime(_hCtrl(once_dp_date), &st) == GDT_VALID)
        {
            m_pcjtCurr->m_jt.wBeginYear   = st.wYear;
            m_pcjtCurr->m_jt.wBeginMonth  = st.wMonth;
            m_pcjtCurr->m_jt.wBeginDay    = st.wDay;
        }

        break;

    case INDEX_STARTUP:
        m_pcjtCurr->m_jt.TriggerType = TASK_EVENT_TRIGGER_AT_SYSTEMSTART;
        break;

    case INDEX_LOGON:
        m_pcjtCurr->m_jt.TriggerType = TASK_EVENT_TRIGGER_AT_LOGON;
        break;

    case INDEX_IDLE:
    {
        m_pcjtCurr->m_jt.TriggerType = TASK_EVENT_TRIGGER_ON_IDLE;
        ULONG ulSpinPos = Spin_GetPos(Hwnd(), sch_spin_idle_min);

        WORD wDummy;
        WORD wIdleDeadline;

        m_pIJob->GetIdleWait(&wDummy, &wIdleDeadline);

        if (HIWORD(ulSpinPos))
        {
            m_pIJob->SetIdleWait(SCH_DEFAULT_IDLE_TIME, wIdleDeadline);
        }
        else
        {
            m_pIJob->SetIdleWait(LOWORD(ulSpinPos), wIdleDeadline);
        }
        break;
    }

    default:
        Win4Assert(0 && "Unexpected");
    }
}


LRESULT
CSchedulePage::_OnTimer(
    UINT idTimer)
{
    TRACE(CSchedulePage, _OnTimer);

    //
    // If this isn't the right timer, ignore it.
    //
    // If one of the comboboxes holding data needed to build the trigger is
    // in the dropped-down state (and therefore may not have a valid
    // selection), don't try to update the trigger.  leave the timer
    // running so we get another chance to update.
    //
    // Otherwise, save current trigger settings, update the string displayed
    // at the top of the page, and get rid of the timer.
    //

    if (idTimer == IDT_UPDATE_TRIGGER_STRING && s_iCbx == -1)
    {
        _SaveTriggerSettings();
        _UpdateTriggerString();

        _DeleteTimerToUpdateTriggerStr();
    }
    else
    {
        DEBUG_OUT((DEB_IWARN,
                   "Ignoring timer message (%s)\n",
                    idTimer != IDT_UPDATE_TRIGGER_STRING ?
                        "foreign timer" :
                        "combobox down"));
    }

    return 0;
}



LRESULT
CSchedulePage::_OnPSNSetActive(
    LPARAM lParam)
{
    TRACE(CSchedulePage, _OnPSNSetActive);

    m_fInInit = TRUE;

    Win4Assert(s_iCbx == -1); // can't have a combo open yet

    //
    //  Show application icon
    //

    SendDlgItemMessage(Hwnd(), idc_icon, STM_SETICON,
            (WPARAM)m_pIconHelper->hiconJob, 0L);

    //
    //  single or multiple scheds
    //

    if (m_fShowingMultiSchedsOnKillActive != m_fShowMultiScheds)
    {
        _ShowTriggerStringDispCtrls();

        if (m_fShowMultiScheds == FALSE)
        {
            m_indexCbxTriggers = 0; // reset to zero

            //
            // Show the first trigger
            //

            m_pcjtCurr = (CJobTrigger *) ComboBox_GetItemData(
                                            _hCtrl(cbx_triggers), 0);

            _RefreshPage();
        }
        else
        {
            _UpdateTriggerString();
        }
    }
    else
    {
        _UpdateTriggerString();
    }

    //
    // Make sure IdleWait is syncronized with Settings page changes.
    //

    _UpdateIdleControls();

    //
    //  Create timer to update trigger
    //

    _CreateTimerToUpdateTriggerStr();

    m_fInInit = FALSE;

    return CPropPage::_OnPSNSetActive(lParam);
}


LRESULT
CSchedulePage::_OnPSNKillActive(
    LPARAM lParam)
{
    TRACE(CSchedulePage, _OnPSNKillActive);

    if (_PerformSanityChkOnCurrTrigger() == FALSE)
    {
        // Returns TRUE to prevent the page from losing the activation
        SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, TRUE);
        return TRUE;
    }

    m_fShowingMultiSchedsOnKillActive = m_fShowMultiScheds;

    //
    //  Save the current trigger
    //

    _SaveTriggerSettings();

    //
    // Make sure Settings page is syncronized with IdleWait changes.
    //

    WORD wDummy;
    WORD wIdleDeadline;

    HRESULT hr = m_pIJob->GetIdleWait(&wDummy, &wIdleDeadline);
    CHECK_HRESULT(hr);

    ULONG ulSpinPos = Spin_GetPos(Hwnd(), sch_spin_idle_min);

    if (HIWORD(ulSpinPos))
    {
        m_pIJob->SetIdleWait(SCH_DEFAULT_IDLE_TIME, wIdleDeadline);
    }
    else
    {
        m_pIJob->SetIdleWait(LOWORD(ulSpinPos), wIdleDeadline);
    }

    //
    // kill timer here
    //

    _DeleteTimerToUpdateTriggerStr();

    return CPropPage::_OnPSNKillActive(lParam);
}


LRESULT
CSchedulePage::_OnDateTimeChange(
    LPARAM lParam)
{
    TRACE(CSchedulePage, _OnDateTimeChange);

    m_pcjtCurr->DirtyTrigger();

    _EnableApplyButton();

    _CreateTimerToUpdateTriggerStr();

    return CPropPage::_OnDateTimeChange(lParam);
}


LRESULT
CSchedulePage::_OnSpinDeltaPos(
    NM_UPDOWN * pnmud)
{
    m_pcjtCurr->DirtyTrigger();

    _CreateTimerToUpdateTriggerStr();

    return CPropPage::_OnSpinDeltaPos(pnmud);
}



LRESULT
CSchedulePage::_OnWinIniChange(
    WPARAM  wParam,
    LPARAM  lParam)
{
    TRACE(CSchedulePage, _OnWinIniChange);

    UpdateTimeFormat(m_tszTimeFormat, ARRAYLEN(m_tszTimeFormat));
    DateTime_SetFormat(_hCtrl(dp_start_time), m_tszTimeFormat);
    DateTime_SetFormat(_hCtrl(once_dp_date), NULL);
    return 0;
}



void
CSchedulePage::_UpdateTriggerString(void)
{
    TRACE(CSchedulePage, _UpdateTriggerString);

    if (m_pcjtCurr == 0)
    {
        // No triggers
        return;
    }

    TCHAR   tcBuff[SCH_XBIGBUF_LEN];

    m_pcjtCurr->TriggerString(m_fShowMultiScheds, tcBuff);

    if (m_fShowMultiScheds == TRUE)
    {
        HWND hCombo = _hCtrl(cbx_triggers);

        ComboBox_DeleteString(hCombo, m_indexCbxTriggers);

        int iNew = ComboBox_InsertString(hCombo, m_indexCbxTriggers, tcBuff);

        Win4Assert((UINT)iNew == m_indexCbxTriggers);

        ComboBox_SetItemData(hCombo, iNew, m_pcjtCurr);

        ComboBox_SetCurSel(hCombo, m_indexCbxTriggers);
    }
    else
    {
        // single trigger

        SetDlgItemText(Hwnd(), txt_trigger, tcBuff);
    }
}


LRESULT
CSchedulePage::_OnApply(void)
{
    TRACE(CSchedulePage, _OnApply);

    if (m_fDirty == FALSE)
    {
        return TRUE;
    }

    if (_PerformSanityChkOnCurrTrigger() == FALSE)
    {
        SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, FALSE);
        return FALSE;
    }

    HRESULT     hr = S_OK;

    do
    {
        /////////////////////////////////////////////////////////////////////
        //
        // During the first pass do not delete triggers, since deleting
        // triggers changes the trigger ids in the in memory job. So in
        // the first pass:
        //   - save changes to existing triggers (if any)
        //   - set pcjtLastOriginal to the trigger with the largest ID of
        //     those originally loaded
        //   - add new triggers (if any)
        //

        WORD    wTriggerID = 0;

        ITaskTrigger * pIJobTrigger = NULL;
        CJobTrigger  * pcjtLastOriginal = NULL;

        for (CJobTrigger *pcjt = m_cjtList.First();
             pcjt != NULL;
             pcjt = pcjt->Next())
        {
            wTriggerID = pcjt->GetTriggerID();

            if (wTriggerID < m_cTriggersPrev)
            {
                pcjtLastOriginal = pcjt;

                if (pcjt->IsTriggerDirty() == TRUE)
                {
                    hr = m_pIJob->GetTrigger(wTriggerID, &pIJobTrigger);

                    CHECK_HRESULT(hr);
                    BREAK_ON_FAIL(hr);
                }
                else
                {
                    pIJobTrigger = NULL;
                }
            }
            else
            {
                WORD wTemp;
                hr = m_pIJob->CreateTrigger(&wTemp, &pIJobTrigger);

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);
            }

            if (pIJobTrigger != NULL)
            {
                hr = pIJobTrigger->SetTrigger(&pcjt->m_jt);

                pIJobTrigger->Release();

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);
            }
        }

        BREAK_ON_FAIL(hr);

        //
        // Delete triggers in the decreasing order of Trigger ids, since
        // the trigger ids in memory change.
        //

        if (m_cTriggersPrev && pcjtLastOriginal)
        {
            WORD wSequential = m_cTriggersPrev - 1;
            pcjt = pcjtLastOriginal;

            //
            // There were some triggers originally && not all have been
            // deleted.
            //
            // Go backwards sequentially through the original trigger IDs.
            // Wherever we find a remaining trigger that is out of sync with
            // wSequential, then the original trigger with ID wSequential must
            // have been deleted in the UI, so we delete it on the job.
            //

            while (pcjt)
            {
                if (pcjt->GetTriggerID() < wSequential)
                {
                    hr = m_pIJob->DeleteTrigger(wSequential);
                    CHECK_HRESULT(hr);
                    BREAK_ON_FAIL(hr);
                }
                else
                {
                    pcjt = pcjt->Prev();
                }
                wSequential--;
            }

            //
            // Special case deletions from the start of the list
            //

            wSequential = m_cjtList.First()->GetTriggerID();

            while (wSequential > 0)
            {
                hr = m_pIJob->DeleteTrigger(--wSequential);
                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);
            }
        }
        else if (m_cTriggersPrev)
        {
            WORD wSequential;

            //
            // All the original triggers were deleted in the ui.
            //

            for (wSequential = m_cTriggersPrev; wSequential; )
            {
                hr = m_pIJob->DeleteTrigger(--wSequential);
                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);
            }
        }
        BREAK_ON_FAIL(hr);

        //
        //  Re-number the trigger IDs, since this would have changed for
        //  the job.
        //
        //      NOTE: This is was what we would have if we did a reload of
        //            the job.
        //

        m_wNextTriggerId = 0;

        for (pcjt = m_cjtList.First();
             pcjt != NULL;
             pcjt = pcjt->Next())
        {
             pcjt->SetTriggerID(m_wNextTriggerId++);
        }

        m_cTriggersPrev = m_wNextTriggerId;

        //
        //  Reload the trigger strings.
        //

        ComboBox_ResetContent(_hCtrl(cbx_triggers));

        _LoadTriggerStrings();

        if (m_fShowMultiScheds == TRUE)
        {
            ComboBox_SetCurSel(_hCtrl(cbx_triggers), m_indexCbxTriggers);
            m_pcjtCurr = (CJobTrigger *) ComboBox_GetItemData(
                                                    _hCtrl(cbx_triggers),
                                                    m_indexCbxTriggers);
        }

        //
        // reset dirty flag
        //

        m_fDirty = FALSE;

        //
        //  If evrything went well see if the other pages are ready to
        //  save the job to storage.
        //

        if ((m_fPersistChanges == TRUE) &&
            (PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_READY_TO_BE_SAVED, 0))
            == 0)
        {
            //
            // Save the job file to storage.
            //
            // First, fetch general page task, application dirty status flags.
            // Default to not dirty if the general page isn't present.
            //

#if !defined(_CHICAGO_)
            BOOL fTaskApplicationChange = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_TASK_APPLICATION_DIRTY_STATUS,
                                    (LPARAM)&fTaskApplicationChange);
            BOOL fTaskAccountChange = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_TASK_ACCOUNT_INFO_DIRTY_STATUS,
                                    (LPARAM)&fTaskAccountChange);
            BOOL fSuppressAccountInfoRequest = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG,
                                    (LPARAM)&fSuppressAccountInfoRequest);
#endif // !defined(_CHICAGO_)

            hr = JFSaveJob(Hwnd(),
                           m_pIJob,
#if !defined(_CHICAGO_)
                           this->GetPlatformId() == VER_PLATFORM_WIN32_NT &&
                            this->IsTaskInTasksFolder(),
                           fTaskAccountChange,
                           fTaskApplicationChange,
                           fSuppressAccountInfoRequest);
#else
                           FALSE,
                           FALSE,
                           FALSE);
#endif // !defined(_CHICAGO_)

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

#if !defined(_CHICAGO_)
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_TASK_APPLICATION_DIRTY_STATUS, 0);
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_TASK_ACCOUNT_INFO_DIRTY_STATUS, 0);
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG, 0);

            //
            // Instruct the general page to refresh account information.
            //

            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                        TASK_ACCOUNT_CHANGE_NOTIFY, 0);
#endif // !defined(_CHICAGO_)
        }

    } while (0);

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            _ErrorDialog(IERR_FILE_NOT_FOUND);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            _ErrorDialog(IERR_ACCESS_DENIED);
        }
        else
        {
            _ErrorDialog(IERR_INTERNAL_ERROR, hr);
        }
    }

    return TRUE;
}


LRESULT
CSchedulePage::_OnDestroy(void)
{
    _DeleteTimerToUpdateTriggerStr();

    return 0;
}


LRESULT
CSchedulePage::_OnPSMQuerySibling(
    WPARAM  wParam,
    LPARAM  lParam)
{
    INT_PTR iRet = 0;

    switch (wParam)
    {
    case QUERY_READY_TO_BE_SAVED:
        iRet = (int)m_fDirty;
        break;

    case GET_ICON_HELPER:
        iRet = (INT_PTR)m_pIconHelper;
        break;
    }

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, iRet);
    return iRet;
}


BOOL
CSchedulePage::_PerformSanityChkOnCurrTrigger(void)
{
    if (m_pcjtCurr == 0)
    {
        // No triggers
        return TRUE;
    }

    int iCur = ComboBox_GetCurSel(_hCtrl(cbx_trigger_type));

    Win4Assert(iCur >= 0);

    ULONG   ul;
    UINT    i;
    UINT    idsErrStr = 0;

    switch (iCur)
    {
    case INDEX_DAILY:

        ul = GetDlgItemInt(Hwnd(), daily_txt_every, NULL, FALSE);

        if (ul <= 0)
        {
            Spin_SetPos(Hwnd(), daily_spin_every, 1);
            idsErrStr = IERR_INVALID_DAYILY_EVERY;
        }
        break;

    case INDEX_WEEKLY:

        ul = GetDlgItemInt(Hwnd(), weekly_txt_every, NULL, FALSE);

        if (ul <= 0)
        {
            Spin_SetPos(Hwnd(), weekly_spin_every, 1);
            idsErrStr = IERR_INVALID_WEEKLY_EVERY;
        }
        else
        {
            idsErrStr = IERR_INVALID_WEEKLY_TASK;

            for (i=0; i < ARRAYLEN(g_aDayData); i++)
            {
                if (IsDlgButtonChecked(Hwnd(), g_aDayData[i].idCtrl)
                    == BST_CHECKED)
                {
                    idsErrStr = 0;
                    break;
                }
            }
        }

        break;

    case INDEX_MONTHLY:

        if (IsDlgButtonChecked(Hwnd(), md_rb) == BST_CHECKED)
        {
            //
            // It's a monthly date trigger.  Get the spin control position.
            // Complain if it's not a valid day number for any month, i.e.,
            // if it's < 1 or > 31.
            //

            ul = GetDlgItemInt(Hwnd(), md_txt, NULL, FALSE);

            if (ul <= 0)
            {
                Spin_SetPos(Hwnd(), md_spin, 1);
                idsErrStr = IERR_MONTHLY_DATE_LT0;
                break;
            }

            if (ul > 31)
            {
                Spin_SetPos(Hwnd(), md_spin, 31);
                idsErrStr = IERR_MONTHLY_DATE_GT31;
                break;
            }

            //
            // Complain if the date specified does not fall within any of the
            // months selected (e.g., Feb 31 is an error, Jan+Feb 31 is
            // acceptable).
            //

            TASK_TRIGGER jt = m_pcjtCurr->m_jt;

            jt.Type.MonthlyDate.rgfDays = (1 << (ul - 1));

            if (!IsValidMonthlyDateTrigger(&jt))
            {
                idsErrStr = IERR_MONTHLY_DATE_INVALID;
                break;
            }
        }
        break;

    default:
        break;
    }

    if (idsErrStr != 0)
    {
        _ErrorDialog(idsErrStr);

        return FALSE;
    }

    return TRUE;
}



//+--------------------------------------------------------------------------
//
//  Function:   SkipResourceTemplateArray
//
//  Synopsis:   Return a pointer to the first byte after the resource
//              template array at [pbCur].
//
//  Arguments:  [pbCur] - points to resource template array to skip.
//
//  Returns:    [pbCur] + size of resource template array
//
//  History:    08-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPCBYTE
SkipResourceTemplateArray(
    LPCBYTE pbCur)
{
    //
    // Menu/class array is either 0x0000, 0xFFFF 0x????, or a null terminated
    // Unicode string.
    //

    if (!*(USHORT *)pbCur)
    {
        pbCur += sizeof USHORT; // no menu
    }
    else if (*(USHORT *)pbCur == 0xFFFF)
    {
        pbCur += 2 * sizeof(USHORT);
    }
    else
    {
        pbCur += sizeof(WCHAR) * (1 + lstrlenW((LPCWSTR) pbCur));
    }

    return pbCur;
}


#define SCHEDULE_PAGE_WIDTH     253

HRESULT
GetSchedulePage(
    ITask           * pIJob,
    LPTSTR            ptszTaskPath,
    BOOL              fPersistChanges,
    HPROPSHEETPAGE  * phpage)
{
    Win4Assert(pIJob != NULL);
    Win4Assert(phpage != NULL);

    //
    // If there are no triggers show multiple trigger UI, so that
    // the user can use 'New' push button to create a trigger.
    //

    HRESULT hr = S_OK;
    LPTSTR  ptszPathCopy;

    do
    {
        //
        // Get the job name.
        //

        if (ptszTaskPath != NULL)
        {
            //
            // Create a copy.
            //

            ptszPathCopy = NewDupString(ptszTaskPath);

            if (ptszPathCopy == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                break;
            }
        }
        else
        {
            //
            // Obtain the job path from the interfaces.
            //

            hr = GetJobPath(pIJob, &ptszPathCopy);
        }

        BREAK_ON_FAIL(hr);

        WORD cTriggers = 0;

        hr = pIJob->GetTriggerCount(&cTriggers);

        if (FAILED(hr))
        {
            delete ptszPathCopy;
            CHECK_HRESULT(hr);
            break;
        }

        // Show single trigger only if count of triggers == 1.

        BOOL fShowMultipleTriggers = (cTriggers == 1) ? FALSE : TRUE;

        CSchedulePage * pPage = new CSchedulePage(
                                            pIJob,
                                            ptszPathCopy,
                                            fShowMultipleTriggers,
                                            fPersistChanges);

        if (pPage == NULL)
        {
            delete ptszPathCopy;
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        //
        // To make localization feasible, the trigger controls are specified
        // in the dialog template as non overlapping.  That is, each set of
        // trigger controls has its own area on the dialog.
        //
        // Each set of controls is spaced out to the right, making the
        // entire dialog very wide.
        //
        // The following code loads the template, determines its size, makes
        // a copy, then resizes the copy to normal propsheet page width and
        // moves each set of trigger controls so that they all overlap.
        //

        HRSRC hrsDlg = FindResource(g_hInstance,
                                    MAKEINTRESOURCE(schedule_page),
                                    RT_DIALOG);

        if (!hrsDlg)
        {
            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        //
        // Per SDK: Both Windows 95 and Windows NT automatically free
        // resources.  You do not need to call the FreeResource function to
        // free a resource loaded by using the LoadResource function.
        //

        HGLOBAL hglblDlg = LoadResource(g_hInstance, hrsDlg);

        if (!hglblDlg)
        {
            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        //
        // Per SDK: It is not necessary for Win32-based applications to
        // unlock resources that were locked by the LockResource function.
        //

        LPVOID ptplDlg = (LPVOID) LockResource(hglblDlg);


        if (!ptplDlg)
        {
            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        BOOL bDialogEx;
        UINT uiStyle;
        USHORT iditCount;
        //
        // Handle DIALOGEX style template
        //
        if(((LPDLGTEMPLATE2) ptplDlg)->wSignature == 0xffff)
        {
            bDialogEx = TRUE;
            uiStyle = ((LPDLGTEMPLATE2) ptplDlg)->style;
            iditCount = ((LPDLGTEMPLATE2) ptplDlg)->cDlgItems;
        }
        else
        {
            bDialogEx = FALSE;
            uiStyle = ((LPDLGTEMPLATE) ptplDlg)->style;
            iditCount = ((LPDLGTEMPLATE) ptplDlg)->cdit;
        }

        //
        // ptplDlg is in read-only memory.  Make a writeable copy.
        //
        // Sure wish we could do this:
        //
        //      ULONG cbTemplate = GlobalSize(hglblDlg);
        //
        // but hglblDlg isn't on the global heap.
        //
        // So we're forced to grovel through the template and determine its
        // size.
        //

        LPCBYTE pbCur = (LPCBYTE) ptplDlg;
        USHORT i;

        //
        // Advance to dialog template menu array, then skip it and the class
        // array.
        //

        pbCur += bDialogEx ? sizeof DLGTEMPLATE2 : sizeof DLGTEMPLATE;
        pbCur = SkipResourceTemplateArray(pbCur);
        pbCur = SkipResourceTemplateArray(pbCur);

        //
        // Skip title array, which is a null-terminated Unicode string.
        //

        pbCur += sizeof(WCHAR) * (1 + lstrlenW((LPCWSTR) pbCur));

        //
        // Skip font info, if it is specified.
        //

        if (uiStyle & DS_SETFONT)
        {
            pbCur += sizeof USHORT;
            if (bDialogEx)
            {
                pbCur += sizeof USHORT;
                pbCur += sizeof BYTE;
                pbCur += sizeof BYTE;
            }
            pbCur += sizeof(WCHAR) * (1 + lstrlenW((LPCWSTR) pbCur));
        }

        //
        // Now skip the DLGITEMTEMPLATE structures.
        //

        for (i = 0; i < iditCount; i++)
        {
            //
            // The DLGITEMTEMPLATE structures must be DWORD aligned, but pbCur
            // may be only WORD aligned.  Advance it if necessary to skip a pad
            // WORD.
            //

            if ((ULONG_PTR) pbCur & 3)
            {
                pbCur += 4 - ((ULONG_PTR) pbCur & 3);
            }

            // DEBUG_OUT((DEB_ITRACE, "control id %u\n", ((DLGITEMTEMPLATE*)pbCur)->id));

            // Skip to the start of the variable length data

            pbCur += bDialogEx ? sizeof DLGITEMTEMPLATE2 : sizeof DLGITEMTEMPLATE;

            // Skip the class array

            if (*(USHORT *)pbCur == 0xFFFF)
            {
                pbCur += 2 * sizeof(USHORT);
            }
            else
            {
                pbCur += sizeof(WCHAR) * (1 + lstrlenW((LPCWSTR) pbCur));
            }

            // Skip the title array

            if (*(USHORT *)pbCur == 0xFFFF)
            {
                pbCur += 2 * sizeof(USHORT);
            }
            else
            {
                pbCur += sizeof(WCHAR) * (1 + lstrlenW((LPCWSTR) pbCur));
            }

            //
            // Creation data.  Contrary to SDK docs, it does not start on
            // DWORD boundary.
            //

            if (*(USHORT *)pbCur)
            {
                pbCur += sizeof(USHORT) * (*(USHORT *)pbCur);
            }
            else
            {
                pbCur += sizeof(USHORT);
            }
        }

        //
        // pbCur now points just past the end of the entire dialog template.
        // Now that its size is known, copy it.
        //

        ULONG cbTemplate = (ULONG)(pbCur - (LPCBYTE) ptplDlg);

        LPVOID ptplDlgCopy = (LPVOID) new BYTE[cbTemplate];

        if (!ptplDlgCopy)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        CopyMemory(ptplDlgCopy, ptplDlg, cbTemplate);

        //
        // Set the width of the dialog to the normal size.
        //

        if (bDialogEx)
        {
            ((LPDLGTEMPLATE2) ptplDlgCopy)->cx = SCHEDULE_PAGE_WIDTH;
        }
        else
        {

            ((LPDLGTEMPLATE) ptplDlgCopy)->cx = SCHEDULE_PAGE_WIDTH;
        }

        //
        // Modify the PROPSHEETPAGE struct member to indicate that the page
        // is created from an in-memory template.  The base class dtor will
        // see the PSP_DLGINDIRECT flag and do a delete on the pResource.
        //

        pPage->m_psp.dwFlags |= PSP_DLGINDIRECT;
        pPage->m_psp.pResource = (LPDLGTEMPLATE) ptplDlgCopy;

        HPROPSHEETPAGE hpage = CreatePropertySheetPage(&pPage->m_psp);

        if (hpage == NULL)
        {
            delete pPage;
            delete [] ptplDlgCopy;
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        *phpage = hpage;

    } while (0);

    return hr;
}



HRESULT
AddSchedulePage(
    PROPSHEETHEADER &psh,
    ITask          * pIJob)
{
    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetSchedulePage(pIJob, NULL, TRUE, &hpage);

    if (SUCCEEDED(hr))
    {
        psh.phpage[psh.nPages++] = hpage;
    }

    return hr;
}



HRESULT
AddSchedulePage(
    LPFNADDPROPSHEETPAGE    lpfnAddPage,
    LPARAM                  cookie,
    ITask                 * pIJob)
{
    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetSchedulePage(pIJob, NULL, TRUE, &hpage);

    if (SUCCEEDED(hr))
    {
        if (!lpfnAddPage(hpage, cookie))
        {
            DestroyPropertySheetPage(hpage);

            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\jobpages.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       jobpages.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/5/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include "defines.h"
#include "..\inc\resource.h"
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"
#include "..\folderui\util.hxx"
#include "..\rc.h"

#include "shared.hxx"
#include "schedui.hxx"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//
//  extern EXTERN_C
//

extern HINSTANCE g_hInstance;

//
//  Local constants
//

TCHAR const FAR c_szNULL[] = TEXT("");
TCHAR const FAR c_szStubWindowClass[] = TEXT("JobPropWnd");

#define STUBM_SETDATA   (WM_USER + 1)
#define STUBM_GETDATA   (WM_USER + 2)

#define JF_PROPSHEET_STUB_CLASS 78345



LRESULT
CALLBACK
StubWndProc(
    HWND    hWnd,
    UINT    iMessage,
    WPARAM  wParam,
    LPARAM  lParam)
{
    switch(iMessage)
    {
    case STUBM_SETDATA:
        SetWindowLongPtr(hWnd, 0, wParam);
        return TRUE;

    case STUBM_GETDATA:
        return GetWindowLongPtr(hWnd, 0);

    default:
        return DefWindowProc(hWnd, iMessage, wParam, lParam);
    }
}




HWND I_CreateStubWindow(void)
{
    WNDCLASS wndclass;

    if (!GetClassInfo(g_hInstance, c_szStubWindowClass, &wndclass))
    {
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = StubWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = sizeof(PVOID) * 2;
        wndclass.hInstance     = g_hInstance;
        wndclass.hIcon         = NULL;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = c_szStubWindowClass;

        if (!RegisterClass(&wndclass))
            return NULL;
    }

    return CreateWindowEx(WS_EX_TOOLWINDOW, c_szStubWindowClass, c_szNULL,
                      WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, 0, 0,
                      NULL, NULL, g_hInstance, NULL);
}


HANDLE
StuffStubWindow(
    HWND    hwnd,
    LPTSTR  pszFile)
{
    DWORD   dwProcId;
    HANDLE  hSharedFile;
    UINT    uiFileSize;

    uiFileSize = (lstrlen(pszFile) + 1) * sizeof(TCHAR);

    GetWindowThreadProcessId(hwnd, &dwProcId);

    hSharedFile = SCHEDAllocShared(NULL, sizeof(int)+uiFileSize, dwProcId);

    if (hSharedFile)
    {
        LPBYTE lpb = (LPBYTE)SCHEDLockShared(hSharedFile, dwProcId);

        if (lpb)
        {
            *(int *)lpb = JF_PROPSHEET_STUB_CLASS;
            CopyMemory(lpb+sizeof(int), pszFile, uiFileSize);
            SCHEDUnlockShared(lpb);
            SendMessage(hwnd, STUBM_SETDATA, (WPARAM)hSharedFile, 0);
            return hSharedFile;
        }
        SCHEDFreeShared(hSharedFile, dwProcId);
    }

    return NULL;
}


HWND
FindOtherStub(
    LPTSTR pszFile)
{
    HWND hwnd;

    //
    // BUGBUG using getwindow in a loop is not safe.  this code should
    // use EnumWindows instead.  From win32 sdk:
    //
    // "[EnumWindows] is more reliable than calling the GetWindow function in
    // a loop. An application that calls GetWindow to perform this task risks
    // being caught in an infinite loop or referencing a handle to a window
    // that has been destroyed."
    //

    for (hwnd = FindWindow(c_szStubWindowClass, NULL);
         hwnd != NULL;
         hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        TCHAR szClass[80];

        // find stub windows only
        GetClassName(hwnd, szClass, ARRAYSIZE(szClass));

        if (lstrcmpi(szClass, c_szStubWindowClass) == 0)
        {
            int     iClass;
            HANDLE  hSharedFile;
            DWORD   dwProcId;
            LPTSTR  pszTemp;

            GetWindowThreadProcessId(hwnd, &dwProcId);

            hSharedFile = (HANDLE)SendMessage(hwnd, STUBM_GETDATA, 0, 0);

            if (hSharedFile)
            {
                LPBYTE lpb;

                lpb = (LPBYTE)SCHEDLockShared(hSharedFile, dwProcId);
                pszTemp = (LPTSTR) (lpb + sizeof(int));

                if (lpb)
                {
                    iClass = *(int *)lpb;

                    if (iClass == JF_PROPSHEET_STUB_CLASS &&
                        lstrcmpi(pszTemp, pszFile) == 0)
                    {
                        SCHEDUnlockShared(lpb);
                        return hwnd;
                    }

                    SCHEDUnlockShared(lpb);
                }
            }
        }
    }
    return NULL;
}



STDMETHODIMP
I_GetTaskPage(
    ITask             * pIJob,
    TASKPAGE            tpType,
    BOOL                fPersistChanges,
    HPROPSHEETPAGE    * phPage)
{
    TRACE_FUNCTION(I_GetTaskPage);

    HRESULT     hr = S_OK;
    LPOLESTR    polestr = NULL;

    do
    {
        //
        //  Ensure that the object has a file name.
        //

        IPersistFile  * ppf = NULL;

        hr = pIJob->QueryInterface(IID_IPersistFile, (void **)&ppf);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hr = ppf->GetCurFile(&polestr);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        ppf->Release();

        if (hr == S_FALSE)
        {
            hr = STG_E_NOTFILEBASEDSTORAGE;

            CHECK_HRESULT(hr);
            break;
        }

        //
        // Establish if this task exists within a task's folder.
        //

        LPTSTR ptszJobPath;
#ifdef UNICODE
        ptszJobPath = polestr;
#else
        TCHAR tszJobPath[MAX_PATH + 1];
        hr = UnicodeToAnsi(tszJobPath, polestr, MAX_PATH + 1);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);
        ptszJobPath = tszJobPath;
#endif

        if (ptszJobPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        //
        //  Get the page
        //

        switch (tpType)
        {
        case TASKPAGE_TASK:
        {
            hr = GetGeneralPage(pIJob, ptszJobPath, fPersistChanges, phPage);
            CHECK_HRESULT(hr);
            break;
        }
        case TASKPAGE_SCHEDULE:
            hr = GetSchedulePage(pIJob, ptszJobPath, fPersistChanges, phPage);
            CHECK_HRESULT(hr);
            break;

        case TASKPAGE_SETTINGS:
            hr = GetSettingsPage(pIJob, ptszJobPath, fPersistChanges, phPage);
            CHECK_HRESULT(hr);
            break;

        default:
            hr = E_INVALIDARG;
            CHECK_HRESULT(hr);
            break;
        }

    } while (0);

    if (polestr != NULL)
    {
        CoTaskMemFree(polestr);
    }

    return hr;
}


HRESULT
DisplayJobProperties(
    LPDATAOBJECT    pdtobj)
{
    TRACE_FUNCTION(DisplayJobProperties);

    HRESULT     hr = S_OK;
    HANDLE      hSharedFile = NULL;
    HWND        hwnd = NULL;
    ITask     * pIJob = NULL;

    do
    {
        //
        //  Extract the job name from the data object.
        //

        STGMEDIUM stgm;
        FORMATETC fmte = {CF_HDROP, (DVTARGETDEVICE *)NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

        hr = pdtobj->GetData(&fmte, &stgm);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        TCHAR szFile[MAX_PATH];
        UINT  cchRet = DragQueryFile((HDROP)stgm.hGlobal, 0, szFile, MAX_PATH);

        ReleaseStgMedium(&stgm);

        if (cchRet == 0)
        {
            return E_FAIL;
        }

        //
        //  See if the property page for this job is already being displayed.
        //

        if (NULL != (hwnd = FindOtherStub(szFile)))
        {
            SwitchToThisWindow(GetLastActivePopup(hwnd), TRUE);
            break;
        }
        else
        {
            hwnd = I_CreateStubWindow();
            hSharedFile = StuffStubWindow(hwnd, szFile);
        }

        //
        // Bind to the ITask interface.
        //

        hr = JFCreateAndLoadTask(NULL, szFile, &pIJob);

        BREAK_ON_FAIL(hr);

        LPTSTR pName = PathFindFileName(szFile);
        LPTSTR pExt  = PathFindExtension(pName);

        if (pExt)
        {
            *pExt = TEXT('\0');
        }

        //
        //  Add the pages.
        //

        HPROPSHEETPAGE ahpage[MAX_PROP_PAGES];
        PROPSHEETHEADER psh;

        ZeroMemory(&psh, sizeof(psh));

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_DEFAULT;
        psh.hwndParent = hwnd;
        psh.hInstance = g_hInstance;
        psh.pszCaption = pName;
        psh.phpage = ahpage;

        hr = AddGeneralPage(psh, pIJob);
        CHECK_HRESULT(hr);

        hr = AddSchedulePage(psh, pIJob);
        CHECK_HRESULT(hr);

        hr = AddSettingsPage(psh, pIJob);
        CHECK_HRESULT(hr);

        hr = AddSecurityPage(psh, pdtobj);
        CHECK_HRESULT(hr);

        if (psh.nPages == 0)
        {
            DEBUG_OUT((DEB_USER1, "No pages to display.\n"));
            hr = E_FAIL;
            break;
        }

        PropertySheet(&psh);

    } while (0);

    if (pIJob != NULL)
    {
        pIJob->Release();
    }

    SCHEDFreeShared(hSharedFile, GetCurrentProcessId());

    if (hwnd)
    {
        DestroyWindow(hwnd);
    }

    return hr;
}


HRESULT
DisplayJobProperties(
    LPTSTR      pszJob,
    ITask     * pIJob)
{
    Win4Assert(pszJob != NULL);
    Win4Assert(pIJob != NULL);

    HRESULT         hr = S_OK;
    PROPSHEETHEADER psh;

    ZeroMemory(&psh, sizeof(psh));

    do
    {
        //
        // Determine the job name.
        //

        TCHAR szName[MAX_PATH];
        lstrcpy(szName, PathFindFileName(pszJob));

        LPTSTR pExt  = PathFindExtension(szName);

        if (pExt)
        {
            *pExt = TEXT('\0');
        }

        //
        //  Add the pages.
        //

        HPROPSHEETPAGE ahpage[MAX_PROP_PAGES];

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_DEFAULT;
        psh.hwndParent = I_CreateStubWindow();
        psh.hInstance = g_hInstance;
        psh.pszCaption = szName;
        psh.phpage = ahpage;


        hr = AddGeneralPage(psh, pIJob);
        CHECK_HRESULT(hr);

        hr = AddSchedulePage(psh, pIJob);
        CHECK_HRESULT(hr);

        hr = AddSettingsPage(psh, pIJob);
        CHECK_HRESULT(hr);

        if (psh.nPages == 0)
        {
            DEBUG_OUT((DEB_USER1, "No pages to display.\n"));
            hr = E_FAIL;
            break;
        }

        PropertySheet(&psh);

    } while (0);

    if (psh.hwndParent)
    {
        DestroyWindow(psh.hwndParent);
    }

    return hr;
}




HRESULT
GetJobPath(
    ITask     * pIJob,
    LPTSTR    * ppszJobPath)
{
    HRESULT         hr = S_OK;
    LPOLESTR        polestr = NULL;
    IPersistFile  * ppf = NULL;

    do
    {
        //
        // Get the object name
        //

        hr = pIJob->QueryInterface(IID_IPersistFile, (void **)&ppf);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hr = ppf->GetCurFile(&polestr);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        LPTSTR pszJobPath = NULL;

#ifdef UNICODE
        pszJobPath = NewDupString(polestr);
        CoTaskMemFree(polestr);
#else
        char szName[MAX_PATH + 1];

        hr = UnicodeToAnsi(szName, polestr, MAX_PATH+1);
        CoTaskMemFree(polestr);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        pszJobPath = NewDupString(szName);
#endif


        if (pszJobPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        *ppszJobPath = pszJobPath;

    } while (0);

    if (ppf != NULL)
    {
        ppf->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\security.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       security.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/5/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"

#include "defines.h"
#include "schedui.hxx"


// {1F2E5C40-9550-11CE-99D2-00AA006E086C}
CLSID CLSID_RShellExt = {
    0x1F2E5C40,
    0x9550,
    0x11CE,
    { 0x99, 0xD2, 0x00, 0xAA, 0x00, 0x6E, 0x08, 0x6C }
};

//
//  This function is a callback function from property sheet page extensions.
//

BOOL CALLBACK
I_AddPropSheetPage(
    HPROPSHEETPAGE  hpage,
    LPARAM          lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAX_PROP_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;

        return TRUE;
    }

    return FALSE;
}



HRESULT
AddSecurityPage(
    PROPSHEETHEADER &psh,
    LPDATAOBJECT     pdtobj)
{
    TRACE_FUNCTION(AddSecurityPage);

    HRESULT     hr = S_OK;
    IShellPropSheetExt * pShellPropSheetExt = NULL;

    do
    {
        hr = CoCreateInstance(CLSID_RShellExt, NULL, CLSCTX_ALL,
                   IID_IShellPropSheetExt, (void **)&pShellPropSheetExt);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        IShellExtInit * pShExtInit = NULL;

        hr = pShellPropSheetExt->QueryInterface(IID_IShellExtInit,
                                                (void **)&pShExtInit);

        if (SUCCEEDED(hr))
        {
            hr = pShExtInit->Initialize(NULL, pdtobj, NULL);

            CHECK_HRESULT(hr);

            pShExtInit->Release();

            if (SUCCEEDED(hr))
            {
                hr = pShellPropSheetExt->AddPages(I_AddPropSheetPage,
                                                        (LPARAM)&psh);
                CHECK_HRESULT(hr);
            }
        }

    } while (0);

    if (pShellPropSheetExt)
    {
        pShellPropSheetExt->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\selmonth.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       selmonth.cxx
//
//  Contents:   Implementation of class to manage simple month-selection
//              dialog box.
//
//  Classes:    CSelectMonth
//
//  History:    5-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <mstask.h>
#include "dll.hxx"
#include "dlg.hxx"
#include "selmonth.hxx"
#include "rc.h"
#include "uiutil.hxx"
#include "defines.hxx"
#include "helpids.h"


// Helpids for Select Months dialog
const ULONG s_aSelectMonthDlgHelpIds[] =
{
    select_month_dlg,           Hselect_month_dlg,
    chk_jan,                    Hchk_jan,
    chk_feb,                    Hchk_feb,
    chk_mar,                    Hchk_mar,
    chk_apr,                    Hchk_apr,
    chk_may,                    Hchk_may,
    chk_jun,                    Hchk_jun,
    chk_jul,                    Hchk_jul,
    chk_aug,                    Hchk_aug,
    chk_sep,                    Hchk_sep,
    chk_oct,                    Hchk_oct,
    chk_nov,                    Hchk_nov,
    chk_dec,                    Hchk_dec,
    lbl_sel_months,             Hlbl_sel_months,
    0,0
};

extern "C" TCHAR szMstaskHelp[];


//+--------------------------------------------------------------------------
//
//  Member:     CSelectMonth::InitSelectionFromTrigger
//
//  Synopsis:   Set selected bits from monthly trigger
//
//  Arguments:  [pjt] - pointer to trigger to modify, must be of type
//                       TASK_TIME_TRIGGER_MONTHLYDATE or
//                       TASK_TIME_TRIGGER_MONTHLYDOW.
//
//  History:    07-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectMonth::InitSelectionFromTrigger(
   const TASK_TRIGGER *pjt)
{
    if (pjt->TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE)
    {
        _rgfMonths = pjt->Type.MonthlyDate.rgfMonths;
    }
    else
    {
        Win4Assert(pjt->TriggerType == TASK_TIME_TRIGGER_MONTHLYDOW);
        _rgfMonths = pjt->Type.MonthlyDOW.rgfMonths;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectMonth::UpdateTrigger
//
//  Synopsis:   Copy the dialog settings into the appropriate rgfMonths
//              field in [pjt].
//
//  Arguments:  [pjt] - pointer to trigger to modify.
//
//  History:    07-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectMonth::UpdateTrigger(
    TASK_TRIGGER *pjt)
{
    if (!_rgfMonths)
    {
        _rgfMonths = ALL_MONTHS;
    }

    if (pjt->TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE)
    {
        pjt->Type.MonthlyDate.rgfMonths = _rgfMonths;
    }
    else
    {
        Win4Assert(pjt->TriggerType == TASK_TIME_TRIGGER_MONTHLYDOW);
        pjt->Type.MonthlyDOW.rgfMonths = _rgfMonths;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectMonth::RealDlgProc
//
//  Synopsis:   Dispatch to methods for specific messages.
//
//  Arguments:  standard windows dlg
//
//  Returns:    standard windows dlg
//
//  Derivation: CDlg override
//
//  History:    5-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR
CSelectMonth::RealDlgProc(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        _OnInit();
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            if (!_OnOK())
            {
                // tell user at least 1 month must be selected
                SchedUIErrorDialog(Hwnd(), IERR_INVALID_MONTHLY_TASK, 0);
                break;
            }
            // else FALL THROUGH

        case IDCANCEL:
            EndDialog(Hwnd(), GET_WM_COMMAND_ID(wParam, lParam) != IDCANCEL);
            break;
        }
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle,
                szMstaskHelp,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR)s_aSelectMonthDlgHelpIds);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                szMstaskHelp,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPSTR)s_aSelectMonthDlgHelpIds);
        return TRUE;

    default:
        return FALSE;
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectMonth::_OnInit
//
//  Synopsis:   Check boxes so they match flags in _flMonths
//
//  History:    5-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectMonth::_OnInit()
{
    ULONG id;

    for (id = chk_jan; id <= chk_dec; id++)
    {
        if (_rgfMonths & (1 << (id - chk_jan)))
        {
            CheckDlgButton(Hwnd(), id, BST_CHECKED);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectMonth::_OnOK
//
//  Synopsis:   Map checked boxes to TASK_<month> bits in *_prgfMonths
//
//  Returns:    TRUE if at least one month is selected
//
//  History:    5-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CSelectMonth::_OnOK()
{
    ULONG id;

    _rgfMonths = 0;

    for (id = chk_jan; id <= chk_dec; id++)
    {
        if (IsDlgButtonChecked(Hwnd(), id))
        {
            _rgfMonths |= (1 << (id - chk_jan));
        }
    }

    return _rgfMonths != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\settings.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       settings.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Notes:      For the first release of the scheduling agent, all security
//              operations are disabled under Win95, even Win95 to NT.
//
//  History:    3/4/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include "..\inc\common.hxx"
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"
#include "..\folderui\util.hxx"
#if !defined(_CHICAGO_)
#include "..\inc\network.hxx"
#endif // !defined(_CHICAGO_)
#include "..\inc\dll.hxx"

#include "dlg.hxx"
#include "rc.h"
#include "defines.h"
#include "uiutil.hxx"
#include "helpids.h"
#include "schedui.hxx"



//
//  (Control id, help id) list for context sensitivity help.
//

ULONG s_aSettingsPageHelpIds[] =
{
    chk_start_on_idle,              Hchk_start_on_idle,
    chk_stop_if_not_idle,           Hchk_stop_if_not_idle,
    chk_dont_start_if_on_batteries, Hchk_dont_start_if_on_batteries,
    chk_kill_if_going_on_batteries, Hchk_kill_if_going_on_batteries,
    chk_delete_when_done,           Hchk_delete_when_done,
    chk_stop_after,                 Hchk_stop_after,
    txt_stop_after_hr,              Htxt_stop_after_hr,
    spin_stop_after_hr,             Hspin_stop_after_hr,
    txt_stop_after_min,             Htxt_stop_after_min,
    spin_stop_after_min,            Hspin_stop_after_min,
    txt_idle_min,                   Htxt_idle_min,
    spin_idle_min,                  Hspin_idle_min,
    lbl_idle_deadline1,             Hlbl_idle_deadline,
    lbl_idle_deadline2,             Hlbl_idle_deadline,
    txt_idle_deadline,              Htxt_idle_deadline,
    spin_idle_deadline,             Hspin_idle_deadline,
    lbl_min,                        Hlbl_settings_min,
    lbl_hours,                      Hlbl_settings_hours,
    grp_idle_time,                  Hgrp_idle_time,
    txt_idle_minutes,               Htxt_idle_minutes,
    grp_task_completed,             Hgrp_task_completed,
    grp_power_management,           Hgrp_power_management,
    btn_new,                        Hbtn_new,
    btn_delete,                     Hbtn_delete,
    chk_system_required,            Hchk_system_required,
    0,0
};

extern "C" TCHAR szMstaskHelp[];


//
//  extern
//

extern HINSTANCE g_hInstance;


//
// All task flags included in this define will be modified when the page
// values are persisted in the _OnApply method.
//
// If we're running on NT and targeting NT, the controls for some of these
// flags will be initialized to the job's values and hidden.
//

#define TASK_FLAGS_IN_SETTINGS_PAGE (TASK_FLAG_START_ONLY_IF_IDLE         | \
                                     TASK_FLAG_KILL_ON_IDLE_END           | \
                                     TASK_FLAG_DONT_START_IF_ON_BATTERIES | \
                                     TASK_FLAG_KILL_IF_GOING_ON_BATTERIES | \
                                     TASK_FLAG_SYSTEM_REQUIRED            | \
                                     TASK_FLAG_DELETE_WHEN_DONE)


//____________________________________________________________________________
//____________________________________________________________________________
//________________                      ______________________________________
//________________  class CSettingsPage ______________________________________
//________________                      ______________________________________
//____________________________________________________________________________
//____________________________________________________________________________


class CSettingsPage : public CPropPage
{
public:

    CSettingsPage(ITask * pIJob,
                  LPTSTR  ptszTaskPath,
                  BOOL    fPersistChanges);

    ~CSettingsPage();

private:

    virtual LRESULT _OnInitDialog(LPARAM lParam);
    virtual LRESULT _OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    virtual LRESULT _OnApply();
    virtual LRESULT _OnPSMQuerySibling(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnPSNSetActive(LPARAM lParam);
    virtual LRESULT _OnPSNKillActive(LPARAM lParam);
    virtual LRESULT _OnHelp(HANDLE hRequesting, UINT uiHelpCommand);

    void    _ReadIdleSettings();

    void    _ErrorDialog(int idsErr, LONG error = 0, UINT idsHelpHint = 0)
                { SchedUIErrorDialog(Hwnd(), idsErr, error, idsHelpHint); }

    BOOL    _PerformSanityChk();

    ITask         * m_pIJob;

    DWORD           m_dwFlags;
    DWORD           m_dwMaxRunTime;
    WORD            m_wIdleWait;
    WORD            m_wIdleDeadline;

    //
    //  Should we save on Apply or OK.
    //

    BOOL            m_fPersistChanges;

}; // class CSettingsPage


inline
CSettingsPage::CSettingsPage(
    ITask * pIJob,
    LPTSTR  ptszTaskPath,
    BOOL    fPersistChanges)
        :
        m_pIJob(pIJob),
        m_fPersistChanges(fPersistChanges),
        m_dwFlags(0),
        m_dwMaxRunTime(0),
        m_wIdleWait(0),
        m_wIdleDeadline(0),
        CPropPage(MAKEINTRESOURCE(settings_page), ptszTaskPath)
{
    TRACE(CSettingsPage, CSettingsPage);

    Win4Assert(m_pIJob != NULL);

    pIJob->AddRef();
}


inline
CSettingsPage::~CSettingsPage()
{
    TRACE(CSettingsPage, ~CSettingsPage);

    if (m_pIJob != NULL)
    {
        m_pIJob->Release();
    }
}



LRESULT
CSettingsPage::_OnHelp(
    HANDLE hRequesting,
    UINT uiHelpCommand)
{
    WinHelp((HWND)hRequesting,
            szMstaskHelp,
            uiHelpCommand,
            (DWORD_PTR)(LPSTR)s_aSettingsPageHelpIds);
    return TRUE;
}




LRESULT
CSettingsPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE(CSettingsPage, _OnInitDialog);

    HRESULT     hr = S_OK;
    ITask     * pIJob = m_pIJob;


    Spin_SetRange(m_hPage, spin_idle_min, 1, MAX_IDLE_MINUTES);
    Edit_LimitText(_hCtrl(txt_idle_min), MAX_IDLE_DIGITS);

    Spin_SetRange(m_hPage, spin_idle_deadline, 0, MAX_IDLE_MINUTES);
    Edit_LimitText(_hCtrl(txt_idle_deadline), MAX_IDLE_DIGITS);

    Spin_SetRange(m_hPage, spin_stop_after_hr, 0, MAX_MAXRUNTIME_HOURS);
    Edit_LimitText(_hCtrl(txt_stop_after_hr), MAX_MAXRUNTIME_DIGITS);

    Spin_SetRange(m_hPage, spin_stop_after_min, 0, 59);
    Edit_LimitText(_hCtrl(txt_stop_after_min), 2);

    do
    {
        //
        // Set job flags
        //

        hr = pIJob->GetFlags(&m_dwFlags);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        CheckDlgButton(m_hPage, chk_start_on_idle,
                        (m_dwFlags & TASK_FLAG_START_ONLY_IF_IDLE));

        CheckDlgButton(m_hPage, chk_stop_if_not_idle,
                        (m_dwFlags & TASK_FLAG_KILL_ON_IDLE_END));

        CheckDlgButton(m_hPage, chk_dont_start_if_on_batteries,
                        (m_dwFlags & TASK_FLAG_DONT_START_IF_ON_BATTERIES));

        CheckDlgButton(m_hPage, chk_kill_if_going_on_batteries,
                        (m_dwFlags & TASK_FLAG_KILL_IF_GOING_ON_BATTERIES));

        CheckDlgButton(m_hPage, chk_system_required,
                        (m_dwFlags & TASK_FLAG_SYSTEM_REQUIRED));

        CheckDlgButton(m_hPage, chk_delete_when_done,
                        (m_dwFlags & TASK_FLAG_DELETE_WHEN_DONE));

        //
        // Not all machines have resume timers, which are used to support the
        // TASK_FLAG_SYSTEM_REQUIRED flag.  If the target machine doesn't
        // have resume timers, hide the control.
        //

        if (!SupportsSystemRequired())
        {
            RECT rcSysReq;
            RECT rcGroup;
            LONG cy;

            //
            // Get the distance in pixels from the top of the system required
            // checkbox to the bottom of the group window.
            //
            // Reduce the height of the groupbox by this amount.
            //

            GetWindowRect(_hCtrl(chk_system_required), &rcSysReq);
            GetWindowRect(_hCtrl(grp_power_management), &rcGroup);

            cy = rcGroup.bottom - rcSysReq.top + 1;

            //
            // Hide the checkbox and resize the group window
            //

            ShowWindow(_hCtrl(chk_system_required), SW_HIDE);

            SetWindowPos(_hCtrl(grp_power_management),
                         NULL,
                         0,0,
                         rcGroup.right - rcGroup.left + 1,
                         rcGroup.bottom - rcGroup.top - cy + 1,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }

        //
        // Init idle controls
        //

        hr = m_pIJob->GetIdleWait(&m_wIdleWait, &m_wIdleDeadline);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (m_wIdleWait > MAX_IDLE_MINUTES)
        {
            m_wIdleWait = MAX_IDLE_MINUTES;
        }

        if (m_wIdleDeadline > MAX_IDLE_MINUTES)
        {
            m_wIdleDeadline = MAX_IDLE_MINUTES;
        }

        if (m_dwFlags & TASK_FLAG_START_ONLY_IF_IDLE)
        {
            Spin_Enable(m_hPage, spin_idle_min, m_wIdleWait);
            Spin_Enable(m_hPage, spin_idle_deadline, m_wIdleDeadline);

            Spin_SetPos(m_hPage, spin_idle_min, m_wIdleWait);
            Spin_SetPos(m_hPage, spin_idle_deadline, m_wIdleDeadline);
        }
        else
        {
            m_wIdleWait = SCH_DEFAULT_IDLE_TIME;
            m_wIdleDeadline = SCH_DEFAULT_IDLE_DEADLINE;
            Spin_Disable(m_hPage, spin_idle_min);
            Spin_Disable(m_hPage, spin_idle_deadline);
        }

        //
        // Set max run time
        //

        hr = pIJob->GetMaxRunTime(&m_dwMaxRunTime);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (m_dwMaxRunTime != (DWORD)-1)
        {
            CheckDlgButton(m_hPage, chk_stop_after, BST_CHECKED);

            //
            // Convert to minutes from milliseconds.  If the value is larger
            // than the UI supports, reduce it.
            //

            m_dwMaxRunTime /= 60000;

            if (m_dwMaxRunTime > (MAX_MAXRUNTIME_HOURS * 60 + 59))
            {
                m_dwMaxRunTime = MAX_MAXRUNTIME_HOURS * 60 + 59;
            }

            WORD wHours = (WORD) (m_dwMaxRunTime / 60);
            WORD wMins  = (WORD) (m_dwMaxRunTime % 60);
            Spin_SetPos(m_hPage, spin_stop_after_hr, wHours);
            Spin_SetPos(m_hPage, spin_stop_after_min, wMins);
        }
        else
        {
            CheckDlgButton(m_hPage, chk_stop_after, BST_UNCHECKED);

            Spin_Disable(m_hPage, spin_stop_after_hr);
            Spin_Disable(m_hPage, spin_stop_after_min);
        }

    } while (0);

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else
        {
            _ErrorDialog(IERR_SETTINGS_PAGE_INIT, hr);
        }

        EnableWindow(Hwnd(), FALSE);

        return FALSE;
    }

    m_fDirty = FALSE;

    return TRUE;
}




LRESULT
CSettingsPage::_OnCommand(
    int     id,
    HWND    hwndCtl,
    UINT    codeNotify)
{
    TRACE(CSettingsPage, _OnCommand);

    switch (id)
    {
    case chk_stop_after:
        if (codeNotify != BN_CLICKED)
        {
            return TRUE;
        }

        if (IsDlgButtonChecked(m_hPage, chk_stop_after) == BST_CHECKED)
        {
            Spin_Enable(m_hPage,
                        spin_stop_after_hr,
                        DEFAULT_MAXRUNTIME_HOURS);

            Spin_Enable(m_hPage,
                        spin_stop_after_min,
                        DEFAULT_MAXRUNTIME_MINUTES);
        }
        else
        {
            Spin_Disable(m_hPage, spin_stop_after_hr);
            Spin_Disable(m_hPage, spin_stop_after_min);
        }

        break;

    case chk_start_on_idle:
        if (codeNotify != BN_CLICKED)
        {
            return TRUE;
        }

        if (IsDlgButtonChecked(m_hPage, chk_start_on_idle) == BST_CHECKED)
        {
            Spin_Enable(m_hPage, spin_idle_min, m_wIdleWait);
            Spin_Enable(m_hPage, spin_idle_deadline, m_wIdleDeadline);
        }
        else
        {
            Spin_Disable(m_hPage, spin_idle_min);
            Spin_Disable(m_hPage, spin_idle_deadline);
        }
        break;

    case txt_idle_min:
    case txt_idle_deadline:
    case txt_stop_after_hr:
    case txt_stop_after_min:
        if (codeNotify != EN_CHANGE)
        {
            return TRUE;
        }
        break;

//  case spin_stop_after_hr:
//  case spin_stop_after_min:
//      break;

    case chk_stop_if_not_idle:
    case chk_dont_start_if_on_batteries:
    case chk_kill_if_going_on_batteries:
    case chk_delete_when_done:
    case chk_system_required:
        if (codeNotify != BN_CLICKED)
        {
            return TRUE;
        }

        break;

    default:
        return FALSE;
    }

    _EnableApplyButton();

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CSettingsPage::_ReadIdleSettings
//
//  Synopsis:   Move the idle settings from the edit controls to the member
//              variables, setting them on the job if they have been
//              updated.
//
//  History:    07-17-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CSettingsPage::_ReadIdleSettings()
{
    ULONG ulSpinPos;
    WORD wIdleWait;
    WORD wIdleDeadline;

    //
    // If idle wait isn't turned on, the controls don't have meaningful
    // values.
    //

    if (IsDlgButtonChecked(m_hPage, chk_start_on_idle) != BST_CHECKED)
    {
        return;
    }

    ulSpinPos = Spin_GetPos(m_hPage, spin_idle_min);

    if (HIWORD(ulSpinPos))
    {
        wIdleWait = SCH_DEFAULT_IDLE_TIME;
    }
    else
    {
        wIdleWait = LOWORD(ulSpinPos);
    }

    ulSpinPos = Spin_GetPos(m_hPage, spin_idle_deadline);

    if (HIWORD(ulSpinPos))
    {
        wIdleDeadline = SCH_DEFAULT_IDLE_DEADLINE;
    }
    else
    {
        wIdleDeadline = LOWORD(ulSpinPos);
    }

    if (m_wIdleWait != wIdleWait || m_wIdleDeadline != wIdleDeadline)
    {
        HRESULT hr;

        hr = m_pIJob->SetIdleWait(wIdleWait, wIdleDeadline);

        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            m_wIdleWait = wIdleWait;
            m_wIdleDeadline = wIdleDeadline;
        }
    }
}




BOOL
CSettingsPage::_PerformSanityChk(void)
{
    ULONG ul;

    if (IsDlgButtonChecked(m_hPage, chk_stop_after) == BST_CHECKED)
    {
        ul = GetDlgItemInt(Hwnd(), txt_stop_after_hr, NULL, FALSE);

        if (!ul)
        {
            ul = GetDlgItemInt(Hwnd(), txt_stop_after_min, NULL, FALSE);

            if (!ul)
            {
                Spin_SetPos(Hwnd(), spin_stop_after_min, 1);
                _ErrorDialog(IERR_MAXRUNTIME);
                return FALSE;
            }
        }
    }

    return TRUE;
}

LRESULT
CSettingsPage::_OnPSNKillActive(
    LPARAM lParam)
{
    TRACE(CSettingsPage, _OnPSNKillActive);

    if (_PerformSanityChk() == FALSE)
    {
        // Returns TRUE to prevent the page from losing the activation
        SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, TRUE);
        return TRUE;
    }

    //
    // Make sure Schedule page is synchronized with IdleWait changes.
    //

    _ReadIdleSettings();
    return CPropPage::_OnPSNKillActive(lParam);
}

LRESULT
CSettingsPage::_OnPSNSetActive(LPARAM lParam)
{
    m_fInInit = TRUE;

    //
    // Make sure IdleWait is synchronized with Schedule page changes.
    //

    WORD wDummy;

    HRESULT hr = m_pIJob->GetIdleWait(&m_wIdleWait, &wDummy);

    if (SUCCEEDED(hr) &&
        IsDlgButtonChecked(m_hPage, chk_start_on_idle) == BST_CHECKED)
    {
        Spin_SetPos(m_hPage, spin_idle_min, m_wIdleWait);
    }
    m_fInInit = FALSE;

    return CPropPage::_OnPSNSetActive(lParam);
}

LRESULT
CSettingsPage::_OnApply(void)
{
    TRACE(CSettingsPage, _OnApply);
    //DbxDisplay("CSettingsPage::_OnApply");

    if (m_fDirty == FALSE)
    {
        return TRUE;
    }

    if (_PerformSanityChk() == FALSE)
    {
        SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, FALSE);
        return FALSE;
    }

    HRESULT     hr = S_OK;
    ITask     * pIJob = m_pIJob;
    DWORD       dwFlags = 0;

    do
    {
        if (IsDlgButtonChecked(m_hPage, chk_start_on_idle) == BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_START_ONLY_IF_IDLE;
        }

        if (IsDlgButtonChecked(m_hPage, chk_stop_if_not_idle) == BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_KILL_ON_IDLE_END;
        }

        if (IsDlgButtonChecked(m_hPage, chk_dont_start_if_on_batteries)
            == BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_DONT_START_IF_ON_BATTERIES;
        }

        if (IsDlgButtonChecked(m_hPage, chk_kill_if_going_on_batteries) ==
            BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_KILL_IF_GOING_ON_BATTERIES;
        }

        if (IsDlgButtonChecked(m_hPage, chk_system_required) ==
            BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_SYSTEM_REQUIRED;
        }

        if (IsDlgButtonChecked(m_hPage, chk_delete_when_done) == BST_CHECKED)
        {
            dwFlags |= TASK_FLAG_DELETE_WHEN_DONE;
        }

        if ((m_dwFlags & TASK_FLAGS_IN_SETTINGS_PAGE) != dwFlags)
        {
            hr = pIJob->GetFlags(&m_dwFlags);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            dwFlags |= (m_dwFlags & ~TASK_FLAGS_IN_SETTINGS_PAGE);

            hr = pIJob->SetFlags(dwFlags);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_dwFlags = dwFlags;
        }

        _ReadIdleSettings();

        DWORD dwMins = (DWORD)-1;

        if (IsDlgButtonChecked(m_hPage, chk_stop_after) == BST_CHECKED)
        {
            ULONG ulSpinPos = Spin_GetPos(m_hPage, spin_stop_after_hr);

            if (HIWORD(ulSpinPos))
            {
                dwMins = DEFAULT_MAXRUNTIME_HOURS * 60;
            }
            else
            {
                dwMins = LOWORD(ulSpinPos) * 60;
            }

            ulSpinPos = Spin_GetPos(m_hPage, spin_stop_after_min);

            if (HIWORD(ulSpinPos))
            {
                dwMins += DEFAULT_MAXRUNTIME_MINUTES;
            }
            else
            {
                dwMins += LOWORD(ulSpinPos);
            }
        }

        Win4Assert(dwMins != 0);

        if (m_dwMaxRunTime != dwMins)
        {
            // Max run time is in milliseconds
            hr = pIJob->SetMaxRunTime(
                    ((dwMins == (DWORD)-1) ? (DWORD)-1 : (dwMins * 60000)));

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_dwMaxRunTime = dwMins;
        }

        //
        // reset dirty flag
        //

        m_fDirty = FALSE;

        //
        //  If evrything went well see if the other pages are ready to
        //  save the job to storage.
        //

        if ((m_fPersistChanges == TRUE) &&
            (PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_READY_TO_BE_SAVED, 0))
            == 0)
        {
            //
            // Save the job file to storage.
            //
            // First, fetch general page task, application dirty status flags.
            // Default to not dirty if the general page isn't present.
            //

#if !defined(_CHICAGO_)
            BOOL fTaskApplicationChange = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_TASK_APPLICATION_DIRTY_STATUS,
                                    (LPARAM)&fTaskApplicationChange);
            BOOL fTaskAccountChange = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_TASK_ACCOUNT_INFO_DIRTY_STATUS,
                                    (LPARAM)&fTaskAccountChange);
            BOOL fSuppressAccountInfoRequest = FALSE;
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                    QUERY_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG,
                                    (LPARAM)&fSuppressAccountInfoRequest);
#endif // !defined(_CHICAGO_)

            hr = JFSaveJob(Hwnd(),
                           pIJob,
#if !defined(_CHICAGO_)
                           this->GetPlatformId() == VER_PLATFORM_WIN32_NT &&
                            this->IsTaskInTasksFolder(),
                           fTaskAccountChange,
                           fTaskApplicationChange,
                           fSuppressAccountInfoRequest);
#else
                           FALSE,
                           FALSE,
                           FALSE);
#endif // !defined(_CHICAGO_)

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

#if !defined(_CHICAGO_)
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_TASK_APPLICATION_DIRTY_STATUS, 0);
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_TASK_ACCOUNT_INFO_DIRTY_STATUS, 0);
            PropSheet_QuerySiblings(GetParent(Hwnd()),
                RESET_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG, 0);

            //
            // Instruct the general page to refresh account information.
            //

            PropSheet_QuerySiblings(GetParent(Hwnd()),
                                        TASK_ACCOUNT_CHANGE_NOTIFY, 0);
#endif // !defined(_CHICAGO_)
        }

    } while (0);

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            _ErrorDialog(IERR_FILE_NOT_FOUND);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            _ErrorDialog(IERR_ACCESS_DENIED);
        }
        else
        {
            _ErrorDialog(IERR_INTERNAL_ERROR, hr);
        }
    }

    return TRUE;
}



LRESULT
CSettingsPage::_OnPSMQuerySibling(
    WPARAM  wParam,
    LPARAM  lParam)
{
    int iRet = 0;

    switch (wParam)
    {
    case QUERY_READY_TO_BE_SAVED:
        iRet = (int)m_fDirty;
        break;
    }

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, iRet);

    return iRet;
}



HRESULT
GetSettingsPage(
    ITask          * pIJob,
    LPTSTR           ptszTaskPath,
    BOOL             fPersistChanges,
    HPROPSHEETPAGE * phpage)
{
    Win4Assert(pIJob != NULL);
    Win4Assert(phpage != NULL);

    LPTSTR  ptszPath = NULL;
    HRESULT hr        = S_OK;
    WORD    cTriggers = 0;

    do
    {
        //
        // Get the job name.
        //

        if (ptszTaskPath != NULL)
        {
            //
            // Use passed-in path
            //

            ptszPath = ptszTaskPath;
        }
        else
        {
            //
            // Obtain the job path from the interfaces.
            //

            hr = GetJobPath(pIJob, &ptszPath);
            BREAK_ON_FAIL(hr);
        }

        hr = pIJob->GetTriggerCount(&cTriggers);

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            break;
        }

        CSettingsPage * pPage = new CSettingsPage(
                                            pIJob,
                                            ptszPath,
                                            fPersistChanges);

        if (pPage == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        HPROPSHEETPAGE hpage = CreatePropertySheetPage(&pPage->m_psp);

        if (hpage == NULL)
        {
            delete pPage;

            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        *phpage = hpage;

    } while (0);

    //
    // If we made a copy of pIJob's path string, free it.
    //

    if (ptszPath != ptszTaskPath)
    {
        delete [] ptszPath;
    }

    return hr;
}



HRESULT
AddSettingsPage(
    PROPSHEETHEADER &psh,
    ITask         *  pIJob)
{
    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetSettingsPage(pIJob, NULL, TRUE, &hpage);

    if (SUCCEEDED(hr))
    {
        psh.phpage[psh.nPages++] = hpage;
    }

    return hr;
}



HRESULT
AddSettingsPage(
    LPFNADDPROPSHEETPAGE    lpfnAddPage,
    LPARAM                  cookie,
    ITask                 * pIJob)
{
    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetSettingsPage(pIJob, NULL, TRUE, &hpage);

    CHECK_HRESULT(hr);

    if (SUCCEEDED(hr))
    {
        if (!lpfnAddPage(hpage, cookie))
        {
            DestroyPropertySheetPage(hpage);

            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\strings.cxx ===
#include "..\pch\headers.hxx"
#pragma hdrstop

#include "strings.hxx"

const TCHAR tszBlank[] = TEXT(" ");
const TCHAR tszEmpty[] = TEXT("");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\shared.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       shared.cxx
//
//  Contents:   This file contains a set of routines for the management of
//              shared memory.
//
//  Functions:  SCHEDAllocShared: Allocates a handle (in a given process)
//                  to a copy of a memory block in this process.
//
//              SCHEDFreeShared: Releases the handle (and the copy of the
//                  memory block)
//
//              SCHEDLockShared: Maps a handle (from a given process) into
//                  a memory block in this process.  Has the option of
//                  transfering the handle to this process, thereby deleting
//                  it from the given process
//
//              SCHEDUnlockShared: Opposite of SCHEDLockShared, unmaps the
//                  memory block
//
//  History:    4/1/1996   RaviR   Created (stole from shell\dll\shared.c)
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop


HANDLE
MapHandle(
    HANDLE  hData,
    DWORD   dwSource,
    DWORD   dwDest,
    DWORD   dwDesiredAccess,
    DWORD   dwFlags)
{
    HANDLE hSource = NULL;
    HANDLE hDest = NULL;
    HANDLE hNew = NULL;
    BOOL fOk;

    if (dwSource == GetCurrentProcessId())
        hSource = GetCurrentProcess();
    else
        hSource = OpenProcess( PROCESS_DUP_HANDLE, FALSE, dwSource);

    if (!hSource)
        goto DoExit;

    if (dwDest == GetCurrentProcessId())
        hDest = GetCurrentProcess();
    else
        hDest = OpenProcess( PROCESS_DUP_HANDLE, FALSE, dwDest);

    if (!hDest)
        goto DoExit;

    fOk = DuplicateHandle( hSource, hData,
                           hDest, &hNew,
                           dwDesiredAccess,
                           FALSE, dwFlags | DUPLICATE_SAME_ACCESS);
    if (!fOk)
        hNew = (HANDLE)NULL;

DoExit:
    if (hSource && dwSource != GetCurrentProcessId())
        CloseHandle(hSource);

    if (hDest && dwDest != GetCurrentProcessId())
        CloseHandle(hDest);

    return hNew;
}



HANDLE
SCHEDAllocShared(
    LPCVOID lpvData,
    DWORD   dwSize,
    DWORD   dwDestinationProcessId)
{
    HANDLE  hData;
    SHMAPHEADER* lpmh;
    HANDLE hUsableData;

    //
    // Make a filemapping handle with this data in it.
    //
    hData = CreateFileMapping( INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,0,
                               dwSize+sizeof(SHMAPHEADER),NULL);
    if (hData == NULL)
    {
        // DebugMsg...
        return NULL;
    }

    lpmh = (SHMAPHEADER *)MapViewOfFile(hData, FILE_MAP_READ | FILE_MAP_WRITE,
                                                                    0, 0, 0);

    if (!lpmh)
    {
        // DebugMsg...
        CloseHandle(hData);
        return NULL;
    }
    lpmh->dwSize = dwSize;

    if (lpvData)
        memcpy((LPVOID)(lpmh+1),lpvData,dwSize);

    UnmapViewOfFile(lpmh);

    hUsableData = MapHandle(hData,
                            GetCurrentProcessId(),
                            dwDestinationProcessId,
                            FILE_MAP_ALL_ACCESS,
                            DUPLICATE_CLOSE_SOURCE);
    return hUsableData;
}



LPVOID
SCHEDLockShared(
    HANDLE  hData,
    DWORD   dwSourceProcessId)
{
    SHMAPHEADER*   lpmh;
    HANDLE          hUsableData;

    hUsableData = MapHandle(hData,dwSourceProcessId,GetCurrentProcessId(),FILE_MAP_ALL_ACCESS,0);

    //
    // Now map that new process specific handle and close it
    //
    lpmh = (SHMAPHEADER*)MapViewOfFile(hUsableData,
                    FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);

    CloseHandle(hUsableData);

    if (!lpmh)
        return NULL;

    return (LPVOID)(lpmh+1);
}



BOOL
SCHEDUnlockShared(
    LPVOID  lpvData)
{
    SHMAPHEADER* lpmh = (SHMAPHEADER*)lpvData;

    //
    // Now just unmap the view of the file
    //
    return UnmapViewOfFile(lpmh-1);
}



BOOL
SCHEDFreeShared(
    HANDLE hData,
    DWORD dwSourceProcessId)
{
    HANDLE hUsableData;

    //
    // The below call closes the original handle in whatever process it
    // came from.
    //
    hUsableData = MapHandle(hData,dwSourceProcessId,
                            GetCurrentProcessId(),
                            FILE_MAP_ALL_ACCESS,DUPLICATE_CLOSE_SOURCE);

    //
    // Now free up the local handle
    //
    return CloseHandle(hUsableData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\sources.inc ===
#+----------------------------------------------------------------------------
#
#  Microsoft Windows
#  Copyright (C) Microsoft Corporation, 1995 - 1996.
#
#  Synopsis:    Source list file for the scheduler dll.
#
#  History:     Jan-05-96     RaviR   Created.
#
#-----------------------------------------------------------------------------

TARGETNAME=     SchedUI
TARGETTYPE=     LIBRARY
TARGETPATH=     obj

!IF "$(DBX)" == "yes"
C_DEFINES=$(C_DEFINES) -DDBX
!endif


SOURCES=        \
                ..\advanced.cxx     \
                ..\dlg.cxx          \
                ..\errhdlr.cxx      \
                ..\general.cxx      \
                ..\jobpages.cxx     \
                ..\schedule.cxx     \
                ..\security.cxx     \
                ..\selmonth.cxx     \
                ..\settings.cxx     \
                ..\shared.cxx       \
                ..\shellex.cxx      \
                ..\strings.cxx


INCLUDES=       ..; \
                $(INCLUDES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedule\job_enum.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       job_enum.cxx
//
//  Contents:   job object enumerator implementation
//
//  Classes:    CEnumJobs
//
//  Interfaces: IEnumWorkItems
//
//  History:    13-Sep-95 EricB created
//
//  Notes:      Recursion into subdirs is currently disabled. To reenable,
//              define ENUM_SUBDIRS and recompile.
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "Sched.hxx"

void FreeStrings(LPWSTR * rgpwszNames, int n);

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IEnumWorkItems::Next, public
//
//  Synopsis:   Returns the indicated number of job object monikers
//
//  Arguments:  [cJobs]         - the number of jobs to return
//              [rgpwszNames]   - the array of returned job names
//              [pcJobsFetched] - the actual number of jobs returned; can be
//                                less than or equal to cJobs. Can be NULL if
//                                cJobs is equal to one.
//
//  Returns:    S_OK - returned requested number of job names
//              S_FALSE - returned less than requested number of names because
//                        the end of the enumeration sequence was reached.
//              E_INVALIDARG or E_OUTOFMEMORY - s.b. obvious
//
//  Notes:      Each LPWSTR in the array must be caller freed using
//              CoTaskMemFree and then the array itself must be freed
//              CoTaskMemFree.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CEnumJobs::Next(ULONG cJobs, LPWSTR ** rgpwszNames, ULONG * pcJobsFetched)
{
    HRESULT hr = S_OK;
    if (cJobs == 0)
    {
        return E_INVALIDARG;
    }
    if (cJobs > 1 && pcJobsFetched == NULL)
    {
        // as required by IEnumX spec.
        //
        return E_INVALIDARG;
    }

    *rgpwszNames = NULL;

    if (m_fFindOverrun)
    {
        if (pcJobsFetched != NULL)
        {
            *pcJobsFetched = 0;
        }
        return S_FALSE;
    }

    TCHAR * ptszName;
    WCHAR * pwszName;

    //
    // find the first requested
    //
    hr = GetNext(&ptszName);
    if (hr != S_OK)
    {
        if (pcJobsFetched != NULL)
        {
            *pcJobsFetched = 0;
        }
        *rgpwszNames = NULL;
        return hr;
    }

    //
    // allocate the first job object name string and the pointer to it
    //
    *rgpwszNames = (LPWSTR *)CoTaskMemAlloc(sizeof(LPWSTR *));
    if (*rgpwszNames == NULL)
    {
        if (pcJobsFetched != NULL)
        {
            *pcJobsFetched = 0;
        }
        return E_OUTOFMEMORY;
    }

#if defined(UNICODE)

    pwszName = ptszName;

#else

    WCHAR wszName[MAX_PATH];
    hr = AnsiToUnicode(wszName, ptszName, MAX_PATH);

    if (FAILED(hr))
    {
        delete ptszName;
        CoTaskMemFree(*rgpwszNames);
        if (pcJobsFetched)
        {
            *pcJobsFetched = 0;
        }
        *rgpwszNames = NULL;
        return hr;
    }
    pwszName = wszName;

#endif

    **rgpwszNames =
                (LPWSTR)CoTaskMemAlloc((wcslen(pwszName) + 1) * sizeof(WCHAR));

    if (**rgpwszNames == NULL)
    {
        if (pcJobsFetched != NULL)
        {
            *pcJobsFetched = 0;
        }
        CoTaskMemFree(*rgpwszNames);
        *rgpwszNames = NULL;
        return E_OUTOFMEMORY;
    }

    wcscpy(**rgpwszNames, pwszName);

    delete ptszName;

    if (cJobs == 1)
    {
        if (pcJobsFetched != NULL)
        {
            *pcJobsFetched = 1;
        }
        return S_OK;
    }

    //
    // Note a check at entry guarantees that at this point pcJobsFetched !=
    // NULL.
    //

    ULONG i = 1;

    //
    // find the rest requested
    //
    while (++i <= cJobs)
    {
        hr = GetNext(&ptszName);
        if (hr != S_OK)
        {
            //
            // Either hr == S_FALSE and we've completed successfully because
            // there are no more jobs to enumerate, or else hr is a
            // failure code and we must bail.
            //

            break;
        }
        LPWSTR * rgpwszTmp = *rgpwszNames;

        *rgpwszNames = (LPWSTR *)CoTaskMemAlloc(sizeof(LPWSTR *) * i);

        if (*rgpwszNames == NULL)
        {
            *rgpwszNames = rgpwszTmp; // so cleanup will free strings
            hr = E_OUTOFMEMORY;
            break;
        }

        memcpy(*rgpwszNames, rgpwszTmp, sizeof(LPWSTR *) * (i - 1));

        CoTaskMemFree(rgpwszTmp);

#if defined(UNICODE)

        pwszName = ptszName;

#else

        hr = AnsiToUnicode(wszName, ptszName, MAX_PATH);

        if (FAILED(hr))
        {
            break;
        }
#endif

        (*rgpwszNames)[i - 1] =
                (LPWSTR)CoTaskMemAlloc((wcslen(pwszName) + 1) * sizeof(WCHAR));

        if ((*rgpwszNames)[i - 1] == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        wcscpy((*rgpwszNames)[i - 1], pwszName);

        delete ptszName;
        ptszName = NULL;
    }

    if (FAILED(hr))
    {
        FreeStrings(*rgpwszNames, i - 1);
        delete ptszName;
        *pcJobsFetched = 0;
        *rgpwszNames = NULL;
    }
    else
    {
        *pcJobsFetched = --i;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::GetNext, private
//
//  Synopsis:   enumeration helper
//
//  Arguments:  [pptszName] - the job/queue name, relative to the jobs folder
//
//  Returns:    S_OK - found next file
//              S_FALSE - the end of the enumeration sequence was reached.
//              other code - file system or memory error
//
//-----------------------------------------------------------------------------
HRESULT
CEnumJobs::GetNext(LPTSTR * pptszName)
{
    HRESULT hr = S_OK;

    DWORD dwRet = NO_ERROR;
    WIN32_FIND_DATA FindData;
    //
    // loop until either a matching file is found or the search is done
    //
    do
    {
        //
        // if the find handle is invalid, then we need to start a find in the
        // next directory (which may in fact be the first directory)
        //
        if (m_hFind == INVALID_HANDLE_VALUE)
        {
            //
            // Note that, unless ENUM_SUBDIRS is defined, PopDir returns the
            // string "." the first time it is called and returns S_FALSE the
            // second time to stop the enumeration.
            //
            hr = PopDir(m_tszCurDir);
            if (hr == S_FALSE)
            {
                // we're done
                //
                m_fFindOverrun = TRUE;
                return S_FALSE;
            }

            TCHAR tszFullDirPath[MAX_PATH];

            lstrcpy(tszFullDirPath, m_ptszFolderPath);

#if defined(ENUM_SUBDIRS)

            //
            // Note that, unless ENUM_SUBDIRS is defined, that m_tszCurDir is
            // always ".", so it can be ignored here.
            //
            lstrcat(tszFullDirPath, TEXT("\\"));
            lstrcat(tszFullDirPath, m_tszCurDir);

#endif // ENUM_SUBDIRS

            lstrcat(tszFullDirPath, TEXT("\\*"));

            m_hFind = FindFirstFile(tszFullDirPath, &FindData);
            if (m_hFind == INVALID_HANDLE_VALUE)
            {
                dwRet = GetLastError();
                if (dwRet == ERROR_FILE_NOT_FOUND)
                {   // no files in the current dir, check the next dir.
                    continue;
                }
                else
                {
                    return HRESULT_FROM_WIN32(dwRet);
                }
            }

            hr = CheckFound(&FindData);
            if (hr == S_OK)
            {   // match found
                break;
            }
            if (hr != S_FALSE)
            {   // an error condition
                return hr;
            }
        }

        //
        // Continue looking at files in the current dir until a job/queue has
        // been found or the dir has been scanned. If the former, break out of
        // both loops. If the latter, break out of the inner loop and then
        // restart the search on the next dir.
        //
        do
        {
            if (!FindNextFile(m_hFind, &FindData))
            {
                dwRet = GetLastError();
                if (dwRet == ERROR_NO_MORE_FILES)
                {
                    FindClose(m_hFind);
                    m_hFind = INVALID_HANDLE_VALUE;
                    hr = S_FALSE;
                    break;
                }
                else
                {
                    return HRESULT_FROM_WIN32(dwRet);
                }
            }

            hr = CheckFound(&FindData);
            if (hr == S_OK)
            {   // match found
                break;
            }
            if (hr != S_FALSE)
            {   // an error condition
                return hr;
            }
        } while (hr != S_OK);
    } while (hr != S_OK);

    if (pptszName != NULL && dwRet == NO_ERROR)
    {
        int cch = lstrlen(FindData.cFileName);

#if defined(ENUM_SUBDIRS)
        //
        // special case: the initial DirStack element is "." so that the
        // job scheduler folder is searched first before decending into
        // subdirs - don't add ".\" as a dir to the path
        //
        if (m_tszCurDir[0] == TEXT('.'))
        {
#endif // ENUM_SUBDIRS

            *pptszName = new TCHAR[cch + 1];
            if (*pptszName == NULL)
            {
                return E_OUTOFMEMORY;
            }

            lstrcpy(*pptszName, FindData.cFileName);

#if defined(ENUM_SUBDIRS)
        }
        else
        {
            cch += lstrlen(m_tszCurDir) + 1;

            *pptszName = new TCHAR[cch + 1];
            if (*pptszName == NULL)
            {
                return E_OUTOFMEMORY;
            }

            lstrcpy(*pptszName, m_tszCurDir);
            lstrcat(*pptszName, TEXT("\\"));
            lstrcat(*pptszName, FindData.cFileName);
        }
#endif // ENUM_SUBDIRS

    }
    m_cFound++;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::CheckFound, private
//
//  Synopsis:   Checks if the found file is a job or queue. If it is a
//              directory, push it onto the dir stack.
//
//  Returns:    S_OK if a job or queue, S_FALSE if not.
//
//  Notes:      The file find functions match on both long and short versions
//              of file names, so all names of the form *.job* will match
//              (a file like foo.jobber will have a short name of foo~1.job).
//              Thus, the returned file names must be checked for an exact
//              extension match.
//-----------------------------------------------------------------------------
HRESULT
CEnumJobs::CheckFound(LPWIN32_FIND_DATA pFindData)
{
    HRESULT hr;

#if defined(ENUM_SUBDIRS)
    if (pFindData->dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
    {
        if (pFindData->cFileName[0] != TEXT('.'))   // don't push '.' and '..'
        {
            hr = PushDir(pFindData->cFileName);
            if (FAILED(hr))
            {
                ERR_OUT("CheckFound: PushDir", hr);
                return hr;
            }
        }
        return S_FALSE;
    }
#endif // ENUM_SUBDIRS

    TCHAR * ptszExt = _tcsrchr(pFindData->cFileName, TEXT('.'));

    if (ptszExt)
    {
        if (lstrcmpi(ptszExt, m_tszJobExt) == 0)
            // || lstrcmpi(ptszExt, m_tszQueExt) == 0
        {
            return S_OK;
        }
    }
    return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IEnumWorkItems::Skip, public
//
//  Synopsis:   Skips the indicated number of jobs in the enumeration
//
//  Arguments:  [cJobs] - the number of jobs to skip
//
//  Returns:    S_OK - skipped requested number of job names
//              S_FALSE - skipped less than requested number of names because
//                        the end of the enumeration sequence was reached.
//              E_INVALIDARG - if cJobs == 0
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CEnumJobs::Skip(ULONG cJobs)
{
    if (cJobs == 0)
    {
        return E_INVALIDARG;
    }

    if (m_fFindOverrun)
    {
        return S_FALSE;
    }
    HRESULT hr = S_OK;

    //
    // skip the requested number
    //
    for (ULONG i = 1; i <= cJobs; i++)
    {
        hr = GetNext(NULL);
        if (hr != S_OK)
        {
            return hr;
        }
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IEnumWorkItems::Reset, public
//
//  Synopsis:   Sets the enumerator back to its original state
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CEnumJobs::Reset(void)
{
    if (m_hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(m_hFind);
        m_hFind = INVALID_HANDLE_VALUE;
    }
    m_fFindOverrun = FALSE;
    m_cFound = 0;
    ClearDirStack();
    m_pdsHead = new DIRSTACK;
    if (m_pdsHead == NULL)
    {
        return E_OUTOFMEMORY;
    }
    lstrcpy(m_pdsHead->tszDir, TEXT("."));
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IEnumWorkItems::Clone, public
//
//  Synopsis:   Creates a copy of the enumerator object with the same state
//
//  Arguments:  [ppEnumJobs] - a place to return a pointer to the enum object
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CEnumJobs::Clone(IEnumWorkItems ** ppEnumJobs)
{
    TRACE(CEnumJobs, Clone);
    HRESULT hr;

    CEnumJobs * pEnumJobs = new CEnumJobs;
    if (pEnumJobs == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto ErrCleanup;
    }

    hr = pEnumJobs->Init(m_ptszFolderPath);
    if (FAILED(hr))
    {
        goto ErrCleanup;
    }

    if (m_cFound > 0)
    {
        hr = pEnumJobs->Skip(m_cFound);
        if (FAILED(hr))
        {
            goto ErrCleanup;
        }
    }

    *ppEnumJobs = pEnumJobs;

    return S_OK;

ErrCleanup:

    delete pEnumJobs;
    *ppEnumJobs = NULL;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::Init, protected
//
//  Synopsis:   Initializes the enumeration
//
//  Returns:    hresults
//
//  Notes:      Initialization is not done during construction since the only
//              way to return ctor errors is to throw an exception.
//-----------------------------------------------------------------------------
HRESULT
CEnumJobs::Init(TCHAR * ptszFolderPath)
{
    TRACE(CEnumJobs, Init);
    if (ptszFolderPath == NULL)
    {
        return E_FAIL;
    }

    m_ptszFolderPath = new TCHAR[lstrlen(ptszFolderPath) + 1];
    if (!m_ptszFolderPath)
    {
        return E_OUTOFMEMORY;
    }
    lstrcpy(m_ptszFolderPath, ptszFolderPath);

    m_pdsHead = new DIRSTACK;
    if (m_pdsHead == NULL)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy(m_pdsHead->tszDir, TEXT("."));
    lstrcpy(m_tszJobExt, TEXT(".") TSZ_JOB);
 // lstrcpy(m_tszQueExt, TEXT(".") g_tszQueueExt);

    m_fInitialized = TRUE;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::CEnumJobs
//
//  Synopsis:   constructor
//
//-----------------------------------------------------------------------------
CEnumJobs::CEnumJobs(void) :
    m_hFind(INVALID_HANDLE_VALUE),
    m_pdsHead(NULL),
    m_ptszFolderPath(NULL),
    m_cFound(0),
    m_fInitialized(FALSE),
    m_fFindOverrun(FALSE),
    m_uRefs(1)
{
    m_tszCurDir[0] = TEXT('\0');
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::~CEnumJobs
//
//  Synopsis:   destructor
//
//-----------------------------------------------------------------------------
CEnumJobs::~CEnumJobs(void)
{
    if (m_hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(m_hFind);
    }

    ClearDirStack();

    if (m_ptszFolderPath)
    {
        delete m_ptszFolderPath;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::PushDir, private
//
//  Synopsis:   Pushes a new directory element on the dir stack. The dir stack
//              stores directory path segments that are rooted relative to the
//              jobs directory.
//
//-----------------------------------------------------------------------------
HRESULT
CEnumJobs::PushDir(LPCTSTR ptszDir)
{
#if defined(ENUM_SUBDIRS)

    PDIRSTACK pdsNode = new DIRSTACK;
    if (pdsNode == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // compose relative path
    // special case: the initial DirStack element is "." so that the
    // job scheduler folder is searched first before decending into
    // subdirs - don't add ".\" as a dir to the path
    //
    if (m_tszCurDir[0] == TEXT('.'))
    {
        lstrcpy(pdsNode->tszDir, ptszDir);
    }
    else
    {
        lstrcpy(pdsNode->tszDir, m_tszCurDir);
        lstrcat(pdsNode->tszDir, TEXT("\\"));
        lstrcat(pdsNode->tszDir, ptszDir);
    }

    pdsNode->pdsNext = m_pdsHead;
    m_pdsHead = pdsNode;

#endif // ENUM_SUBDIRS

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::PopDir, private
//
//  Synopsis:   Pops the head element off of the dir stack.
//
//-----------------------------------------------------------------------------
HRESULT
CEnumJobs::PopDir(LPTSTR ptszDir)
{
    if (m_pdsHead == NULL)
    {
        return S_FALSE;
    }
    lstrcpy(ptszDir, m_pdsHead->tszDir);
    PDIRSTACK pdsNode = m_pdsHead->pdsNext;
    delete m_pdsHead;
    m_pdsHead = pdsNode;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::ClearDirStack, private
//
//  Synopsis:   free the stack element memory
//
//-----------------------------------------------------------------------------
void
CEnumJobs::ClearDirStack(void)
{
    if (m_pdsHead != NULL)
    {
        PDIRSTACK pdsNode, pdsNextNode;
        pdsNode = m_pdsHead;
        do
        {
            pdsNextNode = pdsNode->pdsNext;
            delete pdsNode;
            pdsNode = pdsNextNode;
        } while (pdsNode);
        m_pdsHead = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   FreeStrings
//
//  Synopsis:   Frees the strings contained in the array and then the array
//              itself.
//
//  Arguments:  [rgpwszNames] - the array of strings.
//              [n]           - the array size.
//
//-----------------------------------------------------------------------------
void
FreeStrings(LPWSTR * rgpwszNames, int n)
{
    for (int i = 0; i < n; i++)
    {
        CoTaskMemFree(rgpwszNames[i]);
    }
    CoTaskMemFree(rgpwszNames);
}

//+----------------------------------------------------------------------------
//
//      CEnumJobs IUnknown methods
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CEnumJobs::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)(IEnumWorkItems *)this;
    }
    else if (IID_IEnumWorkItems == riid)
    {
        *ppvObject = (IUnknown *)(IEnumWorkItems *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CEnumJobs::AddRef(void)
{
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CEnumJobs::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CEnumJobs::Release(void)
{
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

// BUGBUG: need a class factory if the interface is going to be exposed to OA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\shellex.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       ShellEx.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"

#include "dll.hxx"
#include "..\folderui\jobicons.hxx"
#include "..\folderui\util.hxx"
#include "schedui.hxx"


extern "C" const GUID IID_IShellExtInit;
extern "C" const GUID IID_IShellPropSheetExt;


TCHAR const c_szTask[] = TEXT("task!");


class CSchedObjExt : public IShellExtInit,
                   //public IContextMenu,
                     public IShellPropSheetExt
{
public:
    CSchedObjExt();
    ~CSchedObjExt();

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IShellExtInit methods
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdtobj,
                                                            HKEY hkeyProgID);

    // IShellPropSheetExt methods
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID,
                        LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

private:
    CDllRef         m_DllRef;
    LPDATAOBJECT    m_pdtobj;            // data object
    HKEY            m_hkeyProgID;        // reg. database key to ProgID

}; // CSchedObjExt


inline
CSchedObjExt::CSchedObjExt()
    :
    m_ulRefs(1),
    m_pdtobj(NULL),
    m_hkeyProgID(NULL)
{
    TRACE(CSchedObjExt, CSchedObjExt);
}


CSchedObjExt::~CSchedObjExt()
{
    TRACE(CSchedObjExt, ~CSchedObjExt);

    if (m_pdtobj)
    {
        m_pdtobj->Release();
    }

    if (m_hkeyProgID)
    {
        RegCloseKey(m_hkeyProgID);
    }
}

//
// IUnknown implementation
//
IMPLEMENT_STANDARD_IUNKNOWN(CSchedObjExt);


STDMETHODIMP
CSchedObjExt::QueryInterface(REFIID riid, void **ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    HRESULT hr = S_OK;

    if (ppvObject == NULL)
    {
        return(E_INVALIDARG);
    }

    *ppvObject = NULL;                      // in case of error.

    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IShellExtInit, riid))
    {
        pUnkTemp = (IUnknown *)(IShellExtInit *)this;
    }
    else  if (IsEqualIID(IID_IShellPropSheetExt, riid))
    {
        pUnkTemp = (IUnknown *)(IShellPropSheetExt *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if ((pUnkTemp != NULL) && (SUCCEEDED(hr)))
    {
        *ppvObject = (void*)pUnkTemp;
        pUnkTemp->AddRef();
    }

    return(hr);
}


//____________________________________________________________________________
//
//  Member:     CSchedObjExt::Initialize
//
//  Synopsis:   S
//
//  Arguments:  [pidlFolder] -- IN
//              [pdtobj] -- IN
//              [hkeyProgID] -- IN
//
//  Returns:    HRESULT.
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CSchedObjExt::Initialize(
    LPCITEMIDLIST   pidlFolder,
    LPDATAOBJECT    pdtobj,
    HKEY            hkeyProgID)
{
    TRACE(CSchedObjExt, Initialize);

    // Initialize can be called more than once.
    if (m_pdtobj)
    {
        m_pdtobj->Release();
    }

    if (m_hkeyProgID)
    {
        RegCloseKey(m_hkeyProgID);
        m_hkeyProgID = NULL;
    }

    // Duplicate the pdtobj pointer
    m_pdtobj = pdtobj;

    if (pdtobj)
    {
        pdtobj->AddRef();
    }

    // Duplicate the handle
    if (hkeyProgID)
    {
        RegOpenKeyEx(hkeyProgID, NULL, 0, KEY_ALL_ACCESS, &m_hkeyProgID);
    }

    return S_OK;
}





//+-------------------------------------------------------------------------
//
//  Member:     CSchedObjExt::IShellPropSheetExt::AddPages
//
//  Synopsis:   (from shlobj.h)
//              "The explorer calls this member function when it finds a
//              registered property sheet extension for a particular type
//              of object. For each additional page, the extension creates
//              a page object by calling CreatePropertySheetPage API and
//              calls lpfnAddPage.
//
//  Arguments:  lpfnAddPage -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  Returns:
//
//  History:    12-Oct-94 RaviR
//
//--------------------------------------------------------------------------

STDMETHODIMP
CSchedObjExt::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam)
{
    TRACE(CSchedObjExt, AddPages);

    //
    // Call IDataObject::GetData asking for a CF_HDROP (i.e., HDROP).
    //

    HRESULT   hr = S_OK;
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, (DVTARGETDEVICE *)NULL, DVASPECT_CONTENT,
                                                        -1, TYMED_HGLOBAL };

    hr = m_pdtobj->GetData(&fmte, &medium);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        return hr;
    }

    do
    {
        //
        //  Ensure it is only a single selection.
        //

        UINT cObjects = DragQueryFile((HDROP)medium.hGlobal,
                                                (UINT)-1, NULL, 0);
        if (cObjects != 1)
        {
            hr = S_FALSE;
            break;
        }

        //
        // Create shared info for all pages
        //

        TCHAR szFile[MAX_PATH + 1];
        UINT cchRet = DragQueryFile((HDROP)medium.hGlobal, 0, szFile,
                                                         ARRAYLEN(szFile));

        //
        // Bind to the ITask interface.
        //

        ITask * pIJob = NULL;

        hr = JFCreateAndLoadTask(NULL, szFile, &pIJob);

        BREAK_ON_FAIL(hr);

        // Add the tasks page
        hr = AddGeneralPage(lpfnAddPage, lParam, pIJob);
        CHECK_HRESULT(hr);

        // Add the schedule page
        hr = AddSchedulePage(lpfnAddPage, lParam, pIJob);
        CHECK_HRESULT(hr);

        // Add the settings page
        hr = AddSettingsPage(lpfnAddPage, lParam, pIJob);
        CHECK_HRESULT(hr);

        pIJob->Release();

    } while (0);

    ReleaseStgMedium(&medium);

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:     CSchedObjExt::IShellPropSheetExt::ReplacePages
//
//  Synopsis:   (From shlobj.h)
//              "The explorer never calls this member of property sheet
//              extensions. The explorer calls this member of control panel
//              extensions, so that they can replace some of default control
//              panel pages (such as a page of mouse control panel)."
//
//  Arguments:  uPageID -- Specifies the page to be replaced.
//              lpfnReplace -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  Returns:
//
//  History:    12-Oct-94 RaviR
//
//--------------------------------------------------------------------------

STDMETHODIMP
CSchedObjExt::ReplacePage(
    UINT            uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM          lParam)
{
    TRACE(CSchedObjExt, ReplacePage);

    Win4Assert(!"CSchedObjExt::ReplacePage called, not implemented");
    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////

//____________________________________________________________________________
//
//  Function:   JFGetSchedObjExt
//
//  Synopsis:   Create an instance of CSchedObjExt and return the requested
//              interface.
//
//  Arguments:  [riid] -- IN interface needed.
//              [ppvObj] -- OUT place to store the interface.
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
JFGetSchedObjExt(
    REFIID riid,
    LPVOID* ppvObj)
{
    CSchedObjExt * pSchedObjExt = new CSchedObjExt();

    HRESULT hr = S_OK;

    if (pSchedObjExt != NULL)
    {
        hr = pSchedObjExt->QueryInterface(riid, ppvObj);

        CHECK_HRESULT(hr);

        pSchedObjExt->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
    }

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CTaskIconExt : public IExtractIcon,
                     public IPersistFile
{
public:
    CTaskIconExt(void);
    ~CTaskIconExt(void);

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IExtractIcon methods
    STDMETHOD(GetIconLocation)(UINT uFlags, LPTSTR szIconFile, UINT cchMax,
                                int *piIndex, UINT *pwFlags);
    STDMETHOD(Extract)(LPCTSTR pszFile, UINT nIconIndex, HICON *phiconLarge,
                                HICON *phiconSmall, UINT nIconSize);

    // IPersistFile methods
    STDMETHOD(GetClassID)(LPCLSID lpClsID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(LPCOLESTR pszFile, DWORD grfMode);
    STDMETHOD(Save)(LPCOLESTR pszFile, BOOL fRemember);
    STDMETHOD(SaveCompleted)(LPCOLESTR pszFile);
    STDMETHOD(GetCurFile)(LPOLESTR FAR *ppszFile);

private:
    TCHAR       m_szTask[MAX_PATH + 1];

}; // CTaskIconExt


inline
CTaskIconExt::CTaskIconExt(void)
    :
    m_ulRefs(1)
{
    TRACE(CTaskIconExt, CTaskIconExt);

    m_szTask[0] = TEXT('\0');
}

inline
CTaskIconExt::~CTaskIconExt(void)
{
    TRACE(CTaskIconExt, ~CTaskIconExt);
}

//
// IUnknown implementation
//
IMPLEMENT_STANDARD_IUNKNOWN(CTaskIconExt);

STDMETHODIMP
CTaskIconExt::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IPersistFile, riid))
    {
        *ppvObj = (IUnknown*)(IPersistFile*) this;
    }
    else if (IsEqualIID(IID_IExtractIcon, riid))
    {
        *ppvObj = (IUnknown*)(IExtractIcon*) this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr))
    {
        this->AddRef();
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CTaskIconExt::IExtractIcon::GetIconLocation
//
//  Arguments:  [uFlags] -- IN
//              [szIconFile] -- IN
//              [cchMax] -- IN
//              [piIndex] -- IN
//              [pwFlags] -- IN
//
//  Returns:    HTRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CTaskIconExt::GetIconLocation(
    UINT    uFlags,
    LPTSTR  szIconFile,
    UINT    cchMax,
    int   * piIndex,
    UINT  * pwFlags)
{
    TRACE(CTaskIconExt, GetIconLocation);

    if (uFlags & GIL_OPENICON)
    {
        return S_FALSE;
    }

    *pwFlags = GIL_NOTFILENAME | GIL_PERINSTANCE;

    HRESULT hr = S_OK;
    UINT    len = lstrlen(c_szTask);

    lstrcpy(szIconFile, c_szTask);

    hr = JFGetAppNameForTask(m_szTask, &szIconFile[len], cchMax - len);

    *piIndex = FALSE;

    return hr;
}



//____________________________________________________________________________
//
//  Member:     CTaskIconExt::Extract
//
//  Arguments:  [pszFile] -- IN
//              [nIconIndex] -- IN
//              [phiconLarge] -- IN
//              [phiconSmall] -- IN
//              [nIconSize] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/5/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CTaskIconExt::Extract(
    LPCTSTR pszFile,
    UINT    nIconIndex,
    HICON * phiconLarge,
    HICON * phiconSmall,
    UINT    nIconSize)
{
    TRACE(CTaskIconExt, Extract);

    LPTSTR pszApp = (LPTSTR)(pszFile + lstrlen(c_szTask));

    CJobIcon ji;

    ji.GetIcons(pszApp, FALSE, phiconLarge, phiconSmall);

    return S_OK;
}


//____________________________________________________________________________
//
//  Member:     CTaskIconExt::Load
//
//  Synopsis:   S
//
//  Arguments:  [pszFile] -- IN
//              [grfMode] -- IN
//
//  Returns:    HRESULT.
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CTaskIconExt::Load(
    LPCOLESTR pszFile,
    DWORD grfMode)
{
    TRACE(CTaskIconExt, Load);

#ifdef UNICODE
    lstrcpy(m_szTask, pszFile);
#else
    UnicodeToAnsi(m_szTask, pszFile, MAX_PATH+1);
#endif

    return S_OK;
}


// The following functions, which are part of the OLE IPersistFile interface,
// are not required for shell extensions. In the unlikely event that they are
// called, they return the error code E_FAIL.
//

STDMETHODIMP CTaskIconExt::GetClassID(LPCLSID lpClsID)
{
    return E_FAIL;
}

STDMETHODIMP CTaskIconExt::IsDirty()
{
    return E_FAIL;
}

STDMETHODIMP CTaskIconExt::Save(LPCOLESTR pszFile, BOOL fRemember)
{
    return E_FAIL;
}

STDMETHODIMP CTaskIconExt::SaveCompleted(LPCOLESTR pszFile)
{
    return E_FAIL;
}

STDMETHODIMP CTaskIconExt::GetCurFile(LPOLESTR FAR *ppszFile)
{
    return E_FAIL;
}


//____________________________________________________________________________
//
//  Function:   JFGetTaskIconExt
//
//  Synopsis:   Create an instance of CTaskIconExt and return the requested
//              interface.
//
//  Arguments:  [riid] -- IN interface needed.
//              [ppvObj] -- OUT place to store the interface.
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
JFGetTaskIconExt(
    REFIID riid,
    LPVOID* ppvObj)
{
    TRACE_FUNCTION(JFGetTaskIconExt);

    CTaskIconExt * pTaskIconExt = new CTaskIconExt();

    HRESULT hr = S_OK;

    if (pTaskIconExt != NULL)
    {
        hr = pTaskIconExt->QueryInterface(riid, ppvObj);

        CHECK_HRESULT(hr);

        pTaskIconExt->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedule\sch_at.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sch_at.cxx
//
//  Contents:   scheduler class object methods to support the NetSchedule
//              (AT) APIs.
//
//  Classes:    CSchedule
//
//  History:    30-Jan-96 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "Sched.hxx"

//
// Nothing here is needed for Chicago version since there is no AT support
// there.
//

#if !defined(_CHICAGO_)

//
// Forward references
//


VOID
SetDomTrigger2Days(
    DWORD dwDaysOfMonth,
    WORD wFirstDayToCheck,
    WORD wLastDayToCheck,
    SYSTEMTIME *pstStart2,
    SYSTEMTIME *pstEnd2);


HRESULT
CSchedule::AddAtJobCommon(
    const AT_INFO &At,
    DWORD         *pID,
    CJob          **ppJob,
    WCHAR         wszName[],
    WCHAR         wszID[]
    )
{
    HRESULT  hr = S_OK;

    //
    // If the next at id is > 1 but there aren't any at jobs, the id can be
    // reset to 1.
    //

    if (m_dwNextID > 1 && S_FALSE == _AtTaskExists())
    {
        ResetAtID();
    }

    //
    // Compose a name for the new AT job.
    //
    wcscpy(wszName, m_ptszFolderPath);
    wcscat(wszName, L"\\" TSZ_AT_JOB_PREFIX);
    _itow(m_dwNextID, wszID, 10);
    wcscat(wszName, wszID);
    wcscat(wszName, L"." TSZ_JOB);
    //
    // Create a new job
    //
    CJob * pJob = CJob::Create();
    if (pJob == NULL)
    {
        ERR_OUT("CSchedule::AddAtJob: CJob::Create", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    //
    // Convert the AT command line.
    //
    WCHAR * pwszApp, * pwszParams, wszCommand[MAX_PATH];

    //
    // net\svcdlls\atcmd\atcmd.c defines MAX_COMMAND_LEN to be 128. This
    // should at some point be changed to MAX_PATH.
    //
    wcscpy(wszCommand, At.Command);

    pwszApp = wszCommand;

    //
    // The app name and any command line params are all passed in one string,
    // At.Command, so separate the app name from the params. Any path to the
    // app plus the app name may be quoted. Otherwise, the parameters are
    // separated from the app name by white space.
    //
    if (*pwszApp == L'"')
    {
        //
        // Initial quote found, scan for end quote. The app name passed to
        // SetApplicationName should not be quoted.
        //
        pwszApp++;
        pwszParams = pwszApp + 1;
        while (TRUE)
        {
            if (*pwszParams == L'\0')
            {
                //
                // End of string found, no params.
                //
                pwszParams = NULL;
                break;
            }
            if (*pwszParams == L'"')
            {
                //
                // End quote found.
                //
                break;
            }
            pwszParams++;
        }
    }
    else
    {
        //
        // App path/name not quoted, scan for first white space for parameters.
        //
        pwszParams = wcspbrk(pwszApp, L" \t");
    }

    if (pwszParams != NULL)
    {
        // Null terminate app name string.
        //
        *pwszParams = L'\0';
        //
        // Move to first char of the parameters.
        //
        pwszParams++;
        //
        // Skip any leading white space.
        //
        while (*pwszParams != L'\0')
        {
            if (*pwszParams != L' ' && *pwszParams != L'\t')
            {
                break;
            }
            pwszParams++;
        }

        if (*pwszParams == L'\0')
        {
            //
            // No params.
            //
            pwszParams = NULL;
        }
    }

    hr = pJob->SetApplicationName(pwszApp);
    if (FAILED(hr))
    {
        ERR_OUT("AddAtJob: SetApplicationName", hr);
        pJob->Release();
        return hr;
    }
    if (pwszParams != NULL)
    {
        hr = pJob->SetParameters(pwszParams);
        if (FAILED(hr))
        {
            ERR_OUT("AddAtJob: SetParameters", hr);
            pJob->Release();
            return hr;
        }
    }

    pJob->m_rgFlags |= JOB_I_FLAG_NET_SCHEDULE | TASK_FLAG_DELETE_WHEN_DONE;

    if (!(At.Flags & JOB_NONINTERACTIVE))
    {
        pJob->m_rgFlags |= TASK_FLAG_INTERACTIVE;
    }

    pJob->m_hrStatus = SCHED_S_TASK_READY;

    WCHAR szComment[SCH_BUF_LEN + 1];
    if (LoadString(g_hInstance,
                   IDS_NETSCHED_COMMENT,
                   szComment,
                   SCH_BUF_LEN) > 0)
    {
        pJob->SetComment(szComment);
    }

    //
    // Convert from NetSchedule representation to Job Scheduler representation
    // of the run dates and times.
    //

    SYSTEMTIME stNow, stStart;
    SYSTEMTIME stDomStart1, stDomEnd1, stDomStart2, stDomEnd2;
    SYSTEMTIME stDowStart, stDowEnd;

    stDomStart2.wDay = 0;  // this serves as a flag
    GetLocalTime(&stNow);
    stStart = stNow;

    //
    // JobTime is expressed as milliseconds after midnight, so convert to
    // minutes.
    //
    DWORD dwMins = (DWORD)(At.JobTime / JOB_MILLISECONDS_PER_MINUTE);

    stStart.wHour = (WORD)(dwMins / JOB_MINS_PER_HOUR);
    stStart.wMinute = (WORD)(dwMins % JOB_MINS_PER_HOUR);
    stStart.wSecond = stStart.wMilliseconds = 0;

    DWORD DaysOfMonth = At.DaysOfMonth;

    WORD wFirstDowRunOffset = 0, wFirstDomRunOffset = 0;

    TASK_TRIGGER Trigger;

    if (At.Flags & JOB_ADD_CURRENT_DATE)
    {
        //
        // The flag is set, so add today as the first run date.
        //
        DaysOfMonth |= 1 << (stStart.wDay - 1);
    }
    else
    {
        if (DaysOfMonth == 0 && At.DaysOfWeek == 0)
        {
            //
            // Neither bitmask is set, so run at the next opportunity.
            //

            Trigger.TriggerType = TASK_TIME_TRIGGER_ONCE;

            if (! IsFirstTimeEarlier(&stNow, &stStart))
            {
                // Job runs tomorrow
                IncrementDay(&stStart);
            }
        }
    }

    //
    // Set the trigger values and save the new trigger(s).
    //
    // Initialize the start and end dates in case this is a periodic trigger.
    // If it is not periodic, then new start and end dates will overwrite
    // these initialization values.
    //

    Trigger.cbTriggerSize = sizeof(TASK_TRIGGER);
    Trigger.Reserved1 = pJob->m_Triggers.GetCount();
    Trigger.wBeginYear = stStart.wYear;
    Trigger.wBeginMonth = stStart.wMonth;
    Trigger.wBeginDay = stStart.wDay;
    Trigger.wEndYear = 0;
    Trigger.wEndMonth = 0;
    Trigger.wEndDay = 0;
    Trigger.wStartHour = stStart.wHour;
    Trigger.wStartMinute = stStart.wMinute;
    Trigger.Reserved2 = 0;
    Trigger.wRandomMinutesInterval = 0;

    Trigger.rgFlags = (At.Flags & JOB_RUN_PERIODICALLY)
                      ? 0 : TASK_TRIGGER_FLAG_HAS_END_DATE;

    Trigger.MinutesInterval = Trigger.MinutesDuration = 0;

    if (DaysOfMonth == 0 && At.DaysOfWeek == 0)
    {
       // First, zero out the end date flag
       Trigger.rgFlags &= ~JOB_RUN_PERIODICALLY;

       // This is a TASK_TIME_TRIGGER_ONCE job, and we are ready to commit
       hr = pJob->m_Triggers.Add(Trigger);
       if (FAILED(hr))
       {
           ERR_OUT("AddAtJob: m_Triggers.Add Once", hr);
           pJob->Release();
           return hr;
       }
    }

    if (DaysOfMonth > 0)
    {
        Trigger.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
        Trigger.Type.MonthlyDate.rgfDays = DaysOfMonth;
        Trigger.Type.MonthlyDate.rgfMonths = JOB_RGFMONTHS_MAX;

        if (!(At.Flags & JOB_RUN_PERIODICALLY))
        {
            CalcDomTriggerDates(DaysOfMonth,
                                stNow,
                                stStart,
                                &stDomStart1,
                                &stDomEnd1,
                                &stDomStart2,
                                &stDomEnd2);

            Trigger.wBeginYear = stDomStart1.wYear;
            Trigger.wBeginMonth = stDomStart1.wMonth;
            Trigger.wBeginDay = stDomStart1.wDay;
            Trigger.wEndYear = stDomEnd1.wYear;
            Trigger.wEndMonth = stDomEnd1.wMonth;
            Trigger.wEndDay = stDomEnd1.wDay;
        }

        hr = pJob->m_Triggers.Add(Trigger);
        if (FAILED(hr))
        {
            ERR_OUT("AddAtJob: m_Triggers.Add Dom1", hr);
            pJob->Release();
            return hr;
        }

        if (stDomStart2.wDay != 0)
        {
            Trigger.wBeginYear = stDomStart2.wYear;
            Trigger.wBeginMonth = stDomStart2.wMonth;
            Trigger.wBeginDay = stDomStart2.wDay;
            Trigger.wEndYear = stDomEnd2.wYear;
            Trigger.wEndMonth = stDomEnd2.wMonth;
            Trigger.wEndDay = stDomEnd2.wDay;

            Trigger.Reserved1 = pJob->m_Triggers.GetCount();
            hr = pJob->m_Triggers.Add(Trigger);
            if (FAILED(hr))
            {
                ERR_OUT("AddAtJob: m_Triggers.Add Dom2", hr);
                pJob->Release();
                return hr;
            }
        }
    }

    if (At.DaysOfWeek > 0)
    {
        Trigger.Reserved1 = pJob->m_Triggers.GetCount();
        Trigger.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
        Trigger.Type.Weekly.WeeksInterval = 1;
        //
        // Convert AT_INFO DOW to Scheduler DOW:
        // Scheduler rgfDaysOfTheWeek: Sunday = bit 0, Monday = bit 1.
        // AT_INFO DaysOfWeek: Monday = bit 0, Sunday = bit 6.
        //
        Trigger.Type.Weekly.rgfDaysOfTheWeek = At.DaysOfWeek << 1;
        if (Trigger.Type.Weekly.rgfDaysOfTheWeek & 0x0080)
        {
            Trigger.Type.Weekly.rgfDaysOfTheWeek &= ~0x0080;
            Trigger.Type.Weekly.rgfDaysOfTheWeek |= 1;
        }

        if (!(At.Flags & JOB_RUN_PERIODICALLY))
        {
            CalcDowTriggerDate(stNow,
                               stStart,
                               &stDowStart,
                               &stDowEnd);

            Trigger.wBeginYear = stDowStart.wYear;
            Trigger.wBeginMonth = stDowStart.wMonth;
            Trigger.wBeginDay = stDowStart.wDay;
            Trigger.wEndYear = stDowEnd.wYear;
            Trigger.wEndMonth = stDowEnd.wMonth;
            Trigger.wEndDay = stDowEnd.wDay;
        }

        hr = pJob->m_Triggers.Add(Trigger);
        if (FAILED(hr))
        {
            ERR_OUT("AddAtJob: m_Triggers.Add", hr);
            pJob->Release();
            return hr;
        }
    }

    // get the AT task maximum run time from the registry
    // if the call fails, the default of 72 will be used
    DWORD dwMaxRunTime = 0;
    if (SUCCEEDED(GetAtTaskMaxHours(&dwMaxRunTime)))
        pJob->SetMaxRunTime(dwMaxRunTime);

    //
    // Set the same flags as in CJob::CreateTrigger.  (We should really call
    // CreateTrigger in this function instead of creating the trigger ourselves.)
    //
    pJob->SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    pJob->SetTriggersDirty();

    //
    // Save the new job.  Obviously this is one place we definitely don't want
    // the AT job flag cleared on save!
    //
    hr = pJob->SaveP(wszName,
                     TRUE,
                     SAVEP_VARIABLE_LENGTH_DATA |
                        SAVEP_PRESERVE_NET_SCHEDULE);

    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS))
        {
            //
            // Name collision; someone has renamed a task to match the next
            // AT job. Recalc the max AT job ID.
            //
            GetNextAtID(&m_dwNextID);
            wcscpy(wszName, m_ptszFolderPath);
            wcscat(wszName, L"\\" TSZ_AT_JOB_PREFIX);
            _itow(m_dwNextID, wszID, 10);
            wcscat(wszName, wszID);
            wcscat(wszName, TSZ_DOTJOB);

            //
            // Now, retry the save.
            //
            hr = pJob->SaveP(wszName,
                             TRUE,
                             SAVEP_VARIABLE_LENGTH_DATA |
                                SAVEP_PRESERVE_NET_SCHEDULE);
            if (FAILED(hr))
            {
                ERR_OUT("CSchedule::AddAtJob: Save", hr);
                pJob->Release();
                return hr;
            }
        }
        else
        {
            ERR_OUT("CSchedule::AddAtJob: Save", hr);
            pJob->Release();
            return hr;
        }
    }

    *ppJob = pJob;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::GetAtTaskMaxHours
//
//  Synopsis:   Check a registry setting to see what max run time value a user 
//				has specified for AT tasks.  If the key is not present or can't
//				be opened then interpret as the normal task default of 72.
//
//  Arguments:  none
//
//  Returns:    bool
//
//  Notes:      This method is not exposed to external clients, thus it is not
//              part of a public interface.
//-----------------------------------------------------------------------------
HRESULT CSchedule::GetAtTaskMaxHours(DWORD* pdwMaxHours)
{
    //
    // Open the schedule service key
    //
    long lErr;
    HKEY hSchedKey;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_SVC_KEY, 0, KEY_READ | KEY_WRITE, &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
        return(HRESULT_FROM_WIN32(lErr));
    }

    //
    // Get the AtTaskMaxHours setting
    //
	bool bNeedToUpdate = false;
	DWORD dwMaxHours = 0;
    DWORD cb = sizeof(DWORD);
    lErr = RegQueryValueEx(hSchedKey, SCH_ATTASKMAXHOURS_VALUE, NULL, NULL, (LPBYTE)&dwMaxHours, &cb);
    if (lErr != ERROR_SUCCESS)
    {
        if (lErr != ERROR_FILE_NOT_FOUND)
        {
            ERR_OUT("Read of AtTaskMaxHours registry value", lErr);
            RegCloseKey(hSchedKey);
            return(HRESULT_FROM_WIN32(lErr));
        }

        //
        // Need to create the missing registry entry
        //
		dwMaxHours = DEFAULT_MAXRUNTIME_HOURS;
		bNeedToUpdate = true;
    }

	//
	// Correct out-of-bounds stored registry values
	//
	if (dwMaxHours > 999)
	{
		dwMaxHours = 999;
		bNeedToUpdate = true;
	}

	if (bNeedToUpdate)
	{
        lErr = RegSetValueEx(hSchedKey, SCH_ATTASKMAXHOURS_VALUE, 0, REG_DWORD,(CONST BYTE *)&dwMaxHours, sizeof(DWORD));
        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("Update of AtTaskMaxHours registry value", lErr);
            RegCloseKey(hSchedKey);
            return(HRESULT_FROM_WIN32(lErr));
        }
	}

	//
	// Convert the stored value to a value that has meaning to the scheduler
	//
	if (!dwMaxHours)
		dwMaxHours = INFINITE;	// If value is zero, return infinite (-1) for max run time
	else
		dwMaxHours *= 3600000;	// The stored value is in hours, but the value passed back
								// needs to be in milliseconds, so convert

    RegCloseKey(hSchedKey);

	// Set the value to be passed back
	*pdwMaxHours = dwMaxHours;

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::AddAtJob
//
//  Synopsis:   create a downlevel job
//
//  Arguments:  [At]  - reference to an AT_INFO struct
//              [pID] - returns the new ID (optional, can be NULL)
//
//  Returns:    HRESULTS
//
//  Notes:      This method is not exposed to external clients, thus it is not
//              part of a public interface.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::AddAtJob(const AT_INFO &At, DWORD * pID)
{
    TRACE(CSchedule, AddAtJob);
    HRESULT hr = S_OK;
    CJob *pJob;
    WCHAR wszName[MAX_PATH + 1];
    WCHAR wszID[SCH_SMBUF_LEN];

    hr = AddAtJobCommon(At, pID, &pJob, wszName, wszID);

    if (FAILED(hr))
    {
        ERR_OUT("AddAtJob: AddAtJobCommon", hr);
        return hr;
    }

    //
    // Free the job object.
    //
    pJob->Release();

    //
    // Return the new job's ID and increment the ID counter
    //
    if (pID != NULL)
    {
        *pID = m_dwNextID;
    }

    hr = IncrementAndSaveID();

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   IsMonthBitSet
//
//  Synopsis:   Returns nonzero if 1-based bit [wDay] in [dwDaysOfMonth] is
//              set.
//
//  History:    09-26-96   DavidMun   Created
//
//----------------------------------------------------------------------------

inline BOOL
IsMonthBitSet(DWORD dwDaysOfMonth, WORD wDay)
{
    return dwDaysOfMonth & (1 << (wDay - 1));
}




//+---------------------------------------------------------------------------
//
//  Function:   CalcDomTriggerDates
//
//  Synopsis:   Calculate the dates for the start and end of the Day Of Month
//              trigger(s).
//
//  Arguments:  [dwDaysOfMonth] - bit array, bit 0=day 1, etc.  At least one
//                                  bit must be set!
//              [stNow]         - current time
//              [stStart]       - same as [stNow] but has hour & minute
//                                  values of actual job run time
//              [pstStart1]     - filled with start date of first trigger
//              [pstEnd1]       - filled with end date of first trigger
//              [pstStart2]     - filled with start date of second trigger;
//                                  wDay is 0 if second trigger not needed
//              [pstEnd2]       - filled with end date of second trigger,
//                                  wDay is 0 if second trigger not needed
//
//  Modifies:   All output arguments.
//
//  History:    09-26-96   DavidMun   Created
//
//  Notes:      Only the month, day, and year values in the output structs
//              are used.
//
//----------------------------------------------------------------------------

VOID
CalcDomTriggerDates(
          DWORD       dwDaysOfMonth,
    const SYSTEMTIME &stNow,
    const SYSTEMTIME &stStart,
          SYSTEMTIME *pstStart1,
          SYSTEMTIME *pstEnd1,
          SYSTEMTIME *pstStart2,
          SYSTEMTIME *pstEnd2)
{
    BOOL fDone = FALSE;
    WORD wStart1MonthDays;

    // assert not all bits below 32 are zero
    Win4Assert(dwDaysOfMonth & JOB_RGFDAYS_MAX);

    //
    // Find the start date for the first DOM trigger.
    //

    *pstStart1 = stNow;

    if (IsFirstTimeEarlier(&stStart, &stNow))
    {
        // already past run time today

        IncrementDay(pstStart1);
    }

    HRESULT hr = MonthDays(pstStart1->wMonth, pstStart1->wYear, &wStart1MonthDays);
    if (FAILED(hr))
    {
        schAssert(!"Bad systemtime");
        return;
    }

    do
    {
        while (!IsMonthBitSet(dwDaysOfMonth, pstStart1->wDay) &&
                pstStart1->wDay <= wStart1MonthDays)
        {
           pstStart1->wDay++;
        }

        //
        // now either:
        // start1.wDay > wStart1MonthDays or
        // bit at start1.wDay is 1
        //

        if (pstStart1->wDay > wStart1MonthDays)
        {
            // have to go on to next month to get the first start date

            pstStart1->wDay = 1;
            IncrementMonth(pstStart1);
            MonthDays(pstStart1->wMonth, pstStart1->wYear, &wStart1MonthDays);
        }
        else
        {
            fDone = TRUE;
        }
    } while (!fDone);


    //
    // Now bit at pstStart1->wDay is on, and pstStart1->wDay is a valid day in
    // pstStart1->wMonth, and wStart1MonthDays is the number of days in the
    // month pstStart1->wMonth.  Next we need to find end1.
    //
    // end1 is initialized to start1.
    //
    // If there are any days set before the start day, then end1.wMonth will
    // be start1.wMonth + 1, and end1.wDay will be the last of the days that
    // is set before start1.wDay, with the restriction that end1.wDay is not
    // greater than the number of days in end1.wMonth.
    //

    *pstEnd1 = *pstStart1;
    WORD wDay;

    if (pstStart1->wDay > 1)
    {
        WORD wEnd1Month;
        WORD wEnd1MonthDays;

        wEnd1Month = pstEnd1->wMonth + 1;

        if (wEnd1Month > 12)
        {
            wEnd1Month = 1;
        }

        MonthDays(wEnd1Month, pstEnd1->wYear, &wEnd1MonthDays);
        WORD wMaxDay = min(pstStart1->wDay - 1, wEnd1MonthDays);

        for (wDay = 1; wDay <= wMaxDay; wDay++)
        {
            if (IsMonthBitSet(dwDaysOfMonth, wDay))
            {
                pstEnd1->wDay = wDay;
            }
        }
    }

    //
    // If any day bits were set before start1.wDay then end1.wDay will no
    // longer == start1.wDay, and end1 will be referring to the next month.
    //
    // Otherwise, End1 will remain in the same month as Start1, but will
    // need to be set to the last day bit set in the Start1 month.
    //

    if (pstEnd1->wDay < pstStart1->wDay)
    {
        IncrementMonth(pstEnd1);
    }
    else
    {
        for (wDay = pstStart1->wDay + 1; wDay <= wStart1MonthDays; wDay++)
        {
            if (IsMonthBitSet(dwDaysOfMonth, wDay))
            {
                pstEnd1->wDay = wDay;
            }
        }
    }

    //
    // Now start1 and end1 are set.  next, check if there's a need for the
    // second trigger.  There are two cases where a second trigger is
    // required.
    //
    // Case a: second trigger must fill time between end of first trigger
    // and start of first trigger.  for example, job is to run on next
    // 1, 30, 31 and start1 is 1/31.  then end1 will be 2/1, and a second
    // trigger must go from 3/30 to 3/30.   Note this case can only occur
    // if End1.wMonth == February.
    //
    // Case b: second trigger must fill time somewhere in the 29-31 day range.
    // For example, job is to run on next 1-31, and current day is 4/1.  so
    // start1 is 4/1, end1 is 4/30, then start2 must be 5/31 to 5/31.
    //
    // As another example, job is to run on next 27, 28, 30, current day is
    // 2/28.  then start1 is 2/28, end1 is 3/27, start2 is 3/30, end2 is 3/30.
    //
    // Case b only occurs when there are bits set for days beyond the last day
    // of pstStart1->wmonth.
    //
    //

    //
    // test if we need case a.
    //

    if (pstEnd1->wMonth == 2 &&
        pstStart1->wDay > 29 &&
        pstEnd1->wDay < pstStart1->wDay - 1)
    {
        //
        // There's a gap between end1 and start1.  we need the second trigger
        // if there are any day bits set in that gap.
        //

        Win4Assert(pstStart1->wMonth == 1);
        Win4Assert(pstEnd1->wDay + 1 <= 30);

        *pstStart2 = *pstEnd1;
        pstStart2->wMonth = 3;
        *pstEnd2 = *pstStart2;

        SetDomTrigger2Days(dwDaysOfMonth,
                           pstEnd1->wDay + 1,
                           pstStart1->wDay - 1,
                           pstStart2,
                           pstEnd2);
    }
    else if (wStart1MonthDays < 31)
    {
        //
        // we have case b if any bits after the last day in pstStart1->wMonth
        // are set.
        //

        *pstStart2 = *pstEnd1;
        if (pstEnd1->wMonth == pstStart1->wMonth)
        {
            pstStart2->wMonth++;
        }
        *pstEnd2 = *pstStart2;

        SetDomTrigger2Days(dwDaysOfMonth,
                           wStart1MonthDays + 1,
                           31,
                           pstStart2,
                           pstEnd2);
    }
    else
    {
        // no second trigger

        pstStart2->wDay = 0;
        pstEnd2->wDay = 0;
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   SetDomTrigger2Days
//
//  Synopsis:   Set the start and end dates for the second DOM trigger.
//
//  Arguments:  [dwDaysOfMonth]    - bit array, bit 0=day 1, etc.  At least
//                                     one bit must be set!
//              [wFirstDayToCheck] - 1 based
//              [wLastDayToCheck]  - 1 based, must be >= [wFirstDayToCheck]
//              [pstStart2]        - filled with start date of second
//                                    trigger; wDay is 0 if no second
//                                    trigger is required.
//              [pstEnd2]          - filled with end date of second trigger;
//                                    wDay is 0 if no second trigger is
//                                    required.
//
//  Modifies:   All out args.
//
//  History:    09-26-96   DavidMun   Created
//
//  Notes:      This is a helper function called only by
//              CalcDomTriggerDates.
//
//----------------------------------------------------------------------------

VOID
SetDomTrigger2Days(
    DWORD dwDaysOfMonth,
    WORD wFirstDayToCheck,
    WORD wLastDayToCheck,
    SYSTEMTIME *pstStart2,
    SYSTEMTIME *pstEnd2)
{
    WORD wDay;

    pstStart2->wDay = 0;
    pstEnd2->wDay = 0;

    for (wDay = wFirstDayToCheck; wDay <= wLastDayToCheck; wDay++)
    {
        if (IsMonthBitSet(dwDaysOfMonth, wDay))
        {
            //
            // if the start of the second trigger hasn't been assigned
            // yet, assign it.  otherwise update the end of the second
            // trigger to the current day.
            //

            if (!pstStart2->wDay)
            {
                pstStart2->wDay = wDay;
            }
            else
            {
                pstEnd2->wDay = wDay;
            }
        }
    }

    //
    // there may have been only one day on in the gap, so the start and
    // end of trigger 2 are the same day.
    //

    if (pstStart2->wDay && !pstEnd2->wDay)
    {
        pstEnd2->wDay = pstStart2->wDay;
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   CalcDowTriggerDate
//
//  Synopsis:   Set the start and end dates for the Day of Week trigger.
//
//  Arguments:  [stNow]    - Current time
//              [stStart]  - same as [stNow] but with hour and minute of
//                            actual run time
//              [pstStart] - filled with start date
//              [pstEnd]   - filled with end date
//
//  Modifies:   *[pstStart], *[pstEnd]
//
//  History:    09-26-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID
CalcDowTriggerDate(
    const SYSTEMTIME &stNow,
    const SYSTEMTIME &stStart,
          SYSTEMTIME *pstStart,
          SYSTEMTIME *pstEnd)
{
    *pstStart = stNow;

    //
    // If it's too late for the job to run today, make the start date
    // tomorrow.
    //

    if (IsFirstTimeEarlier(&stStart, &stNow))
    {
        IncrementDay(pstStart);
    }

    //
    // Make the end date 6 days later than the start date, that way we cover a
    // full week and all runs will happen.
    //

    *pstEnd = *pstStart;
    pstEnd->wDay += 6;

    WORD wLastDay;
    HRESULT hr = MonthDays(pstEnd->wMonth, pstEnd->wYear, &wLastDay);

    if (FAILED(hr))
    {
        schAssert(!"Bad systemtime");
    }
    else
    {
        if (pstEnd->wDay > wLastDay)
        {
            //
            // Wrap to the next month.
            //
            pstEnd->wDay -= wLastDay;
            IncrementMonth(pstEnd);
        }
    }
}




//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::GetAtJob, private
//
//  Synopsis:   retrieves a downlevel job's AT info
//
//  Arguments:  [pwszFileName] - job object's file name
//              [pAt]          - pointer to an AT_INFO struct
//              [pwszCommand]  - buffer for the command string
//              [pcchCommand]  - on input, size of supplied buffer, on output,
//                               size needed if supplied buffer is too small.
//
//  Returns:    HRESULTS - ERROR_INSUFFICIENT_BUFFER if too small
//                       - SCHED_E_NOT_AN_AT_JOB if not an AT job
//
//  Notes:      This method is not exposed to external clients, thus it is not
//              part of a public interface.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::GetAtJob(LPCTSTR pwszFileName, AT_INFO * pAt, LPWSTR pwszCommand,
                    DWORD * pcchCommand)
{
    TRACE(CSchedule, GetAtJob);

    CJob * pJob = CJob::Create();

    if (pJob == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pJob->LoadP(pwszFileName, 0, TRUE, TRUE);

    if (FAILED(hr))
    {
        ERR_OUT("GetAtJob: LoadP", hr);
        pJob->Release();
        return hr;
    }

    hr = pJob->GetAtInfo(pAt, pwszCommand, pcchCommand);

    if (FAILED(hr))
    {
        ERR_OUT("GetAtJob: GetAtInfo", hr);
        pJob->Release();
        return hr;
    }

    pJob->Release();

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::IncrementAndSaveID
//
//  Synopsis:   Increment the NextJobID value and save it to the registry.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::IncrementAndSaveID(void)
{
    EnterCriticalSection(&m_CriticalSection);
    long lErr;
    HKEY hSchedKey;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_SVC_KEY, 0, KEY_SET_VALUE,
                        &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
        LeaveCriticalSection(&m_CriticalSection);
        return(HRESULT_FROM_WIN32(lErr));
    }

    m_dwNextID++;

    //
    // update the registry entry
    //
    lErr = RegSetValueEx(hSchedKey, SCH_NEXTATJOBID_VALUE, 0, REG_DWORD,
                         (CONST BYTE *)&m_dwNextID, sizeof(DWORD));
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("Create of NextAtJobId registry value", lErr);
        m_dwNextID--;
        RegCloseKey(hSchedKey);
        LeaveCriticalSection(&m_CriticalSection);
        return(HRESULT_FROM_WIN32(lErr));
    }
    RegCloseKey(hSchedKey);
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ResetAtID
//
//  Synopsis:   Set the next at id value in the registry to 1
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::ResetAtID(void)
{
    HRESULT hr = S_OK;
    HKEY    hSchedKey = NULL;

    EnterCriticalSection(&m_CriticalSection);

    m_dwNextID = 1;

    do
    {
        LONG lErr;

        //
        // Open the schedule service key
        //

        lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            SCH_SVC_KEY,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hSchedKey);

        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
            hr = HRESULT_FROM_WIN32(lErr);
            break;
        }

        //
        // Set the next At Job ID value to 1.  If the value is not present,
        // it will be created.
        //

        lErr = RegSetValueEx(hSchedKey,
                             SCH_NEXTATJOBID_VALUE,
                             0,
                             REG_DWORD,
                             (CONST BYTE *) &m_dwNextID,
                             sizeof(m_dwNextID));

        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("Create of NextAtJobId registry value", lErr);
            hr = HRESULT_FROM_WIN32(lErr);
        }
    } while (0);

    if (hSchedKey)
    {
        RegCloseKey(hSchedKey);
    }
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}




//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::_AtTaskExists, private
//
//  Synopsis:   Check for existing AT tasks
//
//  Returns:    S_OK    - an AT task was found
//              S_FALSE - no AT tasks were found
//              E_*
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::_AtTaskExists(void)
{
    WIN32_FIND_DATA fd;
    HANDLE          hFileFindContext;

    hFileFindContext = FindFirstFile(g_wszAtJobSearchPath, &fd);

    if (hFileFindContext == INVALID_HANDLE_VALUE)
    {
        return S_FALSE;
    }

    CJob * pJob = CJob::Create();
    if (pJob == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_FALSE;
    DWORD   rgFlags;

    do
    {
        if (!IsValidAtFilename(fd.cFileName))
        {
            continue;
        }

        HRESULT hrLoad = LoadAtJob(pJob, fd.cFileName);

        if (FAILED(hrLoad))
        {
            hr = hrLoad;
            break;
        }

        pJob->GetAllFlags(&rgFlags);

        if (rgFlags & JOB_I_FLAG_NET_SCHEDULE)
        {
            hr = S_OK;
            break;
        }
    } while (FindNextFile(hFileFindContext, &fd));

    FindClose(hFileFindContext);
    pJob->Release();

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::InitAtID
//
//  Synopsis:   Obtains the current AT task ID from the registry.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::InitAtID(void)
{
    //
    // Open the schedule service key
    //
    long lErr;
    HKEY hSchedKey;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_SVC_KEY, 0,
                        KEY_READ | KEY_WRITE, &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
        return(HRESULT_FROM_WIN32(lErr));
    }

    //
    // Get the next At Job ID
    //
    DWORD cb = sizeof(DWORD);
    lErr = RegQueryValueEx(hSchedKey, SCH_NEXTATJOBID_VALUE, NULL, NULL,
                           (LPBYTE)&m_dwNextID, &cb);
    if (lErr != ERROR_SUCCESS)
    {
        if (lErr != ERROR_FILE_NOT_FOUND)
        {
            ERR_OUT("Read of NextAtJobId registry value", lErr);
            RegCloseKey(hSchedKey);
            return(HRESULT_FROM_WIN32(lErr));
        }

        //
        // Scan AT jobs for value if registry entry absent
        //
        GetNextAtID(&m_dwNextID);

        //
        // Create registry entry
        //
        lErr = RegSetValueEx(hSchedKey, SCH_NEXTATJOBID_VALUE, 0, REG_DWORD,
                             (CONST BYTE *)&m_dwNextID, sizeof(DWORD));
        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("Create of NextAtJobId registry value", lErr);
            RegCloseKey(hSchedKey);
            return(HRESULT_FROM_WIN32(lErr));
        }
    }

    RegCloseKey(hSchedKey);

    return S_OK;
}

#endif // #if !defined(_CHICAGO_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedule\sch_itf.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sch_itf.cxx
//
//  Contents:   job scheduler service interface impementation
//
//  Classes:    CSchedule
//
//  Interfaces: ITaskScheduler
//
//  History:    08-Sep-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "Sched.hxx"
#include "..\inc\misc.hxx"
#include "..\inc\network.hxx"


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::GetTargetComputer, public
//
//  Synopsis:   Returns the name of the machine towards which the interface is
//              currently targetted.
//
//  Arguments:  [ppwszComputer] - the returned buffer with the machine name
//
//  Returns:    hresults
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::GetTargetComputer(LPWSTR * ppwszComputer)
{
    TRACE(CSchedule, GetTargetComputer);

    HRESULT hr;
    DWORD   cch = SA_MAX_COMPUTERNAME_LENGTH + 1;
    TCHAR   tszLocalName[SA_MAX_COMPUTERNAME_LENGTH + 3] = TEXT("\\\\");
    TCHAR * ptszTargetMachine;
    WCHAR * pwszTargetMachine;

    if (m_ptszTargetMachine)
    {
        ptszTargetMachine = m_ptszTargetMachine;
        cch = lstrlen(ptszTargetMachine) + 1;
    }
    else    // A NULL m_ptszTargetMachine means that we are targetted locally
    {
        if (!GetComputerName(tszLocalName + 2, &cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetTargetComputer: GetComputerName", hr);
            return hr;
        }

        ptszTargetMachine = tszLocalName;
        cch += 3;   // 2 for the leading slashes + 1 for the NULL
    }

    pwszTargetMachine = ptszTargetMachine;

    *ppwszComputer = (LPWSTR)CoTaskMemAlloc(cch * sizeof(WCHAR));

    if (*ppwszComputer == NULL)
    {
        return E_OUTOFMEMORY;
    }

    s_wcscpy(*ppwszComputer, pwszTargetMachine);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::SetTargetComputer, public
//
//  Synopsis:   Sets the machine towards which subsequent ITaskScheduler
//              calls will be directed
//
//  Arguments:  [pwszComputer] - the machine name string
//
//  Returns:    hresults
//
//  Notes:      The string is Caller allocated and freed. The machine name
//              must include two leading backslashes.
//              The caller may indicate using the local machine in one of two
//              ways: by setting pwszComputer to NULL or to the UNC name of the
//              local machine.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::SetTargetComputer(LPCWSTR pwszComputer)
{
    TRACE(CSchedule, SetTargetComputer);
    HRESULT hr;
    DWORD cch;
    BOOL fLocal = FALSE;
    //
    // Parameter validation. A null param means to target the local computer.
    //
    if (!pwszComputer)
    {
        fLocal = TRUE;
    }

    LPCTSTR tszPassedInName = pwszComputer;
    if (!fLocal)
    {
        //
        // Get the local machine name to compare with that passed in.
        //
        TCHAR tszLocalName[SA_MAX_COMPUTERNAME_LENGTH + 1];
        cch = SA_MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerName(tszLocalName, &cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("SetTargetComputer: GetComputerName", hr);
            return hr;
        }

        TCHAR tszFQDN[SA_MAX_COMPUTERNAME_LENGTH + 1];
        cch = SA_MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, tszFQDN, &cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("SetTargetComputer: GetComputerNameEx", hr);
            return hr;
        }

        //
        // skip over first two characters ("\\") of tszPassedInName when comparing
        //
        fLocal = (lstrcmpi(tszPassedInName + 2, tszLocalName) == 0) ||
                 (lstrcmpi(tszPassedInName + 2, tszFQDN) == 0);
    }

    //
    // If targeted remotely, get the folder path out of that machine's
    // registry.
    //
    TCHAR tszFolderPath[MAX_PATH];
    if (!fLocal)
    {
        //
        // Open the remote registry.
        //
        long lErr;
        HKEY hRemoteKey, hSchedKey;

        lErr = RegConnectRegistry(tszPassedInName, HKEY_LOCAL_MACHINE,
                                  &hRemoteKey);
        if (lErr != ERROR_SUCCESS)
        {
            schDebugOut((DEB_ERROR, "SetTargetComputer: RegConnectRegistry "
                         "failed with error %ld\n",
                         lErr));
            return(HRESULT_FROM_WIN32(lErr));
        }

        lErr = RegOpenKeyEx(hRemoteKey, SCH_AGENT_KEY, 0, KEY_READ,
                            &hSchedKey);
        if (lErr != ERROR_SUCCESS)
        {
            RegCloseKey(hRemoteKey);

            if (lErr == ERROR_BADKEY || lErr == ERROR_FILE_NOT_FOUND)
            {
                return SCHED_E_SERVICE_NOT_INSTALLED;
            }

            schDebugOut((DEB_ERROR, "SetTargetComputer: RegOpenKeyEx "
                         "of Scheduler key failed with error %ld\n",
                         lErr));
            return HRESULT_FROM_WIN32(lErr);
        }
        //
        // Get the jobs folder location from the remote registry.
        //
        DWORD cb = MAX_PATH * sizeof(TCHAR);
        TCHAR tszRegFolderValue[MAX_PATH];
        lErr = RegQueryValueEx(hSchedKey, SCH_FOLDER_VALUE, NULL, NULL,
                               (LPBYTE)tszRegFolderValue, &cb);
        if (lErr != ERROR_SUCCESS)
        {
            // use default if value absent
            lstrcpy(tszRegFolderValue, TEXT("%SystemRoot%\\Tasks"));
        }
        RegCloseKey(hSchedKey);

        //
        // BUGBUG: temporary code to expand %SystemRoot% or %WinDir%
        // The installer will have to write a full path to the registry 'cause
        // expanding arbitrary environment strings remotely is too much work.
        //
        cch = ARRAY_LEN("%SystemRoot%") - 1;
        if (_tcsncicmp(tszRegFolderValue, TEXT("%SystemRoot%"), cch) != 0)
        {
            cch = ARRAY_LEN("%WinDir%") - 1;
            if (_tcsncicmp(tszRegFolderValue, TEXT("%WinDir%"), cch) != 0)
            {
                cch = 0;
            }
        }

        if (cch != 0)
        {
            HKEY hCurVerKey;
            lErr = RegOpenKeyEx(hRemoteKey,
                        TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),
                                0, KEY_ALL_ACCESS,
                                &hCurVerKey);
            if (lErr != ERROR_SUCCESS)
            {
                RegCloseKey(hRemoteKey);
                schDebugOut((DEB_ERROR, "SetTargetComputer: RegOpenKeyEx "
                             "of CurrentVersion key failed with error %ld\n",
                             lErr));
                return HRESULT_FROM_WIN32(lErr);
            }
            TCHAR tszSystemRoot[MAX_PATH];
            cb = MAX_PATH * sizeof(TCHAR);
            lErr = RegQueryValueEx(hCurVerKey, TEXT("SystemRoot"), NULL, NULL,
                                   (LPBYTE)tszSystemRoot, &cb);
            if (lErr != ERROR_SUCCESS)
            {
                RegCloseKey(hCurVerKey);
                RegCloseKey(hRemoteKey);
                schDebugOut((DEB_ERROR, "SetTargetComputer: RegQueryValueEx "
                             "of CurrentVersion key failed with error %ld\n",
                             lErr));
                return HRESULT_FROM_WIN32(lErr);
            }
            RegCloseKey(hCurVerKey);
            lstrcpy(tszFolderPath, tszSystemRoot);
            lstrcat(tszFolderPath, tszRegFolderValue + cch);
        }
        else
        {
            lstrcpy(tszFolderPath, tszRegFolderValue);
        }
        //
        // end of temporary code to expand %SystemRoot%
        //

        RegCloseKey(hRemoteKey);

        //
        // Check the folder path for being a fully qualified path name where
        // the first char is the drive designator and the second char is a
        // colon.
        //
        if (!s_isDriveLetter(tszFolderPath[0]) || tszFolderPath[1] != TEXT(':'))
        {
            ERR_OUT("SetTargetComputer: registry path", ERROR_BAD_PATHNAME);
            return HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        }
        //
        // The UNC path to the job folder will be the result of concatonating
        // the machine name and the expanded folder path. The drive designator
        // in the folder path will be turned in an administrative share name
        // by replacing the colon with a dollar sign and will look like:
        //   \\machine\c$\windir\jobs
        // so that the count below includes the slash trailing the machine name
        // plus the terminating null.
        //
        cch = lstrlen(tszPassedInName) + 1 + lstrlen(tszFolderPath) + 1;
    }
    else // Targetted locally.
    {
        //
        // Use the local path. Include one for the null terminator.
        //
        cch = lstrlen(g_TasksFolderInfo.ptszPath) + 1;
    }

    //
    // Allocate the ITaskScheduler folder path string buffer.
    //
    TCHAR * ptszPathBuf = new TCHAR[cch];
    if (!ptszPathBuf)
    {
        ERR_OUT("SetTargetComputer: Job folder path buffer allocation",
                E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    //
    // Allocate the ITaskScheduler machine name string buffer.
    //
    TCHAR * ptszTargetMachine;
    if (!fLocal)
    {
        cch = lstrlen(tszPassedInName) + 1;
        ptszTargetMachine = new TCHAR[cch];
        if (!ptszTargetMachine)
        {
            ERR_OUT("CSchedule::SetTargetComputer", E_OUTOFMEMORY);
            delete ptszPathBuf;
            return E_OUTOFMEMORY;
        }
    }

    //
    // Now that all failable operation have completed sucessfully, we can
    // update the machine name and folder path members.
    //

    if (m_ptszTargetMachine)
    {
        delete m_ptszTargetMachine;
    }

    if (m_ptszFolderPath)
    {
        delete m_ptszFolderPath;
    }

    //
    // Save the new machine name.
    //

    if (fLocal)
    {
        //
        // If we are targetted locally, the machine name member is set to
        // NULL.
        //
        m_ptszTargetMachine = NULL;
    }
    else
    {
        m_ptszTargetMachine = ptszTargetMachine;
        lstrcpy(m_ptszTargetMachine, tszPassedInName);
    }

    //
    // Save the folder path name.
    //

    m_ptszFolderPath = ptszPathBuf;

    if (fLocal)
    {
        lstrcpy(m_ptszFolderPath, g_TasksFolderInfo.ptszPath);
    }
    else
    {
        //
        // Convert the folder location to an UNC path.
        //
        // Turn the drive designator into the admin share by replacing the
        // colon with the dollar sign.
        //
        tszFolderPath[1] = TEXT('$');
        //
        // Compose the UNC path.
        //
        lstrcpy(m_ptszFolderPath, tszPassedInName);
        lstrcat(m_ptszFolderPath, TEXT("\\"));
        lstrcat(m_ptszFolderPath, tszFolderPath);
    }

    schDebugOut((DEB_ITRACE,
                 "SetTargetComputer: path to sched folder: \"" FMT_TSTR "\"\n",
                 m_ptszFolderPath));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::Enum, public
//
//  Synopsis:   Returns a job/queue object enumerator.
//
//  Arguments:  [ppEnumJobs] - a place to return a pointer to the enumerator
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::Enum(IEnumWorkItems ** ppEnumJobs)
{
    TRACE(CSchedule, Enum);
    HRESULT hr;

    CEnumJobs * pEnumJobs = new CEnumJobs;
    if (pEnumJobs == NULL)
    {
        *ppEnumJobs = NULL;
        return E_OUTOFMEMORY;
    }

    hr = pEnumJobs->Init(m_ptszFolderPath);
    if (FAILED(hr))
    {
        delete pEnumJobs;
        *ppEnumJobs = NULL;
    }

    *ppEnumJobs = pEnumJobs;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::NewWorkItem, public
//
//  Synopsis:   Create a new job object.
//
//  Arguments:  [pwszJobName] - the name of the new job *REQUIRED*
//              [riid] - the interface desired
//              [ppunk] - a place to return a pointer to the new job object
//
//  Returns:    hresults
//
//  Notes:      ppwszJobName is caller allocated and freed. The CJob::Save
//              method will copy it before returning. The job name must conform
//              to NT file naming conventions but must not include
//              [back]slashes because nesting within the job object folder is
//              not allowed.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::NewWorkItem(LPCWSTR pwszJobName, REFCLSID rclsid,
                       REFIID riid, IUnknown ** ppunk)
{
    TRACE(CSchedule, NewWorkItem);

    *ppunk = NULL;

    if (!IsEqualCLSID(rclsid, CLSID_CTask))
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    TCHAR * ptszFullName;
    HANDLE hFile;

    HRESULT hr = CheckJobName(pwszJobName, &ptszFullName);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::NewWorkItem: CheckJobName", hr);
        return hr;
    }

    CJob * pJob = CJob::Create();
    if (pJob == NULL)
    {
        delete [] ptszFullName;
        return E_OUTOFMEMORY;
    }

    //
    // Do the QI before the CreateFile so that if the caller asks for a non-
    // supported interface, the failure will not result in disk operations.
    //
    hr = pJob->QueryInterface(riid, (void **)ppunk);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::NewWorkItem: QueryInterface(riid)", hr);
        goto CleanExit;
    }
    // the above QI increased the refcount to 2, so set it back to 1
    pJob->Release();

    //
    // Per the spec for this method, the file must not already exist.
    //
    hFile = CreateFile(ptszFullName,
                       0,               // desired access: none
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        // share mode: all
                       NULL,            // security attributes
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwErr = GetLastError();

        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            //
            // This is good.  Save the new filename.
            //
            pJob->m_ptszFileName = ptszFullName;
            return S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            ERR_OUT("CSchedule::NewWorkItem: CreateFile", hr);
        }
    }
    else
    {
        //
        // Opened successfully - the file exists
        //
        CloseHandle(hFile);
        hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
        ERR_OUT("CSchedule::NewWorkItem", hr);
    }

CleanExit:

    delete [] ptszFullName;
    delete pJob;    // on error, completely destroy the job object
    *ppunk = NULL;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::AddWorkItem, public
//
//  Synopsis:   Saves the job to the job scheduler folder.
//
//  Arguments:  [pwszJobName] - the name of the job *REQUIRED*
//              [pJob]        - pointer to the job object
//
//  Returns:    hresults
//
//  Notes:      Same job name conditions as above.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::AddWorkItem(LPCWSTR pwszJobName,
                       IScheduledWorkItem * pWorkItem)
{
    TRACE(CSchedule, AddWorkItem);
    TCHAR * ptszFullName;

    HRESULT hr = CheckJobName(pwszJobName, &ptszFullName);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::AddWorkItem: CheckJobName", hr);
        return hr;
    }
    IPersistFile * pFile;

    hr = pWorkItem->QueryInterface(IID_IPersistFile, (void **)&pFile);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::AddWorkItem: QI(IPersistFile)", hr);
        delete [] ptszFullName;
        return hr;
    }

    WCHAR * pwszName;

#if !defined(UNICODE)

    int cch = lstrlen(ptszFullName) + 1;
    pwszName = new WCHAR[cch];
    if (!pwszName)
    {
        ERR_OUT("CSchedule::AddWorkItem", E_OUTOFMEMORY);
        pFile->Release();
        delete [] ptszFullName;
        return E_OUTOFMEMORY;
    }

    MultiByteToWideChar(CP_ACP, 0, ptszFullName, -1, pwszName, cch);

#else

    pwszName = ptszFullName;

#endif

    hr = pFile->Save(pwszName, TRUE);

    // Add this if we want nested folders
    //
    // if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    // {
    //     //
    //     // Create folders as needed
    //     //
    //     hr = CreateFolders(ptszFullName, TRUE);
    //     if (FAILED(hr))
    //     {
    //         ERR_OUT("AddWorkItem: CreateFolders", hr);
    //         pFile->Release();
    //         delete [] ptszFullName;
    // #if !defined(UNICODE)
    //         delete [] pwszName;
    // #endif
    //         return hr;
    //     }
    //     //
    //     // Try again
    //     //
    //     hr = pFile->Save(pwszName, TRUE);
    // }

    pFile->Release();
    delete [] ptszFullName;
#if !defined(UNICODE)
    delete [] pwszName;
#endif
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::Delete, public
//
//  Synopsis:   Deletes the job/queue.
//
//  Arguments:  [pwszJobName] - indicates the job/queue to delete
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::Delete(LPCWSTR pwszJobName)
{
    TRACE(CSchedule, Delete);
    HRESULT hr;
    TCHAR * ptszFullName;

    hr = CheckJobName(pwszJobName, &ptszFullName);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::Delete: CheckJobName", hr);
        return hr;
    }

    if (!DeleteFile(ptszFullName))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CSchedule::Delete: DeleteFile", hr);
        delete ptszFullName;
        return hr;
    }
    delete ptszFullName;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::Activate, public
//
//  Synopsis:   Given a valid name, returns a pointer to the activated job
//              object
//
//  Arguments:  [pwszName] - the name of the job to activate
//              [riid]     - the interface to return
//              [ppunk]    - a pointer to the job object interface
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::Activate(LPCWSTR pwszName, REFIID riid, IUnknown ** ppunk)
{
    TRACE(CSchedule, Activate);
    TCHAR * ptszFullName;
    HRESULT hr = CheckJobName(pwszName, &ptszFullName);
    if (FAILED(hr))
    {
        *ppunk = NULL;
        return hr;
    }

    CJob * pJob;

    //
    // CJob is a single-use, in-proc handler, so no need to get OLE in the
    // loop here. Use new (called by CJob::Create) instead of CoCreateInstance.
    //
    pJob = CJob::Create();
    if (pJob == NULL)
    {
        *ppunk = NULL;
        delete [] ptszFullName;
        return E_OUTOFMEMORY;
    }

    hr = pJob->LoadP(ptszFullName, 0, TRUE, TRUE);

    delete [] ptszFullName;

    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::Activate, Load", hr);
        *ppunk = NULL;
        pJob->Release();    // on error, completely release the job object
        return hr;
    }

    hr = pJob->QueryInterface(riid, (void **)ppunk);
    if (FAILED(hr))
    {
        ERR_OUT("CSchedule::Activate: QueryInterface(riid)", hr);
        *ppunk = NULL;
        pJob->Release();    // on error, completely release the job object
        return hr;
    }

    //
    // The above QI increased the refcount to 2, so set it back to 1.
    //
    pJob->Release();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ITaskScheduler::IsOfType, public
//
//  Synopsis:   Does this object support the desired interface?
//
//  Arguments:  [pwszName] - indicates the object name
//              [riid] - indicates the interface of interest, typically
//                  IID_ITask or IID_IScheduledQueue
//
//  Returns:    S_OK if it is, S_FALSE otherwise.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::IsOfType(LPCWSTR pwszName, REFIID riid)
{
    TRACE(CSchedule, IsOfType);

    // CODEWORK: A heavyweight implementation for now.  It could possibly
    // be optimized by doing the QueryInterface before the LoadP, and
    // doing a lightweight LoadP.

    IUnknown * punk;
    HRESULT hr = Activate(pwszName, riid, &punk);
    if (SUCCEEDED(hr))
    {
        punk->Release();
        hr = S_OK;
    }
    else
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_DATA) ||
            hr == SCHED_E_UNKNOWN_OBJECT_VERSION ||
            hr == E_NOINTERFACE)
        {
            //
            // These errors mean that the object is definitely not of a
            // type that we support.  We translate them to S_FALSE.
            // Other errors could include file-not-found, access-denied,
            // invalid-arg, etc.  We return those errors unmodified.
            //
            hr = S_FALSE;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedule\sch_util.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sch_util.cxx
//
//  Contents:   scheduler object IUnknown methods, class factory,
//              plus misc private class methods
//
//  Classes:    CSchedule, CScheduleCF
//
//  Interfaces: IUnknown, IClassFactory
//
//  History:    09-Sep-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "Sched.hxx"

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::ActivateJob, private
//
//  Synopsis:   Given a valid name, returns a pointer to the activated job
//              object
//
//  Arguments:  [pwszName] - the folder-relative name of the job to activate
//              [ppJob]    - a pointer to the job class object; on entry,
//                           must either be NULL or point to a CJob object.
//              [fAllData] - load all job data from disk.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::ActivateJob(LPCTSTR ptszName, CJob ** ppJob, BOOL fAllData)
{
    TCHAR tszFullName[MAX_PATH + MAX_PATH];
    lstrcpy(tszFullName, g_TasksFolderInfo.ptszPath);
    lstrcat(tszFullName, TEXT("\\"));
    lstrcat(tszFullName, ptszName);
    //
    // If *ppJob is NULL, allocate a new job object.
    //
    if (*ppJob == NULL)
    {
        //
        // CJob is a single-use, in-proc handler, so no need to get OLE in the
        // loop here. Use new (called by CJob::Create) instead of CoCreateInstance.
        //
        *ppJob = CJob::Create();
        if (*ppJob == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT hr = (*ppJob)->LoadP(tszFullName, 0, TRUE, fAllData);
    if (FAILED(hr))
    {
        schDebugOut((DEB_ERROR, "CSchedule::ActivateJob: pJob->Load failed"
                     " with error 0x%x\n", hr));
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::CheckJobName
//
//  Synopsis:   Checks for a valid job object file name and returns the full
//              path name. Takes an UNICODE input name and returns a TCHAR.
//
//  Arguments:  [pwszJobName]       - the job name as specified by the client
//              [pptszFullPathName] - the name including the job folder path
//
//  Returns:    HRESULTS
//
//  Notes:      The job name can be an absolute or UNC path. If not,it is
//              assumed to be relative to the job schedule folder.
//              If there is an extension on the last element (the actual file
//              name), then it must be .job. If there is no extension, then
//              the the correct one will be added.
//-----------------------------------------------------------------------------
HRESULT
CSchedule::CheckJobName(LPCWSTR pwszJobName, LPTSTR * pptszFullPathName)
{
    //
    // Make sure that the string doesn't end in a slash character.
    //

    ULONG cchJobName = wcslen(pwszJobName);
    ULONG cchNameParam = cchJobName;

    if (!cchNameParam)
    {
        schDebugOut((DEB_ERROR,
         "CSchedule::CheckJobName: pwszJobName is a 0 length string\n"));
        return E_INVALIDARG;
    }

    if (cchNameParam > 1 &&
            (pwszJobName[cchNameParam - 1] == L'\\' ||
             pwszJobName[cchNameParam - 1] == L'/'))
    {
        schDebugOut((DEB_ERROR,
         "CSchedule::CheckJobName: pwszJobName ends in illegal char %c\n",
         pwszJobName[cchNameParam - 1]));
         return E_INVALIDARG;
    }

    BOOL fNeedsPath = TRUE;
    //
    // Is it a full or relative path?
    //
    if ((cchNameParam > 2 &&
        (pwszJobName[1] == TEXT(':')  ||
         ((pwszJobName[0] == TEXT('\\') || pwszJobName[0] == TEXT('/')) &&
          (pwszJobName[1] == TEXT('\\') || pwszJobName[1] == TEXT('/'))))))
    {
        fNeedsPath = FALSE;
    }
    //
    // Check extension
    //

#if defined(UNICODE)
    WCHAR * pwszJobExt = TSZ_JOB;
#else
    WCHAR * pwszJobExt = WSZ_JOB;
#endif // defined(UNICODE)

    ULONG cJobExt = ARRAY_LEN(TSZ_JOB);  // add one for the period
    BOOL fNeedExt = FALSE;
    const WCHAR * pwszLastDot = wcsrchr(pwszJobName, L'.');

    if (pwszLastDot != NULL)
    {
        // check if the period is within cJobExt chars of the end
        //
        if ((size_t)(cchNameParam - (pwszLastDot - pwszJobName)) <= (size_t)cJobExt)
        {
            if (_wcsicmp(pwszLastDot + 1, pwszJobExt) != 0)
            {
                // Its extension does not match TSZ_JOB, so it is invalid.
                //
                schDebugOut((DEB_ERROR,
                        "CSchedule::CheckJobName: expected '%S', got '%S'",
                        pwszJobExt,
                        pwszLastDot + 1));
                return E_INVALIDARG;
            }
        }
        else    // append the extension.
        {
            fNeedExt = TRUE;
            cchNameParam += cJobExt;  // add the length of the extension
        }
    }
    else    // append the extension.
    {
        fNeedExt = TRUE;
        cchNameParam += cJobExt;  // add the length of the extension
    }

    //
    // Allocate the string to return the result.
    //
    if (fNeedsPath)
    {
        // add one for the '\'
        cchNameParam += lstrlen(m_ptszFolderPath) + 1;
    }

    //
    // If we're about to convert to multibyte, make sure that we allocate
    // enough to hold the job name, even if all of its chars become double
    // byte.  Note that everything else that's been added to cchNameParam has
    // been computed from TCHAR strings.
    //

#if !defined(UNICODE)
    cchNameParam += cchJobName;
#endif

    // add 1 to the array length for the null
    TCHAR * ptszPath = new TCHAR[cchNameParam + 1];
    if (ptszPath == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (fNeedsPath)
    {
        lstrcpy(ptszPath, m_ptszFolderPath);
        lstrcat(ptszPath, TEXT("\\"));
#if defined(UNICODE)
        lstrcat(ptszPath, pwszJobName);
#else
        HRESULT hr = UnicodeToAnsi(ptszPath + lstrlen(ptszPath),
                                   pwszJobName,
                                   2 * cchJobName + 1);
        if (FAILED(hr))
        {
            delete [] ptszPath;
            CHECK_HRESULT(hr);
            return hr;
        }
#endif // defined(UNICODE)
    }
    else
    {
#if defined(UNICODE)
        lstrcpy(ptszPath, pwszJobName);
#else
        HRESULT hr = UnicodeToAnsi(ptszPath,
                                   pwszJobName,
                                   2 * cchJobName + 1);
        if (FAILED(hr))
        {
            delete [] ptszPath;
            CHECK_HRESULT(hr);
            return hr;
        }
#endif // defined(UNICODE)
    }

    if (fNeedExt)
    {
        lstrcat(ptszPath, TEXT(".") TSZ_JOB);
    }


    *pptszFullPathName = ptszPath;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::CSchedule
//
//  Synopsis:   constructor
//
//-----------------------------------------------------------------------------
CSchedule::CSchedule(void) :
    m_ptszTargetMachine(NULL),
    m_ptszFolderPath(NULL),
    m_dwNextID(1),
    m_uRefs(1)
{
    InitializeCriticalSection(&m_CriticalSection);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::~CSchedule
//
//  Synopsis:   destructor
//
//-----------------------------------------------------------------------------
CSchedule::~CSchedule(void)
{
    DeleteCriticalSection(&m_CriticalSection);
    if (m_ptszTargetMachine)
    {
        delete m_ptszTargetMachine;
    }
    if (m_ptszFolderPath)
    {
        delete m_ptszFolderPath;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::Init
//
//  Synopsis:   Two phase construction - can't do operations that could fail
//              in the ctor since there is no way to return errors without
//              throwing exceptions.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedule::Init(void)
{
    if (g_TasksFolderInfo.ptszPath == NULL)
    {
        ERR_OUT("CSchedule::Init, folder path not set", E_FAIL);
        return E_FAIL;
    }
    HRESULT hr;

    //
    // Get the jobs folder location. These values will be replaced when a
    // call is made to SetTargetMachine
    //
    m_ptszFolderPath = new TCHAR[lstrlen(g_TasksFolderInfo.ptszPath) + 1];
    if (!m_ptszFolderPath)
    {
        ERR_OUT("CSchedule::Init", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
    lstrcpy(m_ptszFolderPath, g_TasksFolderInfo.ptszPath);

    return S_OK;
}

#if !defined(_CHICAGO_) // don't need AT support on chicago

//+----------------------------------------------------------------------------
//
//  Function:   GetNextAtID
//
//  Synopsis:   Examine the AT jobs to find the highest ID.
//
//-----------------------------------------------------------------------------
void
GetNextAtID(LPDWORD pdwAtID)
{
    WCHAR wszAtJobSearchPath[MAX_PATH];

    wcscpy(wszAtJobSearchPath, g_TasksFolderInfo.ptszPath);
    wcscat(wszAtJobSearchPath, L"\\" TSZ_AT_JOB_PREFIX L"*." TSZ_JOB);

    DWORD cchNamePrefixLen = ARRAY_LEN(TSZ_AT_JOB_PREFIX) - 1;

    WIN32_FIND_DATA fd;
    HANDLE hFileFind = FindFirstFile(wszAtJobSearchPath, &fd);

    if (hFileFind == INVALID_HANDLE_VALUE)
    {
        //
        // If no at jobs, set the initial job ID to be 1, since zero is
        // reserved for an error flag.
        //
        *pdwAtID = 1;
        return;
    }

    DWORD dwMaxID = 1;

    do
    {
        WCHAR * pDot = wcschr(fd.cFileName, L'.');
        if (pDot == NULL)
        {
            continue;
        }

        *pDot = L'\0';

        DWORD dwCurID = (DWORD)_wtol(fd.cFileName + cchNamePrefixLen);

        schDebugOut((DEB_ITRACE, "GetNextAtID: found %S, with ID %d\n",
                     fd.cFileName, dwCurID));

        if (dwCurID > dwMaxID)
        {
            dwMaxID = dwCurID;
        }

    } while (FindNextFile(hFileFind, &fd));

    FindClose(hFileFind);

    //
    // The next available AT ID will be one greater than the current max.
    //
    *pdwAtID = dwMaxID + 1;

    return;
}

#endif  // !defined(_CHICAGO_)

//+----------------------------------------------------------------------------
//
//      CSchedule IUnknown methods
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::QueryInterface(REFIID riid, void ** ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CSchedule::QueryInterface"));
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IID_ITaskScheduler == riid)
    {
        *ppvObject = (IUnknown *)(ITaskScheduler *)this;
    }
    //else if (IID_IDispatch == riid)
    //{
    //  *ppvObject = (IUnknown *)(IDispatch *)this;
    //}
    else
    {
#if DBG == 1
        //TCHAR * pwsz;
        //StringFromIID(riid, &pwsz);
        //schDebugOut((DEB_NOPREFIX, "%S, refused\n", pwsz));
        //CoTaskMemFree(pwsz);
#endif
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CSchedule::AddRef(void)
{
    //schDebugOut((DEB_ITRACE, "CSchedule::AddRef refcount going in %d\n", m_uRefs));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CSchedule::Release(void)
{
    //schDebugOut((DEB_ITRACE, "CSchedule::Release ref count going in %d\n", m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//      CScheduleCF - class factory for the Schedule Service object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::Create
//
//  Synopsis:   creates a new class factory object
//
//-----------------------------------------------------------------------------
IClassFactory *
CScheduleCF::Create(void)
{
    return new CScheduleCF;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::CScheduleCF
//
//  Synopsis:   ctor
//
//-----------------------------------------------------------------------------
CScheduleCF::CScheduleCF(void)
{
    m_uRefs = 1;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::~CScheduleCF
//
//  Synopsis:   dtor
//
//-----------------------------------------------------------------------------
CScheduleCF::~CScheduleCF(void)
{
    ;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CScheduleCF::QueryInterface(REFIID riid, void ** ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CScheduleCF::QueryInterface"));
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObject = (IClassFactory *)this;
    }
    else
    {
#if DBG == 1
        //TCHAR * pwsz;
        //StringFromIID(riid, &pwsz);
        //schDebugOut((DEB_NOPREFIX, "%S, refused\n", pwsz));
        //CoTaskMemFree(pwsz);
#endif
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CScheduleCF::AddRef(void)
{
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::IUnknown::Release
//
//  Synopsis:   noop, since this is a static object
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CScheduleCF::Release(void)
{
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::IClassFactory::CreateInstance
//
//  Synopsis:   create an incore instance of the job class object
//
//  Arguments:  [pUnkOuter] - aggregator
//              [riid]      - requested interface
//              [ppvObject] - receptor for itf ptr
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CScheduleCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CScheduleCF::CreateInstance\n"));
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    CSchedule * pSched = new CSchedule;
    if (pSched == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = pSched->Init();
    if (FAILED(hr))
    {
        ERR_OUT("CScheduleCF::CreateInstance, pSched->Init", hr);
        pSched->Release();
        return hr;
    }

    hr = pSched->QueryInterface(riid, ppvObject);
    if (FAILED(hr))
    {
        ERR_OUT("CScheduleCF::CreateInstance, pSched->QueryInterface", hr);
        pSched->Release();
        return hr;
    }

    //
    // We got a refcount of one when launched, and the above QI increments it
    // to 2, so call release to take it back to 1.
    //
    pSched->Release();
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CScheduleCF::IClassFactory::LockServer
//
//  Synopsis:   Called with fLock set to TRUE to indicate that the server
//              should continue to run even if none of its objects are active
//
//  Arguments:  [fLock] - increment/decrement the instance count
//
//  Returns:    HRESULTS
//
//  Notes:      This is a no-op since the handler runs in-proc.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CScheduleCF::LockServer(BOOL fLock)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\service\tasksrc.h ===
// Icons
#define IDI_STATE_SUSPENDED         401
#define IDI_STATE_RUNNING           402
#define IDI_STATE_IDLE              403

// Popu Menu
#define IDR_TRAY_ICON_POPUP_MENU_PAUSE      3601
#define IDR_TRAY_ICON_POPUP_MENU_CONTINUE   3602
#define IDM_OPEN_JOB_FOLDER                 3701
#define IDM_SUSPEND_SCHEDULER               3702

// Strings for tray icon tool tip.
#define IDS_STATE_SUSPENDED         502
#define IDS_STATE_RUNNING           503
#define IDS_STATE_IDLE              504
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\service\tasks.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       tasks.cxx
//
//  Contents:   Tray notification icon for Job Scheduler service.
//
//  Classes:    CTrayIcon
//
//  Functions:  None.
//
//  History:    3/22/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include <svc_core.hxx>
#include "tasks.hxx"

extern HINSTANCE g_hInstance;
extern HWND g_hwndSchedSvc;

//____________________________________________________________________________
//
//  Member:     CTrayIcon::_TrayMessage
//
//  Synopsis:   S
//
//  Arguments:  [dwMessage] -- IN Msg to Shell_NotifyIcon
//              [uiIcon]    -- IN Tray icon id
//              [ids]       -- IN Tool tip string id.
//
//  Returns:    HRESULT.
//
//  History:    3/22/1996   RaviR   Created
//
//____________________________________________________________________________

BOOL
CTrayIcon::_TrayMessage(
    DWORD   dwMessage,
    UINT    uiIcon,
    int     ids)
{
    NOTIFYICONDATA  tnd;

    schDebugOut((DEB_ITRACE,
                 "_TrayMessage: g_hwndSchedSvc = %x, dwMessage = %s, "
                 "uiIcon = %u\n",
                 g_hwndSchedSvc,
                 dwMessage == NIM_ADD ? "NIM_ADD" :
                 dwMessage == NIM_MODIFY ? "NIM_MODIFY" : "NIM_DELETE",
                 uiIcon));

    tnd.cbSize              = sizeof(NOTIFYICONDATA);
    tnd.hWnd                = g_hwndSchedSvc;
    tnd.uID                 = 0;
    tnd.uFlags              = NIF_MESSAGE | NIF_ICON | NIF_TIP;
    tnd.uCallbackMessage    = SCHEDM_TRAY_NOTIFY;

    if (m_hTrayIcon != NULL)
    {
        DestroyIcon(m_hTrayIcon);
        m_hTrayIcon = NULL;
    }

    if (uiIcon != NULL)
    {
        m_hTrayIcon = (HICON)LoadImage(g_hInstance, MAKEINTRESOURCE(uiIcon),
                                       IMAGE_ICON, 16, 16, 0);
    }
    tnd.hIcon = m_hTrayIcon;

    if (ids != 0)
    {
        LoadString(g_hInstance, ids, tnd.szTip, sizeof(tnd.szTip));
    }
    else
    {
        tnd.szTip[0] = TEXT('\0');
    }

    return Shell_NotifyIcon(dwMessage, &tnd);
}

//____________________________________________________________________________
//
//  Function:   Schedule_TrayNotify
//
//  Synopsis:   Notify handler for notifications from the scheduler tray icon.
//
//  Arguments:  [wParam] -- IN
//              [lParam] -- IN
//
//  Returns:    void
//
//  History:    3/22/1996   RaviR   Created
//
//____________________________________________________________________________

void
Schedule_TrayNotify(
    WPARAM  wParam,
    LPARAM  lParam)
{
    if (lParam == WM_RBUTTONDOWN)
    {
        //
        // Popup the context menu. {open, pause}
        //

        HMENU popup;
        HMENU subpopup;
        POINT mousepos;

        popup = LoadMenu(g_hInstance,
                         GetCurrentServiceState() == SERVICE_PAUSED ?
                         MAKEINTRESOURCE(IDR_TRAY_ICON_POPUP_MENU_CONTINUE) :
                         MAKEINTRESOURCE(IDR_TRAY_ICON_POPUP_MENU_PAUSE));

        if (popup)
        {
           int suspended;

           subpopup = GetSubMenu(popup, 0);

		   if( subpopup )
		   {
	           SetMenuDefaultItem(subpopup, 0, MF_BYPOSITION);

		       if (GetCursorPos(&mousepos))
			   {
			      SetForegroundWindow(g_hwndSchedSvc);

			      TrackPopupMenuEx(subpopup, TPM_LEFTALIGN | TPM_LEFTBUTTON |
			                       TPM_RIGHTBUTTON, mousepos.x, mousepos.y,
			                       g_hwndSchedSvc, NULL);
			   }

			   RemoveMenu(popup, 0, MF_BYPOSITION);
			   DestroyMenu(popup);
			   DestroyMenu(subpopup);
		   }
		   else	//if we failed clean up first
		   {
				RemoveMenu(popup, 0, MF_BYPOSITION);
				DestroyMenu(popup);
		   }
        }

    }
    else if (lParam == WM_LBUTTONDBLCLK)
    {
        OpenJobFolder();
    }
}

//____________________________________________________________________________
//
//  Function:   OpenJobFolder
//
//  Synopsis:   Opens the job folder on the local machine.
//
//  Returns:    void
//
//  History:    3/22/1996   RaviR   Created
//
//____________________________________________________________________________


#define BREAK_ON_FAIL(hr) if (FAILED(hr)) { break; } else 1;
#define CMD_ID_FIRST    1
#define CMD_ID_LAST     0x7fff

void
OpenJobFolder(void)
{

    //
    // Browse the jobs folder
    //

    HCURSOR hcWait = SetCursor(LoadCursor(NULL, IDC_WAIT));
    HRESULT hr = S_OK;
    LPSHELLFOLDER pshf = NULL;
    LPCONTEXTMENU pcm = NULL;
    HMENU hmenu = NULL;

    // "::CLSID_MyComputer\\::CLSID_TasksFolder"
    WCHAR buf1[200] = L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{d6277990-4c6a-11cf-8d87-00aa0060f5bf}";

    do
    {
        hr = SHGetDesktopFolder(&pshf);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        ULONG chEaten, dwAttributes;
        LPITEMIDLIST pidl;

        hr = pshf->ParseDisplayName(NULL, 0, buf1,
                            &chEaten, &pidl, &dwAttributes);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hr = pshf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&pidl,
                                IID_IContextMenu, NULL, (void**)&pcm);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hmenu = CreatePopupMenu();

        if (hmenu == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

#ifdef _CHICAGO_
        CMINVOKECOMMANDINFO ici = {
            sizeof(CMINVOKECOMMANDINFO),
            CMIC_MASK_ASYNCOK,
            NULL,
            NULL,
            NULL, NULL,
            SW_NORMAL,
        };
#else
        CMINVOKECOMMANDINFOEX ici = {
            sizeof(CMINVOKECOMMANDINFOEX),
            CMIC_MASK_ASYNCOK,
            NULL,
            NULL,
            NULL, NULL,
            SW_NORMAL,
        };
#endif

        UINT idCmd;
        UINT fFlags = CMF_DEFAULTONLY;

        hr = pcm->QueryContextMenu(hmenu, 0, CMD_ID_FIRST,
                                        CMD_ID_LAST, fFlags);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);

        SetCursor(hcWait);
        hcWait = NULL;

        if (idCmd)
        {
            ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - CMD_ID_FIRST);

            hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);

            CHECK_HRESULT(hr);
        }

    } while (0);

    if (hmenu != NULL)
    {
        DestroyMenu(hmenu);
    }

    if (pcm != NULL)
    {
        pcm->Release();
    }

    if (pshf != NULL)
    {
        pshf->Release();
    }

    if (hcWait != NULL)
    {
        SetCursor(hcWait);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\service\daytona\pfsvc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pfsvc.c

Abstract:

    This module contains the main rountines for the prefetcher service
    responsible for maintaining prefetch scenario files.

Author:

    Stuart Sechrest (stuartse)
    Cenk Ergan (cenke)
    Chuck Leinzmeier (chuckl)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <aclapi.h>
#include <dbghelp.h>
#include <idletask.h>
#include <prefetch.h>
#include <shdcom.h>
#include <tchar.h>
#include "pfsvc.h"

//
// Routine called to register for notifications when processing of all idle 
// tasks is requested from the idle task server.
//

typedef VOID (*PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE)(VOID);

BOOL
ItSpSetProcessIdleTasksNotifyRoutine (
    PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE NotifyRoutine
    );

//
// Globals.
//

PFSVC_GLOBALS PfSvcGlobals = {0};

//
// Exposed routines:
//

DWORD 
WINAPI
PfSvcMainThread(
    VOID *Param
    )

/*++

Routine Description:

    This is the main routine for the prefetcher service. It sets up
    file notification on the input files directory and waits for work
    or the signaling of the termination event.

Arguments:

    Param - Pointer to handle to the event that will signal our
      termination.

Return Value:

    Win32 error code.

--*/

{
    HANDLE hStopEvent;
    HANDLE hTracesReadyEvent;
    HANDLE hParametersChangedEvent;
    HANDLE hEvents[4];
    ULONG NumEvents;
    DWORD ErrorCode;
    ULONG Length;
    ULONG EventIdx;
    BOOLEAN bExitMainLoop;
    DWORD dwWait;
    NTSTATUS Status;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_PAGE_NODE PageNode;
    PLIST_ENTRY ListHead;
    PF_ENABLE_STATUS EnableStatus;
    PF_SCENARIO_TYPE ScenarioType;
    BOOLEAN UpdatedParameters;
    BOOLEAN PrefetchingEnabled;
    HANDLE PrefetcherThreads[1];
    ULONG NumPrefetcherThreads;
    ULONG ThreadIdx;
        
    //
    // Initialize locals.
    //

    NumEvents = sizeof(hEvents) / sizeof(HANDLE);
    hStopEvent = *((HANDLE *) Param);
    hTracesReadyEvent = NULL;
    hParametersChangedEvent = NULL;
    NumPrefetcherThreads = 0;

    DBGPR((PFID,PFTRC,"PFSVC: MainThread()\n"));

    //
    // Initialize globals.
    //
    
    ErrorCode = PfSvInitializeGlobals();
    
    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedInitGlobals\n"));
        goto cleanup;
    }

    //
    // Save service start time, prefetcher version etc.
    //

    PfSvSaveStartInfo(PfSvcGlobals.ServiceDataKey);

    //
    // Get necessary permissions for this thread to perform prefetch
    // service tasks.
    //

    ErrorCode = PfSvGetPrefetchServiceThreadPrivileges();
    
    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedGetPrivileges\n"));
        goto cleanup;
    }

    //
    // Set permissions on the event that can be set to override
    // waiting for system to be idle before processing traces, so it
    // can be set by administrators.
    //

    ErrorCode = PfSvSetAdminOnlyPermissions(PFSVC_OVERRIDE_IDLE_EVENT_NAME,
                                            PfSvcGlobals.OverrideIdleProcessingEvent,
                                            SE_KERNEL_OBJECT);
    
    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedSetPermissions1\n"));
        goto cleanup;
    }

    ErrorCode = PfSvSetAdminOnlyPermissions(PFSVC_PROCESSING_COMPLETE_EVENT_NAME,
                                            PfSvcGlobals.ProcessingCompleteEvent,
                                            SE_KERNEL_OBJECT);
    
    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedSetPermissions2\n"));
        goto cleanup;
    }

    //
    // Get system prefetch parameters.
    //

    ErrorCode = PfSvQueryPrefetchParameters(&PfSvcGlobals.Parameters);

    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedQueryParameters\n"));
        goto cleanup;
    }

    //
    // Depending on system type, if various types of prefetching is
    // not specified in the registry (i.e. not specifically disabled),
    // enable it.
    //

    UpdatedParameters = FALSE;

    if (PfSvcGlobals.OsVersion.wProductType == VER_NT_WORKSTATION) {

        //
        // Enable all prefetching types if they are not disabled.
        //

        for(ScenarioType = 0; ScenarioType < PfMaxScenarioType; ScenarioType++) {
            if (PfSvcGlobals.Parameters.EnableStatus[ScenarioType] == PfSvNotSpecified) {
                PfSvcGlobals.Parameters.EnableStatus[ScenarioType] = PfSvEnabled;
                UpdatedParameters = TRUE;
            }
        }

    } else if (PfSvcGlobals.OsVersion.wProductType == VER_NT_SERVER ||
               PfSvcGlobals.OsVersion.wProductType == VER_NT_DOMAIN_CONTROLLER) {
        
        //
        // Enable only boot prefetching.
        //

        if (PfSvcGlobals.Parameters.EnableStatus[PfSystemBootScenarioType] == PfSvNotSpecified) {
            PfSvcGlobals.Parameters.EnableStatus[PfSystemBootScenarioType] = PfSvEnabled;
            UpdatedParameters = TRUE;
        }
    }

    //
    // If we enabled prefetching for a scenario type, call the kernel
    // to update the parameters.
    //
    
    if (UpdatedParameters) {

        ErrorCode = PfSvSetPrefetchParameters(&PfSvcGlobals.Parameters);

        if (ErrorCode != ERROR_SUCCESS) {
            DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedSetParameters\n"));
            goto cleanup;
        }
    }

    //
    // Continue only if prefetching for a scenario type is enabled.
    //

    PrefetchingEnabled = FALSE;

    for(ScenarioType = 0; ScenarioType < PfMaxScenarioType; ScenarioType++) {
        if (PfSvcGlobals.Parameters.EnableStatus[ScenarioType] == PfSvEnabled) {
            PrefetchingEnabled = TRUE;
            break;
        }
    }

    if (PrefetchingEnabled == FALSE) {
        ErrorCode = ERROR_NOT_SUPPORTED;
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-PrefetchingNotEnabled\n"));
        goto cleanup;
    }

    //
    // Initialize the directory that contains prefetch instructions.
    //

    ErrorCode = PfSvInitializePrefetchDirectory(PfSvcGlobals.Parameters.RootDirPath);

    if (ErrorCode != ERROR_SUCCESS) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedInitPrefetchDir\n"));
        goto cleanup;
    }
    
    //
    // Create the event that the kernel will set when raw traces are
    // available. Then set the event so that the first time into the loop we
    // will immediately process whatever raw traces are already waiting.
    //
    // The event is an autoclearing event, so it resets to the not-signaled
    // state when our wait is satisfied. This allows proper synchronization
    // with the kernel prefetcher.
    //

    hTracesReadyEvent = CreateEvent(NULL,
                                    FALSE,
                                    FALSE,
                                    PF_COMPLETED_TRACES_EVENT_WIN32_NAME);

    if (hTracesReadyEvent == NULL) {
        ErrorCode = GetLastError();
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedTracesReadyEvent\n"));
        goto cleanup;
    }

    SetEvent(hTracesReadyEvent);

    //
    // Create the event that the kernel will set when system prefetch
    // parameters change.
    //
    
    hParametersChangedEvent = CreateEvent(NULL,
                                          FALSE,
                                          FALSE,
                                          PF_PARAMETERS_CHANGED_EVENT_WIN32_NAME);

    if (hParametersChangedEvent == NULL) {
        ErrorCode = GetLastError();
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedParamsChangedEvent\n"));
        goto cleanup;
    }

    //
    // Queue a work item to wait for the shell ready event and notify
    // the kernel.
    //

    QueueUserWorkItem(PfSvPollShellReadyWorker, NULL, WT_EXECUTELONGFUNCTION);

    //
    // Create a thread to process traces retrieved from the kernel.
    //

    PrefetcherThreads[NumPrefetcherThreads] = CreateThread(0,
                                                           0,
                                                           PfSvProcessTraceThread,
                                                           0,
                                                           0,
                                                           0);
    
    if (PrefetcherThreads[NumPrefetcherThreads]) {
        NumPrefetcherThreads++;
    }

    //
    // Register a notification routine with the idle task server.
    //

    ItSpSetProcessIdleTasksNotifyRoutine(PfSvProcessIdleTasksCallback);

    //
    // Set up handles we are going to wait on.
    //

    hEvents[0] = hStopEvent;
    hEvents[1] = hTracesReadyEvent;
    hEvents[2] = hParametersChangedEvent;
    hEvents[3] = PfSvcGlobals.CheckForMissedTracesEvent;

    //
    // This is the main loop. Wait on the events for work or for exit
    // signal.
    //

    bExitMainLoop = FALSE;
    
    do {

        DBGPR((PFID,PFWAIT,"PFSVC: MainThread()-WaitForWork\n"));
        dwWait = WaitForMultipleObjects(NumEvents, hEvents, FALSE, INFINITE);
        DBGPR((PFID,PFWAIT,"PFSVC: MainThread()-EndWaitForWork=%x\n",dwWait));
        
        switch(dwWait) {

        case WAIT_OBJECT_0:
            
            //
            // Service exit event:
            //

            //
            // Break out, cleanup and exit.
            //

            ErrorCode = ERROR_SUCCESS;
            bExitMainLoop = TRUE;

            break;

        case WAIT_OBJECT_0 + 3:

            //
            // The event that is set when we had max number of queued
            // traces and we processed one. We should check for traces
            // we could not pick up because the queue had maxed.
            //

            //
            // Fall through to retrieve traces from the kernel.
            //
            
        case WAIT_OBJECT_0 + 1:
            
            //
            // New traces are available event set by the kernel:
            //

            PfSvGetRawTraces();
            
            break;

        case WAIT_OBJECT_0 + 2:
            
            //
            // Prefetch parameters changed event:
            //

            //
            // Get new system prefetch parameters.
            //

            ErrorCode = PfSvQueryPrefetchParameters(&PfSvcGlobals.Parameters);
    
            //
            // If we were not successful, we should not continue.
            //
            
            if (ErrorCode != ERROR_SUCCESS) {
                bExitMainLoop = TRUE;
                DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedQueryParameters2\n"));
                break;
            }

            //
            // Update the path to the prefetch instructions directory.
            //
            
            ErrorCode = PfSvInitializePrefetchDirectory(PfSvcGlobals.Parameters.RootDirPath);

            if (ErrorCode != ERROR_SUCCESS) {
                bExitMainLoop = TRUE;
                DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedReinitPrefetchDir\n"));
                break;
            }

            break;

        default:
            
            //
            // Something gone wrong. Break out, cleanup and exit.
            //

            DBGPR((PFID,PFERR,"PFSVC: MainThread()-WaitForWorkFailed\n"));
            ErrorCode = ERROR_INVALID_HANDLE;
            bExitMainLoop = TRUE;
            
            break;
        }

    } while (!bExitMainLoop);

 cleanup:

    //
    // Save exit information.
    //
    
    if (PfSvcGlobals.ServiceDataKey) {
        PfSvSaveExitInfo(PfSvcGlobals.ServiceDataKey, ErrorCode);
    }

    //
    // Make sure the terminate event is set and wait for all our
    // threads to exit.
    //

    if (NumPrefetcherThreads) {

        //
        // We could not have created worker threads without having
        // initialized the globals successfully.
        //

        PFSVC_ASSERT(PfSvcGlobals.TerminateServiceEvent);
        SetEvent(PfSvcGlobals.TerminateServiceEvent);

        for (ThreadIdx = 0; ThreadIdx < NumPrefetcherThreads; ThreadIdx++) {
            PFSVC_ASSERT(PrefetcherThreads[ThreadIdx]);

            DBGPR((PFID,PFWAIT,"PFSVC: MainThread()-WaitForThreadIdx(%d)\n", ThreadIdx));

            WaitForSingleObject(PrefetcherThreads[ThreadIdx], INFINITE);

            DBGPR((PFID,PFWAIT,"PFSVC: MainThread()-EndWaitForThreadIdx(%d)\n", ThreadIdx));

            CloseHandle(PrefetcherThreads[ThreadIdx]);
        }
    }

    if (hTracesReadyEvent != NULL) {
        CloseHandle(hTracesReadyEvent);
    }

    if (hParametersChangedEvent != NULL) {
        CloseHandle(hParametersChangedEvent);
    }

    //
    // Cleanup all globals.
    //

    PfSvCleanupGlobals();

    DBGPR((PFID,PFTRC,"PFSVC: MainThread()=%x\n", ErrorCode));

    return ErrorCode;
}

//
// Internal service routines:
//

//
// Thread routines:
//

DWORD 
WINAPI
PfSvProcessTraceThread(
    VOID *Param
    )

/*++

Routine Description:

    This is the routine for the thread that processes traces and
    updates scenarios.

Arguments:

    Param - Ignored.

Return Value:

    Win32 error code.

--*/

{
    PFSVC_IDLE_TASK LayoutTask;   
    PFSVC_IDLE_TASK DirectoryCleanupTask;
    PPFSVC_TRACE_BUFFER TraceBuffer;
    PLIST_ENTRY HeadEntry;
    WCHAR *BuildDefragStatus;
    HANDLE CheckForQueuedTracesEvents[3];
    HANDLE BootTraceEvents[2];
    DWORD ErrorCode;
    ULONG TotalTracesProcessed;
    ULONG NumCheckForQueuedTracesEvents;
    ULONG OrgNumQueuedTraces;
    ULONG WaitResult;
    ULONG NumEvents;
    ULONG NumFailedTraces;
    ULONG BuildDefragStatusSize;
    NTSTATUS Status;
    BOOLEAN AcquiredTracesLock;

    //
    // Intialize locals.
    //

    TraceBuffer = NULL;
    TotalTracesProcessed = 0;
    AcquiredTracesLock = FALSE;
    PfSvInitializeTask(&LayoutTask);
    PfSvInitializeTask(&DirectoryCleanupTask);
    BuildDefragStatus = NULL;
    NumFailedTraces = 0;
    
    //
    // These are the events we wait on before picking up traces to
    // process. 
    //

    CheckForQueuedTracesEvents[0] = PfSvcGlobals.TerminateServiceEvent;
    CheckForQueuedTracesEvents[1] = PfSvcGlobals.NewTracesToProcessEvent;
    CheckForQueuedTracesEvents[2] = PfSvcGlobals.OverrideIdleProcessingEvent;
    NumCheckForQueuedTracesEvents = sizeof(CheckForQueuedTracesEvents) / sizeof(HANDLE);

    DBGPR((PFID,PFTRC,"PFSVC: ProcessTraceThread()\n"));

    //
    // Get necessary permissions for this thread to perform prefetch
    // service tasks.
    //

    ErrorCode = PfSvGetPrefetchServiceThreadPrivileges();
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // If we are allowed to run the defragger...     
    //

    if (PfSvAllowedToRunDefragger(FALSE)) {

        //
        // Queue an idle task to check & update the optimal disk layout if 
        // necessary. Ignore failure to do so.
        //

        ErrorCode = PfSvRegisterTask(&LayoutTask,
                                     ItOptimalDiskLayoutTaskId,
                                     PfSvCommonTaskCallback,
                                     PfSvUpdateOptimalLayout);

    }
  
    //
    // Loop forever waiting for traces to process and processing them.
    //

    while(TRUE) {
        
        //
        // Grab queued traces lock to check for queued traces.
        //

        PFSVC_ASSERT(!AcquiredTracesLock);
        PFSVC_ACQUIRE_LOCK(PfSvcGlobals.TracesLock);
        AcquiredTracesLock = TRUE;

        if (!IsListEmpty(&PfSvcGlobals.Traces)) {

            //
            // Dequeue and process the first entry in the list.
            //

            HeadEntry = RemoveHeadList(&PfSvcGlobals.Traces);

            TraceBuffer = CONTAINING_RECORD(HeadEntry,
                                            PFSVC_TRACE_BUFFER,
                                            TracesLink);
            
            
            PFSVC_ASSERT(PfSvcGlobals.NumTraces);
            OrgNumQueuedTraces = PfSvcGlobals.NumTraces;
            PfSvcGlobals.NumTraces--;
            
            //
            // Release the lock.
            //

            PFSVC_RELEASE_LOCK(PfSvcGlobals.TracesLock);
            AcquiredTracesLock = FALSE;

            //
            // If we had maxed the queue, note to check for traces
            // that we may have failed to pick up because the queue
            // was full.
            //
            
            if (OrgNumQueuedTraces == PFSVC_MAX_NUM_QUEUED_TRACES) {
                SetEvent(PfSvcGlobals.CheckForMissedTracesEvent);

                //
                // Let the thread that queries the kernel for traces
                // wake up and run.
                //

                Sleep(0);
            }
            
            //
            // Clear the event that says we don't have traces to
            // process.
            //

            ResetEvent(PfSvcGlobals.ProcessingCompleteEvent);

            //
            // If this is a boot trace, wait for a little while for
            // boot to be really over before processing it.
            //

            if (TraceBuffer->Trace.ScenarioType == PfSystemBootScenarioType) {
                
                BootTraceEvents[0] = PfSvcGlobals.TerminateServiceEvent;
                BootTraceEvents[1] = PfSvcGlobals.OverrideIdleProcessingEvent;
                NumEvents = 2;
                
                PFSVC_ASSERT(NumEvents <= (sizeof(BootTraceEvents) / sizeof(HANDLE)));

                WaitResult = WaitForMultipleObjects(NumEvents,
                                                    BootTraceEvents,
                                                    FALSE,
                                                    45000); // 45 seconds.
                
                if (WaitResult == WAIT_OBJECT_0) {
                    ErrorCode = ERROR_SUCCESS;
                    goto cleanup;
                }
            }

            ErrorCode = PfSvProcessTrace(&TraceBuffer->Trace);

            //
            // Update statistics.
            //

            PfSvcGlobals.NumTracesProcessed++;
            
            if (ErrorCode != ERROR_SUCCESS) {
                PfSvcGlobals.LastTraceFailure = ErrorCode;
            } else {
                PfSvcGlobals.NumTracesSuccessful++;
            }

            //
            // Free the trace buffer.
            //

            VirtualFree(TraceBuffer, 0, MEM_RELEASE);
            TraceBuffer = NULL;

            //
            // Did we just create too many scenario files in the prefetch directory?
            // Queue an idle task to clean up.
            //

            if (PfSvcGlobals.NumPrefetchFiles >= PFSVC_MAX_PREFETCH_FILES) {

                if (!DirectoryCleanupTask.Registered) {

                    //
                    // Make sure we've cleaned up after a possible previous run.
                    //

                    PfSvCleanupTask(&DirectoryCleanupTask);
                    PfSvInitializeTask(&DirectoryCleanupTask);

                    ErrorCode = PfSvRegisterTask(&DirectoryCleanupTask,
                                                 ItPrefetchDirectoryCleanupTaskId,
                                                 PfSvCommonTaskCallback,
                                                 PfSvCleanupPrefetchDirectory);
                }
            }

            //
            // Every so many scenario launches it is good to see if we should update
            // disk layout.
            //

            if (((PfSvcGlobals.NumTracesSuccessful + 1) % 32) == 0) {

                if (PfSvAllowedToRunDefragger(FALSE)) {

                    if (!LayoutTask.Registered) {

                        //
                        // Make sure we've cleaned up after a possible previous run.
                        //

                        PfSvCleanupTask(&LayoutTask);
                        PfSvInitializeTask(&LayoutTask);

                        ErrorCode = PfSvRegisterTask(&LayoutTask,
                                                     ItOptimalDiskLayoutTaskId,
                                                     PfSvCommonTaskCallback,
                                                     PfSvUpdateOptimalLayout);
                    }
                }
            }

        } else {
            
            //
            // The list is empty. Signal that we are done with all the
            // queued traces if we don't have idle tasks to complete.
            //
            
            if (!LayoutTask.Registered && 
                !DirectoryCleanupTask.Registered) {

                SetEvent(PfSvcGlobals.ProcessingCompleteEvent);
            }

            //
            // Release the lock.
            //

            PFSVC_RELEASE_LOCK(PfSvcGlobals.TracesLock);
            AcquiredTracesLock = FALSE;

            //
            // Update the statistics if there were new failed traces.
            //

            if (NumFailedTraces != (PfSvcGlobals.NumTracesProcessed - 
                                    PfSvcGlobals.NumTracesSuccessful)) {

                NumFailedTraces = PfSvcGlobals.NumTracesProcessed - 
                                  PfSvcGlobals.NumTracesSuccessful;
                                  
                PfSvSaveTraceProcessingStatistics(PfSvcGlobals.ServiceDataKey);
            }

            //
            // Wait until new traces are queued.
            //
           
            DBGPR((PFID,PFWAIT,"PFSVC: ProcessTraceThread()-WaitForTrace\n"));

            NumEvents = NumCheckForQueuedTracesEvents;

            WaitResult = WaitForMultipleObjects(NumEvents,
                                                CheckForQueuedTracesEvents,
                                                FALSE,
                                                INFINITE);

            DBGPR((PFID,PFWAIT,"PFSVC: ProcessTraceThread()-EndWaitForTrace=%x\n", WaitResult));

            switch(WaitResult) {

            case WAIT_OBJECT_0:
                
                //
                // Service exit event:
                //

                ErrorCode = ERROR_SUCCESS;
                goto cleanup;

                break;

            case WAIT_OBJECT_0 + 1:
                
                //
                // New traces queued for processing event:
                //

                break;

            case WAIT_OBJECT_0 + 2:
                
                //
                // Idle detection was overriden. If we had registered tasks
                // to be run, we will unregister them and run them manually.
                //

                PfSvSaveTraceProcessingStatistics(PfSvcGlobals.ServiceDataKey);

                if (LayoutTask.Registered) {
                    PfSvUnregisterTask(&LayoutTask, FALSE);
                    PfSvCleanupTask(&LayoutTask);
                    PfSvInitializeTask(&LayoutTask);

                    PfSvUpdateOptimalLayout(NULL);
                }

                if (DirectoryCleanupTask.Registered) {
                    PfSvUnregisterTask(&DirectoryCleanupTask, FALSE);
                    PfSvCleanupTask(&DirectoryCleanupTask);
                    PfSvInitializeTask(&DirectoryCleanupTask);

                    PfSvCleanupPrefetchDirectory(NULL);
                }

                //
                // We will drop out of this block, check & process queued traces
                // and then set the processing complete event.
                //

                break;

            default:

                //
                // Something went wrong...
                //
                
                ErrorCode = ERROR_INVALID_HANDLE;
                goto cleanup;
            }
        }

        //
        // Loop to check if there are new traces.
        //
    }

    //
    // We should not break out of the loop.
    //

    PFSVC_ASSERT(FALSE);

    ErrorCode = ERROR_INVALID_FUNCTION;
    
 cleanup:

    if (AcquiredTracesLock) {
        PFSVC_RELEASE_LOCK(PfSvcGlobals.TracesLock);
    }

    if (TraceBuffer) {
        VirtualFree(TraceBuffer, 0, MEM_RELEASE);
    }

    if (BuildDefragStatus) {
        PFSVC_FREE(BuildDefragStatus);
    }

    PfSvUnregisterTask(&LayoutTask, FALSE);
    PfSvCleanupTask(&LayoutTask);

    PfSvUnregisterTask(&DirectoryCleanupTask, FALSE);
    PfSvCleanupTask(&DirectoryCleanupTask);

    DBGPR((PFID,PFTRC,"PFSVC: ProcessTraceThread()=%x,%d\n", ErrorCode, TotalTracesProcessed));

    return ErrorCode;
}

DWORD 
WINAPI
PfSvPollShellReadyWorker(
    VOID *Param
    )

/*++

Routine Description:

    This is the routine for the thread that is spawned to poll the
    ShellReadyEvent.

Arguments:

    Param - Ignored.

Return Value:

    Win32 error code.

--*/

{
    HANDLE ShellReadyEvent;
    HANDLE Events[2];
    ULONG NumEvents;
    ULONG PollPeriod;
    ULONG TotalPollPeriod;
    DWORD WaitResult;
    DWORD ErrorCode;
    NTSTATUS Status;
    PREFETCHER_INFORMATION PrefetcherInformation;
    PF_BOOT_PHASE_ID PhaseId;
    
    //
    // Initialize locals.
    //
    
    ShellReadyEvent = NULL;
    Events[0] = PfSvcGlobals.TerminateServiceEvent;
    NumEvents = 1;

    DBGPR((PFID,PFTRC,"PFSVC: PollShellReadyThread()\n"));

    //
    // Get necessary permissions for this thread to perform prefetch
    // service tasks.
    //

    ErrorCode = PfSvGetPrefetchServiceThreadPrivileges();
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Until we can open the shell ready event, wait on the service
    // termination event and retry every PollPeriod milliseconds.
    //

    PollPeriod = 1000;
    TotalPollPeriod = 0;

    do {
        
        //
        // Try to open the shell ready event.
        //

        ShellReadyEvent = OpenEvent(EVENT_ALL_ACCESS,FALSE,L"ShellReadyEvent");
        
        if (ShellReadyEvent) {
            break;
        }
        
        //
        // Wait for a while.
        //

        DBGPR((PFID,PFWAIT,"PFSVC: PollShellReadyThread()-WaitForOpen\n"));

        WaitResult = WaitForMultipleObjects(NumEvents,
                                            Events,
                                            FALSE,
                                            PollPeriod);

        DBGPR((PFID,PFWAIT,"PFSVC: PollShellReadyThread()-EndWaitForOpen=%d\n", WaitResult));

        switch(WaitResult) {

        case WAIT_OBJECT_0:
            
            //
            // Service exit event:
            //

            ErrorCode = ERROR_PROCESS_ABORTED;
            goto cleanup;

            break;
            
        case WAIT_TIMEOUT:
            
            //
            // Fall through and try opening the shell ready event again.
            //
            
            break;

        default:
            
            //
            // Something gone wrong. Break out, cleanup and exit.
            //

            ErrorCode = ERROR_INVALID_HANDLE;
            goto cleanup;
        }

        TotalPollPeriod += PollPeriod;

    } while (TotalPollPeriod < 180000);

    //
    // If we could not get the ShellReadyEvent, we timed out.
    //

    if (ShellReadyEvent == NULL) {
        ErrorCode = ERROR_TIMEOUT;
        goto cleanup;
    }

    //
    // Wait on the ShellReadyEvent to be signaled.
    //

    Events[NumEvents] = ShellReadyEvent;
    NumEvents++;

    DBGPR((PFID,PFWAIT,"PFSVC: PollShellReadyThread()-WaitForShell\n"));

    WaitResult = WaitForMultipleObjects(NumEvents,
                                        Events,
                                        FALSE,
                                        60000);

    DBGPR((PFID,PFWAIT,"PFSVC: PollShellReadyThread()-EndWaitForShell=%d\n",WaitResult));

    switch (WaitResult) {

    case WAIT_OBJECT_0:
            
        //
        // Service exit event:
        //
        
        ErrorCode = ERROR_PROCESS_ABORTED;
        goto cleanup;
        
        break;
        
    case WAIT_OBJECT_0 + 1:
        
        //
        // Shell ready event got signaled. Let the kernel mode
        // prefetcher know.
        //

        PhaseId = PfUserShellReadyPhase;

        PrefetcherInformation.Magic = PF_SYSINFO_MAGIC_NUMBER;
        PrefetcherInformation.Version = PF_CURRENT_VERSION;
        PrefetcherInformation.PrefetcherInformationClass = PrefetcherBootPhase;
        PrefetcherInformation.PrefetcherInformation = &PhaseId;
        PrefetcherInformation.PrefetcherInformationLength = sizeof(PhaseId);
            
        Status = NtSetSystemInformation(SystemPrefetcherInformation,
                                        &PrefetcherInformation,
                                        sizeof(PrefetcherInformation));
                    
        //
        // Fall through with the status.
        //
        
        ErrorCode = RtlNtStatusToDosError(Status);

        break;

    case WAIT_TIMEOUT:

        //
        // Shell ready event was created but not signaled...
        //

        ErrorCode = ERROR_TIMEOUT;

        break;
        
    default:
        
        //
        // Something gone wrong.
        //
        
        ErrorCode = GetLastError();

        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = ERROR_INVALID_FUNCTION;
        }
    }

    //
    // Fall through with status from the switch statement.
    //

 cleanup:
    
    if (ShellReadyEvent) {
        CloseHandle(ShellReadyEvent);
    }

    DBGPR((PFID,PFTRC,"PFSVC: PollShellReadyThread()=%x\n", ErrorCode));

    return ErrorCode;
}

//
// Routines called by the main prefetcher thread.
//

DWORD 
PfSvGetRawTraces(
    VOID
    )

/*++

Routine Description:

    This routine checks for new traces prepared by the kernel. The new
    traces are downloaded and queued so they can be processed.

Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    NTSTATUS Status;
    PPFSVC_TRACE_BUFFER TraceBuffer;
    ULONG TraceBufferMaximumLength;
    ULONG TraceBufferLength;
    PREFETCHER_INFORMATION PrefetcherInformation;
    ULONG NumTracesRetrieved;
    ULONG FailedCheck;

    //
    // Initialize locals.
    //

    TraceBuffer = NULL;
    TraceBufferMaximumLength = 0;
    NumTracesRetrieved = 0;

    DBGPR((PFID,PFTRC,"PFSVC: GetRawTraces()\n"));

    //
    // Clear the event that asks us to check for more traces.
    //
    
    ResetEvent(PfSvcGlobals.CheckForMissedTracesEvent);

    //
    // While we do not already have too many traces to process, get
    // traces from the kernel.
    //    

    while (PfSvcGlobals.NumTraces < PFSVC_MAX_NUM_QUEUED_TRACES) { 

        //
        // Retrieve a trace from the kernel.
        //

        PrefetcherInformation.Version = PF_CURRENT_VERSION;
        PrefetcherInformation.Magic = PF_SYSINFO_MAGIC_NUMBER;
        PrefetcherInformation.PrefetcherInformationClass = PrefetcherRetrieveTrace;
        PrefetcherInformation.PrefetcherInformation = &TraceBuffer->Trace;

        if (TraceBufferMaximumLength <= FIELD_OFFSET(PFSVC_TRACE_BUFFER, Trace)) {
            PrefetcherInformation.PrefetcherInformationLength = 0;
        } else {
            PrefetcherInformation.PrefetcherInformationLength = 
                TraceBufferMaximumLength - FIELD_OFFSET(PFSVC_TRACE_BUFFER, Trace);
        }

        Status = NtQuerySystemInformation(SystemPrefetcherInformation,
                                          &PrefetcherInformation,
                                          sizeof(PrefetcherInformation),
                                          &TraceBufferLength);

        if (!NT_SUCCESS(Status)) {

            if (Status == STATUS_BUFFER_TOO_SMALL) {

                if (TraceBuffer != NULL) {
                    VirtualFree(TraceBuffer, 0, MEM_RELEASE);
                }
                
                //
                // Add room for the header we wrap over it.
                //              

                TraceBufferLength += sizeof(PFSVC_TRACE_BUFFER) - sizeof(PF_TRACE_HEADER);

                TraceBufferMaximumLength = ROUND_TRACE_BUFFER_SIZE(TraceBufferLength);  

                TraceBuffer = VirtualAlloc(NULL,
                                           TraceBufferMaximumLength,
                                           MEM_COMMIT,
                                           PAGE_READWRITE);
                if (TraceBuffer == NULL) {
                    ErrorCode = GetLastError();
                    goto cleanup;
                }

                continue;

            } else if (Status == STATUS_NO_MORE_ENTRIES) {

                break;
            }

            ErrorCode = RtlNtStatusToDosError(Status);
            goto cleanup;
        }

#ifdef PFSVC_DBG

        //
        // Write out the trace to a file:
        //

        if (PfSvcDbgMaxNumSavedTraces) {

            WCHAR TraceFilePath[MAX_PATH + 1];
            LONG NumChars;

            //
            // Build up a file name.
            //

            InterlockedIncrement(&PfSvcDbgTraceNumber);

            PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);

            NumChars = _snwprintf(TraceFilePath,
                                  MAX_PATH,
                                  L"%ws\\%ws%d.trc",
                                  PfSvcGlobals.PrefetchRoot,
                                  PfSvcDbgTraceBaseName,
                                  PfSvcDbgTraceNumber % PfSvcDbgMaxNumSavedTraces);

            PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
            
            if (NumChars > 0 && NumChars < MAX_PATH) {
                
                //
                // Make sure the path is terminated.
                //

                TraceFilePath[MAX_PATH - 1] = 0;
                
                //
                // Write out the trace.
                //
                
                PfSvWriteBuffer(TraceFilePath, 
                                &TraceBuffer->Trace, 
                                TraceBuffer->Trace.Size);
            }
        }

#endif // PFSVC_DBG

        //
        // Verify integrity of the trace.
        //

        if (!PfVerifyTraceBuffer(&TraceBuffer->Trace, 
                                 TraceBuffer->Trace.Size, 
                                 &FailedCheck)) {
            DBGPR((PFID,PFWARN,"PFSVC: IGNORING TRACE\n"));
            continue;
        }

        //
        // Put it on the list of traces to process.
        //
        
        PFSVC_ACQUIRE_LOCK(PfSvcGlobals.TracesLock);

        InsertTailList(&PfSvcGlobals.Traces, &TraceBuffer->TracesLink);
        PfSvcGlobals.NumTraces++;

        PFSVC_RELEASE_LOCK(PfSvcGlobals.TracesLock);

        //
        // Notify that there are new traces to process.
        //

        SetEvent(PfSvcGlobals.NewTracesToProcessEvent);

        //
        // Clean out the loop variables.
        //
        
        TraceBuffer = NULL;
        TraceBufferMaximumLength = 0;
        TraceBufferLength = 0;

        NumTracesRetrieved++;
    }
    
    //
    // We should never go above the limit of queued traces.
    //
    
    PFSVC_ASSERT(PfSvcGlobals.NumTraces <= PFSVC_MAX_NUM_QUEUED_TRACES);
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (TraceBuffer != NULL) {
        VirtualFree(TraceBuffer, 0, MEM_RELEASE);
    }

    DBGPR((PFID,PFTRC,"PFSVC: GetRawTraces()=%x,%d\n", ErrorCode, NumTracesRetrieved));

    return ErrorCode;
}

DWORD
PfSvInitializeGlobals(
    VOID
    )

/*++

Routine Description:

    This routine initializes the global variables / tables etc.

Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    NTSTATUS Status;
    DWORD ErrorCode;
    ULONG FileIdx;
    WCHAR *CSCRootPath;
    ULONG CSCRootPathMaxChars;

    //
    // These are the path suffices to recognize files we don't want to 
    // prefetch for boot. Keep these sorted lexically going from
    // LAST CHARACTER TO FIRST and UPCASE.
    //

    static WCHAR *FilesToIgnoreForBoot[] = {
           L"SYSTEM32\\CONFIG\\SOFTWARE",
                     L"\\WMI\\TRACE.LOG",
       L"SYSTEM32\\CONFIG\\SOFTWARE.LOG",
            L"SYSTEM32\\CONFIG\\SAM.LOG",
         L"SYSTEM32\\CONFIG\\SYSTEM.LOG",
        L"SYSTEM32\\CONFIG\\DEFAULT.LOG",
       L"SYSTEM32\\CONFIG\\SECURITY.LOG",
                           L"\\PERF.ETL",
                L"SYSTEM32\\CONFIG\\SAM",
             L"SYSTEM32\\CONFIG\\SYSTEM",
         L"SYSTEM32\\CONFIG\\SYSTEM.ALT",
            L"SYSTEM32\\CONFIG\\DEFAULT",
           L"SYSTEM32\\CONFIG\\SECURITY",
    };

    DBGPR((PFID,PFTRC,"PFSVC: InitializeGlobals()\n"));
    
    //
    // Zero out the globals structure so we know what to cleanup if
    // the initialization fails in the middle.
    //

    RtlZeroMemory(&PfSvcGlobals, sizeof(PfSvcGlobals));

    //
    // Initialize the list of traces to be processed.
    //
    
    InitializeListHead(&PfSvcGlobals.Traces);
    PfSvcGlobals.NumTraces = 0;

    //
    // We have not launched the defragger for anything yet.
    //

    PfSvcGlobals.DefraggerErrorCode = ERROR_SUCCESS;

    //
    // Initialize table for registry files that we don't want to
    // prefetch for boot.
    //

    PfSvcGlobals.FilesToIgnoreForBoot = FilesToIgnoreForBoot;
    PfSvcGlobals.NumFilesToIgnoreForBoot = 
        sizeof(FilesToIgnoreForBoot) / sizeof(WCHAR *);

    //
    // Get OS version information.
    //

    RtlZeroMemory(&PfSvcGlobals.OsVersion, sizeof(PfSvcGlobals.OsVersion));
    PfSvcGlobals.OsVersion.dwOSVersionInfoSize = sizeof(PfSvcGlobals.OsVersion);
    Status = RtlGetVersion((POSVERSIONINFOW)&PfSvcGlobals.OsVersion);

    if (!NT_SUCCESS(Status)) {
        DBGPR((PFID,PFERR,"PFSVC: MainThread()-FailedGetOSVersion\n"));
        ErrorCode = RtlNtStatusToDosError(Status);
        goto cleanup;
    }

   
    //
    // Initialize the table of ignored files' suffix lengths.
    //
  
    PfSvcGlobals.FileSuffixLengths = 
        PFSVC_ALLOC(PfSvcGlobals.NumFilesToIgnoreForBoot * sizeof(ULONG));

    if (!PfSvcGlobals.FileSuffixLengths) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    for (FileIdx = 0; 
         FileIdx < PfSvcGlobals.NumFilesToIgnoreForBoot; 
         FileIdx++) {
        
        PfSvcGlobals.FileSuffixLengths[FileIdx] = 
            wcslen(PfSvcGlobals.FilesToIgnoreForBoot[FileIdx]);
    }   

    //
    // Create an event that will get signaled when the service is
    // exiting.
    //

    PfSvcGlobals.TerminateServiceEvent = CreateEvent(NULL,
                                                     TRUE,
                                                     FALSE,
                                                     NULL);
    
    if (PfSvcGlobals.TerminateServiceEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize the lock for the list of traces to be processed.
    //
    
    PfSvcGlobals.TracesLock = CreateMutex(NULL, FALSE, NULL);
    if (PfSvcGlobals.TracesLock == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize the events that are used to communicate between the
    // acquirer and processor of the traces.
    //
    
    PfSvcGlobals.NewTracesToProcessEvent = CreateEvent(NULL,
                                                       FALSE,
                                                       FALSE,
                                                       NULL);
    if (PfSvcGlobals.NewTracesToProcessEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    PfSvcGlobals.CheckForMissedTracesEvent = CreateEvent(NULL,
                                                         FALSE,
                                                         FALSE,
                                                         NULL);
    if (PfSvcGlobals.CheckForMissedTracesEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // This named manual-reset event can be set to force all traces to
    // be processed as soon as they become available rather than
    // waiting for the system to become idle first.
    //

    PfSvcGlobals.OverrideIdleProcessingEvent = CreateEvent(NULL,
                                                           TRUE,
                                                           FALSE,
                                                           PFSVC_OVERRIDE_IDLE_EVENT_NAME);
    if (PfSvcGlobals.OverrideIdleProcessingEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // This named manual-reset event is created signaled. When this
    // event is signaled, it means there are no traces we have to
    // process now.
    //

    PfSvcGlobals.ProcessingCompleteEvent = CreateEvent(NULL,
                                                       TRUE,
                                                       TRUE,
                                                       PFSVC_PROCESSING_COMPLETE_EVENT_NAME);

    if (PfSvcGlobals.ProcessingCompleteEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    //
    // Initialize prefetch root path and the lock to protect it. The
    // real root path will be initialized after parameters are queried
    // from the kernel.
    //

    PfSvcGlobals.PrefetchRoot[0] = 0;
    PfSvcGlobals.PrefetchRootLock = CreateMutex(NULL, FALSE, NULL);
    if (PfSvcGlobals.PrefetchRootLock == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    PfSvcGlobals.NumPrefetchFiles = 0;

    //
    // Open the service data registry key, creating it if necessary.
    //

    ErrorCode = RegCreateKey(HKEY_LOCAL_MACHINE,
                             PFSVC_SERVICE_DATA_KEY,
                             &PfSvcGlobals.ServiceDataKey);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Check the registry to see if the user does not want us to run 
    // the defragger.
    //

    ErrorCode = PfSvGetDontRunDefragger(&PfSvcGlobals.DontRunDefragger);

    if (ErrorCode != ERROR_SUCCESS) {

        //
        // By default we will run the defragger.
        //
    
        PfSvcGlobals.DontRunDefragger = FALSE;
    }

    //
    // Determine CSC root path. It won't be used if we can't allocate or 
    // determine it, so don't worry about the error code.
    //

    CSCRootPathMaxChars = MAX_PATH + 1;

    CSCRootPath = PFSVC_ALLOC(CSCRootPathMaxChars * sizeof(CSCRootPath[0]));

    if (CSCRootPath) {

        ErrorCode = PfSvGetCSCRootPath(CSCRootPath, CSCRootPathMaxChars);

        if (ErrorCode == ERROR_SUCCESS) {
            PfSvcGlobals.CSCRootPath = CSCRootPath;
        }
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: InitializeGlobals()=%x\n", ErrorCode));

    return ErrorCode;
}

VOID
PfSvCleanupGlobals(
    VOID
    )

/*++

Routine Description:

    This routine uninitializes the global variables / tables etc.

Arguments:

    None.

Return Value:

    VOID

--*/

{
    PPFSVC_TRACE_BUFFER TraceBuffer;
    PLIST_ENTRY ListHead;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_PAGE_NODE PageNode;

    DBGPR((PFID,PFTRC,"PFSVC: CleanupGlobals()\n"));

    //
    // Free allocated table.
    //

    if (PfSvcGlobals.FileSuffixLengths) {
        PFSVC_FREE(PfSvcGlobals.FileSuffixLengths);
    }
    
    //
    // Free queued traces.
    //
    
    while (!IsListEmpty(&PfSvcGlobals.Traces)) {

        ListHead = RemoveHeadList(&PfSvcGlobals.Traces);
        
        PFSVC_ASSERT(PfSvcGlobals.NumTraces);
        PfSvcGlobals.NumTraces--;

        TraceBuffer = CONTAINING_RECORD(ListHead,
                                        PFSVC_TRACE_BUFFER,
                                        TracesLink);
        
        VirtualFree(TraceBuffer, 0, MEM_RELEASE);
    }
    
    //
    // Close handles to opened events/mutexes.
    //
    
    if (PfSvcGlobals.TerminateServiceEvent) {
        CloseHandle(PfSvcGlobals.TerminateServiceEvent);
    }
    
    if (PfSvcGlobals.TracesLock) {
        CloseHandle(PfSvcGlobals.TracesLock);
    }

    if (PfSvcGlobals.NewTracesToProcessEvent) {
        CloseHandle(PfSvcGlobals.NewTracesToProcessEvent);
    }
    
    if (PfSvcGlobals.CheckForMissedTracesEvent) {
        CloseHandle(PfSvcGlobals.CheckForMissedTracesEvent);
    }

    if (PfSvcGlobals.OverrideIdleProcessingEvent) {
        CloseHandle(PfSvcGlobals.OverrideIdleProcessingEvent);
    }

    if (PfSvcGlobals.ProcessingCompleteEvent) {
        CloseHandle(PfSvcGlobals.ProcessingCompleteEvent);
    }
    
    if (PfSvcGlobals.PrefetchRootLock) {
        CloseHandle(PfSvcGlobals.PrefetchRootLock);
    }

    //
    // Close service data key handle.
    //
    
    if (PfSvcGlobals.ServiceDataKey) {
        RegCloseKey(PfSvcGlobals.ServiceDataKey);
    }

    //
    // Free CSC root path.
    //

    if (PfSvcGlobals.CSCRootPath) {
        PFSVC_FREE(PfSvcGlobals.CSCRootPath);
    }
}

DWORD
PfSvGetCSCRootPath (
    WCHAR *CSCRootPath,
    ULONG CSCRootPathMaxChars
    )

/*++

Routine Description:

    This routine determines the root path for CSC (client side caching) files.

Arguments:

    CSCRootPath - If successful, a NUL terminated string is copied into this buffer.

    CSCRootPathMaxChars - Maximum bytes we can copy into CSCRootPath buffer including
      the terminating NUL.
    
Return Value:

    Win32 error code.

--*/

{
    WCHAR CSCDirName[] = L"CSC";
    HKEY CSCKeyHandle;
    BOOL Success;
    ULONG WindowsDirectoryLength;
    ULONG CSCRootPathLength;
    ULONG RequiredNumChars;
    DWORD ErrorCode;
    DWORD BufferSize;
    DWORD ValueType;

    //
    // Initialize locals.
    //

    CSCKeyHandle = NULL;

    //
    // Open CSC parameters key.
    //

    ErrorCode = RegOpenKey(HKEY_LOCAL_MACHINE,
                           TEXT(REG_STRING_NETCACHE_KEY_A),
                           &CSCKeyHandle);

    if (ErrorCode == ERROR_SUCCESS) {

        //
        // Query system setting for the CSC root path.
        //

        BufferSize = CSCRootPathMaxChars * sizeof(CSCRootPath[0]);

        ErrorCode = RegQueryValueEx(CSCKeyHandle,
                                    TEXT(REG_STRING_DATABASE_LOCATION_A),
                                    NULL,
                                    &ValueType,
                                    (PVOID)CSCRootPath,
                                    &BufferSize);

        if (ErrorCode == ERROR_SUCCESS) {

            //
            // Sanity check the length.
            //

            if ((BufferSize / sizeof(CSCRootPath[0])) < MAX_PATH) {

                //
                // We got what we wanted. Make sure it has room for and is terminated 
                // by a slash.
                //

                CSCRootPathLength = wcslen(CSCRootPath);

                if (CSCRootPathLength < CSCRootPathMaxChars - 1) {

                    if (CSCRootPath[CSCRootPathLength - 1] != L'\\') {
                        CSCRootPath[CSCRootPathLength] = L'\\';
                        CSCRootPathLength++;
                        CSCRootPath[CSCRootPathLength] = L'\0';
                    }
                    
                    ErrorCode = ERROR_SUCCESS;
                    goto cleanup;
                }
            }
        }
    }
                               
    //
    // If we come here, we have to use the default CSC path i.e. %windir%\CSC
    //

    WindowsDirectoryLength = GetWindowsDirectory(CSCRootPath,
                                                 CSCRootPathMaxChars - 1);

    if (WindowsDirectoryLength == 0) {

        //
        // There was an error.
        //

        ErrorCode = GetLastError();
        PFSVC_ASSERT(ErrorCode != ERROR_SUCCESS);
        goto cleanup;
    }

    //
    // See if we have room to add \CSC\ and a terminating NUL.
    //

    RequiredNumChars = WindowsDirectoryLength;
    RequiredNumChars ++;                                // leading backslash.
    RequiredNumChars += wcslen(CSCDirName);             // CSC.
    RequiredNumChars ++;                                // ending backslash.
    RequiredNumChars ++;                                // terminating NUL.

    if (CSCRootPathMaxChars < RequiredNumChars) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Build up the path:
    //

    CSCRootPathLength = WindowsDirectoryLength;

    if (CSCRootPath[CSCRootPathLength - 1] != L'\\') {
        CSCRootPath[CSCRootPathLength] = L'\\';
        CSCRootPathLength++;
    }

    wcscpy(CSCRootPath + CSCRootPathLength, CSCDirName);
    CSCRootPathLength += wcslen(CSCDirName);

    CSCRootPath[CSCRootPathLength] = L'\\';
    CSCRootPathLength++;

    //
    // Terminate the string.
    //

    CSCRootPath[CSCRootPathLength] = L'\0';
    
    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

  cleanup:

    if (CSCKeyHandle) {
        RegCloseKey(CSCKeyHandle);
    }

    if (ErrorCode == ERROR_SUCCESS) {

        //
        // We have the path in CSCRootPath. It should be in the X:\path\
        // format. It should also be somewhat long, otherwise we will mismatch
        // to too many files that we will not prefetch. It should also be
        // terminated by a \ and NUL.
        //

        PFSVC_ASSERT(CSCRootPathLength < CSCRootPathMaxChars);

        if ((CSCRootPathLength > 6) &&
            (CSCRootPath[1] == L':') &&
            (CSCRootPath[2] == L'\\') &&
            (CSCRootPath[CSCRootPathLength - 1] == L'\\') &&
            (CSCRootPath[CSCRootPathLength] == L'\0')) {

            //
            // Remove the X: from the beginning of the path so we can match
            // it to NT paths like \Device\HarddiskVolume1. Note that we have 
            // to move the terminating NUL too.
            //

            MoveMemory(CSCRootPath, 
                       CSCRootPath + 2, 
                       (CSCRootPathLength - 1) * sizeof(CSCRootPath[0]));

            CSCRootPathLength -= 2;

            //
            // Upcase the path so we don't have to do expensive case insensitive
            // comparisons.
            //

            _wcsupr(CSCRootPath);

        } else {

            ErrorCode = ERROR_BAD_FORMAT;
        }
    }

    return ErrorCode;
}

DWORD
PfSvSetPrefetchParameters(
    PPF_SYSTEM_PREFETCH_PARAMETERS Parameters
    )

/*++

Routine Description:

    This routine updates the system prefetch parameters in the kernel.

Arguments:

    Parameters - Pointer to parameters structure.
    
Return Value:

    Win32 error code.

--*/

{
    PREFETCHER_INFORMATION PrefetcherInformation;
    NTSTATUS Status;
    DWORD ErrorCode;
    ULONG Length;

    PrefetcherInformation.Magic = PF_SYSINFO_MAGIC_NUMBER;
    PrefetcherInformation.Version = PF_CURRENT_VERSION;
    PrefetcherInformation.PrefetcherInformationClass = PrefetcherSystemParameters;
    PrefetcherInformation.PrefetcherInformation = Parameters;
    PrefetcherInformation.PrefetcherInformationLength = sizeof(*Parameters);
    
    Status = NtSetSystemInformation(SystemPrefetcherInformation,
                                    &PrefetcherInformation,
                                    sizeof(PrefetcherInformation));
    
    if (!NT_SUCCESS(Status)) {
        ErrorCode = RtlNtStatusToDosError(Status);
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:

    return ErrorCode;
}

DWORD
PfSvQueryPrefetchParameters(
    PPF_SYSTEM_PREFETCH_PARAMETERS Parameters
    )

/*++

Routine Description:

    This routine queries the system prefetch parameters from the kernel.
    The calling thread must have called PfSvGetPrefetchServiceThreadPrivileges.

Arguments:

    Parameters - Pointer to structure to update.
    
Return Value:

    Win32 error code.

--*/

{
    PREFETCHER_INFORMATION PrefetcherInformation;
    NTSTATUS Status;
    DWORD ErrorCode;
    ULONG Length;

    PrefetcherInformation.Magic = PF_SYSINFO_MAGIC_NUMBER;
    PrefetcherInformation.Version = PF_CURRENT_VERSION;
    PrefetcherInformation.PrefetcherInformationClass = PrefetcherSystemParameters;
    PrefetcherInformation.PrefetcherInformation = Parameters;
    PrefetcherInformation.PrefetcherInformationLength = sizeof(*Parameters);
    
    Status = NtQuerySystemInformation(SystemPrefetcherInformation,
                                      &PrefetcherInformation,
                                      sizeof(PrefetcherInformation),
                                      &Length);


    if (!NT_SUCCESS(Status)) {
        ErrorCode = RtlNtStatusToDosError(Status);
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:

    return ErrorCode;
}

DWORD
PfSvInitializePrefetchDirectory(
    WCHAR *PathFromSystemRoot
    )

/*++

Routine Description:

    This routine builds up full path for the prefetch instructions
    directory given PathFromSystemRoot, makes sure this directory
    exists, and sets the security information on it. Finally, the
    global PrefetchRoot path is updated with path to the new
    directory.

    Global NumPrefetchFiles is also updated.

    The calling thread must have the SE_TAKE_OWNERSHIP_NAME privilege.

Arguments:

    PathFromSystemRoot - Path to the prefetch directory from SystemRoot.

Return Value:

    Win32 error code.

--*/

{
    ULONG PathLength;
    ULONG NumFiles;
    HANDLE DirHandle;
    DWORD ErrorCode;
    DWORD FileAttributes;
    WCHAR FullDirPathBuffer[MAX_PATH + 1];
   
    //
    // Initialize locals.
    //

    DirHandle = INVALID_HANDLE_VALUE;

    DBGPR((PFID,PFTRC,"PFSVC: InitPrefetchDir(%ws)\n",PathFromSystemRoot));
    
    //
    // Build path name to the prefetch files directory.
    // ExpandEnvironmentStrings return length includes space for
    // the terminating NUL character.
    //

    PathLength = ExpandEnvironmentStrings(L"%SystemRoot%\\",
                                          FullDirPathBuffer,
                                          MAX_PATH);


    PathLength += wcslen(PathFromSystemRoot);
    
    if (PathLength > MAX_PATH) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Copy the path from system root.
    //

    wcscat(FullDirPathBuffer, PathFromSystemRoot);

    //
    // Create the directory if it does not already exist.
    //
    
    if (!CreateDirectory(FullDirPathBuffer, NULL)) {
        
        ErrorCode = GetLastError();
        
        if (ErrorCode == ERROR_ALREADY_EXISTS) {
            
            //
            // The directory, or a file with that name may already
            // exist. Make sure it is the former.
            //
            
            FileAttributes = GetFileAttributes(FullDirPathBuffer);
            
            if (FileAttributes == 0xFFFFFFFF) {
                ErrorCode = GetLastError();
                goto cleanup;
            }
            
            if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                ErrorCode = ERROR_CANNOT_MAKE;
                goto cleanup;
            }

        } else {
            goto cleanup;
        }
    }

    //
    // Disable indexing of the prefetch directory.
    //

    FileAttributes = GetFileAttributes(FullDirPathBuffer);
    
    if (FileAttributes == 0xFFFFFFFF) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (!SetFileAttributes(FullDirPathBuffer,
                           FileAttributes | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Set permissions.
    //

    ErrorCode = PfSvSetAdminOnlyPermissions(FullDirPathBuffer, NULL, SE_FILE_OBJECT);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Count the scenario files in the directory.
    //

    ErrorCode = PfSvCountFilesInDirectory(FullDirPathBuffer,
                                          L"*." PF_PREFETCH_FILE_EXTENSION,
                                          &NumFiles);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Update the global prefetch root directory path.
    //

    PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);
    
    wcscpy(PfSvcGlobals.PrefetchRoot, FullDirPathBuffer);
    PfSvcGlobals.NumPrefetchFiles = NumFiles;

    PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: InitPrefetchDir(%ws)=%x\n",PathFromSystemRoot,ErrorCode));

    return ErrorCode;           
}

DWORD
PfSvCountFilesInDirectory(
    WCHAR *DirectoryPath,
    WCHAR *MatchExpression,
    PULONG NumFiles
    )

/*++

Routine Description:

    This is routine returns the number of files in the specified 
    directory whose names match the specified expression.

Arguments:

    DirectoryPath - NULL terminated path to the directory.

    MatchExpression - Something like "*.pf" Don't go nuts with DOS
      type expressions, this function won't try to transmogrify them.

    NumFiles - Number of files are returned here. Bogus if returned error.

Return Value:

    Win32 error code.

--*/

{
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING DirectoryPathU;
    UNICODE_STRING MatchExpressionU;
    HANDLE DirectoryHandle;
    PVOID QueryBuffer;
    PFILE_NAMES_INFORMATION FileInfo;
    ULONG QueryBufferSize;
    ULONG FileCount;
    NTSTATUS Status;
    DWORD ErrorCode;
    BOOLEAN Success;
    BOOLEAN AllocatedDirectoryPathU;
    BOOLEAN OpenedDirectory;
    BOOLEAN RestartScan;

    //
    // Initialize locals.
    //

    AllocatedDirectoryPathU = FALSE;
    OpenedDirectory = FALSE;
    QueryBuffer = NULL;
    QueryBufferSize = 0;
    RtlInitUnicodeString(&MatchExpressionU, MatchExpression);

    DBGPR((PFID,PFTRC,"PFSVC: CountFilesInDirectory(%ws,%ws)\n", DirectoryPath, MatchExpression));

    //
    // Convert the path to NT path.
    //

    Success = RtlDosPathNameToNtPathName_U(DirectoryPath,
                                           &DirectoryPathU,
                                           NULL,
                                           NULL);

    if (!Success) {
        ErrorCode = ERROR_PATH_NOT_FOUND;
        goto cleanup;
    }

    AllocatedDirectoryPathU = TRUE;

    //
    // Open the directory.
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               &DirectoryPathU,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&DirectoryHandle,
                        FILE_LIST_DIRECTORY | SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | 
                          FILE_SYNCHRONOUS_IO_NONALERT | 
                          FILE_OPEN_FOR_BACKUP_INTENT);

    if (!NT_SUCCESS(Status)) {
        ErrorCode = RtlNtStatusToDosError(Status);
        goto cleanup;
    }

    OpenedDirectory = TRUE;

    //
    // Allocate a decent sized query buffer.
    //

    QueryBufferSize = sizeof(FILE_NAMES_INFORMATION) + MAX_PATH * sizeof(WCHAR);
    QueryBufferSize *= 16;
    QueryBuffer = PFSVC_ALLOC(QueryBufferSize);

    if (!QueryBuffer) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Loop querying file data. We query FileNamesInformation so
    // we don't have to access file metadata.
    //

    RestartScan = TRUE;
    FileCount = 0;

    while (TRUE) {

        Status = NtQueryDirectoryFile(DirectoryHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      QueryBuffer,
                                      QueryBufferSize,
                                      FileNamesInformation,
                                      FALSE,
                                      &MatchExpressionU,
                                      RestartScan);

        RestartScan = FALSE;

        //
        // If there are no files that match the format, then we'll get 
        // STATUS_NO_SUCH_FILE.
        //

        if (Status == STATUS_NO_SUCH_FILE && (FileCount == 0)) {

            //
            // We'll return the fact that there are no such files in the
            // directory.
            //

            break;
        }

        if (Status == STATUS_NO_MORE_FILES) {

            //
            // We are done.
            //

            break;
        }

        if (NT_ERROR(Status)) {

            ErrorCode = RtlNtStatusToDosError(Status);
            goto cleanup;
        }

        //
        // Go through the files returned in the buffer.
        //

        for (FileInfo = QueryBuffer;
             ((PUCHAR) FileInfo < ((PUCHAR) QueryBuffer + QueryBufferSize));
             FileInfo = (PVOID) (((PUCHAR) FileInfo) + FileInfo->NextEntryOffset)) {

            FileCount++;

            if (!FileInfo->NextEntryOffset) {
                break;
            }
        }
    }

    *NumFiles = FileCount;

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: CountFilesInDirectory(%ws)=%d,%x\n", DirectoryPath, *NumFiles, ErrorCode));

    if (AllocatedDirectoryPathU) {
        RtlFreeHeap(RtlProcessHeap(), 0, DirectoryPathU.Buffer);
    }

    if (OpenedDirectory) {
        NtClose(DirectoryHandle);
    }

    if (QueryBuffer) {
        PFSVC_FREE(QueryBuffer);
    }

    return ErrorCode;
}

//
// Routines to process acquired traces:
//

DWORD
PfSvProcessTrace(
    PPF_TRACE_HEADER Trace
    )

/*++

Routine Description:

    This routine is called to process a trace and update the the
    scenario file.

Arguments:

    Trace - Pointer to trace.

Return Value:

    Win32 error code.

--*/

{
    PPF_SCENARIO_HEADER Scenario;    
    PFSVC_SCENARIO_INFO ScenarioInfo;
    PPF_SCENARIO_HEADER NewScenHeader;
    WCHAR ScenarioFilePath[MAX_PATH];
    ULONG ScenarioFilePathMaxChars;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    PfSvInitializeScenarioInfo(&ScenarioInfo,
                               &Trace->ScenarioId,
                               Trace->ScenarioType);

    ScenarioFilePathMaxChars = sizeof(ScenarioFilePath) / 
                               sizeof(ScenarioFilePath[0]);

    Scenario = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: ProcessTrace(%p)\n", Trace));

    //
    // Build file path to existing information for this scenario.
    //

    ErrorCode = PfSvScenarioGetFilePath(ScenarioFilePath,
                                        ScenarioFilePathMaxChars,
                                        &Trace->ScenarioId);

    if (ErrorCode != ERROR_SUCCESS) {

        //
        // The buffer we specified should have been big enough. This call
        // should not fail.
        //

        PFSVC_ASSERT(ErrorCode == ERROR_SUCCESS);

        goto cleanup;
    }

    //
    // Map and verify scenario file if it exists. If we cannot open it,
    // NULL Scenario should be returned.
    //

    ErrorCode = PfSvScenarioOpen(ScenarioFilePath, 
                                 &Trace->ScenarioId,
                                 Trace->ScenarioType,
                                 &Scenario);
                                 
    PFSVC_ASSERT(Scenario || ErrorCode);

    //
    // Allocate memory upfront for trace & scenario processing.
    //

    ErrorCode = PfSvScenarioInfoPreallocate(&ScenarioInfo,
                                            Scenario,
                                            Trace);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Incorporate information from any existing scenario file.
    //

    if (Scenario) {

        ErrorCode = PfSvAddExistingScenarioInfo(&ScenarioInfo, Scenario);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Unmap the scenario so we can write over it when done.
        //

        UnmapViewOfFile(Scenario);
        Scenario = NULL;
    }

    //
    // If this is the first launch of this scenario, it is likely that we
    // will create a new scenario file for it. 
    //

    if (ScenarioInfo.ScenHeader.NumLaunches == 1) {

        //
        // Do we already have too many scenario files in the prefetch directory?
        //

        if (PfSvcGlobals.NumPrefetchFiles > PFSVC_MAX_PREFETCH_FILES) {

            //
            // If this is not the boot scenario, we'll ignore it. We don't
            // create new scenario files until we clean up the old ones.
            //

            if (ScenarioInfo.ScenHeader.ScenarioType != PfSystemBootScenarioType) {

                #ifndef PFSVC_DBG

                ErrorCode = ERROR_TOO_MANY_OPEN_FILES;
                goto cleanup;

                #endif // !PFSVC_DBG
            }
        }

        PfSvcGlobals.NumPrefetchFiles++;
    }

    //
    // Verify that volume magics from existing scenario match those in
    // the new trace. If volumes change beneath us we'd need to fix
    // file paths in the existing scenario. But that is too much work,
    // so for now we just start new.
    //

    if (!PfSvVerifyVolumeMagics(&ScenarioInfo, Trace)) {

        PfSvCleanupScenarioInfo(&ScenarioInfo);

        PfSvInitializeScenarioInfo(&ScenarioInfo,
                                   &Trace->ScenarioId,
                                   Trace->ScenarioType);

        ErrorCode = PfSvScenarioInfoPreallocate(&ScenarioInfo,
                                                NULL,
                                                Trace);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Also delete the existing scenario instruction in case we
        // fail to update them since they are invalid now.
        //
        
        DeleteFile(ScenarioFilePath);
    }

    //
    // Merge information from new trace.
    //
        
    ErrorCode = PfSvAddTraceInfo(&ScenarioInfo, Trace);
        
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
    
    //
    // Decide which pages to actually prefetch next time, and
    // eliminate uninteresting sections and pages.
    //
    
    ErrorCode = PfSvApplyPrefetchPolicy(&ScenarioInfo);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // If no pages/sections are left in the scenario after applying
    // the policy, we'll delete the scenario file.
    //

    if (ScenarioInfo.ScenHeader.NumSections == 0 || 
        ScenarioInfo.ScenHeader.NumPages == 0) {

        //
        // We cannot have sections without pages or vice versa.
        //

        PFSVC_ASSERT(ScenarioInfo.ScenHeader.NumSections == 0);
        PFSVC_ASSERT(ScenarioInfo.ScenHeader.NumPages == 0);

        //
        // Remove the scenario file.
        //
        
        DeleteFile(ScenarioFilePath);
        
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Sort remaining sections by first access.
    //
    
    ErrorCode = PfSvSortSectionNodesByFirstAccess(&ScenarioInfo.SectionList);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
 
    //
    // Write out new scenario file.
    //
            
    ErrorCode = PfSvWriteScenario(&ScenarioInfo, ScenarioFilePath);

    //
    // Fall through with status.
    //
        
 cleanup:

    PfSvCleanupScenarioInfo(&ScenarioInfo);

    if (Scenario) {
        UnmapViewOfFile(Scenario);
    }

    DBGPR((PFID,PFTRC,"PFSVC: ProcessTrace(%p)=%x\n", Trace, ErrorCode));
        
    return ErrorCode;
}

VOID
PfSvInitializeScenarioInfo (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_SCENARIO_ID ScenarioId,
    PF_SCENARIO_TYPE ScenarioType
    )

/*++

Routine Description:

    This routine initializes the specified new scenario structure. It
    sets the fields of the embedded scenario header as if no previous
    scenario information is available.

Arguments:

    ScenarioInfo - Pointer to structure to initialize.

    ScenarioId & ScenarioType - Identifiers for the scenario.

Return Value:

    None.

--*/

{

    //
    // Initialize ScenarioInfo so we know what to cleanup. Zeroing the structure
    // takes care of the following fields:
    //   OneBigAllocation
    //   NewPages
    //   HitPages
    //   MissedOpportunityPages
    //   IgnoredPages
    //   PrefetchedPages
    //

    RtlZeroMemory(ScenarioInfo, sizeof(PFSVC_SCENARIO_INFO));
    InitializeListHead(&ScenarioInfo->SectionList);
    InitializeListHead(&ScenarioInfo->VolumeList);
    PfSvChunkAllocatorInitialize(&ScenarioInfo->SectionNodeAllocator);
    PfSvChunkAllocatorInitialize(&ScenarioInfo->PageNodeAllocator);
    PfSvChunkAllocatorInitialize(&ScenarioInfo->VolumeNodeAllocator);
    PfSvStringAllocatorInitialize(&ScenarioInfo->PathAllocator);
    
    //
    // Initialize the embedded scenario header.
    //
    
    ScenarioInfo->ScenHeader.Version = PF_CURRENT_VERSION;
    ScenarioInfo->ScenHeader.MagicNumber = PF_SCENARIO_MAGIC_NUMBER;
    ScenarioInfo->ScenHeader.ServiceVersion = PFSVC_SERVICE_VERSION;
    ScenarioInfo->ScenHeader.Size = 0;
    ScenarioInfo->ScenHeader.ScenarioId = *ScenarioId;
    ScenarioInfo->ScenHeader.ScenarioType = ScenarioType;
    ScenarioInfo->ScenHeader.NumSections = 0;
    ScenarioInfo->ScenHeader.NumPages = 0;
    ScenarioInfo->ScenHeader.FileNameInfoSize = 0;
    ScenarioInfo->ScenHeader.NumLaunches = 1;
    ScenarioInfo->ScenHeader.Sensitivity = PF_MIN_SENSITIVITY;

    //
    // These fields help us not prefetch if a scenario is getting
    // launched too frequently. RePrefetchTime and ReTraceTime's get
    // set to default values after the scenario is launched a number
    // of times. This allows training scenarios run after clearing the
    // prefetch cache to be traced correctly.
    //

    ScenarioInfo->ScenHeader.LastLaunchTime.QuadPart = 0;
    ScenarioInfo->ScenHeader.MinRePrefetchTime.QuadPart = 0;
    ScenarioInfo->ScenHeader.MinReTraceTime.QuadPart = 0;

    return;
}

VOID 
PfSvCleanupScenarioInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo
    )

/*++

Routine Description:

    This function cleans up a scenario info structure. It does not
    free the structure itself. The structure should have been
    initialized by PfSvInitializeScenarioInfo.

Arguments:

    ScenarioInfo - Pointer to structure.

Return Value:

    None.

--*/

{
    PPFSVC_SECTION_NODE SectionNode;
    PLIST_ENTRY SectListEntry;
    PPFSVC_VOLUME_NODE VolumeNode;
    PLIST_ENTRY VolumeListEntry;

    //
    // Walk through the volume nodes and free them. Do this before
    // freeing section nodes, so when we are trying to cleanup a
    // section node, it is not on a volume node's list.
    //

    while (!IsListEmpty(&ScenarioInfo->VolumeList)) {
        
        VolumeListEntry = RemoveHeadList(&ScenarioInfo->VolumeList);
        
        VolumeNode = CONTAINING_RECORD(VolumeListEntry, 
                                       PFSVC_VOLUME_NODE, 
                                       VolumeLink);

        //
        // Cleanup the volume node.
        //

        PfSvCleanupVolumeNode(ScenarioInfo, VolumeNode);

        //
        // Free the volume node.
        //

        PfSvChunkAllocatorFree(&ScenarioInfo->VolumeNodeAllocator, VolumeNode);
    }

    //
    // Walk through the section nodes and free them.
    //

    while (!IsListEmpty(&ScenarioInfo->SectionList)) {
        
        SectListEntry = RemoveHeadList(&ScenarioInfo->SectionList);
        
        SectionNode = CONTAINING_RECORD(SectListEntry, 
                                        PFSVC_SECTION_NODE, 
                                        SectionLink);

        //
        // Cleanup the section node.
        //

        PfSvCleanupSectionNode(ScenarioInfo, SectionNode);

        //
        // Free the section node.
        //

        PfSvChunkAllocatorFree(&ScenarioInfo->SectionNodeAllocator, SectionNode);
    }

    //
    // Cleanup allocators.
    //

    PfSvChunkAllocatorCleanup(&ScenarioInfo->SectionNodeAllocator);
    PfSvChunkAllocatorCleanup(&ScenarioInfo->PageNodeAllocator);
    PfSvChunkAllocatorCleanup(&ScenarioInfo->VolumeNodeAllocator);
    PfSvStringAllocatorCleanup(&ScenarioInfo->PathAllocator);

    //
    // Free the one big allocation we made.
    //

    if (ScenarioInfo->OneBigAllocation) {
        PFSVC_FREE(ScenarioInfo->OneBigAllocation);
    }

    return;
}

DWORD
PfSvScenarioGetFilePath(
    OUT PWCHAR FilePath,
    IN ULONG FilePathMaxChars,
    IN PPF_SCENARIO_ID ScenarioId
    )

/*++

Routine Description:

    This routine builds the file path for the specified scenario.

Arguments:

    FilePath - Output buffer.

    FilePathMaxChars - Size of FilePath buffer in characters including NUL.

    ScenarioId - Scenario identifier.

Return Value:

    Win32 error code.

--*/

{
    ULONG NumChars;
    DWORD ErrorCode;
    WCHAR ScenarioFileName[PF_MAX_SCENARIO_FILE_NAME];
    BOOLEAN AcquiredPrefetchRootLock;

    //
    // Get the lock so the path to prefetch folder does not change
    // beneath our feet.
    //

    PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredPrefetchRootLock = TRUE;

    //
    // Calculate how big an input buffer we will need.
    //

    NumChars = wcslen(PfSvcGlobals.PrefetchRoot);
    NumChars += wcslen(L"\\");
    NumChars += PF_MAX_SCENARIO_FILE_NAME;
        
    if (NumChars >= FilePathMaxChars) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Build the scenario file name from scenario identifier.
    //

    swprintf(ScenarioFileName, 
             PF_SCEN_FILE_NAME_FORMAT,
             ScenarioId->ScenName,
             ScenarioId->HashId,
             PF_PREFETCH_FILE_EXTENSION);

    //
    // Build file path from prefetch directory path and file name.
    //

    swprintf(FilePath, 
             L"%ws\\%ws",
             PfSvcGlobals.PrefetchRoot,
             ScenarioFileName);

    PFSVC_ASSERT(wcslen(FilePath) < FilePathMaxChars);

    PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredPrefetchRootLock = FALSE;

    ErrorCode = ERROR_SUCCESS;

cleanup:

    if (AcquiredPrefetchRootLock) {
        PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    }

    return ErrorCode;
}

DWORD
PfSvScenarioOpen (
    IN PWCHAR FilePath,
    IN PPF_SCENARIO_ID ScenarioId,
    IN PF_SCENARIO_TYPE ScenarioType,
    OUT PPF_SCENARIO_HEADER *Scenario
    )

/*++

Routine Description:

    This routine maps & verifies the scenario instructions at FilePath.

    If a Scenario is returned, caller has to call UnmapViewOfFile to cleanup.

Arguments:

    FilePath - Path to scenario instructions.

    Scenario - Pointer to base of mapping of scenario instructions or NULL
      if the function returns an error.

Return Value:

    Win32 error code.

--*/

{
    PPF_SCENARIO_HEADER OpenedScenario;
    DWORD FailedCheck;
    DWORD ErrorCode;  
    DWORD FileSize;

    //
    // Initialize locals.
    //

    OpenedScenario = NULL;

    //
    // Initialize output parameters.
    //

    *Scenario = NULL;

    //
    // Try to map the scenario file.
    //

    ErrorCode = PfSvGetViewOfFile(FilePath, 
                                  &OpenedScenario,
                                  &FileSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Verify the scenario file.
    //

    FailedCheck = 0;
   
    if (!PfSvVerifyScenarioBuffer(OpenedScenario, FileSize, &FailedCheck) ||
        (OpenedScenario->ScenarioType != ScenarioType) ||
        OpenedScenario->ServiceVersion != PFSVC_SERVICE_VERSION) {
        
        //
        // This is a bogus / wrong / outdated scenario file. Remove
        // it.
        //

        UnmapViewOfFile(OpenedScenario);
        OpenedScenario = NULL;
        
        DeleteFile(FilePath);

        ErrorCode = ERROR_BAD_FORMAT; 
        goto cleanup;
    }

    *Scenario = OpenedScenario;
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {

        if (OpenedScenario) {
            UnmapViewOfFile(OpenedScenario);
        }

        *Scenario = NULL;

    } else {

        //
        // If we are returning success we should be returning a valid Scenario.
        //

        PFSVC_ASSERT(*Scenario);
    }

    return ErrorCode;
}

DWORD
PfSvScenarioInfoPreallocate(
    IN PPFSVC_SCENARIO_INFO ScenarioInfo,
    OPTIONAL IN PPF_SCENARIO_HEADER Scenario,
    OPTIONAL IN PPF_TRACE_HEADER Trace
    )

/*++

Routine Description:

    This routine preallocates a heap to be divided up and used by the 
    various allocators when processing a prefetch trace. The default allocation
    size is determined from the Trace and Scenario size.

Arguments:

    ScenarioInfo - Pointer to scenario containing allocators to initialize.

    Scenario - Pointer to scenario instructions.

    Trace - Pointer to prefetch trace.

Return Value:

    Win32 error code.

--*/

{
    PUCHAR Allocation;
    PUCHAR ChunkStart;
    DWORD ErrorCode;
    ULONG AllocationSize;
    ULONG NumSections;
    ULONG NumPages;
    ULONG NumVolumes;
    ULONG PathSize;

    //
    // Initialize locals.
    //

    Allocation = NULL;
    NumSections = 0;
    NumPages = 0;
    NumVolumes = 0;
    PathSize = 0;

    //
    // Estimate how much to preallocate. Over-estimate rather than under-
    // estimate because we will have to go to the heap for individual allocations
    // if we underestimate. If we overestimate, as long as we don't touch the extra 
    // pages allocated we don't get a hit.
    //

    if (Trace) {
        NumSections += Trace->NumSections;
    }

    if (Scenario) {
        NumSections += Scenario->NumSections;
    }   

    if (Trace) {
        NumPages += Trace->NumEntries;
    }
    
    if (Scenario) {
        NumPages += Scenario->NumPages;
    }

    if (Trace) {
        NumVolumes += Trace->NumVolumes;
    }
    
    if (Scenario) {

        NumVolumes += Scenario->NumMetadataRecords;

        //
        // It is very likely that we will at least share the volume containing the
        // main executables between the trace and existing scenario instructions.
        // So if we have both Trace and Scenario take one volume node off the estimate.
        //

        if (Trace) {
            PFSVC_ASSERT(NumVolumes);
            NumVolumes--;
        }
    }

    //
    // It is hard to estimate how much we will allocate for various paths
    // e.g. file paths & each level of parent directory paths etc. It should be less
    // than the size of the total trace, although it probably makes up most of it.
    //

    if (Trace) {
        PathSize = Trace->Size;
    }
    
    if (Scenario) {
        PathSize += Scenario->FileNameInfoSize;
        PathSize += Scenario->MetadataInfoSize;
    }

    //
    // Add it all up.
    //

    AllocationSize = 0;
    AllocationSize += _alignof(PFSVC_VOLUME_NODE);
    AllocationSize += NumVolumes * sizeof(PFSVC_VOLUME_NODE);
    AllocationSize += _alignof(PFSVC_SECTION_NODE);
    AllocationSize += NumSections * sizeof(PFSVC_SECTION_NODE);
    AllocationSize += _alignof(PFSVC_PAGE_NODE);
    AllocationSize += NumPages * sizeof(PFSVC_PAGE_NODE);
    AllocationSize += PathSize;

    //
    // Make one big allocation.
    //

    Allocation = PFSVC_ALLOC(AllocationSize);

    if (!Allocation) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Divide up the big allocation. Since we are providing the buffers,
    // allocators should not fail.
    //

    ChunkStart = Allocation;

    //
    // Volume nodes.
    //

    ErrorCode = PfSvChunkAllocatorStart(&ScenarioInfo->VolumeNodeAllocator,
                                        ChunkStart,
                                        sizeof(PFSVC_VOLUME_NODE),
                                        NumVolumes);

    if (ErrorCode != ERROR_SUCCESS) {
        PFSVC_ASSERT(ErrorCode == ERROR_SUCCESS);
        goto cleanup;
    }

    ChunkStart += (ULONG_PTR) NumVolumes * sizeof(PFSVC_VOLUME_NODE);

    //
    // Section nodes.
    //

    ChunkStart = PF_ALIGN_UP(ChunkStart, _alignof(PFSVC_SECTION_NODE));
    
    ErrorCode = PfSvChunkAllocatorStart(&ScenarioInfo->SectionNodeAllocator,
                                        ChunkStart,
                                        sizeof(PFSVC_SECTION_NODE),
                                        NumSections);

    if (ErrorCode != ERROR_SUCCESS) {
        PFSVC_ASSERT(ErrorCode == ERROR_SUCCESS);
        goto cleanup;
    }

    ChunkStart += (ULONG_PTR) NumSections * sizeof(PFSVC_SECTION_NODE);

    //
    // Page nodes.
    //
    
    ChunkStart = PF_ALIGN_UP(ChunkStart, _alignof(PFSVC_PAGE_NODE));

    ErrorCode = PfSvChunkAllocatorStart(&ScenarioInfo->PageNodeAllocator,
                                        ChunkStart,
                                        sizeof(PFSVC_PAGE_NODE),
                                        NumPages);

    if (ErrorCode != ERROR_SUCCESS) {
        PFSVC_ASSERT(ErrorCode == ERROR_SUCCESS);
        goto cleanup;
    }

    ChunkStart += (ULONG_PTR) NumPages * sizeof(PFSVC_PAGE_NODE);

    //
    // Path names.
    //

    ErrorCode = PfSvStringAllocatorStart(&ScenarioInfo->PathAllocator,
                                        ChunkStart,
                                        PathSize);

    if (ErrorCode != ERROR_SUCCESS) {
        PFSVC_ASSERT(ErrorCode == ERROR_SUCCESS);
        goto cleanup;
    }

    ChunkStart += (ULONG_PTR) PathSize;

    //
    // We should not have passed beyond what we allocated.
    //

    PFSVC_ASSERT(ChunkStart > (PUCHAR) Allocation);
    PFSVC_ASSERT(ChunkStart < (PUCHAR) Allocation + (ULONG_PTR) AllocationSize);

    ScenarioInfo->OneBigAllocation = Allocation;

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        if (Allocation) {
            PFSVC_FREE(Allocation);       
        }
    }

    return ErrorCode;
}

DWORD
PfSvAddExistingScenarioInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_SCENARIO_HEADER Scenario
    )

/*++

Routine Description:

    This function gets existing scenario information for the specified
    scenario and updates ScenarioInfo.

Arguments:

    ScenarioInfo - Initialized scenario info structure.

    Scenario - Pointer to mapped scenario instructions.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    ULONG FileSize;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_PAGE_NODE PageNode;
    PPF_SECTION_RECORD Sections;
    PPF_SECTION_RECORD SectionRecord;
    PPF_PAGE_RECORD Pages;
    PCHAR FileNameInfo;
    WCHAR *FileName;
    ULONG FileNameSize;
    LONG PageIdx;
    ULONG SectionIdx;
    ULONG NumPages;
    PCHAR MetadataInfoBase;
    PPF_METADATA_RECORD MetadataRecordTable;
    PPF_METADATA_RECORD MetadataRecord;
    ULONG MetadataRecordIdx;
    ULONG FailedCheck;
    PWCHAR VolumePath;   

    //
    // Copy over the existing scenario header.
    //

    ScenarioInfo->ScenHeader = *Scenario;

    //
    // Update number of launches.
    //

    ScenarioInfo->ScenHeader.NumLaunches++;

    //
    // Convert the scenario data into intermediate data structures
    // we can manipulate easier:
    //

    //
    // Create volume nodes from metadata records.
    //

    MetadataInfoBase = (PCHAR)Scenario + Scenario->MetadataInfoOffset;
    MetadataRecordTable = (PPF_METADATA_RECORD) MetadataInfoBase;

    for (MetadataRecordIdx = 0;
         MetadataRecordIdx < Scenario->NumMetadataRecords;
         MetadataRecordIdx++) {

        MetadataRecord = &MetadataRecordTable[MetadataRecordIdx];
        VolumePath = (PWCHAR)(MetadataInfoBase + MetadataRecord->VolumeNameOffset);  

        ErrorCode = PfSvCreateVolumeNode(ScenarioInfo,
                                         VolumePath,
                                         MetadataRecord->VolumeNameLength,
                                         &MetadataRecord->CreationTime,
                                         MetadataRecord->SerialNumber);
        
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    //
    // Convert page and section nodes.
    //

    Sections = (PPF_SECTION_RECORD) ((PCHAR)Scenario + Scenario->SectionInfoOffset);
    Pages = (PPF_PAGE_RECORD) ((PCHAR)Scenario + Scenario->PageInfoOffset);
    FileNameInfo = (PCHAR)Scenario + Scenario->FileNameInfoOffset;
            
    for (SectionIdx = 0; SectionIdx < Scenario->NumSections; SectionIdx++) {

        //
        // Build a section node from this section record in the
        // scenario file. PfSvGetSectionRecord will insert it into
        // the new scenario by the section record's name.
        //

        SectionRecord = &Sections[SectionIdx];
        FileName = (PWSTR) (FileNameInfo + SectionRecord->FileNameOffset);

        SectionNode = PfSvGetSectionRecord (ScenarioInfo,
                                            FileName,
                                            SectionRecord->FileNameLength);

        if (!SectionNode) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        //
        // There should not be duplicate sections in the
        // scenario. The section node we got should have an empty
        // section record.
        //

        PFSVC_ASSERT(SectionNode->SectionRecord.FirstPageIdx == 0);
        PFSVC_ASSERT(SectionNode->SectionRecord.NumPages == 0);
        PFSVC_ASSERT(SectionNode->OrgSectionIndex == ULONG_MAX);
    
        //
        // Update the index of this section in the scenario file.
        //

        SectionNode->OrgSectionIndex = SectionIdx;

        //
        // Update the section record in the section node.
        //

        SectionNode->SectionRecord = *SectionRecord;

        //
        // Put page records for the section into the list.
        //
            
        PageIdx = SectionRecord->FirstPageIdx;
        NumPages = 0;

        while (PageIdx != PF_INVALID_PAGE_IDX) {

            if (NumPages >= SectionRecord->NumPages) {
                    
                //
                // There should not be more pages on the list than
                // what the section record says there is.
                //

                PFSVC_ASSERT(FALSE);
                break;
            }

            PageNode = PfSvChunkAllocatorAllocate(&ScenarioInfo->PageNodeAllocator);
                
            if (!PageNode) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
                
            //
            // Copy over the page record.
            //

            PageNode->PageRecord = Pages[PageIdx];

            //
            // Insert it into the section's page list. Note that
            // the page records in the section should be sorted by
            // offset. By inserting to the tail, we maintain that.
            //

            InsertTailList(&SectionNode->PageList, &PageNode->PageLink);

            //
            // Shift the usage history for this page record making
            // room for whether this page was used in this launch.
            //
                
            PageNode->PageRecord.UsageHistory <<= 1;

            //
            // Shift the prefetch history for this page record and
            // note whether we had asked this page to be
            // prefetched in this launch.
            //
                
            PageNode->PageRecord.PrefetchHistory <<= 1;
                
            if (!PageNode->PageRecord.IsIgnore) {
                PageNode->PageRecord.PrefetchHistory |= 0x1;
            }

            //
            // Keep the count of pages we had asked to be
            // prefetched, so we can calculate hit rate and adjust
            // the sensitivity.
            //

            if(!PageNode->PageRecord.IsIgnore) {
                if (PageNode->PageRecord.IsImage) {
                    ScenarioInfo->PrefetchedPages++;
                }
                if (PageNode->PageRecord.IsData) {
                    ScenarioInfo->PrefetchedPages++;
                }
            } else {
                ScenarioInfo->IgnoredPages++;
            }

            //
            // Update next page idx.
            //

            PageIdx = Pages[PageIdx].NextPageIdx;

            //
            // Update number of pages we've copied.
            //

            NumPages++;
        }

        //
        // We should have copied as many pages as the section said
        // there were.
        //

        PFSVC_ASSERT(NumPages == SectionRecord->NumPages);
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

DWORD
PfSvVerifyVolumeMagics(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_TRACE_HEADER Trace 
    )

/*++

Routine Description:

    Walk through the volumes in the trace and make sure their magics
    match the ones in ScenarioInfo.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

    Trace - Pointer to trace.

Return Value:

    Win32 error code.

--*/

{
    PPFSVC_VOLUME_NODE VolumeNode;
    PPF_VOLUME_INFO VolumeInfo;
    ULONG VolumeInfoSize;
    ULONG VolumeIdx;
    BOOLEAN VolumeMagicsMatch;
    
    //
    // Walk the volumes in the trace.
    //

    VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR)Trace + Trace->VolumeInfoOffset);

    for (VolumeIdx = 0; VolumeIdx < Trace->NumVolumes; VolumeIdx++) {
        
        //
        // Get the scenario info's volume node for this volume.
        //
        
        VolumeNode = PfSvGetVolumeNode(ScenarioInfo,
                                       VolumeInfo->VolumePath,
                                       VolumeInfo->VolumePathLength);
        
        if (VolumeNode) {

            //
            // Make sure the magics match.
            //

            if (VolumeNode->SerialNumber != VolumeInfo->SerialNumber ||
                VolumeNode->CreationTime.QuadPart != VolumeInfo->CreationTime.QuadPart) {

                VolumeMagicsMatch = FALSE;
                goto cleanup;
            }
        }

        //
        // Get the next volume.
        //

        VolumeInfoSize = sizeof(PF_VOLUME_INFO);
        VolumeInfoSize += VolumeInfo->VolumePathLength * sizeof(WCHAR);

        VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR) VolumeInfo + VolumeInfoSize);
        
        //
        // Make sure VolumeInfo is aligned.
        //

        VolumeInfo = PF_ALIGN_UP(VolumeInfo, _alignof(PF_VOLUME_INFO));
    }
 
    //
    // Volume magics for volumes that appear both in the trace and the
    // scenario info matched.
    //

    VolumeMagicsMatch = TRUE;

 cleanup:

    return VolumeMagicsMatch;
}

DWORD
PfSvAddTraceInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_TRACE_HEADER Trace 
    )

/*++

Routine Description:

    Add information in a raw trace to the specified scenario info
    structure.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

    Trace - Pointer to trace.

Return Value:

    Win32 error code.

--*/

{
    PPF_SECTION_INFO Section;
    PPF_LOG_ENTRY LogEntries;
    PCHAR pFileName;
    PPFSVC_SECTION_NODE *SectionTable;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_VOLUME_NODE VolumeNode;   
    ULONG TraceEndIdx;
    ULONG SectionIdx;
    ULONG EntryIdx;
    DWORD ErrorCode;
    ULONG SectionLength;
    ULONG NextSectionIndex;
    PPF_VOLUME_INFO VolumeInfo;
    ULONG VolumeInfoSize;
    ULONG VolumeIdx;
    ULONG SectionTableSize;

    //
    // Initialize locals so we know what to clean up.
    //

    SectionTable = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: AddTraceInfo()\n"));
    
    //
    // Update last launch time.
    //
   
    ScenarioInfo->ScenHeader.LastLaunchTime = Trace->LaunchTime;

    //
    // If this scenario has been launched a number of times, we update
    // the min reprefetch and retrace times. See comment for
    // PFSVC_MIN_LAUNCHES_FOR_LAUNCH_FREQ_CHECK.
    //

    if (ScenarioInfo->ScenHeader.NumLaunches >= PFSVC_MIN_LAUNCHES_FOR_LAUNCH_FREQ_CHECK) {
        ScenarioInfo->ScenHeader.MinRePrefetchTime.QuadPart = PFSVC_DEFAULT_MIN_REPREFETCH_TIME;
        ScenarioInfo->ScenHeader.MinReTraceTime.QuadPart = PFSVC_DEFAULT_MIN_RETRACE_TIME;
    }

#ifdef PFSVC_DBG

    //
    // On checked build, always set these to 0, so we do prefetch every 
    // scenario launch.
    //

    ScenarioInfo->ScenHeader.MinRePrefetchTime.QuadPart = 0;
    ScenarioInfo->ScenHeader.MinReTraceTime.QuadPart = 0;

#endif // PFSVC_DBG

    //
    // Walk through the volumes in the trace and create volume nodes
    // for them.
    //

    VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR)Trace + Trace->VolumeInfoOffset);

    for (VolumeIdx = 0; VolumeIdx < Trace->NumVolumes; VolumeIdx++) {

        //
        // Upcase the path so we don't have to do expensive case
        // insensitive comparisons.
        //

        _wcsupr(VolumeInfo->VolumePath);

        ErrorCode = PfSvCreateVolumeNode(ScenarioInfo,
                                         VolumeInfo->VolumePath,
                                         VolumeInfo->VolumePathLength,
                                         &VolumeInfo->CreationTime,
                                         VolumeInfo->SerialNumber);
        
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Get the next volume.
        //

        VolumeInfoSize = sizeof(PF_VOLUME_INFO);
        VolumeInfoSize += VolumeInfo->VolumePathLength * sizeof(WCHAR);

        VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR) VolumeInfo + VolumeInfoSize);
        
        //
        // Make sure VolumeInfo is aligned.
        //

        VolumeInfo = PF_ALIGN_UP(VolumeInfo, _alignof(PF_VOLUME_INFO));
    }

    //
    // Allocate section node table so we know where to put the logged
    // page faults.
    //

    SectionTableSize = sizeof(PPFSVC_SECTION_NODE) * Trace->NumSections;

    SectionTable = PFSVC_ALLOC(SectionTableSize);
    
    if (!SectionTable) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    RtlZeroMemory(SectionTable, SectionTableSize);

    //
    // Walk through the sections in the trace, and either find
    // existing section records in the new scenario or create new
    // ones.
    //

    Section = (PPF_SECTION_INFO) ((PCHAR)Trace + Trace->SectionInfoOffset);

    for (SectionIdx = 0; SectionIdx < Trace->NumSections; SectionIdx++) {

        //
        // Upcase the path so we don't have to do expensive case
        // insensitive comparisons.
        //
        
        _wcsupr(Section->FileName);

        //
        // If the section is for metafile, simply add it as a directory
        // to be prefetched. We don't keep track of 
        //

        if (Section->Metafile) {

            VolumeNode = PfSvGetVolumeNode(ScenarioInfo, 
                                           Section->FileName,
                                           Section->FileNameLength);

            PFSVC_ASSERT(VolumeNode);

            if (VolumeNode) {
                PfSvAddParentDirectoriesToList(&VolumeNode->DirectoryList,
                                               VolumeNode->VolumePathLength,
                                               Section->FileName,
                                               Section->FileNameLength);
            }

            goto NextSection;
        }

        //
        // Find or create a section record for this section.
        //

        SectionTable[SectionIdx] = PfSvGetSectionRecord(ScenarioInfo,
                                                        Section->FileName,
                                                        Section->FileNameLength);
        
        //
        // If we could not get a record, it is because we had to
        // create one and we did not have enough memory.
        //
        
        if (!SectionTable[SectionIdx]) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

      NextSection:

        //
        // Get the next section record in the trace.
        //

        SectionLength = sizeof(PF_SECTION_INFO) +
            (Section->FileNameLength) * sizeof(WCHAR);

        Section = (PPF_SECTION_INFO) ((PUCHAR) Section + SectionLength);
    }

    //
    // Determine after which log entry the trace ends.
    //

    TraceEndIdx = PfSvGetTraceEndIdx(Trace);

    //
    // If the determined trace end is zero (as is the case for most
    // applications running under stress that don't get any pagefaults
    // traced for the first few seconds), bail out.
    //

    if (TraceEndIdx == 0) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Add logged pagefault information up to the determined trace end
    // to the new scenario info.
    //

    LogEntries = (PPF_LOG_ENTRY) ((PCHAR)Trace + Trace->TraceBufferOffset);
    
    //
    // Keep track of NextSectionIdx so we can order the sections by
    // the first access [i.e. first page fault in the trace]
    //

    NextSectionIndex = 0;

    for (EntryIdx = 0; EntryIdx < TraceEndIdx; EntryIdx++) {

        SectionNode = SectionTable[LogEntries[EntryIdx].SectionId];

        //
        // For metafile sections we don't create section nodes.
        //

        if (!SectionNode) {
            continue;
        }

        //
        // NewSectionIndex fields of all section nodes are initialized
        // to ULONG_MAX. If we have not already seen this section in
        // the trace note its order and update NextSectionIdx.
        //

        if (SectionNode->NewSectionIndex == ULONG_MAX) {
            SectionNode->NewSectionIndex = NextSectionIndex;
            NextSectionIndex++;
        }

        //
        // Add fault information to our section record.
        //

        ErrorCode = PfSvAddFaultInfoToSection(ScenarioInfo,
                                              &LogEntries[EntryIdx], 
                                              SectionNode);

       if (ErrorCode != ERROR_SUCCESS) {
           goto cleanup;
       }
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (SectionTable) {
        PFSVC_FREE(SectionTable);
    }

    DBGPR((PFID,PFTRC,"PFSVC: AddTraceInfo()=%x\n", ErrorCode));

    return ErrorCode;
}

PPFSVC_SECTION_NODE 
PfSvGetSectionRecord(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *FilePath,
    ULONG FilePathLength
    )

/*++

Routine Description:

    Find or create a section node in the scenario info for the
    specified file path.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

    FilePath - NUL terminated NT path to file.

    FilePathLength - Length of FilePath in chars excluding NUL.

Return Value:

    Pointer to created or found section node or NULL if there was a
    problem.

--*/

{
    PPFSVC_SECTION_NODE SectionNode;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    LONG ComparisonResult;
    ULONG FilePathSize;
    PPFSVC_SECTION_NODE ReturnNode;

    //
    // Initialize locals.
    //

    ReturnNode = NULL;

    //
    // Walk through the existing sections records looking for a file
    // name match. Section records are on a lexically sorted list.
    //

    HeadEntry = &ScenarioInfo->SectionList;
    NextEntry = HeadEntry->Flink;
    
    while (HeadEntry != NextEntry) {

        SectionNode = CONTAINING_RECORD(NextEntry,
                                        PFSVC_SECTION_NODE,
                                        SectionLink);

        ComparisonResult = wcscmp(SectionNode->FilePath, FilePath);
        
        if (ComparisonResult == 0) {

            //
            // We found a match. Return this section record.
            //

            ReturnNode = SectionNode;
            goto cleanup;

        } else if (ComparisonResult > 0) { 
            
            //
            // We won't find the name in our list. We have to create a
            // new section record.
            //

            break;
        }

        NextEntry = NextEntry->Flink;
    }

    //
    // We have to create a new section record. NextEntry points to
    // where we have to insert it in the list.
    //

    SectionNode = PfSvChunkAllocatorAllocate(&ScenarioInfo->SectionNodeAllocator);

    if (!SectionNode) {
        ReturnNode = NULL;
        goto cleanup;
    }

    //
    // Initialize the section node.
    //

    SectionNode->FilePath = NULL;
    InitializeListHead(&SectionNode->PageList);
    InitializeListHead(&SectionNode->SectionVolumeLink);
    SectionNode->NewSectionIndex = ULONG_MAX;
    SectionNode->OrgSectionIndex = ULONG_MAX;
    SectionNode->FileIndexNumber.QuadPart = -1i64;
    
    //
    // Initialize the section record. 
    //

    RtlZeroMemory(&SectionNode->SectionRecord, sizeof(PF_SECTION_RECORD));

    //
    // Allocate and copy over the file name.
    //

    FilePathSize = (FilePathLength + 1) * sizeof(WCHAR);

    SectionNode->FilePath = PfSvStringAllocatorAllocate(&ScenarioInfo->PathAllocator,
                                                        FilePathSize);

    if (!SectionNode->FilePath) {

        PfSvCleanupSectionNode(ScenarioInfo, SectionNode);

        PfSvChunkAllocatorFree(&ScenarioInfo->SectionNodeAllocator, SectionNode);

        ReturnNode = NULL;
        goto cleanup;
    }

    RtlCopyMemory(SectionNode->FilePath, FilePath, FilePathSize);

    //
    // Update the file name length on the section record.
    //

    SectionNode->SectionRecord.FileNameLength = FilePathLength;

    //
    // Insert the section into the right spot on the scenario's list.
    //

    InsertTailList(NextEntry, &SectionNode->SectionLink);

    //
    // Return the newly setup section record.
    //

    ReturnNode = SectionNode;

 cleanup:

    return ReturnNode;
}

DWORD 
PfSvAddFaultInfoToSection(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_LOG_ENTRY LogEntry,
    PPFSVC_SECTION_NODE SectionNode
    )

/*++

Routine Description:

    Add fault information from a trace log entry to proper section
    record in the new scenario.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

    LogEntry - Pointer to trace log entry.

    SectionNode - Pointer to the section node the log entry belongs to.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PPFSVC_PAGE_NODE PageNode;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;

    //
    // Walk through the page records for this section.
    //

    HeadEntry = &SectionNode->PageList;
    NextEntry = HeadEntry->Flink;
                                 
    while (HeadEntry != NextEntry) {
        
        PageNode = CONTAINING_RECORD(NextEntry,
                                     PFSVC_PAGE_NODE,
                                     PageLink);

        if (PageNode->PageRecord.FileOffset > LogEntry->FileOffset) {
            
            //
            // We won't find this fault in this sorted list.
            //
            
            break;

        } else if (PageNode->PageRecord.FileOffset == LogEntry->FileOffset) {

            //
            // We found the page, update the page record and section
            // record with the info in log entry.
            //

            if (LogEntry->IsImage) {
                PageNode->PageRecord.IsImage = 1;
            } else {
                PageNode->PageRecord.IsData = 1;
            }
            
            //
            // Note the this page was used in this launch.
            //

            PageNode->PageRecord.UsageHistory |= 0x1;

            //
            // See if this page was prefetched for this launch and
            // update appropriate stats.
            //

            if(PageNode->PageRecord.IsIgnore) {
                ScenarioInfo->MissedOpportunityPages++;
            } else {
                ScenarioInfo->HitPages++;
            }

            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }
        
        NextEntry = NextEntry->Flink;
    }

    //
    // We have to add a new page record before NextEntry in the list.
    //
    
    PageNode = PfSvChunkAllocatorAllocate(&ScenarioInfo->PageNodeAllocator);

    if (!PageNode) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    
    //
    // Set up new page record. First initialize fields.
    //

    PageNode->PageRecord.IsImage = 0;
    PageNode->PageRecord.IsData = 0;
    PageNode->PageRecord.IsIgnore = 0;
    
    PageNode->PageRecord.FileOffset = LogEntry->FileOffset;
        
    if (LogEntry->IsImage) {
        PageNode->PageRecord.IsImage = 1;
    } else {
        PageNode->PageRecord.IsData = 1;
    }

    //
    // Initialize usage history for this new page record noting that
    // it was used in this launch.
    //

    PageNode->PageRecord.UsageHistory = 0x1;

    //
    // Initialize prefetch history for this new page record.
    //

    PageNode->PageRecord.PrefetchHistory = 0;

    //
    // Insert it into the sections pages list.
    //

    InsertTailList(NextEntry, &PageNode->PageLink);

    //
    // Update stats on the new scenario.
    //

    ScenarioInfo->NewPages++;

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

DWORD
PfSvApplyPrefetchPolicy(
    PPFSVC_SCENARIO_INFO ScenarioInfo
    )

/*++

Routine Description:

    Go through all the information in ScenarioInfo and determine which
    pages/sections to prefetch for the next launch of the scenario.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

Return Value:

    Win32 error code.

--*/

{
    ULONG Sensitivity;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_PAGE_NODE PageNode;
    ULONG SectNumPagesToPrefetch;
    ULONG HitPages;
    ULONG MissedOpportunityPages;
    ULONG PrefetchedPages;
    ULONG IgnoredPages;
    PLIST_ENTRY SectHead;
    PLIST_ENTRY SectNext;
    PLIST_ENTRY PageHead;
    PLIST_ENTRY PageNext;  
    ULONG NumUsed;
    PPF_SCENARIO_HEADER Scenario;
    ULONG FileNameSize;
    ULONG IgnoredFileIdx;
    BOOLEAN bSkipSection;
    PFSV_SUFFIX_COMPARISON_RESULT ComparisonResult;
    DWORD ErrorCode;
    PPFSVC_VOLUME_NODE VolumeNode;
    PWCHAR MFTSuffix;
    PWCHAR PathSuffix;
    FILE_BASIC_INFORMATION FileInformation;
    ULONG MFTSuffixLength;
    
    //
    // Initialize locals.
    //

    Scenario = &ScenarioInfo->ScenHeader;
    MFTSuffix = L"\\$MFT";
    MFTSuffixLength = wcslen(MFTSuffix);

    DBGPR((PFID,PFTRC,"PFSVC: ApplyPrefetchPolicy()\n"));

    //
    // Initialize fields of the scenario header we will set up.
    //
    
    Scenario->NumSections = 0;
    Scenario->NumPages = 0;
    Scenario->FileNameInfoSize = 0;
    
    //
    // Determine sensitivity based on usage of the pages we prefetched
    // and we ignored.
    //

    HitPages = ScenarioInfo->HitPages;
    MissedOpportunityPages = ScenarioInfo->MissedOpportunityPages;
    PrefetchedPages = ScenarioInfo->PrefetchedPages;
    IgnoredPages = ScenarioInfo->IgnoredPages;

    //
    // Check what percent of the pages we brought were used.
    //

    if (PrefetchedPages &&
        (((HitPages * 100) / PrefetchedPages) < PFSVC_MIN_HIT_PERCENTAGE)) {
            
        //
        // Our hit rate is low. Increase sensitivity of the
        // scenario, so for us to prefetch a page, it has to be
        // used in more of the last launches.
        //
            
        if (ScenarioInfo->ScenHeader.Sensitivity < PF_MAX_SENSITIVITY) {
            ScenarioInfo->ScenHeader.Sensitivity ++;
        }

    } else if (IgnoredPages && 
               (((MissedOpportunityPages * 100) / IgnoredPages) > PFSVC_MAX_IGNORED_PERCENTAGE)) {

        //
        // If we are using most of what we prefetched (or we are not
        // prefetching anything!), but we ignored some pages we could
        // have prefetched, and they were used too, time to decrease
        // sensitivity so we ignore less pages.
        //
            
        if (ScenarioInfo->ScenHeader.Sensitivity > PF_MIN_SENSITIVITY) {
            ScenarioInfo->ScenHeader.Sensitivity --;
        }
    }

    //
    // Don't let the boot scenario's sensitivity to fall below 2. 
    // This makes sure we don't pick up all the application setup &
    // configuration updates that happen during boot once.
    //

    if (ScenarioInfo->ScenHeader.ScenarioType == PfSystemBootScenarioType) {
        PFSVC_ASSERT(PF_MIN_SENSITIVITY <= 2);
        if (ScenarioInfo->ScenHeader.Sensitivity < 2) {
            ScenarioInfo->ScenHeader.Sensitivity = 2;
        }
    }

    Sensitivity = ScenarioInfo->ScenHeader.Sensitivity;

    //
    // If number of times this scenario was launched is less
    // than sensitivity, adjust sensitivity. Otherwise we
    // won't end up prefetching anything.
    //
    
    if (Sensitivity > ScenarioInfo->ScenHeader.NumLaunches) {
        Sensitivity = ScenarioInfo->ScenHeader.NumLaunches;
    }   

    //
    // Walk through pages for every section and determine if they
    // should be prefetched or not based on scenario sensitivity and
    // their usage history in the last launches. 
    //

    SectHead = &ScenarioInfo->SectionList;
    SectNext = SectHead->Flink;

    while (SectHead != SectNext) {

        SectionNode = CONTAINING_RECORD(SectNext,
                                        PFSVC_SECTION_NODE,
                                        SectionLink);
        SectNext = SectNext->Flink;

        //
        // Initialize section records fields.
        //
        
        SectionNode->SectionRecord.IsImage = 0;
        SectionNode->SectionRecord.IsData = 0;
        SectionNode->SectionRecord.NumPages = 0;

        //
        // If we are nearing the limits for number of sections and
        // pages, ignore the rest of the sections.
        //

        if (Scenario->NumSections >= PF_MAXIMUM_SECTIONS ||
            Scenario->NumPages + PF_MAXIMUM_SECTION_PAGES >= PF_MAXIMUM_PAGES) {
            
            //
            // Remove this section node from our list.
            //
            
            PfSvCleanupSectionNode(ScenarioInfo, SectionNode);
            
            RemoveEntryList(&SectionNode->SectionLink);
            
            PfSvChunkAllocatorFree(&ScenarioInfo->SectionNodeAllocator, SectionNode);
            
            continue;
        }

        //
        // If this is the boot scenario, check to see if this is one
        // of the sections we ignore.
        //
        
        if (Scenario->ScenarioType == PfSystemBootScenarioType) {

            bSkipSection = FALSE;

            for (IgnoredFileIdx = 0;
                 IgnoredFileIdx < PfSvcGlobals.NumFilesToIgnoreForBoot;
                 IgnoredFileIdx++) {

                ComparisonResult = PfSvCompareSuffix(SectionNode->FilePath,
                                                     SectionNode->SectionRecord.FileNameLength,
                                                     PfSvcGlobals.FilesToIgnoreForBoot[IgnoredFileIdx],
                                                     PfSvcGlobals.FileSuffixLengths[IgnoredFileIdx],
                                                     TRUE);

                if (ComparisonResult == PfSvSuffixIdentical) {
                    
                    //
                    // The suffix matched.
                    //

                    bSkipSection = TRUE;
                    break;

                } else if (ComparisonResult == PfSvSuffixGreaterThan) {

                    //
                    // Since the ignore-suffices are lexically sorted,
                    // this file name's suffix won't match others
                    // either.
                    //

                    bSkipSection = FALSE;
                    break;
                }
            }
            
            if (bSkipSection) {
                
                //
                // Remove this section node from our list.
                //
                
                PfSvCleanupSectionNode(ScenarioInfo, SectionNode);
                
                RemoveEntryList(&SectionNode->SectionLink);
                
                PfSvChunkAllocatorFree(&ScenarioInfo->SectionNodeAllocator, SectionNode);
                
                continue;
            }
        }
        
        //
        // Keep track of num pages to prefetch for this section.
        //
        
        SectNumPagesToPrefetch = 0;
        
        PageHead = &SectionNode->PageList;
        PageNext = PageHead->Flink;
        
        while (PageHead != PageNext) {
            
            PageNode = CONTAINING_RECORD(PageNext,
                                         PFSVC_PAGE_NODE,
                                         PageLink);
            PageNext = PageNext->Flink;
            
            //
            // Get number of times this page was used in the launches
            // in usage history.
            //
            
            NumUsed = PfSvGetNumTimesUsed(PageNode->PageRecord.UsageHistory,
                                          PF_PAGE_HISTORY_SIZE);
            
            
            //
            // If it was not used at all in the history we've kept
            // track of, remove it.
            //
            
            if (NumUsed == 0) {
                
                RemoveEntryList(&PageNode->PageLink);
                
                PfSvChunkAllocatorFree(&ScenarioInfo->PageNodeAllocator, PageNode);

                continue;
            }
            
            //
            // Update the number of pages for this section.
            //
            
            SectionNode->SectionRecord.NumPages++;

            //
            // Check if this page qualifies to be prefetched next time.
            //

            if (NumUsed >= Sensitivity) {
                PageNode->PageRecord.IsIgnore = 0;

                //
                // Update the number of pages we are prefetching for
                // this section.
                //

                SectNumPagesToPrefetch++;
            
                //
                // Update whether we are going to prefetch this
                // section as image, data [or both].
                //
                
                SectionNode->SectionRecord.IsImage |= PageNode->PageRecord.IsImage;
                SectionNode->SectionRecord.IsData |= PageNode->PageRecord.IsData;
                
            } else {
                
                PageNode->PageRecord.IsIgnore = 1;
            }
        }

        //
        // Check if we want to keep this section in the scenario:
        //

        bSkipSection = FALSE;       

        if (SectionNode->SectionRecord.NumPages == 0) {

            //
            // If we don't have any pages left for this section, remove
            // it.
            //

            bSkipSection = TRUE;            

        } else if (SectionNode->SectionRecord.NumPages >= PF_MAXIMUM_SECTION_PAGES) {

            //
            // If we ended up with too many pages for this section, remove
            // it.
            //

            bSkipSection = TRUE;

        } else if (PfSvcGlobals.CSCRootPath &&
                   wcsstr(SectionNode->FilePath, PfSvcGlobals.CSCRootPath)) {

            //
            // Skip client side cache (CSC) files. These files may get encrypted as 
            // LocalSystem, and when the AppData folder is redirected, we may take
            // minutes trying to open them when prefetching for shell launch.
            //

            bSkipSection = TRUE;

        } else {

            //
            // Encrypted files may result in several network accesses during open, 
            // even if they are local. This is especially so if the AppData folder is
            // redirected to a server. We cannot afford these network delays when
            // blocking the scenario for prefetching.
            //

            ErrorCode = PfSvGetFileBasicInformation(SectionNode->FilePath, 
                                                    &FileInformation);

            if ((ErrorCode == ERROR_SUCCESS) &&
                (FileInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {

                bSkipSection = TRUE;

            }
        }

        if (bSkipSection) {

            PfSvCleanupSectionNode(ScenarioInfo, SectionNode);

            RemoveEntryList(&SectionNode->SectionLink);
            
            PfSvChunkAllocatorFree(&ScenarioInfo->SectionNodeAllocator, SectionNode);

            continue;
        }

        //
        // Get the volume node for the volume this section is
        // on. The volume node should have been added when the
        // existing scenario information or the new trace
        // information was added to the scenario info.
        //
        
        VolumeNode = PfSvGetVolumeNode(ScenarioInfo,
                                       SectionNode->FilePath,
                                       SectionNode->SectionRecord.FileNameLength);
        
        PFSVC_ASSERT(VolumeNode);

        if (VolumeNode) {
            VolumeNode->NumAllSections++;
        }

        //
        // If we are not prefetching any pages from this section for
        // the next launch, mark it ignore.
        //

        if (SectNumPagesToPrefetch == 0) {

            SectionNode->SectionRecord.IsIgnore = 1;

        } else {

            SectionNode->SectionRecord.IsIgnore = 0;

            //
            // If this is MFT section for this volume, save it on the volume
            // node. We will add the pages referenced from MFT to the list of
            // files to prefetch metadata for. 
            //

            if ((VolumeNode && VolumeNode->MFTSectionNode == NULL) &&
                 (VolumeNode->VolumePathLength == (SectionNode->SectionRecord.FileNameLength - MFTSuffixLength))) {

                PathSuffix = SectionNode->FilePath + SectionNode->SectionRecord.FileNameLength;
                PathSuffix -= MFTSuffixLength;

                if (wcscmp(PathSuffix, MFTSuffix) == 0) {

                    //
                    // This is the MFT section node for this volume.
                    //

                    VolumeNode->MFTSectionNode = SectionNode;

                    //
                    // Mark the MFT section node as "ignore" so kernel does
                    // not attempt to prefetch it directly.
                    //

                    VolumeNode->MFTSectionNode->SectionRecord.IsIgnore = 1;

                    //
                    // Save how many pages we'll prefetch from MFT on the section
                    // node. We save this instead of FileIndexNumber field, since
                    // there won't be one for MFT. We won't try to get one either
                    // since we are marking this section node ignore.
                    //

                    VolumeNode->MFTSectionNode->MFTNumPagesToPrefetch = SectNumPagesToPrefetch;
                }
            }
        }

        //
        // If we are not ignoring this section, update its file system
        // index number so its metadata can be prefetched.
        //
        
        if (SectionNode->SectionRecord.IsIgnore == 0) {
            
            ErrorCode = PfSvGetFileIndexNumber(SectionNode->FilePath,
                                               &SectionNode->FileIndexNumber);
            
            if (ErrorCode == ERROR_SUCCESS) {

                if (VolumeNode) {
                
                    //
                    // Insert this section node into the section list of
                    // the volume it is on.
                    //
                    
                    InsertTailList(&VolumeNode->SectionList, 
                                   &SectionNode->SectionVolumeLink);
                    
                    VolumeNode->NumSections++;

                    //
                    // Update volume node's directory list with parent
                    // directories of this file.
                    //
                    
                    PfSvAddParentDirectoriesToList(&VolumeNode->DirectoryList,
                                                   VolumeNode->VolumePathLength,
                                                   SectionNode->FilePath,
                                                   SectionNode->SectionRecord.FileNameLength);
                }
            }
        }

        //
        // Update number of sections, number of pages and file name
        // info length on the scenario.
        //
        
        Scenario->NumSections++;
        Scenario->NumPages += SectionNode->SectionRecord.NumPages;
        
        FileNameSize = sizeof(WCHAR) * 
            (SectionNode->SectionRecord.FileNameLength + 1);
        Scenario->FileNameInfoSize += FileNameSize;
    }

    //
    // We are done. 
    //

    ErrorCode = ERROR_SUCCESS;

    DBGPR((PFID,PFTRC,"PFSVC: ApplyPrefetchPolicy()=%x\n", ErrorCode));

    return ErrorCode;
}

ULONG 
PfSvGetNumTimesUsed(
    ULONG UsageHistory,
    ULONG UsageHistorySize
    )

/*++

Routine Description:

    Calculate how many times a page seems to be used according to
    UsageHistory.

Arguments:

    UsageHistory - Bitmap. 1's correspond to "was used", 0 = "not used".
    
    UsageHistorySize - Size of UsageHistory in bits from the least
      significant bit.

Return Value:

    How many times the page seems to be used.

--*/

{
    ULONG NumUsed;
    ULONG BitIdx;

    //
    // Initialize locals.
    //

    NumUsed = 0;

    //
    // Walk through the bits in usage history starting from the least
    // significant and count how many bits are on. We can probably do
    // this more efficiently.
    //

    for (BitIdx = 0; BitIdx < UsageHistorySize; BitIdx++) {
        if (UsageHistory & (1 << BitIdx)) {
            NumUsed++;
        }
    }

    return NumUsed;
}

ULONG 
PfSvGetTraceEndIdx(
    PPF_TRACE_HEADER Trace
    )

/*++

Routine Description:

    Determines the index of the last page logged in the trace.

Arguments:

    Trace - Pointer to trace.

Return Value:

    Index of the last page logged.

--*/

{
    ULONG TotalFaults;
    ULONG PeriodIdx;
    ULONG *Id;

    DBGPR((PFID,PFSTRC,"PFSVC: GetTraceEndIdx(%p)\n", Trace));

    TotalFaults = Trace->FaultsPerPeriod[0];

    for (PeriodIdx = 1; PeriodIdx < PF_MAX_NUM_TRACE_PERIODS; PeriodIdx++) {
        
        if(Trace->FaultsPerPeriod[PeriodIdx] < PFSVC_MIN_FAULT_THRESHOLD) {

            //
            // If this is not the boot scenario, determine that
            // scenario has ended when logged pagefaults for a time
            // slice falls below minimum.
            //

            if (Trace->ScenarioType != PfSystemBootScenarioType) {
                break;
            }
        }
        
        TotalFaults += Trace->FaultsPerPeriod[PeriodIdx];
    }

    //
    // Sum of entries per period should not be greater than all
    // entries logged.
    //

    PFSVC_ASSERT(TotalFaults <= Trace->NumEntries);

    DBGPR((PFID,PFSTRC,"PFSVC: GetTraceEndIdx(%p)=%d\n", Trace, TotalFaults));

    return TotalFaults;
}

//
// Routines to write updated scenario instructions to the scenario
// file.
//

DWORD
PfSvWriteScenario(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PWCHAR ScenarioFilePath
    )

/*++

Routine Description:

    Prepare scenario instructions structure from the scenarion info
    and write it to the specified file.

Arguments:

    ScenarioInfo - Pointer to scenario info structure.

    ScenarioFilePath - Path to scenarion file to update.

Return Value:

    Win32 error code.

--*/

{
    DWORD BytesWritten;
    HANDLE OutputHandle;
    DWORD ErrorCode;
    BOOL bResult;
    PPF_SCENARIO_HEADER Scenario;
    ULONG FailedCheck;
      
    //
    // Initialize locals.
    //
    
    OutputHandle = INVALID_HANDLE_VALUE;
    Scenario = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: WriteScenario(%ws)\n", ScenarioFilePath));

    //
    // Build scenario dump from information we gathered.
    //

    ErrorCode = PfSvPrepareScenarioDump(ScenarioInfo, &Scenario);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Make sure the scenario we built passes the checks.
    //
    
    if (!PfSvVerifyScenarioBuffer(Scenario, Scenario->Size, &FailedCheck) ||
        Scenario->ServiceVersion != PFSVC_SERVICE_VERSION) {
        PFSVC_ASSERT(FALSE);
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Write out the buffer.
    //

    ErrorCode = PfSvWriteBuffer(ScenarioFilePath, Scenario, Scenario->Size);

    //
    // Fall through with ErrorCode.
    //

 cleanup:

    if (Scenario) {
        PFSVC_FREE(Scenario);
    }

    DBGPR((PFID,PFTRC,"PFSVC: WriteScenario(%ws)=%x\n", ScenarioFilePath, ErrorCode));
       
    return ErrorCode;
}

DWORD
PfSvPrepareScenarioDump(
    IN PPFSVC_SCENARIO_INFO ScenarioInfo,
    OUT PPF_SCENARIO_HEADER *ScenarioPtr
    ) 

/*++

Routine Description:

    Allocate a contiguous scenario buffer and fill it in with
    information in ScenarioInfo. ScenarioInfo is not modified.

Arguments:

    ScenarioInfo - Pointer to scenario information built from an
      existing scenario file and a scenario trace.

    ScenarioPtr - If successful, pointer to allocated and built
      scenario is put here. The caller should free this buffer when
      done with it.
    
Return Value:

    Win32 error code.

--*/

{
    PPF_SCENARIO_HEADER Scenario;
    ULONG Size;
    DWORD ErrorCode;
    PPF_SECTION_RECORD Sections;
    PPF_SECTION_RECORD Section;
    PPFSVC_SECTION_NODE SectionNode;
    ULONG SectionIdx;
    ULONG CurSectionIdx;
    PPF_PAGE_RECORD Pages;
    PPF_PAGE_RECORD Page;
    PPF_PAGE_RECORD PreviousPage;
    PPFSVC_PAGE_NODE PageNode;
    ULONG CurPageIdx;
    PCHAR FileNames;
    ULONG CurFileInfoOffset;
    PCHAR DestPtr;
    PLIST_ENTRY SectHead;
    PLIST_ENTRY SectNext;
    PLIST_ENTRY PageHead;
    PLIST_ENTRY PageNext;
    ULONG FileNameSize;
    PPFSVC_VOLUME_NODE VolumeNode;
    PLIST_ENTRY HeadVolume;
    PLIST_ENTRY NextVolume;
    PCHAR MetadataInfoBase;
    PPF_METADATA_RECORD MetadataRecordTable;
    PPF_METADATA_RECORD MetadataRecord;
    ULONG MetadataInfoSize;
    ULONG NumMetadataRecords;
    ULONG CurMetadataRecordIdx;
    ULONG CopySize;
    ULONG CurFilePrefetchIdx;
    ULONG FilePrefetchInfoSize;
    PFILE_PREFETCH FilePrefetchInfo;
    WCHAR *DirectoryPath;
    ULONG DirectoryPathLength;
    PPFSVC_PATH PathEntry;
    LARGE_INTEGER IndexNumber;
    ULONG DirectoryPathInfoSize;
    ULONG DirectoryPathSize;
    PPF_COUNTED_STRING DirectoryPathCS;

    //
    // Initialize locals.
    //

    Scenario = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: PrepareScenarioDump()\n"));

    //
    // Calculate how big the scenario is going to be.
    //
    
    Size = sizeof(PF_SCENARIO_HEADER);
    Size += ScenarioInfo->ScenHeader.NumSections * sizeof(PF_SECTION_RECORD);
    Size += ScenarioInfo->ScenHeader.NumPages * sizeof(PF_PAGE_RECORD);
    Size += ScenarioInfo->ScenHeader.FileNameInfoSize;

    //
    // Add space for the metadata prefetch information.
    //

    //
    // Make some space for aligning the metadata records table.
    //

    MetadataInfoSize = _alignof(PF_METADATA_RECORD);

    HeadVolume = &ScenarioInfo->VolumeList;
    NextVolume = HeadVolume->Flink;

    NumMetadataRecords = 0;
    
    while (NextVolume != HeadVolume) {

        VolumeNode = CONTAINING_RECORD(NextVolume,
                                       PFSVC_VOLUME_NODE,
                                       VolumeLink);

        NextVolume = NextVolume->Flink;

        //
        // If there are no sections at all on this volume, skip it.
        //

        if (VolumeNode->NumAllSections == 0) {
            continue;
        }

        NumMetadataRecords++;

        //
        // Metadata record:
        //

        MetadataInfoSize += sizeof(PF_METADATA_RECORD);
        
        //
        // Volume Path:
        //

        MetadataInfoSize += (VolumeNode->VolumePathLength + 1) * sizeof(WCHAR);
        
        //
        // FilePrefetchInfo buffer: This has to be ULONGLONG
        // aligned. Add extra space for that in case.
        //

        MetadataInfoSize += _alignof(FILE_PREFETCH);
        MetadataInfoSize += sizeof(FILE_PREFETCH);
        
        if (VolumeNode->NumSections) {
            MetadataInfoSize += (VolumeNode->NumSections - 1) * sizeof(ULONGLONG);
        }

        MetadataInfoSize += VolumeNode->DirectoryList.NumPaths * sizeof(ULONGLONG);

        if (VolumeNode->MFTSectionNode) {
            MetadataInfoSize += VolumeNode->MFTSectionNode->MFTNumPagesToPrefetch * sizeof(ULONGLONG);
        }

        //
        // Add space for the directory paths on this volume.
        //
        
        MetadataInfoSize += VolumeNode->DirectoryList.NumPaths * sizeof(PF_COUNTED_STRING);
        MetadataInfoSize += VolumeNode->DirectoryList.TotalLength * sizeof(WCHAR);
        
        //
        // Note that PF_COUNTED_STRING contains space for one
        // character. DirectoryList's total length excludes NUL's at
        // the end of each path.
        //
    }   

    Size += MetadataInfoSize;

    //
    // Allocate scenario buffer.
    //

    Scenario = PFSVC_ALLOC(Size);
    
    if (!Scenario) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Copy the header and set the size.
    //

    *Scenario = ScenarioInfo->ScenHeader;
    Scenario->Size = Size;

    DestPtr = (PCHAR) Scenario + sizeof(*Scenario);
    
    //
    // Initialize where our data is going.
    //
        
    Sections = (PPF_SECTION_RECORD) DestPtr;
    Scenario->SectionInfoOffset = (ULONG) (DestPtr - (PCHAR) Scenario);
    CurSectionIdx = 0;
    
    DestPtr += Scenario->NumSections * sizeof(PF_SECTION_RECORD);
    
    Pages = (PPF_PAGE_RECORD) DestPtr;
    Scenario->PageInfoOffset = (ULONG) (DestPtr - (PCHAR) Scenario);
    CurPageIdx = 0;

    DestPtr += Scenario->NumPages * sizeof(PF_PAGE_RECORD);

    FileNames = DestPtr;
    Scenario->FileNameInfoOffset = (ULONG) (DestPtr - (PCHAR) Scenario);
    CurFileInfoOffset = 0;

    DestPtr += Scenario->FileNameInfoSize;

    //
    // Extra space for this alignment was allocated upfront.
    //

    PFSVC_ASSERT(PF_IS_POWER_OF_TWO(_alignof(PF_METADATA_RECORD)));
    MetadataInfoBase = PF_ALIGN_UP(DestPtr, _alignof(PF_METADATA_RECORD));
    DestPtr += MetadataInfoSize;

    MetadataRecordTable = (PPF_METADATA_RECORD) MetadataInfoBase;
    Scenario->MetadataInfoOffset = (ULONG) (MetadataInfoBase - (PCHAR) Scenario);
    Scenario->MetadataInfoSize = (ULONG) (DestPtr - MetadataInfoBase);
    Scenario->NumMetadataRecords = NumMetadataRecords;

    //
    // Destination pointer should be at the end of the allocated
    // buffer now.
    //
    
    if (DestPtr != (PCHAR) Scenario + Scenario->Size) {

        PFSVC_ASSERT(FALSE);

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Walk through the sections on the new scenario info and copy
    // them.
    //

    SectHead = &ScenarioInfo->SectionList;
    SectNext = SectHead->Flink;

    while (SectHead != SectNext) {
        
        SectionNode = CONTAINING_RECORD(SectNext,
                                        PFSVC_SECTION_NODE,
                                        SectionLink);
        
        //
        // The target section record.
        //

        Section = &Sections[CurSectionIdx];

        //
        // Copy section record info.
        //
                                   
        *Section = SectionNode->SectionRecord;

        //
        // Copy pages for the section.
        //

        Section->FirstPageIdx = PF_INVALID_PAGE_IDX;
        PreviousPage = NULL;
        
        PageHead = &SectionNode->PageList;
        PageNext = PageHead->Flink;
        
        while (PageNext != PageHead) {

            PageNode = CONTAINING_RECORD(PageNext,
                                         PFSVC_PAGE_NODE,
                                         PageLink);

            Page = &Pages[CurPageIdx];

            //
            // If this is the first page in the section, update first
            // page index on the section record.
            //

            if (Section->FirstPageIdx == PF_INVALID_PAGE_IDX) {
                Section->FirstPageIdx = CurPageIdx;
            }

            //
            // Copy page record.
            //

            *Page = PageNode->PageRecord;

            //
            // Update NextPageIdx on the previous page if there is
            // one.
            //

            if (PreviousPage) {
                PreviousPage->NextPageIdx = CurPageIdx;
            }

            //
            // Update previous page.
            //
            
            PreviousPage = Page;

            //
            // Set next link to list termination now. If there is a
            // next page it is going to update this.
            //

            Page->NextPageIdx = PF_INVALID_PAGE_IDX;

            //
            // Update position in the page record table.
            //

            CurPageIdx++;

            PFSVC_ASSERT(CurPageIdx <= Scenario->NumPages);

            PageNext = PageNext->Flink;
        }

        //
        // Copy over file name.
        //

        FileNameSize = (Section->FileNameLength + 1) * sizeof(WCHAR);
        
        RtlCopyMemory(FileNames + CurFileInfoOffset, 
                      SectionNode->FilePath, 
                      FileNameSize);

        //
        // Update section record's file name offset.
        //

        Section->FileNameOffset = CurFileInfoOffset;

        //
        // Update current index into file name info.
        //

        CurFileInfoOffset += FileNameSize;

        PFSVC_ASSERT(CurFileInfoOffset <= Scenario->FileNameInfoSize);
        
        //
        // Update our position in the section table.
        //
        
        CurSectionIdx++;

        PFSVC_ASSERT(CurSectionIdx <= Scenario->NumSections);

        SectNext = SectNext->Flink;
    }    

    //
    // Make sure we filled up the tables.
    //

    if (CurSectionIdx != Scenario->NumSections ||
        CurPageIdx != Scenario->NumPages ||
        CurFileInfoOffset != Scenario->FileNameInfoSize) {
        
        PFSVC_ASSERT(FALSE);

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Build and copy the metadata prefetch information.
    //

    //
    // Set our target to right after the metadata records table.
    //

    DestPtr = MetadataInfoBase + sizeof(PF_METADATA_RECORD) * NumMetadataRecords;
    CurMetadataRecordIdx = 0;
    
    HeadVolume = &ScenarioInfo->VolumeList;
    NextVolume = HeadVolume->Flink;
    
    while (NextVolume != HeadVolume) {

        VolumeNode = CONTAINING_RECORD(NextVolume,
                                       PFSVC_VOLUME_NODE,
                                       VolumeLink);

        NextVolume = NextVolume->Flink;

        //
        // If there are no sections at all on this volume, skip it.
        //

        if (VolumeNode->NumAllSections == 0) {
            continue;
        }

        //
        // Make sure we are within bounds.
        //

        if (CurMetadataRecordIdx >= NumMetadataRecords) {
            PFSVC_ASSERT(CurMetadataRecordIdx < NumMetadataRecords);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }

        MetadataRecord = &MetadataRecordTable[CurMetadataRecordIdx];
        CurMetadataRecordIdx++;

        //
        // Copy volume identifiers. 
        //

        MetadataRecord->SerialNumber = VolumeNode->SerialNumber;
        MetadataRecord->CreationTime = VolumeNode->CreationTime;

        //
        // Copy volume name.
        //

        MetadataRecord->VolumeNameOffset = (ULONG) (DestPtr - MetadataInfoBase);
        MetadataRecord->VolumeNameLength = VolumeNode->VolumePathLength;
        CopySize = (VolumeNode->VolumePathLength + 1) * sizeof(WCHAR);
        
        if (DestPtr + CopySize > (PCHAR) Scenario + Scenario->Size) {
            PFSVC_ASSERT(FALSE);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }

        RtlCopyMemory(DestPtr, VolumeNode->VolumePath, CopySize);
        DestPtr += CopySize;

        //
        // Align and update DestPtr for the FILE_PREFETCH structure.
        //

        PFSVC_ASSERT(PF_IS_POWER_OF_TWO(_alignof(FILE_PREFETCH)));
        DestPtr = PF_ALIGN_UP(DestPtr, _alignof(FILE_PREFETCH));
        FilePrefetchInfo = (PFILE_PREFETCH) DestPtr;
        MetadataRecord->FilePrefetchInfoOffset = (ULONG) (DestPtr - MetadataInfoBase);
       
        //
        // Calculate size of the file prefetch information structure.
        //

        FilePrefetchInfoSize = sizeof(FILE_PREFETCH);
        
        if (VolumeNode->NumSections) {
            FilePrefetchInfoSize += (VolumeNode->NumSections - 1) * sizeof(ULONGLONG);
        }

        if (VolumeNode->MFTSectionNode) {
            FilePrefetchInfoSize += VolumeNode->MFTSectionNode->MFTNumPagesToPrefetch * sizeof(ULONGLONG);
        }

        FilePrefetchInfoSize += VolumeNode->DirectoryList.NumPaths * sizeof(ULONGLONG);
        MetadataRecord->FilePrefetchInfoSize = FilePrefetchInfoSize;

        if (DestPtr + FilePrefetchInfoSize > (PCHAR) Scenario + Scenario->Size) {
            PFSVC_ASSERT(FALSE);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }

        //
        // Update destination pointer.
        //

        DestPtr += FilePrefetchInfoSize;      

        //
        // Initialize file prefetch information structure.
        //

        FilePrefetchInfo->Type = FILE_PREFETCH_TYPE_FOR_CREATE;
        FilePrefetchInfo->Count = VolumeNode->NumSections + VolumeNode->DirectoryList.NumPaths;
        if (VolumeNode->MFTSectionNode) {
            FilePrefetchInfo->Count += VolumeNode->MFTSectionNode->MFTNumPagesToPrefetch;
        }

        //
        // Build list of file indexes to prefetch:
        //

        CurFilePrefetchIdx = 0;

        //
        // Add file system index numbers for sections.
        //

        SectHead = &VolumeNode->SectionList;
        SectNext = SectHead->Flink;
        
        while(SectNext != SectHead) {
            
            SectionNode = CONTAINING_RECORD(SectNext,
                                            PFSVC_SECTION_NODE,
                                            SectionVolumeLink);
            
            SectNext = SectNext->Flink;
            
            if (CurFilePrefetchIdx >= VolumeNode->NumSections) {
                PFSVC_ASSERT(FALSE);
                ErrorCode = ERROR_BAD_FORMAT;
                goto cleanup;
            }

            //
            // Add the filesystem index number for this section to the list.
            //
            
            FilePrefetchInfo->Prefetch[CurFilePrefetchIdx] = 
                SectionNode->FileIndexNumber.QuadPart;
            CurFilePrefetchIdx++;
        }

        //
        // Add file system index numbers for directories.
        //
        
        PathEntry = NULL;
        
        while (PathEntry = PfSvGetNextPathSorted(&VolumeNode->DirectoryList, 
                                                 PathEntry)) {

            DirectoryPath = PathEntry->Path;

            //
            // Get the file index number for this directory and add it
            // to the list we'll ask the filesystem to prefetch.
            //

            ErrorCode = PfSvGetFileIndexNumber(DirectoryPath, &IndexNumber);
            
            if (ErrorCode == ERROR_SUCCESS) {
                FilePrefetchInfo->Prefetch[CurFilePrefetchIdx] = IndexNumber.QuadPart;
            } else {
                FilePrefetchInfo->Prefetch[CurFilePrefetchIdx] = 0;
            }
            
            CurFilePrefetchIdx++;
        }

        //
        // Add file system index numbers that we drive from direct MFT access.
        //

        if (VolumeNode->MFTSectionNode) {

            SectionNode = VolumeNode->MFTSectionNode;
    
            for (PageNext = SectionNode->PageList.Flink;
                 PageNext != &SectionNode->PageList;
                 PageNext = PageNext->Flink) {

                PageNode = CONTAINING_RECORD(PageNext,
                                             PFSVC_PAGE_NODE,
                                             PageLink);

                if (!PageNode->PageRecord.IsIgnore) {

                    //
                    // We know the file offset in MFT. Every file record is
                    // 1KB == 2^10 bytes. To convert fileoffset in MFT to a
                    // file record number we just shift it by 10.
                    //

                    FilePrefetchInfo->Prefetch[CurFilePrefetchIdx] = 
                        PageNode->PageRecord.FileOffset >> 10;

                    CurFilePrefetchIdx++;
                }
            }
        }

        //
        // We should have specified all the file index numbers.
        //
        
        PFSVC_ASSERT(CurFilePrefetchIdx == FilePrefetchInfo->Count);

        //
        // Add paths for directories accessed on this volume.
        //

        MetadataRecord->NumDirectories = VolumeNode->DirectoryList.NumPaths;
        MetadataRecord->DirectoryPathsOffset = (ULONG)(DestPtr - MetadataInfoBase);             

        PathEntry = NULL;
        while (PathEntry = PfSvGetNextPathSorted(&VolumeNode->DirectoryList, 
                                                 PathEntry)) {
            
            DirectoryPath = PathEntry->Path;
            DirectoryPathLength = PathEntry->Length;

            //
            // Calculate how big the entry for this path is going to
            // be and make sure it will be within bounds.
            //

            DirectoryPathSize = sizeof(PF_COUNTED_STRING);
            DirectoryPathSize += DirectoryPathLength * sizeof(WCHAR);

            if (DestPtr + DirectoryPathSize > (PCHAR) Scenario + Scenario->Size) {
                PFSVC_ASSERT(FALSE);
                ErrorCode = ERROR_BAD_FORMAT;
                goto cleanup;
            }
            
            //
            // Copy over the directory path.
            //

            DirectoryPathCS = (PPF_COUNTED_STRING) DestPtr;
            DirectoryPathCS->Length = (USHORT) DirectoryPathLength;
            RtlCopyMemory(DirectoryPathCS->String, 
                          DirectoryPath, 
                          (DirectoryPathLength + 1) * sizeof(WCHAR));

            DestPtr += DirectoryPathSize;
        }
    }    

    //
    // Make sure we are not past the end of the buffer.
    //

    if (DestPtr > (PCHAR) Scenario + Scenario->Size) {
        PFSVC_ASSERT(FALSE);
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Set up return pointer.
    //

    *ScenarioPtr = Scenario;

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        if (Scenario != NULL) {
            PFSVC_FREE(Scenario);
        }
    }

    DBGPR((PFID,PFTRC,"PFSVC: PrepareScenarioDump()=%x\n", ErrorCode));

    return ErrorCode;
}

//
// Routines to maintain the optimal disk layout file and update disk
// layout.
//

DWORD
PfSvUpdateOptimalLayout(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    This routine will determine if the optimal disk layout has to be 
    updated and if so it will write out a new layout file and launch
    the defragger.
        
Arguments:

    Task - If specified the function will check Task every once in a
      while to see if it should exit with ERROR_RETRY.

Return Value:

    Win32 error code.

--*/

{
    ULARGE_INTEGER CurrentTimeLI;
    ULARGE_INTEGER LastDiskLayoutTimeLI;
    ULARGE_INTEGER MinTimeBeforeRelayoutLI;
    PFSVC_PATH_LIST OptimalLayout;
    PFSVC_PATH_LIST CurrentLayout;
    FILETIME LastDiskLayoutTime;
    FILETIME FirstDiskLayoutTime;
    FILETIME LayoutFileTime;
    FILETIME CurrentTime;
    PPFSVC_PATH_LIST NewLayout;
    PWCHAR LayoutFilePath;
    ULONG LayoutFilePathBufferSize;
    DWORD ErrorCode;
    DWORD BootScenarioProcessed;
    DWORD BootFilesWereOptimized;
    DWORD MinHoursBeforeRelayout;
    DWORD Size;
    DWORD RegValueType;
    BOOLEAN LayoutChanged;
    BOOLEAN MissingOriginalLayoutFile;
    BOOLEAN BootPrefetchingIsEnabled;
    BOOLEAN CheckForLayoutFrequencyLimit;

    //
    // Initialize locals.
    //

    LayoutFilePath = NULL;
    LayoutFilePathBufferSize = 0;
    PfSvInitializePathList(&OptimalLayout, NULL, FALSE);
    PfSvInitializePathList(&CurrentLayout, NULL, FALSE);

    DBGPR((PFID,PFTRC,"PFSVC: UpdateOptimalLayout(%p)\n", Task));

    //
    // Determine when we updated the disk layout from the layout file.
    //

    ErrorCode = PfSvGetLastDiskLayoutTime(&LastDiskLayoutTime);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Query whether boot files have been optimized.
    //

    Size = sizeof(BootFilesWereOptimized);

    ErrorCode = RegQueryValueEx(PfSvcGlobals.ServiceDataKey,
                                PFSVC_BOOT_FILES_OPTIMIZED_VALUE_NAME,
                                NULL,
                                &RegValueType,
                                (PVOID) &BootFilesWereOptimized,
                                &Size);

    if (ErrorCode != ERROR_SUCCESS) {
        BootFilesWereOptimized = FALSE;
    }

    //
    // Get optimal layout file path.
    //

    ErrorCode =  PfSvGetLayoutFilePath(&LayoutFilePath,
                                       &LayoutFilePathBufferSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Determine when the file was last modified.
    //

    ErrorCode = PfSvGetLastWriteTime(LayoutFilePath, &LayoutFileTime);

    if (ErrorCode == ERROR_SUCCESS) {

        MissingOriginalLayoutFile = FALSE;

        //
        // If the file was modified after we laid out the files on the disk
        // its contents are not interesting. Otherwise, if the new optimal
        // layout is similar to layout specified in the file, we may not
        // have to re-layout the files.
        //

        if (CompareFileTime(&LayoutFileTime, &LastDiskLayoutTime) <= 0) {

            //
            // Read the current layout.
            //

            ErrorCode = PfSvReadLayout(LayoutFilePath,
                                       &CurrentLayout,
                                       &LayoutFileTime);
            
            if (ErrorCode != ERROR_SUCCESS) {
                
                //
                // The layout file seems to be bad / inaccesible.
                // Cleanup the path list, so a brand new one gets
                // built.
                //

                PfSvCleanupPathList(&CurrentLayout);
                PfSvInitializePathList(&CurrentLayout, NULL, FALSE);
            }
        }

    } else {

        //
        // We could not get the timestamp on the original layout file.
        // It might have been deleted.
        //
        
        MissingOriginalLayoutFile = TRUE;
    }

    //
    // Determine what the current optimal layout should be from 
    // scenario files.
    //

    ErrorCode = PfSvDetermineOptimalLayout(Task, 
                                           &OptimalLayout, 
                                           &BootScenarioProcessed);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Update current layout based on what optimal layout should be.
    // If the two are similar we don't need to launch the defragger.
    //

    ErrorCode = PfSvUpdateLayout(&CurrentLayout, 
                                 &OptimalLayout,
                                 &LayoutChanged);

    if (ErrorCode == ERROR_SUCCESS) {

        if (!LayoutChanged) {
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }

        //
        // We'll use the updated layout.
        //

        NewLayout = &CurrentLayout;

    } else {

        //
        // We'll run with the optimal layout.
        //

        NewLayout = &OptimalLayout;
    }

    //
    // Optimal way to layout files has changed. Write out the new layout.
    //

    ErrorCode = PfSvSaveLayout(LayoutFilePath,
                               NewLayout,
                               &LayoutFileTime);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // If enough time has not passed since last disk layout don't run the
    // defragger again unless...
    //

    CheckForLayoutFrequencyLimit = TRUE;

    //
    //   - We've been explicitly asked to update the layout (i.e. no idle
    //     task context.)
    //

    if (!Task) {
        CheckForLayoutFrequencyLimit = FALSE;        
    }

    //
    //   - Someone seems to have deleted the layout file and we recreated it.
    //

    if (MissingOriginalLayoutFile) {
        CheckForLayoutFrequencyLimit = FALSE;
    }

    //
    //   - Boot prefetching is enabled but boot files have not been optimized
    //     yet and we processed the list of files from the boot this time.
    //

    if (PfSvcGlobals.Parameters.EnableStatus[PfSystemBootScenarioType] == PfSvEnabled) {
        if (!BootFilesWereOptimized && BootScenarioProcessed) {
            CheckForLayoutFrequencyLimit = FALSE;
        }
    }

    if (CheckForLayoutFrequencyLimit) {

        //
        // We will check to see if enough time has passed by getting current 
        // time and comparing it to last disk layout time.
        //

        LastDiskLayoutTimeLI.LowPart = LastDiskLayoutTime.dwLowDateTime;
        LastDiskLayoutTimeLI.HighPart = LastDiskLayoutTime.dwHighDateTime;

        //
        // Get current time as file time.
        //

        GetSystemTimeAsFileTime(&CurrentTime);

        CurrentTimeLI.LowPart = CurrentTime.dwLowDateTime;
        CurrentTimeLI.HighPart = CurrentTime.dwHighDateTime;

        //
        // Check to make sure that current time is after last disk layout time
        // (in case the user has played with time.) 
        //

        if (CurrentTimeLI.QuadPart > LastDiskLayoutTimeLI.QuadPart) {

            //
            // Query how long has to pass before we re-layout the files on
            // disk.
            //
            
            Size = sizeof(MinHoursBeforeRelayout);

            ErrorCode = RegQueryValueEx(PfSvcGlobals.ServiceDataKey,
                                        PFSVC_MIN_RELAYOUT_HOURS_VALUE_NAME,
                                        NULL,
                                        &RegValueType,
                                        (PVOID) &MinHoursBeforeRelayout,
                                        &Size);

            if (ErrorCode == ERROR_SUCCESS) {
                MinTimeBeforeRelayoutLI.QuadPart = PFSVC_NUM_100NS_IN_AN_HOUR * MinHoursBeforeRelayout;
            } else {
                MinTimeBeforeRelayoutLI.QuadPart = PFSVC_MIN_TIME_BEFORE_DISK_RELAYOUT;
            }

            if (CurrentTimeLI.QuadPart < LastDiskLayoutTimeLI.QuadPart + 
                                         MinTimeBeforeRelayoutLI.QuadPart) {

                //
                // Not enough time has passed before last disk layout.
                //

                ErrorCode = ERROR_INVALID_TIME;
                goto cleanup;               
            }
        }       
    }

    //
    // Launch the defragger for layout optimization.
    //

    ErrorCode = PfSvLaunchDefragger(Task, TRUE, NULL);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Save whether boot files were optimized.
    //

    ErrorCode = RegSetValueEx(PfSvcGlobals.ServiceDataKey,
                              PFSVC_BOOT_FILES_OPTIMIZED_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &BootScenarioProcessed,
                              sizeof(BootScenarioProcessed));

    //
    // Save the last time we updated disk layout to the registry.
    //

    ErrorCode = PfSvSetLastDiskLayoutTime(&LayoutFileTime);

    //
    // Fall through with error code.
    //

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: UpdateOptimalLayout(%p)=%x\n", Task, ErrorCode));

    PfSvCleanupPathList(&OptimalLayout);
    PfSvCleanupPathList(&CurrentLayout);

    if (LayoutFilePath) {
        PFSVC_FREE(LayoutFilePath);
    }

    return ErrorCode;
}

DWORD
PfSvUpdateLayout (
    PPFSVC_PATH_LIST CurrentLayout,
    PPFSVC_PATH_LIST OptimalLayout,
    PBOOLEAN LayoutChanged
    )

/*++

Routine Description:

    This routine updates the specified layout based on the new optimal
    layout. If the two layouts are similar, CurrentLayout is not updated.

    An error may be returned while CurrentLayout is being updated. It is the 
    caller's responsibility to revert CurrentLayout to its original in that case.

Arguments:

    CurrentLayout - Current file layout.

    OptimalLayout - Newly determined optimal file layout.

    LayoutChanged - Whether Layout was changed.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PPFSVC_PATH PathEntry;
    ULONG NumOptimalLayoutFiles;
    ULONG NumMissingFiles;
    ULONG NumCommonFiles;
    ULONG NumCurrentLayoutOnlyFiles;

    //
    // Initialize locals.
    //

    NumOptimalLayoutFiles = 0;
    NumMissingFiles = 0;

    //
    // Go through the paths in the new layout counting the differences with
    // the current layout.
    //

    PathEntry = NULL;

    while (PathEntry = PfSvGetNextPathInOrder(OptimalLayout, PathEntry)) {

        NumOptimalLayoutFiles++;

        if (!PfSvIsInPathList(CurrentLayout, PathEntry->Path, PathEntry->Length)) {
            NumMissingFiles++;
        }
    }

    //
    // Make some sanity checks about the statistics gathered.
    //

    PFSVC_ASSERT(NumOptimalLayoutFiles == OptimalLayout->NumPaths);
    PFSVC_ASSERT(NumOptimalLayoutFiles >= NumMissingFiles);

    NumCommonFiles = NumOptimalLayoutFiles - NumMissingFiles;
    PFSVC_ASSERT(CurrentLayout->NumPaths >= NumCommonFiles);

    NumCurrentLayoutOnlyFiles = CurrentLayout->NumPaths - NumCommonFiles;

    //
    // If there are not that many new files: no need to update the layout. 
    //

    if (NumMissingFiles <= 20) {
                
        *LayoutChanged = FALSE;
        ErrorCode = ERROR_SUCCESS;

        goto cleanup;
    } 

    //
    // We will be updating the current layout.
    //

    *LayoutChanged = TRUE;

    //
    // If there are too many files in the current layout that don't need to be
    // there anymore, rebuild the list.
    //

    if (NumCurrentLayoutOnlyFiles >= CurrentLayout->NumPaths / 4) {
        PfSvCleanupPathList(CurrentLayout);
        PfSvInitializePathList(CurrentLayout, NULL, FALSE);
    }
    
    //
    // Add files from the optimal layout to the end of current layout.
    //

    while (PathEntry = PfSvGetNextPathInOrder(OptimalLayout, PathEntry)) {

        ErrorCode = PfSvAddToPathList(CurrentLayout, PathEntry->Path, PathEntry->Length);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: UpdateLayout(%p,%p)=%d,%x\n",CurrentLayout,OptimalLayout,*LayoutChanged,ErrorCode));

    return ErrorCode;
}

DWORD
PfSvDetermineOptimalLayout (
    PPFSVC_IDLE_TASK Task,
    PPFSVC_PATH_LIST OptimalLayout,
    BOOL *BootScenarioProcessed
    )

/*++

Routine Description:

    This routine will determine if the optimal disk layout has to be 
    updated by looking at the existing scenario files.
        
Arguments:

    Task - If specified the function will check Task every once in a
      while to see if it should exit with ERROR_RETRY.

    OptimalLayout - Initialized empty path list that will be built.

    BootScenarioProcessed - Whether we got the list of boot files from
      the boot scenario.

Return Value:

    Win32 error code.

--*/

{
    PFSVC_SCENARIO_FILE_CURSOR FileCursor;
    FILETIME LayoutFileTime;
    PNTPATH_TRANSLATION_LIST TranslationList;
    PWCHAR DosPathBuffer;
    ULONG DosPathBufferSize;
    DWORD ErrorCode;
    BOOLEAN AcquiredLock;
    WCHAR BootScenarioFileName[PF_MAX_SCENARIO_FILE_NAME];
    WCHAR BootScenarioFilePath[MAX_PATH + 1];
    
    //
    // Initialize locals.
    //

    PfSvInitializeScenarioFileCursor(&FileCursor);
    TranslationList = NULL;
    AcquiredLock = FALSE;
    DosPathBuffer = NULL;
    DosPathBufferSize = 0;

    DBGPR((PFID,PFTRC,"PFSVC: DetermineOptimalLayout(%p,%p)\n",Task,OptimalLayout));

    //
    // Initialize output variables.
    //

    *BootScenarioProcessed = FALSE;

    //
    // Acquire the prefetch root directory lock and initialize some locals.
    //

    PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredLock = TRUE;

    //
    // Start the file cursor.
    //

    ErrorCode = PfSvStartScenarioFileCursor(&FileCursor, PfSvcGlobals.PrefetchRoot);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Build the boot scenario file path.
    //

    swprintf(BootScenarioFileName, 
             PF_SCEN_FILE_NAME_FORMAT,
             PF_BOOT_SCENARIO_NAME,
             PF_BOOT_SCENARIO_HASHID,
             PF_PREFETCH_FILE_EXTENSION);

    swprintf(BootScenarioFilePath, 
             L"%ws\\%ws",
             PfSvcGlobals.PrefetchRoot,
             BootScenarioFileName);   

    PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredLock = FALSE;   

    //
    // Get translation list so we can convert NT paths in the trace to
    // Dos paths that the defragger understands.
    //

    ErrorCode = PfSvBuildNtPathTranslationList(&TranslationList);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Should we continue to run?
    //

    ErrorCode = PfSvContinueRunningTask(Task);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }       

    //
    // Add boot loader files to optimal layout.
    //

    ErrorCode = PfSvBuildBootLoaderFilesList(OptimalLayout);
        
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Add files from the boot scenario.
    //

    ErrorCode = PfSvUpdateLayoutForScenario(OptimalLayout, 
                                            BootScenarioFilePath,
                                            TranslationList,
                                            &DosPathBuffer,
                                            &DosPathBufferSize);

    if (ErrorCode == ERROR_SUCCESS) {
        *BootScenarioProcessed = TRUE;
    }

    //
    // Go through all the other scenario files.
    //

    while (TRUE) {

        //
        // Should we continue to run?
        //

        ErrorCode = PfSvContinueRunningTask(Task);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }       

        //
        // Get file info for the next scenario file.
        //

        ErrorCode = PfSvGetNextScenarioFileInfo(&FileCursor);

        if (ErrorCode == ERROR_NO_MORE_FILES) {
            break;
        }

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        PfSvUpdateLayoutForScenario(OptimalLayout, 
                                    FileCursor.FilePath,
                                    TranslationList,
                                    &DosPathBuffer,
                                    &DosPathBufferSize);
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: DetermineOptimalLayout(%p,%p)=%x\n",Task,OptimalLayout,ErrorCode));

    if (AcquiredLock) {
        PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    }

    PfSvCleanupScenarioFileCursor(&FileCursor);

    if (TranslationList) {
        PfSvFreeNtPathTranslationList(TranslationList);
    }

    if (DosPathBuffer) {
        PFSVC_ASSERT(DosPathBufferSize);
        PFSVC_FREE(DosPathBuffer);
    }

    return ErrorCode;
}

DWORD
PfSvUpdateLayoutForScenario (
    PPFSVC_PATH_LIST OptimalLayout,
    WCHAR *ScenarioFilePath,
    PNTPATH_TRANSLATION_LIST TranslationList,
    PWCHAR *DosPathBuffer,
    PULONG DosPathBufferSize
    )

/*++

Routine Description:

    This routine will add the directories and files referenced in a 
    scenario in the order they appear to the specified optimal layout 
    path list .
        
Arguments:

    OptimalLayout - Pointer to path list.

    ScenarioFilePath - Scenario file.

    TranslationList, DosPathBuffer, DosPathBufferSize - These are used
      to translate NT path names in the scenario file to Dos path names
      that should be in the layout file.

Return Value:

    Win32 error code.

--*/

{
    PPF_SCENARIO_HEADER Scenario;
    PCHAR MetadataInfoBase;
    PPF_METADATA_RECORD MetadataRecordTable;
    PPF_METADATA_RECORD MetadataRecord;
    PPF_COUNTED_STRING DirectoryPath;
    PPF_SECTION_RECORD Sections;
    PPF_SECTION_RECORD SectionRecord;
    PCHAR FilePathInfo;
    PWCHAR FilePath;
    ULONG FilePathLength;
    ULONG SectionIdx;
    ULONG MetadataRecordIdx;
    ULONG DirectoryIdx;
    DWORD ErrorCode;
    DWORD FileSize;
    DWORD FailedCheck;

    //
    // Initialize locals.
    //

    Scenario = NULL;

    //
    // Map the scenario file.
    //

    ErrorCode = PfSvGetViewOfFile(ScenarioFilePath, 
                                  &Scenario,
                                  &FileSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Verify scenario file.
    //

    if (!PfSvVerifyScenarioBuffer(Scenario, FileSize, &FailedCheck) ||
        Scenario->ServiceVersion != PFSVC_SERVICE_VERSION) {

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // First add the directories that need to be accessed.
    //
    
    MetadataInfoBase = (PCHAR)Scenario + Scenario->MetadataInfoOffset;
    MetadataRecordTable = (PPF_METADATA_RECORD) MetadataInfoBase;

    for (MetadataRecordIdx = 0;
         MetadataRecordIdx < Scenario->NumMetadataRecords;
         MetadataRecordIdx++) {

        MetadataRecord = &MetadataRecordTable[MetadataRecordIdx];

        DirectoryPath = (PPF_COUNTED_STRING)
            (MetadataInfoBase + MetadataRecord->DirectoryPathsOffset);
        
        for (DirectoryIdx = 0;
             DirectoryIdx < MetadataRecord->NumDirectories;
             DirectoryIdx++,
               DirectoryPath = (PPF_COUNTED_STRING) (&DirectoryPath->String[DirectoryPath->Length + 1])) {

            ErrorCode = PfSvTranslateNtPath(TranslationList,
                                            DirectoryPath->String,
                                            DirectoryPath->Length,
                                            DosPathBuffer,
                                            DosPathBufferSize);

            //
            // We may not be able to translate all NT paths to Dos paths.
            //

            if (ErrorCode == ERROR_SUCCESS) {

                ErrorCode = PfSvAddToPathList(OptimalLayout,
                                              *DosPathBuffer,
                                              wcslen(*DosPathBuffer));

                if (ErrorCode != ERROR_SUCCESS) {
                    goto cleanup;
                }
            }
        }       
    }

    //
    // Now add the file paths.
    //

    Sections = (PPF_SECTION_RECORD) ((PCHAR)Scenario + Scenario->SectionInfoOffset);
    FilePathInfo = (PCHAR)Scenario + Scenario->FileNameInfoOffset;

    for (SectionIdx = 0; SectionIdx < Scenario->NumSections; SectionIdx++) {

        FilePath = (PWSTR) (FilePathInfo + Sections[SectionIdx].FileNameOffset);
        FilePathLength = Sections[SectionIdx].FileNameLength;
        
        ErrorCode = PfSvTranslateNtPath(TranslationList,
                                        FilePath,
                                        FilePathLength,
                                        DosPathBuffer,
                                        DosPathBufferSize);

        //
        // We may not be able to translate all NT paths to Dos paths.
        //

        if (ErrorCode == ERROR_SUCCESS) {

            ErrorCode = PfSvAddToPathList(OptimalLayout,
                                          *DosPathBuffer,
                                          wcslen(*DosPathBuffer));

            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

cleanup:

    if (Scenario) {
        UnmapViewOfFile(Scenario);
    }

    DBGPR((PFID,PFTRC,"PFSVC: UpdateLayoutForScenario(%p,%ws)=%x\n",OptimalLayout,ScenarioFilePath,ErrorCode));

    return ErrorCode;
}

DWORD
PfSvReadLayout(
    IN WCHAR *FilePath,
    OUT PPFSVC_PATH_LIST Layout,
    OUT FILETIME *LastWriteTime
    )

/*++

Routine Description:

    This function adds contents of the optimal layout file to the
    specified path list. Note that failure may be returned after
    adding several files to the list.

Arguments:

    FilePath - NUL terminated path to optimal layout file.

    Layout - Pointer to initialized path list.     

    LastWriteTime - Last write time of the read file.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    FILE *LayoutFile;
    WCHAR *LineBuffer;
    ULONG LineBufferMaxChars;
    ULONG LineLength;

    //
    // Initialize locals.
    //
    
    LayoutFile = NULL;
    LineBuffer = NULL;
    LineBufferMaxChars = 0;

    //
    // Open the layout file.
    //
    
    LayoutFile = _wfopen(FilePath, L"rb");
    
    if (!LayoutFile) {
        ErrorCode = ERROR_FILE_NOT_FOUND;
        goto cleanup;
    }

    //
    // Read and verify header.
    //

    ErrorCode = PfSvReadLine(LayoutFile,
                             &LineBuffer,
                             &LineBufferMaxChars,
                             &LineLength);
    
    if (ErrorCode != ERROR_SUCCESS || !LineLength) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }
    
    PfSvRemoveEndOfLineChars(LineBuffer, &LineLength);
    
    if (wcscmp(LineBuffer, L"[OptimalLayoutFile]")) {

        //
        // Notepad puts a weird first character in the UNICODE text files.
        // Skip the first character and compare again.
        //
        
        if ((LineLength < 1) || 
            wcscmp(&LineBuffer[1], L"[OptimalLayoutFile]")) {

            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }
    }

    //
    // Read and verify version.
    //

    ErrorCode = PfSvReadLine(LayoutFile,
                             &LineBuffer,
                             &LineBufferMaxChars,
                             &LineLength);
    
    if (ErrorCode != ERROR_SUCCESS || !LineLength) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }
    
    PfSvRemoveEndOfLineChars(LineBuffer, &LineLength);

    if (wcscmp(LineBuffer, L"Version=1")) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }
    
    //
    // Read in file names.
    //

    do {

        ErrorCode = PfSvReadLine(LayoutFile,
                                 &LineBuffer,
                                 &LineBufferMaxChars,
                                 &LineLength);
    
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        if (!LineLength) {
            
            //
            // We hit end of file.
            //

            break;
        }
    
        PfSvRemoveEndOfLineChars(LineBuffer, &LineLength);
        
        //
        // Add it to the list.
        //
        
        ErrorCode = PfSvAddToPathList(Layout,
                                      LineBuffer,
                                      LineLength);
        
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

    } while (TRUE);

    //
    // Get the last write time on the file.
    //

    ErrorCode = PfSvGetLastWriteTime(FilePath, LastWriteTime);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    if (LayoutFile) {
        fclose(LayoutFile);
    }
    
    if (LineBuffer) {
        PFSVC_ASSERT(LineBufferMaxChars);
        PFSVC_FREE(LineBuffer);
    }
    
    return ErrorCode;
} 

DWORD
PfSvSaveLayout(
    IN WCHAR *FilePath,
    IN PPFSVC_PATH_LIST Layout,
    OUT FILETIME *LastWriteTime
    )

/*++

Routine Description:

    This routine saves the specified file layout list in order to the
    specified file in the right format.

Arguments:
      
    FilePath - Path to output layout file.

    Layout - Pointer to layout.

    LastWriteTime - Last write time on the file after we are done
      saving the layout.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    HANDLE LayoutFile;
    WCHAR *FileHeader;
    ULONG BufferSize;
    ULONG NumBytesWritten;
    PPFSVC_PATH PathEntry;
    WCHAR *NewLine;
    ULONG SizeOfNewLine;

    //
    // Initialize locals.
    //
    
    LayoutFile = INVALID_HANDLE_VALUE;
    NewLine = L"\r\n";
    SizeOfNewLine = wcslen(NewLine) * sizeof(WCHAR);

    //
    // Open & truncate the layout file. We are also opening with read
    // permissions so we can query the last write time when we are
    // done.
    //
    
    LayoutFile = CreateFile(FilePath,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            0,
                            CREATE_ALWAYS,
                            0,
                            NULL);
    
    if (LayoutFile == INVALID_HANDLE_VALUE) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Write out the header.
    //

    FileHeader = L"[OptimalLayoutFile]\r\nVersion=1\r\n";
    BufferSize = wcslen(FileHeader) * sizeof(WCHAR);

    if (!WriteFile(LayoutFile,
                   FileHeader,
                   BufferSize,
                   &NumBytesWritten,
                   NULL)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    PathEntry = NULL;
    while (PathEntry = PfSvGetNextPathInOrder(Layout, PathEntry)) {
        
        //
        // Write the path.
        //

        BufferSize = PathEntry->Length * sizeof(WCHAR);

        if (!WriteFile(LayoutFile,
                       PathEntry->Path,
                       BufferSize,
                       &NumBytesWritten,
                       NULL)) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
        
        //
        // Write the newline.
        //

        if (!WriteFile(LayoutFile,
                       NewLine,
                       SizeOfNewLine,
                       &NumBytesWritten,
                       NULL)) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
    }
    
    //
    // Make sure everything is written to the file so our
    // LastWriteTime will be accurate.
    //

    if (!FlushFileBuffers(LayoutFile)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Get the last write time.
    //

    if (!GetFileTime(LayoutFile, NULL, NULL, LastWriteTime)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:
    
    if (LayoutFile != INVALID_HANDLE_VALUE) {
        CloseHandle(LayoutFile);
    }

    return ErrorCode;
}

DWORD
PfSvGetLayoutFilePath(
    PWCHAR *FilePathBuffer,
    PULONG FilePathBufferSize
    )

/*++

Routine Description:

    This function tries to query the layout file path into the
    specified buffer. If the buffer is too small, or NULL, it is
    reallocated. If not NULL, the buffer should have been allocated by
    PFSVC_ALLOC. It is the callers responsibility to free the returned
    buffer using PFSVC_FREE.

    In order to avoid having somebody cause us to overwrite any file
    in the system always the default layout file path is saved in the
    registry and returned.

Arguments:

    FilePathBuffer - Layout file path will be put into this buffer
      after it is reallocated if it is NULL or not big enough.

    FilePathBufferSize - Maximum size of *FilePathBuffer in bytes.

Return Value:

    Win32 error code.

--*/

{
    ULONG DefaultPathSize;
    ULONG DefaultPathLength;
    HKEY DefragParametersKey;
    DWORD ErrorCode;
    BOOLEAN AcquiredPrefetchRootLock;
    BOOLEAN OpenedParametersKey;

    //
    // Initialize locals.
    //

    AcquiredPrefetchRootLock = FALSE;
    OpenedParametersKey = FALSE;

    //
    // Verify parameters.
    //

    if (*FilePathBufferSize) {
        PFSVC_ASSERT(*FilePathBuffer);
    }

    PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredPrefetchRootLock = TRUE;

    DefaultPathLength = wcslen(PfSvcGlobals.PrefetchRoot);
    DefaultPathLength += 1;  // for '\\'
    DefaultPathLength += wcslen(PFSVC_OPTIMAL_LAYOUT_FILE_DEFAULT_NAME);

    DefaultPathSize = (DefaultPathLength + 1) * sizeof(WCHAR);

    //
    // Check if we have to allocate/reallocate the buffer.
    //

    if ((*FilePathBufferSize) <= DefaultPathSize) {
        
        if (*FilePathBuffer) {
            PFSVC_ASSERT(*FilePathBufferSize);
            PFSVC_FREE(*FilePathBuffer);
        }
        
        (*FilePathBufferSize) = 0;

        (*FilePathBuffer) = PFSVC_ALLOC(DefaultPathSize);
        
        if (!(*FilePathBuffer)) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        
        (*FilePathBufferSize) = DefaultPathSize;
    }

    //
    // Build the path in the FilePathBuffer
    //
            
    wcscpy((*FilePathBuffer), PfSvcGlobals.PrefetchRoot);
    wcscat((*FilePathBuffer), L"\\");
    wcscat((*FilePathBuffer), PFSVC_OPTIMAL_LAYOUT_FILE_DEFAULT_NAME);

    PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredPrefetchRootLock = FALSE;

    //
    // Save the default path in the registry so it is used by the
    // defragger:
    //

    //
    // Open the parameters key, creating it if necessary.
    //
    
    ErrorCode = RegCreateKey(HKEY_LOCAL_MACHINE,
                             PFSVC_OPTIMAL_LAYOUT_REG_KEY_PATH,
                             &DefragParametersKey);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    OpenedParametersKey = TRUE;
                        
    ErrorCode = RegSetValueEx(DefragParametersKey,
                              PFSVC_OPTIMAL_LAYOUT_REG_VALUE_NAME,
                              0,
                              REG_SZ,
                              (PVOID) (*FilePathBuffer),
                              (*FilePathBufferSize));
            
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

 cleanup:
    
    if (AcquiredPrefetchRootLock) {
        PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    }

    if (OpenedParametersKey) {
        CloseHandle(DefragParametersKey);
    }   

    return ErrorCode;
}

//
// Routines to defrag the disks once after setup when the system is idle.
//

DWORD
PfSvLaunchDefragger(
    PPFSVC_IDLE_TASK Task,
    BOOLEAN ForLayoutOptimization,
    PWCHAR TargetDrive
    )

/*++

Routine Description:

    This routine will launch the defragger. It will create an event that
    will be passed to the defragger so the defragger can be stopped if
    the service is stopping or the Task (if one is specified) is being 
    unregistered, etc.
            
Arguments:

    Task - If specified the function will check Task every once in a
      while to see if it should exit with ERROR_RETRY.

    ForLayoutOptimization - Whether we are launching the defragger
      only for layout optimization.

    TargetDrive - If we are not launching for layout optimization, the 
      drive that we want to defrag.

Return Value:

    Win32 error code.

--*/

{
    PROCESS_INFORMATION ProcessInfo; 
    STARTUPINFO StartupInfo; 
    WCHAR *CommandLine;
    WCHAR *DefragCommand;
    WCHAR *DoLayoutParameter;
    WCHAR *DriveToDefrag;
    HANDLE StopDefraggerEvent;
    HANDLE ProcessHandle;
    HANDLE Events[4];
    ULONG NumEvents;
    ULONG MaxEvents;
    DWORD ErrorCode;
    DWORD ExitCode;
    DWORD WaitResult;
    DWORD ProcessId;
    ULONG SystemDirLength;
    ULONG CommandLineLength;
    ULONG RetryCount;
    BOOL DefraggerExitOnItsOwn;
    WCHAR SystemDrive[3];
    WCHAR ProcessIdString[35];
    WCHAR StopEventString[35];
    WCHAR SystemDir[MAX_PATH + 1];

    //
    // Initialize locals.
    //
   
    StopDefraggerEvent = NULL;
    DefragCommand = L"\\defrag.exe\" ";
    DoLayoutParameter = L"-b ";
    CommandLine = NULL;
    RtlZeroMemory(&ProcessInfo, sizeof(PROCESS_INFORMATION));
    RtlZeroMemory(&StartupInfo, sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO); 
    ProcessHandle = NULL;
    MaxEvents = sizeof(Events) / sizeof(HANDLE);

    DBGPR((PFID,PFTRC,"PFSVC: LaunchDefragger(%p,%d,%ws)\n",Task,(DWORD)ForLayoutOptimization,TargetDrive));

    //
    // If we are not allowed to run the defragger, don't.
    //

    if (!PfSvAllowedToRunDefragger(TRUE)) {
        ErrorCode = ERROR_ACCESS_DENIED;
        goto cleanup;
    }
    
    //
    // Get current process ID as string.
    //

    ProcessId = GetCurrentProcessId();
    swprintf(ProcessIdString, L"-p %x ", ProcessId);

    //
    // Create a stop event and convert handle value to string.
    //

    StopDefraggerEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!StopDefraggerEvent) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    swprintf(StopEventString, L"-s %p ", StopDefraggerEvent);

    //
    // Get path to system32 directory.
    //

    SystemDirLength = GetSystemDirectory(SystemDir, MAX_PATH);
    
    if (!SystemDirLength) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (SystemDirLength >= MAX_PATH) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    SystemDir[MAX_PATH - 1] = 0;

    //
    // Determine which drive we will be defragmenting.
    //

    if (ForLayoutOptimization) {

        //
        // Get system drive from system directory path.
        //
        
        SystemDrive[0] = SystemDir[0];
        SystemDrive[1] = SystemDir[1];
        SystemDrive[2] = 0;

        DriveToDefrag = SystemDrive;

    } else {

        DriveToDefrag = TargetDrive;
    }

    //
    // Build the command line to launch the process. All strings we put 
    // together include a trailing space.
    //

    CommandLineLength = 0;
    CommandLineLength += wcslen(L"\"");  // protect against spaces in SystemDir.
    CommandLineLength += wcslen(SystemDir);
    CommandLineLength += wcslen(DefragCommand); 
    CommandLineLength += wcslen(ProcessIdString);
    CommandLineLength += wcslen(StopEventString);

    if (ForLayoutOptimization) {
        CommandLineLength += wcslen(DoLayoutParameter);
    } 

    CommandLineLength += wcslen(DriveToDefrag);

    CommandLine = PFSVC_ALLOC((CommandLineLength + 1) * sizeof(WCHAR));

    if (!CommandLine) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    wcscpy(CommandLine, L"\"");
    wcscat(CommandLine, SystemDir);
    wcscat(CommandLine, DefragCommand);
    wcscat(CommandLine, ProcessIdString);
    wcscat(CommandLine, StopEventString);

    if (ForLayoutOptimization) {
        wcscat(CommandLine, DoLayoutParameter);
    }
    
    wcscat(CommandLine, DriveToDefrag);

    //
    // We may have to launch the defragger multiple times for it to make
    // or determine the space in which to layout files etc.
    //

    for (RetryCount = 0; RetryCount < 20; RetryCount++) {

        PFSVC_ASSERT(!ProcessHandle);

        //
        // Create the process.
        //
        
        // FUTURE-2002/03/29-ScottMa -- CreateProcess is safer if you supply
        //   the first parameter.  Since the full command-line was built up
        //   by this function, the first parameter is readily available.

        if (!CreateProcess (NULL,
                            CommandLine,
                            NULL,
                            NULL,
                            FALSE,
                            CREATE_NO_WINDOW,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInfo)) {

            ErrorCode = GetLastError();
            goto cleanup;
        }

        //
        // Close handle to the thread, save the process handle.
        //

        CloseHandle(ProcessInfo.hThread);
        ProcessHandle = ProcessInfo.hProcess;

        //
        // Setup the events we will wait on.
        //

        NumEvents = 0;
        Events[NumEvents] = ProcessHandle;
        NumEvents++;
        Events[NumEvents] = PfSvcGlobals.TerminateServiceEvent;
        NumEvents ++;

        if (Task) {
            Events[NumEvents] = Task->StartedUnregisteringEvent;
            NumEvents++;
            Events[NumEvents] = Task->StopEvent;
            NumEvents++;      
        }
        
        PFSVC_ASSERT(NumEvents <= MaxEvents);

        DefraggerExitOnItsOwn = FALSE;

        WaitResult = WaitForMultipleObjects(NumEvents,
                                            Events,
                                            FALSE,
                                            INFINITE);

        switch(WaitResult) {

        case WAIT_OBJECT_0:

            //
            // The defragger process exit.
            //

            DefraggerExitOnItsOwn = TRUE;

            break;

        case WAIT_OBJECT_0 + 1:

            //
            // The service is exiting, Signal the defragger to exit, but don't
            // wait for it.
            //

            SetEvent(StopDefraggerEvent);

            ErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
            goto cleanup;

            break;
            
        case WAIT_OBJECT_0 + 2:
        case WAIT_OBJECT_0 + 3:

            //
            // We would have specified these wait events only if a Task was
            // specified.
            //

            PFSVC_ASSERT(Task);

            //
            // Signal the defragger process to exit and wait for it to exit.
            //

            SetEvent(StopDefraggerEvent);

            NumEvents = 0;
            Events[NumEvents] = ProcessHandle;
            NumEvents++;
            Events[NumEvents] = PfSvcGlobals.TerminateServiceEvent;
            NumEvents++;

            WaitResult = WaitForMultipleObjects(NumEvents,
                                                Events,
                                                FALSE,
                                                INFINITE);

            if (WaitResult == WAIT_OBJECT_0) {

                //
                // Defragger exit, 
                //

                break;

            } else if (WaitResult == WAIT_OBJECT_0 + 1) {

                //
                // Service exiting, cannot wait for the defragger anymore.
                //

                ErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
                goto cleanup;

            } else {

                ErrorCode = GetLastError();
                goto cleanup;
            }

            break;

        default:

            ErrorCode = GetLastError();
            goto cleanup;
        }

        //
        // If we came here, the defragger exit. Determine its exit code and 
        // propagate it. If the defragger exit because we told it to, this should
        // be ENG_USER_CANCELLED.
        //

        if (!GetExitCodeProcess(ProcessHandle, &ExitCode)) {
            ErrorCode = GetLastError();
            goto cleanup;
        }

        //
        // If the defragger needs us to launch it again do so.
        //

        if (DefraggerExitOnItsOwn && (ExitCode == 9)) { // ENGERR_RETRY

            //
            // Reset the event that tells the defragger to stop.
            //

            ResetEvent(StopDefraggerEvent);

            //
            // Close to handle to the old defragger process.
            //

            CloseHandle(ProcessHandle);
            ProcessHandle = NULL;

            //
            // Setup the error code to return. If we've already retried 
            // too many times, this is the error that we'll return when
            // we end the retry loop.
            //

            ErrorCode = ERROR_REQUEST_ABORTED;
            
            continue;
        }

        //
        // If the defragger is crashing, note it so we don't attempt to run
        // it again. When the defragger crashes, its exit code is an NT status
        // code that will be error, e.g. 0xC0000005 for AV etc.
        //

        if (NT_ERROR(ExitCode)) {
            PfSvcGlobals.DefraggerErrorCode = ExitCode;
        }

        //
        // Translate the return value of the defragger to a Win32 error code.
        // These codes are defined in base\fs\utils\dfrg\inc\dfrgcmn.h.
        // I wish they were in a file I could include.
        //

        switch(ExitCode) {

        case 0: ErrorCode = ERROR_SUCCESS; break;               // ENG_NOERR
        case 1: ErrorCode = ERROR_RETRY; break;                 // ENG_USER_CANCELLED
        case 2: ErrorCode = ERROR_INVALID_PARAMETER; break;     // ENGERR_BAD_PARAM

        //
        // If the defragger's children processes AV / die, it will return 
        // ENGERR_UNKNOWN == 3.
        //

        case 3: 

            ErrorCode = ERROR_INVALID_FUNCTION;
            PfSvcGlobals.DefraggerErrorCode = STATUS_UNSUCCESSFUL;
            break;

        case 4: ErrorCode = ERROR_NOT_ENOUGH_MEMORY; break;     // ENGERR_NOMEM
        case 7: ErrorCode = ERROR_DISK_FULL; break;             // ENGERR_LOW_FREESPACE

        //
        // There is no good translation for the other exit codes or we just
        // don't understand them.
        //
        
        default: ErrorCode = ERROR_INVALID_FUNCTION;
        }

        //
        // The defragger returned success or an error other than retry. 
        //

        break;
    }

    //
    // Fall through with error code.
    //
    
 cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: LaunchDefragger(%p)=%x\n",Task,ErrorCode));

    if (CommandLine) {
        PFSVC_FREE(CommandLine);
    }

    if (StopDefraggerEvent) {
        CloseHandle(StopDefraggerEvent);
    }

    if (ProcessHandle) {
        CloseHandle(ProcessHandle);
    }

    return ErrorCode; 
}


DWORD
PfSvGetBuildDefragStatusValueName (
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR *ValueName
    )

/*++

Routine Description:

    This routine translates OsVersion to a string allocated with 
    PFSVC_ALLOC. The returned string should be freed by caller.
            
Arguments:

    OsVersion - Version info to translate to string.

    ValueName - Pointer to output string is returned here.

Return Value:

    Win32 error code.

--*/

{
    PWCHAR BuildName;
    PWCHAR BuildNameFormat;
    ULONG BuildNameMaxLength;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    BuildName = NULL;
    BuildNameFormat = L"%x.%x.%x.%hx.%hx.%hx.%hx_DefragStatus";
    BuildNameMaxLength = 80;

    //
    // Allocate the string.
    //

    BuildName = PFSVC_ALLOC((BuildNameMaxLength + 1) * sizeof(WCHAR));

    if (!BuildName) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    _snwprintf(BuildName, 
               BuildNameMaxLength, 
               BuildNameFormat,
               OsVersion->dwBuildNumber,
               OsVersion->dwMajorVersion,
               OsVersion->dwMinorVersion,
               (WORD) OsVersion->wSuiteMask,
               (WORD) OsVersion->wProductType,
               (WORD) OsVersion->wServicePackMajor,
               (WORD) OsVersion->wServicePackMinor);

    //
    // Make sure the string is terminated.
    //

    BuildName[BuildNameMaxLength] = 0;

    *ValueName = BuildName;
    ErrorCode = ERROR_SUCCESS;

cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        if (BuildName) {
            PFSVC_FREE(BuildName);
        }
    }

    DBGPR((PFID,PFTRC,"PFSVC: GetBuildName(%.80ws)=%x\n",BuildName,ErrorCode));

    return ErrorCode;
}

DWORD
PfSvSetBuildDefragStatus(
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR BuildDefragStatus,
    ULONG Size
    )

/*++

Routine Description:

    This routine will set the information on which drives have been 
    defragmented and such for the specified build (OsVersion).

    Defrag status is in REG_MULTI_SZ format. Each element is a drive
    path that has been defragged for this build. If all drives were
    defragged, than the first element is PFSVC_DEFRAG_DRIVES_DONE.
            
Arguments:

    OsVersion - Build & SP we are setting defrag status for.

    BuildDefragStatus - A string that describes the status, which is a 
      comma delimited list of drives defragged.

    Size - Size in bytes of the data that has to be saved to the registry.

Return Value:

    Win32 error code.

--*/

{
    PWCHAR ValueName;
    DWORD ErrorCode;
    
    //
    // Initialize locals.
    //

    ValueName = NULL;

    //
    // Build the value name from OS version info.
    //

    ErrorCode = PfSvGetBuildDefragStatusValueName(OsVersion, &ValueName);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = RegSetValueEx(PfSvcGlobals.ServiceDataKey,
                              ValueName,
                              0,
                              REG_MULTI_SZ,
                              (PVOID) BuildDefragStatus,
                              Size);

    //
    // Fall through with error code.
    //
    
cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: SetBuildDefragStatus(%ws)=%x\n",BuildDefragStatus,ErrorCode));

    if (ValueName) {
        PFSVC_FREE(ValueName);
    }

    return ErrorCode;    
}

DWORD
PfSvGetBuildDefragStatus(
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR *BuildDefragStatus,
    PULONG ReturnSize
    )

/*++

Routine Description:

    This routine will get the information on which drives have been 
    defragmented and such for the specified build (OsVersion).

    Defrag status is in REG_MULTI_SZ format. Each element is a drive
    path that has been defragged for this build. If all drives were
    defragged, than the first element is PFSVC_DEFRAG_DRIVES_DONE.
            
Arguments:

    OsVersion - Build & SP we are querying defrag status for.

    BuildDefragStatus - Output for defrag status. If the function returns 
      success this should be freed with a call to PFSVC_FREE().

    ReturnSize - Size of the returned value in bytes.

Return Value:

    Win32 error code.

--*/

{
    PWCHAR ValueBuffer;
    PWCHAR ValueName;
    DWORD ErrorCode;
    DWORD RegValueType;
    ULONG ValueBufferSize;
    ULONG Size;
    ULONG NumTries;
    ULONG DefaultValueSize;
    BOOLEAN InvalidValue;

    //
    // Initialize locals.
    //

    ValueName = NULL;
    ValueBuffer = NULL;
    ValueBufferSize = 0;
    InvalidValue = FALSE;

    //
    // Build the value name from OS version info.
    //

    ErrorCode = PfSvGetBuildDefragStatusValueName(OsVersion, &ValueName);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Try to allocate a right size buffer to read this value into.
    //

    NumTries = 0;
    
    do {

        Size = ValueBufferSize;

        ErrorCode = RegQueryValueEx(PfSvcGlobals.ServiceDataKey,
                                    ValueName,
                                    NULL,
                                    &RegValueType,
                                    (PVOID) ValueBuffer,
                                    &Size);

        //
        // API returns SUCCESS with required size in Size if ValueBuffer
        // is NULL. We have to special case that out.
        //

        if (ValueBuffer && ErrorCode == ERROR_SUCCESS) {

            //
            // We got it. Check the type. 
            //

            if (RegValueType != REG_MULTI_SZ) {

                //
                // Return default value.
                //

                InvalidValue = TRUE;

            } else {

                InvalidValue = FALSE;

                *ReturnSize = Size;
            }

            break;
        }

        if (ErrorCode ==  ERROR_FILE_NOT_FOUND) {

            //
            // The value does not exist. Return default value.
            //

            InvalidValue = TRUE;
            
            break;
        }

        if (ErrorCode != ERROR_MORE_DATA &&
            !(ErrorCode == ERROR_SUCCESS && !ValueBuffer)) {

            //
            // This is a real error.
            //

            goto cleanup;
        }

        //
        // Allocate a bigger buffer and try again.
        //

        PFSVC_ASSERT(ValueBufferSize < Size);

        if (ValueBuffer) {
            PFSVC_ASSERT(ValueBufferSize);
            PFSVC_FREE(ValueBuffer);
            ValueBufferSize = 0;           
        }

        ValueBuffer = PFSVC_ALLOC(Size);

        if (!ValueBuffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;            
        }

        ValueBufferSize = Size;

        NumTries++;

    } while (NumTries < 10);

    //
    // If we did not get a valid value from the registry, make up a default
    // one: empty string.
    //

    if (InvalidValue) {

        DefaultValueSize = sizeof(WCHAR);

        if (ValueBufferSize < DefaultValueSize) {

            if (ValueBuffer) {
                PFSVC_ASSERT(ValueBufferSize);
                PFSVC_FREE(ValueBuffer);
                ValueBufferSize = 0;            
            }

            ValueBuffer = PFSVC_ALLOC(DefaultValueSize);

            if (!ValueBuffer) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            ValueBufferSize = DefaultValueSize;
        }

        ValueBuffer[0] = 0;

        *ReturnSize = DefaultValueSize;
    }

    //
    // We should get here only if we got a value in value buffer.
    //

    PFSVC_ASSERT(ValueBuffer && ValueBufferSize);

    *BuildDefragStatus = ValueBuffer;

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: GetBuildDefragStatus(%.80ws)=%x\n",*BuildDefragStatus,ErrorCode));

    if (ErrorCode != ERROR_SUCCESS) {

        if (ValueBuffer) {
            PFSVC_ASSERT(ValueBufferSize);
            PFSVC_FREE(ValueBuffer);
        }
    }

    if (ValueName) {
        PFSVC_FREE(ValueName);
    }

    return ErrorCode;
}

DWORD
PfSvDefragDisks(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    If we have not defragged all disks after a setup/upgrade, do so.
    
Arguments:

    Task - If specified the function will check Task every once in a
      while to see if it should exit with ERROR_RETRY.

Return Value:

    Win32 error code.

--*/

{
    PNTPATH_TRANSLATION_LIST VolumeList;
    PNTPATH_TRANSLATION_ENTRY VolumeEntry;
    PWCHAR DefraggedVolumeName;
    PWCHAR BuildDefragStatus;
    PWCHAR NewBuildDefragStatus;
    PWCHAR FoundPosition;
    PLIST_ENTRY NextEntry;
    ULONG NewBuildDefragStatusLength;
    ULONG BuildDefragStatusSize;
    ULONG NewBuildDefragStatusSize;
    NTSTATUS Status;
    DWORD ErrorCode;
    BOOLEAN AlreadyDefragged;

    //
    // Initialize locals.
    //

    NewBuildDefragStatus = NULL;
    NewBuildDefragStatusSize = 0;
    BuildDefragStatus = NULL;
    BuildDefragStatusSize = 0;
    VolumeList = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: DefragDisks(%p)\n",Task));

    //
    // Determine defrag status for the current build.
    //

    ErrorCode = PfSvGetBuildDefragStatus(&PfSvcGlobals.OsVersion, 
                                         &BuildDefragStatus, 
                                         &BuildDefragStatusSize);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Check if we are already done for this build.
    //
    
    if (!_wcsicmp(BuildDefragStatus, PFSVC_DEFRAG_DRIVES_DONE)) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Build a list of volumes that are mounted.
    //

    ErrorCode = PfSvBuildNtPathTranslationList(&VolumeList);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Walk through the volumes defragging the ones we have not yet
    // defragged after setup.
    //

    for (NextEntry = VolumeList->Flink;
         NextEntry != VolumeList;
         NextEntry = NextEntry->Flink) {

        VolumeEntry = CONTAINING_RECORD(NextEntry,
                                        NTPATH_TRANSLATION_ENTRY,
                                        Link);

        //
        // Skip volumes that are not fixed disks.
        //

        if (DRIVE_FIXED != GetDriveType(VolumeEntry->VolumeName)) {
            continue;
        }

        //
        // Have we already defragged this volume?
        //

        AlreadyDefragged = FALSE;

        for (DefraggedVolumeName = BuildDefragStatus;
             DefraggedVolumeName[0] != 0;
             DefraggedVolumeName += wcslen(DefraggedVolumeName) + 1) {

            PFSVC_ASSERT((PCHAR) DefraggedVolumeName < (PCHAR) BuildDefragStatus + BuildDefragStatusSize);

            if (!_wcsicmp(DefraggedVolumeName, VolumeEntry->DosPrefix)) {
                AlreadyDefragged = TRUE;
                break;
            }
        }

        if (AlreadyDefragged) {
            continue;
        }

        //
        // Launch the defragger to defrag this volume.
        //

        ErrorCode = PfSvLaunchDefragger(Task, FALSE, VolumeEntry->DosPrefix);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Note that we have defragged this volume.
        //

        NewBuildDefragStatusSize = BuildDefragStatusSize;
        NewBuildDefragStatusSize += (VolumeEntry->DosPrefixLength + 1) * sizeof(WCHAR);

        NewBuildDefragStatus = PFSVC_ALLOC(NewBuildDefragStatusSize);

        if (!NewBuildDefragStatus) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        //
        // Start with new defragged drive path.
        //

        wcscpy(NewBuildDefragStatus, VolumeEntry->DosPrefix);

        //
        // Append original status.
        //

        RtlCopyMemory(NewBuildDefragStatus + VolumeEntry->DosPrefixLength + 1, 
                      BuildDefragStatus, 
                      BuildDefragStatusSize);

        //
        // The last character and the one before that should be NUL.
        //

        PFSVC_ASSERT(NewBuildDefragStatus[NewBuildDefragStatusSize/sizeof(WCHAR)-1] == 0);
        PFSVC_ASSERT(NewBuildDefragStatus[NewBuildDefragStatusSize/sizeof(WCHAR)-2] == 0);

        //
        // Save the new status.
        //

        ErrorCode = PfSvSetBuildDefragStatus(&PfSvcGlobals.OsVersion,
                                             NewBuildDefragStatus,
                                             NewBuildDefragStatusSize);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Update the old variable.
        //

        PFSVC_ASSERT(BuildDefragStatus && BuildDefragStatusSize);
        PFSVC_FREE(BuildDefragStatus);

        BuildDefragStatus = NewBuildDefragStatus;
        NewBuildDefragStatus = NULL;
        BuildDefragStatusSize = NewBuildDefragStatusSize;
        NewBuildDefragStatusSize = 0;

        //
        // Continue to check & defrag other volumes.
        //
    }

    //
    // If we came here, then we have successfully defragged all the drives 
    // we had to. Set the status in the registry. Note that defrag status
    // value has to end with an additional NUL because it is REG_MULTI_SZ.
    //

    NewBuildDefragStatusSize = (wcslen(PFSVC_DEFRAG_DRIVES_DONE) + 1) * sizeof(WCHAR);
    NewBuildDefragStatusSize += sizeof(WCHAR);

    NewBuildDefragStatus = PFSVC_ALLOC(NewBuildDefragStatusSize);

    if (!NewBuildDefragStatus) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    wcscpy(NewBuildDefragStatus, PFSVC_DEFRAG_DRIVES_DONE);
    NewBuildDefragStatus[(NewBuildDefragStatusSize / sizeof(WCHAR)) - 1] = 0;

    ErrorCode = PfSvSetBuildDefragStatus(&PfSvcGlobals.OsVersion,
                                         NewBuildDefragStatus,
                                         NewBuildDefragStatusSize);

    //
    // Fall through with error code.
    //

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: DefragDisks(%p)=%x\n",Task,ErrorCode));

    if (BuildDefragStatus) {

        //
        // We should have NULL'ed NewBuildDefragStatus, otherwise we will
        // try to free the same memory twice.
        //
        
        PFSVC_ASSERT(BuildDefragStatus != NewBuildDefragStatus);

        PFSVC_ASSERT(BuildDefragStatusSize);
        PFSVC_FREE(BuildDefragStatus);
    }

    if (NewBuildDefragStatus) {
        PFSVC_ASSERT(NewBuildDefragStatusSize);
        PFSVC_FREE(NewBuildDefragStatus);
    }

    if (VolumeList) {
        PfSvFreeNtPathTranslationList(VolumeList);
    }

    return ErrorCode;
}

//
// Routines to cleanup old scenario files in the prefetch directory.
//

DWORD
PfSvCleanupPrefetchDirectory(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    If we have too many scenario files in the prefetch directory, discard the 
    ones that are not as useful to make room for new files.
    
Arguments:

    Task - If specified the function will check Task every once in a
      while to see if it should exit with ERROR_RETRY.

Return Value:

    Win32 error code.

--*/

{
    PPFSVC_SCENARIO_AGE_INFO Scenarios;
    PFSVC_SCENARIO_FILE_CURSOR FileCursor;
    PPF_SCENARIO_HEADER Scenario;
    ULONG NumPrefetchFiles;
    ULONG AllocationSize;
    ULONG NumScenarios;
    ULONG ScenarioIdx;
    ULONG PrefetchFileIdx;
    ULONG FileSize;
    ULONG FailedCheck;
    ULONG MaxRemainingScenarioFiles;
    ULONG NumLaunches;
    ULONG HoursSinceLastLaunch;
    FILETIME CurrentTime;
    ULARGE_INTEGER CurrentTimeLI;
    ULARGE_INTEGER LastLaunchTimeLI;
    DWORD ErrorCode;
    BOOLEAN AcquiredLock;

    //
    // Initialize locals.
    //

    AcquiredLock = FALSE;
    NumScenarios = 0;
    Scenarios = NULL;
    Scenario = NULL;
    GetSystemTimeAsFileTime(&CurrentTime);
    PfSvInitializeScenarioFileCursor(&FileCursor);
    CurrentTimeLI.LowPart = CurrentTime.dwLowDateTime;
    CurrentTimeLI.HighPart = CurrentTime.dwHighDateTime;

    DBGPR((PFID,PFTRC,"PFSVC: CleanupPrefetchDirectory(%p)\n",Task));

    //
    // Once we are done cleaning up, we should not have more than this many
    // prefetch files remaining.
    //

    MaxRemainingScenarioFiles = PFSVC_MAX_PREFETCH_FILES / 4;

    PFSVC_ACQUIRE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredLock = TRUE;

    //
    // Start the file cursor.
    //

    ErrorCode = PfSvStartScenarioFileCursor(&FileCursor, PfSvcGlobals.PrefetchRoot);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Count the number of files in the directory.
    //

    ErrorCode = PfSvCountFilesInDirectory(PfSvcGlobals.PrefetchRoot,
                                          L"*." PF_PREFETCH_FILE_EXTENSION,
                                          &NumPrefetchFiles);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
    
    PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    AcquiredLock = FALSE;   

    //
    // Allocate an array that we will fill in with information from
    // scenario files to determine which ones need to be discarded.
    //

    AllocationSize = NumPrefetchFiles * sizeof(PFSVC_SCENARIO_AGE_INFO);

    Scenarios = PFSVC_ALLOC(AllocationSize);

    if (!Scenarios) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Initialize the scenarios array so we know what to clean up.
    //

    RtlZeroMemory(Scenarios, AllocationSize);
    NumScenarios = 0;

    //
    // Enumerate the scenario files:
    //

    ScenarioIdx = 0;
    PrefetchFileIdx = 0;

    do {

        //
        // Should we continue to run?
        //

        ErrorCode = PfSvContinueRunningTask(Task);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Get the file info for the next scenario file.
        //

        ErrorCode = PfSvGetNextScenarioFileInfo(&FileCursor);

        if (ErrorCode == ERROR_NO_MORE_FILES) {
            break;
        }

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // Is the file name longer than what a valid prefetch file can be max?
        //

        if (FileCursor.FileNameLength > PF_MAX_SCENARIO_FILE_NAME) {

            //
            // Bogus file. Remove it.
            //

            DeleteFile(FileCursor.FilePath);
            goto NextPrefetchFile;
        }

        //
        // Map the file.
        //

        ErrorCode = PfSvGetViewOfFile(FileCursor.FilePath, 
                                      &Scenario,
                                      &FileSize);

        if (ErrorCode != ERROR_SUCCESS) {
            goto NextPrefetchFile;
        }

        //
        // Verify the scenario file.
        //

        if (!PfSvVerifyScenarioBuffer(Scenario, FileSize, &FailedCheck) ||
            Scenario->ServiceVersion != PFSVC_SERVICE_VERSION) {
            DeleteFile(FileCursor.FilePath);
            goto NextPrefetchFile;
        }

        //
        // Skip boot scenario, we won't discard it.
        //

        if (Scenario->ScenarioType == PfSystemBootScenarioType) {
            goto NextPrefetchFile;
        }

        //
        // Determine the last time scenario was updated. I assume this 
        // corresponds to the last time scenario was launched...
        //

        LastLaunchTimeLI.LowPart = FileCursor.FileData.ftLastWriteTime.dwLowDateTime;
        LastLaunchTimeLI.HighPart = FileCursor.FileData.ftLastWriteTime.dwHighDateTime;

        HoursSinceLastLaunch = (ULONG) ((CurrentTimeLI.QuadPart - LastLaunchTimeLI.QuadPart) / 
                                        PFSVC_NUM_100NS_IN_AN_HOUR);       

        //
        // Calculate weight: bigger weight means scenario file won't get
        // discarded. We calculate the weight by dividing the total number
        // times a scenario was launched by how long has it been since the last
        // launch of the scenario.
        //       

        NumLaunches = Scenario->NumLaunches;

        //
        // For the calculations below limit how large NumLaunches can be, so
        // values does not overflow.
        //

        if (NumLaunches > 1 * 1024 * 1024) {
            NumLaunches = 1 * 1024 * 1024;
        }

        //
        // Since we are going divide by number of hours (e.g. 7*24 for a program
        // launched a week ago) multiplying the number of launches with a number 
        // allows us to give a weight other than 0 to scenarios launched long ago.
        //
        
        Scenarios[ScenarioIdx].Weight = NumLaunches * 256;

        if (HoursSinceLastLaunch) {

             Scenarios[ScenarioIdx].Weight /= HoursSinceLastLaunch;
        }

        //
        // Copy over the file path.
        //

        AllocationSize = (FileCursor.FilePathLength + 1) * sizeof(WCHAR);

        Scenarios[ScenarioIdx].FilePath = PFSVC_ALLOC(AllocationSize);

        if (!Scenarios[ScenarioIdx].FilePath) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        wcscpy(Scenarios[ScenarioIdx].FilePath, FileCursor.FilePath);                    

        ScenarioIdx++;

    NextPrefetchFile:

        PrefetchFileIdx++;

        if (Scenario) {
            UnmapViewOfFile(Scenario);
            Scenario = NULL;
        }

    } while (PrefetchFileIdx < NumPrefetchFiles);

    //
    // If we do not have too many scenario files, we don't have to do anything.
    //

    NumScenarios = ScenarioIdx;

    if (NumScenarios < MaxRemainingScenarioFiles) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Sort the age information.
    //

    qsort(Scenarios, 
          NumScenarios, 
          sizeof(PFSVC_SCENARIO_AGE_INFO),
          PfSvCompareScenarioAgeInfo);

    //
    // Delete the files with the smallest weight until we reach our goal.
    //

    for (ScenarioIdx = 0; 
         (ScenarioIdx < NumScenarios) && 
            ((NumScenarios - ScenarioIdx) > MaxRemainingScenarioFiles);
         ScenarioIdx++) {

        //
        // Should we continue to run?
        //

        ErrorCode = PfSvContinueRunningTask(Task);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }       

        DeleteFile(Scenarios[ScenarioIdx].FilePath);
    }

    //
    // Count the files in the directory now and update the global.
    //

    ErrorCode = PfSvCountFilesInDirectory(PfSvcGlobals.PrefetchRoot,
                                          L"*." PF_PREFETCH_FILE_EXTENSION,
                                          &NumPrefetchFiles);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Note that global NumPrefetchFiles is not protected, so the new value
    // we are setting it to may be overwritten with an older value. It should
    // not be a big problem though, maybe resulting in this task being requeued.
    //

    PfSvcGlobals.NumPrefetchFiles = NumPrefetchFiles;

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: CleanupPrefetchDirectory(%p)=%x\n",Task,ErrorCode));

    if (AcquiredLock) {
        PFSVC_RELEASE_LOCK(PfSvcGlobals.PrefetchRootLock);
    }

    PfSvCleanupScenarioFileCursor(&FileCursor);

    if (Scenarios) {

        for (ScenarioIdx = 0; ScenarioIdx < NumScenarios; ScenarioIdx++) {
            if (Scenarios[ScenarioIdx].FilePath) {
                PFSVC_FREE(Scenarios[ScenarioIdx].FilePath);
            }
        }

        PFSVC_FREE(Scenarios);
    }

    if (Scenario) {
        UnmapViewOfFile(Scenario);
    }

    return ErrorCode;
}

int
__cdecl 
PfSvCompareScenarioAgeInfo(
    const void *Param1,
    const void *Param2
    )

/*++

Routine Description:

    Qsort comparison function for PFSVC_SCENARIO_AGE_INFO structure.
    
Arguments:

    Param1, Param2 - pointer to PFSVC_SCENARIO_AGE_INFO structures

Return Value:

    Qsort comparison function return value.

--*/


{
    PFSVC_SCENARIO_AGE_INFO *Elem1;
    PFSVC_SCENARIO_AGE_INFO *Elem2;

    Elem1 = (PVOID) Param1;
    Elem2 = (PVOID) Param2;

    //
    // Compare precalculated weights.
    //

    if (Elem1->Weight > Elem2->Weight) {

        return 1;

    } else if (Elem1->Weight < Elem2->Weight) {

        return -1;

    } else {

        return 0;
    }
}

//
// Routines to enumerate scenario files.
//

VOID
PfSvInitializeScenarioFileCursor (
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    )

/*++

Routine Description:

    Initializes the cursor structure so it can be safely cleaned up.
    
Arguments:

    FileCursor - Pointer to structure.

Return Value:

    None.

--*/

{
    FileCursor->FilePath = NULL;
    FileCursor->FileNameLength = 0;
    FileCursor->FilePathLength = 0;  
    FileCursor->CurrentFileIdx = 0;

    FileCursor->PrefetchRoot = NULL;
    FileCursor->FindFileHandle = INVALID_HANDLE_VALUE;

    return;
}

VOID
PfSvCleanupScenarioFileCursor(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    )

/*++

Routine Description:

    Cleans up an initialized and possibly started cursor structure.
    
Arguments:

    FileCursor - Pointer to structure.

Return Value:

    None.

--*/

{
    if (FileCursor->FilePath) {
        PFSVC_FREE(FileCursor->FilePath);
    }

    if (FileCursor->PrefetchRoot) {
        PFSVC_FREE(FileCursor->PrefetchRoot);
    }

    if (FileCursor->FindFileHandle != INVALID_HANDLE_VALUE) {
        FindClose(FileCursor->FindFileHandle);
    }

    return;
}

DWORD
PfSvStartScenarioFileCursor(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor,
    WCHAR *PrefetchRoot
    )

/*++

Routine Description:

    After making this call on an initialized FileCursor, you can start
    enumerating the scenario files in that directory by calling the get
    next file function.

    You have to call the get next file function after starting the cursor
    to get the information on the first file.

    If this function fails, you should call cleanup on the FileCursor 
    structure and reinitialize it before trying to start the cursor again.
    
Arguments:

    FileCursor - Pointer to initialized cursor structure.

    PrefetchRoot - Directory path in which we'll look for prefetch
      files.

Return Value:

    Win32 error code.

--*/

{
    WCHAR *PrefetchFileSearchPattern;
    WCHAR *PrefetchFileSearchPath;
    ULONG PrefetchRootLength;
    ULONG PrefetchFileSearchPathLength;
    ULONG FileNameMaxLength;
    ULONG FilePathMaxLength;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    PrefetchRootLength = wcslen(PrefetchRoot);
    PrefetchFileSearchPattern = L"\\*." PF_PREFETCH_FILE_EXTENSION;
    PrefetchFileSearchPath = NULL;

    //
    // The file cursor should have been initialized.
    //

    PFSVC_ASSERT(!FileCursor->CurrentFileIdx);
    PFSVC_ASSERT(!FileCursor->PrefetchRoot);
    PFSVC_ASSERT(FileCursor->FindFileHandle == INVALID_HANDLE_VALUE);

    //
    // Copy the prefetch root directory path.
    //

    FileCursor->PrefetchRoot = PFSVC_ALLOC((PrefetchRootLength + 1) * sizeof(WCHAR));

    if (!FileCursor->PrefetchRoot) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    wcscpy(FileCursor->PrefetchRoot, PrefetchRoot);
    FileCursor->PrefetchRootLength = PrefetchRootLength;

    //
    // Build the path we will pass in to enumerate the prefetch files.
    //

    PrefetchFileSearchPathLength = PrefetchRootLength;
    PrefetchFileSearchPathLength += wcslen(PrefetchFileSearchPattern);

    PrefetchFileSearchPath = PFSVC_ALLOC((PrefetchFileSearchPathLength + 1) * sizeof(WCHAR));

    if (!PrefetchFileSearchPath) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    wcscpy(PrefetchFileSearchPath, PrefetchRoot);
    wcscat(PrefetchFileSearchPath, PrefetchFileSearchPattern);

    //
    // Allocate the string we will use to build the full path of the 
    // prefetch files. We can use it for prefetch files with names of 
    // max MAX_PATH. This works because that is the max file name that
    // can fit into WIN32_FIND_DATA structure.
    //

    FileNameMaxLength = MAX_PATH;

    FilePathMaxLength = PrefetchRootLength;
    FilePathMaxLength += wcslen(L"\\");
    FilePathMaxLength += FileNameMaxLength;

    FileCursor->FilePath = PFSVC_ALLOC((FilePathMaxLength + 1) * sizeof(WCHAR));

    if (!FileCursor->FilePath) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Initialize the first part of the file path and note where we will
    // start copying file names from.
    //

    wcscpy(FileCursor->FilePath, PrefetchRoot);
    wcscat(FileCursor->FilePath, L"\\");
    FileCursor->FileNameStart = PrefetchRootLength + 1;

    //
    // Start enumerating the files. Note that this puts the data for the
    // first file into FileData member.
    //

    FileCursor->FindFileHandle = FindFirstFile(PrefetchFileSearchPath, 
                                               &FileCursor->FileData);

    if (FileCursor->FindFileHandle == INVALID_HANDLE_VALUE) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: StartFileCursor(%p,%ws)=%x\n",FileCursor,PrefetchRoot,ErrorCode));

    if (PrefetchFileSearchPath) {
        PFSVC_FREE(PrefetchFileSearchPath);
    }

    return ErrorCode;    
}

DWORD
PfSvGetNextScenarioFileInfo(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    )

/*++

Routine Description:

    Fills in public fields of the FileCursor with information on the next
    scenario file.

    You have to call the get next file function after starting the cursor
    to get the information on the first file.

    Files with *names* longer than MAX_PATH will be skipped because it
    is not feasible to handle these with Win32 API.
    
Arguments:

    FileCursor - Pointer to started cursor structure.

Return Value:

    ERROR_NO_MORE_FILES - No more files to enumerate.

    Win32 error code.

--*/

{
    DWORD ErrorCode;

    //
    // File cursor should have been started.
    //

    PFSVC_ASSERT(FileCursor->PrefetchRoot);
    PFSVC_ASSERT(FileCursor->FindFileHandle != INVALID_HANDLE_VALUE);

    //
    // If this it the first file, the FileData for it was already set when
    // we started the cursor. Otherwise call FindNextFile.
    //

    if (FileCursor->CurrentFileIdx != 0) {
        if (!FindNextFile(FileCursor->FindFileHandle, &FileCursor->FileData)) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    FileCursor->FileNameLength = wcslen(FileCursor->FileData.cFileName);

    //
    // We allocated a file path to hold MAX_PATH file name in addition to the
    // directory path. FileData.cFileName is MAX_PATH sized.
    //

    PFSVC_ASSERT(FileCursor->FileNameLength < MAX_PATH);

    if (FileCursor->FileNameLength >= MAX_PATH) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Copy the file name.
    //

    wcscpy(FileCursor->FilePath + FileCursor->FileNameStart, 
           FileCursor->FileData.cFileName);

    FileCursor->FilePathLength = FileCursor->FileNameStart + FileCursor->FileNameLength;

    FileCursor->CurrentFileIdx++;

    ErrorCode = ERROR_SUCCESS;

cleanup:

    DBGPR((PFID,PFTRC,"PFSVC: GetNextScenarioFile(%p)=%ws,%x\n",FileCursor,FileCursor->FileData.cFileName,ErrorCode));

    return ErrorCode;
}

//
// File I/O utility routines.
//

DWORD
PfSvGetViewOfFile(
    IN WCHAR *FilePath,
    OUT PVOID *BasePointer,
    OUT PULONG FileSize
    )

/*++

Routine Description:

    Map the all of the specified file to memory.

Arguments:

    FilePath - NUL terminated path to file to map.
    
    BasePointer - Start address of mapping will be returned here.

    FileSize - Size of the mapping/file will be returned here.

Return Value:

    Win32 error code.

--*/

{
    HANDLE InputHandle;
    HANDLE InputMappingHandle;
    DWORD ErrorCode;
    DWORD SizeL;
    DWORD SizeH;
    BOOLEAN OpenedFile;
    BOOLEAN CreatedFileMapping;

    //
    // Initialize locals.
    //

    OpenedFile = FALSE;
    CreatedFileMapping = FALSE;

    DBGPR((PFID,PFTRC,"PFSVC: GetViewOfFile(%ws)\n", FilePath));

    //
    // Note that we are opening the file exclusively. This guarantees
    // that for trace files as long as the kernel is not done writing
    // it we can't open the file, which guarantees we won't have an
    // incomplete file to worry about.
    //

    InputHandle = CreateFile(FilePath, 
                             GENERIC_READ, 
                             0,
                             NULL, 
                             OPEN_EXISTING, 
                             0, 
                             NULL);

    if (INVALID_HANDLE_VALUE == InputHandle)
    {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    OpenedFile = TRUE;

    SizeL = GetFileSize(InputHandle, &SizeH);

    if (SizeL == -1 && (GetLastError() != NO_ERROR )) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (SizeH) {
        ErrorCode = ERROR_BAD_LENGTH;
        goto cleanup;
    }

    if (FileSize) {
        *FileSize = SizeL;
    }

    InputMappingHandle = CreateFileMapping(InputHandle, 
                                           0, 
                                           PAGE_READONLY, 
                                           0,
                                           0, 
                                           NULL);

    if (NULL == InputMappingHandle)
    {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedFileMapping = TRUE;
    
    *BasePointer = MapViewOfFile(InputMappingHandle, 
                                 FILE_MAP_READ, 
                                 0, 
                                 0, 
                                 0);

    if (NULL == *BasePointer) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (OpenedFile) {
        CloseHandle(InputHandle);
    }

    if (CreatedFileMapping) {
        CloseHandle(InputMappingHandle);
    }

    DBGPR((PFID,PFTRC,"PFSVC: GetViewOfFile(%ws)=%x\n", FilePath, ErrorCode));

    return ErrorCode;
}

DWORD
PfSvWriteBuffer(
    PWCHAR FilePath,
    PVOID Buffer,
    ULONG Length
    )

/*++

Routine Description:

    This routine creats/overwrites the file at the specified path and
    writes the contents of the buffer to it.

Arguments:

    FilePath - Full path to the file.

    Buffer - Buffer to write out.

    Length - Number of bytes to write out from the buffer.

Return Value:

    Win32 error code.

--*/

{
    DWORD BytesWritten;
    HANDLE OutputHandle;
    DWORD ErrorCode;
    BOOL Result;

    //
    // Initialize locals.
    //

    OutputHandle = INVALID_HANDLE_VALUE;

    DBGPR((PFID,PFSTRC,"PFSVC: WriteBuffer(%p,%ws)\n", Buffer, FilePath));

    //
    // Open file overwriting any existing one. Don't share it so
    // nobody tries to read a half-written file.
    //

    OutputHandle = CreateFile(FilePath, 
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL, 
                              CREATE_ALWAYS, 
                              0, 
                              NULL);
    
    if (INVALID_HANDLE_VALUE == OutputHandle)
    {
        ErrorCode = GetLastError();      
        goto cleanup;
    }

    //
    // Write out the scenario.
    //

    Result = WriteFile(OutputHandle, 
                       Buffer, 
                       Length, 
                       &BytesWritten, 
                       NULL);

    if (!Result || (BytesWritten != Length)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    if (OutputHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(OutputHandle);
    }

    DBGPR((PFID,PFSTRC,"PFSVC: WriteBuffer(%p,%ws)=%x\n", Buffer, FilePath, ErrorCode));

    return ErrorCode;
}

DWORD
PfSvGetLastWriteTime (
    WCHAR *FilePath,
    PFILETIME LastWriteTime
    )

/*++

Routine Description:

    This function attempts to get the last write time for the
    specified file.

Arguments:

    FilePath - Pointer to NUL terminated path.

    LastWriteTime - Pointer to return buffer.

Return Value:

    Win32 error code.

--*/

{
    HANDLE FileHandle;
    DWORD ErrorCode;
    
    //
    // Initialize locals.
    //

    FileHandle = INVALID_HANDLE_VALUE;

    //
    // Open the file.
    //
    
    FileHandle = CreateFile(FilePath,
                            GENERIC_READ,
                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL);

    if (FileHandle == INVALID_HANDLE_VALUE) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Query last write time.
    //

    if (!GetFileTime(FileHandle, NULL, NULL, LastWriteTime)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(FileHandle);
    }

    return ErrorCode;
}

DWORD
PfSvReadLine (
    FILE *File,
    WCHAR **LineBuffer,
    ULONG *LineBufferMaxChars,
    ULONG *LineLength
    )

/*++

Routine Description:

    This function reads a line from the specified file into
    LineBuffer. If LineBuffer is NULL or not big enough, it is
    allocated or reallocated using PFSVC_ALLOC/FREE macros. It is the
    caller's reponsibility to free the returned buffer.

    Carriage return/Line feed characters are included in the returned
    LineBuffer & LineLength. Thus, a LineLength of 0 means end of file
    is hit. Returned LineBuffer is NUL terminated.

Arguments:

    File - File to read from.
    
    LineBuffer - Pointer to Pointer to buffer to read the line into.

    LineBufferMaxChars - Pointer to size of LineBuffer in characters,
      including room for NUL etc.
    
    LineLength - Pointer to length of the read line in characters
      including the carriage return/linefeed, excluding NUL.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR *NewBuffer;
    ULONG NewBufferMaxChars;
    ULONG RequiredLength;
    WCHAR *CurrentReadPosition;
    ULONG MaxCharsToRead;

    //
    // Verify parameters.
    //

    PFSVC_ASSERT(LineBuffer && LineBufferMaxChars && LineLength);

    if (*LineBufferMaxChars) {
        PFSVC_ASSERT(*LineBuffer);
    } 

    //
    // If a zero length but non NULL buffer was passed in, free it so
    // we can allocate a larger initial one.
    //

    if (((*LineBufferMaxChars) == 0) && (*LineBuffer)) {
        PFSVC_FREE(*LineBuffer);
        (*LineBuffer) = NULL;
    }

    //
    // If no buffer was passed in, allocate one. We do not want to
    // enter the read line loop with a zero length or NULL buffer.
    //

    if (!(*LineBuffer)) {

        PFSVC_ASSERT((*LineBufferMaxChars) == 0);

        (*LineBuffer) = PFSVC_ALLOC(MAX_PATH * sizeof(WCHAR));
        
        if (!(*LineBuffer)) {
            ErrorCode = ERROR_INSUFFICIENT_BUFFER;
            goto cleanup;
        }
        
        (*LineBufferMaxChars) = MAX_PATH;
    }
    
    //
    // Initialize output length and NUL terminate the output line.
    //

    (*LineLength) = 0;   
    (*(*LineBuffer)) = 0;

    do {

        //
        // Try to read a line from the file.
        //
        
        CurrentReadPosition = (*LineBuffer) + (*LineLength);
        MaxCharsToRead = (*LineBufferMaxChars) - (*LineLength);

        if (!fgetws(CurrentReadPosition, 
                    MaxCharsToRead, 
                    File)) {
            
            //
            // If we have not hit an EOF, we have hit an error.
            //
            
            if (!feof(File)) {

                ErrorCode = ERROR_READ_FAULT;
                goto cleanup;

            } else {
                
                //
                // We hit end of file. Return what we have.
                //
                
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }
        }

        //
        // Update line length.
        //

        (*LineLength) += wcslen(CurrentReadPosition);
        
        //
        // If we have read a carriage return, we are done. Check to
        // see if we had room to read anything first!
        //

        if ((*LineLength) && (*LineBuffer)[(*LineLength) - 1] == L'\n') {
            break;
        }
        
        //
        // If we read up to the end of the buffer, resize it.
        //
        
        if ((*LineLength) == (*LineBufferMaxChars) - 1) {
        
            //
            // We should not enter this loop with a zero lengthed or NULL
            // line buffer.
            //

            PFSVC_ASSERT((*LineBufferMaxChars) && (*LineBuffer));

            NewBufferMaxChars = (*LineBufferMaxChars) * 2;
            NewBuffer = PFSVC_ALLOC(NewBufferMaxChars * sizeof(WCHAR));
        
            if (!NewBuffer) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            //
            // Copy contents of the original buffer and free it.
            //

            RtlCopyMemory(NewBuffer,
                          (*LineBuffer),
                          ((*LineLength) + 1) * sizeof(WCHAR));
                
            PFSVC_FREE(*LineBuffer);

            //
            // Update line buffer.
            //

            (*LineBuffer) = NewBuffer;
            (*LineBufferMaxChars) = NewBufferMaxChars;
        }
        
        //
        // Continue reading this line and appending it to output
        // buffer.
        //

    } while (TRUE);
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    if (ErrorCode == ERROR_SUCCESS && (*LineBufferMaxChars)) {
        
        //
        // Returned length must fit into buffer.
        //

        PFSVC_ASSERT((*LineLength) < (*LineBufferMaxChars));

        //
        // Returned buffer should be NUL terminated.
        //

        PFSVC_ASSERT((*LineBuffer)[(*LineLength)] == 0);
    }

    return ErrorCode;
}

DWORD
PfSvGetFileBasicInformation (
    WCHAR *FilePath,
    PFILE_BASIC_INFORMATION FileInformation
    )

/*++

Routine Description:

    This routine queries the basic attributes for the specified file.

Arguments:

    FilePath - Pointer to full NT file path, e.g. 
        \Device\HarddiskVolume1\boot.ini, NOT Win32 path, e.g. c:\boot.ini

    FileInformation - If successful the basic file info is returned here.

Return Value:

    Win32 error code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FilePathU;
    NTSTATUS Status;
    DWORD ErrorCode;

    //
    // Query the file information.
    //

    RtlInitUnicodeString(&FilePathU, FilePath);

    InitializeObjectAttributes(&ObjectAttributes,
                               &FilePathU,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtQueryAttributesFile(&ObjectAttributes,
                                   FileInformation);

    if (NT_SUCCESS(Status)) {

        //
        // In the typical success case, don't call possibly an expensive
        // routine to convert the error code.
        //

        ErrorCode = ERROR_SUCCESS;

    } else {

        ErrorCode = RtlNtStatusToDosError(Status);
    }

    return ErrorCode;
}

DWORD
PfSvGetFileIndexNumber(
    WCHAR *FilePath,
    PLARGE_INTEGER FileIndexNumber
    )

/*++

Routine Description:

    This routine queries the file system's IndexNumber for the specified
    file.

Arguments:

    FilePath - Pointer to full NT file path, e.g. 
        \Device\HarddiskVolume1\boot.ini, NOT Win32 path, e.g. c:\boot.ini

    FileIndexNumber - If successful the index number is returned here.

Return Value:

    Win32 error code.

--*/

{
    HANDLE FileHandle;
    BOOLEAN OpenedFile;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FilePathU;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_INTERNAL_INFORMATION InternalInformation;

    //
    // Initialize locals.
    //
    
    OpenedFile = FALSE;

    //
    // Open the file.
    //

    RtlInitUnicodeString(&FilePathU, FilePath);

    InitializeObjectAttributes(&ObjectAttributes,
                               &FilePathU,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtCreateFile(&FileHandle,
                          STANDARD_RIGHTS_READ |
                            FILE_READ_ATTRIBUTES | 
                            FILE_READ_EA,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          0,
                          FILE_SHARE_READ | 
                            FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE,
                          FILE_OPEN,
                          0,
                          NULL,
                          0);
    
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }
    
    OpenedFile = TRUE;
      
    //
    // Query internal information.
    //
    
    Status = NtQueryInformationFile(FileHandle,
                                    &IoStatusBlock,
                                    &InternalInformation,
                                    sizeof(InternalInformation),
                                    FileInternalInformation);
    
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }
        
    *FileIndexNumber = InternalInformation.IndexNumber;
    
    Status = STATUS_SUCCESS;

 cleanup:

    if (OpenedFile) {
        NtClose(FileHandle);
    }

    return RtlNtStatusToDosError(Status);
}

//
// String utility routines.
//

PFSV_SUFFIX_COMPARISON_RESULT
PfSvCompareSuffix(
    WCHAR *String,
    ULONG StringLength,
    WCHAR *Suffix,
    ULONG SuffixLength,
    BOOLEAN CaseSensitive
    )

/*++

Routine Description:

    This compares the last characters of String to Suffix. The strings
    don't have to be NUL terminated. 

    NOTE: The lexical ordering is done starting from the LAST
    characters.

Arguments:

    String - String to check suffix of. 
    
    StringLength - Number of characters in String.

    Suffix - What the suffix of String should match.

    SuffixLength - Number of characters in Suffix.

    CaseSensitive - Whether the comparison should be case sensitive.

Return Value:

    PFSV_SUFFIX_COMPARISON_RESULT

--*/

{
    LONG StringCharIdx;
    WCHAR StringChar;
    LONG SuffixCharIdx;
    WCHAR SuffixChar;

    //
    // If suffix is longer than the string itself, it cannot match.
    //

    if (SuffixLength > StringLength) {
        return PfSvSuffixLongerThan;
    }

    //
    // If the suffix is 0 length it matches anything.
    //

    if (SuffixLength == 0) {
        return PfSvSuffixIdentical;
    }

    //
    // If the suffix is not 0 length and it is greater than
    // StringLength, StringLength cannot be 0.
    //

    PFSVC_ASSERT(StringLength);

    //
    // Start from the last character of the string and try to match
    // the suffix.
    //

    StringCharIdx = StringLength - 1;
    SuffixCharIdx = SuffixLength - 1;

    while (SuffixCharIdx >= 0) {

        SuffixChar = Suffix[SuffixCharIdx];
        StringChar = String[StringCharIdx];

        if (!CaseSensitive) {
            SuffixChar = towupper(SuffixChar);
            StringChar = towupper(StringChar);
        }

        //
        // Is comparing the values of chars same comparing them
        // lexically?
        //

        if (StringChar < SuffixChar) {
            return PfSvSuffixGreaterThan;
        } else if (StringChar > SuffixChar) {
            return PfSvSuffixLessThan;
        }
        
        //
        // Otherwise this character matches. Compare next one.
        //

        StringCharIdx--;
        SuffixCharIdx--;
    }

    //
    // All suffix characters matched.
    //

    return PfSvSuffixIdentical;
}

PFSV_PREFIX_COMPARISON_RESULT
PfSvComparePrefix(
    WCHAR *String,
    ULONG StringLength,
    WCHAR *Prefix,
    ULONG PrefixLength,
    BOOLEAN CaseSensitive
    )

/*++

Routine Description:

    This compares the first characters of String to Prefix. The
    strings don't have to be NUL terminated.

Arguments:

    String - String to check prefix of. 
    
    StringLength - Number of characters in String.

    Suffix - What the prefix of String should match.

    SuffixLength - Number of characters in Prefix.

    CaseSensitive - Whether the comparison should be case sensitive.

Return Value:

    PFSV_PREFIX_COMPARISON_RESULT

--*/

{
    LONG StrCmpResult;
    
    //
    // If prefix is longer than the string itself, it cannot match.
    //

    if (PrefixLength > StringLength) {
        return PfSvPrefixLongerThan;
    }

    //
    // If the prefix is 0 length it matches anything.
    //

    if (PrefixLength == 0) {
        return PfSvPrefixIdentical;
    }

    //
    // If the prefix is not 0 length and it is greater than
    // StringLength, StringLength cannot be 0.
    //

    ASSERT(StringLength);

    //
    // Compare the prefix to the beginning of the string.
    //

    if (CaseSensitive) {
        StrCmpResult = wcsncmp(Prefix, String, PrefixLength);
    } else {
        StrCmpResult = _wcsnicmp(Prefix, String, PrefixLength);
    }

    if (StrCmpResult == 0) {
        return PfSvPrefixIdentical;
    } else if (StrCmpResult > 0) {
        return PfSvPrefixGreaterThan;
    } else {
        return PfSvPrefixLessThan;
    }
}

VOID
FASTCALL
PfSvRemoveEndOfLineChars (
    WCHAR *Line,
    ULONG *LineLength
    )

/*++

Routine Description:

    If the Line ends with \n/\r\n, these characters are removed and
    LineLength is adjusted accordingly.

Arguments:

    Line - Pointer to line string.
    
    LineLength - Pointer to length of line string in characters
      excluding any terminating NULs. This is updated if carriage
      return/linefeed characters are removed.

Return Value:

    None.

--*/

{
    if ((*LineLength) && (Line[(*LineLength) - 1] == L'\n')) {
        
        Line[(*LineLength) - 1] = 0;
        (*LineLength)--;

        if ((*LineLength) && (Line[(*LineLength) - 1] == L'\r')) {
            
            Line[(*LineLength) - 1] = 0;
            (*LineLength)--;
        }
    }
}

PWCHAR
PfSvcAnsiToUnicode(
    PCHAR str
    )

/*++

Routine Description:

    This routine converts an ANSI string into an allocated wide
    character string. The returned string should be freed by
    PfSvcFreeString.

Arguments:

    str - Pointer to string to convert.

Return Value:

    Allocated wide character string or NULL if there is a failure.

--*/

{
    ULONG len;
    wchar_t *retstr = NULL;

    len = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
    retstr = (wchar_t *)PFSVC_ALLOC(len * sizeof(wchar_t));
    if (!retstr) 
    {
        return NULL;
    }
    MultiByteToWideChar(CP_ACP, 0, str, -1, retstr, len);
    return retstr;
}

PCHAR
PfSvcUnicodeToAnsi(
    PWCHAR wstr
    )

/*++

Routine Description:

    This routine converts a unicode string into an allocated ansi
    string. The returned string should be freed by PfSvcFreeString.

Arguments:

    wstr - Pointer to string to convert.

Return Value:

    Allocated ANSI string or NULL if there is a failure.

--*/

{
    ULONG len;
    char *retstr = NULL;
  
    len = WideCharToMultiByte(CP_ACP, 0, wstr, -1, NULL, 0, 0, 0);
    retstr = (char *) PFSVC_ALLOC(len * sizeof(char));
    if (!retstr)
    {
        return NULL;
    }
    WideCharToMultiByte(CP_ACP, 0, wstr, -1, retstr, len, 0, 0);
    return retstr;
}

VOID 
PfSvcFreeString(
    PVOID String
    )

/*++

Routine Description:

    This routine frees a string allocated and returned by
    PfSvcUnicodeToAnsi or PfSvcAnsiToUnicode.

Arguments:

    String - Pointer to string to free.

Return Value:

    None.

--*/

{
    PFSVC_FREE(String);
}

//
// Routines that deal with information in the registry.
//

DWORD
PfSvSaveStartInfo (
    HKEY ServiceDataKey
    )

/*++

Routine Description:

    This routine saves start time, prefetcher version etc. into the
    registry.

Arguments:

    ServiceDataKey - Key under which the values will be set.

Return Value:

    Win32 error code.

--*/
    
{
    DWORD ErrorCode;
    DWORD PrefetchVersion;
    SYSTEMTIME LocalTime;
    WCHAR CurrentTime[50];
    ULONG CurrentTimeMaxChars;
    ULONG CurrentTimeSize;

    //
    // Initialize locals.
    //

    PrefetchVersion = PF_CURRENT_VERSION;
    CurrentTimeMaxChars = sizeof(CurrentTime) / sizeof(WCHAR);

    //
    // Save version.
    //

    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_VERSION_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &PrefetchVersion,
                              sizeof(PrefetchVersion));

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
    
    //
    // Get system time and convert it to a string.
    //
    
    GetLocalTime(&LocalTime);
    
    _snwprintf(CurrentTime, CurrentTimeMaxChars, 
               L"%04d/%02d/%02d-%02d:%02d:%02d",
               (ULONG)LocalTime.wYear,
               (ULONG)LocalTime.wMonth,
               (ULONG)LocalTime.wDay,
               (ULONG)LocalTime.wHour,
               (ULONG)LocalTime.wMinute,
               (ULONG)LocalTime.wSecond);

    //
    // Make sure it is terminated.
    //
    
    CurrentTime[CurrentTimeMaxChars - 1] = 0;
    
    //
    // Save it to the registry.
    //

    CurrentTimeSize = (wcslen(CurrentTime) + 1) * sizeof(WCHAR);
    
    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_START_TIME_VALUE_NAME,
                              0,
                              REG_SZ,
                              (PVOID) CurrentTime,
                              CurrentTimeSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Save the initial statistics (which should be mostly zeros).
    //

    ErrorCode = PfSvSaveTraceProcessingStatistics(ServiceDataKey);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    return ErrorCode;
}

DWORD
PfSvSaveExitInfo (
    HKEY ServiceDataKey,
    DWORD ExitCode
    )

/*++

Routine Description:

    This routine saves the prefetcher service exit information to the
    registry.

Arguments:

    ServiceDataKey - Key under which the values will be set.
    
    ExitCode - Win32 error code the service is exiting with.

Return Value:

    Win32 error code.

--*/
    
{
    DWORD ErrorCode;
    SYSTEMTIME LocalTime;
    WCHAR CurrentTime[50];
    ULONG CurrentTimeMaxChars;
    ULONG CurrentTimeSize;

    //
    // Initialize locals.
    //

    CurrentTimeMaxChars = sizeof(CurrentTime) / sizeof(WCHAR);

    //
    // Save exit code.
    //   
    
    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_EXIT_CODE_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &ExitCode,
                              sizeof(ExitCode));
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Get system time and convert it to a string.
    //
    
    GetLocalTime(&LocalTime);
    
    _snwprintf(CurrentTime, CurrentTimeMaxChars, 
               L"%04d/%02d/%02d-%02d:%02d:%02d",
               (ULONG)LocalTime.wYear,
               (ULONG)LocalTime.wMonth,
               (ULONG)LocalTime.wDay,
               (ULONG)LocalTime.wHour,
               (ULONG)LocalTime.wMinute,
               (ULONG)LocalTime.wSecond);

    //
    // Make sure it is terminated.
    //
    
    CurrentTime[CurrentTimeMaxChars - 1] = 0;
    
    //
    // Save it to the registry.
    //

    CurrentTimeSize = (wcslen(CurrentTime) + 1) * sizeof(WCHAR);
    
    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_EXIT_TIME_VALUE_NAME,
                              0,
                              REG_SZ,
                              (PVOID) CurrentTime,
                              CurrentTimeSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Save the final statistics.
    //

    ErrorCode = PfSvSaveTraceProcessingStatistics(ServiceDataKey);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    return ErrorCode;
}

DWORD
PfSvSaveTraceProcessingStatistics (
    HKEY ServiceDataKey
    )

/*++

Routine Description:

    This routine saves global trace processing statistics to the
    registry.

Arguments:

    ServiceDataKey - Key under which the values will be set.

Return Value:

    Win32 error code.

--*/
    
{
    DWORD ErrorCode;

    //
    // Save the various global statistics.
    //

    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_TRACES_PROCESSED_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &PfSvcGlobals.NumTracesProcessed,
                              sizeof(DWORD));

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_TRACES_SUCCESSFUL_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &PfSvcGlobals.NumTracesSuccessful,
                              sizeof(DWORD));

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = RegSetValueEx(ServiceDataKey,
                              PFSVC_LAST_TRACE_FAILURE_VALUE_NAME,
                              0,
                              REG_DWORD,
                              (PVOID) &PfSvcGlobals.LastTraceFailure,
                              sizeof(DWORD));

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    return ErrorCode;
}

DWORD
PfSvGetLastDiskLayoutTime(
    FILETIME *LastDiskLayoutTime
    )

/*++

Routine Description:

    This routine queries the last time disk layout was updated from
    the registry under the service data key.

Arguments:

    LastDiskLayoutTime - Pointer to output data.

Return Value:

    Win32 error code.

--*/

{
    ULONG Size;
    DWORD ErrorCode;
    DWORD RegValueType;
    FILETIME CurrentFileTime;
    SYSTEMTIME SystemTime;
                                
    //
    // Query last disk layout time from the registry and adjust it if
    // necessary.
    //

    Size = sizeof(FILETIME);

    ErrorCode = RegQueryValueEx(PfSvcGlobals.ServiceDataKey,
                                PFSVC_LAST_DISK_LAYOUT_TIME_VALUE_NAME,
                                NULL,
                                &RegValueType,
                                (PVOID) LastDiskLayoutTime,
                                &Size);

    if (ErrorCode != ERROR_SUCCESS) {

       if (ErrorCode ==  ERROR_FILE_NOT_FOUND) {
           
           //
           // No successful runs of the defragger to update layout has
           // been recorded in the registry. 
           //

           RtlZeroMemory(LastDiskLayoutTime, sizeof(FILETIME));

       } else {
       
           //
           // This is a real error.
           //
           
           goto cleanup;
       }

    } else {
       
       //
       // The query was successful, but if the value type is not
       // REG_BINARY, we most likely read in trash.
       //

       if (RegValueType != REG_BINARY) {
           
           RtlZeroMemory(LastDiskLayoutTime, sizeof(FILETIME));

       } else {

           //
           // If the time we recorded looks greater than the current
           // time (e.g. because the user played with the system time
           // and such), adjust it.
           //

           GetSystemTime(&SystemTime);

           if (!SystemTimeToFileTime(&SystemTime, &CurrentFileTime)) {
               ErrorCode = GetLastError();
               goto cleanup;
           }

           if (CompareFileTime(LastDiskLayoutTime, &CurrentFileTime) > 0) {
       
               //
               // The time in the registry looks bogus. We'll set it
               // to 0, to drive our caller to run the defragger to
               // update the layout again.
               //

               RtlZeroMemory(LastDiskLayoutTime, sizeof(FILETIME));
           }
       }
    }

    ErrorCode = ERROR_SUCCESS;

  cleanup:

    return ErrorCode;
}

DWORD
PfSvSetLastDiskLayoutTime(
    FILETIME *LastDiskLayoutTime
    )

/*++

Routine Description:

    This routine saves the last time the disk layout was updated to
    the registry under the service data key.

Arguments:

    LastDiskLayoutTime - Pointer to new disk layout time.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR CurrentTime[50];
    ULONG CurrentTimeMaxChars;
    ULONG CurrentTimeSize;
    FILETIME LocalFileTime;
    SYSTEMTIME LocalSystemTime;

    //
    // Initialize locals.
    //
   
    CurrentTimeMaxChars = sizeof(CurrentTime) / sizeof(WCHAR);

    //
    // Save the specified time.
    //

    ErrorCode = RegSetValueEx(PfSvcGlobals.ServiceDataKey,
                              PFSVC_LAST_DISK_LAYOUT_TIME_VALUE_NAME,
                              0,
                              REG_BINARY,
                              (PVOID) LastDiskLayoutTime,
                              sizeof(FILETIME));
   

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Also save it in human readable format.
    //

    if (!FileTimeToLocalFileTime(LastDiskLayoutTime, &LocalFileTime)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (!FileTimeToSystemTime(&LocalFileTime, &LocalSystemTime)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    _snwprintf(CurrentTime, CurrentTimeMaxChars, 
               L"%04d/%02d/%02d-%02d:%02d:%02d",
               (ULONG)LocalSystemTime.wYear,
               (ULONG)LocalSystemTime.wMonth,
               (ULONG)LocalSystemTime.wDay,
               (ULONG)LocalSystemTime.wHour,
               (ULONG)LocalSystemTime.wMinute,
               (ULONG)LocalSystemTime.wSecond);

    //
    // Make sure it is terminated.
    //
    
    CurrentTime[CurrentTimeMaxChars - 1] = 0;

    //
    // Save it to the registry.
    //
    
    CurrentTimeSize = (wcslen(CurrentTime) + 1) * sizeof(WCHAR);
    
    ErrorCode = RegSetValueEx(PfSvcGlobals.ServiceDataKey,
                              PFSVC_LAST_DISK_LAYOUT_TIME_STRING_VALUE_NAME,
                              0,
                              REG_SZ,
                              (PVOID) CurrentTime,
                              CurrentTimeSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

DWORD
PfSvGetDontRunDefragger(
    DWORD *DontRunDefragger
    )

/*++

Routine Description:

    This routine queries the registry setting that disables launching
    the defragger when the system is idle.

Arguments:

    DontRunDefragger - Pointer to output data.

Return Value:

    Win32 error code.

--*/

{
    HKEY ParametersKey;  
    ULONG Size;
    DWORD Value;
    DWORD ErrorCode;
    DWORD RegValueType;
    BOOLEAN OpenedParametersKey;

    //
    // Initialize locals.
    //

    OpenedParametersKey = FALSE;

    //
    // Open the parameters key, creating it if necessary.
    //
    
    ErrorCode = RegCreateKey(HKEY_LOCAL_MACHINE,
                             PFSVC_OPTIMAL_LAYOUT_REG_KEY_PATH,
                             &ParametersKey);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    OpenedParametersKey = TRUE;

    //
    // Query whether auto layout is enabled.
    //

    Size = sizeof(Value);

    ErrorCode = RegQueryValueEx(ParametersKey,
                               PFSVC_OPTIMAL_LAYOUT_ENABLE_VALUE_NAME,
                               NULL,
                               &RegValueType,
                               (PVOID) &Value,
                               &Size);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // The query was successful. Make sure value is a DWORD.
    //

    if (RegValueType != REG_DWORD) {          
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Set the value.
    //

    *DontRunDefragger = !(Value);

    ErrorCode = ERROR_SUCCESS;

cleanup:

    if (OpenedParametersKey) {
        CloseHandle(ParametersKey);
    }

    return ErrorCode;
}

BOOLEAN
PfSvAllowedToRunDefragger(
    BOOLEAN CheckRegistry
    )
    
/*++

Routine Description:

    This routine checks the global state/parameters to see if we
    are allowed to try to run the defragger.

Arguments:

    CheckRegistry - Whether to ignore auto-layout enable key in the registry.

Return Value:

    TRUE - Go ahead and run the defragger.
    FALSE - Don't run the defragger.

--*/

{
    PF_SCENARIO_TYPE ScenarioType;
    BOOLEAN AllowedToRunDefragger;
    BOOLEAN PrefetchingEnabled;
    
    //
    // Initialize locals.
    //

    AllowedToRunDefragger = FALSE;

    //
    // Is this a server machine?
    //

    if (PfSvcGlobals.OsVersion.wProductType != VER_NT_WORKSTATION) {
        goto cleanup;
    }

    //
    // Is prefetching enabled for any scenario type?
    //

    PrefetchingEnabled = FALSE;
    
    for(ScenarioType = 0; ScenarioType < PfMaxScenarioType; ScenarioType++) {
        if (PfSvcGlobals.Parameters.EnableStatus[ScenarioType] == PfSvEnabled) {
            PrefetchingEnabled = TRUE;
            break;
        }
    }    

    if (!PrefetchingEnabled) {
        goto cleanup;
    }

    //
    // Did we try to run the defragger and it crashed before?
    //

    if (PfSvcGlobals.DefraggerErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // If in the registry we were not allowed to run the defragger, don't 
    // do so.
    //

    if (CheckRegistry) {
        if (PfSvcGlobals.DontRunDefragger) {
            goto cleanup;
        }
    }

    //
    // If we passed all checks, we are allowed to run the defragger.
    //

    AllowedToRunDefragger = TRUE;
    
cleanup:

    return AllowedToRunDefragger;
}

//
// Routines that deal with security.
//

BOOL 
PfSvSetPrivilege(
    HANDLE hToken,
    LPCTSTR lpszPrivilege,
    ULONG ulPrivilege,
    BOOL bEnablePrivilege
    ) 

/*++

Routine Description:

    Enables or disables a privilege in an access token.

Arguments:

    hToken - Access token handle.

    lpszPrivilege - Name of privilege to enable/disable.

    ulPrivilege - If a name is not specified, then a ULONG privilege 
      should be specified.

    bEnablePrivilege - Whether to enable or disable privilege

Return Value:

    TRUE - Success.
    FALSE - Failure.

--*/

{
    TOKEN_PRIVILEGES tp;
    LUID luid;

    if (lpszPrivilege) {
        if ( !LookupPrivilegeValue(NULL,
                                   lpszPrivilege,
                                   &luid)) {
            return FALSE; 
        }
    } else {
        luid = RtlConvertUlongToLuid(ulPrivilege);
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if (bEnablePrivilege)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    //
    // Enable the privilege or disable all privileges.
    //

    AdjustTokenPrivileges(
        hToken, 
        FALSE, 
        &tp, 
        sizeof(TOKEN_PRIVILEGES), 
        (PTOKEN_PRIVILEGES) NULL, 
        (PDWORD) NULL); 
 
    //
    // Call GetLastError to determine whether the function succeeded.
    //

    if (GetLastError() != ERROR_SUCCESS) { 
        return FALSE; 
    } 

    return TRUE;
}

DWORD
PfSvSetAdminOnlyPermissions(
    WCHAR *ObjectPath,
    HANDLE ObjectHandle,
    SE_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routine makes the built-in administrators group the owner and
    only allowed in the DACL of the specified directory or event
    object.

    The calling thread must have the SE_TAKE_OWNERSHIP_NAME privilege.

Arguments:

    ObjectPath - File/directory path or event name.
    
    ObjectHandle - If this is a SE_KERNEL_OBJECT, handle to it,
      otherwise NULL.

    ObjectType - Security object type. Only SE_KERNEL_OBJECT and
      SE_FILE_OBJECT are supported.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    SID_IDENTIFIER_AUTHORITY SIDAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsSID;
    PSECURITY_DESCRIPTOR SecurityDescriptor; 
    PACL DiscretionaryACL; 
    DWORD ACLRevision;
    ULONG ACESize;
    ULONG ACLSize;
    PACCESS_ALLOWED_ACE AccessAllowedAce;
    BOOL Result;

    //
    // Initialize locals.
    //

    AdministratorsSID = NULL;
    SecurityDescriptor = NULL;
    DiscretionaryACL = NULL;
    ACLRevision = ACL_REVISION;

    //
    // Check parameters.
    //
    
    if (ObjectType == SE_KERNEL_OBJECT) {
        if (ObjectHandle == NULL) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    } else if (ObjectType == SE_FILE_OBJECT) {
        if (ObjectHandle != NULL) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    } else {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Create a SID for the BUILTIN\Administrators group.
    //

    if(!AllocateAndInitializeSid(&SIDAuthority, 
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0, 0, 0, 0, 0, 0,
                                 &AdministratorsSID)) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Make Administrators the owner.
    //

    ErrorCode = SetNamedSecurityInfo (ObjectPath,
                                      ObjectType,
                                      OWNER_SECURITY_INFORMATION,
                                      AdministratorsSID,
                                      NULL, 
                                      NULL, 
                                      NULL); 
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Setup a discretionary access control list:
    //

    //
    // Determine size of an ACCESS_ALLOWED access control entry for
    // the administrators group. (Subtract size of SidStart which is
    // both part of ACE and SID.
    //

    ACESize = sizeof(ACCESS_ALLOWED_ACE);
    ACESize -= sizeof (AccessAllowedAce->SidStart);
    ACESize += GetLengthSid(AdministratorsSID);

    //
    // Determine size of the access control list.
    //

    ACLSize = sizeof(ACL);
    ACLSize += ACESize;

    //
    // Allocate and initialize the access control list.
    //

    DiscretionaryACL = PFSVC_ALLOC(ACLSize);

    if (!DiscretionaryACL) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if (!InitializeAcl(DiscretionaryACL, ACLSize, ACLRevision)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Add an ACE to allow access for the Administrators group.
    //

    if (!AddAccessAllowedAce(DiscretionaryACL,
                             ACLRevision,
                             GENERIC_ALL,
                             AdministratorsSID)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize a security descriptor.
    //

    SecurityDescriptor = PFSVC_ALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH);
    
    if (!SecurityDescriptor) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    
    if (!InitializeSecurityDescriptor(SecurityDescriptor, 
                                      SECURITY_DESCRIPTOR_REVISION)) {
        ErrorCode = GetLastError();
        goto cleanup; 
    } 
    
    //
    // Set the discretionary access control list on the security descriptor.
    //
    
    if (!SetSecurityDescriptorDacl(SecurityDescriptor, 
                                   TRUE,
                                   DiscretionaryACL, 
                                   FALSE)) {
        ErrorCode = GetLastError();
        goto cleanup; 
    } 
    
    //
    // Set the built security descriptor on the prefetch directory.
    //
    
    if (ObjectType == SE_FILE_OBJECT) {
        Result = SetFileSecurity(ObjectPath, 
                                 DACL_SECURITY_INFORMATION, 
                                 SecurityDescriptor);
 
    } else {

        PFSVC_ASSERT(ObjectType == SE_KERNEL_OBJECT);
        PFSVC_ASSERT(ObjectHandle);

        Result = SetKernelObjectSecurity(ObjectHandle, 
                                         DACL_SECURITY_INFORMATION, 
                                         SecurityDescriptor);

    }

    if (!Result) {
        ErrorCode = GetLastError();
        goto cleanup; 
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (AdministratorsSID) {
        FreeSid(AdministratorsSID);
    }
    
    if (SecurityDescriptor) {
        PFSVC_FREE(SecurityDescriptor);
    }
    
    if (DiscretionaryACL) {
        PFSVC_FREE(DiscretionaryACL);
    }
    
    return ErrorCode;
}

DWORD
PfSvGetPrefetchServiceThreadPrivileges (
    VOID
    )

/*++

Routine Description:

    This routine ensures there is a security token for the current
    thread and sets the right privileges on it so the thread can
    communicate with the kernel mode prefetcher. It should be called
    right after a thread is created.

Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    BOOLEAN ImpersonatedSelf;
    BOOLEAN OpenedThreadToken;
    HANDLE ThreadToken;

    //
    // Initialize locals.
    //

    ImpersonatedSelf = FALSE;
    OpenedThreadToken = FALSE;

    DBGPR((PFID,PFTRC,"PFSVC: GetThreadPriviliges()\n"));
      
    //
    // Obtain a security context for this thread so we can set
    // privileges etc. without effecting the whole process.
    //

    if (!ImpersonateSelf(SecurityImpersonation)) {
        DBGPR((PFID,PFERR,"PFSVC: GetThreadPriviliges()-FailedImpersonateSelf\n"));
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ImpersonatedSelf = TRUE;

    //
    // Set the privileges we will need talk to the kernel mode
    // prefetcher:
    //
    
    //
    // Open thread's access token.
    //
    
    if (!OpenThreadToken(GetCurrentThread(), 
                         TOKEN_ADJUST_PRIVILEGES,
                         FALSE,
                         &ThreadToken)) {
        DBGPR((PFID,PFERR,"PFSVC: GetThreadPriviliges()-FailedOpenToken\n"));
        ErrorCode = GetLastError();
        goto cleanup;
    } 
    
    OpenedThreadToken = TRUE;

    //
    // Enable the SE_PROF_SINGLE_PROCESS_PRIVILEGE privilege so the
    // kernel mode prefetcher accepts our queries & set requests.
    // 
    //
 
    if (!PfSvSetPrivilege(ThreadToken, 0, SE_PROF_SINGLE_PROCESS_PRIVILEGE, TRUE)) {
        DBGPR((PFID,PFERR,"PFSVC: GetThreadPriviliges()-FailedEnableProf\n"));
        ErrorCode = GetLastError();
        goto cleanup; 
    }

    //
    // Enable the SE_TAKE_OWNERSHIP_NAME privilege so we can get
    // ownership of the prefetch directory.
    //
 
    if (!PfSvSetPrivilege(ThreadToken, SE_TAKE_OWNERSHIP_NAME, 0, TRUE)) {
        DBGPR((PFID,PFERR,"PFSVC: GetThreadPriviliges()-FailedEnableOwn\n"));
        ErrorCode = GetLastError();
        goto cleanup; 
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (OpenedThreadToken) {
        CloseHandle(ThreadToken);
    }

    if (ErrorCode != ERROR_SUCCESS) {
        if (ImpersonatedSelf) {
            RevertToSelf();
        }
    }

    DBGPR((PFID,PFTRC,"PFSVC: GetThreadPriviliges()=%x\n",ErrorCode));

    return ErrorCode;
}

//
// Routines that deal with volume node structures.
//

DWORD
PfSvCreateVolumeNode (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *VolumePath,
    ULONG VolumePathLength,
    PLARGE_INTEGER CreationTime,
    ULONG SerialNumber
    )

/*++

Routine Description:

    This routine creates a volume node with the specifed info if it
    does not already exist. If a node already exists, it verifies
    CreationTime and SerialNumber.

Arguments:

    ScenarioInfo - Pointer to new scenario information.
    
    VolumePath - UPCASE NT full path of the volume, NUL terminated.
    
    VolumePathLength - Number of characters in VolumePath excluding NUL.

    CreationTime & SerialNumber - For the volume.

Return Value:

    ERROR_REVISION_MISMATCH - There already exists a volume node with
      that path but with a different signature/creation time.

    Win32 error code.

--*/

{
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    PLIST_ENTRY FoundPosition;
    PPFSVC_VOLUME_NODE VolumeNode;
    DWORD ErrorCode;
    LONG ComparisonResult;
    PPFSVC_VOLUME_NODE NewVolumeNode;
    PWCHAR NewVolumePath;

    //
    // Initialize locals.
    //

    NewVolumeNode = NULL;
    NewVolumePath = NULL;

    DBGPR((PFID,PFSTRC,"PFSVC: CreateVolumeNode(%ws)\n", VolumePath));

    //
    // Walk through the existing volume nodes list and try to find
    // matching one.
    //
    
    HeadEntry = &ScenarioInfo->VolumeList;
    NextEntry = HeadEntry->Flink;
    FoundPosition = NULL;

    while (NextEntry != HeadEntry) {
        
        VolumeNode = CONTAINING_RECORD(NextEntry,
                                       PFSVC_VOLUME_NODE,
                                       VolumeLink);

        NextEntry = NextEntry->Flink;
        
        ComparisonResult = wcsncmp(VolumePath, 
                                   VolumeNode->VolumePath, 
                                   VolumePathLength);
        
        if (ComparisonResult == 0) {

            //
            // Make sure VolumePathLengths are equal.
            //
            
            if (VolumeNode->VolumePathLength != VolumePathLength) {
                
                //
                // Continue searching.
                //
                
                continue;
            }
            
            //
            // We found our volume. Verify magics.
            //
            
            if (VolumeNode->SerialNumber != SerialNumber ||
                VolumeNode->CreationTime.QuadPart != CreationTime->QuadPart) {

                ErrorCode = ERROR_REVISION_MISMATCH;
                goto cleanup;

            } else {

                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }

        } else if (ComparisonResult < 0) {
            
            //
            // The volume paths are sorted lexically. The file path
            // would be less than other volumes too. The new node
            // would go right before this node.
            //

            FoundPosition = &VolumeNode->VolumeLink;

            break;
        }

        //
        // Continue looking...
        //

    }

    //
    // If we could not find an entry to put the new entry befor, it
    // goes before the list head.
    //
    
    if (!FoundPosition) {
        FoundPosition = HeadEntry;
    }

    //
    // If we break out of the while loop, we could not find a
    // volume. We should create a new node.
    //

    NewVolumeNode = PfSvChunkAllocatorAllocate(&ScenarioInfo->VolumeNodeAllocator);
    
    if (!NewVolumeNode) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    NewVolumePath = PfSvStringAllocatorAllocate(&ScenarioInfo->PathAllocator,
                                                (VolumePathLength + 1) * sizeof(WCHAR));

    if (!NewVolumePath) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    
    //
    // Copy file's volume path.
    //

    wcsncpy(NewVolumePath, VolumePath, VolumePathLength);
    NewVolumePath[VolumePathLength] = 0;
    
    //
    // Initialize volume node.
    //

    NewVolumeNode->VolumePath = NewVolumePath;
    NewVolumeNode->VolumePathLength = VolumePathLength;
    NewVolumeNode->SerialNumber = SerialNumber;
    NewVolumeNode->CreationTime = (*CreationTime);
    InitializeListHead(&NewVolumeNode->SectionList);
    PfSvInitializePathList(&NewVolumeNode->DirectoryList, &ScenarioInfo->PathAllocator, TRUE);
    NewVolumeNode->NumSections = 0;
    NewVolumeNode->NumAllSections = 0;
    NewVolumeNode->MFTSectionNode = NULL;

    //
    // Add it to the scenario's volume list before the found position.
    //

    InsertTailList(FoundPosition, &NewVolumeNode->VolumeLink);

    VolumeNode = NewVolumeNode;
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        
        if (NewVolumePath) {
            PfSvStringAllocatorFree(&ScenarioInfo->PathAllocator, NewVolumePath);
        }
        
        if (NewVolumeNode) {
            PfSvChunkAllocatorFree(&ScenarioInfo->VolumeNodeAllocator, NewVolumeNode);
        }
                
        VolumeNode = NULL;
    }

    DBGPR((PFID,PFSTRC,"PFSVC: CreateVolumeNode()=%x\n", ErrorCode));

    return ErrorCode;
}

PPFSVC_VOLUME_NODE
PfSvGetVolumeNode (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *FilePath,
    ULONG FilePathLength
    )

/*++

Routine Description:

    This routine looks for a volume node for the specified file path.

Arguments:

    ScenarioInfo - Pointer to new scenario information.
    
    FilePath - NT full path of the file, NUL terminated.
    
    FilePathLength - Number of characters in FilePath excluding NUL.

Return Value:

    Pointer to found VolumeNode, or NULL.

--*/

{
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    PPFSVC_VOLUME_NODE VolumeNode;
    DWORD ErrorCode;
    PFSV_PREFIX_COMPARISON_RESULT ComparisonResult;

    DBGPR((PFID,PFSTRC,"PFSVC: GetVolumeNode(%ws)\n", FilePath));

    //
    // Walk through the existing volume nodes list and try to find
    // matching one.
    //
    
    HeadEntry = &ScenarioInfo->VolumeList;
    NextEntry = HeadEntry->Flink;
    
    while (NextEntry != HeadEntry) {
        
        VolumeNode = CONTAINING_RECORD(NextEntry,
                                       PFSVC_VOLUME_NODE,
                                       VolumeLink);

        NextEntry = NextEntry->Flink;
        
        ComparisonResult = PfSvComparePrefix(FilePath, 
                                             FilePathLength,
                                             VolumeNode->VolumePath, 
                                             VolumeNode->VolumePathLength,
                                             TRUE);
        
        if (ComparisonResult == PfSvPrefixIdentical) {

            //
            // Make sure that there is a slash in the file
            // path after the volume path.
            //
            
            if (FilePath[VolumeNode->VolumePathLength] != L'\\') {
                
                //
                // Continue searching.
                //
                
                continue;
            }
            
            //
            // We found our volume.
            //
            
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;

        } else if (ComparisonResult == PfSvPrefixGreaterThan) {
            
            //
            // The volume paths are sorted lexically. The file path
            // would be less than other volumes too.
            //

            break;
        }

        //
        // Continue looking...
        //

    }

    //
    // If we break out of the while loop, we could not find a
    // volume. 
    //

    VolumeNode = NULL;
    ErrorCode = ERROR_NOT_FOUND;

 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        VolumeNode = NULL;
    }

    DBGPR((PFID,PFSTRC,"PFSVC: GetVolumeNode()=%p\n", VolumeNode));

    return VolumeNode;
}

VOID
PfSvCleanupVolumeNode(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPFSVC_VOLUME_NODE VolumeNode
    )

/*++

Routine Description:

    This function cleans up a volume node structure. It does not free
    the structure itself.

Arguments:

    ScenarioInfo - Pointer to scenario info context this volume node 
      belongs to.

    VolumeNode - Pointer to structure.

Return Value:

    None.

--*/

{
    PLIST_ENTRY SectListEntry;
    PPFSVC_SECTION_NODE SectionNode;

    //
    // Cleanup directory list.
    //

    PfSvCleanupPathList(&VolumeNode->DirectoryList);

    //
    // If there is a volume path, free it.
    //
    
    if (VolumeNode->VolumePath) {
        PfSvStringAllocatorFree(&ScenarioInfo->PathAllocator, VolumeNode->VolumePath);
        VolumeNode->VolumePath = NULL;
    }
    
    //
    // Remove the section nodes from our list and re-initialize their
    // links so they know they have been removed.
    //

    while (!IsListEmpty(&VolumeNode->SectionList)) {
        
        SectListEntry = RemoveHeadList(&VolumeNode->SectionList);
        
        SectionNode = CONTAINING_RECORD(SectListEntry, 
                                        PFSVC_SECTION_NODE, 
                                        SectionVolumeLink);

        InitializeListHead(&SectionNode->SectionVolumeLink);
    }

    return;
}

DWORD
PfSvAddParentDirectoriesToList(
    PPFSVC_PATH_LIST DirectoryList,
    ULONG VolumePathLength,
    WCHAR *FilePath,
    ULONG FilePathLength
    )

/*++

Routine Description:

    This function will parse a fully qualified NT file path and add
    all parent directories to the specified directory list. The part
    of the path that is the volume path is skipped.

Arguments:

    DirectoryList - Pointer to list to update.

    VolumePathLength - Position in the file path at which the volume
      path ends and the root directory starts.

    FilePath - Pointer to NT file path, NUL terminated.
      
    FullPathLength - Length of FilePath in characters excluding NUL.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR DirectoryPath[MAX_PATH];
    ULONG DirectoryPathLength;
    WCHAR *CurrentChar;
    WCHAR *FilePathEnd;

    //
    // Initialize locals.
    //
    
    FilePathEnd = FilePath + FilePathLength;
    PFSVC_ASSERT(*FilePathEnd == 0);

    //
    // Skip the volume path and start from the root directory.
    //

    CurrentChar = FilePath + VolumePathLength;

    while (CurrentChar < FilePathEnd) {

        if (*CurrentChar == L'\\') {

            //
            // We got a directory.
            //

            DirectoryPathLength = (ULONG) (CurrentChar - FilePath + 1);

            if (DirectoryPathLength >= MAX_PATH) {
                ErrorCode = ERROR_INSUFFICIENT_BUFFER;
                goto cleanup;
            }

            //
            // Copy directory path to buffer and NUL terminate it.
            //

            wcsncpy(DirectoryPath, FilePath, DirectoryPathLength);
            DirectoryPath[DirectoryPathLength] = 0;
            PFSVC_ASSERT(DirectoryPath[DirectoryPathLength - 1] == L'\\');
            
            //
            // Add it to the list.
            //
            
            ErrorCode = PfSvAddToPathList(DirectoryList,
                                       DirectoryPath,
                                       DirectoryPathLength);
            
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
         
            //
            // Continue looking for more directories in the path.
            //
        }

        CurrentChar++;
    }
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

//
// Routines used to allocate / free section & page nodes etc. efficiently.
//

VOID
PfSvChunkAllocatorInitialize (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    )

/*++

Routine Description:

    Initializes the allocator structure. Must be called before other allocator
    routines.

Arguments:

    Allocator - Pointer to structure.
    
Return Value:

    None.

--*/

{
    //
    // Zero the structure. This effectively initializes the following fields:
    //   Buffer
    //   BufferEnd
    //   FreePointer
    //   ChunkSize
    //   MaxHeapAllocs
    //   NumHeapAllocs
    //   UserSpecifiedBuffer
    //

    RtlZeroMemory(Allocator, sizeof(PFSVC_CHUNK_ALLOCATOR));

    return;
}

DWORD
PfSvChunkAllocatorStart (
    IN PPFSVC_CHUNK_ALLOCATOR Allocator,
    OPTIONAL IN PVOID Buffer,
    IN ULONG ChunkSize,
    IN ULONG MaxChunks
    )

/*++

Routine Description:

    Must be called before calling alloc/free on an allocator that has
    been initialized.

Arguments:

    Allocator - Pointer to initialized structure.

    Buffer - If specified, it is the buffer that will be divided up into
      MaxChunks of ChunkSize and given away. Otherwise a buffer will be
      allocated. If specified, the user has to free the buffer after the
      chunk allocator has been cleaned up. It should be aligned right.

    ChunkSize - In bytes how big each allocated chunk will be. 
                e.g. sizeof(PFSVC_PAGE_NODE) It should be greater than
                sizeof(DWORD).

    MaxChunks - Max number of allocs that will be made from the allocator.
    
Return Value:

    Win32 error code.

--*/

{
    ULONG AllocationSize;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    AllocationSize = ChunkSize * MaxChunks;

    //
    // We should be initialized and we should not get started twice.
    //

    PFSVC_ASSERT(Allocator->Buffer == NULL);

    //
    // Chunk size should not be too small.
    //

    if (ChunkSize < sizeof(DWORD) || !MaxChunks) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Did the user specify the buffer to use?
    //

    if (Buffer) {

        Allocator->Buffer = Buffer;
        Allocator->UserSpecifiedBuffer = TRUE;

    } else {

        Allocator->Buffer = PFSVC_ALLOC(AllocationSize);

        if (!Allocator->Buffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        Allocator->UserSpecifiedBuffer = FALSE;
    }

    Allocator->BufferEnd = (PCHAR) Buffer + (ULONG_PTR) AllocationSize;
    Allocator->FreePointer = Buffer;
    Allocator->ChunkSize = ChunkSize;

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

PVOID
PfSvChunkAllocatorAllocate (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    )

/*++

Routine Description:

    Returns a ChunkSize chunk allocated from Allocator. ChunkSize was specified 
    when Allocator was started. If a chunk is return the caller should free it
    to this Allocator before uninitializing the Allocator.

Arguments:

    Allocator - Pointer to started allocator.
    
Return Value:

    NULL or chunk allocated from Allocator.

--*/

{
    PVOID ReturnChunk;

    //
    // We should not be trying to make allocations before we start the 
    // allocator.
    //

    PFSVC_ASSERT(Allocator->Buffer && Allocator->ChunkSize);

    //
    // If we can allocate from our preallocated buffer do so. Otherwise we 
    // have to hit the heap.
    //

    if (Allocator->FreePointer >= Allocator->BufferEnd) {

        Allocator->MaxHeapAllocs++;

        ReturnChunk = PFSVC_ALLOC(Allocator->ChunkSize);

        if (ReturnChunk) {
            Allocator->NumHeapAllocs++;
        }

    } else {

        ReturnChunk = Allocator->FreePointer;

        Allocator->FreePointer += (ULONG_PTR) Allocator->ChunkSize;
    }

    return ReturnChunk;
}

VOID
PfSvChunkAllocatorFree (
    PPFSVC_CHUNK_ALLOCATOR Allocator,
    PVOID Allocation
    )

/*++

Routine Description:

    Frees a chunk allocated from the allocator. This may not make it available
    for use by further allocations from the allocator.

Arguments:

    Allocator - Pointer to started allocator.

    Allocation - Allocation to free.
    
Return Value:

    None.

--*/

{

    //
    // Is this within the preallocated block?
    //

    if ((PUCHAR) Allocation >= Allocator->Buffer &&
        (PUCHAR) Allocation < Allocator->BufferEnd) {

        //
        // Mark this chunk freed.
        //

        *(PULONG)Allocation = PFSVC_CHUNK_ALLOCATOR_FREED_MAGIC;

    } else {

        //
        // This chunk was allocated from heap.
        //

        PFSVC_ASSERT(Allocator->NumHeapAllocs && Allocator->MaxHeapAllocs);

        Allocator->NumHeapAllocs--;

        PFSVC_FREE(Allocation);
    }

    return;
}

VOID
PfSvChunkAllocatorCleanup (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    )

/*++

Routine Description:

    Cleans up resources associated with the allocator. There should not be 
    any outstanding allocations from the allocator when this function is 
    called.

Arguments:

    Allocator - Pointer to initialized allocator.
    
Return Value:

    None.

--*/

{
    PCHAR CurrentChunk;
    ULONG Magic;

    if (Allocator->Buffer) {

        #ifdef PFSVC_DBG

        //
        // Make sure all real heap allocations have been freed.
        //

        PFSVC_ASSERT(Allocator->NumHeapAllocs == 0);

        //
        // Make sure all allocated chunks have been freed. Check
        // ChunkSize first, if it's corrupted we'd loop forever.
        //

        PFSVC_ASSERT(Allocator->ChunkSize);

        for (CurrentChunk = Allocator->Buffer; 
             CurrentChunk < Allocator->FreePointer;
             CurrentChunk += (ULONG_PTR) Allocator->ChunkSize) {

            Magic = *(PULONG)CurrentChunk;

            PFSVC_ASSERT(Magic == PFSVC_CHUNK_ALLOCATOR_FREED_MAGIC);
        }

        #endif // PFSVC_DBG

        //
        // If the buffer was allocated by us (and not specified by
        // the user), free it.
        //

        if (!Allocator->UserSpecifiedBuffer) {
            PFSVC_FREE(Allocator->Buffer);
        }

        #ifdef PFSVC_DBG

        //
        // Setup the fields so if we try to make allocations after cleaning up
        // an allocator we'll hit an assert.
        //

        Allocator->FreePointer = Allocator->Buffer;
        Allocator->Buffer = NULL;

        #endif // PFSVC_DBG

    }

    return;
}

//
// Routines used to allocate / free path strings efficiently.
//

VOID
PfSvStringAllocatorInitialize (
    PPFSVC_STRING_ALLOCATOR Allocator
    )

/*++

Routine Description:

    Initializes the allocator structure. Must be called before other allocator
    routines.

Arguments:

    Allocator - Pointer to structure.
    
Return Value:

    None.

--*/

{
    //
    // Zero the structure. This effectively initializes the following fields:
    //   Buffer
    //   BufferEnd
    //   FreePointer
    //   MaxHeapAllocs
    //   NumHeapAllocs
    //   LastAllocationSize
    //   UserSpecifiedBuffer
    //

    RtlZeroMemory(Allocator, sizeof(PFSVC_STRING_ALLOCATOR));

    return;
}

DWORD
PfSvStringAllocatorStart (
    IN PPFSVC_STRING_ALLOCATOR Allocator,
    OPTIONAL IN PVOID Buffer,
    IN ULONG MaxSize
    )

/*++

Routine Description:

    Must be called before calling alloc/free on an allocator that has
    been initialized.

Arguments:

    Allocator - Pointer to initialized structure.

    Buffer - If specified, it is the buffer that we will allocate strings
      from. Otherwise a buffer will be allocated. If specified, the user 
      has to free the buffer after the chunk allocator has been cleaned up. 
      It should be aligned right.

    MaxSize - Max valid size of buffer in bytes.
    
Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;

    //
    // We should be initialized and we should not get started twice.
    //

    PFSVC_ASSERT(Allocator->Buffer == NULL);

    //
    // Did the user specify the buffer to use?
    //

    if (Buffer) {

        Allocator->Buffer = Buffer;
        Allocator->UserSpecifiedBuffer = TRUE;

    } else {

        Allocator->Buffer = PFSVC_ALLOC(MaxSize);

        if (!Allocator->Buffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        Allocator->UserSpecifiedBuffer = FALSE;
    }

    Allocator->BufferEnd = (PCHAR) Buffer + (ULONG_PTR) MaxSize;
    Allocator->FreePointer = Buffer;

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

PVOID
PfSvStringAllocatorAllocate (
    PPFSVC_STRING_ALLOCATOR Allocator,
    ULONG NumBytes
    )

/*++

Routine Description:

    Returns a ChunkSize chunk allocated from Allocator. ChunkSize was specified 
    when Allocator was started. If a chunk is return the caller should free it
    to this Allocator before uninitializing the Allocator.

Arguments:

    Allocator - Pointer to started allocator.

    NumBytes - Number of bytes to allocate.
    
Return Value:

    NULL or chunk allocated from Allocator.

--*/

{
    PVOID ReturnChunk;
    PCHAR UpdatedFreePointer;
    PPFSVC_STRING_ALLOCATION_HEADER AllocationHeader;
    ULONG_PTR RealAllocationSize;

    //
    // We should not be trying to make allocations before we start the 
    // allocator.
    //

    PFSVC_ASSERT(Allocator->Buffer);

    //
    // Calculate how much we have to reserve from the buffer to make this
    // allocation. 
    //

    RealAllocationSize = 0;
    RealAllocationSize += sizeof(PFSVC_STRING_ALLOCATION_HEADER);
    RealAllocationSize += NumBytes;
    RealAllocationSize = (ULONG_PTR) PF_ALIGN_UP(RealAllocationSize, _alignof(PFSVC_STRING_ALLOCATION_HEADER));
    
    //
    // We can't allocate from our buffer and have to go to the heap if
    // - We've run out of space.
    // - Allocation size is too big to fit in a USHORT.
    // - It is a 0 sized allocation.
    //

    if (Allocator->FreePointer + RealAllocationSize > Allocator->BufferEnd ||
        NumBytes > PFSVC_STRING_ALLOCATOR_MAX_BUFFER_ALLOCATION_SIZE ||
        NumBytes == 0) {

        //
        // Hit the heap.
        //

        Allocator->MaxHeapAllocs++;

        ReturnChunk = PFSVC_ALLOC(NumBytes);

        if (ReturnChunk) {
            Allocator->NumHeapAllocs++;
        }

    } else {

        AllocationHeader = (PVOID) Allocator->FreePointer;
        AllocationHeader->PrecedingAllocationSize = Allocator->LastAllocationSize;

        PFSVC_ASSERT(RealAllocationSize < USHRT_MAX);
        AllocationHeader->AllocationSize = (USHORT) RealAllocationSize;

        Allocator->FreePointer += RealAllocationSize;
        Allocator->LastAllocationSize = (USHORT) RealAllocationSize;

        //
        // The user's allocation comes right after the allocation header. 
        // (Using pointer arithmetic...)
        //

        ReturnChunk = AllocationHeader + 1;
    }

    return ReturnChunk;
}

VOID
PfSvStringAllocatorFree (
    PPFSVC_STRING_ALLOCATOR Allocator,
    PVOID Allocation
    )

/*++

Routine Description:

    Frees a string allocated from the allocator. This may not make it available
    for use by further allocations from the allocator.

Arguments:

    Allocator - Pointer to started allocator.

    Allocation - Allocation to free.
    
Return Value:

    None.

--*/

{

    //
    // Is this within the preallocated block?
    //

    if ((PUCHAR) Allocation >= Allocator->Buffer &&
        (PUCHAR) Allocation < Allocator->BufferEnd) {

        //
        // Mark this chunk freed.
        //

        *((PWCHAR)Allocation) = PFSVC_STRING_ALLOCATOR_FREED_MAGIC;

    } else {

        //
        // This chunk was allocated from heap.
        //

        PFSVC_ASSERT(Allocator->NumHeapAllocs && Allocator->MaxHeapAllocs);

        Allocator->NumHeapAllocs--;

        PFSVC_FREE(Allocation);
    }

    return;
}

VOID
PfSvStringAllocatorCleanup (
    PPFSVC_STRING_ALLOCATOR Allocator
    )

/*++

Routine Description:

    Cleans up resources associated with the allocator. There should not be 
    any outstanding allocations from the allocator when this function is 
    called.

Arguments:

    Allocator - Pointer to initialized allocator.
    
Return Value:

    None.

--*/

{
    PPFSVC_STRING_ALLOCATION_HEADER AllocationHeader;
    PCHAR NextAllocationHeader;
    WCHAR Magic;

    if (Allocator->Buffer) {

        #ifdef PFSVC_DBG

        //
        // Make sure all real heap allocations have been freed.
        //

        PFSVC_ASSERT(Allocator->NumHeapAllocs == 0);

        //
        // Make sure all allocated strings have been freed.
        //

        for (AllocationHeader = (PVOID) Allocator->Buffer; 
             (PCHAR) AllocationHeader < (PCHAR) Allocator->FreePointer;
             AllocationHeader = (PVOID) NextAllocationHeader) {

            Magic = *((PWCHAR)(AllocationHeader + 1));

            PFSVC_ASSERT(Magic == PFSVC_STRING_ALLOCATOR_FREED_MAGIC);

            //
            // Calculate where the NextAllocationHeader will be.
            //
        
            NextAllocationHeader = (PCHAR) AllocationHeader + 
                                   (ULONG_PTR) AllocationHeader->AllocationSize;
        }

        #endif // PFSVC_DBG

        //
        // If the buffer was allocated by us (and not specified by
        // the user), free it.
        //

        if (!Allocator->UserSpecifiedBuffer) {
            PFSVC_FREE(Allocator->Buffer);
        }

        #ifdef PFSVC_DBG

        //
        // Setup the fields so if we try to make allocations after cleaning up
        // an allocator we'll hit an assert.
        //

        Allocator->FreePointer = Allocator->Buffer;
        Allocator->Buffer = NULL;

        #endif // PFSVC_DBG

    }

    return;
}

//
// Routines that deal with section node structures.
//

VOID
PfSvCleanupSectionNode(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPFSVC_SECTION_NODE SectionNode
    )

/*++

Routine Description:

    This function cleans up a section node structure. It does not free
    the structure itself.

Arguments:

    ScenarioInfo - Pointer to scenario info.

    SectionNode - Pointer to structure.

Return Value:

    None.

--*/

{
    PPFSVC_PAGE_NODE PageNode;
    PLIST_ENTRY ListHead;

    //
    // If there is an allocated file name, free it.
    //

    if (SectionNode->FilePath) {
        PfSvStringAllocatorFree(&ScenarioInfo->PathAllocator, SectionNode->FilePath);
        SectionNode->FilePath = NULL;
    }

    //
    // Free all the page nodes for this section.
    //
    
    while (!IsListEmpty(&SectionNode->PageList)) {
        
        ListHead = RemoveHeadList(&SectionNode->PageList);
        PageNode = CONTAINING_RECORD(ListHead, PFSVC_PAGE_NODE, PageLink);

        PfSvChunkAllocatorFree(&ScenarioInfo->PageNodeAllocator, PageNode);
    }

    //
    // We should not be on a volume node's list if we are being
    // cleaned up.
    //

    PFSVC_ASSERT(IsListEmpty(&SectionNode->SectionVolumeLink));
}

//
// Routines used to sort scenario's section nodes.
//

DWORD
PfSvSortSectionNodesByFirstAccess(
    PLIST_ENTRY SectionNodeList
    )

/*++

Routine Description:

    This routine will sort the specified section node list by first
    access using NewSectionIndex and OrgSectionIndex of the section
    nodes.

Arguments:

    SectionNodeList - Pointer to list of section nodes to be sorted.

Return Value:

    Win32 error code.

--*/

{
    PFSV_SECTNODE_PRIORITY_QUEUE SortQueue;
    PLIST_ENTRY SectHead;
    PPFSVC_SECTION_NODE SectionNode;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    PfSvInitializeSectNodePriorityQueue(&SortQueue);

    DBGPR((PFID,PFSTRC,"PFSVC: SortByFirstAccess(%p)\n", SectionNodeList));

    //
    // We have to sort the section nodes by first access. Remove
    // section nodes from the scenario list and put them on a priority
    // queue. [Bummer, it may have been a little faster if we had
    // built a binary tree and traversed that in the rest of the code]
    //
    
    while (!IsListEmpty(SectionNodeList)) {

        //
        // The section list is sorted by name. It is more likely that
        // we also accessed files by name. So to make the priority
        // queue act better in such cases, remove from the tail of the
        // list to insert into the priority queue.
        //

        SectHead = RemoveTailList(SectionNodeList);
        
        SectionNode = CONTAINING_RECORD(SectHead,
                                        PFSVC_SECTION_NODE,
                                        SectionLink);
        
        PfSvInsertSectNodePriorityQueue(&SortQueue, SectionNode);
    }

    //
    // Remove the section nodes from the priority queue sorted by
    // first access and put them to the tail of the section node list.
    //

    while (SectionNode = PfSvRemoveMinSectNodePriorityQueue(&SortQueue)) {
        InsertTailList(SectionNodeList, &SectionNode->SectionLink);
    }

    ErrorCode = ERROR_SUCCESS;

    DBGPR((PFID,PFSTRC,"PFSVC: SortByFirstAccess(%p)=%x\n", SectionNodeList, ErrorCode));
    
    return ErrorCode;
}

PFSV_SECTION_NODE_COMPARISON_RESULT 
FASTCALL
PfSvSectionNodeComparisonRoutine(
    PPFSVC_SECTION_NODE Element1, 
    PPFSVC_SECTION_NODE Element2 
    )

/*++

Routine Description:

    This routine is called to compare to elements when sorting the
    section nodes array by first access.

Arguments:

    Element1, Element2 - The two elements to compare.

Return Value:

    PFSVC_SECTION_NODE_COMPARISON_RESULT

--*/

{
    //
    // First compare first-access index in the new trace.
    //
    
    if (Element1->NewSectionIndex < Element2->NewSectionIndex) {
        
        return PfSvSectNode1LessThanSectNode2;

    } else if (Element1->NewSectionIndex > Element2->NewSectionIndex) {

        return PfSvSectNode1GreaterThanSectNode2;

    } else {

        //
        // Next compare first-access index in the current scenario
        // file.
        //

        if (Element1->OrgSectionIndex < Element2->OrgSectionIndex) {
            
            return PfSvSectNode1LessThanSectNode2;
           
        } else if (Element1->OrgSectionIndex > Element2->OrgSectionIndex) {
            
            return PfSvSectNode1GreaterThanSectNode2;

        } else {
            
            return PfSvSectNode1EqualToSectNode2;

        }
    }
}

//
// Routines that implement a priority queue used to sort section nodes
// for a scenario.
//

VOID
PfSvInitializeSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue
    )

/*++

Routine Description:

    Initialize a section node priority queue.    

Arguments:

    PriorityQueue - Pointer to the queue.

Return Value:

    None.

--*/

{
    PriorityQueue->Head = NULL;
}

VOID
PfSvInsertSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue,
    PPFSVC_SECTION_NODE NewElement
    )

/*++

Routine Description:

    Insert a section node in the a section node priority queue.

Arguments:

    PriorityQueue - Pointer to the queue.

    NewElement - Pointer to new element.

Return Value:

    None.

--*/

{
    PPFSVC_SECTION_NODE *CurrentPosition;
    
    //
    // Initialize the link fields of NewElement.
    //

    NewElement->LeftChild = NULL;
    NewElement->RightChild = NULL;

    //
    // If the queue is empty, insert this at the head.
    //
    
    if (PriorityQueue->Head == NULL) {
        PriorityQueue->Head = NewElement;
        return;
    }
    
    //
    // If we are less than the current min element, put us at the
    // head.
    //

    if (PfSvSectionNodeComparisonRoutine(NewElement, PriorityQueue->Head) <= 0) {
        
        NewElement->RightChild = PriorityQueue->Head;
        PriorityQueue->Head = NewElement;
        return;
    }

    //
    // Insert this node into the tree rooted at the right child of the
    // head node.
    //

    CurrentPosition = &PriorityQueue->Head->RightChild;

    while (*CurrentPosition) {
        if (PfSvSectionNodeComparisonRoutine(NewElement, *CurrentPosition) <= 0) {
            CurrentPosition = &(*CurrentPosition)->LeftChild;
        } else {
            CurrentPosition = &(*CurrentPosition)->RightChild;    
        }
    }
    
    //
    // We found the place.
    //

    *CurrentPosition = NewElement;
}

PPFSVC_SECTION_NODE
PfSvRemoveMinSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue
    )

/*++

Routine Description:

    Remove the head element of the queue.

Arguments:

    PriorityQueue - Pointer to the queue.

Return Value:

    Pointer to head element of the queue. 
    NULL if queue is empty.

--*/

{
    PPFSVC_SECTION_NODE *CurrentPosition;
    PPFSVC_SECTION_NODE OrgHeadNode;
    PPFSVC_SECTION_NODE NewHeadNode;
    PPFSVC_SECTION_NODE TreeRoot;

    //
    // If the queue is empty return NULL.
    //

    if (PriorityQueue->Head == NULL) {
        return NULL;
    }

    //
    // Save pointer to original head node.
    //

    OrgHeadNode = PriorityQueue->Head;

    //
    // Find the minimum element of the tree rooted at the right child
    // of the head node. CurrentPosition points to the link of the
    // parent to the smaller child.
    //

    TreeRoot = OrgHeadNode->RightChild;

    CurrentPosition = &TreeRoot;

    while (*CurrentPosition && (*CurrentPosition)->LeftChild) {
        CurrentPosition = &(*CurrentPosition)->LeftChild;
    }

    NewHeadNode = *CurrentPosition;

    //
    // Check if there is really a new head node that we have to remove
    // from its current position.
    //
    
    if (NewHeadNode) {
  
        //
        // We are removing this node to put it at the head. In its
        // place, we'll put its right child. Since we know that this
        // node does not have a left child, that's all we have to do.
        //
        
        *CurrentPosition = NewHeadNode->RightChild;

        //
        // Set the tree rooted at the head's right child.
        //
        
        NewHeadNode->RightChild = TreeRoot;
    }

    //
    // Set the new head.
    //

    PriorityQueue->Head = NewHeadNode;

    //
    // Return the original head node.
    //

    return OrgHeadNode;
}

//
// Implementation of the Nt path to Dos path translation API.
//

DWORD
PfSvBuildNtPathTranslationList(
    PNTPATH_TRANSLATION_LIST *NtPathTranslationList
    )

/*++

Routine Description:

    This routine is called to build a list that can be used to
    translate Nt paths to Dos paths. If successful, the returned list
    should be freed by calling PfSvFreeNtPathTranslationList.

Arguments:

    TranslationList - Pointer to where a pointer to the built
      translation list is going to be put.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    ULONG VolumeNameLength;
    ULONG VolumeNameMaxLength;
    PWCHAR VolumeName;
    ULONG NTDevicePathMaxLength;
    ULONG NTDevicePathLength;
    PWCHAR NTDevicePath;
    HANDLE FindVolumeHandle;
    ULONG RequiredLength;
    ULONG VolumePathNamesLength;
    WCHAR *VolumePathNames;
    ULONG MountPathNameLength;
    WCHAR *MountPathName;
    ULONG ShortestMountPathLength;
    WCHAR *ShortestMountPathName;
    ULONG NumMountPoints;
    ULONG NumResizes;
    BOOL Result;
    ULONG NumChars;
    ULONG Length;
    PNTPATH_TRANSLATION_LIST TranslationList;
    PNTPATH_TRANSLATION_ENTRY TranslationEntry;
    PNTPATH_TRANSLATION_ENTRY NextTranslationEntry;
    ULONG AllocationSize;
    PUCHAR DestinationPointer;
    ULONG CopySize;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;  
    PLIST_ENTRY InsertPosition;
    BOOLEAN TrimmedTerminatingSlash;

    //
    // Initialize locals.
    //

    FindVolumeHandle = INVALID_HANDLE_VALUE;
    VolumePathNames = NULL;
    VolumePathNamesLength = 0;
    VolumeName = NULL;
    VolumeNameMaxLength = 0;
    NTDevicePath = NULL;
    NTDevicePathMaxLength = 0;   
    TranslationList = NULL;

    DBGPR((PFID,PFTRC,"PFSVC: BuildTransList()\n"));

    //
    // Allocate intermediate buffers.
    //

    Length = MAX_PATH + 1;

    VolumeName = PFSVC_ALLOC(Length * sizeof(WCHAR));
    NTDevicePath = PFSVC_ALLOC(Length * sizeof(WCHAR));

    if (!VolumeName || !NTDevicePath) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    VolumeNameMaxLength = Length;  
    NTDevicePathMaxLength = Length;


    //
    // Allocate and initialize a translation list.
    //

    TranslationList = PFSVC_ALLOC(sizeof(NTPATH_TRANSLATION_LIST));
    
    if (!TranslationList) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    InitializeListHead(TranslationList);

    //
    // Start enumerating the volumes.
    //

    FindVolumeHandle = FindFirstVolume(VolumeName, VolumeNameMaxLength);
    
    if (FindVolumeHandle == INVALID_HANDLE_VALUE) {
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    VolumeNameLength = wcslen(VolumeName);

    do {

        //
        // Get list of where this volume is mounted.
        //

        NumResizes = 0;

        do {
            
            Result = GetVolumePathNamesForVolumeName(VolumeName, 
                                                     VolumePathNames, 
                                                     VolumePathNamesLength, 
                                                     &RequiredLength);
            
            if (Result) {
                
                //
                // We got the mount points.
                //
                
                break;
            }
            
            //
            // Check why we failed.
            //

            ErrorCode = GetLastError();
            
            if (ErrorCode != ERROR_MORE_DATA) {
                
                //
                // A real error...
                //
                
                goto cleanup;
            } 

            //
            // We need to increase the size of our buffer. If there is
            // an existing buffer, first free it.
            //

            if (VolumePathNames) {
                PFSVC_FREE(VolumePathNames);
                VolumePathNames = NULL;
                VolumePathNamesLength = 0;
            }
            
            //
            // Try to allocate a new buffer.
            //
            
            VolumePathNames = PFSVC_ALLOC(RequiredLength * sizeof(WCHAR));
            
            if (!VolumePathNames) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            VolumePathNamesLength = RequiredLength;

            //
            // Retry with the resized buffer but make sure we don't
            // loop forever!
            //

            NumResizes++;
            if (NumResizes > 1000) {
                ErrorCode = ERROR_INVALID_FUNCTION;
                goto cleanup;
            }

        } while (TRUE);

        //
        // Loop through the mount points to find the shortest one. It
        // is possible that the depth of it is more.
        //

        MountPathName = VolumePathNames;
        NumMountPoints = 0;

        ShortestMountPathName = NULL;
        ShortestMountPathLength = ULONG_MAX;

        while (*MountPathName) {

            MountPathNameLength = wcslen(MountPathName);

            if (MountPathNameLength < ShortestMountPathLength) {
                ShortestMountPathName = MountPathName;
                ShortestMountPathLength = MountPathNameLength;
            }

            NumMountPoints++;

            //
            // Update the pointer to next mount point path.
            //

            MountPathName += MountPathNameLength;
        }

        //
        // Check if we got a mount point path.
        //

        if (ShortestMountPathName == NULL) {

            //
            // Skip this volume.
            //

            continue;
        }

        //
        // Remove the terminating slash if there is one.
        //
        
        if (ShortestMountPathName[ShortestMountPathLength - 1] == L'\\') {
            ShortestMountPathName[ShortestMountPathLength - 1] = 0;
            ShortestMountPathLength--;
        }

        //
        // Get NT device that is the target of the volume link in
        // Win32 object namespace. We get the dos device name by
        // trimming the first 4 characters [i.e. \\?\] of the
        // VolumeName. Also trim the \ at the very end of the volume
        // name.
        //

        if (VolumeNameLength <= 4) {
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }

        if (VolumeName[VolumeNameLength - 1] == L'\\') {
            VolumeName[VolumeNameLength - 1] = 0;
            TrimmedTerminatingSlash = TRUE;
        } else {
            TrimmedTerminatingSlash = FALSE;
        }

        NumChars = QueryDosDevice(&VolumeName[4], 
                                  NTDevicePath, 
                                  NTDevicePathMaxLength);
        
        if (TrimmedTerminatingSlash) {
            VolumeName[VolumeNameLength - 1] = L'\\';
        }

        if (NumChars == 0) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
        
        //
        // We are interested only in the current mapping.
        //
        
        NTDevicePathLength = wcslen(NTDevicePath);
        
        if (NTDevicePathLength == 0) {
            
            //
            // Skip this volume.
            //
            
            continue;
        }

        //
        // Remove terminating slash if there is one.
        //
        
        if (NTDevicePath[NTDevicePathLength - 1] == L'\\') {
            NTDevicePath[NTDevicePathLength - 1] = 0;
            NTDevicePathLength--;
        }
        
        //
        // Allocate a translation entry big enough to contain both
        // path names and the volume string.
        //

        AllocationSize = sizeof(NTPATH_TRANSLATION_ENTRY);
        AllocationSize += (ShortestMountPathLength + 1) * sizeof(WCHAR);
        AllocationSize += (NTDevicePathLength + 1) * sizeof(WCHAR);
        AllocationSize += (VolumeNameLength + 1) * sizeof(WCHAR);

        TranslationEntry = PFSVC_ALLOC(AllocationSize);
        
        if (!TranslationEntry) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        DestinationPointer = (PUCHAR) TranslationEntry;
        DestinationPointer += sizeof(NTPATH_TRANSLATION_ENTRY);

        //
        // Copy the NT path name and the terminating NUL.
        //

        TranslationEntry->NtPrefix = (PVOID) DestinationPointer;
        TranslationEntry->NtPrefixLength = NTDevicePathLength;

        CopySize = (NTDevicePathLength + 1) * sizeof(WCHAR);
        RtlCopyMemory(DestinationPointer, NTDevicePath, CopySize);
        DestinationPointer += CopySize;

        //
        // Copy the DOS mount point name and the terminating NUL.
        //

        TranslationEntry->DosPrefix = (PVOID) DestinationPointer;
        TranslationEntry->DosPrefixLength = ShortestMountPathLength;

        CopySize = (ShortestMountPathLength + 1) * sizeof(WCHAR);
        RtlCopyMemory(DestinationPointer, ShortestMountPathName, CopySize);
        DestinationPointer += CopySize;

        //
        // Copy the volume name and the terminating NUL.
        //

        TranslationEntry->VolumeName = (PVOID) DestinationPointer;
        TranslationEntry->VolumeNameLength = VolumeNameLength;

        CopySize = (VolumeNameLength + 1) * sizeof(WCHAR);
        RtlCopyMemory(DestinationPointer, VolumeName, CopySize);
        DestinationPointer += CopySize;
        
        //
        // Find the position for this entry in the sorted translation
        // list.
        //

        HeadEntry = TranslationList;
        NextEntry = HeadEntry->Flink;
        InsertPosition = HeadEntry;

        while (NextEntry != HeadEntry) {
            
            NextTranslationEntry = CONTAINING_RECORD(NextEntry,
                                                     NTPATH_TRANSLATION_ENTRY,
                                                     Link);
            
            if (_wcsicmp(TranslationEntry->NtPrefix, 
                         NextTranslationEntry->NtPrefix) <= 0) {
                break;
            }
            
            InsertPosition = NextEntry;
            NextEntry = NextEntry->Flink;
        }

        //
        // Insert it after the found position.
        //

        InsertHeadList(InsertPosition, &TranslationEntry->Link);

    } while (FindNextVolume(FindVolumeHandle, VolumeName, VolumeNameMaxLength));
    
    //
    // We will break out of the loop when FindNextVolume does not
    // return success. Check if it failed for a reason other than that
    // we have enumerated all volumes.
    //

    ErrorCode = GetLastError();   

    if (ErrorCode != ERROR_NO_MORE_FILES) {
        goto cleanup;
    }

    //
    // Set return value.
    //

    *NtPathTranslationList = TranslationList;

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:
    
    if (FindVolumeHandle != INVALID_HANDLE_VALUE) {
        FindVolumeClose(FindVolumeHandle);
    }

    if (VolumePathNames) {
        PFSVC_FREE(VolumePathNames);
    }

    if (ErrorCode != ERROR_SUCCESS) {
        if (TranslationList) {
            PfSvFreeNtPathTranslationList(TranslationList); 
        }
    }

    if (VolumeName) {
        PFSVC_FREE(VolumeName);
    }

    if (NTDevicePath) {
        PFSVC_FREE(NTDevicePath);
    }

    DBGPR((PFID,PFTRC,"PFSVC: BuildTransList()=%x,%p\n", ErrorCode, TranslationList));

    return ErrorCode;
}

VOID
PfSvFreeNtPathTranslationList(
    PNTPATH_TRANSLATION_LIST TranslationList
    )

/*++

Routine Description:

    This routine is called to free a translation list returned by
    PfSvBuildNtPathTranslationList.

Arguments:

    TranslationList - Pointer to list to free.

Return Value:

    None.

--*/

{
    PLIST_ENTRY HeadEntry;
    PNTPATH_TRANSLATION_ENTRY TranslationEntry;

    DBGPR((PFID,PFTRC,"PFSVC: FreeTransList(%p)\n", TranslationList));

    //
    // Free all entries in the list.
    //

    while (!IsListEmpty(TranslationList)) {

        HeadEntry = RemoveHeadList(TranslationList);
        
        TranslationEntry = CONTAINING_RECORD(HeadEntry,
                                             NTPATH_TRANSLATION_ENTRY,
                                             Link);

        PFSVC_FREE(TranslationEntry);
    }

    //
    // Free the list itself.
    //

    PFSVC_FREE(TranslationList);
}

DWORD 
PfSvTranslateNtPath(
    PNTPATH_TRANSLATION_LIST TranslationList,
    WCHAR *NtPath,
    ULONG NtPathLength,
    PWCHAR *DosPathBuffer,
    PULONG DosPathBufferSize
    )

/*++

Routine Description:

    This routine is called to free a translation list returned by
    PfSvBuildNtPathTranslationList. Note that it may not be possible to
    translate all Nt path's to a Dos path.

Arguments:

    TranslationList - Pointer to list built by PfSvBuildNtPathTranslationList.

    NtPath - Path to translate.

    NtPathLength - Length of NtPath in characters excluding terminating NUL.

    DosPathBuffer - Buffer to put the translation into. If it is NULL
      or not big enough it will get reallocated. If a buffer is passed
      in, it should be allocated by PFSVC_ALLOC. It is the callers
      responsibility to free the buffer with PFSVC_FREE when done.

    DosPathBufferSize - Size of DosPathBuffer in bytes. Updated if the
      buffer is reallocated.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    PNTPATH_TRANSLATION_ENTRY CurrentTranslationEntry;
    PNTPATH_TRANSLATION_ENTRY FoundTranslationEntry;
    PFSV_PREFIX_COMPARISON_RESULT ComparisonResult;
    ULONG RequiredSize;

    //
    // Initialize locals.
    //

    FoundTranslationEntry = NULL;

    DBGPR((PFID,PFPATH,"PFSVC: TranslateNtPath(%ws)\n", NtPath));

    //
    // Walk through the sorted translation list to find an entry that
    // applies.
    //

    HeadEntry = TranslationList;
    NextEntry = HeadEntry->Flink;

    while (NextEntry != HeadEntry) {
        
        CurrentTranslationEntry = CONTAINING_RECORD(NextEntry,
                                                    NTPATH_TRANSLATION_ENTRY,
                                                    Link);
        
        //
        // Do a case insensitive comparison.
        //

        ComparisonResult = PfSvComparePrefix(NtPath,
                                             NtPathLength,
                                             CurrentTranslationEntry->NtPrefix,
                                             CurrentTranslationEntry->NtPrefixLength,
                                             FALSE);

        if (ComparisonResult == PfSvPrefixIdentical) {
            
            //
            // Check to see if the character in NtPath after the
            // prefix is a path seperator [i.e. '\']. Otherwise we may
            // match \Device\CdRom10\DirName\FileName to \Device\Cdrom1.
            //
            
            if (NtPathLength == CurrentTranslationEntry->NtPrefixLength ||
                NtPath[CurrentTranslationEntry->NtPrefixLength] == L'\\') {

                //
                // We found a translation entry that applies to us.
                //
                
                FoundTranslationEntry = CurrentTranslationEntry;
                break;
            }

        } else if (ComparisonResult == PfSvPrefixGreaterThan) {

            //
            // Since the translation list is sorted in increasing
            // order, following entries will also be greater than
            // NtPath.
            //

            FoundTranslationEntry = NULL;
            break;
        }
        
        //
        // Continue looking for a matching prefix.
        //
                                         
        NextEntry = NextEntry->Flink;
    }

    //
    // If we could not find an entry that applies we cannot translate
    // the path.
    //

    if (FoundTranslationEntry == NULL) {
        ErrorCode = ERROR_PATH_NOT_FOUND;
        goto cleanup;
    }

    //
    // Calculate required size: We will replace the NtPrefix with
    // DosPrefix. Don't forget the terminating NUL character.
    //

    RequiredSize = (NtPathLength + 1) * sizeof(WCHAR);
    RequiredSize += (FoundTranslationEntry->DosPrefixLength * sizeof(WCHAR));
    RequiredSize -= (FoundTranslationEntry->NtPrefixLength * sizeof(WCHAR));

    if (RequiredSize > (*DosPathBufferSize)) {

        //
        // Reallocate the buffer. First free it if there is one.
        //

        if (*DosPathBufferSize) {
            PFSVC_ASSERT(*DosPathBuffer);
            PFSVC_FREE(*DosPathBuffer);
            (*DosPathBuffer) = NULL;
            (*DosPathBufferSize) = 0;
        }

        PFSVC_ASSERT((*DosPathBuffer) == NULL);

        (*DosPathBuffer) = PFSVC_ALLOC(RequiredSize);
        
        if (!(*DosPathBuffer)) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        (*DosPathBufferSize) = RequiredSize;
    }

    //
    // We should have enough room now.
    //

    PFSVC_ASSERT(RequiredSize <= (*DosPathBufferSize));

    //
    // Copy the DosPrefix.
    //

    wcscpy((*DosPathBuffer), FoundTranslationEntry->DosPrefix);
    
    //
    // Concatenate the remaining path.
    //

    wcscat((*DosPathBuffer), NtPath + CurrentTranslationEntry->NtPrefixLength);

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    DBGPR((PFID,PFPATH,"PFSVC: TranslateNtPath(%ws)=%x,%ws\n",
           NtPath,ErrorCode,(ErrorCode==ERROR_SUCCESS)?(*DosPathBuffer):L"Failed"));

    return ErrorCode;
}

//
// Implementation of the path list API.
//

VOID
PfSvInitializePathList(
    PPFSVC_PATH_LIST PathList,
    OPTIONAL IN PPFSVC_STRING_ALLOCATOR PathAllocator,
    IN BOOLEAN CaseSensitive
    )

/*++

Routine Description:

    This function initializes a path list structure.

Arguments:

    PathList - Pointer to structure.

    PathAllocator - If specified path allocations will be made from it.

    CaseSenstive - Whether list will be case senstive.

Return Value:

    None.

--*/

{
    InitializeListHead(&PathList->InOrderList);
    InitializeListHead(&PathList->SortedList);
    PathList->NumPaths = 0;
    PathList->TotalLength = 0;
    PathList->Allocator = PathAllocator;
    PathList->CaseSensitive = CaseSensitive;
}

VOID
PfSvCleanupPathList(
    PPFSVC_PATH_LIST PathList
    )

/*++

Routine Description:

    This function cleans up a path list structure. It does not free
    the structure itself. The structure should have been initialized
    by PfSvInitializePathList.

Arguments:

    PathList - Pointer to structure.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PPFSVC_PATH Path;

    while (!IsListEmpty(&PathList->InOrderList)) {

        PFSVC_ASSERT(PathList->NumPaths);
        PathList->NumPaths--;

        ListEntry = RemoveHeadList(&PathList->InOrderList);
        Path = CONTAINING_RECORD(ListEntry,
                                 PFSVC_PATH,
                                 InOrderLink);

        if (PathList->Allocator) {
            PfSvStringAllocatorFree(PathList->Allocator, Path);
        } else {
            PFSVC_FREE(Path);
        }
    }
}

BOOLEAN
PfSvIsInPathList(
    PPFSVC_PATH_LIST PathList,
    WCHAR *Path,
    ULONG PathLength
    )

/*++

Routine Description:

    This function checks if the specified path is already in the path
    list. 

Arguments:

    PathList - Pointer to list.

    Path - Path to look for. Does not have to be NUL terminated.
      
    PathLength - Length of Path in characters excluding NUL if there
      is one.

Return Value:

    Win32 error code.

--*/

{
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    PPFSVC_PATH PathEntry;
    INT ComparisonResult;
    BOOLEAN PathIsInPathList;

    //
    // Walk through the list.
    //

    HeadEntry = &PathList->SortedList;
    NextEntry = HeadEntry->Flink;

    while (NextEntry != HeadEntry) {

        PathEntry = CONTAINING_RECORD(NextEntry,
                                      PFSVC_PATH,
                                      SortedLink);
        
        if (PathList->CaseSensitive) {
            ComparisonResult = wcsncmp(Path,
                                       PathEntry->Path,
                                       PathLength);
        } else {
            ComparisonResult = _wcsnicmp(Path,
                                         PathEntry->Path,
                                         PathLength);
        }

        //
        // Adjust comparison result so we don't match "abcde" to
        // "abcdefg". If string comparison says the first PathLength
        // characters match, check to see if PathEntry's length is
        // longer, which would make it "greater" than the new path.
        //

        if (ComparisonResult == 0 && PathEntry->Length != PathLength) {
            
            //
            // The string comparison would not say The path entry's
            // path is equal to path if its length was smaller.
            //
            
            PFSVC_ASSERT(PathEntry->Length > PathLength);
            
            //
            // Path is actually less than this path entry.
            //

            ComparisonResult = -1; 
        }

        //
        // Based on comparison result determine what to do:
        //

        if (ComparisonResult == 0) {

            //
            // We found it.
            //
            
            PathIsInPathList = TRUE;
            goto cleanup;

        } else if (ComparisonResult < 0) {
            
            //
            // We will be less than the rest of the strings in the
            // list after this too.
            //
            
            PathIsInPathList = FALSE;
            goto cleanup;
        }

        //
        // Continue looking for the path or an available position.
        //

        NextEntry = NextEntry->Flink;
    }

    //
    // If we came here, we could not find the path in the list.
    //

    PathIsInPathList = FALSE;

 cleanup:
    
    return PathIsInPathList;
}

DWORD
PfSvAddToPathList(
    PPFSVC_PATH_LIST PathList,  
    WCHAR *Path,
    ULONG PathLength
    )

/*++

Routine Description:

    This function adds a path to a path list. If the path already
    exists in the list, it is not added again.

Arguments:

    PathList - Pointer to list.

    Path - Path to add. Does not need to be NUL terminated.
      
    PathLength - Length of Path in characters excluding NUL if there
      is one.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;
    PPFSVC_PATH PathEntry;
    PPFSVC_PATH NewPathEntry;
    INT ComparisonResult;
    ULONG AllocationSize;

    //
    // Initialize locals.
    //

    NewPathEntry = NULL;
    
    //
    // Walk through the list to check if path is already in the list,
    // or to find where it should be so we can insert it there.
    //

    HeadEntry = &PathList->SortedList;
    NextEntry = HeadEntry->Flink;

    while (NextEntry != HeadEntry) {

        PathEntry = CONTAINING_RECORD(NextEntry,
                                      PFSVC_PATH,
                                      SortedLink);
        
        if (PathList->CaseSensitive) {
            ComparisonResult = wcsncmp(Path,
                                       PathEntry->Path,
                                       PathLength);
        } else {
            ComparisonResult = _wcsnicmp(Path,
                                         PathEntry->Path,
                                         PathLength);
        }

        //
        // Adjust comparison result so we don't match "abcde" to
        // "abcdefg". If string comparison says the first PathLength
        // characters match, check to see if PathEntry's length is
        // longer, which would make it "greater" than the new path.
        //

        if (ComparisonResult == 0 && PathEntry->Length != PathLength) {
            
            //
            // The string comparison would not say The path entry's
            // path is equal to path if its length was smaller.
            //
            
            PFSVC_ASSERT(PathEntry->Length > PathLength);
            
            //
            // Path is actually less than this path entry.
            //

            ComparisonResult = -1; 
        }

        //
        // Based on comparison result determine what to do:
        //

        if (ComparisonResult == 0) {

            //
            // The path already exists in the list.
            //
            
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;

        } else if (ComparisonResult < 0) {
            
            //
            // We will be less than the rest of the strings in the
            // list after this too. We should be inserted before this
            // one.
            //
            
            break;
        }

        //
        // Continue looking for the path or an available position.
        //

        NextEntry = NextEntry->Flink;
    }

    //
    // We will insert the path before NextEntry. First create an entry
    // we can insert.
    //
    
    AllocationSize = sizeof(PFSVC_PATH);
    AllocationSize += PathLength * sizeof(WCHAR);
    
    //
    // Note that PFSVC_PATH already contains space for the terminating
    // NUL character.
    //

    if (PathList->Allocator) {
        NewPathEntry = PfSvStringAllocatorAllocate(PathList->Allocator, AllocationSize);
    } else {
        NewPathEntry = PFSVC_ALLOC(AllocationSize);
    }
    
    if (!NewPathEntry) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Copy path and terminate it.
    //

    NewPathEntry->Length = PathLength;
    RtlCopyMemory(NewPathEntry->Path,
                  Path,
                  PathLength * sizeof(WCHAR));
    
    NewPathEntry->Path[PathLength] = 0;
    
    //
    // Insert it into the sorted list before the current entry.
    //
    
    InsertTailList(NextEntry, &NewPathEntry->SortedLink);
    
    //
    // Insert it at the end of in-order list.
    //
    
    InsertTailList(&PathList->InOrderList, &NewPathEntry->InOrderLink);
    
    PathList->NumPaths++;
    PathList->TotalLength += NewPathEntry->Length;

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:
    
    if (ErrorCode != ERROR_SUCCESS) {
        if (NewPathEntry) {
            if (PathList->Allocator) {
                PfSvStringAllocatorFree(PathList->Allocator, NewPathEntry);
            } else {
                PFSVC_FREE(NewPathEntry);
            }
        }
    }

    return ErrorCode;
}

PPFSVC_PATH
PfSvGetNextPathSorted (
    PPFSVC_PATH_LIST PathList,
    PPFSVC_PATH CurrentPath
    )

/*++

Routine Description:

    This function is used to walk through paths in a path list in
    lexically (case insensitive) sorted order.

Arguments:

    PathList - Pointer to list.

    CurrentPath - The current path entry. The function will return the 
      next entry in the list. If this is NULL, the first entry in the
      list is returned.

Return Value:

    NULL - There are no more entries in the list.
    
    or Pointer to next path in the list.

--*/

{
    PLIST_ENTRY EndOfList;
    PLIST_ENTRY NextEntry;
    PPFSVC_PATH NextPath;
    
    //
    // Initialize locals.
    //
   
    EndOfList = &PathList->SortedList;

    //
    // Determine NextEntry based on whether CurrentPath is specified.
    //

    if (CurrentPath) {
        NextEntry = CurrentPath->SortedLink.Flink;
    } else {
        NextEntry = PathList->SortedList.Flink;
    }

    //
    // Check if the NextEntry points to the end of list.
    //

    if (NextEntry == EndOfList) {
        NextPath = NULL;
    } else {
        NextPath = CONTAINING_RECORD(NextEntry,
                                     PFSVC_PATH,
                                     SortedLink);
    }
    
    return NextPath;
}

PPFSVC_PATH
PfSvGetNextPathInOrder (
    PPFSVC_PATH_LIST PathList,
    PPFSVC_PATH CurrentPath
    )

/*++

Routine Description:

    This function is used to walk through paths in a path list in
    the order they were inserted into the list.

Arguments:

    PathList - Pointer to list.

    CurrentPath - The current path entry. The function will return the 
      next entry in the list. If this is NULL, the first entry in the
      list is returned.

Return Value:

    NULL - There are no more entries in the list.
    
    or Pointer to next path in the list.

--*/

{
    PLIST_ENTRY EndOfList;
    PLIST_ENTRY NextEntry;
    PPFSVC_PATH NextPath;
    
    //
    // Initialize locals.
    //
   
    EndOfList = &PathList->InOrderList;

    //
    // Determine NextEntry based on whether CurrentPath is specified.
    //

    if (CurrentPath) {
        NextEntry = CurrentPath->InOrderLink.Flink;
    } else {
        NextEntry = PathList->InOrderList.Flink;
    }

    //
    // Check if the NextEntry points to the end of list.
    //

    if (NextEntry == EndOfList) {
        NextPath = NULL;
    } else {
        NextPath = CONTAINING_RECORD(NextEntry,
                                     PFSVC_PATH,
                                     InOrderLink);
    }
    
    return NextPath;
}

//
// Routines to build the list of files accessed by the boot loader.
//

DWORD
PfSvBuildBootLoaderFilesList (
    PPFSVC_PATH_LIST PathList
    )

/*++

Routine Description:

    This function attempts to add the list of files loaded in the boot
    loader to the specified file list.

Arguments:

    PathList - Pointer to initialized list.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    SC_HANDLE ScHandle;
    SC_HANDLE ServiceHandle;
    LPENUM_SERVICE_STATUS_PROCESS EnumBuffer;
    LPENUM_SERVICE_STATUS_PROCESS ServiceInfo;
    ULONG EnumBufferMaxSize;
    ULONG NumResizes;
    BOOL Result;
    ULONG RequiredAdditionalSize;
    ULONG RequiredSize;
    ULONG NumServicesEnumerated;
    ULONG ResumeHandle;
    ULONG ServiceIdx;
    LPQUERY_SERVICE_CONFIG ServiceConfigBuffer;
    ULONG ServiceConfigBufferMaxSize;
    WCHAR FilePath[MAX_PATH + 1];
    ULONG FilePathLength;
    ULONG SystemDirLength;
    ULONG RequiredLength;
    WCHAR *KernelName;
    WCHAR *HalName;
    WCHAR *SystemHive;
    WCHAR *SoftwareHive;
    
    //
    // Initialize locals.
    //
    
    ScHandle = NULL;
    EnumBuffer = NULL;
    EnumBufferMaxSize = 0;
    NumServicesEnumerated = 0;
    ServiceConfigBuffer = 0;
    ServiceConfigBufferMaxSize = 0;
    KernelName = L"ntoskrnl.exe";
    HalName = L"hal.dll";
    SystemHive = L"config\\system";
    SoftwareHive = L"config\\software";

    //
    // Add kernel & hal to known files list:
    //

    //
    // Get path to system directory.
    // 

    SystemDirLength = GetSystemDirectory(FilePath, MAX_PATH);

    if (!SystemDirLength) {
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    //
    // Append a trailing \.
    //

    if (SystemDirLength + 1 < MAX_PATH) {
        FilePath[SystemDirLength] = '\\';
        SystemDirLength++;
        FilePath[SystemDirLength] = 0;
    } else {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Append kernel name and add it to the list.
    //

    FilePathLength = SystemDirLength;
    FilePathLength += wcslen(KernelName);
    
    if (FilePathLength < MAX_PATH) {
        wcscat(FilePath, KernelName);
        ErrorCode = PfSvAddBootImageAndImportsToList(PathList, 
                                                     FilePath,
                                                     FilePathLength);
        
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }
    
    //
    // Roll FilePath back to system directory. Append hal name and add
    // it to the list.
    //

    FilePathLength = SystemDirLength;
    FilePathLength += wcslen(HalName);
    
    if (FilePathLength < MAX_PATH) {
        FilePath[SystemDirLength] = 0;
        wcscat(FilePath, HalName);
        ErrorCode = PfSvAddBootImageAndImportsToList(PathList, 
                                                  FilePath,
                                                  FilePathLength);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }
    
    //
    // Roll FilePath back to system directory. Append system hive path
    // and add it to the list.
    //

    FilePathLength = SystemDirLength;
    FilePathLength += wcslen(SystemHive);
    
    if (FilePathLength < MAX_PATH) {
        FilePath[SystemDirLength] = 0;
        wcscat(FilePath, SystemHive);
        
        ErrorCode = PfSvAddToPathList(PathList,
                                   FilePath,
                                   FilePathLength);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Note that we will use FilePath & FilePathLength to add the
    // software hive after we add all the other boot loader files. The
    // software hive is not accessed in the boot loader, but during
    // boot. It is not put into the boot scenario file, however. We
    // don't want to mix it in with the boot loader files, so we don't
    // hurt the boot loader performance.
    //

    //
    // Add file paths for NLS data & fonts loaded by the boot loader.
    //

    PfSvGetBootLoaderNlsFileNames(PathList);

    //
    // Open service controller.
    //

    ScHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    
    if (ScHandle == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Get the list of boot services we are interested in.
    //
    
    NumResizes = 0;
    
    do {

        //
        // We want to get all of services at one call.
        //

        ResumeHandle = 0;

        Result = EnumServicesStatusEx (ScHandle,
                                       SC_ENUM_PROCESS_INFO,
                                       SERVICE_DRIVER,
                                       SERVICE_ACTIVE,
                                       (PVOID)EnumBuffer,
                                       EnumBufferMaxSize,
                                       &RequiredAdditionalSize,
                                       &NumServicesEnumerated,
                                       &ResumeHandle,
                                       NULL);
        
        if (Result) {

            //
            // We got it.
            //
            
            break;
        }

        //
        // Check why our call failed.
        //

        ErrorCode = GetLastError();

        //
        // If we failed for some other reason than that our buffer was
        // too small, we cannot go on.
        //

        if (ErrorCode != ERROR_MORE_DATA) {
            goto cleanup;
        }

        //
        // Free the old buffer if it exists, and allocate a bigger one.
        //

        RequiredSize = EnumBufferMaxSize + RequiredAdditionalSize;

        if (EnumBuffer) {
            PFSVC_FREE(EnumBuffer);
            EnumBuffer = NULL;
            EnumBufferMaxSize = 0;
        }
        
        EnumBuffer = PFSVC_ALLOC(RequiredSize);
        
        if (EnumBuffer == NULL) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        
        EnumBufferMaxSize = RequiredSize;

        //
        // Make sure we don't loop for ever.
        //

        NumResizes++;
        if (NumResizes > 100) {
            ErrorCode = ERROR_INVALID_FUNCTION;
            goto cleanup;
        }

    } while (TRUE);

    //
    // Identify the enumerated services that may be loaded by the boot
    // loader.
    //

    for (ServiceIdx = 0; ServiceIdx < NumServicesEnumerated; ServiceIdx++) {
        
        ServiceInfo = &EnumBuffer[ServiceIdx];

        //
        // Open the service to get its configuration info.
        //

        ServiceHandle = OpenService(ScHandle, 
                                    ServiceInfo->lpServiceName,
                                    SERVICE_QUERY_CONFIG);

        if (ServiceHandle == NULL) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
        
        //
        // Query service configuration.
        //

        NumResizes = 0;
        
        do {

            Result = QueryServiceConfig(ServiceHandle,
                                        ServiceConfigBuffer,
                                        ServiceConfigBufferMaxSize,
                                        &RequiredSize);

            if (Result) {
                
                //
                // We got it.
                //
                
                break;
            }
        
            ErrorCode = GetLastError();
            
            if (ErrorCode != ERROR_INSUFFICIENT_BUFFER) {
                
                //
                // This is a real error.
                //
                
                goto cleanup;
            }

            //
            // Resize the buffer and try again.
            //

            if (ServiceConfigBuffer) {
                PFSVC_FREE(ServiceConfigBuffer);
                ServiceConfigBuffer = NULL;
                ServiceConfigBufferMaxSize = 0;
            }

            ServiceConfigBuffer = PFSVC_ALLOC(RequiredSize);
            
            if (ServiceConfigBuffer == NULL) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            ServiceConfigBufferMaxSize = RequiredSize;

            //
            // Make sure we don't loop forever.
            //

            NumResizes++;
            if (NumResizes > 100) {
                ErrorCode = ERROR_INVALID_FUNCTION;
                goto cleanup;
            }

        } while (TRUE);
        
        //
        // We are interested in this service only if it starts as a
        // boot driver or if it is a file system.
        //

        if (ServiceConfigBuffer->dwStartType == SERVICE_BOOT_START ||
            ServiceConfigBuffer->dwServiceType == SERVICE_FILE_SYSTEM_DRIVER) {

            //
            // Try to locate the real service binary path.
            //

            ErrorCode = PfSvGetBootServiceFullPath(ServiceInfo->lpServiceName,
                                            ServiceConfigBuffer->lpBinaryPathName,
                                            FilePath,
                                            MAX_PATH,
                                            &RequiredLength);
            
            if (ErrorCode == ERROR_SUCCESS) {
                PfSvAddBootImageAndImportsToList(PathList, 
                                                 FilePath,
                                                 wcslen(FilePath));
            }
        }
        
        //
        // Close the handle and continue.
        //
        
        CloseServiceHandle(ServiceHandle);
    }
    
    //
    // Roll FilePath back to system directory. Append software hive path
    // and add it to the list.
    //

    FilePathLength = SystemDirLength;
    FilePathLength += wcslen(SoftwareHive);
    
    if (FilePathLength < MAX_PATH) {
        FilePath[SystemDirLength] = 0;
        wcscat(FilePath, SoftwareHive);
        
        ErrorCode = PfSvAddToPathList(PathList,
                                   FilePath,
                                   FilePathLength);

        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

    } else {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ScHandle) {
        CloseServiceHandle(ScHandle);
    }
    
    if (EnumBuffer) {
        PFSVC_FREE(EnumBuffer);
    }

    if (ServiceConfigBuffer) {
        PFSVC_FREE(ServiceConfigBuffer);
    }

    return ErrorCode;
}

DWORD 
PfSvAddBootImageAndImportsToList(
    PPFSVC_PATH_LIST PathList,
    WCHAR *FilePath,
    ULONG FilePathLength
    )

/*++

Routine Description:

    This function attempts to add the image file whose fully qualified
    path is in FilePath as well as the modules it imports from to the
    file list, if those modules can be located.

    NOTE: Ntoskrnl.exe and Hal.dll are special cased out and not added
    to the file list, since most drivers will import from them. They
    can be added to the list seperately. Also note that the file list
    is not checked for duplicates when adding new entries.

Arguments:

    PathList - Pointer to list.

    FilePath - Fully qualified path of an image file.

    FilePathLength - Length of the file path in characters excluding NUL.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    ULONG MaxNumImports;
    ULONG NumImports;
    WCHAR **ImportNames;
    ULONG ImportIdx;
    ULONG BufferSize;
    WCHAR *FileName;
    WCHAR ParentDir[MAX_PATH + 1];
    ULONG ParentDirLength;
    WCHAR *ImportName;
    ULONG ImportNameLength;
    WCHAR ImportPath[MAX_PATH + 1];
    PUCHAR ImportBase;
    ULONG RequiredLength;
    ULONG FileSize;
    PIMAGE_IMPORT_DESCRIPTOR NewImportDescriptor;
    CHAR *NewImportNameAnsi;
    WCHAR *NewImportName;
    ULONG NewImportNameRva;
    ULONG ImportTableSize;
    BOOLEAN AddedToTable;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG NextImport;

    //
    // Initialize locals.
    //

    MaxNumImports = 256;
    ImportNames = NULL;
    NumImports = 0;
    NextImport = 0;

    //
    // Find the file name from the path.
    //

    if (FilePathLength == 0 || FilePath[FilePathLength - 1] == L'\\') {
        ErrorCode = ERROR_BAD_LENGTH;
        goto cleanup;
    }

    FileName = &FilePath[FilePathLength - 1];   
    while (FileName > FilePath) {

        if (*FileName == L'\\') {
            FileName++;
            break;
        }

        FileName--;
    }

    //
    // Extract the parent directory.
    //

    ParentDirLength = (ULONG) (FileName - FilePath);

    if (ParentDirLength >= MAX_PATH) {
        ErrorCode = ERROR_BAD_LENGTH;
        goto cleanup;
    }
    
    wcsncpy(ParentDir, FilePath, ParentDirLength);
    ParentDir[ParentDirLength] = 0;
    
    //
    // Allocate a table for keeping track of imported modules.
    //

    BufferSize = MaxNumImports * sizeof(WCHAR *);
    ImportNames = PFSVC_ALLOC(BufferSize);
    
    if (ImportNames == NULL) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    RtlZeroMemory(ImportNames, BufferSize);

    //
    // Insert the file into the table and kick off import enumeration
    // on the table. Each enumerated import gets appended to the table
    // if it is not already present. Enumeration continues until all
    // appended entries are processed. 
    //

    ImportNames[NumImports] = FileName;
    NumImports++;

    while (NextImport < NumImports) {

        //
        // Initialize loop locals.
        //
        
        ImportBase = NULL;
        ImportName = ImportNames[NextImport];
        ImportNameLength = wcslen(ImportName);

        //
        // Locate the file. First look in ParentDir.
        //
        
        if (ImportNameLength + ParentDirLength >= MAX_PATH) {
          goto NextImport;
        }
        
        wcscpy(ImportPath, ParentDir);
        wcscat(ImportPath, ImportName);
        
        if (GetFileAttributes(ImportPath) == 0xFFFFFFFF) {

            //
            // Look for this file in other known directories.
            //
            
            ErrorCode = PfSvLocateBootServiceFile(ImportName,
                                               ImportNameLength,
                                               ImportPath,
                                               MAX_PATH,
                                               &RequiredLength);
            
            if (ErrorCode != ERROR_SUCCESS) {
              goto NextImport;
            }
        }

        //
        // Add the file to the file list.
        //

        PfSvAddToPathList(PathList,
                          ImportPath,
                          wcslen(ImportPath));
        
        //
        // Map the file.
        //

        ErrorCode = PfSvGetViewOfFile(ImportPath, &ImportBase, &FileSize); 
        
        if (ErrorCode != ERROR_SUCCESS) {
          goto NextImport;
        }

        //
        // Make sure this is an image file.
        //

        __try {

            //
            // This is the first access to the mapped file. Under stress we might not be
            // able to page this in and an exception might be raised. This protects us from
            // the most common failure case.
            //

            NtHeaders = ImageNtHeader(ImportBase);

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            NtHeaders = NULL;
        }
        
        if (NtHeaders == NULL) {
          goto NextImport;
        }

        //
        // Walk through the imports for this binary.
        //

        NewImportDescriptor = ImageDirectoryEntryToData(ImportBase,
                                                        FALSE,
                                                        IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                        &ImportTableSize);

        while (NewImportDescriptor &&
               (NewImportDescriptor->Name != 0) &&
               (NewImportDescriptor->FirstThunk != 0)) {

            //
            // Initialize loop locals.
            //
            
            AddedToTable = FALSE;
            NewImportName = NULL;

            //
            // Get the name for this import.
            //

            NewImportNameRva = NewImportDescriptor->Name;
            NewImportNameAnsi = ImageRvaToVa(NtHeaders, 
                                             ImportBase,
                                             NewImportNameRva,
                                             NULL);
            
            ErrorCode = GetLastError();

            if (NewImportNameAnsi) {
                NewImportName = PfSvcAnsiToUnicode(NewImportNameAnsi);
            }

            if (NewImportName == NULL) {
                goto NextImportDescriptor;
            }
            
            //
            // Skip the kernel and hal imports. See comment in
            // function description.
            //

            if (!_wcsicmp(NewImportName, L"ntoskrnl.exe") ||
                !_wcsicmp(NewImportName, L"hal.dll")) {
                goto NextImportDescriptor;
            }

            //
            // Check to see if this import is already in our table.
            //

            for (ImportIdx = 0; ImportIdx < NumImports; ImportIdx++) {
                if (!_wcsicmp(NewImportName, ImportNames[ImportIdx])) {
                    goto NextImportDescriptor;
                }
            }
            
            //
            // Append this import to the table.
            //
            
            if (NumImports < MaxNumImports) {
                ImportNames[NumImports] = NewImportName;
                NumImports++;
                AddedToTable = TRUE;
            }

        NextImportDescriptor:

            if (!AddedToTable && NewImportName) {
                PFSVC_FREE(NewImportName);
            }
            
            if (NumImports >= MaxNumImports) {
                break;
            }
            
            NewImportDescriptor++;
        }
        
    NextImport:        

        if (ImportBase) {
            UnmapViewOfFile(ImportBase);
        }
        
        NextImport++;
    }
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ImportNames) {
        
        //
        // The first entry in the table is the filename from FilePath,
        // which is not allocated and which should not be freed.
        //
        
        for (ImportIdx = 1; ImportIdx < NumImports; ImportIdx++) {
            PfSvcFreeString(ImportNames[ImportIdx]);
        }

        PFSVC_FREE(ImportNames);
    }

    return ErrorCode;
}

DWORD
PfSvLocateBootServiceFile(
    IN WCHAR *FileName,
    IN ULONG FileNameLength,
    OUT WCHAR *FullPathBuffer,
    IN ULONG FullPathBufferLength,
    OUT PULONG RequiredLength   
    )

/*++

Routine Description:

    This function looks at known directories in an *attempt* locate
    the file whose name is specified. The logic may have to be
    improved.

Arguments:

    FileName - File name to look for.

    FileNameLength - Length of file name in characters excluding NUL.
      
    FullPathBuffer - The full path will be put here.
    
    FullPathBufferLength - Length of the FullPathBuffer in characters.

    RequiredLength - If FullPathBuffer is too small, this is how big it 
      should be in characters.

Return Value:

    ERROR_INSUFFICIENT_BUFFER - The FullPathBuffer is not big enough.

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR *DriversDirName;
    ULONG SystemDirLength;
    
    //
    // Initialize locals.
    //

    DriversDirName = L"drivers\\";

    //
    // Copy system root path and a trailing \.
    //

    SystemDirLength = GetSystemDirectory(FullPathBuffer, FullPathBufferLength);

    if (!SystemDirLength) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    SystemDirLength++;

    //
    // Calculate maximum size of required length.
    //

    (*RequiredLength) = SystemDirLength;
    (*RequiredLength) += wcslen(DriversDirName);
    (*RequiredLength) += FileNameLength;
    (*RequiredLength) += 1; // terminating NUL.

    if ((*RequiredLength) > FullPathBufferLength) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // Append slash.
    //
    
    wcscat(FullPathBuffer, L"\\");

    //
    // Append drivers path.
    //

    wcscat(FullPathBuffer, DriversDirName);
    
    //
    // Append file name.
    //

    wcscat(FullPathBuffer, FileName);

    if (GetFileAttributes(FullPathBuffer) != 0xFFFFFFFF) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Roll back and look for the file in the system
    // directory. SystemDirLength includes the slash after system
    // directory path.
    //
    
    FullPathBuffer[SystemDirLength] = 0;
    
    wcscat(FullPathBuffer, FileName);

    if (GetFileAttributes(FullPathBuffer) != 0xFFFFFFFF) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    ErrorCode = ERROR_FILE_NOT_FOUND;

 cleanup:    
    
    return ErrorCode;
}

DWORD
PfSvGetBootServiceFullPath(
    IN WCHAR *ServiceName,
    IN WCHAR *BinaryPathName,
    OUT WCHAR *FullPathBuffer,
    IN ULONG FullPathBufferLength,
    OUT PULONG RequiredLength
    )

/*++

Routine Description:

    This function *attempts* to locate specified boot service. The
    logic may have to be improved.

Arguments:

    ServiceName - Name of the service.

    BinaryPathName - From service configuration info. This is supposed
      to be the full path, but it is not.
      
    FullPathBuffer - The full path will be put here.
    
    FullPathBufferLength - Length of the FullPathBuffer in characters.

    RequiredLength - If FullPathBuffer is too small, this is how big it 
      should be in characters.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR FileName[MAX_PATH];
    WCHAR FoundFilePath;
    ULONG BinaryPathLength;
    BOOLEAN GotFileNameFromBinaryPath;
    LONG CharIdx;
    ULONG CopyLength;
    WCHAR *SysExtension;
    WCHAR *DllExtension;
    WCHAR *FileNamePart;

    //
    // Initialize locals.
    //
    
    GotFileNameFromBinaryPath = FALSE;
    SysExtension = L".sys";
    DllExtension = L".dll";

    //
    // Check if a binary path was specified.
    //

    if (BinaryPathName && BinaryPathName[0]) {

        //
        // See if the file is really there.
        //

        if (GetFileAttributes(BinaryPathName) != 0xFFFFFFFF) {
            
            //
            // BinaryPathName may not be a fully qualified path. Make
            // sure it is.
            //
            
            (*RequiredLength) = GetFullPathName(BinaryPathName,
                                              FullPathBufferLength,
                                              FullPathBuffer,
                                              &FileNamePart);
            
            if ((*RequiredLength) == 0) {
                ErrorCode = GetLastError();
                goto cleanup;
            }

            if ((*RequiredLength) > FullPathBufferLength) {
                ErrorCode = ERROR_INSUFFICIENT_BUFFER;
                goto cleanup;
            }
            
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }

        //
        // Try to extract a file name from the binary path.
        //

        BinaryPathLength = wcslen(BinaryPathName);
        
        for (CharIdx = BinaryPathLength - 1;
             CharIdx >= 0;
             CharIdx --) {
            
            if (BinaryPathName[CharIdx] == L'\\') {

                //
                // Check length and copy it.
                //
                
                CopyLength = BinaryPathLength - CharIdx;

                if (CopyLength < MAX_PATH &&
                    CopyLength > 1) {

                    //
                    // Copy name starting after the \ character.
                    //

                    wcscpy(FileName, &BinaryPathName[CharIdx + 1]);

                    GotFileNameFromBinaryPath = TRUE;
                }

                break;
            }
        }
        
        //
        // There was not a slash. Maybe the BinaryPathLength is just
        // the file name.
        //
        
        if (GotFileNameFromBinaryPath == FALSE && 
            BinaryPathLength && 
            BinaryPathLength < MAX_PATH) {

            wcscpy(FileName, BinaryPathName);
            GotFileNameFromBinaryPath = TRUE;
        }
    }

    //
    // After this point we will base our search on file name hints.
    //

    //
    // If we got a file name from the binary path try that first.
    //

    if (GotFileNameFromBinaryPath) {
        
        ErrorCode = PfSvLocateBootServiceFile(FileName,
                                           wcslen(FileName),
                                           FullPathBuffer,
                                           FullPathBufferLength,
                                           RequiredLength);
        
        if (ErrorCode != ERROR_FILE_NOT_FOUND) {

            //
            // If we found a path or if the buffer length was not
            // enough we will bubble up that to our caller.
            //

            goto cleanup;
        }      
    }

    //
    // Build a file name from service name by appending a .sys.
    //

    CopyLength = wcslen(ServiceName);
    CopyLength += wcslen(SysExtension);
    
    if (CopyLength >= MAX_PATH) {

        //
        // The service name is too long!
        //

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    wcscpy(FileName, ServiceName);
    wcscat(FileName, SysExtension);

    ErrorCode = PfSvLocateBootServiceFile(FileName,
                                       wcslen(FileName),
                                       FullPathBuffer,
                                       FullPathBufferLength,
                                       RequiredLength);
    
    if (ErrorCode != ERROR_FILE_NOT_FOUND) {

        //
        // If we found a path or if the buffer length was not
        // enough we will bubble up that to our caller.
        //

        goto cleanup;
    }      

    //
    // Build a file name from service name by appending a .dll.
    //

    CopyLength = wcslen(ServiceName);
    CopyLength += wcslen(DllExtension);
    
    if (CopyLength >= MAX_PATH) {

        //
        // The service name is too long!
        //

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    wcscpy(FileName, ServiceName);
    wcscat(FileName, DllExtension);

    ErrorCode = PfSvLocateBootServiceFile(FileName,
                                       wcslen(FileName),
                                       FullPathBuffer,
                                       FullPathBufferLength,
                                       RequiredLength);
    
    if (ErrorCode != ERROR_FILE_NOT_FOUND) {

        //
        // If we found a path or if the buffer length was not
        // enough we will bubble up that to our caller.
        //

        goto cleanup;
    }      
        
    //
    // We could not find the file...
    //

    ErrorCode = ERROR_FILE_NOT_FOUND;

 cleanup:

    return ErrorCode;
}

DWORD 
PfSvGetBootLoaderNlsFileNames (
    PPFSVC_PATH_LIST PathList
    ) 

/*++

Routine Description:

    This function attempts to add the list of NLS files loaded in the
    boot loader to the specified file list.

Arguments:

    PathList - Pointer to list.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    HKEY NlsKeyHandle;
    WCHAR *CodePageKeyName;
    HKEY CodePageKeyHandle;
    WCHAR *LanguageKeyName;
    HKEY LanguageKeyHandle;
    ULONG BufferSize;
    ULONG RequiredSize;
    ULONG RequiredLength;
    WCHAR FileName[MAX_PATH + 1];
    WCHAR FilePath[MAX_PATH + 1];
    WCHAR *AnsiCodePageName;
    WCHAR *OemCodePageName;
    WCHAR *OemHalName;
    WCHAR *DefaultLangName;
    ULONG RegValueType;

    //
    // Initialize locals.
    //
    
    NlsKeyHandle = NULL;
    CodePageKeyHandle = NULL;
    LanguageKeyHandle = NULL;
    CodePageKeyName = L"CodePage";
    LanguageKeyName = L"Language";
    AnsiCodePageName = L"ACP";
    OemCodePageName = L"OEMCP";
    DefaultLangName = L"Default";
    OemHalName = L"OEMHAL";  

    //
    // Open NLS key.
    //

    ErrorCode = RegOpenKey(HKEY_LOCAL_MACHINE,
                           PFSVC_NLS_REG_KEY_PATH,
                           &NlsKeyHandle);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
    
    //
    // Open CodePage key.
    //

    ErrorCode = RegOpenKey(NlsKeyHandle,
                        CodePageKeyName,
                        &CodePageKeyHandle);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }
    
    //
    // Open Language key.
    //

    ErrorCode = RegOpenKey(NlsKeyHandle,
                        LanguageKeyName,
                        &LanguageKeyHandle);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // AnsiCodePage:
    //

    ErrorCode = PfSvQueryNlsFileName(CodePageKeyHandle,
                                  AnsiCodePageName,
                                  FileName,
                                  MAX_PATH * sizeof(WCHAR),
                                  &RequiredSize);
    
    if (ErrorCode == ERROR_SUCCESS) {
        
        ErrorCode = PfSvLocateNlsFile(FileName,
                                   FilePath,
                                   MAX_PATH,
                                   &RequiredLength);
        
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = PfSvAddToPathList(PathList, FilePath, wcslen(FilePath));
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    //
    // OemCodePage:
    //

    ErrorCode = PfSvQueryNlsFileName(CodePageKeyHandle,
                                  OemCodePageName,
                                  FileName,
                                  MAX_PATH * sizeof(WCHAR),
                                  &RequiredSize);
    
    if (ErrorCode == ERROR_SUCCESS) {
        
        ErrorCode = PfSvLocateNlsFile(FileName,
                                   FilePath,
                                   MAX_PATH,
                                   &RequiredLength);
        
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = PfSvAddToPathList(PathList, FilePath, wcslen(FilePath));
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    //
    // Default language case conversion.
    //

    ErrorCode = PfSvQueryNlsFileName(LanguageKeyHandle,
                                  DefaultLangName,
                                  FileName,
                                  MAX_PATH * sizeof(WCHAR),
                                  &RequiredSize);
    
    if (ErrorCode == ERROR_SUCCESS) {
        
        ErrorCode = PfSvLocateNlsFile(FileName,
                                   FilePath,
                                   MAX_PATH,
                                   &RequiredLength);
        
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = PfSvAddToPathList(PathList, FilePath, wcslen(FilePath));
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    //
    // OemHal:
    //
   
    BufferSize = MAX_PATH * sizeof(WCHAR);
    ErrorCode = RegQueryValueEx(CodePageKeyHandle,
                             OemHalName,
                             NULL,
                             &RegValueType,
                             (PVOID) FileName,
                             &BufferSize);
    
    if (ErrorCode == ERROR_SUCCESS && RegValueType == REG_SZ) {
        
        ErrorCode = PfSvLocateNlsFile(FileName,
                                   FilePath,
                                   MAX_PATH,
                                   &RequiredLength);
        
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = PfSvAddToPathList(PathList, FilePath, wcslen(FilePath));
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (NlsKeyHandle) {
        RegCloseKey(NlsKeyHandle);
    }

    if (CodePageKeyHandle) {
        RegCloseKey(CodePageKeyHandle);
    }

    if (LanguageKeyHandle) {
        RegCloseKey(LanguageKeyHandle);
    }

    return ErrorCode;
}

DWORD 
PfSvLocateNlsFile(
    WCHAR *FileName,
    WCHAR *FilePathBuffer,
    ULONG FilePathBufferLength,
    ULONG *RequiredLength
    )

/*++

Routine Description:

    This function attempts to locate a nls/font related file in known
    directories.

Arguments:

    FileName - File name to look for.

    FullPathBuffer - The full path will be put here.
    
    FullPathBufferLength - Length of the FullPathBuffer in characters.

    RequiredLength - If FullPathBuffer is too small, this is how big it 
      should be in characters.

Return Value:

    ERROR_INSUFFICIENT_BUFFER - The FullPathBuffer is not big enough.

    Win32 error code.

--*/
    
{
    DWORD ErrorCode;
    ULONG SystemRootLength;
    WCHAR *System32DirName;
    WCHAR *FontsDirName;
    WCHAR *SystemDirName;
    WCHAR *LongestDirName;

    //
    // Initialize locals. NOTE: The length of the longest directory
    // name to concatenate to SystemRoot is used in RequiredLength
    // calculation.
    //
    
    System32DirName = L"System32\\";
    SystemDirName = L"System\\";
    FontsDirName = L"Fonts\\";
    LongestDirName = System32DirName;

    //
    // Get system root path.
    //

    SystemRootLength = ExpandEnvironmentStrings(L"%SystemRoot%\\",
                                                FilePathBuffer,
                                                FilePathBufferLength);

    if (SystemRootLength == 0) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // SystemRootLength includes the terminating NUL. Adjust it.
    //

    SystemRootLength--;

    //
    // Calculate required length with space for terminating NUL.
    //

    (*RequiredLength) = SystemRootLength;
    (*RequiredLength) += wcslen(LongestDirName);
    (*RequiredLength) += wcslen(FileName);
    (*RequiredLength) ++;

    if ((*RequiredLength) > FilePathBufferLength) {
        ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }
    
    //
    // Look for it under system32 dir.
    //

    FilePathBuffer[SystemRootLength] = 0;
    wcscat(FilePathBuffer, System32DirName);
    wcscat(FilePathBuffer, FileName);

    if (GetFileAttributes(FilePathBuffer) != 0xFFFFFFFF) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Look for it under fonts dir.
    //

    FilePathBuffer[SystemRootLength] = 0;
    wcscat(FilePathBuffer, FontsDirName);
    wcscat(FilePathBuffer, FileName);

    if (GetFileAttributes(FilePathBuffer) != 0xFFFFFFFF) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }
    
    //
    // Look for it under system dir.
    //

    FilePathBuffer[SystemRootLength] = 0;
    wcscat(FilePathBuffer, SystemDirName);
    wcscat(FilePathBuffer, FileName);

    if (GetFileAttributes(FilePathBuffer) != 0xFFFFFFFF) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Look for it at SystemRoot.
    //

    FilePathBuffer[SystemRootLength] = 0;
    wcscat(FilePathBuffer, FileName);

    if (GetFileAttributes(FilePathBuffer) != 0xFFFFFFFF) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }                                                

    //
    // Could not find the file.
    //

    ErrorCode = ERROR_FILE_NOT_FOUND;

 cleanup:

    return ErrorCode;
}

DWORD
PfSvQueryNlsFileName (
    HKEY Key,
    WCHAR *ValueName,
    WCHAR *FileNameBuffer,
    ULONG FileNameBufferSize,
    ULONG *RequiredSize
    )

/*++

Routine Description:

    This function attempts to get a file name from an NLS
    CodePage/Language registry key.

Arguments:

    Key - CodePage or Language key handle.

    ValueName - What we are trying to get the file name for.

    FileNameBuffer - Where the file name will be put.
    
    FileNameBufferSize - Size in bytes of the file name buffer.

    RequiredSize - If FileNameBuffer is too small, this is what its
      size should be.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    WCHAR FileValueName[MAX_PATH + 1];
    ULONG BufferSize;
    ULONG RegValueType;

    //
    // First we first get the valuename under which the file name is
    // stored, then we get the file name:
    //

    BufferSize = MAX_PATH * sizeof(WCHAR);
    ErrorCode = RegQueryValueEx(Key,
                             ValueName,
                             NULL,
                             &RegValueType,
                             (PVOID) FileValueName,
                             &BufferSize);
    
    if (ErrorCode == ERROR_MORE_DATA) {
        ErrorCode = ERROR_INVALID_FUNCTION;
        goto cleanup;
    }

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (RegValueType != REG_SZ) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }
    
    *RequiredSize = FileNameBufferSize;
    ErrorCode = RegQueryValueEx(Key,
                             FileValueName,
                             NULL,
                             &RegValueType,
                             (PVOID) FileNameBuffer,
                             RequiredSize);
    
    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (RegValueType != REG_SZ) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    return ErrorCode;
}

//
// Routines to manage / run idle tasks.
//

VOID
PfSvInitializeTask (
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    Initialize the task structure. Should be called before any other
    task functions are called. You should call the cleanup routine
    on the initialized task.

Arguments:

    Task - Pointer to structure.

Return Value:

    None.
    
--*/
  
{

    //
    // Zero out the structure initializing the following to
    // the right values:
    //
    //   Registered
    //   WaitUnregisteredEvent
    //   CallbackStoppedEvent
    //   StartedUnregisteringEvent
    //   CompletedUnregisteringEvent
    //   Unregistering
    //   CallbackRunning
    //
    
    RtlZeroMemory(Task, sizeof(PFSVC_IDLE_TASK));

    Task->Initialized = TRUE;
}

DWORD
PfSvRegisterTask (
    PPFSVC_IDLE_TASK Task,
    IT_IDLE_TASK_ID TaskId,
    WAITORTIMERCALLBACK Callback,
    PFSVC_IDLE_TASK_WORKER_FUNCTION DoWorkFunction
    )

/*++

Routine Description:

    Registers the Callback to be called when it is the turn of this
    idle task to run. IFF this function returns success, you should
    call unregister function before calling the cleanup function.

Arguments:

    Task - Pointer to initialized task structure.

    TaskId - Idle task ID to register.

    Callback - We'll register a wait on the start event returned by
      idle task registration with this callback. The callback should 
      call start/stop task callback functions appropriately.

    DoWorkFunction - If the caller wants the common callback function
      to be used, then this function will be called to do the actual
      work in the common callback.

Return Value:

    Win32 error code.
    
--*/

{
    DWORD ErrorCode;
    BOOL Success;
    BOOLEAN CreatedWaitUnregisteredEvent;
    BOOLEAN CreatedStartedUnregisteringEvent;
    BOOLEAN CreatedCompletedUnregisteringEvent;
    BOOLEAN CreatedCallbackStoppedEvent;
    BOOLEAN RegisteredIdleTask;

    //
    // Initialize locals.
    //

    RegisteredIdleTask = FALSE;
    CreatedWaitUnregisteredEvent = FALSE;
    CreatedStartedUnregisteringEvent = FALSE;
    CreatedCompletedUnregisteringEvent = FALSE;
    CreatedCallbackStoppedEvent = FALSE;

    DBGPR((PFID,PFTASK,"PFSVC: RegisterTask(%p,%d,%p,%p)\n",Task,TaskId,Callback,DoWorkFunction));

    //
    // The task should be initialized and not registered.
    //

    PFSVC_ASSERT(Task->Initialized);
    PFSVC_ASSERT(!Task->Registered);
    PFSVC_ASSERT(!Task->Unregistering);
    PFSVC_ASSERT(!Task->CallbackRunning);

    //
    // Create the event that cleanup waits on to make sure
    // the registered wait is fully unregistered.
    //

    Task->WaitUnregisteredEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (Task->WaitUnregisteredEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedWaitUnregisteredEvent = TRUE;

    //
    // Create the event that will get signaled when we start
    // unregistering the task.
    //

    Task->StartedUnregisteringEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (Task->StartedUnregisteringEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedStartedUnregisteringEvent = TRUE;

    //
    // Create the event that will get signaled when we complete
    // unregistering the task.
    //

    Task->CompletedUnregisteringEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (Task->CompletedUnregisteringEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedCompletedUnregisteringEvent = TRUE;

    //
    // Create the event we may wait on for the current running
    // callback to go away.
    //

    Task->CallbackStoppedEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    if (Task->CallbackStoppedEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedCallbackStoppedEvent = TRUE;

    //
    // Register the idle task.
    //

    ErrorCode = RegisterIdleTask(TaskId,
                                 &Task->ItHandle,
                                 &Task->StartEvent,
                                 &Task->StopEvent);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    RegisteredIdleTask = TRUE;

    //
    // Register the callback: Note that once this call succeeds the task has to
    // be unregistered via PfSvUnregisterTask.
    //

    //
    // The callback might fire right away so note that we registered it and set
    // up its fields upfront.
    //

    Task->Registered = 1;
    Task->Callback = Callback;
    Task->DoWorkFunction = DoWorkFunction;

    //
    // If the common task callback was specified, a worker function should also
    // be specified.
    //

    if (Callback == PfSvCommonTaskCallback) {
        PFSVC_ASSERT(DoWorkFunction);
    }

    Success = RegisterWaitForSingleObject(&Task->WaitHandle,
                                          Task->StartEvent,
                                          Task->Callback,
                                          Task,
                                          INFINITE,
                                          WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION);

    if (!Success) {

        //
        // We failed to really register the task.
        //

        Task->Registered = 0;

        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;       

cleanup:

    DBGPR((PFID,PFTASK,"PFSVC: RegisterTask(%p)=%x\n",Task,ErrorCode));

    if (ErrorCode != ERROR_SUCCESS) {

        if (CreatedWaitUnregisteredEvent) {
            CloseHandle(Task->WaitUnregisteredEvent);
            Task->WaitUnregisteredEvent = NULL;
        }

        if (CreatedStartedUnregisteringEvent) {
            CloseHandle(Task->StartedUnregisteringEvent);
            Task->StartedUnregisteringEvent = NULL;
        }

        if (CreatedCompletedUnregisteringEvent) {
            CloseHandle(Task->CompletedUnregisteringEvent);
            Task->CompletedUnregisteringEvent = NULL;
        }

        if (CreatedCallbackStoppedEvent) {
            CloseHandle(Task->CallbackStoppedEvent);
            Task->CallbackStoppedEvent = NULL;
        }
    
        if (RegisteredIdleTask) {
            UnregisterIdleTask(Task->ItHandle,
                               Task->StartEvent,
                               Task->StopEvent);
        }
    }

    return ErrorCode;
}

DWORD
PfSvUnregisterTask (
    PPFSVC_IDLE_TASK Task,
    BOOLEAN CalledFromCallback
    )

/*++

Routine Description:

    Unregisters the idle task and the registered wait / callback. You should 
    call this function before calling the cleanup routine IFF the register
    function returned success.

Arguments:

    Task - Pointer to registered task.

    CalledFromCallback - Whether this function is being called from inside
      the queued callback of the task.
      
Return Value:

    Win32 error code.
    
--*/


{
    LONG OldValue;
    LONG NewValue;
    DWORD ErrorCode;

    DBGPR((PFID,PFTASK,"PFSVC: UnregisterTask(%p,%d)\n",Task,(DWORD)CalledFromCallback));

    //
    // The task should be initialized. It may already be unregistered.
    //

    PFSVC_ASSERT(Task->Initialized);

    if (Task->Registered == 0) {
        ErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
        goto cleanup;
    }

    //
    // Distinguish whether we are unregistering the task from a callback.
    //

    if (CalledFromCallback) {
        NewValue = PfSvcUnregisteringTaskFromCallback;
    } else {
        NewValue = PfSvcUnregisteringTaskFromMainThread;
    }

    //
    // Is this task already being unregistered?
    //

    OldValue = InterlockedCompareExchange(&Task->Unregistering,
                                          NewValue,
                                          PfSvcNotUnregisteringTask);

    if (OldValue != PfSvcNotUnregisteringTask) {

        ErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
        goto cleanup;
    }

    //
    // *We* will be unregistering the task. There is no turning back.
    //

    SetEvent(Task->StartedUnregisteringEvent);

    //
    // If we are not inside a callback, wait for no callbacks to be running
    // and cause new ones that start to bail out. We do this so we can safely
    // unregister the wait.
    //

    if (!CalledFromCallback) {

        do {
            OldValue = InterlockedCompareExchange(&Task->CallbackRunning,
                                                  PfSvcTaskCallbackDisabled,
                                                  PfSvcTaskCallbackNotRunning);

            if (OldValue == PfSvcTaskCallbackNotRunning) {

                //
                // We did it. No callbacks are running and new ones that try to
                // start will bail out.
                //

                PFSVC_ASSERT(Task->CallbackRunning == PfSvcTaskCallbackDisabled);

                break;
            }

            //
            // A callback might be active right now. It will see that we are unregistering and
            // go away. Sleep for a while and try again.
            //

            PFSVC_ASSERT(OldValue == PfSvcTaskCallbackRunning);

            //
            // We wait on this event with a timeout, because signaling of it is not
            // 100% reliable because it is not under a lock etc.
            //

            WaitForSingleObject(Task->CallbackStoppedEvent, 1000);

        } while (TRUE);

    } else {

        //
        // We already have control of this variable as the running callback: just
        // update it.
        //

        Task->CallbackRunning = PfSvcTaskCallbackDisabled;
    }

    //
    // Unregister the wait. Note that in cleanup we have to wait to for 
    // WaitUnregisteredEvent to be signaled.
    //

    UnregisterWaitEx(Task->WaitHandle, Task->WaitUnregisteredEvent);

    //
    // Unregister the idle task.
    //

    UnregisterIdleTask(Task->ItHandle,
                       Task->StartEvent,
                       Task->StopEvent);

    //
    // Note that the task is no longer registered.
    //

    Task->Registered = FALSE;

    SetEvent(Task->CompletedUnregisteringEvent);

    ErrorCode = ERROR_SUCCESS;
    
cleanup:

    DBGPR((PFID,PFTASK,"PFSVC: UnregisterTask(%p)=%x\n",Task,ErrorCode));

    return ErrorCode;
}

VOID
PfSvCleanupTask (
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    Cleans up all fields of an unregistered task or a task that was never
    registered.

Arguments:

    Task - Pointer to task.

Return Value:

    None.
    
--*/
    
{
    //
    // The task should have been initialized.
    //

    PFSVC_ASSERT(Task->Initialized);
    
    //
    // If there is a WaitUnregisteredEvent, we have to wait on it
    // to make sure the unregister operation is fully complete.
    //

    if (Task->WaitUnregisteredEvent) {
        WaitForSingleObject(Task->WaitUnregisteredEvent, INFINITE);
        CloseHandle(Task->WaitUnregisteredEvent);
    }   

    //
    // If there is CompletedUnregisteringEvent, wait for it to
    // be signalled to make sure both that the wait is unregistered,
    // and the idle task is unregistered.
    //

    if (Task->CompletedUnregisteringEvent) {
        WaitForSingleObject(Task->CompletedUnregisteringEvent, INFINITE);
    }   

    //
    // The task should be unregistered before it is cleaned up.
    //

    PFSVC_ASSERT(Task->Registered == FALSE);

    //
    // Cleanup task unregistering events.
    //

    if (Task->StartedUnregisteringEvent) {
        CloseHandle(Task->StartedUnregisteringEvent);
    }

    if (Task->CompletedUnregisteringEvent) {
        CloseHandle(Task->CompletedUnregisteringEvent);
    }

    //
    // Clean up callback stopped event.
    //

    if (Task->CallbackStoppedEvent) {
        CloseHandle(Task->CallbackStoppedEvent);
    }

    Task->Initialized = FALSE;

    return;
}

BOOL
PfSvStartTaskCallback(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    Callbacks registered via register task function should call this as the
    first thing. If this function returns FALSE, the callback should go away
    immediately without calling the stop-callback function.

Arguments:

    Task - Pointer to task.

Return Value:

    TRUE - Everything is cool.
    FALSE - The task is being unregistered. Exit the callback asap.
    
--*/

{
    BOOL ReturnValue;
    LONG OldValue;

    DBGPR((PFID,PFTASK,"PFSVC: StartTaskCallback(%p)\n",Task));

    //
    // We should not be called if the task is not initialized.
    //

    PFSVC_ASSERT(Task->Initialized);

    do {

        //
        // First check if we are trying to unregister.
        //

        if (Task->Unregistering) {
            ReturnValue = FALSE;
            goto cleanup;
        }

        //
        // Try to mark the callback running.
        //

        OldValue = InterlockedCompareExchange(&Task->CallbackRunning,
                                              PfSvcTaskCallbackRunning,
                                              PfSvcTaskCallbackNotRunning);

        if (OldValue == PfSvcTaskCallbackNotRunning) {

            //
            // We are the running callback now. Reset the event that says
            // the current callback stopped running.
            //

            ResetEvent(Task->CallbackStoppedEvent);

            ReturnValue = TRUE;
            goto cleanup;
        }

        //
        // Either another callback is running or we are unregistering.
        //

        //
        // Are we unregistering?
        //

        if (Task->Unregistering) {

            ReturnValue = FALSE;
            goto cleanup;

        } else {

            PFSVC_ASSERT(OldValue == PfSvcTaskCallbackRunning);
        }

        //
        // Sleep for a while and try again. There should not be much conflict in this 
        // code, so we should hardly ever need to sleep.
        //

        Sleep(15);
        
    } while (TRUE);

    //
    // We should not come here.
    //

    PFSVC_ASSERT(FALSE);

cleanup:

    //
    // If we are starting a callback, the task should not be in unregistered state.
    //

    PFSVC_ASSERT(!ReturnValue || Task->Registered);

    DBGPR((PFID,PFTASK,"PFSVC: StartTaskCallback(%p)=%d\n",Task,ReturnValue));

    return ReturnValue;
}

VOID
PfSvStopTaskCallback(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    Callbacks registered via register task function should call this as the
    last thing, only if they successfully called the start callback function and
    they did not unregister the task.

Arguments:

    Task - Pointer to task.

Return Value:

    None.
    
--*/

{
    DBGPR((PFID,PFTASK,"PFSVC: StopTaskCallback(%p)\n",Task));

    //
    // The task should be registered.
    //

    PFSVC_ASSERT(Task->Registered);

    //
    // There should be a running callback.
    //

    PFSVC_ASSERT(Task->CallbackRunning == PfSvcTaskCallbackRunning);

    Task->CallbackRunning = PfSvcTaskCallbackNotRunning;

    //
    // Signal the event the main thread may be waiting on to unregister
    // this task.
    //

    SetEvent(Task->CallbackStoppedEvent);

    return;
}

VOID 
CALLBACK 
PfSvCommonTaskCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired
    )

/*++

Routine Description:

    This is the callback for the idle tasks. It is called when the system is idle,
    and it is this tasks turn to run.

    Note that you cannot call PfSvCleanupTask from this thread, as it would cause
    a deadlock when that function waits for registered wait callbacks to exit.

Arguments:

    lpParameter - Pointer to task.

    TimerOrWaitFired - Whether the callback was initiated by a timeout or the start
      event getting signaled by the idle task service.

Return Value:

    None.
    
--*/

{
    HANDLE NewWaitHandle;
    PPFSVC_IDLE_TASK Task;
    BOOL StartedCallback;
    BOOL Success;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    Task = lpParameter;
    StartedCallback = FALSE;

    DBGPR((PFID,PFTASK,"PFSVC: CommonTaskCallback(%p)\n",Task));

    //
    // Enter task callback.
    //

    StartedCallback = PfSvStartTaskCallback(Task);

    if (!StartedCallback) {
        goto cleanup;
    }
    
    //
    // Do the task.
    //

    ErrorCode = Task->DoWorkFunction(Task);

    if (ErrorCode == ERROR_RETRY) {

        //
        // The stop event was signaled. We will queue another callback.
        //

        Success = RegisterWaitForSingleObject(&NewWaitHandle,
                                              Task->StartEvent,
                                              Task->Callback,
                                              Task,
                                              INFINITE,
                                              WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION);


        if (Success) {

            //
            // Unregister the current wait handle and update it.
            //

            UnregisterWaitEx(Task->WaitHandle, NULL);
            Task->WaitHandle = NewWaitHandle;

            goto cleanup;

        } else {

            //
            // We could not queue another callback. We will unregister, 
            // since we would not be able to respond to start signals
            // from the idle task service. Unregister may fail only if
            // the main thread is already trying to unregister.
            //

            ErrorCode = PfSvUnregisterTask(Task, TRUE);

            if (ErrorCode == ERROR_SUCCESS) {

                //
                // Since *we* unregistered, we should not call stop callback.
                //

                StartedCallback = FALSE;

            }

            goto cleanup;
        }

    } else {

        //
        // The task completed. Let's unregister.
        //

        ErrorCode = PfSvUnregisterTask(Task, TRUE);

        if (ErrorCode == ERROR_SUCCESS) {

            //
            // Since *we* unregistered, we should not call stop callback.
            //

            StartedCallback = FALSE;

        }

        goto cleanup;
    }

    //
    // We should not come here.
    //

    PFSVC_ASSERT(FALSE);

cleanup:

    DBGPR((PFID,PFTASK,"PFSVC: CommonTaskCallback(%p)=%x\n",Task,ErrorCode));

    if (StartedCallback) {
        PfSvStopTaskCallback(Task);
    }
}

DWORD
PfSvContinueRunningTask(
    PPFSVC_IDLE_TASK Task
    )

/*++

Routine Description:

    This is called from a running task to determine if we should continue
    running this task. The task should continue running if ERROR_SUCCESS is
    returned. ERROR_RETRY may be returned if the task is unregistering or
    was asked to stop.

Arguments:

    Task - Pointer to task. If NULL, this parameter is ignored.

Return Value:

    Win32 error code.
    
--*/

{
    DWORD WaitResult;
    DWORD ErrorCode;

    if (Task) {

        //
        // Is the task being unregistered?
        //

        if (Task->Unregistering) {
            ErrorCode = ERROR_RETRY;
            goto cleanup;
        }

        //
        // Is the stop event signaled? We don't really wait here since
        // the timeout is 0.
        //

        WaitResult = WaitForSingleObject(Task->StopEvent, 0);

        if (WaitResult == WAIT_OBJECT_0) {

            ErrorCode = ERROR_RETRY;
            goto cleanup;

        } else if (WaitResult != WAIT_TIMEOUT) {

            //
            // There was an error.
            //

            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    //
    // Check if the service is exiting...
    //

    if (PfSvcGlobals.TerminateServiceEvent) {

        WaitResult = WaitForSingleObject(PfSvcGlobals.TerminateServiceEvent, 0);

        if (WaitResult == WAIT_OBJECT_0) {

            ErrorCode = ERROR_RETRY;
            goto cleanup;

        } else if (WaitResult != WAIT_TIMEOUT) {

            //
            // There was an error.
            //

            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    //
    // The task should continue to run.
    //

    ErrorCode = ERROR_SUCCESS;

cleanup:

    return ErrorCode;
}

//
// ProcessIdleTasks notify routine and its dependencies.
//

VOID
PfSvProcessIdleTasksCallback(
    VOID
    )

/*++

Routine Description:

    This is routine is registered with the idle task server as a notify
    routine that is called when processing of all idle tasks is requested.
    ProcessIdleTasks is usually called to prepare the system for a benchmark 
    run by performing the optimization tasks that would have been performed 
    when the system is idle.

Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE Events[2];
    DWORD NumEvents;
    DWORD WaitResult;
    BOOLEAN ResetOverrideIdleEvent;

    //
    // First flush the idle tasks the prefetcher may have queued:
    //

    //
    // Determine the current status of the override-idle event.
    //

    WaitResult = WaitForSingleObject(PfSvcGlobals.OverrideIdleProcessingEvent,
                                     0);
    
    if (WaitResult != WAIT_OBJECT_0) {

        //
        // Override idle event is not already set. Set it and note to reset
        // it once tasks are completed. 
        //

        SetEvent(PfSvcGlobals.OverrideIdleProcessingEvent);
        ResetOverrideIdleEvent = TRUE;

    } else {

        ResetOverrideIdleEvent = FALSE;
    }

    //
    // Wait for processing complete event to get signaled.
    //

    Events[0] = PfSvcGlobals.ProcessingCompleteEvent;
    Events[1] = PfSvcGlobals.TerminateServiceEvent;
    NumEvents = 2;

    WaitForMultipleObjects(NumEvents, Events, FALSE, 30 * 60 * 1000);

    //
    // If we set the override idle event, reset it.
    //

    if (ResetOverrideIdleEvent) {
        ResetEvent(PfSvcGlobals.OverrideIdleProcessingEvent);
    }
    
    //
    // Force an update of the disk layout in case it did not happen.
    // If we notice no changes we will not launch the defragger again.
    //

    PfSvUpdateOptimalLayout(NULL);

    //
    // Signal WMI to complete its idle tasks if it has pending tasks.
    //

    PfSvForceWMIProcessIdleTasks();

    return;
}

DWORD
PfSvForceWMIProcessIdleTasks(
    VOID
    )

/*++

Routine Description:

    This is routine is called to force WMI to process all of its idle tasks.

Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    HANDLE StartEvent;
    HANDLE DoneEvent;
    HANDLE Events[2];
    DWORD NumEvents;
    DWORD ErrorCode;
    DWORD WaitResult;
    BOOL Success;

    //
    // Initialize locals.
    //

    StartEvent = NULL;
    DoneEvent = NULL;

    //
    // Wait until WMI service is started.
    //

    Success = PfSvWaitForServiceToStart(L"WINMGMT", 5 * 60 * 1000);

    if (!Success) {
        ErrorCode = ERROR_SERVICE_NEVER_STARTED;
        goto cleanup;
    }

    //
    // Open the start and done events.
    //

    StartEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, L"WMI_ProcessIdleTasksStart");
    DoneEvent =  OpenEvent(EVENT_ALL_ACCESS, FALSE, L"WMI_ProcessIdleTasksComplete");

    if (!StartEvent || !DoneEvent) {
        ErrorCode = ERROR_FILE_NOT_FOUND;
        goto cleanup;
    }

    //
    // Reset the done event.
    //

    ResetEvent(DoneEvent);

    //
    // Signal the start event.
    //

    SetEvent(StartEvent);

    //
    // Wait for the done event to be signaled.
    //

    Events[0] = DoneEvent;
    Events[1] = PfSvcGlobals.TerminateServiceEvent;
    NumEvents = 2;

    WaitResult = WaitForMultipleObjects(NumEvents, Events, FALSE, 25 * 60 * 1000);

    switch(WaitResult) {
    case WAIT_OBJECT_0     : ErrorCode = ERROR_SUCCESS; break;
    case WAIT_OBJECT_0 + 1 : ErrorCode = ERROR_SHUTDOWN_IN_PROGRESS; break;
    case WAIT_FAILED       : ErrorCode = GetLastError();
    case WAIT_TIMEOUT      : ErrorCode = WAIT_TIMEOUT;
    default                : ErrorCode = ERROR_INVALID_FUNCTION;
    }

    //
    // Fall through with error code.
    //

  cleanup:

    if (StartEvent) {
        CloseHandle(StartEvent);
    }

    if (DoneEvent) {
        CloseHandle(DoneEvent);
    }

    return ErrorCode;
}

BOOL 
PfSvWaitForServiceToStart (
    LPTSTR lpServiceName, 
    DWORD dwMaxWait
    )

/*++

Routine Description:

    Waits for the service to start.

Arguments:

    lpServiceName - Service to wait for.

    dwMaxWait - Timeout in ms.

Return Value:

    Whether the service was started.

--*/

{
    BOOL bStarted = FALSE;
    DWORD dwSize = 512;
    DWORD StartTickCount;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG lpServiceConfig = NULL;

    //
    // OpenSCManager and the service.
    //
    hScManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (!hScManager) {
        goto Exit;
    }

    hService = OpenService(hScManager, lpServiceName,
                           SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS);
    if (!hService) {
        goto Exit;
    }

    //
    // Query if the service is going to start
    //
    lpServiceConfig = LocalAlloc (LPTR, dwSize);
    if (!lpServiceConfig) {
        goto Exit;
    }

    if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Exit;
        }

        LocalFree (lpServiceConfig);

        lpServiceConfig = LocalAlloc (LPTR, dwSize);

        if (!lpServiceConfig) {
            goto Exit;
        }

        if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {
            goto Exit;
        }
    }

    if (lpServiceConfig->dwStartType != SERVICE_AUTO_START) {
        goto Exit;
    }

    //
    // Loop until the service starts or we think it never will start
    // or we've exceeded our maximum time delay.
    //

    StartTickCount = GetTickCount();

    while (!bStarted) {

        if (WAIT_OBJECT_0 == WaitForSingleObject(PfSvcGlobals.TerminateServiceEvent, 0)) {
            break;
        }

        if ((GetTickCount() - StartTickCount) > dwMaxWait) {
            break;
        }

        if (!QueryServiceStatus(hService, &ServiceStatus )) {
            break;
        }

        if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
            if (ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED) {
                Sleep(500);
            } else {
                break;
            }
        } else if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {

            bStarted = TRUE;

        } else if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING) {
            Sleep(500);
        } else {
            Sleep(500);
        }
    }

Exit:

    if (lpServiceConfig) {
        LocalFree (lpServiceConfig);
    }

    if (hService) {
        CloseServiceHandle(hService);
    }

    if (hScManager) {
        CloseServiceHandle(hScManager);
    }

    return bStarted;
}

//
// Wrappers around the verify routines.
//

BOOLEAN
PfSvVerifyScenarioBuffer(
    PPF_SCENARIO_HEADER Scenario,
    ULONG BufferSize,
    PULONG FailedCheck
    )

/*++

Routine Description:

    This wrapper arounding PfVerifyScenarioBuffer traps exceptions such as in-page errors that
    may happen when the system is under stress. Otherwise these non-fatal failures may take
    down a service-host full of important system services.
    
Arguments:

    See PfVerifyScenarioBuffer.
    
Return Value:

    See PfVerifyScenarioBuffer.

--*/

{
    BOOLEAN Success;
    
    __try {

        Success = PfVerifyScenarioBuffer(Scenario, BufferSize, FailedCheck);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // We should not be masking other types of exceptions.
        //

        PFSVC_ASSERT(GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR);

        Success = FALSE;
        *FailedCheck = (ULONG) GetExceptionCode();
        
    }

    return Success;
    
}

//
// Try to keep the verification code below at the end of the file so it is 
// easier to copy.
//

//
// Verification code shared between the kernel and user mode
// components. This code should be kept in sync with a simple copy &
// paste, so don't add any kernel/user specific code/macros. Note that
// the prefix on the function names are Pf, just like it is with
// shared structures / constants.
//

BOOLEAN
PfWithinBounds(
    PVOID Pointer,
    PVOID Base,
    ULONG Length
    )

/*++

Routine Description:

    Check whether the pointer is within Length bytes from the base.

Arguments:

    Pointer - Pointer to check.

    Base - Pointer to base of mapping/array etc.

    Length - Number of bytes that are valid starting from Base.

Return Value:

    TRUE - Pointer is within bounds.
    
    FALSE - Pointer is not within bounds.

--*/

{
    if (((PCHAR)Pointer < (PCHAR)Base) ||
        ((PCHAR)Pointer >= ((PCHAR)Base + Length))) {

        return FALSE;
    } else {

        return TRUE;
    }
}

BOOLEAN
PfVerifyScenarioId (
    PPF_SCENARIO_ID ScenarioId
    )

/*++

Routine Description:

    Verify that the scenario id is sensible.

Arguments:

    ScenarioId - Scenario Id to verify.

Return Value:

    TRUE - ScenarioId is fine.
    FALSE - ScenarioId is corrupt.

--*/
    
{
    LONG CurCharIdx;

    //
    // Make sure the scenario name is NUL terminated.
    //

    for (CurCharIdx = PF_SCEN_ID_MAX_CHARS; CurCharIdx >= 0; CurCharIdx--) {

        if (ScenarioId->ScenName[CurCharIdx] == 0) {
            break;
        }
    }

    if (ScenarioId->ScenName[CurCharIdx] != 0) {
        return FALSE;
    }

    //
    // Make sure there is a scenario name.
    //

    if (CurCharIdx == 0) {
        return FALSE;
    }

    //
    // Checks passed.
    //
    
    return TRUE;
}

BOOLEAN
PfVerifyScenarioBuffer(
    PPF_SCENARIO_HEADER Scenario,
    ULONG BufferSize,
    PULONG FailedCheck
    )

/*++

Routine Description:

    Verify offset and indices in a scenario file are not beyond
    bounds. This code is shared between the user mode service and
    kernel mode component. If you update this function, update it in
    both.

Arguments:

    Scenario - Base of mapped view of the whole file.

    BufferSize - Size of the scenario buffer.

    FailedCheck - If verify failed, Id for the check that was failed.

Return Value:

    TRUE - Scenario is fine.
    FALSE - Scenario is corrupt.

--*/

{
    PPF_SECTION_RECORD Sections;
    PPF_SECTION_RECORD pSection;
    ULONG SectionIdx;
    PPF_PAGE_RECORD Pages;
    PPF_PAGE_RECORD pPage;
    LONG PageIdx;   
    PCHAR FileNames;
    PCHAR pFileNameStart;
    PCHAR pFileNameEnd;
    PWCHAR pwFileName;
    ULONG FileNameIdx;
    LONG FailedCheckId;
    ULONG NumRemainingPages;
    ULONG FileNameDataSize;
    ULONG NumPages;
    LONG PreviousPageIdx;
    ULONG FileNameSize;
    BOOLEAN ScenarioVerified;
    PCHAR MetadataInfoBase;
    PPF_METADATA_RECORD MetadataRecordTable;
    PPF_METADATA_RECORD MetadataRecord;
    ULONG MetadataRecordIdx;
    PWCHAR VolumePath;
    PFILE_PREFETCH FilePrefetchInfo;
    ULONG FilePrefetchInfoSize;
    PPF_COUNTED_STRING DirectoryPath;
    ULONG DirectoryIdx;

    //
    // Initialize locals.
    //

    FailedCheckId = 0;
        
    //
    // Initialize return value to FALSE. It will be set to TRUE only
    // after all the checks pass.
    //
    
    ScenarioVerified = FALSE;

    //
    // The buffer should at least contain the scenario header.
    //

    if (BufferSize < sizeof(PF_SCENARIO_HEADER)) {
        
        FailedCheckId = 10;
        goto cleanup;
    }

    //
    // Check version and magic on the header.
    //

    if (Scenario->Version != PF_CURRENT_VERSION ||
        Scenario->MagicNumber != PF_SCENARIO_MAGIC_NUMBER) { 

        FailedCheckId = 20;
        goto cleanup;
    }

    //
    // The buffer should not be greater than max allowed size.
    //

    if (BufferSize > PF_MAXIMUM_SCENARIO_SIZE) {
        
        FailedCheckId = 25;
        goto cleanup;
    }

    //
    // Check for legal scenario type.
    //

    if (Scenario->ScenarioType >= PfMaxScenarioType) {
        FailedCheckId = 27;
        goto cleanup;
    }

    //
    // Check limits on number of pages, sections etc.
    //

    if (Scenario->NumSections > PF_MAXIMUM_SECTIONS ||
        Scenario->NumMetadataRecords > PF_MAXIMUM_SECTIONS ||
        Scenario->NumPages > PF_MAXIMUM_PAGES ||
        Scenario->FileNameInfoSize > PF_MAXIMUM_FILE_NAME_DATA_SIZE) {
        
        FailedCheckId = 30;
        goto cleanup;
    }

    if (Scenario->NumSections == 0 ||
        Scenario->NumPages == 0 ||
        Scenario->FileNameInfoSize == 0) {
        
        FailedCheckId = 33;
        goto cleanup;
    }
    
    //
    // Check limit on sensitivity.
    //

    if (Scenario->Sensitivity < PF_MIN_SENSITIVITY ||
        Scenario->Sensitivity > PF_MAX_SENSITIVITY) {
        
        FailedCheckId = 35;
        goto cleanup;
    }

    //
    // Make sure the scenario id is valid.
    //

    if (!PfVerifyScenarioId(&Scenario->ScenarioId)) {
        
        FailedCheckId = 37;
        goto cleanup;
    }

    //
    // Initialize pointers to tables.
    //

    Sections = (PPF_SECTION_RECORD) ((PCHAR)Scenario + Scenario->SectionInfoOffset);
       
    if (!PfWithinBounds(Sections, Scenario, BufferSize)) {
        FailedCheckId = 40;
        goto cleanup;
    }

    if (!PfWithinBounds((PCHAR) &Sections[Scenario->NumSections] - 1, 
                        Scenario, 
                        BufferSize)) {
        FailedCheckId = 45;
        goto cleanup;
    }   

    Pages = (PPF_PAGE_RECORD) ((PCHAR)Scenario + Scenario->PageInfoOffset);
       
    if (!PfWithinBounds(Pages, Scenario, BufferSize)) {
        FailedCheckId = 50;
        goto cleanup;
    }

    if (!PfWithinBounds((PCHAR) &Pages[Scenario->NumPages] - 1, 
                        Scenario, 
                        BufferSize)) {
        FailedCheckId = 55;
        goto cleanup;
    }

    FileNames = (PCHAR)Scenario + Scenario->FileNameInfoOffset;
      
    if (!PfWithinBounds(FileNames, Scenario, BufferSize)) {
        FailedCheckId = 60;
        goto cleanup;
    }

    if (!PfWithinBounds(FileNames + Scenario->FileNameInfoSize - 1, 
                        Scenario, 
                        BufferSize)) {
        FailedCheckId = 70;
        goto cleanup;
    }

    MetadataInfoBase = (PCHAR)Scenario + Scenario->MetadataInfoOffset;
    MetadataRecordTable = (PPF_METADATA_RECORD) MetadataInfoBase;

    if (!PfWithinBounds(MetadataInfoBase, Scenario, BufferSize)) {
        FailedCheckId = 73;
        goto cleanup;
    }

    if (!PfWithinBounds(MetadataInfoBase + Scenario->MetadataInfoSize - 1, 
                        Scenario, 
                        BufferSize)) {
        FailedCheckId = 74;
        goto cleanup;
    }   

    if (!PfWithinBounds(((PCHAR) &MetadataRecordTable[Scenario->NumMetadataRecords]) - 1, 
                        Scenario, 
                        BufferSize)) {
        FailedCheckId = 75;
        goto cleanup;
    }   
    
    //
    // Verify that sections contain valid information.
    //

    NumRemainingPages = Scenario->NumPages;

    for (SectionIdx = 0; SectionIdx < Scenario->NumSections; SectionIdx++) {
        
        pSection = &Sections[SectionIdx];

        //
        // Check if file name is within bounds. 
        //

        pFileNameStart = FileNames + pSection->FileNameOffset;

        if (!PfWithinBounds(pFileNameStart, Scenario, BufferSize)) {
            FailedCheckId = 80;
            goto cleanup;
        }

        //
        // Make sure there is a valid sized file name. 
        //

        if (pSection->FileNameLength == 0) {
            FailedCheckId = 90;
            goto cleanup;    
        }

        //
        // Check file name max length.
        //

        if (pSection->FileNameLength > PF_MAXIMUM_SECTION_FILE_NAME_LENGTH) {
            FailedCheckId = 100;
            goto cleanup;    
        }

        //
        // Note that pFileNameEnd gets a -1 so it is the address of
        // the last byte.
        //

        FileNameSize = (pSection->FileNameLength + 1) * sizeof(WCHAR);
        pFileNameEnd = pFileNameStart + FileNameSize - 1;

        if (!PfWithinBounds(pFileNameEnd, Scenario, BufferSize)) {
            FailedCheckId = 110;
            goto cleanup;
        }

        //
        // Check if the file name is NUL terminated.
        //
        
        pwFileName = (PWCHAR) pFileNameStart;
        
        if (pwFileName[pSection->FileNameLength] != 0) {
            FailedCheckId = 120;
            goto cleanup;
        }

        //
        // Check max number of pages in a section.
        //

        if (pSection->NumPages > PF_MAXIMUM_SECTION_PAGES) {
            FailedCheckId = 140;
            goto cleanup;    
        }

        //
        // Make sure NumPages for the section is at least less
        // than the remaining pages in the scenario. Then update the
        // remaining pages.
        //

        if (pSection->NumPages > NumRemainingPages) {
            FailedCheckId = 150;
            goto cleanup;
        }

        NumRemainingPages -= pSection->NumPages;

        //
        // Verify that there are NumPages pages in our page list and
        // they are sorted by file offset.
        //

        PageIdx = pSection->FirstPageIdx;
        NumPages = 0;
        PreviousPageIdx = PF_INVALID_PAGE_IDX;

        while (PageIdx != PF_INVALID_PAGE_IDX) {
            
            //
            // Check that page idx is within range.
            //
            
            if (PageIdx < 0 || (ULONG) PageIdx >= Scenario->NumPages) {
                FailedCheckId = 160;
                goto cleanup;
            }

            //
            // If this is not the first page record, make sure it
            // comes after the previous one. We also check for
            // duplicate offset here.
            //

            if (PreviousPageIdx != PF_INVALID_PAGE_IDX) {
                if (Pages[PageIdx].FileOffset <= 
                    Pages[PreviousPageIdx].FileOffset) {

                    FailedCheckId = 165;
                    goto cleanup;
                }
            }

            //
            // Update the last page index.
            //

            PreviousPageIdx = PageIdx;

            //
            // Get the next page index.
            //

            pPage = &Pages[PageIdx];
            PageIdx = pPage->NextPageIdx;
            
            //
            // Update the number of pages we've seen on the list so
            // far. If it is greater than what there should be on the
            // list we have a problem. We may have even hit a list.
            //

            NumPages++;
            if (NumPages > pSection->NumPages) {
                FailedCheckId = 170;
                goto cleanup;
            }
        }
        
        //
        // Make sure the section has exactly the number of pages it
        // says it does.
        //

        if (NumPages != pSection->NumPages) {
            FailedCheckId = 180;
            goto cleanup;
        }
    }

    //
    // We should have accounted for all pages in the scenario.
    //

    if (NumRemainingPages) {
        FailedCheckId = 190;
        goto cleanup;
    }

    //
    // Make sure metadata prefetch records make sense.
    //

    for (MetadataRecordIdx = 0;
         MetadataRecordIdx < Scenario->NumMetadataRecords;
         MetadataRecordIdx++) {

        MetadataRecord = &MetadataRecordTable[MetadataRecordIdx];
        
        //
        // Make sure that the volume path is within bounds and NUL
        // terminated.
        //

        VolumePath = (PWCHAR)(MetadataInfoBase + MetadataRecord->VolumeNameOffset);  
        
        if (!PfWithinBounds(VolumePath, Scenario, BufferSize)) {
            FailedCheckId = 200;
            goto cleanup;
        }

        if (!PfWithinBounds(((PCHAR)(VolumePath + MetadataRecord->VolumeNameLength + 1)) - 1, 
                            Scenario, 
                            BufferSize)) {
            FailedCheckId = 210;
            goto cleanup;
        }

        if (VolumePath[MetadataRecord->VolumeNameLength] != 0) {
            FailedCheckId = 220;
            goto cleanup;           
        }

        //
        // Make sure that FilePrefetchInformation is within bounds.
        //

        FilePrefetchInfo = (PFILE_PREFETCH) 
            (MetadataInfoBase + MetadataRecord->FilePrefetchInfoOffset);
        
        if (!PfWithinBounds(FilePrefetchInfo, Scenario, BufferSize)) {
            FailedCheckId = 230;
            goto cleanup;
        }

        //
        // Its size should be greater than size of a FILE_PREFETCH
        // structure (so we can safely access the fields).
        //

        if (MetadataRecord->FilePrefetchInfoSize < sizeof(FILE_PREFETCH)) {
            FailedCheckId = 240;
            goto cleanup;
        }
        
        //
        // It should be for prefetching file creates.
        //

        if (FilePrefetchInfo->Type != FILE_PREFETCH_TYPE_FOR_CREATE) {
            FailedCheckId = 250;
            goto cleanup;
        }

        //
        // There should not be more entries then are files and
        // directories. The number of inidividual directories may be
        // more than what we allow for, but it would be highly rare to
        // be suspicious and thus ignored.
        //

        if (FilePrefetchInfo->Count > PF_MAXIMUM_DIRECTORIES + PF_MAXIMUM_SECTIONS) {
            FailedCheckId = 260;
            goto cleanup;
        }

        //
        // Its size should match the size calculated by number of file
        // index numbers specified in the header.
        //

        FilePrefetchInfoSize = sizeof(FILE_PREFETCH);
        if (FilePrefetchInfo->Count) {
            FilePrefetchInfoSize += (FilePrefetchInfo->Count - 1) * sizeof(ULONGLONG);
        }

        if (!PfWithinBounds((PCHAR) FilePrefetchInfo + MetadataRecord->FilePrefetchInfoSize - 1,
                            Scenario,
                            BufferSize)) {
            FailedCheckId = 270;
            goto cleanup;
        }

        //
        // Make sure that the directory paths for this volume make
        // sense.
        //

        if (MetadataRecord->NumDirectories > PF_MAXIMUM_DIRECTORIES) {
            FailedCheckId = 280;
            goto cleanup;
        }

        DirectoryPath = (PPF_COUNTED_STRING) 
            (MetadataInfoBase + MetadataRecord->DirectoryPathsOffset);
        
        for (DirectoryIdx = 0;
             DirectoryIdx < MetadataRecord->NumDirectories;
             DirectoryIdx ++) {
            
            //
            // Make sure head of the structure is within bounds.
            //

            if (!PfWithinBounds((PCHAR)DirectoryPath + sizeof(PF_COUNTED_STRING) - 1, 
                                Scenario, 
                                BufferSize)) {
                FailedCheckId = 290;
                goto cleanup;
            }
                
            //
            // Check the length of the string.
            //
            
            if (DirectoryPath->Length >= PF_MAXIMUM_SECTION_FILE_NAME_LENGTH) {
                FailedCheckId = 300;
                goto cleanup;
            }

            //
            // Make sure end of the string is within bounds.
            //
            
            if (!PfWithinBounds((PCHAR)(&DirectoryPath->String[DirectoryPath->Length + 1]) - 1,
                                Scenario, 
                                BufferSize)) {
                FailedCheckId = 310;
                goto cleanup;
            }
            
            //
            // Make sure the string is NUL terminated.
            //
            
            if (DirectoryPath->String[DirectoryPath->Length] != 0) {
                FailedCheckId = 320;
                goto cleanup;   
            }
            
            //
            // Set pointer to next DirectoryPath.
            //
            
            DirectoryPath = (PPF_COUNTED_STRING) 
                (&DirectoryPath->String[DirectoryPath->Length + 1]);
        }            
    }

    //
    // We've passed all the checks.
    //

    ScenarioVerified = TRUE;

 cleanup:

    *FailedCheck = FailedCheckId;

    return ScenarioVerified;
}

BOOLEAN
PfVerifyTraceBuffer(
    PPF_TRACE_HEADER Trace,
    ULONG BufferSize,
    PULONG FailedCheck
    )

/*++

Routine Description:

    Verify offset and indices in a trace buffer are not beyond
    bounds. This code is shared between the user mode service and
    kernel mode component. If you update this function, update it in
    both.

Arguments:

    Trace - Base of Trace buffer.

    BufferSize - Size of the scenario file / mapping.

    FailedCheck - If verify failed, Id for the check that was failed.

Return Value:

    TRUE - Trace is fine.
    FALSE - Trace is corrupt;

--*/

{
    LONG FailedCheckId;
    PVOID Offset;
    PPF_LOG_ENTRY LogEntries;
    PPF_SECTION_INFO Section;
    PPF_VOLUME_INFO VolumeInfo;
    ULONG SectionLength;
    ULONG EntryIdx;
    ULONG SectionIdx;
    ULONG TotalFaults;
    ULONG PeriodIdx;
    ULONG VolumeIdx;
    BOOLEAN TraceVerified;
    ULONG VolumeInfoSize;

    //
    // Initialize locals:
    //

    FailedCheckId = 0;

    //
    // Initialize return value to FALSE. It will be set to TRUE only
    // after all the checks pass.
    //

    TraceVerified = FALSE;

    //
    // The buffer should at least contain the scenario header.
    //

    if (BufferSize < sizeof(PF_TRACE_HEADER)) {
        FailedCheckId = 10;
        goto cleanup;
    }

    //
    // Check version and magic on the header.
    //

    if (Trace->Version != PF_CURRENT_VERSION ||
        Trace->MagicNumber != PF_TRACE_MAGIC_NUMBER) {
        FailedCheckId = 20;
        goto cleanup;
    }

    //
    // The buffer should not be greater than max allowed size.
    //

    if (BufferSize > PF_MAXIMUM_TRACE_SIZE) {
        FailedCheckId = 23;
        goto cleanup;
    }

    //
    // Check for legal scenario type.
    //

    if (Trace->ScenarioType >= PfMaxScenarioType) {
        FailedCheckId = 25;
        goto cleanup;
    }

    //
    // Check limits on number of pages, sections etc.
    //

    if (Trace->NumSections > PF_MAXIMUM_SECTIONS ||
        Trace->NumEntries > PF_MAXIMUM_LOG_ENTRIES ||
        Trace->NumVolumes > PF_MAXIMUM_SECTIONS) {
        FailedCheckId = 30;
        goto cleanup;
    }

    //
    // Check buffer size and the size of the trace.
    //

    if (Trace->Size != BufferSize) {
        FailedCheckId = 35;
        goto cleanup;
    }

    //
    // Make sure the scenario id is valid.
    //

    if (!PfVerifyScenarioId(&Trace->ScenarioId)) {
        
        FailedCheckId = 37;
        goto cleanup;
    }

    //
    // Check Bounds of Trace Buffer
    //

    LogEntries = (PPF_LOG_ENTRY) ((PCHAR)Trace + Trace->TraceBufferOffset);

    if (!PfWithinBounds(LogEntries, Trace, BufferSize)) {
        FailedCheckId = 40;
        goto cleanup;
    }

    if (!PfWithinBounds((PCHAR)&LogEntries[Trace->NumEntries] - 1, 
                        Trace, 
                        BufferSize)) {
        FailedCheckId = 50;
        goto cleanup;
    }

    //
    // Verify pages contain valid information.
    //

    for (EntryIdx = 0; EntryIdx < Trace->NumEntries; EntryIdx++) {

        //
        // Make sure sequence number is within bounds.
        //

        if (LogEntries[EntryIdx].SectionId >= Trace->NumSections) {
            FailedCheckId = 60;
            goto cleanup;
        }
    }

    //
    // Verify section info entries are valid.
    //

    Section = (PPF_SECTION_INFO) ((PCHAR)Trace + Trace->SectionInfoOffset);

    for (SectionIdx = 0; SectionIdx < Trace->NumSections; SectionIdx++) {

        //
        // Make sure the section is within bounds.
        //

        if (!PfWithinBounds(Section, Trace, BufferSize)) {
            FailedCheckId = 70;
            goto cleanup;
        }

        //
        // Make sure the file name is not too big.
        //

        if(Section->FileNameLength > PF_MAXIMUM_SECTION_FILE_NAME_LENGTH) {
            FailedCheckId = 80;
            goto cleanup;
        }
        
        //
        // Make sure the file name is NUL terminated.
        //
        
        if (Section->FileName[Section->FileNameLength] != 0) {
            FailedCheckId = 90;
            goto cleanup;
        }

        //
        // Calculate size of this section entry.
        //

        SectionLength = sizeof(PF_SECTION_INFO) +
            (Section->FileNameLength) * sizeof(WCHAR);

        //
        // Make sure all of the data in the section info is within
        // bounds.
        //

        if (!PfWithinBounds((PUCHAR)Section + SectionLength - 1, 
                            Trace, 
                            BufferSize)) {

            FailedCheckId = 100;
            goto cleanup;
        }

        //
        // Set pointer to next section.
        //

        Section = (PPF_SECTION_INFO) ((PUCHAR) Section + SectionLength);
    }

    //
    // Check FaultsPerPeriod information.
    //

    if (!PfWithinBounds((PCHAR)&Trace->FaultsPerPeriod[PF_MAX_NUM_TRACE_PERIODS] - 1,
                        Trace,
                        BufferSize)) {
        FailedCheckId = 110;
        goto cleanup;
    }

    TotalFaults = 0;

    for (PeriodIdx = 0; PeriodIdx < PF_MAX_NUM_TRACE_PERIODS; PeriodIdx++) {
        TotalFaults += Trace->FaultsPerPeriod[PeriodIdx];
    }

    if (TotalFaults > Trace->NumEntries) {
        FailedCheckId = 120;
        goto cleanup;
    }

    //
    // Verify the volume information block.
    //

    VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR)Trace + Trace->VolumeInfoOffset);

    if (!PfWithinBounds(VolumeInfo, Trace, BufferSize)) {
        FailedCheckId = 130;
        goto cleanup;
    }

    if (!PfWithinBounds((PCHAR)VolumeInfo + Trace->VolumeInfoSize - 1, 
                        Trace, 
                        BufferSize)) {
        FailedCheckId = 140;
        goto cleanup;
    }
    
    //
    // If there are sections, we should have at least one volume.
    //

    if (Trace->NumSections && !Trace->NumVolumes) {
        FailedCheckId = 150;
        goto cleanup;
    }

    //
    // Verify the volume info structures per volume.
    //

    for (VolumeIdx = 0; VolumeIdx < Trace->NumVolumes; VolumeIdx++) {
        
        //
        // Make sure the whole volume structure is within bounds. Note
        // that VolumeInfo structure contains space for the
        // terminating NUL.
        //

        VolumeInfoSize = sizeof(PF_VOLUME_INFO);
        VolumeInfoSize += VolumeInfo->VolumePathLength * sizeof(WCHAR);
        
        if (!PfWithinBounds((PCHAR) VolumeInfo + VolumeInfoSize - 1,
                            Trace,
                            BufferSize)) {
            FailedCheckId = 160;
            goto cleanup;
        }
        
        //
        // Verify that the volume path string is terminated.
        //

        if (VolumeInfo->VolumePath[VolumeInfo->VolumePathLength] != 0) {
            FailedCheckId = 170;
            goto cleanup;
        }
        
        //
        // Get the next volume.
        //

        VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR) VolumeInfo + VolumeInfoSize);
        
        //
        // Make sure VolumeInfo is aligned.
        //

        VolumeInfo = PF_ALIGN_UP(VolumeInfo, _alignof(PF_VOLUME_INFO));
    }

    //
    // We've passed all the checks.
    //
    
    TraceVerified = TRUE;
    
 cleanup:

    *FailedCheck = FailedCheckId;

    return TraceVerified;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\service\daytona\test\pfctrl\pfctrl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pfctrl.c

Abstract:

    This module builds a console test program to control various
    parameters of the prefetcher maintenance service.

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <aclapi.h>
#include "prefetch.h"
#include "idletask.h"
#include "..\..\pfsvc.h"

WCHAR *PfCtrlUsage = 
L"                                                                          \n"
L"Usage: pfctrl [-override_idle=[0|1]] [-process_all]                       \n"
L"  Controls the prefetcher maintenance service.                            \n"
L"                                                                          \n"
L"Arguments:                                                                \n"
L"  -override_idle=[0|1]  - Whether to wait for system to be idle before    \n"
L"                          processing prefetcher traces.                   \n"
L"  -process_all          - Sets the override-idle event and waits for all  \n"
L"                          current traces to be processed.                 \n"
L"                                                                          \n"
;

int 
__cdecl 
main(int argc, char* argv[])
{
    WCHAR *CommandLine;
    WCHAR *Argument;
    DWORD ErrorCode;
    ULONG OverrideIdle;
    BOOLEAN EventIsSet;
    HANDLE OverrideIdleEvent;
    HANDLE ProcessingCompleteEvent;
    DWORD WaitResult;
    BOOLEAN ResetOverrideIdleEvent;

    //
    // Initialize locals.
    //

    OverrideIdleEvent = NULL;
    ProcessingCompleteEvent = NULL;
    CommandLine = GetCommandLine();

    if (Argument = wcsstr(CommandLine, L"-override_idle=")) {
        
        swscanf(Argument, L"-override_idle=%d", &OverrideIdle);

        //
        // Open the override idle processing event.
        //

        OverrideIdleEvent = OpenEvent(EVENT_ALL_ACCESS,
                                      FALSE,
                                      PFSVC_OVERRIDE_IDLE_EVENT_NAME);

        if (!OverrideIdleEvent) {
            ErrorCode = GetLastError();
            wprintf(L"Could not open override-idle-processing event: %x\n", ErrorCode);
            goto cleanup;
        }

        //
        // Determine the current status of the event.
        //

        WaitResult = WaitForSingleObject(OverrideIdleEvent,
                                         0);
        
        if (WaitResult == WAIT_OBJECT_0) {
            EventIsSet = TRUE;
        } else {
            EventIsSet = FALSE;
        }

        //
        // Do what we are asked to do:
        //

        if (OverrideIdle) {

            if (EventIsSet) {

                wprintf(L"Override event is already set!\n");
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;

            } else {
            
                wprintf(L"Setting the override idle processing event.\n");
                SetEvent(OverrideIdleEvent);
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }

        } else {

            if (!EventIsSet) {

                wprintf(L"Override event is already cleared!\n");
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;

            } else {

                wprintf(L"Clearing the override idle processing event.\n");
                ResetEvent(OverrideIdleEvent);
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }
        }

    } else if (Argument = wcsstr(CommandLine, L"-process_all")) {

        //
        // Open the override-idle-processing and processing-complete
        // events.
        //

        OverrideIdleEvent = OpenEvent(EVENT_ALL_ACCESS,
                                      FALSE,
                                      PFSVC_OVERRIDE_IDLE_EVENT_NAME);

        if (!OverrideIdleEvent) {
            ErrorCode = GetLastError();
            wprintf(L"Could not open override-idle-processing event: %x\n", ErrorCode);
            goto cleanup;
        }
        
        ProcessingCompleteEvent = OpenEvent(EVENT_ALL_ACCESS,
                                            FALSE,
                                            PFSVC_PROCESSING_COMPLETE_EVENT_NAME);

        if (!ProcessingCompleteEvent) {
            ErrorCode = GetLastError();
            wprintf(L"Could not open processing-complete event: %x\n", ErrorCode);
            goto cleanup;
        }

        //
        // Determine the current status of the override-idle event.
        //

        WaitResult = WaitForSingleObject(OverrideIdleEvent,
                                         0);
        
        if (WaitResult == WAIT_OBJECT_0) {
            EventIsSet = TRUE;
        } else {
            EventIsSet = FALSE;
        }
        
        //
        // Set the override-idle event to force processing of traces
        // right away.
        //

        if (!EventIsSet) {

            wprintf(L"Setting override idle event.\n");

            SetEvent(OverrideIdleEvent);

            ResetOverrideIdleEvent = TRUE;

        } else {

            wprintf(L"WARNING: Override-idle event is already set. "
                    L"It won't be reset.\n");

            ResetOverrideIdleEvent = FALSE;
        }

        //
        // Wait for processing complete event to get signaled.
        //
        
        wprintf(L"Waiting for all traces to be processed... ");
        
        WaitResult = WaitForSingleObject(ProcessingCompleteEvent, INFINITE);
        
        if (WaitResult != WAIT_OBJECT_0) {
            
            ErrorCode = GetLastError();
            wprintf(L"There was an error: %x\n", ErrorCode);
            goto cleanup;
        }
        
        wprintf(L"Done!\n");
        
        //
        // Reset the override idle event if necessary.
        //
        
        if (ResetOverrideIdleEvent) {
            
            wprintf(L"Resetting override-idle-processing event.\n");
            ResetEvent(OverrideIdleEvent);
        }

        ErrorCode = ERROR_SUCCESS;
        goto cleanup;

    } else {

        wprintf(PfCtrlUsage);
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // We should not come here.
    //

    PFSVC_ASSERT(FALSE);
    
    ErrorCode = ERROR_GEN_FAILURE;

 cleanup:

    if (OverrideIdleEvent) {
        CloseHandle(OverrideIdleEvent);
    }
    
    if (ProcessingCompleteEvent) {
        CloseHandle(ProcessingCompleteEvent);
    }

    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\service\daytona\pfsvc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pfsvc.h

Abstract:

    This module contains private declarations for the prefetcher
    service responsible for maintaining prefetch scenario files.

Author:

    Stuart Sechrest (stuartse)
    Cenk Ergan (cenke)
    Chuck Leinzmeier (chuckl)

Environment:

    User Mode

--*/

#ifndef _PFSVC_H_
#define _PFSVC_H_

//
// This is the version of the prefetcher maintenance service. It does
// not have to be in sync with the the prefetcher PF_CURRENT_VERSION.
//

#define PFSVC_SERVICE_VERSION           15

//
// This is the maximum number of traces that will be acquired from the
// kernel and put on the list in the service waiting to be processed.
//

#define PFSVC_MAX_NUM_QUEUED_TRACES     100

//
// If the number of faults in a trace period falls below this, that
// marks the end of the trace for some scenario types.
//

#define PFSVC_MIN_FAULT_THRESHOLD       10

//
// What the rate of usage for the pages we prefetched should be
// greater than for us not to increase scenario sensitivity.
//

#define PFSVC_MIN_HIT_PERCENTAGE        90

//
// What the rate of usage for the pages we knew about but ignored
// should be less than for us not to decrease scenario sensitivity.
//

#define PFSVC_MAX_IGNORED_PERCENTAGE    30

//
// This is the number of launches after which we will set the
// MinReTraceTime and MinRePrefetchTime's on the scenario's header to
// limit prefetch activity if a scenario gets launched very
// frequently. This allows short training scenarios to be run before
// benchmarking after deleting the prefetch files.
//

#define PFSVC_MIN_LAUNCHES_FOR_LAUNCH_FREQ_CHECK     10

//
// This is the default time in 100ns that has to pass from the last
// launch of a scenario before we prefetch it again.
//

#define PFSVC_DEFAULT_MIN_REPREFETCH_TIME            (1i64 * 120 * 1000 * 1000 * 10)

//
// This is the default time in 100ns that has to pass from the last
// launch of a scenario before we prefetch it again.
//

#define PFSVC_DEFAULT_MIN_RETRACE_TIME               (1i64 * 120 * 1000 * 1000 * 10) 

//
// This is the maximum number of prefetch scenario files we'll have in 
// the prefetch directory. Once we reach this amount we won't create 
// new scenario files until we clean up the old ones.
//

#if DBG
#define PFSVC_MAX_PREFETCH_FILES                     12
#else // DBG
#define PFSVC_MAX_PREFETCH_FILES                     128
#endif // DBG

//
// Path to the registry key and name of the value that specifies the
// file the defragger uses to determine optimal layout of files on the
// disk.
//

#define PFSVC_OPTIMAL_LAYOUT_REG_KEY_PATH       \
    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\OptimalLayout"
#define PFSVC_OPTIMAL_LAYOUT_REG_VALUE_NAME     \
    L"LayoutFilePath"
#define PFSVC_OPTIMAL_LAYOUT_FILE_DEFAULT_NAME  \
    L"Layout.ini"
#define PFSVC_OPTIMAL_LAYOUT_ENABLE_VALUE_NAME  \
    L"EnableAutoLayout"

//
// Path to the registry key under which we store various service data,
// e.g. version, last time the defragger was run successfully to
// update layout etc.
//

#define PFSVC_SERVICE_DATA_KEY                  \
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Prefetcher"

//
// These are the value names under PFSVC_SERVICE_DATA_KEY in which we
// store various prefetcher service data.
//

#define PFSVC_VERSION_VALUE_NAME                \
    L"Version"

#define PFSVC_START_TIME_VALUE_NAME             \
    L"StartTime"

#define PFSVC_EXIT_TIME_VALUE_NAME              \
    L"ExitTime"

#define PFSVC_EXIT_CODE_VALUE_NAME              \
    L"ExitCode"

#define PFSVC_LAST_DISK_LAYOUT_TIME_STRING_VALUE_NAME  \
    L"LastDiskLayoutTimeString"

#define PFSVC_TRACES_PROCESSED_VALUE_NAME       \
    L"TracesProcessed"

#define PFSVC_TRACES_SUCCESSFUL_VALUE_NAME      \
    L"TracesSuccessful"

#define PFSVC_LAST_TRACE_FAILURE_VALUE_NAME     \
    L"LastTraceFailure"

#define PFSVC_BOOT_FILES_OPTIMIZED_VALUE_NAME   \
    L"BootFilesOptimized"

#define PFSVC_MIN_RELAYOUT_HOURS_VALUE_NAME     \
    L"MinRelayoutHours"

//
// This is the value name under PFSVC_SERVICE_DATA_KEY in which we
// store the last time the defragger was run successfully to update
// layout.
//

#define PFSVC_LAST_DISK_LAYOUT_TIME_VALUE_NAME  \
    L"LastDiskLayoutTime"

//
// This is the registry path to the NLS configuration key.
//

#define PFSVC_NLS_REG_KEY_PATH                  \
    L"SYSTEM\\CurrentControlSet\\Control\\Nls"

//
// This is the name of the named manual-reset event that can be set to
// override waiting for system to be idle before processing traces.
//

#define PFSVC_OVERRIDE_IDLE_EVENT_NAME       L"PrefetchOverrideIdle"

//
// This is the name of the named manual-reset event that will be set
// when there are no traces left to process.
//

#define PFSVC_PROCESSING_COMPLETE_EVENT_NAME L"PrefetchProcessingComplete"

//
// When we have run the defragger for all drives after a setup / upgrade,
// we set the build status registry value to this string:
//

#define PFSVC_DEFRAG_DRIVES_DONE             L"DefragDone"

//
// Number of 100ns in an hour.
//

#define PFSVC_NUM_100NS_IN_AN_HOUR           (1i64 * 60 * 60 * 1000 * 1000 * 10)

//
// This is how many 100ns have to pass since last disk layout for us to do
// another one, if we are not being explicitly run.
//

#define PFSVC_MIN_TIME_BEFORE_DISK_RELAYOUT  (1i64 * 3 * 24 * PFSVC_NUM_100NS_IN_AN_HOUR)

//
// Allocation granularity for trace buffers.
//

#define ROUND_TRACE_BUFFER_SIZE(_required) (((_required) + 16384 - 1) & ~(16384 - 1))

//
// Define useful macros. As with all macros, must be careful of parameter
// reevalation. Don't use expressions as macro parameters.
//

#define PFSVC_ALLOC(NumBytes)          (HeapAlloc(GetProcessHeap(),0,(NumBytes)))
#define PFSVC_REALLOC(Buffer,NumBytes) (HeapReAlloc(GetProcessHeap(),0,(Buffer),(NumBytes)))
#define PFSVC_FREE(Buffer)             (HeapFree(GetProcessHeap(),0,(Buffer)))

//
// This magic is used to mark free'd memory in chunk allocator.
//

#define PFSVC_CHUNK_ALLOCATOR_FREED_MAGIC  0xFEEDCEED

//
// This magic is used to mark free'd memory in chunk allocator.
//

#define PFSVC_STRING_ALLOCATOR_FREED_MAGIC 0xFEED

//
// This is the max size for the strings allocated from the string
// allocator that will be allocated from the preallocated buffer, so we 
// can save the size of the allocation with the header in a USHORT.
// 

#define PFSVC_STRING_ALLOCATOR_MAX_BUFFER_ALLOCATION_SIZE 60000

//
// These macros are used to acquire/release a mutex.
//

#define PFSVC_ACQUIRE_LOCK(Lock)                                                        \
    DBGPR((PFID,PFLOCK,"PFSVC: AcquireLock-Begin(%s,%d,%s)\n",#Lock,__LINE__,__FILE__));\
    WaitForSingleObject((Lock), INFINITE);                                              \
    DBGPR((PFID,PFLOCK,"PFSVC: AcquireLock-End(%s,%d,%s)\n",#Lock,__LINE__,__FILE__));  \

#define PFSVC_RELEASE_LOCK(Lock)                                                        \
    ReleaseMutex((Lock));                                                               \
    DBGPR((PFID,PFLOCK,"PFSVC: ReleaseLock(%s,%d,%s)\n",#Lock,__LINE__,__FILE__));      \

//
// Internal type and constant definitions: Entries in the trace and in
// the existing scenario file are put into these structures for easier
// manipulation and policy implementation.
//

typedef struct _PFSVC_SECTION_NODE {
   
    union {

        //
        // Link in the scenarios list of section nodes.
        //

        LIST_ENTRY SectionLink;

        //
        // These fields are used to sort section nodes by first
        // access.
        //

        struct {
            struct _PFSVC_SECTION_NODE *LeftChild;
            struct _PFSVC_SECTION_NODE *RightChild;
        };
    };

    //
    // Filesystem index number for this section is saved here if it is
    // retrieved. If the section node is for the MFT for the volume we
    // save the number of pages to prefetch from it here.
    //

    union {
        LARGE_INTEGER FileIndexNumber;
        ULONG MFTNumPagesToPrefetch;  
    };

    //
    // This is the section record that we will setup and save in the
    // scenario file.
    //

    PF_SECTION_RECORD SectionRecord;

    //
    // File path for this section.
    //

    WCHAR *FilePath;
    
    //
    // List of page nodes belonging to this section.
    //

    LIST_ENTRY PageList;

    //
    // This is the index of the section in the new trace file when
    // ordered by first access [i.e. page fault].
    //
    
    ULONG NewSectionIndex;

    //
    // This is the index of the section in the original scenario file.
    //

    ULONG OrgSectionIndex;

    //
    // Link in the volume's list of section nodes.
    //

    LIST_ENTRY SectionVolumeLink;

} PFSVC_SECTION_NODE, *PPFSVC_SECTION_NODE;

//
// This structure contains a path and is used with the path list below.
//

typedef struct _PFSVC_PATH {

    //
    // Link in the path list sorted by insertion order.
    //

    LIST_ENTRY InOrderLink;

    //
    // Link in the path list sorted lexically.
    //

    LIST_ENTRY SortedLink;

    //
    // Number of characters in the path excluding terminating NUL.
    //

    ULONG Length;

    //
    // NUL terminated path.
    //

    WCHAR Path[1];

} PFSVC_PATH, *PPFSVC_PATH;

//
// This structure holds a list paths. You should manipulate the
// list or walk through paths in it only using the PathList APIs
// (e.g. GetNextPathInOrder).
//

//
// Wrapper around section records.
//

typedef struct _PFSVC_PATH_LIST {

    //
    // The list of paths sorted by insertion order.
    //

    LIST_ENTRY InOrderList;
    
    //
    // The list of paths sorted lexically.
    //

    LIST_ENTRY SortedList;

    //
    // If non NULL, we will make allocations for new entries from it
    // instead of hitting the heap.
    //

    struct _PFSVC_STRING_ALLOCATOR *Allocator;

    //
    // Number of paths in the list.
    //

    ULONG NumPaths;
    
    //
    // Total length of the paths in the list excluding NULs.
    //

    ULONG TotalLength;

    //
    // Whether list will be case sensitive or not.
    //

    BOOLEAN CaseSensitive;

} PFSVC_PATH_LIST, *PPFSVC_PATH_LIST;

//
// This structure is used to divide sections in a scenario to
// different disk volumes (i.e. c:, d:) they are on.
//

typedef struct _PFSVC_VOLUME_NODE {

    //
    // Link in the scenario's list of volume nodes.
    //

    LIST_ENTRY VolumeLink;

    //
    // Volume path and length in number of characters excluding NUL.
    //

    WCHAR *VolumePath;
    ULONG VolumePathLength;
    
    //
    // List of sections that are on this volume that will be prefetched.
    //

    LIST_ENTRY SectionList;
    ULONG NumSections;

    //
    // This is the total number of sections on this volume, including
    // those that won't be prefetched.
    //

    ULONG NumAllSections;

    //
    // List of directories accessed on this volume.
    //
    
    PFSVC_PATH_LIST DirectoryList;

    //
    // Serial Number/Creation time for this volume. This is retrieved
    // either from a new trace or from the existing scenarion file
    // (both should match or the scenario file gets discarded.)
    //

    LARGE_INTEGER CreationTime;
    ULONG SerialNumber;

    //
    // Pointer to section node for the MFT for this volume (if there is one).
    //

    PPFSVC_SECTION_NODE MFTSectionNode;

} PFSVC_VOLUME_NODE, *PPFSVC_VOLUME_NODE;

//
// Wrapper around page records.
//

typedef struct _PFSVC_PAGE_NODE {

    //
    // Link in the section node's list of pages.
    //

    LIST_ENTRY PageLink;

    //
    // Page record from previous scenario instructions or a new one
    // initialized for a trace log entry.
    //

    PF_PAGE_RECORD PageRecord;

} PFSVC_PAGE_NODE, *PPFSVC_PAGE_NODE;

//
// This structure is used to make a single big allocation and give it away
// in small chunks to be used as strings. It is very simple and will not reclaim 
// freed memory for future allocs. The whole allocation will be freed in cleanup. 
// There is no synchronization.
//

typedef struct _PFSVC_STRING_ALLOCATOR {

    //
    // Actual allocation to be divided up and given away in small chunks.
    //

    PCHAR Buffer;

    //
    // End of buffer. If FreePointer is equal to beyond this we can't give
    // away more from this buffer.
    //

    PCHAR BufferEnd;

    //
    // Pointer to start of free memory in Buffer.
    //

    PCHAR FreePointer;

    //
    // Number of times we had to hit the heap because we ran out of space
    // and the current outstanding such allocations.
    //

    ULONG MaxHeapAllocs;
    ULONG NumHeapAllocs;

    //
    // Size of the last allocation that was made from the buffer.
    //

    USHORT LastAllocationSize;

    //
    // Whether user has passed in Buffer (so we don't free it when
    // cleaning up.
    //

    ULONG UserSpecifiedBuffer:1;

} PFSVC_STRING_ALLOCATOR, *PPFSVC_STRING_ALLOCATOR;

//
// This structure comes before allocations from the string allocator buffer.
//

typedef struct _PFSVC_STRING_ALLOCATION_HEADER {

    union {

        //
        // This structure contains the actual fields.
        //

        struct {

            //
            // Size of the preceding allocation.
            //

            USHORT PrecedingAllocationSize;

            //
            // Size of this allocation.
            //

            USHORT AllocationSize;

        };

        //
        // Require pointer alignment for this structure, so allocations
        // from the string allocator end up pointer aligned.
        //

        PVOID FieldToRequirePointerAlignment;
    };

} PFSVC_STRING_ALLOCATION_HEADER, *PPFSVC_STRING_ALLOCATION_HEADER;

//
// This structure is used to make a single big allocation and give it away
// to be used as page nodes, sections nodes etc in small chunks. It is very 
// simple and will not reclaim freed small chunks for future allocs. The whole
// allocation will be freed in cleanup. The chunk size and max allocs to satisfy
// is fixed at initialization. There is no synchronization.
//

typedef struct _PFSVC_CHUNK_ALLOCATOR {

    //
    // Actual allocation to be divided up and given away in small chunks.
    //

    PCHAR Buffer;

    //
    // End of buffer. If FreePointer is equal to beyond this we can't give
    // away more from this buffer.
    //

    PCHAR BufferEnd;

    //
    // Pointer to start of free memory in Buffer.
    //

    PCHAR FreePointer;

    //
    // How big each chunk will be in bytes.
    //

    ULONG ChunkSize;

    //
    // Number of times we had to hit the heap because we ran out of space
    // and the current outstanding such allocations.
    //

    ULONG MaxHeapAllocs;
    ULONG NumHeapAllocs;

    //
    // Whether user has passed in Buffer (so we don't free it when
    // cleaning up.
    //

    ULONG UserSpecifiedBuffer:1;

} PFSVC_CHUNK_ALLOCATOR, *PPFSVC_CHUNK_ALLOCATOR;

//
// Wrapper around a scenario structure.
//

typedef struct _PFSVC_SCENARIO_INFO {

    //
    // Header information for the scenario instructions in preparation.
    //

    PF_SCENARIO_HEADER ScenHeader;

    //
    // Allocators used to make allocations for scenario processing efficient.
    //

    PVOID OneBigAllocation;
    PFSVC_CHUNK_ALLOCATOR SectionNodeAllocator;
    PFSVC_CHUNK_ALLOCATOR PageNodeAllocator;
    PFSVC_CHUNK_ALLOCATOR VolumeNodeAllocator;
    PFSVC_STRING_ALLOCATOR PathAllocator;

    //
    // Container for the sections in this scenario.
    //

    LIST_ENTRY SectionList;

    //
    // List of disk volumes that the scenario's sections are on. This
    // list is sorted lexically.
    //

    LIST_ENTRY VolumeList;

    //
    // Various statistics acquired from the trace information and used
    // in applying prefetch policy.
    //

    ULONG NewPages;
    ULONG HitPages;
    ULONG MissedOpportunityPages;
    ULONG IgnoredPages;
    ULONG PrefetchedPages;

} PFSVC_SCENARIO_INFO, *PPFSVC_SCENARIO_INFO;

//
// This is a priority queue used for sorting section nodes by first
// access.
//

typedef struct _PFSV_SECTNODE_PRIORITY_QUEUE {

    //
    // Think of this priority queue as a Head node and a binary sorted
    // tree at the right child of the Head node. The left child of the
    // Head node always stays NULL. If we need to add a new node
    // smaller than Head, the new node becames the new Head. This way
    // we always have binary sorted tree rooted at Head as well.
    //

    PPFSVC_SECTION_NODE Head;

} PFSV_SECTNODE_PRIORITY_QUEUE, *PPFSV_SECTNODE_PRIORITY_QUEUE;

//
// A list of these may be used to convert the prefix of a path from NT
// to DOS style. [e.g. \Device\HarddiskVolume1 to C:]
//

typedef struct _NTPATH_TRANSLATION_ENTRY {
    
    //
    // Link in a list of translation entries.
    //

    LIST_ENTRY Link;

    //
    // NT path prefix to convert and its length in number of
    // characters excluding NUL.
    //
    
    WCHAR *NtPrefix;
    ULONG NtPrefixLength;
    
    //
    // A DOS path prefix that the NT Path translates to. Note that
    // this not the only possible DOS name translation as a volume may
    // be mounted anywhere.
    //

    WCHAR *DosPrefix;
    ULONG DosPrefixLength;

    //
    // This is the volume string returned by FindNextVolume.
    //

    WCHAR *VolumeName;
    ULONG VolumeNameLength;

} NTPATH_TRANSLATION_ENTRY, *PNTPATH_TRANSLATION_ENTRY;

typedef LIST_ENTRY NTPATH_TRANSLATION_LIST;
typedef NTPATH_TRANSLATION_LIST *PNTPATH_TRANSLATION_LIST;

//
// Define structure that wraps traces from the kernel.
//

typedef struct _PFSVC_TRACE_BUFFER {
    
    //
    // Traces are saved on the list via this link.
    //

    LIST_ENTRY TracesLink;
    
    //
    // The real trace from kernel starts here and extends for traces
    // size.
    //

    PF_TRACE_HEADER Trace;

} PFSVC_TRACE_BUFFER, *PPFSVC_TRACE_BUFFER;

//
// Define the globals structure.
//

typedef struct _PFSVC_GLOBALS {

    //
    // Prefetch parameters. These won't be initialized when globals are 
    // initialized and have to be explicitly acquired from the kernel.
    // Use PrefetchRoot below instead of RootDirPath in this structure.  
    //

    PF_SYSTEM_PREFETCH_PARAMETERS Parameters;

    //
    // OS Version information.
    //

    OSVERSIONINFOEXW OsVersion;

    //
    // An array of path suffices to recognize files we don't want to prefetch 
    // for boot. It is UPCASE and sorted lexically going from last character 
    // to first.
    //

    WCHAR **FilesToIgnoreForBoot;
    ULONG NumFilesToIgnoreForBoot;
    ULONG *FileSuffixLengths;
    
    //
    // This manual reset event gets set when the prefetcher service is
    // asked to go away.
    //
    
    HANDLE TerminateServiceEvent;

    //
    // This is the list of traces acquired from the kernel that have
    // to be processed, number of them and the lock to protect the
    // list.
    //

    LIST_ENTRY Traces;
    ULONG NumTraces;
    HANDLE TracesLock;
    
    //
    // This auto-clearing event is set when new traces are put on the
    // list.
    //

    HANDLE NewTracesToProcessEvent;
    
    //
    // This auto-clearing event is set when we had max number of
    // queued traces and we process one. It signifies that we should
    // check for any traces we could not pick up because the queue was
    // maxed.
    //
    
    HANDLE CheckForMissedTracesEvent;

    //
    // This named manual-reset event is set to force the prefetcher
    // service to process the traces without waiting for an idle
    // system.
    //

    HANDLE OverrideIdleProcessingEvent;

    //
    // This named manual-reset event is set when processing of the
    // currently available traces are done.
    //

    HANDLE ProcessingCompleteEvent;

    //
    // This is the path to the directory where prefetch files are
    // kept and the lock to protect it.
    //
    
    WCHAR PrefetchRoot[MAX_PATH + 1];
    HANDLE PrefetchRootLock;

    //
    // Number of prefetch files in the prefetch directory. This is an estimate
    // (i.e. may not be exact) used to make sure the prefetch directory does
    // not grow too big.
    //

    ULONG NumPrefetchFiles;

    //
    // This is a registry handle to the data key under which some
    // prefetch service data is stored.
    //

    HKEY ServiceDataKey;

    //
    // This is the number of total traces we attempted to process. 
    //

    ULONG NumTracesProcessed;

    //
    // This is the number of traces processed successfully.
    //

    ULONG NumTracesSuccessful;

    //
    // This is the last error code with which we failed processing a
    // trace.
    //

    DWORD LastTraceFailure;

    //
    // Did the defragger crash last time we ran it?
    //

    DWORD DefraggerErrorCode;

    //
    // Whether we are asked not to run the defragger in the registry.
    //

    DWORD DontRunDefragger;

    //
    // Pointer to path where CSC (client side caching) files are stored.
    //

    WCHAR *CSCRootPath;

} PFSVC_GLOBALS, *PPFSVC_GLOBALS;

//
// This describes a worker function called when it is time for an idle
// task to run.
//

typedef 
DWORD 
(*PFSVC_IDLE_TASK_WORKER_FUNCTION) (
    struct _PFSVC_IDLE_TASK *Task
    );

//
// This structure is used to keep context for a registered idle task.
//

typedef struct _PFSVC_IDLE_TASK {

    //
    // Parameters filled in by RegisterIdleTask call.
    //

    HANDLE ItHandle;
    HANDLE StartEvent;
    HANDLE StopEvent;

    //
    // Handle for the registered wait.
    //

    HANDLE WaitHandle;

    //
    // The registered callback function that will be called when the start
    // event is signaled.
    //

    WAITORTIMERCALLBACK Callback;

    //
    // If the common callback function is specified, it calls this function
    // to do the actual work.
    //

    PFSVC_IDLE_TASK_WORKER_FUNCTION DoWorkFunction;

    //
    // This is a manual reset event that will be set when the wait/callback
    // on the start event is fully unregistered.
    //

    HANDLE WaitUnregisteredEvent;

    //
    // This manual reset event gets reset when a callback starts running and
    // gets signaled when the callback stops running. Signaling of this event
    // is not protected so you can't purely rely on it. It is useful as a
    // shortcut.
    //

    HANDLE CallbackStoppedEvent;

    //
    // This manual reset event gets signaled when somebody starts unregistering.
    //

    HANDLE StartedUnregisteringEvent;

    //
    // This manual reset event gets signaled when somebody completes unregistering.
    //

    HANDLE CompletedUnregisteringEvent;
    
    //
    // The first one to interlocked set this from 0 to an integer is responsible 
    // for unregistering the wait & task and cleaning up.
    //

    LONG Unregistering;

    //
    // This is interlocked set from 0 to 1 when a callback is running, or when
    // the main thread is unregistering.
    //

    LONG CallbackRunning;

    //
    // Whether this task is registered (i.e. and has to be unregistered.)
    //

    BOOLEAN Registered;

    //
    // Whether this task has been initialized, used as a sanity check.
    //

    BOOLEAN Initialized;

} PFSVC_IDLE_TASK, *PPFSVC_IDLE_TASK;

//
// Values for the Unregistering field of PFSVC_IDLE_TASK.
//

typedef enum _PFSVC_TASK_UNREGISTERING_VALUES {
    PfSvcNotUnregisteringTask = 0,
    PfSvcUnregisteringTaskFromCallback,
    PfSvcUnregisteringTaskFromMainThread,
    PfSvcUnregisteringTaskMaxValue
} PFSVC_TASK_UNREGISTERING_VALUES, *PPFSVC_TASK_UNREGISTERING_VALUES;

//
// Values for the CallbackRunning field of PFSVC_IDLE_TASK.
//

typedef enum _PFSVC_TASK_CALLBACKRUNNING_VALUES {
    PfSvcTaskCallbackNotRunning = 0,
    PfSvcTaskCallbackRunning,
    PfSvcTaskCallbackDisabled,
    PfSvcTaskCallbackMaxValue
} PFSVC_TASK_CALLBACKRUNNING_VALUES, *PPFSVC_TASK_CALLBACKRUNNING_VALUES;


//
// Information on a scenario file's age, number of launches etc. used in 
// discarding old scenario files in the prefetch directory.
//

typedef struct _PFSVC_SCENARIO_AGE_INFO {

    //
    // Weight calculated based on the launch information. Larger weight is 
    // better. We'd rather discrad scenario with smaller weight.
    //

    ULONG Weight;

    //
    // Scenario file path.
    //

    WCHAR *FilePath;   

} PFSVC_SCENARIO_AGE_INFO, *PPFSVC_SCENARIO_AGE_INFO;

//
// This structure is used to enumerate through the scenario files
// in the prefetch directory. None of the fields of this function
// should be modified outside the file cursor routines.
//

typedef struct _PFSVC_SCENARIO_FILE_CURSOR {

    //
    // Data returned from FindFile calls for the current prefetch file.
    //

    WIN32_FIND_DATA FileData;

    //
    // The current prefetch file's full path.
    //

    WCHAR *FilePath;

    //
    // File name & path length in number of characters excluding NUL.
    //

    ULONG FileNameLength;
    ULONG FilePathLength;

    //
    // Index of the current file.
    //

    ULONG CurrentFileIdx;

    //
    // The fields below are used privately by the scenario file cursor
    // functions.
    //

    //
    // FindFile handle.
    //

    HANDLE FindFileHandle;

    //
    // Where we are looking for prefetch files.
    //

    WCHAR *PrefetchRoot;
    ULONG PrefetchRootLength;

    //
    // This is the maximum length string the allocated FilePath can store.
    //

    ULONG FilePathMaxLength;

    //
    // This is where the file name starts in the file path. The base of
    // the file path does not change (i.e. PrefetchRoot) and we copy
    // the new enumerated file name starting at FilePath+FileNameStart.
    //

    ULONG FileNameStart;
    
} PFSVC_SCENARIO_FILE_CURSOR, *PPFSVC_SCENARIO_FILE_CURSOR;

//
// Return values from CompareSuffix.
//

typedef enum _PFSV_SUFFIX_COMPARISON_RESULT {
    PfSvSuffixIdentical,
    PfSvSuffixLongerThan,
    PfSvSuffixLessThan,
    PfSvSuffixGreaterThan
} PFSV_SUFFIX_COMPARISON_RESULT, *PPFSV_SUFFIX_COMPARISON_RESULT;

//
// Return values from ComparePrefix.
//

typedef enum _PFSV_PREFIX_COMPARISON_RESULT {
    PfSvPrefixIdentical,
    PfSvPrefixLongerThan,
    PfSvPrefixLessThan,
    PfSvPrefixGreaterThan
} PFSV_PREFIX_COMPARISON_RESULT, *PPFSV_PREFIX_COMPARISON_RESULT;

//
// Return values from SectionNodeComparisonRoutine.
//

typedef enum _PFSV_SECTION_NODE_COMPARISON_RESULT {
    PfSvSectNode1LessThanSectNode2 = -1,
    PfSvSectNode1EqualToSectNode2 = 0,
    PfSvSectNode1GreaterThanSectNode2 = 1,
} PFSV_SECTION_NODE_COMPARISON_RESULT, *PPFSV_SECTION_NODE_COMPARISON_RESULT;

//
// Local function prototypes:
//

//
// Exposed routines:
//

DWORD 
WINAPI
PfSvcMainThread(
    VOID *Param
    );


//
// Internal service routines:
//

//
// Thread routines:
//

DWORD 
WINAPI
PfSvProcessTraceThread(
    VOID *Param
    );

DWORD 
WINAPI
PfSvPollShellReadyWorker(
    VOID *Param
    );

//
// Routines called by the main prefetcher thread.
//

DWORD 
PfSvGetRawTraces(
    VOID
    );

DWORD
PfSvInitializeGlobals(
    VOID
    );

VOID
PfSvCleanupGlobals(
    VOID
    );

DWORD
PfSvGetCSCRootPath (
    WCHAR *CSCRootPath,
    ULONG CSCRootPathMaxChars
    );
    
DWORD
PfSvGetDontRunDefragger(
    DWORD *DontRunDefragger
    );

DWORD
PfSvSetPrefetchParameters(
    PPF_SYSTEM_PREFETCH_PARAMETERS Parameters
    );

DWORD
PfSvQueryPrefetchParameters(
    PPF_SYSTEM_PREFETCH_PARAMETERS Parameters
    );

DWORD
PfSvInitializePrefetchDirectory(
    WCHAR *PathFromSystemRoot
    );

DWORD
PfSvCountFilesInDirectory(
    WCHAR *DirectoryPath,
    WCHAR *MatchExpression,
    PULONG NumFiles
    );

//
// Routines to process acquired traces:
//

DWORD
PfSvProcessTrace(
    PPF_TRACE_HEADER Trace
    );

VOID
PfSvInitializeScenarioInfo (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_SCENARIO_ID ScenarioId,
    PF_SCENARIO_TYPE ScenarioType
    );

VOID 
PfSvCleanupScenarioInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo
    );

DWORD
PfSvScenarioOpen (
    IN PWCHAR FilePath,
    IN PPF_SCENARIO_ID ScenarioId,
    IN PF_SCENARIO_TYPE ScenarioType,
    OUT PPF_SCENARIO_HEADER *Scenario
    );

DWORD
PfSvScenarioGetFilePath(
    OUT PWCHAR FilePath,
    IN ULONG FilePathMaxChars,
    IN PPF_SCENARIO_ID ScenarioId
    );

DWORD
PfSvScenarioInfoPreallocate(
    IN PPFSVC_SCENARIO_INFO ScenarioInfo,
    OPTIONAL IN PPF_SCENARIO_HEADER Scenario,
    IN PPF_TRACE_HEADER Trace
    );

DWORD
PfSvAddExistingScenarioInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_SCENARIO_HEADER Scenario
    );

DWORD
PfSvVerifyVolumeMagics(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_TRACE_HEADER Trace 
    );

DWORD
PfSvAddTraceInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_TRACE_HEADER Trace 
    );

PPFSVC_SECTION_NODE 
PfSvGetSectionRecord(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *FilePath,
    ULONG FilePathLength
    );

DWORD 
PfSvAddFaultInfoToSection(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPF_LOG_ENTRY LogEntry,
    PPFSVC_SECTION_NODE SectionNode
    );

DWORD
PfSvApplyPrefetchPolicy(
    PPFSVC_SCENARIO_INFO ScenarioInfo
    );

ULONG 
PfSvGetNumTimesUsed(
    ULONG UsageHistory,
    ULONG UsageHistorySize
    );

ULONG 
PfSvGetTraceEndIdx(
    PPF_TRACE_HEADER Trace
    );

//
// Routines to write updated scenario instructions to the scenario
// file.
//

DWORD
PfSvWriteScenario(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PWCHAR ScenarioFilePath
    );

DWORD
PfSvPrepareScenarioDump(
    IN PPFSVC_SCENARIO_INFO ScenarioInfo,
    OUT PPF_SCENARIO_HEADER *ScenarioPtr
    );

//
// Routines to maintain the optimal disk layout file and update disk
// layout.
//

DWORD
PfSvUpdateOptimalLayout(
    PPFSVC_IDLE_TASK Task
    );

DWORD
PfSvUpdateLayout (
    PPFSVC_PATH_LIST CurrentLayout,
    PPFSVC_PATH_LIST OptimalLayout,
    PBOOLEAN LayoutChanged
    );

DWORD
PfSvDetermineOptimalLayout (
    PPFSVC_IDLE_TASK Task,
    PPFSVC_PATH_LIST OptimalLayout,
    BOOL *BootScenarioProcessed
    );

DWORD
PfSvUpdateLayoutForScenario (
    PPFSVC_PATH_LIST OptimalLayout,
    WCHAR *ScenarioFilePath,
    PNTPATH_TRANSLATION_LIST TranslationList,
    PWCHAR *DosPathBuffer,
    PULONG DosPathBufferSize
    );

DWORD
PfSvReadLayout(
    IN WCHAR *FilePath,
    OUT PPFSVC_PATH_LIST Layout,
    OUT FILETIME *LastWriteTime
    );

DWORD
PfSvSaveLayout(
    IN WCHAR *FilePath,
    IN PPFSVC_PATH_LIST Layout,
    OUT FILETIME *LastWriteTime
    );

DWORD
PfSvGetLayoutFilePath(
    PWCHAR *FilePathBuffer,
    PULONG FilePathBufferSize
    );

//
// Routines to defrag the disks once after setup when the system is idle.
//

DWORD
PfSvDefragDisks(
    PPFSVC_IDLE_TASK Task
    );

DWORD
PfSvLaunchDefragger(
    PPFSVC_IDLE_TASK Task,
    BOOLEAN ForLayoutOptimization,
    PWCHAR TargetDrive
    );

DWORD
PfSvGetBuildDefragStatusValueName (
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR *ValueName
    );

DWORD
PfSvSetBuildDefragStatus(
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR BuildDefragStatus,
    ULONG Size
    );

DWORD
PfSvGetBuildDefragStatus(
    OSVERSIONINFOEXW *OsVersion,
    PWCHAR *BuildDefragStatus,
    PULONG ReturnSize
    );

//
// Routines to cleanup old scenario files in the prefetch directory.
//

DWORD
PfSvCleanupPrefetchDirectory(
    PPFSVC_IDLE_TASK Task
    );

int
__cdecl 
PfSvCompareScenarioAgeInfo(
    const void *Param1,
    const void *Param2
    );

//
// Routines to enumerate scenario files.
//

VOID
PfSvInitializeScenarioFileCursor (
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    );

VOID
PfSvCleanupScenarioFileCursor(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    );

DWORD
PfSvStartScenarioFileCursor(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor,
    WCHAR *PrefetchRoot
    );

DWORD
PfSvGetNextScenarioFileInfo(
    PPFSVC_SCENARIO_FILE_CURSOR FileCursor
    );

//
// File I/O utility routines.
//

DWORD
PfSvGetViewOfFile(
    IN WCHAR *FilePath,
    OUT PVOID *BasePointer,
    OUT PULONG FileSize
    );

DWORD
PfSvWriteBuffer(
    PWCHAR FilePath,
    PVOID Buffer,
    ULONG Length
    );

DWORD
PfSvGetLastWriteTime (
    WCHAR *FilePath,
    PFILETIME LastWriteTime
    );

DWORD
PfSvReadLine (
    FILE *File,
    WCHAR **LineBuffer,
    ULONG *LineBufferMaxChars,
    ULONG *LineLength
    );

DWORD
PfSvGetFileBasicInformation (
    WCHAR *FilePath,
    PFILE_BASIC_INFORMATION FileInformation
    );

DWORD
PfSvGetFileIndexNumber(
    WCHAR *FilePath,
    PLARGE_INTEGER FileIndexNumber
    );

//
// String utility routines.
//

PFSV_SUFFIX_COMPARISON_RESULT
PfSvCompareSuffix(
    WCHAR *String,
    ULONG StringLength,
    WCHAR *Suffix,
    ULONG SuffixLength,
    BOOLEAN CaseSensitive
    );

PFSV_PREFIX_COMPARISON_RESULT
PfSvComparePrefix(
    WCHAR *String,
    ULONG StringLength,
    WCHAR *Prefix,
    ULONG PrefixLength,
    BOOLEAN CaseSensitive
    );

VOID
FASTCALL
PfSvRemoveEndOfLineChars (
    WCHAR *Line,
    ULONG *LineLength
    );

PWCHAR
PfSvcAnsiToUnicode(
    PCHAR str
    );

PCHAR
PfSvcUnicodeToAnsi(
    PWCHAR wstr
    );

VOID 
PfSvcFreeString(
    PVOID String
    );

//
// Routines that deal with information in the registry.
//

DWORD
PfSvSaveStartInfo (
    HKEY ServiceDataKey
    );

DWORD
PfSvSaveExitInfo (
    HKEY ServiceDataKey,
    DWORD ExitCode
    );

DWORD
PfSvSaveTraceProcessingStatistics (
    HKEY ServiceDataKey
    );

DWORD
PfSvGetLastDiskLayoutTime(
    FILETIME *LastDiskLayoutTime
    );

DWORD
PfSvSetLastDiskLayoutTime(
    FILETIME *LastDiskLayoutTime
    );

BOOLEAN
PfSvAllowedToRunDefragger(
    BOOLEAN CheckRegistry
    );

//
// Routines that deal with security.
//

BOOL 
PfSvSetPrivilege(
    HANDLE hToken,
    LPCTSTR lpszPrivilege,
    ULONG ulPrivilege,
    BOOL bEnablePrivilege
    );

DWORD
PfSvSetAdminOnlyPermissions(
    WCHAR *ObjectPath,
    HANDLE ObjectHandle,
    SE_OBJECT_TYPE ObjectType
    );

DWORD
PfSvGetPrefetchServiceThreadPrivileges (
    VOID
    );

//
// Routines that deal with volume node structures.
//

DWORD
PfSvCreateVolumeNode (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *VolumePath,
    ULONG VolumePathLength,
    PLARGE_INTEGER CreationTime,
    ULONG SerialNumber
    );

PPFSVC_VOLUME_NODE
PfSvGetVolumeNode (
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    WCHAR *FilePath,
    ULONG FilePathLength
    );

VOID
PfSvCleanupVolumeNode(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPFSVC_VOLUME_NODE VolumeNode
    );
    
DWORD
PfSvAddParentDirectoriesToList(
    PPFSVC_PATH_LIST DirectoryList,
    ULONG VolumePathLength,
    WCHAR *FilePath,
    ULONG FilePathLength
    );

//
// Routines used to allocate / free section & page nodes etc. efficiently.
//

VOID
PfSvChunkAllocatorInitialize (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    );

DWORD
PfSvChunkAllocatorStart (
    PPFSVC_CHUNK_ALLOCATOR Allocator,
    PVOID Buffer,
    ULONG ChunkSize,
    ULONG MaxChunks
    );

PVOID
PfSvChunkAllocatorAllocate (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    );

VOID
PfSvChunkAllocatorFree (
    PPFSVC_CHUNK_ALLOCATOR Allocator,
    PVOID Allocation
    );

VOID
PfSvChunkAllocatorCleanup (
    PPFSVC_CHUNK_ALLOCATOR Allocator
    );

//
// Routines used to allocate / free file / directory / volume paths fast.
//

VOID
PfSvStringAllocatorInitialize (
    PPFSVC_STRING_ALLOCATOR Allocator
    );

DWORD
PfSvStringAllocatorStart (
    PPFSVC_STRING_ALLOCATOR Allocator,
    PVOID Buffer,
    ULONG MaxSize
    );

PVOID
PfSvStringAllocatorAllocate (
    PPFSVC_STRING_ALLOCATOR Allocator,
    ULONG NumBytes
    );

VOID
PfSvStringAllocatorFree (
    PPFSVC_STRING_ALLOCATOR Allocator,
    PVOID Allocation
    );

VOID
PfSvStringAllocatorCleanup (
    PPFSVC_STRING_ALLOCATOR Allocator
    );

//
// Routines that deal with section node structures.
//

VOID
PfSvCleanupSectionNode(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    PPFSVC_SECTION_NODE SectionNode
    );

//
// Routines used to sort scenario's section nodes.
//

DWORD
PfSvSortSectionNodesByFirstAccess(
    PLIST_ENTRY SectionNodeList
    );

PFSV_SECTION_NODE_COMPARISON_RESULT 
FASTCALL
PfSvSectionNodeComparisonRoutine(
    PPFSVC_SECTION_NODE Element1, 
    PPFSVC_SECTION_NODE Element2 
    );

//
// Routines that implement a priority queue used to sort section nodes
// for a scenario.
//

VOID
PfSvInitializeSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue
    );

VOID
PfSvInsertSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue,
    PPFSVC_SECTION_NODE NewElement
    );

PPFSVC_SECTION_NODE
PfSvRemoveMinSectNodePriorityQueue(
    PPFSV_SECTNODE_PRIORITY_QUEUE PriorityQueue
    );

//
// Implementation of the Nt path to Dos path translation API.
//

DWORD
PfSvBuildNtPathTranslationList(
    PNTPATH_TRANSLATION_LIST *NtPathTranslationList
    );

VOID
PfSvFreeNtPathTranslationList(
    PNTPATH_TRANSLATION_LIST TranslationList
    );

DWORD 
PfSvTranslateNtPath(
    PNTPATH_TRANSLATION_LIST TranslationList,
    WCHAR *NtPath,
    ULONG NtPathLength,
    PWCHAR *DosPathBuffer,
    PULONG DosPathBufferSize
    );
    
//
// Path list API.
//

VOID
PfSvInitializePathList(
    PPFSVC_PATH_LIST PathList,
    PPFSVC_STRING_ALLOCATOR PathAllocator,
    BOOLEAN CaseSensitive
    );

VOID
PfSvCleanupPathList(
    PPFSVC_PATH_LIST PathList
    );

BOOLEAN
PfSvIsInPathList(
    PPFSVC_PATH_LIST PathList,
    WCHAR *Path,
    ULONG PathLength
    );

DWORD
PfSvAddToPathList(
    PPFSVC_PATH_LIST PathList,
    WCHAR *Path,
    ULONG PathLength
    );

PPFSVC_PATH
PfSvGetNextPathSorted (
    PPFSVC_PATH_LIST PathList,
    PPFSVC_PATH CurrentPath
    );

PPFSVC_PATH
PfSvGetNextPathInOrder (
    PPFSVC_PATH_LIST PathList,
    PPFSVC_PATH CurrentPath
    );

//
// Routines to build the list of files accessed by the boot loader.
//

DWORD
PfSvBuildBootLoaderFilesList (
    PPFSVC_PATH_LIST PathList
    );

DWORD 
PfSvAddBootImageAndImportsToList(
    PPFSVC_PATH_LIST PathList,
    WCHAR *FilePath,
    ULONG FilePathLength
    );

DWORD
PfSvLocateBootServiceFile(
    IN WCHAR *FileName,
    IN ULONG FileNameLength,
    OUT WCHAR *FullPathBuffer,
    IN ULONG FullPathBufferLength,
    OUT PULONG RequiredLength   
    );

DWORD
PfSvGetBootServiceFullPath(
    IN WCHAR *ServiceName,
    IN WCHAR *BinaryPathName,
    OUT WCHAR *FullPathBuffer,
    IN ULONG FullPathBufferLength,
    OUT PULONG RequiredLength
    );

DWORD 
PfSvGetBootLoaderNlsFileNames (
    PPFSVC_PATH_LIST PathList
    );

DWORD 
PfSvLocateNlsFile(
    WCHAR *FileName,
    WCHAR *FilePathBuffer,
    ULONG FilePathBufferLength,
    ULONG *RequiredLength
    );

DWORD
PfSvQueryNlsFileName (
    HKEY Key,
    WCHAR *ValueName,
    WCHAR *FileNameBuffer,
    ULONG FileNameBufferSize,
    ULONG *RequiredSize
    );

//
// Routines to manage / run idle tasks.
//

VOID
PfSvInitializeTask (
    PPFSVC_IDLE_TASK Task
    );

DWORD
PfSvRegisterTask (
    PPFSVC_IDLE_TASK Task,
    IT_IDLE_TASK_ID TaskId,
    WAITORTIMERCALLBACK Callback,
    PFSVC_IDLE_TASK_WORKER_FUNCTION DoWorkFunction
    );

DWORD
PfSvUnregisterTask (
    PPFSVC_IDLE_TASK Task,
    BOOLEAN CalledFromCallback
    );

VOID
PfSvCleanupTask (
    PPFSVC_IDLE_TASK Task
    );

BOOL
PfSvStartTaskCallback(
    PPFSVC_IDLE_TASK Task
    );

VOID
PfSvStopTaskCallback(
    PPFSVC_IDLE_TASK Task
    );

VOID 
CALLBACK 
PfSvCommonTaskCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired
    );

DWORD
PfSvContinueRunningTask(
    PPFSVC_IDLE_TASK Task
    );

//
// ProcessIdleTasks notify routine and its dependencies.
//

VOID
PfSvProcessIdleTasksCallback(
    VOID
    );

DWORD
PfSvForceWMIProcessIdleTasks(
    VOID
    );

BOOL 
PfSvWaitForServiceToStart (
    LPTSTR ServiceName, 
    DWORD MaxWait
    );

//
// Wrappers around verify routines.
//

BOOLEAN
PfSvVerifyScenarioBuffer(
    PPF_SCENARIO_HEADER Scenario,
    ULONG BufferSize,
    PULONG FailedCheck
    );

//
// Debug definitions.
//

#if DBG
#ifndef PFSVC_DBG
#define PFSVC_DBG
#endif // !PFSVC_DBG
#endif // DBG

#ifdef PFSVC_DBG

//
// Define the component ID we use.
//

#define PFID       DPFLTR_PREFETCHER_ID

//
// Define DbgPrintEx levels.
//

#define PFERR      DPFLTR_ERROR_LEVEL
#define PFWARN     DPFLTR_WARNING_LEVEL
#define PFTRC      DPFLTR_TRACE_LEVEL
#define PFINFO     DPFLTR_INFO_LEVEL

//
// DbgPrintEx levels 4 - 19 are reserved for the kernel mode component.
//

#define PFSTRC     20
#define PFWAIT     21
#define PFLOCK     22
#define PFPATH     23
#define PFNTRC     24
#define PFTASK     25

//
//  This may help you determine what to set the DbgPrintEx mask.
//
//  3 3 2 2  2 2 2 2  2 2 2 2  1 1 1 1   1 1 1 1  1 1 0 0  0 0 0 0  0 0 0 0
//  1 0 9 8  7 6 5 4  3 2 1 0  9 8 7 6   5 4 3 2  1 0 9 8  7 6 5 4  3 2 1 0
//  _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _   _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _
//

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define DBGPR(x) DbgPrintEx x
#define PFSVC_ASSERT(x) if (!(x)) RtlAssert(#x, __FILE__, __LINE__, NULL )

//
// Variables used when saving traces acquired from the kernel. The
// traces are saved in the prefetch directory by appending the trace
// number % max number of saved traces to the base trace name.
//

WCHAR *PfSvcDbgTraceBaseName = L"PrefetchTrace";
LONG PfSvcDbgTraceNumber = 0;
LONG PfSvcDbgMaxNumSavedTraces = 20;

#else // PFSVC_DBG

#define DBGPR(x)
#define PFSVC_ASSERT(x)

#endif // PFSVC_DBG

#endif // _PFSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\service\daytona\sch_main.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sch_main.cxx
//
//  Contents:   job scheduler NT service entry point and thread launcher
//
//  History:    08-Sep-95 EricB created
//              03-Mar-01 JBenton - BUG 207402 RESUMESUSPEND and RESUMEAUTOMATIC
//                  events arrive out of the expected sequence on some hardware.
//                  This caused the internal POWER_RESUME event to be sent twice
//                  which sometimes (20%) prevented the scheduled job that 
//                  triggered the wake-up from running.
//
//-----------------------------------------------------------------------------

#include "..\..\pch\headers.hxx"
#pragma hdrstop
#include <svc_core.hxx>
#include "..\..\inc\sadat.hxx"
#include "..\..\inc\resource.h"
#include "..\..\idletask\inc\idlesrv.h"

DECLARE_INFOLEVEL(Sched);

// globals
SERVICE_STATUS_HANDLE g_hStatus = NULL;
SERVICE_STATUS g_SvcStatus;         // BUGBUG guard with critsec, put in class
ATOM   g_aClass = 0;
HANDLE g_hWindowThread = NULL;
HWND   g_hwndSchedSvc = NULL;
LONG   g_fUserIsLoggedOn = FALSE;   // Whether a user is currently logged on
HANDLE g_WndEvent = NULL;
UINT   g_uTaskbarMessage = 0;
BOOL   g_fShuttingDown;

// the following allows the service to be run from the command line as a
// console app.
BOOL g_fVisible = FALSE;
BOOL ConsoleHandler(DWORD dwControl);

// local prototypes
void SchedStart(DWORD, LPWSTR *);
BOOL RunningAsLocalSystem(VOID);
HRESULT WindowMsgFcn(LPVOID pVoid);
LRESULT CALLBACK SchedWndProc(HWND, UINT, WPARAM, LPARAM);

// routine to run on the prefetcher service thread.

extern "C" DWORD WINAPI PfSvcMainThread(VOID *Param);

#define IDM_EXIT    100

//+----------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   entry point
//
//-----------------------------------------------------------------------------
void _cdecl
main(int argc, char ** argv)
{
    DBG_OUT("Schedule svc starting...");

    if (argc > 1)
    {
        if (argv[1][0] == '/' || argv[1][0] == '-')
        {
            if (argv[1][1] == '?' || argv[1][1] == 'h' || argv[1][1] == 'H')
            {
                SchError(IDS_NOT_FROM_CMD_LINE);
#if DBG == 1
                printf("\nJob Scheduler service: "
                       "use the /d switch to run from the command line\n");
#endif
                return;
            }
#if DBG == 1
            else
            {
                if (argv[1][1] == 'd')
                {
                    // debug switch, run from the command line
                    g_fVisible = TRUE;
                }
            }
#endif
        }
    }

    //
    // Open the schedule service log file.
    //
    if (FAILED(OpenLogFile()))
    {
        return;
    }

    LogServiceEvent(IDS_LOG_SERVICE_STARTED);

    if (!g_fVisible)
    {
        SERVICE_TABLE_ENTRY ScheduleServiceDispatchTable[] = {
            {g_tszSrvcName, SchedStart},
            {NULL, NULL}};

        if (!StartServiceCtrlDispatcher(ScheduleServiceDispatchTable))
        {
            LogServiceError(IDS_FATAL_ERROR, GetLastError(), 0);
            ERR_OUT("StartServiceCtrlDispatcher", GetLastError());
            SchError(IDS_NOT_FROM_CMD_LINE);
            LogServiceEvent(IDS_LOG_SERVICE_EXITED);
            CloseLogFile();
            exit(EXIT_FAILURE);
        }
    }
    else
    {
        SchedStart(0, NULL);
    }

    LogServiceEvent(IDS_LOG_SERVICE_EXITED);

    //
    // Close the schedule service log.
    //
    CloseLogFile();

    DBG_OUT("Schedule svc exiting.\n");
}

//+----------------------------------------------------------------------------
//
//  Function:   SchedServiceMain
//
//  Synopsis:   Entry point when running in an SvcHost.exe instance.
//
//  Arguments:  [CArgs]     - count of arg strings
//              [ppwszArgs] - array of arg strings
//
//-----------------------------------------------------------------------------
VOID
WINAPI
SchedServiceMain(DWORD cArgs, LPWSTR * ppwszArgs)
{

    //
    // We need to initialize g_hInstance here for OpenLogFile
    // to work.
    //

    g_hInstance = GetModuleHandle(SCH_SERVICE_DLL_NAME);

    //
    // Open the schedule service log file.
    //
    if (FAILED(OpenLogFile()))
    {
        return;
    }
   
    LogServiceEvent(IDS_LOG_SERVICE_STARTED);

    SchedStart(cArgs, ppwszArgs);

    LogServiceEvent(IDS_LOG_SERVICE_EXITED);

    //
    // Close the schedule service log.
    //
    CloseLogFile();
}

//+----------------------------------------------------------------------------
//
//  Function:   SchedStart
//
//  Synopsis:   Primary thread of the NT service
//
//  Arguments:  [CArgs]     - count of arg strings
//              [ppwszArgs] - array of arg strings
//
//-----------------------------------------------------------------------------
void
SchedStart(DWORD cArgs, LPWSTR * ppwszArgs)
{
    HANDLE  hPfSvcThread;
    HANDLE  hPfSvcStopEvent;
    DWORD   ErrorCode;
    BOOLEAN StartedIdleDetectionServer;

    HRESULT hr;

    //
    // initialize locals so we know what to cleanup.
    //

    hPfSvcStopEvent            = NULL;
    hPfSvcThread               = NULL;
    StartedIdleDetectionServer = FALSE;

    //
    // Initialize some globals.
    //

    if (!g_hInstance) {
        g_hInstance = GetModuleHandle(NULL);
    }

    g_fShuttingDown   = FALSE;
    g_hStatus         = NULL;
    g_hWindowThread   = NULL;
    g_hwndSchedSvc    = NULL;
    g_fUserIsLoggedOn = FALSE;
    g_WndEvent        = NULL;
    
    g_SvcStatus.dwServiceType      = SERVICE_WIN32_OWN_PROCESS;
    g_SvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                     SERVICE_ACCEPT_PAUSE_CONTINUE |
                                     SERVICE_ACCEPT_SHUTDOWN |
                                     SERVICE_ACCEPT_POWEREVENT;

    g_SvcStatus.dwWaitHint                = SCH_WAIT_HINT;
    g_SvcStatus.dwCheckPoint              = 1;
    g_SvcStatus.dwWin32ExitCode           = NO_ERROR;
    g_SvcStatus.dwServiceSpecificExitCode = 0;
    g_SvcStatus.dwCurrentState            = SERVICE_START_PENDING;

    //
    // Register the control handler.
    //
    if (g_fVisible)
    {   // running in a console window
        SetConsoleCtrlHandler(ConsoleHandler, TRUE);
    }
    else
    {
        g_hStatus = RegisterServiceCtrlHandlerEx(g_tszSrvcName,
                                                 SchSvcHandler,
                                                 NULL);

        if (g_hStatus == NULL)
        {
            LogServiceError(IDS_INITIALIZATION_FAILURE, GetLastError(), 0);
            ERR_OUT("RegisterServiceCtrlHandler", GetLastError());
            return;
        }
    }

    //
    // Let the service controller know we're making progress.
    //
    UpdateStatus();

    //
    // Make sure the service is running as LocalSystem
    //
    if (!RunningAsLocalSystem())
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE,
                        HRESULT_FROM_WIN32(SCHED_E_SERVICE_NOT_LOCALSYSTEM),
                        0);

        SchStop(HRESULT_FROM_WIN32(SCHED_E_SERVICE_NOT_LOCALSYSTEM), FALSE);
        return;
    }

    //
    // Initialize the service.
    //
    hr = SchInit();

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr, FALSE);
        return;
    }

    //
    // Let the service controller know we're making progress.
    //
    StartupProgressing();

    //
    // Get the ID of the logged on user, if there is one.
    //
    GetLoggedOnUser();

    //
    // Let the service controller know we're making progress.
    //
    StartupProgressing();

    //
    // Initialize NetSchedule API support code.
    //
    hr = InitializeNetScheduleApi();

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr);
        return;
    }

    //
    // Let the service controller know we're making progress.
    //
    StartupProgressing();

    //
    // Start the RPC server.
    //
    hr = StartRpcServer();

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr);
        return;
    }

    //
    // Let the service controller know we're making progress.
    //
    StartupProgressing();

    //
    // Create the window thread event.
    //
    g_WndEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (g_WndEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateEvent", hr);
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr);
        return;
    }

    //
    // Create the window thread.
    //
    DWORD dwThreadID;
    g_hWindowThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)WindowMsgFcn,
                                   NULL,
                                   0,
                                   &dwThreadID);
    if (!g_hWindowThread)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("Creation of Window Thread", hr);
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr);

        CloseHandle( g_WndEvent );
        g_WndEvent = NULL;

        return;
    }

    //
    // Initialize idle detection server. This must be done after we
    // start the other RPC servers that register a dynamic ncalrpc
    // endpoint.
    //

    ErrorCode = ItSrvInitialize();

    hr = HRESULT_FROM_WIN32(ErrorCode);

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        SchStop(hr);
        return;
    }

    StartedIdleDetectionServer = TRUE;


    //
    // Initialize the event it is going to wait on and kick off the
    // prefetcher maintenance thread.
    //
    
    hPfSvcStopEvent = CreateEvent(NULL,    // no security attributes
                                  TRUE,    // manual reset event
                                  FALSE,   // not-signalled
                                  NULL);   // no name
    
    if (hPfSvcStopEvent) { 
        hPfSvcThread = CreateThread(0,0,PfSvcMainThread,&hPfSvcStopEvent,0,0); 
    }

    //
    // We're off and running.
    //
    g_SvcStatus.dwCurrentState = SERVICE_RUNNING;
    g_SvcStatus.dwCheckPoint   = 0;
    UpdateStatus();

    hr = g_pSched->InitialDirScan();

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        goto Exit;
    }

    //
    // Update the service flag in SA.DAT to running.
    // Also redetermine whether the machine supports wakeup timers.  We do
    // this every time the service starts in order to work around problems
    // with IBM Thinkpads and VPOWERD on Windows 98.  (BUGBUG  Do we need
    // to do this on NT as well?)
    //
    // Note, this function should not fail. If it does, something is
    // seriously wrong with the system.
    //

    hr = SADatCreate(g_TasksFolderInfo.ptszPath);

    if (FAILED(hr))
    {
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        goto Exit;
    }

    //
    // Call the main function.
    //

    hr = SchedMain(NULL);

    //
    // Exit.
    //

Exit:

    //
    // If one exists, signal prefetcher thread's stop event and wait
    // for it to terminate.
    //
    
    if (hPfSvcStopEvent && hPfSvcThread) {
        SetEvent(hPfSvcStopEvent);
        WaitForSingleObject(hPfSvcThread, INFINITE);
    }

    if (hPfSvcStopEvent) {
        CloseHandle(hPfSvcStopEvent);
    }

    if (hPfSvcThread) {
        CloseHandle(hPfSvcThread);
    }

    HANDLE  rghWaitArray[2] = { g_WndEvent, g_hWindowThread };

    DBG_OUT("Service exit -- waiting for window thread to finish starting.");

    if (WaitForMultipleObjects(2, rghWaitArray, FALSE, INFINITE) == WAIT_OBJECT_0)
    {
        //
        // g_WndEvent was signalled -- we can now send a message
        // to the window thread to tell it to shut down
        //
        g_fShuttingDown = TRUE;
        SendMessage(g_hwndSchedSvc, WM_COMMAND, IDM_EXIT, 0);

        //
        // Wait for window thread to exit before exitting the main thread.
        // This is to ensure that the task bar icon is removed. The wait is
        // probably not needed since the SendMessage exit processing looks
        // like it is completely syncronous.
        //

        DBG_OUT("Waiting for window thread to exit.");
        WaitForSingleObject(g_hWindowThread, INFINITE);
        DBG_OUT("Window thread exited.");
    }
    else
    {
        DBG_OUT("Window thread exited prematurely -- shutting down.");
    }

    //
    // Stop idle detection server.
    //
    
    if (StartedIdleDetectionServer) {
        ItSrvUninitialize();
    }

    //
    // Cleanup some globals.
    //

    if (g_fUserIsLoggedOn) {
        LogonSessionDataCleanup();
        g_fUserIsLoggedOn = FALSE;
    }

    if (g_hWindowThread) {
        CloseHandle(g_hWindowThread);
        g_hWindowThread = NULL;
    }

    if (g_WndEvent) {
        CloseHandle(g_WndEvent);
        g_WndEvent = NULL;
    }

    SchStop(hr);
}


//+----------------------------------------------------------------------------
//
//  Function:   RunningAsLocalSystem
//
//  Synopsis:   Detects whether the service was started in the System account.
//
//  Arguments:  None
//
//  Returns:    TRUE  if the service is running as LocalSystem
//              FALSE if it is not or if any errors were encountered
//
//-----------------------------------------------------------------------------
BOOL
RunningAsLocalSystem(VOID)
{
    SID    LocalSystemSid = { SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID };

    BOOL   fCheckSucceeded;
    BOOL   fIsLocalSystem = FALSE;

    fCheckSucceeded = CheckTokenMembership(NULL,
                                           &LocalSystemSid,
                                           &fIsLocalSystem);

    if (!fCheckSucceeded)
    {
        ERR_OUT("CheckTokenMembership", GetLastError());
    }

    return (fCheckSucceeded && fIsLocalSystem);
}


//+----------------------------------------------------------------------------
//
//  Function:   WindowMsgFcn
//
//  Synopsis:   Window message loop thread of the service.
//
//  Arguments:  [pVoid] - currently not used
//
//  Returns:    HRESULTS - the service is not currently detecting if this
//              thread exits prematurely. Thus, the exit code is ignored.
//              Monitoring the thread handle in SchedMain would give more
//              thorough error detection.
//-----------------------------------------------------------------------------
HRESULT
WindowMsgFcn(LPVOID pVoid)
{
    HRESULT hr = S_OK;

    //
    // Find out the ID of the message that the tray will send us when it
    // starts.
    //
    g_uTaskbarMessage = RegisterWindowMessage(TEXT("TaskbarCreated"));

    //
    // Register the window class
    //
    WNDCLASS wc;

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = SchedWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInstance;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = SCHED_CLASS;

    g_aClass = RegisterClass(&wc);
    if (!g_aClass)
    {
        ULONG ulLastError = GetLastError();

        LogServiceError(IDS_NON_FATAL_ERROR, ulLastError, 0);
        ERR_OUT("RegisterClass", ulLastError);
        return HRESULT_FROM_WIN32(ulLastError);
    }

    //
    // Now create the hidden window on the interactive desktop.
    //
    g_hwndSchedSvc = CreateWindow(SCHED_CLASS, SCHED_TITLE, WS_OVERLAPPEDWINDOW,
                                  CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                  CW_USEDEFAULT, (HWND)NULL, (HMENU)NULL,
                                  g_hInstance, (LPVOID)NULL);
    if (!g_hwndSchedSvc)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        ERR_OUT("CreateWindow", hr);
        return hr;
    }

    ShowWindow(g_hwndSchedSvc, SW_HIDE);
    UpdateWindow(g_hwndSchedSvc);

    //
    // Initialize this thread's keep-awake count.
    //

    InitThreadWakeCount();

    //
    // Initialize idle detection.  This must be done by the window thread
    // (not the state machine thread).
    //
    InitIdleDetection();

    //
    // Notify the main thread that the window creation is complete.
    //
    if (!SetEvent(g_WndEvent))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LogServiceError(IDS_INITIALIZATION_FAILURE, (DWORD)hr, 0);
        ERR_OUT("SetEvent(g_WndEvent)", hr);
        return hr;
    }

    MSG msg;
    while (GetMessage(&msg, (HWND) NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    if (g_aClass != 0)
    {
        DeleteAtom(g_aClass);
        g_aClass = 0;

        UnregisterClass(SCHED_CLASS, g_hInstance);
    }
    
    DBG_OUT("Window exited.");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   SchedWndProc
//
//  Synopsis:   handle messages
//
//  Returns:    occasionally
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
SchedWndProc(HWND hwndSched, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    switch (uMsg)
    {
    case WM_CREATE:
    case WM_SETTEXT:
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDM_EXIT:

            //
            // Only exit if this message was sent by the
            // Task Scheduler's shutdown code (vs. a user)
            //
            if (g_fShuttingDown)
            {
                DestroyWindow(hwndSched);
            }
            break;
        }

        break;

    case WM_TIMECHANGE:
        DBG_OUT("WM_TIMECHANGE received");
        g_pSched->SubmitControl(SERVICE_CONTROL_TIME_CHANGED);
        break;

    case WM_SCHED_SetNextIdleNotification:
        return SetNextIdleNotificationFn((WORD)wParam);

    case WM_SCHED_SetIdleLossNotification:
        return SetIdleLossNotificationFn();

    case WM_DESTROY:
        DBG_OUT("Got WM_DESTROY.");

        //
        // Only exit if this message was sent by the
        // Task Scheduler's shutdown code (vs. a user)
        //
        if (g_fShuttingDown)
        {
            EndIdleDetection();
            PostQuitMessage(0);
        }
        break;

    case WM_CLOSE:
    case WM_QUIT:

        //
        // If the Task Scheduler isn't shutting down, these
        // are malicious messages, so ignore them.  If the
        // Task Scheduler is shutting down, fall through and
        // let DefWindowProc handle these
        //
        if (!g_fShuttingDown)
        {
            break;
        }

        // Fall through

    default:
        if (uMsg == g_uTaskbarMessage)
        {
            schDebugOut((DEB_ITRACE,
                         "Got Taskbar message, calling SchSvcHandler.\n"));
            SchSvcHandler(SERVICE_CONTROL_USER_LOGON, 0, NULL, NULL);
            // CODEWORK: Is a non-zero return code expected from the wndproc?
        }
        else
        {
            return DefWindowProc(hwndSched, uMsg, wParam, lParam);
        }
    }
    return lResult;
}

//+----------------------------------------------------------------------------
//
//  Function:   SchSvcHandler
//
//  Synopsis:   handles service controller callback notifications
//
//  Arguments:  [dwControl] - the control code
//
//-----------------------------------------------------------------------------
DWORD WINAPI
SchSvcHandler(
    DWORD   dwControl,
    DWORD   dwEventType,
    LPVOID  lpEventData,
    LPVOID  lpContext
    )
{
    static BOOL fResumeHandled;   // initially FALSE

    switch (dwControl)
    {
    case SERVICE_CONTROL_PAUSE:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_PAUSE");
        if (g_SvcStatus.dwCurrentState == SERVICE_RUNNING ||
            g_SvcStatus.dwCurrentState == SERVICE_CONTINUE_PENDING)
        {
            g_SvcStatus.dwCurrentState = SERVICE_PAUSE_PENDING;
            g_SvcStatus.dwWaitHint = 0;
            g_SvcStatus.dwCheckPoint = 0;

            g_pSched->SubmitControl(0);
            LogServiceEvent(IDS_LOG_SERVICE_PAUSED);
        }
        else
        {
            ERR_OUT("Trying to pause when service not running!", 0);
        }
        break;

    case SERVICE_CONTROL_CONTINUE:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_CONTINUE");
        if (g_SvcStatus.dwCurrentState == SERVICE_PAUSED ||
            g_SvcStatus.dwCurrentState == SERVICE_PAUSE_PENDING)
        {
            g_SvcStatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
            g_SvcStatus.dwWaitHint = 0;
            g_SvcStatus.dwCheckPoint = 0;

            g_pSched->SubmitControl(0);
            LogServiceEvent(IDS_LOG_SERVICE_CONTINUED);
        }
        else
        {
            ERR_OUT("Trying to continue when service not paused!", 0);
        }
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_SHUTDOWN");
    case SERVICE_CONTROL_STOP:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_STOP");
        g_SvcStatus.dwCurrentState = SERVICE_STOP_PENDING;
        g_SvcStatus.dwWaitHint = SCH_WAIT_HINT;
        g_SvcStatus.dwCheckPoint = 1;

        UpdateStatus();

        g_pSched->SubmitControl(0);
        break;

    case SERVICE_CONTROL_USER_LOGON:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_USER_LOGON");
        //
        // (This could be called by the window-handling thread.)
        // The tray (or mstinit /logon) has notified us that it's started.
        // This usually happens because a user has logged on, but it also
        // happens when the tray crashes and restarts.  We must ignore the
        // notification in the latter case.
        //
        if (InterlockedExchange(&g_fUserIsLoggedOn, TRUE))
        {
            //
            // It wasn't really a user logon.  Ignore the control.
            //
            DBG_OUT("SchSvcHandler: User is already logged on");
            break;
        }

        //
        // Signal the main thread loop to run logon jobs.
        //
        g_pSched->SubmitControl(SERVICE_CONTROL_USER_LOGON);
        break;

    case SERVICE_CONTROL_USER_LOGOFF:

        schDebugOut((DEB_ITRACE, "User logging off *******************\n"));

        //
        // Dealloc & set to NULL the global data associated with the
        // user's logon session.
        //

        LogonSessionDataCleanup();

        g_fUserIsLoggedOn = FALSE;

        break;

    case SERVICE_CONTROL_INTERROGATE:
        DBG_OUT("SchSvcHandler: SERVICE_CONTROL_INTERROGATE");
        //
        // The interrogate is satisfied by the UpdateStatus call below.
        //
        break;

    case SERVICE_CONTROL_POWEREVENT:
        switch (dwEventType)
        {
        case PBT_APMPOWERSTATUSCHANGE:
            SYSTEM_POWER_STATUS PwrStatus;
            if (!GetSystemPowerStatus(&PwrStatus))
            {
                LogServiceError(IDS_NON_FATAL_ERROR, GetLastError(), 0);
                ERR_OUT("GetSystemPowerStatus", GetLastError());
                break;
            }
            if (PwrStatus.ACLineStatus == 0)
            {
                //
                // On battery.
                //
                OnPowerChange(TRUE);
            }
            else
            {
                if (PwrStatus.ACLineStatus == 1)
                {
                    //
                    // On AC power.
                    //
                    OnPowerChange(FALSE);
                }
            }
            break;

        case PBT_APMQUERYSUSPEND:
            //
            // The computer is preparing for suspended mode.
            // Signal the other thread to stop running jobs.
            //
            DBG_OUT("PBT_APMQUERYSUSPEND received");
            g_pSched->SubmitControl(SERVICE_CONTROL_POWER_SUSPEND);
            break;

        case PBT_APMQUERYSUSPENDFAILED:
            //
            // Aborted going into suspended mode.
            // Signal the other thread to run the elapsed jobs.
            //
            DBG_OUT("PBT_APMQUERYSUSPENDFAILED received");
            g_pSched->SubmitControl(SERVICE_CONTROL_POWER_SUSPEND_FAILED);
            break;

        case PBT_APMSUSPEND:
            //
            // The computer is going into the suspended mode.
            // We already prepared for it when we got QUERYSUSPEND.
            // BUGBUG  We should wait here for the other thread to finish.
            //
            DBG_OUT("PBT_APMSUSPEND received, ignoring (already handled)");
            fResumeHandled = FALSE;
            break;


        //
        // PBT_APMRESUMExxx messages:
        // The computer is coming back from suspended mode.
        // Signal the other thread to run the appropriate jobs.
        //

        case PBT_APMRESUMESUSPEND:
            DBG_OUT("PBT_APMRESUMESUSPEND received");
            if (fResumeHandled)
            {
                DBG_OUT("IGNORING resumesuspend (sent after resumeautomatic)");
            }
            else
            {
                g_pSched->SubmitControl(SERVICE_CONTROL_POWER_RESUME);
                //
                // On some systems we see the RESUMESUSPEND message before
                // the RESUMEAUTOMATIC message. We don't want to signal the
				// main loop twice.  So set a flag telling us to ignore
				// RESUMEAUTOMATIC messages until a SUSPEND message is sent.
                //
                fResumeHandled = TRUE;
            }
            break;

        case PBT_APMRESUMECRITICAL:
            DBG_OUT("PBT_APMRESUMECRITICAL received");
            g_pSched->SubmitControl(SERVICE_CONTROL_POWER_RESUME);
            break;

        case PBT_APMRESUMEAUTOMATIC:
            DBG_OUT("PBT_APMRESUMEAUTOMATIC received");

            if (fResumeHandled)
            {
                DBG_OUT("IGNORING resumeautomatic (sent after resumeresume)");
			}
			else
			{
                g_pSched->SubmitControl(SERVICE_CONTROL_POWER_RESUME);
                //
                // After this RESUMEAUTOMATIC message, the system may also
                // send a RESUMESUSPEND message (if it detects user activity).
                // We don't want to signal the main loop twice.  So set a flag
                // telling us to ignore RESUMESUSPEND messages until a SUSPEND
                // message is sent.
                //
                fResumeHandled = TRUE;
			}

            break;
        }
        break;

    default:
        ERR_OUT("Unrecognized service control code", dwControl);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    UpdateStatus();

    return NO_ERROR;
}


//+----------------------------------------------------------------------------
//
//  Function:   CSchedWorker::HandleControl
//
//  Synopsis:   Handle NT service controller state changes.
//
//  Returns:    the control or the current/new state
//
//-----------------------------------------------------------------------------
DWORD
CSchedWorker::HandleControl()
{
    TRACE(CSchedWorker,HandleControl);

    DWORD dwControl = m_ControlQueue.GetEntry();

    switch (dwControl)
    {
    case SERVICE_CONTROL_USER_LOGON:
        schDebugOut((DEB_ITRACE, "  Event is USER_LOGON\n"));
        break;

    case SERVICE_CONTROL_POWER_SUSPEND:
        schDebugOut((DEB_ITRACE, "  Event is POWER_SUSPEND\n"));
        break;

    case SERVICE_CONTROL_POWER_SUSPEND_FAILED:
        schDebugOut((DEB_ITRACE, "  Event is POWER_SUSPEND_FAILED\n"));
        break;

    case SERVICE_CONTROL_POWER_RESUME:
        schDebugOut((DEB_ITRACE, "  Event is POWER_RESUME\n"));
        break;

    case SERVICE_CONTROL_TIME_CHANGED:
        schDebugOut((DEB_ITRACE, "  Event is TIME_CHANGED\n"));
        break;

    case 0:
        schDebugOut((DEB_ITRACE, "  Service Control is state %#lx\n",
                     g_SvcStatus.dwCurrentState));

        switch (g_SvcStatus.dwCurrentState)
        {
        case SERVICE_STOP_PENDING:
            schDebugOut((DEB_ITRACE,
                         "    WaitForMultipleObjects signaled for exit\n"));
            break;

        case SERVICE_PAUSE_PENDING:
            schDebugOut((DEB_ITRACE,
                         "    WaitForMultipleObjects signaled for pausing\n"));
            g_SvcStatus.dwCurrentState = SERVICE_PAUSED;
            g_SvcStatus.dwWaitHint = 0;
            g_SvcStatus.dwCheckPoint = 0;
            UpdateStatus();
            break;

        case SERVICE_CONTINUE_PENDING:
            schDebugOut((DEB_ITRACE,
                         "    WaitForMultipleObjects signaled for continuing\n"));
            g_SvcStatus.dwCurrentState = SERVICE_RUNNING;
            g_SvcStatus.dwWaitHint = 0;
            g_SvcStatus.dwCheckPoint = 0;
            UpdateStatus();
            break;
        }
        return g_SvcStatus.dwCurrentState;

    default:
        schDebugOut((DEB_ITRACE, "  ??? UNKNOWN CONTROL %#lx\n", dwControl));
        break;
    }

    return dwControl;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetCurrentServiceState
//
//  Returns:    The schedule service's current state.
//
//-----------------------------------------------------------------------------
DWORD
GetCurrentServiceState(void)
{
    return g_SvcStatus.dwCurrentState;
}

//+----------------------------------------------------------------------------
//
//  Function:   UpdateStatus
//
//  Synopsis:   Tell the service controller what the current status is.
//
//  Returns:    Win32 error values
//
//-----------------------------------------------------------------------------
DWORD
UpdateStatus(void)
{
    if (g_fVisible)
    {
        return NO_ERROR;
    }
    TRACE_FUNCTION(UpdateStatus);

    DWORD dwRet = NO_ERROR;

    if (g_hStatus == NULL)
    {
        ERR_OUT("UpdateStatus called with a null status handle!", 0);
        return ERROR_INVALID_HANDLE;
    }

    if (!SetServiceStatus(g_hStatus, &g_SvcStatus))
    {
        dwRet = GetLastError();
        LogServiceError(IDS_NON_FATAL_ERROR, dwRet, 0);
        ERR_OUT("SetServiceStatus", dwRet);
    }
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//  Function:   SchStop
//
//  Synopsis:   Shuts down the schedule service
//
//  Arguments:  [hr] - an error code if terminating abnormally
//
//-----------------------------------------------------------------------------
void
SchStop(HRESULT hr, BOOL fCoreCleanup)
{
    //
    // Update the service flag in SA.DAT to not running.
    // Check the folder path for NULL in case initialization failed.
    //

    if (g_TasksFolderInfo.ptszPath != NULL)
    {
        UpdateSADatServiceFlags(g_TasksFolderInfo.ptszPath,
                                SA_DAT_SVCFLAG_SVC_RUNNING,
                                TRUE);
    }

    g_SvcStatus.dwCurrentState = SERVICE_STOP_PENDING;
    g_SvcStatus.dwCheckPoint++;

    UpdateStatus();

    //
    // do core cleanup
    //

    if (fCoreCleanup)
    {
        SchCleanup();
    }

    //
    // tell service controller that we are done cleaning up
    //

    if (FAILED(hr))
    {
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
        {
            g_SvcStatus.dwWin32ExitCode = HRESULT_CODE(hr);
        }
        else
        {
            g_SvcStatus.dwWin32ExitCode = hr;
        }
    }
    else
    {
        g_SvcStatus.dwWin32ExitCode = NO_ERROR;
    }

    g_SvcStatus.dwServiceSpecificExitCode = 0;
    g_SvcStatus.dwCurrentState = SERVICE_STOPPED;
    g_SvcStatus.dwControlsAccepted = 0;
    g_SvcStatus.dwWaitHint = 0;
    g_SvcStatus.dwCheckPoint = 0;

    UpdateStatus();
}

//+----------------------------------------------------------------------------
//
//  Function:   ConsoleHandler
//
//  Synopsis:   handles system signals when run as a console app
//
//-----------------------------------------------------------------------------
BOOL
ConsoleHandler(DWORD dwControl)
{
    TRACE_FUNCTION(ConsoleHandler);
    g_SvcStatus.dwCurrentState = SERVICE_STOP_PENDING;
    g_pSched->SubmitControl(0);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   StartupProgressing
//
//  Synopsis:   Notifies the service controller that startup is still
//              progressing normally.
//
//-----------------------------------------------------------------------------
void
StartupProgressing(void)
{
    g_SvcStatus.dwCheckPoint++;
    UpdateStatus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\service\daytona\test\pfapp\pfapp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pfapp.c

Abstract:

    This module builds a console test program that can be launched
    to test/stress the application launch prefetcher.

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

DWORD
PfAppGetViewOfFile(
    IN WCHAR *FilePath,
    OUT PVOID *BasePointer,
    OUT PULONG FileSize
    )

/*++

Routine Description:

    Map the all of the specified file to memory.

Arguments:

    FilePath - NUL terminated path to file to map.
    
    BasePointer - Start address of mapping will be returned here.

    FileSize - Size of the mapping/file will be returned here.

Return Value:

    Win32 error code.

--*/

{
    HANDLE InputHandle;
    HANDLE InputMappingHandle;
    DWORD ErrorCode;
    DWORD SizeL;
    DWORD SizeH;
    BOOLEAN OpenedFile;
    BOOLEAN CreatedFileMapping;

    //
    // Initialize locals.
    //

    OpenedFile = FALSE;
    CreatedFileMapping = FALSE;

    //
    // Note that we are opening the file exclusively. This guarantees
    // that for trace files as long as the kernel is not done writing
    // it we can't open the file, which guarantees we won't have an
    // incomplete file to worry about.
    //

    InputHandle = CreateFile(FilePath, 
                             GENERIC_READ, 
                             0,
                             NULL, 
                             OPEN_EXISTING, 
                             FILE_SHARE_READ, 
                             NULL);

    if (INVALID_HANDLE_VALUE == InputHandle)
    {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    OpenedFile = TRUE;

    SizeL = GetFileSize(InputHandle, &SizeH);

    if (SizeL == -1 && (GetLastError() != NO_ERROR )) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (SizeH) {
        ErrorCode = ERROR_BAD_LENGTH;
        goto cleanup;
    }

    if (FileSize) {
        *FileSize = SizeL;
    }

    InputMappingHandle = CreateFileMapping(InputHandle, 
                                           0, 
                                           PAGE_READONLY, 
                                           0,
                                           0, 
                                           NULL);

    if (NULL == InputMappingHandle)
    {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    CreatedFileMapping = TRUE;
    
    *BasePointer = MapViewOfFile(InputMappingHandle, 
                                 FILE_MAP_READ, 
                                 0, 
                                 0, 
                                 0);

    if (NULL == *BasePointer) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (OpenedFile) {
        CloseHandle(InputHandle);
    }

    if (CreatedFileMapping) {
        CloseHandle(InputMappingHandle);
    }

    return ErrorCode;
}

PWCHAR
PfAppAnsiToUnicode(
    PCHAR str
    )

/*++

Routine Description:

    This routine converts an ANSI string into an allocated wide
    character string. The returned string should be freed by
    free().

Arguments:

    str - Pointer to string to convert.

Return Value:

    Allocated wide character string or NULL if there is a failure.

--*/

{
    ULONG len;
    wchar_t *retstr = NULL;

    len = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
    retstr = (wchar_t *)malloc(len * sizeof(wchar_t));
    if (!retstr) 
    {
        return NULL;
    }
    MultiByteToWideChar(CP_ACP, 0, str, -1, retstr, len);
    return retstr;
}



//
// This does not have to be the actual page size on the platform. It is the
// granularity with which we will make accesses.
//

#define MY_PAGE_SIZE 4096

#define PFAPP_MAX_DATA_PAGES    256

char Data[PFAPP_MAX_DATA_PAGES * MY_PAGE_SIZE] = {1};

#define PFAPP_MAX_FUNCS         16

#pragma code_seg("func0")
DWORD func0(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func1")
DWORD func1(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func2")
DWORD func2(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func3")
DWORD func3(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func4")
DWORD func4(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func5")
DWORD func5(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func6")
DWORD func6(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func7")
DWORD func7(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func8")
DWORD func8(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func9")
DWORD func9(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func10")
DWORD func10(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func11")
DWORD func11(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func12")
DWORD func12(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func13")
DWORD func13(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func14")
DWORD func14(VOID) {return ERROR_SUCCESS;};

#pragma code_seg("func15")
DWORD func15(VOID) {return ERROR_SUCCESS;};

#pragma code_seg()

char *PfAppUsage = "pfapp.exe -data datafile\n";

INT 
__cdecl
main(
    INT argc, 
    PCHAR argv[]
    ) 
{
    WCHAR *CommandLine;
    WCHAR *Argument;
    WCHAR *DataFile;
    PCHAR BasePointer;
    DWORD FileSize;
    DWORD FileSizeInMyPages;
    DWORD ErrorCode;
    DWORD FuncNo;
    DWORD NumCalls;
    DWORD CallIdx;
    DWORD DataPage;
    DWORD NumDataAccesses;
    DWORD DataAccessIdx;
    DWORD Sum;

    //
    // Initialize locals.
    //

    CommandLine = GetCommandLine();
    DataFile = NULL;
    BasePointer = NULL;

    //
    // Initialize random generator.
    //

    srand((unsigned)time(NULL));

    //
    // Check arguments.
    //

    if (argc != 3) {
        printf(PfAppUsage);
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Call functions. Each one is on a different page. Basing the number of calls
    // we will make on number of functions/pages we have leads to more interesting
    // access patterns and prefetch policy decisions.
    //

    NumCalls = rand() % PFAPP_MAX_FUNCS;
    NumCalls += PFAPP_MAX_FUNCS / 4;

    for (CallIdx = 0; CallIdx < NumCalls; CallIdx++) {

        FuncNo = rand() % PFAPP_MAX_FUNCS;

        switch(FuncNo) {

        case 0: func0(); break;
        case 1: func1(); break;
        case 2: func2(); break;
        case 3: func3(); break;
        case 4: func4(); break;
        case 5: func5(); break;
        case 6: func6(); break;
        case 7: func7(); break;
        case 8: func8(); break;
        case 9: func9(); break;
        case 10: func10(); break;
        case 11: func11(); break;
        case 12: func12(); break;
        case 13: func13(); break;
        case 14: func14(); break;
        case 15: func15(); break;

        default: break;
        }
    }

    //
    // Access pages in the data section. Basing the number of accesses
    // we will make on number of pages we have adds more regularity to our 
    // accesses so they survive sensitivity based prefetch policy decisions.
    //

    NumDataAccesses = rand() % PFAPP_MAX_DATA_PAGES;
    NumDataAccesses += PFAPP_MAX_DATA_PAGES / 4;

    Sum = 0;

    for (DataAccessIdx = 0; DataAccessIdx < NumDataAccesses; DataAccessIdx++) {

        DataPage = rand() % PFAPP_MAX_DATA_PAGES;

        Sum += Data[DataPage * MY_PAGE_SIZE];
    }

    printf("Bogus sum1 is %d\n", Sum);

    //
    // Map the executable as data.
    //

    DataFile = PfAppAnsiToUnicode(argv[2]);

    if (!DataFile) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    ErrorCode = PfAppGetViewOfFile(DataFile, &BasePointer, &FileSize);

    if (ErrorCode != ERROR_SUCCESS) {
        printf("Could not map data file: %x\n", ErrorCode);
        goto cleanup;
    }

    FileSizeInMyPages = FileSize / MY_PAGE_SIZE;

    //
    // Touch the pages of the executable as data pages.
    //

    NumDataAccesses = rand() % FileSizeInMyPages;
    NumDataAccesses += FileSizeInMyPages / 4;

    Sum = 0;

    for (DataAccessIdx = 0; DataAccessIdx < NumDataAccesses; DataAccessIdx++) {

        DataPage = rand() % FileSizeInMyPages;

        Sum += BasePointer[DataPage * MY_PAGE_SIZE];
    }

    printf("Bogus sum2 is %d\n", Sum);
                
    ErrorCode = ERROR_SUCCESS;

cleanup:

    if (DataFile) {
        free(DataFile);
    }

    if (BasePointer) {
        UnmapViewOfFile(BasePointer);
    }
    
    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\service\daytona\test\pftest\pfcontst.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pfcontst.c

Abstract:

    This module builds a console test program for the prefetcher
    maintenance service.

    The console test program

     - Can dump the contents of a scenario or trace file.
     - Can create a thread and run as the service would. Press CTRL-C 
       to send the termination signal.
  
    Note that both scenario and trace files are currently dumped after
    putting them into the intermediate format which may change number
    of launches and shift the UsageHistory etc.

    The test programs are built from the same sources as the original. This
    allows the test program to override parts of the original program to run
    it in a managed environment, and be able to test individual functions. 

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#define PFSVC_CONSOLE_TEST

#include "..\..\pfsvc.c"

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

//
// Fake the idletask server internal function.
//

BOOL
ItSpSetProcessIdleTasksNotifyRoutine (
    PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE NotifyRoutine
    )
{
    return TRUE;
}

//
// Dump intermediate scenario structure.
//

VOID
DumpMetadataInfo (
    PPF_SCENARIO_HEADER Scenario
    )
{
    PCHAR MetadataInfoBase;
    PPF_METADATA_RECORD MetadataRecordTable;
    PPF_METADATA_RECORD MetadataRecord;
    ULONG MetadataRecordIdx;
    PWCHAR VolumePath;
    PFILE_PREFETCH FilePrefetchInfo;
    ULONG FileIndexNumberIdx;
    ULONG DirectoryIdx;
    PPF_COUNTED_STRING DirectoryPath;

    //
    // Get pointers to metadata prefetch information.
    //

    MetadataInfoBase = (PCHAR)Scenario + Scenario->MetadataInfoOffset;
    MetadataRecordTable = (PPF_METADATA_RECORD) MetadataInfoBase;

    //
    // Dump metadata records and contents.
    //

    for (MetadataRecordIdx = 0;
         MetadataRecordIdx < Scenario->NumMetadataRecords;
         MetadataRecordIdx++) {

        MetadataRecord = &MetadataRecordTable[MetadataRecordIdx];
        
        //
        // Print volume name.
        //

        VolumePath = (PWCHAR)
            (MetadataInfoBase + MetadataRecord->VolumeNameOffset);  
        
        wprintf(L"VolumePath:%s\n", VolumePath);

        //
        // Print volume identifiers.
        //

        wprintf(L"SerialNumber:%.8x CreationTime:%I64x\n", 
                MetadataRecord->SerialNumber,
                MetadataRecord->CreationTime.QuadPart);

        //
        // Print the directories accessed on this volume.
        //

        wprintf(L"Directories:\n");
        
        DirectoryPath = (PPF_COUNTED_STRING)
            (MetadataInfoBase + MetadataRecord->DirectoryPathsOffset);
        
        for (DirectoryIdx = 0;
             DirectoryIdx < MetadataRecord->NumDirectories;
             DirectoryIdx++) {

            wprintf(L"  %ws\n", DirectoryPath->String);
            
            DirectoryPath = (PPF_COUNTED_STRING) 
                (&DirectoryPath->String[DirectoryPath->Length + 1]);
        }

        //
        // Print file prefetch info structure.
        //

        FilePrefetchInfo = (PFILE_PREFETCH) 
            (MetadataInfoBase + MetadataRecord->FilePrefetchInfoOffset);
        
        wprintf(L"FilePrefetchInfo.Type:%d\n", FilePrefetchInfo->Type);
        wprintf(L"FilePrefetchInfo.Count:%d\n", FilePrefetchInfo->Count);

        //
        // Print file index numbers.
        //

        for(FileIndexNumberIdx = 0;
            FileIndexNumberIdx < FilePrefetchInfo->Count;
            FileIndexNumberIdx++) {

            wprintf(L"0x%016I64x\n", FilePrefetchInfo->Prefetch[FileIndexNumberIdx]);
        }
        
        wprintf(L"\n");
    }

    return;
}
   
VOID
DumpScenarioInfo(
    PPFSVC_SCENARIO_INFO ScenarioInfo,
    LONG DumpSectionIdx
    )
{
    PPF_SCENARIO_HEADER Scenario;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_PAGE_NODE PageNode;
    PLIST_ENTRY SectHead;
    PLIST_ENTRY SectNext;
    PLIST_ENTRY PageHead;
    PLIST_ENTRY PageNext;
    LONG SectionIdx;
    LONG PageIdx;
    WCHAR UsageHistory[PF_PAGE_HISTORY_SIZE + 1];
    WCHAR PrefetchHistory[PF_PAGE_HISTORY_SIZE + 1];
    ULONG HistoryMask;
    ULONG CharIdx;
    ULONG BitIdx;
    TIME_FIELDS TimeFields;

    Scenario = &ScenarioInfo->ScenHeader;
    SectHead = &ScenarioInfo->SectionList;
    SectNext = SectHead->Flink;
    SectionIdx = 0;

    //
    // Print information on the scenario header.
    //
    
    wprintf(L"Scenario: %s-%08X Type: %2d Sects: %5d Pages: %8d "
            L"Launches: %5d Sensitivity: %5d\n",
            Scenario->ScenarioId.ScenName, Scenario->ScenarioId.HashId,
            (ULONG) Scenario->ScenarioType,
            Scenario->NumSections, Scenario->NumPages,
            Scenario->NumLaunches, Scenario->Sensitivity);

    RtlTimeToTimeFields(&Scenario->LastLaunchTime, &TimeFields);

    wprintf(L"  LastLaunchTime(UNC): %04d/%02d/%02d %02d:%02d:%02d, "
            L"MinRePrefetchTime: %10I64d, MinReTraceTime: %10I64d\n\n",
            TimeFields.Year,
            TimeFields.Month,
            TimeFields.Day,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second,
            Scenario->MinReTraceTime.QuadPart,
            Scenario->MinRePrefetchTime.QuadPart);
    
    //
    // Print information per section node.
    //

    while (SectHead != SectNext) {

        SectionNode = (PPFSVC_SECTION_NODE) CONTAINING_RECORD(SectNext,
                                                        PFSVC_SECTION_NODE,
                                                        SectionLink);

        if (DumpSectionIdx == -1 || DumpSectionIdx == SectionIdx) {
            
            wprintf(L"Section %5d: %8d Pages %4s %4s %4s '%s'\n", 
                    SectionIdx, 
                    SectionNode->SectionRecord.NumPages,
                    (SectionNode->SectionRecord.IsIgnore) ? L"Ign" : L"",
                    (SectionNode->SectionRecord.IsImage) ?  L"Img" : L"",
                    (SectionNode->SectionRecord.IsData) ?   L"Dat" : L"",
                    SectionNode->FilePath);
        }

        if (DumpSectionIdx == SectionIdx) {

            wprintf(L"\n");

            PageHead = &SectionNode->PageList;
            PageNext = PageHead->Flink;
        
            PageIdx = 0;
            
            while (PageHead != PageNext) {
            
                PageNode = (PPFSVC_PAGE_NODE) CONTAINING_RECORD(PageNext,
                                                          PFSVC_PAGE_NODE,
                                                          PageLink);

                //
                // Build bitwise representation of the page
                // usage/prefetch histories.
                //

                for (BitIdx = 0; BitIdx < PF_PAGE_HISTORY_SIZE; BitIdx++) {
                    
                    HistoryMask = 0x1 << BitIdx;
                    CharIdx = PF_PAGE_HISTORY_SIZE - BitIdx - 1;

                    if (PageNode->PageRecord.UsageHistory & HistoryMask) {
                        UsageHistory[CharIdx] = L'X';
                    } else {
                        UsageHistory[CharIdx] = L'-';
                    }

                    if (PageNode->PageRecord.PrefetchHistory & HistoryMask) {
                        PrefetchHistory[CharIdx] = L'X';
                    } else {
                        PrefetchHistory[CharIdx] = L'-';
                    }
                }

                //
                // Make sure history strings are NUL terminated.
                //
                
                UsageHistory[PF_PAGE_HISTORY_SIZE] = 0;
                PrefetchHistory[PF_PAGE_HISTORY_SIZE] = 0;
                
                //
                // Print out page record.
                //

                wprintf(L"Page %8d: File Offset: %10x IsImage: %1d IsData: %1d UsageHist: %s PrefetchHist: %s\n", 
                        PageIdx,
                        PageNode->PageRecord.FileOffset,
                        PageNode->PageRecord.IsImage,
                        PageNode->PageRecord.IsData,
                        UsageHistory,
                        PrefetchHistory);
            
                PageIdx++;
                PageNext = PageNext->Flink;
            }
        }

        SectionIdx++;
        SectNext = SectNext->Flink;
    }
}
    
HANDLE PfSvStopEvent = NULL;
HANDLE PfSvThread = NULL;

BOOL
ConsoleHandler(DWORD dwControl)
{
    SetEvent(PfSvStopEvent);   
    
    return TRUE;
}

PFSVC_IDLE_TASK *RunningTask = NULL;
PFSVC_IDLE_TASK g_Tasks[3];

DWORD 
DoWork (
    PFSVC_IDLE_TASK *Task
    )
{
    DWORD ErrorCode;
    DWORD EndTime;
    DWORD TaskNo;

    //
    // Initialize locals.
    //

    TaskNo = (ULONG) (Task - g_Tasks);

    printf("TSTRS: %d: DoWork()\n",TaskNo);

    RunningTask = Task;

    //
    // Randomly determine how long the task should take.
    //

    EndTime = GetTickCount() + rand() % 8192;

    //
    // Run until we are done or told to stop.
    //

    while (GetTickCount() < EndTime) {

        //
        // Check if we should still run.
        //

        ErrorCode = PfSvContinueRunningTask(Task);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("TSTRS: %d: DoWork-ContinueTaskReturned=%x\n",TaskNo, ErrorCode);
            goto cleanup;
        }
    }

    //
    // Sometimes return failure, sometimes success.
    //

    ErrorCode = ERROR_SUCCESS;

    if (rand() % 2) {
        ErrorCode = ERROR_INVALID_FUNCTION;
    }

cleanup:

    RunningTask = NULL;

    printf("TSTRS: %d: DoWork()=%d,%s\n",TaskNo,ErrorCode,(ErrorCode==ERROR_RETRY)?"Retry":"Done");

    return ErrorCode;
}

DWORD
TaskStress(
    VOID
    )
{
    INPUT MouseInput;
    PPFSVC_IDLE_TASK TaskToUnregister;
    ULONG NumTasks;
    ULONG TaskIdx;
    ULONG SleepTime;
    DWORD ErrorCode;
    DWORD WaitResult;
    BOOLEAN UnregisterRunningTask;

    //
    // Initialize locals.
    //

    RtlZeroMemory(&MouseInput, sizeof(MouseInput));
    MouseInput.type = INPUT_MOUSE;
    MouseInput.mi.dwFlags = MOUSEEVENTF_MOVE;

    NumTasks = sizeof(g_Tasks) / sizeof(g_Tasks[0]);

    for (TaskIdx = 0; TaskIdx < NumTasks; TaskIdx++) {
        PfSvInitializeTask(&g_Tasks[TaskIdx]);     
    }

    printf("TSTRS: TaskStress()\n");

    //
    // Loop, reregistering / unregistering tasks, sending user input 
    // etc.
    //

    while (TRUE) {

        //
        // Send user input once in a while to restart idle detection.
        //

        if ((rand() % 3) == 0) {
            printf("TSTRS: TaskStress-SendingInput\n");
            SendInput(1, &MouseInput, sizeof(MouseInput));
        }

        //
        // Once in a while unregister a task.
        //      

        TaskToUnregister = NULL;

        if ((rand() % 4) == 0) {

            TaskToUnregister = RunningTask;
            printf("TSTRS: TaskStress-UnregisterRunningTask\n");

        } else if ((rand() % 3) == 0) {

            TaskIdx = rand() % NumTasks;

            TaskToUnregister = &g_Tasks[TaskIdx];
            printf("TSTRS: TaskStress-UnregisterTaskIdx(%d)\n", TaskIdx);
        }

        if (TaskToUnregister) {
            PfSvUnregisterTask(TaskToUnregister, FALSE);
            printf("TSTRS: TaskStress-Unregistered(%d)\n", TaskToUnregister - g_Tasks);
        }       

        //
        // Register any unregistered tasks.
        //

        for (TaskIdx = 0; TaskIdx < NumTasks; TaskIdx++) {

            if (!g_Tasks[TaskIdx].Registered) {

                //
                // Cleanup and reinitialize the task.
                //

                PfSvCleanupTask(&g_Tasks[TaskIdx]);
                PfSvInitializeTask(&g_Tasks[TaskIdx]);

                printf("TSTRS: TaskStress-RegisterTaskIdx(%d)\n", TaskIdx);

                ErrorCode = PfSvRegisterTask(&g_Tasks[TaskIdx], 
                                             ItDiskMaintenanceTaskId,
                                             PfSvCommonTaskCallback,
                                             DoWork);

                if (ErrorCode != ERROR_SUCCESS) {
                    goto cleanup;
                }
            }
        }

        SleepTime = 10000 * (rand() % 64) / 64;       

        //
        // Sleep, waiting on the event that will be signaled to stop us.
        //

        printf("TSTRS: TaskStress-MainLoopSleeping(%d)\n", SleepTime);

        WaitResult = WaitForSingleObject(PfSvStopEvent, SleepTime);

        printf("TSTRS: TaskStress-Wokeup(%d)\n", SleepTime);
        
        if (WaitResult == WAIT_OBJECT_0) {
            printf("TSTRS: TaskStress-PfSvStopEventSignaled\n");
            break;
        } else if (WaitResult != WAIT_TIMEOUT) {
            ErrorCode = GetLastError();
            printf("TSTRS: TaskStress-WaitFailed=%x\n", ErrorCode);
            goto cleanup;
        }
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:    

    for (TaskIdx = 0; TaskIdx < NumTasks; TaskIdx++) {

        if (g_Tasks[TaskIdx].Registered) {
            printf("TSTRS: TaskStress-Unregistering(%d)\n", TaskIdx);
            PfSvUnregisterTask(&g_Tasks[TaskIdx], FALSE);
        }
        
        printf("TSTRS: TaskStress-Cleanup(%d)\n", TaskIdx);
        PfSvCleanupTask(&g_Tasks[TaskIdx]);
    }

    printf("TSTRS: TaskStress()=%d\n", ErrorCode);

    return ErrorCode;
}

DWORD
DumpTrace (
    PPF_TRACE_HEADER Trace 
    )

/*++

Routine Description:

    Prints out contents of a trace file as is.

Arguments:

    Trace - Pointer to trace.

Return Value:

    Win32 error code.

--*/

{
    PPF_SECTION_INFO *SectionTable;
    PPF_SECTION_INFO Section;
    PPF_LOG_ENTRY LogEntries;
    PCHAR pFileName;
    ULONG SectionIdx;
    ULONG EntryIdx;
    DWORD ErrorCode;
    ULONG SectionLength;
    ULONG NextSectionIndex;
    PPF_VOLUME_INFO VolumeInfo;
    ULONG VolumeInfoSize;
    ULONG VolumeIdx;
    ULONG SectionTableSize;

    //
    // Initialize locals so we know what to clean up.
    //

    SectionTable = NULL;

    //
    // Walk through the volumes in the trace.
    //

    printf("Volume Info\n");

    VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR)Trace + Trace->VolumeInfoOffset);

    for (VolumeIdx = 0; VolumeIdx < Trace->NumVolumes; VolumeIdx++) {

        printf("%16I64x %8x %ws\n", 
               VolumeInfo->CreationTime, 
               VolumeInfo->SerialNumber,
               VolumeInfo->VolumePath);

        //
        // Get the next volume.
        //

        VolumeInfoSize = sizeof(PF_VOLUME_INFO);
        VolumeInfoSize += VolumeInfo->VolumePathLength * sizeof(WCHAR);

        VolumeInfo = (PPF_VOLUME_INFO) ((PCHAR) VolumeInfo + VolumeInfoSize);
        
        //
        // Make sure VolumeInfo is aligned.
        //

        VolumeInfo = PF_ALIGN_UP(VolumeInfo, _alignof(PF_VOLUME_INFO));
    }

    //
    // Allocate section table.
    //

    SectionTableSize = sizeof(PPF_SECTION_INFO) * Trace->NumSections;
    SectionTable = PFSVC_ALLOC(SectionTableSize);
    
    if (!SectionTable) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    RtlZeroMemory(SectionTable, SectionTableSize);

    //
    // Walk through the sections in the trace.
    //

    Section = (PPF_SECTION_INFO) ((PCHAR)Trace + Trace->SectionInfoOffset);

    for (SectionIdx = 0; SectionIdx < Trace->NumSections; SectionIdx++) {

        //
        // Put section into the table.
        //

        SectionTable[SectionIdx] = Section;

        //
        // Get the next section record in the trace.
        //

        SectionLength = sizeof(PF_SECTION_INFO) +
            (Section->FileNameLength) * sizeof(WCHAR);

        Section = (PPF_SECTION_INFO) ((PUCHAR) Section + SectionLength);
    }

    //
    // Print out pagefault information.
    //

    printf("\n");
    printf("Page faults\n");

    LogEntries = (PPF_LOG_ENTRY) ((PCHAR)Trace + Trace->TraceBufferOffset);
    
    for (EntryIdx = 0; EntryIdx < Trace->NumEntries; EntryIdx++) {

        Section = SectionTable[LogEntries[EntryIdx].SectionId];

        printf("%8x %8d %1d %1d %1d %ws\n", 
               LogEntries[EntryIdx].FileOffset,
               (ULONG) LogEntries[EntryIdx].SectionId,
               (ULONG) LogEntries[EntryIdx].IsImage,
               (ULONG) LogEntries[EntryIdx].InProcess,
               (ULONG) Section->Metafile,
               Section->FileName);
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (SectionTable) {
        PFSVC_FREE(SectionTable);
    }

    DBGPR((PFID,PFTRC,"PFSVC: AddTraceInfo()=%x\n", ErrorCode));

    return ErrorCode;
}


wchar_t *PfSvUsage = 
L" pftest -scenario=scenariofile [-sectionid=sectionid] [-realdump]          \n"
L" pftest -scenario=scenariofile -metadata                                   \n"
L" pftest -scenario=scenariofile -layout=outputfile                          \n"
L" pftest -trace=tracefile [-sectionid=sectionid] [-realdump]                \n"
L" pftest -process_trace=tracefile                                           \n"
L" pftest -bootfiles                                                         \n"
L" pftest -service                                                           \n"
L" pftest -cleanupdir                                                        \n"
L" pftest -defragdisks                                                       \n"
L" pftest -updatelayout                                                      \n"
L" pftest -taskstress                                                        \n"
L" pftest -scenfiles=scendir                                                 \n"
;

INT 
__cdecl
main(
    INT argc, 
    PCHAR argv[]
    ) 
{
    WCHAR FileName[MAX_PATH];
    WCHAR LayoutFile[MAX_PATH];
    LONG SectionId;
    DWORD ErrorCode;
    PPF_SCENARIO_HEADER Scenario;
    PPF_TRACE_HEADER TraceFile;
    PPF_TRACE_HEADER Trace;
    DWORD Size;
    PF_SCENARIO_ID ScenarioId;
    PF_SCENARIO_TYPE ScenarioType;
    PFSVC_SCENARIO_INFO ScenarioInfo;
    PLIST_ENTRY SectHead;
    PLIST_ENTRY SectNext;
    PPFSVC_SECTION_NODE SectionNode;
    PPFSVC_VOLUME_NODE VolumeNode;
    PFSVC_PATH_LIST Layout;
    FILETIME FileTime;
    ULONG FailedCheck;
    PFSVC_PATH_LIST PathList;
    PPFSVC_PATH Path;
    WCHAR *CommandLine;
    WCHAR *Argument;
    BOOLEAN DumpOptimalLayout;
    BOOLEAN DumpMetadata;
    BOOLEAN InitializedPfSvGlobals;
    BOOLEAN MappedViewOfTrace;
    BOOLEAN MappedViewOfScenario;
    BOOLEAN InitializedScenarioInfo;
    PF_SYSTEM_PREFETCH_PARAMETERS Parameters;
    PREFETCHER_INFORMATION PrefetcherInformation;
    NTSTATUS Status;
    ULONG Length;
    PNTPATH_TRANSLATION_LIST TranslationList;
    PWCHAR DosPathBuffer;
    ULONG DosPathBufferSize;
    PFSVC_SCENARIO_FILE_CURSOR FileCursor;
    ULONG LoopIdx;
    ULONG NumLoops;
    ULONG NumPrefetchFiles;
    WCHAR ScenarioFilePath[MAX_PATH];
    ULONG ScenarioFilePathMaxChars;
    BOOLEAN RealDump;
    
    //
    // Initialize locals.
    //

    CommandLine = GetCommandLine();
    PfSvInitializePathList(&PathList, NULL, FALSE);
    PfSvInitializePathList(&Layout, NULL, FALSE);
    SectionId = -1;
    InitializedPfSvGlobals = FALSE;
    MappedViewOfScenario = FALSE;
    MappedViewOfTrace = FALSE;
    InitializedScenarioInfo = FALSE;
    Trace = NULL;
    TranslationList = NULL;
    DosPathBuffer = NULL;
    DosPathBufferSize = 0;
    PfSvInitializeScenarioFileCursor(&FileCursor);
    ScenarioFilePathMaxChars = sizeof(ScenarioFilePath) / 
                               sizeof(ScenarioFilePath[0]);
    RealDump = FALSE;

    //
    // Initialize globals.
    //

    PfSvStopEvent = NULL;
    PfSvThread = NULL;

    ErrorCode = PfSvInitializeGlobals();
    
    if (ErrorCode != ERROR_SUCCESS) {
        printf("Could not initialize globals: %x\n", ErrorCode);
        goto cleanup;
    }

    InitializedPfSvGlobals = TRUE;

    //
    // Initialize random.
    //
    
    srand((unsigned)time(NULL));

    //
    // Get necessary permissions for this thread to perform prefetch
    // service tasks.
    //

    ErrorCode = PfSvGetPrefetchServiceThreadPrivileges();
    
    if (ErrorCode != ERROR_SUCCESS) {
        printf("Failed to get prefetcher service thread priviliges=%x\n", ErrorCode);
        goto cleanup;
    }

    //
    // Get system prefetch parameters.
    //

    ErrorCode = PfSvQueryPrefetchParameters(&PfSvcGlobals.Parameters);

    if (ErrorCode != ERROR_SUCCESS) {
        printf("Failed to query system prefetch parameters=%x\n", ErrorCode);
        goto cleanup;
    }

    //
    // Initialize the directory that contains prefetch instructions.
    //
    
    ErrorCode = PfSvInitializePrefetchDirectory(PfSvcGlobals.Parameters.RootDirPath);
    
    if (ErrorCode != ERROR_SUCCESS) {
        printf("Failed to initialize prefetch directory=%x\n", ErrorCode);
        goto cleanup;
    }   

    //
    // Initialize the event the will get set when we get CTRL-C'ed.
    //
    
    PfSvStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    
    if (!PfSvStopEvent) {
        ErrorCode = GetLastError();
        printf("Failed to initialize stop event=%x\n", ErrorCode);
        goto cleanup;
    }

    //
    // Build NT path translation list. We don't need to do this always, but heck,
    // let's do it anyway. It should work.
    //

    ErrorCode = PfSvBuildNtPathTranslationList(&TranslationList);

    if (ErrorCode != ERROR_SUCCESS) {
        printf("Failed to build NT path translation list=%x\n", ErrorCode);
        goto cleanup;
    }

    //
    // Are we supposed dump the scenarios and traces as they are?
    //

    if (Argument = wcsstr(CommandLine, L"-realdump")) {
        RealDump = TRUE;
    }

    //
    // Were we asked to run as the service?
    //
    
    if (Argument = wcsstr(CommandLine, L"-service")) {
    
        fprintf(stderr, "Running as service...\n");

        //
        // Set a console handler so we know to stop when Ctrl-C is typed.
        //

        SetConsoleCtrlHandler(ConsoleHandler, TRUE);

        //
        // Create service thread:
        //

        //
        // Cleanup the globals as the service thread will reinitialize
        // them.
        //

        PfSvCleanupGlobals();
        InitializedPfSvGlobals = FALSE;

        PfSvThread = CreateThread(0,0,PfSvcMainThread,&PfSvStopEvent,0,0); 
        
        if (!PfSvThread) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
    
        //
        // Wait for the thread to exit.
        //

        WaitForSingleObject(PfSvThread, INFINITE);

        ErrorCode = ERROR_SUCCESS;
        
        goto cleanup;
    }

    //
    // Were we asked to build the list of boot files?
    //

    if (Argument = wcsstr(CommandLine, L"-bootfiles")) {
            
        ErrorCode = PfSvBuildBootLoaderFilesList(&PathList);
            
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not build boot files list: %d\n", ErrorCode);
            goto cleanup;
        }
            
        Path = NULL;
        
        while (Path = PfSvGetNextPathInOrder(&PathList,Path)) {
            printf("%ws\n", Path->Path);
        }

        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Was a section ID specified for trace/scenario dumping?
    //
    
    if (Argument = wcsstr(CommandLine, L"-sectionid=")) {
    
        swscanf(Argument, L"-sectionid=%d", &SectionId);
    }

    //
    // Are we dumping a trace?
    //

    if (Argument = wcsstr(CommandLine, L"-trace=")) {

        swscanf(Argument, L"-trace=%s", FileName);
            
        //
        // Map the file.
        //

        ErrorCode = PfSvGetViewOfFile(FileName,
                                      &TraceFile,
                                      &Size);
            
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not map\n");
            goto cleanup;
        }

        MappedViewOfTrace = TRUE;

        Trace = PFSVC_ALLOC(Size);

        if (!Trace) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        RtlCopyMemory(Trace, TraceFile, Size);
        
        //
        // Verify it.
        //

        if (!PfVerifyTraceBuffer(Trace, Size, &FailedCheck)) {
            printf("Could not verify:%d\n",FailedCheck);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }

        //
        // If we were asked to do a real as-is dump, do so.
        //

        if (RealDump) {
            DumpTrace(Trace);
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }

        //
        // Build a scenario info structure. 
        //

        ScenarioId = Trace->ScenarioId;
        ScenarioType = Trace->ScenarioType;
            
        PfSvInitializeScenarioInfo(&ScenarioInfo,
                                   &ScenarioId,
                                   ScenarioType);

        InitializedScenarioInfo = TRUE;

        //
        // Allocate memory upfront for trace processing.
        //

        ErrorCode = PfSvScenarioInfoPreallocate(&ScenarioInfo,
                                                NULL,
                                                Trace);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not Preallocate=%d\n", ErrorCode);
            goto cleanup;
        }
            
        ErrorCode = PfSvAddTraceInfo(&ScenarioInfo,
                                     Trace);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not AddTraceInfo=%d\n", ErrorCode);
            goto cleanup;
        }

        ErrorCode = PfSvApplyPrefetchPolicy(&ScenarioInfo);
        
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not apply policy=%d\n", ErrorCode);
            goto cleanup;
        }

        DumpScenarioInfo(&ScenarioInfo, SectionId);

        ErrorCode = ERROR_SUCCESS;
        
        goto cleanup;

    }

    //
    // Are we processing a trace?
    //

    if (Argument = wcsstr(CommandLine, L"-process_trace=")) {

        swscanf(Argument, L"-process_trace=%s", FileName);
            
        //
        // Map the file.
        //

        ErrorCode = PfSvGetViewOfFile(FileName,
                                      &TraceFile,
                                      &Size);
            
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not map\n");
            goto cleanup;
        }

        MappedViewOfTrace = TRUE;

        Trace = PFSVC_ALLOC(Size);

        if (!Trace) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        RtlCopyMemory(Trace, TraceFile, Size);
        
        //
        // Verify it.
        //

        if (!PfVerifyTraceBuffer(Trace, Size, &FailedCheck)) {
            printf("Could not verify:%d\n",FailedCheck);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }
               
        //
        // Process the trace.
        //

        ErrorCode = PfSvProcessTrace(Trace);
        
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Failed process trace: %d\n", ErrorCode);
            goto cleanup;
        }
        
        printf("Done.\n");

        ErrorCode = ERROR_SUCCESS;
        
        goto cleanup;
    }

    //
    // Are we dumping the contents of a scenario?
    //

    if (Argument = wcsstr(CommandLine, L"-scenario=")) {

        swscanf(Argument, L"-scenario=%s", FileName);

        //
        // Are we dumping metadata?
        //

        if(Argument = wcsstr(CommandLine, L"-metadata")) {
            DumpMetadata = TRUE;
        } else {
            DumpMetadata = FALSE;
        }
        
        //
        // Are we dumping layout?
        //

        if (Argument = wcsstr(CommandLine, L"-layout")) {
            
            swscanf(Argument, L"-layout=%s", LayoutFile);
            DumpOptimalLayout = TRUE;

        } else {
            DumpOptimalLayout = FALSE;
        }
            
        //
        // Map the file.
        //

        ErrorCode = PfSvGetViewOfFile(FileName,
                                      &Scenario,
                                      &Size);
            
        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not map\n");
            goto cleanup;
        }

        MappedViewOfScenario = TRUE;
        
        //
        // Verify it.
        //

        if (!PfVerifyScenarioBuffer(Scenario, Size, &FailedCheck)) {
            printf("Could not verify:%d\n",FailedCheck);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }              

        //
        // If we were asked to, dump what the optimal layout file
        // derived just from this scenario would be:
        //

        if (DumpOptimalLayout) {

            //
            // Do this multiple times, it should not change the resulting file.
            //

            for (LoopIdx = 0; LoopIdx < 32; LoopIdx++) {

                if (Scenario->ScenarioType == PfSystemBootScenarioType) {

                    ErrorCode = PfSvBuildBootLoaderFilesList(&Layout);
                        
                    if (ErrorCode != ERROR_SUCCESS) {
                        printf("Could not build boot files list: %d\n", ErrorCode);
                        goto cleanup;
                    }
                }

                ErrorCode = PfSvUpdateLayoutForScenario(&Layout,
                                                        FileName,
                                                        TranslationList,
                                                        &DosPathBuffer,
                                                        &DosPathBufferSize);

                if (ErrorCode != ERROR_SUCCESS) {
                    printf("Failed UpdateLayoutForScenario=%x\n", ErrorCode);
                    goto cleanup;
                }
                                      
                ErrorCode = PfSvSaveLayout (LayoutFile, &Layout, &FileTime);

                if (ErrorCode != ERROR_SUCCESS) {
                    printf("Could not save optimal layout\n");
                    goto cleanup;
                }
            }

            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }


        //
        // If we were asked to dump the metadata, just do that.
        //

        if (DumpMetadata) {
            DumpMetadataInfo(Scenario);
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }
        
        //
        // Initialize scenario information.
        //

        PfSvInitializeScenarioInfo(&ScenarioInfo,
                                   &Scenario->ScenarioId,
                                   Scenario->ScenarioType);

        InitializedScenarioInfo = TRUE;

        //
        // Allocate memory upfront for trace & scenario processing.
        //

        ErrorCode = PfSvScenarioInfoPreallocate(&ScenarioInfo,
                                                Scenario,
                                                NULL);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not preallocate: %d\n", ErrorCode);
            goto cleanup;
        }

        //
        // Incorporate information from existing scenario file.
        //

        ErrorCode = PfSvAddExistingScenarioInfo(&ScenarioInfo, Scenario);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Could not add scenario info: %d\n", ErrorCode);
            goto cleanup;
        }
        
        //
        // Dump contents of the scenario.
        //
        
        DumpScenarioInfo(&ScenarioInfo, SectionId);

        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Check if we were asked to perform some tasks that we usually do when the
    // system is idle.
    //

    if (Argument = wcsstr(CommandLine, L"-cleanupdir")) {

        ErrorCode = PfSvCleanupPrefetchDirectory(NULL);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Failed CleanupPrefechDirectory()=%x\n", ErrorCode);
        }

        goto cleanup;
    }

    if (Argument = wcsstr(CommandLine, L"-updatelayout")) {

        ErrorCode = PfSvUpdateOptimalLayout(NULL);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Failed UpdateOptimalLayout()=%x\n", ErrorCode);
        }

        goto cleanup;
    }

    if (Argument = wcsstr(CommandLine, L"-defragdisks")) {

        ErrorCode = PfSvDefragDisks(NULL);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("Failed DefragDisks()=%x\n", ErrorCode);
        }

        goto cleanup;
    }

    if (Argument = wcsstr(CommandLine, L"-taskstress")) {

        ErrorCode = TaskStress();
        goto cleanup;
    }

    //
    // Enumerate scenario files in the given directory.
    //

    if (Argument = wcsstr(CommandLine, L"-scenfiles=")) {

        swscanf(Argument, L"-scenfiles=%s", FileName);

        //
        // Go through the files several times before finally
        // printing out the information.
        //

        NumLoops = 10;

        for (LoopIdx = 0; LoopIdx < NumLoops; LoopIdx++) {

            //
            // Count the files for heck.
            //

            ErrorCode = PfSvCountFilesInDirectory(FileName,
                                                  L"*." PF_PREFETCH_FILE_EXTENSION,
                                                  &NumPrefetchFiles);

            if (ErrorCode != ERROR_SUCCESS) {
                printf("Failed CountFilesInDirectory=%x\n", ErrorCode);
                goto cleanup;
            }

            PfSvCleanupScenarioFileCursor(&FileCursor);
            PfSvInitializeScenarioFileCursor(&FileCursor);

            ErrorCode = PfSvStartScenarioFileCursor(&FileCursor, FileName);

            if (ErrorCode != ERROR_SUCCESS) {
                printf("Failed StartScenarioFileCursor: %x\n", ErrorCode);
                goto cleanup;
            }       

            while (!(ErrorCode = PfSvGetNextScenarioFileInfo(&FileCursor))) {

                if (LoopIdx == NumLoops - 1) {
                    printf("%5d: %ws\n", FileCursor.CurrentFileIdx, FileCursor.FilePath);
                }

                ErrorCode = ERROR_BAD_FORMAT;

                if (FileCursor.FilePathLength != wcslen(FileCursor.FilePath)) {
                    printf("Bad format id: 10\n");
                    goto cleanup;
                }

                if (FileCursor.FileNameLength != wcslen(FileCursor.FileData.cFileName)) {
                    printf("Bad format id: 20\n");
                    goto cleanup;
                }

                if (wcscmp(FileCursor.FileData.cFileName, FileCursor.FilePath + FileCursor.FileNameStart)) {
                    printf("Bad format id: 30\n");
                    goto cleanup;
                }

                if (wcsncmp(FileCursor.PrefetchRoot, FileCursor.FilePath, FileCursor.PrefetchRootLength)) {
                    printf("Bad format id: 40\n");
                    goto cleanup;
                }

                if (FileCursor.FilePathLength > FileCursor.FilePathMaxLength ||
                    FileCursor.PrefetchRootLength > FileCursor.FilePathLength) {
                    printf("Bad format id: 50\n");
                    goto cleanup;
                }           
            }

            if (ErrorCode != ERROR_NO_MORE_FILES) {
                printf("Failed GetNextScenarioFileInfo: %x\n", ErrorCode);
                goto cleanup;
            }

            if (NumPrefetchFiles != FileCursor.CurrentFileIdx) {
                printf("\n\nNum files in directory changed? %d != %d\n\n", 
                       NumPrefetchFiles, FileCursor.CurrentFileIdx);
            }
        }

        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }
    
    //
    // If we come here, no parameters that we understood were
    // specified.
    //

    printf("%ws", PfSvUsage);

    ErrorCode = ERROR_INVALID_PARAMETER;
    
 cleanup:

    if (PfSvStopEvent) {
        CloseHandle(PfSvStopEvent);
    }

    if (PfSvThread) {
        CloseHandle(PfSvThread);
    }

    if (Trace) {
        PFSVC_FREE(Trace);
    }

    if (MappedViewOfTrace) {
        UnmapViewOfFile(TraceFile);
    }

    if (MappedViewOfScenario) {
        UnmapViewOfFile(Scenario);
    }

    if (InitializedScenarioInfo) {
        PfSvCleanupScenarioInfo(&ScenarioInfo);
    }

    PfSvCleanupPathList(&PathList);

    PfSvCleanupPathList(&Layout);

    PfSvCleanupScenarioFileCursor(&FileCursor);

    if (TranslationList) {
        PfSvFreeNtPathTranslationList(TranslationList);
    }

    if (DosPathBuffer) {
        PFSVC_FREE(DosPathBuffer);
    }

    //
    // Uninitialize the globals last.
    //
        
    if (InitializedPfSvGlobals) {
        PfSvCleanupGlobals();
    }

    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\setup\setup.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       setup.cxx
//
//  Contents:   Task Scheduler setup program
//
//  Classes:    None.
//
//  Functions:
//
//  History:    04-Apr-96  MarkBl    Created
//              23-Sep-96  AnirudhS  Added SetTaskFolderSecurity, etc.
//              30-Sep-96  AnirudhS  Added /firstlogon and /logon options
//              15-Nov-96  AnirudhS  Conditionally enable the service on NT too
//              01-09-97   DavidMun  Add sysagent.exe path value under
//                                      app paths, backup sysagent.exe
//              04-14-97   DavidMun  Add DoMemphisSetup
//              03-03-01   JBenton   Prefix BUG 333200 use of uninit memory
//              03-10-01   JBenton   BUG 142333 tighten Tasks folder security
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <regstr.h>
#include <tchar.h>
#include <common.hxx>
#include <security.hxx>
#include "setupids.h"

#if defined(_CHICAGO_)
#include <shlobj.h>
#include <shellapi.h>
#include <shlobjp.h>
#include <dbcs.hxx>
#else // NT
#include <userenv.h>
#include <userenvp.h>
#endif // defined(_CHICAGO_)

#define ARRAY_LEN(a)                (sizeof(a)/sizeof((a)[0]))
#define ARG_DELIMITERS              TEXT(" \t")
#define MINUTES_BEFORE_IDLE_DEFAULT 15

//
// Note that the svchost registry keys to run schedule service as a part
// of netsvcs is set in hivesft.inx file.
//

#define SCHED_SERVICE_EXE_PATH      TEXT("%SystemRoot%\\System32\\svchost.exe -k netsvcs")


#define SCHED_SERVICE_EXE           TEXT("MSTask.exe")
#define SCHED_SERVICE_DLL           TEXT("MSTask.dll")
#define SCHED_SERVICE_PRE_DLL       TEXT("mstnt.dll")
#define SCHED_SERVICE_NAME          TEXT("Schedule")
#define SCHED_SERVICE_GROUP         TEXT("SchedulerGroup")
#define MINUTESBEFOREIDLE           TEXT("MinutesBeforeIdle")
#define MAXLOGSIZEKB                TEXT("MaxLogSizeKB")
#define TASKSFOLDER                 TEXT("TasksFolder")
#define FIRSTBOOT                   TEXT("FirstBoot")
#define SM_SA_KEY                   TEXT("Software\\Microsoft\\SchedulingAgent")
#define SAGE_EXE                    TEXT("SAGE.EXE")
#define SAGE_DLL                    TEXT("SAGE.DLL")
#define SYSAGENT_BAK                TEXT("SYSAGENT.BAK")
#define SYSAGENT_EXE                TEXT("SYSAGENT.EXE")
#define SAVED_SAGE_EXE              TEXT("SAGEEXE.BAK")
#define SAVED_SAGE_DLL              TEXT("SAGEDLL.BAK")
#define SAVED_SAGE_LINK             TEXT("SAGELNK.BAK")

//
// Entry points from mstask.dll loaded by chicago or daytona versions of this
// program.  Note they are used with GetProcAddress, which always wants an
// ANSI string.
//

#define CONVERT_SAGE_TASKS_API      "ConvertSageTasksToJobs"
#define CONDITIONALLY_ENABLE_API    "ConditionallyEnableService"
#define CONVERT_AT_TASKS_API        "ConvertAtJobsToTasks"

//
// Function pointer types used when loading above functions from mstask.dll
//

typedef HRESULT (__stdcall *PSTDAPI)(void);
typedef BOOL (__stdcall *PBOOLAPI)(void);
typedef VOID (__stdcall *PVOIDAPI)(void);

// NOTE - Debug output is turned off.  To turn it on, link in smdebug.lib.
#define schDebugOut(x)

VOID DoPreUnsetup(void);

#if defined(_CHICAGO_)

VOID DoPreSetup(void);
VOID DoMemphisSetup();
BOOL GetOriginalShortcutLocation(LPTSTR tszPath);

#else  // !_CHICAGO_

typedef struct _MYSIDINFO {
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority;
    DWORD                     dwSubAuthority;
    PSID                      pSid;
} MYSIDINFO;

DWORD SetTaskFolderSecurity(LPCWSTR pwszFolderPath);
DWORD AllocateAndInitializeDomainSid(
            PSID        pDomainSid,
            MYSIDINFO * pDomainSidInfo);

#endif // !_CHICAGO_
void DoSetup(void);
void DoLogon(void);
void DoFirstLogon(void);
BOOL IsLogonMessageSupported(void);
void ErrorDialog(UINT ErrorFmtStringID, TCHAR * szRoutine, DWORD ErrorCode);

HINSTANCE ghInstance = NULL;

extern "C" int __cdecl _purecall(void)
{
    return 0;
}


//+----------------------------------------------------------------------------
//
//  Function:   WinMainCRTStartup
//
//  Synopsis:   entry point
//
//-----------------------------------------------------------------------------
#ifdef _CHICAGO_
void
WinMainCRTStartup(void)
#else
void _cdecl
main(int argc, char ** argv)
#endif // _CHICAGO_
{
    //
    // Skip EXE name and find first parameter, if any
    //
    LPTSTR ptszStart;
    LPTSTR szArg1 = _tcstok(ptszStart = GetCommandLine(), ARG_DELIMITERS);
    szArg1 = _tcstok(NULL, ARG_DELIMITERS);
    //
    // Switch based on the first parameter
    //
    if (szArg1 == NULL)
    {
        ;   // Do nothing
#if DBG == 1
        MessageBox(NULL,
                   TEXT("Missing command line arguments"),
                   TEXT("Task Scheduler setup/init"),
                   MB_ICONERROR | MB_OK);
#endif // DBG
    }
    else if (lstrcmpi(szArg1, SCHED_LOGON_SWITCH) == 0)
    {
        DoLogon();
    }
    else if (lstrcmpi(szArg1, SCHED_FIRSTLOGON_SWITCH) == 0)
    {
        DoFirstLogon();
    }
#if defined(_CHICAGO_)
    else if (lstrcmpi(szArg1, SCHED_PRESETUP_SWITCH) == 0)
    {
        DoPreSetup();
    }
    else if (lstrcmpi(szArg1, SCHED_MEMPHIS_SWITCH) == 0)
    {
        DoMemphisSetup();
    }
#endif // defined(_CHICAGO_)
    else if (lstrcmpi(szArg1, SCHED_PREUNSETUP_SWITCH) == 0)
    {
        DoPreUnsetup();
    }
    else if (lstrcmpi(szArg1, SCHED_SETUP_SWITCH) == 0)
    {
        DoSetup();
    }
#if DBG == 1
    else
    {
        MessageBox(NULL,
                   TEXT("Invalid command line"),
                   TEXT("Task Scheduler setup/init"),
                   MB_ICONERROR | MB_OK);
    }
#endif // DBG
}


#if defined(_CHICAGO_)

#define MAX_KEY_LEN     (ARRAY_LEN(REGSTR_PATH_APPPATHS) + MAX_PATH)

//+--------------------------------------------------------------------------
//
//  Function:   GetAppPathInfo
//
//  Synopsis:   Fill [ptszAppPathDefault] with the default value and
//              [ptszAppPathVar] with the Path value in the
//              [ptszFilename] application's key under the APPPATHS regkey.
//
//  Arguments:  [ptszFilename]       - application name
//              [ptszAppPathDefault] - if not NULL, filled with default value
//              [cchDefaultBuf]      - size of [ptszAppPathDefault] buffer
//              [ptszAppPathVar]     - if not NULL, filled with Path value
//              [cchPathVarBuf]      - size of [cchPathVarBuf] buffer
//
//  Modifies:   *[ptszAppPathDefault], *[ptszAppPathVar]
//
//  History:    11-22-1996   DavidMun   Created
//
//  Notes:      Both values are optional on the registry key, so if a
//              requested value isn't found, it is set to "".
//
//---------------------------------------------------------------------------

VOID
GetAppPathInfo(
        LPCTSTR ptszFilename,
        LPTSTR  ptszAppPathDefault,
        ULONG   cchDefaultBuf,
        LPTSTR  ptszAppPathVar,
        ULONG   cchPathVarBuf)
{
    HKEY    hkey = NULL;
    TCHAR   tszAppPathKey[MAX_KEY_LEN];

    //
    // Initialize out vars
    //

    if (ptszAppPathDefault)
    {
        ptszAppPathDefault[0] = TEXT('\0');
    }

    if (ptszAppPathVar)
    {
        ptszAppPathVar[0] = TEXT('\0');
    }

    //
    // Build registry key name for this app
    //

    lstrcpy(tszAppPathKey, REGSTR_PATH_APPPATHS);
    lstrcat(tszAppPathKey, TEXT("\\"));
    lstrcat(tszAppPathKey, ptszFilename);

    do
    {
        LRESULT lr;
        lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          tszAppPathKey,
                          0,
                          KEY_QUERY_VALUE,
                          &hkey);

        if (lr != ERROR_SUCCESS)
        {
            schDebugOut((DEB_ERROR,
                         "GetAppPathInfo: RegOpenKeyEx lr=%u\n",
                         GetLastError()));
            break;
        }

        //
        // If the key could be opened, attempt to read requested values.
        // Both are optional, so ignore errors.
        //

        DWORD cb;
        DWORD dwType;


        if (ptszAppPathDefault)
        {
            cb = cchDefaultBuf * sizeof(TCHAR);
            lr = RegQueryValueEx(hkey,
                                 NULL, // value name
                                 NULL, // reserved
                                 &dwType,
                                 (LPBYTE) ptszAppPathDefault,
                                 &cb);
        }

        if (ptszAppPathVar)
        {
            cb = cchPathVarBuf * sizeof(TCHAR);

            lr = RegQueryValueEx(hkey,
                                 TEXT("Path"),  // value name
                                 NULL,          // reserved
                                 &dwType,
                                 (LPBYTE) ptszAppPathVar,
                                 &cb);
        }
    } while (0);

    if (hkey)
    {
        RegCloseKey(hkey);
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   TerminateLast
//
//  Synopsis:   Find the last occurence of [tch] in [tsz], and overwrite it
//              with a null.
//
//  Arguments:  [tsz] - string to search
//              [tch] - char to search for
//
//  Modifies:   *[tsz]
//
//  History:    1-09-1997   DavidMun   Created
//
//  Notes:      If [tch] is not found, [tsz] is not modified.
//
//---------------------------------------------------------------------------

VOID
TerminateLast(LPTSTR tsz, TCHAR tch)
{
    LPTSTR ptszLast = NULL;
    LPTSTR ptsz;

    for (ptsz = tsz; *ptsz; ptsz = NextChar(ptsz))
    {
        if (*ptsz == tch)
        {
            ptszLast = ptsz;
        }
    }

    if (ptszLast)
    {
        *ptszLast = TEXT('\0');
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   DoMemphisSetup
//
//  Synopsis:   If the app path for SAGE's sysagent.exe exists, replace the
//              sysagent.exe at that location with the one in
//              %windir%\system.
//
//  History:    4-14-1997   DavidMun   Created
//
//  Notes:      This is necessary for Memphis installs because their initial
//              setup runs in 16 bit mode.  Therefore they can't invoke
//              this exe before the ini file runs.  Therefore the inf file
//              for memphis can't use the CustomLDID section.
//
//---------------------------------------------------------------------------

VOID
DoMemphisSetup()
{
    do
    {
        //
        // Initialize source path
        //

        UINT  cchDirSize;
        TCHAR tszNewSysAgent[MAX_PATH + 1];

        cchDirSize = GetSystemDirectory(tszNewSysAgent, MAX_PATH);

        if (!cchDirSize || cchDirSize > MAX_PATH)
        {
            schDebugOut((DEB_ERROR,
                         "DoMemphisSetup: GetSystemDirectory %uL\n",
                         GetLastError()));
            break;
        }
        lstrcat(tszNewSysAgent, TEXT("\\") SYSAGENT_EXE);

        //
        // Initialize destination path to the location of SAGE's sysagent.exe.
        //
        // If SAGE isn't installed on this system, put our sysagent.exe
        // in program files\plus!, since that is created by memphis and is
        // the default location if a user install Plus! over Memphis.
        //

        TCHAR tszDestPath[MAX_PATH+1];

        GetAppPathInfo(SYSAGENT_EXE, tszDestPath, MAX_PATH + 1, NULL, 0);

        if (!*tszDestPath)
        {
            BOOL fOk;

            cchDirSize = GetWindowsDirectory(tszDestPath, MAX_PATH);

            if (!cchDirSize || cchDirSize > MAX_PATH)
            {
                schDebugOut((DEB_ERROR,
                             "DoMemphisSetup: GetWindowsDirectory %uL\n",
                             GetLastError()));
                break;
            }

            fOk = LoadString(ghInstance,
                             IDS_DEFAULT_SYSAGENT_PATH,
                             tszDestPath + 2, // preserve drive letter and colon
                             ARRAY_LEN(tszDestPath) - 2);
            lstrcat(tszDestPath, TEXT("\\") SYSAGENT_EXE);
        }

        //
        // Copy the task scheduler version of sysagent.exe over the sage version
        //

        BOOL fOk = CopyFile(tszNewSysAgent, // pointer to name of an existing file
                            tszDestPath,    // pointer to filename to copy to
                            FALSE);         // don't fail if destination file exists

        //
        // If the old sysagent.exe was successfully copied over with the new
        // sysagent.exe, delete the extra new sysagent.exe in %windir%\system.
        //

        if (fOk)
        {
            DeleteFile(tszNewSysAgent);
        }
    } while (0);

    //
    // Do the rest of the setup, which is common to win95/memphis
    //

    DoSetup();
}




//+----------------------------------------------------------------------------
//
//  Function:   DoPreSetup
//
//  Synopsis:   Makes backups of existing sage binaries, so that they can
//              be restored on uninstall.
//
//-----------------------------------------------------------------------------
VOID
DoPreSetup(void)
{
    TCHAR tszSourceFile[MAX_PATH + 1];
    TCHAR tszDestFile[MAX_PATH + 1];
    UINT  ccSystemDirSize;

    //
    // See if there's an app path entry for sysagent.exe.
    //
    // If not, continue, since the plus pack may never have been installed.
    //
    // If it is found, get the application full path and truncate at the
    // last backslash to make a string with the full path to the
    // application's directory.  Then add a new value with that string.
    //
    // This is necessary so the IExpress inf can create a custom LDID
    // (logical directory ID) pointing to the directory in which sysagent.exe
    // resides.
    //

    TCHAR tszSysagentInstallDir[MAX_PATH+1];
    GetAppPathInfo(SYSAGENT_EXE, tszSysagentInstallDir, MAX_PATH + 1, NULL, 0);

    if (*tszSysagentInstallDir)
    {
        GetShortPathName(tszSysagentInstallDir,
                         tszSysagentInstallDir,
                         MAX_PATH + 1);

        TerminateLast(tszSysagentInstallDir, TEXT('\\'));

        HKEY hkSysAgent;

        LONG lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               REGSTR_PATH_APPPATHS TEXT("\\") SYSAGENT_EXE,
                               0,
                               KEY_SET_VALUE,
                               &hkSysAgent);

        if (lr == ERROR_SUCCESS)
        {
            lr = RegSetValueEx(hkSysAgent,
                               TEXT("InstallDir"),
                               0,
                               REG_SZ,
                               (LPBYTE) tszSysagentInstallDir,
                               (lstrlen(tszSysagentInstallDir) + 1) *
                                  sizeof(TCHAR));

            RegCloseKey(hkSysAgent);

            if (lr != ERROR_SUCCESS)
            {
                schDebugOut((DEB_ERROR,
                             "DoPreSetup: RegSetValueEx error %uL\n",
                             lr));
            }
        }
        else
        {
            schDebugOut((DEB_ERROR,
                         "DoPreSetup: RegOpenKeyEx error %uL\n",
                         lr));
        }
    }

    //
    // Initialize source and destination names
    //

    if (!(ccSystemDirSize = GetSystemDirectory(tszSourceFile, MAX_PATH)) ||
        ccSystemDirSize > MAX_PATH)
    {
        ErrorDialog(IDS_INSTALL_FAILURE,
                    TEXT("GetSystemDirectory"),
                    GetLastError());
        return;
    }

    lstrcat(tszSourceFile, TEXT("\\"));
    lstrcpy(tszDestFile, tszSourceFile);

    //
    // Backup the existing sage.exe and sage.dll by copying & renaming them
    // from the system to the windows dir.  Don't fail if the binaries don't
    // exist, since sage may never have been installed.
    //
    // Also fail quietly if the backup copies already exist.  This keeps us
    // from overwriting saved SAGE binaries if user reinstalls us.
    //

    lstrcpy(&tszSourceFile[ccSystemDirSize + 1], SAGE_EXE);
    lstrcpy(&tszDestFile[ccSystemDirSize + 1], SAVED_SAGE_EXE);
    CopyFile(tszSourceFile, tszDestFile, TRUE);

    lstrcpy(&tszSourceFile[ccSystemDirSize + 1], SAGE_DLL);
    lstrcpy(&tszDestFile[ccSystemDirSize + 1], SAVED_SAGE_DLL);
    CopyFile(tszSourceFile, tszDestFile, TRUE);

    //
    // Back up system agent link
    //

    if (GetOriginalShortcutLocation(tszSourceFile))
    {
        lstrcpy(&tszDestFile[ccSystemDirSize + 1], SAVED_SAGE_LINK);
        CopyFile(tszSourceFile, tszDestFile, TRUE);
    }

    //
    // Backup the sysagent.exe file
    //

    if (*tszSysagentInstallDir)
    {
        lstrcat(tszSysagentInstallDir, TEXT("\\"));
        lstrcpy(tszSourceFile, tszSysagentInstallDir);
        lstrcpy(tszDestFile, tszSysagentInstallDir);

        lstrcat(tszSourceFile, SYSAGENT_EXE);
        lstrcat(tszDestFile, SYSAGENT_BAK);
        CopyFile(tszSourceFile, tszDestFile, TRUE);
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   DoPreUnsetup
//
//  Synopsis:   Restore the System Agent start menu shortcut.
//
//-----------------------------------------------------------------------------
VOID
DoPreUnsetup(void)
{
    UINT    ccSystemDirSize;
    TCHAR   tszSourceFile[MAX_PATH];
    TCHAR   tszDestFile[MAX_PATH];

    //
    // Get the full path to the source file (the backup of the link)
    //

    if (!(ccSystemDirSize = GetSystemDirectory(tszSourceFile, MAX_PATH)) ||
        ccSystemDirSize > MAX_PATH)
    {
        schDebugOut((DEB_ERROR,
                    "DoPreUnsetup: GetSystemDirectory error = %u\n",
                    GetLastError()));
        return;
    }

    tszSourceFile[ccSystemDirSize] = TEXT('\\');
    lstrcpy(&tszSourceFile[ccSystemDirSize + 1], SAVED_SAGE_LINK);

    //
    // Get the full path to the destination file (the original location of the
    // link).
    //

    if (!GetOriginalShortcutLocation(tszDestFile))
    {
        return;
    }

    //
    // Now move the source file to the destination file
    //

    BOOL fOk = MoveFile(tszSourceFile, tszDestFile);

    if (!fOk)
    {
        schDebugOut((DEB_ERROR,
                    "DoPreUnsetup: MoveFile(%s,%s) error = %u\n",
                    tszSourceFile,
                    tszDestFile,
                    GetLastError()));
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   GetOriginalShortcutLocation
//
//  Synopsis:   Fill [tszPath] with the full path to the SAGE shortcut.
//
//  Returns:    TRUE on success, FALSE on failure
//
//  History:    11-06-96   DavidMun   Created
//
//----------------------------------------------------------------------------

BOOL
GetOriginalShortcutLocation(LPTSTR tszPath)
{
    #define LINK_EXT        TEXT(".lnk")
    HRESULT hr;
    LPITEMIDLIST pidl;

    hr = SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &pidl);

    if (FAILED(hr))
    {
        schDebugOut((DEB_ERROR,
                    "GetOriginalShortcutLocation: SHGetSpecialFolderLocation hr=0x%x\n",
                    hr));
        return FALSE;
    }

    BOOL fOk;

    fOk = SHGetPathFromIDList(pidl, tszPath);

    ILFree(pidl);

    if (!fOk)
    {
        schDebugOut((DEB_ERROR,
            "GetOriginalShortcutLocation: SHGetPathFromIDList failed\n"));
        return FALSE;
    }

    lstrcat(tszPath, TEXT("\\"));

    // In English IDS_SAGE_SHORTCUT_GROUP is "Accessories\\System Tools"

    TCHAR tszGroupName[MAX_PATH];

    fOk = LoadString(ghInstance,
                     IDS_SAGE_SHORTCUT_GROUP,
                     tszGroupName,
                     ARRAY_LEN(tszGroupName));

    if (!fOk)
    {
        schDebugOut((DEB_ERROR,
                    "GetOriginalShortcutLocation: LoadString(IDS_SAGE_SHORTCUT_GROUP) error = %u\n",
                    GetLastError()));
        return FALSE;
    }

    lstrcat(tszPath, tszGroupName);

    lstrcat(tszPath, TEXT("\\"));

    TCHAR tszLinkName[MAX_PATH];

    fOk = LoadString(ghInstance,
                     IDS_SAGE_SHORTCUT,
                     tszLinkName,
                     ARRAY_LEN(tszLinkName));

    if (!fOk)
    {
        schDebugOut((DEB_ERROR,
                    "GetOriginalShortcutLocation: LoadString(IDS_SAGE_SHORTCUT) error = %u\n",
                    GetLastError()));
        return FALSE;
    }

    lstrcat(tszPath, tszLinkName);
    lstrcat(tszPath, LINK_EXT);

    return TRUE;
}



#else // NT

//+---------------------------------------------------------------------------
//
//  Function:   DoPreUnsetup
//
//  Synopsis:   Delete the admin tools (common) scheduled tasks link
//
//  History:    11-11-96   DavidMun   Created
//              06-17-98   AnirudhS   Link no longer created, nothing to do.
//
//----------------------------------------------------------------------------

VOID
DoPreUnsetup(void)
{
    ;
}

#endif // defined(_CHICAGO_)

//+----------------------------------------------------------------------------
//
//  Function:   DoSetup
//
//  Synopsis:   Performs the normal setup procedure
//
//-----------------------------------------------------------------------------
void
DoSetup(void)
{
#if !defined(_CHICAGO_)
#define SCHED_SERVICE_DEPENDENCY    L"RpcSs\0"
#define SCC_AT_SVC_KEY L"System\\CurrentControlSet\\Services\\Schedule"
#define TASKS_FOLDER_DEFAULT        L"%SystemRoot%\\Tasks"
#endif // _CHICAGO_


#if defined(_CHICAGO_)
    TCHAR szServiceExePath[MAX_PATH + 1];
#else
    TCHAR szTasksFolder[MAX_PATH + 1] = TEXT("");
#endif // ! _CHICAGO_
    TCHAR tszDisplayName[50];       // "Task Scheduler"
    DWORD dwTmp;
    HKEY  hKey;

    //
    //  Disable hard-error popups.
    //
    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    ghInstance = GetModuleHandle(NULL);

    //
    // Load the service display name.
    //
    int cch = LoadString(ghInstance, IDS_SERVICE_DISPLAY_NAME, tszDisplayName,
                         ARRAY_LEN(tszDisplayName));
    if (!(0 < cch && cch < ARRAY_LEN(tszDisplayName) - 1))
    {
        ErrorDialog(IDS_INSTALL_FAILURE,
                    TEXT("LoadString"),
                    GetLastError());
        return;
    }

#if defined(_CHICAGO_)
    //
    // Compute the path to the service EXE.
    //

    UINT  ccSystemDirSize;

    if (!(ccSystemDirSize = GetSystemDirectory(szServiceExePath, MAX_PATH)))
    {
        ErrorDialog(IDS_INSTALL_FAILURE,
                    TEXT("GetSystemDirectory"),
                    GetLastError());
        return;
    }

    lstrcpy(&szServiceExePath[ccSystemDirSize], TEXT("\\"));
    lstrcpy(&szServiceExePath[ccSystemDirSize + 1], SCHED_SERVICE_EXE);
#endif


    //
    // Create/open the Scheduling Agent key in Software\Microsoft.
    //
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       SM_SA_KEY,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS,
                       NULL,
                       &hKey,
                       &dwTmp) == ERROR_SUCCESS)
    {
        // Set MinutesBeforeIdle to a default value of 15 mins.
        // Ignore return code.
        //
        dwTmp = MINUTES_BEFORE_IDLE_DEFAULT;

        RegSetValueEx(hKey,
                      MINUTESBEFOREIDLE,
                      0,
                      REG_DWORD,
                      (CONST BYTE *)&dwTmp,
                      sizeof(dwTmp));

        // Set MaxLogSizeKB to 32K or 0x7FFF.
        // Ignore return code.
        //
        dwTmp = MAX_LOG_SIZE_DEFAULT;

        RegSetValueEx(hKey,
                      MAXLOGSIZEKB,
                      0,
                      REG_DWORD,
                      (CONST BYTE *)&dwTmp,
                      sizeof(dwTmp));

#if !defined(_CHICAGO_)
        // Read the tasks folder location. The .INF should've set this.
        // If not, default.
        //
        dwTmp = MAX_PATH * sizeof(TCHAR);

        if (RegQueryValueEx(hKey,
                            TASKSFOLDER,
                            NULL,
                            NULL,
                            (LPBYTE)szTasksFolder,
                            &dwTmp) != ERROR_SUCCESS  ||
            szTasksFolder[0] == TEXT('\0'))
        {
            lstrcpy(szTasksFolder, TASKS_FOLDER_DEFAULT);
        }

        // Set FirstBoot to non-zero.
        // Ignore return code.
        //
        dwTmp = 1;

        RegSetValueEx(hKey,
                      FIRSTBOOT,
                      0,
                      REG_DWORD,
                      (CONST BYTE *)&dwTmp,
                      sizeof(dwTmp));

#endif // ! _CHICAGO_

        RegCloseKey(hKey);
    }

#if !defined(_CHICAGO_)
    //
    // Set the right permissions on the job folder.
    // The default permissions allow anyone to delete any job, which we
    // don't want.
    //
    {
        TCHAR szTaskFolderPath[MAX_PATH + 1];
        DWORD cch = ExpandEnvironmentStrings(szTasksFolder,
                                             szTaskFolderPath,
                                             ARRAY_LEN(szTaskFolderPath));
        if (cch == 0 || cch > ARRAY_LEN(szTaskFolderPath))
        {
            //
            // The job folder path is too long.
            //
            ErrorDialog(IDS_INSTALL_FAILURE,
                        TEXT("ExpandEnvironmentStrings"),
                        cch ? ERROR_BUFFER_OVERFLOW : GetLastError());
            return;
        }

        DWORD dwError = SetTaskFolderSecurity(szTaskFolderPath);
        if (dwError != ERROR_SUCCESS)
        {
            ErrorDialog(IDS_INSTALL_FAILURE,
                        TEXT("SetTaskFolderSecurity"),
                        dwError);
            return;
        }
    }
#endif // ! _CHICAGO_


    HINSTANCE hinstMSTask;
#if defined(_CHICAGO_)
    hinstMSTask = LoadLibrary(SCHED_SERVICE_DLL);
#else
    hinstMSTask = LoadLibrary(SCHED_SERVICE_PRE_DLL);

    //
    // If we're being installed as part of DS setup then we're not using
    // iexpress, so dll name is SCHED_SERVICE_DLL.
    //

    if (!hinstMSTask)
    {
        hinstMSTask = LoadLibrary(SCHED_SERVICE_DLL);
    }
#endif // defined(_CHICAGO_)

    if (!hinstMSTask)
    {
        ErrorDialog(IDS_INSTALL_FAILURE,
                    SCHED_SERVICE_DLL,
                    GetLastError());
        return;
    }

#if defined(_CHICAGO_)
    PSTDAPI  pfnConvertLegacyJobsToTasks = (PSTDAPI)
        GetProcAddress(hinstMSTask, CONVERT_SAGE_TASKS_API);
#else
    PVOIDAPI pfnConvertLegacyJobsToTasks = (PVOIDAPI)
        GetProcAddress(hinstMSTask, CONVERT_AT_TASKS_API);
#endif

    PBOOLAPI pfnConditionallyEnableService = (PBOOLAPI)
        GetProcAddress(hinstMSTask, CONDITIONALLY_ENABLE_API);

    if (!pfnConvertLegacyJobsToTasks || !pfnConditionallyEnableService)
    {
        ErrorDialog(IDS_INSTALL_FAILURE,
                    TEXT("GetProcAddress"),
                    GetLastError());
        return;
    }

    pfnConvertLegacyJobsToTasks();

    //
    // ConditionallyEnableService *MUST* be after ConvertSageTasksToJobs
    // or ConvertAtJobsToTasks!
    //

#if defined(_CHICAGO_)

    //
    // If and only if there are jobs to run, enable the service and create
    // the "Run = mstinit.exe /firstlogon" registry entry.
    //
    BOOL fServiceEnabled = pfnConditionallyEnableService();

    if (fServiceEnabled)
    {
        //
        // Start the service, if not already running.
        //

        HWND hwnd = FindWindow(SCHED_SERVICE_NAME, tszDisplayName);

        if (hwnd == NULL)
        {
            //
            // Create a process to open the log.
            //

            STARTUPINFO         si;
            PROCESS_INFORMATION pi;

            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof (STARTUPINFO);

            BOOL fRet = CreateProcess(szServiceExePath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      FALSE,
                                      CREATE_NEW_CONSOLE |
                                        CREATE_NEW_PROCESS_GROUP,
                                      NULL,
                                      NULL,
                                      &si,
                                      &pi);

            if (fRet == 0)
            {
                ErrorDialog(IDS_START_FAILURE,
                            TEXT("CreateProcess"),
                            GetLastError());
                return;
            }
        }
    }
#else  // NT

    //
    // Install the Win32 service.
    //

    SC_HANDLE hSCMgr = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

    if (hSCMgr == NULL)
    {
        //
        // Yow, we're hosed.
        //

        ErrorDialog(IDS_INSTALL_FAILURE,
                    TEXT("OpenSCManager"),
                    GetLastError());
        return;
    }


    //
    // Is the service already installed? If so, change its parameters;
    // otherwise, create it.
    //

    SC_HANDLE hSvc = OpenService(hSCMgr,
                                 SCHED_SERVICE_NAME,
                                 SERVICE_CHANGE_CONFIG);

    if (hSvc == NULL)
    {
        hSvc = CreateService(hSCMgr,
                             SCHED_SERVICE_NAME,
                             tszDisplayName,
                             SERVICE_CHANGE_CONFIG,
                             SERVICE_WIN32_SHARE_PROCESS |
                                SERVICE_INTERACTIVE_PROCESS,
                             SERVICE_AUTO_START,
                             SERVICE_ERROR_NORMAL,
                             SCHED_SERVICE_EXE_PATH,
                             SCHED_SERVICE_GROUP,
                             NULL,
                             SCHED_SERVICE_DEPENDENCY,
                             NULL,
                             NULL);

        if (hSvc == NULL)
        {
            ErrorDialog(IDS_INSTALL_FAILURE,
                        TEXT("CreateService"),
                        GetLastError());
            CloseServiceHandle(hSCMgr);
            return;
        }
    }
    else
    {
        //
        // This path will be followed when we upgrade the At service
        // to the Scheduling Agent.  The service name will remain the
        // same, but the display name will be set to the new display
        // name (the At service had no display name) and the image path
        // will be changed to point to the new exe.
        // (The old binary will be left on disk in order to make it easy
        // to revert to it, in case of compatibility problems.)
        //
        if (!ChangeServiceConfig(
                hSvc,                               // hService
                SERVICE_WIN32_SHARE_PROCESS |
                     SERVICE_INTERACTIVE_PROCESS,   // dwServiceType
                SERVICE_AUTO_START,                 // dwStartType
                SERVICE_ERROR_NORMAL,               // dwErrorControl
                SCHED_SERVICE_EXE_PATH,             // lpBinaryPathName
                SCHED_SERVICE_GROUP,                // lpLoadOrderGroup
                NULL,                               // lpdwTagId
                SCHED_SERVICE_DEPENDENCY,           // lpDependencies
                L".\\LocalSystem",                  // lpServiceStartName
                L"",                                // lpPassword
                tszDisplayName                      // lpDisplayName
                ))
        {
            ErrorDialog(IDS_INSTALL_FAILURE,
                        TEXT("ChangeServiceConfig"),
                        GetLastError());
            CloseServiceHandle(hSvc);
            CloseServiceHandle(hSCMgr);
            return;
        }
    }

    CloseServiceHandle(hSvc);
    CloseServiceHandle(hSCMgr);

    //
    // If and only if there are jobs to run, enable the service and create
    // the "Run = mstinit.exe /firstlogon" registry entry.
    //
    pfnConditionallyEnableService();

#endif // _CHICAGO_
}


//+----------------------------------------------------------------------------
//
//  Function:   DoLogon
//
//  Synopsis:   Sends a message to the service indicating that a user has
//              logged on.
//
//-----------------------------------------------------------------------------
void
DoLogon(void)
{
    //
    // This instance has been invoked by the Run key of the registry to
    // signal the running service that a user has logged on.
    //

#ifdef _CHICAGO_

    schDebugOut((DEB_ITRACE, "Sending user log on message.\n"));

    HWND hwndSvc = FindWindow(SCHED_CLASS, SCHED_TITLE);

    if (hwndSvc == NULL)
    {
        schDebugOut((DEB_ITRACE,
                    "FindWindow: service window not found (%d)\n",
                    GetLastError()));
    }
    else
    {
        PostMessage(hwndSvc, WM_SCHED_WIN9X_USER_LOGON, 0, 0);
    }

#else // NT

    schDebugOut((DEB_ITRACE,
                "Sending user log on notification...........\n"));

    SC_HANDLE hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC == NULL)
    {
        schDebugOut((DEB_ERROR,
                     "DoLogon: OpenSCManager error = %uL\n",
                     GetLastError()));
        return;
    }

    SC_HANDLE hSvc = OpenService(hSC, SCHED_SERVICE_NAME,
                                 SERVICE_USER_DEFINED_CONTROL);
    if (hSvc == NULL)
    {
        schDebugOut((DEB_ERROR,
                     "DoLogon: OpenService(%s) error = %uL\n",
                     SCHED_SERVICE_NAME,
                     GetLastError()));
        CloseServiceHandle(hSC);
        return;
    }

    BOOL fSucceeded;
    const int NOTIFY_RETRIES = 20;
    const DWORD NOTIFY_SLEEP = 4000;

    //
    // Use a retry loop to notify the service. This is done
    // because, if the user logs in quickly, the service may not
    // be started when the shell runs this instance.
    //
    for (int i = 1; ; i++)
    {
        SERVICE_STATUS Status;
        fSucceeded = ControlService(hSvc,
                                    SERVICE_CONTROL_USER_LOGON,
                                    &Status);
        if (fSucceeded)
        {
            break;
        }

        if (i >= NOTIFY_RETRIES)
        {
            SetLastError(0);    // There's no good error code
            break;
        }

        schDebugOut((DEB_ITRACE,
                    "Service notification failed, waiting to "
                    "send it again...\n"));

        Sleep(NOTIFY_SLEEP);

    }

    CloseServiceHandle(hSvc);
    CloseServiceHandle(hSC);

#endif // _CHICAGO_
}


//+----------------------------------------------------------------------------
//
//  Function:   DoFirstLogon
//
//  Synopsis:   Checks whether the shell supports the tray startup notify
//              message.  If it does, simply removes the "Run = " value from
//              the registry, so that this will not run at future logons.
//              If it doesn't, changes the "Run = " value's command line
//              parameter from "/FirstLogon" to "/Logon", and then calls
//              DoLogon.
//
//-----------------------------------------------------------------------------
void
DoFirstLogon(void)
{
    // CODEWORK:  Use winlogon for logon notifies on NT?

    BOOL bLogonMessageSupported = IsLogonMessageSupported();

    HKEY hRunKey;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_RUN,
                     0,
                     KEY_SET_VALUE,
                     &hRunKey) == ERROR_SUCCESS)
    {
        if (bLogonMessageSupported)
        {
            RegDeleteValue(hRunKey, SCH_RUN_VALUE);
        }
        else
        {
            #define NewValue  SCHED_SETUP_APP_NAME TEXT(" ") SCHED_LOGON_SWITCH

            RegSetValueEx(hRunKey,
                          SCH_RUN_VALUE,
                          0,
                          REG_SZ,
                          (CONST BYTE *) (NewValue),
                          sizeof(NewValue));
        }

        RegCloseKey(hRunKey);
    }
    // If RegOpenKeyEx fails, we just have to retry at the next logon.

    if (! bLogonMessageSupported)
    {
        DoLogon();
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   IsLogonMessageSupported
//
//  Synopsis:   Determines whether the currently installed shell version
//              broadcasts the "TaskbarCreated" message.
//
//  Arguments:  None.
//
//  Returns:    TRUE - the logon message is supported.
//              FALSE - it is not supported; or, this cannot be determined.
//
//  Notes:      The "TaskbarCreated" message tells the service that (1) a
//              user has logged on, and (2) it's time to create our tray icon.
//
//----------------------------------------------------------------------------
BOOL
IsLogonMessageSupported()
{
    // CODEWORK  Use GetFileVersionInfo instead, once the version numbers are fixed.
    HINSTANCE hLib = LoadLibrary(TEXT("SHELL32.DLL"));
    if (hLib == NULL)
    {
        return FALSE;
    }

    FARPROC VersionProc = GetProcAddress(hLib, "DllGetVersion");

    FreeLibrary(hLib);

    //
    // Versions of shell32.dll that export DllGetVersion support the logon
    // message.
    //

    return (VersionProc != NULL);
}


//+----------------------------------------------------------------------------
//
//  Function:   ErrorDialog
//
//  Synopsis:   Displays an error message.
//
//-----------------------------------------------------------------------------
void
ErrorDialog(UINT ErrorFmtStringID, TCHAR * szRoutine, DWORD ErrorCode)
{
#define ERROR_BUFFER_SIZE (MAX_PATH * 2)

    TCHAR szErrorFmt[MAX_PATH + 1] = TEXT("");
    TCHAR szError[ERROR_BUFFER_SIZE + 1];
    TCHAR * pszError = szError;

    LoadString(ghInstance, ErrorFmtStringID, szErrorFmt, MAX_PATH);

    if (*szErrorFmt)
    {
        wsprintf(szError, szErrorFmt, szRoutine, ErrorCode);
    }
    else
    {
        //
        // Not a localizable string, but done just in case LoadString
        // should fail for some reason.
        //

        lstrcpy(szErrorFmt,
                TEXT("Error installing Task Scheduler; error = 0x%x"));
        wsprintf(szError, szErrorFmt, ErrorCode);
    }

    MessageBox(NULL, szError, NULL, MB_ICONSTOP | MB_OK);
}


#if !defined(_CHICAGO_)

//+---------------------------------------------------------------------------
//
//  Function:   SetTaskFolderSecurity
//
//  Synopsis:   Grant the following permissions to the task folder:
//
//                  LocalSystem             All Access.
//                  Domain Administrators   All Access.
//                  World                   RWX Access (no permission to delete
//                                          child files).
//
//  Arguments:  [pwszFolderPath] -- Task folder path.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD
SetTaskFolderSecurity(LPCWSTR pwszFolderPath)
{
#define BASE_SID_COUNT      4
#define DOMAIN_SID_COUNT    1
#define TASK_ACE_COUNT      4

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD                Status = ERROR_SUCCESS;
    DWORD                i;

    //
    // Build the SIDs that will go in the security descriptor.
    //

    SID_IDENTIFIER_AUTHORITY NtAuth       = SECURITY_NT_AUTHORITY;
	SID_IDENTIFIER_AUTHORITY CreatorAuth  = SECURITY_CREATOR_SID_AUTHORITY;

    MYSIDINFO rgBaseSidInfo[BASE_SID_COUNT] = {
        { &NtAuth,                          // Local System.
          SECURITY_LOCAL_SYSTEM_RID,
          NULL },
        { &NtAuth,                          // Built in domain.  (Used for
          SECURITY_BUILTIN_DOMAIN_RID,      // domain admins SID.)
          NULL },
        { &NtAuth,                          // Authenticated user.
          SECURITY_AUTHENTICATED_USER_RID,
          NULL },
        { &CreatorAuth,                     // Creator.
          SECURITY_CREATOR_OWNER_RID,
          NULL },
    };

    MYSIDINFO rgDomainSidInfo[DOMAIN_SID_COUNT] = {
        { NULL,                             // Domain administrators.
          DOMAIN_ALIAS_RID_ADMINS,
          NULL }
    };

    //
    // Create the base SIDs.
    //

    for (i = 0; i < BASE_SID_COUNT; i++)
    {
        if (!AllocateAndInitializeSid(rgBaseSidInfo[i].pIdentifierAuthority,
                                      1,
                                      rgBaseSidInfo[i].dwSubAuthority,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &rgBaseSidInfo[i].pSid))
        {
            Status = GetLastError();
            break;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        //
        // Create the domain SIDs.
        //

        for (i = 0; i < DOMAIN_SID_COUNT; i++)
        {
            Status = AllocateAndInitializeDomainSid(rgBaseSidInfo[1].pSid,
                                                    &rgDomainSidInfo[i]);

            if (Status != ERROR_SUCCESS)
            {
                break;
            }
        }
    }

    //
    // Create the security descriptor.
    //

    PACCESS_ALLOWED_ACE rgAce[TASK_ACE_COUNT] = {
        NULL, NULL, NULL                    // Supply this to CreateSD so we
    };                                      // don't have to allocate memory.

    MYACE rgMyAce[TASK_ACE_COUNT] = {
        { FILE_ALL_ACCESS,
          OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
          rgBaseSidInfo[0].pSid },          // Local System
        { FILE_ALL_ACCESS,
          OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
          rgDomainSidInfo[0].pSid },        // Domain admins
        { FILE_GENERIC_READ | FILE_GENERIC_EXECUTE | FILE_WRITE_DATA,
          0,
          rgBaseSidInfo[2].pSid },          // Authenticated user
		{ FILE_ALL_ACCESS,
		  OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE,
          rgBaseSidInfo[3].pSid }           // Creator
    };

    if (Status != ERROR_SUCCESS)
    {
        goto CleanExit;
    }

    if ((pSecurityDescriptor = CreateSecurityDescriptor(TASK_ACE_COUNT,
                                                        rgMyAce,
                                                        rgAce,
                                                        &Status)) == NULL)
    {
        goto CleanExit;
    }

    //
    // Finally, set permissions.
    //

    if (!SetFileSecurity(pwszFolderPath,
                         DACL_SECURITY_INFORMATION,
                         pSecurityDescriptor))
    {
        Status = GetLastError();
        goto CleanExit;
    }

CleanExit:
    for (i = 0; i < BASE_SID_COUNT; i++)
    {
        if (rgBaseSidInfo[i].pSid != NULL)
        {
            FreeSid(rgBaseSidInfo[i].pSid);
        }
    }
    for (i = 0; i < DOMAIN_SID_COUNT; i++)
    {
        LocalFree(rgDomainSidInfo[i].pSid);
    }
    if (pSecurityDescriptor != NULL)
    {
        DeleteSecurityDescriptor(pSecurityDescriptor);
    }

    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   AllocateAndInitializeDomainSid
//
//  Synopsis:
//
//  Arguments:  [pDomainSid]     --
//              [pDomainSidInfo] --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD
AllocateAndInitializeDomainSid(
    PSID        pDomainSid,
    MYSIDINFO * pDomainSidInfo)
{
    UCHAR DomainIdSubAuthorityCount;
    DWORD SidLength;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(GetSidSubAuthorityCount(pDomainSid));
    SidLength = GetSidLengthRequired(DomainIdSubAuthorityCount + 1);

    pDomainSidInfo->pSid = (PSID) LocalAlloc(0, SidLength);

    if (pDomainSidInfo->pSid == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Initialize the new SID to have the same initial value as the
    // domain ID.
    //

    if (!CopySid(SidLength, pDomainSidInfo->pSid, pDomainSid))
    {
        LocalFree(pDomainSidInfo->pSid);
        pDomainSidInfo->pSid = NULL;
        return(GetLastError());
    }

    //
    // Adjust the sub-authority count and add the relative Id unique
    // to the newly allocated SID
    //

    (*(GetSidSubAuthorityCount(pDomainSidInfo->pSid)))++;
    *(GetSidSubAuthority(pDomainSidInfo->pSid,
                         DomainIdSubAuthorityCount)) =
                                            pDomainSidInfo->dwSubAuthority;

    return(ERROR_SUCCESS);
}

#endif // !_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\setup\setupids.h ===
//#ifndef __SETUP_H__
//#define __SETUP_H__

#define IDS_INSTALL_FAILURE         0
#define IDS_START_FAILURE           1
#define IDS_LOGON_NOTICE_ERROR      3
#define IDS_SAGE_SHORTCUT_GROUP     6
#define IDS_SAGE_SHORTCUT           7
#define IDS_DEFAULT_SYSAGENT_PATH   8
#define IDS_SERVICE_DISPLAY_NAME    9

//#endif // __SETUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\desktop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       desktop.cxx
//
//  Contents:   Creation/initialization of the Scheduling Agent windowstation
//              and its desktop, "SAWinSta\SADesktop". This windowstation
//              needs to exist to run tasks when no user is logged on, or the
//              logged on user is different than the task-specific account.
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    26-Jun-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"
#include "security.hxx"

#define SA_WINDOW_STATION L"SAWinSta"
#define SA_DESKTOP        L"SADesktop"

//
// Define all access to windows objects
//
// From windows\gina\winlogon\secutil.c
//

#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | STANDARD_RIGHTS_REQUIRED)

#define WINSTA_ALL  (WINSTA_ENUMDESKTOPS     | WINSTA_READATTRIBUTES    | \
                     WINSTA_ACCESSCLIPBOARD  | WINSTA_CREATEDESKTOP     | \
                     WINSTA_WRITEATTRIBUTES  | WINSTA_ACCESSGLOBALATOMS | \
                     WINSTA_EXITWINDOWS      | WINSTA_ENUMERATE         | \
                     WINSTA_READSCREEN       | \
                     STANDARD_RIGHTS_REQUIRED)

#define WINSTA_ATOMS    (WINSTA_ACCESSGLOBALATOMS | \
                         WINSTA_ACCESSCLIPBOARD )

HDESK                CreateSADesktop(HWINSTA hWinSta);
HWINSTA              CreateSAWindowStation(void);
PSID                 GetProcessSid(void);
BOOL                 InitializeSAWindow(void);
BOOL                 SetSADesktopSecurity(
                                    HDESK   hDesktop,
                                    PSID    pSchedAgentSid,
                                    PSID    pLocalSid);
BOOL                 SetSAWindowStationSecurity(
                                    HWINSTA hWinSta,
                                    PSID    pSchedAgentSid,
                                    PSID    pLocalSid);
void                 UninitializeSAWindow(void);

// Globals used in this module exclusively.
// Initialized in InitializeSAWindow, closed in UnitializeSAWindow.
//
HWINSTA ghSAWinsta  = NULL;     // Handle to window station, "SAWinSta".
HDESK   ghSADesktop = NULL;     // Handle to desktop, "SADesktop"

PSECURITY_DESCRIPTOR psdUserThreadTokenSD = NULL;


//+---------------------------------------------------------------------------
//
//  Function:   InitializeSAWindow
//
//  Synopsis:   Create and set security info on the windowstation\desktop,
//              "SAWinSta\SADesktop". This desktop exists for tasks which
//              run under an account different than the currently logged
//              on user, or when no user is logged on. Note, these tasks will
//              never appear on the interactive desktop.
//
//  Arguments:  None.
//
//  Returns:    TRUE  -- Everything succeeded.
//              FALSE -- Encountered an error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
InitializeSAWindow(void)
{
    BOOL    fRet     = TRUE;
    PSID    pLocalSid;
    PSID    pSchedAgentSid;
    HWINSTA hWinSta  = NULL;
    HDESK   hDesktop = NULL;

    //
    // Retrieve local system and local account SIDs.
    //

    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_LOCAL_SID_AUTHORITY;
    if (!AllocateAndInitializeSid(&SidAuth,
                                  1,
                                  SECURITY_LOCAL_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &pLocalSid))
    {
        schDebugOut((DEB_ERROR,
            "SetSAWindowSecurity, AllocateAndInitializeSid failed, " \
            "status = 0x%lx\n",
        GetLastError()));
        return(FALSE);
    }

    if ((pSchedAgentSid = GetProcessSid()) == NULL)
    {
        fRet = FALSE;
        goto CleanExit;
    }

    //
    // Create the window station & desktop.
    //

    if ((hWinSta = CreateSAWindowStation()) == NULL)
    {
        fRet = FALSE;
        goto CleanExit;
    }

    if (!SetProcessWindowStation(hWinSta))
    {
        schDebugOut((DEB_ERROR,
            "SetSAWindowSecurity, SetProcessWindowStation failed, " \
            "status = 0x%lx\n",
        GetLastError()));
        fRet = FALSE;
        goto CleanExit;
    }

    if ((hDesktop = CreateSADesktop(hWinSta)) == NULL)
    {
        fRet = FALSE;
        goto CleanExit;
    }

    //
    // Set security on the window station & desktop.
    //

    if (!SetSAWindowStationSecurity(hWinSta, pSchedAgentSid, pLocalSid))
    {
        fRet = FALSE;
        goto CleanExit;
    }

    if (!SetSADesktopSecurity(hDesktop, pSchedAgentSid, pLocalSid))
    {
        fRet = FALSE;
        goto CleanExit;
    }

CleanExit:
    if (pLocalSid      != NULL) FreeSid(pLocalSid);
    if (pSchedAgentSid != NULL) LocalFree(pSchedAgentSid);
    if (fRet)
    {
        ghSAWinsta  = hWinSta;
        ghSADesktop = hDesktop;
    }
    else
    {
        if (hWinSta != NULL) CloseHandle(hWinSta);
        if (hDesktop != NULL) CloseHandle(hDesktop);
    }

    return(fRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitializeSAWindow
//
//  Synopsis:   Close the global window station & desktop handles.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
UninitializeSAWindow(void)
{
    if (ghSADesktop != NULL) CloseDesktop(ghSADesktop);
    if (ghSADesktop != NULL) CloseWindowStation(ghSAWinsta);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetProcessSid
//
//  Synopsis:   Obtain the SID of this process.
//
//  Arguments:  None.
//
//  Returns:    This process' sid.
//              NULL on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
PSID
GetProcessSid(void)
{
    PSECURITY_DESCRIPTOR psdProcessSD = NULL;
    PSID                 pProcessSid  = NULL;
    PSID                 pProcessSidTmp;
    DWORD                cbSize;
    HANDLE               hProcess;
    BOOL                 fOwnerDefaulted;

    hProcess = GetCurrentProcess();

    if (hProcess == NULL)
    {
        schDebugOut((DEB_ERROR,
            "GetProcessSid, GetCurrentProcess failed, status = 0x%lx\n",
            GetLastError()));
        return(NULL);
    }

    //
    // Retrieve the buffer size necessary to retrieve this process' SD.
    //

    if (!GetKernelObjectSecurity(hProcess,
                                 OWNER_SECURITY_INFORMATION,
                                 NULL,
                                 0,
                                 &cbSize) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        psdProcessSD = LocalAlloc(LMEM_FIXED, cbSize);

        if (psdProcessSD == NULL)
        {
            schDebugOut((DEB_ERROR,
                "GetProcessSid, process security descriptor allocation " \
                "failure\n"));
            return(NULL);
        }

        //
        // Actually retrieve this process' SD.
        //

        if (!GetKernelObjectSecurity(hProcess,
                                     OWNER_SECURITY_INFORMATION,
                                     psdProcessSD,
                                     cbSize,
                                     &cbSize))
        {
            schDebugOut((DEB_ERROR,
                "GetProcessSid, GetKernelObjectSecurity failed, " \
                "status = 0x%lx\n",
                GetLastError()));
            goto ErrorExit;
        }
    }
    else
    {
        schAssert(0 && "GetKernelObjectSecurity() succeeded!");
        return(NULL);
    }

    //
    // Retrieve the owner SID from the SD.
    //

    if (!GetSecurityDescriptorOwner(psdProcessSD, 
                                    &pProcessSidTmp, 
                                    &fOwnerDefaulted)) 
    {
        schDebugOut((DEB_ERROR,
            "GetProcessSid, GetSecurityDescriptorOwner failed, " \
            "status = 0x%lx\n",
            GetLastError()));
        goto ErrorExit;
    }

    //
    // An unnecessary check, maybe, but safe.
    //

    if (!IsValidSid(pProcessSidTmp))
    {
        schDebugOut((DEB_ERROR,
            "GetProcessSid, IsValidSid failed, status = 0x%lx\n",
            GetLastError()));
        goto ErrorExit;
    }

    //
    // Make a copy of the SID since that returned from GetSecuritySD refers
    // within the security descriptor allocated above.
    //

    cbSize = GetLengthSid(pProcessSidTmp);

    pProcessSid = LocalAlloc(LMEM_FIXED, cbSize);

    if (pProcessSid == NULL)
    {
        schDebugOut((DEB_ERROR,
            "GetProcessSid, process SID allocation failure\n"));
        goto ErrorExit;
    }

    if (!CopySid(cbSize, pProcessSid, pProcessSidTmp))
    {
        LocalFree(pProcessSid);
        pProcessSid = NULL;
        schDebugOut((DEB_ERROR,
            "GetProcessSid, CopySid failed, status = 0x%lx\n",
            GetLastError()));
    }

ErrorExit:
    if (psdProcessSD != NULL) LocalFree(psdProcessSD);

    return(pProcessSid);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateSAWindowStation
//
//  Synopsis:   Create the window station named "SAWinSta".
//
//  Arguments:  None.
//
//  Returns:    Window station handle on success.
//              NULL on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HWINSTA
CreateSAWindowStation(void)
{
    HWINSTA hWinSta;

    if ((hWinSta = CreateWindowStation(SA_WINDOW_STATION,
                                       NULL,
                                       MAXIMUM_ALLOWED,
                                       NULL)) == NULL)
    {
        schDebugOut((DEB_ERROR,
            "CreateSAWindowStation, CreateWindowStation failed, " \
            "status = 0x%lx\n",
            GetLastError()));
        return(NULL);
    }

    return(hWinSta);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateSADesktop 
//
//  Synopsis:   Create the desktop, "SADesktop", on the window station
//              indicated.
//
//  Arguments:  [hWinSta] -- Window station.
//
//  Returns:    Desktop handle on success.
//              NULL on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HDESK
CreateSADesktop(HWINSTA hWinSta)
{
    HDESK hDesktop;

    if ((hDesktop = CreateDesktop(SA_DESKTOP,
                                  NULL,
                                  NULL,
                                  0,
                                  MAXIMUM_ALLOWED,
                                  NULL)) == NULL)
    {
        schDebugOut((DEB_ERROR,
            "CreateSADesktop, CreateDesktop failed, status = 0x%lx\n",
            GetLastError()));
        return(NULL);
    } 

    return(hDesktop);
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSAWindowStationSecurity
//
//  Synopsis:   Set permissions on the scheduling agent window station for
//              this process and the local user.
//
//  Arguments:  [hWinSta]        -- Window station.
//              [pSchedAgentSid] -- Scheduling Agent process SID.
//              [pLocalSid]      -- Local SID.
//
//  Returns:    TRUE  -- Function succeeded,
//              FALSE -- Otherwise.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
SetSAWindowStationSecurity(
    HWINSTA hWinSta,
    PSID    pSchedAgentSid,
    PSID    pLocalSid)
{
#define WS_ACE_COUNT 5

    PACCESS_ALLOWED_ACE rgAce[WS_ACE_COUNT] = {
        NULL, NULL, NULL, NULL, NULL };     // Supply this to CreateSD so we
                                            // don't have to allocate memory.
    MYACE rgMyAce[WS_ACE_COUNT] = { 
        { WINSTA_ALL,                       // Acess mask.
          NO_PROPAGATE_INHERIT_ACE,         // Inherit flags.
          pSchedAgentSid },                 // SID.
        { GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL,
          OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE,
          pSchedAgentSid },
        { WINSTA_ALL & ~(WRITE_DAC | WRITE_OWNER),
          NO_PROPAGATE_INHERIT_ACE,
          pLocalSid },
        { (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)
              & ~(WRITE_DAC | WRITE_OWNER),
          INHERIT_ONLY_ACE,
          pLocalSid },
        { WINSTA_ATOMS,
          NO_PROPAGATE_INHERIT_ACE,
          pLocalSid }
    };

    schAssert(WS_ACE_COUNT == (sizeof(rgAce)/sizeof(PACCESS_ALLOWED_ACE)) &&
              WS_ACE_COUNT == (sizeof(rgMyAce) / sizeof(MYACE)));

    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    SECURITY_INFORMATION si;
    DWORD                Status = 0;

    if ((pSecurityDescriptor = CreateSecurityDescriptor(WS_ACE_COUNT,
                                                        rgMyAce,
                                                        rgAce)) == NULL)
    {
        return(FALSE);
    }

    si = DACL_SECURITY_INFORMATION;
    if (!SetUserObjectSecurity(hWinSta, &si, pSecurityDescriptor))
    {
        Status = GetLastError();
    }

    DeleteSecurityDescriptor(pSecurityDescriptor);

    if (Status)
    {
        schDebugOut((DEB_ERROR,
            "SetSASetWindowStationSecurity, SetUserObjectSecurity failed, " \
            "status = 0x%lx\n",
            Status));
        return(FALSE);
    }    

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSADesktopSecurity
//
//  Synopsis:   Set permissions on the scheduling agent desktop for this
//              process and the local user.
//
//  Arguments:  [hDesktop]       -- Desktop.
//              [pSchedAgentSid] -- Scheduling Agent process SID.
//              [pLocalSid]      -- Local SID.
//
//  Returns:    TRUE  -- Function succeeded,
//              FALSE -- Otherwise.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
SetSADesktopSecurity(
    HDESK   hDesktop,
    PSID    pSchedAgentSid,
    PSID    pLocalSid)
{
#define DT_ACE_COUNT 2

    PACCESS_ALLOWED_ACE rgAce[DT_ACE_COUNT] = {
        NULL, NULL };                       // Supply this to CreateSD so we
                                            // don't have to allocate memory.
    MYACE rgMyAce[DT_ACE_COUNT] = { 
        { DESKTOP_ALL,                      // Acess mask.
          0,                                // Inherit flags.
          pSchedAgentSid },                 // SID.
        { DESKTOP_ALL,
          0,
          pLocalSid }
    };

    schAssert(DT_ACE_COUNT == (sizeof(rgAce)/sizeof(PACCESS_ALLOWED_ACE)) &&
              DT_ACE_COUNT == (sizeof(rgMyAce) / sizeof(MYACE)));

    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    SECURITY_INFORMATION si;
    DWORD                Status = 0;

    if ((pSecurityDescriptor = CreateSecurityDescriptor(DT_ACE_COUNT,
                                                        rgMyAce,
                                                        rgAce)) == NULL)
    {
        return(FALSE);
    }

    si = DACL_SECURITY_INFORMATION;
    if (!SetUserObjectSecurity(hDesktop, &si, pSecurityDescriptor))
    {
        Status = GetLastError();
    }

    DeleteSecurityDescriptor(pSecurityDescriptor);

    if (Status)
    {
        schDebugOut((DEB_ERROR,
            "SetSADesktopSecurity, SetUserObjectSecurity failed, " \
            "status = 0x%lx\n",
            Status));
        return(FALSE);
    }    

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\events.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       events.cxx
//
//  Contents:   Idle and battery event code.
//
//  History:    22-Mar-96 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"
extern "C"
{
#include "msidle.h"
}

#define SCH_NOIDLE_VALUE    TEXT("NoIdle")

BOOL g_fOnBattery;
BOOL g_fIdleInitialized;
HINSTANCE g_hMsidleDll = NULL;

//
// msidle.dll function pointers.
//
_BEGINIDLEDETECTION gpfnBeginIdleDetection;
_ENDIDLEDETECTION   gpfnEndIdleDetection;
_SETIDLETIMEOUT     gpfnSetIdleTimeout;
_SETIDLENOTIFY      gpfnSetIdleNotify;
_SETBUSYNOTIFY      gpfnSetBusyNotify;
_GETIDLEMINUTES     gpfnGetIdleMinutes;


//+----------------------------------------------------------------------------
//
//  Function:   OnIdleNotification
//
//  Synopsis:   Called when the winproc receives idle notifications.
//
//  Arguments:  [wParam] - indicates whether it is for idle start or end.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
void WINAPI
OnIdleNotify(DWORD dwState)
{
    switch (dwState)
    {
    case STATE_USER_IDLE_BEGIN:
        //
        // Received idle notification.
        //
        if (g_pSched != NULL)
        {
            schDebugOut((DEB_ITRACE,
                        "*** OnIdleNotification: entering idle state. ***\n"));
            g_pSched->OnIdleEvent(TRUE);
        }
        break;

    case STATE_USER_IDLE_END:
        //
        // Idle has ended.
        //
        if (g_pSched != NULL)
        {
            schDebugOut((DEB_ITRACE,
                         "*** OnIdleNotification: idle lost. ***\n"));
            g_pSched->OnIdleEvent(FALSE);
        }
        break;

    default:
        schAssert(0);
        break;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   SetNextIdleNotificationFn
//
//  Synopsis:   Set the length of time to wait for the next idle notification.
//
//  Returns:    TRUE for success, and FALSE if unable to make the call.
//
//-----------------------------------------------------------------------------
BOOL
SetNextIdleNotificationFn(WORD wIdleWait)
{
    schDebugOut((DEB_ITRACE, "SetNextIdleNotification(%u)\n", wIdleWait));

    if (!g_fIdleInitialized)
    {
        DBG_OUT("Calling SetNextIdleNotification before idle init!");
        return FALSE;
    }

    //
    // 0xffff is a flag value meaning that no idle notification is needed.
    //
    if (wIdleWait == 0xffff)
    {
        schDebugOut((DEB_IDLE, "Next idle wait is 0xffff, not requesting"
                               " idle notification\n"));
        //
        // msidle.dll makes it impossible to turn off idle notification
        // completely.  SetIdleNotify(FALSE, 0) will do it temporarily,
        // but if we have also registered for a loss-of-idle notification,
        // then as soon as we get that notification, msidle.dll turns idle
        // notification back on automatically.
        // So we also set a long idle wait period.
        // (It doesn't have to be 0xffff, but it might as well be)
        //
        gpfnSetIdleTimeout(0xffff, 0);
        gpfnSetIdleNotify(FALSE, 0);
        return FALSE;
    }

    schAssert(wIdleWait != 0);
    schDebugOut((DEB_IDLE, "Requesting %u-minute idle notification\n",
                           wIdleWait));

    gpfnSetIdleTimeout(wIdleWait, 0);
    gpfnSetIdleNotify(TRUE, 0);

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function:   SetIdleLossNotificationFn
//
//  Synopsis:   Registers for idle loss notification.
//
//  Returns:    TRUE for success, and FALSE if unable to make the call.
//
//-----------------------------------------------------------------------------
BOOL
SetIdleLossNotificationFn()
{
    schDebugOut((DEB_ITRACE, "SetIdleLossNotification()\n"));

    if (!g_fIdleInitialized)
    {
        DBG_OUT("Calling SetIdleLossNotification before idle init!");
        return FALSE;
    }

    schDebugOut((DEB_IDLE, "Requesting idle LOSS notification\n"));
    gpfnSetBusyNotify(TRUE, 0);

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function:   GetTimeIdle
//
//  Synopsis:   Obtains the length of time the machine has been idle.
//
//-----------------------------------------------------------------------------
DWORD
GetTimeIdle(void)
{
    DWORD dwMinutes;

    if (!g_fIdleInitialized)
    {
        DBG_OUT("Calling GetTimeIdle before idle init!");
        dwMinutes = 0;
    }
    else
    {
        dwMinutes = gpfnGetIdleMinutes(0);
    }

    schDebugOut((DEB_IDLE, "User has been idle for %u minutes\n", dwMinutes));

    return dwMinutes;
}


//+----------------------------------------------------------------------------
//
//  Function:   OnPowerChange
//
//  Synopsis:   Called when the machine's battery  state changes.
//
//  Arguments:  [fGoingOnBattery] - set to true if going on battery power,
//                                  false if going back on line power.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
OnPowerChange(BOOL fGoingOnBattery)
{
    schDebugOut((DEB_ITRACE, "OnPowerChange: fGoingOnBattery = %s\n",
                 (fGoingOnBattery) ? "TRUE" : "FALSE"));

    //
    // Check to see if our battery state has changed, or if this is just
    // a battery update
    //
    if (g_fOnBattery != fGoingOnBattery) 
    {
        g_fOnBattery = fGoingOnBattery;
    
        //
        // Signal the main thread to recalculate the next wakeup time, since
        // the calculation depends on whether the machine is on batteries.
        // Do this by simply signaling the wakeup timer.  This will cause a
        // recalc.
        //
        g_pSched->SignalWakeupTimer();
    
        if (fGoingOnBattery)
        {
            //
            // Notify the job processor to kill any jobs with the
            // TASK_FLAG_KILL_IF_GOING_ON_BATTERIES flag set.
            //
            CJobProcessor * pjp;
            for (pjp = gpJobProcessorMgr->GetFirstProcessor(); pjp != NULL; )
            {
                pjp->KillIfFlagSet(TASK_FLAG_KILL_IF_GOING_ON_BATTERIES);
                CJobProcessor * pjpNext = pjp->Next();
                pjp->Release();
                pjp = pjpNext;
            }
        }
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   InitBatteryNotification
//
//  Synopsis:   Initialize the battery event boolean.
//
//  Returns:    hresults
//
//  Notes:      Currently only Win95 supports power management.
//
//-----------------------------------------------------------------------------
HRESULT
InitBatteryNotification(void)
{
    DWORD dwErr;

    //
    // Check current battery state and set bool accordingly.
    //
    SYSTEM_POWER_STATUS PwrStatus;

    if (!GetSystemPowerStatus(&PwrStatus))
    {
        dwErr = GetLastError();

        if (dwErr == ERROR_FILE_NOT_FOUND ||
            dwErr == ERROR_CALL_NOT_IMPLEMENTED)
        {
            g_fOnBattery = FALSE;
            schDebugOut((DEB_ITRACE,
                         "InitBatteryNotification: GetSystemPowerStatus"
                         " returned %u, g_fOnBattery set to FALSE\n",
                         dwErr));
            return S_OK;
        }
        ERR_OUT("GetSystemPowerStatus", HRESULT_FROM_WIN32(dwErr));
        return HRESULT_FROM_WIN32(dwErr);
    }

    g_fOnBattery = (PwrStatus.ACLineStatus == 0) ? TRUE : FALSE;

    schDebugOut((DEB_ITRACE, "InitBatteryNotification: g_fOnBattery = %s\n",
                 (g_fOnBattery) ? "TRUE" : "FALSE"));
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   InitIdleDetection
//
//  Synopsis:   Called after the message window is created to initialize idle
//              detection and hot corners.
//
//  Arguments:
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
InitIdleDetection()
{
    TRACE_FUNCTION(InitIdleDetection);
    DWORD dwErr;

    //
    // Look in the registry to see if idle detection is disabled.
    //
    long lErr;
    HKEY hSchedKey = NULL;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, KEY_READ,
                        &hSchedKey);
    if (lErr == ERROR_SUCCESS)
    {
        TCHAR tszInit[SCH_MED0BUF_LEN + 1];
        DWORD cb = SCH_MED0BUF_LEN * sizeof(TCHAR);

        lErr = RegQueryValueEx(hSchedKey, SCH_NOIDLE_VALUE, NULL, NULL,
                               (LPBYTE)tszInit, &cb);

        RegCloseKey(hSchedKey);

        if (lErr == ERROR_SUCCESS)
        {
            //
            // The presence of the value is sufficient to disable idle
            // detection. g_fIdleInitialized will remain FALSE, resulting
            // in all idle operations being skipped.
            //
            schDebugOut((DEB_ITRACE, "Idle detection is disabled!!!!!!!!\n"));
            return S_OK;
        }
    }

    // load msidle.dll
    if (g_hMsidleDll == NULL) {
    
        g_hMsidleDll = LoadLibrary(TEXT("MSIDLE.DLL"));

        if (g_hMsidleDll == NULL)
        {
            dwErr = GetLastError();
            ERR_OUT("Load of msidle.dll", dwErr);
            return HRESULT_FROM_WIN32(dwErr);
        }
    }

    // get entry points
    gpfnBeginIdleDetection = (_BEGINIDLEDETECTION)
                                GetProcAddress(g_hMsidleDll, (LPSTR)3);
    gpfnEndIdleDetection = (_ENDIDLEDETECTION)
                                GetProcAddress(g_hMsidleDll, (LPSTR)4);
    gpfnSetIdleTimeout = (_SETIDLETIMEOUT)
                                GetProcAddress(g_hMsidleDll, (LPSTR)5);
    gpfnSetIdleNotify = (_SETIDLENOTIFY)
                                GetProcAddress(g_hMsidleDll, (LPSTR)6);
    gpfnSetBusyNotify = (_SETBUSYNOTIFY)
                                GetProcAddress(g_hMsidleDll, (LPSTR)7);
    gpfnGetIdleMinutes = (_GETIDLEMINUTES)
                                GetProcAddress(g_hMsidleDll, (LPSTR)8);

    if (gpfnBeginIdleDetection == NULL ||
        gpfnEndIdleDetection == NULL ||
        gpfnSetIdleTimeout == NULL ||
        gpfnSetIdleNotify == NULL ||
        gpfnSetBusyNotify == NULL ||
        gpfnGetIdleMinutes == NULL)
    {
        dwErr = GetLastError();
        ERR_OUT("Getting msidle.dll entry point addresses", dwErr);
        goto ErrExit;
    }

    // call start monitoring
    dwErr = gpfnBeginIdleDetection(OnIdleNotify, SCH_DEFAULT_IDLE_TIME, 0);
    if (dwErr)
    {
        ERR_OUT("Making initial idle call", dwErr);
        goto ErrExit;
    }

    g_fIdleInitialized = TRUE;

    return S_OK;

ErrExit:

    FreeLibrary(g_hMsidleDll);
    g_hMsidleDll = NULL;
    gpfnBeginIdleDetection = NULL;
    gpfnEndIdleDetection = NULL;
    gpfnSetIdleTimeout = NULL;
    gpfnSetIdleNotify = NULL;
    gpfnSetBusyNotify = NULL;
    gpfnGetIdleMinutes = NULL;

    return HRESULT_FROM_WIN32(dwErr);
}


//+----------------------------------------------------------------------------
//
//  Function:   EndIdleDetection
//
//  Synopsis:   Stop idle detection.
//
//  Arguments:  None.
//
//-----------------------------------------------------------------------------
void
EndIdleDetection()
{
    if (gpfnEndIdleDetection != NULL)
    {
        gpfnEndIdleDetection(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\setup\security.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       security.cxx
//
//  Contents:   Security-related helper functions used by the Task Scheduler
//              setup program to set security on the job folder.
//
//  Classes:    None.
//
//  Functions:
//
//  History:    23-Sep-96  AnirudhS  Copied with minor modifications from
//                  ..\job\security.cxx.
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "..\inc\security.hxx"

#define schDebugOut(x)
#define schAssert(x)

//+---------------------------------------------------------------------------
//
//  Function:   CreateSecurityDescriptor
//
//  Synopsis:   Create a security descriptor with the ACE information
//              specified.
//
//  Arguments:  [AceCount] -- ACE count (no. of rgMyAce and rgAce elements).
//              [rgMyAce]  -- ACE specification array.
//              [rgAce]    -- Caller allocated array of ptrs to ACEs so
//                            this function doesn't have to allocate it.
//
//  Returns:    TRUE  -- Function succeeded,
//              FALSE -- Otherwise.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
PSECURITY_DESCRIPTOR
CreateSecurityDescriptor(
    DWORD               AceCount,
    MYACE               rgMyAce[],
    PACCESS_ALLOWED_ACE rgAce[],
    DWORD *             pStatus)
{
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PACL  pAcl                               = NULL;
    DWORD LengthAces                         = 0;
    DWORD LengthAcl;
    DWORD i;
    DWORD Status;

    for (i = 0; i < AceCount; i++)
    {
        rgAce[i] = CreateAccessAllowedAce(rgMyAce[i].pSid,
                                          rgMyAce[i].AccessMask,
                                          0,
                                          rgMyAce[i].InheritFlags,
                                          &Status);

        if (rgAce[i] == NULL)
        {
            goto ErrorExit;
        }

        LengthAces += rgAce[i]->Header.AceSize;
    }

    //
    // Calculate ACL and SD sizes
    //

    LengthAcl  = sizeof(ACL) + LengthAces;

    //
    // Create the ACL.
    //

    pAcl = (PACL)LocalAlloc(LMEM_FIXED, LengthAcl);

    if (pAcl == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, ACL allocation failed\n"));
        goto ErrorExit;
    }

    if (!InitializeAcl(pAcl, LengthAcl, ACL_REVISION))
    {
        Status = GetLastError();
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, InitializeAcl failed, " \
            "status = 0x%lx\n",
            Status));
        goto ErrorExit;
    }

    for (i = 0; i < AceCount; i++)
    {
        if (!AddAce(pAcl,
                    ACL_REVISION,
                    0,
                    rgAce[i],
                    rgAce[i]->Header.AceSize))
        {
            Status = GetLastError();
            schDebugOut((DEB_ERROR,
                "CreateSecurityDescriptor, AddAce[%l] failed, " \
                "status = 0x%lx\n", i, Status));
            goto ErrorExit;
        }

        LocalFree(rgAce[i]);
        rgAce[i] = NULL;
    }

    //
    // Create the security descriptor.
    //

    pSecurityDescriptor = LocalAlloc(LMEM_FIXED,
                                     SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (pSecurityDescriptor == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, SECURITY_DESCRIPTOR allocation " \
            "failed\n"));
        goto ErrorExit;
    }

    if (!InitializeSecurityDescriptor(pSecurityDescriptor,
                                      SECURITY_DESCRIPTOR_REVISION))
    {
        Status = GetLastError();
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, InitializeSecurityDescriptor " \
            "failed, status = 0x%lx\n",
            Status));
        goto ErrorExit;
    }

    if (!SetSecurityDescriptorDacl(pSecurityDescriptor,
                                   TRUE,
                                   pAcl,
                                   FALSE))
    {
        Status = GetLastError();
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, SetSecurityDescriptorDacl " \
            "failed, status = 0x%lx\n",
            Status));
        goto ErrorExit;
    }

    if (pStatus != NULL) *pStatus = ERROR_SUCCESS;

    return(pSecurityDescriptor);

ErrorExit:
    for (i = 0; i < AceCount; i++)
    {
        if (rgAce[i] != NULL)
        {
            LocalFree(rgAce[i]);
            rgAce[i] = NULL;
        }
    }
    if (pAcl != NULL) LocalFree(pAcl);
    if (pSecurityDescriptor != NULL) LocalFree(pSecurityDescriptor);

    if (pStatus != NULL) *pStatus = Status;

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteSecurityDescriptor
//
//  Synopsis:   Deallocate the security descriptor allocated in
//              CreateSecurityDescriptor.
//
//  Arguments:  [pSecurityDescriptor] -- SD returned from
//                                       CreateSecurityDescriptor.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
DeleteSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    BOOL fPresent;
    BOOL fDefaulted;
    PACL pAcl;

    schAssert(pSecurityDescriptor != NULL);

    if (GetSecurityDescriptorDacl(pSecurityDescriptor,
                                  &fPresent,
                                  &pAcl,
                                  &fDefaulted))
    {
        if (fPresent && pAcl != NULL)
        {
            LocalFree(pAcl);
        }
    }
    else
    {
        schDebugOut((DEB_ERROR,
            "DeleteSecurityDescriptor, GetSecurityDescriptorDacl failed, " \
            "status = 0x%lx\n",
            GetLastError()));
    }

    LocalFree(pSecurityDescriptor);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAccessAllowedAce
//
//  Synopsis:   Scavenged code from winlogon to create an access allowed ACE.
//              Modified a bit to use Win32 vs. Rtl.
//
//  Arguments:  [pSid]         -- Sid to which this ACE is applied.
//              [AccessMask]   -- ACE access mask value.
//              [AceFlags]     -- ACE flags value.
//              [InheritFlags] -- ACE inherit flags value.
//
//  Returns:    Created ACE if successful.
//              NULL on error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
PACCESS_ALLOWED_ACE
CreateAccessAllowedAce(
    PSID        pSid,
    ACCESS_MASK AccessMask,
    UCHAR       AceFlags,
    UCHAR       InheritFlags,
    DWORD *     pStatus)
{
    ULONG   LengthSid = GetLengthSid(pSid);
    ULONG   LengthACE = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + LengthSid;
    PACCESS_ALLOWED_ACE Ace;

    Ace = (PACCESS_ALLOWED_ACE)LocalAlloc(LMEM_FIXED, LengthACE);

    if (Ace == NULL)
    {
        if (pStatus != NULL) *pStatus = ERROR_NOT_ENOUGH_MEMORY;
        schDebugOut((DEB_ERROR,
            "CreateAccessAllowedAce, ACE allocation failed\n"));
        return(NULL);
    }

    Ace->Header.AceType  = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize  = (UCHAR)LengthACE;
    Ace->Header.AceFlags = AceFlags | InheritFlags;
    Ace->Mask            = AccessMask;
    CopySid(LengthSid, (PSID)(&(Ace->SidStart)), pSid);

    if (pStatus != NULL) *pStatus = ERROR_SUCCESS;

    return(Ace);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\atsec.cxx ===
//+---------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:       atsec.cxx
//
//  Contents:   Net Schedule API access checking routines.
//
//  Functions:  AtCheckSecurity
//              AtCreateSecurityObject
//              AtDeleteSecurityObject
//
//  History:    06-Nov-92   vladimv created.
//              30-May-96   EricB adapted for the scheduling agent.
//
//----------------------------------------------------------------------------

//
// Some NT header definitions conflict with some of the standard windows
// definitions. Thus, the project precompiled header can't be used.
//
extern "C" {
#include <nt.h>                 //  NT definitions
#include <ntrtl.h>              //  NT runtime library definitions
#include <nturtl.h>
#include <netevent.h>
}

#include <windef.h>             //  Win32 type definitions
#include <winbase.h>            //  Win32 base API prototypes
#include <winsvc.h>             //  Win32 service control APIs
#include <winreg.h>             //  HKEY

#include <lmcons.h>             //  LAN Manager common definitions
#include <lmerr.h>              //  LAN Manager network error definitions
#include <netlib.h>             //  LAN Man utility routines
#include <netlibnt.h>           //  NetpNtStatusToApiStatus
#include <rpc.h>                //  DataTypes and runtime APIs
#include <rpcutil.h>            //  Prototypes for MIDL user functions
#include <secobj.h>             //  ACE_DATA

#include <..\..\..\smdebug\smdebug.h>
#include <debug.hxx>

#include "atsec.hxx"

//
// Security descriptor to control user access to the AT schedule service
// configuration information.
//
PSECURITY_DESCRIPTOR AtGlobalSecurityDescriptor = NULL;

#define AT_JOB_ALL_ACCESS   (STANDARD_RIGHTS_REQUIRED   |   \
                             AT_JOB_ADD                 |   \
                             AT_JOB_DEL                 |   \
                             AT_JOB_ENUM                |   \
                             AT_JOB_GET_INFO)

//
// Structure that describes the mapping of Generic access rights to
// object specific access rights for the AT schedule service security object.
//
GENERIC_MAPPING     AtGlobalInformationMapping = {

    STANDARD_RIGHTS_READ        |           // Generic read
        AT_JOB_ENUM             |
        AT_JOB_GET_INFO,
    STANDARD_RIGHTS_WRITE       |           // Generic write
        AT_JOB_ADD              |
        AT_JOB_DEL,
    STANDARD_RIGHTS_EXECUTE,                // Generic execute
    AT_JOB_ALL_ACCESS                       // Generic all
};

//+---------------------------------------------------------------------------
//
//  Function:   AtCheckSecurity
//
//  Synopsis:   Verify that the caller has the proper privilege.
//
//  Arguments:  [DesiredAccess] - the type of access.
//
//  Returns:    NERR_Success or reason for failure.
//
//  Notes:      This routine checks if an rpc caller is allowed to perform a
//              given AT service operation. Members of the groups LocalAdmin
//              and LocalBackupOperators are allowed to do all operations and
//              everybody else is not allowed to do anything.
//
//----------------------------------------------------------------------------
NET_API_STATUS
AtCheckSecurity(ACCESS_MASK DesiredAccess)
{
    NTSTATUS        NtStatus;
    NET_API_STATUS  Status;
    HANDLE          ClientToken;
    LPWSTR          StringArray[2];
    WCHAR           ErrorCodeString[25];

    if ((Status = RpcImpersonateClient(NULL)) != NERR_Success)
    {
        ERR_OUT("RpcImpersonateClient", Status);
        return Status;
    }

    NtStatus = NtOpenThreadToken(NtCurrentThread(),
                                 TOKEN_QUERY,
                                 (BOOLEAN)TRUE,
                                 &ClientToken);

    if (NtStatus != STATUS_SUCCESS)
    {
        ERR_OUT("NtOpenThreadToken", NtStatus);
    }
    else
    {
        PRIVILEGE_SET       PrivilegeSet;
        DWORD               PrivilegeSetLength;
        ACCESS_MASK         GrantedAccess;
        NTSTATUS            AccessStatus;

        PrivilegeSetLength = sizeof( PrivilegeSet);

        //  NtAccessCheck() returns STATUS_SUCCESS if parameters
        //  are correct.  Whether or not access is allowed is
        //  governed by the returned value of AccessStatus.

        NtStatus = NtAccessCheck(
                        AtGlobalSecurityDescriptor,     //  SecurityDescriptor
                        ClientToken,                    //  ClientToken
                        DesiredAccess,                  //  DesiredAccess
                        &AtGlobalInformationMapping,    //  GenericMapping
                        &PrivilegeSet,
                        &PrivilegeSetLength,
                        &GrantedAccess,                 //  GrantedAccess
                        &AccessStatus);                 //  AccessStatus

        if (NtStatus != STATUS_SUCCESS)
        {
            ERR_OUT("NtAccessCheck", NtStatus);
        }
        else
        {
            NtStatus = AccessStatus;
        }
        NtClose(ClientToken);
    }

    if ((Status = RpcRevertToSelf()) != NERR_Success)
    {
        ERR_OUT("RpcRevertToSelf", Status);
        return Status;
    }

    return(NetpNtStatusToApiStatus(NtStatus));
}

//+----------------------------------------------------------------------------
//
//  Function:   AtCreateSecurityObject
//
//  Synopsis:   Creates the scheduler user-mode configuration information
//              object which is represented by a security descriptor.
//
//  Returns:    NERR_Success or reason for failure.
//
//-----------------------------------------------------------------------------
NET_API_STATUS
AtCreateSecurityObject(VOID)
{
    DWORD       SubmitControl;
    NTSTATUS    status;
    DWORD       type;
    DWORD       Length;
    HKEY        LsaKey;

    //
    // Server operators are permitted to manage the AT schedule service only if
    // the key exists and the proper flag is set. In all other case we do not
    // permit server operators to manage the AT schedule service.
    //
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          SCH_LSA_REGISTRY_PATH,
                          0L,
                          KEY_READ,
                          &LsaKey);

    if (status != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx(LsaKey)", status);
        return status;
    }

    Length = sizeof(SubmitControl);

    status = RegQueryValueEx(LsaKey,
                             SCH_LSA_SUBMIT_CONTROL,
                             NULL,
                             &type,
                             (LPBYTE)&SubmitControl,
                             &Length);

    RegCloseKey(LsaKey);

    if (status != ERROR_SUCCESS ||
        type != REG_DWORD       ||
        Length != sizeof(SubmitControl))
    {
        DBG_OUT3("SubmitControl reg value not found, "
                 "ServerOps not enabled for AT cmd.");
        SubmitControl = 0;
    }

    status = NetpCreateWellKnownSids(NULL);
    if (!NT_SUCCESS(status))
    {
        ERR_OUT("Failure to create security object", 0);
        return NetpNtStatusToApiStatus(status);
    }

    //
    //  Order matters!  These ACEs are inserted into the DACL in the
    //  following order.  Security access is granted or denied based on
    //  the order of the ACEs in the DACL.
    //
    //  In win3.1 both LocalGroupAdmins and LocalGroupSystemOps were
    //  allowed to perform all Schedule Service operations.  In win3.5
    //  LocalGroupSystemOps may be disallowed (this is the default case).
    //

    ACE_DATA    aceData[] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, GENERIC_ALL, &AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, GENERIC_ALL, &AliasSystemOpsSid}
    };

    status = NetpCreateSecurityObject(
                    aceData,                                    // pAceData
                    (SubmitControl & SCH_SERVER_OPS) ? 2 : 1,   // countAceData
                    NULL,                                       // OwnerSid
                    NULL,                               // PrimaryGroupSid
                    &AtGlobalInformationMapping,
                    &AtGlobalSecurityDescriptor);       // ppNewDescriptor

    if (!NT_SUCCESS(status))
    {
        ERR_OUT("Failure to create security object", 0);
        return NetpNtStatusToApiStatus(status);
    }

    return NERR_Success;
}

//+---------------------------------------------------------------------------
//
//  Function:   AtDeleteSecurityObject
//
//  Synopsis:   Destroys the schedule service user-mode configuration
//              information object.
//
//  Returns:    NERR_Success or reason for failure.
//
//----------------------------------------------------------------------------
void
AtDeleteSecurityObject(VOID)
{
    if (AtGlobalSecurityDescriptor != NULL)
    {
        NetpDeleteSecurityObject(&AtGlobalSecurityDescriptor);
        NetpFreeWellKnownSids();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\getuser.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       getuser.cxx
//
//  Contents:   Get the identity of the logged in user.
//
//  History:    19-Jun-96 EricB created
//
//  Notes:      This is for NT only since Win95 doesn't have security.
//
//-----------------------------------------------------------------------------

//
// Some NT header definitions conflict with some of the standard windows
// definitions. Thus, the project precompiled header can't be used.
//
extern "C" {
#include <nt.h>                 //  NT definitions
#include <ntrtl.h>              //  NT runtime library definitions
#include <nturtl.h>
#include <ntlsa.h>              // BUGBUG 254102
}

#include <windows.h>
#define  SECURITY_WIN32         // needed by security.h
#include <security.h>           // GetUserNameEx

#include <lmcons.h>             // BUGBUG 254102
#include <defines.hxx>          // BUGBUG 254102

#include <..\..\..\smdebug\smdebug.h>
#include <debug.hxx>
#include "globals.hxx"

const int SCH_BIGBUF_LEN = 256;

//
// Registry key/value for default shell.
//
#define SHELL_REGKEY    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SHELL_REGVAL    L"Shell"
#define DEFAULT_SHELL   L"explorer.exe"

// This function is actually declared in proto.hxx. But including proto.hxx
// brings in alot of things we don't need. Just define it here to the includes
// simple.
//
HANDLE ImpersonateUser(HANDLE hUserToken, HANDLE hImpersonationToken);

HANDLE  GetShellProcessHandle(void);
PSYSTEM_PROCESS_INFORMATION GetSystemProcessInfo(void);
PSYSTEM_PROCESS_INFORMATION FindProcessByName(PSYSTEM_PROCESS_INFORMATION,
                                              LPWSTR);
VOID    FreeSystemProcessInfo(PSYSTEM_PROCESS_INFORMATION pProcessInfo);

//+----------------------------------------------------------------------------
//
//  Function:   GetShellProcessHandle
//
//  Synopsis:   Initialize & return the shell handle of the current logged
//              on user, gUserLogonInfo.ShellHandle.
//
//  Returns:    ERROR_SUCCESS or an error code.
//
//  Notes:                      **** Important ****
//
//              Caller must have entered gUserLogonInfo.CriticalSection
//              for the duration of this call and continue to remain in
//              in it for the lifetime use of the returned handle.
//
//              DO NOT close the returned handle. It is a global handle.
//
//-----------------------------------------------------------------------------
HANDLE
GetShellProcessHandle(void)
{
    PSYSTEM_PROCESS_INFORMATION pSystemInfo, pProcessInfo;
    WCHAR    wszShellName[MAX_PATH + 1];
    WCHAR *  pwszShellName = wszShellName;
    WCHAR *  pwsz;
    HKEY     hReg = NULL;
    HANDLE   hProcess = NULL;
    DWORD    dwErr = ERROR_SUCCESS;
    DWORD    dwType;
    DWORD    dwSize;


    //
    // Get the shell process name.  We will look for this
    // to find out who the currently logged-on user is.
    //

    if (gUserLogonInfo.ShellHandle != NULL)
    {
        //
        // Check if the handle is valid.
        //

        if (WaitForSingleObject(gUserLogonInfo.ShellHandle,
                                0) == WAIT_TIMEOUT)
        {
            //
            // Still valid.
            //

            return(gUserLogonInfo.ShellHandle);
        }

        //
        // Re-acquire handle.
        //

        CloseHandle(gUserLogonInfo.ShellHandle);
        gUserLogonInfo.ShellHandle = NULL;
    }

    wcscpy(pwszShellName, DEFAULT_SHELL);

    if ((dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              SHELL_REGKEY,
                              0,
                              KEY_READ,
                              &hReg)) == ERROR_SUCCESS)
    {
        dwSize = sizeof(wszShellName);

        dwErr = RegQueryValueEx(hReg,
                                SHELL_REGVAL,
                                NULL,
                                &dwType,
                                (PBYTE)pwszShellName,
                                &dwSize);
    }

    RegCloseKey(hReg);

    if (dwErr != ERROR_SUCCESS)
    {
        ERR_OUT("GetShellProcessHandle: RegQueryValueEx", dwErr);
        return(NULL);
    }

    //
    // Remove parameters from command line.
    //

    pwsz = pwszShellName;
    while (*pwsz != L' ' && *pwsz != L'\0')
    {
        pwsz++;
    }
    *pwsz = L'\0';

    //
    // Get the process list.
    //

    pSystemInfo = GetSystemProcessInfo();

    if (pSystemInfo == NULL)
    {
        return(NULL);
    }

    //
    // See if wszShell is running.
    //

    pProcessInfo = FindProcessByName(pSystemInfo, pwszShellName);

    if (pProcessInfo != NULL)
    {
        //
        // Open the process.
        //

        hProcess = OpenProcess(PROCESS_ALL_ACCESS,
                               FALSE,
                               HandleToUlong(pProcessInfo->UniqueProcessId));

#if DBG == 1
        if (hProcess == NULL)
        {
            ERR_OUT("GetShellProcessHandle: OpenProcess", GetLastError());
        }
#endif
    }

    //
    // Free resources.
    //
    FreeSystemProcessInfo(pSystemInfo);

    //
    // Return process handle.
    //
    return(gUserLogonInfo.ShellHandle = hProcess);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetShellProcessToken
//
//  Synopsis:
//
//  Returns:    ERROR_SUCCESS or an error code.
//
//  Notes:                      **** Important ****
//
//              Caller must have entered the gcsLogonSessionInfoCritSection
//              critical section for the duration of this call and continue
//              to remain in this critical section for the lifetime use of
//              the returned handle.
//
//              DO NOT close the returned handle. It is a global handle.
//
//-----------------------------------------------------------------------------
HANDLE
GetShellProcessToken(void)
{
    HANDLE hProcess = GetShellProcessHandle();

    if (hProcess == NULL)
    {
        return(NULL);
    }

    HANDLE hToken = gUserLogonInfo.ShellToken;

    if (gUserLogonInfo.ShellToken == NULL)
    {
        if (OpenProcessToken(hProcess,
                             TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                             &hToken))
        {
            return(gUserLogonInfo.ShellToken = hToken);
        }
        else
        {
            ERR_OUT("GetShellProcessToken: OpenProcessToken", GetLastError());
            return(NULL);
        }
    }

    return gUserLogonInfo.ShellToken;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetSystemProcessInfo
//
//  Synopsis:   Return a block containing information about all processes
//              currently running in the system.
//
//  Returns:    A pointer to the system process information or NULL if it could
//              not be allocated or retrieved.
//
//-----------------------------------------------------------------------------
PSYSTEM_PROCESS_INFORMATION
GetSystemProcessInfo(void)
{
#define SYSTEM_PROCESS_BUFFER_INCREMENT 4096

    NTSTATUS Status = 0;
    PUCHAR   pBuffer;
    DWORD    cbBufferSize;

    //
    // Get the process list.
    //

    cbBufferSize = SYSTEM_PROCESS_BUFFER_INCREMENT;

    pBuffer = (PUCHAR)LocalAlloc(LMEM_FIXED, cbBufferSize);

    if (pBuffer == NULL)
    {
        ERR_OUT("GetSystemProcessInfo: LocalAlloc", GetLastError());
        return(NULL);
    }

    for (;;)
    {
        Status = NtQuerySystemInformation(SystemProcessInformation,
                                          pBuffer,
                                          cbBufferSize,
                                          NULL);

        if (Status == STATUS_SUCCESS)
        {
            break;
        }
        else if (Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            cbBufferSize += SYSTEM_PROCESS_BUFFER_INCREMENT;
            pBuffer = (PUCHAR)LocalReAlloc(pBuffer, cbBufferSize, LMEM_MOVEABLE);
            if (pBuffer == NULL)
            {
                ERR_OUT("GetSystemProcessInfo: LocalReAlloc", GetLastError());
                return(NULL);
            }
        }
        else
        {
            break;
        }
    }

    if (Status != STATUS_SUCCESS && pBuffer != NULL)
    {
        LocalFree(pBuffer);
        pBuffer = NULL;
    }

    return (PSYSTEM_PROCESS_INFORMATION)pBuffer;
}

//+----------------------------------------------------------------------------
//
//  Function:   FindProcessByName
//
//  Synopsis:   Given a pointer returned by GetSystemProcessInfo(), find
//              a process by name.
//              Hydra modification: Only processes on the physical console
//              session are included.
//
//  Arguments:  [pProcessInfo] - a pointer returned by GetSystemProcessInfo().
//              [lpExeName]    - a pointer to a Unicode string containing the
//                               process to be found.
//
//  Returns:    A pointer to the process information for the supplied
//              process or NULL if it could not be found.
//
//-----------------------------------------------------------------------------
PSYSTEM_PROCESS_INFORMATION
FindProcessByName(PSYSTEM_PROCESS_INFORMATION pProcessInfo, LPWSTR lpExeName)
{
    PUCHAR pLargeBuffer = (PUCHAR)pProcessInfo;
    ULONG ulTotalOffset = 0;

    //
    // Look in the process list for lpExeName.
    //
    for (;;)
    {
        if (pProcessInfo->ImageName.Buffer != NULL)
        {
            schDebugOut((DEB_USER3, "FindProcessByName: process: %S (%d)\n",
                         pProcessInfo->ImageName.Buffer,
                         pProcessInfo->UniqueProcessId));
            if (!_wcsicmp(pProcessInfo->ImageName.Buffer, lpExeName))
            {
                //
                // Pick this process only if it's
                // running on the physical console session
                //
                DWORD dwSessionId;
                if (! ProcessIdToSessionId(
                            HandleToUlong(pProcessInfo->UniqueProcessId),
                            &dwSessionId))
                {
                    schDebugOut((DEB_ERROR, "ProcessIdToSessionId FAILED, %lu\n",
                                 GetLastError));
                }
                else if (dwSessionId == 0)
                {
                    return pProcessInfo;
                }
            }
        }
        //
        // Increment offset to next process information block.
        //
        if (!pProcessInfo->NextEntryOffset)
        {
            break;
        }
        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }

    schDebugOut((DEB_ITRACE, "FindProcessByName: process %ws not found\n", lpExeName));
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   FreeSystemProcessInfo
//
//  Synopsis:   Free a buffer returned by GetSystemProcessInfo().
//
//  Arguments:  [pProcessInfo] - a pointer returned by GetSystemProcessInfo().
//
//-----------------------------------------------------------------------------
VOID
FreeSystemProcessInfo(PSYSTEM_PROCESS_INFORMATION pProcessInfo)
{
    LocalFree(pProcessInfo);
}

//+----------------------------------------------------------------------------
//
//  Function:   StopImpersonating
//
//  Synopsis:   Stop impersonating.
//
//  Notes:      This code was taken from winlogon. Specifically:
//              windows\gina\winlogon\secutil.c.
//
//-----------------------------------------------------------------------------
BOOL
StopImpersonating(HANDLE ThreadHandle, BOOL fCloseHandle)
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE   ImpersonationToken;

    //
    // Remove the user's token from our thread so we are 'ourself' again
    //

    ImpersonationToken = NULL;

    Status = NtSetInformationThread(ThreadHandle,
                                    ThreadImpersonationToken,
                                    (PVOID)&ImpersonationToken,
                                    sizeof(ImpersonationToken));

    //
    // We're finished with the thread handle
    //

    if (fCloseHandle)
    {
        IgnoreStatus = NtClose(ThreadHandle);
        schAssert(NT_SUCCESS(IgnoreStatus));
    }

    if (!NT_SUCCESS(Status))
    {
        schDebugOut((DEB_ERROR,
            "Failed to remove user impersonation token from SA service, " \
            "status = 0x%lx", Status));
    }

    return(NT_SUCCESS(Status));
}

//+----------------------------------------------------------------------------
//
//  Function:   ImpersonateLoggedInUser
//
//  Synopsis:   Impersonate the shell user.
//
//  Returns:
//
//  Notes:                      **** Important ****
//
//              Caller must have entered the gcsLogonSessionInfoCritSection
//              critical section for the duration of this call.
//
//-----------------------------------------------------------------------------
HANDLE
ImpersonateLoggedInUser(void)
{
    BOOL fDuplicateToken;

    //
    // Open the impersonation token for the
    // process we want to impersonate.
    //
    if (gUserLogonInfo.ImpersonationThread == NULL)
    {
        if (gUserLogonInfo.ShellHandle == NULL)
        {
            if (GetShellProcessHandle() == NULL)
            {
                return(NULL);
            }
        }

        if (gUserLogonInfo.ShellToken == NULL)
        {
            if (GetShellProcessToken() == NULL)
            {
                return(NULL);
            }
        }
    }

    return(gUserLogonInfo.ImpersonationThread = ImpersonateUser(
                                gUserLogonInfo.ShellToken,
                                gUserLogonInfo.ImpersonationThread));
}



//+----------------------------------------------------------------------------
//
//  Function:   ImpersonateUser
//
//  Synopsis:   Impersonate the user associated with the token.
//
//  Arguments:  [hUserToken] - Handle to the token to be impersonated.
//              [ThreadHandle] - Handle to the thread that is to impersonate
//                  hUserToken.  If this is NULL, the function opens a handle
//                  to the current thread.
//
//  Returns:    Handle to the thread that is impersonating hUserToken.
//
//  Notes:      BUGBUG : This code was taken from RAS. It is quite different
//                       than that in winlogon
//                       (windows\gina\winlogon\secutil.c).
//
//-----------------------------------------------------------------------------
HANDLE
ImpersonateUser(HANDLE hUserToken, HANDLE ThreadHandle)
{
    NTSTATUS                    Status;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    HANDLE                      ImpersonationToken;
    BOOL                        ThreadHandleOpened = FALSE;

    if (ThreadHandle == NULL)
    {
        //
        // Get a handle to the current thread.
        // Once we have this handle, we can set the user's impersonation
        // token into the thread and remove it later even though we ARE
        // the user for the removal operation. This is because the handle
        // contains the access rights - the access is not re-evaluated
        // at token removal time.
        //

        Status = NtDuplicateObject( NtCurrentProcess(),     // Source process
                                    NtCurrentThread(),      // Source handle
                                    NtCurrentProcess(),     // Target process
                                    &ThreadHandle,          // Target handle
                                    THREAD_SET_THREAD_TOKEN,// Access
                                    0L,                     // Attributes
                                    DUPLICATE_SAME_ATTRIBUTES);

        if (!NT_SUCCESS(Status))
        {
            ERR_OUT("ImpersonateUser: NtDuplicateObject", Status);
            return(NULL);
        }

        ThreadHandleOpened = TRUE;
    }

    //
    // If the usertoken is NULL, there's nothing to do
    //

    if (hUserToken != NULL)
    {
        //
        // hUserToken is a primary token - create an impersonation token
        // version of it so we can set it on our thread
        //

        InitializeObjectAttributes(&ObjectAttributes,
                                   NULL,
                                   0L,
                                   NULL,
//                                 UserProcessData->NewThreadTokenSD);
                                   NULL);

        SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode =
                                                    SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

        Status = NtDuplicateToken(hUserToken,
                                  TOKEN_IMPERSONATE | TOKEN_READ,
                                  &ObjectAttributes,
                                  FALSE,
                                  TokenImpersonation,
                                  &ImpersonationToken);

        if (!NT_SUCCESS(Status))
        {
            ERR_OUT("ImpersonateUser: NtDuplicateToken", Status);

            if (ThreadHandleOpened)
            {
                NtClose(ThreadHandle);
            }

            return(NULL);
        }

        //
        // Set the impersonation token on this thread so we 'are' the user
        //

        Status = NtSetInformationThread(ThreadHandle,
                                        ThreadImpersonationToken,
                                        (PVOID)&ImpersonationToken,
                                        sizeof(ImpersonationToken));

        //
        // We're finished with our handle to the impersonation token
        //

        NtClose(ImpersonationToken);

        //
        // Check we set the token on our thread ok
        //

        if (!NT_SUCCESS(Status))
        {
            ERR_OUT("ImpersonateUser: NTSetInformationThread", Status);

            if (ThreadHandleOpened)
            {
                NtClose(ThreadHandle);
            }

            return(NULL);
        }

    }


    return(ThreadHandle);
}

//+----------------------------------------------------------------------------
//
//  Function:   LogonSessionDataCleanup
//
//  Synopsis:   Close all open handles and free memory.
//
//  Notes:                      **** Important ****
//
//              No need to enter gcsLogonSessionInfoCritSection prior to
//              calling this function since it is entered here.
//
//-----------------------------------------------------------------------------
void
LogonSessionDataCleanup(void)
{
    EnterCriticalSection(gUserLogonInfo.CritSection);

    if (gUserLogonInfo.ImpersonationThread != NULL)
    {
        CloseHandle(gUserLogonInfo.ImpersonationThread);
        gUserLogonInfo.ImpersonationThread = NULL;
    }
    if (gUserLogonInfo.ShellHandle != NULL)
    {
        CloseHandle(gUserLogonInfo.ShellHandle);
        gUserLogonInfo.ShellHandle = NULL;
    }
    if (gUserLogonInfo.ShellToken != NULL)
    {
        CloseHandle(gUserLogonInfo.ShellToken);
        gUserLogonInfo.ShellToken = NULL;
    }
    if (gUserLogonInfo.DomainUserName != NULL)
    {
        delete gUserLogonInfo.DomainUserName;
        gUserLogonInfo.DomainUserName= NULL;
    }
    memset(gUserLogonInfo.Sid, 0, sizeof(gUserLogonInfo.Sid));

    LeaveCriticalSection(gUserLogonInfo.CritSection);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetLoggedOnUser
//
//  Synopsis:   Called when a user logs in.
//
//  Returns:    None.  Sets the global gUserLogonInfo.
//
//  Notes:                      **** Important ****
//
//              Caller must have entered the gcsLogonSessionInfoCritSection
//              critical section for the duration of this call and continue
//              to remain in this critical section for the lifetime use of
//              the returned string.
//
//              DO NOT attempt to dealloc the returned string! It is a
//              pointer to global memory.
//
//-----------------------------------------------------------------------------
void
GetLoggedOnUser(void)
{
    LPWSTR pwszLoggedOnUser;
    DWORD  cchName = 0;
    DWORD dwErr = ERROR_SUCCESS;

    if (gUserLogonInfo.DomainUserName != NULL)
    {
        //
        // Already done.
        //
        return;
    }

    //
    // Impersonate the logged in user.
    //
    if (ImpersonateLoggedInUser())
    {
        //
        // Get the size of the user name string.
        //
        if (!GetUserNameEx(NameSamCompatible, NULL, &cchName))
        {
            dwErr = GetLastError();
            if (dwErr != ERROR_MORE_DATA || cchName == 0)
            {
                StopImpersonating(gUserLogonInfo.ImpersonationThread, TRUE);
                ERR_OUT("GetLoggedOnUser: GetUserName", dwErr);
                return;
            }
        }
        cchName++;  // contrary to docs, cchName excludes the null

        //
        // Allocate the user name string buffer and get the user name.
        //
        pwszLoggedOnUser = new WCHAR[cchName * 2];

        if (pwszLoggedOnUser != NULL)
        {
            if (!GetUserNameEx(NameSamCompatible, pwszLoggedOnUser, &cchName))
            {
                dwErr = GetLastError();
                ERR_OUT("GetLoggedOnUser: GetUserName", dwErr);
                delete pwszLoggedOnUser;
            }
            else
            {
                schDebugOut((DEB_ITRACE, "GetLoggedOnUser: got '%S'\n",
                             pwszLoggedOnUser));
                cchName++;  // contrary to docs, cchName excludes the null

                //
                // This name is in the format "domain\\user".
                // Make a copy of the domain name right after it, so
                // we end up with a single buffer in the format
                // "domain\\user\0domain".  Set up pointers into this
                // buffer for all 3 parts of the name:
                //      domain
                //      user
                //      domain\user
                //
                gUserLogonInfo.DomainUserName = pwszLoggedOnUser;

                WCHAR *pSlash = wcschr(pwszLoggedOnUser, L'\\');
                schAssert(pSlash != NULL);
                gUserLogonInfo.UserName = pSlash + 1;

                DWORD cchDomain = (DWORD) (pSlash - pwszLoggedOnUser);
                gUserLogonInfo.DomainName = pwszLoggedOnUser + cchName;

                wcsncpy(gUserLogonInfo.DomainName, pwszLoggedOnUser, cchDomain);
                gUserLogonInfo.DomainName[cchDomain] = L'\0';

                schDebugOut((DEB_ITRACE, "GetLoggedOnUser: domain '%S', user '%S'\n",
                             gUserLogonInfo.DomainName, gUserLogonInfo.UserName));
            }
        }
        else
        {
            ERR_OUT("GetLoggedOnUser", ERROR_OUTOFMEMORY);
        }


        //
        // BUGBUG 254102 - Cache the logged-on user's SID, since
        // LookupAccountName doesn't do it when offline.
        // Remove this code when bug 254102 is fixed.
        //
#define USER_TOKEN_STACK_BUFFER_SIZE    \
        (sizeof(TOKEN_USER) + sizeof(SID_AND_ATTRIBUTES) + MAX_SID_SIZE)

        BYTE         rgbTokenInformation[USER_TOKEN_STACK_BUFFER_SIZE];
        TOKEN_USER * pTokenUser = (TOKEN_USER *)rgbTokenInformation;
        DWORD        cbReturnLength;

        if (!GetTokenInformation(gUserLogonInfo.ShellToken,
                                 TokenUser,
                                 pTokenUser,
                                 USER_TOKEN_STACK_BUFFER_SIZE,
                                 &cbReturnLength))
        {
            schAssert(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            memset(gUserLogonInfo.Sid, 0, sizeof(gUserLogonInfo.Sid));
        }
        else if (!CopySid(sizeof(gUserLogonInfo.Sid),
                          gUserLogonInfo.Sid,
                          pTokenUser->User.Sid))
        {
            schAssert(!"CopySid failed");
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            memset(gUserLogonInfo.Sid, 0, sizeof(gUserLogonInfo.Sid));
        }


        StopImpersonating(gUserLogonInfo.ImpersonationThread, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\globals.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       globals.cxx
//
//  Contents:   Service global data.
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    6-Apr-95    MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "svc_core.hxx"
#include "globals.hxx"

//
// The service worker instance.
//

CSchedWorker * g_pSched = NULL;

//
// Job processor manager.
//

CJobProcessorMgr * gpJobProcessorMgr = NULL;

//
// Worker thread manager.
//

CWorkerThreadMgr * gpThreadMgr = NULL;

#if !defined(_CHICAGO_)

//
// Service scavenger task.
//

CSAScavengerTask * gpSAScavengerTask = NULL;

//
// Used for NetScheduleX thread serialization.
//

CRITICAL_SECTION    gcsNetScheduleCritSection;

//
// Event Source for NetSchedule Job logging
//

HANDLE g_hAtEventSource = NULL;

//
// Global data associated with the locally logged on user.
//

CRITICAL_SECTION    gcsUserLogonInfoCritSection;
GlobalUserLogonInfo gUserLogonInfo = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &gcsUserLogonInfoCritSection,
    0
};

#endif  // !defined(_CHICAGO_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\jqueue.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       jqueue.cxx
//
//  Contents:   CJobQueue class implementation.
//
//  Classes:    CJobQueue
//
//  Functions:  None.
//
//  History:    25-Oct-95   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CJobQueue::~CJobQueue
//
//  Synopsis:   Destructor. Destruct job info queue.
//
//  Arguments:  N/A
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CJobQueue::~CJobQueue()
{
    TRACE3(CJobQueue, ~CJobQueue);

    CRun * pRun, * pRunNext;

    pRun = (CRun *)CQueue::RemoveElement();
//    pRun = (CRun *)CQueue::GetFirstElement();

    while (pRun != NULL)
    {
        pRunNext = (CRun *)CQueue::RemoveElement();
//        pRunNext = pRun->Next();
        delete pRun;
        pRun = pRunNext;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobQueue::FindJob
//
//  Synopsis:   Find the job with matching handle in the job queue.
//
//  Arguments:  [hJob] -- Job handle.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CRun *
CJobQueue::FindJob(HANDLE hJob)
{
    schDebugOut((DEB_USER3,
        "CJobQueue::FindJob(0x%x) hJob(0x%x)\n"));

    CRun * pRun = (CRun *)CQueue::GetFirstElement();

    while (pRun != NULL)
    {
        if (pRun->GetHandle() == hJob)
        {
            schDebugOut((DEB_USER3,
                "CJobQueue::FindJob(0x%x) hJob(0x%x) Found it\n"));

            return(pRun);
        }
        pRun = pRun->Next();
    }

    schDebugOut((DEB_USER3,
        "CJobQueue::FindJob(0x%x) hJob(0x%x) Not found\n"));

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\jpmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       jpmgr.cxx
//
//  Contents:   CJobProcessorMgr class implementation.
//
//  Classes:    CJobProcessorMgr
//
//  Functions:  None.
//
//  History:    25-Oct-95   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"

// class CJobProcessorQueue
//

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessorQueue::~CJobProcessorQueue
//
//  Synopsis:   Destructor. Destruct job processor queue.
//
//  Arguments:  N/A
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CJobProcessorQueue::~CJobProcessorQueue()
{
    TRACE3(CJobProcessorQueue, ~CJobProcessorQueue);

    CJobProcessor * pjp;

    while ((pjp = (CJobProcessor *)CQueue::RemoveElement()) != NULL)
    {
        pjp->Release();
    }
}

// class CJobProcessorMgr
//

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessorMgr::NewProcessor
//
//  Synopsis:   Create a new job processor object and add it to the queue.
//
//  Arguments:  None.
//
//  Returns:    S_OK    -- Processor created successfully.
//              S_FALSE -- Service shutting down - ignore the request.
//              HRESULT -- On error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CJobProcessorMgr::NewProcessor(CJobProcessor ** ppjp)
{
    TRACE3(CJobProcessorMgr, NewProcessor);

    CJobProcessor * pjp = new CJobProcessor;

    if (pjp == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }

    HRESULT hr = pjp->Initialize();

    if (FAILED(hr))
    {
        delete pjp;
        CHECK_HRESULT(hr);
        return(hr);
    }

    //
    // Check if the service is shutting down.
    //

    if (IsServiceStopping())
    {
        //
        // Shutdown & release the new processor. With a successful call to
        // CJobProcessor::Initialize(), another thread now references pjp.
        // Shutdown instructs the thread to stop servicing the processor.
        //
        // NB : DO NOT delete pjp! The worker thread maintains a reference
        //      until it has completed servicing it.
        //

        pjp->Shutdown();
        pjp->Release();
        return(S_FALSE);
    }

    EnterCriticalSection(&_csProcessorMgrCritSection);

    _JobProcessorQueue.AddElement(pjp);

    pjp->AddRef();      // For return below.

    LeaveCriticalSection(&_csProcessorMgrCritSection);

    *ppjp = pjp;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessorMgr::GarbageCollection
//
//  Synopsis:   Dequeue and release unused job processor objects. This member
//              is to be called occasionally by an idle thread to clean up the
//              queue. Idle worker threads which have expired call this member
//              upon termination, for example. 
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessorMgr::GarbageCollection(void)
{
    TRACE3(CJobProcessorMgr, GarbageCollection);

    CJobProcessor * pjp;

    EnterCriticalSection(&_csProcessorMgrCritSection);

    //
    // Evaluate all processors in the queue.
    //

    pjp = _JobProcessorQueue.GetFirstElement();

    while (pjp != NULL)
    {
        //
        // If a processor is idle and unreferenced, dequeue & release it.
        //
        // NB : CJobProcessor::Next() re-enters the critical section entered
        //      above. This is OK, though, since the nesting occurs within
        //      the same thread.
        //      Also, the processor object will be AddRef()'d as a result of
        //      Next(). The release logic undoes this.
        //

        CJobProcessor * pjpNext = pjp->Next();

        if (pjpNext != NULL)
        {
            pjpNext->Release();     // See note above.
        }

        if (pjp->IsIdle())
        {
            _JobProcessorQueue.RemoveElement(pjp);
            pjp->Release();
        }

        pjp = pjpNext;
    }

    LeaveCriticalSection(&_csProcessorMgrCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessorMgr::GetFirstProcessor
//
//  Synopsis:   Return the first processor in the queue. This enables the
//              caller to enumerate the queue.
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CJobProcessor *
CJobProcessorMgr::GetFirstProcessor(void)
{
    TRACE3(CJobProcessorMgr, GetFirstProcessor);

    CJobProcessor * pjp;

    EnterCriticalSection(&_csProcessorMgrCritSection);

    pjp = _JobProcessorQueue.GetFirstElement();

    if (pjp != NULL)
    {
        pjp->AddRef();
    }

    LeaveCriticalSection(&_csProcessorMgrCritSection);

    return(pjp);
}


//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessorMgr::Shutdown
//
//  Synopsis:   Shutdown & release all processors.
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessorMgr::Shutdown(void)
{
    TRACE3(CJobProcessorMgr, Shutdown);

    CJobProcessor * pjp;

    EnterCriticalSection(&_csProcessorMgrCritSection);

    while ((pjp = _JobProcessorQueue.RemoveElement()) != NULL)
    {
        pjp->Shutdown();
        pjp->Release();
    }

    LeaveCriticalSection(&_csProcessorMgrCritSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\job.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       job.cxx
//
//  Contents:   Stubs for the Job handler methods that are not in job.lib.
//
//  Notes:      This module allows job.lib to be statically linked into
//              mstask.exe. job.lib is built in sched\job and is linked to
//              both mstask.dll and mstask.exe. The *real* code resides in
//              sched\client\job.cxx.
//
//              BUGBUG : We *must* split CJob et al interface(s) into two
//                       classes: a small core base class, and an OLE
//                       supporting subclass. This would be a *significant*
//                       code savings in the service .exe.  For example,
//                       we would not need the E_NOTIMPL stub functions in 
//                       this file, or the CJob::Save implementation.
//
//  History:    14-Nov-95 EricB  created
//              06-Jun-96 MarkBl Renamed from juistubs.cxx and added
//                               Get/SetAccountInformation.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "svc_core.hxx"

// ref count global (not actually used since the service is an exe not a dll)
// UINT g_cDllRefs;

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::EditWorkItem
//
//  Synopsis:   Stub. Actual code in sched\client\jobedit.cxx and compiled
//              into mstask.dll.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::EditWorkItem(HWND hParent, DWORD dwReserved)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IProvideTaskPage::GetPage
//
//  Synopsis:   Stub. Actual code in sched\client\job.cxx and compiled
//              into job.dll.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetPage(
    TASKPAGE            tpType,
    BOOL                fPersistChanges,
    HPROPSHEETPAGE    * phPage)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetAccountInformation
//
//  Synopsis:   Stub. Actual code in sched\client\job.cxx and compiled
//              into mstask.dll. This is necessary, as otherwise, it would
//              be necessary to include the client rpc code into the service!
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetAccountInformation(
    LPCWSTR pwszAccountName,
    LPCWSTR pwszPassword)
{
    return(E_NOTIMPL);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetAccountInformation
//
//  Synopsis:   Stub. Actual code in sched\client\job.cxx and compiled
//              into mstask.dll. This is necessary, as otherwise, it would
//              be necessary to include the client rpc code into the service!
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetAccountInformation(
    LPWSTR * ppwszAccountName)
{
    return(E_NOTIMPL);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::Save
//
//  Synopsis:   saves the object to storage
//
//  Arguments:  [pwszFileName] - if null, save to the previously loaded file.
//              [fRemember]    - if TRUE, the object becomes associated with
//                               the new filename.
//
//  Notes:      Sigh... New security code in IPersistFile::Save. The security
//              code is client-only; the service doesn't need it. This is
//              Save() sans security. As mentioned, if the split wasn't made,
//              we'd have to include the client rpc code into the service.
//
//              All OLE32 strings are UNICODE, including the filename passed
//              in the IPersistFile methods. On Win9x, all file names must
//              be in ANSI strings, thus the conversion and call to SaveP.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::Save(
    LPCOLESTR pwszFileName,
    BOOL fRemember)
{
    HRESULT hr;

#if defined(UNICODE)

    //
    // Always do a full save.  Never alter the running instance count from the
    // COM interface method.
    //

    hr = SaveP(pwszFileName, fRemember, SAVEP_VARIABLE_LENGTH_DATA);

#else

    CHAR szFileName[MAX_PATH + 1];

    if (pwszFileName != NULL)   // If filename non-null, convert to ANSI
    {
        hr = UnicodeToAnsi(szFileName, pwszFileName, ARRAY_LEN(szFileName));
        if (FAILED(hr))
        {
            return STG_E_INVALIDPARAMETER;
        }
    }

    hr = SaveP(pwszFileName != NULL ? szFileName : NULL,
               fRemember,
               SAVEP_VARIABLE_LENGTH_DATA);

#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\msidle.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       msidle.h
//
//  Contents:   Types and prototypes for idle detection callback dll
//
//  Classes:
//
//  Functions:
//
//  History:    05-26-1997  darrenmi (Darren Mitchell) Created
//              07-11-1997  anirudhs Temporarily added to NT admin project,
//                  BUGBUG  NEEDS TO BE REMOVED when Darren checks in for NT
//
//----------------------------------------------------------------------------

//
// Idle callback type
//
typedef void (WINAPI* _IDLECALLBACK) (DWORD dwState);

#define STATE_USER_IDLE_BEGIN       1
#define STATE_USER_IDLE_END         2

//
// BeginIdleDetection - start monitoring idleness
//
// pfnCallback - function to call back when idle state changes
// dwIdleMin - minutes of inactivity before idle callback
// dwReserved - must be 0
//
// Returns: 0 on success, error code on failure
//
// Note: Exported as ordinal 3
//
DWORD BeginIdleDetection(_IDLECALLBACK pfnCallback, DWORD dwIdleMin, DWORD dwReserved);

typedef DWORD (WINAPI* _BEGINIDLEDETECTION) (_IDLECALLBACK, DWORD, DWORD);

//
// EndIdleDetection - stop monitoring idleness
//
// Returns: TRUE on success, FALSE on failure
//
// Note: Exported as ordinal 4
//
BOOL EndIdleDetection(DWORD dwReserved);

typedef BOOL (WINAPI* _ENDIDLEDETECTION) (DWORD);

//
// SetIdleTimeout - Set minutes for idle timeout and reset idle state
//
// dwMinutes - new minutes threshold for idleness
// fResetState - flag to return to non-idle state to retrigger idle callback
// dwReserved - must be 0
//
// Note: Exported as ordinal 5
//
BOOL SetIdleTimeout(DWORD dwMinutes, DWORD dwReserved);

typedef BOOL (WINAPI* _SETIDLETIMEOUT) (DWORD, DWORD);

//
// SetIdleNotify - Turns on or off notification when idle
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 6
//
void SetIdleNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETIDLENOTIFY) (BOOL, DWORD);

//
// SetBusyNotify - Turns on or off notification when busy
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 7
//
void SetBusyNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETBUSYNOTIFY) (BOOL, DWORD);

//
// GetIdleMinutes
//
// dwReserved - must be 0
//
// Returns number of minutes since user's last activity
//
// Note: Exported as ordinal 8
//
DWORD GetIdleMinutes(DWORD dwReserved);

typedef DWORD (WINAPI* _GETIDLEMINUTES) (DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\log.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       log.cxx
//
//  Contents:   Logging routines for the job scheduler service.
//
//  Classes:    None.
//
//  Functions:  OpenLogFile
//              CloseLogFile
//              LogTaskStatus
//              LogTaskError
//              LogServiceStatus
//              LogServiceError
//              ConstructStatusField
//              ConstructResultField
//              GetSchedulerResultCodeString
//              OverwriteRecordFragment
//              IntegerToString
//
//  History:    1-Feb-96    MarkBl    Created.
//              24-Oct-96   AnirudhS  Modified to handle DBCS.
//              2-Feb-98    jschwart  Modified to handle Unicode.
//              26-Feb-01   JBenton   Prefix bug 294880
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"
#include "..\inc\resource.h"

#define CCH_INT 11
#define ARRAY_LEN(a)    (sizeof(a)/sizeof(a[0]))

TCHAR *  ConstructStatusField(DWORD, SYSTEMTIME *, ULONG *);
TCHAR *  ConstructResultField(DWORD, LPTSTR);
TCHAR *  GetSchedulerResultCodeString(DWORD, DWORD);
TCHAR *  IntegerToString(ULONG, TCHAR *);
VOID     OverwriteRecordFragment(VOID);
VOID     WriteLog(LPTSTR);
BOOL     GetDateTime(const SYSTEMTIME *, LPTSTR, LPTSTR);
VOID     LogServiceMessage(LPCTSTR, DWORD);


//
// Note, this buffer must be at least double the size of the ASCII string:
//     "[ ***** Most recent entry is above this line ***** ]\r\n\r\n"
// to leave sufficient space for localization changes.
//
#define MOST_RECENT_ENTRY_MARKER_SIZE   128
static TCHAR gtszMostRecentEntryMarker[MOST_RECENT_ENTRY_MARKER_SIZE + 1] = TEXT("");

CRITICAL_SECTION gcsLogCritSection;
HANDLE           ghLog           = NULL;
DWORD            gdwMaxLogSizeKB = NULL;
DWORD            gcbMostRecentEntryMarkerSize;


//+---------------------------------------------------------------------------
//
//  Function:   OpenLogFile
//
//  Synopsis:   Open the log file and position the global file pointer.
//
//              Log file path/name can be specified in in the registry as:
//              HKEY_LOCAL_MACHINE\Software\Microsoft\JobScheduler\LogPath.
//              If this value is not specified, or we fail somehow fetching
//              it, default to the log file name "SCHEDLOG.TXT" (Ansi/Win9x)
//              or "SCHEDLGU.TXT" (Unicode/NT) in the windows root.
//
//              The log file handle is cached as a global.
//
//  Arguments:  None.
//
//  Returns:    HRESULT status code.
//
//  Notes:      ** Important Note **
//
//              This function *must* be called *once* prior to log usage.
//              This function should be called after g_hInstance has been
//              initialized.
//
//----------------------------------------------------------------------------
HRESULT
OpenLogFile(VOID)
{
    TCHAR       tszBuffer[MAX_PATH + 1] = TEXT("\0");
    DWORD       cbBufferSize            = sizeof(tszBuffer);
    DWORD       dwMaxLogSizeKB          = MAX_LOG_SIZE_DEFAULT;
    DWORD       dwType;
    HKEY        hKey;
    HRESULT     hr;

#define tszLogPath              TEXT("LogPath")
#define tszMaxLogSizeKB         TEXT("MaxLogSizeKB")
#define tszMarkerSentinel       TEXT("[ *****")
#define MARKER_SENTINEL_LENGTH  (ARRAY_LEN(tszMarkerSentinel) - 1)
#define READ_BUFFER_SIZE        512

    schAssert(ghLog == NULL);

    //
    // The crit sec must be initialized first, because a failure in this
    // function will result in the higher level functions trying to log a
    // message, which will try to enter the crit sec.
    //
    InitializeCriticalSection(&gcsLogCritSection);

    // Load the most recent entry marker string from the resource table.
    // Set the size of the marker to the end of the string.  Otherwise,
    // the IsTextUnicode API (called by notepad) thinks this is Ansi.
    //
    gcbMostRecentEntryMarkerSize =

            LoadString(g_hInstance,
                       IDS_MOSTRECENTLOGENTRYMARKER,
                       gtszMostRecentEntryMarker,
                       MOST_RECENT_ENTRY_MARKER_SIZE + 1);

    if (!gcbMostRecentEntryMarkerSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    // Convert to size in bytes
    //
    gcbMostRecentEntryMarkerSize *= sizeof(TCHAR);

    // Read the log path and maximum size from the registry. Note that these
    // are stored in the service's key.
    //
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       SCH_AGENT_KEY,
                       0,
                       KEY_READ,
                       &hKey))
    {
        if (RegQueryValueEx(hKey,
                            tszLogPath,
                            NULL,
                            &dwType,
                            (UCHAR *)tszBuffer,
                            &cbBufferSize) ||
            (dwType != REG_SZ && dwType != REG_EXPAND_SZ))
        {
            tszBuffer[0] = TEXT('\0');
        }

        cbBufferSize = sizeof(dwMaxLogSizeKB);

        if (RegQueryValueEx(hKey,
                            tszMaxLogSizeKB,
                            NULL,
                            &dwType,
                            (UCHAR *)&dwMaxLogSizeKB,
                            &cbBufferSize) || dwType != REG_DWORD)
        {
            dwMaxLogSizeKB = MAX_LOG_SIZE_DEFAULT;
        }

        RegCloseKey(hKey);
    }

    // Default log path on error.
    //
    if (!tszBuffer[0])
    {
        lstrcpy(tszBuffer, TSZ_LOG_NAME_DEFAULT);
    }

    // Expand environment strings in the log path.
    //
    TCHAR tszFileName[MAX_PATH+1];
    DWORD cch = ExpandEnvironmentStrings(tszBuffer,
                                         tszFileName,
                                         ARRAY_LEN(tszFileName));
    if (cch == 0 || cch > ARRAY_LEN(tszFileName))
    {
        ERR_OUT("ExpandEnvironmentStrings", cch);
        return E_OUTOFMEMORY;
    }

    // Create the file if it doesn't exist, open it if it does.
    //
    HANDLE hLog = CreateFile(tszFileName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                             NULL);

    if (hLog == INVALID_HANDLE_VALUE)
    {
        // We're in a fine mess, bail.
        //
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        schDebugOut((DEB_ERROR, "Attempted to create file \"" FMT_TSTR "\"\n", tszFileName));
        return(hr);
    }

    TCHAR rgtBuffer[READ_BUFFER_SIZE / sizeof(TCHAR)];
    DWORD dwRead;
    DWORD iMarker = 0;  // Scope the marker index such that the search may
                        // span multiple reads.

#ifdef UNICODE

    DWORD dwLoops = 0;  // Keep track of how many successful reads we've made.
                        // Used to figure out whether to write the UNICODE
                        // byte order mark (BOM) at the top of the file

#endif // UNICODE

    // Seek to the most recent entry marker. Do so by searching for the first
    // several distinguishable characters of the marker - a sentinel.
    //
    for (;;)
    {
        // Save away current file position for later file pointer adjustment.
        //
        LARGE_INTEGER liLogPos;

        liLogPos.QuadPart = 0;

        if ((liLogPos.LowPart = SetFilePointer(hLog,
                                               0,
                                               &liLogPos.HighPart,
                                               FILE_CURRENT)) == -1)
        {
            break;
        }

        if (!ReadFile(hLog, rgtBuffer, READ_BUFFER_SIZE, &dwRead, NULL) ||
                    !dwRead)
        {
            break;
        }

        // Convert to the number of characters (and chop off a stray byte
        // if it exists in the Unicode case)
        //
        dwRead /= sizeof(TCHAR);

        for (DWORD iBuffer = 0; iBuffer < dwRead; iBuffer++)
        {
            // If the first marker character is found, or the marker
            // comparison is continued from the previous read, evaluate
            // remaining marker string.
            //
            if (rgtBuffer[iBuffer] == TEXT('[') || iMarker)
            {
                for (; iMarker < MARKER_SENTINEL_LENGTH && dwRead - iBuffer;
                          iMarker++, iBuffer++)
                {
                    if (rgtBuffer[iBuffer] != tszMarkerSentinel[iMarker])
                    {
                        break;
                    }
                }

                // If the marker is found, stop & re-position the file
                // pointer for future writes.
                //
                if (iMarker == MARKER_SENTINEL_LENGTH)
                {
                    // Adjust file pointer accordingly.
                    //
                    liLogPos.QuadPart += iBuffer * sizeof(TCHAR);
                    liLogPos.QuadPart -= MARKER_SENTINEL_LENGTH * sizeof(TCHAR);

                    if (SetFilePointer(hLog,
                                       liLogPos.LowPart,
                                       &liLogPos.HighPart,
                                       FILE_BEGIN) != -1)
                    {
                        goto MarkerFound;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        CHECK_HRESULT(hr);
                    }
                }
                else if (iMarker < MARKER_SENTINEL_LENGTH && dwRead - iBuffer)
                {
                    // Almost a match, but not quite - reset for continued
                    // search.
                    //
                    iMarker = 0;
                }
            }
        }

#ifdef UNICODE

    dwLoops++;

#endif // UNICODE

    }

#ifdef UNICODE

    if (!dwLoops && !dwRead)
    {
        // We just created the file and it's empty, so write the Unicode BOM
        //

        DWORD cbWritten;
        WCHAR wcBOM = 0xFEFF;

        if (!WriteFile(hLog, &wcBOM, sizeof(WCHAR), &cbWritten, NULL) ||
                      !cbWritten)
        {
            // If we can't write to the log, we've got problems
            //
            CloseHandle(hLog);
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return hr;
        }
    }

#endif // UNICODE

    // Marker not found. Seek to file end.
    //
    if (SetFilePointer(hLog, 0, NULL, FILE_END) == -1)
    {
        // Another fine mess, bail.
        //
        CloseHandle(hLog);
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        schAssert(!"Couldn't seek to log file end");
        return(hr);
    }

MarkerFound:
    gdwMaxLogSizeKB = dwMaxLogSizeKB;
    ghLog = hLog;
    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   CloseLogFile
//
//  Synopsis:   Close log file and invalidate global handle.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      ** Important Note **
//
//              Presumably, this function is called on process closure.
//              Therefore, let the OS delete the critical section, *not* this
//              thread. Otherwise, the critical section can be deleted out
//              from under other threads currently accessing the log.
//
//----------------------------------------------------------------------------
VOID
CloseLogFile(VOID)
{
    //
    // If OpenLogFile has not completed successfully, the critical section
    // won't have been initialized nor the global file handle set.
    //
    if (ghLog != NULL)
    {
        // Handle close gracefully in case another thread is accessing the log.
        // Do so by entering the log critical section, closing the log and
        // invalidating the global log handle (setting it to NULL).
        //
        EnterCriticalSection(&gcsLogCritSection);

        CloseHandle(ghLog);
        ghLog = NULL;

        LeaveCriticalSection(&gcsLogCritSection);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LogTaskStatus
//
//  Purpose:    Log successful task operations.
//
//  Arguments:  [ptszTaskName]   - the task name.
//              [ptszTaskTarget] - the application/document name.
//              [uMsgID]         - this would typically be either:
//                                 IDS_LOG_JOB_STATUS_STARTED or
//                                 IDS_LOG_JOB_STATUS_FINISHED
//              [dwExitCode]     - if uMsgID is IDS_LOG_JOB_STATUS_FINISHED,
//                                 it is the task exit code; ignored otherwise.
//
//----------------------------------------------------------------------------
VOID
LogTaskStatus(
    LPCTSTR ptszTaskName,
    LPTSTR  ptszTaskTarget,
    UINT    uMsgID,
    DWORD   dwExitCode)
{
    TCHAR   tszMsgFormat[SCH_BIGBUF_LEN];
    TCHAR * ptszStatusMsg = NULL;
    ULONG   ccSize;

    //
    // Add the date & time as inserts to the format string.
    //

    TCHAR tszDate[SCH_MEDBUF_LEN];
    TCHAR tszTime[SCH_MEDBUF_LEN];

    if (!GetDateTime(NULL, tszDate, tszTime))
    {
        return;
    }

    TCHAR * ptszResultField = NULL;

    // Load the format string resource.
    //
    if (!LoadString(g_hInstance,
                    uMsgID,
                    tszMsgFormat,
                    ARRAY_LEN(tszMsgFormat)))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    if (uMsgID == IDS_LOG_JOB_STATUS_FINISHED)
    {
        ptszResultField = ConstructResultField(dwExitCode, ptszTaskTarget);

        if (ptszResultField == NULL)
        {
            return;
        }
    }

    TCHAR * rgptszInserts[] = { (TCHAR *)ptszTaskName,
                                (TCHAR *)ptszTaskTarget,
                                tszDate,
                                tszTime,
                                ptszResultField };

    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING        |
                          FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        tszMsgFormat,
                        0,
                        0,
                        (TCHAR *)&ptszStatusMsg,
                        1,
                        (va_list *) rgptszInserts))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        if (ptszResultField != NULL)
        {
            LocalFree(ptszResultField);
        }
        return;
    }

    WriteLog(ptszStatusMsg);

    LocalFree(ptszStatusMsg);
    if (ptszResultField != NULL)
    {
        LocalFree(ptszResultField);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LogTaskError
//
//  Purpose:    Log task warnings and errors.
//
//  Arguments:  [ptszTaskName]     - the task name.
//              [ptszTaskTarget]   - the application/document name.
//              [uSeverityMsgID]   - this would typically be either:
//                                   IDS_LOG_SEVERITY_WARNING or
//                                   IDS_LOG_SEVERITY_ERROR
//              [uErrorClassMsgID] - this indicates the class of error, such
//                                   as "Unable to start task" or "Forced to
//                                   close"
//              [pst]              - the time when the error occured; if NULL,
//                                   enters the current time.
//              [dwErrorCode]      - if non-zero, then an error from the OS
//                                   that would be expanded by FormatMessage.
//              [uHelpHintMsgID]   - if an error, then a suggestion as to a
//                                   possible remedy.
//
//----------------------------------------------------------------------------
VOID
LogTaskError(
    LPCTSTR ptszTaskName,
    LPCTSTR ptszTaskTarget,
    UINT    uSeverityMsgID,
    UINT    uErrorClassMsgID,
    LPSYSTEMTIME pst,
    DWORD   dwErrCode,
    UINT    uHelpHintMsgID)
{
    TCHAR tszEmpty[] = TEXT("");

    //
    // Verify params:
    //

    if (ptszTaskName == NULL)
    {
        ptszTaskName = tszEmpty;
    }
    if (ptszTaskTarget == NULL)
    {
        ptszTaskTarget = tszEmpty;
    }

    TCHAR tszFormat[SCH_BUF_LEN];

    //
    // Compose the first part of the error log entry:
    // "<task name>" (<task target>) <time> ** [WARNING | ERROR] **
    //

    if (!LoadString(g_hInstance,
                    uSeverityMsgID,
                    tszFormat,
                    SCH_BUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    //
    // Add the date & time as inserts to the format string.
    //

    TCHAR tszDate[SCH_MEDBUF_LEN];
    TCHAR tszTime[SCH_MEDBUF_LEN];

    if (!GetDateTime(pst, tszDate, tszTime))
    {
        return;
    }

    //
    // Obtain the error message string.
    //

    LPTSTR ptszErrMsg = ComposeErrorMsg(uErrorClassMsgID,
                                        dwErrCode,
                                        uHelpHintMsgID);
    if (ptszErrMsg == NULL)
    {
        return;
    }

    //
    // Glue the whole mess together.
    //

    TCHAR * rgptszInserts[] = { (TCHAR *)ptszTaskName,
                                (TCHAR *)ptszTaskTarget,
                                tszDate,
                                tszTime,
                                ptszErrMsg };

    TCHAR * ptszLogStr;

    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING         |
                           FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       tszFormat,
                       0,
                       0,
                       (TCHAR *)&ptszLogStr,
                       1,
                       (va_list *) rgptszInserts))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        LocalFree(ptszErrMsg);
        return;
    }

    WriteLog(ptszLogStr);

    LocalFree(ptszErrMsg);
    LocalFree(ptszLogStr);
}

//+---------------------------------------------------------------------------
//
//  Function:   LogServiceError
//
//  Purpose:    Log service failures.
//
//  Arguments:  [uErrorClassMsgID] - as above.
//              [dwErrCode]        - as above.
//              [uHelpHintMsgID]   - as above.
//
//----------------------------------------------------------------------------
VOID
LogServiceError(
    UINT uErrorClassMsgID,
    DWORD dwErrCode,
    UINT uHelpHintMsgID)
{
    TCHAR   tszSvcErrMsgFormat[SCH_MEDBUF_LEN];

    if (LoadString(g_hInstance,
                   IDS_LOG_SERVICE_ERROR,
                   tszSvcErrMsgFormat,
                   SCH_MEDBUF_LEN) == 0)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        //
        // Generic error message if things are really foobared.
        //
        lstrcpy(tszSvcErrMsgFormat,
                TEXT("\042Task Scheduler Service\042 ** FATAL ERROR **\n"));
        WriteLog(tszSvcErrMsgFormat);
        return;
    }

    //
    // Add the date & time as inserts to the format string.
    //

    TCHAR tszDate[SCH_MEDBUF_LEN];
    TCHAR tszTime[SCH_MEDBUF_LEN];

    if (!GetDateTime(NULL, tszDate, tszTime))
    {
        return;
    }

    LPTSTR ptszErrMsg = ComposeErrorMsg(uErrorClassMsgID,
                                        dwErrCode,
                                        uHelpHintMsgID);
    if (ptszErrMsg == NULL)
    {
        return;
    }

    TCHAR * rgptszInserts[] = {tszDate, tszTime, ptszErrMsg};
    TCHAR * ptszLogStr;

    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING         |
                           FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       tszSvcErrMsgFormat,
                       0,
                       0,
                       (TCHAR *)&ptszLogStr,
                       1,
                       (va_list *) rgptszInserts))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        LocalFree(ptszErrMsg);
        return;
    }

    WriteLog(ptszLogStr);

    LocalFree(ptszErrMsg);
    LocalFree(ptszLogStr);
}

//+---------------------------------------------------------------------------
//
//  Function:   LogServiceEvent
//
//  Synopsis:   Write the service event to the log file.
//
//  Purpose:    Note the starting, stopping, pausing, and continuing of the
//              service.
//
//  Arguments:  [uStrId] - a string identifying the event.
//
//----------------------------------------------------------------------------
VOID
LogServiceEvent(UINT uStrId)
{
    TCHAR * ptszSvcMsg;
    ULONG   cbMsgSize;
    SYSTEMTIME st;

    GetLocalTime(&st);

    ptszSvcMsg = ConstructStatusField(uStrId, &st, &cbMsgSize);

	if( NULL == ptszSvcMsg )
	{
		schDebugOut((DEB_ITRACE, "LogServiceEvent - ConstructStatusField(uStrId, &st, &cbMsgSize) failed!\n"));
		return;
	}

    LogServiceMessage(ptszSvcMsg, cbMsgSize);

    LocalFree(ptszSvcMsg);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogMissedRuns
//
//  Synopsis:   Write details about missed runs to the log file.
//
//  Arguments:  [pstLastRun], [pstNow] - times between which runs were missed.
//
//----------------------------------------------------------------------------
VOID
LogMissedRuns(const SYSTEMTIME * pstLastRun, const SYSTEMTIME * pstNow)
{
    TCHAR tszLastRunDate[SCH_MEDBUF_LEN];
    TCHAR tszLastRunTime[SCH_MEDBUF_LEN];
    TCHAR tszNowDate    [SCH_MEDBUF_LEN];
    TCHAR tszNowTime    [SCH_MEDBUF_LEN];

    if (!GetDateTime(pstLastRun, tszLastRunDate, tszLastRunTime) ||
        !GetDateTime(pstNow, tszNowDate, tszNowTime))
    {
        return;
    }

    TCHAR tszMsgFormat[SCH_BIGBUF_LEN];
    if (!LoadString(g_hInstance,
                    IDS_LOG_RUNS_MISSED,
                    tszMsgFormat,
                    SCH_BIGBUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    TCHAR * rgptszInserts[] = { tszLastRunDate, tszLastRunTime,
                                tszNowDate, tszNowTime };

    TCHAR * ptszLogStr;
    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING        |
                          FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       tszMsgFormat,
                       0,
                       0,
                       (TCHAR *)&ptszLogStr,
                       1,
                       (va_list *) rgptszInserts))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    LogServiceMessage(ptszLogStr, (lstrlen(ptszLogStr) + 1) * sizeof(TCHAR));

    LocalFree(ptszLogStr);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogServiceMessage
//
//  Synopsis:   Write a generic service message to the log file.
//
//  Purpose:    Used by LogServiceEvent and LogMissedRuns.
//
//  Arguments:  [ptszStrMsg] - a string message.
//              [cbStrMsg]   - size of pszStrMsg in bytes (may be overestimated,
//                  used only to calculate size of intermediate buffer.)
//
//----------------------------------------------------------------------------
VOID
LogServiceMessage(LPCTSTR ptszStrMsg, DWORD cbStrMsg)
{
    TCHAR * ptszMsg = (TCHAR *)LocalAlloc(LPTR,
                                          SCH_MEDBUF_LEN * sizeof(TCHAR)
                                            + cbStrMsg + sizeof(TCHAR));
    if (ptszMsg == NULL)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    if (LoadString(g_hInstance,
                   IDS_LOG_SERVICE_TITLE,
                   ptszMsg,
                   SCH_MEDBUF_LEN) == 0)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        //
        // Generic error message if things are really foobared.
        //
        lstrcpy(ptszMsg, TEXT("\042Task Scheduler Service\042 ** ERROR **\n"));
    }

    if (ptszStrMsg != NULL)
    {
        lstrcat(ptszMsg, ptszStrMsg);
    }

    WriteLog(ptszMsg);

    LocalFree(ptszMsg);
}


#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   LogDebugMessage
//
//  Synopsis:   Write a debug message to the log file.
//
//  Purpose:    For debugging private builds only.
//
//  Arguments:  [ptszStrMsg] - a string message.
//
//----------------------------------------------------------------------------
VOID
LogDebugMessage(LPCTSTR ptszStrMsg)
{
    TCHAR   tszBuf[500];    // Assumed to be large enough

    //
    // Add the date & time as inserts to the status field format string.
    //
    TCHAR   tszDate[SCH_MEDBUF_LEN] = TEXT("");
    TCHAR   tszTime[SCH_MEDBUF_LEN] = TEXT("");

    GetDateTime(NULL, tszDate, tszTime);

    schAssert(lstrlen(ptszStrMsg) + lstrlen(tszDate) + lstrlen(tszTime) + 20 <
              ARRAY_LEN(tszBuf));

    wsprintf(tszBuf, TEXT("\"**DEBUG MESSAGE**\" %s %s\r\n\t%s\r\n"),
             tszDate, tszTime, ptszStrMsg);

    WriteLog(tszBuf);
}
#endif // DBG


//+---------------------------------------------------------------------------
//
//  Function:   WriteLog
//
//  Synopsis:   Write the string to the log file.
//
//----------------------------------------------------------------------------
VOID
WriteLog(LPTSTR ptsz)
{
    LARGE_INTEGER liCurLogSize, liMaxLogSize;
    DWORD cbWritten;
    ULONG cbStringSize = lstrlen(ptsz) * sizeof(TCHAR);
    ULONG cbDataSize = cbStringSize;

    EnterCriticalSection(&gcsLogCritSection);

    schDebugOut((DEB_TRACE, "LOG:\n " FMT_TSTR "", ptsz));

    // Lose some time here by not caching this value, but not much.
    //
    cbDataSize += lstrlen(gtszMostRecentEntryMarker) * sizeof(TCHAR);

    // Get the current log size to see if there is room to write this.
    //
    liCurLogSize.QuadPart = 0;

    if ((liCurLogSize.LowPart = SetFilePointer(ghLog,
                                               0,
                                               &liCurLogSize.HighPart,
                                               FILE_CURRENT)) == -1)
    {
        goto ErrorExit_A;
    }

    // Add current data size. Convert maximum size to bytes for comparison.
    //
    liCurLogSize.QuadPart += cbDataSize;

    liMaxLogSize.QuadPart = gdwMaxLogSizeKB * 1024;

    // Is there sufficient space to write the entry?
    //
    if (liCurLogSize.QuadPart > liMaxLogSize.QuadPart)
    {
        // No, adjust the end of file to eliminate the most recent entry
        // marker & wrap to beginning.
        //
        SetEndOfFile(ghLog);            // Ignore return code.

#ifdef UNICODE

        // Unicode log -- skip the BOM
        //
        if (SetFilePointer(ghLog, sizeof(WCHAR), NULL, FILE_BEGIN) == -1)
        {
            // Seek failure
            //
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
			schAssert(!"Couldn't seek log file");
			goto ErrorExit_A;
        }

#else

        // Ansi log -- no Unicode BOM
        //
        if (SetFilePointer(ghLog, 0, NULL, FILE_BEGIN) == -1)
        {
            // Seek failure
            //
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
			schAssert(!"Couldn't seek log file");
            goto ErrorExit_A;
        }

#endif // UNICODE

    }

    // Write the string.
    //
    if (!WriteFile(ghLog, ptsz, cbStringSize, &cbWritten, NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        goto ErrorExit_A;
    }

    // Write most recent entry marker.
    //
    // First, save the current file pointer position. This will be the
    // starting location of the next log write. Note: double-timing current
    // log size local since it is no longer used.
    //
    liCurLogSize.QuadPart = 0;

    if ((liCurLogSize.LowPart = SetFilePointer(ghLog,
                                               0,
                                               &liCurLogSize.HighPart,
                                               FILE_CURRENT)) == -1)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        goto ErrorExit_A;
    }

    if (!WriteFile(ghLog,
                   gtszMostRecentEntryMarker,
                   gcbMostRecentEntryMarkerSize,
                   &cbWritten,
                   NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        goto ErrorExit_A;
    }

    // If the log has wrapped, it's likely the write pointer is positioned
    // somewhere in the middle of the next record. If this is the case,
    // the remaining partial record must be overwritten with spaces.
    //
    OverwriteRecordFragment();

    // Restore log position for next write.
    //
    if (SetFilePointer(ghLog,
                       liCurLogSize.LowPart,
                       &liCurLogSize.HighPart,
                       FILE_BEGIN) == -1)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
    }

ErrorExit_A:
    LeaveCriticalSection(&gcsLogCritSection);
}

//+---------------------------------------------------------------------------
//
//  Function:   OverwriteRecordFragment
//
//  Synopsis:   If the log has wrapped, the last write most likely has
//              partially overwritten a record. This routine overwrites such
//              record fragments with spaces up to the next record.
//
//              Fundamental assumption - how a record is designated: The start
//              of a new record is designated by the two characters \n". This
//              routine simply fills text with spaces up to but not including
//              this character sequence.
//
//  Arguments:  None.
//
//  Returns:    N/A
//
//  Notes:      Upon exit, the log file pointer is restored to its original
//              position on entry.
//
//----------------------------------------------------------------------------
VOID
OverwriteRecordFragment(VOID)
{
    TCHAR         rgtBuffer[READ_BUFFER_SIZE / sizeof(TCHAR)];
    LARGE_INTEGER liSavedLogPos, liLogPos;
    DWORD         dwRead;

    // Save file pointer position during read for subsequent write.
    //
    liSavedLogPos.QuadPart = 0;

    if ((liSavedLogPos.LowPart = SetFilePointer(ghLog,
                                                0,
                                                &liSavedLogPos.HighPart,
                                                FILE_CURRENT)) == -1)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    // From the previous write, the last character is a line feed.
    //
    TCHAR  tchPrev = TEXT('\n');
    TCHAR  tchCur;
    int    cbOverwrite = 0;
    DWORD  i = 0;    // Index of chCur in rgbBuffer

    for (;;)
    {
        if (!ReadFile(ghLog, rgtBuffer, READ_BUFFER_SIZE, &dwRead, NULL) ||
                      !dwRead)
        {
            break;
        }

        // Convert to the number of characters (and chop off a stray byte
        // if it exists in the Unicode case)
        //
        dwRead /= sizeof(TCHAR);

        for ( ; i < dwRead; i++, cbOverwrite += sizeof(TCHAR))
        {
            tchCur = rgtBuffer[i];

            if (tchPrev == TEXT('\n') && tchCur == TEXT('"') && cbOverwrite > 2 * sizeof(TCHAR))
            {
                break;
            }

#ifndef UNICODE

            if (IsDBCSLeadByte(tchCur))
            {
                // Skip the trail byte.  Note that we might not have read
                // the trail byte into the buffer yet, so i might now be
                // pointing past the last byte read.
                i++;
                cbOverwrite++;
            }

#endif  // UNICODE

            tchPrev = tchCur;
        }

        if (i < dwRead)
        {
            // We found the \n" character sequence.  Don't
            // overwrite the \r\n" sequence of the next record.
            //
            cbOverwrite -= 2 * sizeof(TCHAR);
            break;
        }

#ifdef UNICODE

        i = 0;

#else

        //
        // ReadFile could span a multi-byte char. Adjust i accordingly vs.
        // resetting it to zero.
        //

        i -= dwRead;    // This will result in either 1 or 0

        if (i == 1)
        {
            cbOverwrite++;
        }

#endif  // UNICODE

    }

    DWORD cbWritten;

    // Overwrite record fragment with spaces.
    //
    if (cbOverwrite > 0)
    {
        // Adjust file pointer from read above.
        //
        if (SetFilePointer(ghLog,
                           liSavedLogPos.LowPart,
                           &liSavedLogPos.HighPart,
                           FILE_BEGIN) != -1)
        {

#ifdef UNICODE

            for (UINT uCount = 0;
                      uCount < READ_BUFFER_SIZE / sizeof(TCHAR);
                      uCount++)
            {
                rgtBuffer[uCount] = TEXT(' ');
            }

#else

            FillMemory(rgtBuffer, READ_BUFFER_SIZE, ' ');

#endif  // UNICODE

            while (cbOverwrite > 0)
            {
                if (!WriteFile(ghLog,
                               rgtBuffer,
                               min(cbOverwrite, READ_BUFFER_SIZE),
                               &cbWritten,
                               NULL))
                {
                    CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
                    break;
                }

                cbOverwrite -= cbWritten;
            }
        }
        else
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ConstructStatusField
//
//  Synopsis:   Retrieve the status field with an optional status timestamp
//              insert.
//
//  Arguments:  [dwStatusFieldMsgID] -- Status field format string msg id.
//              [pstStatusTime]      -- Optional status timestamp. If NULL,
//                                      no timestamp is written.
//              [pcbSize]            -- Returned status field size (bytes).
//
//  Returns:    TCHAR * status field
//              NULL on error
//
//  Notes:      FormatMessage allocates the return string. Use LocalFree() to
//              deallocate.
//
//----------------------------------------------------------------------------
TCHAR *
ConstructStatusField(
    DWORD        dwStatusFieldMsgID,
    SYSTEMTIME * pstStatusTime,
    ULONG *      pcbSize)
{
    // Note: Insure string buffer sizes are at least double the size of the
    //       largest string they'll contain, for localization reasons.
    //
    TCHAR   tszStatusFieldFormat[SCH_BIGBUF_LEN];
    TCHAR   tszDate[SCH_MEDBUF_LEN];
    TCHAR   tszTime[SCH_MEDBUF_LEN];
    TCHAR * rgptszInserts[] = { tszDate, tszTime };
    TCHAR * ptszStatusField = NULL;

    // The status field may/may not contain a date & time. The first
    // branch is taken for status fields containing them.
    //
    if (pstStatusTime != NULL)
    {
        // Add the date & time as inserts to the status field format string.
        //
        if (!GetDateTime(pstStatusTime, tszDate, tszTime))
        {
            return(NULL);
        }
    }

    ULONG ccSize = 0;

    // Load the status field format string resource.
    //
    if (LoadString(g_hInstance,
                   dwStatusFieldMsgID,
                   tszStatusFieldFormat,
                   SCH_BIGBUF_LEN))
    {
        if (!(ccSize = FormatMessage(FORMAT_MESSAGE_FROM_STRING       |
                                       FORMAT_MESSAGE_ALLOCATE_BUFFER |
               (pstStatusTime != NULL ? FORMAT_MESSAGE_ARGUMENT_ARRAY : 0),
                                     tszStatusFieldFormat,
                                     0,
                                     0,
                                     (TCHAR *)&ptszStatusField,
                                     1,
               (pstStatusTime != NULL ? (va_list *) rgptszInserts : NULL))))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    else
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
    }

    *pcbSize = ccSize * sizeof(TCHAR);

    return(ptszStatusField);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConstructResultField
//
//  Synopsis:   Retrieve the result field. Algorithm:
//
//              The result code is the job's exit code. Utilize the following
//              algorithm to obtain the exit code string:
//
//                  First, attempt to fetch the the exit code string as a
//                  message binary specified in the Job Scheduler portion of
//                  the registry.
//
//                  If the fetch failed, perhaps this is a SAGE job. Attempt
//                  to fetch the string the SAGE way.
//
//                  If neither scheme worked above, produce a default
//                  "message not found for exit code (n)" message.
//
//              Insert the result string obtained above as an insert string
//              to the result field format string.
//
//  Arguments:  [dwResultCode]       -- Result field result code.
//              [ptszJobExecutable]  -- Binary name executed by the job.
//
//  Returns:    TCHAR * result field
//              NULL on error
//
//  Notes:      FormatMessage allocates the return string. Use LocalFree() to
//              deallocate.
//
//----------------------------------------------------------------------------
TCHAR *
ConstructResultField(
    DWORD  dwResultCode,
    LPTSTR ptszJobExecutable)
{
    // Note: Insure format string buffer size is at least double the size of
    //       the largest string it will contain, for localization reasons.
    //
    TCHAR   tszResultFieldFormat[SCH_MEDBUF_LEN];
    TCHAR   tszResultCodeValue[CCH_INT + 1];
    TCHAR * ptszResultField = NULL;
    TCHAR * ptszResult;

    IntegerToString(dwResultCode, tszResultCodeValue);

    // Job exit code. Fetch the exit code string from the
    // ExitCodeMessageFile associated with the job program.
    //
    if ((ptszResult = GetExitCodeString(dwResultCode,
                                        tszResultCodeValue,
                                        (TCHAR *)ptszJobExecutable)) == NULL)
    {
        // If the above failed, try the SAGE way.
        //
        ptszResult = GetSageExitCodeString(tszResultCodeValue,
                                           (TCHAR *)ptszJobExecutable);
    }

    if (ptszResult == NULL)
    {
        // Produce a default "message not found" result string.
        //
        ptszResult = GetSchedulerResultCodeString(
                                         IDS_LOG_EXIT_CODE_MSG_NOT_FOUND,
                                         dwResultCode);
    }

    ULONG ccSize = 0;

    // Load the result field format string resource.
    //
    if (ptszResult != NULL)
    {
        if (LoadString(g_hInstance,
                       IDS_LOG_JOB_RESULT_FINISHED,
                       tszResultFieldFormat,
                       SCH_MEDBUF_LEN))
        {
            TCHAR * rgtszInserts[] = { ptszResult, tszResultCodeValue };

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING       |
                                 FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               tszResultFieldFormat,
                               0,
                               0,
                               (TCHAR *)&ptszResultField,
                               1,
                               (va_list *) rgtszInserts))
            {
                CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            }

            LocalFree(ptszResult);       // pszResultField now encapsulates
                                        // this string.
        }
        else
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    return(ptszResultField);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSchedulerResultCodeString
//
//  Synopsis:   Fetch the result code from the schedule service process.
//
//  Arguments:  [dwResultMsgID] -- Result message string ID.
//              [dwResultCode]  -- result code.
//
//  Returns:    TCHAR * result code string
//              NULL on error
//
//  Notes:      FormatMessage allocates the return string. Use LocalFree() to
//              deallocate.
//
//----------------------------------------------------------------------------
TCHAR *
GetSchedulerResultCodeString(
    DWORD  dwResultMsgID,
    DWORD  dwResultCode)
{
    TCHAR   tszResultCodeValue[SCH_SMBUF_LEN];
    TCHAR   tszErrMsg[SCH_MEDBUF_LEN];
    TCHAR * ptszErrMsg = NULL, * ptszResultCode = NULL;
    DWORD   ccLength;
    TCHAR * rgtszInserts[] = { tszResultCodeValue, ptszErrMsg };

    IntegerToString(dwResultCode, tszResultCodeValue);

    TCHAR tszMsgBuf[MAX_PATH], * ptsz;

    if (LoadString(g_hInstance, dwResultMsgID, tszMsgBuf, MAX_PATH) == 0)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return NULL;
    }

    if (dwResultCode != 0)
    {
        BOOL fDelete = FALSE;
        //
        // Try to obtain an error message from the system.
        //
        if (!(ccLength = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                       NULL,
                                       dwResultCode,
                                       LOCALE_SYSTEM_DEFAULT,
                                       (TCHAR *)&ptszErrMsg,
                                       1,
                                       NULL)))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));

            if (!LoadString(g_hInstance,
                            IDS_GENERIC_ERROR_MSG,
                            tszErrMsg,
                            SCH_MEDBUF_LEN))
            {
                CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
                return NULL;
            }

            ptszErrMsg = tszErrMsg;
        }
        else
        {
            fDelete = TRUE;

            //
            // Overwrite \r\n with a null characters.
            //
            ptsz = ptszErrMsg + ccLength - 2;

            *ptsz++ = TEXT('\0');
            *ptsz   = TEXT('\0');
        }

        if (!(ccLength = FormatMessage(FORMAT_MESSAGE_FROM_STRING         |
                                           FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                       tszMsgBuf,
                                       0,
                                       0,
                                       (TCHAR *)&ptszResultCode,
                                       2,
                                       (va_list *) rgtszInserts)))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            if (fDelete) LocalFree(ptszErrMsg);
            return NULL;
        }

        if (fDelete) LocalFree(ptszErrMsg);
    }
    else
    {
        //
        // No result code. All of the info is encapsulated in dwResultMsgID,
        // which has no inserts.
        //
        if (!(ccLength = FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                           FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                       tszMsgBuf,
                                       0,
                                       0,
                                       (TCHAR *)&ptszResultCode,
                                       1,
                                       NULL)))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            return NULL;
        }
    }

    return(ptszResultCode);
}

//+---------------------------------------------------------------------------
//
//  Function:   IntegerToString
//
//  Synopsis:   Converts a 32 bit integer to a string.
//
//  Arguments:  [n]       -- Converted int.
//              [ptszBuf] -- Caller allocated buffer.
//
//  Returns:    Buffer ptr passed.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
TCHAR *
IntegerToString(ULONG n, TCHAR * tszBuf)
{
    //
    // Assemble hex representation into passed buffer, reversed,
    // then reverse in-place into correct format
    //
    // This code deliberately eschews ultoa, since div and mod 16
    // optimize so very nicely.
    //

    UINT ich = 0;

    do
    {
        UINT nDigitValue = (UINT)(n % 16);

        n /= 16;

        if (nDigitValue > 9)
        {
            tszBuf[ich++] = (WCHAR)nDigitValue - 10 + TEXT('a');
        }
        else
        {
            tszBuf[ich++] = (WCHAR)nDigitValue + TEXT('0');
        }

    } while (n > 0);

    tszBuf[ich] = TEXT('\0');

    _tcsrev(tszBuf);

    return(tszBuf);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDateTime
//
//  Synopsis:   Formats the date and time.
//
//  Arguments:  [pst]      - The time to use; if NULL, then the current time
//                           is obtained.
//              [ptszDate] - The date string buffer.
//              [ptszTime] - The time string buffer.
//
//  Returns:    TRUE for success, FALSE for failure.
//
//  Notes:      Note that the buffers must be at least SCH_MEDBUF_LEN in size.
//
//----------------------------------------------------------------------------
BOOL
GetDateTime(const SYSTEMTIME * pst, LPTSTR ptszDate, LPTSTR ptszTime)
{
    SYSTEMTIME st;

    if (pst == NULL)
    {
        GetLocalTime(&st);
        pst = &st;
    }

    if (!GetDateFormat(LOCALE_USER_DEFAULT,
                       LOCALE_NOUSEROVERRIDE,
                       pst,
                       NULL,
                       ptszDate,
                       SCH_MEDBUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    if (!GetTimeFormat(LOCALE_USER_DEFAULT,
                       LOCALE_NOUSEROVERRIDE,
                       pst,
                       NULL,
                       ptszTime,
                       SCH_MEDBUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\netsch.cxx ===
//+---------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       netsch.cxx
//
//  Contents:   Server-side Net Scheduler RPC implementation.
//
//  Classes:    None.
//
//  RPC:        NetrJobAdd
//              NetrJobDel
//              NetrJobEnum
//              NetrJobGetInfo
//
//  Functions:  CreateAtJobPath
//              GetAtJobIdFromFileName
//              InitializeNetScheduleApi
//              UninitializeNetScheduleApi
//
//  History:    11-Nov-95   MarkBl  Created.
//              02-Feb-01   JBenton Fixed BUG 303146 - 64bit pointer alignment problem
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include <align.h>
#include <apperr.h>
#include <lmerr.h>
#include <netevent.h>
extern "C" {
#include <netlib.h>
}
#include "atsvc.h"
#include "..\inc\resource.h"
#include "svc_core.hxx"
#include "atsec.hxx"
#include "proto.hxx"

//
// Manifests below taken from the existing At service. Values must *not*
// change to maintain compatibility.
//

#define MAXIMUM_COMMAND_LENGTH          (MAX_PATH - 1)
#define MAXIMUM_JOB_TIME                (24 * 60 * 60 * 1000 - 1)
#define DAYS_OF_WEEK                    0x7F        // 7 bits for 7 days.
#define DAYS_OF_MONTH                   0x7FFFFFFF  // 31 bits for 31 days.

// This is not localized - it is a registry key (indirectly) from the At service

#define SCHEDULE_EVENTLOG_NAME          TEXT("Schedule")

//
// Converts an HRESULT to a WIN32 status code. Masks off everything but
// the error code.
//
// BUGBUG : Review.
//

#define WIN32_FROM_HRESULT(x)           (HRESULT_CODE(x))

//
// Minimum and maximum buffer size returned in an enumeration.
//

// 02/05/01-jbenton : this macro is used to a unicode buffer so must be even
// to avoid alignment problems (bug 303146).
#define BUFFER_LENGTH_MINIMUM (sizeof(AT_ENUM) + (MAXIMUM_COMMAND_LENGTH+1)*sizeof(WCHAR))
#define BUFFER_LENGTH_MAXIMUM 65536

//
// Ballpark maximum command string length.
//
// BUGBUG : Review this value.
//

#define COMMAND_STRING_LENGTH_APPROX    (((MAX_PATH / 4) + 1) * sizeof(WCHAR))

#define ASTERISK_STR                    L"*"
#define BACKSLASH_STR                   L"\\"

void           CreateAtJobPath(DWORD, WCHAR *);
DWORD          GetAtJobIdFromFileName(WCHAR *);
void           GetNextAtID(LPDWORD);

WCHAR * gpwszAtJobPathTemplate   = NULL;


//+---------------------------------------------------------------------------
//
//  RPC:        NetrJobAdd
//
//  Synopsis:   Add a single At job.
//
//  Arguments:  [ServerName] -- Unused.
//              [pAtInfo]    -- New job information.
//              [pJobId]     -- Returned job id.
//
//  Returns:    BUGBUG : Problem mapping a HRESULT to WIN32. Masking off the
//                       facility & error bits is insufficient.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
NET_API_STATUS
NetrJobAdd(ATSVC_HANDLE ServerName, LPAT_INFO pAtInfo, LPDWORD pJobId)
{
    schDebugOut((DEB_ITRACE,
        "NetrJobAdd ServerName(%ws), pAtInfo(0x%x)\n",
        (ServerName != NULL) ? ServerName : L"(local)",
        pAtInfo));

    UNREFERENCED_PARAMETER(ServerName);

    NET_API_STATUS Status = NERR_Success;

    Status = AtCheckSecurity(AT_JOB_ADD);
    if (Status != NERR_Success)
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Validate arguments.
    //

    if ( (pAtInfo->Command        == NULL)                   ||
         (wcslen(pAtInfo->Command) > MAXIMUM_COMMAND_LENGTH) ||
         (pAtInfo->JobTime         > MAXIMUM_JOB_TIME)       ||
         (pAtInfo->DaysOfWeek      & ~DAYS_OF_WEEK)          ||
         (pAtInfo->DaysOfMonth     & ~DAYS_OF_MONTH)         ||
         (pAtInfo->Flags           & ~JOB_INPUT_FLAGS))
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // TBD : Logic to punt the submission if the service is paused.
    //

    EnterCriticalSection(&gcsNetScheduleCritSection);

    //
    // Have the global schedule instance add the At job.
    //

    HRESULT hr = g_pSched->m_pSch->AddAtJobWithHash(*pAtInfo, pJobId);

    if (FAILED(hr))
    {
        //
        // Convert the HRESULT to a WIN32 status code.
        //

        Status = WIN32_FROM_HRESULT(hr);
    }

    LeaveCriticalSection(&gcsNetScheduleCritSection);

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  RPC:        NetrJobDel
//
//  Synopsis:   Delete the At jobs in the range specified.
//
//  Arguments:  [ServerName] -- Unused.
//              [MinJobId]   -- Range lower bound, inclusive.
//              [MaxJobId]   -- Range upper bound, inclusive.
//
//  Returns:    NERR_Sucess
//              ERROR_INVALID_PARAMETER
//              APE_AT_ID_NOT_FOUND
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
NET_API_STATUS
NetrJobDel(ATSVC_HANDLE ServerName, DWORD MinJobId, DWORD MaxJobId)
{
    schDebugOut((DEB_ITRACE,
        "NetrJobDel ServerName(%ws), MinJobId(%d), MaxJobId(%d)\n",
        (ServerName != NULL) ? ServerName : L"(local)",
        MinJobId,
        MaxJobId));

    UNREFERENCED_PARAMETER(ServerName);

    NET_API_STATUS Status;

    Status = AtCheckSecurity(AT_JOB_DEL);
    if (Status != NERR_Success)
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Validate range.
    //

    if (MinJobId > MaxJobId)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&gcsNetScheduleCritSection);

    //
    // Delete the indicated At job objects from storage.
    //
    // NB : To maintain compatibility with the existing AT service, if at
    //      least one job is deleted successfully, return success; otherwise,
    //      return APE_ID_NOT_FOUND.
    //

    WCHAR   wszPath[MAX_PATH + 1];
    BOOL    fJobDeleted = FALSE;
    HRESULT hr;
    BOOL    fDeleteAll = FALSE;

    //
    // Test for delete-all; signaled by passing a MaxJobId of 0xffffffff.
    //

    if (MaxJobId == 0xffffffff)
    {
        //
        // Get the actual maximum ID value (this fixes bug 55839).
        //

        GetNextAtID(&MaxJobId);
        fDeleteAll = TRUE;
    }

    CJob * pJob = CJob::Create();

    if (pJob)
    {
        for (DWORD i = MinJobId; i <= MaxJobId; i++)
        {
            CreateAtJobPath(i, wszPath);

            //
            // Make sure this is really an AT job, and not one that's just
            // named like one.  Just load the fixed-length data and check for
            // the at flag.
            //

            hr = pJob->LoadP(wszPath, 0, FALSE, FALSE);

            if (SUCCEEDED(hr))
            {
                DWORD rgFlags;

                pJob->GetAllFlags(&rgFlags);

                if (rgFlags & JOB_I_FLAG_NET_SCHEDULE)
                {
                    if (DeleteFile(wszPath))
                    {
                        fJobDeleted = TRUE;
                    }
                }
            }
            else
            {
                schDebugOut((DEB_IWARN, "LoadP(%S) hr=0x%x\n", wszPath, hr));
            }
        }
        pJob->Release();
    }

    //
    // If the user asked to delete all at jobs, reset the next id to 1
    //

    if (fDeleteAll)
    {
        (void) g_pSched->m_pSch->ResetAtID();
    }

    LeaveCriticalSection(&gcsNetScheduleCritSection);

    Status = fJobDeleted ? NERR_Success : APE_AT_ID_NOT_FOUND;

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  RPC:        NetrJobEnum
//
//  Synopsis:   Enumerate At jobs.
//
//  Arguments:  [ServerName]             -- Unused.
//              [pEnumContainer]         -- Returned enumeration (AT_JOB_INFO
//                                          array and size).
//              [PreferredMaximumLength] -- Preferred buffer size maximum. If
//                                          -1, allocate as needed.
//              [pTotalEntries]          -- Returns the total number of
//                                          entries available.
//              [pResumeHandle]          -- Enumeration context. Indexes the
//                                          the At jobs directory.
//
//  Returns:    BUGBUG : Problem here too with HRESULTs mapped to WIN32 status
//                       codes.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
NET_API_STATUS
NetrJobEnum(
    ATSVC_HANDLE        ServerName,
    LPAT_ENUM_CONTAINER pEnumContainer,
    DWORD               PreferredMaximumLength,
    LPDWORD             pTotalEntries,
    LPDWORD             pResumeHandle)
{
    schDebugOut((DEB_ITRACE,
        "NetrJobEnum ServerName(%ws), pEnumContainer(0x%x), " \
        "PreferredMaximumLength(%d)\n",
        (ServerName != NULL) ? ServerName : L"(local)",
        pEnumContainer,
        PreferredMaximumLength));

    UNREFERENCED_PARAMETER(ServerName);

    WCHAR           wszCommand[MAX_PATH + 1];
    WIN32_FIND_DATA fd;
    NET_API_STATUS  Status;
    HANDLE          hFileFindContext;
    LPBYTE          pbBuffer;
    LPBYTE          pbStringsOffset;
    PAT_ENUM        pAtEnum;
    DWORD           cbBufferSize;
    DWORD           cbCommandSize;
    DWORD           cJobsEnumerated;
    DWORD           iEnumContext;
    DWORD           i;
    DWORD           rgFlags;
    HRESULT         hr;

    Status          = NERR_Success;
    pbBuffer        = NULL;
    cJobsEnumerated = 0;
    i               = 0;

    //
    // pEnumContainer is defined in the IDL file as [in,out] though it
    // should only be [out].  This can't be changed in the IDL file for
    // backwards compatibility, so check it here.  Without this check,
    // we'll leak memory if the user gives a non-NULL buffer.
    //
    if (pEnumContainer->Buffer != NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = AtCheckSecurity(AT_JOB_ENUM);
    if (Status != NERR_Success)
    {
        return ERROR_ACCESS_DENIED;
    }

    if (pResumeHandle != NULL)
    {
        iEnumContext = *pResumeHandle;
    }
    else
    {
        iEnumContext = 0;
    }
    //
    // Allocate one job object that will be reused.
    //
    CJob * pJob = CJob::Create();
    if (pJob == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    EnterCriticalSection(&gcsNetScheduleCritSection);

    //
    // Compute the total number of At jobs (i.e., the number of At jobs in
    // the At subdirectory). This number is used to update the pTotalEntries
    // argument, and may be used for enumeration buffer size computation.
    //

    DWORD cAtJobTotal = 0;

    hFileFindContext = FindFirstFile(g_wszAtJobSearchPath, &fd);

    if (hFileFindContext == INVALID_HANDLE_VALUE)
    {
        //
        // Nothing to enumerate.
        //
        *pTotalEntries = 0;
        goto EnumExit;
    }

    do
    {
        //
        // If somebody renamed an At job, don't enumerate it.  This is to
        // prevent us from returning duplicate IDs as a result of finding jobs
        // like At1.job and At01.job.
        //

        if (!IsValidAtFilename(fd.cFileName))
        {
            continue;
        }

        hr = LoadAtJob(pJob, fd.cFileName);
        if (FAILED(hr))
        {
            ERR_OUT("NetrJobEnum: pJob->Load", hr);
            Status = WIN32_FROM_HRESULT(hr);
            FindClose(hFileFindContext);
            goto EnumExit;
        }

        pJob->GetAllFlags(&rgFlags);

        if (rgFlags & JOB_I_FLAG_NET_SCHEDULE)
        {
            cAtJobTotal++;
        }
    } while (FindNextFile(hFileFindContext, &fd));

    FindClose(hFileFindContext);

    if (!cAtJobTotal)
    {
        //
        // Nothing to enumerate.
        //
        *pTotalEntries = 0;
        goto EnumExit;
    }

    //
    // Get buffer size.
    //

    if (PreferredMaximumLength != -1)
    {
        //
        // Caller has specified a preferred buffer size.
        //

       // 02/05/01-jbenton : buffer size must be even to avoid
	   // alignment errors. (bug 303146).
        cbBufferSize = ROUND_DOWN_COUNT(PreferredMaximumLength, ALIGN_WCHAR);
    }
    else
    {
        //
        // Compute a "best-guess" buffer size to return all of the data.
        // If we underestimate the buffer size, we'll return as much data
        // as the buffer allows, plus a return code of ERROR_MORE_DATA.
        //

        cbBufferSize = (sizeof(AT_ENUM) + COMMAND_STRING_LENGTH_APPROX) *
                                cAtJobTotal;
    }

    //
    // Restrict buffer size.
    //

    cbBufferSize = (DWORD)max(cbBufferSize, BUFFER_LENGTH_MINIMUM);
    cbBufferSize = min(cbBufferSize, BUFFER_LENGTH_MAXIMUM);

    //
    // The enumeration context is utilized as an index in the find first/next
    // file result. If non-zero, enumerate the directory until the number
    // of AT jobs enumerated equals the caller's enumeration context.
    //
    // BUGBUG : This is quite a departure from the existing At service, but
    //          I'm confident it should not present a problem. Note for
    //          review.
    //
    // Seek to the enumeration context index.
    //

    hFileFindContext = FindFirstFile(g_wszAtJobSearchPath, &fd);

    if (hFileFindContext == INVALID_HANDLE_VALUE)
    {
        //
        // Nothing to enumerate.
        //
        *pTotalEntries = 0;
        goto EnumExit;
    }

    i = 0;
    do
    {
        if (!IsValidAtFilename(fd.cFileName))
        {
            continue;
        }

        hr = LoadAtJob(pJob, fd.cFileName);
        if (FAILED(hr))
        {
            ERR_OUT("NetrJobEnum: pJob->Load", hr);
            Status = WIN32_FROM_HRESULT(hr);
            FindClose(hFileFindContext);
            goto EnumExit;
        }

        pJob->GetAllFlags(&rgFlags);

        if (rgFlags & JOB_I_FLAG_NET_SCHEDULE)
        {
            i++;

            if (i > iEnumContext)
            {
                break;
            }
        }

    } while (FindNextFile(hFileFindContext, &fd));

    if (i <= iEnumContext)
    {
        //
        // The above enumeration seek failed to find any more AT jobs
        // beyond the Resume handle count. Thus, the enumeration is
        // complete. Nothing else to enumerate.
        //

        FindClose(hFileFindContext);
        *pTotalEntries = 0;
        goto EnumExit;
    }

    //
    // Update pTotalEntries argument. It is the difference between the total
    // number of jobs and the number of jobs previously enumerated.
    //

    *pTotalEntries = cAtJobTotal - i + 1;

    pbBuffer = (LPBYTE)MIDL_user_allocate(cbBufferSize);

    if (pbBuffer == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CHECK_HRESULT(HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
        goto EnumExit;
    }

    //
    // Begin the enumeration.
    //

    pbStringsOffset = pbBuffer + cbBufferSize;
    pAtEnum = (PAT_ENUM)pbBuffer;

    //
    // To have arrived here, the resume handle seek above will have left us
    // a valid AT job object in pJob and the corresponding rgFlags.
    //
    do
    {
        if (rgFlags & JOB_I_FLAG_NET_SCHEDULE)
        {
            if (pbStringsOffset <= (LPBYTE)pAtEnum + sizeof(AT_ENUM))
            {
                //
                // Buffer full.
                //

                Status = ERROR_MORE_DATA;
                break;
            }

            //
            // Get At job information.
            //

            DWORD CommandSize = MAX_PATH + 1;
            AT_INFO         AtInfo;

            hr = pJob->GetAtInfo(&AtInfo, wszCommand, &CommandSize);

            if (SUCCEEDED(hr))
            {
                //
                // Copy fixed portion.
                //

                pAtEnum->JobId       = GetAtJobIdFromFileName(fd.cFileName);
                pAtEnum->JobTime     = AtInfo.JobTime;
                pAtEnum->DaysOfMonth = AtInfo.DaysOfMonth;
                pAtEnum->DaysOfWeek  = AtInfo.DaysOfWeek;
                pAtEnum->Flags       = AtInfo.Flags;

                //
                // Copy variable data.
                //

                BOOL fRet = NetpCopyStringToBuffer(
                                            wszCommand,
                                            CommandSize,
                                            (LPBYTE)(pAtEnum + 1),
                                            (LPWSTR *)&pbStringsOffset,
                                            &pAtEnum->Command);

                if (!fRet)
                {
                    Status = ERROR_MORE_DATA;
                    break;
                }

                pAtEnum++; cJobsEnumerated++; iEnumContext++;
            }
        }

        //
        // Get the next filename, skipping any that have been renamed
        //

        BOOL fFoundAnotherAtJob;

        while (fFoundAnotherAtJob = FindNextFile(hFileFindContext, &fd))
        {
            if (IsValidAtFilename(fd.cFileName))
            {
                break;
            }
        }

        if (!fFoundAnotherAtJob)
        {
            //
            // No more files.
            //
            break;
        }

        hr = LoadAtJob(pJob, fd.cFileName);
        if (FAILED(hr))
        {
            ERR_OUT("NetrJobEnum: pJob->Load", hr);
            Status = WIN32_FROM_HRESULT(hr);
            FindClose(hFileFindContext);
            goto EnumExit;
        }

        pJob->GetAllFlags(&rgFlags);

    } while (TRUE);

    FindClose(hFileFindContext);

    //
    // Reset enumeration context if everything has been read.
    //

    if (Status == NERR_Success)
    {
        iEnumContext = 0;
    }

EnumExit:

    LeaveCriticalSection(&gcsNetScheduleCritSection);

    if (pJob)
    {
        pJob->Release();
    }

    pEnumContainer->EntriesRead = cJobsEnumerated;

    if (cJobsEnumerated == 0 && pbBuffer != NULL)
    {
        MIDL_user_free(pbBuffer);
        pbBuffer = NULL;
    }

    pEnumContainer->Buffer = (LPAT_ENUM)pbBuffer;

    if (pResumeHandle != NULL)
    {
        *pResumeHandle = iEnumContext;
    }

    return(Status);
}




//+---------------------------------------------------------------------------
//
//  RPC:        NetrJobGetInfo
//
//  Synopsis:   Get information on an At job.
//
//  Arguments:  [ServerName] -- Unused.
//              [JobId]      -- Target At job.
//              [ppAtInfo]   -- Returned information.
//
//  Returns:    BUGBUG : Problem here too with HRESULTs mapped to WIN32 status
//                       codes.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
NET_API_STATUS
NetrJobGetInfo(ATSVC_HANDLE ServerName, DWORD JobId, LPAT_INFO * ppAtInfo)
{
    schDebugOut((DEB_ITRACE,
        "NetrJobGetInfo ServerName(%ws), JobId(%d)\n",
        (ServerName != NULL) ? ServerName : L"(local)",
        JobId));

    UNREFERENCED_PARAMETER(ServerName);

    AT_INFO         AtInfo;
    PAT_INFO        pAtInfo;
    NET_API_STATUS  Status;
    WCHAR           wszPath[MAX_PATH + 1];
    WCHAR           wszCommand[MAX_PATH + 1];
    WCHAR           wszJobId[10 + 1];
    DWORD           CommandSize;
    HRESULT         hr;

    Status  = NERR_Success;
    pAtInfo = NULL;

    Status = AtCheckSecurity(AT_JOB_GET_INFO);
    if (Status != NERR_Success)
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Create the file name from the ID.
    //
    CreateAtJobPath(JobId, wszPath);
    schDebugOut((DEB_ITRACE, "At job name: %S\n", wszPath));

    EnterCriticalSection(&gcsNetScheduleCritSection);

    //
    // Ensure the job object exists in storage.
    //

    if (GetFileAttributes(wszPath) == -1 &&
        GetLastError() == ERROR_FILE_NOT_FOUND)
    {
        //
        // Job object does not exist.
        //

        Status = APE_AT_ID_NOT_FOUND;
        CHECK_HRESULT(HRESULT_FROM_WIN32(Status));
        goto GetInfoExit;
    }

    //
    // Command size. A character count throughout the call to GetAtJob;
    // a byte count thereafter.
    //

    CommandSize = MAX_PATH + 1;

    //
    // Get At job information.
    //

    hr = g_pSched->m_pSch->GetAtJob(wszPath, &AtInfo, wszCommand, &CommandSize);

    if (FAILED(hr))
    {
        //
        // Convert the HRESULT to a WIN32 status code.
        //

        Status = WIN32_FROM_HRESULT(hr);

        if (Status == ERROR_FILE_NOT_FOUND)
        {
            Status = APE_AT_ID_NOT_FOUND;
        }
        goto GetInfoExit;
    }

    CommandSize *= sizeof(WCHAR);   // Character count -> Byte count

    pAtInfo = (PAT_INFO)MIDL_user_allocate(sizeof(AT_INFO) + CommandSize);

    if (pAtInfo == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CHECK_HRESULT(HRESULT_FROM_WIN32(Status));
        goto GetInfoExit;
    }

    *pAtInfo = AtInfo;

    pAtInfo->Command = (LPWSTR)(pAtInfo + 1);

    CopyMemory(pAtInfo->Command, wszCommand, CommandSize);


GetInfoExit:

    LeaveCriticalSection(&gcsNetScheduleCritSection);

    *ppAtInfo = pAtInfo;

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetAtJobIdFromFileName
//
//  Synopsis:   Return the DWORD At job id from an At filename. At filenames
//              are named according the following convention: "At<nnnn>.Job".
//              The "<nnnn>" portion is the At job id in string form.
//              eg: "At132.Job"
//
//  Arguments:  [pwszAtFileName] -- At path/filename.
//
//  Returns:    Non-zero At job id.
//              Zero if the filename is not recognized as an At filename.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD
GetAtJobIdFromFileName(WCHAR * pwszAtFileName)
{
    static ULONG ccAtJobFilenamePrefix = 0;

    schAssert(pwszAtFileName != NULL);

    if (ccAtJobFilenamePrefix == 0)
    {
        ccAtJobFilenamePrefix = ARRAY_LEN(TSZ_AT_JOB_PREFIX) - 1;
    }

    //
    // Refer to the last (right-most) path element.
    //

    WCHAR * pwsz = wcsrchr(pwszAtFileName, L'\\');

    if (pwsz == NULL)
    {
        pwsz = pwszAtFileName;
    }

    //
    // Skip past the "At" filename portion.
    //

    if (_wcsnicmp(pwsz, TSZ_AT_JOB_PREFIX, ccAtJobFilenamePrefix) == 0)
    {
        pwsz += ccAtJobFilenamePrefix;
    }
    else
    {
        //
        // Unknown filename. At least, it's known if this is an At job.
        // Proceed no further.
        //

        return(0);
    }

    //
    // Isolate the At job Id portion of the path. Do so by temporarilly
    // replacing the extension period character with a null character.
    //

    WCHAR * pwszExt = wcsrchr(pwsz, L'.');

    if (pwszExt != NULL)
    {
        *pwszExt = L'\0';
    }

    //
    // Convert the Id to integer from string form.
    //

    DWORD AtJobId = _wtol(pwsz);

    //
    // Restore period character.
    //

    if (pwszExt != NULL)
    {
        *pwszExt = L'.';
    }

    return(AtJobId);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAtJobPath
//
//  Synopsis:   Constructs a path in the form:
//                  "...\Jobs\At_Jobs\At<nnnn>.job"
//              where <nnnn> is the At job id.
//
//  Arguments:  [JobId]    -- At job Id.
//              [pwszPath] -- Returned path.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CreateAtJobPath(DWORD JobId, WCHAR * pwszPath)
{
    WCHAR wszJobId[10 + 1];

    wsprintf(wszJobId, L"%d", JobId);

    wcscpy(pwszPath, gpwszAtJobPathTemplate);
    wcscat(pwszPath, wszJobId);
    wcscat(pwszPath, TSZ_DOTJOB);
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeNetScheduleApi
//
//  Synopsis:   Initializes globals used by the server-side NetScheduleXXX.
//              Associated globals:
//
//              gpwszAtJobPathTemplate    -- Used to construct full paths to
//                                           At jobs in the At jobs directory.
//                                           (eg: "...\At_Jobs\At")
//              gcsNetScheduleCritSection -- Used to serialize thread access
//                                           to server-side NetScheduleXXX
//                                           RPC.
//
//  Arguments:  None.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
InitializeNetScheduleApi(void)
{
    WCHAR   wszBuffer[MAX_PATH + 1];
    ULONG   ccAtJobPathTemplate;
    HRESULT hr;

    NET_API_STATUS Status;

    Status = AtCreateSecurityObject();

    if (Status != NERR_Success)
    {
        hr = Status;
        CHECK_HRESULT(hr);
        goto InitializeError;
    }

    schAssert(g_TasksFolderInfo.ptszPath);

    ULONG ccFolderPath;
    ccFolderPath = wcslen(g_TasksFolderInfo.ptszPath);

    //
    // Create the At job path template. For use in NetScheduleJobAdd/Del.
    // Example: "<Job Folder Path>\At". To which the Job Id (string form) +
    // the ".job" extension is appended.
    //

    ccAtJobPathTemplate = wcslen(g_TasksFolderInfo.ptszPath) +
                          ARRAY_LEN(TSZ_AT_JOB_PREFIX)       +
                          1;  // '\' + null terminator

    gpwszAtJobPathTemplate = new WCHAR[ccAtJobPathTemplate];

    if (gpwszAtJobPathTemplate == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        goto InitializeError;
    }

    wcscpy(gpwszAtJobPathTemplate, g_TasksFolderInfo.ptszPath);
    wcscat(gpwszAtJobPathTemplate, BACKSLASH_STR TSZ_AT_JOB_PREFIX);

    //
    // Register the Event Source, which is used to report NetSchedule
    // errors in the event log - for NT4 ATSVC compatibility
    //

    g_hAtEventSource = RegisterEventSource(NULL, SCHEDULE_EVENTLOG_NAME);
    if (g_hAtEventSource == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto InitializeError;
    }

    //
    // Note that the last error exit above is if the allocation of
    // gpwszAtJobPathTemplate fails. Thus, if gpwszAtJobPathTemplate is
    // non-null, then the critical section has been initialized.
    // UninitializeNetScheduleApi depends on this behavior.
    //
    InitializeCriticalSection(&gcsNetScheduleCritSection);

    return(S_OK);

InitializeError:

    if (gpwszAtJobPathTemplate != NULL)
    {
        delete gpwszAtJobPathTemplate;
	gpwszAtJobPathTemplate = NULL;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitializeNetScheduleApi
//
//  Synopsis:   Un-does work done in InitializeNetScheduleApi.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
UninitializeNetScheduleApi(void)
{
    //
    // Clean up the event logging for downlevel jobs
    //

    if (g_hAtEventSource != NULL)
    {
        DeregisterEventSource(g_hAtEventSource);
        g_hAtEventSource = NULL;
    }

    if (gpwszAtJobPathTemplate != NULL)
    {
        delete gpwszAtJobPathTemplate;
        gpwszAtJobPathTemplate = NULL;
        //
        // If gpwszAtJobPathTemplate is non-null, then the critical section
        // has been initialized.
        //
        DeleteCriticalSection(&gcsNetScheduleCritSection);
    }

    AtDeleteSecurityObject();
}


//+---------------------------------------------------------------------------
//
//  Function:   IsAdminFileOwner
//
//  Synopsis:   Ensure the file owner is an adminstrator. Currently used to
//              determine if AT jobs are owned by administrators. Local system
//              ownership is allowed as well.
//
//  Arguments:  [pwszFile] -- Checked file.
//
//  Returns:    TRUE  -- The owner is an admin or local system.
//              FALSE -- The owner isn't an admin or local system, or the
//                       attempt to confirm ownership identity failed.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
IsAdminFileOwner(LPCWSTR pwszFile)
{
#define SECDESCR_STACK_BUFFER_SIZE  512

    BYTE                 rgbBuffer[SECDESCR_STACK_BUFFER_SIZE];
    PSECURITY_DESCRIPTOR pOwnerSecDescr = rgbBuffer;
    DWORD                cbSize       = SECDESCR_STACK_BUFFER_SIZE;
    DWORD                cbSizeNeeded = 0;
    BOOL                 fAllocatedBuffer;

    if (GetFileSecurity(pwszFile,
                        OWNER_SECURITY_INFORMATION,
                        pOwnerSecDescr,
                        cbSize,
                        &cbSizeNeeded))
    {
        //
        // The information fit within the stack-allocated buffer.
        // This should cover 90% of the cases.
        //
    }
    else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER && cbSizeNeeded)
    {
        //
        // Too much data. We'll need to allocate memory on the heap.
        //

        fAllocatedBuffer = TRUE;
        pOwnerSecDescr = (SECURITY_DESCRIPTOR *)new BYTE[cbSizeNeeded];

        if (pOwnerSecDescr == NULL)
        {
            return FALSE;
        }

        if (!GetFileSecurity(pwszFile,
                             OWNER_SECURITY_INFORMATION,
                             pOwnerSecDescr,
                             cbSizeNeeded,
                             &cbSizeNeeded))
        {
            delete pOwnerSecDescr;
            return FALSE;
        }
    }
    else
    {
        //
        // An unexpected error occurred. Disallow access.
        //

        return FALSE;
    }

    //
    // Get the owner sid.
    //

    PSID pOwnerSid;
    BOOL fOwnerDefaulted;
    BOOL fRet = FALSE;

    if (GetSecurityDescriptorOwner(pOwnerSecDescr, &pOwnerSid,
                                    &fOwnerDefaulted))
    {
        if (IsValidSid(pOwnerSid))
        {
            //
            // Enumerate the subauthorities to check for the admin RID.
            //

            for (DWORD i = *GetSidSubAuthorityCount(pOwnerSid); i; i--)
            {
                DWORD SubAuthority = *GetSidSubAuthority(pOwnerSid, i);

                if (SubAuthority == DOMAIN_ALIAS_RID_ADMINS ||
                    SubAuthority == SECURITY_LOCAL_SYSTEM_RID)
                {
                    //
                    // Done. Owner is an admin or local system.
                    //

                    fRet = TRUE;
                    break;
                }
            }
        }
    }

    if (pOwnerSecDescr != rgbBuffer)
    {
        delete pOwnerSecDescr;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\lsa.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       lsa.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:  None.
//
//  History:    15-May-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <ntsecapi.h>
#include <mstask.h>
#include <msterr.h>

#include "lsa.hxx"
#include "debug.hxx"
#if DBG
class CTask;
#include "proto.hxx"
#endif

// Maximum secret size.
//
#define MAX_SECRET_SIZE 65536

BYTE grgbDeletedEntryMarker[] =
    { 'D', 'E', 'L', 'E', 'T', 'E', 'D', '_', 'E', 'N', 'T', 'R', 'Y' };

static WCHAR gwszSAI[] = L"SAI";
static WCHAR gwszSAC[] = L"SAC";


//+---------------------------------------------------------------------------
//
//  Function:   ReadSecurityDBase
//
//  Synopsis:
//
//  Arguments:  [pcbSAI] --
//              [ppbSAI] --
//              [pcbSAC] --
//              [ppbSAC] --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
ReadSecurityDBase(
    DWORD * pcbSAI,
    BYTE ** ppbSAI,
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    HRESULT hr;

    *ppbSAI = *ppbSAC = NULL;

    // Read the SAC.
    //
    hr = ReadLsaData(sizeof(gwszSAC), gwszSAC, pcbSAC, ppbSAC);

    if (SUCCEEDED(hr))
    {
        // Read the SAI.
        //
        hr = ReadLsaData(sizeof(gwszSAI), gwszSAI, pcbSAI, ppbSAI);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Check the sizes. For sizes greater than zero, but less than the
        // header size, deallocate the memory and zero the returned sizes,
        // ptrs.
        //
        // This seems inefficient, but it saves quite a few checks in the
        // SAC/SAI API.
        //

        if (*pcbSAI && *pcbSAI <= SAI_HEADER_SIZE)
        {
            *pcbSAI = 0;
            LocalFree(*ppbSAI);
            *ppbSAI = NULL;
        }

        if (*pcbSAC && *pcbSAC <= SAC_HEADER_SIZE)
        {
            *pcbSAC = 0;
            LocalFree(*ppbSAC);
            *ppbSAC = NULL;
        }

        //
        // Ensure the databases are in sync. The first DWORD is a USN (Update
        // Sequence Number). Its value increases monatonically for every
        // write to the LSA. The SAI & SAC USN values must be equal. If not,
        // they are out of sync with each other - an unrecoverable problem.
        //

        if (((*ppbSAI != NULL && *ppbSAC == NULL)  ||
             (*ppbSAI == NULL && *ppbSAC != NULL)) ||
            (*ppbSAI != NULL && *ppbSAC != NULL &&
             (DWORD)**ppbSAI != (DWORD)**ppbSAC))
        {
            schAssert(0 && "Scheduling Agent security database out of sync!");
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
        }
    }

    if (FAILED(hr))
    {
        if (*ppbSAI != NULL) LocalFree(*ppbSAI);
        if (*ppbSAC != NULL) LocalFree(*ppbSAC);
        *ppbSAI = *ppbSAC = NULL;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteSecurityDBase
//
//  Synopsis:
//
//  Arguments:  [cbSAI] --
//              [pbSAI] --
//              [cbSAC] --
//              [pbSAC] --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
WriteSecurityDBase(
    DWORD  cbSAI,
    BYTE * pbSAI,
    DWORD  cbSAC,
    BYTE * pbSAC)
{
    HRESULT hr;

    //
    // Advance the USN (Update Sequence Numbers) on the SAI & SAC. They
    // should always remain equal. Otherwise, they'll be out of sync
    // with each other - an unrecoverable problem.
    //

    (DWORD)(*pbSAI)++;
    (DWORD)(*pbSAC)++;

    // Write the SAC.
    //
    hr = WriteLsaData(sizeof(gwszSAC), gwszSAC, cbSAC, pbSAC);

    if (SUCCEEDED(hr))
    {
        // Write the SAI.
        //
        hr = WriteLsaData(sizeof(gwszSAI), gwszSAI, cbSAI, pbSAI);
    }

    // LogDebug3("WriteSecurityDBase returning %#lx, wrote %lu, %lu bytes", hr, cbSAI, cbSAC);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadLsaData
//
//  Synopsis:
//
//  Arguments:  [cbKey]   --
//              [pwszKey] --
//              [pcbData] --
//              [ppbData] --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
ReadLsaData(WORD cbKey, LPCWSTR pwszKey, DWORD * pcbData, BYTE ** ppbData)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes = {
        sizeof(LSA_OBJECT_ATTRIBUTES),
        NULL,
        NULL,
        0L,
        NULL,
        NULL
    };
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    PLSA_UNICODE_STRING   psData;
    NTSTATUS              Status;

    //
    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    //

    sKey.Length        = cbKey;
    sKey.MaximumLength = cbKey;
    sKey.Buffer        = (LPWSTR)pwszKey;

    //
    // Open the LSA.
    //

    Status = LsaOpenPolicy(NULL,
                           &ObjectAttributes,
                           POLICY_GET_PRIVATE_INFORMATION,
                           &hPolicy);

    if (!(Status >= 0))
    {
        return(E_FAIL);
    }

    //
    // Retrieve the LSA data associated with the key passed.
    //

    Status = LsaRetrievePrivateData(hPolicy, &sKey, &psData);

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
        (Status >= 0 && psData == NULL))
    {
        LsaClose(hPolicy);
        *pcbData = 0;
        *ppbData = NULL;
        return(S_FALSE);
    }
    else if (!(Status >= 0))
    {
        LsaClose(hPolicy);
        return(E_FAIL);
    }

    LsaClose(hPolicy);

    //
    // Create a copy of the LSA data to return. Why? The LSA private data
    // is callee allocated, so we are not free to reallocate the memory
    // as-needed.
    //

    BYTE * pbData = (BYTE *)LocalAlloc(LMEM_FIXED, psData->Length);

    if (pbData == NULL)
    {
        LsaFreeMemory(psData);
        return(E_OUTOFMEMORY);
    }

    HRESULT hr = S_OK;

    //
    // Wrapping in a try/except in case the data read from the LSA is bad.
    //

    __try
    {
        CopyMemory(pbData, psData->Buffer, psData->Length);

        //
        // Update out ptrs.
        //
        // NB : Making the assignment in here to save on an rc check.
        //

        *pcbData = psData->Length;
        *ppbData = pbData;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        schAssert(0 &&
                  "Exception reading Scheduling Agent security database!");
        hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
    }

    LsaFreeMemory(psData);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteLsaData
//
//  Synopsis:
//
//  Arguments:  [cbKey]   --
//              [pwszKey] --
//              [cbData]  --
//              [pbData]  --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
WriteLsaData(WORD cbKey, LPCWSTR pwszKey, DWORD cbData, BYTE * pbData)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes = {
        sizeof(LSA_OBJECT_ATTRIBUTES),
        NULL,
        NULL,
        0L,
        NULL,
        NULL
    };
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    LSA_UNICODE_STRING    sData;
    NTSTATUS              Status;

    //
    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    //

    sKey.Length        = cbKey;
    sKey.MaximumLength = cbKey;
    sKey.Buffer        = (LPWSTR)pwszKey;

    sData.Length        = (WORD)cbData;
    sData.MaximumLength = (WORD)cbData;
    sData.Buffer        = (WCHAR *)pbData;

    //
    // Open the LSA.
    //

    Status = LsaOpenPolicy(NULL,
                           &ObjectAttributes,
                           POLICY_CREATE_SECRET,
                           &hPolicy);

    if (!(Status >= 0))
    {
        return(E_FAIL);
    }

    //
    // Write the LSA data associated with the key passed.
    //

    Status = LsaStorePrivateData(hPolicy, &sKey, &sData);

    if (!(Status >= 0))
    {
        LsaClose(hPolicy);
        return(E_FAIL);
    }

    LsaClose(hPolicy);

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACAddCredential
//
//  Synopsis:
//
//  Arguments:  [pbCredentialIdentity] --
//              [cbCredential]         --
//              [pbCredential]         --
//              [pcbSAC]               --
//              [ppbSAC]               --
//
//  Notes:      try/except unnecessary here. Memory writes are guaranteed to
//              remain within the buffer allocated.
//
//----------------------------------------------------------------------------
HRESULT
SACAddCredential(
    BYTE *  pbCredentialIdentity,
    DWORD   cbEncryptedData,
    BYTE *  pbEncryptedData,
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    DWORD dwCredentialCount = 1;
    DWORD cbCredentialSize  = HASH_DATA_SIZE + cbEncryptedData;

    //
    // Make room for the new credential.
    //

    DWORD  cbSACNew;
    BYTE * pbSACNew;

    cbSACNew = *pcbSAC + sizeof(cbCredentialSize) + cbCredentialSize;

    //
    // Check for maximum size. The LSA handles at most 64K.
    //

    if (cbSACNew > MAX_SECRET_SIZE)
    {
        // BUGBUG : Create a new error code for this error, something like
        // SCHED_E_CRED_LIMIT_EXCEEDED: "The system limit on the storage space 
        // for task account information has been reached."
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    if (*pcbSAC == 0)
    {
        cbSACNew += SAC_HEADER_SIZE;
        pbSACNew = (BYTE *)LocalAlloc(LMEM_FIXED, cbSACNew);

        if (pbSACNew == NULL)
        {
            return(E_OUTOFMEMORY);
        }

        //
        // Zero out the header.
        //

        memset(pbSACNew, 0, SAC_HEADER_SIZE);
    }
    else
    {
        pbSACNew = (BYTE *)LocalReAlloc(*ppbSAC, cbSACNew, LMEM_MOVEABLE);

        if (pbSACNew == NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    //
    // Adjust total credential count & prepare to write the credential.
    //

    BYTE * pbCredentialSizePos;

    if (*pcbSAC == 0)
    {
        //
        // First entry.
        //   - Write entry after header.
        //   - Initialize credential count to one (in declaration above).
        //

        pbCredentialSizePos = pbSACNew + SAC_HEADER_SIZE;
    }
    else
    {
        //
        // Append entry.
        //  - Append after last credential entry.
        //  - Increase credential count by one.
        //

        pbCredentialSizePos = pbSACNew + *pcbSAC;
        CopyMemory(&dwCredentialCount, pbSACNew + USN_SIZE,
                   sizeof(dwCredentialCount));
        dwCredentialCount++;
    }

    BYTE * pbCredentialIdentityPos;
    pbCredentialIdentityPos = pbCredentialSizePos + sizeof(cbCredentialSize);

    //
    // Update total credential count.
    //

    CopyMemory(pbSACNew + USN_SIZE, &dwCredentialCount,
                    sizeof(dwCredentialCount));

    // Write total credential size, excluding the size value itself.
    //
    CopyMemory(pbCredentialSizePos, &cbCredentialSize,
                    sizeof(cbCredentialSize));

    // Write credential identity.
    //
    CopyMemory(pbCredentialIdentityPos, pbCredentialIdentity,
                        HASH_DATA_SIZE);

    // Finally, write encrypted credentials.
    //
    CopyMemory(pbCredentialIdentityPos + HASH_DATA_SIZE, pbEncryptedData,
                    cbEncryptedData);

    // Update out pointers.
    //
    *pcbSAC = cbSACNew;
    *ppbSAC = pbSACNew;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACIndexCredential
//
//  Synopsis:
//
//  Arguments:  [dwCredentialIndex]  --
//              [cbSAC]              --
//              [pbSAC]              --
//              [pcbCredential]      --
//              [ppbFoundCredential] --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SACIndexCredential(
    DWORD   dwCredentialIndex,
    DWORD   cbSAC,
    BYTE *  pbSAC,
    DWORD * pcbCredential,
    BYTE ** ppbFoundCredential)
{
    HRESULT hr = S_FALSE;

    if (ppbFoundCredential != NULL) *ppbFoundCredential = NULL;

    if (cbSAC <= SAC_HEADER_SIZE || pbSAC == NULL)
    {
        return(hr);
    }

    BYTE * pbSACEnd = pbSAC + cbSAC;
    BYTE * pb       = pbSAC + USN_SIZE;       // Advance past USN.

    //
    // Read credential count.
    //

    DWORD dwCredentialCount;
    CopyMemory(&dwCredentialCount, pb, sizeof(dwCredentialCount));
    pb += sizeof(dwCredentialCount);

    //
    // Seek to credential index within the credential array.
    //

    DWORD cbCredentialSize;

    for (DWORD i = 0; (i < dwCredentialIndex) && (i < dwCredentialCount) &&
                ((DWORD)(pb - pbSAC) < cbSAC); i++)
    {
        //
        // Advance to next credential.
        //
        // First, ensure sufficient space remains in the buffer.
        //

        if ((pb + sizeof(cbCredentialSize)) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        CopyMemory(&cbCredentialSize, pb, sizeof(cbCredentialSize));
        pb += sizeof(cbCredentialSize) + cbCredentialSize;
    }

    if ((i == dwCredentialIndex) && (i < dwCredentialCount) &&
                ((DWORD)(pb - pbSAC) < cbSAC))
    {
        //
        // Found it, but ensure the contents referenced are valid.
        // Do so by checking remaining size.
        //

        CopyMemory(&cbCredentialSize, pb, sizeof(cbCredentialSize));
        pb += sizeof(cbCredentialSize);

        if ((pb + cbCredentialSize) <= (pbSAC + cbSAC))
        {
            // Set the credential  & credential size return ptrs.
            //
            *pcbCredential = cbCredentialSize;

            // Optionally return a ptr to the credential.
            //
            if (ppbFoundCredential != NULL)
            {
                *ppbFoundCredential = pb;
            }
            hr = S_OK;
        }
        else
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
        }
    }
    else if ((i != dwCredentialCount) || ((DWORD)(pb - pbSAC) != cbSAC))
    {
        //
        // The database appears to be truncated.
        //

        ASSERT_SECURITY_DBASE_CORRUPT();
        hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACFindCredential
//
//  Synopsis:
//
//  Arguments:  [pbCredentialIdentity] --
//              [cbSAC]                --
//              [pbSAC]                --
//              [pdwCredentialIndex]   --
//              [pcbEncryptedData]     --
//              [ppbFoundCredential]   --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SACFindCredential(
    BYTE *  pbCredentialIdentity,
    DWORD   cbSAC,
    BYTE *  pbSAC,
    DWORD * pdwCredentialIndex,
    DWORD * pcbEncryptedData,
    BYTE ** ppbFoundCredential)
{
    HRESULT hr = S_FALSE;

    if (ppbFoundCredential != NULL) *ppbFoundCredential = NULL;

    if (cbSAC <= SAC_HEADER_SIZE || pbSAC == NULL)
    {
        return(hr);
    }

    BYTE * pbSACEnd = pbSAC + cbSAC;
    BYTE * pb       = pbSAC + USN_SIZE;     // Advance past USN.

    //
    // Read credential count.
    //

    DWORD dwCredentialCount;
    CopyMemory(&dwCredentialCount, pb, sizeof(dwCredentialCount));
    pb += sizeof(dwCredentialCount);

    //
    // Iterate the SAC credentials for a match against the passed credential
    // identity.
    //

    DWORD cbCredentialSize;

    for (DWORD i = 0; (i < dwCredentialCount) &&
         ((DWORD)(pb - pbSAC) < cbSAC); i++)
    {
        //
        // Ensure sufficient space remains in the buffer.
        //

        if ((pb + sizeof(cbCredentialSize)) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        CopyMemory(&cbCredentialSize, pb, sizeof(cbCredentialSize));
        pb += sizeof(cbCredentialSize);

        //
        // Check remaining buffer size prior to the comparison.
        //

        if ((pb + HASH_DATA_SIZE) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        BOOL fFound;
        fFound = (memcmp(pb, pbCredentialIdentity, HASH_DATA_SIZE) == 0);

        pb += HASH_DATA_SIZE;
        cbCredentialSize -= HASH_DATA_SIZE; // Subtract identity size.
                                            // Equals the encrypted data
                                            // size.

        if (fFound)
        {
            //
            // Found it, but ensure the contents referenced are valid.
            // Do so by checking remaining size.
            //

            if ((pb + cbCredentialSize) > pbSACEnd)
            {
                ASSERT_SECURITY_DBASE_CORRUPT();
                return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
            }

            *pcbEncryptedData   = cbCredentialSize;
            *pdwCredentialIndex = i;
            if (ppbFoundCredential != NULL)
            {
                *ppbFoundCredential = pb;
            }
            return(S_OK);
        }

        //
        // Advance to next credential.
        //

        pb += cbCredentialSize;
    }

    if ((i == dwCredentialCount) && ((DWORD)(pb - pbSAC) != cbSAC) ||
        (i != dwCredentialCount) && ((DWORD)(pb - pbSAC) > cbSAC))
    {
        //
        // The database appears to be truncated.
        //

        ASSERT_SECURITY_DBASE_CORRUPT();
        hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACRemoveCredential
//
//  Synopsis:
//
//  Arguments:  [CredentialIndex] --
//              [pcbSAC]          --
//              [ppbSAC]          --
//
//  Returns:    TBD
//
//  Notes:      try/except unnecessary here since SACIndexCredential will
//              return only valid buffer ptrs.
//
//----------------------------------------------------------------------------
HRESULT
SACRemoveCredential(
    DWORD   CredentialIndex,
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    DWORD   cbCredential;
    BYTE *  pbCredential;
    HRESULT hr;

    //
    // Index the credential in the SAC.
    //

    hr = SACIndexCredential(CredentialIndex, *pcbSAC, *ppbSAC, &cbCredential,
                            &pbCredential);

    if (hr == S_FALSE)
    {
        return(SCHED_E_ACCOUNT_INFORMATION_NOT_SET);
    }
    else if (FAILED(hr))
    {
        return(hr);
    }

    // Overwrite credential with SAC remaining buffer.
    //
    BYTE * pbDest = pbCredential - sizeof(cbCredential);
    BYTE * pbSrc  = pbCredential + cbCredential;

    MoveMemory(pbDest, pbSrc, (*ppbSAC + *pcbSAC) - pbSrc);

    // Decrement SAC credential count.
    //
    DWORD dwCredentialCount;

    CopyMemory(&dwCredentialCount, *ppbSAC + USN_SIZE,
                    sizeof(dwCredentialCount));
    --dwCredentialCount;
    CopyMemory(*ppbSAC + USN_SIZE, &dwCredentialCount,
                    sizeof(dwCredentialCount));

    DWORD cbSACNew = *pcbSAC - (cbCredential + sizeof(cbCredential));

    // Shrink SAC buffer memory with a realloc.
    //
    BYTE * pbSACNew = (BYTE *)LocalReAlloc(*ppbSAC, cbSACNew, LMEM_MOVEABLE);

    if (pbSACNew == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    // Update return ptrs.
    //
    *pcbSAC = cbSACNew;
    *ppbSAC = pbSACNew;

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACUpdateCredential
//
//  Synopsis:
//
//  Arguments:  [cbEncryptedData]  --
//              [pbEncryptedData]  --
//              [cbPrevCredential] --
//              [pbPrevCredential] --
//              [pcbSAC]           --
//              [ppbSAC]           --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SACUpdateCredential(
    DWORD   cbEncryptedData,
    BYTE *  pbEncryptedData,
    DWORD   cbPrevCredential,
    BYTE *  pbPrevCredential,   // Indexes *ppbSAC.
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    DWORD   cbNewCredential = HASH_DATA_SIZE + cbEncryptedData;
    BYTE *  pbSACNew;

    //
    // Ensure the prev credential ptr is within the buffer boundaries.
    // This is probably a redundant check since this ptr was most likely
    // obtained from a call to SACIndex/FindCredential.
    //

    if (*pcbSAC < SAC_HEADER_SIZE                        ||
        pbPrevCredential < (*ppbSAC + SAC_HEADER_SIZE +
                             sizeof(cbNewCredential))    ||
        (pbPrevCredential + cbPrevCredential) > (*ppbSAC + *pcbSAC))
    {
        ASSERT_SECURITY_DBASE_CORRUPT();
        return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
    }

    if (cbNewCredential != cbPrevCredential)
    {
        //
        // Reallocate to either shrink or grow the SAC data.
        //

        DWORD  cbSACNew;
        BYTE * pbDest;
        BYTE * pbSrc;

        if (cbNewCredential > cbPrevCredential)
        {
            //
            // Credential is larger than the previous. Grow the
            // buffer. Must reallocate the buffer FIRST, then
            // relocate contents.
            //

            cbSACNew = *pcbSAC + (cbNewCredential - cbPrevCredential);

            //
            // Keep SAC size in check.
            //

            if (cbSACNew > MAX_SECRET_SIZE)
            {
                // BUGBUG : use new SCHED_E_CRED_LIMIT_EXCEEDED, as above
                return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
            }

            //
            // Save the linear offset to the previous credential
            // from SAC start, in case realloc changes our ptr.
            //

            DWORD cbPrevCredentialOffset;

            cbPrevCredentialOffset = (DWORD)(pbPrevCredential - *ppbSAC);

            pbSACNew = (BYTE *)LocalReAlloc(*ppbSAC, cbSACNew, LMEM_MOVEABLE);

            if (pbSACNew == NULL)
            {
                return(E_OUTOFMEMORY);
            }

            pbPrevCredential = pbSACNew + cbPrevCredentialOffset;

            //
            // Compute start and ending block ptrs for subsequent
            // move.
            //

            pbDest = pbPrevCredential + cbNewCredential;
            pbSrc  = pbPrevCredential + cbPrevCredential;

            //
            // Move remaining buffer up.
            //

            BYTE * pbSACEnd = pbSACNew + *pcbSAC;

            if (pbDest < pbSACEnd)
            {
                MoveMemory(pbDest, pbSrc, pbSACEnd - pbSrc);
            }
        }
        else
        {
            //
            // Credential is smaller than the previous. Shrink the
            // buffer. Must relocate buffer contents FIRST, then
            // realloc.
            //

            cbSACNew = *pcbSAC - (cbPrevCredential - cbNewCredential);

            //
            // Compute start and ending block ptrs for subsequent
            // move.
            //

            pbDest = pbPrevCredential + cbNewCredential;
            pbSrc  = pbPrevCredential + cbPrevCredential;

            //
            // Move remaining buffer down.
            //

            MoveMemory(pbDest, pbSrc, (*ppbSAC + *pcbSAC) - pbSrc);

            pbSACNew = (BYTE *)LocalReAlloc(*ppbSAC, cbSACNew, LMEM_MOVEABLE);

            if (pbSACNew == NULL)
            {
                return(E_OUTOFMEMORY);
            }
        }

        // Update out pointers.
        //
        *pcbSAC = cbSACNew;
        *ppbSAC = pbSACNew;
    }

    //
    // Finally, update the credential.
    //
    // Write the credential size.
    //
    CopyMemory(pbPrevCredential - sizeof(cbNewCredential), &cbNewCredential,
                       sizeof(cbNewCredential));

    // No need to update the credential identity. It has not changed.
    //

    // Write the encrypted bits.
    //
    CopyMemory(pbPrevCredential + HASH_DATA_SIZE, pbEncryptedData,
                       cbEncryptedData);

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SAIAddIdentity
//
//  Synopsis:
//
//  Arguments:  [pbIdentity] --
//              [pcbSAI]     --
//              [ppbSAI]     --
//
//  Notes:      try/except unnecessary here. Memory writes are guaranteed to
//              remain within the buffer allocated.
//
//----------------------------------------------------------------------------
HRESULT
SAIAddIdentity(
    BYTE *  pbIdentity,
    DWORD * pcbSAI,
    BYTE ** ppbSAI)
{
    //
    // Make room for the new identity.
    //

    DWORD  dwSetArrayCount = 1;
    DWORD  dwSetSubCount   = 1; // Equal to one in the case of addition.
    DWORD  cbSAINew;
    BYTE * pbSAINew;

    cbSAINew = *pcbSAI + sizeof(dwSetSubCount) + HASH_DATA_SIZE;

    //
    // Check for maximum size. The LSA handles at most 64K.
    //

    if (cbSAINew > MAX_SECRET_SIZE)
    {
        // BUGBUG : use new SCHED_E_CRED_LIMIT_EXCEEDED, as above
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    if (*pcbSAI == 0)
    {
        cbSAINew += SAI_HEADER_SIZE;
        pbSAINew = (BYTE *)LocalAlloc(LMEM_FIXED, cbSAINew);

        if (pbSAINew == NULL)
        {
            return(E_OUTOFMEMORY);
        }

        //
        // Zero out the header.
        //

        memset(pbSAINew, 0, SAI_HEADER_SIZE);
    }
    else
    {
        pbSAINew = (BYTE *)LocalReAlloc(*ppbSAI, cbSAINew, LMEM_MOVEABLE);

        if (pbSAINew == NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    //
    // Write identity set subcount of one & write identity.
    //

    BYTE * pbSetSubCount;

    if (*pcbSAI == 0)
    {
        //
        // First entry.
        //     - Write entry after header.
        //     - Initialize set array count to one.
        //

        pbSetSubCount = pbSAINew + SAI_HEADER_SIZE;
        CopyMemory(pbSAINew + USN_SIZE, &dwSetArrayCount,
                        sizeof(dwSetArrayCount));
    }
    else
    {
        //
        // Append entry.
        //     - Append after last identity array entry.
        //     - Increase set array count by one.
        //

        pbSetSubCount = pbSAINew + *pcbSAI;
        CopyMemory(&dwSetArrayCount, pbSAINew + USN_SIZE,
                        sizeof(dwSetArrayCount));
        dwSetArrayCount++;
        CopyMemory(pbSAINew + USN_SIZE, &dwSetArrayCount,
                        sizeof(dwSetArrayCount));
    }

    CopyMemory(pbSetSubCount, &dwSetSubCount, sizeof(dwSetSubCount));
    CopyMemory(pbSetSubCount + sizeof(dwSetSubCount), pbIdentity,
                        HASH_DATA_SIZE);

    // Update out ptrs.
    //
    *pcbSAI = cbSAINew;
    *ppbSAI = pbSAINew;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SAIFindIdentity
//
//  Synopsis:
//
//  Arguments:  [pbIdentity]          --
//              [cbSAI]               --
//              [pbSAI]               --
//              [pdwCredentialIndex]  --
//              [pfIsPasswordNull]    --
//              [ppbFoundIdentity]    --
//              [pdwSetSubCount]      --
//              [ppbSet]              --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SAIFindIdentity(
    BYTE *  pbIdentity,
    DWORD   cbSAI,
    BYTE *  pbSAI,
    DWORD * pdwCredentialIndex,
    BOOL *  pfIsPasswordNull,
    BYTE ** ppbFoundIdentity,
    DWORD * pdwSetSubCount,
    BYTE ** ppbSet)
{
    HRESULT hr = S_FALSE;

    if (ppbFoundIdentity != NULL) *ppbFoundIdentity = NULL;

    if (cbSAI <= SAI_HEADER_SIZE || pbSAI == NULL)
    {
        return(hr);
    }

    *pdwCredentialIndex = 0;
    if (pdwSetSubCount != NULL) *pdwSetSubCount = 0;
    if (ppbSet != NULL)         *ppbSet         = NULL;

    BYTE * pbSAIEnd = pbSAI + cbSAI;
    BYTE * pb       = pbSAI + USN_SIZE;       // Advance past USN.

    //
    // Read identity set array count.
    //

    DWORD dwSetArrayCount;
    CopyMemory(&dwSetArrayCount, pb, sizeof(dwSetArrayCount));
    pb += sizeof(dwSetArrayCount);

    //
    // Iterative identity comparison.
    //

    DWORD  dwSetSubCount;

    for (DWORD i = 0;
         (i < dwSetArrayCount) && ((DWORD)(pb - pbSAI) < cbSAI);
         i++)
    {
        //
        // Read identity set subcount.
        //
        // First, ensure sufficient space remains in the buffer.
        //

        if ((pb + sizeof(dwSetSubCount)) > pbSAIEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        BYTE * pbSet;

        CopyMemory(&dwSetSubCount, pb, sizeof(dwSetSubCount));
        pbSet = (pb += sizeof(dwSetSubCount));

        for (DWORD j = 0;
             (j < dwSetSubCount) && ((DWORD)(pb - pbSAI) < cbSAI);
             j++, pb += HASH_DATA_SIZE)
        {
            //
            // Check remaining buffer size prior to the comparison.
            //

            if ((pb + HASH_DATA_SIZE) > pbSAIEnd)
            {
                ASSERT_SECURITY_DBASE_CORRUPT();
                return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
            }

            //
            // We consider the hashed data to be equal even if the last bit
            // is different
            //
            if (memcmp(pb, pbIdentity, HASH_DATA_SIZE - 1) == 0 &&
                ((LAST_HASH_BYTE(pb) ^ LAST_HASH_BYTE(pbIdentity)) & 0xFE) == 0)
            {
                //
                // Found it. No need to further check return ptrs. The
                // buffer size check above accomplished this.
                //

                *pdwCredentialIndex = i;

                if (pfIsPasswordNull != NULL)
                {
                    // Unequal last bits denote a NULL password
                    *pfIsPasswordNull = LAST_HASH_BYTE(pb) ^ LAST_HASH_BYTE(pbIdentity);
                }
                if (pdwSetSubCount != NULL)
                {
                    *pdwSetSubCount = dwSetSubCount;
                }
                if (ppbSet != NULL)
                {
                    *ppbSet = pbSet;
                }

                if (ppbFoundIdentity != NULL)
                {
                    *ppbFoundIdentity = pb;
                }
                return(S_OK);
            }
        }

        //
        // Check for database truncation.
        //

        if ((j != dwSetSubCount) || ((DWORD)(pb - pbSAI) > cbSAI))
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }
    }

    //
    // Check for database truncation.
    //

    if ((i != dwSetArrayCount) || ((DWORD)(pb - pbSAI) != cbSAI))
    {
        ASSERT_SECURITY_DBASE_CORRUPT();
        return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SAIIndexIdentity
//
//  Synopsis:
//
//  Arguments:  [cbSAI]           --
//              [pbSAI]           --
//              [dwSetArrayIndex] --
//              [dwSetIndex]      --
//              [pdwSetSubCount]  --
//              [ppbSet]          --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SAIIndexIdentity(
    DWORD   cbSAI,
    BYTE *  pbSAI,
    DWORD   dwSetArrayIndex,
    DWORD   dwSetIndex,
    BYTE ** ppbFoundIdentity,
    DWORD * pdwSetSubCount,
    BYTE ** ppbSet)
{
    HRESULT hr = S_FALSE;

    if (ppbFoundIdentity != NULL) *ppbFoundIdentity = NULL;

    if (cbSAI <= SAI_HEADER_SIZE || pbSAI == NULL)
    {
        return(hr);
    }

    if (pdwSetSubCount != NULL) *pdwSetSubCount = 0;
    if (ppbSet != NULL)         *ppbSet         = NULL;

    BYTE *  pbSAIEnd = pbSAI + cbSAI;
    BYTE *  pb       = pbSAI + USN_SIZE;      // Advance past USN.

    //
    // Read identity array count.
    //

    DWORD dwSetArrayCount;
    CopyMemory(&dwSetArrayCount, pb, sizeof(dwSetArrayCount));
    pb += sizeof(dwSetArrayCount);

    //
    // Iterative identity comparison.
    //

    for (DWORD i = 0; (i < dwSetArrayCount) &&
         ((DWORD)(pb - pbSAI) < cbSAI); i++)
    {
        DWORD dwSetSubCount;

        //
        // Read identity set subcount.
        // Note, this value may not be on an aligned boundary.
        //
        // First, ensure sufficient space remains in the buffer.
        //

        if ((pb + sizeof(dwSetSubCount)) > pbSAIEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        BYTE * pbSet;

        CopyMemory(&dwSetSubCount, pb, sizeof(dwSetSubCount));
        pbSet = (pb += sizeof(dwSetSubCount));

        DWORD j;
        for (j = 0; (j < dwSetSubCount) && ((DWORD)(pb - pbSAI) < cbSAI);
                        j++, pb += HASH_DATA_SIZE)
        {
            if (i == dwSetArrayIndex && j == dwSetIndex)
            {
                //
                // Found it, but ensure the contents referenced are valid.
                // Do so by checking remaining size.
                //

                if ((pb + HASH_DATA_SIZE) > pbSAIEnd)
                {
                    ASSERT_SECURITY_DBASE_CORRUPT();
                    return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
                }

                if (pdwSetSubCount != NULL)
                {
                    *pdwSetSubCount = dwSetSubCount;
                }
                if (ppbSet != NULL)
                {
                    *ppbSet = pbSet;
                }

                if (ppbFoundIdentity != NULL)
                {
                    *ppbFoundIdentity = pb;
                }
                return(S_OK);
            }
        }

        //
        // Check for database truncation.
        //

        if ((j != dwSetSubCount) || ((DWORD)(pb - pbSAI) > cbSAI))
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }
    }

    //
    // Check for database truncation.
    //

    if ((i != dwSetArrayCount) || ((DWORD)(pb - pbSAI) != cbSAI))
    {
        ASSERT_SECURITY_DBASE_CORRUPT();
        return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SAIInsertIdentity
//
//  Synopsis:
//
//  Arguments:  [pbIdentity] --
//              [pbSAIIndex] --
//              [pcbSAI]     --
//              [ppbSAI]     --
//
//  Notes:      try/except unnecesssary here as checks exist to ensure we
//              remain within the buffer passed.
//
//----------------------------------------------------------------------------
HRESULT
SAIInsertIdentity(
    BYTE *  pbIdentity,
    BYTE *  pbSAIIndex,     // Indexes *ppbSAI.
    DWORD * pcbSAI,
    BYTE ** ppbSAI)
{
    DWORD dwSetSubCount;

    //
    // Check index boundary.
    //

    if (pbSAIIndex < (*ppbSAI + SAI_HEADER_SIZE + sizeof(dwSetSubCount)) ||
        (pbSAIIndex + HASH_DATA_SIZE) > (*ppbSAI + *pcbSAI))
    {
        ASSERT_SECURITY_DBASE_CORRUPT();
        return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
    }

    //
    // Save the linear offset to the identity insertion point from SAI start,
    // in case realloc changes our ptr.
    //

    DWORD cbInsertionOffset = (DWORD)(pbSAIIndex - *ppbSAI);

    //
    // Make room for the new identity.
    //

    DWORD  cbSAINew = *pcbSAI + HASH_DATA_SIZE;
    BYTE * pbSAINew;

    //
    // Check for maximum size. The LSA handles at most 64K.
    //

    if (cbSAINew > MAX_SECRET_SIZE)
    {
        // BUGBUG : use new SCHED_E_CRED_LIMIT_EXCEEDED, as above
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    if (*pcbSAI == 0)
    {
        cbSAINew += SAI_HEADER_SIZE;
        pbSAINew = (BYTE *)LocalAlloc(LMEM_FIXED, cbSAINew);

        if (pbSAINew == NULL)
        {
            return(E_OUTOFMEMORY);
        }

        //
        // Zero out the header.
        //

        memset(pbSAINew, 0, SAI_HEADER_SIZE);
    }
    else
    {
        pbSAINew = (BYTE *)LocalReAlloc(*ppbSAI, cbSAINew, LMEM_MOVEABLE);

        if (pbSAINew == NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    pbSAIIndex = pbSAINew + cbInsertionOffset;

    //
    // Move buffer content down.
    //

    BYTE * pbSetSubCount   = pbSAIIndex - sizeof(dwSetSubCount);
    BYTE * pbIdentityStart = pbSAIIndex;

    MoveMemory(pbIdentityStart + HASH_DATA_SIZE, pbIdentityStart,
                   (pbSAINew + *pcbSAI) - pbIdentityStart);

    //
    // Update identity count & write new identity.
    //

    CopyMemory(&dwSetSubCount, pbSetSubCount, sizeof(dwSetSubCount));
    dwSetSubCount++;
    CopyMemory(pbSetSubCount, &dwSetSubCount, sizeof(dwSetSubCount));
    CopyMemory(pbIdentityStart, pbIdentity, HASH_DATA_SIZE);

    // Update out ptrs.
    //
    *pcbSAI = cbSAINew;
    *ppbSAI = pbSAINew;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SAIRemoveIdentity
//
//  Synopsis:
//
//  Arguments:  [pbIdentity]      --
//              [pbSet]           --
//              [pcbSAI]          --
//              [ppbSAI]          --
//              [CredentialIndex] --
//              [pcbSAC]          --
//              [ppbSAC]          --
//
//  Returns:    TBD
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
SAIRemoveIdentity(
    BYTE *  pbIdentity,
    BYTE *  pbSet,
    DWORD * pcbSAI,
    BYTE ** ppbSAI,
    DWORD   CredentialIndex,
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    HRESULT hr = S_OK;
    DWORD   dwSetSubCount;

    //
    // Check identity, set ptr values. If this fails, it is either a developer
    // error (hence, the assertion) or the database is hosed. In either case,
    // return an error vs. writing blindly to memory.
    //

    if ((pbSet > pbIdentity)                                          ||
        (pbSet < (*ppbSAI + SAI_HEADER_SIZE + sizeof(dwSetSubCount))) ||
        ((pbIdentity + HASH_DATA_SIZE) > (*ppbSAI + *pcbSAI)))
    {
        ASSERT_SECURITY_DBASE_CORRUPT();
        return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
    }

    BYTE *  pbSetSubCount;

    //
    // Read and decrement identity array count.
    //

    pbSetSubCount = pbSet - sizeof(dwSetSubCount);
    CopyMemory(&dwSetSubCount, pbSetSubCount, sizeof(dwSetSubCount));
    --dwSetSubCount;

    //
    // If this is the last identity in the set,
    //     overwrite the set count value & the identity with remaining SAI
    //       buffer content;
    //     remove associated credential from the SAC.
    // If this is not the last entry,
    //     overwrite the identity with the remaining SAI buffer content &
    //       decrement the identity set count.
    //

    BYTE * pbDest, * pbSrc;
    DWORD  cbSAINew;

    if (dwSetSubCount == 0)             // Last entry.
    {
        // Remove associated credential in the SAC.
        //
        hr = SACRemoveCredential(CredentialIndex, pcbSAC, ppbSAC);

        if (SUCCEEDED(hr))
        {
            // Overwrite identity set with SAI remaining buffer.
            // Includes the set array count and the single identity
            // element. Actual move accomplished following this condition.
            //
            pbDest = pbSetSubCount;
            pbSrc  = pbSet + HASH_DATA_SIZE;

            cbSAINew = *pcbSAI - (HASH_DATA_SIZE + sizeof(dwSetSubCount));

            // Decrement SAI identity set count. That is, the count of
            // identity sets in the SAI. Note, overloading dwSetSubCount.
            //
            CopyMemory(&dwSetSubCount, *ppbSAI + USN_SIZE,
                            sizeof(dwSetSubCount));
            --dwSetSubCount;
            CopyMemory(*ppbSAI + USN_SIZE, &dwSetSubCount,
                            sizeof(dwSetSubCount));
        }
    }
    else                                // More entries remain.
    {
        // Overwrite identity with SAI remaining buffer.
        // Actual move accomplished following this condition.
        //
        pbDest = pbIdentity;
        pbSrc  = pbIdentity + HASH_DATA_SIZE;

        cbSAINew = *pcbSAI - HASH_DATA_SIZE;

        // Update identity set array count to reflect removed entry.
        //
        CopyMemory(pbSetSubCount, &dwSetSubCount, sizeof(dwSetSubCount));
    }

    if (SUCCEEDED(hr))
    {
        MoveMemory(pbDest, pbSrc, (*ppbSAI + *pcbSAI) - pbSrc);

        // Shrink SAI buffer memory with a realloc.
        //
        BYTE * pbSAINew = (BYTE *)LocalReAlloc(*ppbSAI, cbSAINew,
                                                LMEM_MOVEABLE);

        if (pbSAINew != NULL)
        {
            // Update return ptrs.
            //
            *pcbSAI = cbSAINew;
            *ppbSAI = pbSAINew;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   SAIUpdateIdentity
//
//  Synopsis:   Updates the hash data stored for a job in place.
//
//  Arguments:  [pbNewIdentity] -- the new hash data to be stored
//              [pbFoundIdentity] -- pointer to the previously found hash data
//              [cbSAI] --
//              [pbSAI] --
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//              SCHED_E_ACCOUNT_DBASE_CORRUPT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SAIUpdateIdentity(
    const BYTE * pbNewIdentity,
    BYTE *  pbFoundIdentity,
    DWORD   cbSAI,
    BYTE *  pbSAI)
{
    schAssert(pbSAI <= pbFoundIdentity && pbFoundIdentity < pbSAI + cbSAI);
    UNREFERENCED_PARAMETER(cbSAI);
    UNREFERENCED_PARAMETER(pbSAI);

    CopyMemory(pbFoundIdentity, pbNewIdentity, HASH_DATA_SIZE);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   SAICoalesceDeletedEntries
//
//  Synopsis:   Removed entries marked for deletion and reallocate the buffer.
//
//  Arguments:  [pcbSAI] --
//              [ppbSAI] --
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//              SCHED_E_ACCOUNT_DBASE_CORRUPT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SAICoalesceDeletedEntries(
    DWORD * pcbSAI,
    BYTE ** ppbSAI)
{
    schAssert(pcbSAI != NULL && ppbSAI != NULL && *ppbSAI != NULL);

    if (*pcbSAI <= SAI_HEADER_SIZE)
    {
        //
        // Nothing to do.
        //

        return(S_OK);
    }

    //
    // Read set array count.
    //

    DWORD  cbSAINew     = *pcbSAI;
    DWORD  cSetsRemoved = 0;
    DWORD  dwSetArrayCount;
    DWORD  dwSetSubCount;
    DWORD  cEntriesDeleted;
    BYTE * pb;
    BYTE * pbSetArrayCount;
    BYTE * pbSAIEnd     = *ppbSAI + *pcbSAI;
    BYTE * pbSAINew;
    BYTE * pbDest;
    BYTE * pbSrc;

    pb = pbSetArrayCount = *ppbSAI + USN_SIZE;

    CopyMemory(&dwSetArrayCount, pbSetArrayCount, sizeof(dwSetArrayCount));
    pb += sizeof(dwSetArrayCount);

    for (DWORD i = 0; i < dwSetArrayCount && pb < pbSAIEnd; i++)
    {
        if ((pb + sizeof(dwSetSubCount)) > pbSAIEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        CopyMemory(&dwSetSubCount, pb, sizeof(dwSetSubCount));

        pbDest = pb;
        pb += sizeof(dwSetSubCount);
        pbSrc = pb;

        //
        // Must scan the set to see if all entries are to be removed.
        // To know if the set subcount can be removed as well.
        //
        cEntriesDeleted = 0;
        for (DWORD j = 0; j < dwSetSubCount && pbSrc < pbSAIEnd; j++)
        {
            //
            // Deleted entry marker size is less than HASH_DATA_SIZE.
            //

            if ((pbSrc + HASH_DATA_SIZE) > pbSAIEnd)
            {
                ASSERT_SECURITY_DBASE_CORRUPT();
                return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
            }

            if (DELETED_ENTRY(pbSrc))
            {
                cEntriesDeleted++;
            }

            pbSrc += HASH_DATA_SIZE;
        }

        //
        // Anything to remove?
        //

        if (cEntriesDeleted != 0)
        {
            //
            // Reduce SAI size by the total no. of deleted entries.
            // After the above, we can safely dispense with buffer boundary
            // checks.
            //

            DWORD cbBytesDeleted = (HASH_DATA_SIZE * cEntriesDeleted);

            if (cEntriesDeleted == dwSetSubCount)
            {
                //
                // Removing entire set.
                // Update total no. of sets removed.
                //

                cSetsRemoved++;
                cbBytesDeleted += sizeof(dwSetSubCount);
                MoveMemory(pbDest, pbSrc, pbSAIEnd - pbSrc);
            }
            else
            {
                //
                // Removing individual set entries.
                // First, update the set array count.
                // pbDest is positioned on the set subcount, pb just after it.
                //

                dwSetSubCount -= cEntriesDeleted;
                CopyMemory(pbDest, &dwSetSubCount, sizeof(dwSetSubCount));

                pbDest = pbSrc = pb;

                for ( ; cEntriesDeleted && pbSrc < pbSAIEnd; )
                {
                    pbSrc += HASH_DATA_SIZE;

                    if (DELETED_ENTRY(pbDest))
                    {
                        cEntriesDeleted--;
                        MoveMemory(pbDest, pbSrc, pbSAIEnd - pbSrc);
                        pbSrc = pbDest;
                    }

                    pbDest = pbSrc;
                }

                //
                // Advance to next set.
                //

                pbDest = pb + (HASH_DATA_SIZE * dwSetSubCount);
            }

            cbSAINew -= cbBytesDeleted;
            pbSAIEnd -= cbBytesDeleted;
        }
        else
        {
            //
            // Advance to next set.
            //

            pbDest += (HASH_DATA_SIZE * dwSetSubCount) +
                        sizeof(dwSetSubCount);
        }

        pb = pbDest;
    }

    //
    // Fix up set array count to reflect removed sets.
    //

    dwSetArrayCount -= cSetsRemoved;
    CopyMemory(pbSetArrayCount, &dwSetArrayCount, sizeof(dwSetArrayCount));

    //
    // Finally, reallocate the array. That is, if it changed.
    //

    if (*pcbSAI != cbSAINew)
    {
        pbSAINew = (BYTE *)LocalReAlloc(*ppbSAI, cbSAINew, LMEM_MOVEABLE);

        if (pbSAINew != NULL)
        {
            // Update return ptrs.
            //
            *pcbSAI = cbSAINew;
            *ppbSAI = pbSAINew;
        }
        else
        {
            return(E_OUTOFMEMORY);
        }
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SACCoalesceDeletedEntries
//
//  Synopsis:   Removed entries marked for deletion and reallocate the buffer.
//
//  Arguments:  [pcbSAC] --
//              [ppbSAC] --
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//              SCHED_E_ACCOUNT_DBASE_CORRUPT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SACCoalesceDeletedEntries(
    DWORD * pcbSAC,
    BYTE ** ppbSAC)
{
    schAssert(pcbSAC != NULL && ppbSAC != NULL && *ppbSAC != NULL);

    if (*pcbSAC <= SAC_HEADER_SIZE)
    {
        //
        // Nothing to do.
        //

        return(S_OK);
    }

    BYTE * pb;
    BYTE * pbCredentialCount;
    DWORD  dwCredentialCount;
    DWORD  cbCredentialSize;
    DWORD  cCredentialsRemoved = 0;
    DWORD  cbSACNew            = *pcbSAC;
    BYTE * pbSACNew;
    BYTE * pbSACEnd            = *ppbSAC + *pcbSAC;
    BYTE * pbSrc;
    BYTE * pbDest;
    BYTE * pbNext;
    DWORD  cbBytesDeleted;

    //
    // Read credential count.
    //

    pb = pbCredentialCount = *ppbSAC + USN_SIZE;

    CopyMemory(&dwCredentialCount, pbCredentialCount,
                    sizeof(dwCredentialCount));
    pb += sizeof(dwCredentialCount);

    for (DWORD i = 0; i < dwCredentialCount && pb < pbSACEnd; i++)
    {
        if ((pb + sizeof(cbCredentialSize)) > pbSACEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
        }

        cbBytesDeleted = 0;
        pbDest = pbSrc = pb;

        //
        // Move consecutive entries.
        //

        for ( ; i < dwCredentialCount && pb < pbSACEnd; i++)
        {
            CopyMemory(&cbCredentialSize, pb, sizeof(cbCredentialSize));
            pb += sizeof(cbCredentialSize);
            pbNext = pb + cbCredentialSize;

            //
            // A credential could never be less than the deleted entry size,
            // unless it is bogus.
            //

            if (cbCredentialSize  < DELETED_ENTRY_MARKER_SIZE ||
                (pb + DELETED_ENTRY_MARKER_SIZE) > pbSACEnd)
            {
                ASSERT_SECURITY_DBASE_CORRUPT();
                return(SCHED_E_ACCOUNT_DBASE_CORRUPT);
            }

            if (DELETED_ENTRY(pb))
            {
                //
                // Update the new SAC size to reflect the removed entry.
                // Also update the total no. of credentials removed.
                //

                cbBytesDeleted += sizeof(cbCredentialSize) + cbCredentialSize;
                cCredentialsRemoved++;
                pbSrc = pb = pbNext;
            }
            else
            {
                pb = pbNext;
                break;
            }
        }

        if (pbDest != pbSrc)
        {
            MoveMemory(pbDest, pbSrc, pbSACEnd - pbSrc);
            pb = pbDest;
            cbSACNew -= cbBytesDeleted;
            pbSACEnd -= cbBytesDeleted;
        }
    }

    //
    // Fix up credential count to reflect removed sets.
    //

    dwCredentialCount -= cCredentialsRemoved;
    CopyMemory(pbCredentialCount, &dwCredentialCount,
                    sizeof(dwCredentialCount));

    //
    // Finally, reallocate the array. That is, if it changed.
    //

    if (*pcbSAC != cbSACNew)
    {
        pbSACNew = (BYTE *)LocalReAlloc(*ppbSAC, cbSACNew, LMEM_MOVEABLE);

        if (pbSACNew != NULL)
        {
            // Update return ptrs.
            //
            *pcbSAC = cbSACNew;
            *ppbSAC = pbSACNew;
        }
        else
        {
            return(E_OUTOFMEMORY);
        }
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\queue.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       queue.cxx
//
//  Contents:   CQueue class implementation.
//
//  Classes:    CQueue
//
//  Functions:  None.
//
//  History:    25-Oct-95   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include "queue.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CQueue::AddElement
//
//  Synopsis:   Add an element to the linked list.
//
//  Arguments:  [pdl] -- Doubly-linked list element.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CQueue::AddElement(CDLink * pdl)
{
    schAssert(pdl != NULL);

    //
    // NB: maintain a circular list to insure FIFO ordering.
    //

    if (_pdlFirst == NULL)
    {
        _pdlFirst = pdl;
    }
    else
    {
        pdl->LinkAfter(_pdlFirst->Prev());
    }

    _pdlFirst->SetPrev(pdl);

    ++_cElems;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueue::RemoveElement
//
//  Synopsis:   Remove an element to the linked list.
//
//  Arguments:  [pdl] -- Doubly-linked list element.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CDLink *
CQueue::RemoveElement(CDLink * pdl)
{
    if (pdl != NULL)
    {
        if (pdl == _pdlFirst)
        {
            //
            // Special case list head.
            //

            if (pdl->Next() != NULL)
            {
                pdl->Next()->SetPrev(pdl->Prev());
            }
            _pdlFirst = pdl->Next(); 

            pdl->SetNext(NULL);
            pdl->SetPrev(NULL);
        }
        else
        {
            //
            // If deleting last entry in list, must make list head
            // point to new last entry.  
            //

            if (pdl == _pdlFirst->Prev())
            {
                _pdlFirst->SetPrev(pdl->Prev());    
            }

            //
            // Standard node deletion.
            //

            pdl->UnLink();
        }

        --_cElems;
    }

    return(pdl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\procssr.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       procssr.cxx
//
//  Contents:   CJobProcessor class implementation.
//
//  Classes:    CJobProcessor
//
//  Functions:  None.
//
//  History:    25-Oct-95   MarkBl  Created
//				11/16/00	Dgrube remove (dwRet >= WAIT_OBJECT_0) && 
//							from "else if ((dwRet >= WAIT_OBJECT_0) && (dwRet < WAIT_ABANDONED_0))"
//							since dwRet is a DWORD. It would never occur and
//							is causing compile errors.
//
//-----------------------------------------------------------------------------
//

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"
#include "..\inc\resource.h"

#if defined(_CHICAGO_) && DBG == 1
extern HWND g_hList;
#endif

// Parameters to CloseWindowEnumProc and ThreadWindowEnumProc
struct ENUMPROCPARMS
{
    DWORD   dwProcessId;    // IN - pid of the process being closed
    BOOL    fWindowFound;   // OUT - whether WM_CLOSE was sent to any window
};

BOOL CALLBACK CloseWindowEnumProc(HWND, LPARAM);
BOOL CALLBACK ThreadWindowEnumProc(HWND, LPARAM);


//
// Notes on the use of CRun's m_dwMaxRunTime and m_ftKill fields:
//
// m_ftKill is the time when the job processor thread monitoring the
// job should try to kill the job, if it hasn't already terminated.
// It is an absolute time.  It is computed when the job is launched, based
// on a combination of (1) the duration-end of triggers that have
// TASK_TRIGGER_FLAG_KILL_AT_DURATION_END set and (2) the MaxRunTime set on
// the job itself.
// (1) can be predicted before the job runs, so it is calculated in
// GetTriggerRunTimes() and stored in m_ftKill.
// (2) is a relative time, so in many cases its end time cannot be
// predicted until the job runs.  It is temporarily stored in m_dwMaxRunTime
// when the CRun object is created; but it is converted to an absolute time
// and combined with m_ftKill when the job is launched in RunJobs().
//
// Once the job is launched, m_ftKill remains the same for the lifetime of
// the CRun object, even if the job is killed because of
// TASK_FLAG_KILL_ON_IDLE_END and restarted because of
// TASK_FLAG_RESTART_ON_IDLE_RESUME.
//
// m_dwMaxRunTime is the remaining number of milliseconds that the
// CJobProcessor::PerformTask() thread will wait for the job to terminate.
// It is initialized to (m_ftKill - current time) in CJobProcessor::
// SubmitJobs() and repeatedly adjusted downwards each time the job processor
// thread wakes up.  If the job is killed and restarted, m_dwMaxRunTime is
// recomputed from the original m_ftKill and the new current time.
//

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::~CJobProcessor
//
//  Synopsis:   Job processor destructor. This object is reference counted,
//              ala class CTask inheritance. As a result, we are guaranteed
//              all of this is safe to do, as no outstanding references
//              remain.
//
//  Arguments:  N/A
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CJobProcessor::~CJobProcessor()
{
    TRACE3(CJobProcessor, ~CJobProcessor);

    if (_rgHandles != NULL)
    {
        //
        // Close the processor notification event handle & delete the handle
        // array.
        //

        CloseHandle(_rgHandles[0]);
        delete _rgHandles;
    }

    DeleteCriticalSection(&_csProcessorCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::Initialize
//
//  Synopsis:   Perform the initialization steps that would have otherwise
//              been performed in the constructor. This method enables return
//              of a status code if initialization should fail.
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CJobProcessor::Initialize(void)
{
    TRACE3(CJobProcessor, Initialize);

    HRESULT hr;

    schAssert(_rgHandles == NULL);

    //
    // Create the handle array with the processor notification event handle
    // as the sole element.
    //

    _rgHandles = new HANDLE[1];

    if (_rgHandles == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }


    //
    // Create the processor notification event and assign its handle to the
    // handle array.
    //

    _rgHandles[0] = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (_rgHandles[0] == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    //
    // Request a thread to service this object.
    //

    hr = RequestService(this);

    if (SUCCEEDED(hr))
    {
        this->InService();
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::IsIdle
//
//  Synopsis:   This member is called during job processor pool garbage
//              collection to determine if this processor can be removed
//              from the pool. This method is problematic, but this is OK,
//              since the worst that can happen is this processor may
//              be removed from the pool prematurely, requiring use of a
//              additional, redundant job processor object.
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
CJobProcessor::IsIdle(void)
{
    TRACE3(CJobProcessor, IsIdle);

    if ((_RequestQueue.GetCount() + _ProcessingQueue.GetCount()) == 0)
    {
        return(this->GetReferenceCount() == 1 ? TRUE : FALSE);
    }

    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::Next
//
//  Synopsis:   Return the next processor this object refers to. The returned
//              object is AddRef()'d to reflect the new reference.
//
//  Arguments:  None.
//
//  Notes:      The processor pool is locked to ensure this thread is the
//              sole thread accessing the pool throughout this operation.
//
//----------------------------------------------------------------------------
CJobProcessor *
CJobProcessor::Next(void)
{
    TRACE3(CJobProcessor, Next);

    gpJobProcessorMgr->LockProcessorPool();

    CJobProcessor * pjpNext = (CJobProcessor *)CDLink::Next();

    if (pjpNext != NULL)
    {
        pjpNext->AddRef();
    }

    gpJobProcessorMgr->UnlockProcessorPool();

    return(pjpNext);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::Prev
//
//  Synopsis:   Return the previous processor this object refers to. The
//              returned object is AddRef()'d to reflect the new reference.
//
//  Arguments:  None.
//
//  Notes:      The processor pool is locked to ensure this thread is the
//              sole thread accessing the pool throughout this operation.
//
//----------------------------------------------------------------------------
CJobProcessor *
CJobProcessor::Prev(void)
{
    TRACE3(CJobProcessor, Prev);

    gpJobProcessorMgr->LockProcessorPool();

    CJobProcessor * pjpPrev = (CJobProcessor *)CDLink::Prev();

    if (pjpPrev != NULL)
    {
        pjpPrev->AddRef();
    }

    gpJobProcessorMgr->UnlockProcessorPool();

    return(pjpPrev);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::PerformTask
//
//  Synopsis:   This is the function performed by the worker thread on the
//              job processor. The processor thread enters a wait on the array
//              of handles in the private data member, _rgHandles. The first
//              array element is a handle to the processor notification event.
//              This event is signals this thread that new jobs have been sub-
//              mitted to this processor. The remaining n-1 handles in the
//              array are job process handles signaled on job completion.
//              When a job completes, the persisted job object is updated with
//              the job's exit status code, completion time, etc.
//
//              It's possible the wait for one or more jobs may time out. If
//              the processor notification event wait times out, the wait is
//              re-entered. If a job times out, its handle is removed from
//              wait handle array and the job's job info object removed from
//              the processing queue.
//
//  Arguments:  None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessor::PerformTask(void)
{
#define CLOSE_WAIT_TIME     (3 * 60 * 1000)      //  3 mins (milliseconds).
#define WAIT_TIME_DEFAULT   (10 * 3 * 60 * 1000) // 30 mins (milliseconds).

    TRACE3(CJobProcessor, PerformTask);

    CRun * pRun;
    DWORD      dwObjectIndex;

    //
    // Initialize this thread's keep-awake count.
    //
    InitThreadWakeCount();

    for (;;)
    {
        //
        // Wait for job completion, timeout, or processor notification.
        //
        // NB :  ProcessQueue count + 1 since there is no processing queue
        //       entry for the first handle, the new submission event
        //       handle.
        //
        //       There will never be a discrepancy between the processing
        //       queue count and the actual number of handles in _rgHandles
        //       since this thread exclusively updates the processing queue.
        //

        DWORD dwTimeoutInterval = WAIT_TIME_DEFAULT;
        DWORD cHandles          = _ProcessingQueue.GetCount() + 1;

        if (cHandles > 1)
        {
            //
            // There are jobs to process.
            //
            // Scan job info objects in the processor queue for the minimum
            // value of the job's maximum run time. This will be the wait
            // time on WaitForMultipleObjects.
            //

            for (pRun = _ProcessingQueue.GetFirstElement();
                 pRun != NULL;
                 pRun = pRun->Next())
            {
                schDebugOut((DEB_USER3,
                    "PerformTask(0x%x) Job " FMT_TSTR " remaining time %u ms\n",
                    this,
                    pRun->GetName(),
                    pRun->GetMaxRunTime()));

                dwTimeoutInterval = min(dwTimeoutInterval,
                                        pRun->GetMaxRunTime());
            }
        }

        schDebugOut((DEB_USER3,
            "PerformTask(0x%x) Processor entering wait; p queue cnt(%d); " \
            "wait time %u ms\n",
            this,
            cHandles - 1,
            dwTimeoutInterval));

        DWORD dwWaitTime = GetTickCount();
        DWORD dwRet = WaitForMultipleObjects(cHandles,
                                             _rgHandles,
                                             FALSE,
                                             dwTimeoutInterval);

        //
        // Serialize processor data structure access.
        //

        EnterCriticalSection(&_csProcessorCritSection);

        //
        // (Note that GetTickCount() wrap is automatically taken care of
        // by 2's-complement subtraction.)
        //
        dwWaitTime = GetTickCount() - dwWaitTime;

        schDebugOut((DEB_USER3,
            "PerformTask(0x%x) Processor awake after %u ms\n",
            this,
            dwWaitTime));

        //
        // Decrement each job's max run time by the amount of time waited.
        // Skip jobs with zeroed max run time values.
        //

        for (pRun = _ProcessingQueue.GetFirstElement();
             pRun != NULL;
             pRun = pRun->Next())
        {
            //
            // NB : Jobs with infinite run times do not expire. Therefore, do
            //      not decrease the max run time value.
            //

            if (pRun->GetMaxRunTime() != 0  &&
                pRun->GetMaxRunTime() != INFINITE)
            {
                if (pRun->GetMaxRunTime() > dwWaitTime)
                {
                    pRun->SetMaxRunTime(pRun->GetMaxRunTime() - dwWaitTime);
                }
                else
                {
                    pRun->SetMaxRunTime(0);
                }
            }
        }

        if (dwRet == WAIT_FAILED)
        {
            //
            // Wait attempt failed. Shutdown the processor & bail out.
            //
            // BUGBUG : Should probably log this.
            //

            schDebugOut((DEB_ERROR,
                "PerformTask(0x%x) Wait failure(0x%x) - processor " \
                "shutdown initiated\n",
                this,
                HRESULT_FROM_WIN32(GetLastError())));
            this->_Shutdown();
            LeaveCriticalSection(&_csProcessorCritSection);
            break;
        }

        if (dwRet == WAIT_TIMEOUT)
        {
            if (!_ProcessingQueue.GetCount() && !_RequestQueue.GetCount())
            {
                //
                // Shutdown this processor. The wait has expired and no jobs
                // are in service, nor are there new requests queued.
                //

                schDebugOut((DEB_TRACE,
                    "PerformTask(0x%x) Processor idle - shutdown " \
                    "initiated\n",
                    this));
                this->_Shutdown();
                LeaveCriticalSection(&_csProcessorCritSection);
                break;
            }

            //
            // One or more jobs timed out (those with max run time values of
            // zero). Close associated event handle, overwrite event handle
            // array entry, then remove and destroy the associated job info
            // object from the processor queue.
            //

            schDebugOut((DEB_USER3,
                "PerformTask(0x%x) Wait timeout\n",
                this));

            CRun * pRunNext;
            DWORD i;
            for (pRun = _ProcessingQueue.GetFirstElement(), i = 1;
                 pRun != NULL;
                 pRun = pRunNext, i++)
            {
                pRunNext = pRun->Next();

                if (pRun->GetMaxRunTime() != 0)
                {
                    continue;
                }

                //
                // Post a WM_CLOSE message to the job if this is the
                // first attempt at closure. If WM_CLOSE was issued
                // previously and the job is still running, resort to
                // TerminateProcess.
                //

                if (!(pRun->IsFlagSet(RUN_STATUS_CLOSE_PENDING)))
                {
                    pRun->SetFlag(RUN_STATUS_TIMED_OUT);

                    schDebugOut((DEB_ITRACE,
                        "PerformTask(0x%x) Forced closure; issuing " \
                        "WM_CLOSE to job " FMT_TSTR "\n",
                        this,
                        pRun->GetName()));

                    //
                    // Log job closure, post WM_CLOSE, then re-enter the
                    // wait for closure.
                    //

                    SYSTEMTIME stFinished;
                    GetLocalTime(&stFinished);

                    g_pSched->JobPostProcessing(pRun, stFinished);

                    // Issue WM_CLOSE in a roundabout way. Is there a
                    // a better way to do this?
                    //
                    ENUMPROCPARMS Parms = { pRun->GetProcessId(), FALSE };

#if !defined(_CHICAGO_)
   
                    // Attach to the correct desktop prior to enumerating
                    // the windows
                    //
                    HWINSTA hwinstaSave = NULL;
                    HDESK hdeskSave = NULL;
                    HWINSTA hwinsta = NULL;

                    DWORD dwTreadId = GetCurrentThreadId( );

                    if( NULL == dwTreadId )
					{
                         schDebugOut((DEB_ERROR,
	                           "CJobProcessor::PerformTask, GetCurrentThreadId " ));
					}
                    else
					{
                         hdeskSave = GetThreadDesktop( dwTreadId );
					}

                    if( NULL == hdeskSave )
					{
                         schDebugOut((DEB_ERROR,
	                           "CJobProcessor::PerformTask, GetThreadDesktop " ));
					}
                    else
					{
	                     hwinstaSave = GetProcessWindowStation( );
					}

                    if( NULL == hwinstaSave )
					{
                         schDebugOut((DEB_ERROR,
	                           "CJobProcessor::PerformTask, GetProcessWindowStation " ));
					}

                    hwinsta = OpenWindowStation(
	                              pRun->GetStation( ),
	                              TRUE,
	                              MAXIMUM_ALLOWED );

                    if( NULL == hwinsta )
					{
                         schDebugOut((DEB_ERROR,
	                           "CJobProcessor::PerformTask, OpenWindowStation " ));
					}
                    else if( !SetProcessWindowStation( hwinsta ) )
					{
                         schDebugOut((DEB_ERROR,
	                           "CJobProcessor::PerformTask, SetProcessWindowStation " ));
					}

                    HDESK hDesk = OpenDesktop(
		                              pRun->GetDesktop(),  
		                              0,						//No hooks allowed
		                              TRUE,					//No inheritance
			                          MAXIMUM_ALLOWED
		                              );

                    if( !SetThreadDesktop( hDesk ) )
					{
                          schDebugOut((DEB_ERROR,
	                            "CJobProcessor::PerformTask, OpenDesktop failed, " \
	                            "status = 0x%lx\n",
	                            GetLastError()));
					}
                    else
					{

                          // Success enumerate windows else SetMaxRunTime to 0
                          // and ultimately kill the process (not very graceful)
			              //
                          EnumWindows(CloseWindowEnumProc, (LPARAM) &Parms);
					}

#else	//!defined(_CHICAGO_)	
					
			        // Success enumerate windows else SetMaxRunTime to 0
			        // and ultimately kill the process (not very graceful)
			        //
		            EnumWindows(CloseWindowEnumProc, (LPARAM) &Parms);

#endif // defined(_CHICAGO_)				
					
					pRun->SetFlag(RUN_STATUS_CLOSE_PENDING);
					 
					if (Parms.fWindowFound)
				    {
					    pRun->SetMaxRunTime(CLOSE_WAIT_TIME);
					}
					else
					{
					    schDebugOut((DEB_ITRACE, "PerformTask: no windows found\n"));

					    //
						// If WM_CLOSE was not sent to any windows, there is no
						// point waiting for the job to terminate.
						// DCR: It would be polite, and perhaps help the app to 
						// avoid data loss (depending on the app), to send some other
						// notification, such as a CTRL_C_EVENT.  See bug 65251.
						//
						pRun->SetMaxRunTime(0);
					}
					
#if !defined(_CHICAGO_)
					// Clean up and reset Desktop back to where it was
					//
				   if( NULL != hdeskSave  )  //if this is true we have noted it above
				   {                     
						if( !SetThreadDesktop( hdeskSave ) )
						{
							schDebugOut((DEB_ERROR,
								"CJobProcessor::PerformTask, SetThreadDesktop failed (resetting), " \
								"status = 0x%lx\n",
								GetLastError()));
						}
				
					}

				    if( NULL != hDesk)
					{
						CloseDesktop( hDesk );
					}
					// Reset WindowStation back to where it was
					//
					if( NULL != hwinstaSave )
					{
						if( !SetProcessWindowStation( hwinstaSave ) )
						{
							schDebugOut((DEB_ERROR,
								"CJobProcessor::PerformTask, SetProcessWindowStation failed (resetting), " \
								"status = 0x%lx\n",
								GetLastError()));
						}
					}

					if( NULL != hwinsta )
					{
						CloseWindowStation( hwinsta );
					}
#endif // !defined(_CHICAGO_)
                }
                else
                {
                    schDebugOut((DEB_ITRACE,
                        "PerformTask(0x%x) 2nd forced closure; issuing " \
                        "TerminateProcess on job " FMT_TSTR "\n",
                        this,
                        pRun->GetName()));

                    DWORD dwExitCode = 0;
                    GetExitCodeProcess(pRun->GetHandle(), &dwExitCode);

                    if (dwExitCode == STILL_ACTIVE)
                    {
                        TerminateProcess(pRun->GetHandle(), (UINT)-1);
                    }

#ifdef NOT_YET
                    pRun->ClearFlag(RUN_STATUS_RUNNING);
                    pRun->SetFlag(RUN_STATUS_CLOSED);
#endif // NOT_YET

                    if (i < _ProcessingQueue.GetCount()) // Ignore last
                                                         // entry.
                    {
                        CopyMemory(&_rgHandles[i],
                                   &_rgHandles[i + 1],
                                   sizeof(HANDLE) *
                            (_ProcessingQueue.GetCount() - i));
                    }

                    i--;    // Reflect overwritten array entry.

                    //
                    // Remove CRun object from the processing queue
                    // and destroy it.
                    //

                    _ProcessingQueue.RemoveElement(pRun);

                    if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
                    {
                        //
                        // This thread is monitoring one less system-
                        // required job
                        //
                        WrapSetThreadExecutionState(FALSE,
                            "processor - forced close of task");
                    }

                    if (pRun->IsFlagSet(RUN_STATUS_RESTART_ON_IDLE_RESUME)
                        && pRun->GetWait() > 0)
                    {
                        //
                        // Ask the main thread to move it back into the
                        // idle wait queue
                        //
                        pRun->ClearFlag(JOB_INTERNAL_FLAG_MASK);
                        pRun->SetMaxRunTime(INFINITE);
                        g_pSched->SubmitIdleRun(pRun);
                        //
                        // Note that we changed (reduced) pRun's MaxRunTime
                        // when we killed it.  However we didn't mess with
                        // the kill time.  The MaxRunTime will be recomputed
                        // based on the same kill time as before when this
                        // run is next submitted to a processor.
                        //
                    }
                    else
                    {
                        delete pRun;
                    }
                }
            }
        }
        else if (dwRet < WAIT_ABANDONED_0)
        {
            //
            // One or more jobs completed.
            //

            dwObjectIndex = dwRet - WAIT_OBJECT_0;

            if (dwObjectIndex == 0)
            {
                //
                // Processor notification event signaled. Either new jobs
                // have been submitted or the service is stopping.
                //

                if (IsServiceStopping())
                {
                    //
                    // Service stop. Shutdown the processor.
                    //

                    schDebugOut((DEB_TRACE,
                        "PerformTask(0x%x) Service stop - processor " \
                        "shutdown initiated\n",
                        this));
                    this->_Shutdown();
                    LeaveCriticalSection(&_csProcessorCritSection);
                    break;
                }

                ResetEvent(_rgHandles[0]);

                //
                // Move jobs from request to processing queue.
                //

                _ProcessRequests();

                //
                // Unblock the thread that called SubmitJobs().
                // (We happen to know it's the thread in the main service
                // loop so we can use the global event.  A cleaner model
                // would be to either pass the handle of the event to
                // SubmitJobs, or use an event private to SubmitJobs and
                // PerformTask.)
                //
                g_pSched->Unblock();
            }
            else if (dwObjectIndex < cHandles)
            {
                //
                // A job has finished (or closed).
                // Find the CRun object associated with the handle.
                //

                if ((pRun = _ProcessingQueue.FindJob(
                                    _rgHandles[dwObjectIndex])) != NULL)
                {
                    pRun->ClearFlag(RUN_STATUS_RUNNING);

                    if (!(pRun->GetFlags() & RUN_STATUS_CLOSE_PENDING))
                    {
                        schDebugOut((DEB_USER3,
                            "PerformTask(0x%x) Job " FMT_TSTR " completed\n",
                            this,
                            pRun->GetName()));

                        //
                        // The job finished on its own. Log completion
                        // status. Fetch job completion time for pending log
                        // entry.
                        //

                        pRun->SetFlag(RUN_STATUS_FINISHED);

                        SYSTEMTIME stFinished;
                        GetLocalTime(&stFinished);

                        //
                        // Standard job post processing.
                        //

                        g_pSched->JobPostProcessing(pRun, stFinished);
                    }
                    else
                    {
                        // (NOTE: This may not be necessary - this info
                        //      is not used yet.)
                        //
                        pRun->SetFlag(RUN_STATUS_CLOSED);
                    }

                    //
                    // Fix up handle array to reflect processed entry.
                    //

                    if (dwObjectIndex < _ProcessingQueue.GetCount())
                    {
                        CopyMemory(&_rgHandles[dwObjectIndex],
                                   &_rgHandles[dwObjectIndex + 1],
                                   sizeof(HANDLE) *
                        (_ProcessingQueue.GetCount() - dwObjectIndex));
                    }

                    //
                    // Remove CRun object from the processing queue and
                    // destroy it.
                    //

                    _ProcessingQueue.RemoveElement(pRun);

                    if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
                    {
                        //
                        // This thread is monitoring one less system-
                        // required job
                        //
                        WrapSetThreadExecutionState(FALSE,
                            "processor - last task exited");
                    }

                    if (pRun->IsFlagSet(RUN_STATUS_CLOSE_PENDING) &&
                        pRun->IsFlagSet(RUN_STATUS_RESTART_ON_IDLE_RESUME) &&
                        pRun->GetWait() > 0)
                    {
                        //
                        // Ask the main thread to move it back into the
                        // idle wait queue
                        //
                        pRun->ClearFlag(JOB_INTERNAL_FLAG_MASK);
                        pRun->SetMaxRunTime(INFINITE);
                        g_pSched->SubmitIdleRun(pRun);
                        //
                        // Note that we changed (reduced) pRun's MaxRunTime
                        // when we killed it.  However we didn't mess with
                        // the kill time.  The MaxRunTime will be reset to
                        // match the same kill time as before when this run
                        // is next submitted to a processor.
                        //
                    }
                    else
                    {
                        delete pRun;
                    }
                }
            }
            else
            {
                //
                // Index out of range.  This should never happen.
                //

                schDebugOut((DEB_ERROR,
                    "PerformTask(0x%x) Wait array index (%d) out of " \
                    "range! Handle count(%d)\n",
                    this,
                    dwObjectIndex,
                    cHandles));

				schAssert(0);

                LeaveCriticalSection(&_csProcessorCritSection);
                continue;
            }
        }
        else
        {
            //
            // Clueless how we got here. Just continue the wait.
            //

            schAssert(!"How did this branch get evaluated?");
            LeaveCriticalSection(&_csProcessorCritSection);
            continue;
        }

        LeaveCriticalSection(&_csProcessorCritSection);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CloseWindowEnumProc
//
//  Synopsis:
//
//  Arguments:  [hWnd]   --
//              [lParam] --
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CALLBACK
CloseWindowEnumProc(HWND hWnd, LPARAM lParam)
{
    DWORD dwProcessId, dwThreadId;
    ENUMPROCPARMS * pParms = (ENUMPROCPARMS *) lParam;

    dwThreadId = GetWindowThreadProcessId(hWnd, &dwProcessId);

    if (dwProcessId == pParms->dwProcessId)
    {
        //
        // Enumerate and close each owned, non-child window. This will close
        // open dialogs along with the main window(s).
        //

        EnumThreadWindows(dwThreadId, ThreadWindowEnumProc, lParam);
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   ThreadWindowEnumProc
//
//  Synopsis:   Enumeration procedure.
//
//  Arguments:  [hWnd]   -- The window handle.
//              [lParam] -- The process ID.
//
//----------------------------------------------------------------------------
BOOL CALLBACK
ThreadWindowEnumProc(HWND hWnd, LPARAM lParam)
{
    DWORD dwProcessId;
    ENUMPROCPARMS * pParms = (ENUMPROCPARMS *) lParam;

    GetWindowThreadProcessId(hWnd, &dwProcessId);

    if (dwProcessId == pParms->dwProcessId)
    {
        //
        // Close any dialogs.
        //

#if DBG == 1
        TCHAR buf[100];
        GetClassName(hWnd, buf, 100);
#if defined(UNICODE)
        schDebugOut((DEB_ITRACE, "Closing thread window 0x%x with class %S\n",
                     hWnd, buf));
#else
        schDebugOut((DEB_ITRACE, "Closing thread window 0x%x with class %s\n",
                     hWnd, buf));
#endif
#endif
        //
        // The most common dialog we are likely to see at this point is a
        // "save changes" dialog. First try to send no to close that dialog
        // and then try a cancel.
        //
        if( !PostMessage(hWnd, WM_COMMAND, 0, MAKEWPARAM(IDNO, 0)) )
		{
			schDebugOut((DEB_ERROR,
				"CJobProcessor::PerformTask - ThreadWindowEnumProc, PMsg1, " \
				"status = 0x%lx\n",
				GetLastError()));
		}

        if( !PostMessage(hWnd, WM_COMMAND, 0, MAKEWPARAM(IDCANCEL, 0)) )
		{
			schDebugOut((DEB_ERROR,
				"CJobProcessor::PerformTask - ThreadWindowEnumProc, PMsg2, " \
				"status = 0x%lx\n",
				GetLastError()));
		}
        //
        // Close any non-child windows.
        //

        if( !PostMessage(hWnd, WM_CLOSE, 0, 0) )
		{
			schDebugOut((DEB_ERROR,
				"CJobProcessor::PerformTask - ThreadWindowEnumProc, PMsg3, " \
				"status = 0x%lx\n",
				GetLastError()));
		}
        //
        // Tell the calling function that we found a matching window.
        //
        pParms->fWindowFound = TRUE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::SubmitJobs
//
//  Synopsis:   This method is used to submit new jobs to this processor.
//
//              Each processor can handle a maximum of (MAXIMUM_WAIT_OBJECTS
//              - 1) jobs (from the WaitForMultipleObjects constraint of
//              at most MAXIMUM_WAIT_OBJECTS). Subject to processor capacity,
//              all, or a subset of the jobs passed may be taken.
//
//  Arguments:  [pRunList] -- Submitted job linked list object. Jobs taken are
//                            transferred from this list to a private one.
//
//  Returns:    S_OK    -- No submissions taken (as a result of a normal
//                         condition, such as the job processor already full,
//                         or the job processor shutting down).
//              S_SCHED_JOBS_ACCEPTED -- Some submissions taken.
//                         On return, GetFirstJob() will return NULL if all
//                         submissions were taken.
//              S_FALSE -- The service is shutting down. Call Shutdown()
//                         on this processor immediately after this return
//                         code. Submissions were likely taken, but they will
//                         not execute.
//              HRESULT -- On error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CJobProcessor::SubmitJobs(CRunList * pRunList)
{
    TRACE3(CJobProcessor, SubmitJobs);
    schAssert(pRunList != NULL);

    HRESULT hr = S_OK;
    BOOL fJobsAccepted = FALSE;

    schDebugOut((DEB_USER3,
        "SubmitJobs(0x%x) pRunList(0x%x)\n",
        this,
        pRunList));

    //
    // Serialize processor data structure access.
    //

    EnterCriticalSection(&_csProcessorCritSection);

    FILETIME ftNow = GetLocalTimeAsFileTime();
    schDebugOut((DEB_USER3, "SubmitJobs: Time now = %lx %lx\n",
                 ftNow.dwLowDateTime, ftNow.dwHighDateTime));

    //
    // Add as many jobs as this processor will allow to the request queue.
    // See synopsis for details.
    //
    // NB : Adding one to the request/processing queue sum to reflect the new
    //      processor notification event handle. For this handle array entry,
    //      there is no processing queue entry.
    //

    CRun * pRun = pRunList->GetFirstJob();

    //
    // First, check if this processor is in the process of shutting down.
    // The data member, _rgHandles, is utilized as a flag to indicate this.
    // If it is NULL, this processor has shutdown and will take no more jobs.
    //

    if (_rgHandles != NULL)
    {
        while ( !pRun->IsNull() &&
                (MAXIMUM_WAIT_OBJECTS - (this->_RequestQueue.GetCount()    +
                                         this->_ProcessingQueue.GetCount() +
                                         1) ))
        {
            CRun * pRunNext = pRun->Next();

            pRun->UnLink();

            schDebugOut((DEB_USER3,
                "SubmitJobs: pRun(%#lx) (" FMT_TSTR ") KillTime = %lx %lx\n",
                pRun, pRun->GetName(), pRun->GetKillTime().dwLowDateTime,
                pRun->GetKillTime().dwHighDateTime));

            //
            // Compute the max run time (the time we will wait for
            // this job to complete) based on the kill time
            //
            DWORDLONG MaxRunTime;
            if (FTto64(pRun->GetKillTime()) < FTto64(ftNow))
            {
                MaxRunTime = 0;
            }
            else
            {
                MaxRunTime = (FTto64(pRun->GetKillTime()) - FTto64(ftNow)) /
                                FILETIMES_PER_MILLISECOND;
                MaxRunTime = min(MaxRunTime, MAXULONG);
            }
            pRun->SetMaxRunTime((DWORD) MaxRunTime);
            schDebugOut((DEB_USER3, "SubmitJobs: MaxRunTime = %lu\n", MaxRunTime));

            _RequestQueue.AddElement(pRun);

            fJobsAccepted = TRUE;

            pRun = pRunNext;
        }

        //
        // Is there a thread servicing this object? If not, request one.
        //

        if (!this->IsInService())
        {
            //
            // NB : A RequestService() return code of S_FALSE indicates the
            //      service is shutting down. Simply propagate this return
            //      code. It will then be the caller's responsibility to
            //      shut down this processor.
            //

            hr = RequestService(this);

            if (SUCCEEDED(hr) && hr != S_FALSE)
            {
                this->InService();
            }
        }

        //
        // Set the processor notification event.
        //

        schDebugOut((DEB_USER3,
            "CJobProcessor::SubmitJobs(0x%x) Signalling processor thread\n"));

        //
        // A NOP if RequestService() failed above.
        //

        SetEvent(_rgHandles[0]);
    }

    LeaveCriticalSection(&_csProcessorCritSection);

    if (hr == S_OK && fJobsAccepted)
    {
        hr = S_SCHED_JOBS_ACCEPTED;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::KillJob
//
//  Synopsis:   Kill all instances of the job indicated, if in service by
//              this processor.
//
//  Arguments:  [ptszJobName] -- Job name.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessor::KillJob(LPTSTR ptszJobName)
{
    TRACE(CJobProcessor, KillJob);
    BOOL fContractInitiated = FALSE;

    //
    // Serialize processor data structure access.
    //

    EnterCriticalSection(&_csProcessorCritSection);

    //
    // Is the job serviced by this processor?
    // Find associated job info object(s) in the processing queue.
    //
    // NB : Rarely, but it is possible there may be more than one instance.
    //

    CRun * pRun;
    for (pRun = _ProcessingQueue.GetFirstElement(); pRun != NULL;
                        pRun = pRun->Next())
    {
        //
        // The abort flag check addresses the case where more than one user
        // simultaneously aborts the same job.
        //

        if (!lstrcmpi(ptszJobName, pRun->GetName()) &&
            !(pRun->GetFlags() & RUN_STATUS_ABORTED))
        {
            //
            // Set flags for immediate timeout and closure.
            //

            pRun->SetMaxRunTime(0);
            pRun->SetFlag(RUN_STATUS_ABORTED);
            fContractInitiated = TRUE;
        }
    }

    if (fContractInitiated)
    {
        //
        // This logic will induce the PerformTask thread to respond as
        // follows:
        //     - The wait will unblock and the next wait time re-calculated;
        //       this value will be zero since the min value is taken.
        //     - The wait is re-entered and immediately times out.
        //     - Jobs with max run times of zero are closed in the
        //       WAIT_TIMEOUT condition. As a result, the jobs are killed.
        //

        SetEvent(_rgHandles[0]);
    }

    LeaveCriticalSection(&_csProcessorCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::KillIfFlagSet
//
//  Synopsis:   Kill all jobs that have the passed in flag set, if in service
//              by this processor.
//
//  Arguments:  [dwFlag] - Job flag value, one of TASK_FLAG_KILL_ON_IDLE_END
//                         or TASK_FLAG_KILL_IF_GOING_ON_BATTERIES.
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessor::KillIfFlagSet(DWORD dwFlag)
{
    TRACE(CJobProcessor, KillIfFlagSet);
    BOOL fContractInitiated = FALSE;

    //
    // Serialize processor data structure access.
    //

    EnterCriticalSection(&_csProcessorCritSection);

    //
    // Is the job serviced by this processor?
    // Find associated job info object(s) in the processing queue.
    //

    CRun * pRun;
    for (pRun = _ProcessingQueue.GetFirstElement(); pRun != NULL;
                        pRun = pRun->Next())
    {
        //
        // The abort flag check addresses the case where more than one user
        // simultaneously aborts the same job.
        //

        if ((pRun->GetFlags() & dwFlag) &&
            !(pRun->GetFlags() & RUN_STATUS_ABORTED))
        {
            //
            // Set flags for immediate timeout and closure.
            //

            pRun->SetMaxRunTime(0);
            pRun->SetFlag(RUN_STATUS_ABORTED);
            if (dwFlag == TASK_FLAG_KILL_ON_IDLE_END &&
                pRun->IsFlagSet(TASK_FLAG_RESTART_ON_IDLE_RESUME) &&
                ! pRun->IsIdleTriggered())
            {
                //
                // Note that this is the only case in which we set
                // RUN_STATUS_RESTART_ON_IDLE_RESUME.  If a job is terminated
                // because a user explicitly terminated it, for example, we
                // don't want to restart it on idle resume.
                //
                pRun->SetFlag(RUN_STATUS_RESTART_ON_IDLE_RESUME);
            }
            fContractInitiated = TRUE;
        }
    }

    if (fContractInitiated)
    {
        //
        // This logic will induce the PerformTask thread to respond as
        // follows:
        //     - The wait will unblock and the next wait time re-calculated;
        //       this value will be zero since the min value is taken.
        //     - The wait is re-entered and immediately times out.
        //     - Jobs with max run times of zero are closed in the
        //       WAIT_TIMEOUT condition. As a result, the jobs are killed.
        //

        SetEvent(_rgHandles[0]);
    }

    LeaveCriticalSection(&_csProcessorCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::Shutdown
//
//  Synopsis:   Effect processor shutdown. Do so by signalling the
//              PerformTask thread. The thread will check the global service
//              status flag. If the service is stopped (actually, in the
//              process of stopping), the thread will execute the processor
//              shutdown code & relinquish itself.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CJobProcessor::Shutdown(void)
{
    TRACE3(CJobProcessor, Shutdown);

    EnterCriticalSection(&_csProcessorCritSection);

    if (_rgHandles != NULL)
    {
        SetEvent(_rgHandles[0]);
    }

    LeaveCriticalSection(&_csProcessorCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::_EmptyJobQueue
//
//  Synopsis:   Empty respective job queue and log, per job, the reason why.
//
//  Arguments:  [JobQueue] -- Reference to CJobQueue instance.
//              [dwMsgId]  -- Why each job was abandoned. A value of zero 
//					indicates no reason; nothing is logged.
//
//  Notes:      Must be in the processor critical section for the duration
//                              of this method!
//
//----------------------------------------------------------------------------
void
CJobProcessor::_EmptyJobQueue(CJobQueue & JobQueue, DWORD dwMsgId)
{
    TRACE3(CJobProcessor, _EmptyJobQueue);

    CRun * pRun;

    for (pRun = JobQueue.RemoveElement(); pRun != NULL;
            pRun = JobQueue.RemoveElement())
    {
        if (!dwMsgId)
        {
            //
            // BUGBUG : Log job info + reason why the job was abandoned.
            //          Should logging be per job? Per incident w/ job list?
            //
        }

        delete pRun;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::_ProcessRequests
//
//  Synopsis:   Transfer submitted jobs from the request queue to the
//              processing queue and rebuild the wait handle array.
//
//  Arguments:  None.
//
//  Notes:      Must be in the processor critical section for the duration
//                              of this method!
//
//----------------------------------------------------------------------------
void
CJobProcessor::_ProcessRequests(void)
{
    TRACE3(CJobProcessor, _ProcessRequests);

    if (_RequestQueue.GetCount())
    {
        //
        // Sum request, processing queue counts.
        //

        DWORD cJobs = _RequestQueue.GetCount() +
                     _ProcessingQueue.GetCount() + 1;

        schDebugOut((DEB_USER3,
            "CJobProcessor::_ProcessRequests(0x%x) Total job count(%d) = " \
            "request(%d) + processing(%d) + 1\n",
            this,
            cJobs,
            _RequestQueue.GetCount(),
            _ProcessingQueue.GetCount()));

        //
        // Logic in SubmitJobs should prevent this from becoming false.
        //

        schAssert(cJobs <= MAXIMUM_WAIT_OBJECTS);

        HANDLE * rgHandles = new HANDLE[cJobs];

        if (rgHandles == NULL)
        {
            //
            // Leave request, processing queues as-is.
            //
            LogServiceError(IDS_FATAL_ERROR,
                            ERROR_NOT_ENOUGH_MEMORY,
                            IDS_HELP_HINT_CLOSE_APPS);
            ERR_OUT("JobProcessor: ProcessRequests", E_OUTOFMEMORY);
            return;
        }

        //
        // Copy existing handles.
        //

        CopyMemory(rgHandles,
                   _rgHandles,
                   sizeof(HANDLE) * (_ProcessingQueue.GetCount() + 1));

        //
        // Copy new job handles from request queue and transfer request
        // queue contents to the tail of the processing queue.
        //

        for (DWORD i = _ProcessingQueue.GetCount() + 1; i < cJobs; i++)
        {
            CRun * pRun = _RequestQueue.RemoveElement();
			
			Win4Assert( pRun != NULL );
            
			rgHandles[i] = pRun->GetHandle();
            _ProcessingQueue.AddElement(pRun);

            if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
            {
                //
                // Increment the count of running system_required jobs
                // handled by this thread.  If this is the first such
                // job, tell the system not to sleep until further notice.
                //
                WrapSetThreadExecutionState(TRUE, "processor - new job");
            }
        }

        delete _rgHandles;
        _rgHandles = rgHandles;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CJobProcessor::_Shutdown
//
//  Synopsis:   Take no more requests and dump whatever jobs remain in the
//              request & processing queues.
//
//  Arguments:  None.
//
//  Notes:      Must be in the processor critical section for the duration
//                              of this method!
//
//----------------------------------------------------------------------------
void
CJobProcessor::_Shutdown(void)
{
    TRACE3(CJobProcessor, _Shutdown);

    //
    // Utilizing the handle array member as a flag to indicate that this
    // processor will take no more new jobs. Set this member to NULL on
    // shutdown.
    //
    // First close the processor notification event handle & delete the
    // array.
    //

    // No need to keep the machine awake for this thread any more
    if (pfnSetThreadExecutionState != NULL)
    {
        schDebugOut((DEB_USER5, "RESETTING sys-required state: processor shutdown\n"));
        (pfnSetThreadExecutionState)(ES_CONTINUOUS);
    }

    CloseHandle(_rgHandles[0]);
    delete _rgHandles;
    _rgHandles = NULL;

    //
    // Now, empty request & processing queues.
    //
    // BUGBUG : Log job abandoned message.
    //

    this->_EmptyJobQueue(_RequestQueue);
    this->_EmptyJobQueue(_ProcessingQueue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSchedWorker::JobPostProcessing
//
//  Synopsis:   Set the exit code, current status, and NextRunTime on the
//              job object and log the run exit.
//
//  Arguments:  [pRun]          -- Job run information object.
//              [stFinished]    -- Job finish time (local time). For logging.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CSchedWorker::JobPostProcessing(
    CRun *       pRun,
    SYSTEMTIME & stFinished)
{
    TRACE3(CSchedWorker, JobPostProcessing);
    schDebugOut((DEB_ITRACE,
        "JobPostProcessing pRun(0x%x) flags(0x%x)\n",
        pRun,
        pRun->GetFlags()));

    DWORD dwExitCode;

    CJob * pJob = NULL;

    //
    // Instantiate the job so that the exit status can be saved.
    //
    // Note: if any of the variable length properties or the triggers are
    // needed, then a full activation will be necessary.
    //
    // Important: the running instance count must be protected by the
    // critical section here, where it is decremented, and in RunJobs, where
    // it is incremented. These are the only sections of code that change
    // the running instance count on the file object.
    //

    EnterCriticalSection(&m_SvcCriticalSection);

    HRESULT hr = ActivateWithRetry(pRun->GetName(), &pJob, FALSE);
    if (FAILED(hr))
    {
        //
        // The job object may have been deleted.  We can't supply LogTaskError
        // with the name of the run target, since that's on the job object,
        // which we just failed to load.
        //

        LogTaskError(pRun->GetName(),
                     NULL,
                     IDS_LOG_SEVERITY_WARNING,
                     IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                     NULL,
                     (DWORD)hr);
        ERR_OUT("JobPostProcessing Activate", hr);
        LeaveCriticalSection(&m_SvcCriticalSection);
        return;
    }

    //
    // Isolate the executable name.
    //

    TCHAR tszExeName[MAX_PATH + 1];
    GetExeNameFromCmdLine(pJob->GetCommand(), MAX_PATH + 1, tszExeName);

    if (pRun->GetFlags() & RUN_STATUS_FINISHED)
    {
        //
        // Only check the exit code if the job completed normally, that is,
        // it wasn't timed-out or aborted.
        //
        if (!GetExitCodeProcess(pRun->GetHandle(), &dwExitCode))
        {
            LogTaskError(pRun->GetName(),
                         tszExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_CANT_GET_EXITCODE,
                         NULL,
                         GetLastError());
            ERR_OUT("GetExitCodeProcess", GetLastError());
        }
    }
    else
    {
        //
        // BUGBUG : What is written on the job when not complete?
        //
    }

    //
    // PostRunUpdate updates the flags and instance count, so always call it.
    //
    pJob->PostRunUpdate(dwExitCode, pRun->GetFlags() & RUN_STATUS_FINISHED);

    //
    // If the last run and the delete flag is set, delete the job object.
    //

    if (pJob->IsFlagSet(JOB_I_FLAG_NO_MORE_RUNS) &&
        pJob->IsFlagSet(TASK_FLAG_DELETE_WHEN_DONE))
    {
        hr = pJob->Delete();
        if (FAILED(hr))
        {
            LogTaskError(pRun->GetName(),
                         tszExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_CANT_DELETE_JOB,
                         NULL,
                         GetLastError());
            ERR_OUT("JobPostProcessing, delete-when-done", hr);
        }
    }
    else
    {
        //
        // Write the updated status to the job object. If there are sharing
        // violations, retry two times.
        //
        hr = SaveWithRetry(pJob,
                           SAVEP_RUNNING_INSTANCE_COUNT |
                                SAVEP_PRESERVE_NET_SCHEDULE);
        if (FAILED(hr))
        {
            LogTaskError(pRun->GetName(),
                         tszExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_CANT_UPDATE_JOB,
                         NULL,
                         GetLastError());
            ERR_OUT("JobPostProcessing, Saving run-completion-status", hr);
        }
    }

    LeaveCriticalSection(&m_SvcCriticalSection);

#if DBG == 1
#if defined(_CHICAGO_)
    schDebugOut((DEB_ITRACE,
                (pRun->GetFlags() & RUN_STATUS_FINISHED ?
                    "*** Job %s completed with exit code %d\n" :
                    "*** Job %s timed out and was forced closed\n"),
                pRun->GetName(),
                dwExitCode));
#else
    schDebugOut((DEB_ITRACE,
                (pRun->GetFlags() & RUN_STATUS_FINISHED ?
                    "*** Job %S completed with exit code %d\n" :
                    "*** Job %S timed out and was forced closed\n"),
                pRun->GetName(),
                dwExitCode));
#endif // _CHICAGO_

    if (g_fVisible)
    {
#if defined(_CHICAGO_)
        char szBuf[120];
        wsprintf(szBuf,
                 (pRun->GetFlags() & RUN_STATUS_FINISHED ?
                    "Job %s completed with exit code %ld" :
                    "Job %s timed out and was forced closed"),
                 pRun->GetName(),
                 dwExitCode);
        SendMessage(g_hList, LB_ADDSTRING, 0, (LPARAM)szBuf);
#else
        printf((pRun->GetFlags() & RUN_STATUS_FINISHED ?
                "Job %S completed with exit code %d\n" :
                "Job %S timed out and was forced closed\n"),
               pRun->GetName(),
               dwExitCode);
#endif // _CHICAGO_
    }
#endif // DBG

    if (pRun->GetFlags() & RUN_STATUS_FINISHED)
    {
        // Log job finish time & result.
        //
        LogTaskStatus(pRun->GetName(),
                      tszExeName,
                      IDS_LOG_JOB_STATUS_FINISHED,
                      dwExitCode);
    }
    else if (pRun->GetFlags() & RUN_STATUS_ABORTED)
    {
        // Log job closure on abort warning.
        //
        LogTaskError(pRun->GetName(),
                     tszExeName,
                     IDS_LOG_SEVERITY_WARNING,
                     IDS_LOG_JOB_WARNING_ABORTED,
                     &stFinished);
    }
    else if (pRun->GetFlags() & RUN_STATUS_TIMED_OUT)
    {
        // Log job closure on timeout warning.
        //
        LogTaskError(pRun->GetName(),
                     tszExeName,
                     IDS_LOG_SEVERITY_WARNING,
                     IDS_LOG_JOB_WARNING_TIMEOUT,
                     &stFinished,
                     0,
                     IDS_HELP_HINT_TIMEOUT);
    }

    pJob->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   SaveWithRetry
//
//  Synopsis:   Save the job object to disk with failure retry.
//
//  Arguments:  [pJob]      - Job object.
//              [flOptions] - See CJob::SaveP.
//
//  Notes:      This method is called in two places: from RunJobs to save the
//              newly launched job status and from PostJobProcessing to save
//              the exit status. In both cases, the running instance count is
//              saved, as indicated by the SAVEP_RUNNING_INSTANCE_COUNT bit
//              in flOptions.
//
//----------------------------------------------------------------------------
HRESULT
SaveWithRetry(CJob * pJob, ULONG flOptions)
{
    HRESULT hr;

    //
    // Write the updated status to the job object. If there are sharing
    // violations, retry two times.
    //
    for (int i = 0; i < 3; i++)
    {
        hr = pJob->SaveP(NULL, FALSE, flOptions);
        if (SUCCEEDED(hr))
        {
            return S_OK;
        }
        if (hr != HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
        {
            //
            // If we have a failure other than sharing violation, we will
            // retry anyway after reporting the error.
            //
            ERR_OUT("SaveWithRetry, Saving run-completion-status", hr);
        }

        //
        // Wait 300 milliseconds before trying again.
        //
        Sleep(300);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\rpc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rpc.cxx
//
//  Contents:   RPC related routines.
//
//  Classes:    None.
//
//  Functions:  StartRpcServer
//              StopRpcServer
//
//  RPC:
//
//  History:    25-Oct-95   MarkBl  Created.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include "atsvc.h"
#include "SASecRPC.h"

RPC_BINDING_VECTOR * gpBindingVector = NULL;

//
// We have to register protocol sequences and known end points only once
// per process.
//

BOOL gRegisteredProtocolSequences = FALSE;

WCHAR *              grgpwszProtocolSequences[] = {
                            L"ncalrpc",         // Local RPC
                            L"ncacn_ip_tcp",    // Connection-oriented TCP/IP
                            L"ncacn_spx",       // Connection-oriented SPX
                            NULL
};

//+---------------------------------------------------------------------------
//
//  Function:   StartRpcServer
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
StartRpcServer(void)
{
    RPC_STATUS  RpcStatus;
    HRESULT     hr = S_OK;

    //
    // Register protocol sequences and known end points onlt if we have not 
    // already done so in this process.
    //

    if (!gRegisteredProtocolSequences) {

        //
        // Support all available protocols.
        //
        // NB : Named pipe support is handled specifically below.
        //

        for (int i = 0; grgpwszProtocolSequences[i] != NULL; i++)
        {
            RpcStatus = RpcServerUseProtseq(grgpwszProtocolSequences[i],
                                            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                            NULL);

            if (RpcStatus != RPC_S_OK && RpcStatus != RPC_S_PROTSEQ_NOT_SUPPORTED)
            {
                //
                // Bail on error other than protseq not supported; may be out
                // of memory.
                //

                CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));

                goto RpcError;
            }
        }

        //
        // Now, explicitly handle named pipe support. Register a specific
        // endpoint for named pipes.
        //

        RpcStatus = RpcServerUseProtseqEp(L"ncacn_np",
                                          RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                          L"\\PIPE\\atsvc",
                                          NULL);

        if (RpcStatus)
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
            goto RpcError;
        }

        gRegisteredProtocolSequences = TRUE;
    }

    //
    // Register the protocol handles with the endpoint-mapping service.
    //

    if (RpcStatus = RpcServerInqBindings(&gpBindingVector))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        return(HRESULT_FROM_WIN32(RpcStatus));
    }

    // AT service interface.
    //
    RpcStatus = RpcEpRegister(atsvc_ServerIfHandle,
                              gpBindingVector,
                              NULL,
                              NULL);

    if (RpcStatus)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        goto RpcError;
    }

    // Scheduling Agent security interface.
    //
    RpcStatus = RpcEpRegister(sasec_ServerIfHandle,
                              gpBindingVector,
                              NULL,
                              NULL);

    if (RpcStatus)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        goto RpcError;
    }

    //
    // Set up secure RPC. Note, if the RPC client doesn't explicitly state
    // they wish the RPC connection to be secured, the connection defaults
    // to non-secure.
    //

    if (RpcStatus = RpcServerRegisterAuthInfo(NULL,
                                              RPC_C_AUTHN_WINNT,
                                              NULL,
                                              NULL))
    {
        if (RpcStatus == RPC_S_UNKNOWN_AUTHN_SERVICE)
        {
            //
            // This happens when NTLMSSP -- which is used for authentication
            // on the named pipes transport -- is not installed.  Typically
            // happens when "Client for Microsoft Networks" is not installed.
            // However, local users can still be authenticated by LRPC.
            //
            // Note, if "Client for Microsoft Networks" is subsequently
            // installed, remote callers will get RPC_S_UNKNOWN_AUTHN_SERVICE
            // until the service is restarted.  BUGBUG  Fix this by noticing
            // the PNP event that indicates the net has arrived, and then
            // calling RpcServerRegisterAuthInfo again.
            //
            schDebugOut((DEB_ERROR, "**** No authentication provider is "
                         "installed.  Remote clients will get error "
                         "RPC_S_UNKNOWN_AUTHN_SERVICE.\n"));
        }
        else
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
            goto RpcError;
        }
    }

    //
    // Finally, register the interface(s) and listen on them.
    //

    if (RpcStatus = RpcServerRegisterIfEx(atsvc_ServerIfHandle,
                                          NULL,
                                          NULL,
                                          RPC_IF_AUTOLISTEN,
                                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                          NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        goto RpcError;
    }

    if (RpcStatus = RpcServerRegisterIfEx(sasec_ServerIfHandle,
                                          NULL,
                                          NULL,
                                          RPC_IF_AUTOLISTEN,
                                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                          NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        goto RpcError;
    }

    return(S_OK);

RpcError:

    if (gpBindingVector != NULL)
    {
        RpcBindingVectorFree(&gpBindingVector);
        gpBindingVector = NULL;
    }

    return(HRESULT_FROM_WIN32(RpcStatus));
}

//+---------------------------------------------------------------------------
//
//  Function:   StopRpcServer
//
//  Synopsis:   Stop the RPC server.
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
StopRpcServer(void)
{
    RpcServerUnregisterIf(atsvc_ServerIfHandle, NULL, 0);
    RpcServerUnregisterIf(sasec_ServerIfHandle, NULL, 0);

    if (gpBindingVector != NULL)
    {
        RpcEpUnregister(atsvc_ServerIfHandle, gpBindingVector, NULL);
        RpcEpUnregister(sasec_ServerIfHandle, gpBindingVector, NULL);
        RpcBindingVectorFree(&gpBindingVector);

        gpBindingVector = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\runjob.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       runjob.cxx
//
//  Contents:   Functions to run the target file.
//
//  History:    02-Jul-96 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <lmerr.h>          // NERR_Success
#include <dsgetdc.h>        // DsGetDcName
#include <lmaccess.h>       // NetUserGetInfo
#include <lmapibuf.h>       // NetApiBufferFree
#include <netevent.h>       // for logging to event log
#include "svc_core.hxx"
#include "..\inc\resource.h"
#include "path.hxx"
#include "..\inc\common.hxx"
#include "..\inc\runobj.hxx"
#include <wtsapi32.h>

HRESULT
ComposeBatchParam(
    LPCTSTR pwszPrefix,
    LPCTSTR wszAppPathName,
    LPCTSTR pwszParameters,
    LPTSTR * ppwszCmdLine
    );

HRESULT
ComposeParam(BOOL fTargetIsExe,
             LPTSTR ptszRunTarget,
             LPTSTR ptszParameters,
             LPTSTR * pptszCmdLine);

#if !defined(_CHICAGO_)
#include <userenv.h>  // LoadUserProfile

BOOL AllowInteractiveServices(void);
BOOL LogonAccount(
                LPCWSTR   pwszJobFile,
                CJob *    pJob,
                DWORD *   pdwErrorMsg,
                HRESULT * pdwSpecificError,
				CRun *	  pRun,
                HANDLE *  phToken,
                BOOL *    pfTokenIsShellToken,
                LPWSTR *  ppwsz,
                HANDLE *  phUserProfile);
HANDLE
LoadAccountProfile(
    HANDLE  hToken,
    LPCWSTR pwszUser,
    LPCWSTR pwszDomain);

BOOL GetUserTokenFromSession(
	LPTSTR lpszUsername,
	LPTSTR lpszDomain,
	PHANDLE phUserToken
);

DWORD   SchedUPNToAccountName(
                IN  LPCWSTR lpUPN,
                OUT LPWSTR  *ppAccountName);
#endif // !defined(_CHICAGO_)

void InitializeStartupInfo(
                CJob *        pJob,
                LPTSTR        ptszDesktop,
                STARTUPINFO * psi);
HRESULT MapFindExecutableError(HINSTANCE hRet);
BOOL WaitForStubExe(HANDLE hProcess);


#if !defined(_CHICAGO_)
#define WSZ_INTERACTIVE_DESKTOP L"WinSta0\\Default"
#define WSZ_SA_DESKTOP          L"SAWinSta\\SADesktop"
#define CMD_PREFIX          TEXT("cmd.exe /c ")
#define STUB_PREFIX         L"RUNDLL32.EXE Shell32.DLL,ShellExec_RunDLL ?0x400?"
                                // 0x400 is SEE_MASK_FLAG_NO_UI
#define USERNAME            L"USERNAME"
#define USERDOMAIN          L"USERDOMAIN"
#define USERPROFILE         L"USERPROFILE"
#endif // !defined(_CHICAGO_)

#define DQUOTE              TEXT("\"")
#define SPACE               TEXT(" ")

//
// IMPORTANT: it is assumed that when _CHICAGO_ is defined, then UNICODE is
// NOT defined. The if clause of this preprocessor macro will fail to build
// if BOTH _CHICAGO_ and UNICODE are defined.
//

#if defined(_CHICAGO_)

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunWin95Job
//
//  Synopsis:   Run a Win95 job.
//
//  Arguments:  [pJob] - the job object to be run.
//              [pRun] - the run information object.
//              [phrRet] - a place to return launch failure info.
//              [pdwErrMsgID] - message ID for failure reporting.
//
//  Returns:    S_OK - if job launched.
//              S_FALSE - if job not launched.
//              HRESULR - other, fatal, error.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunWin95Job(CJob * pJob, CRun * pRun, HRESULT * phrRet,
                          DWORD * pdwErrMsgID)
{
    LPSTR pszWorkingDir = NULL, pszRunTarget = NULL, pszParameters = NULL;
    DWORD cch;
    HRESULT hr;

    *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;

    ULONG cchRunTarget = wcslen(pJob->m_pwszApplicationName) + 1;
    pszRunTarget = new CHAR[2 * cchRunTarget];

    if (pszRunTarget == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("CSchedWorker::RunWin95Job", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    hr = UnicodeToAnsi(pszRunTarget,
                       pJob->m_pwszApplicationName,
                       2 * cchRunTarget);

    if (FAILED(hr))
    {
        ERR_OUT("CSchedWorker::RunWin95Job", hr);
        delete [] pszRunTarget;
        return hr;
    }

    if (pJob->m_pwszWorkingDirectory != NULL)
    {
        cch = wcslen(pJob->m_pwszWorkingDirectory) + 1;

        // Add one to the count for the null terminator.
        // Assume all characters are double-byte.
        //
        pszWorkingDir = new CHAR[cch * 2];

        if (pszWorkingDir == NULL)
        {
            LogServiceError(IDS_NON_FATAL_ERROR,
                            ERROR_OUTOFMEMORY,
                            IDS_HELP_HINT_CLOSE_APPS);
            ERR_OUT("CSchedWorker::RunWin95Job", E_OUTOFMEMORY);
            delete pszRunTarget;
            return E_OUTOFMEMORY;
        }

        hr = UnicodeToAnsi(pszWorkingDir, pJob->m_pwszWorkingDirectory, cch*2);
        if (FAILED(hr))
        {
            LogServiceError(IDS_NON_FATAL_ERROR,
                            hr,
                            IDS_HELP_HINT_BADDIR);
            ERR_OUT("CSchedWorker::RunWin95Job", hr);
            delete pszWorkingDir;
            delete pszRunTarget;
            return hr;
        }
    }

#if DBG == 1
    if (g_fVisible)
    {
        CHAR szBuf[120];
        wsprintf(szBuf, "*** Running job %s", pJob->m_ptszFileName);
        SendMessage(g_hList, LB_ADDSTRING, 0, (LPARAM)szBuf);
    }

    schDebugOut((DEB_TRACE, "*** Running job %s\n", pJob->m_ptszFileName));

    schDebugOut((DEB_USER3, "*** with MaxRunTime of %u\n",
                 pJob->m_dwMaxRunTime));
#endif // DBG == 1

    hr = S_OK;
    CHAR szAppPathName[MAX_PATH + 1];
    LPSTR pszCmdLine = NULL;

    //
    // Change to the job's working dir before searching for the
    // executable.
    //
    if (pszWorkingDir != NULL)
    {
        if (!SetCurrentDirectory(pszWorkingDir))
        {
            //
            // An invalid working directory may not prevent the job from
            // running, so this is not a fatal error. Log it though, to
            // inform the user.
            //

            CHAR szExeName[MAX_PATH + 1];

            GetExeNameFromCmdLine(pJob->GetCommand(), MAX_PATH + 1, szExeName);

            LogTaskError(pRun->GetName(),
                         szExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_BAD_DIR,
                         NULL,
                         GetLastError(),
                         IDS_HELP_HINT_BADDIR);

            delete [] pszWorkingDir;
            //
            // Set the pointer to NULL so that CreateProcess will ignore it.
            //
            pszWorkingDir = NULL;
        }
    }

    //
    // Check if the run target has an extension and determine if the run
    // target is a program or a document. If there is no extension, then it
    // is assumed that it is a program.
    //

    BOOL fTargetIsExe = FALSE;

    if (*PathFindExtension(pszRunTarget) == '\0' || PathIsExeA(pszRunTarget))
    {
        fTargetIsExe = TRUE;
    }

    if (fTargetIsExe)
    {
        DBG_OUT("Job target is an executable");

        CHAR SecondChar = * CharNext(pszRunTarget);
        if (SecondChar == ':' || SecondChar == '\\')
        {
            //
            // If the second character is a colon or a backslash, then this
            // must be a fully qualified path. If so, don't call SearchPath.
            //

            lstrcpy(szAppPathName, pszRunTarget);
        }
        else
        {
            //
            // Look for the application.
            //

            DWORD cchFound;

            cchFound = SearchPath(NULL, pszRunTarget, DOTEXE, MAX_PATH + 1,
                                  szAppPathName, NULL);

            if (!cchFound || cchFound >= MAX_PATH)
            {
                //
                // Error, cannot locate job target application. Note that this
                // is not a fatal error (probably file-not-found) so
                // processing will continue with other jobs in the list.
                //

                //
                // phrRet and pdwErrMsgId are used by LogTaskError on return.
                //
                *phrRet = HRESULT_FROM_WIN32(GetLastError());
                *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;

                hr = S_FALSE;
                goto CleanUp;
            }
        }

        if (pJob->m_pwszParameters != NULL)
        {
            cch = wcslen(pJob->m_pwszParameters) + 1;

            pszParameters = new CHAR[cch * 2];

            if (pszParameters == NULL)
            {
                LogServiceError(IDS_NON_FATAL_ERROR,
                                ERROR_OUTOFMEMORY,
                                IDS_HELP_HINT_CLOSE_APPS);
                ERR_OUT("CSchedWorker::RunWin95Job", E_OUTOFMEMORY);

                hr = E_OUTOFMEMORY;
                goto CleanUp;
            }

            hr = UnicodeToAnsi(pszParameters, pJob->m_pwszParameters, cch * 2);
            if (FAILED(hr))
            {
                LogServiceError(IDS_NON_FATAL_ERROR,
                                hr,
                                IDS_HELP_HINT_PARAMETERS);
                ERR_OUT("CSchedWorker::RunWin95Job", hr);
                goto CleanUp;
            }

        }

        schDebugOut((DEB_ITRACE, "*** Running %s\n", szAppPathName));
    }
    else
    {
        DBG_OUT("Job target is a document");

        HINSTANCE hRet = FindExecutable(pszRunTarget,
                                        pszWorkingDir,
                                        szAppPathName);
        if (hRet <= (HINSTANCE)32)
        {
            //
            // This is not a fatal error, so RunJobs will just log the failure
            // and continue with any other pending jobs.
            //

            //
            // phrRet and pdwErrMsgId are used by LogTaskError on return.
            //
            *phrRet = MapFindExecutableError(hRet);
            *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;

            hr = S_FALSE;
            goto CleanUp;
        }

        //
        // If running a document by association, the parameter property is
        // ignored and the run target property is passed as the parameter.
        //
        pszParameters = pszRunTarget;
        pszRunTarget = szAppPathName;

        schDebugOut((DEB_ITRACE, "*** Running %s\n", pszParameters));
    }

    //
    // Add the app name as the first token of the command line param.
    //

    if (pszParameters != NULL)
    {
        hr = ComposeParam(fTargetIsExe,
                          pszRunTarget,
                          pszParameters,
                          &pszCmdLine);

        if (FAILED(hr))
        {
            goto CleanUp;
        }

        schDebugOut((DEB_ITRACE, "*** With cmd line '%s'\n", pszCmdLine));
    }

    PROCESS_INFORMATION processinfo;
    STARTUPINFO startupinfo;

    InitializeStartupInfo(pJob, NULL, &startupinfo);

    if (pJob->IsFlagSet(TASK_FLAG_HIDDEN))
    {
        startupinfo.wShowWindow = SW_HIDE;
    }

    //
    // Modify the path if the application has an app path registry entry
    //

    BOOL  fChangedPath;
    LPSTR pszSavedPath;

    fChangedPath = SetAppPath(szAppPathName, &pszSavedPath);

    //
    // Launch job.
    //

    if (CreateProcess(szAppPathName,
                      pszCmdLine,
                      NULL,                 // process security attributes
                      NULL,                 // thread security attributes
                      FALSE,                // inherit handles?
                      pJob->m_dwPriority,   // creation flags
                      NULL,                 // environment
                      pszWorkingDir,
                      &startupinfo,
                      &processinfo))
    {
        //
        // Successfully launched job.
        //
        hr = S_OK;

        CloseHandle(processinfo.hThread);

        pRun->SetHandle(processinfo.hProcess);
        pRun->SetProcessId(processinfo.dwProcessId);
    }
    else
    {
        //
        // Job launch failed.
        //
        hr = S_FALSE;

        //
        // phrRet and pdwErrMsgId are used by LogTaskError on return.
        //
        *phrRet = HRESULT_FROM_WIN32(GetLastError());
        *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;
        schDebugOut((DEB_ERROR, "*** CreateProcess for job %s failed, %lu\n",
                     pJob->m_ptszFileName, GetLastError()));
    }

    //
    // Change back to the service's working directory.
    //
    if (pszWorkingDir != NULL)
    {
        if (!SetCurrentDirectory(m_ptszSvcDir))
        {
            LogServiceError(IDS_NON_FATAL_ERROR, GetLastError(), 0);
            ERR_OUT("RunJobs: changing back to the service's directory",
                    HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    //
    // Restore the path environment variable, if it was changed
    //

    if (fChangedPath)
    {
        SetEnvironmentVariable(TEXT("PATH"), pszSavedPath);
        delete [] pszSavedPath;
        pszSavedPath = NULL;
    }

CleanUp:

    if (fTargetIsExe)
    {
        //
        // If !fTargetIsExe, then pszRunTarget points to szAppPathName, which
        // we don't want to delete. So only delete if the target is an exe.
        //
        delete [] pszRunTarget;
    }
    if (pszParameters != NULL)
    {
        delete [] pszParameters;
    }
    if (pszCmdLine != NULL)
    {
        delete [] pszCmdLine;
    }
    if (pszWorkingDir != NULL)
    {
        delete [] pszWorkingDir;
    }

    return hr;
}

#else   // !defined(_CHICAGO_)


//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunNTJob
//
//  Synopsis:   Run an NT Job.
//
//  Arguments:  [pJob] - the job object to be run.
//              [pRun] - the run information object.
//              [phrRet] - a place to return launch failure info.
//              [pdwErrMsgID] - message ID for failure reporting.
//
//  Returns:    S_OK - if job launched.
//              S_FALSE - if job not launched.
//              HRESULT - other, fatal, error.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunNTJob(CJob * pJob, CRun * pRun, HRESULT * phrRet,
                       DWORD * pdwErrMsgID)
{
    LPWSTR pwszRunTarget,
           pwszWorkingDir = pJob->m_pwszWorkingDirectory,
           pwszParameters = pJob->m_pwszParameters;
    DWORD  cch;
    BOOL   fRanJob              = FALSE;
    LPTSTR ptszDesktop          = NULL;
    HANDLE hImpersonationHandle = NULL;
    HANDLE hToken               = NULL;
    BOOL   fTokenIsShellToken   = FALSE;
    HANDLE hUserProfile         = NULL;
    BOOL   fTargetIsExe         = FALSE;
    BOOL   fTargetIsBinaryExe   = FALSE;
    BOOL   fUseStubExe          = FALSE;


    *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;

    pwszRunTarget = new WCHAR[lstrlen(pJob->m_pwszApplicationName) + 1];

    if (pwszRunTarget == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("CSchedWorker::RunNTJob", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    lstrcpy(pwszRunTarget, pJob->m_pwszApplicationName);

#if DBG == 1
    if (g_fVisible)
    {
        printf("*** Running job %S\n", pJob->m_ptszFileName);
    }
#endif // DBG == 1

    schDebugOut((DEB_TRACE, "*** Running job %S\n", pJob->m_ptszFileName));

    schDebugOut((DEB_USER3, "*** with MaxRunTime of %u\n",
                 pJob->m_dwMaxRunTime));

    HRESULT hr = S_OK;
    WCHAR wszAppPathName[MAX_PATH + 1];
    LPWSTR pwszCmdLine = NULL;

    //
    // Logon the account associated with the job and set the security token
    // and desktop appropriately based on several factors: is this an AT job,
    // is the account the same as the currently logged-on user, etc.
    //

    if (!LogonAccount(pJob->m_ptszFileName,
                      pJob,
                      pdwErrMsgID,
                      phrRet,
					  pRun,
                      &hToken,
                      &fTokenIsShellToken,
                      &ptszDesktop,
                      &hUserProfile))
    {
        hr = S_FALSE;
        goto cleanup;
    }

	if( NULL != ptszDesktop )
	{
		hr = pRun->SetDesktop( _tcschr( ptszDesktop, '\\' ) + 1 );
		if( FAILED( hr ) )
		{
		    LogServiceError(IDS_NON_FATAL_ERROR,
		                    ERROR_OUTOFMEMORY,
		                    IDS_HELP_HINT_CLOSE_APPS);
		    ERR_OUT("CSchedWorker::RunNTJob", E_OUTOFMEMORY);
		    goto cleanup;
		}

		TCHAR ptszStation[MAX_PATH];

		ZeroMemory( ptszStation, MAX_PATH );

		wcsncpy( ptszStation, ptszDesktop, 
			( _tcschr( ptszDesktop, '\\' ) - ptszDesktop ) );

		hr = pRun->SetStation( ptszStation );

		if( FAILED( hr ) )
		{
		    LogServiceError(IDS_NON_FATAL_ERROR,
		                    ERROR_OUTOFMEMORY,
		                    IDS_HELP_HINT_CLOSE_APPS);
		    ERR_OUT("CSchedWorker::RunNTJob", E_OUTOFMEMORY);
		    goto cleanup;
		}
	}

	//
    // NOTE: After this point, if fTokenIsShellToken is TRUE, we must leave
    // gUserLogonInfo.CritSection.
    //

    //
    // For all but AT jobs, impersonate the user to ensure the user
    // gets access checked correctly on the file executed.
    //

    hImpersonationHandle = NULL;

    if (!pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE))
    {
        if (fTokenIsShellToken)
        {
            hImpersonationHandle = ImpersonateLoggedInUser();
        }
        else
        {
            hImpersonationHandle = ImpersonateUser(hToken,
                                                   hImpersonationHandle);
        }

        if (hImpersonationHandle == NULL)
        {
            *phrRet      = 0;
            *pdwErrMsgID = IDS_ACCOUNT_LOGON_FAILED;
            hr = S_FALSE;
            goto cleanup2;
        }
    }

    //
    // Change to the job's working dir before searching for the
    // executable.
    //
    if (pwszWorkingDir != NULL)
    {
        if (!SetCurrentDirectory(pwszWorkingDir))
        {
            //
            // An invalid working directory may not prevent the job from
            // running, so this is not a fatal error. Log it though, to
            // inform the user.
            //
            TCHAR tszExeName[MAX_PATH + 1];

            GetExeNameFromCmdLine(pJob->GetCommand(), MAX_PATH + 1, tszExeName);

            LogTaskError(pRun->GetName(),
                         tszExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_BAD_DIR,
                         NULL,
                         GetLastError(),
                         IDS_HELP_HINT_BADDIR);

            //
            // Set the pointer to NULL so that CreateProcess will ignore it.
            //
            pwszWorkingDir = NULL;
        }
    }

    //
    // Check if the run target has an extension and determine if the run
    // target is a program, a batch or command file (.bat or .cmd), or a
    // document.  If there is no extension, then it is assumed that it is a
    // program.
    //

    if (*PathFindExtension(pwszRunTarget) == '\0')
    {
        fTargetIsExe = TRUE;
        fTargetIsBinaryExe = TRUE;
    }
    else if (PathIsExeW(pwszRunTarget))
    {
        fTargetIsExe = TRUE;

        if (PathIsBinaryExeW(pwszRunTarget))
        {
            fTargetIsBinaryExe = TRUE;
        }
    }

    if (fTargetIsExe)
    {
        if (fTargetIsBinaryExe)
        {
            DBG_OUT("Job target is a binary executable");
        }
        else
        {
            DBG_OUT("Job target is a batch file");
        }

        if (pwszRunTarget[1] == L':' || pwszRunTarget[1] == L'\\')
        {
            //
            // If the second character is a colon or a backslash, then this
            // must be a fully qualified path. If so, don't call SearchPath.
            //

            wcscpy(wszAppPathName, pwszRunTarget);
        }
        else
        {
            //
            // Build a full path name for the application.
            //

            DWORD cchFound;

            cchFound = SearchPath(NULL, pwszRunTarget, DOTEXE, MAX_PATH + 1,
                                  wszAppPathName, NULL);

            if (!cchFound || cchFound >= MAX_PATH)
            {
                //
                // Error, cannot locate job target application. Note that this
                // is not a fatal error (probably file-not-found) so
                // processing will continue with other jobs in the list.
                //

                //
                // phrRet and pdwErrMsgId are used by LogTaskError on return.
                //
                *phrRet = HRESULT_FROM_WIN32(GetLastError());
                *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;

                hr = S_FALSE;
                goto cleanup3;
            }
        }

        if (fTargetIsBinaryExe)
        {
            schDebugOut((DEB_ITRACE, "*** Running '%S'\n", wszAppPathName));
        }
    }
    else
    {
        DBG_OUT("Job target is a document");

        HINSTANCE hRet = FindExecutable(pwszRunTarget,
                                        pwszWorkingDir,
                                        wszAppPathName);
        if (hRet == (HINSTANCE)31)
        {
            //
            // No association found.  Try using rundll32.exe with ShellExecute
            // to run the document.
            //
            fUseStubExe = TRUE;

            fTargetIsExe = TRUE;
            fTargetIsBinaryExe = FALSE;

            wcscpy(wszAppPathName, pwszRunTarget);
        }
        else if (hRet < (HINSTANCE)32)
        {
            //
            // This is not a fatal error, so RunJobs will just log the failure
            // and continue with any other pending jobs.
            //

            //
            // phrRet and pdwErrMsgId are used by LogTaskError on return.
            //
            schDebugOut((DEB_ERROR, "FindExecutable FAILED with %d for '%ws'\n",
                         hRet, pwszRunTarget));
            *phrRet = MapFindExecutableError(hRet);
            *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;

            hr = S_FALSE;
            goto cleanup3;
        }
        else
        {
            //
            // If running a document by association, the parameter property is
            // ignored and the run target property is passed as the parameter.
            //
            pwszParameters = pwszRunTarget;
            pwszRunTarget = wszAppPathName;

            schDebugOut((DEB_ITRACE, "*** Running '%S'\n", pwszParameters));
        }
    }

    if (fTargetIsExe && !fTargetIsBinaryExe)
    {
        hr = ComposeBatchParam(fUseStubExe ? STUB_PREFIX : CMD_PREFIX,
                               wszAppPathName,
                               pwszParameters,
                               &pwszCmdLine);

        if (FAILED(hr))
        {
            goto cleanup3;
        }

        schDebugOut((DEB_ITRACE, "*** Running batch file '%S'\n", pwszCmdLine));
    }
    else
    {
        //
        // Add the app name as the first token of the command line param.
        //

        if (pwszParameters != NULL)
        {
            hr = ComposeParam(fTargetIsExe,
                              pwszRunTarget,
                              pwszParameters,
                              &pwszCmdLine);

            if (FAILED(hr))
            {
                goto cleanup3;
            }

            schDebugOut((DEB_ITRACE, "*** With cmd line '%S'\n", pwszCmdLine));
        }
    }

    PROCESS_INFORMATION processinfo;
    STARTUPINFO startupinfo;

    InitializeStartupInfo(pJob, ptszDesktop, &startupinfo);

    if (pJob->IsFlagSet(TASK_FLAG_HIDDEN))
    {
        startupinfo.wShowWindow = SW_HIDE;
    }

    //
    // Modify the path if the application has an app path registry entry
    //

    BOOL  fChangedPath;
    LPWSTR pwszSavedPath;

    fChangedPath = SetAppPath(wszAppPathName, &pwszSavedPath);

    //
    // Launch job.
    //
    // NB : Must call CreateProcess when the token handle is
    //      NULL (in the case of AT jobs running as local system),
    //      since CreateProcessAsUser rejects NULL handles.
    //      Alternatively, OpenProcessToken could be used,
    //      but then we have to deal with the failure cases,
    //      logging appropriate errors, closing the token
    //      handle, etc.
    //

    if (hToken == NULL)
    {
        fRanJob = CreateProcess((fTargetIsExe && !fTargetIsBinaryExe) ?
                                    NULL : wszAppPathName,
                                pwszCmdLine,
                                NULL,
                                NULL,
                                FALSE,
                                pJob->m_dwPriority          |
                                    CREATE_NEW_CONSOLE      |
                                    CREATE_SEPARATE_WOW_VDM,
                                NULL,
                                pwszWorkingDir,
                                &startupinfo,
                                &processinfo);
    }
    else
    {
        LPVOID  lpEnvironment;

        //
        // Launch the job with the appropriate environment
        //

        schDebugOut((DEB_ITRACE, "Calling CreateEnvironmentBlock...\n"));
        if (!CreateEnvironmentBlock(&lpEnvironment,
                                    hToken,
                                    FALSE))
        {
            ERR_OUT("CreateEnvironmentBlock", GetLastError());
            lpEnvironment = NULL;
        }
        else
        {
            schDebugOut((DEB_ITRACE, "... CreateEnvironmentBlock succeded\n"));
        }

        fRanJob = CreateProcessAsUser(hToken,
                                      (fTargetIsExe && !fTargetIsBinaryExe) ?
                                          NULL : wszAppPathName,
                                      pwszCmdLine,
                                      NULL,
                                      NULL,
                                      FALSE,
                                      pJob->m_dwPriority          |
                                          CREATE_NEW_CONSOLE      |
                                          CREATE_SEPARATE_WOW_VDM |
                                          CREATE_UNICODE_ENVIRONMENT,
                                      lpEnvironment,
                                      pwszWorkingDir,
                                      &startupinfo,
                                      &processinfo);

        //
        // DestroyEnvironmentBlock handles NULL
        //

        DestroyEnvironmentBlock(lpEnvironment);
    }

    if (fRanJob && fUseStubExe)
    {
        //
        // If we launched the stub exe, we must wait for it to exit, and check
        // its exit code.
        //
        fRanJob = WaitForStubExe(processinfo.hProcess);

        //
        // It's not interesting to copy info about the stub exe into pRun
        //
        CloseHandle(processinfo.hProcess);
        CloseHandle(processinfo.hThread);
        processinfo.hProcess = 0;
        processinfo.dwProcessId = 0;
    }

    if (fRanJob)
    {
        //
        // Successfully launched job.
        //
        hr = S_OK;

        pRun->SetHandle(processinfo.hProcess);
        pRun->SetProcessId(processinfo.dwProcessId);

        if (fUseStubExe)
        {
            pRun->ClearFlag(RUN_STATUS_RUNNING);    // was set by SetHandle
            fRanJob = FALSE;    // clean up profile handles below
        }
        else
        {
            CloseHandle(processinfo.hThread);

			if(!fTokenIsShellToken)
            {
                pRun->SetProfileHandles(hToken, hUserProfile);
            }
        }
    }
    else
    {
        //
        // Job launch failed.
        //
        hr = S_FALSE;

        //
        // phrRet and pdwErrMsgId are used by LogTaskError on return.
        //
        *phrRet = HRESULT_FROM_WIN32(GetLastError());
        *pdwErrMsgID = IDS_LOG_JOB_ERROR_FAILED_START;
        schDebugOut((DEB_ERROR, "*** CreateProcess for job %S failed, %lu\n",
                     pJob->m_ptszFileName, GetLastError()));
    }

    if (fChangedPath)
    {
        SetEnvironmentVariable(L"PATH", pwszSavedPath);
        delete [] pwszSavedPath;
        pwszSavedPath = NULL;
    }

    //
    // If impersonating, stop.
    //

cleanup3:

    if (!pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE))
    {
        StopImpersonating(hImpersonationHandle, !fTokenIsShellToken);
    }

cleanup2:

    if (fTokenIsShellToken)
    {
        LeaveCriticalSection(gUserLogonInfo.CritSection);
    }

cleanup:

    //
    // If the job ran successfully, then the CRun object pointed to by pRun
    // has the profile and user tokens and will release them when the job
    // quits.  If the job didn't run, however, release them here.
    //

    if (!fRanJob)
    {
        if (hUserProfile)
        {
            UnloadUserProfile(hToken, hUserProfile);
			pRun->SetProfileHandles( NULL, NULL );  //clear members for the CRun destruction
													//and UnloadUserProfile
        }
        if (!fTokenIsShellToken && hToken)
        {
            CloseHandle(hToken);
        }
    }

    //
    // Change back to the service's working directory.
    //
    if (pwszWorkingDir != NULL)
    {
        if (!SetCurrentDirectory(m_ptszSvcDir))
        {
            LogServiceError(IDS_NON_FATAL_ERROR, GetLastError(), 0);
            ERR_OUT("RunJobs: changing back to the service's directory",
                    HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    if (pwszRunTarget != wszAppPathName)
    {
        delete [] pwszRunTarget;
    }
    else
    {
        delete [] pwszParameters;
    }

    if (pwszCmdLine != NULL)
    {
        delete [] pwszCmdLine;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   LogonAccount
//
//  Synopsis:   Retrieve the account information associated with the job
//              and logon.
//
//              Non-AT jobs:
//              Account == Current logged on user:
//              If the logon succeeds and the account matches that of the
//              currently logged on user, return the shell security token
//              to be used with CreateProcessAsUser. This enables jobs to
//              show up on the user's desktop.
//
//              Account != Current logged on user or no user logged on:
//              If the logon succeeds, but the currently logged on user is
//              different than the account, or there is no-one logged on,
//              return the account token. Also return the scheduling agent's
//              desktop name in the desktop return argument so this job can
//              run on it.
//
//              AT jobs:
//              Ensure the AT job owner is an administrator and return an
//              account token.  AT jobs never get the shell token, since
//              that's how the original schedule service worked.  Also
//              return the desktop name, "WinSta0\Default".
//
//  Arguments:  [pwszJobFile]         -- Path to the job object file.
//              [pJob]                -- Job object to execute under the
//                                       associated account.
//              [pdwErrorMsg]         -- SCHED_E error message on error.
//              [pdwSpecificError]    -- HRESULT on error.
//              [phToken]             -- Returned token.
//              [pfTokenIsShellToken] -- If TRUE, the token returned is the
//                                       shell's.
//              [ppwszDesktop]        -- Desktop to launch the job on.
//              [phUserProfile]       -- user profile token
//
//  Returns:    TRUE  -- Logon successful.
//              FALSE -- Logon failure.
//
//  Notes:      DO NOT delete:
//                  *pptszDestkop. If non-NULL, it refers to a static string.
//                  *phToken if *pfTokenIsShellToken == TRUE. This token
//                    cannot be duplicated. You delete it and you've got
//                    problems.
//              If *pfTokenIsShellToken, the logon session critical section
//              has been entered! Right after the call to CreateProcessAsUser
//              leave this critical section if this flag value is TRUE.
//
//-----------------------------------------------------------------------------
BOOL
LogonAccount(LPCWSTR   pwszJobFile,
             CJob *    pJob,
             DWORD *   pdwErrorMsg,
             HRESULT * phrSpecificError,
			 CRun *	   pRun,
             HANDLE *  phToken,
             BOOL *    pfTokenIsShellToken,
             LPWSTR *  ppwszDesktop,
             HANDLE *  phUserProfile)
{
    JOB_CREDENTIALS jc;
    HANDLE          hToken;
    HRESULT         hr;
    WCHAR           wszProfilePath[MAX_PATH+1] = L"";
    ULONG           cchPath = ARRAY_LEN(wszProfilePath);

    *pdwErrorMsg         = 0;
    *phrSpecificError    = S_OK;
    *phToken             = NULL;
    *pfTokenIsShellToken = FALSE;
    *ppwszDesktop        = NULL;
    *phUserProfile       = NULL;

    if (pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE))
    {
        //
        // Verify the job's signature.
        //
        if (! pJob->VerifySignature())
        {
            *phrSpecificError = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            *pdwErrorMsg      = IDS_FILE_ACCESS_DENIED;
            return(FALSE);
        }

        *ppwszDesktop = WSZ_INTERACTIVE_DESKTOP;

        hr = I_GetNSAccountInformation(&jc);

        if (SUCCEEDED(hr))
        {
            if (hr == S_OK)
            {
                if (!LogonUser(jc.wszAccount,
                               jc.wszDomain,
                               jc.wszPassword,
                               LOGON32_LOGON_BATCH,
                               LOGON32_PROVIDER_DEFAULT,
                               &hToken))
                {
                    *pdwErrorMsg      = IDS_NS_ACCOUNT_LOGON_FAILED;
                    *phrSpecificError = HRESULT_FROM_WIN32(GetLastError());
                }

                //
                // Don't leave the plain-text password on the stack.
                //

                ZERO_PASSWORD(jc.wszPassword);

                if (*phrSpecificError)
                {
                    return(FALSE);
                }

                // If the job was scheduled to run in any account other than LocalSystem account
                if ((!jc.fIsPasswordNull) ||(jc.wszAccount[0] != L'\0'))
                {
                    // If Fast User Switching is enabled and the task user
                    // is logged on in any of the sessions then use the session's 
                    // user token in place of that obtained above so any UI associated 
                    // with the job can show up on the user's desktop.

                    // If terminal serveice is running but FUS is disabled, WTSEnumerateSessions
                    // will return the only user logged on. If the username and domain name of that 
                    // user matches with the jc.wszDomain and jc.wszAccount respectively, then  
                    // GetUserTokenFromSession will return TRUE with the token of that user

                    HANDLE hSessionUserToken = INVALID_HANDLE_VALUE;
                    BOOL bUserLoggedOn = GetUserTokenFromSession(jc.wszAccount,jc.wszDomain,&hSessionUserToken);

                    if(bUserLoggedOn)
                    {
                        schDebugOut((DEB_TRACE, "*** user session found\n"));

                        if (!jc.fIsPasswordNull)
                        {
                            pRun->SetProfileHandles(hSessionUserToken, *phUserProfile);
                            *ppwszDesktop = WSZ_INTERACTIVE_DESKTOP;
                        }

                        hToken = hSessionUserToken;
                    }
                }

				*phToken = hToken;
                *phUserProfile = LoadAccountProfile(hToken,
                                                    jc.wszAccount,
                                                    jc.wszDomain);
            }
        }
        else
        {
            CHECK_HRESULT(hr);
            *pdwErrorMsg      = IDS_FAILED_NS_ACCOUNT_RETRIEVAL;
            *phrSpecificError = hr;
            return(FALSE);
        }
    }
    else 
    {
        hr = I_GetAccountInformation(pJob->GetFileName(), &jc);

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            *pdwErrorMsg      = IDS_FAILED_ACCOUNT_RETRIEVAL;
            *phrSpecificError = hr;
            return(FALSE);
        }

        //
        // If the job was set with a NULL password, we don't need to log it on.
        //
        if (jc.fIsPasswordNull)
        {
            //
            // If the job was scheduled to run in the LocalSystem account
            // (Accountname is the empty string), the NULL password is valid.
            //
            if (jc.wszAccount[0] == L'\0')
            {
                //
                // It's LocalSystem, so we don't need to log on the account.
                // Since the token is zeroed out above, this works
                //
                schDebugOut((DEB_TRACE, "Running %ws as LocalSystem\n",
                             pJob->GetFileName()));
                *ppwszDesktop = WSZ_SA_DESKTOP;
                return(TRUE);
            }
            else
            {
                //
                // It's not LocalSystem, so make sure this job has
                // the appropriate flags for a NULL password set
                //
                if (!pJob->IsFlagSet(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))
                {
                    schDebugOut((DEB_ERROR, "%ws is scheduled to run in "
                                 "a user account with a NULL password, but"
                                 " lacks TASK_FLAG_RUN_ONLY_IF_LOGGED_ON\n",
                                 pJob->GetFileName()));
                    //
                    // Not a completely accurate error message, but since there
                    // is no UI for this task option, it's good enough.
                    //
                    *pdwErrorMsg        = IDS_ACCOUNT_LOGON_FAILED;
                    *phrSpecificError   = SCHED_E_UNSUPPORTED_ACCOUNT_OPTION;
                }
            }
        }
        else
        {
            //
            // If the name was stored as a UPN, convert it to a SAM name first.
            //
            if (jc.wszDomain[0] == L'\0')
            {
                LPWSTR pwszSamName;
                DWORD dwErr = SchedUPNToAccountName(jc.wszAccount, &pwszSamName);
                if (dwErr != NO_ERROR)
                {
                    *pdwErrorMsg      = IDS_ACCOUNT_LOGON_FAILED;
                    *phrSpecificError = HRESULT_FROM_WIN32(dwErr);
                    CHECK_HRESULT(*phrSpecificError);
                }
                else
                {
                    WCHAR * pSlash = wcschr(pwszSamName, L'\\');
                    schAssert(pSlash);
                    *pSlash = L'\0';
                    wcscpy(jc.wszDomain, pwszSamName);
                    wcscpy(jc.wszAccount, pSlash + 1);
                    delete pwszSamName;
                }
            }

            if (SUCCEEDED(*phrSpecificError))
            {
                if (!LogonUser(jc.wszAccount,
                               jc.wszDomain,
                               jc.wszPassword,
                               LOGON32_LOGON_BATCH,
                               LOGON32_PROVIDER_DEFAULT,
                               &hToken))
                {
                    *pdwErrorMsg      = IDS_ACCOUNT_LOGON_FAILED;
                    *phrSpecificError = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }

        //
        // Don't leave the plain-text password on the stack.
        //

        ZERO_PASSWORD(jc.wszPassword);
        //
        // Load the user profile associated with the account just logged on.
        // (If the user is already logged on, this will just increment the
        // profile ref count, to be decremented when the job stops.)
        // Don't bother doing this if the job is "run-only-if-logged-on", in
        // which case it's OK to unload the profile when the user logs off.
        //

        if (!pJob->IsFlagSet(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))
        {
			*phToken = hToken;
            *phUserProfile = LoadAccountProfile(*phToken,
                                                jc.wszAccount,
                                                jc.wszDomain);
        }

        if (*phrSpecificError)
        {
            return(FALSE);
        }

        
        // If Fast User Switching is enabled and the task user
        // is logged on in any of the sessions then use the session's 
        // user token in place of that obtained above so any UI associated 
        // with the job can show up on the user's desktop.

        // If terminal serveice is running but FUS is disabled, WTSEnumerateSessions
        // will return the only user logged on. If the username and domain name of that 
        // user matches with the jc.wszDomain and jc.wszAccount respectively, then  
        // GetUserTokenFromSession will return TRUE with the token of that user

        HANDLE hSessionUserToken = INVALID_HANDLE_VALUE;
        BOOL bUserLoggedOn = GetUserTokenFromSession(jc.wszAccount,jc.wszDomain,&hSessionUserToken);
		
        if(bUserLoggedOn)
        {
            schDebugOut((DEB_TRACE, "*** Terminal services running and user session found\n"));
            
            if (!jc.fIsPasswordNull)
            {
                pRun->SetProfileHandles(hSessionUserToken, *phUserProfile);
                *ppwszDesktop = WSZ_INTERACTIVE_DESKTOP;
            }

            *phToken             = hSessionUserToken;
            *pfTokenIsShellToken = FALSE;
        }
	
        else
        {
            schDebugOut((DEB_TRACE, "*** user session not found executing old code\n"));
        //
		// Providing a user is logged on locally, is the account logged
        // on above the same as that of the currently logged on user?
        // If so, use the shell's security token in place of that
        // obtained above so any UI associated with the job can
        // show up on the user's desktop.
        //
        //                  ** Important **
        //
        // Only perform this check if the account logon succeeded
        // above. Otherwise, it would be possible to specify an
        // account name with an invalid password and have the job
        // run anyway.
        //

		EnterCriticalSection(gUserLogonInfo.CritSection);

        GetLoggedOnUser();

        if (gUserLogonInfo.DomainUserName != NULL &&
            _wcsicmp(jc.wszAccount, gUserLogonInfo.UserName) == 0 &&
            _wcsicmp(jc.wszDomain, gUserLogonInfo.DomainName) == 0)

		{
            if (!jc.fIsPasswordNull)
            {
				pRun->SetProfileHandles(hToken, *phUserProfile);
				*ppwszDesktop = WSZ_INTERACTIVE_DESKTOP;
            }

            *phToken             = gUserLogonInfo.ShellToken;
            *pfTokenIsShellToken = TRUE;
        }
        else
        {
            LeaveCriticalSection(gUserLogonInfo.CritSection);

            //
            // Is this "run-only-if-logged-on"?
            //
            if (pJob->IsFlagSet(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))
            {
                //
                // The job is "run-only-if-logged-on" and the user is
                // not currently logged on, so fail silently
                //
                schDebugOut((DEB_TRACE, "Not running %ws because user is not logged on\n",
                             pJob->GetFileName()));
                *pdwErrorMsg      = IDS_ACCOUNT_LOGON_FAILED;   // not really used
                *phrSpecificError = S_FALSE;    // suppress error logging
                if (!jc.fIsPasswordNull)
                {
                    CloseHandle(hToken);
                }
                return(FALSE);
            }

            *phToken      = hToken;
            *ppwszDesktop = WSZ_SA_DESKTOP;
        //
        // Load the user profile associated with the account just logged on.
        // (If the user is already logged on, this will just increment the
        // profile ref count, to be decremented when the job stops.)
        // Don't bother doing this if the job is "run-only-if-logged-on", in
        // which case it's OK to unload the profile when the user logs off.
        //
			if (!pJob->IsFlagSet(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))
			{
				*phUserProfile = LoadAccountProfile(*phToken,
                                                jc.wszAccount,
                                                jc.wszDomain);
			}
        }
        }
    }

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadAccountProfile
//
//  Synopsis:   Attempt to load the profile for the specified user.
//
//  Arguments:  [hToken]     - handle representing user
//              [pwszUser]   - user name
//              [pwszDomain] - domain name
//
//  Returns:    Profile handle or NULL.
//
//  History:    10-04-96   DavidMun   Created
//              07-07-99   AnirudhS   Rewrote to use NetUserGetInfo
//
//  Notes:      Returned profile handle must be closed with
//                  UnloadUserProfile(hToken, hUserProfile);
//              CODEWORK  Delay-load netapi32.dll.
//
//----------------------------------------------------------------------------

HANDLE
LoadAccountProfile(
    HANDLE  hToken,
    LPCWSTR pwszUser,
    LPCWSTR pwszDomain
    )
{
    schDebugOut((DEB_TRACE, "Loading profile for '%ws%'\\'%ws'\n",
                 pwszDomain, pwszUser));

    //
    // Determine the server on which to look up the account info
    // Skip this for for local accounts
    // CODEWORK  lstrcmpi won't work if pwszDomain is a DNS name.
    //
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    LPWSTR  pwszDC = NULL;

    if (lstrcmpi(pwszDomain, gpwszComputerName) != 0)
    {
        DWORD err = DsGetDcName(NULL, pwszDomain, NULL, NULL, 0, &pDcInfo);
        if (err == NO_ERROR)
        {
            pwszDC = pDcInfo->DomainControllerName;
        }
        else
        {
            schDebugOut((DEB_ERROR, "DsGetDcName for '%ws' FAILED, %u\n",
                         pwszDomain, err));

            // continue anyway, using NULL as the server
        }
    }

    //
    // Impersonate the user before calling NetUserGetInfo
    //
    if (!ImpersonateLoggedOnUser(hToken))
    {
        ERR_OUT("ImpersonateLoggedOnUser", GetLastError());
    }

    //
    // Look up the path to the profile for the account
    //
    LPUSER_INFO_3 pUserInfo = NULL;

    NET_API_STATUS nerr = NetUserGetInfo(pwszDC, pwszUser, 3,
                                         (LPBYTE *) &pUserInfo);
    //
    // Stop impersonating
    //
    if (!RevertToSelf())
    {
        ERR_OUT("RevertToSelf", GetLastError());
    }

    if (nerr != NERR_Success)
    {
        schDebugOut((DEB_ERROR, "NetUserGetInfo on '%ws' for '%ws' FAILED, %u\n",
                     pwszDC, pwszUser, nerr));
        NetApiBufferFree(pDcInfo);
        SetLastError(nerr);
        return NULL;
    }

    NetApiBufferFree(pDcInfo);

    schDebugOut((DEB_USER3, "Profile path is '%ws'\n", pUserInfo->usri3_profile));

    //
    // LoadUserProfile changes our USERPROFILE environment variable, so save
    // its value before calling LoadUserProfile
    //
    WCHAR  wszOrigUserProfile[MAX_PATH + 1] = L"";

    GetEnvironmentVariable(USERPROFILE,
                           wszOrigUserProfile,
                           ARRAY_LEN(wszOrigUserProfile));

    //
    // Load the profile
    //
    PROFILEINFO ProfileInfo;

    ZeroMemory(&ProfileInfo, sizeof(ProfileInfo));
    ProfileInfo.dwSize = sizeof(ProfileInfo);
    ProfileInfo.dwFlags = PI_NOUI;
    ProfileInfo.lpUserName = (LPWSTR) pwszUser;
    if (pUserInfo != NULL)
    {
        ProfileInfo.lpProfilePath = pUserInfo->usri3_profile;
    }

    if (!LoadUserProfile(hToken, &ProfileInfo))
    {
        schDebugOut((DEB_ERROR, "LoadUserProfile from '%ws' FAILED, %lu\n",
                     ProfileInfo.lpProfilePath, GetLastError()));
        ProfileInfo.hProfile = NULL;
    }

    NetApiBufferFree(pUserInfo);

    //
    // Restore environment variables changed by LoadUserProfile
    //
    SetEnvironmentVariable(USERPROFILE, wszOrigUserProfile);

    return ProfileInfo.hProfile;
}


//+----------------------------------------------------------------------------
//
//  Function:   AllowInteractiveServices
//
//  Synopsis:   Tests the NoInteractiveServices value in the Microsoft\Windows
//              key. If the value is present and its value is non-zero return
//              FALSE; return TRUE otherwise.
//
//  Arguments:  None.
//
//  Returns:    TRUE  -- Allow interactive services.
//              FALSE -- Disallow interactive services.
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
BOOL
AllowInteractiveServices(void)
{
#define WINDOWS_REGISTRY_PATH L"System\\CurrentControlSet\\Control\\Windows"
#define NOINTERACTIVESERVICES L"NoInteractiveServices"

    HKEY  hKey;
    DWORD dwNoInteractiveServices, dwSize, dwType;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     WINDOWS_REGISTRY_PATH,
                     0L,
                     KEY_READ,
                     &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwNoInteractiveServices);

        if (RegQueryValueEx(hKey,
                            NOINTERACTIVESERVICES,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwNoInteractiveServices,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
            {
                return(dwNoInteractiveServices == 0);
            }
        }

        RegCloseKey(hKey);
    }

    //
    // I really hate to have this be the default, but AT does this currently.
    //

    return(TRUE);
}
#endif   // defined(_CHICAGO_)

//+----------------------------------------------------------------------------
//
//  Function:   InitializeStartupInfo
//
//  Synopsis:   Initialize the STARTUPINFO structure passed. If the job is
//              an AT interactive job, set structure fields accordingly.
//
//  Arguments:  [pJob]        -- Job object.
//              [ptszDesktop] -- Desktop name.
//              [psi]         -- Structure to initialized.
//
//  Returns:    None.
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
void
InitializeStartupInfo(
    CJob *        pJob,
    LPTSTR        ptszDesktop,
    STARTUPINFO * psi)
{
#if !defined(_CHICAGO_)
    //
    // NT only.
    //
    // Check if the job is to run interactively. Applicable only for AT jobs.
    //
    //     If the job is an AT job AND
    //     if the interactive flag is set AND
    //     if the NoInteractiveServices is not set in the registry THEN
    //
    // initialize the STARTUPINFO struct such that the AT job will run
    // interactively.
    //

    BOOL fInteractive = pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE) &&
                        pJob->IsFlagSet(TASK_FLAG_INTERACTIVE)   &&
                        AllowInteractiveServices();
    //
    // Emulate the NT4 AT_SVC and log an error to the event log, if the
    // task is supposed to be interactive, but we can't be, due to
    // system settings.
    //
    // Note this query is NOT fInteractive.
    //

    if (pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE) &&
        pJob->IsFlagSet(TASK_FLAG_INTERACTIVE) &&
        !AllowInteractiveServices())
    {
       LPWSTR StringArray[1];
       HRESULT hr;

       //
       // EVENT_COMMAND_NOT_INTERACTIVE
       //  The %1 command is marked as an interactive command.  However, the system is
       //  configured to not allow interactive command execution.  This command may not
       //  function properly.
       //

       hr = pJob->GetCurFile(&StringArray[0]);
       if (FAILED(hr))
       {
            ERR_OUT("Failed to obtain file name for non-interactive AT job", hr);
       }
       else
       {
            if (! ReportEvent(g_hAtEventSource,                      // source handle
                         EVENTLOG_WARNING_TYPE,                 // event type
                         0,                                     // event category
                         EVENT_COMMAND_NOT_INTERACTIVE,         // event id
                         NULL,                                  // user sid
                         1,                                     // number of strings
                         0,                                     // data block length
                         (LPCWSTR *)StringArray,                // string array
                         NULL))                                 // data block
            {
                 // Not fatal, but why did we fail?
                 ERR_OUT("Failed to report the non-interactive event to the eventlog", GetLastError());
            }
            //
            // Clean up -- Theoretically, we should use IMalloc::Free here, but we are in
            // the same process, and the memory was allocated from CoTaskMemAlloc,
            // so CoTaskMemFree is the appropriate call
            //
            CoTaskMemFree(StringArray[0]);
       }
    }
#endif // !defined(_CHICAGO_)

    GetStartupInfo(psi);

    psi->dwFlags    |= STARTF_USESHOWWINDOW;
    psi->wShowWindow = SW_SHOWNOACTIVATE;

#if !defined(_CHICAGO_)
    if (pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE))
    {
        if (fInteractive)
        {
            psi->lpDesktop = ptszDesktop;
            psi->dwFlags  |= STARTF_DESKTOPINHERIT;
        }
        else
        {
            psi->lpDesktop = WSZ_SA_DESKTOP;
            psi->dwFlags  &= ~STARTF_DESKTOPINHERIT;
        }
    }
    else
    {
#endif // !defined(_CHICAGO_)
        psi->lpDesktop = ptszDesktop;
#if !defined(_CHICAGO_)
    }
#endif // !defined(_CHICAGO_)
}


#if !defined(_CHICAGO_)
//+----------------------------------------------------------------------------
//
//  Function:   ComposeBatchParam
//
//  Synopsis:   Builds the CreateProcess command line parameter
//
//  Arguments:  [pwszPrefix]   -
//              [pwszAppPathName]  - The run target task property.
//              [pwszParameters] - The parameters task propery.
//              [ppwszCmdLine]    - The command line to return.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//-----------------------------------------------------------------------------
HRESULT
ComposeBatchParam(
    LPCTSTR pwszPrefix,
    LPCTSTR pwszAppPathName,
    LPCTSTR pwszParameters,
    LPTSTR * ppwszCmdLine)
{
    ULONG cchCmdLine;
    BOOL fBatchNameHasSpaces = HasSpaces(pwszAppPathName);

    //
    // Space for the command line is length of prefix "cmd /c " plus batch
    // file name, plus two if the batch file name will be surrounded with
    // spaces, plus length of parameters, if any, plus one for the space
    // preceding the parameters, plus one for the terminating nul.
    //

    cchCmdLine = lstrlen(pwszPrefix) + 1 +
                 lstrlen(pwszAppPathName) +
                 (fBatchNameHasSpaces ? 2 : 0) +
                 (pwszParameters ? 1 + lstrlen(pwszParameters) : 0);

    *ppwszCmdLine = new TCHAR[cchCmdLine];

    if (!*ppwszCmdLine)
    {
        schDebugOut((DEB_ERROR,
                     "RunNTJob: Can't allocate %u for cmdline\n",
                     cchCmdLine));
        return E_OUTOFMEMORY;
    }

    lstrcpy(*ppwszCmdLine, pwszPrefix);

    if (fBatchNameHasSpaces)
    {
        lstrcat(*ppwszCmdLine, DQUOTE);
    }

    lstrcat(*ppwszCmdLine, pwszAppPathName);

    if (fBatchNameHasSpaces)
    {
        lstrcat(*ppwszCmdLine, DQUOTE);
    }

    if (pwszParameters)
    {
        lstrcat(*ppwszCmdLine, SPACE);
        lstrcat(*ppwszCmdLine, pwszParameters);
    }

    return S_OK;
}
#endif // !defined(_CHICAGO_)


//+----------------------------------------------------------------------------
//
//  Function:   ComposeParam
//
//  Synopsis:   Builds the CreateProcess command line parameter
//
//  Arguments:  [fTargetIsExe]   - Is pwszRunTarget an exe or a document.
//              [ptszRunTarget]  - The run target task property.
//              [ptszParameters] - The parameters task propery.
//              [ptszCmdLine]    - The command line to return.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//-----------------------------------------------------------------------------
HRESULT
ComposeParam(BOOL fTargetIsExe,
             LPTSTR ptszRunTarget,
             LPTSTR ptszParameters,
             LPTSTR * pptszCmdLine)
{
    LPTSTR ptszCmdLine;

    //
    // Check for whitespace in the app name.
    //

    BOOL fAppNameHasSpaces = HasSpaces(ptszRunTarget);

    //
    // If running a document, check for spaces in the doc path name.
    //

    BOOL fParamHasSpaces = FALSE;

    if (!fTargetIsExe && HasSpaces(ptszParameters))
    {
        fParamHasSpaces = TRUE;
    }

    //
    // Figure the length, adding 1 for the space and 1 for the null,
    // plus 2 for the quotes, if needed.
    //

    DWORD cch = lstrlen(ptszRunTarget) + lstrlen(ptszParameters) + 2
                + (fAppNameHasSpaces ? 2 : 0)
                + (fParamHasSpaces ? 2 : 0);

    ptszCmdLine = new TCHAR[cch];
    if (!ptszCmdLine)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("CSchedWorker::RunWin95Job", E_OUTOFMEMORY);
        *pptszCmdLine = NULL;
        return E_OUTOFMEMORY;
    }

    if (fAppNameHasSpaces)
    {
        //
        // Enclose the app name in quotes if it contains whitespace.
        //
        lstrcpy(ptszCmdLine, DQUOTE);
        lstrcat(ptszCmdLine, ptszRunTarget);
        lstrcat(ptszCmdLine, DQUOTE);
    }
    else
    {
        lstrcpy(ptszCmdLine, ptszRunTarget);
    }

    lstrcat(ptszCmdLine, SPACE);

    if (fParamHasSpaces)
    {
        lstrcat(ptszCmdLine, DQUOTE);
    }

    lstrcat(ptszCmdLine, ptszParameters);

    if (fParamHasSpaces)
    {
        lstrcat(ptszCmdLine, DQUOTE);
    }

    *pptszCmdLine = ptszCmdLine;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   MapFindExecutableError
//
//  Synopsis:   Converts the poorly designed error codes returned by the
//              FindExecutable API to HRESULTs
//
//  Arguments:  [hRet] - Error return code from FindExecutable
//
//  Returns:    HRESULT (with FACILITY_WIN32) for the same error
//
//-----------------------------------------------------------------------------
HRESULT
MapFindExecutableError(HINSTANCE hRet)
{
    schAssert((DWORD_PTR)hRet <= 32);

    HRESULT hr;
    if (hRet == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
    }
    else if ((DWORD_PTR)hRet == 31)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
    }
    else
    {
        hr = HRESULT_FROM_WIN32((DWORD_PTR)hRet);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   WaitForStubExe
//
//  Synopsis:   Waits for the stub exe to launch the job
//
//  Arguments:  [hProcess] - Handle to the stub exe process
//
//  Returns:    TRUE if stub exe launched job
//              FALSE if stub exe didn't launch job.  Last error is set to the
//              exit code from the stub exe.
//
//-----------------------------------------------------------------------------
BOOL
WaitForStubExe(HANDLE hProcess)
{
    BOOL fRanJob = FALSE;

    DWORD dwWait = WaitForSingleObject(hProcess, 90000);
    if (dwWait == WAIT_OBJECT_0)
    {
        DWORD dwExitCode;
        if (!GetExitCodeProcess(hProcess, &dwExitCode))
        {
            ERR_OUT("GetExitCodeProcess", GetLastError());
        }
        else if (dwExitCode == 0)
        {
            fRanJob = TRUE;
        }
        else
        {
            ERR_OUT("Stub exe run", dwExitCode);
            SetLastError(dwExitCode);
        }
    }
    else if (dwWait == WAIT_TIMEOUT)
    {
        schAssert(!"Stub exe didn't exit in 90 sec!");
        SetLastError(ERROR_TIMEOUT);
    }
    // else WAIT_FAILED - last error will be set to failure code

    return fRanJob;
}



//+----------------------------------------------------------------------------
//
//  Function:   GetUserTokenFromSession
//
//  Synopsis:   Enumerates the sessions and returns token of the session in 
//				which the given user has logged on
//
//  Arguments:  [IN lpszUsername] - user account name
//				[IN lpszDomain]   - domain name
//				[OUT phUserToken] - token to be returned
//
//  Returns:    FALSE if the given user is not found in the enumerated sessions
//				TRUE if the user is found in the the enumerated sessions array
//				
//				This function enumerates the sessions and compared the user name
//				and domainname of the session with the given username and domain
//				name. If such session is found, it checks to see if it is a console 
//				session. 
//				If it is a console session, the search is terminated and the token 
//				given by the session is returned in  phUserToken
//				Else the token from first session saved and search is continued
//				
//				At the end of the search if no console session is found then
//				the saved first session token is returned.
//
//				Else if no session found whatsoever then the function returns FALSE
//-----------------------------------------------------------------------------

BOOL GetUserTokenFromSession(
    LPTSTR lpszUsername,    // user name
    LPTSTR lpszDomain,      // domain or server
    PHANDLE phUserToken     // receive tokens handle	
)
{

    PWTS_SESSION_INFO pWTSSessionInfo = NULL;
    DWORD  WTSSessionInfoCount = 0;

    //WTS_CURRENT_SERVER_HANDLE indicates the terminal server
    //on which your application is running

    BOOL result = WTSEnumerateSessions(
        WTS_CURRENT_SERVER_HANDLE,
        0,  //Reserved; must be zero
        1,  //version of the enumeration request. Must be 1
        &pWTSSessionInfo,
        &WTSSessionInfoCount);

    if(!result)
    {
        schDebugOut((DEB_TRACE, "*** WTSEnumerateSessions failed\n"));
        return (FALSE);
    }

    schDebugOut((DEB_TRACE, "*** WTSEnumerateSessions returned %d sessions\n",WTSSessionInfoCount));

    LPTSTR pWTSDomainNameBuffer = NULL;
    LPTSTR pWTSUserNameBuffer = NULL;

    HANDLE hNewToken = INVALID_HANDLE_VALUE;
    HANDLE hFirstToken = INVALID_HANDLE_VALUE;
    HANDLE hConsoleToken = INVALID_HANDLE_VALUE;

    // Get the session id of the session attached to the console. If there is 
    // no session attached to console then this return 0xFFFFFFFF
    DWORD ConsoleSessionID = WTSGetActiveConsoleSessionId ();

    BOOL bSuccess = FALSE;
    
    //Check each session to see if the user name and the domain name matches with the
    //ones that are passed to this function
    for (DWORD i = 0; i < WTSSessionInfoCount; i++)
    {
        WTS_INFO_CLASS WTSInfoClass;
        pWTSDomainNameBuffer = NULL;
        pWTSUserNameBuffer = NULL;
        DWORD BytesReturned = 0;

        BOOL bDomainNameResult = WTSQuerySessionInformation(
                            WTS_CURRENT_SERVER_HANDLE,
                            pWTSSessionInfo[i].SessionId,
                            WTSDomainName,			//the type of information to retrieve
                            &pWTSDomainNameBuffer,				
                            &BytesReturned
                        );

        BOOL bUserNameResult = WTSQuerySessionInformation(
                            WTS_CURRENT_SERVER_HANDLE,
                            pWTSSessionInfo[i].SessionId,
                            WTSUserName,			//the type of information to retrieve
                            &pWTSUserNameBuffer,				
                            &BytesReturned
                        );
		
        if (bDomainNameResult && bUserNameResult)
        {
            
            schDebugOut((DEB_TRACE, "*** \n Comparing %s with %s and %s with %s",
                                        lpszUsername,pWTSUserNameBuffer,
                                        lpszDomain, pWTSDomainNameBuffer));

            if (_wcsicmp(lpszUsername, pWTSUserNameBuffer) == 0 &&
                _wcsicmp(lpszDomain, pWTSDomainNameBuffer) == 0)
            {
                // Call WTSQueryUserToken to retrieve a handle to the user access 
                // token for this session. Token returned by WTSQueryUserToken is
                // a primary token and can be passed to CreateProcessAsUser 
                
                BOOL fRet = WTSQueryUserToken(pWTSSessionInfo[i].SessionId, &hNewToken);

                if(fRet)
                {
                    // Check to see if it is a console session
                    
                    if(pWTSSessionInfo[i].SessionId == ConsoleSessionID)
                    {
                        schDebugOut((DEB_TRACE, "*** Console session found\n"));
                        // We have have found the user session that is attached to console
                        // No need to search the remaining So we can break from here
                        hConsoleToken = hNewToken;

                        WTSFreeMemory(pWTSUserNameBuffer);
                        WTSFreeMemory(pWTSDomainNameBuffer);

                        bSuccess = TRUE;
                        break;
                    }

                    // Else if this is the first token that matches then save it in hFirstToken
                    // and proceed to search for console session that matches with the user
                    // If such session is not found then we will use this token
                    else if (!bSuccess)
                    {
                        schDebugOut((DEB_TRACE, "*** First session found\n"));

                        hFirstToken = hNewToken;
                        bSuccess = TRUE;
                    }
					
                    else
                    {
                        CloseHandle(hNewToken);
                    }

                    // else keep seaching as we may get console session id in the remaining 
                    // list
                }
            }
        }

        // pWTSUserNameBuffer may be non-null if bUserNameResult is false
        if (pWTSUserNameBuffer)
        {
            WTSFreeMemory(pWTSUserNameBuffer);
        }

        // pWTSDomainNameBuffer may be non-null if bDomainNameResult is false
        if (pWTSDomainNameBuffer)
        {
            WTSFreeMemory(pWTSDomainNameBuffer);
        }
    }

    WTSFreeMemory(pWTSSessionInfo);

    if(bSuccess)
    {
        // We may have either one or both open tokens.
        // If we get hConsoleToken then we return hConsoleToken
        // In that case if hFirstToken is open then we close hFirstToken
        // If we dont get hConsoleToken then we return hFirstToken
        if(hConsoleToken != INVALID_HANDLE_VALUE)
        {
            if(hFirstToken != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFirstToken);
            }

            *phUserToken = hConsoleToken;

            schDebugOut((DEB_TRACE, "*** Returning TRUE with Console Session Token\n"));
        }
        else
        {
            *phUserToken = hFirstToken;

            schDebugOut((DEB_TRACE, "*** Returning TRUE with First Session Token\n"));
        }
    }

	else
    {
        schDebugOut((DEB_TRACE, "*** Returning FALSE\n"));
    }
    
    return (bSuccess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\sch_wkr.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sch_wkr.cxx
//
//  Contents:   job scheduler service worker class impementation
//
//  Classes:    CSchedWorker
//
//  History:    15-Sep-95 EricB created
//              25-Jun-99 AnirudhS  Extensive fixes to close windows in
//                  MainServiceLoop algorithms.
//              15-Feb-01 Jbenton Bug 315821 - NULL pJob pointer being
//                  dereferenced when ActivateJob failed with OUT_OF_MEMORY.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"
#include "..\inc\resource.h"

#define CONTROL_WINDOWS_KEY     TEXT("System\\CurrentControlSet\\Control\\Windows")
#define NOBOOTPOPUPS_VALUENAME  TEXT("NoPopupsOnBoot")

#if !defined(_CHICAGO_)
extern HANDLE g_WndEvent;
#endif  // #if !defined(_CHICAGO_)

#ifdef _CHICAGO_
//
// These routines exist on Win98, NT4 and NT5 but not on Win95
//
typedef VOID (APIENTRY *PTIMERAPCROUTINE)(
    LPVOID lpArgToCompletionRoutine,
    DWORD dwTimerLowValue,
    DWORD dwTimerHighValue
    );

typedef HANDLE (WINAPI *PFNCreateWaitableTimerA)(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCSTR lpTimerName
    );

typedef BOOL (WINAPI *PFNSetWaitableTimer)(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    );

typedef BOOL (WINAPI *PFNCancelWaitableTimer)(
    HANDLE hTimer
    );

PFNCreateWaitableTimerA     pfnCreateWaitableTimerA;
PFNSetWaitableTimer         pfnSetWaitableTimer;
PFNCancelWaitableTimer      pfnCancelWaitableTimer;
#endif // _CHICAGO_

DWORD CalcWait(LPFILETIME pftNow, LPFILETIME pftJob);
void  ReportMissedRuns(const SYSTEMTIME * pstLastRun,
                       const SYSTEMTIME * pstNow);
DWORD WINAPI PopupThread(LPVOID lpParameter);

#if DBG
LPSTR SystemTimeString(const SYSTEMTIME& st, CHAR * szBuf)
{
    wsprintfA(szBuf, "%2d/%02d/%d %2d:%02d:%02d.%03d",
             st.wMonth, st.wDay, st.wYear,
             st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    return szBuf;
}

LPSTR FileTimeString(FILETIME ft, CHAR * szBuf)
{
    SYSTEMTIME st;
    FileTimeToSystemTime(&ft, &st);
    return (SystemTimeString(st, szBuf));
}
#endif

LONG    g_fPopupDisplaying;  // = FALSE


//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::Init
//
//  Synopsis:   Two phase constrution - do class init that could fail here.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::Init()
{
    m_pSch = new CSchedule;
    if (m_pSch == NULL)
    {
        return E_OUTOFMEMORY;
    }
    HRESULT hr = m_pSch->Init();
    if (FAILED(hr))
    {
        ERR_OUT("CSchedWorker::Init, m_pSch->Init", hr);
        delete m_pSch;
        return hr;
    }

#if !defined(_CHICAGO_) // don't need AT support on chicago

    hr = m_pSch->InitAtID();
    if (FAILED(hr))
    {
        ERR_OUT("CSchedWorker::Init, m_pSch->Init", hr);
        delete m_pSch;
        return hr;
    }

#endif  // !defined(_CHICAGO_)

    //
    // Compose the job search string. It will be composed of the following:
    // g_TasksFolderInfo.ptszPath\*.TSZ_JOB
    //
    UINT cch = lstrlen(g_TasksFolderInfo.ptszPath) + 3 +
                    ARRAY_LEN(TSZ_JOB);
    m_ptszSearchPath = new TCHAR[cch];
    if (!m_ptszSearchPath)
    {
        ERR_OUT("CSchedWorker::Init", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
    lstrcpy(m_ptszSearchPath, g_TasksFolderInfo.ptszPath);
    lstrcat(m_ptszSearchPath, TEXT("\\*.") TSZ_JOB);

    //
    // Create the service control event.
    //
    m_hServiceControlEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hServiceControlEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateEvent", hr);
        return hr;
    }

    //
    // Create the on idle event.
    //
    m_hOnIdleEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hOnIdleEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateEvent", hr);
        return hr;
    }

    //
    // Create the idle loss event.
    //
    m_hIdleLossEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hIdleLossEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateEvent", hr);
        return hr;
    }

    //
    // Create the event used for synchronization with processor threads.
    //
    m_hMiscBlockEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hMiscBlockEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateEvent", hr);
        return hr;
    }

    //
    // Create the timer that will wake the system when it's time to run
    // a job with TASK_FLAG_SYSTEM_REQUIRED.
    //
    HINSTANCE hKernel32Dll = GetModuleHandle(TEXT("KERNEL32.DLL"));
    if (hKernel32Dll == NULL)
    {
        DWORD dwErr = GetLastError();
        ERR_OUT("Load of kernel32.dll", dwErr);
        return HRESULT_FROM_WIN32(dwErr);
    }

    pfnSetThreadExecutionState = (PFNSetThreadExecutionState)
            GetProcAddress(hKernel32Dll, "SetThreadExecutionState");
    if (pfnSetThreadExecutionState == NULL)
    {
        ERR_OUT("GetProcAddress for SetThreadExecutionState", GetLastError());
    }

#ifdef _CHICAGO_

    pfnCreateWaitableTimerA = (PFNCreateWaitableTimerA)
            GetProcAddress(hKernel32Dll, "CreateWaitableTimerA");
    pfnSetWaitableTimer     = (PFNSetWaitableTimer)
            GetProcAddress(hKernel32Dll, "SetWaitableTimer");
    pfnCancelWaitableTimer     = (PFNCancelWaitableTimer)
            GetProcAddress(hKernel32Dll, "CancelWaitableTimer");
    if (pfnCreateWaitableTimerA == NULL ||
        pfnSetWaitableTimer == NULL ||
        pfnCancelWaitableTimer == NULL)
    {
        pfnCreateWaitableTimerA = NULL;
        pfnSetWaitableTimer = NULL;
        pfnCancelWaitableTimer = NULL;
        ERR_OUT("GetProcAddress in kernel32.dll", GetLastError());
    }
    else
    {
        m_hSystemWakeupTimer = pfnCreateWaitableTimerA(NULL, FALSE, NULL);
        if (m_hSystemWakeupTimer == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CreateWaitableTimer", hr);
            return hr;
        }
    }

#else // !_CHICAGO_

    m_hSystemWakeupTimer = CreateWaitableTimer(NULL, FALSE, NULL);

    if (m_hSystemWakeupTimer == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CreateWaitableTimer", hr);
        return hr;
    }

#endif // _CHICAGO_

    //
    // Save the service's working directory.
    //
    cch = GetCurrentDirectory(0, m_ptszSvcDir);
    if (cch == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CSchedWorker::Init, GetCurrentDirectory", hr);
        return hr;
    }

    m_ptszSvcDir = new TCHAR[cch + 1];
    if (m_ptszSvcDir == NULL)
    {
        ERR_OUT("CSchedWorker::Init, service directory", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    if (GetCurrentDirectory(cch + 1, m_ptszSvcDir) == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CSchedWorker::Init, GetCurrentDirectory", hr);
        return hr;
    }

    //
    // Tell the queue of service controls which event to signal when a
    // control is in the queue.
    //
    m_ControlQueue.Init(m_hServiceControlEvent);

    //
    // Record the start up time as the directory-last-checked-time.
    //
    GetSystemTimeAsFileTime(&m_ftLastChecked);

    //
    // Also use this as the beginning of the wait list period.
    //
    FileTimeToLocalFileTime(&m_ftLastChecked, &m_ftBeginWaitList);

    //
    // Set the initial end-of-wait-list-period.
    //
    SYSTEMTIME st;
    FileTimeToSystemTime(&m_ftBeginWaitList, &st);
    schDebugOut((DEB_ITRACE, "Init: time now is %u/%u/%u %u:%02u:%02u\n",
                 st.wMonth, st.wDay, st.wYear,
                 st.wHour, st.wMinute, st.wSecond));
    SetEndOfWaitListPeriod(&st);

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::BuildWaitList
//
//  Synopsis:   Examines the job objects in the scheduler folder and builds
//              a run time list.
//
//  Arguments:  [fStartup] - if true, then being called at initial service
//                           start up. If this is the case, then verify and fix
//                           job state consistency and run any jobs with
//                           startup triggers.
//              [fReportMisses] - whether to detect and report task runs that
//                           were missed (because the service was not running
//                           or the machine was asleep).  This is TRUE when
//                           called on machine wakeup and service start or
//                           continue, FALSE otherwise.
//              [fSignAtJobs] - whether to trust and sign all At jobs that
//                           an owner of Admin or LocalSystem (the pre-NT5
//                           check).  This is TRUE the first time the service
//                           runs on NT5.
//
//  Returns:    hresults
//
//  Notes:      Currently gets all runs from now until midnight. A later
//              enhancement will be to allow a different period to be
//              specified.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::BuildWaitList(
    BOOL    fStartup,
    BOOL    fReportMisses,
    BOOL    fSignAtJobs
    )
{
    TRACE(CSchedWorker, BuildWaitList);
    HRESULT hr = S_OK;
    DWORD dwRet;
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    BOOL    fMisses = FALSE;    // Whether runs were missed

    m_WaitList.FreeList();
    m_IdleList.FreeExpiredOrRegenerated();
    m_ftFutureWakeup = MAX_FILETIME;

    fReportMisses = (fReportMisses && g_fNotifyMiss);

    //
    // The start of the wait list period was picked elsewhere.
    //
    SYSTEMTIME stBegin;
    FileTimeToSystemTime(&m_ftBeginWaitList, &stBegin);
    FILETIME   ftSTBegin;
    LocalFileTimeToFileTime(&m_ftBeginWaitList, &ftSTBegin);

    //
    // Set the end of the wait list period.
    //
    SYSTEMTIME stEnd = stBegin;
    SetEndOfWaitListPeriod(&stEnd);

    schDebugOut((DEB_TRACE, "BuildWaitList %s to %s\n",
                        CSystemTimeString(stBegin).sz(),
                        CSystemTimeString(stEnd).sz()));

    //
    // Save the time of last (starting to) scan the folder.
    //
    GetSystemTimeAsFileTime(&m_ftLastChecked);

#if DBG
    if (g_fVisible)
    {
 #if defined(_CHICAGO_)
        char szBuf[120] = "Enumerating jobs:";
        SendMessage(g_hList, LB_ADDSTRING, 0, (LPARAM)szBuf);
 #else
        printf("Enumerating jobs:\n");
 #endif
    }
#endif

    m_cJobs = 0;

    hFind = FindFirstFile(m_ptszSearchPath, &fd);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwRet = GetLastError();
        if (dwRet == ERROR_FILE_NOT_FOUND)
        {
            //
            // No job files.
            //
#if DBG
            if (g_fVisible)
            {
#if defined(_CHICAGO_)
                char szBuf[120] = "No jobs found!";
                SendMessage(g_hList, LB_ADDSTRING, 0, (LPARAM)szBuf);
#else
                printf("No jobs found!\n");
#endif
            }
#endif
            schDebugOut((DEB_ITRACE, "No jobs found!\n"));
            return S_OK;
        }
        else
        {
            return HRESULT_FROM_WIN32(dwRet);
        }
    }

    //
    // Read the last task run time from the registry.  If it's absent,
    // as it will be the first time the service runs, use stBegin (so no
    // misses will be reported).
    //
    SYSTEMTIME stLastRun;
    if (fReportMisses)
    {
        if (!ReadLastTaskRun(&stLastRun))
        {
            stLastRun = stBegin;
        }
    }

    CJob * pJob = NULL;

    CRunList * pStartupList = new CRunList;
    if (pStartupList == NULL)
    {
        ERR_OUT("BuildWaitList list allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    do
    {
        DWORD dwSavePFlags = 0;

        //
        // Check if the service is shutting down. We check the event rather
        // than simply checking GetCurrentServiceState because this method is
        // called by the main loop which won't be able to react to the shut
        // down event while in this method.
        //

        DWORD dwWaitResult = WaitForSingleObject(m_hServiceControlEvent, 0);

        if (dwWaitResult == WAIT_OBJECT_0)
        {
            //
            // Reset the event so that the main loop will react properly.
            //
            EnterCriticalSection(&m_SvcCriticalSection);
            if (!SetEvent(m_hServiceControlEvent))
            {
                LogServiceError(IDS_NON_FATAL_ERROR, GetLastError());
                ERR_OUT("BuildWaitList: SetEvent",
                        HRESULT_FROM_WIN32(GetLastError()));
                //
                // If this call fails, we are in a heap of trouble, so it
                // really doesn't matter what we do. So, continue.
                //
            }
            LeaveCriticalSection(&m_SvcCriticalSection);

            if (GetCurrentServiceState() == SERVICE_STOP_PENDING)
            {
                DBG_OUT("BuildWaitList: Service shutting down");
                //
                // The service is shutting down. Free job info objects.
                //
                delete pStartupList;
                m_WaitList.FreeList();
                return S_OK;
            }
        }

#if DBG == 1
        if (g_fVisible)
        {
#if defined(_CHICAGO_)
            char szBuf[120];
            wsprintf(szBuf, "found %s", fd.cFileName);
            SendMessage(g_hList, LB_ADDSTRING, 0, (LPARAM)szBuf);
#else
            printf("found %S\n", fd.cFileName);
#endif
        }
        schDebugOut((DEB_ITRACE, "found " FMT_TSTR "\n", fd.cFileName));
#endif
        m_cJobs++;

        //
        // Activate the job.
        // If we've been asked to sign At jobs, do a full load (because we
        // will be writing some variable-length job properties, and we don't
        // want to lose the others).  Otherwise a partial load is enough.
        //
        BOOL fTriggersLoaded = fSignAtJobs;

        hr = m_pSch->ActivateJob(fd.cFileName, &pJob, fSignAtJobs);
        if (FAILED(hr))
        {
            LogTaskError(fd.cFileName,
                         NULL,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                         NULL,
                         (DWORD)hr);
            ERR_OUT("BuildWaitList Activate", hr);
            hr = S_OK;
            goto CheckNext;
        }

#if !defined(_CHICAGO_)

        if (pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE) && fSignAtJobs)
        {
            //
            // We're about to sign this At job, because it's the first time
            // the service is running and At jobs didn't have signatures
            // before NT5.  First verify that the job at least passes the
            // pre-NT5 test for authenticity.
            //
            if (g_TasksFolderInfo.FileSystemType == FILESYSTEM_NTFS &&
                !IsAdminFileOwner(pJob->GetFileName()))
            {
                //
                // Bogus job.  Leave it unsigned.
                //
                schDebugOut((DEB_ERROR,
                             "BuildWaitList: file not owned by Admin:  %ws\n",
                             pJob->GetFileName()));
                hr = S_OK;
                goto CheckNext;
            }

            //
            // Sign the job
            //
            hr = pJob->Sign();

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                hr = S_OK;
                goto CheckNext;
            }

            //
            // Force the updated job to be written to disk
            //
            dwSavePFlags |= SAVEP_VARIABLE_LENGTH_DATA;
        }

#endif  // !defined(_CHICAGO_)

        FILETIME ftSTNow;   // time just after activating job
        GetSystemTimeAsFileTime(&ftSTNow);

        if (fStartup)
        {
            //
            // Let the service controller know we're making progress.
            //
            StartupProgressing();

            //
            // Do service startup processing. First load the triggers.
            //
            hr = pJob->LoadTriggers();
            if (FAILED(hr))
            {
                LogTaskError(fd.cFileName,
                             NULL,
                             IDS_LOG_SEVERITY_WARNING,
                             IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                             NULL,
                             (DWORD)hr);
                ERR_OUT("BuildWaitList, pJob->LoadTriggers", hr);
                hr = S_OK;
                goto CheckNext;
            }

            fTriggersLoaded = TRUE;

            pJob->UpdateJobState(FALSE);

            //
            // If this job has no more runs and the delete-when-done flag is
            // set, then delete the job.
            //
            if (pJob->IsFlagSet(JOB_I_FLAG_NO_MORE_RUNS) &&
                pJob->IsFlagSet(TASK_FLAG_DELETE_WHEN_DONE))
            {
                hr = pJob->Delete();
                if (FAILED(hr))
                {
                    LogTaskError(fd.cFileName,
                                 NULL,
                                 IDS_LOG_SEVERITY_WARNING,
                                 IDS_CANT_DELETE_JOB,
                                 NULL,
                                 (DWORD)hr);
                    ERR_OUT("JobPostProcessing, delete-when-done", hr);
                }
                goto CheckNextNoSave;
            }

            //
            // Make sure that the job object status is in a consistent state.
            // The state can be left inconsistent if the service is stopped
            // while jobs are running.
            //
            if (pJob->IsStatus(SCHED_S_TASK_RUNNING))
            {
                if (pJob->IsFlagSet(JOB_I_FLAG_NO_MORE_RUNS))
                {
                    pJob->SetStatus(SCHED_S_TASK_NO_MORE_RUNS);
                }
                pJob->SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
            }

            if (pJob->IsFlagSet(JOB_I_FLAG_RUN_NOW) ||
                pJob->IsFlagSet(JOB_I_FLAG_ABORT_NOW))
            {
                pJob->ClearFlag(JOB_I_FLAG_RUN_NOW | JOB_I_FLAG_ABORT_NOW);
                pJob->SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
            }

            if (pJob->m_cRunningInstances)
            {
                pJob->m_cRunningInstances = 0;
                pJob->SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
            }
        }

        //
        // Check if job can run.
        //
        if (!pJob->IsFlagSet(TASK_FLAG_DISABLED) &&
            pJob->IsFlagSet(JOB_I_FLAG_HAS_APPNAME))
        {
            //
            // LoadTriggers will set or clear the JOB_I_FLAG_HAS_TRIGGERS flag
            // as appropriate.
            //
            if (!fTriggersLoaded)
            {
                hr = pJob->LoadTriggers();
                if (FAILED(hr))
                {
                    LogTaskError(fd.cFileName,
                                 NULL,
                                 IDS_LOG_SEVERITY_WARNING,
                                 IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                                 NULL,
                                 (DWORD)hr);
                    ERR_OUT("BuildWaitList, pJob->LoadTriggers", hr);
                    hr = S_OK;
                    goto CheckNext;
                }
            }

            if (pJob->IsFlagSet(JOB_I_FLAG_HAS_TRIGGERS))
            {
                //
                // Add startup-triggered runs to the startup list, if this
                // is startup
                //
                if (fStartup && !g_fUserStarted)
                {
                    hr = pJob->IfStartupJobAddToList(fd.cFileName,
                                                     pStartupList,
                                                     &m_IdleList);
                    if (FAILED(hr))
                    {
                        ERR_OUT("BuildWaitList IfStartupJobAddToList", hr);
                        goto Cleanup;
                    }
                }

                //
                // See if the job had missed runs (runs scheduled between
                // stLastRun and stBegin)
                //
                if (fReportMisses)
                {
                    CTimeRunList MissedList;
                    WORD cMissedRuns = 0;
                    hr = pJob->GetRunTimesP(&stLastRun, &stBegin, &cMissedRuns,
                                            1, &MissedList, fd.cFileName);
                    if (FAILED(hr))
                    {
                        schDebugOut((DEB_ERROR, "BuildWaitList: Get Missed RunTimes for "
                                     FMT_TSTR " FAILED, %#lx\n", fd.cFileName, hr));
                        // BUGBUG  Log this?  Disable the job?
                        hr = S_OK;
                    }

                    if (cMissedRuns != 0)
                    {
                        fMisses = TRUE;
                        pJob->SetFlag(JOB_I_FLAG_MISSED |
                                      JOB_I_FLAG_PROPERTIES_DIRTY);

                        FILETIME ftMissed;
                        schAssert(MissedList.PeekHeadTime(&ftMissed) == S_OK);
                        schDebugOut((DEB_TRACE,
                                     FMT_TSTR " missed a run (at %s) between %s and %s\n",
                                     fd.cFileName,
                                     CFileTimeString(ftMissed).sz(),
                                     CSystemTimeString(stLastRun).sz(),
                                     CSystemTimeString(stBegin).sz()
                                     ));
                    }
                }

                //
                // Add time-triggered runs to the wait list
                //
                // If the file has a creation time between stBegin and now,
                // start its run list from that time, instead of stBegin.
                // This prevents the most common case of a task being run
                // even though it was created after its scheduled run time.
                // We can't use the task write time because that could cause
                // runs to be skipped if non-schedule changes were made to
                // the task after it was submitted.
                //
                // BUGBUG  We will still run a task if it was created at
                // 5:00:00, and modified at 8:03:20 to run at 8:03:00, and
                // we haven't yet run an 8:03:00 batch by 8:03:20.
                //
                SYSTEMTIME stJobBegin = stBegin;
                if (CompareFileTime(&ftSTBegin, &fd.ftCreationTime) < 0
                        // recently created
                    &&
                    CompareFileTime(&fd.ftCreationTime, &ftSTNow) < 0
                        // created "in the future" would mean a time change
                        // or a drag-drop occurred, so forget this adjustment
                    )
                {
                    FILETIME ftJobBegin;
                    FileTimeToLocalFileTime(&fd.ftCreationTime, &ftJobBegin);
                    FileTimeToSystemTime(&ftJobBegin, &stJobBegin);
                    schDebugOut((DEB_TRACE, "Using %s for " FMT_TSTR "\n",
                                 CSystemTimeString(stJobBegin).sz(),
                                 fd.cFileName));
                }

                WORD cRuns = 0;
                hr = pJob->GetRunTimesP(&stJobBegin, &stEnd, &cRuns,
                                        TASK_MAX_RUN_TIMES, &m_WaitList,
                                        fd.cFileName);
                if (FAILED(hr))
                {
                    schDebugOut((DEB_ERROR, "BuildWaitList: GetRunTimesP for "
                                 FMT_TSTR " FAILED, %#lx\n", fd.cFileName, hr));
                    // BUGBUG  Log this?  Disable the job?
                    hr = S_OK;
                }

                if (cRuns == 0)
                {
                    schDebugOut((DEB_TRACE,
                                 "There are no runs scheduled for " FMT_TSTR ".\n",
                                 fd.cFileName));
                }

                //
                // If the system must be woken to run this task, also
                // compute its first run time AFTER the wait list period.
                // Remember the first of all such run times.
                //
                if (pJob->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
                {
                    CTimeRunList RunList;
                    WORD cRuns = 0;
                    hr = pJob->GetRunTimesP(&stEnd, NULL, &cRuns, 1,
                                            &RunList, NULL);

                    if (hr == S_OK && cRuns != 0)
                    {
                        FILETIME ft;
                        RunList.PeekHeadTime(&ft);

                        m_ftFutureWakeup = minFileTime(m_ftFutureWakeup, ft);
                    }
                }

                //
                // Add idle-triggered runs to the idle list
                //
                hr = pJob->IfIdleJobAddToList(fd.cFileName, &m_IdleList);

                if (FAILED(hr))
                {
                    schDebugOut((DEB_ERROR, "BuildWaitList: IfIdleJobAddToList for "
                                 FMT_TSTR " FAILED, %#lx\n", fd.cFileName, hr));
                    // BUGBUG  Log this?  Disable the job?
                    hr = S_OK;
                }
            }
        }

CheckNext:
        if (pJob != NULL &&
			(pJob->IsFlagSet(JOB_I_FLAG_PROPERTIES_DIRTY) ||
            !pJob->IsFlagSet(JOB_I_FLAG_NO_RUN_PROP_CHANGE)))
        {
            //
            // Mark this job as clean
            //
            pJob->SetFlag(JOB_I_FLAG_NO_RUN_PROP_CHANGE);

            //
            // Write out the cleaned up state.  Be sure not to clear the
            // AT bit on an AT job just because we're updating its run
            // state.
            //
            dwSavePFlags |= (SAVEP_PRESERVE_NET_SCHEDULE |
                                SAVEP_RUNNING_INSTANCE_COUNT);

            hr = pJob->SaveP(NULL,
                             FALSE,
                             dwSavePFlags);

            if (FAILED(hr))
            {
                ERR_OUT("BuildWaitList, pJob->Save", hr);
                goto Cleanup;
            }
        }

CheckNextNoSave:
        if (!FindNextFile(hFind, &fd))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                ERR_OUT("CSchedWorker::BuildWaitList, FindNextFile", dwRet);
                hr = HRESULT_FROM_WIN32(dwRet);
                goto Cleanup;
            }
        }
    }
    while (SUCCEEDED(hr));

Cleanup:
    if (pJob)
    {
        pJob->Release();
    }

    FindClose(hFind);

    if (FAILED(hr))
    {
        m_WaitList.FreeList();
        m_IdleList.FreeList();
        delete pStartupList;
        return hr;
    }

    //
    // Report missed runs
    //
    if (fMisses)
    {
        ReportMissedRuns(&stLastRun, &stBegin);
    }

#if !defined(_CHICAGO_)
    if (fStartup)
    {
        //
        // If this is the first time in BuildWaitList, wait until the other
        // thread has created the window and initialized idle detection.
        //
        // On Win9x: This code is executed by the main thread of the service,
        // which is also the window thread, and idle detection is already
        // initialized before entering this function.
        //
        // On NT: This code is executed by the main thread of the service,
        // which is the state machine thread, not the window thread.
        // So it must wait for the window thread to initialize.
        //
        // Currently waiting for 15 minutes. If the window has not been
        // created by then, we are in trouble.
        //
        #define WINDOW_WAIT_TIMEOUT  (15 * 60 * 1000)

        if (WaitForSingleObject(g_WndEvent, WINDOW_WAIT_TIMEOUT)
            == WAIT_TIMEOUT)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_WINDOW_HANDLE);
            ERR_OUT("Waiting for window creation", hr);
            return hr;
        }
    }
#endif  // #if !defined(_CHICAGO_)

    //
    // If there are any idle-dependent tasks, set the initial idle wait time.
    //
    // (Possible optimization: It may be safe to get rid of this crit sec)
    EnterCriticalSection(&m_SvcCriticalSection);

    SetNextIdleNotification(m_IdleList.GetFirstWait());

    LeaveCriticalSection(&m_SvcCriticalSection);


    if (!pStartupList->GetFirstJob()->IsNull())
    {
        //
        // Run all jobs with startup triggers.
        //

#if DBG == 1
        if (g_fVisible)
        {
#if defined(_CHICAGO_)
            char szBuf[120];
            lstrcpy(szBuf, "Running startup jobs...");
            SendMessage(g_hList, LB_ADDSTRING, 0, (LPARAM)szBuf);
#else
            printf("Running startup jobs...\n");
#endif
        }
#endif  // DBG == 1

        schDebugOut((DEB_ITRACE, "Running startup jobs...\n"));
        hr = RunJobs(pStartupList);
        if (FAILED(hr))
        {
            ERR_OUT("Running startup jobs", hr);
            return hr;
        }
    }
    else
    {
        delete pStartupList;
    }

#if DBG == 1
    if (g_fVisible)
    {
#if defined(_CHICAGO_)
        char szBuf[120];
        lstrcpy(szBuf, "Computing next to run...");
        SendMessage(g_hList, LB_ADDSTRING, 0, (LPARAM)szBuf);
#else
        printf("Computing next to run...\n");
#endif
    }
#endif

    return (hr == S_FALSE) ? S_OK : hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::GetNextListTime
//
//  Synopsis:   Returns the time at which the next job needs to run or
//              the end of the current wait list period.
//
//  Arguments:  None.
//
//  Returns:    Wait time in milliseconds.
//
//-----------------------------------------------------------------------------
FILETIME
CSchedWorker::GetNextListTime()
{
    //TRACE(CSchedWorker, GetNextListTime);

    FILETIME ftJob;
    if (m_WaitList.PeekHeadTime(&ftJob) == S_FALSE)
    {
        //
        // No more jobs in list, return the end of the wait list period
        // instead.
        //
        SystemTimeToFileTime(&m_stEndOfWaitListPeriod, &ftJob);
    }

    return ftJob;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::GetNextRunWait
//
//  Synopsis:   Returns the wait time until the next job needs to run or until
//              the end of the current wait list period.
//
//  Arguments:  None.
//
//  Returns:    Wait time in milliseconds.
//
//-----------------------------------------------------------------------------
DWORD
CSchedWorker::GetNextRunWait()
{
    //TRACE(CSchedWorker, GetNextRunWait);

    FILETIME ftJob = GetNextListTime();

    FILETIME ftNow = GetLocalTimeAsFileTime();

    return (CalcWait(&ftNow, &ftJob));
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::NextWakeupTime
//
//  Synopsis:   Finds the next time at which the machine must be awake.
//
//  Arguments:  [ftNow] - the current time.
//
//  Returns:    The next time at which the machine must be awake.
//
//  Notes:      Finds the first run of a SYSTEM_REQUIRED job that is at least
//              5 seconds into the future, and returns its time.
//              If there's no such run, returns MAX_FILETIME.
//-----------------------------------------------------------------------------
FILETIME
CSchedWorker::NextWakeupTime(FILETIME ftNow)
{
    FILETIME ftWakeup = FTfrom64(FTto64(ftNow) + SCHED_WAKEUP_CALC_MARGIN);

    for (CRun * pRun = m_WaitList.GetFirstJob();
         !pRun->IsNull();
         pRun = pRun->Next())
    {
        if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED) &&
            CompareFileTime(pRun->GetTime(), &ftWakeup) > 0 &&
            !(g_fOnBattery && pRun->IsFlagSet(TASK_FLAG_DONT_START_IF_ON_BATTERIES)))
        {
            return (* (pRun->GetTime()));
        }
    }

    //
    // No suitable run time in the list.  Use m_ftFutureWakeup, unless
    // it's MAX_FILETIME.
    //
    ftWakeup = m_ftFutureWakeup;
    if (CompareFileTime(&ftWakeup, &MAX_FILETIME) < 0)
    {
        if (CompareFileTime(&ftWakeup, &ftNow) < 0)
        {
            //
            // The "future wakeup time" is in the past.
            // This can happen if the time is changed and the service hasn't
            // received the WM_TIMECHANGE message yet.  This check avoids an
            // infinite loop of WAKEUP_TIME_EVENT and NextWakeupTime().
            // It could also happen if, e.g., the future wakeup time was
            // 12:01 am and we passed that time and got here before rebuilding
            // the wait list.
            //
            schDebugOut((DEB_ERROR, "***** WARNING: Wakeup time in past!  "
                "Machine time changed without receiving WM_TIMECHANGE. *****\n"));
            ftWakeup = MAX_FILETIME;

            //
            // When the WM_TIMECHANGE is received, we'll rebuild the wait
            // list and recalculate m_ftFutureWakeup.
            // If the WM_TIMECHANGE is never received, the wakeup time won't
            // be set and the machine could fail to wakeup.  (e.g. on NT 4.0
            // the "time" command changes the time without sending the
            // message.)  Send ourselves the message to be sure.
            //
            schDebugOut((DEB_TRACE, "Sending ourselves a WM_TIMECHANGE message\n"));
            PostMessage(g_hwndSchedSvc, WM_TIMECHANGE, 0, 0);
        }
    }
    return ftWakeup;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::SetNextWakeupTime
//
//  Synopsis:   Sets the wakeup timer to the next time at which the machine
//              must be awake.
//
//  Arguments:  None.
//
//  Returns:    The next time at which the machine must be awake.
//
//  Notes:
//-----------------------------------------------------------------------------
void
CSchedWorker::SetNextWakeupTime()
{
#if DBG
    CHAR szDbgTime[40], szDbgTime2[40];
#endif

    //
    // Remember the time that we set the timer for.  It is used on waking
    // to make sure we don't miss any runs.
    //
    m_ftLastWakeupSet = NextWakeupTime(GetLocalTimeAsFileTime());

    if (m_hSystemWakeupTimer != NULL)
    {
        if (CompareFileTime(&m_ftLastWakeupSet, &MAX_FILETIME) < 0)
        {
            schDebugOut((DEB_TRACE, "SetNextWakeupTime: now %s, setting to %s\n",
                             FileTimeString(GetLocalTimeAsFileTime(),szDbgTime2),
                         FileTimeString(m_ftLastWakeupSet, szDbgTime)));

            // Convert to UTC
            FILETIME ft;
            LocalFileTimeToFileTime(&m_ftLastWakeupSet, &ft);
            LARGE_INTEGER li = { ft.dwLowDateTime, ft.dwHighDateTime };
#ifdef _CHICAGO_
            if (pfnSetWaitableTimer != NULL &&
                ! pfnSetWaitableTimer(
#else
            if (! SetWaitableTimer(
#endif
                                   m_hSystemWakeupTimer,
                                   &li,
                                   0,       // not periodic
                                   NULL,
                                   NULL,
                                   TRUE))   // wake up system when signaled
            {
                ERR_OUT("SetNextWakeupTime SetWaitableTimer", HRESULT_FROM_WIN32(GetLastError()));
            }
        }
        else
        {
            CancelWakeup();
        }
    }

}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::CancelWakeup
//
//  Synopsis:   Cancels the wakeup timer.  (Usually done when going into a
//              PAUSED state.  Also done if there are no more jobs with
//              TASK_FLAG_SYSTEM_REQUIRED.)
//
//  Arguments:  None.
//
//  Returns:
//
//  Notes:
//-----------------------------------------------------------------------------
void
CSchedWorker::CancelWakeup()
{
    schDebugOut((DEB_TRACE, "Canceling wakeup timer\n"));

    if (m_hSystemWakeupTimer)
    {
#ifdef _CHICAGO_
        if (pfnCancelWaitableTimer != NULL &&
            ! pfnCancelWaitableTimer(m_hSystemWakeupTimer))
#else
        if (!CancelWaitableTimer(m_hSystemWakeupTimer))
#endif
        {
            ERR_OUT("CancelWaitableTimer", GetLastError());
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::SignalWakeupTimer
//
//  Synopsis:   Signals the wakeup timer.
//
//  Arguments:  None.
//
//  Returns:
//
//  Notes:
//-----------------------------------------------------------------------------
void
CSchedWorker::SignalWakeupTimer()
{
    schDebugOut((DEB_TRACE, "Signaling wakeup timer\n"));

    if (m_hSystemWakeupTimer != NULL)
    {
        // Signal the timer 1 time unit in the future (i.e. now)
        LARGE_INTEGER li = { 0xFFFFFFFF, 0xFFFFFFFF };
#ifdef _CHICAGO_
        if (pfnSetWaitableTimer != NULL &&
            ! pfnSetWaitableTimer(
#else
        if (! SetWaitableTimer(
#endif
                               m_hSystemWakeupTimer,
                               &li,
                               0,       // not periodic
                               NULL,
                               NULL,
                               TRUE))   // wake up system when signaled
        {
            ERR_OUT("SignalWakeupTimer SetWaitableTimer", HRESULT_FROM_WIN32(GetLastError()));
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CalcWait
//
//  Synopsis:   return the time difference between the FILETIME params
//
//  Arguments:  [pftNow]
//              [pftThen]
//
//  Returns:    time difference in milliseconds
//              0 if pftThen was before pftNow
//
//-----------------------------------------------------------------------------
DWORD
CalcWait(LPFILETIME pftNow, LPFILETIME pftThen)
{
    if (CompareFileTime(pftNow, pftThen) >= 0)
    {
        //
        // Job run time is in the past.
        //
        return 0;
    }

    //
    // subtract now-time from job-time to get the wait in 100-nano-seconds unit
    //
    ULARGE_INTEGER uliNow, uliJob;
    uliNow.LowPart  = pftNow->dwLowDateTime;
    uliNow.HighPart = pftNow->dwHighDateTime;
    uliJob.LowPart  = pftThen->dwLowDateTime;
    uliJob.HighPart = pftThen->dwHighDateTime;

    __int64 n64Wait = uliJob.QuadPart - uliNow.QuadPart;

    //
    // convert to milliseconds
    //
    DWORD dwWait = (DWORD)(n64Wait / FILETIMES_PER_MILLISECOND);

#if DBG == 1
    //schDebugOut((DEB_TRACE, "GetNextRunWait time is %u milliseconds\n",
    //             dwWait));
    SYSTEMTIME stNow, stRun;
    FileTimeToSystemTime(pftNow, &stNow);
    FileTimeToSystemTime(pftThen, &stRun);
    schDebugOut((DEB_TRACE, "Run time is %u:%02u\n",
                 stRun.wHour, stRun.wMinute));
    DWORD dwSeconds = dwWait / 1000;
    schDebugOut((DEB_TRACE, "*** Wait time to next run is %u:%02u:%02u (h:m:s)\n",
                 dwSeconds / 3600, dwSeconds / 60 % 60, dwSeconds % 60));
    if (g_fVisible)
    {
#if defined(_CHICAGO_)
        char szBuf[120];
        wsprintf(szBuf, "The next run is at: %u:%02u:00",
                 stRun.wHour, stRun.wMinute);
        SendMessage(g_hList, LB_ADDSTRING, 0, (LPARAM)szBuf);
        wsprintf(szBuf, "Wait time until the next run: %u:%02u:%02u (h:m:s)",
                 dwSeconds / 3600, dwSeconds / 60 % 60, dwSeconds % 60);
        SendMessage(g_hList, LB_ADDSTRING, 0, (LPARAM)szBuf);
#else
        printf("The next run is at: %u:%02u:00\n",
               stRun.wHour, stRun.wMinute);
        printf("Wait time until the next run: %u:%02u:%02u (h:m:s)\n",
               dwSeconds / 3600, dwSeconds / 60 % 60, dwSeconds % 60);
#endif
    }
#endif
    return dwWait;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunNextJobs
//
//  Synopsis:   Run the jobs at the top of the list that have the same run
//              time.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunNextJobs(void)
{
    TRACE(CSchedWorker, RunNextJobs);

    FILETIME ftCurJob;
    if (m_WaitList.PeekHeadTime(&ftCurJob) != S_OK)
    {
        return S_FALSE; // list is empty
    }

    //
    // Set the beginning of any wait list we build in future to one second
    // past the scheduled run time of the last scheduled jobs we ran.
    //
    m_ftBeginWaitList = FTfrom64(FTto64(ftCurJob) + FILETIMES_PER_SECOND);

    CRunList * pJobList = new CRunList;
    if (pJobList == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("RunNextJobs list allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    //
    // Collect all jobs with the same start time as the first job.
    //

    FILETIME ftNextJob;
    BOOL fIdleWaitChanged = FALSE;
    while (m_WaitList.PeekHeadTime(&ftNextJob) == S_OK &&
           CompareFileTime(&ftCurJob, &ftNextJob) == 0)
    {
        CRun * pRun = m_WaitList.Pop();
        schAssert(pRun);

        if ((pRun->GetFlags() & TASK_FLAG_START_ONLY_IF_IDLE) &&
            pRun->GetWait() > 0)
        {
            //
            // The job has to wait for an idle period before running, so
            // move it to the idle wait list.
            //
            schDebugOut((DEB_IDLE, "Time to run " FMT_TSTR ", but it needs a "
                         "%d-minute idle period - moving to idle list\n",
                         pRun->GetName(), pRun->GetWait()));
            m_IdleList.AddSortedByIdleWait(pRun);
            fIdleWaitChanged = TRUE;

            // Optimization:  If idle detection is disabled, we will never get an
            // idle notification, so the run will stay in the idle list until
            // its deadline passes.  This could cause a big accumulation of
            // runs in the idle list.  It would be more space-efficient to just discard all
            // runs that are added to the idle list, or never generate runs
            // for tasks with TASK_FLAG_START_ONLY_IF_IDLE (and log one error
            // about them).
        }
        else
        {
            //
            // Move it to the list of jobs that we are about to run.
            //
            schDebugOut((DEB_IDLE, "Time to run " FMT_TSTR ", and it needs "
                         "no idle period\n", pRun->GetName()));
            pJobList->Add(pRun);
        }
    }

    if (fIdleWaitChanged)
    {
        SetNextIdleNotification(m_IdleList.GetFirstWait());
    }

    if (pJobList->GetFirstJob()->IsNull())
    {
        // RunJobs won't accept an empty list
        delete pJobList;
        return S_OK;
    }
    else
    {
        schDebugOut((DEB_TRACE, "RunNextJobs: Running %s jobs\n",
                     CFileTimeString(ftCurJob).sz()));

        HRESULT hr = RunJobs(pJobList);

        schDebugOut((DEB_TRACE, "RunNextJobs: Done running %s jobs\n",
                     CFileTimeString(ftCurJob).sz()));

        if (SUCCEEDED(hr))
        {
            //
            // Save the last scheduled run time at which we ran jobs
            //
            ftCurJob = FTfrom64(FTto64(ftCurJob) + FILETIMES_PER_SECOND);
            SYSTEMTIME stCurJob;
            FileTimeToSystemTime(&ftCurJob, &stCurJob);
            WriteLastTaskRun(&stCurJob);
        }

        return hr;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunLogonJobs
//
//  Synopsis:   Run all jobs with a Logon trigger.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunLogonJobs(void)
{
    TRACE(CSchedWorker, RunLogonJobs);
    HRESULT hr = S_OK;
    DWORD dwRet;
    HANDLE hFind;
    WIN32_FIND_DATA fd;

    hFind = FindFirstFile(m_ptszSearchPath, &fd);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwRet = GetLastError();
        if (dwRet == ERROR_FILE_NOT_FOUND)
        {
            //
            // No job files.
            //
            return S_OK;
        }
        else
        {
            return HRESULT_FROM_WIN32(dwRet);
        }
    }

    CJob * pJob = NULL;
    CRunList * pRunLogonList = new CRunList;
    if (pRunLogonList == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("RunLogonJobs list allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    do
    {
        //
        // TODO: differentiate between job and queue objects and handle
        // accordingly.
        //
        hr = m_pSch->ActivateJob(fd.cFileName, &pJob, FALSE);
        if (FAILED(hr))
        {
            LogTaskError(fd.cFileName,
                         NULL,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                         NULL,
                         (DWORD)hr);
            ERR_OUT("RunLogonJobs Activate", hr);
            if (pJob)
            {
                pJob->Release();
            }
            FindClose(hFind);
            delete pRunLogonList;
            return hr;
        }

        //
        // Check if job can run.
        // TODO: similar checks for account flags.
        //
        if (!pJob->IsFlagSet(TASK_FLAG_DISABLED) &&
            pJob->IsFlagSet(JOB_I_FLAG_HAS_APPNAME))
        {
            //
            // LoadTriggers will set or clear the JOB_I_FLAG_HAS_TRIGGERS flag
            // as appropriate.
            //
            hr = pJob->LoadTriggers();
            if (FAILED(hr))
            {
                LogTaskError(fd.cFileName,
                             NULL,
                             IDS_LOG_SEVERITY_WARNING,
                             IDS_LOG_JOB_WARNING_CANNOT_LOAD,
                             NULL,
                             (DWORD)hr);
                ERR_OUT("RunLogonJobs, pJob->LoadTriggers", hr);
                pJob->Release();
                FindClose(hFind);
                delete pRunLogonList;
                return hr;
            }

            hr = pJob->IfLogonJobAddToList(fd.cFileName, pRunLogonList,
                                           &m_IdleList);
            if (FAILED(hr))
            {
                LogServiceError(IDS_NON_FATAL_ERROR, (DWORD)hr);
                ERR_OUT("RunLogonJobs IfLogonJobAddToList", hr);
                pJob->Release();
                FindClose(hFind);
                delete pRunLogonList;
                return hr;
            }
        }

        if (!FindNextFile(hFind, &fd))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                LogServiceError(IDS_NON_FATAL_ERROR, dwRet);
                ERR_OUT("RunLogonJobs, FindNextFile", dwRet);
                pJob->Release();
                FindClose(hFind);
                delete pRunLogonList;
                return HRESULT_FROM_WIN32(dwRet);
            }
        }
    }
    while (SUCCEEDED(hr));

    pJob->Release();

    FindClose(hFind);

    //
    // If any jobs with a TASK_EVENT_TRIGGER_AT_LOGON trigger were found, then
    // run them now.
    //
    if (!pRunLogonList->GetFirstJob()->IsNull())
    {
        hr = RunJobs(pRunLogonList);

        if (FAILED(hr))
        {
            LogServiceError(IDS_NON_FATAL_ERROR, (DWORD)hr);
            ERR_OUT("Running idle jobs", hr);
        }
    }
    else
    {
        delete pRunLogonList;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunIdleJobs
//
//  Synopsis:   Run all jobs with an OnIdle trigger.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunIdleJobs(void)
{
    TRACE(CSchedWorker, RunIdleJobs);
    HRESULT hr = S_OK;
    CRun *pRun, *pNext;

    //
    // Move pending idle runs, if any, into the idle list. (See SubmitIdleRun.)
    //
    if (! m_PendingList.IsEmpty())
    {
        EnterCriticalSection(&m_PendingListCritSec);
        for (pRun = m_PendingList.GetFirstJob();
             !pRun->IsNull();
             pRun = pNext)
        {
            pNext = pRun->Next();

            schDebugOut((DEB_IDLE, "Moving " FMT_TSTR " from pending to idle list\n",
                         pRun->GetName()));
            pRun->UnLink();
            m_IdleList.AddSortedByIdleWait(pRun);
        }
        LeaveCriticalSection(&m_PendingListCritSec);
    }


    DWORD wCumulativeIdleTime = GetTimeIdle();

    CRunList * pRunIdleList = new CRunList;
    if (pRunIdleList == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR,
                        ERROR_OUTOFMEMORY,
                        IDS_HELP_HINT_CLOSE_APPS);
        ERR_OUT("RunIdleJobs list allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    //
    // Use the critical section to protect the idle struct assignments since
    // assignments can be made asynchronously from two different threads. This
    // is called on the main event-loop/state-machine thread.
    //
    EnterCriticalSection(&m_SvcCriticalSection);

    //
    // Run all unexpired tasks whose idle wait is less than or equal
    // to the current cumulative idle time.  But don't start a task
    // more than once in any period of idleness.
    //

    FILETIME ftNow;
    SYSTEMTIME stNow;
    GetLocalTime(&stNow);
    SystemTimeToFileTime(&stNow, &ftNow);

    for (pRun = m_IdleList.GetFirstJob();
         !pRun->IsNull() && pRun->GetWait() <= wCumulativeIdleTime;
         pRun = pNext)
    {
        pNext = pRun->Next();

        if (pRun->m_fStarted)
        {
            continue;
        }

        if (CompareFileTime(pRun->GetDeadline(), &ftNow) < 0)
        {
            //
            // The run has missed its deadline - delete it.
            // (This is also done when rebuilding the wait list.)
            //
            schDebugOut((DEB_IDLE, "Run of " FMT_TSTR " has missed its deadline - deleting\n",
                         pRun->GetName()));
            //
            // Log the reason for not running.
            //
            LogTaskError(pRun->GetName(),
                         NULL,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_NOT_IDLE,
                         &stNow);

            pRun->UnLink();

            //
            // If the system needed to stay awake to run this task, decrement
            // the thread's wake count.  (We know that this is always called
            // by the worker thread.)
            //
            if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
            {
                WrapSetThreadExecutionState(FALSE, "CSchedWorker::RunIdleJobs 1");
            }

            delete pRun;
            continue;
        }

        if (pRun->IsIdleTriggered())
        {
            //
            // Run it, and keep it in the idle list
            //
            schDebugOut((DEB_IDLE, "COPYING idle-triggered run of " FMT_TSTR " to run list\n",
                         pRun->GetName()));
            hr = pRunIdleList->AddCopy(pRun);
            if (FAILED(hr))
            {
                LogServiceError(IDS_NON_FATAL_ERROR,
                                ERROR_OUTOFMEMORY,
                                IDS_HELP_HINT_CLOSE_APPS);
                ERR_OUT("RunIdleJobs CRun allocation", E_OUTOFMEMORY);
                LeaveCriticalSection(&m_SvcCriticalSection);
                delete pRunIdleList;
                return E_OUTOFMEMORY;
            }
            pRun->m_fStarted = TRUE;
        }
        else
        {
            //
            // Run it, and remove it from the idle list
            //
            schDebugOut((DEB_IDLE, "MOVING run of " FMT_TSTR " to run list\n",
                         pRun->GetName()));
            pRun->UnLink();

            //
            // If the system needed to stay awake to run this task, decrement
            // the thread's wake count.  (We know that this is always called
            // by the worker thread.)
            //
            if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
            {
                WrapSetThreadExecutionState(FALSE, "CSchedWorker::RunIdleJobs 2");
            }

            pRunIdleList->Add(pRun);
        }
    }

    //
    // Set the next idle wait time.
    //
    WORD wIdleWait = m_IdleList.GetFirstWait();

    LeaveCriticalSection(&m_SvcCriticalSection);

    //
    // If more idle-trigger tasks to run, then set the wait time for
    // their notification.
    //
    SetNextIdleNotification(wIdleWait);

    //
    // Run any tasks with a matching idle wait time.
    //
    if (!pRunIdleList->GetFirstJob()->IsNull())
    {
        hr = RunJobs(pRunIdleList);

        if (FAILED(hr))
        {
            LogServiceError(IDS_NON_FATAL_ERROR, (DWORD)hr);
            ERR_OUT("Running idle jobs", hr);
        }
    }
    else
    {
        delete pRunIdleList;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::SubmitIdleRun
//
//  Synopsis:   Submits a CRun for insertion in the idle list.
//
//  Notes:      This method is called by job processor threads for jobs with
//              TASK_FLAG_RESTART_ON_IDLE_RESUME set.
//
//-----------------------------------------------------------------------------
void
CSchedWorker::SubmitIdleRun(CRun * pRun)
{
    //
    // Insert the run in the pending list.
    // We don't insert directly into the idle list because we want to avoid
    // having a critical section to guard the idle list.
    //
    schAssert(pRun->GetWait() != 0);
    EnterCriticalSection(&m_PendingListCritSec);
    schDebugOut((DEB_IDLE, "Submitting " FMT_TSTR " to pending idle list\n",
                 pRun->GetName()));
    m_PendingList.Add(pRun);
    LeaveCriticalSection(&m_PendingListCritSec);

    //
    // Wake up the main thread, which will move the run into the idle list
    // and register for idle notification if necessary.
    //
    SetEvent(m_hOnIdleEvent);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::CControlQueue methods
//
//  Synopsis:   Ensure that controls sent to the service are processed in the
//              order received
//
//-----------------------------------------------------------------------------
CSchedWorker::CControlQueue::~CControlQueue()
{
    DeleteCriticalSection(&_Lock);

    while (!IsListEmpty(&_ListHead))
    {
        QueueEntry * pEntry =
            CONTAINING_RECORD(_ListHead.Flink, QueueEntry, Links);
        RemoveEntryList(&pEntry->Links);
        delete pEntry;
    }
}

void
CSchedWorker::CControlQueue::AddEntry(DWORD dwControl)
{
    QueueEntry * pNew = new QueueEntry;
    if (pNew == NULL)
    {
        LogServiceError(IDS_NON_FATAL_ERROR, GetLastError());
        ERR_OUT("new QueueEntry", GetLastError());
        return;
    }

    pNew->dwControl = dwControl;

    EnterCriticalSection(&_Lock);

    InsertTailList(&_ListHead, &pNew->Links);

    if (!SetEvent(_Event))
    {
        LogServiceError(IDS_NON_FATAL_ERROR, GetLastError());
        ERR_OUT("CControlQueue::AddEntry: SetEvent", GetLastError());
    }

    LeaveCriticalSection(&_Lock);
}

DWORD
CSchedWorker::CControlQueue::GetEntry()
{
    DWORD   dwControl;

    EnterCriticalSection(&_Lock);

    if (IsListEmpty(&_ListHead))
    {
        dwControl = 0;
    }
    else
    {
        QueueEntry * pEntry =
            CONTAINING_RECORD(_ListHead.Flink, QueueEntry, Links);
        dwControl = pEntry->dwControl;
        RemoveEntryList(&pEntry->Links);
        delete pEntry;

        //
        // If there are still controls in the queue, make sure we get
        // signaled again.
        //
        if (!IsListEmpty(&_ListHead))
        {
            if (!SetEvent(_Event))
            {
                LogServiceError(IDS_NON_FATAL_ERROR, GetLastError());
                ERR_OUT("CControlQueue::GetEntry: SetEvent", GetLastError());
            }
        }
    }

    LeaveCriticalSection(&_Lock);

    return dwControl;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::OnIdleEvent
//
//  Synopsis:   Called when the machine's idle state changes.
//
//  Arguments:  [fIdle] - set to true if receiving an idle time notification,
//                        false if leaving the idle state.
//
//  Returns:    S_OK unless there is a SetEvent error.
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::OnIdleEvent(BOOL fIdle)
{
    TRACE(CSchedWorker, OnIdleEvent);
    HRESULT hr = S_OK;

    if (fIdle)
    {
        //
        // Notify the main service loop that the machine has entered the idle
        // state.
        //
        schDebugOut((DEB_IDLE, "Setting idle event\n"));
        if (!SetEvent(m_hOnIdleEvent))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LogServiceError(IDS_NON_FATAL_ERROR, (DWORD)hr);
            ERR_OUT("OnIdleChange: SetEvent", hr);
        }
    }

    if (!fIdle)
    {
        //
        // Notify the main service loop that idle has been lost.
        //
        schDebugOut((DEB_IDLE, "Setting idle loss event\n"));
        if (!SetEvent(m_hIdleLossEvent))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LogServiceError(IDS_NON_FATAL_ERROR, (DWORD)hr);
            ERR_OUT("OnIdleChange: SetEvent(IdleLoss)", hr);
        }

        //
        //
        // Notify the job processor to kill any jobs with the
        // TASK_FLAG_KILL_ON_IDLE_END flag set.
        //
        CJobProcessor * pjp;
        for (pjp = gpJobProcessorMgr->GetFirstProcessor(); pjp != NULL; )
        {
            pjp->KillIfFlagSet(TASK_FLAG_KILL_ON_IDLE_END);
            CJobProcessor * pjpNext = pjp->Next();
            pjp->Release();
            pjp = pjpNext;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::CSchedWorker
//
//  Synopsis:   ctor
//
//-----------------------------------------------------------------------------
CSchedWorker::CSchedWorker(void) :
    m_pSch(NULL),
    m_hChangeNotify(INVALID_HANDLE_VALUE),
    m_hServiceControlEvent(NULL),
    m_hOnIdleEvent(NULL),
    m_hIdleLossEvent(NULL),
    m_hSystemWakeupTimer(NULL),
    m_hMiscBlockEvent(NULL),
    m_ptszSearchPath(NULL),
    m_ptszSvcDir(NULL),
    m_cJobs(0)
{
    TRACE(CSchedWorker, CSchedWorker);
    InitializeCriticalSection(&m_SvcCriticalSection);
    InitializeCriticalSection(&m_PendingListCritSec);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::~CSchedWorker
//
//  Synopsis:   dtor
//
//-----------------------------------------------------------------------------
CSchedWorker::~CSchedWorker(void)
{
    TRACE(CSchedWorker, ~CSchedWorker);
    //
    // Free resources and close handles.
    //
    if (m_pSch != NULL)
    {
        m_pSch->Release();
    }

    if (m_hChangeNotify != INVALID_HANDLE_VALUE)
    {
        FindCloseChangeNotification(m_hChangeNotify);
    }

    if (m_hServiceControlEvent != NULL)
    {
        CloseHandle(m_hServiceControlEvent);
    }

    if (m_hOnIdleEvent != NULL)
    {
        CloseHandle(m_hOnIdleEvent);
    }

    if (m_hIdleLossEvent != NULL)
    {
        CloseHandle(m_hIdleLossEvent);
    }

    if (m_hSystemWakeupTimer != NULL)
    {
        CloseHandle(m_hSystemWakeupTimer);
    }

    if (m_hMiscBlockEvent != NULL)
    {
        CloseHandle(m_hMiscBlockEvent);
    }

    DeleteCriticalSection(&m_PendingListCritSec);
    DeleteCriticalSection(&m_SvcCriticalSection);

    if (m_ptszSearchPath)
    {
        delete [] m_ptszSearchPath;
    }

    if (m_ptszSvcDir != NULL)
    {
        delete [] m_ptszSvcDir;
    }

    m_WaitList.FreeList();
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::SetEndOfWaitListPeriod
//
//  Synopsis:   Advance the passed in time to the end of the current run
//              period.
//
//-----------------------------------------------------------------------------
void
CSchedWorker::SetEndOfWaitListPeriod(LPSYSTEMTIME pstEnd)
{
    //
    // Set pstEnd to a few seconds after midnight so that midnight jobs are
    // included. Midnight is 0:0:0 of the next day.
    //
    pstEnd->wHour = pstEnd->wMinute = 0;
    pstEnd->wSecond = 10;

    IncrementDay(pstEnd);

    //
    // Save it for use in GetNextRunWait.
    //
    m_stEndOfWaitListPeriod = *pstEnd;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSchedWorker::ActivateWithRetry
//
//  Synopsis:   Load the job object from disk with failure retry.
//
//  Arguments:  [ptszName] - name of the job to activate.
//              [pJob]     - Job object to activate.
//              [fFullActivate] - load the entire object?
//
//----------------------------------------------------------------------------
HRESULT
CSchedWorker::ActivateWithRetry(LPTSTR ptszName, CJob ** ppJob,
                                BOOL fFullActivate)
{
    HRESULT hr;

    //
    // Load the job object. If there are sharing violations, retry two times.
    //
    for (int i = 0; i < 3; i++)
    {
        hr = m_pSch->ActivateJob(ptszName, ppJob, fFullActivate);
        if (SUCCEEDED(hr))
        {
            return S_OK;
        }
        if (hr != HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
        {
            //
            // If we have a failure other than sharing violation, we will
            // retry anyway after reporting the error.
            //
            ERR_OUT("ActivateWithRetry, Loading job object", hr);
        }
#if DBG == 1
        else
        {
            ERR_OUT("ActivateWithRetry, file read sharing violation", 0);
        }
#endif

        //
        // Wait 300 milliseconds before trying again.
        //
        Sleep(300);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSchedWorker::InitialDirScan
//
//  Synopsis:   Do the startup BuildWaitList and create the change events.
//
//----------------------------------------------------------------------------
HRESULT
CSchedWorker::InitialDirScan(void)
{
    HRESULT hr;
    DWORD   dwFirstBoot = 0;

#if !defined(_CHICAGO_)

    DWORD   dwType;
    DWORD   cb = sizeof(dwFirstBoot);
    HKEY    hSchedKey = NULL;
    LONG    lErr;

    //
    // Find out if this is the first boot by checking the FirstBoot
    // value under the schedule agent key
    //
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        SCH_AGENT_KEY,
                        0,
                        KEY_QUERY_VALUE | KEY_SET_VALUE,
                        &hSchedKey);

    if (lErr == ERROR_SUCCESS)
    {
        //
        // Get the first boot value
        //
        lErr = RegQueryValueEx(hSchedKey,
                               SCH_FIRSTBOOT_VALUE,
                               NULL,
                               &dwType,
                               (LPBYTE) &dwFirstBoot,
                               &cb);

        if (lErr == ERROR_SUCCESS && dwFirstBoot != 0)
        {
            schDebugOut((DEB_TRACE, "First boot -- will sign At jobs\n"));
        }
    }

#endif  // !defined(_CHICAGO_)

    //
    // Do the initial job folder read -- a non-zero dwValue means
    // this is the first boot of the Task Scheduler on NT5.
    //
    hr = BuildWaitList(TRUE, TRUE, dwFirstBoot);
    if (FAILED(hr))
    {
        LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
        ERR_OUT("InitialDirScan, BuildWaitList", hr);
#if !defined(_CHICAGO_)
        RegCloseKey(hSchedKey);
#endif  // !defined(_CHICAGO_)
        return hr;
    }

#if !defined(_CHICAGO_)
    if (hSchedKey != NULL)
    {
        //
        // No more need for this reg value
        //
        RegDeleteValue(hSchedKey, SCH_FIRSTBOOT_VALUE);

        RegCloseKey(hSchedKey);
    }
#endif  // !defined(_CHICAGO_)

    //
    // Set up the folder change notification.
    //
    // If a job is created, deleted, renamed, or modified then
    // m_hChangeNotify will be triggered.
    //
    // This is done after the initial call to BuildWaitList since there is no
    // reason to field change notifications until the main loop is entered.
    //
    m_hChangeNotify = FindFirstChangeNotification(
                                    g_TasksFolderInfo.ptszPath,
                                    FALSE,  // no subdirs
                                    FILE_NOTIFY_CHANGE_FILE_NAME |
                                        FILE_NOTIFY_CHANGE_LAST_WRITE);

    if (m_hChangeNotify == INVALID_HANDLE_VALUE)
    {
        ULONG ulLastError = GetLastError();

        LogServiceError(IDS_FATAL_ERROR, ulLastError, 0);
        ERR_OUT("InitialDirScan, FindFirstChangeNotification", ulLastError);
        return HRESULT_FROM_WIN32(ulLastError);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReportMissedRuns
//
//  Synopsis:   Pops up a message indicating that some runs were missed, and
//              logs this to the event log and task scheduler log.
//
//  Arguments:  [pstLastRun], [pstNow] - times between which runs were missed.
//
//----------------------------------------------------------------------------
void
ReportMissedRuns(const SYSTEMTIME * pstLastRun, const SYSTEMTIME * pstNow)
{
    //
    // Write to the task scheduler log
    //
    LogMissedRuns(pstLastRun, pstNow);

    //
    // Spin a thread to popup a message.
    // Suppress the popup if NoPopupsOnBoot is indicated in the registry.
    //
    DWORD   PopupStatus;
    BOOL    bPopups = TRUE;     // FALSE means suppress popups on boot
    HKEY    WindowsKey=NULL;

    PopupStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CONTROL_WINDOWS_KEY,
                                0, KEY_READ, &WindowsKey);
    if (PopupStatus == ERROR_SUCCESS)
    {
        DWORD Type;
        DWORD Data;
        DWORD cbData = sizeof(Data);

        PopupStatus = RegQueryValueEx(WindowsKey, NOBOOTPOPUPS_VALUENAME,
                                      NULL, &Type, (LPBYTE) &Data, &cbData);

        //
        // Popups are suppressed if the NOBOOTPOPUPS_VALUENAME value is
        // present, is a REG_DWORD and is non-zero.
        //
        if (PopupStatus == ERROR_SUCCESS &&
            Type == REG_DWORD &&
            Data != 0)
        {
            bPopups = FALSE;
        }

        RegCloseKey(WindowsKey);
    }

    if (bPopups &&
        //
        // If the message has already been popped up on the screen, and hasn't
        // been dismissed yet, don't pop up another one.
        //
        ! InterlockedExchange(&g_fPopupDisplaying, TRUE))
    {
        DWORD dwThreadId;
        HANDLE hThread = CreateThread(
                           NULL,
                           0L,
                           (LPTHREAD_START_ROUTINE) PopupThread,
                           0,   // parameter
                           0L,
                           &dwThreadId
                           );

        if (hThread == NULL)
        {
            ERR_OUT("CreateThread PopupThread", GetLastError());
            g_fPopupDisplaying = FALSE;
        }
        else
        {
            CloseHandle(hThread);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   PopupThread
//
//  Synopsis:   Pops up a message indicating that some runs were missed.
//
//  Arguments:  [lpParameter] - ignored.
//
//----------------------------------------------------------------------------
DWORD WINAPI
PopupThread(LPVOID lpParameter)
{
    CHAR szTitle[SCH_MEDBUF_LEN];
    CHAR szMsg[SCH_BIGBUF_LEN];

    if (LoadStringA(g_hInstance,
                    IDS_POPUP_SERVICE_TITLE,
                    szTitle,
                    SCH_MEDBUF_LEN) == 0)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
    }
    else if (LoadStringA(g_hInstance,
                    IDS_POPUP_RUNS_MISSED,
                    szMsg,
                    SCH_BIGBUF_LEN) == 0)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
    }
    else
    {
        MessageBoxA(NULL, szMsg, szTitle,
                    MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION |
#ifndef _CHICAGO_
                        MB_SERVICE_NOTIFICATION |
#endif
                        MB_SYSTEMMODAL);
    }

    g_fPopupDisplaying = FALSE;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\path.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       path.cxx
//
//  Contents:   Functions to manipulate file path strings
//
//  History:    02-Jul-96 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"
#include "..\inc\resource.h"
#include "path.hxx"

//+----------------------------------------------------------------------------
//
//  Function:   OnExtList
//
//-----------------------------------------------------------------------------
BOOL
OnExtList(LPCTSTR pszExtList, LPCTSTR pszExt)
{
    for (; *pszExtList; pszExtList += lstrlen(pszExtList) + 1)
    {
        if (!lstrcmpi(pszExt, pszExtList))
        {
            return TRUE;        // yes
        }
    }

    return FALSE;
}

#ifdef WINNT

    // Character offset where binary exe extensions begin in above

    #define BINARY_EXE_OFFSET 15
    #define EXT_TABLE_SIZE    26    // Understand line above before changing

    static const WCHAR achExes[EXT_TABLE_SIZE] = L".cmd\0.bat\0.pif\0.exe\0.com\0";

#else

    // Character offset where binary exe extensions begin in above

    #define BINARY_EXE_OFFSET 10
    #define EXT_TABLE_SIZE    21    // Understand line above before changing

    static const CHAR achExes[EXT_TABLE_SIZE] = ".bat\0.pif\0.exe\0.com\0";

#endif

//+----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Arguments:  [] -
//
//-----------------------------------------------------------------------------
BOOL WINAPI
PathIsBinaryExe(LPCTSTR szFile)
{
	Win4Assert( szFile );
    return OnExtList(achExes+BINARY_EXE_OFFSET, PathFindExtension(szFile));
}

//+----------------------------------------------------------------------------
//
//  Function:   PathIsExe
//
//  Synopsis:   Determine if a path is a program by looking at the extension
//
//  Arguments:  [szFile] - the path name.
//
//  Returns:    TRUE if it is a program, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL WINAPI
PathIsExe(LPCTSTR szFile)
{
    LPCTSTR temp = PathFindExtension(szFile);
	Win4Assert( temp );
    return OnExtList(achExes, temp);
}

//+----------------------------------------------------------------------------
//
//  Function:   EnsureUniquenessOfFileName
//
//  Synopsis:
//
//  Arguments:  [pszFile] - the
//
//  Notes:      This function is also in folderui\util.cxx. If this file is
//              moved to common, remove the other occurrence of the function.
//-----------------------------------------------------------------------------
void
EnsureUniquenessOfFileName(LPTSTR pszFile)
{
    TRACE_FUNCTION(EnsureUniquenessOfFileName);
    int     iPostFix = 2;

    BOOL fFileAltered = FALSE;

    TCHAR   szNameBuf[MAX_PATH+MAX_PATH];
    lstrcpy(szNameBuf, g_TasksFolderInfo.ptszPath);
    lstrcat(szNameBuf, TEXT("\\"));
    lstrcat(szNameBuf, pszFile);

    LPTSTR  pszName = PathFindFileName(szNameBuf);
    LPTSTR  pszExt = PathFindExtension(pszName);
	Win4Assert( pszExt );

    TCHAR szBufExt[10];
    Win4Assert(lstrlen(pszExt) < ARRAY_LEN(szBufExt));
    lstrcpy(szBufExt, pszExt);

    int lenUpToExt = (int)(pszExt - szNameBuf); // lstrlen(szNameBuf) - lstrlen(pszExt)

    Win4Assert(lenUpToExt >= 0);

    TCHAR szBufPostFix[10];

    //
    //  Ensure uniqueness of the file
    //

    while (1)
    {
        HANDLE hFile = CreateFile(szNameBuf, GENERIC_READ,
                                FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            // No file with this name exists. So this name is unique.
            break;
        }
        else
        {
            CloseHandle(hFile);

            // post fix a number to make the file name unique
            wsprintf(szBufPostFix, TEXT(" %d"), iPostFix++);

            lstrcpy(&szNameBuf[lenUpToExt], szBufPostFix);

            lstrcat(szNameBuf, szBufExt);

            fFileAltered = TRUE;
        }
    }
    if (fFileAltered)
    {
        pszName = PathFindFileName(pszFile);
        pszExt = PathFindExtension(pszName);
        lenUpToExt = (int)(pszExt - pszFile);
        lstrcpy(&pszFile[lenUpToExt], szBufPostFix);
        lstrcat(pszFile, szBufExt);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\daytona\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE0):	..\..\idl\$(O)\$(@F)
    copy ..\..\idl\$(O)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\scvgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       scvgr.cxx
//
//  Contents:   CSAScavengerTask class implementation.
//
//  Classes:    CSAScavengerTask
//
//  Functions:  None.
//
//  History:    21-Jul-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include "lsa.hxx"
#include "task.hxx"
#include "scvgr.hxx"


//+---------------------------------------------------------------------------
//
//  Method:     CSAScavengerTask::Initialize
//
//  Synopsis:   Initialize the scavenger task by creating a wait event handle.
//
//  Arguments:  None.
//
//  Returns:    S_OK
//              CreateEvent HRESULT error code on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CSAScavengerTask::Initialize(void)
{
    TRACE3(CSAScavengerTask, Initialize);

    _hWaitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (_hWaitEvent == NULL)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return(HRESULT_FROM_WIN32(GetLastError()));
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSAScavengerTask::PerformTask
//
//  Synopsis:   Let ScavengeSASecurityDBase do the actual work of cleaning
//              up the scheduling agent security database.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CSAScavengerTask::PerformTask(void)
{
    TRACE3(CSAScavenger, PerformTask);

    DWORD dwRet = WaitForSingleObject(_hWaitEvent, _msWaitTime);

    if (dwRet == WAIT_OBJECT_0)
    {
        //
        // The scavenger is to shutdown.
        //

        ResetEvent(_hWaitEvent);
        return;
    }
    else if (WAIT_TIMEOUT)
    {
        ScavengeSASecurityDBase();
        ResetEvent(_hWaitEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CSAScavengerTask::Shutdown
//
//  Synopsis:   Signal the scavenger to shut down by signalling its wait
//              event.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CSAScavengerTask::Shutdown(void)
{
    TRACE3(CSAScavengerTask, Shutdown);
    SetEvent(_hWaitEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\secmisc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       secmisc.cxx
//
//  Contents:   Code to retrieve security-related information from the job
//              object. Function names partially describe the intended
//              function - we don't want to give too much away.
//
//  Classes:    None.
//
//  Functions:  CloseFile
//              OpenFile
//              GetFileInformation
//
//  History:    15-May-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <ntsecapi.h>
#include <mstask.h>
#include <msterr.h>
#include "debug.hxx"
#include "lsa.hxx"

HRESULT
CloseFile(
    HANDLE  hFile,
    WORD    ccApplication,
    WCHAR   wszApplication[],
    HRESULT hrPrevious);
HRESULT
OpenFile(
    LPCWSTR  pwszFileName,
    DWORD    dwDesiredAccess,
    HANDLE * phFile);

BOOL WaitForMUP (DWORD dwMaxWait);
BOOL WaitForServiceToStart (LPTSTR lpServiceName, DWORD dwMaxWait);

// Defined in security.cxx.
//
extern CRITICAL_SECTION             gcsSSCritSection;
extern DWORD                        gdwSystem;
extern POLICY_ACCOUNT_DOMAIN_INFO * gpDomainInfo;
extern WCHAR gwszComputerName[MAX_COMPUTERNAME_LENGTH + 2];


#define gdwKeyElement gdwSystem         // Rename to understand its true
                                        // function.

//+---------------------------------------------------------------------------
//
//  Function:   OpenFile
//
//  Synopsis:
//
//  Arguments:  [pwszFileName] --
//              [dwDesiredAccess] --
//              [hFile]        --
//
//  Returns:    S_OK
//              SCHED_E_CANNOT_OPEN_TASK
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
OpenFile(LPCWSTR pwszFileName, DWORD dwDesiredAccess, HANDLE * phFile)
{
#define FILE_OPEN_RETRY_COUNT       3
#define FILE_OPEN_RETRY_WAIT_TIME   100     // 100 milliseconds.

    DWORD   Status = 0;
    HANDLE  hFile;

    //
    // Retry open if it is in use by another process.
    //

    for (DWORD i = FILE_OPEN_RETRY_COUNT; i; i--)
    {
        hFile = CreateFile(pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_SEQUENTIAL_SCAN,
                           NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            Status = GetLastError();

            if (Status == ERROR_SHARING_VIOLATION)
            {
                Sleep(FILE_OPEN_RETRY_WAIT_TIME);
                continue;
            }
        }
        else
        {
            Status = 0;
        }

        break;
    }

    if (Status)
    {
        schDebugOut((DEB_ERROR, "Open of task file '%ws' failed with error %u\n",
                     pwszFileName, Status));
        return SCHED_E_CANNOT_OPEN_TASK;
    }

    *phFile = hFile;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CloseFile
//
//  Synopsis:
//
//  Arguments:  [hFile]          --
//              [ccApplication]  --
//              [wszApplication] --
//              [hrPrevious]     --
//
//  Returns:    S_OK
//              SCHED_E_INVALID_TASK
//              E_UNEXPECTED
//              HRESULT argument, if it is an error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CloseFile(
    HANDLE  hFile,
    WORD    ccApplication,
    WCHAR   wszApplication[],
    HRESULT hrPrevious)
{
    HRESULT hr = S_OK;
    DWORD   dwBytesRead;
    WCHAR * pwsz;
    WORD    wAppOffset;
    WORD    cch;

    //
    // If the previous operation failed, skip the application read.
    //

    if (FAILED(hrPrevious))
    {
        hr = hrPrevious;
        goto ErrorExit;
    }

    //
    // Read the offset to the application name.
    //

    if (!ReadFile(hFile, &wAppOffset, sizeof(wAppOffset), &dwBytesRead, NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        hr = SCHED_E_INVALID_TASK;
        goto ErrorExit;
    }

    //
    // Move to read the application name.
    //

    if (SetFilePointer(hFile, wAppOffset, NULL, FILE_BEGIN) != -1)
    {
        //
        // Read the application size, allocate sufficient buffer space
        // and read the application string.
        //

        if (!ReadFile(hFile, &cch, sizeof(cch), &dwBytesRead, NULL) ||
            dwBytesRead != sizeof(cch))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            hr = SCHED_E_INVALID_TASK;
            goto ErrorExit;
        }

        if (!cch)
        {
            wszApplication[0] = L'\0';
        }
        else if (cch > ccApplication)
        {
            hr = E_UNEXPECTED;
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
        else
        {
            if (!ReadFile(hFile,
                          wszApplication,
                          cch * sizeof(WCHAR),
                          &dwBytesRead,
                          NULL))
            {
                CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
                hr = SCHED_E_INVALID_TASK;
                goto ErrorExit;
            }

            if (dwBytesRead != (cch * sizeof(WCHAR)))
            {
                hr = SCHED_E_INVALID_TASK;
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }

            if (wszApplication[cch - 1] != L'\0')
            {
                hr = SCHED_E_INVALID_TASK;
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }
    }
    else
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        hr = SCHED_E_INVALID_TASK;
    }

ErrorExit:
    if (hFile != NULL) CloseHandle(hFile);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetFileInformation
//
//  Synopsis:
//
//  Arguments:  [pwszFileName]      --
//              [hFile]             --
//              [pcbOwnerSid]       --
//              [ppOwnerSid]        --
//              [ppOwnerSecDescr]   --
//              [ccOwnerName]       --
//              [ccOwnerDomain]     --
//              [ccApplication]     --
//              [wszOwnerName]      --
//              [wszOwnerDomain]    --
//              [wszApplication]    --
//              [pftCreationTime]   --
//              [pdwVolumeSerialNo] --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetFileInformation(
    LPCWSTR                pwszFileName,
    DWORD *                pcbOwnerSid,
    PSID *                 ppOwnerSid,
    PSECURITY_DESCRIPTOR * ppOwnerSecDescr,
    UUID *                 pJobID,
    DWORD                  ccOwnerName,
    DWORD                  ccOwnerDomain,
    DWORD                  ccApplication,
    WCHAR                  wszOwnerName[],
    WCHAR                  wszOwnerDomain[],
    WCHAR                  wszApplication[],
    FILETIME *             pftCreationTime,
    DWORD *                pdwVolumeSerialNo)
{
    BY_HANDLE_FILE_INFORMATION hinfo;
    HANDLE                     hFile;
    SECURITY_DESCRIPTOR *      pOwnerSecDescr = NULL;
    PSID                       pOwnerSid;
    DWORD                      cbOwnerSid;
    DWORD                      cbSizeNeeded;
    BOOL                       fRet, fOwnerDefaulted;
    static                     s_bWaitForWorkStation = TRUE;

    HRESULT hr = OpenFile(pwszFileName, GENERIC_READ, &hFile);

    if (FAILED(hr))
    {
        return hr;
    }
    else
    {
        //
        // Read the UUID from the job indicated.
        //

        BYTE  pbBuffer[sizeof(DWORD) + sizeof(UUID)];
        DWORD dwBytesRead;

        if (!ReadFile(hFile, pbBuffer, sizeof(pbBuffer), &dwBytesRead, NULL))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            CloseHandle(hFile);
            return SCHED_E_INVALID_TASK;
        }

        if (dwBytesRead != sizeof(pbBuffer))
        {
            CHECK_HRESULT(SCHED_E_INVALID_TASK);
            CloseHandle(hFile);
            return SCHED_E_INVALID_TASK;
        }

        CopyMemory(pJobID, pbBuffer + sizeof(DWORD), sizeof(*pJobID));
    }

    //
    // Retrieve file creation time and the volume serial number.
    //

    if (!GetFileInformationByHandle(hFile, &hinfo))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Retrieve the file owner. Call GetFileSecurity twice - first to get
    // the buffer size, then the actual information retrieval.
    //

    if (GetFileSecurity(pwszFileName,
                        OWNER_SECURITY_INFORMATION,
                        NULL,
                        0,
                        &cbSizeNeeded))
    {
        //
        // Didn't expect this to succeed!
        //

        hr = E_UNEXPECTED;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) && (cbSizeNeeded > 0))
    {
        //
        // Allocate the buffer space necessary and retrieve the info.
        //

        pOwnerSecDescr = (SECURITY_DESCRIPTOR *)new BYTE[cbSizeNeeded];

        if (pOwnerSecDescr == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        if (!GetFileSecurity(pwszFileName,
                             OWNER_SECURITY_INFORMATION,
                             pOwnerSecDescr,
                             cbSizeNeeded,
                             &cbSizeNeeded))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Retrieve & validate the owner sid.
    //
    // NB : After this, pOwnerSid will point into the security descriptor,
    //      pOwnerSecDescr; hence, the descriptor must exist for the
    //      lifetime of pOwnerSid.
    //

    fRet = GetSecurityDescriptorOwner(pOwnerSecDescr,
                                      &pOwnerSid,
                                      &fOwnerDefaulted);

    if (fRet)
    {
        if (fRet = IsValidSid(pOwnerSid))
        {
            cbOwnerSid = GetLengthSid(pOwnerSid);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
    }

    if (!fRet)
    {
        goto ErrorExit;
    }

   //
   // Retrieve the account name & domain name from the file owner sid.
   //

    SID_NAME_USE snu;
    BOOL         bDoLookupAgain;

    //
    //Startup jobs for domain users will fail if workstation is not initialized
    //If LookupAccountSid fails and we are booting then force the service to 
    //  wait until workstation is fully initialized and then try again
    //
    do
    {
       bDoLookupAgain = FALSE;

       schDebugOut((DEB_TRACE, "GetFileInformation: Calling LookupAccountSid\n"));

       if (!LookupAccountSid(NULL,
                             pOwnerSid,
                             wszOwnerName,
                             &ccOwnerName,
                             wszOwnerDomain,
                             &ccOwnerDomain,
                             &snu))
       {
           hr = HRESULT_FROM_WIN32(GetLastError());
           CHECK_HRESULT(hr);

           if( s_bWaitForWorkStation )
           {
              schDebugOut((DEB_TRACE, "GetFileInformation: Delaying LookupAccountSid for boot\n"));

              WaitForMUP(120000);
              WaitForServiceToStart(L"workstation",120000);
              WaitForServiceToStart(L"netlogon",120000);

              bDoLookupAgain        = TRUE;
              s_bWaitForWorkStation = FALSE;

              //Reset since CloseFile returns this value if failure
              hr = ERROR_SUCCESS;  

           } else {
              goto ErrorExit;
           }
       }

    } while(bDoLookupAgain);


ErrorExit:
    //
    // Being a little sneaky here and reading the job application whilst
    // closing the file handle. That is, if all succeeded above.
    //

    hr = CloseFile(hFile, (WORD)ccApplication, wszApplication, hr);

    if (SUCCEEDED(hr))
    {
        *pftCreationTime   = hinfo.ftCreationTime;
        *pdwVolumeSerialNo = hinfo.dwVolumeSerialNumber;
        *pcbOwnerSid       = cbOwnerSid;
        *ppOwnerSid        = pOwnerSid;
        *ppOwnerSecDescr   = pOwnerSecDescr;

        //
        // If not already done so, set the 'mystery' global DWORD.
        // This DWORD, in addition to other data, is used to generate
        // the encryption key for the SAC/SAI database.
        //
        // The reason why this is done here is to spread the key generation
        // code around a bit.
        //

        if (!gdwKeyElement)     // This is a manifest name. Its actual name
                                // is gdwSystem.
        {
            SetMysteryDWORDValue();
        }
    }
    else
    {
        delete pOwnerSecDescr;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SetMysteryDWORDValue
//
//  Synopsis:   Initialize a global DWORD to be used as a data element in
//              generation of the SAC/SAI database encryption key.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
SetMysteryDWORDValue(void)
{
    //
    // Set the global mystery dword to the first dword of the job or queue
    // class ids, depending on the value of the machine sid.
    //

    EnterCriticalSection(&gcsSSCritSection);

    if (!gdwKeyElement)     // This is a manifest name. Its actual name
                            // is gdwSystem.
    {
        DWORD dwTmp;

        //
        // The last (3) subauthorities of the machine SID are unique per
        // machine. Test LSB of the 2nd from the last subauthority.
        //

        PUCHAR pSidSubAuthorityCount = GetSidSubAuthorityCount(
                                                gpDomainInfo->DomainSid);
        schAssert(pSidSubAuthorityCount != NULL);
        DWORD   nSubAuthority = (pSidSubAuthorityCount != NULL ?
                        max(*pSidSubAuthorityCount, 2) : 2);
        DWORD * pSubAuthority = GetSidSubAuthority(
                                                gpDomainInfo->DomainSid,
                                                nSubAuthority - 2);
        schAssert(pSubAuthority != NULL);

        if (pSubAuthority != NULL && *pSubAuthority & 0x00000001)
        {
            dwTmp = 0x255b3f60; // CLSID_CQueue.Data1
        }
        else
        {
            dwTmp = CLSID_CTask.Data1;
        }

        //
        // Apply a mask to the mystery value to further disguise it.
        //

        if (gwszComputerName[0] & 0x0100)
        {
            dwTmp &= 0xC03F71C3;
        }
        else
        {
            dwTmp &= 0xE3507233;
        }

        gdwKeyElement = dwTmp;
    }

    LeaveCriticalSection(&gcsSSCritSection);
}

//*************************************************************
//
//  WaitForServiceToStart()
//
//  Purpose:    Waits for the specified service to start
//
//  Parameters: dwMaxWait  -  Max wait time
//
//
//  Return:     TRUE if the network is started
//              FALSE if not
//
//*************************************************************
BOOL WaitForServiceToStart (LPTSTR lpServiceName, DWORD dwMaxWait)
{
    BOOL bStarted                          = FALSE;
    DWORD dwSize                           = 512;
    SC_HANDLE hScManager                   = NULL;
    SC_HANDLE hService                     = NULL;
    LPQUERY_SERVICE_CONFIG lpServiceConfig = NULL;
    DWORD dwPoleWait                       = 1000;
    DWORD StartTickCount;
    SERVICE_STATUS ServiceStatus;
 
    //
    // OpenSCManager and the rpcss service
    //
    hScManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (!hScManager) {
        goto Exit;
    }
 
    hService = OpenService(hScManager, lpServiceName,
                           SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS);
    if (!hService) {
        goto Exit;
    }
 
    //
    // Query if the service is going to start
    //
    lpServiceConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc (LPTR, dwSize);
    if (!lpServiceConfig) {
        goto Exit;
    }
 
    if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {
 
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Exit;
        }
 
        LocalFree (lpServiceConfig);
 
        lpServiceConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc (LPTR, dwSize);
 
        if (!lpServiceConfig) {
            goto Exit;
        }
 
        if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {
            goto Exit;
        }
    }
 
    if (lpServiceConfig->dwStartType != SERVICE_AUTO_START) {
        goto Exit;
    }
 
    //
    // Loop until the service starts or we think it never will start
    // or we've exceeded our maximum time delay.
    //
 
    StartTickCount = GetTickCount();
 
    while (!bStarted) {
 
        if ((GetTickCount() - StartTickCount) > dwMaxWait) {
            break;
        }
 
        if (!QueryServiceStatus(hService, &ServiceStatus )) {
            break;
        }

        if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
            if (ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED) {
                Sleep(dwPoleWait);
            } else {
                break;
            }
        } else if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {
 
            bStarted = TRUE;
 
        } else if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING) {
            Sleep(dwPoleWait);
        } else {
            Sleep(dwPoleWait);
        }
    }
 

Exit:
 
    if (lpServiceConfig) {
        LocalFree (lpServiceConfig);
    }
 
    if (hService) {
        CloseServiceHandle(hService);
    }
 
    if (hScManager) {
        CloseServiceHandle(hScManager);
    }
 
    return bStarted;
}
 

//*************************************************************
//
//  WaitForMUP()
//
//  Purpose:    Waits for the MUP to finish initializing
//
//  Parameters: dwMaxWait     -  Max wait time
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************
BOOL WaitForMUP (DWORD dwMaxWait)
{
    HANDLE hEvent;
    BOOL bResult;
    INT i = 0;
 
    //
    // Try to open the event
    //
    do {
        hEvent = OpenEvent (SYNCHRONIZE, FALSE,
                            TEXT("wkssvc:  MUP finished initializing event"));
        if (hEvent) {
            break;
        }
 
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            break;
        }
 
        Sleep(500);
        i++;
    } while (i < 20);
 
    if (!hEvent) {
        return FALSE;
    }
 
    //
    // Wait for the event to be signalled
    //
    bResult = (WaitForSingleObject (hEvent, dwMaxWait) == WAIT_OBJECT_0);
 
    //
    // Clean up
    //
    CloseHandle (hEvent);
 
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\security.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       security.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:  None.
//
//  History:    15-May-96   MarkBl  Created
//              26-Feb-01   JBenton Prefix Bug 160502 - using uninit memory
//              17-Apr-01   a-JyotiG Fixed Bug 367263 - Should not assign any privilege/right 
//							to system account.  
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#include <wincrypt.h>
#include <rc2.h>        // found in private\inc\crypto
#include <modes.h>      // found in private\inc\crypto
#include <ntsecapi.h>
#include <ntdsapi.h>    // DsCrackNames
#include <mstask.h>
#include "SASecRPC.h"
#include "misc.hxx"     // for _HRESULT_FROM_WIN32
#include "debug.hxx"
#include "resource.h"
#include "lsa.hxx"
#include "queue.hxx"    // Need these to include proto.hxx.
#include "task.hxx"
#include "thread.hxx"
#include "proto.hxx"
#include "globals.hxx"  // BUGBUG 254102
#include "sch_cls.hxx"  // To implement AddAtJobWithHash


#define NULL_PASSWORD_SIZE  0xFFFFFFFF
#define WSZ_SANSC           L"SANSC"

#if SIGNATURE_SIZE != HASH_DATA_SIZE
 #error SIGNATURE_SIZE is assumed to be the same as HASH_DATA_SIZE
#endif

typedef enum _MARSHAL_FUNCTION {
    Marshal,
    Hash,
    HashAndSign
} MARSHAL_FUNCTION;

typedef struct _RC2_KEY_INFO {
    BYTE rgbIV[RC2_BLOCKLEN];
    WORD rgwKeyTable[RC2_TABLESIZE];
} RC2_KEY_INFO;

HRESULT OpenFile(   // BUGBUG  Move to a header shared with secmisc.cxx
                LPCWSTR  pwszFileName,
                DWORD    dwDesiredAccess,
                HANDLE * phFile);
HRESULT ComputeCredentialKey(
                HCRYPTPROV     hCSP,
                RC2_KEY_INFO * pRC2KeyInfo);
BOOL    CredentialAccessCheck(
                HCRYPTPROV hCSP,
                BYTE *    pbCredentialIdentity);
HRESULT CredentialLookupAndAccessCheck(
                HCRYPTPROV hCSP,
                PSID       pSid,
                DWORD      cbSAC,
                BYTE *     pbSAC,
                DWORD *    pCredentialIndex,
                BYTE       rgbHashedSid[],
                DWORD *    pcbCredential,
                BYTE **    ppbCredential);
HRESULT DecryptCredentials(
                const RC2_KEY_INFO & RC2KeyInfo,
                DWORD                cbEncryptedData,
                BYTE *               pbEncryptedData,
                PJOB_CREDENTIALS     pjc,
                BOOL                 fDecryptInPlace = TRUE);
HRESULT EncryptCredentials(
                const RC2_KEY_INFO & RC2KeyInfo,
                LPCWSTR              pwszAccount,
                LPCWSTR              pwszDomain,
                LPCWSTR              pwszPassword,
                PSID                 pSid,
                DWORD *              pcbEncryptedData,
                BYTE **              ppbEncryptedData);
HRESULT GrantAccountBatchPrivilege(PSID pAccountSid);
HRESULT HashJobIdentity(
                HCRYPTPROV hCSP,
                LPCWSTR    pwszFileName,
                BYTE       rgbHash[]);
HRESULT HashSid(HCRYPTPROV hCSP,
                PSID       pSid,
                BYTE       rgbHash[]);
HRESULT GetCSPHandle(HCRYPTPROV * phCSP);
void    CloseCSPHandle(HCRYPTPROV hCSP);
BOOL    IsThreadCallerAnAdmin(
                HANDLE hThreadToken);
HRESULT MarshalData(
                HCRYPTPROV       hCSP,
                HCRYPTHASH *     phHash,
                MARSHAL_FUNCTION MarshalFunction,
                DWORD *          pcbSignature,
                BYTE **          ppbSignature,
                DWORD            cArgs,
                ...);
BOOL    MatchThreadCallerAgainstCredential(
                HCRYPTPROV hCSP,
                HANDLE     hThreadToken,
                BYTE *     pbCredentialIdentity);
void    MungeComputerName(
                DWORD ccComputerName);
#ifndef NOSTATIC
#define SaveJobCredentials SAFunction19
#endif
HRESULT SaveJobCredentials(
                LPCWSTR pwszJobPath,
                LPCWSTR pwszAccount,
                LPCWSTR pwszDomain,
                LPCWSTR pwszPassword,
                PSID    pAccountSid);
DWORD   SchedUPNToAccountName(
                IN  LPCWSTR lpUPN,
                OUT LPWSTR  *ppAccountName);
LPWSTR  SkipDomainName(
                LPCWSTR pwszUserName);
BOOL    LookupAccountNameWrap(          // BUGBUG 254102
                LPCTSTR lpSystemName,
                LPCTSTR lpAccountName,
                PSID    Sid,
                LPDWORD cbSid,
                LPTSTR  ReferencedDomainName,
                LPDWORD cbReferencedDomainName,
                PSID_NAME_USE peUse);

CRITICAL_SECTION   gcsSSCritSection;
WCHAR              gwszComputerName[MAX_COMPUTERNAME_LENGTH + 2] = L"";  // this buffer must remain this size or it will break old credentials
LPWSTR             gpwszComputerName;
DWORD              gdwSystem       = 0;
DWORD              gccComputerName = MAX_COMPUTERNAME_LENGTH + 2;
POLICY_ACCOUNT_DOMAIN_INFO * gpDomainInfo = NULL;
DWORD              gcbMachineSid   = 0;
PSID               gpMachineSid    = NULL;

#define gdwKeyElement gdwSystem         // A manifest for this global's true
                                        // function.


//+---------------------------------------------------------------------------
//
//  RPC:        SASetAccountInformation
//
//  Synopsis:
//
//  Arguments:  [Handle]       --
//              [pwszJobName]  -- Relative job name. eg: MyJob.job.
//              [pwszAccount]  --
//              [pwszPassword] --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SASetAccountInformation(
    SASEC_HANDLE Handle,
    LPCWSTR      pwszJobName,
    LPCWSTR      pwszAccount,
    LPCWSTR      pwszPassword,
    DWORD        dwJobFlags)
{
    WCHAR        wszJobPath[MAX_PATH + 1];
    BYTE         pbAccountSid[MAX_SID_SIZE];
    WCHAR        wszDomain[MAX_DOMAINNAME + 1]       = L"";
    PSID         pAccountSid                         = NULL;
    DWORD        cbAccountSid                        = MAX_SID_SIZE;
    DWORD        ccDomain                            = MAX_DOMAINNAME + 1;
    SID_NAME_USE snu;
    HRESULT      hr                 = S_OK;
    SID          LocalSystemSid     = { SID_REVISION,
                                        1,
                                        SECURITY_NT_AUTHORITY,
                                        SECURITY_LOCAL_SYSTEM_RID };

    TRACE_FUNCTION("SASetAccountInformation");

    if (pwszJobName == NULL || pwszAccount == NULL)
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Disallow files outside the tasks folder
    //
    if (wcschr(pwszJobName, L'\\') || wcschr(pwszJobName, L'/'))
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Append the job name to the local Task's folder path.
    //

    schAssert(g_TasksFolderInfo.ptszPath != NULL);

    if (wcslen(g_TasksFolderInfo.ptszPath) + 1 + wcslen(pwszJobName) + 1
            > ARRAY_LEN(wszJobPath))
    {
        CHECK_HRESULT(SCHED_E_CANNOT_OPEN_TASK);
        return(SCHED_E_CANNOT_OPEN_TASK);
    }

    // password debug
    // LogDebug2("Set password \"%s\" for job \"%s\"",
    //            pwszPassword ? pwszPassword : L"(NULL)",
    //            pwszJobName);

    wcscpy(wszJobPath, g_TasksFolderInfo.ptszPath);
    wcscat(wszJobPath, L"\\");
    wcscat(wszJobPath, pwszJobName);

    //
    // An account name of "" signifies the local system account.
    //
    BOOL  fIsAccountLocalSystem = (pwszAccount[0] == L'\0');

    //
    // Treat the account name as a UPN if it lacks a \ and has an @.
    // Otherwise, treat it as a SAM name.
    //
    BOOL  fUpn = (wcschr(pwszAccount, L'\\') == NULL &&
                  wcschr(pwszAccount, L'@') != NULL);
    schDebugOut((DEB_TRACE, "Name '%S' is a %s name\n", pwszAccount,
                 fUpn ? "UPN" : "SAM"));

    //
    // Get the account's SID
    //
    if (fIsAccountLocalSystem)
    {
        pAccountSid = &LocalSystemSid;
    }
    else
    {
        LPWSTR pwszSamName;

        if (fUpn)
        {
            //
            // Get the SAM name, so we can call LookupAccountName
            //
            DWORD dwErr = SchedUPNToAccountName(pwszAccount, &pwszSamName);
            if (dwErr != NO_ERROR)
            {
                hr = HRESULT_FROM_WIN32(dwErr);
                CHECK_HRESULT(hr);
                return hr;
            }
        }
        else
        {
            pwszSamName = (LPWSTR) pwszAccount;
        }

        if (!LookupAccountNameWrap(NULL,
                               pwszSamName,
                               pbAccountSid,
                               &cbAccountSid,
                               wszDomain,
                               &ccDomain,
                               &snu))
        {
            CHECK_HRESULT(_HRESULT_FROM_WIN32(GetLastError()));
            hr = SCHED_E_ACCOUNT_NAME_NOT_FOUND;
        }

        if (fUpn)
        {
            delete pwszSamName;
        }

        if (FAILED(hr))
        {
            return hr;
        }

        schAssert(IsValidSid(pbAccountSid));

        pAccountSid = pbAccountSid;
    }

    //
    // If the password is NULL, this task is meant to be run
    // without prompting the user for credentials
    //
    if (pwszPassword == NULL)
    {
        DWORD       dwError   = NO_ERROR;
        HANDLE      hToken;

        //
        // Impersonate the caller and open his token
        //
        DWORD       RpcStatus = RpcImpersonateClient(NULL);

        if (RpcStatus != RPC_S_OK)
        {
            hr = _HRESULT_FROM_WIN32(RpcStatus);
            CHECK_HRESULT(hr);
            return hr;
        }

        if (!OpenThreadToken(GetCurrentThread(),
                                  TOKEN_QUERY,           // Desired access.
                                  TRUE,                  // Open as self.
                                  &hToken))
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            goto Clean0;
        }

        do  // Not a loop.  Error break out.
        {
            //
            // If the caller has a restricted token (e.g., an ActiveX
            // control), it's not allowed to use a NULL password.
            //
            if (IsTokenRestricted(hToken))
            {
                dwError = ERROR_ACCESS_DENIED;
                schDebugOut((DEB_ERROR, "Restricted token tried to set NULL "
                             "password for %ws.  Denying access.\n", pwszJobName));
                break;
            }

            //
            // To set credentials for the job, the caller must have write
            // access to the job file.
            //
            // Note - CreateFile with FILE_SHARE_READ is OK since we don't
            // really write to the file.
            //
            HANDLE  hFile;
            hr = OpenFile(wszJobPath, GENERIC_WRITE, &hFile);
            if (FAILED(hr))
            {
                ERR_OUT("SASetAccountInformation: caller's open of task file", hr);
                break;
            }

            CloseHandle(hFile);

            //
            // Unless the task is being set to run as LocalSystem, a NULL
            // password means that the task must be scheduled to run only
            // if the user is logged on, so make sure that flag is set in
            // that case
            //
            if (!fIsAccountLocalSystem
                &&
                !(dwJobFlags & TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))
            {
                schDebugOut((DEB_ERROR, "SetAccountInformation with NULL "
                             "password is only supported for LocalSystem "
                             "account or for job with "
                             "TASK_FLAG_RUN_ONLY_IF_LOGGED_ON\n",
                             pwszJobName));
                hr = SCHED_E_UNSUPPORTED_ACCOUNT_OPTION;
                break;
            }

            //
            // The caller must be either LocalSystem, an administrator or
            // the user named in pwszAccount (the latter being the most
            // common case.  CODEWORK - rearrange to optimize for that case?)
            //

            BOOL    fIsCallerLocalSystem;

            if (!CheckTokenMembership(hToken,
                                      &LocalSystemSid,
                                      &fIsCallerLocalSystem))
            {
                dwError = GetLastError();
                ERR_OUT("CheckTokenMembership", dwError);
                // translate this to E_UNEXPECTED?
                break;
            }

            if (fIsCallerLocalSystem || IsThreadCallerAnAdmin(hToken))
            {
                //
                // (success)
                //
                break;
            }

            if (fIsAccountLocalSystem)
            {
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                schDebugOut((DEB_ERROR, "Non-system, non-admin tried "
                             "to schedule task as LocalSystem\n"));
                break;
            }

            //
            // Compare the caller's token with the account's SID
            //
            BOOL fIsCallerAccount;
            if (!CheckTokenMembership(hToken,
                                      pAccountSid,
                                      &fIsCallerAccount))
            {
                dwError = GetLastError();
                ERR_OUT("CheckTokenMembership", dwError);
                // translate this to E_UNEXPECTED?
                break;
            }

            if (! fIsCallerAccount)
            {
                schDebugOut((DEB_ERROR, "Caller is neither LocalSystem "
                             "nor admin nor the named account\n"));
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            }

            //
            // else success -- the caller is the named account
            //
        } while (0);


        CloseHandle(hToken);

Clean0:
        //
        // End impersonation.
        //
        if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK)
        {
            ERR_OUT("RpcRevertToSelf", RpcStatus);
            schAssert(!"RpcRevertToSelf failed");
        }

        if (dwError != NO_ERROR)
        {
            hr = _HRESULT_FROM_WIN32(dwError);
        }

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
        }
        else
        {
            schDebugOut((DEB_TRACE, "Saving NULL password for %ws\n", pwszJobName));
        }
    }
    // end of NULL password stuff


    if (SUCCEEDED(hr))
    {
        //
        // Write the credentials to the database
        // If given a UPN, save "" for the domain and the entire UPN for the user
        //
        hr = SaveJobCredentials(
                        wszJobPath,
                        fUpn ? pwszAccount : SkipDomainName(pwszAccount),
                        fUpn ? L"" : wszDomain,
                        pwszPassword,
                        pAccountSid
                        );
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveJobCredentials
//
//  Synopsis:   Writes the job credentials to the credential database
//
//  Arguments:
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
SaveJobCredentials(
    LPCWSTR pwszJobPath,
    LPCWSTR pwszAccount,
    LPCWSTR pwszDomain,
    LPCWSTR pwszPassword,
    PSID    pAccountSid
    )
{
    BYTE         rgbIdentity[HASH_DATA_SIZE];
    BYTE         rgbHashedAccountSid[HASH_DATA_SIZE] = { 0 };
    RC2_KEY_INFO RC2KeyInfo;
    HRESULT      hr;
    DWORD        cbSAI;
    DWORD        cbSAC;
    DWORD        cbCredentialNew;
    DWORD        cbEncryptedData;
    DWORD        CredentialIndexNew, CredentialIndexPrev;
    BYTE *       pbEncryptedData;
    BYTE *       pbFoundIdentity;
    BYTE *       pbIdentitySet;
    BYTE *       pbCredentialNew    = NULL;
    BYTE *       pbSAI              = NULL;
    BYTE *       pbSAC              = NULL;
    HCRYPTPROV   hCSP               = NULL;

    //
    // Obtain a provider handle to the CSP (for use with Crypto API).
    //

    hr = GetCSPHandle(&hCSP);

    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Hash the job into a unique identity.
    //

    hr = HashJobIdentity(hCSP, pwszJobPath, rgbIdentity);

    if (FAILED(hr))
    {
        CloseCSPHandle(hCSP);
        return(hr);
    }

    //
    // Store a NULL password by flipping the last bit of the hash data.
    //

    if (pwszPassword == NULL)
    {
        LAST_HASH_BYTE(rgbIdentity) ^= 1;
    }

    //
    // Guard SA security database access.
    //

    EnterCriticalSection(&gcsSSCritSection);

    //
    // Read SAI & SAC databases.
    //

    hr = ReadSecurityDBase(&cbSAI, &pbSAI, &cbSAC, &pbSAC);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Check if the identity exists in the SAI.
    // (Note, SAIFindIdentity ignores the last bit of the hash data
    // when searching for a match.)
    //

    hr = SAIFindIdentity(rgbIdentity,
                         cbSAI,
                         pbSAI,
                         &CredentialIndexPrev,
                         NULL,
                         &pbFoundIdentity,
                         NULL,
                         &pbIdentitySet);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Check if the caller-specified credentials already exist in the SAC.
    // Ensure also, if the credentials exist, that the caller has access.
    //

    hr = CredentialLookupAndAccessCheck(hCSP,
                                        pAccountSid,
                                        cbSAC,
                                        pbSAC,
                                        &CredentialIndexNew,
                                        rgbHashedAccountSid,
                                        &cbCredentialNew,
                                        &pbCredentialNew);

    if (FAILED(hr) && hr != SCHED_E_ACCOUNT_INFORMATION_NOT_SET)
    {
        goto ErrorExit;
    }

    //
    // Generate the encryption key & encrypt the account information passed.
    //

    hr = ComputeCredentialKey(hCSP, &RC2KeyInfo);

    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    hr = EncryptCredentials(RC2KeyInfo,
                            pwszAccount,
                            pwszDomain,
                            pwszPassword,
                            pAccountSid,
                            &cbEncryptedData,
                            &pbEncryptedData);

    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    if (pbFoundIdentity == NULL)
    {
        //
        // This job is new to the SAI. That is, there are no credentials
        // associated with this job yet.
        //

        if (pbCredentialNew != NULL)
        {
            //
            // If the credentials the caller specified already exist in the
            // SAC, use them. Note, we've already established the caller
            // has permission to use them.
            //
            // Insert the job identity into the SAI identity set associated
            // with this credential.
            //

            hr = SAIIndexIdentity(cbSAI,
                                  pbSAI,
                                  CredentialIndexNew,
                                  0,
                                  NULL,
                                  NULL,
                                  &pbIdentitySet);

            if (hr == S_FALSE)
            {
                //
                // The SAC & SAI databases are out of sync.
                // Should *never* occur. Logic on exit handles this.
                //

                ASSERT_SECURITY_DBASE_CORRUPT();
                hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                goto ErrorExit;
            }
            else if (SUCCEEDED(hr))
            {
                hr = SAIInsertIdentity(rgbIdentity,
                                       pbIdentitySet,
                                       &cbSAI,
                                       &pbSAI);
                CHECK_HRESULT(hr);

                if (SUCCEEDED(hr) && pwszPassword != NULL)
                {
                    //
                    // Simply change of existing credentials (password change).
                    // If we're setting a NULL password, we're setting it for
                    // this job alone, and we don't need to touch the SAC.
                    // If we're setting a non-NULL password, we're setting it
                    // for all jobs in this account, and we need to update the
                    // SAC credential in-place.
                    //

                    hr = SACUpdateCredential(cbEncryptedData,
                                             pbEncryptedData,
                                             cbCredentialNew,
                                             pbCredentialNew,
                                             &cbSAC,
                                             &pbSAC);
                    CHECK_HRESULT(hr);
                }
            }
            else
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // The credentials didn't exist in the SAC.
            //
            // Append new credentials to the SAC & append the new job
            // identity to the SAI. As a result, the identity will be
            // associated with the new credentials.
            //

            hr = SACAddCredential(rgbHashedAccountSid,
                                  cbEncryptedData,
                                  pbEncryptedData,
                                  &cbSAC,
                                  &pbSAC);

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }

            hr = SAIAddIdentity(rgbIdentity, &cbSAI, &pbSAI);
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        //
        // Account change for an existing job's credentials.
        //
        // Ensure the caller has permission to change account information.
        // Do so by verifying caller access to the existing credentials.
        //

        DWORD  cbCredentialPrev;
        BYTE * pbCredentialPrev;

        hr = SACIndexCredential(CredentialIndexPrev,
                                cbSAC,
                                pbSAC,
                                &cbCredentialPrev,
                                &pbCredentialPrev);

        if (hr == S_FALSE)
        {
            //
            // Credential not found? The SAC & SAI databases are out of sync.
            // This should *never* occur. Logic on exit handles this.
            //

            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
            goto ErrorExit;
        }
        else if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        //
        // Only check the credentials if we're dealing with a non-NULL password
        //
        if (pwszPassword != NULL)
        {
            //
            // pbCredentialPrev points to the start of the credential identity.
            //

            if (!CredentialAccessCheck(hCSP,
                                       pbCredentialPrev))
            {
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }

        if ((pbCredentialNew != NULL) &&
            (CredentialIndexPrev != CredentialIndexNew))
        {
            //
            // The credentials the caller wishes to use already exist in the
            // SAC, yet it differs from the previous.
            //
            // Remove the job identity from its existing SAI position
            // (associated with the previous credentials) and relocate
            // to be associated with the new credentials.
            //
            // SAIRemoveIdentity could result in removal of the associated
            // credential, if this was the last identity associated with it.
            // Save away the original SAC size to see if we must fix up the
            // new credential index on remove.
            //

            DWORD cbSACOrg = cbSAC;

            hr = SAIRemoveIdentity(pbFoundIdentity,
                                   pbIdentitySet,
                                   &cbSAI,
                                   &pbSAI,
                                   CredentialIndexPrev,
                                   &cbSAC,
                                   &pbSAC);

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }

            if (cbSACOrg != cbSAC)
            {
                //
                // The new credential index must be adjusted.
                //

                if (CredentialIndexNew > CredentialIndexPrev)
                {
                    CredentialIndexNew--;
                }
            }

            hr = SAIIndexIdentity(cbSAI,
                                  pbSAI,
                                  CredentialIndexNew,
                                  0,
                                  NULL,
                                  NULL,
                                  &pbIdentitySet);  // [out] ptr.

            if (hr == S_FALSE)
            {
                //
                // The SAC & SAI databases are out of sync. This should
                // *never* occur. Logic on exit handles this.
                //

                ASSERT_SECURITY_DBASE_CORRUPT();
                hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                goto ErrorExit;
            }
            else if (SUCCEEDED(hr))
            {
                hr = SAIInsertIdentity(rgbIdentity,
                                       pbIdentitySet,
                                       &cbSAI,
                                       &pbSAI);
                CHECK_HRESULT(hr);

                if (SUCCEEDED(hr) && pwszPassword != NULL)
                {
                    //
                    // Update the existing credentials if the user has
                    // specified a non-NULL password.
                    //
                    // First, re-index the credential since the remove
                    // above may have altered SAC content.
                    //

                    hr = SACIndexCredential(CredentialIndexNew,
                                            cbSAC,
                                            pbSAC,
                                            &cbCredentialNew,
                                            &pbCredentialNew);

                    if (hr == S_FALSE)
                    {
                        //
                        // Something is terribly wrong. This should *never*
                        // occur. Logic on exit handles this.
                        //

                        ASSERT_SECURITY_DBASE_CORRUPT();
                        hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                        goto ErrorExit;
                    }
                    else if (FAILED(hr))
                    {
                        CHECK_HRESULT(hr);
                        goto ErrorExit;
                    }

                    hr = SACUpdateCredential(cbEncryptedData,
                                             pbEncryptedData,
                                             cbCredentialNew,
                                             pbCredentialNew,
                                             &cbSAC,
                                             &pbSAC);
                    CHECK_HRESULT(hr);
                }
            }
            else
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }
        else if (pbCredentialNew == NULL)
        {
            //
            // The credentials the caller wishes to use do not exist in the
            // SAC.
            //
            // Remove the job identity from its existing SAI position
            // (associated with the previous credentials), then add both
            // the new credentials and the identity to the SAC & SAI
            // respectively. As a result, the identity will be associated
            // with the new credentials.
            //

            //
            // NB : This routine also removes the associated credential from
            //      the SAC if this was the last identity associated with it.
            //      Also, do not reference pbFoundIdentity & pbIdentitySet
            //      after this call, as they will be invalid.
            //

            hr = SAIRemoveIdentity(pbFoundIdentity,
                                   pbIdentitySet,
                                   &cbSAI,
                                   &pbSAI,
                                   CredentialIndexPrev,
                                   &cbSAC,
                                   &pbSAC);

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }

            //
            // Append the identity and the new credentials to the SAI and
            // SAC respectively.
            //

            hr = SACAddCredential(rgbHashedAccountSid,
                                  cbEncryptedData,
                                  pbEncryptedData,
                                  &cbSAC,
                                  &pbSAC);

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }

            hr = SAIAddIdentity(rgbIdentity, &cbSAI, &pbSAI);

            if (FAILED(hr))
            {
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Simply change of existing credentials (password change).
            // If we're setting a NULL password, we're setting it for this job
            // alone, and we don't need to touch the SAC.  If we're setting a
            // non-NULL password, we're setting it for all jobs in this
            // account, and we need to update the SAC credential in-place.
            //

            if (pwszPassword != NULL)
            {
                hr = SACUpdateCredential(cbEncryptedData,
                                         pbEncryptedData,
                                         cbCredentialPrev,
                                         pbCredentialPrev,
                                         &cbSAC,
                                         &pbSAC);

                if (FAILED(hr))
                {
                    CHECK_HRESULT(hr);
                    goto ErrorExit;
                }
            }

            //
            // We also need to rewrite the SAI data, because if the password
            // changed from NULL to non-NULL or vice versa, the last bit of
            // the SAI data will have changed.
            //
            hr = SAIUpdateIdentity(rgbIdentity,
                                   pbFoundIdentity,
                                   cbSAI,
                                   pbSAI);

            CHECK_HRESULT(hr);
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = WriteSecurityDBase(cbSAI, pbSAI, cbSAC, pbSAC);
        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            //
            // Grant the account batch privilege.
            // We could choose to ignore the return code here, since the
            // privilege can still be granted later; but if we ignored it,
            // a caller might never know that the call failed until it was
            // time to run the job, which is not good behavior.  (See
            // bug 366582)
            //
			
			//Also we should not assign any privilege/right to system account. Refer to bug 367263
			SID LocalSystemSid = { SID_REVISION,
                                   1,
                                   SECURITY_NT_AUTHORITY,
                                   SECURITY_LOCAL_SYSTEM_RID };

			if(!EqualSid(&LocalSystemSid,pAccountSid)) {
				hr = GrantAccountBatchPrivilege(pAccountSid);
			}            
        }
    }

ErrorExit:
    if (pbSAI != NULL) LocalFree(pbSAI);
    if (pbSAC != NULL) LocalFree(pbSAC);
    if (hCSP  != NULL) CloseCSPHandle(hCSP);

    //
    // Log an error & rest the SA security dbases SAI & SAC if corruption
    // is detected.
    //

    if (hr == SCHED_E_ACCOUNT_DBASE_CORRUPT)
    {
        //
        // Log an error.
        //

        LogServiceError(IERR_SECURITY_DBASE_CORRUPTION, 0,
                        IDS_HELP_HINT_DBASE_CORRUPT);

        //
        // Reset SAI & SAC by writing four bytes of zeros into each.
        // Ignore the return code. No recourse if this fails.
        //

        DWORD dwZero = 0;
        WriteSecurityDBase(sizeof(dwZero), (BYTE *)&dwZero, sizeof(dwZero),
                            (BYTE *)&dwZero);
    }

    LeaveCriticalSection(&gcsSSCritSection);

    return(hr);
}


//+---------------------------------------------------------------------------
//
//  RPC:        SASetNSAccountInformation
//
//  Synopsis:   Configure the NetSchedule account.
//
//  Arguments:  [Handle]       -- Unused.
//              [pwszAccount]  -- Account name. If NULL, reset the credential
//                                information to zero.
//              [pwszPassword] -- Account password.
//
//  Returns:    S_OK    -- Operation successful.
//              HRESULT -- Error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SASetNSAccountInformation(
    SASEC_HANDLE Handle,
    LPCWSTR      pwszAccount,
    LPCWSTR      pwszPassword)
{
    HRESULT    hr = S_OK;
    RPC_STATUS RpcStatus;

    //
    // If not done so already, initialize the DWORD global data element to be
    // used in generation of the encryption key. It's possible this hasn't
    // been performed yet.
    //

    if (!gdwKeyElement)
    {
        //
        // NB : This routine enters (and leaves) the gcsSSCritSection
        //      critical section.
        //

        SetMysteryDWORDValue();
    }

    //
    // The RPC caller must be an administrator to perform this function.
    //
    // Impersonate the caller.
    //

    if ((RpcStatus = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        hr = _HRESULT_FROM_WIN32(RpcStatus);
        CHECK_HRESULT(hr);
        return(hr);
    }

    if (! IsThreadCallerAnAdmin(NULL))
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    //
    // End impersonation.
    //

    if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        //
        // BUGBUG : What to do if the impersonation revert fails?
        //

        hr = _HRESULT_FROM_WIN32(RpcStatus);
        CHECK_HRESULT(hr);
        schAssert(!"Couldn't revert to self");
    }

    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Privilege level check above succeeded if we've gotten to this point.
    //
    // Retrieve the SID of the account name specified.
    //

    RC2_KEY_INFO RC2KeyInfo;
    BYTE         pbAccountSid[MAX_SID_SIZE];
    PSID         pAccountSid                   = NULL;
    WCHAR        wszDomain[MAX_DOMAINNAME + 1] = L"";
    DWORD        cbAccountSid                  = MAX_SID_SIZE;
    DWORD        ccDomain                      = MAX_DOMAINNAME + 1;
    DWORD        dwZero                        = 0;
    DWORD        cbEncryptedData               = 0;
    BYTE *       pbEncryptedData               = NULL;
    SID_NAME_USE snu;
    HCRYPTPROV   hCSP                          = NULL;

    if (pwszAccount != NULL)
    {
        if (!LookupAccountName(NULL,
                               pwszAccount,
                               pbAccountSid,
                               &cbAccountSid,
                               wszDomain,
                               &ccDomain,
                               &snu))
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return(SCHED_E_ACCOUNT_NAME_NOT_FOUND);
        }

        pAccountSid = pbAccountSid;
        pwszAccount = SkipDomainName(pwszAccount);
    }

    //
    // Guard SA security database access.
    //

    EnterCriticalSection(&gcsSSCritSection);

    if (pwszAccount == NULL)
    {
        hr = WriteLsaData(sizeof(WSZ_SANSC), WSZ_SANSC, sizeof(dwZero),
                                    (BYTE *)&dwZero);
        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
    }
    else
    {
        //
        // Obtain a provider handle to the CSP (for use with Crypto API).
        //

        hr = GetCSPHandle(&hCSP);

        if (FAILED(hr))
        {
            goto ErrorExit;
        }

        //
        // Generate the encryption key & encrypt the account information
        // passed.
        //

        hr = ComputeCredentialKey(hCSP, &RC2KeyInfo);

        if (FAILED(hr))
        {
            goto ErrorExit;
        }

        hr = EncryptCredentials(RC2KeyInfo,
                                pwszAccount,
                                wszDomain,
                                pwszPassword,
                                pAccountSid,
                                &cbEncryptedData,
                                &pbEncryptedData);

        // Clear key content.
        //
        memset(&RC2KeyInfo, 0, sizeof(RC2KeyInfo));

        if (FAILED(hr))
        {
            goto ErrorExit;
        }

        hr = WriteLsaData(sizeof(WSZ_SANSC), WSZ_SANSC, cbEncryptedData,
                                    pbEncryptedData);

        delete [] pbEncryptedData;

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
    }

    //
    // Grant the account batch privilege.
    // We could choose to ignore the return code here, since the
    // privilege can still be granted later; but if we ignored it,
    // a caller might never know that the call failed until it was
    // time to run the job, which is not good behavior.  (See
    // bug 366582)
    //
    if (pAccountSid != NULL)
    {
        hr = GrantAccountBatchPrivilege(pAccountSid);
    }

ErrorExit:
    LeaveCriticalSection(&gcsSSCritSection);

    if (hCSP != NULL) CloseCSPHandle(hCSP);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  RPC:        SAGetNSAccountInformation
//
//  Synopsis:   Retrieve the NetSchedule account name.
//
//  Arguments:  [Handle]       --
//              [ccBufferSize] --
//              [wszBuffer]    --
//
//  Returns:    S_OK    -- Operation successful.
//              S_FALSE -- No account specified.
//              HRESULT -- Error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SAGetNSAccountInformation(
    SASEC_HANDLE Handle,
    DWORD        ccBufferSize,
    WCHAR        wszBuffer[])
{
    JOB_CREDENTIALS jc;
    HRESULT         hr;

    //
    // Retrieve the NetSchedule credentials, but return only the account name.
    //

    hr = I_GetNSAccountInformation(&jc);

    if (SUCCEEDED(hr) && hr != S_FALSE)
    {
        ZERO_PASSWORD(jc.wszPassword);      // Not needed; NULL handled.

        if (ccBufferSize > (jc.ccAccount + 1 + jc.ccDomain))
        {
            wcscpy(wszBuffer, jc.wszDomain);
            wcscat(wszBuffer, L"\\");
            wcscat(wszBuffer, jc.wszAccount);
        }
        else
        {
            //
            // Should *never* occur.
            //

            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            CHECK_HRESULT(hr);
        }
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNetScheduleInformation, aka I_GetNSAccountInformation
//
//  Synopsis:   Retrieve the NetSchedule account credentials.
//
//  Arguments:  [pjc] -- Returned credentials.
//
//  Returns:    S_OK    -- Operation successful.
//              S_FALSE -- No account specified.
//              HRESULT -- Error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetNetScheduleInformation(
    PJOB_CREDENTIALS pjc)
{
    RC2_KEY_INFO RC2KeyInfo;
    DWORD        cbEncryptedData = 0;
    BYTE *       pbEncryptedData = NULL;
    HCRYPTPROV   hCSP            = NULL;
    HRESULT      hr;

    //
    // If not done so already, initialize the DWORD global data element to be
    // used in generation of the encryption key. It's possible this hasn't
    // been performed yet.
    //

    if (!gdwKeyElement)
    {
        //
        // NB : This routine enters (and leaves) the gcsSSCritSection
        //      critical section.
        //

        SetMysteryDWORDValue();
    }

    //
    // Guard SA security database access.
    //

    EnterCriticalSection(&gcsSSCritSection);

    //
    // Read SAI & SAC databases.
    //

    hr = ReadLsaData(sizeof(WSZ_SANSC), WSZ_SANSC, &cbEncryptedData,
                            &pbEncryptedData);

    if (FAILED(hr) || hr == S_FALSE)
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }
    else if (cbEncryptedData <= sizeof(DWORD))
    {
        //
        // The information was specified previously but has been reset since.
        //

        hr = S_FALSE;
        goto ErrorExit;
    }

    //
    // Obtain a provider handle to the CSP (for use with Crypto API).
    //

    hr = GetCSPHandle(&hCSP);

    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // Generate key & decrypt the credentials.
    //

    hr = ComputeCredentialKey(hCSP, &RC2KeyInfo);

    if (SUCCEEDED(hr))
    {
        //                      *** Important ***
        //
        // The encrypted credentials passed are decrypted *in-place*.
        // The decrypted data must be zeroed immediately following decryption
        // (even in a failure case).
        //

        hr = DecryptCredentials(RC2KeyInfo,
                                cbEncryptedData,
                                pbEncryptedData,
                                pjc);

        // Don't leave the plain-text password on the heap.
        //
        memset(pbEncryptedData, 0, cbEncryptedData);

        // Clear key content.
        //
        memset(&RC2KeyInfo, 0, sizeof(RC2KeyInfo));
    }

ErrorExit:
    LeaveCriticalSection(&gcsSSCritSection);

    if (pbEncryptedData != NULL) LocalFree(pbEncryptedData);

    if (hCSP != NULL) CloseCSPHandle(hCSP);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  RPC:        SAGetAccountInformation
//
//  Synopsis:
//
//  Arguments:  [pwszJobName]  -- Relative job name. eg: MyJob.job.
//              [ccBufferSize] --
//              [wszBuffer]    --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SAGetAccountInformation(
    SASEC_HANDLE Handle,
    LPCWSTR      pwszJobName,
    DWORD        ccBufferSize,
    WCHAR        wszBuffer[])
{
    WCHAR           wszJobPath[MAX_PATH + 1];
    JOB_CREDENTIALS jc;
    HRESULT         hr;

    //
    // Disallow files outside the tasks folder
    //
    if (pwszJobName == NULL ||
        wcschr(pwszJobName, L'\\') ||
        wcschr(pwszJobName, L'/'))
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Append the job name to the local Task's folder path.
    //

    schAssert(g_TasksFolderInfo.ptszPath != NULL);

    if (wcslen(g_TasksFolderInfo.ptszPath) + 1 + wcslen(pwszJobName) + 1
            > ARRAY_LEN(wszJobPath))
    {
        CHECK_HRESULT(SCHED_E_CANNOT_OPEN_TASK);
        return(SCHED_E_CANNOT_OPEN_TASK);
    }

    wcscpy(wszJobPath, g_TasksFolderInfo.ptszPath);
    wcscat(wszJobPath, L"\\");
    wcscat(wszJobPath, pwszJobName);

    //
    // Retrieve the job's credentials, but return only the account name.
    //

    hr = I_GetAccountInformation(wszJobPath, &jc);

    if (SUCCEEDED(hr))
    {
        ZERO_PASSWORD(jc.wszPassword);      // Not needed; NULL handled.

        if (ccBufferSize > (jc.ccAccount + 1 + jc.ccDomain))
        {
            //
            // If the job was scheduled to run in the LocalSystem account,
            // Accountname is the empty string
            //
            if (jc.wszAccount[0] == L'\0')
            {
                wszBuffer[0] = L'\0';
            }
            else
            {
                //
                // If the account was supplied as a UPN, DomainName is
                // the empty string
                //
                wcscpy(wszBuffer, jc.wszDomain);
                if (wszBuffer[0] != L'\0')
                {
                    wcscat(wszBuffer, L"\\");
                }
                wcscat(wszBuffer, jc.wszAccount);
            }
        }
        else
        {
            //
            // Should *never* occur.
            //

            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            CHECK_HRESULT(hr);
        }
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetJobInformation, aka I_GetAccountInformation
//
//  Synopsis:
//
//  Arguments:  [pwszJobPath] -- Fully qualified job path.
//                               eg: D:\NT\Tasks\MyJob.job.
//              [pjc]         --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetJobInformation(
    LPCWSTR          pwszJobPath,
    PJOB_CREDENTIALS pjc)
{
    BYTE       rgbIdentity[HASH_DATA_SIZE];
    HCRYPTPROV hCSP = NULL;
    DWORD      CredentialIndex;
    DWORD      cbSAI;
    DWORD      cbSAC;
    DWORD      cbCredential;
    BYTE *     pbCredential;
    BYTE *     pbSAI = NULL;
    BYTE *     pbSAC = NULL;
    BOOL       fIsPasswordNull = FALSE;
    HRESULT    hr;

    //
    // Obtain a provider handle to the CSP (for use with Crypto API).
    //

    hr = GetCSPHandle(&hCSP);

    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Hash the job into a unique identity.
    // It will be used for credential lookup.
    //

    hr = HashJobIdentity(hCSP, pwszJobPath, rgbIdentity);

    if (FAILED(hr))
    {
        CloseCSPHandle(hCSP);
        return(hr);
    }

    //
    // Guard SA security database access.
    //

    EnterCriticalSection(&gcsSSCritSection);

    //
    // Read SAI & SAC databases.
    //

    hr = ReadSecurityDBase(&cbSAI, &pbSAI, &cbSAC, &pbSAC);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Does this identity exist in the LSA?
    //

    hr = SAIFindIdentity(rgbIdentity,
                         cbSAI,
                         pbSAI,
                         &CredentialIndex,
                         &fIsPasswordNull);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }
    else if (hr == S_OK)                    // Found it.
    {
        //
        // Index the credential associated with the identity.
        //

        hr = SACIndexCredential(CredentialIndex,
                                cbSAC,
                                pbSAC,
                                &cbCredential,
                                &pbCredential);

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
        else if (hr == S_FALSE)
        {
            //
            // Credential not found? The SAC & SAI databases are out of sync.
            // This should *never* occur.
            //

            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
            goto ErrorExit;
        }

        //
        // Generate key & decrypt the credentials.
        //

        RC2_KEY_INFO RC2KeyInfo;

        hr = ComputeCredentialKey(hCSP, &RC2KeyInfo);

        if (SUCCEEDED(hr))
        {
            //           *** Important ***
            //
            // The encrypted credentials passed are decrypted
            // *in-place*. Therefore, SAC buffer content has been
            // compromised; plus, the decrypted data must be zeroed
            // immediately following decryption (even in a failure
            // case).
            //
            // NB : The start of the credential refers to the
            //      credential identity. Skip over this to refer
            //      to the encrypted bits.
            //

            DWORD  cbEncryptedData = cbCredential - HASH_DATA_SIZE;
            BYTE * pbEncryptedData = pbCredential + HASH_DATA_SIZE;

            hr = DecryptCredentials(RC2KeyInfo,
                                    cbEncryptedData,
                                    pbEncryptedData,
                                    pjc);

            CHECK_HRESULT(hr);
            if (SUCCEEDED(hr))
            {
                // password debug
                // LogDebug3("Got password \"%s\" for job \"%s\"%s",
                //          pjc->fIsPasswordNull ? L"(NULL)" : pjc->wszPassword,
                //          pwszJobPath,
                //          fIsPasswordNull ? L", converting to (NULL)" : L"");

                // Don't leave the plain-text password on the heap.
                //
                memset(pbEncryptedData, 0, cbEncryptedData);

                //
                // If the SAI said this job has a null password, that
                // overrides the password read from the SAC.
                //
                if (fIsPasswordNull)
                {
                    pjc->fIsPasswordNull = TRUE;
                    memset(pjc->wszPassword, 0, pjc->ccPassword * sizeof(WCHAR));
                    pjc->ccPassword = 0;
                }
            }
            // Clear key content.
            //
            memset(&RC2KeyInfo, 0, sizeof(RC2KeyInfo));
        }
    }
    else
    {
        hr = SCHED_E_ACCOUNT_INFORMATION_NOT_SET;
    }

ErrorExit:
    if (pbSAI != NULL) LocalFree(pbSAI);
    if (pbSAC != NULL) LocalFree(pbSAC);

    if (hCSP != NULL) CloseCSPHandle(hCSP);

    //
    // Log an error & rest the SA security dbases SAI & SAC
    // if corruption is detected.
    //

    if (hr == SCHED_E_ACCOUNT_DBASE_CORRUPT)
    {
        //
        // Log an error.
        //

        LogServiceError(IERR_SECURITY_DBASE_CORRUPTION, 0,
                        IDS_HELP_HINT_DBASE_CORRUPT);

        //
        // Reset SAI & SAC by writing four bytes of zeros into each.
        // Ignore the return code. No recourse if this fails.
        //

        DWORD dwZero = 0;
        WriteSecurityDBase(sizeof(dwZero), (BYTE *)&dwZero, sizeof(dwZero),
                                (BYTE *)&dwZero);
    }

    LeaveCriticalSection(&gcsSSCritSection);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   HashJobIdentity
//
//  Synopsis:
//
//  Arguments:  [hCSP]         --
//              [pwszFileName] --
//              [rgbHash]      --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC HRESULT
HashJobIdentity(
    HCRYPTPROV hCSP,
    LPCWSTR    pwszFileName,
    BYTE       rgbHash[])
{
    WCHAR                wszApplication[MAX_PATH + 1]       = L"";
    WCHAR                wszOwnerName[MAX_USERNAME + 1]     = L"";
    WCHAR                wszOwnerDomain[MAX_DOMAINNAME + 1] = L"";
    UUID                 JobID;
    FILETIME             ftCreationTime;
    PSECURITY_DESCRIPTOR pOwnerSecDescr                     = NULL;
    DWORD                cbOwnerSid;
    PSID                 pOwnerSid;
    DWORD                dwVolumeSerialNo;
    HRESULT              hr;

    hr = GetFileInformation(pwszFileName,
                            &cbOwnerSid,
                            &pOwnerSid,
                            &pOwnerSecDescr,
                            &JobID,
                            MAX_USERNAME + 1,
                            MAX_DOMAINNAME + 1,
                            MAX_PATH + 1,
                            wszOwnerName,
                            wszOwnerDomain,
                            wszApplication,
                            &ftCreationTime,
                            &dwVolumeSerialNo);

    if (SUCCEEDED(hr))
    {
        DWORD  cbHash  = HASH_DATA_SIZE;
        BYTE * pbHash  = rgbHash;

        hr = MarshalData(hCSP,
                         NULL,
                         HashAndSign,
                         &cbHash,
                         &pbHash,
                         7,
                         cbOwnerSid,
                         pOwnerSid,
                         sizeof(JobID),
                         &JobID,
                         (wcslen(wszOwnerName) + 1) * sizeof(WCHAR),
                         wszOwnerName,
                         (wcslen(wszOwnerDomain) + 1) * sizeof(WCHAR),
                         wszOwnerDomain,
                         (wcslen(wszApplication) + 1) * sizeof(WCHAR),
                         wszApplication,
                         sizeof(ftCreationTime),
                         &ftCreationTime,
                         sizeof(dwVolumeSerialNo),
                         &dwVolumeSerialNo);

        schAssert(pbHash == rgbHash);
    }

    // BUGBUG  Is pOwnerSid leaked???

    delete pOwnerSecDescr;

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GrantAccountBatchPrivilege
//
//  Synopsis:   Grant the account batch privilege.
//
//  Arguments:  [pAccountSid] -- Account set.
//
//  Arguments:  None.
//
//  Returns:    HRESULTs
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GrantAccountBatchPrivilege(PSID pAccountSid)
{
    HRESULT hr = S_OK;

    LSA_OBJECT_ATTRIBUTES ObjectAttributes = {
        sizeof(LSA_OBJECT_ATTRIBUTES),
        NULL,
        NULL,
        0L,
        NULL,
        NULL
    };
    LSA_HANDLE            hPolicy;

    NTSTATUS Status = LsaOpenPolicy(NULL,
                                    &ObjectAttributes,
                                    POLICY_CREATE_ACCOUNT,
                                    &hPolicy);
    if (Status >= 0)
    {
        LSA_UNICODE_STRING PrivilegeString = {
            sizeof(SE_BATCH_LOGON_NAME) - 2,
            sizeof(SE_BATCH_LOGON_NAME),
            SE_BATCH_LOGON_NAME,
        };

        Status = LsaAddAccountRights(hPolicy, pAccountSid, &PrivilegeString, 1);
        if (Status < 0)
        {
            ERR_OUT("LsaAddAccountRights", Status);
        }

        LsaClose(hPolicy);
    }
    else
    {
        ERR_OUT("LsaOpenPolicy", Status);
    }

    if (Status < 0)
    {
        schAssert(!"Grant Batch Privilege failed, shouldn't have");
        DWORD err = RtlNtStatusToDosError(Status);
        hr = HRESULT_FROM_WIN32(err);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   MarshalData
//
//  Synopsis:   [hCSP]            --
//              [phHash]          --
//              [MarshalFunction] --
//              [pcbSignature]    --
//              [ppbSignature]    --
//              [cArgs]           --
//              [...]             --
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
MarshalData(
    HCRYPTPROV       hCSP,
    HCRYPTHASH *     phHash,
    MARSHAL_FUNCTION MarshalFunction,
    DWORD *          pcbSignature,
    BYTE **          ppbSignature,
    DWORD            cArgs,
    ...)
{
#define COPYMEMORY(dest, src, size) { \
    CopyMemory(*dest, src, size);     \
    *(BYTE **)dest += size;           \
}

    HCRYPTHASH hHash       = NULL;
    DWORD      cbSignature = 0;
    BYTE *     pbSignature = NULL;
    HRESULT    hr          = S_OK;

    va_list pvarg;

    va_start(pvarg, cArgs);

    DWORD i, cbSize, cbData = 0;

    for (i = cArgs; i--; )
    {
        cbData += va_arg(pvarg, DWORD);
        va_arg(pvarg, BYTE *);
    }

    BYTE * pbData, * pb;

    pbData = pb = new BYTE[cbData];

    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    va_start(pvarg, cArgs);

    for (i = cArgs; i--; )
    {
        cbSize = va_arg(pvarg, DWORD);
        COPYMEMORY(&pb, va_arg(pvarg, BYTE *), cbSize);
    }

    if (MarshalFunction == Marshal)
    {
        //
        // Done. Return marshal data in the signature return args.
        //

        *pcbSignature = cbData;
        *ppbSignature = pbData;
        va_end(pvarg);
        return(S_OK);
    }

    //
    // Acquire a handle to an MD5 hashing object. MD5 is the most secure
    // hashing algorithm.
    //

    schAssert(hCSP != NULL);

#if DBG
    //
    // We must not be impersonating while calling the Crypto APIs.
    // If we are, the key data will go in the wrong hives.
    //
    HANDLE hToken;
    schAssert(!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY,           // Desired access.
                         TRUE,                  // Open as self.
                         &hToken));
#endif

    if (!CryptCreateHash(hCSP,
                         CALG_MD5,              // Use MD5 hashing.
                         0,                     // MD5 is non-keyed.
                         0,                     // New key container.
                         &hHash))               // Returned handle.
    {
        hr = _HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Hash and optionally sign the data. The hash is cached w/in the hash
    // object and returned upon signing.
    //

    if (!CryptHashData(hHash,
                       pbData,                  // Hash data.
                       cbData,                  // Hash data size.
                       0))                      // No special flags.
    {
        hr = _HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    if (MarshalFunction == HashAndSign)
    {
        //
        // First, determine necessary signature buffer size & allocate it.
        //

        if (!CryptSignHash(hHash,
                           AT_SIGNATURE,        // Signature private key.
                           NULL,                // No signature.
                           0,                   // Reserved.
                           NULL,                // NULL return buffer.
                           &cbSignature))       // Returned size.
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        //
        // Caller can supply a buffer to return the signed data only with
        // the HashAndSign option. This is an optimization to reduce the
        // number of memory allocations with known data sizes such as
        // hashed data.
        //

        if (*pcbSignature)
        {
            if (*pcbSignature >= cbSignature)
            {
                //
                // Caller supplied a buffer & the signed data will fit in it.
                //

                pbSignature = *ppbSignature;
            }
            else
            {
                //
                // Caller supplied buffer insufficient size.
                // This is a developer error only.
                //

                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                schAssert(0 && "MarshalData insufficient buffer!");
                goto ErrorExit;
            }
        }
        else
        {
            pbSignature = new BYTE[cbSignature];

            if (pbSignature == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }

        //
        // Perform the actual signing.
        //

        if (!CryptSignHash(hHash,
                           AT_SIGNATURE,        // Signature private key.
                           NULL,                // No signature.
                           0,                   // Reserved.
                           pbSignature,         // Signature buffer.
                           &cbSignature))       // Buffer size.
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        *pcbSignature = cbSignature;
        *ppbSignature = pbSignature;
    }

    if (phHash != NULL)
    {
        *phHash = hHash;
        hHash   = NULL;
    }

ErrorExit:
    delete pbData;
    if (FAILED(hr))
    {
        //
        // Caller may have supplied the signature data buffer in the
        // HashAndSign option. If so, don't delete it.
        //

        if (pbSignature != *ppbSignature)
        {
            delete pbSignature;
        }
    }
    if (hHash != NULL) CryptDestroyHash(hHash);
    va_end(pvarg);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   HashSid
//
//  Synopsis:   [hCSP]    --
//              [pSid]    --
//              [rgbHash] --
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC HRESULT
HashSid(
    HCRYPTPROV hCSP,
    PSID       pSid,
    BYTE       rgbHash[])
{
    DWORD                      rgdwSubAuthorities[SID_MAX_SUB_AUTHORITIES];
    SID_IDENTIFIER_AUTHORITY * pAuthority;

    //
    // Validate the sid passed. This is important since the win32
    // documentation for the sid-related api states the returns are
    // undefined if the functions fail.
    //

    if (!IsValidSid(pSid))
    {
        CHECK_HRESULT(_HRESULT_FROM_WIN32(GetLastError()));
        return(E_UNEXPECTED);
    }

    //
    // Fetch the sid identifier authority.
    // BUGBUG : I hate this. The doc states if these functions fail, the
    //          return value is undefined. How to determine failure?
    //

    pAuthority = GetSidIdentifierAuthority(pSid);

    //
    // Fetch all sid subauthorities. Copy them to a temporary buffer in
    // preparation for hashing.
    //

    PUCHAR pcSubAuthorities = GetSidSubAuthorityCount(pSid);

    UCHAR  cSubAuthoritiesCopied = min(*pcSubAuthorities,
                                       SID_MAX_SUB_AUTHORITIES);

    for (UCHAR i = 0; i < cSubAuthoritiesCopied; i++)
    {
        rgdwSubAuthorities[i] = *GetSidSubAuthority(pSid, i);
    }

    DWORD  cbHash = HASH_DATA_SIZE;
    BYTE * pbHash = rgbHash;

    HRESULT hr = MarshalData(hCSP,
                             NULL,
                             HashAndSign,
                             &cbHash,
                             &pbHash,
                             2,
                             sizeof(SID_IDENTIFIER_AUTHORITY),
                             pAuthority,
                             cSubAuthoritiesCopied * sizeof(DWORD),
                             rgdwSubAuthorities);

    schAssert(pbHash == rgbHash);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   InitSS
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
InitSS(void)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes = {
        sizeof(LSA_OBJECT_ATTRIBUTES),
        NULL,
        NULL,
        0L,
        NULL,
        NULL
    };
    NTSTATUS Status;
    HRESULT  hr;

    //
    // Used to guard SA security database access.
    //

    InitializeCriticalSection(&gcsSSCritSection);

    gccComputerName = sizeof(gwszComputerName) / sizeof(TCHAR);

    if (!GetComputerName(gwszComputerName, &gccComputerName))
    {
        hr = _HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // gwszComputerName will be munged.  Save an unmunged copy in
    // gpwszComputerName.
    //
    gpwszComputerName = new WCHAR[gccComputerName + 1];
    if (gpwszComputerName == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }
    wcscpy(gpwszComputerName, gwszComputerName);

    //
    // gwszComputerName is used only for credential encryption.  The
    // computer might have been renamed since the credential database was
    // created, so the credential database might have been encrypted using
    // a different computer name than the present one.  If a computer name
    // is stored in the registry, use that one rather than the present name.
    // If no name is stored in the registry, store the present one.
    //

    {
        //
        // Open the schedule agent key
        //
        HKEY hSchedKey;
        long lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0,
                                 KEY_QUERY_VALUE | KEY_SET_VALUE, &hSchedKey);
        if (lErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lErr);
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        //
        // Get the saved computer name
        //
        WCHAR wszOldName[MAX_COMPUTERNAME_LENGTH + 2];
        DWORD dwType;
        DWORD cb = sizeof(wszOldName);
        lErr = RegQueryValueEx(hSchedKey, SCH_OLDNAME_VALUE, NULL, &dwType,
                               (LPBYTE)wszOldName, &cb);

        if (lErr != ERROR_SUCCESS || dwType != REG_SZ)
        {
            schDebugOut((DEB_ERROR, "InitSS: Couldn't read OldName: err %u, "
                                    "type %u.  Writing '%ws'\n",
                         lErr, dwType, gwszComputerName));
            //
            // Write the present computer name
            //
            lErr = RegSetValueEx(hSchedKey, SCH_OLDNAME_VALUE, NULL, REG_SZ,
                                 (LPBYTE) gwszComputerName,
                                 (gccComputerName + 1) * sizeof(WCHAR));
            if (lErr != ERROR_SUCCESS)
            {
                schDebugOut((DEB_ERROR, "InitSS: Couldn't write OldName: err %u\n",
                             lErr));
            }
        }
        else if (lstrcmpi(gwszComputerName, wszOldName) != 0)
        {
            //
            // Use the stored name instead of the present name
            //
            schDebugOut((DEB_ERROR, "InitSS: Using OldName '%ws'\n", wszOldName));
            wcscpy(gwszComputerName, wszOldName);
            gccComputerName = (cb / sizeof(WCHAR)) - 1;
        }

        //
        // Close the key
        //
        RegCloseKey(hSchedKey);
    }


    LSA_HANDLE hPolicy;

    if (!(LsaOpenPolicy(NULL,
                        &ObjectAttributes,
                        POLICY_VIEW_LOCAL_INFORMATION,
                        &hPolicy) >= 0))
    {
        hr = E_UNEXPECTED;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    Status = LsaQueryInformationPolicy(hPolicy,
                                       PolicyAccountDomainInformation,
                                       (void **)&gpDomainInfo);

    LsaClose(hPolicy);

    if (!(Status >= 0))
    {
        hr = E_UNEXPECTED;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    MungeComputerName(gccComputerName);

    gpMachineSid  = gpDomainInfo->DomainSid;
    gcbMachineSid = GetLengthSid(gpDomainInfo->DomainSid);

    return(S_OK);

ErrorExit:
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitSS
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
UninitSS(void)
{
    if (gpDomainInfo != NULL)
    {
        LsaFreeMemory(gpDomainInfo);
    }

    delete gpwszComputerName;

    DeleteCriticalSection(&gcsSSCritSection);
}

//+---------------------------------------------------------------------------
//
//  Function:   MungeComputerName
//
//  Synopsis:
//
//  Arguments:  [psidUser]           --
//              [ccAccountName]      --
//              [wszAccountName]     --
//              [wszAccountNameSize] --
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC void
MungeComputerName(DWORD ccComputerName)
{
    WCHAR * pwszStart = gwszComputerName;

    while (*pwszStart) pwszStart++;

    gwszComputerName[MAX_COMPUTERNAME_LENGTH + 1] = L'\0';

    //
    // Set the character following the computername to a '+' or '-' depending
    // on the value of ccAccountName (if the 2nd bit is set).
    //

    if ((ccComputerName - 1) & 0x00000001)
    {
        gwszComputerName[MAX_COMPUTERNAME_LENGTH] = L'+';
    }
    else
    {
        gwszComputerName[MAX_COMPUTERNAME_LENGTH] = L'-';
    }

    //
    // Fill any intermediary buffer space with space characters. Note, no
    // portion of the computername is overwritten.
    //
    // NB : The astute reader will notice the subtle difference in behavior
    //      if the computername should be of maximum length. In this case,
    //      the '+' or '-' character written above will be overwritten with
    //      a space.
    //

    WCHAR * pwszEnd = &gwszComputerName[MAX_COMPUTERNAME_LENGTH - 1];

    if (pwszEnd > pwszStart)
    {
        while (pwszEnd != pwszStart)
        {
            *pwszEnd-- = L' ';
        }
    }

    *pwszStart = L' ';
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCSPHandle
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC HRESULT
GetCSPHandle(HCRYPTPROV * phCSP)
{
#if DBG
    //
    // We must not be impersonating while calling the Crypto APIs.
    // If we are, the key data will go in the wrong hives.
    //
    HANDLE hToken;
    schAssert(!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY,           // Desired access.
                         TRUE,                  // Open as self.
                         &hToken));
#endif

    HRESULT    hr;

    if (!CryptAcquireContext(phCSP,             // Returned CSP handle.
                             g_tszSrvcName,     // Default Key container.
                                                    // MSFT RSA Base Provider.
                             NULL,              // Default user provider.
                             PROV_RSA_FULL,     // Default provider type.
                             0))                // No special flags.
    {
        DWORD Status = GetLastError();

        if (Status == NTE_KEYSET_ENTRY_BAD)
        {
            //
            // Delete the keyset and try again.
            // Ignore this return code.
            //

            if (!CryptAcquireContext(phCSP,
                                     g_tszSrvcName,
                                     NULL,
                                     PROV_RSA_FULL,
                                     CRYPT_DELETEKEYSET))
            {
                ERR_OUT("CryptAcquireContext(delete)", GetLastError());
            }
        }
        else
        {
            //
            // Print the error in debug builds, but otherwise ignore it.
            //
            ERR_OUT("CryptAcquireContext(open)", Status);
        }

        //
        // Assume this is the first time this code has been run on this
        // particular machine.  Must create a new keyset & key.
        //

        if (!CryptAcquireContext(phCSP,
                                 g_tszSrvcName,
                                 NULL,
                                 PROV_RSA_FULL,
                                 CRYPT_NEWKEYSET))  // New keyset.
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return(hr);
        }

        HCRYPTKEY hKey;

        //
        // The upper 16 bits of the 3rd parm to CryptGenKey specify the key
        // size in bits.  The size of the signature from CryptSignHash will
        // be equal to the size of this key.  Since we rely on the signature
        // being a specific size, we must explicitly specify the key size.
        //
        if (!CryptGenKey(*phCSP,
                         AT_SIGNATURE,      // Digital signature.
                         (HASH_DATA_SIZE * 8) << 16,    // see above
                         &hKey ))
        {
            hr = _HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return(hr);
        }
        CryptDestroyKey(hKey);              // No further use for
                                            // the key.
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   CloseCSPHandle
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC void
CloseCSPHandle(HCRYPTPROV hCSP)
{
    CryptReleaseContext(hCSP, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   ComputeCredentialKey
//
//  Synopsis:
//
//  Arguments:  [hCSP]        --
//              [pRC2KeyInfo] --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC HRESULT
ComputeCredentialKey(HCRYPTPROV hCSP, RC2_KEY_INFO * pRC2KeyInfo)
{
    BYTE       rgbHash[HASH_DATA_SIZE];
    HCRYPTHASH hHash  = NULL;
    DWORD      cbHash = 0;
    BYTE *     pbHash = NULL;
    HRESULT    hr     = S_OK;
    DWORD      i;

    //
    // Hash misc. global data.
    //
    // NB : MarshalData actually does nothing with the 3rd & 4th arguments
    //      with the Hash option.
    //

    hr = MarshalData(hCSP,
                     &hHash,
                     Hash,
                     &cbHash,
                     &pbHash,
                     2,
                     (gccComputerName & 0x00000001 ?
                        (MAX_COMPUTERNAME_LENGTH + 2) * sizeof(WCHAR) :
                            sizeof(DWORD)),
                     (gccComputerName & 0x00000001 ?
                        (BYTE *)gwszComputerName : (BYTE *)&gdwKeyElement),
                     gcbMachineSid,
                     gpMachineSid);

    //
    // Generate the key.
    //
    // NB : In place of CryptDeriveKey, statically generate the key. This
    //      is done to work around Crypto restrictions in France.
    //
    // Old:
    //
    //     CryptDeriveKey(ghCSP, CALG_RC2, hHash, 0, &hKey);
    //
    // New:
    //

    cbHash = sizeof(rgbHash);

    if (!CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0))
    {
        hr = _HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Clear RC2KeyInfo content.
    //

    schAssert(pRC2KeyInfo != NULL);

    memset(pRC2KeyInfo, 0, sizeof(*pRC2KeyInfo));

    //
    // Set the upper eleven bytes to 0x00 because Derive key by default
    // uses 11 bytes of 0x00 salt
    //

    memset(rgbHash + 5, 0, 11);

    //
    // Use the 5 bytes (40 bits) of the hash as a key.
    //

    RC2KeyEx(pRC2KeyInfo->rgwKeyTable, rgbHash, 16, 40);

ErrorExit:
    if (hHash != NULL) CryptDestroyHash(hHash);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   EncryptCredentials
//
//  Synopsis:
//
//  Arguments:  [RC2KeyInfo]       --
//              [pwszAccount]      --
//              [pwszDomain]       --
//              [pwszPassword]     --
//              [pSid]             --
//              [pcbEncryptedData] --
//              [ppbEncryptedData] --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC HRESULT
EncryptCredentials(
    const RC2_KEY_INFO & RC2KeyInfo,
    LPCWSTR              pwszAccount,
    LPCWSTR              pwszDomain,
    LPCWSTR              pwszPassword,
    PSID                 pSid,
    DWORD *              pcbEncryptedData,
    BYTE **              ppbEncryptedData)
{
    BYTE    rgbBuf[RC2_BLOCKLEN];
    WCHAR * pwszPasswordLocal;
    DWORD   cbAccount;
    DWORD   cbDomain;
    DWORD   cbPassword;
    DWORD   cbData          = 0;
    DWORD   cbEncryptedData = 0;
    DWORD   cbPartial;
    DWORD   dwPadVal;
    BYTE *  pbData          = NULL;
    BYTE *  pbEncryptedData = NULL;
    HRESULT hr;

    *pcbEncryptedData = 0;
    *ppbEncryptedData = NULL;

    if (pwszAccount == NULL || pwszDomain == NULL)
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    if (pwszPassword == NULL)
    {
        //
        // In the SAC, a NULL password is stored the same as a "" password.
        // (The distinction is made per-job, in the SAI.)
        //
        pwszPasswordLocal = L"";
    }
    else
    {
        pwszPasswordLocal = (WCHAR *)pwszPassword;
    }

    cbAccount  = wcslen(pwszAccount) * sizeof(WCHAR);
    cbDomain   = wcslen(pwszDomain) * sizeof(WCHAR);
    cbPassword = wcslen(pwszPasswordLocal) * sizeof(WCHAR);

    hr = MarshalData(NULL,
                     NULL,
                     Marshal,
                     &cbData,
                     &pbData,
                     6,
                     sizeof(cbAccount),
                     &cbAccount,
                     cbAccount,
                     pwszAccount,
                     sizeof(cbDomain),
                     &cbDomain,
                     cbDomain,
                     pwszDomain,
                     sizeof(cbPassword),
                     &cbPassword,
                     cbPassword,
                     pwszPasswordLocal);

    if (SUCCEEDED(hr))
    {
        //
        // NB : This code exists in place of a call to CryptEncrypt to
        //      work around France's Crypto API restrictions. Since
        //      CryptEncrypt cannot be called directly, the code from
        //      the API to accomplish cypher block encryption is duplicated
        //      here.
        //

        //
        // Calculate the number of pad bytes necessary (must be a multiple)
        // of RC2_BLOCKLEN). If already a multiple of blocklen, do a full
        // block of pad.
        //

        cbPartial = (cbData % RC2_BLOCKLEN);

        dwPadVal = RC2_BLOCKLEN - cbPartial;

        cbEncryptedData = cbData + dwPadVal;

        //
        // Allocate a buffer for the encrypted data.
        //

        pbEncryptedData = new BYTE[cbEncryptedData];

        if (pbEncryptedData == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        CopyMemory(pbEncryptedData, pbData, cbData);

        if (dwPadVal)
        {
            //
            // Fill the pad with a value equal to the length of the padding,
            // so decrypt will know the length of the original data and as
            // a simple integrity check.
            //

            memset(pbEncryptedData + cbData, (INT)dwPadVal, (size_t)dwPadVal);
        }

        //
        // Perform the encryption - cypher block.
        //

        *pcbEncryptedData = cbEncryptedData;
        *ppbEncryptedData = pbEncryptedData;

        while (cbEncryptedData)
        {
            //
            // Put the plaintext into a temporary buffer, then encrypt the
            // data back into the allocated buffer.
            //

            CopyMemory(rgbBuf, pbEncryptedData, RC2_BLOCKLEN);

            CBC(RC2,
                RC2_BLOCKLEN,
                pbEncryptedData,
                rgbBuf,
                (void *)RC2KeyInfo.rgwKeyTable,
                ENCRYPT,
                (BYTE *)RC2KeyInfo.rgbIV);

            pbEncryptedData += RC2_BLOCKLEN;
            cbEncryptedData -= RC2_BLOCKLEN;
        }
    }

    pbEncryptedData = NULL;         // For delete below.

ErrorExit:
    delete pbData;
    delete pbEncryptedData;

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SkipDomainName
//
//  Synopsis:   Return the relative username if the username passed is in
//              distinguished form. eg: return 'Joe' from 'DogFood\Joe'.
//
//  Arguments:  [pwszUserName] -- User name.
//
//  Returns:    Pointer index to/into pwszUserName.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
LPWSTR
SkipDomainName(LPCWSTR pwszUserName)
{
    LPWSTR pwsz = (LPWSTR)pwszUserName;

    while (*pwsz && *pwsz != '\\')
    {
        pwsz++;
    }

    if (*pwsz == L'\\')
    {
        return(++pwsz);
    }

    return((LPWSTR)pwszUserName);
}

//+---------------------------------------------------------------------------
//
//  Function:   DecryptCredentials
//
//  Synopsis:
//
//  Arguments:  [RC2KeyInfo]      --
//              [cbEncryptedData] --
//              [pbEncryptedData] --
//              [pjc]             --
//              [fDecryptInPlace] --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC HRESULT
DecryptCredentials(
    const RC2_KEY_INFO & RC2KeyInfo,
    DWORD                cbEncryptedData,
    BYTE *               pbEncryptedData,
    PJOB_CREDENTIALS     pjc,
    BOOL                 fDecryptInPlace)
{
    BYTE    rgbBuf[RC2_BLOCKLEN];
    DWORD   cbDecryptedData = cbEncryptedData;
    BYTE *  pbDecryptedData;
    DWORD   BytePos;
    DWORD   dwPadVal;
    DWORD   i;
    DWORD   cbAccount, cbDomain, cbPassword;
    BYTE *  pbAccount, * pbDomain, * pbPassword;
    BOOL    fIsPasswordNull = FALSE;
    BYTE *  pb;
    HRESULT hr = S_OK;

    //
    // The encrypted data length *must* be a multiple of RC2_BLOCKLEN.
    //

    if (cbEncryptedData % RC2_BLOCKLEN)
    {
        CHECK_HRESULT(E_UNEXPECTED);
        return(E_UNEXPECTED);
    }

    //
    // Decrypt overwrites the encrypted data with the decrypted data.
    // If fDecryptInPlace is FALSE, allocate an additional buffer for
    // the decrypted bits, so the encrypted data buffer will not be
    // overwritten.
    //

    if (!fDecryptInPlace)
    {
        pbDecryptedData = new BYTE[cbEncryptedData];

        if (pbDecryptedData == NULL)
        {
            CHECK_HRESULT(E_OUTOFMEMORY);
            return(E_OUTOFMEMORY);
        }
        CopyMemory(pbDecryptedData, pbEncryptedData, cbEncryptedData);
    }
    else
    {
        pbDecryptedData = pbEncryptedData;
    }

    //
    // NB : This code exists in place of a call to CryptDencrypt to
    //      work around France's Crypto API restrictions. Since
    //      CryptDecrypt cannot be called directly, the code from
    //      the API to accomplish cypher block decryption is duplicated
    //      here.
    //

    for (BytePos = 0; (BytePos + RC2_BLOCKLEN) <= cbEncryptedData;
         BytePos += RC2_BLOCKLEN)
    {
        //
        // Use a temporary buffer to store the encrypted data.
        //

        CopyMemory(rgbBuf, pbDecryptedData + BytePos, RC2_BLOCKLEN);

        CBC(RC2,
            RC2_BLOCKLEN,
            pbDecryptedData + BytePos,
            rgbBuf,
            (void *)RC2KeyInfo.rgwKeyTable,
            DECRYPT,
            (BYTE *)RC2KeyInfo.rgbIV);
    }

    //
    // Verify the padding and remove the pad size from the data length.
    // NOTE: The padding is filled with a value equal to the length
    // of the padding and we are guaranteed >= 1 byte of pad.
    //
    // NB : If the pad is wrong, the user's buffer is hosed, because
    //      we've decrypted into the user's buffer -- can we re-encrypt it?
    //

    dwPadVal = (DWORD)*(pbDecryptedData + cbEncryptedData - 1);

    if (dwPadVal == 0 || dwPadVal > (DWORD) RC2_BLOCKLEN)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Make sure all the (rest of the) pad bytes are correct.
    //

    for (i = 1; i < dwPadVal; i++)
    {
        if (pbDecryptedData[cbEncryptedData - (i + 1)] != dwPadVal)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }
    }

    pb = pbDecryptedData;

    //
    // Have to do the following incantation since otherwise we'd likely
    // fault on an unaligned fetch.
    //
    // Cache account name size & position.
    //

    CopyMemory(&cbAccount, pb, sizeof(cbAccount));
    pbAccount = pb + sizeof(cbAccount);
    pb = pbAccount + cbAccount;

    if (((DWORD)(pb - pbDecryptedData) > cbDecryptedData) || // Check size.
        (cbAccount > (MAX_USERNAME * sizeof(WCHAR))))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Cache domain name size & position.
    //

    CopyMemory(&cbDomain, pb, sizeof(cbDomain));
    pbDomain = pb + sizeof(cbDomain);
    pb = pbDomain + cbDomain;

    if (((DWORD)(pb - pbDecryptedData) > cbDecryptedData) || // Check size.
        (cbDomain > (MAX_DOMAINNAME * sizeof(WCHAR))))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Cache password size & position.
    //

    CopyMemory(&cbPassword, pb, sizeof(cbPassword));
    pbPassword = pb + sizeof(cbPassword);
    // In the IE 5 release of the Task Scheduler, a NULL password was denoted
    // by a size of 0xFFFFFFFF in the SAC.  The following check lets us read
    // databases created by the IE 5 TS.
    if (cbPassword == NULL_PASSWORD_SIZE)
    {
        fIsPasswordNull = TRUE;
        cbPassword = 0;
    }
    pb = pbPassword + cbPassword;

    if (((DWORD)(pb - pbDecryptedData) > cbDecryptedData) || // Check size.
        (cbPassword > (MAX_PASSWORD * sizeof(WCHAR))))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Finally, copy the return data.
    //

    CopyMemory(pjc->wszAccount, pbAccount, cbAccount);
    *(WCHAR *)(((BYTE *)pjc->wszAccount) + cbAccount) = L'\0';
    pjc->ccAccount = cbAccount / sizeof(WCHAR);

    CopyMemory(pjc->wszDomain, pbDomain, cbDomain);
    *(WCHAR *)(((BYTE *)pjc->wszDomain) + cbDomain) = L'\0';
    pjc->ccDomain = cbDomain / sizeof(WCHAR);

    CopyMemory(pjc->wszPassword, pbPassword, cbPassword);
    *(WCHAR *)(((BYTE *)pjc->wszPassword) + cbPassword) = L'\0';
    pjc->ccPassword = cbPassword / sizeof(WCHAR);

    pjc->fIsPasswordNull = fIsPasswordNull;

ErrorExit:
    if (!fDecryptInPlace) delete pbDecryptedData;

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CredentialLookupAndAccessCheck
//
//  Synopsis:
//
//  Arguments:  [hCSP]             --
//              [pSid]             --
//              [cbSAC]            --
//              [pbSAC]            --
//              [pCredentialIndex] --
//              [rgbHashedSid]     --
//              [pcbCredential]    --
//              [ppbCredential]    --
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC HRESULT
CredentialLookupAndAccessCheck(
    HCRYPTPROV hCSP,
    PSID       pSid,
    DWORD      cbSAC,
    BYTE *     pbSAC,
    DWORD *    pCredentialIndex,
    BYTE       rgbHashedSid[],
    DWORD *    pcbCredential,
    BYTE **    ppbCredential)
{
    HRESULT hr;

    // Either pSid or rgbHashedSid must be specified.
    //
    schAssert(rgbHashedSid != NULL && (pSid != NULL || *rgbHashedSid));

    if (pSid != NULL)
    {
        if (!IsValidSid(pSid))
        {
            CHECK_HRESULT(E_UNEXPECTED);
            return(E_UNEXPECTED);
        }

        hr = HashSid(hCSP, pSid, rgbHashedSid);

        if (FAILED(hr))
        {
            return(hr);
        }
    }

    //
    // Find the credential in the SAC associated with the account sid. The
    // hashed account sid is utilized as a SAC database key.
    //

    DWORD  cbEncryptedData;
    BYTE * pbEncryptedData;

    hr = SACFindCredential(rgbHashedSid,
                           cbSAC,
                           pbSAC,
                           pCredentialIndex,
                           &cbEncryptedData,
                           &pbEncryptedData);

    if (hr == S_OK)
    {
        //
        // Found it. Does the caller have access to this credential?
        //

        BYTE * pbCredential = pbEncryptedData - HASH_DATA_SIZE;

        if (CredentialAccessCheck(hCSP, pbCredential))
        {
            // Update out ptrs.
            //
            *ppbCredential = pbCredential;
            CopyMemory(pcbCredential,
                       *ppbCredential - sizeof(*pcbCredential),
                       sizeof(*pcbCredential));
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        }
    }
    else if (hr == S_FALSE)
    {
        //
        // Didn't find the credential.
        //

        hr = SCHED_E_ACCOUNT_INFORMATION_NOT_SET;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CredentialAccessCheck
//
//  Synopsis:   Determine if the RPC client has access to the credential
//              indicated.
//
//  Arguments:  [hCSP]                 -- CSP provider handle (for use with
//                                        Crypto API).
//              [pbCredentialIdentity] -- Credential identity.
//
//  Returns:    TRUE  -- RPC client has permission to access this credential.
//              FALSE -- RPC client doesn't have credential access or an
//                       unexpected error occurred.
//
//  Notes:                  ** Important **
//
//              Thread impersonation is performed in this routine via
//              RpcImpersonateClient; therefore, it is assumed only RPC
//              threads enter it.
//
//----------------------------------------------------------------------------
STATIC BOOL
CredentialAccessCheck(
    HCRYPTPROV hCSP,
    BYTE *     pbCredentialIdentity)
{
    RPC_STATUS RpcStatus;

    //
    // Impersonate the caller.
    //

    if ((RpcStatus = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        CHECK_HRESULT(RpcStatus);
        return(FALSE);
    }

    HANDLE hToken;
    BOOL   bRet;

    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY,           // Desired access.
                         TRUE,                  // Open as self.
                         &hToken))
    {
        CHECK_HRESULT(_HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    //
    // End impersonation, but don't close the token yet.
    // (We must not be impersonating when we call HashSid, which is
    // called by MatchThreadCallerAgainstCredential.)
    //
    if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        ERR_OUT("RpcRevertToSelf", RpcStatus);
        schAssert(!"RpcRevertToSelf failed");
    }

    //
    // Does the thread caller's hashed SID match the credential identity.
    // If so, the caller's account is the same as that specified in the
    // credentials.
    //

    if (!(bRet = MatchThreadCallerAgainstCredential(hCSP,
                                                    hToken,
                                                    pbCredentialIdentity)))
    {
        //
        // Nope. Thread caller account/credential account mismatch.
        // Is the caller an administrator?
        //

        bRet = IsThreadCallerAnAdmin(hToken);
    }

    CloseHandle(hToken);

    return(bRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   MatchThreadCallerAgainstCredential
//
//  Synopsis:   Hash the user SID of the thread indicated and compare it
//              against the credential identity passed. A credential identity
//              is the hashed SID of the associated account.
//
//  Arguments:  [hCSP]                 -- CSP provider handle (for use with
//                                        Cryto API).
//              [hThreadToken]         -- Obtain the user SID from this
//                                        thread.
//              [pbCredentialIdentity] -- Matched credential identity.
//
//  Returns:    TRUE  -- Match
//              FALSE -- No match or an error occurred.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
STATIC BOOL
MatchThreadCallerAgainstCredential(
    HCRYPTPROV hCSP,
    HANDLE     hThreadToken,
    BYTE *     pbCredentialIdentity)
{
#define USER_TOKEN_STACK_BUFFER_SIZE    \
        (sizeof(TOKEN_USER) + sizeof(SID_AND_ATTRIBUTES) + MAX_SID_SIZE)

    BYTE         rgbTokenInformation[USER_TOKEN_STACK_BUFFER_SIZE];
    TOKEN_USER * pTokenUser = (TOKEN_USER *)rgbTokenInformation;
    DWORD        cbReturnLength;
    DWORD        Status     = ERROR_SUCCESS;

    if (!GetTokenInformation(hThreadToken,
                             TokenUser,
                             pTokenUser,
                             USER_TOKEN_STACK_BUFFER_SIZE,
                             &cbReturnLength))
    {
        //
        // Buffer space should have been sufficient. Check if we goofed.
        //

        schAssert(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        CHECK_HRESULT(_HRESULT_FROM_WIN32(GetLastError()));
        return(FALSE);
    }

    //
    // Hash the user's SID.
    //

    BYTE rgbHashedSid[HASH_DATA_SIZE] = { 0 };

    if (SUCCEEDED(HashSid(hCSP, pTokenUser->User.Sid, rgbHashedSid)))
    {
        if (memcmp(pbCredentialIdentity, rgbHashedSid, HASH_DATA_SIZE) == 0)
        {
            return(TRUE);
        }
        else
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED));
        }
    }

    return(FALSE);
}

//
// SAC/SAI scavenger code.
//

typedef struct _JOB_IDENTITY_SET {
    BYTE *  pbSetStart;
    DWORD   dwSetSubCount;
    BYTE ** rgpbIdentity;
} JOB_IDENTITY_SET;

//+---------------------------------------------------------------------------
//
//  Function:   ScavengeSASecurityDBase
//
//  Synopsis:   Enumerate the jobs folder and remove identities in the SAI
//              for which no current jobs hash to. Note, SAC credentials
//              are also removed if the removed identity was the last to be
//              associated with it.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      Should read of any job fail, for any reason, the scavenge
//              task is abandoned. Reason is, if the removal process was
//              to continue anyway, credentials might be removed for existent
//              jobs.
//
//              The service state is checked periodically as this could
//              potentially be a lengthy routine time-wise. Bail as soon
//              as service stop or service stop pending is detected.
//
//----------------------------------------------------------------------------
void
ScavengeSASecurityDBase(void)
{
#define EXTENSION_WILDCARD L"\\*."

    TCHAR              tszSearchPath[MAX_PATH + 1];
    BYTE               rgbIdentity[HASH_DATA_SIZE];
    WIN32_FIND_DATA    fd;
    JOB_IDENTITY_SET * rgIdentitySet = NULL;
    HRESULT            hr            = S_OK;
    HANDLE             hFileEnum;
    DWORD              dwZero        = 0;
    DWORD              i, j;
    DWORD              iConcatenation;
    DWORD              dwRet;
    DWORD              dwSetCount    = 0;
    DWORD              dwSetSubCount;
    DWORD              cbIdentitySetArraySize;
    BYTE *             pbSet;
    BOOL               fDirty        = FALSE;

    //
    // Build the enumeration search path.
    //

    lstrcpy(tszSearchPath, g_TasksFolderInfo.ptszPath);
    lstrcat(tszSearchPath, EXTENSION_WILDCARD TSZ_JOB);

    //
    // Initialize the enumeration.
    //

    if ((hFileEnum = FindFirstFile(tszSearchPath,
                                   &fd)) == INVALID_HANDLE_VALUE)
    {
        //
        // Either no jobs, or an error occurred.
        //

        dwRet = GetLastError();

        if (dwRet == ERROR_FILE_NOT_FOUND)
        {
            EnterCriticalSection(&gcsSSCritSection);

            //
            // No files found. Reset SAI & SAC by writing four bytes of
            // zeros into each.
            //

            // LogDebug1("Scavenger RESETTING database, one", 0);

            hr = WriteSecurityDBase(sizeof(dwZero), (BYTE *)&dwZero,
                                    sizeof(dwZero), (BYTE *)&dwZero);
            CHECK_HRESULT(hr);

            LeaveCriticalSection(&gcsSSCritSection);
        }
        else
        {
            CHECK_HRESULT(_HRESULT_FROM_WIN32(dwRet));
        }

        return;
    }

    DWORD      cbSAI;
    DWORD      cbSAC;
    BYTE *     pbSAI = NULL;
    BYTE *     pbSAC = NULL;
    BYTE *     pbSAIEnd;
    BYTE *     pb;
    HCRYPTPROV hCSP = NULL;

    //
    // Check if the service is stopping.
    //

    if (IsServiceStopping())
    {
        return;
    }

    EnterCriticalSection(&gcsSSCritSection);

    hr = ReadSecurityDBase(&cbSAI, &pbSAI, &cbSAC, &pbSAC);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    if (cbSAI <= SAI_HEADER_SIZE)
    {
        //
        // Database empty.
        //

        hr = S_OK;
        goto ErrorExit;
    }

    //
    // Some background first. The SAI consists of an array of arrays. The
    // first dimension represents the set of job identities per credential
    // in the SAC. SAI/SAC indices are associative in this case. The set of
    // job identities at SAI row[n] correspond to the credential at SAC
    // row[n].
    //
    // We need to construct an SAI pending deletion data structure. It will
    // consist of an array of JOB_IDENTITY_SET structures, in which each
    // structure refers to an array of pointers to job identities in the
    // SAI (literally indexing the SAI).
    //
    // Once the data structure is built and initialized, we'll enumerate the
    // jobs in the local tasks folder. For each job found, the corresponding
    // job identity pointer in the job identity set array will be set to NULL.
    // Upon completion of the enumeration, the non-NULL job identity ptr
    // entries within the job identity set array refer to non-existent jobs.
    // The job identitites these entries refer to are removed from the SAI,
    // and the associated credential in the SAC, if there are no longer
    // entries in the SAI associated with it.
    //
    // First, allocate the array.
    //

    pb = pbSAI + USN_SIZE;

    CopyMemory(&dwSetCount, pb, sizeof(dwSetCount));
    pb += sizeof(dwSetCount);

    cbIdentitySetArraySize = dwSetCount * sizeof(JOB_IDENTITY_SET);

    rgIdentitySet = (JOB_IDENTITY_SET *)LocalAlloc(LMEM_FIXED,
                                                   cbIdentitySetArraySize);

    if (rgIdentitySet == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    memset(rgIdentitySet, 0, cbIdentitySetArraySize);

    pb       = pbSAI + SAI_HEADER_SIZE;
    pbSAIEnd = pbSAI + cbSAI;

    //
    // Check if the service is stopping.
    //

    if (IsServiceStopping())
    {
        hr = S_OK;
        goto ErrorExit;
    }

    //
    // Now allocate, intialize individual identity sets.
    //

    for (i = 0; i < dwSetCount; i++)
    {
        //
        // Check boundary.
        //

        if ((pb + sizeof(dwSetSubCount)) > pbSAIEnd)
        {
            ASSERT_SECURITY_DBASE_CORRUPT();
            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
            goto ErrorExit;
        }

        CopyMemory(&dwSetSubCount, pb, sizeof(dwSetSubCount));
        pb += sizeof(dwSetSubCount);

        BYTE ** rgpbIdentity = (BYTE **)LocalAlloc(
                                            LMEM_FIXED,
                                            sizeof(BYTE *) * dwSetSubCount);

        if (rgpbIdentity == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        rgIdentitySet[i].pbSetStart    = pb;
        rgIdentitySet[i].dwSetSubCount = dwSetSubCount;
        rgIdentitySet[i].rgpbIdentity  = rgpbIdentity;

        for (j = 0; j < dwSetSubCount; j++)
        {
            rgpbIdentity[j] = pb;
            pb += HASH_DATA_SIZE;

            if (pb > pbSAIEnd)
            {
                ASSERT_SECURITY_DBASE_CORRUPT();
                hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                goto ErrorExit;
            }
        }
    }

    //
    // Check if the service is stopping.
    //

    if (IsServiceStopping())
    {
        hr = S_OK;
        goto ErrorExit;
    }

    //
    // Enumerate job objects in the task's folder directory. Set
    // corresponding job identity ptrs in the job identity set array to
    // NULL for existent jobs.
    //

    //
    // First, obtain a provider handle to the CSP (for use with Crypto API).
    //

    hr = GetCSPHandle(&hCSP);

    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    //
    // Must concatenate the filename returned from the enumeration onto
    // the folder path.
    //

    lstrcpy(tszSearchPath, g_TasksFolderInfo.ptszPath);
    iConcatenation = lstrlenW(g_TasksFolderInfo.ptszPath);
    tszSearchPath[iConcatenation++] = L'\\';

    for (;;)
    {
        //
        // Append the filename to the folder path.
        //

        tszSearchPath[iConcatenation] = L'\0';
        lstrcatW(tszSearchPath, fd.cFileName);

        //
        // Hash the job into a unique identity.
        //

        hr = HashJobIdentity(hCSP, tszSearchPath, rgbIdentity);

        if (FAILED(hr))
        {
            //
            // Must bail if the hash fails. If this is ignored, one, or more,
            // identities may be removed for existent jobs - not good.
            //
            // TBD : Log error.
            //

            goto ErrorExit;
        }

        //
        // Does an identity exist in the SAI for this job? If so, NULL out
        // the corresponding entry in the job identity set array.
        //

        DWORD  CredentialIndex;
        BYTE * pbIdentity;

        hr = SAIFindIdentity(rgbIdentity,
                             cbSAI,
                             pbSAI,
                             &CredentialIndex,
                             NULL,
                             &pbIdentity,
                             NULL,
                             &pbSet);

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            goto ErrorExit;
        }

        if (pbIdentity != NULL)
        {
            for (i = 0; i < dwSetCount; i++)
            {
                for (j = 0; j < rgIdentitySet[i].dwSetSubCount; j++)
                {
                    if (pbIdentity == rgIdentitySet[i].rgpbIdentity[j])
                    {
                        rgIdentitySet[i].rgpbIdentity[j] = NULL;
                        break;
                    }
                }
            }
        }

        if (!FindNextFile(hFileEnum, &fd))
        {
            dwRet = GetLastError();

            if (dwRet == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                hr = _HRESULT_FROM_WIN32(GetLastError());
                CHECK_HRESULT(hr);
                goto ErrorExit;
            }
        }
    }

    //
    // Check if the service is stopping.
    //

    if (IsServiceStopping())
    {
        hr = S_OK;
        goto ErrorExit;
    }

    //
    // Non-NULL entries in the identity set array refer to job identities in
    // the SAI to be removed. Mark them for removal.
    //

    for (i = 0; i < dwSetCount; i++)
    {
        if (rgIdentitySet[i].rgpbIdentity != NULL)
        {
            dwSetSubCount = rgIdentitySet[i].dwSetSubCount;

            for (j = 0; j < dwSetSubCount; j++)
            {
                if (rgIdentitySet[i].rgpbIdentity[j] != NULL)
                {
                    MARK_DELETED_ENTRY(rgIdentitySet[i].rgpbIdentity[j]);
                    rgIdentitySet[i].dwSetSubCount--;
                    fDirty = TRUE;

                    if (rgIdentitySet[i].dwSetSubCount == 0)
                    {
                        //
                        // Last identity in set. Mark associated SAC
                        // credential for removal also.
                        //

                        DWORD  cbCredential;
                        BYTE * pbCredential;

                        hr = SACIndexCredential(i,
                                                cbSAC,
                                                pbSAC,
                                                &cbCredential,
                                                &pbCredential);

                        if (hr == S_FALSE)
                        {
                            //
                            // This should *never* happen. Consider the
                            // database corrupt if so.
                            //

                            ASSERT_SECURITY_DBASE_CORRUPT();
                            hr = SCHED_E_ACCOUNT_DBASE_CORRUPT;
                            goto ErrorExit;
                        }
                        else if (FAILED(hr))
                        {
                            CHECK_HRESULT(hr);
                            goto ErrorExit;
                        }
                        else
                        {
                            MARK_DELETED_ENTRY(pbCredential);
                        }
                    }
                }
            }
        }
    }

    //
    // Check if the service is stopping.
    //

    if (IsServiceStopping())
    {
        hr = S_OK;
        goto ErrorExit;
    }

    //
    // Removed entries marked for deletion.
    //

    if (fDirty)
    {
        hr = SAICoalesceDeletedEntries(&cbSAI, &pbSAI);
        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            hr = SACCoalesceDeletedEntries(&cbSAC, &pbSAC);
            CHECK_HRESULT(hr);
        }

        if (FAILED(hr))
        {
            goto ErrorExit;
        }

        //
        // Finally, persist the changes made to the SAI & SAC.
        //

        // LogDebug1("SCAVENGER writing database", 0);

        hr = WriteSecurityDBase(cbSAI, pbSAI, cbSAC, pbSAC);
        CHECK_HRESULT(hr);
    }

ErrorExit:
    //
    // Deallocate data structures allocated above.
    //
    for (i = 0; i < dwSetCount; i++)
    {
        if (rgIdentitySet[i].rgpbIdentity != NULL)
        {
            LocalFree(rgIdentitySet[i].rgpbIdentity);
        }
    }

    if (rgIdentitySet != NULL) LocalFree(rgIdentitySet);
    if (pbSAI != NULL) LocalFree(pbSAI);
    if (pbSAC != NULL) LocalFree(pbSAC);

    if (hFileEnum != INVALID_HANDLE_VALUE) FindClose(hFileEnum);

    if (hCSP != NULL) CloseCSPHandle(hCSP);
    //
    // Log an error & rest the SA security dbases SAI & SAC if corruption
    // is detected.
    //

    if (hr == SCHED_E_ACCOUNT_DBASE_CORRUPT)
    {
        //
        // Log an error.
        //

        LogServiceError(IERR_SECURITY_DBASE_CORRUPTION, 0,
                        IDS_HELP_HINT_DBASE_CORRUPT);

        //
        // Reset SAI & SAC by writing four bytes of zeros into each.
        // Ignore the return code. No recourse if this fails.
        //

        // LogDebug1("Scavenger RESETTING database, two", 0);

        DWORD dwZero = 0;
        WriteSecurityDBase(sizeof(dwZero), (BYTE *)&dwZero, sizeof(dwZero),
                            (BYTE *)&dwZero);
    }

    LeaveCriticalSection(&gcsSSCritSection);
}


//+---------------------------------------------------------------------------
//
//  Function:   SchedUPNToAccountName
//
//  Synopsis:   Converts a UPN to an Account Name
//
//  Arguments:  lpUPN - The UPN
//              ppAccountName - Pointer to the location to create/copy the account name
//
//  Returns:    NO_ERROR - Success (ppAccountName contains the converted UPN)
//              Any other Win32 error - error at some stage of conversion
//
//----------------------------------------------------------------------------

DWORD
SchedUPNToAccountName(
    IN  LPCWSTR  lpUPN,
    OUT LPWSTR  *ppAccountName
    )
{
    DWORD               dwError;
    HANDLE              hDS;
    PDS_NAME_RESULT     pdsResult;

    schAssert(ppAccountName != NULL);

    schDebugOut((DEB_TRACE, "SchedUPNToAccountName: Converting \"%ws\"\n", lpUPN));

    //
    // Get a binding handle to the DS
    //
    dwError = DsBind(NULL, NULL, &hDS);

    if (dwError != NO_ERROR)
    {
        schDebugOut((DEB_ERROR, "SchedUPNToAccountName: DsBind failed %d\n", dwError));
        return dwError;
    }

    dwError = DsCrackNames(hDS,                     // Handle to the DS
                           DS_NAME_NO_FLAGS,        // No parsing flags
                           DS_USER_PRINCIPAL_NAME,  // We have a UPN
                           DS_NT4_ACCOUNT_NAME,     // We want Domain\User
                           1,                       // Number of names to crack
                           &lpUPN,                  // Array of name(s)
                           &pdsResult);             // Filled in by API

    if (dwError != NO_ERROR)
    {
        schDebugOut((DEB_ERROR, "SchedUPNToAccountName: DsCrackNames failed %d\n", dwError));

        DsUnBind(&hDS);
        return dwError;
    }

    schAssert(pdsResult->cItems == 1);
    schAssert(pdsResult->rItems != NULL);

    if (pdsResult->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY)
    {
        //
        // Couldn't crack the name but we got the name of
        // the domain where it is -- let's try it
        //
        DsUnBind(&hDS);

        schAssert(pdsResult->rItems[0].pDomain != NULL);

        schDebugOut((DEB_TRACE, "Retrying DsBind on domain %ws\n", pdsResult->rItems[0].pDomain));

        dwError = DsBind(NULL, pdsResult->rItems[0].pDomain, &hDS);

        //
        // Free up the structure holding the old info
        //
        DsFreeNameResult(pdsResult);

        if (dwError != NO_ERROR)
        {
            schDebugOut((DEB_ERROR, "SchedUPNToAccountName: DsBind #2 failed %d\n", dwError));
            return dwError;
        }

        dwError = DsCrackNames(hDS,                     // Handle to the DS
                               DS_NAME_NO_FLAGS,        // No parsing flags
                               DS_USER_PRINCIPAL_NAME,  // We have a UPN
                               DS_NT4_ACCOUNT_NAME,     // We want Domain\User
                               1,                       // Number of names to crack
                               &lpUPN,                  // Array of name(s)
                               &pdsResult);             // Filled in by API

        if (dwError != NO_ERROR)
        {
            schDebugOut((DEB_ERROR, "SchedUPNToAccountName: DsCrackNames #2 failed %d\n", dwError));

            DsUnBind(&hDS);
            return dwError;
        }

        schAssert(pdsResult->cItems == 1);
        schAssert(pdsResult->rItems != NULL);
    }

    if (pdsResult->rItems[0].status != DS_NAME_NO_ERROR)
    {
        schDebugOut((DEB_ERROR, "SchedUPNToAccountName: DsCrackNames failure (status %#x)\n", pdsResult->rItems[0].status));

        //
        // DS errors don't map to Win32 errors -- this is the best we can do
        //
        dwError = SCHED_E_ACCOUNT_NAME_NOT_FOUND;
    }
    else
    {
        schDebugOut((DEB_TRACE, "SchedUPNToAccountName: Got \"%ws\"\n",
                     pdsResult->rItems[0].pName));

        *ppAccountName = new WCHAR[wcslen(pdsResult->rItems[0].pName) + 1];

        if (*ppAccountName != NULL)
        {
            wcscpy(*ppAccountName, pdsResult->rItems[0].pName);
        }
        else
        {
            dwError = GetLastError();
            schDebugOut((DEB_ERROR, "SchedUPNToAccountName: LocalAlloc failed %d\n", dwError));
        }
    }

    DsUnBind(&hDS);
    DsFreeNameResult(pdsResult);
    return dwError;
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupAccountNameWrap
//
//  Synopsis:   BUGBUG  This is a workaround for bug 254102 - LookupAccountName
//              doesn't work when the DC can't be reached, even for the
//              currently logged-on user, and even though LookupAccountSid
//              does work.  Remove this function when that bug is fixed.
//
//  Arguments:  Same as LookupAccountName - but cbSid and cbReferencedDomainName
//              are assumed to be large enough, and peUse is ignored.
//
//  Returns:    Same as LookupAccountName.
//
//----------------------------------------------------------------------------
BOOL
LookupAccountNameWrap(
    LPCTSTR lpSystemName,  // address of string for system name
    LPCTSTR lpAccountName, // address of string for account name
    PSID    Sid,           // address of security identifier
    LPDWORD cbSid,         // address of size of security identifier
    LPTSTR  ReferencedDomainName,
                           // address of string for referenced domain
    LPDWORD cbReferencedDomainName,
                           // address of size of domain string
    PSID_NAME_USE peUse    // address of SID-type indicator
    )
{
    //
    // See if the account name matches the account name we cached
    //

    EnterCriticalSection(gUserLogonInfo.CritSection);

    if (gUserLogonInfo.DomainUserName != NULL &&
        lstrcmpi(gUserLogonInfo.DomainUserName, lpAccountName) == 0)
    {
        //
        // The names match.  Return the cached SID.
        //
        schDebugOut((DEB_TRACE, "Using cached SID for user \"%ws\"\n", lpAccountName));
        if (CopySid(*cbSid, Sid, gUserLogonInfo.Sid))
        {
            LeaveCriticalSection(gUserLogonInfo.CritSection);

            //
            // Copy the ReferencedDomainName from the account name
            //
            PCWCH pchSlash = wcschr(lpAccountName, L'\\');
            schAssert(pchSlash != NULL);
            DWORD  DomainLen = (DWORD)(pchSlash - lpAccountName);
            schAssert(DomainLen+1 <= *cbReferencedDomainName);
            wcsncpy(ReferencedDomainName, lpAccountName, DomainLen);
            ReferencedDomainName[DomainLen] = L'\0';

            return TRUE;
        }
        else
        {
            schAssert(0);
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    LeaveCriticalSection(gUserLogonInfo.CritSection);

    return LookupAccountName(
                lpSystemName,
                lpAccountName,
                Sid,
                cbSid,
                ReferencedDomainName,
                cbReferencedDomainName,
                peUse
                );
}


//+----------------------------------------------------------------------------
//
//  Member:     ComputeJobSignature
//
//  Synopsis:   Creates a signature for the job file
//
//  Arguments:  [pwszFileName] - name of job file
//              [pSignature] - block in which to store the signature.  Must
//                  be at least SIGNATURE_SIZE bytes long.
//
//  Returns:    HRESULT
//
//  Notes:      The job must have been saved to disk before calling this
//              function.
//
//-----------------------------------------------------------------------------
HRESULT
ComputeJobSignature(
    LPCWSTR     pwszFileName,
    LPBYTE      pbSignature
    )
{
    HCRYPTPROV  hCSP;

    HRESULT hr = GetCSPHandle(&hCSP);

    if (SUCCEEDED(hr))
    {
        hr = HashJobIdentity(hCSP, pwszFileName, pbSignature);
        CloseCSPHandle(hCSP);
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CJob::Sign
//
//  Synopsis:   Computes and sets the job's signature
//
//  Arguments:  None
//
//  Notes:      The job must have been written to disk before calling this method
//
//-----------------------------------------------------------------------------
HRESULT
CJob::Sign(
    VOID
    )
{
    BYTE rgbSignature[SIGNATURE_SIZE];
    HRESULT hr = ComputeJobSignature(m_ptszFileName, rgbSignature);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        return hr;
    }

    hr = _SetSignature(rgbSignature);

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CJob::VerifySignature
//
//  Synopsis:   Compares the job file's hash to the one stored in the file
//
//  Arguments:  None
//
//  Notes:      The job must have been written to disk before calling this method
//
//-----------------------------------------------------------------------------
BOOL
CJob::VerifySignature(
    VOID
    ) const
{
    if (m_pbSignature == NULL)
    {
        CHECK_HRESULT(SCHED_E_ACCOUNT_INFORMATION_NOT_SET);
        return FALSE;
    }

    BYTE rgbSignature[SIGNATURE_SIZE];
    HRESULT hr = ComputeJobSignature(m_ptszFileName, rgbSignature);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        return FALSE;
    }

    if (memcmp(m_pbSignature, rgbSignature, SIGNATURE_SIZE) != 0)
    {
        CHECK_HRESULT(E_ACCESSDENIED);
        return(FALSE);
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSchedule::AddAtJobWithHash
//
//  Synopsis:   create a downlevel job
//
//  Arguments:  [At]  - reference to an AT_INFO struct
//              [pID] - returns the new ID (optional, can be NULL)
//
//  Returns:    HRESULTS
//
//  Notes:      This method is not exposed to external clients, thus it is not
//              part of a public interface.
//-----------------------------------------------------------------------------
STDMETHODIMP
CSchedule::AddAtJobWithHash(const AT_INFO &At, DWORD * pID)
{
    TRACE(CSchedule, AddAtJob);
    HRESULT hr = S_OK;
    CJob *pJob;
    WCHAR wszName[MAX_PATH + 1];
    WCHAR wszID[SCH_SMBUF_LEN];

    hr = AddAtJobCommon(At, pID, &pJob, wszName, wszID);

    if (FAILED(hr))
    {
        ERR_OUT("AddAtJobWithHash: AddAtJobCommon", hr);
        return hr;
    }

    //
    // Now get a signature for the job file and add it to the job object
    //
    hr = pJob->Sign();

    if (FAILED(hr))
    {
        ERR_OUT("AddAtJobWithHash: Sign", hr);
        pJob->Release();
        return hr;
    }

    hr = pJob->SaveP(pJob->GetFileName(),
                     FALSE,
                     SAVEP_VARIABLE_LENGTH_DATA |
                        SAVEP_PRESERVE_NET_SCHEDULE);

    //
    // Free the job object.
    //
    pJob->Release();

    //
    // Return the new job's ID and increment the ID counter
    //
    if (pID != NULL)
    {
        *pID = m_dwNextID;
    }

    hr = IncrementAndSaveID();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\svc_core.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       svc_core.cxx
//
//  Contents:   job scheduler service entry point and thread launcher
//
//  History:    08-Sep-95 EricB created
//              25-Jun-99 AnirudhS  Extensive fixes to close windows in
//                  MainServiceLoop algorithms.
//              03-Mar-01 JBenton  Bug 307808 - Security Subsystem critical
//                  sections deleted too early.  Scavenger task could still
//                  be running.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "svc_core.hxx"
#include "..\inc\resource.h"
#include "..\inc\sadat.hxx"
#include "globals.hxx"
#include <netevent.h>

#include <winsvcp.h>    // SC_AUTOSTART_EVENT_NAME

#define SCAVENGER_START_WAIT_TIME (1000 * 60 * 10)      // 10 minutes in ms
#define CHANGE_WAIT         300                         // 300 milliseconds
#define MAX_CHANGE_WAITS    (30000 / CHANGE_WAIT)       // 30 sec / CHANGE_WAIT
#define FAT_FUDGE_FACTOR    (4 * FILETIMES_PER_SECOND)  // 4 seconds
#define SMALL_TIME_CHANGE   (7 * FILETIMES_PER_MINUTE)  // 7 minutes
#define UNBLOCK_ALLOWANCE   (20 * FILETIMES_PER_SECOND) // 20 seconds
#define NUM_EVENTS          5

// types

typedef enum _SVC_EVENT_STATE {
    RUN_WAIT_STATE,
    DIR_CHANGE_WAIT_STATE,
    PAUSED_STATE,
    PAUSED_DIR_CHANGE_STATE,
    SLEEP_STATE
} SVC_EVENT_STATE;

typedef enum _SVC_EVENT {
    TIME_OUT_EVENT,
    DIR_CHANGE_EVENT,
    SERVICE_CONTROL_EVENT,
    ON_IDLE_EVENT,
    IDLE_LOSS_EVENT,
    WAKEUP_TIME_EVENT
} SVC_EVENT;

BOOL  g_fUserStarted;

//+----------------------------------------------------------------------------
//
//  Function:   SchedMain
//
//  Synopsis:   Primary thread of the service
//
//  Arguments:  [pVoid] - currently not used
//
//-----------------------------------------------------------------------------
HRESULT
SchedMain(LPVOID pVoid)
{
    return g_pSched->MainServiceLoop();
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::MainServiceLoop
//
//  Synopsis:   The service primary thread main loop. Runs time and event
//              trigger jobs. Handles service controller and job directory
//              change notification events.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::MainServiceLoop(void)
{
    HANDLE  rgEvents[NUM_EVENTS] = {
                m_hServiceControlEvent, // must be first
                m_hOnIdleEvent,
                m_hChangeNotify,
                m_hIdleLossEvent,
                m_hSystemWakeupTimer    // may be NULL
    };
    DWORD   dwWait;
    HRESULT hr;
    DWORD   dwNumEvents = (m_hSystemWakeupTimer ? NUM_EVENTS : NUM_EVENTS - 1);
                                        // Number of events we'll wait for
    SVC_EVENT_STATE NextState;          // State to go into on wakeup
    SVC_EVENT_STATE CurSvcEventState;   // State we are currently in

    DWORD       dwNumChangeWaits;       // Num iterations in change wait state
    FILETIME    ftDirChangeStart;       // When dir changes started (see
                                        //    DIR_CHANGE_EVENT)

    //
    // Set the initial state.
    //
    CurSvcEventState = RUN_WAIT_STATE;
    //
    // Set the wakeup timer to the next wakeup time.
    //
    SetNextWakeupTime();
    //
    // Avoid an idle notification during service startup
    //
    ResetEvent(m_hOnIdleEvent);

#if !defined(_CHICAGO_)
    //
    // Kick up the service scavenger on service start.
    // It'll wait ~10 minutes before doing anything. Well after
    // the activity associated with service start dies down.
    // Also, it will relinquish its thread when it has completed.
    //
    RequestService(gpSAScavengerTask);
#endif // !defined(_CHICAGO_)


    //
    // Main waiting-to-run and event processing loop.
    //
    for (;;)
    {
        //
        // How long we wait depends on the state we are in.
        //
        switch (CurSvcEventState)
        {
        case RUN_WAIT_STATE:
            dwNumChangeWaits = 0;
            dwWait = GetNextRunWait();
            break;

        case DIR_CHANGE_WAIT_STATE:
            if (dwNumChangeWaits == 0)
            {
                // Save the time when dir changes started.  We use this only if
                // we get a time change while in the dir change wait state, as
                // a heuristic to see if the time change was small and can be
                // ignored.
                //
                ftDirChangeStart = GetLocalTimeAsFileTime();
            }
            dwNumChangeWaits++;
            dwWait = CHANGE_WAIT;
            break;

        case PAUSED_STATE:
            dwNumChangeWaits = 0;
            dwWait = INFINITE;
            break;

        case PAUSED_DIR_CHANGE_STATE:
            dwNumChangeWaits = 0;
            dwWait = CHANGE_WAIT;
            break;

        case SLEEP_STATE:
            dwNumChangeWaits = 0;
            dwWait = INFINITE;
            break;
        }

        //
        // Wait for the above time *or* a control event.
        //

        schDebugOut((DEB_ITRACE, "MainServiceLoop: in %s, waiting %lu ms %s\n",

                    CurSvcEventState == RUN_WAIT_STATE ? "RUN_WAIT_STATE" :
                    CurSvcEventState == DIR_CHANGE_WAIT_STATE ?
                                                    "DIR_CHANGE_WAIT_STATE" :
                    CurSvcEventState == PAUSED_STATE ? "PAUSED_STATE" :
                    CurSvcEventState == PAUSED_DIR_CHANGE_STATE ?
                                                    "PAUSED_DIR_CHANGE_STATE" :
                    CurSvcEventState == SLEEP_STATE ? "SLEEP_STATE" :
                                                    "??? -- UNKNOWN STATE --",
                    dwWait,
                    (dwWait == INFINITE) ? "(infinite)" : ""));

        DWORD dwEvent;
        FILETIME ftSavedBeginWaitList = m_ftBeginWaitList;

        //
        // If we're idling in the run wait state, take the opportunity to
        // advance the wait list begin time until after we're idle.  This is
        // functionally equivalent to waking up every minute to advance the
        // begin time.  It prevents most cases of jobs being run for times
        // prior to their submission.
        //
        if (CurSvcEventState == RUN_WAIT_STATE && dwWait > 0)
        {
            dwEvent = WaitForMultipleObjects(dwNumEvents, rgEvents, FALSE, 0);

            if (dwEvent == WAIT_TIMEOUT)
            {
                //
                // No jobs ready, no events signaled - we're idle.
                // Do the real wait.
                //
                dwEvent = WaitForMultipleObjects(dwNumEvents, rgEvents, FALSE,
                                                 dwWait);

                // Advance the wait list begin time to just before now.
                // The exception is if we get an insignificant time change, in
                // which case we will restore the original begin time.
                //
                // What this means: An 8:05:00 job will be run if:
                // (a) (if we were busy at 8:05:00) as long as it was
                //  submitted before we started running the 8:05:00 batch
                // (b) (if we weren't busy at 8:05:00) as long as we notice
                //  the dir change event by 8:05:20 (where 20 sec is
                //  UNBLOCK_ALLOWANCE).
                // But also see the file creation time check in BuildWaitList.
                //
                m_ftBeginWaitList = maxFileTime(
                    m_ftBeginWaitList,
                    FTfrom64(FTto64(GetLocalTimeAsFileTime()) - UNBLOCK_ALLOWANCE));

                schDebugOut((DEB_ITRACE, "MainServiceLoop: New list begin: %s\n",
                             CFileTimeString(m_ftBeginWaitList).sz()));
            }
        }
        else
        {
            //
            // Just do a normal wait.
            //
            dwEvent = WaitForMultipleObjects(dwNumEvents, rgEvents, FALSE, dwWait);
        }

        //
        // Determine the type of the event.
        //

        SVC_EVENT   CurSvcEvent;

        switch (dwEvent)
        {
        case WAIT_TIMEOUT:
            //
            // Wait timeout event.
            //
            CurSvcEvent = TIME_OUT_EVENT;
            break;

        case WAIT_OBJECT_0:
            //
            // Service control event.
            //
            CurSvcEvent = SERVICE_CONTROL_EVENT;
            break;

        case WAIT_OBJECT_0 + 1:
            //
            // Entered the idle state.
            //
            CurSvcEvent = ON_IDLE_EVENT;
            schDebugOut((DEB_IDLE, "Noticed idle event\n"));
            break;

        case WAIT_OBJECT_0 + 2:
            //
            // Directory Change Notification went off.
            //
            CurSvcEvent = DIR_CHANGE_EVENT;
            break;

        case WAIT_OBJECT_0 + 3:
            //
            // Left the idle state.
            //
            CurSvcEvent = IDLE_LOSS_EVENT;
            schDebugOut((DEB_IDLE, "Noticed idle loss event\n"));
            break;

        case WAIT_OBJECT_0 + 4:
            //
            // The wakeup timer is signaled.  This doesn't necessarily
            // mean that the machine woke up, only that the wakeup time
            // passed.
            //
            CurSvcEvent = WAKEUP_TIME_EVENT;
            break;

        case WAIT_FAILED:
        {
            //
            // Wait failure.
            //
            ULONG ulLastError = GetLastError();
            LogServiceError(IDS_FATAL_ERROR, ulLastError, 0);
            ERR_OUT("Main loop WaitForMultipleObjects", ulLastError);
            return HRESULT_FROM_WIN32(ulLastError);
        }
        }

SwitchStart:
        schDebugOut((DEB_ITRACE, "MainServiceLoop:  got %s\n",

                    CurSvcEvent == TIME_OUT_EVENT ? "TIME_OUT_EVENT" :
                    CurSvcEvent == SERVICE_CONTROL_EVENT ?
                                                    "SERVICE_CONTROL_EVENT" :
                    CurSvcEvent == DIR_CHANGE_EVENT ? "DIR_CHANGE_EVENT" :
                    CurSvcEvent == ON_IDLE_EVENT ? "ON_IDLE_EVENT" :
                    CurSvcEvent == IDLE_LOSS_EVENT ? "IDLE_LOSS_EVENT" :
                    CurSvcEvent == WAKEUP_TIME_EVENT ? "WAKEUP_TIME_EVENT" :
                                                    "??? -- UNKNOWN EVENT --"));

        switch (CurSvcEvent)
        {
        //=================
        case TIME_OUT_EVENT:
        //=================
            switch (CurSvcEventState)
            {
            case RUN_WAIT_STATE:

                if (GetNextRunWait() > 0)
                {
                    //
                    // There is still time to wait before the next run.
                    // This can happen if the system time is adjusted
                    // while we're in WaitForMultipleObjects and a
                    // WM_TIMECHANGE is not sent.
                    //
                    schDebugOut((DEB_ITRACE, "Time not yet elapsed, re-waiting\n"));
                    break;
                }

                //
                // Run jobs whose time has arrived.
                //
                hr = RunNextJobs();
                if (hr == S_FALSE)
                {
                    //
                    // No jobs waiting, so we must have passed the end of
                    // the wait list period.  Rebuild the wait list starting
                    // from the end of the last wait list period.
                    //
                    SystemTimeToFileTime(&m_stEndOfWaitListPeriod,
                                         &m_ftBeginWaitList);

                    hr = BuildWaitList(FALSE, FALSE, FALSE);
                    if (FAILED(hr))
                    {
                        LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
                        ERR_OUT("BuildWaitList", hr);
                        return hr;
                    }

                    //
                    // Set the wakeup timer to the next wakeup time.
                    //
                    SetNextWakeupTime();

#if !defined(_CHICAGO_)
                    //
                    // The wait has timed out and there is nothing to run.
                    // This will occur at most once a day. Take this
                    // opportunity to kick up the service scavenger to
                    // cleanup the SA security database.
                    //
                    // Note, the scavenge task will wait ~10 minutes before
                    // doing anything.
                    //
                    RequestService(gpSAScavengerTask);
#endif // !defined(_CHICAGO_)
                }
                break;

            case DIR_CHANGE_WAIT_STATE:
                //
                // Change notification timeout expired. Process the change.
                //
                hr = CheckDir();
                if (FAILED(hr))
                {
                    LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
                    ERR_OUT("SchedMain: CheckDir", hr);
                }

                //
                // Set the new state.
                //
                CurSvcEventState = RUN_WAIT_STATE;

                //
                // Go directly to the run wait state, in case it's time to run
                // some jobs.  Skip the wait, to avoid seeing the dir change
                // event again and losing the wait list we just built.
                //
                schDebugOut((DEB_ITRACE, "MainServiceLoop: Going to RUN_WAIT_STATE\n"));
                goto SwitchStart;
                break;

            case PAUSED_STATE:
                schAssert(!"Got TIME_OUT_EVENT while in PAUSED_STATE");
                break;

            case PAUSED_DIR_CHANGE_STATE:
                //
                // Change notification timeout expired. Process the change.
                //
                hr = CheckDir();
                if (FAILED(hr))
                {
                    LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
                    ERR_OUT("SchedMain: CheckDir", hr);
                }

                //
                // Now go to the paused state.
                //
                CurSvcEventState = PAUSED_STATE;
                break;

            case SLEEP_STATE:
                schAssert(!"Got TIME_OUT_EVENT while in SLEEP_STATE");
                break;
            }
            break;

        //===================
        case DIR_CHANGE_EVENT:
        //===================
            //
            // Directory Change Notification went off.
            //
            // Note that copy/create produce both a name change
            // notification and a write timestamp change notification
            // whereas a delete only produces a name change notification.
            // Thus, several sequential events can be produced for one
            // file change. Simarly, bulk copies or deletes will produce a
            // number of change notifications. We want the change
            // notifications to stop before processing them. So, when a
            // change is received, set the WaitForMultipleObjects
            // timeout to CHANGE_WAIT (currently 0.3 seconds), set the new
            // state to DIR_CHANGE_WAIT_STATE, and then go back into the
            // wait. The change notifications will not be processed until
            // CHANGE_WAIT has elapsed without receiving another change
            // event.
            //
            switch (CurSvcEventState)
            {
            case RUN_WAIT_STATE:
                //
                // Directory changes have begun.
                // Wait to see if there are more.
                //
                CurSvcEventState = DIR_CHANGE_WAIT_STATE;
                //
                // fall through
                //
            case DIR_CHANGE_WAIT_STATE:
                //
                // Another directory change notification went off.
                //
                FindNextChangeNotification(m_hChangeNotify);

                // If it's time to run a task in the existing wait list, leave
                // this state now.
                // Also, limit the amount of time spent in this state, so new
                // jobs aren't delayed indefinitely.
                // Jobs would not be skipped if we didn't do these checks, but
                // they could get delayed.
                //
                if (GetNextRunWait() == 0 || dwNumChangeWaits > MAX_CHANGE_WAITS)
                {
                    CurSvcEvent = TIME_OUT_EVENT;

                    // Skip the wait, to avoid seeing the dir change event again
                    goto SwitchStart;
                }
                break;

            case PAUSED_STATE:
                FindNextChangeNotification(m_hChangeNotify);

                //
                // A dir change, wait to see if there are more.
                //
                CurSvcEventState = PAUSED_DIR_CHANGE_STATE;
                break;

            case PAUSED_DIR_CHANGE_STATE:
                //
                // Continue waiting until the dir changes stop.
                //
                FindNextChangeNotification(m_hChangeNotify);
                break;

            case SLEEP_STATE:
                //
                // We don't wait for this event in the sleep state
                //
                schAssert(!"Got DIR_CHANGE_EVENT while in SLEEP_STATE");
                break;
            }
            break;

        //========================
        case SERVICE_CONTROL_EVENT:
        //========================
            switch(HandleControl())
            {
            case SERVICE_STOP_PENDING:
                //
                // Exit the service.
                //
                return S_OK;

            case SERVICE_PAUSED:
                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                    //
                    // Set the new state.
                    //
                    CurSvcEventState = PAUSED_STATE;
                    //
                    // Cancel the wakeup timer.  Since we won't run any
                    // jobs while paused, there is no point waking up.
                    //
                    CancelWakeup();
                    break;

                case DIR_CHANGE_WAIT_STATE:
                    //
                    // Set the wait and state.
                    //
                    CurSvcEventState = PAUSED_DIR_CHANGE_STATE;
                    //
                    // Cancel the wakeup timer.  Since we won't run any
                    // jobs while paused, there is no point waking up.
                    //
                    CancelWakeup();
                    break;

                case PAUSED_STATE:
                case PAUSED_DIR_CHANGE_STATE:
                    //
                    // Already paused, do nothing.
                    //
                    break;

                case SLEEP_STATE:
                    //
                    // Set the state that we will go into when we wake.
                    //
                    if (NextState == DIR_CHANGE_WAIT_STATE)
                    {
                        NextState = PAUSED_DIR_CHANGE_STATE;
                    }
                    else
                    {
                        NextState = PAUSED_STATE;
                    }
                    break;
                }
                break;

            case SERVICE_RUNNING:
                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                case DIR_CHANGE_WAIT_STATE:
                    //
                    // Already running, ignore.
                    //
                    break;

                case PAUSED_STATE:
                    //
                    // Resume the service. Get the next run wait and discard
                    // expired jobs.
                    //
                    DiscardExpiredJobs();
                    SetNextWakeupTime();
                    CurSvcEventState = RUN_WAIT_STATE;
                    break;

                case PAUSED_DIR_CHANGE_STATE:
                    //
                    // Resume the service. Pop expired jobs off of the stack.
                    //
                    DiscardExpiredJobs();
                    SetNextWakeupTime();
                    //
                    // Continue waiting until the dir changes stop.
                    //
                    CurSvcEventState = DIR_CHANGE_WAIT_STATE;
                    break;

                case SLEEP_STATE:
                    //
                    // Set the state that we will go into when we wake.
                    //
                    if (NextState == PAUSED_DIR_CHANGE_STATE)
                    {
                        NextState = DIR_CHANGE_WAIT_STATE;
                    }
                    else
                    {
                        NextState = RUN_WAIT_STATE;
                    }
                    break;
                }
                break;

            case SERVICE_CONTROL_USER_LOGON:

#if !defined(_CHICAGO_)  // no security on Win9x
                //
                // Get the newly logged on user's identity.
                //
                EnterCriticalSection(gUserLogonInfo.CritSection);
                GetLoggedOnUser();
                LeaveCriticalSection(gUserLogonInfo.CritSection);
#endif
                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                case DIR_CHANGE_WAIT_STATE:
                    //
                    // Run logon trigger jobs.
                    //
                    RunLogonJobs();
                    break;

                case PAUSED_STATE:
                case PAUSED_DIR_CHANGE_STATE:
                case SLEEP_STATE:
                    //
                    // Don't run logon trigger jobs.
                    //
                    break;
                }
                break;

            case SERVICE_CONTROL_TIME_CHANGED:

                if (CurSvcEventState == SLEEP_STATE)
                {
                    //
                    // We got a time-change message before the power-resume
                    // message.  Ignore it.  We will rebuild the wait list
                    // on power resume anyway.
                    //
                    break;
                }

                //
                // If the new time is close to the time for the next run,
                // assume the time change was just a minor clock correction,
                // and don't rebuild the wait list (otherwise the next run
                // could get skipped).  We need to resort to such a heuristic
                // because WM_TIMECHANGE doesn't tell how much the time
                // changed by.
                //
                {
                    FILETIME ftNow, ftSTNow;
                    GetSystemTimeAsFileTime(&ftSTNow);
                    FileTimeToLocalFileTime(&ftSTNow, &ftNow);

                    // Never let the last-dir-checked time be in the future -
                    // or we could miss some changes.  BUGBUG there is still
                    // a window here where runs could get missed (though it
                    // would need a highly improbable conjunction of events).
                    // The scenario is: 1. The system time is changed to
                    // something earlier than m_ftLastChecked.  2. A job file 
                    // is modified.  3. We notice the time change and execute
                    // the GetSystemTimeAsFileTime call above.  Then 
                    // m_ftLastChecked gets set to a time later than the file
                    // time, and the file change could go unnoticed.
                    // This window would be avoidable if WM_TIMECHANGE told us
                    // exactly what the system time was before and after the 
                    // change.
                    if (CompareFileTime(&ftSTNow, &m_ftLastChecked) < 0)
                    {
                        schDebugOut((DEB_TRACE, "Backing up dir check time to %s\n",
                                     CFileTimeString(ftSTNow).sz()));
                        m_ftLastChecked = ftSTNow;
                    }

                    FILETIME ftFirst = GetNextListTime();

                    if (absFileTimeDiff(ftFirst, ftNow) < SMALL_TIME_CHANGE)
                    {
                        m_ftBeginWaitList = ftSavedBeginWaitList;
                        schDebugOut((DEB_ITRACE, "Ignoring TIMECHANGE, too near next run;\n"
                                        "            restoring list begin to %s\n",
                                        CFileTimeString(m_ftBeginWaitList).sz()));
                        break;
                    }

                    if (absFileTimeDiff(ftSavedBeginWaitList, ftNow) < SMALL_TIME_CHANGE)
                    {
                        // Another time we can use as a heuristic.  Also avoids
                        // re-running jobs if the time was changed backward.
                        m_ftBeginWaitList = ftSavedBeginWaitList;
                        schDebugOut((DEB_ITRACE, "Ignoring TIMECHANGE, too near last run;\n"
                                        "            restoring list begin to %s\n",
                                        CFileTimeString(m_ftBeginWaitList).sz()));
                        break;
                    }

                    if (CurSvcEventState == DIR_CHANGE_WAIT_STATE)
                    {
                        // If we're waiting for dir changes to stop, use
                        // the time when they started.  (Strictly, we should
                        // use the time of the first file changed after
                        // m_ftLastChecked - but that will definitely be
                        // earlier.)
                        if (absFileTimeDiff(ftDirChangeStart, ftNow) < SMALL_TIME_CHANGE)
                        {
                            // Insignificant time change
                            m_ftBeginWaitList = ftSavedBeginWaitList;
                            schDebugOut((DEB_ITRACE, "Ignoring TIMECHANGE, too near dir change start;\n"
                                        "            restoring list begin to %s\n",
                                        CFileTimeString(m_ftBeginWaitList).sz()));
                            break;
                        }
                        else
                        {
                            // Significant time change
                            // Force ourselves out of the change wait state
                            dwNumChangeWaits = MAX_CHANGE_WAITS + 1;
                        }
                    }

                    // else

                    //
                    // The machine time has been changed, so discard the old
                    // wait list and rebuild it, starting from now.  We will
                    // intentionally skip runs scheduled before now and re-run
                    // runs scheduled after now.
                    // If we wanted to write a log entry about runs being 
                    // skipped or re-run (DCR 25519), the code would go here.
                    //
                    m_ftBeginWaitList = ftNow;
                }

                hr = BuildWaitList(FALSE, TRUE, FALSE);
                if (FAILED(hr))
                {
                    LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
                    ERR_OUT("BuildWaitList", hr);
                    return hr;
                }

                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                case DIR_CHANGE_WAIT_STATE:
                    //
                    // Set the wakeup timer to the next wakeup time.
                    //
                    SetNextWakeupTime();
                    break;

                case PAUSED_STATE:
                case PAUSED_DIR_CHANGE_STATE:
                    break;
                }
                break;

            case SERVICE_CONTROL_POWER_SUSPEND:
                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                case DIR_CHANGE_WAIT_STATE:
                case PAUSED_STATE:
                case PAUSED_DIR_CHANGE_STATE:
                    //
                    // The computer is preparing for suspended mode.
                    // Stop running jobs.
                    // Stop waiting for all events except the service
                    // control event.
                    //
                    dwNumEvents = 1;
                    NextState = CurSvcEventState;
                    CurSvcEventState = SLEEP_STATE;
                    break;

                case SLEEP_STATE:
                    schAssert(!"Got SERVICE_CONTROL_POWER_SUSPEND while in SLEEP_STATE");
                    break;
                }
                break;

            case SERVICE_CONTROL_POWER_SUSPEND_FAILED:
                if (CurSvcEventState != SLEEP_STATE)
                {
                    schAssert(!"Got POWER_SUSPEND_FAILED without POWER_SUSPEND");
                    break;
                }

                //
                // The suspend has been canceled.  Go back into the state we
                // were in before we got the suspend message, without
                // rebuilding the wait list.
                //
                dwNumEvents = (m_hSystemWakeupTimer ? NUM_EVENTS :
                                                      NUM_EVENTS - 1);
                CurSvcEventState = NextState;
                break;

            case SERVICE_CONTROL_POWER_RESUME:
                switch (CurSvcEventState)
                {
                case RUN_WAIT_STATE:
                case DIR_CHANGE_WAIT_STATE:
                case PAUSED_STATE:
                case PAUSED_DIR_CHANGE_STATE:
                    //
                    // We got a power-resume without a power-suspend.  We must
                    // be waking up from an emergency sleep.  Fall through to
                    // the wakeup code, making sure it returns us to this state.
                    //
                    NextState = CurSvcEventState;
                    //
                    // fall through
                    //
                case SLEEP_STATE:
                    //
                    // The machine is waking up from a sleep, so discard the
                    // old wait list and rebuild it.
                    // CODEWORK: Optimize this for the common case when all
                    // we need to do is discard some runs from the front of
                    // the existing list.

                    // Set the wait list's begin time to now, so we don't run
                    // jobs that were scheduled for when we were sleeping.
                    // If the wakeup time that we set has passed, build the
                    // wait list starting from that time, so that the runs we
                    // woke up for are included.
                    //
                    m_ftBeginWaitList =
                        minFileTime(GetLocalTimeAsFileTime(), m_ftLastWakeupSet);

                    hr = BuildWaitList(FALSE, TRUE, FALSE);
                    if (FAILED(hr))
                    {
                        LogServiceError(IDS_FATAL_ERROR, (DWORD)hr, 0);
                        ERR_OUT("BuildWaitList", hr);
                        return hr;
                    }

                    //
                    // Go back into the state that we were in before sleeping.
                    // Resume waiting on the other events.
                    //
                    dwNumEvents = (m_hSystemWakeupTimer ? NUM_EVENTS :
                                                          NUM_EVENTS - 1);
                    CurSvcEventState = NextState;
                    switch (NextState)
                    {
                    case RUN_WAIT_STATE:
                    case DIR_CHANGE_WAIT_STATE:
                        SetNextWakeupTime();
                        SetNextIdleNotification(m_IdleList.GetFirstWait());
                        break;

                    case PAUSED_STATE:
                    case PAUSED_DIR_CHANGE_STATE:
                        break;
                    }
                    break;
                }
                break;
            }
            break;

        //================
        case ON_IDLE_EVENT:
        //================
            switch (CurSvcEventState)
            {
            case RUN_WAIT_STATE:
            case DIR_CHANGE_WAIT_STATE:
                //
                // Now in the idle state, run jobs with idle triggers.
                //
                RunIdleJobs();
                break;

            case PAUSED_STATE:
            case PAUSED_DIR_CHANGE_STATE:
                //
                // Do nothing.
                //
                break;

            case SLEEP_STATE:
                //
                // Got an ON_IDLE event while the machine is either going
                // to sleep or waking up from a sleep.  In either case, we
                // don't want to run idle-triggered jobs now.
                // Note, we'll request another idle notification when we
                // wake.
                //
                break;
            }
            break;

        //==================
        case IDLE_LOSS_EVENT:
        //==================
            switch (CurSvcEventState)
            {
            case RUN_WAIT_STATE:
            case DIR_CHANGE_WAIT_STATE:
                //
                // Left the idle state, note that we've started no idle jobs
                // in the current idle period.
                //
                m_IdleList.MarkNoneStarted();

                //
                // Request the next idle notification.
                //
                SetNextIdleNotification(m_IdleList.GetFirstWait());
                break;

            case PAUSED_STATE:
            case PAUSED_DIR_CHANGE_STATE:
            case SLEEP_STATE:
                //
                // Left the idle state, note that we've started no idle jobs
                // in the current idle period.
                // Don't request more idle notifications.
                //
                m_IdleList.MarkNoneStarted();
                break;
            }
            break;

        //====================
        case WAKEUP_TIME_EVENT:
        //====================
            switch (CurSvcEventState)
            {
            case RUN_WAIT_STATE:
            case DIR_CHANGE_WAIT_STATE:
                //
                // Set the wakeup timer to the next wakeup time.
                //
                SetNextWakeupTime();
                break;

            case PAUSED_STATE:
            case PAUSED_DIR_CHANGE_STATE:
                //
                // (We could get here if the timer event was signaled
                // before we canceled it.)
                // We won't run any jobs while the service is paused, so
                // don't bother setting the wakeup timer until we leave
                // the paused state.
                //
                break;

            case SLEEP_STATE:
                //
                // (When the system wakes up due to a wakeup timer, we could
                // get this event before the POWER_RESUME event)
                // Remain in the sleep state until we get the POWER_RESUME event.
                //
                break;
            }
            break;
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::CheckDir
//
//  Synopsis:   Checks the jobs directory for changes.
//              Runs jobs that are marked to run now, kills jobs that are
//              marked to be killed.  If jobs have been changed since the
//              last time the directory was checked, and those jobs do not
//              have JOB_I_FLAG_NO_RUN_PROP_CHANGE set, rebuilds the wait
//              list by calling BuildWaitList().
//
//  Arguments:  None.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::CheckDir()
{
    TRACE(CSchedWorker, CheckDir);
    HRESULT hr = S_OK;
    DWORD dwRet;
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    FILETIME ftChecked;

    WORD cJobs = 0;

    hFind = FindFirstFile(m_ptszSearchPath, &fd);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwRet = GetLastError();
        if (dwRet == ERROR_FILE_NOT_FOUND)
        {   // no job files.
            m_WaitList.FreeList();
            m_cJobs = 0;
            return S_OK;
        }
        else
        {
            return HRESULT_FROM_WIN32(dwRet);
        }
    }

    BOOL fRebuildWaitList = FALSE;
    CJob * pJob = NULL;

    CRunList * pRunNowList = new CRunList;
    if (pRunNowList == NULL)
    {
        ERR_OUT("CheckDir run-now list allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    //
    // Get the current time which will be saved after all files are checked.
    //
    GetSystemTimeAsFileTime(&ftChecked);

    do
    {
        //
        // Check if the service is shutting down. We check the event rather
        // than simply checking GetCurrentServiceState because this method is
        // called by the main loop which won't be able to react to the shut
        // down event while in this method.
        //

        DWORD dwWaitResult = WaitForSingleObject(m_hServiceControlEvent, 0);

        if (dwWaitResult == WAIT_OBJECT_0)
        {
            //
            // Reset the event so that the main loop will react properly.
            //
            EnterCriticalSection(&m_SvcCriticalSection);
            if (!SetEvent(m_hServiceControlEvent))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("CheckDir: SetEvent", hr);
                //
                // If this call fails, we are in a heap of trouble, so it
                // really doesn't matter what we do. So, continue.
                //
            }
            LeaveCriticalSection(&m_SvcCriticalSection);

            if (GetCurrentServiceState() == SERVICE_STOP_PENDING)
            {
                DBG_OUT("CheckDir: Service shutting down");
                //
                // The service is shutting down.
                // Free any job info objects for jobs not already launched.
                //
                delete pRunNowList;
                return S_OK;
            }
        }

        cJobs++;

        schDebugOut((DEB_USER2, "CheckDir: %s " FMT_TSTR "\n",
                     CFileTimeString(fd.ftLastWriteTime).sz(), fd.cFileName));

        if (CompareFileTime(&fd.ftLastWriteTime, &m_ftLastChecked) > 0)
        {
            //
            // Job file changed since last check. See if Run or Abort bits
            // are set.
            //
            hr = m_pSch->ActivateJob(fd.cFileName, &pJob, FALSE);
            if (FAILED(hr))
            {
                schDebugOut((DEB_ERROR,"CSchedWorker::CheckDir job load for "
                                    FMT_TSTR " failed, %#lx\n",
                                    fd.cFileName, hr));
                hr = S_OK;
                goto NextJob;
            }

#if DBG
            {
                DWORD dw;
                pJob->GetAllFlags(&dw);
                schDebugOut((DEB_USER2,
                             "CheckDir: flags 0x%08x, " FMT_TSTR " (%s %s %s)\n",
                             dw,
                             fd.cFileName,
                             dw & JOB_I_FLAG_RUN_NOW            ? "RUN_NOW" : "",
                             dw & JOB_I_FLAG_ABORT_NOW          ? "ABORT_NOW" : "",
                             dw & JOB_I_FLAG_NO_RUN_PROP_CHANGE ? "NO_RUN_PROP_CHANGE" : ""
                             ));
            }
#endif  // DBG

            if (pJob->IsFlagSet(JOB_I_FLAG_RUN_NOW))
            {
                //
                // Add the job to the run now list.
                //
                CRun * pNewRun = new CRun(pJob->m_dwMaxRunTime,
                                          pJob->GetUserFlags(),
                                          MAX_FILETIME,
                                          FALSE);
                if (!pNewRun)
                {
                    hr = E_OUTOFMEMORY;
                    ERR_OUT("CSchedWorker::CheckDir new CRun", hr);
                    break;
                }

                // Complete job info object initialization.
                //
                hr = pNewRun->Initialize(fd.cFileName);

                if (FAILED(hr))
                {
                    ERR_OUT("CSchedWorker::CheckDir, Initialize", hr);
                    break;
                }

                pRunNowList->Add(pNewRun);
            }
            else if (pJob->IsFlagSet(JOB_I_FLAG_ABORT_NOW))
            {
                //
                // Find the processor that is running this job, and kill
                // the job
                //

                CJobProcessor * pjp;
                for (pjp = gpJobProcessorMgr->GetFirstProcessor();
                            pjp != NULL; )
                {
                    pjp->KillJob(fd.cFileName);
                    CJobProcessor * pjpNext = pjp->Next();
                    pjp->Release();
                    pjp = pjpNext;
                }
            }
            else if (!pJob->IsFlagSet(JOB_I_FLAG_NO_RUN_PROP_CHANGE))
            {
                //
                // Timestamp change was due to a trigger update or by
                // setting an app name when there hadn't been one.
                // Thus, rebuild wait list.
                //
                fRebuildWaitList = TRUE;
            }
        }

NextJob:

        if (!FindNextFile(hFind, &fd))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(dwRet);
                ERR_OUT("CSchedWorker::CheckDir FindNextFile", hr);
                break;
            }
        }
    } while (TRUE);

    FindClose(hFind);

    if (pJob)
    {
        pJob->Release();
    }

    if (FAILED(hr))
    {
        delete pRunNowList;
        return hr;
    }

    //
    // Save the time now that the enum is done.
    //
    m_ftLastChecked = ftChecked;
    //
    // Account for rounding down to the nearest even second done by FAT file
    // systems.
    //
    ULARGE_INTEGER ul;
    ul.LowPart  = m_ftLastChecked.dwLowDateTime;
    ul.HighPart = m_ftLastChecked.dwHighDateTime;
    ul.QuadPart -= FAT_FUDGE_FACTOR;
    m_ftLastChecked.dwLowDateTime  = ul.LowPart;
    m_ftLastChecked.dwHighDateTime = ul.HighPart;
    schDebugOut((DEB_USER2, "CheckDir: last checked %s\n",
                 CFileTimeString(m_ftLastChecked).sz()));

    //
    // If count changed, set fRebuildWaitList to TRUE and save new count.
    //
    if (m_cJobs != cJobs)
    {
        fRebuildWaitList = TRUE;
        m_cJobs = cJobs;
    }

    //
    // If jobs to run, run them now.
    //
    if (!pRunNowList->GetFirstJob()->IsNull())
    {
        hr = RunJobs(pRunNowList);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // If jobs have changed, rebuild the wait list.
    //
    if (fRebuildWaitList)
    {
        hr = BuildWaitList(FALSE, FALSE, FALSE);
        if (FAILED(hr))
        {
            return hr;
        }

        //
        // Set the wakeup timer to the next wakeup time.
        //
        SetNextWakeupTime();
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::RunJobs
//
//  Synopsis:   Run the jobs passed in the list.
//
//  Arguments:  [pJobList] - an object containing a linked list of CRun objects.
//
//  Returns:    hresults
//
//-----------------------------------------------------------------------------
HRESULT
CSchedWorker::RunJobs(CRunList * pJobList)
{
    TRACE(CSchedWorker, RunJobs);
    if (!pJobList)
    {
        return E_INVALIDARG;
    }
    HRESULT hr = S_OK;
    BOOL fNothingRan = TRUE;
    BOOL fNeedIdleLossNotify = FALSE;
    BOOL fKeptAwake = FALSE;    // Whether we called WrapSetThreadExec(TRUE)
    BOOL fLaunchSucceeded;
    DWORD dwErrMsgID;

    CRun * pCurRun = pJobList->GetFirstJob();

    //
    // I'm being paranoid here.
    //
    if (pCurRun->IsNull())
    {
        return E_INVALIDARG;
    }

    CJob * pJob = NULL;

    //
    // Run all of the jobs in the list.
    //
    do
    {
        //
        // Check if the service is shutting down. The event is checked rather
        // than simply checking GetCurrentServiceStatus because this method is
        // called synchronously from the main event loop. Thus, the main
        // event loop would not be able to react to a shutdown event while
        // we are processing in this method.
        //

        DWORD dwWaitResult = WaitForSingleObject(m_hServiceControlEvent, 0);

        if (dwWaitResult == WAIT_OBJECT_0)
        {
            //
            // Reset the event so that the main loop will react properly.
            //
            EnterCriticalSection(&m_SvcCriticalSection);
            if (!SetEvent(m_hServiceControlEvent))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("RunJobs: SetEvent", hr);
                //
                // If this call fails, we are in a heap of trouble, so it
                // really doesn't matter what we do. So, continue.
                //
            }
            LeaveCriticalSection(&m_SvcCriticalSection);

            if (GetCurrentServiceState() == SERVICE_STOP_PENDING)
            {
                DBG_OUT("RunJobs: Service shutting down");
                //
                // The service is shutting down.
                // Free any job info objects for jobs not already launched.
                //
                CRun * pRun;
                while (!pCurRun->IsNull())
                {
                    pRun = pCurRun;
                    pCurRun = pRun->Next();
                    pRun->UnLink();
                    delete pRun;
                }

                if (fKeptAwake)
                {
                    WrapSetThreadExecutionState(FALSE, "RunJobs - service shutdown");
                }

                return S_OK;
            }
        }

        FILETIME ftRun = GetLocalTimeAsFileTime();

        SYSTEMTIME stRun;
        FileTimeToSystemTime(&ftRun, &stRun);

        //
        // Instantiate the job to get its run properties.
        //

        hr = ActivateWithRetry(pCurRun->GetName(), &pJob, TRUE);
        if (FAILED(hr))
        {
            ERR_OUT("RunJobs Activate", hr);
            if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) &&
                hr != HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
            {
                //
                // Something other than file-not-found or sharing violation
                // represents a catastrophic error.
                //
                break;
            }
        }
        //
        // Don't attempt to run if no command or file can't be opened.
        //
        if (pJob->m_pwszApplicationName == NULL ||
            hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
            hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
        {
            CRun * pRun = pCurRun;
            pCurRun = pRun->Next();
            pRun->UnLink();
            delete pRun;
            ERR_OUT("RunJobs: can't open job or app name missing", 0);
            continue;
        }

        //
        // Don't attempt to run if already running.
        //
        pJob->GetStatus(&hr);
        if (hr == SCHED_S_TASK_RUNNING)
        {
            CRun * pRun = pCurRun;
            pCurRun = pRun->Next();
            pRun->UnLink();
            delete pRun;
            ERR_OUT("RunJobs: job already running", 0);

            //
            // Clear the RUN_NOW flag on the job file - otherwise, it never
            // gets cleared, and other flags like the abort flag never get
            // noticed.
            //
            if (pJob->IsFlagSet(JOB_I_FLAG_RUN_NOW))
            {
                pJob->ClearFlag(JOB_I_FLAG_RUN_NOW);

                hr = SaveWithRetry(pJob, SAVEP_PRESERVE_NET_SCHEDULE);

                if (FAILED(hr))
                {
                    ERR_OUT("RunJobs, Saving run-now", hr);
                }
            }
            continue;
        }

        //
        // pCurRun->m_dwMaxRunTime is a time period starting now.
        // Convert it to an absolute time in pRun->m_ftKill.
        //
        pCurRun->AdjustKillTimeByMaxRunTime(ftRun);

        //
        // Isolate the executable name for logging purposes.
        //

        TCHAR tszExeName[MAX_PATH + 1];

        GetExeNameFromCmdLine(pJob->GetCommand(), MAX_PATH + 1, tszExeName);

        //
        // JOB_I_FLAG_RUN_NOW tasks run regardless of the battery or idle
        // flags, so check those flags if JOB_I_FLAG_RUN_NOW is not set.
        //
        if (!pJob->IsFlagSet(JOB_I_FLAG_RUN_NOW) &&
            pJob->IsFlagSet(TASK_FLAG_DONT_START_IF_ON_BATTERIES) &&
            g_fOnBattery)
        {
            //
            // The task is set to not run when on batteries, and we
            // are on batteries now, so log the reason for not running.
            //
            LogTaskError(pCurRun->GetName(),
                         tszExeName,
                         IDS_LOG_SEVERITY_WARNING,
                         IDS_LOG_JOB_WARNING_ON_BATTERIES,
                         NULL);

            //
            // Remove the job element from the list.
            //
            CRun * pRun = pCurRun;
            pCurRun = pRun->Next();
            pRun->UnLink();
            delete pRun;

            continue;
        }

        //
        // If the job has TASK_FLAG_SYSTEM_REQUIRED, make sure the system
        // doesn't go to sleep between the time it's launched and the time
        // we call SubmitJobs().
        //
        if (pJob->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED) && !fKeptAwake)
        {
            WrapSetThreadExecutionState(TRUE, "(RunJobs - launching task)");
            fKeptAwake = TRUE;
        }

        HRESULT hrRet;

        //
        // Launch job.
        //

#if defined(_CHICAGO_)

        hr = RunWin95Job(pJob, pCurRun, &hrRet, &dwErrMsgID);

#else   // defined(_CHICAGO_)

        hr = RunNTJob(pJob, pCurRun, &hrRet, &dwErrMsgID);

#endif   // defined(_CHICAGO_)

        if (FAILED(hr))
        {
            //
            // Fatal task scheduler error, exit the loop.
            //
            break;
        }

        if (hr == S_FALSE)
        {
            //
            // Job failed to launch, but not a fatal task scheduler error.
            //
            fLaunchSucceeded = FALSE;

            //
            // An hrRet of S_FALSE indicates to skip error logging.
            //
            if (hrRet == S_FALSE)
            {
                goto WriteLog;
            }
        }
        else
        {
            fLaunchSucceeded = TRUE;
        }

        //
        // Update the job object with the current status. Updates to the
        // running instance count are guarded by the critical section here,
        // where it is incremented, and in PostJobProcessing, where it is
        // decremented.
        // We have to read the variable-length data because if the job
        // succeeds, we have to write the variable-length data (see the
        // comment on this below).
        //

        EnterCriticalSection(&m_SvcCriticalSection);

        hr = ActivateWithRetry(pCurRun->GetName(), &pJob, TRUE);
        if (FAILED(hr))
        {
            ERR_OUT("RunJobs 2nd Activate", hr);
            //
            // We are in deep stink if the job can't be activated. The only
            // workable cause would be if the job object was deleted sometime
            // between the activation at the top of this function and here.
            // If some 3rd party app opened the job object in exclusive mode,
            // then there is nothing we can do.
            //
            LeaveCriticalSection(&m_SvcCriticalSection);
            goto WriteLog;
        }

        if (fLaunchSucceeded)
        {
            pJob->ClearFlag(JOB_I_FLAG_LAST_LAUNCH_FAILED);

            pJob->SetStartError(S_OK);

            pJob->m_stMostRecentRunTime = stRun;

            if (pCurRun->IsFlagSet(RUN_STATUS_RUNNING))
            {
                pJob->m_cRunningInstances++;

                schDebugOut((DEB_ITRACE, "RunJobs: incremented running instance "
                             "count (%d after increment)\n",
                             pJob->m_cRunningInstances));

                pJob->UpdateJobState(TRUE);
            }
            else
            {
                //
                // This happens if we launched the job in a way that didn't
                // give us a handle to wait on for job completion.  We have
                // to set the job state to not running.
                //
                pJob->UpdateJobState(FALSE);
            }
        }
        else
        {
            pJob->SetFlag(JOB_I_FLAG_LAST_LAUNCH_FAILED);

            pJob->SetStartError(hrRet);
        }

        pJob->ClearFlag(JOB_I_FLAG_RUN_NOW | JOB_I_FLAG_MISSED);
        pJob->SetFlag(JOB_I_FLAG_NO_RUN_PROP_CHANGE);

        //
        // Write the updated status to the job object.
        // If !fLaunchSucceeded, write flags without touching running instance
        // count.
        // We have to write the variable-length data solely to write the
        // StartError.
        //

        if (fLaunchSucceeded)
        {
            hr = SaveWithRetry(pJob,
                               SAVEP_PRESERVE_NET_SCHEDULE |
                                    SAVEP_VARIABLE_LENGTH_DATA |
                                    SAVEP_RUNNING_INSTANCE_COUNT);
        }
        else
        {
            hr = SaveWithRetry(pJob, SAVEP_PRESERVE_NET_SCHEDULE |
                                     SAVEP_VARIABLE_LENGTH_DATA);
        }

        if (FAILED(hr))
        {
            ERR_OUT("RunJobs, Saving run-state", hr);
        }

        LeaveCriticalSection(&m_SvcCriticalSection);

WriteLog:
        if (fLaunchSucceeded)
        {
            // Log job start.
            //

            LogTaskStatus(pCurRun->GetName(),
                          tszExeName,
                          pCurRun->IsFlagSet(RUN_STATUS_RUNNING) ?
                            IDS_LOG_JOB_STATUS_STARTED :
                            IDS_LOG_JOB_STATUS_STARTED_NO_STOP);

            fNothingRan = FALSE;

            if (pJob->IsFlagSet(TASK_FLAG_KILL_ON_IDLE_END))
            {
                fNeedIdleLossNotify = TRUE;
            }
        }
        else
        {
            if (hrRet != S_FALSE)
            {
                // Log start error. The failure code is recorded in the
                // scheduler log.
                //

                DWORD dwHelpHint;

                if (dwErrMsgID == IDS_LOG_JOB_ERROR_FAILED_START)
                {
                    if (hrRet == HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES))
                    {
                        // Per bug
                        //    54843 : Jobs not run due to system resource
                        //            shortage give wrong error
                        //
                        dwHelpHint = IDS_HELP_HINT_CLOSE_APPS;
                    }
                    else
                    {
                        dwHelpHint = IDS_HELP_HINT_BROWSE;
                    }
                }
                else if (dwErrMsgID == IDS_FILE_ACCESS_DENIED)
                {
                    dwHelpHint = IDS_FILE_ACCESS_DENIED_HINT;
                }
                else if (dwErrMsgID != IDS_FAILED_NS_ACCOUNT_RETRIEVAL &&
                         dwErrMsgID != IDS_FAILED_ACCOUNT_RETRIEVAL    &&
                         dwErrMsgID != IDS_NS_ACCOUNT_LOGON_FAILED)
                {
                    dwHelpHint = IDS_HELP_HINT_LOGON;
                }
                else
                {
                    dwHelpHint = 0;
                }

                LogTaskError(pCurRun->GetName(),
                             tszExeName,
                             IDS_LOG_SEVERITY_ERROR,
                             dwErrMsgID,
                             NULL,
                             hrRet,
                             dwHelpHint);

#if !defined(_CHICAGO_)
               //
               // Check if this is an AT job and log it to the
               // event log to maintain NT4 compatibility
               //

               if (pJob->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE))
               {
                  LPWSTR StringArray[2];
                  WCHAR szNumberString[24];

                  StringArray[0] = pCurRun->GetName();
                  // need space for the numeric coversion + the %% symbols
                  wcscpy(szNumberString, L"%%");
                  _ultow(hrRet, szNumberString + 2, 10);
                  StringArray[1] = szNumberString;
                  // EVENT_COMMAND_START_FAILED -
                  //  The %1 command failed to start due to the following error: %2
                  if (! ReportEvent(g_hAtEventSource,     // handle to source
                       EVENTLOG_ERROR_TYPE,            // event type to log
                       0,                              // category
                       EVENT_COMMAND_START_FAILED,     // EventID
                       NULL,                           // User SID
                       2,                              // Number of strings
                       0,                              // raw data length
                       (LPCWSTR *)StringArray,         // Strings for substitution
                       NULL))                          // raw data pointer
                  {
                        // Not fatal, but why did we fail to report the job error?
                        ERR_OUT("Failed to report the access denied event", GetLastError());
                  }
               }

#endif
            }
        }

        //
        // Move to the next job in the list.
        //
        CRun * pRun = pCurRun;
        pCurRun = pRun->Next();

        if (!(fLaunchSucceeded && pRun->IsFlagSet(RUN_STATUS_RUNNING)))
        {
            //
            // Remove pCurRun from the list and dispose of it.
            //
            pRun->UnLink();
            delete pRun;
        }
    } while (!pCurRun->IsNull());

    if (pJob)
    {
        pJob->Release();
    }

    if (FAILED(hr))
    {
        fNothingRan = pJobList->GetFirstJob()->IsNull();
        //
        // Free any job info objects for jobs not already launched.
        //
        CRun * pRun;
        while (!pCurRun->IsNull())
        {
            pRun = pCurRun;
            pCurRun = pRun->Next();
            pRun->UnLink();
            delete pRun;
        }
    }
    if (fNothingRan)
    {
        delete pJobList;
        if (fKeptAwake)
        {
            WrapSetThreadExecutionState(FALSE, "(RunJobs - nothing ran)");
        }
        return hr;
    }

    CJobProcessor * pjpNext, * pjp = gpJobProcessorMgr->GetFirstProcessor();

    while (!pJobList->GetFirstJob()->IsNull() && SUCCEEDED(hr) &&
           hr != S_FALSE)
    {
        //
        // Construct another processor, if necessary.
        //

        if (pjp == NULL)
        {
            hr = gpJobProcessorMgr->NewProcessor(&pjp);

            if (hr == S_FALSE)
            {
                //
                // The service is stopping. Shut down the processor.
                //

                pjp->Shutdown();
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }
        }

        if (!ResetEvent(m_hMiscBlockEvent))
        {
            ERR_OUT("ResetEvent", GetLastError());
        }

        hr = pjp->SubmitJobs(pJobList);

        if (hr == S_SCHED_JOBS_ACCEPTED)
        {
            //
            // Wait for the processor thread to notice the jobs and call
            // SetThreadExecutionState if necessary.  If we didn't wait here,
            // we could return and call SetThreadExecutionState(ES_CONTINUOUS)
            // and the system could go to sleep even though a SYSTEM_REQUIRED
            // task had been started.
            //
            WaitForSingleObject(m_hMiscBlockEvent, INFINITE);
        }

        if (hr == S_FALSE)
        {
            //
            // The service is stopping. Shut down the processor.
            //

            pjp->Shutdown();
        }

        pjpNext = pjp->Next();
        pjp->Release();
        pjp = pjpNext;
    }

    if (fKeptAwake)
    {
        WrapSetThreadExecutionState(FALSE, "(RunJobs - returning)");
    }

    if (pjp != NULL)
    {
        pjp->Release();
    }

    if (fNeedIdleLossNotify)
    {
        //
        // Some of the jobs started had KILL_ON_IDLE_END set, so request
        // loss-of-idle notification.
        //
        SetIdleLossNotification();
    }

    delete pJobList;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSchedWorker::DiscardExpiredJobs
//
//  Synopsis:   Get the next run wait and pop expired jobs off of the stack.
//
//-----------------------------------------------------------------------------
void
CSchedWorker::DiscardExpiredJobs()
{
    TRACE(CSchedWorker, DiscardExpiredJobs);
    // CODEWORK  Make this more efficient by not calling GetNextRunWait.

    while (!m_WaitList.IsEmpty() && GetNextRunWait() == 0)
    {
        // The job at the top of the list has expired.
        //
        CRun * pRun = m_WaitList.Pop();
        if (pRun)
        {
            schDebugOut((DEB_ITRACE, "The run time for %S has elapsed!\n",
                         pRun->GetName()));
            delete pRun;
        }
    }

    // Don't back up past the present time.
    m_ftBeginWaitList = GetLocalTimeAsFileTime();
}

//+----------------------------------------------------------------------------
//
//  Function:   SchInit
//
//  Synopsis:   Initializes the schedule service
//
//  Returns:    HRESULTS/Win32 error codes
//
//-----------------------------------------------------------------------------
HRESULT
SchInit(void)
{
    HRESULT hr;
    HANDLE  hEvent;

    //
    // Initialize the folder path and name extension globals.
    //

    hr = InitGlobals();

    if (FAILED(hr))
    {
        ERR_OUT("InitGlobals", hr);
        return hr;
    }

    //
    // Allocate the Thread Local Storage slot that holds the "keep machine
    // awake" ref count for each thread
    //
    g_WakeCountSlot = TlsAlloc();
    if (g_WakeCountSlot == 0xFFFFFFFF)
    {
        ERR_OUT("TlsAlloc for WakeCountSlot", GetLastError());
        schAssert(!"TlsAlloc for WakeCountSlot failed");
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // Initialize this thread's keep-awake count.
    //

    InitThreadWakeCount();

#if !defined(_CHICAGO_)
    //
    // Initialize user logon session critical section.
    //

    InitializeCriticalSection(gUserLogonInfo.CritSection);

    //
    // Initialize security subsystem.
    //

    hr = InitSS();

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        goto ErrorExit;
    }

    //
    // Create & initialize scheduling agent window/desktop.
    //

    if (!InitializeSAWindow())
    {
        hr = E_FAIL;
        goto ErrorExit;
    }

    //
    // Check to see if starting at system start or if manually by a user.  If
    // the Service Controller has signalled the "autostart complete" event,
    // the service is being demand-started.  Otherwise (and on failure),
    // assume auto-started.
    //

    hEvent = OpenEvent(SYNCHRONIZE,
                       FALSE,
                       SC_AUTOSTART_EVENT_NAME);

    if (hEvent != NULL)
    {
        if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
        {
            //
            // Event is signalled, meaning service auto-start
            // already finished.  Therefore, the service has
            // been started by the user.
            //
            schDebugOut((DEB_ITRACE, "Service has been demand-started\n"));

            g_fUserStarted = TRUE;
        }
        else
        {
            schDebugOut((DEB_ITRACE, "Service has been auto-started\n"));
        }

        CloseHandle(hEvent);
    }
    else
    {
        ERR_OUT("OpenEvent", GetLastError());
    }

#else // defined(_CHICAGO_)

    //
    // Initialize idle and battery events code on Win95.
    //

    hr = InitBatteryNotification();

    if (FAILED(hr))
    {
        ERR_OUT("InitBatteryNotification", hr);
        goto ErrorExit;
    }

    //
    // Check to see if starting at system start or if manually by a user. If
    // the tray window is up, then the service has been user started.
    //

    g_fUserStarted = FindWindow(WNDCLASS_TRAY, NULL) != NULL;

#endif // defined(_CHICAGO_)


    schDebugOut((DEB_ITRACE, "g_fUserStarted = %s\n",
                 g_fUserStarted ? "TRUE" : "FALSE"));

    //
    // Create and initialize the service worker class
    //

    g_pSched = new CSchedWorker;
    if (g_pSched == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERR_OUT("Allocation of CSchedWorker", hr);
        goto CloseLogExit;
    }

    hr = g_pSched->Init();

    if (FAILED(hr))
    {
        ERR_OUT("CSchedWorker::Init", hr);
        goto CloseLogExit;
    }

    //
    // Create the job processor manager.
    //

    gpJobProcessorMgr = new CJobProcessorMgr;
    if (gpJobProcessorMgr == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERR_OUT("Allocation of CJobProcessorMgr", hr);
        goto CloseLogExit;
    }

    //
    // Create the Worker thread manager.
    //

    gpThreadMgr = new CWorkerThreadMgr;
    if (gpThreadMgr == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERR_OUT("Allocation of CWorkerThreadMgr", hr);
        goto CloseLogExit;
    }
    
    if (!gpThreadMgr->Initialize())

    {
        hr = E_FAIL;
        ERR_OUT("Thread manager initialization", GetLastError());
        goto CloseLogExit;
    }

#if defined(_CHICAGO_)
    //
    // Initialize idle detection.  This must be done by the window thread
    // (not the state machine thread).  On Chicago, this is called by the
    // window thread.
    //
    InitIdleDetection();

#else // defined(_CHICAGO_)

    //
    // Create the service scavenger task. Note, no thread associated
    // with it initially.
    //

    gpSAScavengerTask = new CSAScavengerTask(SCAVENGER_START_WAIT_TIME);
    if (gpSAScavengerTask == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERR_OUT("Allocation of CSAScavengerTask", hr);
        goto CloseLogExit;
    }

    hr = gpSAScavengerTask->Initialize();

    if (FAILED(hr))
    {
        ERR_OUT("Scavenger task initialization", hr);
        goto CloseLogExit;
    }
#endif // defined(_CHICAGO_)

    return(S_OK);

CloseLogExit:
    delete g_pSched;
    g_pSched = NULL;

    delete gpJobProcessorMgr;
    gpJobProcessorMgr = NULL;

    delete gpThreadMgr;
    gpThreadMgr = NULL;

#if !defined(_CHICAGO_)
    delete gpSAScavengerTask;
    gpSAScavengerTask = NULL;
#endif // !defined(_CHICAGO_)

    CloseLogFile();

ErrorExit:
#if !defined(_CHICAGO_)
    UninitializeSAWindow();
    UninitSS();
    DeleteCriticalSection(gUserLogonInfo.CritSection);
#endif // !defined(_CHICAGO_)
    TlsFree(g_WakeCountSlot);
    FreeGlobals();
    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   SchCleanup
//
//  Synopsis:   exit cleanup for the schedule service
//
//-----------------------------------------------------------------------------
void
SchCleanup(void)
{
    //
    // Shutdown processor & thread managers.
    //
    // NB : Placing this call first to give threads time to exit.
    //

    if (gpJobProcessorMgr != NULL)
    {
        gpJobProcessorMgr->Shutdown();
    }
    if (gpThreadMgr != NULL)
    {
        gpThreadMgr->Shutdown(FALSE);
    }

    //
    // Shut down the scavenger task thread, if it is running.
    //

    if (gpSAScavengerTask != NULL)
    {
        gpSAScavengerTask->Shutdown();
    }

    //
    // Stop the RPC server.
    //

    StopRpcServer();

    //
    // Cleanup data associated with the Net Schedule API support code.
    //

    UninitializeNetScheduleApi();

    //
    // Close scheduling agent window/desktop.
    //

    UninitializeSAWindow();

    //
    // Delete user logon session critical section.
    //

    DeleteCriticalSection(gUserLogonInfo.CritSection);

    //
    // DO NOT delete the thread manager & processor manager objects if
    // worker threads remain active. This case is *highly* unlikely.
    //

    BOOL fNoWorkerThreadsActive = TRUE;

    if (gpThreadMgr != NULL)
    {
        //
        // Invoke shutdown one last time with the wait on worker thread
        // termination option specified.
        //

        if (gpThreadMgr->GetThreadCount() != 0)
        {
            fNoWorkerThreadsActive = gpThreadMgr->Shutdown(TRUE);
        }
        else
        {
            delete gpThreadMgr;
            gpThreadMgr = NULL;
        }
    }

    //
    // free up globals and delete AFTER threads are gone,
    // otherwise a thread might try to access something
    // we've already deleted
    //
    FreeGlobals();

    if (g_pSched != NULL)
    {
        delete g_pSched;
        g_pSched = NULL;
    }


    //
    // Uninitialize security subsystem.
    //

    UninitSS();

    if (gpSAScavengerTask != NULL && fNoWorkerThreadsActive)
    {
        delete gpSAScavengerTask;
        gpSAScavengerTask = NULL;
    }

    if (gpJobProcessorMgr != NULL && fNoWorkerThreadsActive)
    {
        delete gpJobProcessorMgr;
        gpJobProcessorMgr = NULL;
    }

    g_fUserStarted = FALSE;

    if (g_WakeCountSlot != 0xFFFFFFFF) {
        TlsFree(g_WakeCountSlot);
        g_WakeCountSlot = 0xFFFFFFFF;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetExeNameFromCmdLine
//
//  Synopsis:   Copy the relative executable name from the command line into
//              a buffer.
//
//  Arguments:  [pwszCmdLine]  -- Command line.
//              [ccBufferSize] -- Size of buffer in characters
//              [szBuffer]     -- Buffer to store name.
//
//  Returns:    None.
//
//  Notes:      The command line argument string is modified & restored!
//
//----------------------------------------------------------------------------
VOID
GetExeNameFromCmdLine(LPCWSTR pwszCmdLine, DWORD ccBufferSize, TCHAR tszBuffer[])
{
    LPCWSTR pwszExeName;

    tszBuffer[0] = TEXT('\0');               // In case of error.

    if (pwszCmdLine == NULL || !*pwszCmdLine)
    {
        return;
    }

    // Isolate the relative executable filename from the command line.
    //
    // Note that the cmd line string is actually just the application
    // name - no arguments.
    //
    for (pwszExeName = pwszCmdLine + wcslen(pwszCmdLine) - 1;
            pwszExeName != pwszCmdLine; pwszExeName--)
    {
        if (*pwszExeName == L'\\' || *pwszExeName == L':')
        {
            pwszExeName++;
            break;
        }
    }

    // Copy executable name.
    //
    if (*pwszExeName)
    {

#ifdef UNICODE

        // Make sure the buffer is large enough.  If not,
        // return the same error as WideCharToMultiByte
        //
        if (wcslen(pwszExeName) + 1 > ccBufferSize)
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
        }
        else
        {
            wcscpy(tszBuffer, pwszExeName);
        }

#else  // ndef UNICODE

        if (!WideCharToMultiByte(CP_ACP,
                                 0,
                                 pwszExeName,
                                 -1,
                                 tszBuffer,
                                 ccBufferSize,
                                 NULL,
                                 NULL))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }

#endif // UNICODE

    }
}

//+---------------------------------------------------------------------------
//
//  Function:   UpdateSADatServiceFlags
//
//  Synopsis:   Called by the service code to update the service flag settings
//              in the file, SA.DAT, located in the local tasks folder.
//
//  Arguments:  [ptszFolderPath]  -- Tasks folder path.
//              [rgfServiceFlags] -- Flags to update.
//              [fClear]          -- TRUE, clear the flags indicated; FALSE,
//                                   set them.
//
//  Returns:    SADatGet/SetData return codes.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
UpdateSADatServiceFlags(
    LPTSTR ptszFolderPath,
    BYTE   rgfServiceFlags,
    BOOL   fClear)
{
    BYTE    rgbData[SA_DAT_VERSION_ONE_SIZE];
    HANDLE  hSADatFile;
    HRESULT hr;

    //
    // Update the flags in the service flags field of SA.DAT (in the Tasks
    // folder).
    //

    hr = SADatGetData(ptszFolderPath,
                      SA_DAT_VERSION_ONE_SIZE,
                      rgbData,
                      &hSADatFile);

    if (SUCCEEDED(hr))
    {
        if (fClear)
        {
            rgbData[SA_DAT_SVCFLAGS_OFFSET] &= ~rgfServiceFlags;
        }
        else
        {
            rgbData[SA_DAT_SVCFLAGS_OFFSET] |= rgfServiceFlags;
        }

        hr = SADatSetData(hSADatFile, SA_DAT_VERSION_ONE_SIZE, rgbData);

        CloseHandle(hSADatFile);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\task.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       task.cxx
//
//  Contents:   CTask class implementation.
//
//  Classes:    CTask
//
//  Functions:  None.
//
//  History:    25-Oct-95   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include "task.hxx"

//+---------------------------------------------------------------------------
//
//  Method:     CTask::AddRef
//
//  Synopsis:   Increment the task reference count.
//
//  Arguments:  None.
//
//  Returns:    ULONG reference count.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
ULONG
CTask::AddRef(void)
{
    ULONG ulTmp = InterlockedIncrement((LONG *)&_cReferences);

    schDebugOut((DEB_USER3,
        "CTask::AddRef(0x%x) _cReferences(%d)\n",
        this,
        ulTmp));

    return(ulTmp);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTask::Release
//
//  Synopsis:   Decrement the task reference count.
//
//  Arguments:  None.
//
//  Returns:    ULONG reference count.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
ULONG
CTask::Release(void)
{
    ULONG ulTmp = InterlockedDecrement((LONG *)&_cReferences);

    schDebugOut((DEB_USER3,
        "CTask::Release(0x%x) _cReferences(%d)\n",
        this,
        ulTmp));

    if (ulTmp == 0)
    {
        delete this;
    }
    return(ulTmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jobtask\res-ids.h ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Object Handler
//
//	Microsoft Windows
//	Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       res-ids.h
//
//  Contents:   resource IDs
//
//  History:    14-Jan-96 EricB created
//
//-----------------------------------------------------------------------------

#define IDI_SCHEDULER           100

#define MAIN_MENU               10

#define IDM_EXIT                100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jobtask\jobtask.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       jobtask.cxx
//
//  Contents:   job scheduler test task application
//
//  History:    14-Jan-96 EricB created
//
//-----------------------------------------------------------------------------

#include "..\..\pch\headers.hxx"
#pragma hdrstop
#include <debug.hxx>
#include "res-ids.h"

DECLARE_INFOLEVEL(Sched);

// globals
HINSTANCE   g_hInstance;
HWND        g_hwndChild;
UINT        g_uTimeTillExit = 0;
UINT        g_uExitCode = 0;
SYSTEMTIME  g_st;

// local prototypes
LRESULT CALLBACK TargWndProc(HWND hwndTarg, UINT uMsg, WPARAM wParam,
                             LPARAM lParam);

#define TARG_CLASS  TEXT("TargWndClass")
#define TITLE       TEXT("Job Scheduler Test Target")

const int   BUF_LEN = 512;
const UINT  TIMER_ID = 7;

//+----------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Synopsis:   entry point
//
//-----------------------------------------------------------------------------
int WINAPI
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
        int nCmdShow)
{
    GetLocalTime(&g_st);

    if (hPrevInstance != NULL)
    {
        return -1;
    }

    g_hInstance = hInstance;

    if (lpCmdLine && *lpCmdLine != '\0')
    {
        lpCmdLine = strtok(lpCmdLine, " \t");
        // convert seconds to milliseconds.
        g_uTimeTillExit = (UINT)atoi(lpCmdLine) * 1000;
        LPSTR lpExitCode = strtok(NULL, " \t");
        if (lpExitCode)
        {
            g_uExitCode = (UINT)atoi(lpExitCode);
        }
    }

    //
    // Register the window class
    //
    WNDCLASS wc;

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = TargWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_SCHEDULER));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = MAKEINTRESOURCE(MAIN_MENU);
    wc.lpszClassName = TARG_CLASS;

    if (!RegisterClass(&wc))
    {
        schDebugOut((DEB_ERROR, "RegisterClass failed with error %d\n",
                     GetLastError()));
        return -1;
    }

    //
    // Create the window
    //

    HWND hwndTarg = CreateWindow(TARG_CLASS, TITLE, WS_OVERLAPPEDWINDOW,
                                 CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                 CW_USEDEFAULT, (HWND)NULL, (HMENU)NULL,
                                 hInstance, (LPVOID)NULL);
    if (!hwndTarg)
    {
        schDebugOut((DEB_ERROR, "CreateWindow failed with error %d\n",
                     GetLastError()));
        return -1;
    }

    if (g_uTimeTillExit > 0)
    {
        if (TIMER_ID != SetTimer(hwndTarg, TIMER_ID, g_uTimeTillExit, NULL))
        {
            schDebugOut((DEB_ERROR, "SetTimer failed with error %d\n",
                         GetLastError()));
        }
    }

    ShowWindow(hwndTarg, nCmdShow);
    UpdateWindow(hwndTarg);

    MSG msg;
    while (GetMessage(&msg, (HWND) NULL, 0, 0))
    { 
        TranslateMessage(&msg); 
        DispatchMessage(&msg); 
    } 
    return msg.wParam;
}

//+----------------------------------------------------------------------------
//
//  Function:   TargWndProc
//
//  Synopsis:   handle messages
//
//  Returns:    occasionally
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
TargWndProc(HWND hwndTarg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR tszBuf[BUF_LEN];
    switch (uMsg)
    {
    case WM_CREATE:
        g_hwndChild = CreateWindow(TEXT("EDIT"), NULL,
                                    WS_CHILD | WS_VISIBLE | WS_HSCROLL |
                                    WS_VSCROLL | ES_MULTILINE |
                                    ES_AUTOVSCROLL | ES_WANTRETURN |
                                    ES_READONLY,
                                    0, 0, 0, 0, hwndTarg, (HMENU) 1,
                                    g_hInstance, NULL);
        TCHAR tszBuf[BUF_LEN];
        wsprintf(tszBuf,
                 TEXT("\r\nTest task launched at %u:%02u:%02u %u/%u/%u,"),
                 g_st.wHour, g_st.wMinute, g_st.wSecond, g_st.wMonth,
                 g_st.wDay, g_st.wYear);
        TCHAR tszDir[BUF_LEN];
        GetCurrentDirectory(BUF_LEN, tszDir);
        wsprintf(tszBuf + lstrlen(tszBuf),
                 TEXT("\r\n\r\nin working directory %s,"), tszDir);
        if (g_uTimeTillExit)
        {
            wsprintf(tszBuf + lstrlen(tszBuf),
                     TEXT("\r\n\r\nand will run for %u seconds,"),
                     g_uTimeTillExit / 1000);
        }
        wsprintf(tszBuf + lstrlen(tszBuf),
                 TEXT("\r\n\r\nand will return exit code %x."),
                 g_uExitCode);
        SendMessage(g_hwndChild, WM_SETTEXT, 0, (LPARAM)tszBuf);
        break;

    case WM_SIZE:
        MoveWindow(g_hwndChild, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
        break;

    case WM_TIMER:
        DestroyWindow(hwndTarg);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDM_EXIT:
            DestroyWindow(hwndTarg);
            break;
        }
        break;

    case WM_SYSCOMMAND:
        if (wParam == SC_CLOSE)
        {
            SendMessageA(hwndTarg, WM_COMMAND, MAKEWPARAM(IDM_EXIT, 0), 0);
            break;
        }
        else
        {
            return DefWindowProc(hwndTarg, uMsg, wParam, lParam);
        }

    case WM_DESTROY:
        PostQuitMessage(g_uExitCode);
        break;

    default:
        return DefWindowProc(hwndTarg, uMsg, wParam, lParam);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\svc_core\thread.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       thread.cxx
//
//  Contents:   Job scheduler thread code.
//
//  Classes:    CWorkerThread
//              CWorkerThreadMgr
//
//  Functions:  RequestService
//              WorkerThreadStart
//
//  History:    25-Oct-95   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#include "queue.hxx"
#include "task.hxx"
#include "jpmgr.hxx"
#include "globals.hxx"
#include "thread.hxx"
#include "proto.hxx"

extern "C"
HRESULT WorkerThreadStart(CWorkerThread *);

//
// Thread idle time before termination.
//

#define MAX_THREAD_IDLE_TIME (1000 * 60 * 3)   // 3 minutes


//+---------------------------------------------------------------------------
//
//  Function:   WorkerThreadStart
//
//  Synopsis:   The entry point for a worker thread.
//
//  Arguments:  [pWrkThrd] -- Worker thread object to start.
//
//  Returns:    TBD
//
//  Effects:    Calls the StartWorking function for the provided worker
//
//----------------------------------------------------------------------------

extern "C"
HRESULT WorkerThreadStart(CWorkerThread * pWrkThrd)
{
    schDebugOut((DEB_USER3,
        "WorkerThreadStart pWrkThrd(0x%x)\n",
        pWrkThrd));

    HRESULT hr;

    //
    //  Call the worker thread class
    //

    hr = pWrkThrd->StartWorking();

    delete pWrkThrd;

    return(hr);
}

// Class CWorkerThread
//

//+-------------------------------------------------------------------------
//
//  Member:     CWorkerThread::~CWorkerThread
//
//  Synopsis:   Destructor
//
//  Arguments:  N/A
//
//  Returns:    N/A
//
//  Notes:      A WorkerThread should only be deleted after its associated
//              thread has been terminated. This is noted by having the
//              _hThread being == NULL.
//
//--------------------------------------------------------------------------
CWorkerThread::~CWorkerThread()
{
    TRACE3(CWorkerThread, ~CWorkerThread);

    gpThreadMgr->SignalThreadTermination();

    //
    //  A precondition to destroying this thread is for the thread to
    //  have been terminated already. If this isn't the case, we are
    //  in big trouble.
    //
    //  Terminating the thread is not good, since it leaves the threads
    //  stack allocated in our address space. We also are not sure what
    //  the thread is up to. It could have resources locked. But, we
    //  also don't know what it will do next. We will have no record of it.
    //

    if (_hThread == NULL && _hWorkAvailable != NULL)
    {
        CloseHandle(_hWorkAvailable);
    }
    else
    {
        //
        // BUGBUG : Commenting out the assertion below until
        //          (ServiceStatus != STOPPING) can be added.
        //

#if 0
        schAssert(0 && (_hThread != NULL) &&
            "Destroying CWorkerThread while thread exists. Memory Leak!");
#endif // 0
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThread::AssignTask
//
//  Synopsis:   Assigns the task passed to this worker. A NULL task signals
//              thread termination.
//
//  Arguments:  [pTask] -- Task to be serviced.
//
//  Returns:    S_OK
//              E_FAIL -- Task already assigned.
//              TBD
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
CWorkerThread::AssignTask(CTask * pTask)
{
    schDebugOut((DEB_USER3,
        "CWorkerThread::AssignTask(0x%x) pTask(0x%x)\n",
         this,
        pTask));

    HRESULT hr;

    //
    // A must not already be assigned.
    //

    if (_pTask != NULL)
    {
        return(E_FAIL);
    }

    _pTask = pTask;

    if (_pTask != NULL)
    {
        _pTask->AddRef();
    }

    //
    // Signal the thread to process the task.
    //

    if (!SetEvent(_hWorkAvailable))
    {
        if (_pTask != NULL)
        {
             _pTask->Release();
             _pTask = NULL;
        }
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThread::Initialize
//
//  Synopsis:   Performs initialization unable to be performed in the
//              constructor.
//
//  Arguments:  None.
//
//  Returns:    S_OK
//              TBD
//
//  Effects:    None.
//
//----------------------------------------------------------------------------
HRESULT
CWorkerThread::Initialize(void)
{
    TRACE3(CWorkerThread, Initialize);

    HRESULT hr = S_OK;

    //
    // Create the event used to signal the thread to start working.
    //

    _hWorkAvailable = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (_hWorkAvailable == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    ULONG ThreadID;
    _hThread = CreateThread(NULL,
                            WORKER_STACK_SIZE,
    (LPTHREAD_START_ROUTINE)WorkerThreadStart,
                            this,
                            0,
                            &ThreadID);

    if (_hThread != NULL)
    {
        if (!SetThreadPriority(_hThread, THREAD_PRIORITY_LOWEST))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
    }

    if (SUCCEEDED(hr))
    {
        gpThreadMgr->SignalThreadCreation();
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThread::StartWorking
//
//  Synopsis:   The almost endless loop for a worker thread
//
//  Arguments:  None.
//
//  Returns:    TBD
//
//  Notes:      This routine will sit in a loop, and wait for tasks to
//              be assigned. When a task is assigned, it will call the
//              PerformTask method of the task. If the assigned task
//              is NULL, then the thread will kill itself.
//
//----------------------------------------------------------------------------
HRESULT
CWorkerThread::StartWorking(void)
{
    TRACE3(CWorkerThread, StartWorking);

    HRESULT hr;
    BOOL    fTerminationSignalled = FALSE;

    while (1)
    {
        //
        // Wait on the work available semaphore for the signal that a task
        // has been assigned.
        //

        DWORD dwRet = WaitForSingleObject(_hWorkAvailable,
                                          MAX_THREAD_IDLE_TIME);

        ResetEvent(_hWorkAvailable);

        if (dwRet == WAIT_FAILED)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            break;
        }
        else if (dwRet == WAIT_TIMEOUT)
        {
            //
            // This thread has timed out - see if it can be terminated.
            // If this thread object exists in the global free thread
            // pool, it can be terminated. If it doesn't exist in the pool,
            // it means this thread is in use, therefore re-enter the wait.
            //
            // More detail on the above: It's possible another thread
            // (thread A) can take this thread (thread B) for service just
            // after thread B's wait has timed out. In absence of the thread
            // pool check, thread B would exit out from under thread A.
            //

            CWorkerThread * pWrkThrd = gpThreadMgr->RemoveThread(_hThread);

            if (pWrkThrd == NULL)
            {
                //
                // This object doesn't exist in the pool. Assume another
                // thread has taken this thread for service, re-enter the
                // wait.
                //

                continue;
            }
            else
            {
                //
                // This thread has expired.
                //
                // NB: DO NOT delete the thread object!
                //

                schAssert(pWrkThrd == this);

                break;
            }
        }

        //
        // A NULL task signals thread termination.
        //

        if (_pTask == NULL)
        {
            fTerminationSignalled = TRUE;
            break;
        }

        //
        // Perform the task.
        //

        _pTask->PerformTask();

        _pTask->UnServiced();

        //
        // Release the task.
        //

        schDebugOut((DEB_USER3, "CWorkerThread::StartWorking(0x%x) "
            "Completed and Releasing task(0x%x)\n",
            this,
            _pTask));

        _pTask->Release();
        _pTask = NULL;

        //
        // Return this thread to the global pool, if the service is not
        // in the process of stopping. If the service is stopping, this
        // thread must exit.
        //

        if (IsServiceStopping())
        {
            fTerminationSignalled = TRUE;
            break;
        }
        else
        {
            gpThreadMgr->AddThread(this);
        }
    }

    //
    // Scavenger duty. Perform global job processor pool housekeeping prior
    // to thread termination.
    //
    // Do this only if the thread timed out; not when the thread is
    // instructed to terminate.
    //

    if (!fTerminationSignalled)
    {
        gpJobProcessorMgr->GarbageCollection();
    }

    //
    // By closing the handle, we allow the system to remove all remaining
    // traces of this thread.
    //

    BOOL fTmp = CloseHandle(_hThread);
    schAssert(fTmp && "Thread handle close failed - possible memory leak");

    _hThread = NULL;

    return(hr);
}

// Class CWorkerThreadMgr
//

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::~CWorkerThreadMgr
//
//  Synopsis:   Destructor.
//
//  Arguments:  N/A
//
//  Returns:    None.
//
//  Notes:      Memory leaks can occur with this destructor. This destructor
//              must only be called with process termination.
//
//----------------------------------------------------------------------------
CWorkerThreadMgr::~CWorkerThreadMgr()
{
    TRACE3(CWorkerThreadMgr, ~CWorkerThreadMgr);

    //
    // This destructor must only be called with process termination.
    //
    // If the global thread count is non-zero, there are threads
    // remaining. In this case, DO NOT delete the critical section or
    // close the event handle! An active thread could still access it.
    //
    // This will be a memory leak on process termination if the count is
    // non-zero, but the leak is far better than an a/v.
    //
    if (!_cThreadCount)
    {
        DeleteCriticalSection(&_csThreadMgrCritSection);
        CloseHandle(_hThreadTerminationEvent);
    }
    else
    {
        schDebugOut((DEB_FORCE,
            "CWorkerThreadMgr dtor(0x%x) : Unavoidable memory leak. " \
            "Leaking one or more CWorkerThread objects since worker " \
            "thread(s) are still active.\n",
            this));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::AddThread
//
//  Synopsis:   Adds the worker thread indicated to the pool.
//
//  Arguments:  [pWrkThrd] -- Worker thread to add.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CWorkerThreadMgr::AddThread(CWorkerThread * pWrkThrd)
{
    schDebugOut((DEB_USER3,
        "CWorkerThreadMgr::AddThread(0x%x) pWrkThrd(0x%x)\n",
        this,
        pWrkThrd));

    //
    // If the service is stopping, instruct the thread to terminate; else,
    // add it to the pool. Note, this is safe since only the threads
    // themselves perform AddThread - the thread is free.
    //

    if (IsServiceStopping())
    {
        pWrkThrd->AssignTask(NULL);
        return;
    }

    EnterCriticalSection(&_csThreadMgrCritSection);

    _WorkerThreadQueue.AddElement(pWrkThrd);

    LeaveCriticalSection(&_csThreadMgrCritSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::Initialize
//
//  Synopsis:   Creates the private data member, _hThreadTerminationEvent.
//
//  Arguments:  None.
//
//  Returns:    TRUE  -- Creation succeeded;
//              FALSE -- otherwise.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
BOOL
CWorkerThreadMgr::Initialize(void)
{
    if ((_hThreadTerminationEvent = CreateEvent(NULL,
                                                TRUE,
                                                FALSE,
                                                NULL)) == NULL)
    {
        schDebugOut((DEB_ERROR,
            "CWorkerThreadMgr::Initialize(0x%x) CreateEvent failed, " \
            "status = 0x%lx\n",
            this,
            GetLastError()));
        return(FALSE);
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::Shutdown
//
//  Synopsis:   This member is called once, no wait, early on in the schedule
//              service's shutdown sequence. It relinquishes all free threads.
//              Done so by signalling the threads in the pool to terminate.
//
//              This member is called a second time, with the wait option, to
//              ensure any busy (non-free) worker threads have terminated
//              also.
//
//  Arguments:  [fWait] -- Flag instructing this method to wait indefinitely
//                         until all worker threads have terminated.
//                           ** Use only in this case of service stop **
//
//  Returns:    TRUE  -- All worker threads terminated.
//              FALSE -- One ore more worker threads still active.
//
//  Notes:      It must not be possible for worker threads to enter the
//              thread pool critical section in their termination code paths.
//              Otherwise, a nested, blocking section will result.
//
//----------------------------------------------------------------------------
BOOL
CWorkerThreadMgr::Shutdown(BOOL fWait)
{
#define THRDMGR_INITIAL_WAIT_TIME   2000    // 2 seconds.

    EnterCriticalSection(&_csThreadMgrCritSection);

    CWorkerThread * pWrkThrd;

    while ((pWrkThrd = _WorkerThreadQueue.RemoveElement()) != NULL)
    {
        pWrkThrd->AssignTask(NULL);         // NULL task signals termination.
    }

    LeaveCriticalSection(&_csThreadMgrCritSection);

    //
    // Optionally wait for outstanding worker threads to terminate before
    // returning. This is only to be done during service shutdown. All worker
    // threads have logic to terminate with service shutdown.
    //
    // To actually have to wait is a very rare. Only occurring in a rare
    // case, or if this machine is under *extreme* loads, or the absolutely
    // unexpected occurs. The rare case mentioned is a small window where
    // a job processor object is spun up immediately prior to the service
    // shutdown sequence and its initialization phase coincides with
    // CJobProcessor::Shutdown().
    //

    if (fWait)
    {
        //
        // On destruction, each thread decrements the global thread count
        // and sets the thread termination event.
        //

        DWORD dwWaitTime = THRDMGR_INITIAL_WAIT_TIME;
        DWORD dwRet;

        while (_cThreadCount)
        {
            //
            // Wait initially THRDMGR_INITIAL_WAIT_TIME amount of time.
            // If this wait times-out, re-issue a Shutdown of the global
            // processor object then wait infinitely.
            //

            if ((dwRet = WaitForSingleObject(_hThreadTerminationEvent,
                                             dwWaitTime)) == WAIT_OBJECT_0)
            {
                ResetEvent(_hThreadTerminationEvent);
            }
            else if (dwRet == WAIT_TIMEOUT)
            {
                //
                // Address the case where the job processor was spun up
                // inadvertently. This will shut it down.
                //

                gpJobProcessorMgr->Shutdown();
                dwWaitTime = INFINITE;
            }
            else
            {
                //
                // This return code will notify the service cleanup code
                // to not free up resources associated with the worker
                // threads. Otherwise, they may fault.
                //

                return(FALSE);
            }
        }
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::RemoveThread
//
//  Synopsis:   Remove & return a thread from the pool.
//
//  Arguments:  None.
//
//  Returns:    CWorkerThread * -- Returned thread.
//              NULL            -- Pool empty.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CWorkerThread *
CWorkerThreadMgr::RemoveThread(void)
{
    TRACE3(CWorkerThread, RemoveThread);

    CWorkerThread * pWrkThrd = NULL;

    EnterCriticalSection(&_csThreadMgrCritSection);

    pWrkThrd = _WorkerThreadQueue.RemoveElement();

    LeaveCriticalSection(&_csThreadMgrCritSection);

    return(pWrkThrd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkerThreadMgr::RemoveThread
//
//  Synopsis:   Remove & return the thread from the pool with the associated
//              handle.
//
//  Arguments:  [hThread] -- Target thread handle.
//
//  Returns:    CWorkerThread * -- Found it.
//              NULL            -- Worker thread not found.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
CWorkerThread *
CWorkerThreadMgr::RemoveThread(HANDLE hThread)
{
    schDebugOut((DEB_USER3,
        "CWorkerThreadMgr::RemoveThread(0x%x) hThread(0x%x)\n",
        this,
        hThread));

    CWorkerThread * pWrkThrd;

    EnterCriticalSection(&_csThreadMgrCritSection);

    pWrkThrd = _WorkerThreadQueue.GetFirstElement();

    while (pWrkThrd != NULL)
    {
        if (pWrkThrd->GetHandle() == hThread)
        {
            _WorkerThreadQueue.RemoveElement(pWrkThrd);
            break;
        }

        pWrkThrd = pWrkThrd->Next();
    }

    LeaveCriticalSection(&_csThreadMgrCritSection);

    return(pWrkThrd);
}

//+---------------------------------------------------------------------------
//
//  Function:   RequestService
//
//  Synopsis:   Request a free worker thread from the global thread pool to
//              service the task indicated. If no free threads exist in the
//              pool, create a new one.
//
//  Arguments:  [pTask] -- Task to undergo service.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//              TBD
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
RequestService(CTask * pTask)
{
    schDebugOut((DEB_USER3, "RequestService pTask(0x%x)\n", pTask));

    HRESULT hr = S_OK;

    //
    // Take no requests if the service is stopping.
    //

    if (IsServiceStopping())
    {
        schDebugOut((DEB_ERROR,
            "RequestService pTask(0x%x) Service stopping - request " \
            "refused\n",
            pTask));
        return(E_FAIL);
    }

    //
    // Obtain a free thread from the global thread pool.
    //

    CWorkerThread * pWrkThrd = gpThreadMgr->RemoveThread();

    if (pWrkThrd == NULL)
    {
        //
        // Create a new worker thread object if none were available.
        //

        pWrkThrd = new CWorkerThread;

        if (pWrkThrd == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            return(hr);
        }

        hr = pWrkThrd->Initialize();

        if (FAILED(hr))
        {
            delete pWrkThrd;
            return(hr);
        }
    }

    hr = pWrkThrd->AssignTask(pTask);

    if (FAILED(hr))
    {
        delete pWrkThrd;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jobtest\jobtest.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Schedule Application Unit Test
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       jobtest.cxx
//
//  Contents:   job object test harness
//
//  History:    28-Apr-95 EricB created
//
//-----------------------------------------------------------------------------
#include "headers.hxx"
#pragma hdrstop
#if defined(_CHICAGO_)
#include "..\..\inc\job_cls.hxx"
typedef HRESULT (* GETCLASSOBJECT)(REFCLSID cid, REFIID iid, void **ppvObj);
#else
#include <mstask.h>
const int SCH_BIGBUF_LEN = 256;
#endif

DECLARE_INFOLEVEL(Sched);

//+----------------------------------------------------------------------------
// Macro: TEST_HR
// Purpose: tests the HRESULT for error, takes "action" if found
//-----------------------------------------------------------------------------
#define TEST_HR(hr, str, action) \
    if (FAILED(hr)) \
    { \
        fprintf(stderr, #str " failed with error %lx\n", hr); \
        action; \
    }

// flags
#define JT_PERSISTENT       0x1
#define JT_CREATE_JOB       0x2
#define JT_EDIT_JOB         0x4
#define JT_CREATE_TRIGGER   0x8
#define JT_PRINT_TRIGGERS   0x10
#define JT_PRINT_RUNS       0x20

// prototypes
void Usage(int ExitCode);
HRESULT LoadJob(ITask * pJob, TCHAR * ptszFileName);
HRESULT SaveJob(ITask * pJob, TCHAR * ptszFileName);
HRESULT IsJobDirty(ITask * pJob);
HRESULT EditJob(ITask * pJobEx);
HRESULT PrintRunTimes(ITask * pJob, WORD cRuns);
HRESULT PrintTriggers(ITask * pJob);

//+----------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   entry point
//
//-----------------------------------------------------------------------------
int _cdecl
main(int argc, char ** argv)
{
    if (argc < 2)
    {
        Usage(EXIT_SUCCESS);
    }
    DWORD dwFlags = 0;
    WORD cRunsToPrint = 0;
    short iTrigger = SHRT_MAX;
    TCHAR * ptszFileName;
    char szMsg[80] = "\n** Job object test";
    LPTSTR ptszCmdLine = GetCommandLine();
    // skip the program name
    TCHAR * ptszToken = _tcspbrk(ptszCmdLine, TEXT(" \t"));
    // delimit the first token
    ptszToken = _tcstok(ptszToken, TEXT(" \t"));
    // parse command line
    do {
        switch (*ptszToken)
        {
        case TEXT('/'):
        case TEXT('-'):
            ptszToken = _tcsinc(ptszToken);
            switch(*ptszToken)
            {
            case TEXT('c'):
            case TEXT('C'):
                dwFlags |= JT_CREATE_JOB;
                strcat(szMsg, "; create");
                break;

            case TEXT('e'):
            case TEXT('E'):
                dwFlags |= JT_EDIT_JOB;
                strcat(szMsg, "; edit job");
                break;

            case TEXT('s'):
            case TEXT('S'):
                dwFlags |= JT_PRINT_TRIGGERS;
                strcat(szMsg, "; print trigger strings");
                break;

            case TEXT('r'):
            case TEXT('R'):
                dwFlags |= JT_PRINT_RUNS;
                ptszToken = _tcsinc(ptszToken);
                TCHAR * ptszNumRuns;
                ptszNumRuns = _tcstok(NULL, TEXT(" \t"));
                if (ptszNumRuns == NULL || *ptszNumRuns == TEXT('/') ||
                    *ptszNumRuns == TEXT('-'))
                {
                    Usage(EXIT_FAILURE);
                }
                cRunsToPrint = (WORD)_tcstol(ptszNumRuns, NULL, 10);
                strcat(szMsg, "; print runs");
                break;

            case TEXT('f'):
            case TEXT('F'):
                dwFlags |= JT_PERSISTENT;
                ptszToken = _tcsinc(ptszToken);
                ptszFileName = _tcstok(NULL, TEXT(" \t"));
                if (ptszFileName == NULL || *ptszFileName == TEXT('/') ||
                    *ptszFileName == TEXT('-'))
                {
                    Usage(EXIT_FAILURE);
                }
                sprintf(szMsg + strlen(szMsg), "; save %S", ptszFileName);
                break;

            case TEXT('h'):
            case TEXT('H'):
            case TEXT('?'):
                Usage(EXIT_SUCCESS);

            default:
                Usage(EXIT_FAILURE);
            }
            break;

        default:
            // not a switch character (/ or -)
            Usage(EXIT_FAILURE);
        }
        ptszToken = _tcstok(NULL, TEXT(" \t"));
    } while (ptszToken);
    strcat(szMsg, "\n");
    printf(szMsg);
    HRESULT hr;
    ITask * pJob;

#if defined(_CHICAGO_) // don't use OLE on Chicago for now

    HINSTANCE hLib = LoadLibrary("c:\\windows\\schedulr.dll");
    if (!hLib)
    {
        fprintf(stderr, "LoadLibrary of schedulr.dll failed with error %d\n",
                GetLastError());
        goto Err0;
    }
    GETCLASSOBJECT GetClassObject;
    GetClassObject = (GETCLASSOBJECT)GetProcAddress(hLib, "DllGetClassObject");
    IClassFactory * pJobCF;
    hr = (*GetClassObject)(CLSID_CJob, IID_IClassFactory, (void **)&pJobCF);
    TEST_HR(hr, "DllGetClassObject(CLSID_CJob)", goto Err0);
    hr = pJobCF->CreateInstance(NULL, IID_ITask, (void **)&pJob);
    TEST_HR(hr, "CreateInstance(IID_ITask)", goto Err0);

#else

    //hr = OleInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = OleInitialize(NULL);
    TEST_HR(hr, "OleInitialize", return -1);
    hr = CoCreateInstance(CLSID_CJob, NULL, CLSCTX_INPROC_SERVER, IID_ITask,
                          (void **)&pJob);
    TEST_HR(hr, "CoCreateInstance(CLSID_CJob)", goto Err0);

#endif

    if (dwFlags & JT_PERSISTENT && !(dwFlags & JT_CREATE_JOB))
    {
        hr = LoadJob(pJob, ptszFileName);
        if (hr == ERROR_FILE_NOT_FOUND)
        {
            fprintf(stderr, "\nERROR, cannot specify /f on a non-existent "
                    "file unless /c is also given!\n");
            goto Err1;
        }
        else
        {
            if (FAILED(hr))
            {
                goto Err1;
            }
        }
    }
    if (dwFlags & JT_EDIT_JOB)
    {
        hr = EditJob(pJob);
        if (hr == ERROR_CANCELLED)
        {
            goto cleanup;
        }
        if (FAILED(hr))
        {
            goto Err1;
        }
    }
    if (dwFlags & JT_CREATE_TRIGGER)
    {
        ITaskTrigger * pTrigger;
        hr = pJob->CreateTrigger(NULL, &pTrigger);
        if (FAILED(hr))
        {
            goto Err1;
        }
        pTrigger->Release();
    }
    if (dwFlags & JT_PRINT_TRIGGERS)
    {
        hr = PrintTriggers(pJob);
        if (FAILED(hr))
        {
            goto Err1;
        }
    }
    if (dwFlags & JT_PRINT_RUNS)
    {
        hr = PrintRunTimes(pJob, cRunsToPrint);
        if (FAILED(hr))
        {
            goto Err1;
        }
    }
    if (dwFlags & JT_CREATE_JOB)
    {
        hr = SaveJob(pJob, ptszFileName);
        if (FAILED(hr))
        {
            goto Err1;
        }
    }
    else
    {
        if ((dwFlags & JT_PERSISTENT) && (IsJobDirty(pJob) == S_OK))
        {
            hr = SaveJob(pJob, NULL);
            if (FAILED(hr))
            {
                goto Err1;
            }
        }
    }
cleanup:
    pJob->Release();
    OleUninitialize();
    printf("\n** Test successfully completed! **\n");
    return(EXIT_SUCCESS);
Err1:
    pJob->Release();
Err0:
#if !defined(_CHICAGO_) // don't use OLE on Chicago for now
    OleUninitialize();
#endif
    printf("** Test failed.\n");
    return(EXIT_FAILURE);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsJobDirty
//
//  Synopsis:   is the job object in core dirty?
//
//-----------------------------------------------------------------------------
HRESULT
IsJobDirty(ITask * pJob)
{
    IPersistFile * pFile;
    HRESULT hr = pJob->QueryInterface(IID_IPersistFile, (void **)&pFile);
    TEST_HR(hr, "pJob->QueryInterface(IID_IPersistFile)", return hr);
    hr = pFile->IsDirty();
    pFile->Release();
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   LoadJob
//
//  Synopsis:   loads the job object from disk, if found
//
//-----------------------------------------------------------------------------
HRESULT
LoadJob(ITask * pJob, TCHAR * ptszFileName)
{
    IPersistFile * pFile;
    HRESULT hr = pJob->QueryInterface(IID_IPersistFile, (void **)&pFile);
    TEST_HR(hr, "pJob->QueryInterface(IID_IPersistFile)", return hr);

#if defined(UNICODE)

    hr = pFile->Load(ptszFileName, STGM_READWRITE | STGM_SHARE_EXCLUSIVE);

#else // convert from ANSI to UNICODE

    WCHAR wszName[SCH_BIGBUF_LEN];
    MultiByteToWideChar(CP_ACP, 0, ptszFileName, -1, wszName, SCH_BIGBUF_LEN);

    hr = pFile->Load(wszName, STGM_READWRITE | STGM_SHARE_EXCLUSIVE);

#endif

    if (hr == STG_E_FILENOTFOUND)
    {
        pFile->Release();
        return hr;
    }
    TEST_HR(hr, "pFile->Load", pFile->Release(); return hr);
    pFile->Release();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   EditJob
//
//  Synopsis:   post the edit dialog for the job
//
//-----------------------------------------------------------------------------
HRESULT
EditJob(ITask * pJob)
{
    HRESULT hr;
    hr = pJob->EditJob(GetDesktopWindow(), TRUE);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   PrintRunTimes
//
//  Synopsis:   print out the next cRuns run times
//
//-----------------------------------------------------------------------------
HRESULT
PrintRunTimes(ITask * pJob, WORD cRuns)
{
    SYSTEMTIME stNow;
    GetLocalTime(&stNow);
    LPSYSTEMTIME pstRuns;
    HRESULT hr;
    if (cRuns == 0)
    {   // get runs for today
        SYSTEMTIME stEnd = stNow;
        stNow.wHour = stNow.wMinute = 0;
        stEnd.wHour = 23;
        stEnd.wMinute = 59;
        hr = pJob->GetRunTimes(&stNow, &stEnd, &cRuns, &pstRuns);
        TEST_HR(hr, "pJob->GetRunTimes", return hr);
        if (cRuns == 0)
        {
            printf("\nThere are no job runs scheduled for today.\n");
            return S_OK;
        }
    }
    else
    {
        hr = pJob->GetRunTimes(&stNow, NULL, &cRuns, &pstRuns);
        TEST_HR(hr, "pJob->GetRunTimes", return hr);
    }
    printf("\nThe next %d job run times: \n", cRuns);
    printf("-------------------------------------------------------------\n");
    for (WORD i = 0; i < cRuns; i++)
    {
        printf("%02d/%02d/%4d at %02d:%02d\n", pstRuns[i].wMonth,
               pstRuns[i].wDay, pstRuns[i].wYear, pstRuns[i].wHour,
               pstRuns[i].wMinute);
    }
    CoTaskMemFree(pstRuns);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   PrintTriggers
//
//  Synopsis:   print out the trigger strings
//
//-----------------------------------------------------------------------------
HRESULT
PrintTriggers(ITask * pJob)
{
    HRESULT hr;
    WCHAR * pwszTrigger;
    WORD cTriggers;
    hr = pJob->GetTriggerCount(&cTriggers);
    TEST_HR(hr, "pJob->GetTriggerCount", return hr)
    printf("\nPrint %d trigger string(s):\n\n", cTriggers);
    printf("Index\tValue\n");
    printf("-----\t-----------------------------------------------------\n");
    for (short i = 0; i < cTriggers; i++)
    {
        hr = pJob->GetTriggerString(i, &pwszTrigger);
        TEST_HR(hr, "pJob->GetTriggerString", return hr)
            printf("%d:\t%S\n", i, pwszTrigger);
        CoTaskMemFree(pwszTrigger);
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   SaveJob
//
//  Synopsis:   saves the job object persistently
//
//-----------------------------------------------------------------------------
HRESULT
SaveJob(ITask * pJob, TCHAR * ptszFileName)
{
    IPersistFile * pFile;
    HRESULT hr = pJob->QueryInterface(IID_IPersistFile, (void **)&pFile);
    TEST_HR(hr, "pJob->QueryInterface(IID_IPersistFile)", return hr);
    if (ptszFileName == NULL)
    {
        hr = pFile->Save(NULL, FALSE);
    }
    else
    {
#if defined(UNICODE)

        hr = pFile->Save(ptszFileName, TRUE);

#else // convert from ANSI to UNICODE

        WCHAR wszName[SCH_BIGBUF_LEN];
        MultiByteToWideChar(CP_ACP, 0, ptszFileName, -1, wszName,
                            SCH_BIGBUF_LEN);

        hr = pFile->Save(wszName, TRUE);

#endif
    }
    TEST_HR(hr, "pFile->Save", pFile->Release(); return hr);
    pFile->Release();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   Usage
//
//-----------------------------------------------------------------------------
void
Usage(int ExitCode)
{
    printf("\nJOBTEST: Job object test harness\n\n");
    if (ExitCode == EXIT_FAILURE)
    {
        printf("ERROR: incorrect command line!\n\n");
    }
    printf("Usage: jobtest [/c] [/e] [/s] [/t [<i>]] [/r <n>] [/f <file name>]\n");
    printf("       /c - create the job object (ignored without /f)\n");
    printf("       /e - edit the job object\n");
    printf("       /s - print out the string representation of the triggers\n");
    printf("       /t - edit a trigger; if an index i is not specified, create a new one\n");
    printf("       /r <n> - print out the next n run times for the job\n");
    printf("           n == 0 means prints today's jobs\n");
    printf("       /f - specify a filename, save changes to that file\n\n");
    printf("If /f is not specified, operations are performed on a temporary,\n"
           "in-core job object.\n");
    exit(ExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\atsign.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       atsign.cxx
//
//  Contents:   Functions to read commands from a script file.
//
//  History:    04-20-95   davidmun   Created
//
//----------------------------------------------------------------------------

#include <headers.hxx>
#pragma hdrstop
#include "jt.hxx"

//
// Forward references
// 

ULONG FindEol(CHAR *pstr, ULONG cchRemaining);
CHAR FindNextNonSpace(CHAR *pstr, ULONG cchRemaining);




//+---------------------------------------------------------------------------
//
//  Function:   DoAtSign
//
//  Synopsis:   Get filename from commandline and process it.
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    S_OK - file processed without error
//              E_*  - error logged
//
//  Modifies:   *[ppwsz]
//
//  History:    04-20-95   davidmun   Created
//              01-03-96   DavidMun   Support multi-line commands
//
//  Notes:      This routine may be indirectly recursive.
//
//----------------------------------------------------------------------------

HRESULT DoAtSign(WCHAR **ppwsz)
{
    HRESULT     hr = S_OK;
    ShHANDLE    shFile;
    ShHANDLE    shFileMapping;
    VOID        *pvBase = NULL;
    BOOL        fOk;
    ULONG       cchFile;
    TCHAR       tszFilename[MAX_PATH + 1] = TEXT("None");

    g_Log.Write(LOG_DEBUG, "DoAtSign");
    do
    {
        hr = GetFilename(ppwsz, L"command file name");
        BREAK_ON_FAILURE(hr);

#ifdef UNICODE
        wcscpy(tszFilename, g_wszLastStringToken);
#else
        wcstombs(tszFilename, g_wszLastStringToken, wcslen(g_wszLastStringToken)+1);
#endif

        //
        // Open the command file, then hand one line at a time to 
        // ProcessCommandLine (which is our caller, so we're recursing).  
        //

        shFile = CreateFile(
                    tszFilename,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,   // default security
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);  // no template

        if (shFile == INVALID_HANDLE_VALUE)
        {
            hr = E_FAIL;
            g_Log.Write(LOG_ERROR, "Can't open file %S", tszFilename);
            break;
        }

        shFileMapping = CreateFileMapping(
                            shFile,
                            NULL,   // default security
                            PAGE_READONLY,
                            0, 0,   // max size is size of file
                            NULL);  // unnamed object

        if (shFileMapping == NULL)
        {
            hr = E_FAIL;
            g_Log.Write(LOG_ERROR, "CreateFileMapping (%u)", GetLastError());
            break;
        }

        pvBase = MapViewOfFile(
                            shFileMapping,
                            FILE_MAP_READ,
                            0, 0, // start mapping at beginning of file
                            0);   // map entire file

        if (!pvBase)
        {
            hr = E_FAIL;
            g_Log.Write(LOG_ERROR, "MapViewOfFile (%u)", GetLastError());
            break;
        }

        //
        // pvBase points to start of mapped file.  Get the file length.
        //

        BY_HANDLE_FILE_INFORMATION bhfi;

        fOk = GetFileInformationByHandle(shFile, &bhfi);

        if (!fOk)
        {
            hr = E_FAIL;
            g_Log.Write(LOG_ERROR, "GetFileInformationByHandle (%u)", GetLastError());
            break;
        }

        cchFile = bhfi.nFileSizeLow;

        if (bhfi.nFileSizeHigh)
        {
            hr = E_FAIL;
            g_Log.Write(LOG_ERROR, "File too large");
            break;
        }
    }
    while (0);

    //
    // Finally ready to process file.
    //

    ULONG cchProcessed = 0;
    ULONG ulCurLine = 1;
    CHAR  *pstrFile = (CHAR *) pvBase;

    while (SUCCEEDED(hr) && cchProcessed < cchFile)
    {
        CHAR  szLine[MAX_TOKEN_LEN + 1] = "";
        ULONG cchLine = 0;
        WCHAR wszLine[MAX_TOKEN_LEN + 1];
        WCHAR wszExpandedLine[MAX_TOKEN_LEN + 1];
        BOOL  fInQuote = FALSE;
        BOOL  fFoundNextCommand = FALSE;

        //
        // Copy all chars of the next command from pstrfile into wszline, 
        // condensing whitespace into single blanks and skipping comment 
        // lines.  
        // 

        for (;
            cchProcessed < cchFile &&
            !fFoundNextCommand        &&
            cchLine < MAX_TOKEN_LEN;
            cchProcessed++)
        {
            // 
            // If we're in a quoted string, copy everything verbatim until 
            // closing quote 
            //

            if (fInQuote)
            {
                if (pstrFile[cchProcessed] == '"')
                {
                    fInQuote = FALSE;
                }

                //
                // Check for error case of newline in string
                //

                if (pstrFile[cchProcessed] == '\n')
                {
                    hr = E_FAIL;
                    g_Log.Write(LOG_FAIL, "Newline in string constant");
                    break;
                }

                szLine[cchLine++] = pstrFile[cchProcessed];
                continue;
            }

            //
            // Not already in a quoted string.  See if we're entering one.  
            // 

            if (pstrFile[cchProcessed] == '"')
            {
                fInQuote = TRUE;
                szLine[cchLine++] = pstrFile[cchProcessed];
                continue;
            }

            //
            // Not in or starting a quoted string, so we're free to condense 
            // whitespace (including newlines) and ignore comment lines 
            // 

            if (isspace(pstrFile[cchProcessed]))
            {
                // 
                // Only copy this space char if none has been copied yet.  
                // Bump the line count if the whitespace char we're skipping 
                // is a newline.  
                //

                if (cchLine && szLine[cchLine - 1] != ' ')
                {
                    szLine[cchLine++] = ' ';
                }

                if (pstrFile[cchProcessed] == '\n')
                {
                    ulCurLine++;
                }
                continue;
            }

            if (pstrFile[cchProcessed] == ';')
            {
                //
                // Skip to end of line
                //

                cchProcessed += FindEol(
                                    &pstrFile[cchProcessed],
                                    cchFile - cchProcessed);

                // subtract 1 because for loop is going to add one

                cchProcessed--;
                continue;
            }

            //
            // Next char is not quote, semicolon (start of comment), or 
            // whitespace.  If we haven't copied anything yet, copy that char 
            // as the first of the line.  
            //

            if (!cchLine)
            {
                szLine[cchLine++] = pstrFile[cchProcessed];
                continue;
            }

            //
            // Since we've already started copying stuff, we want to quit when 
            // we get to the start of the next command, i.e., when we see a 
            // switch char '/' or '-'.  
            // 
            // Unfortunately these two characters also delimit the parts of a 
            // date, and we don't want to stop copying the line because of a 
            // date.  
            // 
            // Therefore we'll only stop copying if the next non whitespace 
            // character is not a number.  This imposes the constraints that 
            // no commands can be a number (i.e.  /10 cannot be a valid 
            // command) and that dates must use only digits (i.e.  10-Feb is 
            // not valid because we'll think -Feb is a command and only copy 
            // the 10).  
            // 
            // Note it isn't safe to check that the *previous* character was a 
            // digit and assume we're in a date, since a command with a 
            // numeric argument could be mistaken for a date.  
            // 
            //  /foo bar=10 /baz
            // 

            if (pstrFile[cchProcessed] == '/' ||
                pstrFile[cchProcessed] == '-')
            {
                CHAR ch;

                ch = FindNextNonSpace(
                            &pstrFile[cchProcessed + 1],
                            cchFile - (cchProcessed + 1));

                if (isdigit(ch))
                {
                    szLine[cchLine++] = pstrFile[cchProcessed];
                }
                else
                {
                    fFoundNextCommand = TRUE;
                    cchProcessed--; // because for loop will increment it
                }
            }
            else
            {
                szLine[cchLine++] = pstrFile[cchProcessed];
            }
        }
        BREAK_ON_FAILURE(hr);

        //
        // If we stopped copying not because we found the next command or hit 
        // the end of the file, then it's because we ran out of room in 
        // szLine, which is an error.  
        // 

        if (!fFoundNextCommand && cchProcessed < cchFile)
        {
            hr = E_FAIL;
            g_Log.Write(
                LOG_ERROR,
                "Line %u is longer than %u chars",
                ulCurLine,
                MAX_TOKEN_LEN);
            break;
        }

#ifdef UNICODE
        // 
        // Convert line to wchar and null terminate it.
        // 

        mbstowcs(wszLine, szLine, cchLine);
        wszLine[cchLine] = L'\0';

        // 
        // Expand environment variables
        // 

        ULONG cchRequired;

        cchRequired = ExpandEnvironmentStrings(
                            wszLine,
                            wszExpandedLine,
                            MAX_TOKEN_LEN+1);
#else
        CHAR szExpandedLine[MAX_TOKEN_LEN + 1];

        ULONG cchRequired;

        szLine[cchLine] = '\0';

        cchRequired = ExpandEnvironmentStrings(
                            szLine,
                            szExpandedLine,
                            MAX_TOKEN_LEN+1);

        mbstowcs(wszExpandedLine, szExpandedLine, MAX_TOKEN_LEN + 1);
#endif
        if (!cchRequired || cchRequired > MAX_TOKEN_LEN + 1)
        {
            hr = E_FAIL;
            g_Log.Write(LOG_FAIL, "ExpandEnvironmentStrings failed");
            break;
        }

        // 
        // Perform the command in wszExpandedLine, then loop around and
        // read the next command.
        // 

        if (SUCCEEDED(hr))
        {
            g_Log.Write(LOG_DEBUG, "DoAtSign: processing '%S'", wszExpandedLine);
            hr = ProcessCommandLine(wszExpandedLine);
        }
    }

    if (FAILED(hr))
    {
        g_Log.Write(LOG_ERROR, "File: %S Line: %u", tszFilename, ulCurLine);
    }

    if (pvBase)
    {
        fOk = UnmapViewOfFile(pvBase);

        if (!fOk)
        {
            hr = E_FAIL;
            g_Log.Write(LOG_ERROR, "UnmapViewOfFile (%u)", GetLastError());
        }
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   FindEol
//
//  Synopsis:   Return the number of characters between [pstr] and the end 
//              of the line.  
//
//  Arguments:  [pstr]         - non-terminated string
//              [cchRemaining] - characters till eof
//
//  Returns:    Character count
//
//  History:    04-20-95   davidmun   Created
//
//----------------------------------------------------------------------------

ULONG FindEol(CHAR *pstr, ULONG cchRemaining)
{
    CHAR   *pstrCur;
    ULONG   cchCur;

    for (pstrCur = pstr, cchCur = 0;
         cchCur < cchRemaining;
         cchCur++, pstrCur++)
    {
        if (*pstrCur == '\r' || *pstrCur == '\n')
        {
            return cchCur;
        }
    }
    return cchCur;
}



//+---------------------------------------------------------------------------
//
//  Function:   FindNextNonSpace
//
//  Synopsis:   Return the next non-whitespace character in [pstr], or space
//              if there are no non-whitespace characters in the next
//              [cchRemaining] characters.
//
//  Arguments:  [pstr]         - non-terminated string
//              [cchRemaining] - number of characters in string
//
//  Returns:    Character as described.
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CHAR FindNextNonSpace(CHAR *pstr, ULONG cchRemaining)
{
    CHAR   *pstrCur;
    ULONG   cchCur;

    for (pstrCur = pstr, cchCur = 0;
         cchCur < cchRemaining;
         cchCur++, pstrCur++)
    {
        if (!isspace(*pstrCur))
        {
            return *pstrCur;
        }
    }
    return ' ';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\consts.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       consts.cxx
//
//  Contents:   Storage for contants declared in consts.hxx
//              
//  History:    01-02-96   DavidMun   Created
//
//----------------------------------------------------------------------------

#include <headers.hxx>
#pragma hdrstop
#include "jt.hxx"

// 
// Tunable parameters
//

const ULONG INDENT = 4;             // spaces to indent each level of output
const ULONG TIME_NOW_INCREMENT = 60; // seconds that NOW is in future


const WCHAR *g_awszMonthAbbrev[12] =
{
    L"Jan",
    L"Feb",
    L"Mar",
    L"Apr",
    L"May",
    L"Jun",
    L"Jul",
    L"Aug",
    L"Sep",
    L"Oct",
    L"Nov",
    L"Dec"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\commands.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       commands.cxx
//
//  Contents:   Implementation of command-line switches.
//
//  History:    01-03-96   DavidMun   Created
//
//----------------------------------------------------------------------------

#include <headers.hxx>
#pragma hdrstop
#include "jt.hxx"
#include "..\..\inc\defines.hxx"

#define MAX_TRIGGER_STRING      160
#define DEFAULT_FETCH_COUNT     2
#define MSTASK_DLL              TEXT("MSTASK.DLL")

typedef HRESULT (WINAPI * PSETNSACCOUNTINFO)(LPCWSTR, LPCWSTR, LPCWSTR);
typedef HRESULT (WINAPI * PGETNSACCOUNTINFO)(LPCWSTR, DWORD, LPWSTR);



//+---------------------------------------------------------------------------
//
//  Function:   Abort
//
//  Synopsis:   Parse and execute the abort job command.
//
//  Arguments:  [ppwsz] - command line
//              [fJob]  - TRUE=>operate on job, FALSE=>operate on queue
//
//  Returns:    S_OK - command executed
//              E_*  - error logged
//
//  Modifies:   *[ppwsz]
//
//  History:    01-05-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT Abort(WCHAR **ppwsz, BOOL fJob)
{
    HRESULT     hr = S_OK;

    if (fJob)
    {
        g_Log.Write(LOG_TRACE, "Aborting job");

        hr = g_pJob->Terminate();

        if (FAILED(hr))
        {
            g_Log.Write(LOG_FAIL, "ITask::Terminate hr=%#010x", hr);
        }
    }
    else
    {
        g_Log.Write(LOG_TRACE, "Aborting Queue");

#ifdef NOT_YET
        hr = g_pJobQueue->Terminate();

        if (FAILED(hr))
        {
            g_Log.Write(LOG_FAIL, "ITaskQueue::Terminate hr=%#010x", hr);
        }
#endif // NOT_YET
        hr = E_NOTIMPL;
    }

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSage
//
//  Synopsis:   Execute the convert sage tasks to jobs command, but only
//              if this binary was built for and is running on Win9x.
//
//  Returns:    Built for or runnong on NT - S_OK
//              Otherwise - result of ConvertSageTasksToJobs()
//
//  History:    03-25-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT ConvertSage()
{
    HRESULT hr = S_OK;

#ifdef _CHICAGO_

    OSVERSIONINFO VersionInfo = { sizeof OSVERSIONINFO };

    GetVersionEx(&VersionInfo);

    if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
        hr = ConvertSageTasksToJobs();
    }
    else
    {
        g_Log.Write(
            LOG_WARN,
            "This command cannot be executed when running under Windows NT.");
    }
#else
    g_Log.Write(
        LOG_WARN,
        "This version of JT was built for NT and cannot execute this command.");
#endif // !_CHICAGO_
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SetNSAccountInfo
//
//  Synopsis:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------------------

HRESULT SetNSAccountInfo(WCHAR ** ppwsz)
{
#define SET_NS_ACCOUNT_INFO    "SetNetScheduleAccountInformation"

    HRESULT hr = S_OK;

#ifndef _CHICAGO_

    OSVERSIONINFO VersionInfo = { sizeof OSVERSIONINFO };

    GetVersionEx(&VersionInfo);

    if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        WCHAR wszAccount[MAX_USERNAME + 1];
        WCHAR wszPassword[MAX_PASSWORD + 1];

        hr = Expect(TKN_STRING, ppwsz, L"Account name");

        if (FAILED(hr))
        {
            return hr;
        }

        wcsncpy(wszAccount, g_wszLastStringToken,
                min(wcslen(g_wszLastStringToken) + 1, MAX_USERNAME));

        hr = Expect(TKN_STRING, ppwsz, L"Account password");

        if (FAILED(hr))
        {
            return hr;
        }

        wcsncpy(wszPassword, g_wszLastStringToken,
                min(wcslen(g_wszLastStringToken) + 1, MAX_PASSWORD));

        PSETNSACCOUNTINFO pSetNSAccountInfo;
        HMODULE           hMod = LoadLibrary(MSTASK_DLL);

        if (hMod == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            g_Log.Write(LOG_FAIL, "LoadLibrary hr=%#010x", hr);
            return hr;
        }
        else
        {
            pSetNSAccountInfo = (PSETNSACCOUNTINFO)GetProcAddress(
                                                        hMod,
                                                        SET_NS_ACCOUNT_INFO);

            if (pSetNSAccountInfo == NULL)
            {
                FreeLibrary(hMod);
                hr = HRESULT_FROM_WIN32(GetLastError());
                g_Log.Write(LOG_FAIL, "GetProcAddress hr=%#010x", hr);
                return hr;
            }
        }

        hr = pSetNSAccountInfo(
                    NULL,
                    lstrcmpiW(wszAccount, L"NULL") == 0 ? NULL : wszAccount,
                    wszPassword);

        if (FAILED(hr))
        {
            g_Log.Write(LOG_FAIL,
                "SetNetScheduleAccountInformation hr=%#010x", hr);
        }

        FreeLibrary(hMod);
    }
    else
    {
        g_Log.Write(
            LOG_WARN,
            "This command cannot be executed when running under Windows 95.");
    }
#else
    g_Log.Write(
        LOG_WARN,
        "This version of JT was built for Win95 and cannot execute this command.");
#endif // !_CHICAGO_
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   PrintNSAccountInfo
//
//  Synopsis:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------------------

HRESULT PrintNSAccountInfo(void)
{
#define GET_NS_ACCOUNT_INFO    "GetNetScheduleAccountInformation"

    HRESULT hr = S_OK;

#ifndef _CHICAGO_

    OSVERSIONINFO VersionInfo = { sizeof OSVERSIONINFO };

    GetVersionEx(&VersionInfo);

    if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        PGETNSACCOUNTINFO pGetNSAccountInfo;
        HMODULE           hMod = LoadLibrary(MSTASK_DLL);

        if (hMod == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            g_Log.Write(LOG_FAIL, "LoadLibrary hr=%#010x", hr);
            return hr;
        }
        else
        {
            pGetNSAccountInfo = (PGETNSACCOUNTINFO)GetProcAddress(
                                                        hMod,
                                                        GET_NS_ACCOUNT_INFO);

            if (pGetNSAccountInfo == NULL)
            {
                FreeLibrary(hMod);
                hr = HRESULT_FROM_WIN32(GetLastError());
                g_Log.Write(LOG_FAIL, "GetProcAddress hr=%#010x", hr);
                return hr;
            }
        }

        WCHAR wszAccount[MAX_USERNAME + 1];
        DWORD ccAccount = MAX_USERNAME + 1;

        hr = pGetNSAccountInfo(NULL, ccAccount, wszAccount);

        if (SUCCEEDED(hr))
        {
            if (hr == S_FALSE)
            {
                g_Log.Write(LOG_TRACE, "NetSchedule account not specified");
            }
            else
            {
                g_Log.Write(LOG_TRACE,
                    "NetSchedule account name = '%S'", wszAccount);
            }
        }
        else
        {
            g_Log.Write(LOG_FAIL,
                "GetNetScheduleAccountInformation hr=%#010x", hr);
        }

        FreeLibrary(hMod);
    }
    else
    {
        g_Log.Write(
            LOG_WARN,
            "This command cannot be executed when running under Windows 95.");
    }
#else
    g_Log.Write(
        LOG_WARN,
        "This version of JT was built for Win95 and cannot execute this command.");
#endif // !_CHICAGO_
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   CreateTrigger
//
//  Synopsis:   Parse and execute the create trigger command.
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    S_OK - created trigger
//              E_*  - error logged
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT CreateTrigger(WCHAR **ppwsz, BOOL fJob)
{
    HRESULT         hr = S_OK;
    CTrigProp       TriggerProps;
    USHORT          usTrigger;
    SpIJobTrigger   spTrigger;

    do
    {
        hr = TriggerProps.Parse(ppwsz);
        BREAK_ON_FAILURE(hr);

        //
        // Ask job or queue to create trigger
        //

        if (fJob)
        {
            hr = g_pJob->CreateTrigger(&usTrigger, &spTrigger);
            LOG_AND_BREAK_ON_FAIL(hr, "ITask::CreateTrigger");
        }
        else
        {
#ifdef NOT_YET
            hr = g_pJobQueue->CreateTrigger(&usTrigger, &spTrigger);
            LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::CreateTrigger");
#endif // NOT_YET
            hr = E_NOTIMPL;
        }

        g_Log.Write(LOG_TRACE, "Created trigger %u", usTrigger);

        //
        // Now set the trigger's properties to the values we parsed already
        //

        hr = TriggerProps.SetActual(spTrigger);
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   DeleteTrigger
//
//  Synopsis:   Parse and execute the delete trigger command.
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    S_OK - trigger deleted
//              E_*  - error logged
//
//  Modifies:   *[ppwsz]
//
//  History:    01-05-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT DeleteTrigger(WCHAR **ppwsz, BOOL fJob)
{
    HRESULT hr = S_OK;
    USHORT  usTrigger = 0;

    do
    {
        if (PeekToken(ppwsz) == TKN_NUMBER)
        {
            GetToken(ppwsz);
            usTrigger = (SHORT) g_ulLastNumberToken;
        }

        g_Log.Write(LOG_TRACE, "Deleting trigger %u", usTrigger);

        if (fJob)
        {
            hr = g_pJob->DeleteTrigger(usTrigger);
            LOG_AND_BREAK_ON_FAIL(hr, "ITask::DeleteTrigger");
        }
        else
        {
#ifdef NOT_YET
            hr = g_pJobQueue->DeleteTrigger(usTrigger);
            LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::DeleteTrigger");
#endif // NOT_YET
            hr = E_NOTIMPL;
        }
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   EditJob
//
//  Synopsis:   Invoke the edit job command
//
//  Arguments:  [ppwsz] - command line
//              [fJob]  - TRUE=>edit g_pJob, FALSE=>edit a job in g_pJobQueue
//
//  Returns:    S_OK - UI invoked
//              E_*  - error logged
//
//  History:    01-11-96   DavidMun   Created
//              06-28-96   DavidMun   Support individual prop pages
//
//----------------------------------------------------------------------------

HRESULT EditJob(WCHAR **ppwsz, BOOL fJob)
{
    HRESULT             hr = S_OK;
    SpIJob              spJob;
    ITask              *pJob;   // Do not Release this
    SpIUnknown          spunkJob;
    SpIProvideTaskPage  spProvideTaskPage;
    TOKEN               tkn;
    ULONG               ulType = 0;
    BOOL                fPersist = TRUE;
    PROPSHEETHEADER     psh;
    HPROPSHEETPAGE      hPage;
    LONG                lResult;

    ZeroMemory(&psh, sizeof(psh));

    do
    {
        if (fJob)
        {
            pJob = g_pJob;
        }
        else
        {
#ifdef NOT_YET
            hr = Expect(TKN_STRING, ppwsz, L"job name");
            BREAK_ON_FAILURE(hr);

            hr = g_pJobQueue->GetTask(
                                g_wszLastStringToken,
                                IID_IUnknown,
                                &spunkJob);
            LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::GetTask");

            hr = spunkJob->QueryInterface(IID_ITask, (VOID**)(ITask**)&spJob);
            LOG_AND_BREAK_ON_FAIL(hr, "QI for ITask");

            pJob = spJob;
#endif // NOT_YET
            hr = E_NOTIMPL;
        }

        //
        // See if the optional property sheet page argument has been
        // specified.  If so, retrieve and open just that page, otherwise use
        // the EditJob method to open all the pages.
        //

        tkn = PeekToken(ppwsz);

        if (tkn == TKN_NUMBER)
        {
            GetToken(ppwsz);
            ulType = g_ulLastNumberToken;

            //
            // Now see if the optional value for fPersistChanges was
            // provided.
            //

            tkn = PeekToken(ppwsz);

            if (tkn == TKN_STRING)
            {
                GetToken(ppwsz);

                fPersist = g_wszLastStringToken[0] == L't' ||
                           g_wszLastStringToken[0] == L'T';
            }

            //
            // Get the interface that has the method that returns a page.
            // Then retrieve the page the user asked for.
            //

            hr = pJob->QueryInterface(
                            IID_IProvideTaskPage,
                            (VOID**)(IProvideTaskPage**)&spProvideTaskPage);
            LOG_AND_BREAK_ON_FAIL(hr, "QI for IProvideTaskPage");

            g_Log.Write(
                LOG_TRACE,
                "Opening page %u, changes will%s be persisted",
                ulType,
                fPersist ? "" : " not");
            hr = spProvideTaskPage->GetPage((TASKPAGE)ulType, fPersist, &hPage);
            LOG_AND_BREAK_ON_FAIL(hr, "IProvideTaskPage::GetPage");

            //
            // Now that we have the page, display it in its very own
            // property sheet.
            //

            psh.dwSize = sizeof(PROPSHEETHEADER);
            psh.dwFlags = PSH_DEFAULT;
            psh.hwndParent = NULL;
            psh.hInstance = NULL;
            psh.pszCaption = TEXT("jt job object");
            psh.phpage = &hPage;
            psh.nPages = 1;

            lResult = PropertySheet(&psh);

            if (lResult == -1)
            {
                g_Log.Write(LOG_FAIL, "PropertySheet (%u)", GetLastError());
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            hr = pJob->EditWorkItem(NULL, TRUE);
            LOG_AND_BREAK_ON_FAIL(hr, "ITask::EditWorkItem");
        }
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   EnumClone
//
//  Synopsis:   Invoke the IEnumJobs::Clone command
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    S_OK         - a slot has been filled with cloned enumerator
//              E_INVALIDARG - bad slot number
//
//  Modifies:   g_apEnumJobs
//
//  History:    01-30-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT EnumClone(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;
    ULONG   idxDestSlot;
    ULONG   idxSourceSlot;

    do
    {
        hr = GetAndPrepareEnumeratorSlot(ppwsz, &idxDestSlot);
        BREAK_ON_FAILURE(hr);

        hr = GetEnumeratorSlot(ppwsz, &idxSourceSlot);
        BREAK_ON_FAILURE(hr);

        hr = VerifySlotFilled(idxSourceSlot);
        BREAK_ON_FAILURE(hr);

        g_Log.Write(
            LOG_TRACE,
            "Cloning enumerator in slot %u into slot %u",
            idxSourceSlot,
            idxDestSlot);

        hr = g_apEnumJobs[idxSourceSlot]->Clone(&g_apEnumJobs[idxDestSlot]);

        if (FAILED(hr))
        {
            g_Log.Write(
                LOG_FAIL,
                "IEnumJobs::Clone hr=%#010x",
                hr);
        }
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   EnumNext
//
//  Synopsis:   Invoke the IEnumJobs::Next command
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    S_OK         - Next performed successfully
//              E_INVALIDARG - bad slot number
//
//  History:    01-30-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT EnumNext(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;
    ULONG   idxSlot;
    LPWSTR *ppwszFetched;
    LPWSTR *ppwszCur;
    ULONG   cFetched;
    ULONG   i;

    do
    {
        hr = GetEnumeratorSlot(ppwsz, &idxSlot);
        BREAK_ON_FAILURE(hr);

        hr = VerifySlotFilled(idxSlot);
        BREAK_ON_FAILURE(hr);

        hr = Expect(TKN_NUMBER, ppwsz, L"number of items to enumerate");
        BREAK_ON_FAILURE(hr);

        g_Log.Write(
            LOG_TRACE,
            "Enumerating next %u items using enumerator in slot %u",
            g_ulLastNumberToken,
            idxSlot);

        hr = g_apEnumJobs[idxSlot]->Next(g_ulLastNumberToken, &ppwszFetched, &cFetched);
        LOG_AND_BREAK_ON_FAIL(hr, "IEnumJobs::Next");

        if (hr == S_FALSE)
        {
            g_Log.Write(LOG_INFO, "IEnumJobs::Next returned S_FALSE");
        }

        if (cFetched != g_ulLastNumberToken)
        {
            g_Log.Write(
                    LOG_INFO,
                    "IEnumJobs::Next fetched only %u jobs",
                    cFetched);
        }

        for (i = 0, ppwszCur = ppwszFetched; i < cFetched; i++, ppwszCur++)
        {
            g_Log.Write(LOG_TEXT, "%u:  %S", idxSlot, *ppwszCur);
            CoTaskMemFree(*ppwszCur);
        }
        CoTaskMemFree(ppwszFetched);
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   EnumReset
//
//  Synopsis:   Invoke the IEnumJobs::Reset command
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    S_OK         - Reset performed successfully
//              E_INVALIDARG - bad slot number
//
//  History:    01-30-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT EnumReset(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;
    ULONG   idxSlot;

    do
    {
        hr = GetEnumeratorSlot(ppwsz, &idxSlot);
        BREAK_ON_FAILURE(hr);

        hr = VerifySlotFilled(idxSlot);
        BREAK_ON_FAILURE(hr);

        g_Log.Write(LOG_TRACE, "Resetting enumerator in slot %u", idxSlot);

        hr = g_apEnumJobs[idxSlot]->Reset();
        LOG_AND_BREAK_ON_FAIL(hr, "IEnumJobs::Reset");
    }
    while (0);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   EnumSkip
//
//  Synopsis:   Invoke the IEnumJobs::Skip command
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    S_OK         - Skip performed successfully
//              E_INVALIDARG - bad slot number
//
//  History:    01-30-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT EnumSkip(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;
    ULONG   idxSlot;

    do
    {
        hr = GetEnumeratorSlot(ppwsz, &idxSlot);
        BREAK_ON_FAILURE(hr);

        hr = VerifySlotFilled(idxSlot);
        BREAK_ON_FAILURE(hr);

        hr = Expect(TKN_NUMBER, ppwsz, L"number of items to skip");
        BREAK_ON_FAILURE(hr);

        g_Log.Write(
            LOG_TRACE,
            "Skipping next %u items using enumerator in slot %u",
            g_ulLastNumberToken,
            idxSlot);

        hr = g_apEnumJobs[idxSlot]->Skip(g_ulLastNumberToken);
        LOG_AND_BREAK_ON_FAIL(hr, "IEnumJobs::Skip");

        if (hr == S_FALSE)
        {
            g_Log.Write(LOG_INFO, "IEnumJobs::Skip returned S_FALSE");
        }
    }
    while (0);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   Load
//
//  Synopsis:   Load the job or queue file specified on the command line
//              into the global job or queue object.
//
//  Arguments:  [ppwsz]        - command line.
//              [szJobOrQueue] - "Job" or "Queue"
//              [fJob]         - TRUE=>use global job, FALSE=>use global queue
//
//  Returns:    S_OK - job or queue loaded
//              E_*  - error logged
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT Load(WCHAR **ppwsz, CHAR *szJobOrQueue, BOOL fJob)
{
    HRESULT         hr = S_OK;
    SpIPersistFile  spPersistFile;

    do
    {
        hr = GetFilename(ppwsz, L"file to load");
        BREAK_ON_FAILURE(hr);

        g_Log.Write(
            LOG_TRACE,
            "Loading %s %S",
            szJobOrQueue,
            g_wszLastStringToken);

        if (fJob)
        {
            g_pJob->QueryInterface(
                        IID_IPersistFile,
                        (VOID**)(IPersistFile**)&spPersistFile);
            LOG_AND_BREAK_ON_FAIL(hr, "ITask::QI(IPersistFile)");
        }
        else
        {
            g_pJobQueue->QueryInterface(
                        IID_IPersistFile,
                        (VOID**)(IPersistFile**)&spPersistFile);
            LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::QI(IPersistFile)");
        }

        DWORD ulTicks = GetTickCount();

        hr = spPersistFile->Load(
                    g_wszLastStringToken,
                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE);

        ulTicks = GetTickCount() - ulTicks;
        g_Log.Write(LOG_PERF, "Load took %lu ms", ulTicks);

        LOG_AND_BREAK_ON_FAIL(hr, "IPersistFile::Load");
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   PrintAll
//
//  Synopsis:   Print all properties of global job or queue.
//
//  Arguments:  [ppwsz] - command line
//              [fJob]  - TRUE=>use global job, FALSE=>use global queue
//
//  Returns:    S_OK - command executed
//              E_*  - error logged
//
//  Modifies:   *[ppwsz]
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT PrintAll(WCHAR **ppwsz, BOOL fJob)
{
    HRESULT     hr = S_OK;

    do
    {
        if (!fJob)
        {
            g_Log.Write(LOG_ERROR, "this command is not yet implemented");
            break;
        }
        else
        {
            hr = DumpJob(g_pJob);
            BREAK_ON_FAILURE(hr);

            hr = DumpJobTriggers(g_pJob);
        }
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   PrintRunTimes
//
//  Synopsis:   Parse and execute the print job run times command
//
//  Arguments:  [ppwsz] - command line
//              [fJob]  - TRUE=>use global job, FALSE=>use global queue
//
//  Returns:    S_OK - command executed
//              E_*  - error logged
//
//  Modifies:   *[ppwsz]
//
//  History:    01-05-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT PrintRunTimes(WCHAR **ppwsz, BOOL fJob)
{
    HRESULT         hr = S_OK;
    TOKEN           tkn;
    USHORT          cRuns = 0;
    SYSTEMTIME      stNow;
    LPSYSTEMTIME    pstRuns = NULL;
    USHORT          i;

    do
    {
        tkn = PeekToken(ppwsz);

        if (tkn == TKN_NUMBER)
        {
            GetToken(ppwsz);
            cRuns = (USHORT) g_ulLastNumberToken;
        }

        GetLocalTime(&stNow);

        //
        // If the optional number of runs was not specified or was 0,
        // print remaining runs for today only.
        //

        if (cRuns == 0)
        {
            SYSTEMTIME stEnd;

            stEnd = stNow;
            stEnd.wHour = 23;
            stEnd.wMinute = 59;

            if (fJob)
            {
                hr = g_pJob->GetRunTimes(&stNow, &stEnd, &cRuns, &pstRuns);
                LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetRunTimes");
            }
            else
            {
#ifdef NOT_YET
                hr = g_pJobQueue->GetRunTimes(&stNow, &stEnd, &cRuns, &pstRuns);
                LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::GetRunTimes");
#endif // NOT_YET
                hr = E_NOTIMPL;
            }

            if (cRuns == 0)
            {
                g_Log.Write(LOG_TEXT, "No runs are scheduled for today.");
                break;
            }

            g_Log.Write(LOG_TEXT, "The remaining %u run", cRuns);
            g_Log.Write(LOG_TEXT, "times for today:");
            g_Log.Write(LOG_TEXT, "--------------------");
        }
        else
        {
            //
            // cRuns > 0.  Get at most the next cRuns run times.
            //

            if (fJob)
            {
                hr = g_pJob->GetRunTimes(&stNow, NULL, &cRuns, &pstRuns);
                LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetRunTimes");
            }
            else
            {
#ifdef NOT_YET
                hr = g_pJobQueue->GetRunTimes(&stNow, NULL, &cRuns, &pstRuns);
                LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetRunTimes");
#endif // NOT_YET
                hr = E_NOTIMPL;
            }

            if (cRuns == 0)
            {
                g_Log.Write(LOG_TEXT, "No runs are scheduled.  hr = %#lx", hr);
                break;
            }

            g_Log.Write(LOG_TEXT, "ITask::GetRunTimes succeeded, hr = %#lx", hr);
            g_Log.Write(LOG_TEXT, "The next %u run times:", cRuns);
            g_Log.Write(LOG_TEXT, "----------------------");
        }

        for (i = 0; i < cRuns; i++)
        {
            g_Log.Write(
                LOG_TEXT,
                "%02d/%02d/%d at %02d:%02d:%02d",
                pstRuns[i].wMonth,
                pstRuns[i].wDay,
                pstRuns[i].wYear,
                pstRuns[i].wHour,
                pstRuns[i].wMinute,
                pstRuns[i].wSecond);
        }
    }
    while (0);

    CoTaskMemFree(pstRuns);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   PrintTrigger
//
//  Synopsis:   Print one or more trigger's properties
//
//  Arguments:  [ppwsz] - command line
//              [fJob]  - TRUE=>use g_pJob, FALSE=>use g_pJobQueue
//
//  Returns:    S_OK - trigger(s) printed
//              E_*  - error logged
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT PrintTrigger(WCHAR **ppwsz, BOOL fJob)
{
    HRESULT         hr = S_OK;
    USHORT          usTrigger = 0;
    BOOL            fPrintAll = FALSE;
    SpIJobTrigger   spTrigger;

    do
    {
        if (PeekToken(ppwsz) == TKN_NUMBER)
        {
            GetToken(ppwsz);
            usTrigger = (USHORT) g_ulLastNumberToken;
        }
        else
        {
            fPrintAll = TRUE;
        }

        if (fPrintAll)
        {
            hr = DumpTriggers(fJob);
        }
        else
        {
            hr = DumpTrigger(fJob, usTrigger);
        }
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   PrintTriggerStrings
//
//  Synopsis:   Parse and execute the command to print one or all trigger
//              strings for a job.
//
//  Arguments:  [ppwsz] - command line
//              [fJob]  - TRUE=>use g_pJob, FALSE=>use g_pJobQueue
//
//  Returns:    S_OK - string(s) printed
//              E_*  - error logged
//
//  Modifies:   *[ppwsz]
//
//  History:    01-05-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT PrintTriggerStrings(WCHAR **ppwsz, CHAR *szJobOrQueue, BOOL fJob)
{
    HRESULT hr = S_OK;
    TOKEN   tkn;
    BOOL    fAllTriggers = TRUE;
    USHORT  usTrigger;
    USHORT  cTriggers;
    SHORT   i;
    WCHAR * pwszTriggerString;

    do
    {
        tkn = PeekToken(ppwsz);

        if (tkn == TKN_NUMBER)
        {
            GetToken(ppwsz);
            fAllTriggers = FALSE;
            usTrigger = (USHORT) g_ulLastNumberToken;
        }

        if (fJob)
        {
            hr = g_pJob->GetTriggerCount(&cTriggers);
            LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetTriggerCount");
        }
        else
        {
#ifdef NOT_YET
            hr = g_pJobQueue->GetTriggerCount(&cTriggers);
            LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::GetTriggerCount");
#endif // NOT_YET
            hr = E_NOTIMPL;
        }

        if (!cTriggers)
        {
            g_Log.Write(LOG_TEXT, "There are no triggers on the %s", szJobOrQueue);
            break;
        }

        if (fAllTriggers)
        {
            g_Log.Write(LOG_TEXT, "All %u triggers on %s:", cTriggers, szJobOrQueue);

            g_Log.Write(LOG_TEXT, "Index    Value");
            g_Log.Write(LOG_TEXT, "-----    -----------------------------------------------------");

            for (i = 0; i < cTriggers; i++)
            {
                if (fJob)
                {
                    hr = g_pJob->GetTriggerString(i, &pwszTriggerString);
                    LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetTriggerString");
                }
                else
                {
#ifdef NOT_YET
                    hr = g_pJobQueue->GetTriggerString(i, &pwszTriggerString);
                    LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetTriggerString");
#endif // NOT_YET
                    hr = E_NOTIMPL;
                }

                g_Log.Write(LOG_TEXT, "% 5d    %S", i, pwszTriggerString);

                CoTaskMemFree(pwszTriggerString);

                if (i < cTriggers - 1)
                {
                    g_Log.Write(LOG_TEXT, "");
                }
            }
        }
        else
        {
            g_Log.Write(LOG_TEXT, "Trigger %u:", usTrigger);

            if (fJob)
            {
                hr = g_pJob->GetTriggerString(usTrigger,
                                              &pwszTriggerString);
                LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetTriggerString");
            }
            else
            {
#ifdef NOT_YET
                hr = g_pJobQueue->GetTriggerString(usTrigger,
                                                   &pwszTriggerString);
                LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::GetTriggerString");
#endif // NOT_YET
                hr = E_NOTIMPL;
            }

            g_Log.Write(LOG_TEXT, "%S", pwszTriggerString);

            CoTaskMemFree(pwszTriggerString);
        }
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   Run
//
//  Synopsis:   Run job or queue object.
//
//  Arguments:  [fJob]  - TRUE=>use g_pJob, FALSE=>use g_pJobQueue
//
//  Returns:    Result of ITask[Queue]::Run
//
//  History:    01-11-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT Run(BOOL fJob)
{
    HRESULT hr = S_OK;

    if (fJob)
    {
        g_Log.Write(LOG_TRACE, "Running job");
        hr = g_pJob->Run();

        if (FAILED(hr))
        {
            g_Log.Write(LOG_FAIL, "ITask::Run hr=%#010x", hr);
        }
    }
    else
    {
#ifdef NOT_YET
        g_Log.Write(LOG_TRACE, "Running queue");
        hr = g_pJobQueue->Run();

        if (FAILED(hr))
        {
            g_Log.Write(LOG_FAIL, "ITaskQueue::Run hr=%#010x", hr);
        }
#endif // NOT_YET
        hr = E_NOTIMPL;
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   Save
//
//  Synopsis:   Persist the global job or queue to the file specified in
//              the command line
//
//  Arguments:  [ppwsz]        - command line.
//              [szJobOrQueue] - "Job" or "Queue"
//              [fJob]         - TRUE=>use global job, FALSE=>use global queue
//
//  Returns:    S_OK - job or queue persisted
//              E_*  - error logged
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT Save(WCHAR **ppwsz, CHAR *szJobOrQueue, BOOL fJob)
{
    HRESULT         hr = S_OK;
    TOKEN           tkn;
    WCHAR          *pwszFilename = NULL;
    SpIPersistFile  spPersistFile;

    do
    {
        tkn = PeekToken(ppwsz);

        if (tkn == TKN_STRING)
        {
            hr = GetFilename(ppwsz, L"filename for save");
            BREAK_ON_FAILURE(hr);

            pwszFilename = g_wszLastStringToken;

            g_Log.Write(LOG_TRACE, "Saving %s to %S", szJobOrQueue, g_wszLastStringToken);
        }
        else
        {
            g_Log.Write(LOG_TRACE, "Saving %s", szJobOrQueue);
        }

        if (fJob)
        {
            g_pJob->QueryInterface(
                        IID_IPersistFile,
                        (VOID**)(IPersistFile**)&spPersistFile);
            LOG_AND_BREAK_ON_FAIL(hr, "ITask::QI(IPersistFile)");
        }
        else
        {
            g_pJobQueue->QueryInterface(
                        IID_IPersistFile,
                        (VOID**)(IPersistFile**)&spPersistFile);
            LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::QI(IPersistFile)");
        }

        DWORD ulTicks = GetTickCount();

        hr = spPersistFile->Save(pwszFilename, TRUE);

        ulTicks = GetTickCount() - ulTicks;
        g_Log.Write(LOG_PERF, "Save took %lu ms", ulTicks);

        LOG_AND_BREAK_ON_FAIL(hr, "IPersistFile::Save");
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SchedActivate
//
//  Synopsis:   Perform activate job/queue command.
//
//  Arguments:  [ppwsz] - commandline.
//
//  Returns:    S_OK - activated job or queue
//              E_*  - error logged
//
//  History:    01-11-96   DavidMun   Created
//
//  Notes:      This is the command-line front end to the utility routine
//              Activate.  That routine is also called by other routines;
//              see SchedEnum.
//
//----------------------------------------------------------------------------

HRESULT SchedActivate(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;
    BOOL    fJob;

    do
    {
        hr = Expect(TKN_STRING, ppwsz, L"job or queue filename");
        BREAK_ON_FAILURE(hr);

        hr = Activate(g_wszLastStringToken, &g_pJob, &g_pJobQueue, &fJob);
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SchedAddJob
//
//  Synopsis:   Perform add job command.
//
//  Arguments:  [ppwsz] - commandline.
//
//  Returns:    S_OK - added job
//              E_*  - error logged
//
//  History:    01-11-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SchedAddJob(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;

    do
    {
        //
        // Note this filename may be a path relative to the job folder, so we
        // don't want to expand it to a full path name by calling GetFilename.
        // Just read it as a string instead.
        //

        hr = Expect(TKN_STRING, ppwsz, L"job filename");
        BREAK_ON_FAILURE(hr);

        g_Log.Write(LOG_TRACE, "Adding job '%S'", g_wszLastStringToken);

        hr = g_pJobScheduler->AddWorkItem(g_wszLastStringToken, g_pJob);
        LOG_AND_BREAK_ON_FAIL(hr, "ITaskScheduler::AddWorkItemn");
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SchedCreateEnum
//
//  Synopsis:   Create a new jobs folder enumerator in the slot specified
//              by command line
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    S_OK - new enumerator created
//              E_INVALIDARG - command line has bad slot number
//              E_* - from ITaskScheduler::EnumJobs
//
//  Modifies:   g_apEnumJobs
//
//  History:    01-30-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SchedCreateEnum(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;
    ULONG   idxSlot;

    do
    {
        hr = GetAndPrepareEnumeratorSlot(ppwsz, &idxSlot);
        BREAK_ON_FAILURE(hr);

        g_Log.Write(LOG_TRACE, "Creating new enumerator in slot %u", idxSlot);
        hr = g_pJobScheduler->Enum(&g_apEnumJobs[idxSlot]);
        LOG_AND_BREAK_ON_FAIL(hr, "ITaskScheduler::Enum");
    }
    while (0);
    return hr;
}





//+---------------------------------------------------------------------------
//
//  Function:   SchedDelete
//
//  Synopsis:   Perform delete job/queue command.
//
//  Arguments:  [ppwsz] - commandline.
//
//  Returns:    S_OK - deleted job or queue
//              E_*  - error logged
//
//  History:    01-11-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SchedDelete(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;

    do
    {
        hr = Expect(TKN_STRING, ppwsz, L"job or queue filename to delete");
        BREAK_ON_FAILURE(hr);

        g_Log.Write(LOG_TRACE, "Deleting '%S'", g_wszLastStringToken);

        hr = g_pJobScheduler->Delete(g_wszLastStringToken);
        LOG_AND_BREAK_ON_FAIL(hr, "ITaskScheduler::Delete");
    }
    while (0);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   SchedEnum
//
//  Synopsis:   Perform enumerate jobs/queues command.
//
//  Arguments:  [ppwsz] - commandline.
//
//  Returns:    S_OK - job/queue names enumerated
//              E_*  - error logged
//
//  History:    01-12-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SchedEnum(WCHAR **ppwsz)
{
    HRESULT     hr = S_OK;
    SpIEnumJobs spEnum;
    TOKEN       tkn;
    ULONG       i;
    ULONG       cToFetch = DEFAULT_FETCH_COUNT;
    ULONG       cFetched;
    BOOL        fPrint = FALSE;

    do
    {
        g_Log.Write(LOG_TRACE, "Enumerating jobs and queues");

        tkn = PeekToken(ppwsz);

        while (tkn == TKN_NUMBER || tkn == TKN_STRING)
        {
            GetToken(ppwsz);

            if (tkn == TKN_NUMBER)
            {
                cToFetch = g_ulLastNumberToken;
            }
            else
            {
                if (towupper(g_wszLastStringToken[0]) == L'P')
                {
                    fPrint = TRUE;
                }
            }

            tkn = PeekToken(ppwsz);
        }

        hr = g_pJobScheduler->Enum(&spEnum);
        LOG_AND_BREAK_ON_FAIL(hr, "ITaskScheduler::Enum");

        do
        {
            LPWSTR *ppwszFetched;
            LPWSTR *ppwszCur;

            hr = spEnum->Next(cToFetch, &ppwszFetched, &cFetched);
            LOG_AND_BREAK_ON_FAIL(hr, "IEnumJobs::Next");

            for (i = 0, ppwszCur = ppwszFetched; i < cFetched; i++, ppwszCur++)
            {
                if (fPrint)
                {
                    SpIJob      spJob;
                    SpIUnknown  spQueue;
                    BOOL        fJob;

                    hr = Activate(*ppwszCur, &spJob, &spQueue, &fJob);

                    if (SUCCEEDED(hr))
                    {
                        if (fJob)
                        {
                            DumpJob(spJob);
                            DumpJobTriggers(spJob);
                        }
                        else
                        {
                            // BUGBUG call DumpQueue here
                            g_Log.Write(
                                LOG_WARN,
                                "Ignoring %S: DumpQueue not implemented",
                                *ppwszCur);
                        }
                    }
                    g_Log.Write(LOG_TEXT, "");
                    g_Log.Write(LOG_TEXT, "");
                }
                else
                {
                    g_Log.Write(LOG_TEXT, "  %S", *ppwszCur);
                }
                CoTaskMemFree(*ppwszCur);
            }
            CoTaskMemFree(ppwszFetched);
        } while (cFetched);
    }
    while (0);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetCredentials
//
//  Synopsis:   Retrieve the account name associated with the job's
//              credentials.
//
//  Returns:    Result of GetTargetComputer call.
//
//  History:    06-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT GetCredentials(void)
{
    HRESULT hr;
    LPWSTR  pwszAccount;

    if (g_pJob == NULL)
    {
        g_Log.Write(
            LOG_FAIL,
            "A job object must be specified to get account information.");
        return(E_FAIL);
    }

    hr = g_pJob->GetAccountInformation(&pwszAccount);

    if (FAILED(hr))
    {
        g_Log.Write(LOG_FAIL,
            "ITaskScheduler::GetAccountInformation hr=%#010x", hr);
    }
    else
    {
        g_Log.Write(LOG_TRACE, "Credential account name = '%S'", pwszAccount);
        CoTaskMemFree(pwszAccount);
    }

    return(hr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SchedGetMachine
//
//  Synopsis:   Perform Get Machine command (print target computer).
//
//  Returns:    Result of GetTargetComputer call.
//
//  History:    06-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SchedGetMachine()
{
    HRESULT hr;
    LPWSTR  pwszComputer;

    hr = g_pJobScheduler->GetTargetComputer(&pwszComputer);

    if (FAILED(hr))
    {
        g_Log.Write(LOG_FAIL, "ITaskScheduler::GetTargetComputer hr=%#010x", hr);
    }
    else
    {
        g_Log.Write(LOG_TRACE, "TargetComputer = '%S'", pwszComputer);
        CoTaskMemFree(pwszComputer);
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SchedIsJobOrQueue
//
//  Synopsis:   Call the ITaskScheduler::IsJob and IsQueue commands on the
//              specified filename and report the results.
//
//  Arguments:  [ppwsz] - commandline.
//
//  Returns:    S_OK - methods called
//              E_*  - invalid commandline
//
//  History:    03-11-96   DavidMun   Created
//
//  Notes:      Don't consider errors returned by the IsJob and IsQueue
//              methods as errors in calling this routine.  That would
//              halt a script that purposely gives them bad paths.
//
//----------------------------------------------------------------------------

HRESULT SchedIsJobOrQueue(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;

    do
    {
        hr = Expect(TKN_STRING, ppwsz, L"filename to test");
        BREAK_ON_FAILURE(hr);

        hr = g_pJobScheduler->IsOfType(g_wszLastStringToken, IID_ITask);

        g_Log.Write(
            LOG_TRACE,
            "ITaskScheduler::IsOfType(%S) returned %#010x",
            g_wszLastStringToken,
            hr);

#ifdef NOT_YET
        hr = g_pJobScheduler->IsQueue(g_wszLastStringToken);

        g_Log.Write(
            LOG_TRACE,
            "ITaskScheduler::IsQueue(%S) returned %#010x",
            g_wszLastStringToken,
            hr);
#endif

        hr = S_OK;
    }
    while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SchedNewJob
//
//  Synopsis:   Perform new job command.
//
//  Arguments:  [ppwsz] - commandline.
//
//  Returns:    S_OK - created new job
//              E_*  - error logged
//
//  History:    01-11-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SchedNewJob(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;
    SpIJob  spNewJob;

    do
    {
        hr = Expect(TKN_STRING, ppwsz, L"job filename");
        BREAK_ON_FAILURE(hr);

        g_Log.Write(LOG_TRACE, "Creating new job '%S'", g_wszLastStringToken);

        DWORD ulTicks = GetTickCount();

        hr = g_pJobScheduler->NewWorkItem(
                    g_wszLastStringToken,
                    CLSID_CTask,
                    IID_ITask,
                    (IUnknown**)(ITask**)&spNewJob);

        ulTicks = GetTickCount() - ulTicks;
        g_Log.Write(LOG_PERF, "NewWorkItem call took %lu ms", ulTicks);

        LOG_AND_BREAK_ON_FAIL(hr, "ITaskScheduler::NewWorkItem");

        //
        // Replace the global job object with the new one.
        //

        g_pJob->Release();
        spNewJob.Transfer(&g_pJob);
    }
    while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SetCredentials
//
//  Synopsis:   Call SetAccountInformation to set the job credentials.
//
//  Arguments:  [ppwsz] - command line.
//
//  Returns:    Result of calling ITaskScheduler::SetAccountInformation
//
//  History:    06-22-96   MarkBl     Created
//              07-22-96   DavidMun   Method now takes just two arguments
//
//----------------------------------------------------------------------------

HRESULT SetCredentials(WCHAR **ppwsz)
{
    WCHAR        wszAccountNew[MAX_USERNAME + 1]; //see sched\inc\defines.hxx
    WCHAR        wszPasswordNew[MAX_PASSWORD + 1];
    HRESULT      hr;
    TOKEN        tkn;

    ZeroMemory(wszAccountNew, sizeof(wszAccountNew));
    ZeroMemory(wszPasswordNew, sizeof(wszPasswordNew));

    do
    {
        hr = Expect(TKN_STRING, ppwsz, L"new account name");
        BREAK_ON_FAILURE(hr);

        wcsncpy(wszAccountNew,
                g_wszLastStringToken,
                min(wcslen(g_wszLastStringToken) + 1, MAX_USERNAME));
        wszAccountNew[MAX_USERNAME] = L'\0';

        hr = Expect(TKN_STRING, ppwsz, L"new account password");
        BREAK_ON_FAILURE(hr);

        wcsncpy(wszPasswordNew,
                g_wszLastStringToken,
                min(wcslen(g_wszLastStringToken) + 1, MAX_PASSWORD));
        wszPasswordNew[MAX_PASSWORD] = L'\0';

        g_Log.Write(LOG_TRACE, "Setting account information");
        hr = g_pJob->SetAccountInformation(wszAccountNew,
                                           wcscmp(wszPasswordNew, L"NULL") ? wszPasswordNew : 
                                                                             NULL);

        if (FAILED(hr))
        {
            g_Log.Write(
                LOG_FAIL,
                "ITaskScheduler::SetAccountInformation hr=%#010x",
                hr);
        }
    } while (0);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   SchedSetMachine
//
//  Synopsis:   Call SetTargetComputer with computer name (NULL if not
//              specified on command line).
//
//  Arguments:  [ppwsz] - command line.
//
//  Returns:    Result of calling ITaskScheduler::SetTargetComputer
//
//  History:    06-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SchedSetMachine(WCHAR **ppwsz)
{
    HRESULT hr;
    TOKEN tkn;
    LPWSTR pwszComputer = NULL;

    tkn = PeekToken(ppwsz);

    if (tkn == TKN_STRING)
    {
        GetToken(ppwsz);
        pwszComputer = g_wszLastStringToken;
    }

    g_Log.Write(LOG_TRACE, "Setting target computer to '%S'", pwszComputer);
    hr = g_pJobScheduler->SetTargetComputer(pwszComputer);

    if (FAILED(hr))
    {
        g_Log.Write(
            LOG_FAIL,
            "ITaskScheduler::SetTargetComputer hr=%#010x",
            hr);
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SetJob
//
//  Synopsis:   Set one or more properties on the global job.
//
//  Arguments:  [ppwsz] - command line.
//
//  Returns:    S_OK - job properties set
//              E_*  - error logged
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SetJob(WCHAR **ppwsz)
{
    HRESULT     hr = S_OK;
    CJobProp    JobProperties;

    do
    {
        g_Log.Write(LOG_TRACE, "Setting job's properties");

        hr = JobProperties.Parse(ppwsz);
        BREAK_ON_FAILURE(hr);

        //
        // Set the job's properties to the values we just parsed
        //

        hr = JobProperties.SetActual(g_pJob);
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SetTrigger
//
//  Synopsis:   Parse and execute the set trigger command.
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    S_OK - trigger modified
//              E_*  - error logged
//
//  Modifies:   *[ppwsz]
//
//  History:    01-05-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SetTrigger(WCHAR **ppwsz, BOOL fJob)
{
    HRESULT         hr = S_OK;
    CTrigProp       TriggerProps;
    SHORT           usTrigger = 0;
    SpIJobTrigger   spTrigger;

    do
    {
        if (PeekToken(ppwsz) == TKN_NUMBER)
        {
            GetToken(ppwsz);
            usTrigger = (SHORT) g_ulLastNumberToken;
        }

        g_Log.Write(
            LOG_TRACE,
            "Setting properties on trigger %u",
            usTrigger);

        hr = TriggerProps.Parse(ppwsz);
        BREAK_ON_FAILURE(hr);

        if (fJob)
        {
            hr = g_pJob->GetTrigger(usTrigger, &spTrigger);
            LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetTrigger");
        }
        else
        {
#ifdef NOT_YET
            hr = g_pJobQueue->GetTrigger(usTrigger, &spTrigger);
            LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::GetTrigger");
#endif // NOT_YET
            hr = E_NOTIMPL;
        }

        hr = TriggerProps.SetActual(spTrigger);
    }
    while (0);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\globals.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       globals.cxx
//
//  Contents:   Globals shared between two or more modules.
//
//  History:    09-27-94   DavidMun   Created
//
//----------------------------------------------------------------------------

#include <headers.hxx>
#pragma hdrstop
#include "jt.hxx"

CLog              g_Log("JT");
            
WCHAR             g_wszLastStringToken[MAX_TOKEN_LEN + 1];
WCHAR             g_wszLastNumberToken[11]; // "4294967295" is max number
ULONG             g_ulLastNumberToken;
ITask            *g_pJob;
IUnknown         *g_pJobQueue;
ITaskScheduler *  g_pJobScheduler;
IEnumWorkItems   *g_apEnumJobs[NUM_ENUMERATOR_SLOTS];

const IID IID_ITaskTrigger = {0x148BD52B,0xA2AB,0x11CE,{0xB1,0x1F,0x00,0xAA,0x00,0x53,0x05,0x03}};


const IID IID_ITask = {0x148BD524,0xA2AB,0x11CE,{0xB1,0x1F,0x00,0xAA,0x00,0x53,0x05,0x03}};


const IID IID_IEnumTasks = {0x148BD528,0xA2AB,0x11CE,{0xB1,0x1F,0x00,0xAA,0x00,0x53,0x05,0x03}};


const IID IID_ITaskScheduler = {0x148BD527,0xA2AB,0x11CE,{0xB1,0x1F,0x00,0xAA,0x00,0x53,0x05,0x03}};


const IID IID_IProvideTaskPage = {0x4086658a,0xcbbb,0x11cf,{0xb6,0x04,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};

#include <initguid.h>


// {148BD520-A2AB-11CE-B11F-00AA00530503}
DEFINE_GUID(CLSID_CTask, 0x148BD520, 0xA2AB, 0x11CE, 0xB1, 0x1F, 0x00, 0xAA, 0x00, 0x53, 0x05, 0x03);
 
// {255b3f60-829e-11cf-8d8b-00aa0060f5bf}
DEFINE_GUID(CLSID_CQueue, 0x255b3f60, 0x829e, 0x11cf, 0x8d, 0x8b, 0x00, 0xaa, 0x00, 0x60, 0xf5, 0xbf);
 
// {148BD52A-A2AB-11CE-B11F-00AA00530503}
DEFINE_GUID(CLSID_CTaskScheduler, 0x148BD52A, 0xA2AB, 0x11CE, 0xB1, 0x1F, 0x00, 0xAA, 0x00, 0x53, 0x05, 0x03);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\log.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       log.cxx
//
//  Contents:   Simple logging support.
//
//  History:    02-08-94   DavidMun   Created
//
//----------------------------------------------------------------------------


#include <headers.hxx>
#pragma hdrstop
#include "jt.hxx"

//
// Forward references for private funcs
// 

static const CHAR *GetTimeStamp();
static const CHAR *GetCpuStr();
static const CHAR *GetVideoStr();


//+---------------------------------------------------------------------------
//
//  Member:     CLog::CLog, public
//
//  Synopsis:   Initialize member variables
//
//  Arguments:  [szTestTitle]           - title of test being logged
//              [szLogFile]             - filename to use if LOG_TOFILE used
//              [flDefaultDestinations] - LOG_TO* bits to use if none are
//                                          specified in call to Write()
//              [flLogInfoLevel]        - if bitwise and of this mask and bits
//                                         passed to Write != 0, line is
//                                         logged.
//
//  Modifies:   All member vars.
// 
//  History:    02-11-94   DavidMun   Created
//
//----------------------------------------------------------------------------

CLog::CLog(
        const CHAR *szTestTitle,
        const CHAR *szLogFile,
        ULONG flDefaultDestinations,
        ULONG flLogInfoLevel)
{
    // make copies of test title and log filename

    strncpy(_szTestTitle, szTestTitle, sizeof(_szTestTitle));
    _szTestTitle[sizeof(_szTestTitle) - 1] = '\0';
    strcpy(_szLogFile, szLogFile);

    // copy other args

    _flDefaultDestinations = flDefaultDestinations;
    _flInfoLevel = flLogInfoLevel;

    // Zero count of each type of message logged

    _cLogPass  = 0;
    _cLogFail  = 0;
    _cLogWarn  = 0;
    _cLogStart = 0;
    _cLogInfo  = 0;
    _cLogSkip  = 0;
    _cLogAbort = 0;
    _cLogError = 0;
    _cLogOther = 0;

    //
    // Indicate that we haven't logged the header yet, and that logging of 
    // header and footer is not suppressed.  
    // 

    _fLoggedHeader = FALSE;
    _fSuppress = FALSE;

    InitializeCriticalSection(&_critsec);
}




//+---------------------------------------------------------------------------
//
//  Member:     CLog::~CLog, public
//
//  Synopsis:   Log the footer before terminating
//
//  History:    02-11-94   DavidMun   Created
//
//----------------------------------------------------------------------------

CLog::~CLog()
{

    // 
    // Make sure the footer is the last thing logged, unless its being
    // suppressed.
    // 

    if (!_fSuppress)
    {
        _LogFooter();
    }
}




//+---------------------------------------------------------------------------
//
//  Member:     CLog::SetFile, public
//
//  Synopsis:   Set the filename to use when LOG_TOFILE is specified
//
//  Arguments:  [szNewFilename] - new file
//
//  Modifies:   [_szLogFile]
//
//  History:    02-11-94   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID CLog::SetFile(const CHAR *szNewFilename)
{
    strcpy(_szLogFile, szNewFilename);
}




//+---------------------------------------------------------------------------
//
//  Member:     CLog::SetFile
//
//  Synopsis:   Wide char wrapper
//
//  History:    04-06-95   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID CLog::SetFile(const WCHAR *wszNewFilename)
{
    CHAR szNewFilename[MAX_PATH + 1];

    wcstombs(szNewFilename, wszNewFilename, MAX_PATH);
    SetFile(szNewFilename);
}




//+---------------------------------------------------------------------------
//
//  Member:     CLog::SetInfoLevel, public
//
//  Synopsis:   Set infolevel mask bits
//
//  Arguments:  [flNewInfoLevel] - new mask
//
//  Returns:    Previous infolevel
//
//  Modifies:   [_flInfoLevel]
//
//  History:    02-11-94   DavidMun   Created
//
//----------------------------------------------------------------------------

ULONG CLog::SetInfoLevel(ULONG flNewInfoLevel)
{
    ULONG flOldInfoLevel = _flInfoLevel;
    _flInfoLevel = flNewInfoLevel & ~LOG_DESTINATIONBITS;
    return flOldInfoLevel;
}




//+---------------------------------------------------------------------------
//
//  Member:     CLog::_LogHeader, private
//
//  Synopsis:   Called the first time Write() is invoked, and never called
//              again.
//
//  Modifies:   [_fLoggedHeader]
//
//  History:    02-11-94   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID CLog::_LogHeader()
{
    if (_fLoggedHeader)
    {
        return;
    }

    //
    // _fLoggedHeader MUST be set before calling Write to avoid infinite 
    // recursion!  
    // 

    _fLoggedHeader = TRUE;

    //
    // Write the header.
    // 

    Write(LOG_TEXT, "");
    Write(LOG_START, "Header");
    Write(LOG_TEXT, BANNER_WIDTH_EQUALS);
    Write(LOG_TEXT, "  Run of '%s' starting at %s", _szTestTitle, GetTimeStamp());
    Write(LOG_TEXT, "");
    Write(LOG_TEXT, "    Processors: %s", GetCpuStr());
    Write(LOG_TEXT, "    Video:      %s", GetVideoStr());
    Write(LOG_TEXT, "");
    Write(LOG_TEXT, BANNER_WIDTH_DASH);
    Write(LOG_END, "");
}




//+---------------------------------------------------------------------------
//
//  Member:     CLog::Write
//
//  Synopsis:   Write the printf style arguments to the destinations 
//              specified in [flLevelAndDest] iff the bitwise and of 
//              [_flInfoLevel] and [flLevelAndDest] != 0.
//
//  Arguments:  [flLevelAndDest] - LOG_TO* bits and at most 1 infolevel bit.
//              [szFormat]       - printf style format
//              [...]            - args for printf
//
//  History:    02-11-94   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID CLog::Write(ULONG flLevelAndDest, const CHAR *szFormat, ...)
{
    EnterCriticalSection(&_critsec);

    if (!_fLoggedHeader && !_fSuppress)
    {
        _LogHeader();
    }

    static CHAR szLastStart[BANNER_WIDTH + 1];
    va_list varArgs;
    ULONG flDestinations;
    FILE *fp = NULL;
    CHAR szMessage[CCH_MAX_LOG_STRING]; // _vsnwprintf of args
    CHAR szToLog[CCH_MAX_LOG_STRING];   // prefix plus message
    CHAR szCurLine[BANNER_WIDTH + 1];
    CHAR *pszNextLine;
    ULONG cchPrefix;
    ULONG cchToLog;

    //
    // If the caller set any of the destination bits in flLevelAndDest, then
    // they override the default destinations in flLogDefaultDestinations.
    //
    // Return without logging anything if flLevelAndDest has no destination
    // bits set AND the default destination bits are also cleared.  Also do
    // nothing if the intersection of infolevel bits in flLevelAndDest and
    // _flInfoLevel is nil.
    //

    flDestinations = flLevelAndDest & LOG_DESTINATIONBITS;

    if (0 == flDestinations)
    {
        flDestinations = _flDefaultDestinations;

        if (0 == flDestinations)
        {
            LeaveCriticalSection(&_critsec);
            return;
        }
    }

    if (0 == (flLevelAndDest & _flInfoLevel))
    {
        LeaveCriticalSection(&_critsec);
        return;
    }

    //
    // If we've reached this point then the message will be logged.  sprintf
    // the args into szMessage.
    //

    va_start(varArgs, szFormat);
    _vsnprintf(szMessage, CCH_MAX_LOG_STRING, szFormat, varArgs);
    szMessage[CCH_MAX_LOG_STRING - 1] = '\0';
    va_end(varArgs);

    //
    // If we're starting a new section, close out the previous one if
    // necessary, then output a blank line to separate the new section from
    // the old one visually.  Save the new section name.  Note strncpy does
    // not guarantee null termination.
    //

    if (flLevelAndDest & LOG_START)
    {
        if (szLastStart[0] != '\0')
        {
            Write((flLevelAndDest & ~LOG_START) | LOG_END, "");
        }
        Write((flLevelAndDest & ~LOG_START) | LOG_TEXT, "");
        strncpy(szLastStart, szMessage, CCH_MAX_START_MESSAGE);
        szLastStart[CCH_MAX_START_MESSAGE - 1] = '\0';
    }

    if (flDestinations & LOG_TOFILE)
    {
        fp = fopen(_szLogFile, "a");
    }

    if (flLevelAndDest & LOG_TEXT)
    {
        //
        // LOG_TEXT strings are special: they are not wrapped, prefixed, or
        // counted.  Logging them is therefore easy: just write szMessage.
        // 
        
        if (fp)
        {
            fprintf(fp, "%s\n", szMessage);
        }

        if (flDestinations & LOG_TOCONSOLE)
        {
            printf("%s\n", szMessage);
        }

        if (flDestinations & LOG_TODEBUG)
        {
            OutputDebugStringA(szMessage);
            OutputDebugStringA("\n");
        }
    }
    else 
    {
        // 
        // Generate the prefix for this log entry, then fill cchPrefix with 
        // its length.  This will be the amount to indent portions of the line 
        // that must be wrapped.  
        // 
        // If flLevelAndDest has LOG_START then szLastStart has just been set.  
        // If it has LOG_END, then szLastStart has the message from the last 
        // time a LOG_START was logged.  In either case the message has 
        // already been included in the prefix, so don't append it to szToLog.  
        // Also, in the case of LOG_END, zero out the last start message, 
        // since it's part of the prefix now, and the next LOG_START will 
        // think this LOG_END wasn't logged if szLastStart isn't empty.  
        //
        // Otherwise flLevelAndDest has neither LOG_START nor LOG_END, so the 
        // string to log will be the prefix and the message.  
        //

        _LogPrefix(flLevelAndDest, szLastStart, szToLog);
        cchPrefix = strlen(szToLog);
    
        if (0 == (flLevelAndDest & (LOG_START | LOG_END)))
        {
            strncat(szToLog, szMessage, CCH_MAX_LOG_STRING - cchPrefix);
            szToLog[CCH_MAX_LOG_STRING - 1] = '\0';
        }
        else if (flLevelAndDest & LOG_END)
        {
            szLastStart[0] = '\0';
        }
    
        //
        // szToLog contains the string to be logged.  This will be output
        // BANNER_WIDTH characters at a time.
        //
    
        cchToLog = strlen(szToLog);
        pszNextLine = szToLog;

        do
        {
            //
            // Fill szCurLine with a BANNER_WIDTH chunk of szToLog, starting 
            // at pszNextLine.  If pszNextLine points to the start of szToLog, 
            // then this is the first pass and no indent is necessary, 
            // otherwise indent with spaces by the size of the prefix for this 
            // log entry.  
            //
    
            if (pszNextLine == szToLog)
            {
                strncpy(szCurLine, szToLog, BANNER_WIDTH);
                szCurLine[BANNER_WIDTH] = '\0';
                cchToLog -= min(cchToLog, BANNER_WIDTH);
                pszNextLine += BANNER_WIDTH;
            }
            else
            {
                sprintf(szCurLine,
                    "%*s%.*s",
                    cchPrefix,
                    "",
                    BANNER_WIDTH - cchPrefix,
                    pszNextLine);
                szCurLine[BANNER_WIDTH] = '\0';
                cchToLog -= min(cchToLog, (ULONG) (BANNER_WIDTH - cchPrefix));
                pszNextLine += BANNER_WIDTH - cchPrefix;
            }
    
            if (fp)
            {
                fprintf(fp, "%s\n", szCurLine);
            }
    
            if (flDestinations & LOG_TOCONSOLE)
            {
                printf("%s\n", szCurLine);
            }
    
            if (flDestinations & LOG_TODEBUG)
            {
                OutputDebugStringA(szCurLine);
                OutputDebugStringA("\n");
            }
        } while (cchToLog);
    }

    if (fp)
    {
        fclose(fp);
    }
    LeaveCriticalSection(&_critsec);
}




//+---------------------------------------------------------------------------
//
//  Member:     CLog::_LogPrefix, private
//
//  Synopsis:   Fill [pszPrefix] with the prefix string corresponding to the
//              infolevel bit set in [flLevel].
//
//  Arguments:  [flLevel]   - exactly one LOG_* infolevel bit
//              [szStart]   - forms part of prefix for LOG_START and LOG_END
//              [pszPrefix] - output
//
//  Modifies:   [pszPrefix]
//
//  History:    02-09-94   DavidMun   Created
//
//  Notes:      Caller must ensure that pswzPrefix points to a buffer large
//              enough to hold START_PREFIX and szStart together.
//              
//              Neither TRACE nor TEXT levels are tallied.  
//              
//----------------------------------------------------------------------------

VOID CLog::_LogPrefix(ULONG flLevel, const CHAR *szStart, CHAR *pszPrefix)
{
    if (flLevel & LOG_PASS)
    {
        _cLogPass++;
        strcpy(pszPrefix, PASS_PREFIX);
    }
    else if (flLevel & LOG_FAIL)
    {
        _cLogFail++;
        strcpy(pszPrefix, FAIL_PREFIX);
    }
    else if (flLevel & LOG_WARN)
    {
        _cLogWarn++;
        strcpy(pszPrefix, WARN_PREFIX);
    }
    else if (flLevel & LOG_START)
    {
        _cLogStart++;
        sprintf(pszPrefix, START_PREFIX, szStart);
    }
    else if (flLevel & LOG_END)
    {
        sprintf(pszPrefix, END_PREFIX, szStart);
    }
    else if (flLevel & LOG_INFO)
    {
        _cLogInfo++;
        strcpy(pszPrefix, INFO_PREFIX);
    }
    else if (flLevel & LOG_SKIP)
    {
        _cLogSkip++;
        strcpy(pszPrefix, SKIP_PREFIX);
    }
    else if (flLevel & LOG_ABORT)
    {
        _cLogAbort++;
        strcpy(pszPrefix, ABORT_PREFIX);
    }
    else if (flLevel & LOG_ERROR)
    {
        _cLogError++;
        strcpy(pszPrefix, ERROR_PREFIX);
    }
    else if (flLevel & LOG_TRACE)
    {
        strcpy(pszPrefix, TRACE_PREFIX);
    }
    else if (flLevel & LOG_PERF)
    {
        strcpy(pszPrefix, PERF_PREFIX);
    }
    else if (flLevel & LOG_DEBUG)
    {
        strcpy(pszPrefix, DEBUG_PREFIX);
    }
    else if (flLevel & LOG_TEXT)
    {
        pszPrefix[0] = '\0';
    }
    else
    {
        _cLogOther++;
        pszPrefix[0] = '\0';
    }
}




//+---------------------------------------------------------------------------
//
//  Member:     CLog::_LogFooter, private
//
//  Synopsis:   Write a footer to the log.
//
//  History:    02-11-94   DavidMun   Created
//
//  Notes:      Called by dtor.
//
//----------------------------------------------------------------------------

VOID CLog::_LogFooter()
{
    Write(LOG_START, "Footer");
    Write(LOG_TEXT, BANNER_WIDTH_DASH);
    Write(LOG_TEXT, "  Run of '%s' finished at %s", _szTestTitle, GetTimeStamp());

    Write(LOG_TEXT, "");
    Write(LOG_TEXT, "    Total messages logged, by type:");
    Write(LOG_TEXT, "");

    if (_cLogStart)
    {
        Write(LOG_TEXT, "    Start:              %u", _cLogStart);
    }

    if (_cLogPass)
    {
        Write(LOG_TEXT, "    Pass:               %u", _cLogPass);
    }

    if (_cLogFail)
    {
        Write(LOG_TEXT, "    Fail:               %u", _cLogFail);
    }

    if (_cLogAbort)
    {
        Write(LOG_TEXT, "    Abort:              %u", _cLogAbort);
    }

    if (_cLogError)
    {
        Write(LOG_TEXT, "    Error:              %u", _cLogError);
    }

    if (_cLogSkip)
    {
        Write(LOG_TEXT, "    Skip:               %u", _cLogSkip);
    }

    if (_cLogWarn)
    {
        Write(LOG_TEXT, "    Warning:            %u", _cLogWarn);
    }

    if (_cLogInfo)
    {
        Write(LOG_TEXT, "    Information:        %u", _cLogInfo);
    }

    if (_cLogOther)
    {
        Write(LOG_TEXT, "    User-defined:       %u", _cLogOther);
    }

    Write(LOG_TEXT, "");
    Write(LOG_TEXT, BANNER_WIDTH_EQUALS);
    Write(LOG_END, "");
}




//+---------------------------------------------------------------------------
//
//  Function:   GetCpuStr, private
//
//  Synopsis:   Return a string describing CPU.
//
//  Returns:    Pointer to static string
//
//  History:    02-11-94   DavidMun   Created
//              05-01-95   DavidMun   Update for change to GetSystemInfo
//
//----------------------------------------------------------------------------

static const CHAR *GetCpuStr()
{
    static CHAR s_szCpuStr[BANNER_WIDTH];
    SYSTEM_INFO siSystemInfo;
    CHAR *pszCpuType;

    GetSystemInfo(&siSystemInfo);

    switch (siSystemInfo.wProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        pszCpuType = " Intel";
        break;

    case PROCESSOR_ARCHITECTURE_MIPS:
        pszCpuType = " MIPS";
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
        pszCpuType = " ALPHA";
        break;

    default:
        pszCpuType = "Unknown Processor(s)";
        break;
    }

    sprintf(s_szCpuStr, "%u %s", siSystemInfo.dwNumberOfProcessors, pszCpuType);
    return s_szCpuStr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetVideoStr
//
//  Synopsis:   Return a pointer to a string describing video resolution and
//              color (i.e., XxYxC).
//
//  Returns:    Pointer to static string.
//
//  History:    02-11-94   DavidMun   Created
//
//----------------------------------------------------------------------------

static const CHAR *GetVideoStr()
{
    static CHAR s_szVideo[BANNER_WIDTH];
    HDC hdcDisplay;
    ULONG cPlanes;
    ULONG cBitsPerPixel;

    //
    // Get a DC for the display, then find out its horizontal and vertical
    // resolutions.  Determine the number of colors per Petzold 3.1, p. 513.
    //

    hdcDisplay = CreateDC(TEXT("DISPLAY"), TEXT(""), TEXT(""), NULL);
    cPlanes = GetDeviceCaps(hdcDisplay, PLANES);
    cBitsPerPixel = GetDeviceCaps(hdcDisplay, BITSPIXEL);

    sprintf(s_szVideo,
        "%ux%ux%u",
        GetDeviceCaps(hdcDisplay, HORZRES),
        GetDeviceCaps(hdcDisplay, VERTRES),
        1 << (cPlanes * cBitsPerPixel));

    DeleteDC(hdcDisplay);
    return s_szVideo;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetTimeStamp
//
//  Synopsis:   Return a pointer to a string containing current time and date.
//
//  Returns:    Pointer to a static string.
//
//  History:    02-11-94   DavidMun   Created
//
//----------------------------------------------------------------------------

static const CHAR *GetTimeStamp()
{
    static CHAR s_szTimeStamp[20];  // space for time & date in format below
    SYSTEMTIME  tmStart;

    GetLocalTime(&tmStart);

    sprintf(s_szTimeStamp,
        "%02d:%02d:%02d %d/%02d/%d",
        tmStart.wHour,
        tmStart.wMinute,
        tmStart.wSecond,
        tmStart.wMonth,
        tmStart.wDay,
        tmStart.wYear);

    return s_szTimeStamp;
}




//+---------------------------------------------------------------------------
//
//  Function:   LogIt
//
//  Synopsis:   Log success or failure.
//
//  Arguments:  [hrFound]    - hresult returned from some operation
//              [hrExpected] - EXPECT_SUCCEEDED or a valid HRESULT
//              [szFormat]   - printf style format string
//              [...]        - args specified in [szFormat]
//
//  History:    08-24-94   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID LogIt(HRESULT hrFound, HRESULT hrExpected, CHAR *szFormat, ...)
{
    va_list varg;

    va_start(varg, szFormat);

    if (hrExpected == EXPECT_SUCCEEDED && SUCCEEDED(hrFound) ||
        hrFound == hrExpected)
    {
        CHAR szBuf[MAX_LOGIT_MSG] = "Succeeded in ";
        CHAR *pBuf;

        pBuf = strchr(szBuf, '\0');
        _vsnprintf(pBuf, MAX_LOGIT_MSG - (pBuf - szBuf), szFormat, varg);
        g_Log.Write(LOG_TRACE, szBuf);
    }
    else
    {
        CHAR szBuf[MAX_LOGIT_MSG] = "Didn't succeed in ";
        CHAR *pBuf;

        pBuf = strchr(szBuf, '\0');
        _vsnprintf(pBuf, MAX_LOGIT_MSG - (pBuf - szBuf), szFormat, varg);
        g_Log.Write(LOG_FAIL, szBuf);
    }
    va_end( varg );
}




#if 0
void __cdecl main()
{
    CLog Log("Unit Test", "test.log", LOG_TOCONSOLE | LOG_TOFILE);

    Log.Write(LOG_START, "variation");
    Log.Write(LOG_INFO, "Here is some info: %d %s", 1, "foo");
    Log.Write(LOG_WARN, "a wide char warning '%S'", L"wide string");
    Log.Write(LOG_TRACE, "line to trace");
    Log.Write(LOG_ABORT, "Abort message");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\main.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       main.cxx
//
//  Contents:   Entry point
//
//  History:    03-31-95   DavidMun   Created
//
//----------------------------------------------------------------------------

#include <headers.hxx>
#pragma hdrstop
#include "jt.hxx"


//
// Forward references
//

HRESULT Init();
VOID Cleanup();




//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Entry point for DRT.
//
//  Arguments:  See DisplayUsage().
//
//  Returns:    1 on success, 0 on failure
//
//  History:    03-31-95   DavidMun   Created
//
//----------------------------------------------------------------------------

ULONG __cdecl main(int argc, char *argv[])
{
    HRESULT hr = S_OK;
    WCHAR   *pwszCommandLine;

    if (argc == 1)
    {
        DisplayUsage();
        g_Log.SuppressHeaderFooter(TRUE);
        return 1;
    }

    do
    {
        hr = Init();
        BREAK_ON_FAILURE(hr);

        pwszCommandLine = GetCommandLineW();

        // Point past the zero'th arg
        while (iswspace(*pwszCommandLine))
        {
            pwszCommandLine++;
        }
        pwszCommandLine += lstrlenA(argv[0]);
        // leading spaces and quotes were stripped off in argv[0]
        // this will compensate, most of the time
        while (!iswspace(*pwszCommandLine))
        {
            pwszCommandLine++;
        }

        hr = ProcessCommandLine(pwszCommandLine);
    } while (0);

    Cleanup();
    return FAILED(hr) ? 1 : 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   Initialize OLE and globals.
//
//  Returns:    S_OK - initialization successful
//              E_*  - error logged
//
//  Modifies:   [g_Log], [g_*Factory], [g_prepmgr]
//
//  History:    04-24-95   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT Init()
{
    HRESULT hr = S_OK;

    do
    {
        g_Log.SuppressHeaderFooter(TRUE);
        g_Log.SetInfoLevel(g_Log.GetInfoLevel() & ~LOG_DEBUG);

        hr = CoInitialize(NULL);

        if( FAILED(hr))
        {
            g_Log.Write(LOG_FAIL, "CoInitialize hr=%#010x", hr);
            break;
        }

        hr = CoCreateInstance(
                CLSID_CTask,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ITask,
                (void **)&g_pJob);

        LOG_AND_BREAK_ON_FAIL(hr, "CoCreateInstance(CLSID_CTask)");
#if 0 // BUGBUG queue objects not yet available
        hr = CoCreateInstance(
                CLSID_CTaskQueue,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ITaskQueue,
                (void **)&g_pJobQueue);

        LOG_AND_BREAK_ON_FAIL(hr, "CoCreateInstance(CLSID_CTaskQueue)");
#endif

        hr = CoCreateInstance(
                CLSID_CTaskScheduler,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ITaskScheduler,
                (void **)&g_pJobScheduler);
        LOG_AND_BREAK_ON_FAIL(hr, "CoCreateInstance(CLSID_CTaskScheduler)");
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   Cleanup
//
//  Synopsis:   Do shutdown processing.
//
//  History:    01-02-96   DavidMun   Created
//              01-30-96   DavidMun   Release enumerators
//
//----------------------------------------------------------------------------

VOID Cleanup()
{
    ULONG i;

    if (g_pJob)
    {
        SaveIfDirty(g_pJob);
        g_pJob->Release();
        g_pJob = NULL;
    }

    if (g_pJobQueue)
    {
        SaveIfDirty(g_pJobQueue);
        g_pJobQueue->Release();
        g_pJobQueue = NULL;
    }

    for (i = 0; i < NUM_ENUMERATOR_SLOTS; i++)
    {
        if (g_apEnumJobs[i])
        {
            g_apEnumJobs[i]->Release();
        }
    }
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\help.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       help.cxx
//
//  Contents:   Routines to display help info.
//
//  History:    04-04-95   DavidMun   Created
//
//  Notes:      TO CHANGE THE HELP TEXT FOR A COMMAND:
//                  - edit the command's RCDATA block in jt.rc.
//
//              TO ADD HELP FOR A NEW COMMAND:
//                  - Add a RC_<command_name> identifier to resource.h
//                  - Add an RCDATA block for RC_<command_name> in jt.rc
//                  - Add a case statement in the DoHelp() function (below)
//                    for the new command.
//
//----------------------------------------------------------------------------

#include <headers.hxx>
#pragma hdrstop
#include "jt.hxx"
#include "resource.h"




//+---------------------------------------------------------------------------
//
//  Function:   DisplayHelp
//
//  Synopsis:   Print help strings with RCDATA identifier [usResourceID] on
//              the console.
//
//  Arguments:  [usResourceID] - identifier for RCDATA block containing
//                               printf style string to print.
//              [...]          - arguments for vprintf
//
//  History:    03-11-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID DisplayHelp(USHORT usResourceID, ...)
{
    va_list varArgs;
    HRSRC   hResource = NULL;
    HGLOBAL hgResource = NULL;
    LPSTR   psz = NULL;

    va_start(varArgs, usResourceID);
    do
    {
        hResource = FindResource(NULL, (LPCTSTR) usResourceID, RT_RCDATA);

        if (!hResource)
        {
            g_Log.Write(LOG_ERROR, "FindResource (%u)", GetLastError());
            break;
        }

        hgResource = LoadResource(NULL, hResource);

        if (!hgResource)
        {
            g_Log.Write(LOG_ERROR, "LoadResource (%u)", GetLastError());
            break;
        }

        psz = (LPSTR) LockResource(hgResource);

        if (!psz)
        {
            g_Log.Write(LOG_ERROR, "LockResource (%u)", GetLastError());
            break;
        }

        while (*psz)
        {
            vprintf(psz, varArgs);
            psz += lstrlenA(psz) + 1;
        }
    } while (0);
    va_end(varArgs);

    if (hgResource)
    {
        FreeResource(hgResource);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   DisplayUsage
//
//  Synopsis:   Print usage instructions for this exe on the console
//
//  History:    02-18-94   DavidMun   Created
//              03-31-95   DavidMun   Rewrite
//
//----------------------------------------------------------------------------

VOID DisplayUsage()
{
    DisplayHelp(
        RC_USAGE1,
#if (DBG == 1)
        "as a debug build",
#else
        "as a retail build",
#endif
#ifdef _CHICAGO_
        "Windows 95 or Windows 98"
#else
#ifndef RES_KIT
        "Windows NT"
#else
        "the Windows NT Resource Kit"
#endif
#endif
        );
    DisplayHelp(RC_USAGE2, NUM_ENUMERATOR_SLOTS - 1);
}




//+---------------------------------------------------------------------------
//
//  Function:   DoHelp
//
//  Synopsis:   Process the HELP command
//
//  Arguments:  [ppwsz] - token stream
//
//  Modifies:   *[ppwsz]
//
//  History:    04-10-95   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID DoHelp(WCHAR **ppwsz)
{
    TOKEN   tkn;
    BOOL    fGotToken = FALSE;

    do
    {
        do
        {
            tkn = GetToken(ppwsz);
        } while (tkn != TKN_EOL &&
                 tkn != TKN_ATSIGN &&
                 !IsCommandToken(tkn));

#ifdef RES_KIT
       if ((tkn == TKN_ADDJOBTOQUEUE)              ||
             (tkn == TKN_REMOVEJOBFROMQUEUE)       ||
             (tkn == TKN_SETQUEUE)                 ||
             (tkn == TKN_ABORTQUEUE)               ||
             (tkn == TKN_CONVERTSAGETASKSTOJOBS)   ||
             (tkn == TKN_EDITJOB)                  ||
             (tkn == TKN_ENUMCLONE)                ||
             (tkn == TKN_ENUMNEXT)                 ||
             (tkn == TKN_ENUMRESET)                ||
             (tkn == TKN_ENUMSKIP)                 ||
             (tkn == TKN_CREATETRIGGERQUEUE)       ||
             (tkn == TKN_DELETETRIGGERQUEUE)       ||
             (tkn == TKN_EDITJOBINQUEUE)           ||
             (tkn == TKN_LOADQUEUE)                ||
             (tkn == TKN_PRINTQUEUE)               ||
             (tkn == TKN_PRINTRUNTIMEQUEUE)        ||
             (tkn == TKN_PRINTSTRINGQUEUE)         ||
             (tkn == TKN_PRINTTRIGGERQUEUE)        ||
             (tkn == TKN_RUNQUEUE)                 ||
             (tkn == TKN_SCHEDADDQUEUE)            ||
             (tkn == TKN_SCHEDCREATEENUM)          ||
             (tkn == TKN_SCHEDISJOBORQUEUE)        ||
             (tkn == TKN_SAVEQUEUE)                ||
             (tkn == TKN_SCHEDNEWQUEUE)            ||
             (tkn == TKN_SETTRIGGERQUEUE))
       {
          continue;
       }
#endif

        if (tkn != TKN_EOL)
        {
            fGotToken = TRUE;
        }

        switch (tkn)
        {
//        case TKN_ADDJOBTOQUEUE:
//        case TKN_REMOVEJOBFROMQUEUE:
//        case TKN_SETQUEUE:
//            DisplayHelp(RC_NOTIMPL);
//            break;

        case TKN_ABORTJOB:
//        case TKN_ABORTQUEUE:
            DisplayHelp(RC_ABORT);
            break;

        case TKN_ATSIGN:
            DisplayHelp(RC_ATSIGN);
            break;

#ifndef RES_KIT
        case TKN_CONVERTSAGETASKSTOJOBS:
            DisplayHelp(
                RC_CONVERTSAGE,
#ifdef _CHICAGO_
                "Win9x"
#else
                "Windows NT"
#endif
            );
            break;
#endif // RES_KIT not defined

        case TKN_CREATETRIGGERJOB:
//        case TKN_CREATETRIGGERQUEUE:
            DisplayHelp(RC_CREATETRIGGER1);
            DisplayHelp(RC_TRIGPROPS, TIME_NOW_INCREMENT);
            DisplayHelp(RC_CREATETRIGGER2);
            break;

        case TKN_DELETETRIGGERJOB:
//        case TKN_DELETETRIGGERQUEUE:
            DisplayHelp(RC_DELETETRIGGER);
            break;

#ifndef RES_KIT
        case TKN_EDITJOB:
//        case TKN_EDITJOBINQUEUE:
            DisplayHelp(RC_EDITJOB);
            break;

        case TKN_ENUMCLONE:
            DisplayHelp(RC_ENUMCLONE);
            break;

        case TKN_ENUMNEXT:
            DisplayHelp(RC_ENUMNEXT);
            break;

        case TKN_ENUMRESET:
            DisplayHelp(RC_ENUMRESET);
            break;

        case TKN_ENUMSKIP:
            DisplayHelp(RC_ENUMSKIP);
            break;
#endif // RES_KIT not defined

        case TKN_GETCREDENTIALS:
            DisplayHelp(RC_GETCREDENTIALS);
            break;

        case TKN_GETMACHINE:
            DisplayHelp(RC_GETMACHINE);
            break;

#ifndef RES_KIT
        case TKN_SCHEDISJOBORQUEUE:
            DisplayHelp(RC_ISJOBORQUEUE);
            break;
#endif // RES_KIT not defined

        case TKN_LOADJOB:
//        case TKN_LOADQUEUE:
            DisplayHelp(RC_LOAD);
            break;

        case TKN_PRINTJOB:
//        case TKN_PRINTQUEUE:
            DisplayHelp(RC_PRINT);
            break;

        case TKN_PRINTRUNTIMEJOB:
//        case TKN_PRINTRUNTIMEQUEUE:
            DisplayHelp(RC_PRINTRUNTIME);
            break;

        case TKN_PRINTSTRINGJOB:
//        case TKN_PRINTSTRINGQUEUE:
            DisplayHelp(RC_PRINTSTRING);
            break;

        case TKN_PRINTTRIGGERJOB:
//        case TKN_PRINTTRIGGERQUEUE:
            DisplayHelp(RC_PRINTTRIGGER);
            break;

        case TKN_RUNJOB:
//        case TKN_RUNQUEUE:
            DisplayHelp(RC_RUN);
            break;

        case TKN_SCHEDACTIVATE:
            DisplayHelp(RC_ACTIVATE);
            break;

        case TKN_SCHEDADDJOB:
//        case TKN_SCHEDADDQUEUE:
            DisplayHelp(RC_ADD);
            break;

#ifndef RES_KIT
        case TKN_SCHEDCREATEENUM:
            DisplayHelp(
                RC_CREATEENUM,
                NUM_ENUMERATOR_SLOTS - 1,
                NUM_ENUMERATOR_SLOTS,
                NUM_ENUMERATOR_SLOTS - 1);
            break;
#endif // RES_KIT not defined

        case TKN_SCHEDDELETE:
            DisplayHelp(RC_DELETE);
            break;

        case TKN_SCHEDENUM:
            DisplayHelp(RC_ENUM);
            break;

        case TKN_SETCREDENTIALS:
            DisplayHelp(RC_SETCREDENTIALS);
            break;

        case TKN_SETJOB:
            DisplayHelp(RC_SETJOB);
            break;

        case TKN_SAVEJOB:
//        case TKN_SAVEQUEUE:
            DisplayHelp(RC_SAVE);
            break;

        case TKN_SETMACHINE:
            DisplayHelp(RC_SETMACHINE);
            break;

        case TKN_SCHEDNEWJOB:
//        case TKN_SCHEDNEWQUEUE:
            DisplayHelp(RC_NEW);
            break;


        case TKN_SETTRIGGERJOB:
//        case TKN_SETTRIGGERQUEUE:
            DisplayHelp(RC_SETTRIGGER1);
            DisplayHelp(RC_TRIGPROPS, TIME_NOW_INCREMENT);
            DisplayHelp(RC_SETTRIGGER2);
            break;

        default:
            if (!fGotToken)
            {
                DisplayUsage();
            }
            break;
        }
    } while (tkn != TKN_EOL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\jobprop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       jobprop.cxx
//
//  Contents:   Implementation of job property container class.
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------


#include <headers.hxx>
#pragma hdrstop
#include "jt.hxx"

typedef HRESULT (STDMETHODCALLTYPE ITask::* SETSTRINGPROPFN)(LPCWSTR);
typedef HRESULT (STDMETHODCALLTYPE ITask::* GETSTRINGPROPFN)(LPWSTR *);

VOID SetStringProp(
    ITask *pJob,
    LPCSTR szMethodName,
    LPCWSTR wszNewValue,
    SETSTRINGPROPFN pfnSetJobStrProp,
    HRESULT *phr);

VOID GetStringProp(
    ITask *pJob,
    LPCSTR szMethodName,
    GETSTRINGPROPFN pfnGetJobStrProp,
    WCHAR **ppwszProp,
    HRESULT *phr);


#define JP_PRIORITY     0x0001
#define JP_MAXRUNTIME   0x0002
#define JP_IDLEWAIT     0x0004
#define JP_TASKFLAGS    0x0008

const ULONG MS_PER_SECOND   = 1000;
const ULONG MS_PER_MINUTE   = 60 * MS_PER_SECOND;
const ULONG MS_PER_HOUR     = 60 * MS_PER_MINUTE;
const ULONG MS_PER_DAY      = 24 * MS_PER_HOUR;


//+---------------------------------------------------------------------------
//
//  Member:     CJobProp::CJobProp
//
//  Synopsis:   Init this.
//
//  History:    01-08-96   DavidMun   Created
//
//  Notes:      Note it is not safe to call Clear(), since it assumes any
//              non-NULL values in the string member vars are valid.
//
//----------------------------------------------------------------------------

CJobProp::CJobProp()
{
    pwszAppName = NULL;
    pwszParams = NULL;
    pwszWorkingDirectory = NULL;
    pwszComment = NULL;
    pwszCreator = NULL;
    dwPriority = NORMAL_PRIORITY_CLASS;
    dwFlags = 0;
}




//+---------------------------------------------------------------------------
//
//  Member:     CJobProp::~CJobProp
//
//  Synopsis:   Free resources
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CJobProp::~CJobProp()
{
    Clear();
}




//+---------------------------------------------------------------------------
//
//  Member:     CJobProp::Clear
//
//  Synopsis:   Release all resources held by this and set all properties
//              to initial values.
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID CJobProp::Clear()
{
    dwFlags = 0;
    dwPriority = NORMAL_PRIORITY_CLASS;
    dwMaxRunTime = 0;
    wIdleWait = 0;
    wIdleDeadline = 0;
    _flSet = 0;
    _flSetFlags = 0;

    CoTaskMemFree(pwszAppName);
    CoTaskMemFree(pwszParams);
    CoTaskMemFree(pwszWorkingDirectory);
    CoTaskMemFree(pwszComment);
    CoTaskMemFree(pwszCreator);
    pwszAppName = NULL;
    pwszParams = NULL;
    pwszWorkingDirectory = NULL;
    pwszComment = NULL;
    pwszCreator = NULL;
    ZeroMemory(&stMostRecentRun, sizeof stMostRecentRun);
    ZeroMemory(&stNextRun, sizeof stNextRun);
    dwExitCode = 0;
    hrStatus = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CJobProp::Dump
//
//  Synopsis:   Write job properties to the log
//
//  History:    01-08-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID CJobProp::Dump()
{
    g_Log.Write(LOG_TEXT, "");
    g_Log.Write(LOG_TEXT, "  ApplicationName:    '%S'", pwszAppName);
    g_Log.Write(LOG_TEXT, "  Parameters:         '%S'", pwszParams);
    g_Log.Write(LOG_TEXT, "  WorkingDirectory:   '%S'", pwszWorkingDirectory);
    g_Log.Write(LOG_TEXT, "  Comment:            '%S'", pwszComment);
    g_Log.Write(LOG_TEXT, "  Creator:            '%S'", pwszCreator);
    g_Log.Write(LOG_TEXT, "  Priority:           %s", GetPriorityString(dwPriority));
    if (dwMaxRunTime == INFINITE)
    {
        g_Log.Write(LOG_TEXT, "  MaxRunTime:         INFINITE");
    }
    else
    {
        ULONG ulMRT = dwMaxRunTime;

        ULONG ulDays = ulMRT / MS_PER_DAY;
        ulMRT %= MS_PER_DAY;

        ULONG ulHours = ulMRT / MS_PER_HOUR;
        ulMRT %= MS_PER_HOUR;

        ULONG ulMinutes = ulMRT / MS_PER_MINUTE;
        ulMRT %= MS_PER_MINUTE;

        ULONG ulSeconds = (ulMRT + MS_PER_SECOND / 2) / MS_PER_SECOND;

        g_Log.Write(
            LOG_TEXT,
            "  MaxRunTime:         %u (%ud %2u:%02u:%02u)",
            dwMaxRunTime,
            ulDays,
            ulHours,
            ulMinutes,
            ulSeconds);
    }
    g_Log.Write(LOG_TEXT, "  IdleWait:           %u", wIdleWait);
    g_Log.Write(LOG_TEXT, "  IdleDeadline:       %u", wIdleDeadline);
    g_Log.Write(LOG_TEXT, "  MostRecentRun:      %02u/%02u/%04u %2u:%02u:%02u",
        stMostRecentRun.wMonth,
        stMostRecentRun.wDay,
        stMostRecentRun.wYear,
        stMostRecentRun.wHour,
        stMostRecentRun.wMinute,
        stMostRecentRun.wSecond);
    g_Log.Write(LOG_TEXT, "  NextRun:            %02u/%02u/%04u %2u:%02u:%02u",
        stNextRun.wMonth,
        stNextRun.wDay,
        stNextRun.wYear,
        stNextRun.wHour,
        stNextRun.wMinute,
        stNextRun.wSecond);
    g_Log.Write(LOG_TEXT, "  StartError:         %s", GetStatusString(hrStartError));
    g_Log.Write(LOG_TEXT, "  ExitCode:           %#x", dwExitCode);
    g_Log.Write(LOG_TEXT, "  Status:             %s", GetStatusString(hrStatus));
    g_Log.Write(LOG_TEXT, "  ScheduledWorkItem Flags:");
    DumpJobFlags(dwFlags);
    g_Log.Write(LOG_TEXT, "  TaskFlags:          %#x", dwTaskFlags);
}




//+---------------------------------------------------------------------------
//
//  Member:     CJobProp::Parse
//
//  Synopsis:   Set this object's members according to the values specified
//              on the command line.
//
//  Arguments:  [ppwsz] - command line.
//
//  Returns:    S_OK - this valid
//              E_*  - error logged
//
//  History:    01-03-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT CJobProp::Parse(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;
    TOKEN   tkn;
    TOKEN   tknProp;
    WCHAR   *pwszStringValue;

    Clear();
    tkn = PeekToken(ppwsz);

    while (tkn != TKN_SWITCH && tkn != TKN_EOL && tkn != TKN_INVALID)
    {
        //
        // Get the property name token in tknProp, then eat the equal sign
        // and, depending on the property, get a string, token or number
        // value.
        //

        tknProp = GetToken(ppwsz);

        hr = Expect(TKN_EQUAL, ppwsz, L"=");
        BREAK_ON_FAILURE(hr);

        if (tknProp == TKN_WORKINGDIRECTORY)
        {
            hr = GetFilename(ppwsz, L"filename");
            if (SUCCEEDED(hr))
            {
                hr = DupString(g_wszLastStringToken, &pwszStringValue);
            }
        }
        else if (tknProp == TKN_APPNAME          ||
                 tknProp == TKN_PARAMS           ||
                 tknProp == TKN_COMMENT          ||
                 tknProp == TKN_CREATOR)
        {
            hr = Expect(TKN_STRING, ppwsz, L"string property value");
            if (SUCCEEDED(hr))
            {
                hr = DupString(g_wszLastStringToken, &pwszStringValue);
            }
        }
        else if (tknProp == TKN_PRIORITY)
        {
            tkn = GetToken(ppwsz);
        }
        else
        {
            hr = Expect(TKN_NUMBER, ppwsz, L"numeric property value");
        }
        BREAK_ON_FAILURE(hr);

        //
        // Now assign the value to the appropriate member
        //

        switch (tknProp)
        {
        case TKN_APPNAME:
            pwszAppName = pwszStringValue;
            break;

        case TKN_PARAMS:
            pwszParams = pwszStringValue;
            break;

        case TKN_WORKINGDIRECTORY:
            pwszWorkingDirectory = pwszStringValue;
            break;

        case TKN_COMMENT:
            pwszComment = pwszStringValue;
            break;

        case TKN_CREATOR:
            pwszCreator = pwszStringValue;
            break;

        case TKN_PRIORITY:
            _flSet |= JP_PRIORITY;
            switch (tkn)
            {
            case TKN_IDLE: // used here as priority
                dwPriority = IDLE_PRIORITY_CLASS;
                break;

            case TKN_NORMAL:
                dwPriority = NORMAL_PRIORITY_CLASS;
                break;

            case TKN_HIGH:
                dwPriority = HIGH_PRIORITY_CLASS;
                break;

            case TKN_REALTIME:
                dwPriority = REALTIME_PRIORITY_CLASS;
                break;

            default:
                hr = E_FAIL;
                LogSyntaxError(tkn, L"IDLE, NORMAL, HIGH, or REALTIME");
            }
            break;

        case TKN_MAXRUNTIME:
            _flSet |= JP_MAXRUNTIME;
            dwMaxRunTime = g_ulLastNumberToken;
            break;

        case TKN_IDLE: // used here as idlewait/deadline property
            _flSet |= JP_IDLEWAIT;
            wIdleWait = (WORD)g_ulLastNumberToken;
            hr = Expect(TKN_NUMBER, ppwsz, L"idle deadline");
            BREAK_ON_FAILURE(hr);
            wIdleDeadline = (WORD)g_ulLastNumberToken;
            break;

        case TKN_TASKFLAGS:
            _flSet |= JP_TASKFLAGS;
            dwTaskFlags = g_ulLastNumberToken;
            break;

#ifndef RES_KIT
        case TKN_INTERACTIVE:
            _flSetFlags |= TASK_FLAG_INTERACTIVE;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_INTERACTIVE;
            }
            break;
#endif

        case TKN_DONTRUNONBATTERIES:
            _flSetFlags |= TASK_FLAG_DONT_START_IF_ON_BATTERIES;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_DONT_START_IF_ON_BATTERIES;
            }
            break;

        case TKN_KILLIFGOINGONBATS:
            _flSetFlags |= TASK_FLAG_KILL_IF_GOING_ON_BATTERIES;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_KILL_IF_GOING_ON_BATTERIES;
            }
            break;

        case TKN_RUNONLYIFLOGGEDON:
            _flSetFlags |= TASK_FLAG_RUN_ONLY_IF_LOGGED_ON;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_RUN_ONLY_IF_LOGGED_ON;
            }
            break;

        case TKN_SYSTEMREQUIRED:
            _flSetFlags |= TASK_FLAG_SYSTEM_REQUIRED;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_SYSTEM_REQUIRED;
            }
            break;

        case TKN_DELETEWHENDONE:
            _flSetFlags |= TASK_FLAG_DELETE_WHEN_DONE;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_DELETE_WHEN_DONE;
            }
            break;

        case TKN_SUSPEND:
            _flSetFlags |= TASK_FLAG_DISABLED;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_DISABLED;
            }
            break;

        case TKN_ONLYIFIDLE:
            _flSetFlags |= TASK_FLAG_START_ONLY_IF_IDLE;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_START_ONLY_IF_IDLE;
            }
            break;

        case TKN_KILLATIDLEEND:
            _flSetFlags |= TASK_FLAG_KILL_ON_IDLE_END;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_KILL_ON_IDLE_END;
            }
            break;

        case TKN_RESTARTONIDLERESUME:
            _flSetFlags |= TASK_FLAG_RESTART_ON_IDLE_RESUME;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_RESTART_ON_IDLE_RESUME;
            }
            break;

        case TKN_HIDDEN:
            _flSetFlags |= TASK_FLAG_HIDDEN;
            if (g_ulLastNumberToken)
            {
                dwFlags |= TASK_FLAG_HIDDEN;
            }
            break;

        default:
            hr = E_FAIL;
            LogSyntaxError(tknProp, L"job property name");
            break;
        }
        tkn = PeekToken(ppwsz);
    }
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CJobProp::InitFromActual
//
//  Synopsis:   Read properties from [pJob] and set this object to match
//
//  Arguments:  [pJob] - job object whose properties we'll read
//
//  Returns:    S_OK - this initialized
//              E_*  - error logged, this only partly initialized
//
//  History:    01-08-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT CJobProp::InitFromActual(ITask *pJob)
{
    HRESULT hr = S_OK;

    do
    {
        Clear();

        hr = pJob->GetApplicationName(&pwszAppName);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetApplicationName(&pwszAppName)");

        CoTaskMemFree(pwszAppName);

        GetStringProp(pJob, "ApplicationName", &ITask::GetApplicationName, &pwszAppName, &hr);
        GetStringProp(pJob, "Parameters", &ITask::GetParameters, &pwszParams, &hr);
        GetStringProp(pJob, "WorkingDirectory", &ITask::GetWorkingDirectory, &pwszWorkingDirectory, &hr);
        GetStringProp(pJob, "Comment", &ITask::GetComment, &pwszComment, &hr);
        GetStringProp(pJob, "Creator", &ITask::GetCreator, &pwszCreator, &hr);
        BREAK_ON_FAILURE(hr);

        hr = pJob->GetPriority(&dwPriority);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetPriority");

        hr = pJob->GetMaxRunTime(&dwMaxRunTime);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetMaxRunTime");

        hr = pJob->GetIdleWait(&wIdleWait, &wIdleDeadline);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetIdleWait");

        hr = pJob->GetFlags(&dwFlags);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetFlags");

        hr = pJob->GetTaskFlags(&dwTaskFlags);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetTaskFlags");

        hr = pJob->GetMostRecentRunTime(&stMostRecentRun);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetMostRecentRunTime");

        hr = pJob->GetNextRunTime(&stNextRun);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetNextRunTime");

        hrStartError = pJob->GetExitCode(&dwExitCode);

        hr = pJob->GetStatus(&hrStatus);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetStatus");
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CJobProp::SetActual
//
//  Synopsis:   Set the properties of the job object with interface [pJob]
//              to the ones stored in this.
//
//  Arguments:  [pJob] - ITask interface
//
//  Returns:    S_OK - all props set
//              E_*  - error logged
//
//  History:    01-08-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT CJobProp::SetActual(ITask *pJob)
{
    HRESULT hr = S_OK;
    HRESULT hrReturn = S_OK;
    ULONG   flCurFlags;

    SetStringProp(pJob, "ApplicationName", pwszAppName, &ITask::SetApplicationName, &hrReturn);
    SetStringProp(pJob, "Parameters", pwszParams, &ITask::SetParameters, &hrReturn);
    SetStringProp(pJob, "WorkingDirectory", pwszWorkingDirectory, &ITask::SetWorkingDirectory, &hrReturn);
    SetStringProp(pJob, "Comment", pwszComment , &ITask::SetComment , &hrReturn);
    SetStringProp(pJob, "Creator", pwszCreator, &ITask::SetCreator, &hrReturn);
    if (_flSet & JP_PRIORITY)
    {
        hr = pJob->SetPriority(dwPriority);
        if (FAILED(hr))
        {
            g_Log.Write(
                LOG_FAIL,
                "ITask::SetPriority(%u) hr=%#010x",
                dwPriority,
                hr);
            hrReturn = hr;
        }
    }

    if (_flSet & JP_MAXRUNTIME)
    {
        hr = pJob->SetMaxRunTime(dwMaxRunTime);
        if (FAILED(hr))
        {
            g_Log.Write(
                LOG_FAIL,
                "ITask::SetMaxRunTime(%u) hr=%#010x",
                dwMaxRunTime,
                hr);
            hrReturn = hr;
        }
    }

    if (_flSet & JP_IDLEWAIT)
    {
        hr = pJob->SetIdleWait(wIdleWait, wIdleDeadline);
        if (FAILED(hr))
        {
            g_Log.Write(
                LOG_FAIL,
                "ITask::SetIdleWait(%u,%u) hr=%#010x",
                wIdleWait,
                wIdleDeadline,
                hr);
            hrReturn = hr;
        }
    }

    if (_flSet & JP_TASKFLAGS)
    {
        hr = pJob->SetTaskFlags(dwTaskFlags);
        if (FAILED(hr))
        {
            g_Log.Write(
                LOG_FAIL,
                "ITask::SetTaskFlags(%u) hr=%#010x",
                dwTaskFlags,
                hr);
            hrReturn = hr;
        }
    }

    hr = pJob->GetFlags(&flCurFlags);

    if (SUCCEEDED(hr))
    {
        //
        // Turn off all flags user touched, then turn back on ones
        // he specified nonzero value for.
        //

        flCurFlags &= ~_flSetFlags;
        flCurFlags |= dwFlags;

        hr = pJob->SetFlags(flCurFlags);

        if (FAILED(hr))
        {
            g_Log.Write(LOG_FAIL, "ITask::SetFlags hr=%#010x", hr);
            hrReturn = hr;
        }
    }
    else
    {
        g_Log.Write(LOG_FAIL, "ITask::GetFlags hr=%#010x", hr);
        hrReturn = hr;
    }

    return hrReturn;
}



//+---------------------------------------------------------------------------
//
//  Function:   SetStringProp
//
//  Synopsis:   Set a string property on a job object
//
//  Arguments:  [pJob]             - job object to modify
//              [szMethodName]     - for logging, name of method we're calling
//              [wszNewValue]      - new string value for property
//              [pfnSetJobStrProp] - ITask member function pointer
//              [phr]              - filled with error if failure occurs
//
//  Modifies:   *[phr] on error
//
//  History:    01-05-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID SetStringProp(
    ITask *pJob,
    LPCSTR szMethodName,
    LPCWSTR wszNewValue,
    SETSTRINGPROPFN pfnSetJobStrProp,
    HRESULT *phr)
{
    HRESULT hr = S_OK;

    if (wszNewValue)
    {
        hr = (pJob->*pfnSetJobStrProp)(wszNewValue);

        if (hr == E_NOTIMPL)
        {
            g_Log.Write(
                LOG_WARN,
                "Ignoring E_NOTIMPL from ITask::Set%s",
                szMethodName);
        }
        else if (FAILED(hr))
        {
            g_Log.Write(LOG_FAIL, "ITask::Set%s hr=%#010x", szMethodName, hr);
            *phr = hr;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   GetStringProp
//
//  Synopsis:   Read a string property from a job object
//
//  Arguments:  [pJob]             - object from which to read property
//              [szMethodName]     - for logging, name of method to call
//              [pfnGetJobStrProp] - pointer to ITask method to call
//              [ppwszProp]        - filled with new'd string
//              [phr]              - modified on error
//
//  Modifies:   *[phr] on error
//
//  History:    01-05-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID GetStringProp(
    ITask *pJob,
    LPCSTR szMethodName,
    GETSTRINGPROPFN pfnGetJobStrProp,
    WCHAR **ppwszProp,
    HRESULT *phr)
{
    HRESULT hr = S_OK;
    UINT    cchProp;

    do
    {
        hr = (pJob->*pfnGetJobStrProp)(ppwszProp);

        if (hr == E_NOTIMPL)
        {
            g_Log.Write(
                LOG_WARN,
                "Ignoring E_NOTIMPL from ITask::Get%s",
                szMethodName);
            hr = S_OK;
            break;
        }

        if (FAILED(hr))
        {
            g_Log.Write(
                LOG_FAIL,
                "ITask::Get%s(ppwszProp) hr=%#010x",
                szMethodName,
                hr);
        }
    }
    while (0);

    if (FAILED(hr))
    {
        *phr = hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\parse.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       parse.cxx
//
//  Contents:   Functions that support parsing.
//
//  History:    04-01-95   DavidMun   Created
//
//----------------------------------------------------------------------------

#include <headers.hxx>
#pragma hdrstop
#include "jt.hxx"

//
// Private globals
//
// s_awszTokens - the strings in this array must exactly match the order
// of tokens in the TOKEN enum in parse.hxx.
//



WCHAR *s_awszTokens[] =
{
    L"ABJ",
    L"ABQ",
    L"AJQ",
    L"CSAGE",
    L"CTJ",
    L"CTQ",
    L"DTJ",
    L"DTQ",
    L"EJ",
    L"EJQ",
    L"ENC",
    L"ENN",
    L"ENR",
    L"ENS",
    L"GC",
    L"GM",
    L"LJ",
    L"LQ",
    L"NSGA",
    L"NSSA",
    L"PJ",
    L"PQ",
    L"PRJ",
    L"PRQ",
    L"PSJ",
    L"PSQ",
    L"PTJ",
    L"PTQ",
    L"RJ",
    L"RQ",
    L"RMJQ",
    L"SAC",
    L"SAJ",
    L"SAQ",
    L"SC",
    L"SCE",
    L"SD",
    L"SE",
    L"ISJQ",
    L"SJ",
    L"SM",
    L"SNJ",
    L"SNQ",
    L"SQ",
    L"STJ",
    L"STQ",
    L"SVJ",
    L"SVQ",
    L"ApplicationName",
    L"Parameters",
    L"WorkingDirectory",
    L"Comment",
    L"Creator",
    L"Priority",
    L"MaxRunTime",
    L"TaskFlags",
    L"Interactive",
    L"DeleteWhenDone",
    L"Suspend",
    L"NetSchedule",
    L"DontStartIfOnBatteries",
    L"KillIfGoingOnBatteries",
    L"RunOnlyIfLoggedOn",
    L"Hidden",
    L"StartDate",
    L"EndDate",
    L"StartTime",
    L"MinutesDuration",
    L"HasEndDate",
    L"KillAtDuration",
    L"StartOnlyIfIdle",
    L"KillOnIdleEnd",
    L"RestartOnIdleResume",
    L"SystemRequired",
    L"Disabled",
    L"MinutesInterval",
    L"Type",
    L"TypeArguments",
    L"IDLE",
    L"NORMAL",
    L"HIGH",
    L"REALTIME",
    L"ONCE",
    L"DAILY",
    L"WEEKLY",
    L"MONTHLYDATE",
    L"MONTHLYDOW",
    L"YEARLYDATE",
    L"YEARLYDOW",
    L"ONIDLE",
    L"ATSTARTUP",
    L"ATLOGON",

    //
    // CAUTION: single-character nonalpha tokens need to be added to the
    // constant DELIMITERS.
    //

    L"TODAY",
    L"NOW",
    L"=",
    L"@",
    L"?",
    L":",
    L",",
    L"!"
};

const WCHAR DELIMITERS[] = L"=@?:,!;/- \t";

#define NUM_TOKEN_STRINGS ARRAY_LEN(s_awszTokens)

//
// Forward references
//

WCHAR *SkipSpaces(WCHAR *pwsz);
TOKEN _GetStringToken(WCHAR **ppwsz);
TOKEN _GetNumberToken(WCHAR **ppwsz, WCHAR *pwszEnd);


//+---------------------------------------------------------------------------
//
//  Function:   ProcessCommandLine
//
//  Synopsis:   Dispatch to the routine that completes parsing for and carries
//              out the next command specified on [pwszCommandLine].
//
//  Arguments:  [pwszCommandLine] - command line
//
//  Returns:    S_OK - command performed
//              E_*  - error logged
//
//  History:    04-21-95   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT ProcessCommandLine(WCHAR *pwszCommandLine)
{
    HRESULT hr;
    WCHAR *pwsz = pwszCommandLine;
    static CHAR s_szJob[] = "Job";
    static CHAR s_szQueue[] = "Queue";

    //
    // If a command starts with TKN_BANG instead of TKN_SWITCH, then its
    // return value will be ignored.  Clear this flag in any case statement
    // that should cause a failure regardless of the use of TKN_BANG (see
    // TKN_INVALID, for example).
    //

    BOOL   fIgnoreReturnValue = FALSE;

    while (*pwsz)
    {
        WCHAR  *pwszLast = pwsz;
        TOKEN   tkn;

        hr = S_OK;

        tkn = GetToken(&pwsz);

        if (tkn == TKN_EOL)
        {
            break;
        }

        if (tkn == TKN_SWITCH)
        {
            tkn = GetToken(&pwsz);
        }
        else if (tkn == TKN_BANG)
        {
            fIgnoreReturnValue = TRUE;
            tkn = GetToken(&pwsz);
        }
        else if (tkn != TKN_ATSIGN && tkn != TKN_QUESTION)
        {
            hr = E_FAIL;
            LogSyntaxError(tkn, L"'/', '-', '?', '!', or '@'");
            break;
        }

        switch (tkn)
        {
#if 0
        case TKN_ABORTQUEUE:
            hr = Abort(&pwsz, FALSE);
            break;

        case TKN_LOADQUEUE:
            hr = Load(&pwsz, s_szQueue, FALSE);
            break;

        case TKN_CREATETRIGGERQUEUE:
            hr = CreateTrigger(&pwsz, FALSE);
            break;

        case TKN_DELETETRIGGERQUEUE:
            hr = DeleteTrigger(&pwsz, FALSE);
            break;

        case TKN_EDITJOBINQUEUE:
            hr = EditJob(&pwsz, FALSE);
            break;

        case TKN_PRINTQUEUE:
            hr = PrintAll(&pwsz, FALSE);
            break;

        case TKN_PRINTRUNTIMEQUEUE:
            hr = PrintRunTimes(&pwsz, FALSE);
            break;

        case TKN_PRINTTRIGGERQUEUE:
            hr = PrintTrigger(&pwsz, FALSE);
            break;

        case TKN_PRINTSTRINGQUEUE:
            hr = PrintTriggerStrings(&pwsz, s_szQueue, FALSE);
            break;

        case TKN_RUNQUEUE:
            hr = Run(FALSE);
            break;

        case TKN_SAVEQUEUE:
            hr = Save(&pwsz, s_szQueue, FALSE);
            break;

        case TKN_SETTRIGGERQUEUE:
            hr = SetTrigger(&pwsz, FALSE);
            break;

#endif
        case TKN_ATSIGN:
            hr = DoAtSign(&pwsz);
            break;

        case TKN_ABORTJOB:
            hr = Abort(&pwsz, TRUE);
            break;

#ifndef RES_KIT
        case TKN_CONVERTSAGETASKSTOJOBS:
            hr = ConvertSage();
            break;
#endif // RES_KIT not defined

        case TKN_CREATETRIGGERJOB:
            hr = CreateTrigger(&pwsz, TRUE);
            break;

        case TKN_DELETETRIGGERJOB:
            hr = DeleteTrigger(&pwsz, TRUE);
            break;

#ifndef RES_KIT
        case TKN_EDITJOB:
            hr = EditJob(&pwsz, TRUE);
            break;

        case TKN_ENUMCLONE:
            hr = EnumClone(&pwsz);
            break;

        case TKN_ENUMNEXT:
            hr = EnumNext(&pwsz);
            break;

        case TKN_ENUMRESET:
            hr = EnumReset(&pwsz);
            break;

        case TKN_ENUMSKIP:
            hr = EnumSkip(&pwsz);
            break;
#endif // RES_KIT not defined

        case TKN_EOL:
            hr = E_FAIL;
            fIgnoreReturnValue = FALSE;  // be sure we exit loop
            g_Log.Write(LOG_ERROR, "Unexpected end of line after switch character");
            break;

        case TKN_GETCREDENTIALS:
            hr = GetCredentials();
            break;

        case TKN_GETMACHINE:
            hr = SchedGetMachine();
            break;

        case TKN_INVALID:
            hr = E_FAIL;
            fIgnoreReturnValue = FALSE;  // be sure we exit loop
            LogSyntaxError(tkn, L"valid token after switch");
            break;

        case TKN_LOADJOB:
            hr = Load(&pwsz, s_szJob, TRUE);
            break;

        case TKN_SETCREDENTIALS:
            hr = SetCredentials(&pwsz);
            break;

        case TKN_SETMACHINE:
            hr = SchedSetMachine(&pwsz);
            break;

        case TKN_PRINTJOB:
            hr = PrintAll(&pwsz, TRUE);
            break;

        case TKN_PRINTRUNTIMEJOB:
            hr = PrintRunTimes(&pwsz, TRUE);
            break;

        case TKN_PRINTTRIGGERJOB:
            hr = PrintTrigger(&pwsz, TRUE);
            break;

        case TKN_PRINTSTRINGJOB:
            hr = PrintTriggerStrings(&pwsz, s_szJob, TRUE);
            break;

        case TKN_NSGETACCOUNTINFO:
            hr = PrintNSAccountInfo();
            break;

        case TKN_NSSETACCOUNTINFO:
            hr = SetNSAccountInfo(&pwsz);
            break;

        case TKN_QUESTION:
            DoHelp(&pwsz);
            break;

        case TKN_RUNJOB:
            hr = Run(TRUE);
            break;

        case TKN_SAVEJOB:
            hr = Save(&pwsz, s_szJob, TRUE);
            break;

        case TKN_SCHEDADDJOB:
            hr = SchedAddJob(&pwsz);
            break;

        case TKN_SCHEDACTIVATE:
            hr = SchedActivate(&pwsz);
            break;

#ifndef RES_KIT
        case TKN_SCHEDCREATEENUM:
            hr = SchedCreateEnum(&pwsz);
            break;
#endif // RES_KIT not defined

        case TKN_SCHEDDELETE:
            hr = SchedDelete(&pwsz);
            break;

        case TKN_SCHEDENUM:
            hr = SchedEnum(&pwsz);
            break;

#ifndef RES_KIT
        case TKN_SCHEDISJOBORQUEUE:
            hr = SchedIsJobOrQueue(&pwsz);
            break;
#endif // RES_KIT not defined

        case TKN_SCHEDNEWJOB:
            hr = SchedNewJob(&pwsz);
            break;

        case TKN_SETJOB:
            hr = SetJob(&pwsz);
            break;

        case TKN_SETTRIGGERJOB:
            hr = SetTrigger(&pwsz, TRUE);
            break;

        default:
            hr = E_FAIL;
            fIgnoreReturnValue = FALSE;  // be sure we exit loop
            LogSyntaxError(tkn, L"command");
            break;
        }

        if (fIgnoreReturnValue)
        {
            fIgnoreReturnValue = FALSE;
        }
        else if (FAILED(hr))
        {
            break;
        }
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   LogSyntaxError
//
//  Synopsis:   Complain that we expected [pwszExpected] but found [tkn].
//
//  Arguments:  [tkn]          - token that was found
//              [pwszExpected] - description of what was expected
//
//  History:    04-21-95   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID LogSyntaxError(TOKEN tkn, WCHAR *pwszExpected)
{
    if (tkn == TKN_INVALID)
    {
        return;
    }

    if (tkn == TKN_EOL)
    {
        g_Log.Write(
            LOG_ERROR,
            "Expected %S but found end of line",
            pwszExpected);
    }
    else
    {
        g_Log.Write(
            LOG_ERROR,
            "Expected %S but found token '%S'",
            pwszExpected,
            GetTokenStringForLogging(tkn));
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   GetToken
//
//  Synopsis:   Return a token representing the next characters in *[ppwsz],
//              and advance *[ppwsz] past the end of this token.
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    token describing characters found
//
//  Modifies:   *[ppwsz]
//
//  History:    04-21-95   DavidMun   Created
//
//----------------------------------------------------------------------------

TOKEN GetToken(WCHAR **ppwsz)
{
    ULONG i;

    *ppwsz = SkipSpaces(*ppwsz);

    if (!**ppwsz)
    {
        return TKN_EOL;
    }

    if (**ppwsz == L';')
    {
        *ppwsz += wcslen(*ppwsz);
        return TKN_EOL;
    }

    if (**ppwsz == L'/' || **ppwsz == L'-')
    {
        ++*ppwsz;
        return TKN_SWITCH;
    }

    if (**ppwsz == L'"')
    {
        return _GetStringToken(ppwsz);
    }

    if (iswdigit(**ppwsz))
    {
        WCHAR *pwszEnd;
        ULONG ulTemp;

        ulTemp = wcstoul(*ppwsz, &pwszEnd, 10);

        g_ulLastNumberToken = ulTemp;
        return _GetNumberToken(ppwsz, pwszEnd);
    }

    ULONG cchToken;

    //
    // We've already skipped leading whitespace, so length of token is number
    // of characters that are not whitespace or single-character tokens.  If
    // wcscspn returns 0, then **ppwsz must be one of the single character
    // tokens.
    //

    cchToken = wcscspn(*ppwsz, DELIMITERS);

    if (!cchToken)
    {
        cchToken = 1;
    }

    //
    // Check the input against all the tokens
    //

    for (i = 0; i < NUM_TOKEN_STRINGS; i++)
    {
        if (!_wcsnicmp(*ppwsz, s_awszTokens[i], cchToken))
        {
            if (wcslen(s_awszTokens[i]) != cchToken)
            {
                continue;
            }
            *ppwsz += cchToken;
            return (TOKEN) i;
        }
    }

    //
    // Not a number or token.  Return it as a string.
    //

    return _GetStringToken(ppwsz);
}




//+---------------------------------------------------------------------------
//
//  Function:   _GetStringToken
//
//  Synopsis:   Treat *[ppwsz] as the start of an optionally quote-enclosed
//              string (even if it's a digit or matches a predefined token).
//
//  Arguments:  [ppwsz]    - command line
//
//  Returns:    TKN_STRING
//              TKN_INVALID - string too long
//
//  Modifies:   Moves *[ppwsz] past end of string; g_wszLastStringToken.
//
//  History:    04-21-95   DavidMun   Created
//              01-08-96   DavidMun   Allow empty strings
//
//----------------------------------------------------------------------------

TOKEN _GetStringToken(WCHAR **ppwsz)
{
    BOOL fFoundQuote = FALSE;

    *ppwsz = SkipSpaces(*ppwsz);

    if (!**ppwsz)
    {
        return TKN_EOL;
    }

    if (**ppwsz == L';')
    {
        *ppwsz += wcslen(*ppwsz);
        return TKN_EOL;
    }

    if (**ppwsz == L'"')
    {
        ++*ppwsz;
        fFoundQuote = TRUE;
    }

    //
    // It's not a recognized token, so consider it a string.  If we found a
    // double-quote, copy everything till next double quote into
    // g_wszLastStringToken.  If not, just copy till next whitespace char or
    // eol.
    //
    // Note that if !fFoundQuote *ppwsz != L'\0' or whitespace or else we
    // would've returned TKN_EOL already.
    //

    ULONG cchToCopy;

    if (fFoundQuote)
    {
        if (**ppwsz == L'"')
        {
            ++*ppwsz;
            g_wszLastStringToken[0] = L'\0';
            return TKN_STRING;
        }

        if (!**ppwsz)
        {
            g_Log.Write(LOG_ERROR, "Syntax: '\"' followed by end of line");
            return TKN_INVALID;
        }

        cchToCopy = wcscspn(*ppwsz, L"\"");

        if ((*ppwsz)[cchToCopy] != L'"')
        {
            *ppwsz += cchToCopy;
            g_Log.Write(LOG_ERROR, "Syntax: unterminated string");
            return TKN_INVALID;
        }
    }
    else
    {
        cchToCopy = wcscspn(*ppwsz, L", \t");
    }

    if (cchToCopy + 1 >= ARRAY_LEN(g_wszLastStringToken))
    {
        *ppwsz += cchToCopy + (fFoundQuote == TRUE);
        g_Log.Write(
            LOG_ERROR,
            "String token > %u characters",
            ARRAY_LEN(g_wszLastStringToken) - 1);
        return TKN_INVALID;
    }

    wcsncpy(g_wszLastStringToken, *ppwsz, cchToCopy);
    g_wszLastStringToken[cchToCopy] = L'\0';
    *ppwsz += cchToCopy + (fFoundQuote == TRUE);
    return TKN_STRING;
}




//+---------------------------------------------------------------------------
//
//  Function:   _GetNumberToken
//
//  Synopsis:   Copy the number starting at *[ppwsz] and ending at [pwszEnd]
//              into g_wszLastNumberToken.
//
//  Arguments:  [ppwsz]   - command line containing number
//              [pwszEnd] - first non-numeric character in command line
//
//  Returns:    TKN_NUMBER - g_wszLastNumberToken modified
//              TKN_INVALID - string too long, g_wszLastNumberToken unchanged
//
//  Modifies:   *[ppwsz] is always moved to [pwszEnd].
//              g_wszLastNumberToken gets copy of number, but only if
//              return value is TKN_NUMBER.
//
//  History:    04-21-95   DavidMun   Created
//
//----------------------------------------------------------------------------

TOKEN _GetNumberToken(WCHAR **ppwsz, WCHAR *pwszEnd)
{
    ULONG cchToCopy;

    cchToCopy = pwszEnd - *ppwsz;

    if (cchToCopy >= ARRAY_LEN(g_wszLastNumberToken))
    {
        *ppwsz = pwszEnd;

        g_Log.Write(
            LOG_ERROR,
            "Number token > %u characters",
            ARRAY_LEN(g_wszLastNumberToken) - 1);
        return TKN_INVALID;
    }

    wcsncpy(g_wszLastNumberToken, *ppwsz, cchToCopy);
    g_wszLastNumberToken[cchToCopy] = L'\0';
    *ppwsz = pwszEnd;

    return TKN_NUMBER;
}




//+---------------------------------------------------------------------------
//
//  Function:   PeekToken
//
//  Synopsis:   Same as GetToken(), but *[ppwsz] is unmodified.
//
//  Arguments:  [ppwsz] - command line
//
//  Returns:    token describing characters at *[ppwsz]
//
//  Modifies:   May modify g_*LastNumberToken, g_wszLastStringToken
//
//  History:    04-21-95   DavidMun   Created
//
//----------------------------------------------------------------------------

TOKEN PeekToken(WCHAR **ppwsz)
{
    WCHAR *pwszSavedPosition = *ppwsz;
    TOKEN tkn;

    tkn = GetToken(ppwsz);
    *ppwsz = pwszSavedPosition;
    return tkn;
}




//+---------------------------------------------------------------------------
//
//  Function:   Expect
//
//  Synopsis:   Get a token and log a syntax error if it isn't [tknExpected]
//
//  Arguments:  [tknExpected] - token we should get
//              [ppwsz]       - command line
//              [wszExpected] - description for logging if next token isn't
//                               [tknExpected].
//
//  Returns:    S_OK   - got expected token
//              E_FAIL - got different token
//
//  Modifies:   *[ppwsz]
//
//  History:    04-21-95   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT Expect(TOKEN tknExpected, WCHAR **ppwsz, WCHAR *wszExpected)
{
    HRESULT hr = S_OK;
    TOKEN   tkn;

    if (tknExpected == TKN_STRING)
    {
        tkn = _GetStringToken(ppwsz);
    }
    else
    {
        tkn = GetToken(ppwsz);
    }

    if (tkn != tknExpected)
    {
        hr = E_FAIL;
        LogSyntaxError(tkn, wszExpected);
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   GetFilename
//
//  Synopsis:   Expect a string token at *[ppwsz] and convert it to a full
//              path in g_wszLastStringToken.
//
//  Arguments:  [ppwsz]       - command line
//              [wszExpected] - for logging if next token isn't string
//
//  Returns:    S_OK - [wszExpected] valid
//
//  Modifies:   *[ppwsz], g_wszLastStringToken
//
//  History:    04-21-95   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT GetFilename(WCHAR **ppwsz, WCHAR *wszExpected)
{
    HRESULT hr = S_OK;
    WCHAR   wszFullPath[MAX_PATH+1];
    ULONG   cchRequired;
    TOKEN   tkn;

    do
    {
        tkn = _GetStringToken(ppwsz);

        if (tkn != TKN_STRING)
        {
            hr = E_FAIL;
            g_Log.Write(
                LOG_FAIL,
                "Expected %S but got invalid or missing string",
                wszExpected);
            break;
        }

#ifdef UNICODE
        cchRequired = GetFullPathName(
                            g_wszLastStringToken,
                            MAX_PATH + 1,
                            wszFullPath,
                            NULL);
#else
        CHAR szToken[MAX_PATH + 1];
        CHAR szFullPath[MAX_PATH + 1];

        wcstombs(szToken, g_wszLastStringToken, MAX_PATH + 1);
        cchRequired = GetFullPathName(
                            szToken,
                            MAX_PATH + 1,
                            szFullPath,
                            NULL);
#endif
        if (!cchRequired)
        {
            hr = E_FAIL;
            g_Log.Write(
                LOG_ERROR,
                "GetFullPathName(%S) %u",
                g_wszLastStringToken,
                GetLastError());
            break;
        }

        if (cchRequired > MAX_PATH)
        {
            hr = E_FAIL;
            g_Log.Write(LOG_ERROR, "Full path > MAX_PATH chars");
            break;
        }

#ifdef UNICODE
        wcscpy(g_wszLastStringToken, wszFullPath);
#else
        mbstowcs(g_wszLastStringToken, szFullPath, MAX_PATH + 1);
#endif
    } while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   ParseDate
//
//  Synopsis:   Fill [pwMonth], [pwDay], and [pwYear] with numeric values
//              taken from the command line in [ppwsz].
//
//  Arguments:  [ppwsz]   - Command line
//              [pwMonth] - filled with first value
//              [pwDay]   - filled with second value
//              [pwYear]  - filled with third value
//
//  Returns:    S_OK - [pwMonth], [pwDay], and [pwYear] contain numbers
//                      (but do not necessarily constitute a valid date)
//              E_*  - error logged
//
//  Modifies:   All args.
//
//  History:    01-04-96   DavidMun   Created
//
//  Notes:      Dates can be of the form:
//
//                      n/n/n
//                      n-n-n
//
//              or any other single character nonalpha token may be used to
//              separate the numbers.  If spaces appear on both sides of
//              the tokens separating the numbers, then the tokens can be
//              of any type at all.
//
//----------------------------------------------------------------------------

HRESULT ParseDate(WCHAR **ppwsz, WORD *pwMonth, WORD *pwDay, WORD *pwYear)
{
    HRESULT     hr = S_OK;
    TOKEN       tkn;
    SYSTEMTIME  stNow;

    do
    {
        tkn = PeekToken(ppwsz);

        if (tkn == TKN_TODAY)
        {
            GetToken(ppwsz);
            GetLocalTime(&stNow);
            *pwMonth = stNow.wMonth;
            *pwDay = stNow.wDay;
            *pwYear = stNow.wYear;
            break;
        }

        hr = Expect(TKN_NUMBER, ppwsz, L"month value");
        BREAK_ON_FAILURE(hr);

        *pwMonth = (WORD) g_ulLastNumberToken;

        GetToken(ppwsz);    // eat whatever separator there is

        hr = Expect(TKN_NUMBER, ppwsz, L"day value");
        BREAK_ON_FAILURE(hr);

        *pwDay = (WORD) g_ulLastNumberToken;

        GetToken(ppwsz);    // eat whatever separator there is

        hr = Expect(TKN_NUMBER, ppwsz, L"year value");
        BREAK_ON_FAILURE(hr);

        *pwYear = (WORD) g_ulLastNumberToken;

        if (*pwYear < 100)
        {
            *pwYear += 1900;
        }
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   ParseTime
//
//  Synopsis:   Fill [pwHour] and [pwMinute] with numeric values taken from
//              the command line in [ppwsz].
//
//  Arguments:  [ppwsz]    - command line
//              [pwHour]   - filled with first number
//              [pwMinute] - filled with second number
//
//  Returns:    S_OK - [pwHour] and [pwMinute] contain numbers (but do not
//                      necessarily constitute a valid time).
//              E_*  - error logged
//
//  Modifies:   All args.
//
//  History:    01-04-96   DavidMun   Created
//
//  Notes:      See ParseDate for rules about delimiters.
//
//----------------------------------------------------------------------------

HRESULT ParseTime(WCHAR **ppwsz, WORD *pwHour, WORD *pwMinute)
{
    HRESULT hr = S_OK;
    TOKEN       tkn;
    SYSTEMTIME  stNow;

    do
    {
        tkn = PeekToken(ppwsz);

        if (tkn == TKN_NOW)
        {
            GetToken(ppwsz);
            GetLocalTime(&stNow);

            //
            // Add some time to the current time so that a trigger with
            // NOW start time is far enough in the future to get run
            //

            AddSeconds(&stNow, TIME_NOW_INCREMENT);

            *pwHour = stNow.wHour;
            *pwMinute = stNow.wMinute;
            break;
        }
        hr = Expect(TKN_NUMBER, ppwsz, L"hour value");
        BREAK_ON_FAILURE(hr);

        *pwHour = (WORD) g_ulLastNumberToken;

        GetToken(ppwsz);    // eat whatever separator there is

        hr = Expect(TKN_NUMBER, ppwsz, L"minute value");

        *pwMinute = (WORD) g_ulLastNumberToken;
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   ParseDaysOfWeek
//
//  Synopsis:   Fill [pwDaysOfTheWeek] with the days of the week specified
//              by the next string token in the command line.
//
//  Arguments:  [ppwsz]           - command line
//              [pwDaysOfTheWeek] - filled with JOB_*DAY bits
//
//  Returns:    S_OK - *[pwDaysOfTheWeek] valid
//              E_*  - invalid string token
//
//  Modifies:   All args.
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT ParseDaysOfWeek(WCHAR **ppwsz, WORD *pwDaysOfTheWeek)
{
    HRESULT hr = S_OK;
    TOKEN   tkn;
    WCHAR   *pwszDay;

    tkn = _GetStringToken(ppwsz);

    if (tkn != TKN_STRING)
    {
        hr = E_FAIL;
    }

    *pwDaysOfTheWeek = 0;

    for (pwszDay = g_wszLastStringToken; SUCCEEDED(hr) && *pwszDay; pwszDay++)
    {
        switch (towupper(*pwszDay))
        {
        case L'U':
            *pwDaysOfTheWeek |= TASK_SUNDAY;
            break;

        case L'M':
            *pwDaysOfTheWeek |= TASK_MONDAY;
            break;

        case L'T':
            *pwDaysOfTheWeek |= TASK_TUESDAY;
            break;

        case L'W':
            *pwDaysOfTheWeek |= TASK_WEDNESDAY;
            break;

        case L'R':
            *pwDaysOfTheWeek |= TASK_THURSDAY;
            break;

        case L'F':
            *pwDaysOfTheWeek |= TASK_FRIDAY;
            break;

        case L'A':
            *pwDaysOfTheWeek |= TASK_SATURDAY;
            break;

        case L'.':
            // ignore this, since we display day as . when its bit is off
            break;

        default:
            hr = E_FAIL;
            g_Log.Write(
                LOG_FAIL,
                "Expected day of week character 'UMTWRFA' but got '%wc'",
                *pwszDay);
            break;
        }
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   ParseDaysOfMonth
//
//  Synopsis:   Translate a comma separated list of day numbers into a bit
//              field in [pdwDays].
//
//  Arguments:  [ppwsz]   - command line
//              [pdwDays] - least significant bit represents day 1
//
//  Returns:    S_OK
//              E_FAIL - syntax or value error
//
//  History:    03-07-96   DavidMun   Created
//
//  Notes:      Day list may contain dashes to indicate day ranges.  For
//              example, "1,3-5,7,10-12" is equivalent to
//              "1,3,4,5,7,10,11,12".  Expressions like "1-3-5" are allowed
//              (it's equivalent to "1-5").  Ranges with the first bit
//              less than the second are automatically swapped, for example
//              "4-2" is treated as "2-4".  So even "4-2-1" would be
//              interpreted as "1-4".
//
//              Day numbers up to 32 are allowed for the purposes of
//              exercising the error checking code in the job scheduler
//              interfaces.
//
//              CAUTION: this function will eat a trailing comma OR SWITCH
//              character!  It is therefore a requirement that a DaysOfMonth
//              list be followed by some other nonswitch string to avoid
//              having it eat the switch character that starts the next
//              command.
//
//----------------------------------------------------------------------------

HRESULT ParseDaysOfMonth(WCHAR **ppwsz, DWORD *pdwDays)
{
    HRESULT hr = S_OK;
    TOKEN   tkn;
    ULONG   ulLastDay = 0;
    BOOL    fGotDash = FALSE;
    ULONG   i;

    *pdwDays = 0;

    do
    {
        tkn = PeekToken(ppwsz);

        //
        // A string, EOL, or error token means we've gone past the end of the
        // list of days and can quit.  (The latter means we're about to
        // abort!)
        //

        if (tkn == TKN_STRING || tkn == TKN_EOL || tkn == TKN_INVALID)
        {
            break;
        }

        //
        // Eat commas, but don't allow "-,".  Also, getting a comma resets the
        // last day to zero, which allows TKN_SWITCH check to complain about
        // "1,-2"
        //

        if (tkn == TKN_COMMA)
        {
            ulLastDay = 0;

            if (fGotDash)
            {
                hr = E_FAIL;
                g_Log.Write(
                    LOG_FAIL,
                    "Expected a number following the dash but got ',' in day of month list");
                break;
            }

            GetToken(ppwsz);
            continue;
        }

        //
        // A dash is valid only if the preceding token was a number
        //

        if (tkn == TKN_SWITCH)
        {
            if (fGotDash)
            {
                hr = E_FAIL;

                g_Log.Write(
                    LOG_FAIL,
                    "Didn't expect two switch characters in a row in day of month list");
                break;
            }

            if (ulLastDay == 0)
            {
                hr = E_FAIL;

                g_Log.Write(
                    LOG_FAIL,
                    "Expected a number preceding switch character in day of month list");
                break;
            }

            //
            // It's ok to have a dash.  Note that we got one, consume the
            // token, and look at the next one.
            //

            fGotDash = TRUE;
            GetToken(ppwsz);
            continue;
        }

        //
        // At this point, anything other than a number means we're done.  If
        // there's a hanging switch, though, that's an error.

        if (tkn != TKN_NUMBER)
        {
            if (fGotDash)
            {
                hr = E_FAIL;
                LogSyntaxError(tkn, L"a number following the switch character");
            }
            break;
        }

        //
        // The next token is TKN_NUMBER, so consume it.  Also make sure it's
        // >= 1 and <= 32.  Yes, 32, because we want to allow specifying an
        // invalid bit pattern to the Job Scheduler code.
        //
        // If fGotDash, this number is the end of a range that started with
        // ulLastDay (which has already been verified).
        //
        // Otherwise it's just a single day bit to turn on.
        //

        GetToken(ppwsz);

        if (g_ulLastNumberToken < 1 ||
#ifndef RES_KIT
            g_ulLastNumberToken > 32)
#else
            g_ulLastNumberToken > 31)
#endif
        {
            hr = E_FAIL;
            g_Log.Write(
                LOG_FAIL,
#ifndef RES_KIT
                "Expected a day number from 1 to 32 (yes, thirty-two) but got %u",
#else
                "Day numbers run from 1 to 31, but %u was passed in, instead.",
#endif
                g_ulLastNumberToken);
            break;
        }

        if (fGotDash)
        {
            fGotDash = FALSE;

            // allow backwards ranges

            if (ulLastDay > g_ulLastNumberToken)
            {
                ULONG ulTemp = ulLastDay;
                ulLastDay = g_ulLastNumberToken;
                g_ulLastNumberToken = ulTemp;
            }

            //
            // Turn on all the bits in the range.  Note that the previous
            // iteration already saw ulLastDay and turned it on, so we can
            // skip that bit.
            //

            for (i = ulLastDay + 1; i <= g_ulLastNumberToken; i++)
            {
                *pdwDays |= 1 << (i - 1);
            }
        }
        else
        {
            *pdwDays |= 1 << (g_ulLastNumberToken - 1);
        }

        ulLastDay = g_ulLastNumberToken;
    } while (TRUE);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   ParseMonths
//
//  Synopsis:   Translate MONTH_ABBREV_LEN character long month
//              abbreviations in [ppwsz] into month bits in [pwMonths].
//
//  Arguments:  [ppwsz]    - command line
//              [pwMonths] - filled with month bits
//
//  Returns:    S_OK
//              E_FAIL
//
//  History:    03-07-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT ParseMonths(WCHAR **ppwsz, WORD *pwMonths)
{
    HRESULT hr = S_OK;
    TOKEN   tkn;
    WCHAR   *pwszMonth;
    ULONG   i;

    *pwMonths = 0;

    tkn = _GetStringToken(ppwsz);

    if (tkn != TKN_STRING)
    {
        hr = E_FAIL;
    }
    else if (wcslen(g_wszLastStringToken) % MONTH_ABBREV_LEN)
    {
        hr = E_FAIL;
        g_Log.Write(
            LOG_FAIL,
            "Month string must consist of %u letter abbreviations",
            MONTH_ABBREV_LEN);
    }

    for (pwszMonth = g_wszLastStringToken;
        SUCCEEDED(hr) && *pwszMonth;
        pwszMonth += 3)
    {
        for (i = 0; i < 12; i++)
        {
            if (!_wcsnicmp(pwszMonth, g_awszMonthAbbrev[i], MONTH_ABBREV_LEN))
            {
                switch (i)
                {
                case 0:
                    *pwMonths |= TASK_JANUARY;
                    break;

                case 1:
                    *pwMonths |= TASK_FEBRUARY;
                    break;

                case 2:
                    *pwMonths |= TASK_MARCH;
                    break;

                case 3:
                    *pwMonths |= TASK_APRIL;
                    break;

                case 4:
                    *pwMonths |= TASK_MAY;
                    break;

                case 5:
                    *pwMonths |= TASK_JUNE;
                    break;

                case 6:
                    *pwMonths |= TASK_JULY;
                    break;

                case 7:
                    *pwMonths |= TASK_AUGUST;
                    break;

                case 8:
                    *pwMonths |= TASK_SEPTEMBER;
                    break;

                case 9:
                    *pwMonths |= TASK_OCTOBER;
                    break;

                case 10:
                    *pwMonths |= TASK_NOVEMBER;
                    break;

                case 11:
                    *pwMonths |= TASK_DECEMBER;
                    break;
                }

                //
                // Since we've found the month abbreviation, break out of the
                // inner loop that's comparing abbreviations against the
                // user's string.
                //

                break;
            }
        }

        //
        // If the inner loop found the next MONTH_ABBREV_LEN chars of the
        // user's string in the g_awszMonthAbbrev array, then it executed the
        // break and i would be less than 12.
        //

        if (i >= 12)
        {
            hr = E_FAIL;
            g_Log.Write(
                LOG_FAIL,
                "Expected %u character month abbreviation at '%S",
                MONTH_ABBREV_LEN,
                pwszMonth);
        }
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTokenStringForLogging
//
//  Synopsis:   Return a human-readable string describing [tkn].
//
//  Arguments:  [tkn] - token to describe.
//
//  History:    04-21-95   DavidMun   Created
//
//----------------------------------------------------------------------------

WCHAR *GetTokenStringForLogging(TOKEN tkn)
{
    switch (tkn)
    {
    case TKN_INVALID:
        return L"an invalid token";

    case TKN_EOL:
        return L"end of line";

    case TKN_SWITCH:
        return L"switch character";

    case TKN_STRING:
        return g_wszLastStringToken;

    case TKN_NUMBER:
        return g_wszLastNumberToken;

    default:
        if (tkn < NUM_TOKEN_STRINGS)
        {
            return s_awszTokens[tkn];
        }
        return L"an unknown token value";
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   SkipSpaces
//
//  Synopsis:   Return [pwsz] advanced to end of string, end of line, or
//              next non-space character.
//
//  Arguments:  [pwsz] - string to skip spaces in
//
//  Returns:    [pwsz] + n
//
//  History:    04-21-95   DavidMun   Created
//
//----------------------------------------------------------------------------

WCHAR *SkipSpaces(WCHAR *pwsz)
{
    while (*pwsz && *pwsz == L' ' || *pwsz == L'\t')
    {
        pwsz++;
    }
    return pwsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\resource.h ===
#define RC_NOTIMPL              1
#define RC_USAGE1               2
#define RC_USAGE2               3
#define RC_ABORT                4
#define RC_ATSIGN               5
#define RC_CONVERTSAGE          6
#define RC_TRIGPROPS            7
#define RC_CREATETRIGGER1       8
#define RC_CREATETRIGGER2       9
#define RC_DELETETRIGGER        10
#define RC_EDITJOB              11
#define RC_ISJOBORQUEUE         12
#define RC_LOAD                 13
#define RC_PRINT                14
#define RC_PRINTRUNTIME         15
#define RC_PRINTSTRING          16
#define RC_PRINTTRIGGER         17
#define RC_RUN                  18
#define RC_SAVE                 19
#define RC_ACTIVATE             20
#define RC_ADD                  21
#define RC_DELETE               22
#define RC_ENUM                 23
#define RC_NEW                  24
#define RC_SETJOB               25
#define RC_SETTRIGGER1          26
#define RC_SETTRIGGER2          27
#define RC_ENUMCLONE            28
#define RC_ENUMNEXT             29
#define RC_ENUMRESET            30
#define RC_ENUMSKIP             31
#define RC_CREATEENUM           32
#define RC_GETMACHINE           33
#define RC_SETMACHINE           34
#define RC_SETCREDENTIALS       35
#define RC_GETCREDENTIALS       36
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\schtest\guids.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       guids.cxx
//
//  Contents:   guid allocations - guids are defined in mstask.h
//
//  History:    24-May-95 EricB created
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <windows.h>

// initguid.h requires this.
//
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

//
// mstask.h contains the GUID
// definitions in DEFINE_GUID macros. initguid.h causes the DEFINE_GUID
// definitions to actually allocate data.
//
#include <mstask.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\trigprop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       trigprop.cxx
//
//  Contents:   Implementation of trigger container.
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

#include <headers.hxx>
#pragma hdrstop
#include "jt.hxx"




//+---------------------------------------------------------------------------
//
//  Member:     CTrigProp::CTrigProp
//
//  Synopsis:   Init this.
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CTrigProp::CTrigProp()
{
    Clear();
}




//+---------------------------------------------------------------------------
//
//  Member:     CTrigProp::Clear
//
//  Synopsis:   Clear all fields of trigger.
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID CTrigProp::Clear()
{
    ZeroMemory(&Trigger, sizeof Trigger);
    Trigger.cbTriggerSize = sizeof Trigger;
    flSetFlags = 0;
    flSet = 0;
}




//+---------------------------------------------------------------------------
//
//  Member:     CTrigProp::InitFromActual
//
//  Synopsis:   Set this to contain the same properties as an actual
//              trigger.
//
//  Arguments:  [pTrigger] - interface on actual trigger
//
//  Returns:    S_OK - properties set
//              E_*  - error retrieving properties
//
//  History:    01-08-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT CTrigProp::InitFromActual(ITaskTrigger *pTrigger)
{
    HRESULT      hr = S_OK;
    TASK_TRIGGER ActualTrigger;

    do
    {
        Clear();

        ActualTrigger.cbTriggerSize = sizeof ActualTrigger;

        hr = pTrigger->GetTrigger(&ActualTrigger);
        LOG_AND_BREAK_ON_FAIL(hr, "ITrigger::GetTrigger");

        Trigger = ActualTrigger;
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CTrigProp::Dump
//
//  Synopsis:   Write trigger properties to log.
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID CTrigProp::Dump()
{
    g_Log.Write(LOG_TEXT, "    Type:            %s",
        GetTriggerTypeString(Trigger.TriggerType));
    _DumpTypeArguments();
    g_Log.Write(LOG_TEXT, "    StartDate:       %02d/%02d/%04d",
        Trigger.wBeginMonth,
        Trigger.wBeginDay,
        Trigger.wBeginYear);
    g_Log.Write(LOG_TEXT, "    EndDate:         %02d/%02d/%04d",
        Trigger.wEndMonth,
        Trigger.wEndDay,
        Trigger.wEndYear);
    g_Log.Write(LOG_TEXT, "    StartTime:       %02d:%02d",
        Trigger.wStartHour,
        Trigger.wStartMinute);
    g_Log.Write(LOG_TEXT, "    MinutesDuration: %u",
        Trigger.MinutesDuration);
    g_Log.Write(LOG_TEXT, "    MinutesInterval: %u",
        Trigger.MinutesInterval);

    g_Log.Write(LOG_TEXT, "    Flags:");
    g_Log.Write(LOG_TEXT, "      HasEndDate      = %u",
        (Trigger.rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE) != 0);

    g_Log.Write(LOG_TEXT, "      KillAtDuration  = %u",
        (Trigger.rgFlags & TASK_TRIGGER_FLAG_KILL_AT_DURATION_END) != 0);

    g_Log.Write(LOG_TEXT, "      Disabled        = %u",
        (Trigger.rgFlags & TASK_TRIGGER_FLAG_DISABLED) != 0);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTrigProp::_DumpTypeArguments, private
//
//  Synopsis:   Write trigger properties that are determined by its type
//              to the log.
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID CTrigProp::_DumpTypeArguments()
{
    switch (Trigger.TriggerType)
    {
    case TASK_TIME_TRIGGER_ONCE:
    case TASK_EVENT_TRIGGER_ON_IDLE:
    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
    case TASK_EVENT_TRIGGER_AT_LOGON:
        //
        // No type-specific data.
        //
        break;

    case TASK_TIME_TRIGGER_DAILY:
        g_Log.Write(LOG_TEXT, "    DaysInterval:    %u",
            Trigger.Type.Daily.DaysInterval);
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        g_Log.Write(LOG_TEXT, "    WeeksInterval:   %u",
            Trigger.Type.Weekly.WeeksInterval);

        g_Log.Write(LOG_TEXT, "    DaysOfTheWeek:   %s",
            GetDaysOfWeekString(Trigger.Type.Weekly.rgfDaysOfTheWeek));
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        g_Log.Write(LOG_TEXT, "    Days:            %s",
            GetDaysString(Trigger.Type.MonthlyDate.rgfDays));

        g_Log.Write(LOG_TEXT, "    Months:          %S",
            GetMonthsString(Trigger.Type.MonthlyDate.rgfMonths));
        break;

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        g_Log.Write(LOG_TEXT, "    Week:            %u",
            Trigger.Type.MonthlyDOW.wWhichWeek);

        g_Log.Write(LOG_TEXT, "    DaysOfTheWeek:   %s",
            GetDaysOfWeekString(Trigger.Type.MonthlyDOW.rgfDaysOfTheWeek));

        g_Log.Write(LOG_TEXT, "    Months:          %S",
            GetMonthsString(Trigger.Type.MonthlyDOW.rgfMonths));
        break;

    default:
        g_Log.Write(LOG_TEXT, "    Invalid Type:    %u",
            Trigger.TriggerType);
    }
}




//+---------------------------------------------------------------------------
//
//  Member:     CTrigProp::Parse
//
//  Synopsis:   Read trigger properties from the command line.
//
//  Arguments:  [ppwsz] - command line.
//
//  Returns:    S_OK - filled in trigger property values.
//
//  History:    01-04-96   DavidMun   Created
//
//  Notes:      Sets members flSet and flSetFlags to indicate which
//              properties were set from the command line.  This is used
//              by the edit trigger command to know which props to modify
//              on the actual trigger.
//
//----------------------------------------------------------------------------

HRESULT CTrigProp::Parse(WCHAR **ppwsz)
{
    HRESULT hr = S_OK;
    TOKEN   tkn;
    TOKEN   tknProp;

    Clear();
    tkn = PeekToken(ppwsz);

    while (tkn != TKN_SWITCH && tkn != TKN_EOL && tkn != TKN_INVALID)
    {
        //
        // Get the property name token in tknProp, then eat the equal sign 
        // and, depending on the property, get the appropriate type and number 
        // of values.  
        //

        tknProp = GetToken(ppwsz);

        hr = Expect(TKN_EQUAL, ppwsz, L"=");
        BREAK_ON_FAILURE(hr);

        switch (tknProp)
        {
        case TKN_STARTDATE:
            flSet |= TP_STARTDATE;
            hr = ParseDate(
                    ppwsz,
                    &Trigger.wBeginMonth,
                    &Trigger.wBeginDay,
                    &Trigger.wBeginYear);
            break;

        case TKN_ENDDATE:
            flSet |= TP_ENDDATE;
            hr = ParseDate(
                    ppwsz,
                    &Trigger.wEndMonth,
                    &Trigger.wEndDay,
                    &Trigger.wEndYear);
            break;

        case TKN_STARTTIME:
            flSet |= TP_STARTTIME;
            hr = ParseTime(
                    ppwsz,
                    &Trigger.wStartHour,
                    &Trigger.wStartMinute);
            break;

        case TKN_MINUTESDURATION:
            flSet |= TP_MINUTESDURATION;
            hr = Expect(TKN_NUMBER, ppwsz, L"numeric value for MinutesDuration property");
            Trigger.MinutesDuration = g_ulLastNumberToken;
            break;

        case TKN_HASENDDATE:
            flSetFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;
            hr = Expect(TKN_NUMBER, ppwsz, L"1 or 0 for HasEndDate property");
            if (g_ulLastNumberToken)
            {
                Trigger.rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;
            }
            break;

        case TKN_KILLATDURATION:
            flSetFlags |= TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
            hr = Expect(TKN_NUMBER, ppwsz, L"1 or 0 for KillAtDuration property");
            if (g_ulLastNumberToken)
            {
                Trigger.rgFlags |= TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
            }
            break;

        case TKN_DISABLED:
            flSetFlags |= TASK_TRIGGER_FLAG_DISABLED;
            hr = Expect(TKN_NUMBER, ppwsz, L"1 or 0 for Disabled property");
            if (g_ulLastNumberToken)
            {
                Trigger.rgFlags |= TASK_TRIGGER_FLAG_DISABLED;
            }
            break;

        case TKN_MINUTESINTERVAL:
            flSet |= TP_MINUTESINTERVAL;
            hr = Expect(TKN_NUMBER, ppwsz, L"minutes interval");
            Trigger.MinutesInterval = (DWORD) g_ulLastNumberToken;
            break;

        case TKN_TYPE:
            flSet |= TP_TYPE;
            tkn = GetToken(ppwsz);
            switch (tkn)
            {
            case TKN_ONEDAY:
                Trigger.TriggerType = TASK_TIME_TRIGGER_ONCE;
                break;

            case TKN_DAILY:
                Trigger.TriggerType = TASK_TIME_TRIGGER_DAILY;
                break;

            case TKN_WEEKLY:
                Trigger.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
                break;

            case TKN_MONTHLYDATE:
                Trigger.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
                break;

            case TKN_MONTHLYDOW:
                Trigger.TriggerType = TASK_TIME_TRIGGER_MONTHLYDOW;
                break;

            case TKN_ONIDLE:
                Trigger.TriggerType = TASK_EVENT_TRIGGER_ON_IDLE;
                break;

            case TKN_ATSTARTUP:
                Trigger.TriggerType = TASK_EVENT_TRIGGER_AT_SYSTEMSTART;
                break;

            case TKN_ATLOGON:
                Trigger.TriggerType = TASK_EVENT_TRIGGER_AT_LOGON;
                break;

            default:
                hr = E_FAIL;
                LogSyntaxError(
                    tkn,
                    L"Once, Daily, Weekly, MonthlyDate, MonthlyDOW, OnIdle, AtStartup, or AtLogon");
                break;
            }
            break;

        case TKN_TYPEARGUMENTS:
            flSet |= TP_TYPEARGUMENTS;

            // 
            // BUGBUG this forces user to specify type even if editing type 
            // arguments of an existing trigger with a valid type.  
            //

            if (flSet & TP_TYPE)
            {
                hr = _ParseTriggerArguments(ppwsz, Trigger.TriggerType);
            }
            else
            {
                hr = _ParseTriggerArguments(ppwsz, TASK_TIME_TRIGGER_DAILY);
            }
            break;
        }
        BREAK_ON_FAILURE(hr);

        tkn = PeekToken(ppwsz);
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CTrigProp::_ParseTriggerArguments
//
//  Synopsis:   Parse the command line for the trigger arguments required
//              by trigger type [TriggerType].
//
//  Arguments:  [ppwsz]       - command line
//              [TriggerType] - type of trigger to parse args for
//
//  Returns:    S_OK - Appropriate member of Trigger.Type set.
//              E_*  - error logged
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT CTrigProp::_ParseTriggerArguments(
        WCHAR **ppwsz,
        TASK_TRIGGER_TYPE TriggerType)
{
    HRESULT hr = S_OK;
    TOKEN   tkn;

    switch (TriggerType)
    {
    case TASK_TIME_TRIGGER_ONCE:
    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
    case TASK_EVENT_TRIGGER_AT_LOGON:
    case TASK_EVENT_TRIGGER_ON_IDLE:
        break;

    case TASK_TIME_TRIGGER_DAILY:
        hr = Expect(TKN_NUMBER, ppwsz, L"days interval");
        Trigger.Type.Daily.DaysInterval = (WORD) g_ulLastNumberToken;
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        hr = Expect(TKN_NUMBER, ppwsz, L"weeks interval");
        Trigger.Type.Weekly.WeeksInterval = (WORD) g_ulLastNumberToken;
        BREAK_ON_FAILURE(hr);

        hr = Expect(
            TKN_COMMA,
            ppwsz,
            L"comma separating weeks interval and days of the week string");
        BREAK_ON_FAILURE(hr);

        hr = ParseDaysOfWeek(ppwsz, &Trigger.Type.Weekly.rgfDaysOfTheWeek);
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        hr = ParseDaysOfMonth(ppwsz, &Trigger.Type.MonthlyDate.rgfDays);
        BREAK_ON_FAILURE(hr);

        // 
        // Note ParseDaysOfMonth() will eat the comma separating the days of 
        // the month from the month names.  
        // 

        hr = ParseMonths(ppwsz, &Trigger.Type.MonthlyDate.rgfMonths);
        break;

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        hr = Expect(TKN_NUMBER, ppwsz, L"week number");
        Trigger.Type.MonthlyDOW.wWhichWeek = (WORD) g_ulLastNumberToken;
        BREAK_ON_FAILURE(hr);

        hr = Expect(
            TKN_COMMA,
            ppwsz,
            L"comma separating week number and days of the week string");
        BREAK_ON_FAILURE(hr);

        hr = ParseDaysOfWeek(ppwsz, &Trigger.Type.MonthlyDOW.rgfDaysOfTheWeek);
        BREAK_ON_FAILURE(hr);

        hr = Expect(
            TKN_COMMA,
            ppwsz,
            L"comma separating days of the week string and months");
        BREAK_ON_FAILURE(hr);

        hr = ParseMonths(ppwsz, &Trigger.Type.MonthlyDOW.rgfMonths);
        break;

    default:
        hr = E_FAIL;
        g_Log.Write(
            LOG_FAIL,
            "Invalid trigger type %u discovered while parsing trigger arguments");
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CTrigProp::SetActual
//
//  Synopsis:   Set the properties of an actual trigger object.
//
//  Arguments:  [pTrigger] - interface to actual object to set
//
//  Returns:    S_OK - props set
//              E_*  - couldn't get actual trigger's current props
//
//  History:    01-05-96   DavidMun   Created
//
//  Notes:      Changes only the properties of the trigger that the user
//              specified on the commandline.
//
//----------------------------------------------------------------------------

HRESULT CTrigProp::SetActual(ITaskTrigger *pTrigger)
{
    HRESULT      hr = S_OK;
    TASK_TRIGGER CurTrigger;

    do
    {
        CurTrigger.cbTriggerSize = sizeof CurTrigger;
        hr = pTrigger->GetTrigger(&CurTrigger);
        LOG_AND_BREAK_ON_FAIL(hr, "ITaskTrigger::GetTrigger");

        if (flSet & TP_STARTDATE)
        {
            CurTrigger.wBeginMonth = Trigger.wBeginMonth;
            CurTrigger.wBeginDay = Trigger.wBeginDay;
            CurTrigger.wBeginYear = Trigger.wBeginYear;
        }

        if (flSet & TP_ENDDATE)
        {
            CurTrigger.wEndMonth = Trigger.wEndMonth;
            CurTrigger.wEndDay = Trigger.wEndDay;
            CurTrigger.wEndYear = Trigger.wEndYear;
        }

        if (flSet & TP_STARTTIME)
        {
            CurTrigger.wStartHour = Trigger.wStartHour;
            CurTrigger.wStartMinute = Trigger.wStartMinute;
        }

        if (flSet & TP_MINUTESDURATION)
        {
            CurTrigger.MinutesDuration = Trigger.MinutesDuration;
        }

        if (flSet & TP_MINUTESINTERVAL)
        {
            CurTrigger.MinutesInterval = Trigger.MinutesInterval;
        }

        if (flSet & TP_TYPE)
        {
            CurTrigger.TriggerType = Trigger.TriggerType;
        }

        if (flSet & TP_TYPEARGUMENTS)
        {
            CurTrigger.Type = Trigger.Type;
        }

        //
        // Turn off all the flag bits that user specified a value for.  Then
        // turn back on the ones that the user specified a nonzero value for.
        // 

        CurTrigger.rgFlags &= ~flSetFlags;
        CurTrigger.rgFlags |= Trigger.rgFlags;

        hr = pTrigger->SetTrigger(&CurTrigger);
        LOG_AND_BREAK_ON_FAIL(hr, "ITrigger::SetTrigger");
    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\tint\globals.cxx ===
//+-------------------------------------------------
// globals.cxx
//
// Contains global variables used in this program
//
// 10-31-96 Created
//--------------------------------------------------

#include <mstask.h>
#include <msterr.h>
#include "tint.hxx"

ITask            *g_pITask = NULL;
ITaskTrigger     *g_pITaskTrigger;
ITaskScheduler   *g_pISchedAgent = NULL;
IEnumWorkItems   *g_pIEnumTasks = NULL;
IUnknown         *g_pIUnknown = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\schtest\schtest.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Schedule Application Unit Test
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       schtest.cxx
//
//  Contents:   schedule object test harness
//
//  History:    14-Nov-95 EricB created
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop
#include <mstask.h>
#include <sch_cls.hxx>

DECLARE_INFOLEVEL(Sched);

//const WORD JOB_MILLISECONDS_PER_MINUTE = 60 * 1000;

//+----------------------------------------------------------------------------
// Macro: TEST_HR
// Purpose: tests the HRESULT for error, takes "action" if found
//-----------------------------------------------------------------------------
#define TEST_HR(hr, str, action) \
    if (FAILED(hr)) \
    { \
        fprintf(stderr, #str " failed with error %lx\n", hr); \
        action; \
    }

HINSTANCE g_hInstance;

// flags
#define ST_PRINT_RUNS       0x1
#define ST_CREATE           0x2
#define ST_NEWATJOB         0x4
#define ST_TARGET           0x8

// prototypes
void Usage(int ExitCode);
HRESULT PrintRunTimes(ISchedulingAgent * pSched);
HRESULT CreateJob(ISchedulingAgent * pSched, TCHAR * ptszFileName);
HRESULT CreateAtJob(ISchedulingAgent * pSched);

//+----------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   entry point
//
//-----------------------------------------------------------------------------
int _cdecl
main(int argc, char ** argv)
{
    if (argc < 2)
    {
        Usage(EXIT_SUCCESS);
    }
    DWORD dwFlags = 0;
    char szMsg[80] = "\n** Schedule object test";
    LPTSTR ptszCmdLine = GetCommandLine();
    TCHAR * ptszFileName, * ptszTarget;
    // skip the program name
    TCHAR * ptszToken = _tcspbrk(ptszCmdLine, TEXT(" \t"));
    // delimit the first token
    ptszToken = _tcstok(ptszToken, TEXT(" \t"));
    // parse command line
    do {
        switch (*ptszToken)
        {
        case TEXT('/'):
        case TEXT('-'):
            ptszToken = _tcsinc(ptszToken);
            switch(*ptszToken)
            {

#if !defined(_CHICAGO_) // no AT command support on Chicago

            case TEXT('a'):
            case TEXT('A'):
                dwFlags |= ST_NEWATJOB;
                strcat(szMsg, "; new AT job");
                break;

#endif // #if !defined(_CHICAGO_)

            case TEXT('r'):
            case TEXT('R'):
                dwFlags |= ST_PRINT_RUNS;
                strcat(szMsg, "; print runs");
                break;

            case TEXT('c'):
            case TEXT('C'):
                dwFlags |= ST_CREATE;
                ptszToken = _tcsinc(ptszToken);
                ptszFileName = _tcstok(NULL, TEXT(" \t"));
                if (ptszFileName == NULL || *ptszFileName == TEXT('/') ||
                    *ptszFileName == TEXT('-'))
                {
                    Usage(EXIT_FAILURE);
                }
                sprintf(szMsg + strlen(szMsg), "; create %S", ptszFileName);
                break;

            case TEXT('t'):
            case TEXT('T'):
                dwFlags |= ST_TARGET;
                ptszToken = _tcsinc(ptszToken);
                ptszTarget = _tcstok(NULL, TEXT(" \t"));
                if (ptszTarget == NULL || *ptszTarget == TEXT('/') ||
                    *ptszTarget == TEXT('-') ||
                    lstrlen(ptszTarget) > MAX_COMPUTERNAME_LENGTH)
                {
                    Usage(EXIT_FAILURE);
                }
                sprintf(szMsg + strlen(szMsg), "; target %S", ptszTarget);
                break;

            case TEXT('h'):
            case TEXT('H'):
            case TEXT('?'):
                Usage(EXIT_SUCCESS);

            default:
                Usage(EXIT_FAILURE);
            }
            break;

        default:
            Usage(EXIT_FAILURE);
        }
        ptszToken = _tcstok(NULL, TEXT(" \t"));
    } while (ptszToken);
    strcat(szMsg, "\n");
    printf(szMsg);
    HRESULT hr;
    hr = OleInitialize(NULL);
    TEST_HR(hr, "OleInitialize", return -1);
    ISchedulingAgent * pSched;
    hr = CoCreateInstance(CLSID_CSchedulingAgent, NULL, CLSCTX_INPROC_SERVER,
                          IID_ISchedulingAgent, (void **)&pSched);
    TEST_HR(hr, "CoCreateInstance(CLSID_CSchedulingAgent)", goto Err0);
    if (dwFlags & ST_TARGET)
    {
        WCHAR wszTarget[MAX_COMPUTERNAME_LENGTH + 4] = L"\\\\";
#if defined(UNICODE)
        lstrcat(wszTarget, ptszTarget);
#else
        MultiByteToWideChar(CP_ACP, 0, ptszTarget, -1, wszTarget + 2,
                            MAX_COMPUTERNAME_LENGTH + 2);
#endif
        hr = pSched->SetTargetComputer(wszTarget);
        if (FAILED(hr))
        {
            if (hr == SCHED_E_SERVICE_NOT_INSTALLED)
            {
                printf("\nScheduler not installed on \\\\%S\n", ptszTarget);
                pSched->Release();
                OleUninitialize();
                printf("\n** Test could not be run **\n");
                return(EXIT_SUCCESS);
            }
            fprintf(stderr,
                    "pSched->SetTargetComputer failed with error %lx\n",
                    hr);
            goto Err1;
        }
    }
    if (dwFlags & ST_PRINT_RUNS)
    {
        hr = PrintRunTimes(pSched);
        if (FAILED(hr))
        {
            goto Err1;
        }
    }
    if (dwFlags & ST_CREATE)
    {
        hr = CreateJob(pSched, ptszFileName);
        if (FAILED(hr))
        {
            goto Err1;
        }
    }
    if (dwFlags & ST_NEWATJOB)
    {
        hr = CreateAtJob(pSched);
        if (FAILED(hr))
        {
            goto Err1;
        }
    }
    pSched->Release();
    OleUninitialize();
    printf("\n** Test successfully completed! **\n");
    return(EXIT_SUCCESS);
Err1:
    pSched->Release();
Err0:
    OleUninitialize();
    printf("** Test failed.\n");
    return(EXIT_FAILURE);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateJob
//
//  Synopsis:   creates the named job in the jobs folder
//
//-----------------------------------------------------------------------------
HRESULT
CreateJob(ISchedulingAgent * pSched, TCHAR * ptszFileName)
{
    ITask * pJob;

#if defined(UNICODE)

    HRESULT hr = pSched->NewJob(ptszFileName, IID_ITask, (IUnknown **)&pJob);

#else // convert from ANSI to UNICODE

    WCHAR wszName[SCH_BIGBUF_LEN];
    MultiByteToWideChar(CP_ACP, 0, ptszFileName, -1, wszName, SCH_BIGBUF_LEN);

    HRESULT hr = pSched->NewJob(wszName, IID_ITask, (IUnknown **)&pJob);

#endif
    TEST_HR(hr, "pSched->NewJob", return hr);
    pJob->Release();
    printf("\nJob %S successfully created!\n", ptszFileName);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateJob
//
//  Synopsis:   creates an AT job in the AT jobs folder
//
//-----------------------------------------------------------------------------
HRESULT
CreateAtJob(ISchedulingAgent * pSched)
{
    HRESULT hr = E_NOTIMPL;

#if !defined(_CHICAGO_) // no AT support on Chicago

    AT_INFO At;
    At.Flags = 0;
    At.JobTime = 655 * JOB_MILLISECONDS_PER_MINUTE; // run at 10:50
    At.DaysOfWeek = 0x1f;           // weekdays
    At.DaysOfMonth = 0x00001000;    // on the twelfth
    At.Command = TEXT("sol.exe");
    DWORD dwID;
    hr = ((CSchedule *)pSched)->AddAtJob(At, &dwID);
    TEST_HR(hr, "pSched->AddAtJob", return hr);
    printf("\nAT Job 'at%d.job' successfully created!\n", dwID);

#endif // #if !defined(_CHICAGO_)

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   PrintRunTimes
//
//  Synopsis:   print out the next cRuns run times
//
//-----------------------------------------------------------------------------
HRESULT
PrintRunTimes(ISchedulingAgent * pSched)
{
    SYSTEMTIME stNow;
    GetLocalTime(&stNow);
    LPSYSTEMTIME pstRuns;
    HRESULT hr;
    IEnumJobs * pEnumJobs;
    hr = pSched->Enum(&pEnumJobs);
    TEST_HR(hr, "pSched->Enum", return hr);
    ITask * pJob;
    SYSTEMTIME stEnd = stNow;
    stNow.wHour = stNow.wMinute = 0;
    stEnd.wHour = 23;
    stEnd.wMinute = 59;
    LPWSTR * rgpwszJobNames;
    ULONG cFetched;
    do
    {
        //hr = pEnumJobs->Skip(1);
        //TEST_HR(hr, "pEnumJobs->Skip", pEnumJobs->Release(); return hr);
        hr = pEnumJobs->Next(3, &rgpwszJobNames, &cFetched);
        TEST_HR(hr, "pEnumJobs->Next", break);
        ITask * pJob;
        for (ULONG i = 0; i < cFetched; i++)
        {
            hr = pSched->Activate(rgpwszJobNames[i], IID_ITask,
                                  (IUnknown **)&pJob);
            if (FAILED(hr))
            {
                fprintf(stderr, "pSched->Activate failed with error 0x%x\n",
                        hr);
                break;
            }
            WORD cRuns = 0;
            LPSYSTEMTIME pstRuns;
            hr = pJob->GetRunTimes(&stNow, &stEnd, &cRuns, &pstRuns);
            TEST_HR(hr, "pJob->GetRunTimes", break);
            if (cRuns == 0)
            {
                hr = S_OK;  // hr had been set to S_FALSE
                printf("There are no runs scheduled for %S.\n",
                       rgpwszJobNames[i]);
            }
            else
            {
                printf("Runs scheduled for %S:\n", rgpwszJobNames[i]);
                for (WORD i = 0; i < cRuns; i++)
                {
                    printf("%02d/%02d/%4d at %02d:%02d\n",
                           pstRuns[i].wMonth, pstRuns[i].wDay,
                           pstRuns[i].wYear, pstRuns[i].wHour,
                           pstRuns[i].wMinute);
                    //CTimeNode * ptn = new CTimeNode(&(pstRuns[i]));
                    //if (ptn == NULL)
                    //{
                    //    ERR_OUT("new CTimeNode", E_OUTOFMEMORY);
                    //    hr = E_OUTOFMEMORY;
                    //    break;
                    //}
                }
                CoTaskMemFree(pstRuns);
            }
            pJob->Release();
        }
        for (i = 0; i < cFetched; i++)
        {
            CoTaskMemFree(rgpwszJobNames[i]);
        }
        if (cFetched != 0)
        {
            CoTaskMemFree(rgpwszJobNames);
        }
    }
    while (hr == S_OK);
    pEnumJobs->Release();
    return (hr == S_FALSE) ? S_OK : hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   Usage
//
//-----------------------------------------------------------------------------
void
Usage(int ExitCode)
{
    printf("\nSCHTEST: Schedule object test harness\n\n");
    if (ExitCode == EXIT_FAILURE)
    {
        printf("ERROR: incorrect command line!\n\n");
    }

#if defined(_CHICAGO_) // no AT command support on Chicago

    printf("Usage: schtest [/t <computer>] [/r] [/c <jobname>]\n");
    printf("       /t <computer name> - target another computer (no leading slashes)\n");

#else   // not on Win9x

    printf("Usage: schtest [/t <computer>] [/a] [/r] [/c <jobname>] \n");
    printf("       /t <computer name> - target another computer (no leading slashes)\n");
    printf("       /a - create a new AT job in the AT jobs folder\n");

#endif
    printf("       /r - print out today's run times for all job\n");
    printf("       /c <job name> - create a new job object in the jobs folder\n");
    exit(ExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\tint\resource.h ===
#define RC_NOTIMPL              1
#define RC_USAGE1               2
#define RC_USAGE2               3
#define RC_ABORT                4
#define RC_ATSIGN               5
#define RC_CONVERTSAGE          6
#define RC_TRIGPROPS            7
#define RC_CREATETRIGGER1       8
#define RC_CREATETRIGGER2       9
#define RC_DELETETRIGGER        10
#define RC_EDITJOB              11
#define RC_ISJOBORQUEUE         12
#define RC_LOAD                 13
#define RC_PRINT                14
#define RC_PRINTRUNTIME         15
#define RC_PRINTSTRING          16
#define RC_PRINTTRIGGER         17
#define RC_RUN                  18
#define RC_SAVE                 19
#define RC_ACTIVATE             20
#define RC_ADD                  21
#define RC_DELETE               22
#define RC_ENUM                 23
#define RC_NEW                  24
#define RC_SETJOB               25
#define RC_SETTRIGGER1          26
#define RC_SETTRIGGER2          27
#define RC_ENUMCLONE            28
#define RC_ENUMNEXT             29
#define RC_ENUMRESET            30
#define RC_ENUMSKIP             31
#define RC_CREATEENUM           32
#define RC_GETMACHINE           33
#define RC_SETMACHINE           34
#define RC_SETCREDENTIALS       35
#define RC_GETCREDENTIALS       36
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\st\st.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Unit Test
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       st.cxx
//
//  Contents:   sage API compatability test harness
//
//  History:    26-Jun-96 EricB created
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>
#include "..\..\inc\sage.hxx"

// flags
#define ST_DETECT       0x1
#define ST_ENABLE       0x2
#define ST_TERMINATE    0x4
#define ST_ADDTASK      0x8
#define ST_GETTASK      0x10
#define ST_REMOVETASK   0x20

// prototypes
void Usage(int ExitCode);
BOOL AddTask(HWND);
BOOL GetTask(HWND, int);
BOOL RemoveTask(HWND, int);
BOOL SetSageInputs (int *IOnum, TaskInfo *pti);
BOOL GetSageInputs (int IOnum, TaskInfo *pti);

//
// Function pointers.
//
typedef int (*PFCNVOID)(VOID);
typedef int (*PFCNINT)(int);

//+----------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   entry point
//
//-----------------------------------------------------------------------------
int _cdecl
main(int argc, char ** argv)
{
    if (argc < 2 || argc > 3)
    {
        Usage(EXIT_SUCCESS);
    }
    DWORD dwTest = 0;
    int   iParam = 0;
    char  szMsg[80] = "\n** Sage API test";

    LPSTR pszCmdLine = GetCommandLineA();

    // skip the program name
    CHAR * pszToken = strpbrk(pszCmdLine, TEXT(" \t"));

    // delimit the first token
    pszToken = strtok(pszToken, TEXT(" \t"));

    // parse command line
    do {
        switch (*pszToken)
        {
        case TEXT('/'):
        case TEXT('-'):
            pszToken++;
            switch(*pszToken)
            {
            case TEXT('d'):
            case TEXT('D'):
                dwTest = ST_DETECT;
                strcat(szMsg, "; System_Agent_Detect");
                break;

            case TEXT('e'):
            case TEXT('E'):
                dwTest = ST_ENABLE;
                pszToken++;
                TCHAR * ptszFunction;
                ptszFunction = strtok(NULL, TEXT(" \t"));
                if (ptszFunction == NULL || *ptszFunction == TEXT('/') ||
                    *ptszFunction == TEXT('-'))
                {
                    Usage(EXIT_FAILURE);
                }
                iParam = (WORD)strtol(ptszFunction, NULL, 10);
                sprintf(szMsg + strlen(szMsg), "; System_Agent_Enable(%i)",
                        iParam);
                break;

            case TEXT('t'):
            case TEXT('T'):
                dwTest = ST_TERMINATE;
                strcat(szMsg, "; System_Agent_Terminate");
                break;

            case TEXT('a'):
            case TEXT('A'):
                dwTest = ST_ADDTASK;
                strcat(szMsg, "; AddTask");
                break;

            case TEXT('g'):
            case TEXT('G'):
                dwTest = ST_GETTASK;
                pszToken++;
                ptszFunction = strtok(NULL, TEXT(" \t"));
                if (ptszFunction == NULL || *ptszFunction == TEXT('/') ||
                    *ptszFunction == TEXT('-'))
                {
                    Usage(EXIT_FAILURE);
                }
                iParam = (WORD)strtol(ptszFunction, NULL, 10);
                sprintf(szMsg + strlen(szMsg), "; GetTask(%i)",
                        iParam);
                break;

            case TEXT('r'):
            case TEXT('R'):
                dwTest = ST_REMOVETASK;
                pszToken++;
                ptszFunction = strtok(NULL, TEXT(" \t"));
                if (ptszFunction == NULL || *ptszFunction == TEXT('/') ||
                    *ptszFunction == TEXT('-'))
                {
                    Usage(EXIT_FAILURE);
                }
                iParam = (WORD)strtol(ptszFunction, NULL, 10);
                sprintf(szMsg + strlen(szMsg), "; RemoveTask(%i)",
                        iParam);
                break;

            case TEXT('h'):
            case TEXT('H'):
            case TEXT('?'):
                Usage(EXIT_SUCCESS);

            default:
                Usage(EXIT_FAILURE);
            }
            break;

        default:
            // not a switch character (/ or -)
            Usage(EXIT_FAILURE);
        }
        pszToken = strtok(NULL, TEXT(" \t"));
    } while (pszToken);

    strcat(szMsg, "\n\n");
    printf(szMsg);

    HWND hAgent = NULL;
    HINSTANCE hSageLib = NULL;

    if (dwTest == ST_DETECT || dwTest == ST_ENABLE || dwTest == ST_TERMINATE)
    {
        hSageLib = LoadLibrary("SAGE.DLL");

        if (hSageLib == NULL)
        {
            printf("Load of sage.dll failed with error %d\n", GetLastError());
            goto Err;
        }
    }
    else
    {
        hAgent = FindWindow ("SAGEWINDOWCLASS", "SYSTEM AGENT COM WINDOW");
        if (hAgent == NULL)
        {
            printf("16 bit API test: Scheduling Agent not running!\n");
            goto Err;
        }
    }

    int iRet;
    PFCNVOID pfnDetect, pfnTerminate;
    PFCNINT pfnEnable;

    switch (dwTest)
    {
    case ST_DETECT:
        pfnDetect = (PFCNVOID)GetProcAddress(hSageLib, "System_Agent_Detect");
        if (pfnDetect == NULL)
        {
            printf("GetProcAddress failed with error %d\n", GetLastError());
            goto Err;
        }

        iRet = pfnDetect();

        printf("System_Agent_Detect returned %d\n", iRet);
        break;

    case ST_ENABLE:
        pfnEnable = (PFCNINT)GetProcAddress(hSageLib, "System_Agent_Enable");
        if (pfnEnable == NULL)
        {
            printf("GetProcAddress failed with error %d\n", GetLastError());
            goto Err;
        }

        iRet = pfnEnable(iParam);

        printf("System_Agent_Enable returned %d\n", iRet);
        break;

    case ST_TERMINATE:
        pfnTerminate = (PFCNVOID)GetProcAddress(hSageLib,
                                                "System_Agent_Terminate");
        if (pfnTerminate == NULL)
        {
            printf("GetProcAddress failed with error %d\n", GetLastError());
            goto Err;
        }

        iRet = pfnTerminate();

        printf("System_Agent_Terminate returned %d\n", iRet);
        break;

    case ST_ADDTASK:
        if (!AddTask(hAgent))
        {
            goto Err;
        }
        break;

    case ST_GETTASK:
        if (!GetTask(hAgent, iParam))
        {
            goto Err;
        }
        break;

    case ST_REMOVETASK:
        if (!RemoveTask(hAgent, iParam))
        {
            goto Err;
        }
        break;

    default:
        Usage(EXIT_FAILURE);
    }

    printf("\n** Test successfully completed! **\n");
    return(EXIT_SUCCESS);

Err:
    printf("\n** Test failed.\n");
    return(EXIT_FAILURE);
}

char *pszREGIOpath = "Software\\Microsoft\\Plus!\\System Agent";
char *pszREGIOkey  = "IOKey%lu";
#define cbRESOURCE   256
#define nKeySageMAX  100    // Don't try over 100 keys
#define SAGE_ADDTASK            (WM_USER + 9)
#define SAGE_REMOVETASK         (WM_USER + 10)
#define SAGE_GETTASK            (WM_USER + 11)

//+----------------------------------------------------------------------------
//
//  Function:   AddTask
//
//-----------------------------------------------------------------------------
BOOL AddTask(HWND hAgent)
{
    TaskInfo ti = {0};

    ti.StructureSize = sizeof(TaskInfo);
    ti.BeginTime.wYear      = (WORD)-1;
    ti.BeginTime.wMonth     = (WORD)-1;
    ti.BeginTime.wDay       = (WORD)-1;
    ti.BeginTime.wDayOfWeek = (WORD)-1;
    ti.BeginTime.wDay       = (WORD)-1;
    ti.BeginTime.wHour      = 12;
    ti.BeginTime.wMinute    = 10;
    ti.EndTime.wYear        = (WORD)-1;
    ti.EndTime.wMonth       = (WORD)-1;
    ti.EndTime.wDay         = (WORD)-1;
    ti.EndTime.wDayOfWeek   = (WORD)-1;
    ti.EndTime.wDay         = (WORD)-1;
    ti.EndTime.wHour        = 13;
    ti.EndTime.wMinute      = 50;

    ti.Time_Granularity = 900;  // seconds = 15 minutes.
    ti.StopAfterTime = 600;     // seconds = 10 minutes.

    lstrcpy(ti.CommandLine, "sol");
    lstrcpy(ti.Comment, "this is a test of the 16 bit Sage support.");

    GetStartupInfo(&ti.StartupInfo);
    ti.StartupInfo.cb = sizeof(STARTUPINFO); 

    ti.CreatorId = (unsigned long)GetCurrentProcess();

    int IOnum;

    if (!SetSageInputs(&IOnum, &ti))
        return FALSE;

    LRESULT lRet =
    SendMessage(hAgent, SAGE_ADDTASK, (WPARAM)IOnum, (LPARAM)ti.CreatorId);

    SetSageInputs(&IOnum, NULL); // Delete the regkey

    if (lRet > 0)
    {
        printf("AddTask added a task with Task_Identifier of %u.\n", lRet);
    }
    else
    {
        printf("AddTask failed to add a task.\n");
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetTask
//
//-----------------------------------------------------------------------------
BOOL GetTask(HWND hAgent, int iTask)
{
    char szValue[cbRESOURCE];
    int IOnum;
    HKEY hk;
    DWORD dwType;

    if (RegCreateKey(HKEY_LOCAL_MACHINE, pszREGIOpath, &hk) != ERROR_SUCCESS)
        return FALSE;

    for (IOnum = 0; IOnum < nKeySageMAX; IOnum++)
    {
        wsprintf(szValue, pszREGIOkey, (unsigned long)IOnum);

        if (RegQueryValueEx(hk, szValue, NULL, &dwType, NULL, NULL)
            != ERROR_SUCCESS)
        {
            break;
        }
    }
    RegCloseKey(hk);

    LRESULT lRet =
    SendMessage(hAgent, SAGE_GETTASK, (WPARAM)IOnum, (LPARAM)iTask);

    TaskInfo ti;

    if (lRet > 0)
    {
        printf("GetTask returned a task with Task_Identifier of %u.\n", lRet);
    }
    else
    {
        printf("GetTask failed to return a task.\n");
        return FALSE;
    }

    if (!GetSageInputs(IOnum, &ti))
    {
        printf("Unable to read the task from the registry!\n");
        return FALSE;
    }

    printf("The task data has been left in the registry at:\n"
           "HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Plus!\\System Agent: "
           "IOKey%lu\n", (unsigned long)IOnum);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveTask
//
//-----------------------------------------------------------------------------
BOOL RemoveTask(HWND hAgent, int iTask)
{
    LRESULT lRet =
    SendMessage(hAgent, SAGE_REMOVETASK, 0, (LPARAM)iTask);

    if (lRet > 0)
    {
        printf("RemoveTask deleted a task with Task_Identifier of %u.\n", iTask);
    }
    else
    {
        printf("RemoveTask failed to delete a task.\n");
        return FALSE;
    }

    return TRUE;
}

/*** SetSageInputs - Create or remove a regkey for IPC with SAGE
 *
 * If called with a non-NULL {TaskInfo*}, this function will create a new
 * registry value for IPC with SAGE, returning in {*IOnum} an index to that
 * new registry value.
 *
 * If called with a NULL {TaskInfo*}, this function will remove the registry
 * key indicated by {*IOnum}.
 *
 * In both cases, TRUE is returned upon success.
 *
 */
BOOL
SetSageInputs(int *IOnum, TaskInfo *pti)
{
    HKEY   hk;
    DWORD  cb;
    DWORD  dwType;
    char   value[cbRESOURCE];
    DWORD  rc;
    BOOL   fDone = FALSE;


    if (RegCreateKey(HKEY_LOCAL_MACHINE, pszREGIOpath, &hk) != ERROR_SUCCESS)
        return FALSE;

    if (pti == NULL) // Delete the previously-used key?
    {
        wsprintf(value, pszREGIOkey, (unsigned long)(*IOnum));
        RegDeleteValue(hk, value);
    }
    else // Or create a new key?
    {
        for (*IOnum = 0; (*IOnum) < nKeySageMAX; (*IOnum)++)
        {
            wsprintf(value, pszREGIOkey, (unsigned long)(*IOnum));

            rc = RegQueryValueEx(hk, value, NULL, &dwType, NULL, NULL);
            if (rc != ERROR_SUCCESS)
                break;
        }

        if ((*IOnum) >= nKeySageMAX)  // Never found a spot for a free key?
        {
            RegCloseKey (hk);
            return FALSE;
        }

        cb = sizeof(*pti);
        rc = RegSetValueEx(hk, value, NULL, REG_BINARY, (const BYTE *)pti, cb);

        if (rc != ERROR_SUCCESS)  // If we couldn't write to the registry
        {  // then something bad is happening.
            RegDeleteKey(hk, value);
            RegCloseKey(hk);
            return FALSE;
        }
        RegCloseKey (hk);
    }

    return TRUE;
}

BOOL
GetSageInputs(int IOnum, TaskInfo *pti)
{
    char   value[cbRESOURCE];
    HKEY   hk;
    DWORD  cb;
    DWORD  dwType;
    LONG   rc;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, pszREGIOpath, &hk) != ERROR_SUCCESS)
        return FALSE;

    wsprintf(value, pszREGIOkey, (unsigned long)IOnum);

    cb = sizeof(*pti);
    rc = RegQueryValueEx(hk, value, NULL, &dwType, (LPBYTE)pti, &cb);

    return (rc == ERROR_SUCCESS) ? TRUE : FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   Usage
//
//-----------------------------------------------------------------------------
void
Usage(int ExitCode)
{
    printf("\nST: sage API compatibility test harness\n\n");
    if (ExitCode == EXIT_FAILURE)
    {
        printf("ERROR: incorrect command line!\n\n");
    }
    printf("Usage: st [/d] | [/e <#>] | [/t] | [/a] | [/g <#>] | [/r <#>]\n");
    printf("       /d - System_Agent_Detect\n");
    printf("            returns the Scheduling Agent version if running\n");
    printf("       /e - System_Agent_Enable\n");
    printf("            # can be one of 1, 2, or 3. If # is 3, then returns 0, 1 or 2\n");
    printf("       /t - System_Agent_Terminate\n");
    printf("            cause the service to exit.\n");
    printf("       /a - AddTask\n");
    printf("            uses the 16 bit method to add a pre-canned task.\n");
    printf("       /g - GetTask\n");
    printf("            uses the 16 bit method to get task #.\n");
    printf("       /r - RemoveTask\n");
    printf("            uses the 16 bit method to remove task #.\n");
    exit(ExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\tint\main.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       main.cxx
//
//  Contents:   Entry point
//
//  History:    10-31-96 Created
//
//----------------------------------------------------------------------------
#ifdef _CHICAGO_
#ifdef UNICODE
#undef UNICODE
#endif
#endif

#include <windows.h>
#include <mstask.h>
#include <msterr.h>
#include <stdio.h>
#include <tchar.h>
#include "tint.hxx"


//
// Forward references
//

HRESULT Init();
VOID Cleanup();
HRESULT StartSchedAgent();
HRESULT EndSchedAgent();

//
// Global variables
//

BOOL g_fSchedAgentRunning = FALSE;
SC_HANDLE g_hSCM, g_hSchedule;

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Entry point for DRT.
//
//  Arguments:  See DisplayUsage().
//
//  Returns:    1 on success, 0 on failure
//
//  History:    10-31-96  (cribbed)
//
//----------------------------------------------------------------------------

ULONG __cdecl main(int argc, char *argv[])
{
    HRESULT hr = S_OK;

        hr = StartSchedAgent();
        if (FAILED(hr))
        {
                printf("Failure to start the scheduling agent. hr = %x\n",hr);
                EndSchedAgent();
                return hr;
        }

    do
    {
        hr = Init();
        if (hr == E_FAIL)
        {
            printf("Initialization Failed with %x\n",hr);
            break;
        };
    TestISchedAgent();
    TestITask();
    TestITaskTrigger();
//    wprintf(L"Pausing 3 seconds to allow service to catch up\n");
    Sleep(3000);
    TestIEnum();
    } while (0);

//    TestGRT();
    Cleanup();
        hr = EndSchedAgent();
        if (FAILED(hr))
        {
                printf("Failure to stop the scheduling agent.  hr = %x\n",hr);
        }
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   Initialize OLE and globals.
//
//  Returns:    S_OK - initialization successful
//              E_*  - error logged
//
//  Modifies:   [g_pITask], [g_pISchedAgent]
//
//  History:    10-31-96  cribbed
//
//----------------------------------------------------------------------------

HRESULT Init()
{
    HRESULT hr = S_OK;

    do
    {
        hr = CoInitialize(NULL);

        if(hr == E_FAIL)
        {
            break;
        }


        hr = CoCreateInstance(
                CLSID_CTask,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ITask,
                (void **)&g_pITask);

        hr = CoCreateInstance(
                CLSID_CSchedulingAgent,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ITaskScheduler,
                (void **)&g_pISchedAgent);
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   Cleanup
//
//  Synopsis:   Do shutdown processing.
//
//  History:    10-31-96  created
//
//----------------------------------------------------------------------------

VOID Cleanup()
{
    if (g_pITask)
    {
        g_pITask->Release();
        g_pITask = NULL;
    }


    if (g_pISchedAgent)
    {
        g_pISchedAgent -> Release();
        g_pISchedAgent = NULL;
    }

    if (g_pIUnknown)
    {
        g_pIUnknown -> Release();
        g_pIUnknown = NULL;
    }

    if (g_pIEnumTasks)
    {
        g_pIEnumTasks->Release();
    }
    CoUninitialize();
}


//+---------------------------------------------------------------------
//
// Function: StartSchedAgent()
//
// Arguments/Returns: nothing
//
// Starts the service IF it is not running.  Modifies global flag
// g_fSchedAgentRunning with initial service state.
//
//-----------------------------------------------------------------------

HRESULT StartSchedAgent()
{
        HRESULT hr = S_OK;

#ifdef _CHICAGO_
// We are the inferior on Win9x - it has no system service
// daemon, no service control manager, no nothing.  We have
// to make extra work for ourselves and fake it with a hidden window.


    const char SCHED_CLASS[16] = "SAGEWINDOWCLASS";
    const char SCHED_TITLE[24] = "SYSTEM AGENT COM WINDOW";
    const char SCHED_SERVICE_APP_NAME[11] = "mstask.exe";

    // is it running?
    HWND hwnd = FindWindow(SCHED_CLASS, SCHED_TITLE);

    if (hwnd != NULL)
    {
        // Already up
        g_fSchedAgentRunning = TRUE;
        return S_OK;
    }
    else
    {
        hr = GetLastError();
        g_fSchedAgentRunning = FALSE;
    }

    // Start me up...
    STARTUPINFO sui;
    PROCESS_INFORMATION pi;

    ZeroMemory(&sui, sizeof(sui));
    sui.cb = sizeof(STARTUPINFO);

    char szApp[MAX_PATH];
    LPSTR pszPath;

    DWORD dwRet = SearchPath(NULL,
                            SCHED_SERVICE_APP_NAME,
                            NULL, MAX_PATH, szApp, &pszPath);
    if (dwRet == 0)
        return GetLastError();

    BOOL fRet = CreateProcess(szApp, NULL, NULL, NULL, FALSE,
                                CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP,
                                NULL, NULL, &sui, &pi);
    if (fRet == FALSE)
        return GetLastError();

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return S_OK;

#else
// It's NT! Do the smart thing and use a service control manager

        LPTSTR lpszMachineName;
        SERVICE_STATUS svcStatus;

        lpszMachineName = new TCHAR[9999];
        hr = GetEnvironmentVariable(_T("COMPUTERNAME"),lpszMachineName, 9999);
        if (FAILED(hr))
        {
                printf("Failed to get machine name\n");
                return hr;
        }

        g_hSCM = OpenSCManager(lpszMachineName, NULL,
                SC_MANAGER_CONNECT | STANDARD_RIGHTS_REQUIRED |
                GENERIC_READ | GENERIC_EXECUTE);
        if (g_hSCM == NULL)
        {
                hr = (HRESULT)GetLastError();
                printf("Service control manager handle not obtained. hr = %x\n",hr);
                return hr;
        }

        delete lpszMachineName;

        g_hSchedule = OpenService(g_hSCM, _T("Schedule"),
                SERVICE_INTERROGATE | SERVICE_STOP | SERVICE_QUERY_STATUS |
                SERVICE_START | STANDARD_RIGHTS_REQUIRED);
        if (g_hSchedule == NULL)
        {
                hr = (HRESULT)GetLastError();
                printf("Schedule Service handle not obtained. hr = %x\n",hr);
                return hr;
        }

        if (QueryServiceStatus(g_hSchedule, &svcStatus) == 0)
        {
                hr = (HRESULT)GetLastError();
                printf("Failed to get service status, hr = %x\n",hr);
                return hr;
        }

        if (svcStatus.dwCurrentState == SERVICE_RUNNING)
        {
                g_fSchedAgentRunning = TRUE;
                return S_OK;
        }
        else
                g_fSchedAgentRunning = FALSE;

        // Start the service

        if (StartService(g_hSchedule, 0, NULL) == 0)
        {
                printf("Failed to start the service!\n");
                hr = (HRESULT)GetLastError();
                return hr;
        }

        // Got to wait for the service to fully start, though
        // or things will fail.
        int nCounter = 0;
        while (svcStatus.dwCurrentState != SERVICE_RUNNING)
        {
                QueryServiceStatus(g_hSchedule, &svcStatus);
                Sleep(250);
                nCounter++;
                if (nCounter > 80)
                {
                        // It's been 20 seconds and we're still not
                        // running.  Fail out.
                        printf("FAILURE - unable to start service after 20 seconds.");
                        return E_FAIL;
                }
        }

        return S_OK;

#endif
}


//+----------------------------------------------------------------
//
// Funtion: EndSchedAgent()
//
// No arguments, but depends on globals g_hSCM, g_hSchedule, and
// g_fSchedAgentRunning
//
//-----------------------------------------------------------------
HRESULT EndSchedAgent()
{
        HRESULT hr = S_OK;

#ifdef _CHICAGO_
// Memphis/Win9x.  No support for an SCM, must use cheap window tricks
// to spoof around it.

    const char SCHED_CLASS[16] = "SAGEWINDOWCLASS";
    const char SCHED_TITLE[24] = "SYSTEM AGENT COM WINDOW";

    if (! g_fSchedAgentRunning)
    {
        // Service was stopped, so we must stop it.
        HWND hwnd = FindWindow(SCHED_CLASS, SCHED_TITLE);

        if (hwnd)
        {
            // It is up and going.  Nuke it.
            SendMessage(hwnd, (WM_USER + 201), NULL, NULL);
        }
    }

#else
// NT.  SCM is cool.

        SERVICE_STATUS svcStatus;

        if (! g_fSchedAgentRunning)
        {
                // Service was stopped.
                if (ControlService(g_hSchedule, SERVICE_CONTROL_STOP,
                                        &svcStatus) == 0)
                {
                        hr = (HRESULT)GetLastError();
                        printf("Failed to stop the service - hr = %x\n",hr);
                }
        }
        if (g_hSchedule)
        {
                if (CloseServiceHandle(g_hSchedule) == 0)
                {
                        hr = (HRESULT)GetLastError();
                        printf("Failed to close service handle - hr = %x\n",hr);
                }
        }

        if (g_hSCM)
        {
                if (CloseServiceHandle(g_hSCM) == 0)
                {
                        hr = (HRESULT)GetLastError();
                        printf("Failed to close service controller handle - hr = %x\n",hr);
                }
        }

#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\jt\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       util.cxx
//
//  Contents:   Miscellaneous utility functions.
//
//  History:    04-04-95   DavidMun   Created
//
//----------------------------------------------------------------------------


#include <headers.hxx>
#pragma hdrstop
#include <msterr.h>
#include "jt.hxx"

//
// Local constants
//

const ULONG MONTH_INDEX_JAN = 0;
const ULONG MONTH_INDEX_FEB = 1;
const ULONG MONTH_INDEX_MAR = 2;
const ULONG MONTH_INDEX_APR = 3;
const ULONG MONTH_INDEX_MAY = 4;
const ULONG MONTH_INDEX_JUN = 5;
const ULONG MONTH_INDEX_JUL = 6;
const ULONG MONTH_INDEX_AUG = 7;
const ULONG MONTH_INDEX_SEP = 8;
const ULONG MONTH_INDEX_OCT = 9;
const ULONG MONTH_INDEX_NOV = 10;
const ULONG MONTH_INDEX_DEC = 11;

const ULONG MONTHS_PER_YEAR = 12;



//+---------------------------------------------------------------------------
//
//  Function:   GetPriorityString
//
//  Synopsis:   Return a human-readable string representing [dwPriority].
//
//  Arguments:  [dwPriority] - process priority
//
//  Returns:    static string
//
//  History:    01-03-96   DavidMun   Created
//
//----------------------------------------------------------------------------

LPCSTR GetPriorityString(DWORD dwPriority)
{
    switch (dwPriority)
    {
    case IDLE_PRIORITY_CLASS:
        return "IDLE";

    case NORMAL_PRIORITY_CLASS:
        return "NORMAL";

    case HIGH_PRIORITY_CLASS:
        return "HIGH";

    case REALTIME_PRIORITY_CLASS:
        return "REALTIME";
    }
    return "INVALID PRIORITY";
}



//+---------------------------------------------------------------------------
//
//  Function:   GetMonthsString
//
//  Synopsis:   Return a static string containing month names for each month
//              bit turned on in [rgfMonths]
//
//  Arguments:  [rgfMonths] - TASK_JANUARY | TASK_FEBRUARY | ... |
//                            TASK_DECEMBER
//
//  Returns:    static string
//
//  History:    03-07-96   DavidMun   Created
//
//----------------------------------------------------------------------------

LPCWSTR GetMonthsString(WORD rgfMonths)
{
    static WCHAR s_wszMonths[MONTHS_PER_YEAR * MONTH_ABBREV_LEN + 1];

    s_wszMonths[0] = '\0';

    if (rgfMonths & TASK_JANUARY)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_JAN]);
    }

    if (rgfMonths & TASK_FEBRUARY)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_FEB]);
    }

    if (rgfMonths & TASK_MARCH)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_MAR]);
    }

    if (rgfMonths & TASK_APRIL)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_APR]);
    }

    if (rgfMonths & TASK_MAY)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_MAY]);
    }

    if (rgfMonths & TASK_JUNE)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_JUN]);
    }

    if (rgfMonths & TASK_JULY)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_JUL]);
    }

    if (rgfMonths & TASK_AUGUST)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_AUG]);
    }

    if (rgfMonths & TASK_SEPTEMBER)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_SEP]);
    }

    if (rgfMonths & TASK_OCTOBER)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_OCT]);
    }

    if (rgfMonths & TASK_NOVEMBER)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_NOV]);
    }

    if (rgfMonths & TASK_DECEMBER)
    {
        wcscat(s_wszMonths, g_awszMonthAbbrev[MONTH_INDEX_DEC]);
    }

    if (s_wszMonths[0] == '\0')
    {
        wcscpy(s_wszMonths, L"None");
    }

    return s_wszMonths;
}




//+---------------------------------------------------------------------------
//
//  Function:   DumpJobFlags
//
//  Synopsis:   Dump description of [flJobFlags] to log.
//
//  Arguments:  [flJobFlags] - TASK_*
//
//  History:    01-03-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID DumpJobFlags(DWORD flJobFlags)
{
#ifndef RES_KIT
    g_Log.Write(
        LOG_TEXT,
        "    Interactive             = %u",
        (flJobFlags & TASK_FLAG_INTERACTIVE) != 0);
#endif
    g_Log.Write(
        LOG_TEXT,
        "    DeleteWhenDone          = %u",
        (flJobFlags & TASK_FLAG_DELETE_WHEN_DONE) != 0);

    g_Log.Write(
        LOG_TEXT,
        "    Suspend                 = %u",
        (flJobFlags & TASK_FLAG_DISABLED) != 0);

    g_Log.Write(
        LOG_TEXT,
        "    StartOnlyIfIdle         = %u",
        (flJobFlags & TASK_FLAG_START_ONLY_IF_IDLE) != 0);

    g_Log.Write(
        LOG_TEXT,
        "    KillOnIdleEnd           = %u",
        (flJobFlags & TASK_FLAG_KILL_ON_IDLE_END) != 0);

    g_Log.Write(
        LOG_TEXT,
        "    RestartOnIdleResume     = %u",
        (flJobFlags & TASK_FLAG_RESTART_ON_IDLE_RESUME) != 0);

    g_Log.Write(
        LOG_TEXT,
        "    DontStartIfOnBatteries  = %u",
        (flJobFlags & TASK_FLAG_DONT_START_IF_ON_BATTERIES) != 0);

    g_Log.Write(
        LOG_TEXT,
        "    KillIfGoingOnBatteries  = %u",
        (flJobFlags & TASK_FLAG_KILL_IF_GOING_ON_BATTERIES) != 0);

    g_Log.Write(
        LOG_TEXT,
        "    RunOnlyIfLoggedOn       = %u",
        (flJobFlags & TASK_FLAG_RUN_ONLY_IF_LOGGED_ON) != 0);

    g_Log.Write(
        LOG_TEXT,
        "    SystemRequired          = %u",
        (flJobFlags & TASK_FLAG_SYSTEM_REQUIRED) != 0);

    g_Log.Write(
        LOG_TEXT,
        "    Hidden                  = %u",
        (flJobFlags & TASK_FLAG_HIDDEN) != 0);


    flJobFlags = flJobFlags &
        ~(TASK_FLAG_INTERACTIVE                 |
          TASK_FLAG_DELETE_WHEN_DONE            |
          TASK_FLAG_DISABLED                    |
          TASK_FLAG_START_ONLY_IF_IDLE          |
          TASK_FLAG_KILL_ON_IDLE_END            |
          TASK_FLAG_RESTART_ON_IDLE_RESUME      |
          TASK_FLAG_DONT_START_IF_ON_BATTERIES  |
          TASK_FLAG_KILL_IF_GOING_ON_BATTERIES  |
          TASK_FLAG_RUN_ONLY_IF_LOGGED_ON       |
          TASK_FLAG_SYSTEM_REQUIRED             |
          TASK_FLAG_HIDDEN);

    if (flJobFlags)
    {
        g_Log.Write(LOG_WARN, "    Unrecognized bits       = %x", flJobFlags);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   DumpTriggers
//
//  Synopsis:   Print all triggers to the log.
//
//  Arguments:  [fJob] - TRUE=>print g_pJob triggers, FALSE=> use g_pJobQueue
//
//  Returns:    S_OK - all triggers printed
//              E_*  - error printing a trigger
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT DumpTriggers(BOOL fJob)
{
    HRESULT hr = S_OK;
    USHORT  i;
    USHORT  cTriggers;

    do
    {
        if (fJob)
        {
            hr = g_pJob->GetTriggerCount(&cTriggers);
            LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetTriggerCount");
        }
        else
        {
#ifdef NOT_YET
            hr = g_pJobQueue->GetTriggerCount(&cTriggers);
            LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::GetTriggerCount");
#endif // NOT_YET
            hr = E_NOTIMPL;
        }

        g_Log.Write(LOG_TEXT, "");

        if (!cTriggers)
        {
            g_Log.Write(LOG_TEXT, "  No triggers");
            break;
        }

        g_Log.Write(
            LOG_TEXT,
            "  %u Trigger%c",
            cTriggers,
            cTriggers == 1 ? ' ' : 's');

        for (i = 0; i < cTriggers; i++)
        {
            hr = DumpTrigger(fJob, i);
        }

    }
    while (0);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   DumpJob
//
//  Synopsis:   Write all job properties to the log.
//
//  Arguments:  [pJob] - job to dump
//
//  Returns:    S_OK - printed
//              E_*  - couldn't read all job properties
//
//  History:    03-11-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT DumpJob(ITask *pJob)
{
    HRESULT hr = S_OK;
    CJobProp    JobProperties;

    do
    {
        g_Log.Write(LOG_TRACE, "Printing all job properties");

        //
        // Print the properties of the job itself first
        //

        hr = JobProperties.InitFromActual(pJob);
        BREAK_ON_FAILURE(hr);

        JobProperties.Dump();
    }
    while (0);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   DumpJobTriggers
//
//  Synopsis:   Write properties of all triggers on job to the log.
//
//  Arguments:  [pJob] - job for which to write trigger properties to log
//
//  Returns:    S_OK - information printed
//              E_*  - couldn't read all trigger properties
//
//  History:    03-11-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT DumpJobTriggers(ITask *pJob)
{
    HRESULT hr = S_OK;
    USHORT  i;
    USHORT  cTriggers;

    do
    {
        hr = pJob->GetTriggerCount(&cTriggers);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetTriggerCount");

        g_Log.Write(LOG_TEXT, "");

        if (!cTriggers)
        {
            g_Log.Write(LOG_TEXT, "  No triggers");
            break;
        }

        g_Log.Write(
            LOG_TEXT,
            "  %u Trigger%c",
            cTriggers,
            cTriggers == 1 ? ' ' : 's');

        for (i = 0; i < cTriggers; i++)
        {
            SpIJobTrigger   spTrigger;
            CTrigProp       TriggerProperties;

            hr = pJob->GetTrigger(i, &spTrigger);
            LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetTrigger");

            hr = TriggerProperties.InitFromActual(spTrigger);
            BREAK_ON_FAILURE(hr);

            g_Log.Write(LOG_TEXT, "");
            g_Log.Write(LOG_TEXT, "  Trigger %u:", i);
            TriggerProperties.Dump();
        }
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   DumpTrigger
//
//  Synopsis:   Print a single trigger to the log
//
//  Arguments:  [fJob]      - TRUE=>print g_pJob triggers,
//                            FALSE=> use g_pJobQueue
//              [usTrigger] - 0-based trigger index
//
//  Returns:    S_OK - trigger printed
//              E_*  - error printing a trigger
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT DumpTrigger(BOOL fJob, USHORT usTrigger)
{
    HRESULT         hr = S_OK;
    SpIJobTrigger   spTrigger;
    CTrigProp       TriggerProperties;

    do
    {
        if (fJob)
        {
            hr = g_pJob->GetTrigger(usTrigger, &spTrigger);
            LOG_AND_BREAK_ON_FAIL(hr, "ITask::GetTrigger");
        }
        else
        {
#ifdef NOT_YET
            hr = g_pJobQueue->GetTrigger(usTrigger, &spTrigger);
            LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::GetTrigger");
#endif // NOT_YET
            hr = E_NOTIMPL;
        }

        hr = TriggerProperties.InitFromActual(spTrigger);
        BREAK_ON_FAILURE(hr);

        g_Log.Write(LOG_TEXT, "");
        g_Log.Write(LOG_TEXT, "  Trigger %u:", usTrigger);
        TriggerProperties.Dump();
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   GetInterfaceString
//
//  Synopsis:   Return string in the form IID_* or "unrecognized interface"
//
//  Arguments:  [iidToBind] - interface
//
//  History:    04-25-95   DavidMun   Created
//              09-11-95   DavidMun   New interfaces
//
//----------------------------------------------------------------------------

LPCSTR GetInterfaceString(REFIID iid)
{
    CHAR *szInterface;

    if (&iid == &IID_IUnknown)
    {
        szInterface = "IID_IUnknown";
    }
    else if (&iid == &IID_ITask)
    {
        szInterface = "IID_ITask";
    }
    else if (&iid == &IID_ITaskTrigger)
    {
        szInterface = "IID_ITaskTrigger";
    }
    else
    {
        szInterface = "unrecognized interface";
    }

    return szInterface;
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTriggerTypeString
//
//  Synopsis:   Return a static human-readable string describing
//              [TriggerType].
//
//  Arguments:  [TriggerType] - TASK_TRIGGER_TYPE
//
//  Returns:    static string
//
//  History:    01-04-96   DavidMun   Created
//              06-13-96   DavidMun   Logon trigger
//
//----------------------------------------------------------------------------

LPCSTR GetTriggerTypeString(TASK_TRIGGER_TYPE TriggerType)
{
    switch (TriggerType)
    {
    case TASK_TIME_TRIGGER_ONCE:
        return "Once";

    case TASK_TIME_TRIGGER_DAILY:
        return "Daily";

    case TASK_TIME_TRIGGER_WEEKLY:
        return "Weekly";

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        return "MonthlyDate";

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        return "MonthlyDOW";

    case TASK_EVENT_TRIGGER_ON_IDLE:
        return "OnIdle";

    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
        return "AtStartup";

    case TASK_EVENT_TRIGGER_AT_LOGON:
        return "AtLogon";
    }
    return "INVALID TRIGGER TYPE";
}




//+---------------------------------------------------------------------------
//
//  Function:   GetDaysString
//
//  Synopsis:   Returns static string representing day bits in
//              [rgfDays].
//
//  Arguments:  [rgfDays] - each of the 32 bits corresponds to a day of the
//                          month.
//
//  Returns:    static string
//
//  History:    03-07-96   DavidMun   Created
//
//  Notes:      This routine supports "day 32" because if the job scheduler
//              erroneously turns on that bit we want to make it visible.
//
//----------------------------------------------------------------------------

LPCSTR GetDaysString(DWORD rgfDays)
{
    static CHAR s_szDaysList[] =
        "1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,32";
    ULONG   i;
    ULONG   j;
    ULONG   ulRunStart = 0;
    BOOL    fInRun = FALSE;

    //
    // Note s_szDaysList is initialized to worst case to get adequately long
    // string.  The most significant bit may be set and we want to display
    // that, so it includes space for 32.
    //

    s_szDaysList[0] = '\0';

    for (i = 0; i <= 32; i++, rgfDays >>= 1)
    {
        if (rgfDays & 1)
        {
            //
            // Day 'i' should be included in the string.  If we're in a run of
            // days that are on, simply continue.  When the run ends we'll add
            // it to the string.
            //
            // If we're not in a run of days, consider this day the start of
            // a new run (which may turn out to be only one day long).
            //

            if (!fInRun)
            {
                fInRun = TRUE;
                ulRunStart = i;
            }
        }
        else if (fInRun)
        {
            //
            // Bit i is a zero, so obviously we're not in a run of ones
            // anymore.  Turn off that flag.
            //

            fInRun = FALSE;

            //
            // The bits from ulRunStart to i-1 were all on.  Find out if the
            // run was just one or two bits long, if that's the case then
            // we don't want to use the m-n list form, the day number(s) should
            // simply be appended to the string.
            //
            // Note that at this point i must be >= 1.
            //

            if (i == 1)
            {
                // ulRunStart == 0.  bit 0 was on, which corresponds to day 1.

                strcpy(s_szDaysList, "1");
            }
            else if (i == 2)
            {
                //
                // ulRunStart == 0 or 1, so the run is 1 or 2 bits long.  So
                // we don't want to use a dash.
                //

                if (ulRunStart == 0)
                {
                    strcpy(s_szDaysList, "1,2");
                }
                else
                {
                    strcpy(s_szDaysList, "2");
                }
            }
            else if (ulRunStart <= i - 3)  // i >= 3 at this point
            {
                // There's a run of > 2 bits, which means we want a dash

                if (s_szDaysList[0])
                {
                    strcat(s_szDaysList, ",");
                }

                //
                // Remember we're converting from a bit position, which is 0
                // based, to a day number, which is 1 based.
                //

                CHAR *pszNext;

                pszNext = s_szDaysList + strlen(s_szDaysList);
                pszNext += wsprintfA(pszNext, "%u", ulRunStart + 1);
                *pszNext++ = '-';
                wsprintfA(pszNext, "%u", i);
            }
            else
            {
                // There's a run of 1 or 2 bits

                CHAR *pszNext = s_szDaysList + strlen(s_szDaysList);

                for (j = ulRunStart; j < i; j++)
                {
                    if (s_szDaysList[0])
                    {
                        *pszNext++ = ',';
                    }

                    pszNext += wsprintfA(pszNext, "%u", j+1);
                }
            }
        }
    }
    return s_szDaysList;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDaysOfWeekString
//
//  Synopsis:   Returns static string representing day bits in
//              [flDaysOfTheWeek].
//
//  Arguments:  [flDaysOfTheWeek] - TASK_*DAY bits
//
//  Returns:    static string
//
//  History:    01-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

LPCSTR GetDaysOfWeekString(WORD flDaysOfTheWeek)
{
    static CHAR s_szDOW[] = "UMTWRFA"; // init to get max size

    sprintf(s_szDOW, ".......");

    if (flDaysOfTheWeek & TASK_SUNDAY)
    {
        s_szDOW[0] = 'U';
    }

    if (flDaysOfTheWeek & TASK_MONDAY)
    {
        s_szDOW[1] = 'M';
    }

    if (flDaysOfTheWeek & TASK_TUESDAY)
    {
        s_szDOW[2] = 'T';
    }

    if (flDaysOfTheWeek & TASK_WEDNESDAY)
    {
        s_szDOW[3] = 'W';
    }

    if (flDaysOfTheWeek & TASK_THURSDAY)
    {
        s_szDOW[4] = 'R';
    }

    if (flDaysOfTheWeek & TASK_FRIDAY)
    {
        s_szDOW[5] = 'F';
    }

    if (flDaysOfTheWeek & TASK_SATURDAY)
    {
        s_szDOW[6] = 'A';
    }
    return s_szDOW;
}




//+---------------------------------------------------------------------------
//
//  Function:   GetStatusString
//
//  Synopsis:   Return a string describing job status.
//
//  Arguments:  [hrJobStatus] - SCHED_* hresult
//
//  Returns:    static string
//
//  History:    01-08-96   DavidMun   Created
//
//----------------------------------------------------------------------------

LPCSTR GetStatusString(HRESULT hrJobStatus)
{
    static CHAR s_szStatus[11]; // big enough for 0x00000000

    switch (hrJobStatus)
    {
    case S_OK:
        return "S_OK";

    case SCHED_S_TASK_READY:
        return "SCHED_S_TASK_READY";

    case SCHED_S_TASK_RUNNING:
        return "SCHED_S_TASK_RUNNING";

    case SCHED_S_TASK_DISABLED:
        return "SCHED_S_TASK_DISABLED";

    case SCHED_S_TASK_TERMINATED:
        return "SCHED_S_TASK_TERMINATED";

    case SCHED_S_TASK_HAS_NOT_RUN:
        return "SCHED_S_TASK_HAS_NOT_RUN";

    case SCHED_S_TASK_NO_VALID_TRIGGERS:
        return "SCHED_S_TASK_NO_VALID_TRIGGERS";

    case SCHED_S_TASK_NO_MORE_RUNS:
        return "SCHED_S_TASK_NO_MORE_RUNS";

    case SCHED_S_TASK_NOT_SCHEDULED:
        return "SCHED_S_TASK_NOT_SCHEDULED";

    case SCHED_E_TASK_NOT_RUNNING:
        return "SCHED_E_TASK_NOT_RUNNING";

    case SCHED_E_SERVICE_NOT_INSTALLED:
        return "SCHED_E_SERVICE_NOT_INSTALLED";

    case SCHED_E_ACCOUNT_INFORMATION_NOT_SET:
        return "SCHED_E_ACCOUNT_INFORMATION_NOT_SET";

#ifdef DELETED
    case SCHED_E_NOT_AN_AT_JOB:
        return "SCHED_E_NOT_AN_AT_JOB";
#endif // DELETED

    default:
        sprintf(s_szStatus, "%#x", hrJobStatus);
        return s_szStatus;
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   Bind
//
//  Synopsis:   Bind to [wszFilename] for [iidToBind].
//
//  Arguments:  [wszFilename] - file to bind to
//              [iidToBind]   - interface to request
//              [ppitf]       - resulting interface
//
//  Returns:    S_OK - *[ppitf] valid
//              E_*  - error logged
//
//  Modifies:   *[ppitf]
//
//  History:    04-20-95   DavidMun   Created
//              04-25-95   DavidMun   Add performance output
//
//----------------------------------------------------------------------------

HRESULT Bind(WCHAR *wszFilename, REFIID iidToBind, VOID **ppitf)
{
    HRESULT     hr = S_OK;
    SpIMoniker  spmk;
    ULONG       ulTicks;

    do
    {
        g_Log.Write(
            LOG_DEBUG,
            "Binding to %S for %s",
            wszFilename,
            GetInterfaceString(iidToBind));

        hr = GetMoniker(wszFilename, &spmk);
        BREAK_ON_FAILURE(hr);

        ulTicks = GetTickCount();
        hr = BindMoniker(spmk, 0, iidToBind, ppitf);
        ulTicks = GetTickCount() - ulTicks;

        g_Log.Write(
            LOG_PERF,
            "Bind to %S for %s %u ms",
            wszFilename,
            GetInterfaceString(iidToBind),
            ulTicks);

        if (FAILED(hr))
        {
            g_Log.Write(
                    LOG_FAIL,
                    "BindMoniker to \"%S\" hr=%#010x",
                    wszFilename,
                    hr);
        }
    }
    while (0);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetMoniker
//
//  Synopsis:   Return a filemoniker to [wszFilename].
//
//  Arguments:  [wszFilename] - file to get moniker for
//              [ppmk]        - resulting moniker
//
//  Returns:    S_OK - *[ppmk] valid
//              E_*  - error logged
//
//  Modifies:   *[ppmk]
//
//  History:    04-20-95   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT GetMoniker(WCHAR *wszFilename, IMoniker **ppmk)
{
    HRESULT hr = S_OK;

    do
    {
        g_Log.Write(LOG_DEBUG, "Creating file moniker to %S", wszFilename);
        hr = CreateFileMoniker(wszFilename, ppmk);

        if (FAILED(hr))
        {
            g_Log.Write(
                LOG_FAIL,
                "CreateFileMoniker(\"%S\") hr=%#010x",
                wszFilename,
                hr);
            break;
        }
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   DupString
//
//  Synopsis:   Fill *[ppwszDest] with a buffer containing a copy of
//              [wszSource].
//
//  Arguments:  [wszSource] - string to copy
//              [ppwszDest] - filled with buffer containing copy
//
//  Returns:    S_OK
//              E_OUTOFMEMORY;
//
//  Modifies:   *[ppwszDest]
//
//  History:    04-20-95   DavidMun   Created
//
//  Notes:      Caller must use delete to free *[ppwszDest].
//
//----------------------------------------------------------------------------

HRESULT DupString(const WCHAR *wszSource, WCHAR **ppwszDest)
{
    HRESULT hr = S_OK;

    *ppwszDest = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR) * (1 + wcslen(wszSource)));

    if (!*ppwszDest)
    {
        hr = E_OUTOFMEMORY;
        g_Log.Write(LOG_ERROR, "DupString: out of memory");
    }
    else
    {
        wcscpy(*ppwszDest, wszSource);
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   HasFilename
//
//  Synopsis:   Return S_OK if object has filename, S_FALSE if not.
//
//  Arguments:  [pPersistFile] - IPFile itf on object
//
//  Returns:    S_OK    - object has filename
//              S_FALSE - object does not have filename
//              E_*     - error logged
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT HasFilename(IPersistFile *pPersistFile)
{
    HRESULT     hr = S_OK;
    LPOLESTR    pstrFile;

    do
    {
        hr = pPersistFile->GetCurFile(&pstrFile);
        LOG_AND_BREAK_ON_FAIL(hr, "IPersistFile::GetCurFile");

        CoTaskMemFree(pstrFile);
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SaveIfDirty
//
//  Synopsis:   Save given job object if it's dirty.
//
//  Arguments:  [pJob] - job to save
//
//  Returns:    S_OK - not dirty or successfully saved
//              E_*  - error logged
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SaveIfDirty(ITask *pJob)
{
    HRESULT         hr = S_OK;
    SpIPersistFile  spPersistFile;

    do
    {
        hr = pJob->QueryInterface(IID_IPersistFile, (void **)&spPersistFile);
        LOG_AND_BREAK_ON_FAIL(hr, "ITask::QI(IPersistFile)");

        hr = _SaveIfDirty(spPersistFile);
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   SaveIfDirty
//
//  Synopsis:   Save queue object if it's dirty.  See job object version.
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT SaveIfDirty(IUnknown *pJobQueue)
{
    HRESULT         hr = S_OK;
    SpIPersistFile  spPersistFile;

    do
    {
        hr = pJobQueue->QueryInterface(
                            IID_IPersistFile,
                            (void **)&spPersistFile);
        LOG_AND_BREAK_ON_FAIL(hr, "ITaskQueue::QI(IPersistFile)");

        hr = _SaveIfDirty(spPersistFile);
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   _SaveIfDirty
//
//  Synopsis:   Save persisted object if it reports it's dirty.
//
//  Arguments:  [pPersistFile] - IPFile on job or queue
//
//  Returns:    S_OK - saved or not dirty
//              E_*  - error logged
//
//  History:    01-10-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT _SaveIfDirty(IPersistFile *pPersistFile)
{
    HRESULT     hr = S_OK;

    do
    {
        hr = HasFilename(pPersistFile);
        BREAK_ON_FAILURE(hr);

        //
        // If the object doesn't have a filename then it can't be persisted.
        //

        if (hr == S_FALSE)
        {
            break;
        }

        //
        // If the object isn't dirty, there's nothing to do
        //

        hr = pPersistFile->IsDirty();
        LOG_AND_BREAK_ON_FAIL(hr, "IPersistFile::IsDirty");

        if (hr == S_FALSE)
        {
            break;
        }

        //
        // Save the object.
        //

        hr = pPersistFile->Save(NULL, TRUE);
        LOG_AND_BREAK_ON_FAIL(hr, "IPersistFile::Save");
    }
    while (0);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   Activate
//
//  Synopsis:   Perform the Activate command
//
//  Arguments:  [wszFileName] - name of job or queue to activate
//              [ppJob]       - filled if file is job
//              [ppQueue]     - filled if file is queue
//              [pfJob]       - set TRUE if [wszFileName] is a job, FALSE
//                               otherwise.
//
//  Returns:    S_OK - *[pfJob] and either *[ppJob] or *[ppQueue] valid
//              E_*  - error logged
//
//  Modifies:   *[pfJob], and either *[ppJob] or *[ppQueue]
//
//  History:    01-30-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT Activate(
            WCHAR *wszFileName,
            ITask **ppJob,
            IUnknown **ppQueue,
            BOOL *pfJob)
{
    HRESULT     hr = S_OK;
    SpIJob      spJob;
    SpIUnknown  spQueue;

    do
    {
        *pfJob = TRUE;

        //
        // BUGBUG remove this ifdef when ITaskScheduler::IsTask() and
        // ITaskScheduler::IsQueue() are implemented.
        //

#ifdef IS_JOB_IMPLEMENTED
        hr = g_pJobScheduler->IsJob(wszFileName);
        LOG_AND_BREAK_ON_FAIL(hr, "ITaskScheduler::IsTask");

        if (hr == S_FALSE)
        {
            hr = g_pJobScheduler->IsQueue(wszFileName);

            if (hr == S_OK)
            {
                *pfJob = FALSE;
            }
            else
            {
                g_Log.Write(
                    LOG_FAIL,
                    "File '%S' is neither a job nor a queue, IsJob hr=S_FALSE, IsQueue hr=%#010x",
                    wszFilename,
                    hr);
                hr = E_FAIL;
                break;
            }
        }
        else if (hr != S_OK)
        {
            g_pLog->Write(
                LOG_FAIL,
                "Unexpected hr from IsJob: %#010x", hr);
            hr = E_FAIL;
            break;
        }
#endif // IS_JOB_IMPLEMENTED

        //
        // Activate the job or queue and ask for the appropriate interface.
        //

        g_Log.Write(
            LOG_TRACE,
            "Activating %s '%S'",
            *pfJob ? "job" : "queue",
            wszFileName);

        if (*pfJob)
        {
            hr = g_pJobScheduler->Activate(
                        wszFileName,
                        IID_ITask,
                        (IUnknown**)(ITask**)&spJob);
        }
        else
        {
            hr = g_pJobScheduler->Activate(
                        wszFileName,
                        IID_IUnknown,
                        (IUnknown**)&spQueue);
        }

        //
        // Bail if the activate failed
        //

        if (FAILED(hr))
        {
            g_Log.Write(
                LOG_FAIL,
                "ITaskScheduler::Activate(%S, IID_ITask%s) hr=%#010x",
                wszFileName,
                *pfJob ? "" : "Queue",
                hr);
            break;
        }

        //
        // Replace the passed in job or queue object with the new one.
        //

        if (*pfJob)
        {
            if (*ppJob)
            {
                hr = SaveIfDirty(*ppJob);
                (*ppJob)->Release();
            }
            spJob.Transfer(ppJob);
        }
        else
        {
            if (*ppQueue)
            {
                hr = SaveIfDirty(*ppQueue);
                (*ppQueue)->Release();
            }
#ifdef NOT_YET
            spQueue.Transfer(ppQueue);
#endif // NOT_YET
            hr = E_NOTIMPL;
        }
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   GetAndPrepareEnumeratorSlot
//
//  Synopsis:   Get an enumerator slot number from the command line.
//
//  Arguments:  [ppwsz]    - command line
//              [pidxSlot] - filled with slot number 0..NUM_ENUMERATOR_SLOTS-1
//
//  Returns:    S_OK - *[pidxSlot] is valid
//              E_INVALIDARG - command line specified bad slot number
//
//  Modifies:   *pidxSlot
//
//  History:    01-30-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT GetEnumeratorSlot(WCHAR **ppwsz, ULONG *pidxSlot)
{
    HRESULT hr = S_OK;

    do
    {
        hr = Expect(TKN_NUMBER, ppwsz, L"enumerator slot number");
        BREAK_ON_FAILURE(hr);

        if (g_ulLastNumberToken >= NUM_ENUMERATOR_SLOTS)
        {
            hr = E_INVALIDARG;
            g_Log.Write(
                LOG_ERROR,
                "got %u for enumerator slot, but value must be in 0..%u",
                g_ulLastNumberToken,
                NUM_ENUMERATOR_SLOTS - 1);
            break;
        }

        *pidxSlot = g_ulLastNumberToken;
    }
    while (0);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   GetAndPrepareEnumeratorSlot
//
//  Synopsis:   Get an enumerator slot number from the command line, and
//              release any existing enumerator at that slot.
//
//  Arguments:  [ppwsz]    - command line
//              [pidxSlot] - filled with slot number 0..NUM_ENUMERATOR_SLOTS-1
//
//  Returns:    S_OK - *[pidxSlot] is valid
//              E_INVALIDARG - command line specified bad slot number
//
//  Modifies:   *pidxSlot, g_apEnumJob[*pidxSlot]
//
//  History:    01-30-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT GetAndPrepareEnumeratorSlot(WCHAR **ppwsz, ULONG *pidxSlot)
{
    HRESULT hr = S_OK;

    do
    {
        hr = GetEnumeratorSlot(ppwsz, pidxSlot);
        BREAK_ON_FAILURE(hr);

        //
        // If there's an existing enumerator, get rid of it.
        //

        if (g_apEnumJobs[*pidxSlot])
        {
            g_Log.Write(
                LOG_TRACE,
                "Releasing existing enumerator in slot %u",
                *pidxSlot);
            g_apEnumJobs[*pidxSlot]->Release();
            g_apEnumJobs[*pidxSlot] = NULL;
        }
    }
    while (0);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   VerifySlotFilled
//
//  Synopsis:   Return S_OK if g_apEnumJob[idxSlot] contains a non-NULL
//              pointer, E_INVALIDARG otherwise.
//
//  History:    01-30-96   DavidMun   Created
//
//----------------------------------------------------------------------------

HRESULT VerifySlotFilled(ULONG idxSlot)
{
    if (!g_apEnumJobs[idxSlot])
    {
        g_Log.Write(
            LOG_ERROR,
            "Slot %u does not contain an enumerator",
            idxSlot);
        return E_INVALIDARG;
    }

    return S_OK;
}




//+---------------------------------------------------------------------------
//
//  Function:   AddSeconds
//
//  Synopsis:   Add [ulSeconds] to [pst].
//
//  Arguments:  [pst]       - valid systemtime
//              [ulSeconds] - seconds to add
//
//  Modifies:   *[pst]
//
//  History:    04-11-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID AddSeconds(SYSTEMTIME *pst, ULONG ulSeconds)
{
    FILETIME ft;
    LONGLONG llTime;
    LONGLONG llIncrement;

    //
    // Convert caller's SYSTEMTIME to a FILETIME, which is easy to do math on.
    //

    SystemTimeToFileTime(pst, &ft);

    //
    // Convert the ulSeconds increment from seconds to 100 ns intervals, which
    // is the unit used in the FILETIME struct.
    //

    llIncrement = ulSeconds;
    llIncrement *= 10000000UL;

    //
    // Convert the FILETIME equivalent of pst into a LONGLONG, then add the
    // increment.
    //

    llTime = ft.dwHighDateTime;
    llTime <<= 32;
    llTime |= ft.dwLowDateTime;
    llTime += llIncrement;

    //
    // Convert the incremented LONGLONG back to a filetime, then convert that
    // back to a SYSTEMTIME
    //

    ft.dwLowDateTime = (DWORD) llTime;
    ft.dwHighDateTime = (DWORD) (llTime >> 32);
    FileTimeToSystemTime(&ft, pst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\types\uuid\guids.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Schedule Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       guids.cxx
//
//  Contents:   schedule service class object GUIDs
//
//  History:    05-Mar-96 EricB added CLSIDs.
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <initguid.h>
#include <mstask.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\test\tint\test.cxx ===
//+-----------------------------------------------------
//
// file: test.cxx
//
// Called from main.cxx, this file actually runs the
// test suite on the interfaces.  We test the following:
//      2. ITaskScheduler
//      3. ITask
//      4. ITaskTrigger
//      5. IEnumWorkItem
// We sort of test IUnknown, in that we use it to get
// the other interfaces.
//
// History:  10-31-96  created
//
//-------------------------------------------------------

#include <string.h>
#include <tchar.h>
#include <wchar.h>
#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include <oleguid.h>
#include <mstask.h>
#include <msterr.h>
#include "tint.hxx"

//+------------------------------------------------------
//
//  Function:   TestISchedAgent
//
//  Synopsis:   Uh.  What it says.
//
//  Arguments:  None
//
//  Returns:    S_OK, but typically caller discards as
//              implicit cast to void.
//
//  History:    10-31-96  created
//--------------------------------------------------------

HRESULT TestISchedAgent()
{
    HRESULT hr = S_OK;

    // Tell where we are
//    wprintf(L"\n----------------------------------------------\n");
//    wprintf(L"Beginning TestISchedAgent\n\n");

    //
    // SetTargetComputer method
    //

    LPWSTR szMyHostName, szMyUNCNameBad;
    DWORD MyHostNameSize;

    MyHostNameSize = 32;
    szMyHostName = (LPWSTR) malloc(32 * sizeof(WCHAR));
    szMyUNCNameBad = (LPWSTR) malloc(32* sizeof(WCHAR));
    wcscpy(szMyUNCNameBad,L"\\FOO");
//    wprintf(L"SetTargetComputer setting computer to %s\n",szMyUNCNameBad);
    hr = g_pISchedAgent -> SetTargetComputer((LPCWSTR) szMyUNCNameBad);
    if (SUCCEEDED(hr))
    {
        wprintf(L"FAILURE! SetTargetComputer on bad name returned %x.\n",hr);
    }
//    wprintf(L"SetTargetComputer setting computer to localhost\n");
    hr = g_pISchedAgent -> SetTargetComputer(NULL);
    if (FAILED(hr))
    {
        wprintf(L"FAILURE! SetTargetComputer on good name returned %x.\n\n",hr);
    }
    free(szMyUNCNameBad);
    free(szMyHostName);

    //
    // Get Target Computer Method
    //

    LPWSTR lszMyMachine;
    hr = g_pISchedAgent -> GetTargetComputer(&lszMyMachine);
    if (FAILED(hr))
        wprintf(L"GetTargetComputer returned hr = %x, %s\n\n",hr,lszMyMachine);
    CoTaskMemFree(lszMyMachine);

    //
    // NewTask method
    //

    IUnknown *pIU;

    pIU = NULL;
    hr = g_pISchedAgent -> NewWorkItem(L"foo\bar.job", CLSID_CTask, IID_ITask, &pIU);

    // File is not returned as error until it is persisted.
    if (pIU)
    {
        IPersistFile *pIPF;
        hr = pIU->QueryInterface(IID_IPersistFile, (void **)&pIPF);
        if (FAILED(hr))
        {
            pIU->Release();
            pIU = NULL;
            wprintf(L"FAIL! Unable to get an IPersistFile for illegal new task.\n");
        }
        hr = pIPF->Save(NULL, FALSE);
        if (SUCCEEDED(hr))
        {
            wprintf(L"FAIL! Succeeded on saving bad task name\n");
        }
        pIU->Release();
        pIU = NULL;
        pIPF->Release();
        pIPF = NULL;
    }

    if (pIU != 0)
    {
        wprintf(L"FAILURE - new illegal task created\n");
        pIU -> Release();
        pIU = NULL;
    }
    else
    {
//        wprintf(L"New Task (bad) returned a pIUnknown of NULL\n");
    }
//    wprintf(L"New Task (bad) returned hr = %x\n",hr);

    hr = g_pISchedAgent -> NewWorkItem(L"foo.job", CLSID_CTask, IID_ITask, &pIU);
    if (pIU != 0)
    {
        IPersistFile *pIPF;

        hr = pIU->QueryInterface(IID_IPersistFile, (void **) &pIPF);
        if (pIPF)
        {
            hr = pIPF->Save(NULL, FALSE);
            if (FAILED(hr))
            {
                wprintf(L"FAIL! IPersistFile->Save, good task creation %x\n",hr);
            }
            pIPF->Release();
            pIPF=NULL;
        }
        pIU -> Release();
        pIU = NULL;
    }
    else
    {
        wprintf(L"FAILURE! New Task (good) return a pIUnknown of NULL\n");
    }
//    wprintf(L"New Task (good - foo.job) returned hr = %x\n\n",hr);

    //
    // AddTask Method
    //

    hr = g_pISchedAgent -> AddWorkItem(L"bar\foo2.job", g_pITask);
    if (SUCCEEDED(hr))
        wprintf(L"FAILURE! Add Task (bad) returned hr = %x\n",hr);
    hr = g_pISchedAgent -> AddWorkItem(L"foo2.job", g_pITask);
    if (FAILED(hr))
        wprintf(L"FAILURE! Add Task (good - foo2.job) returned hr = %x\n\n",hr);

    //
    //  IsTask method (not currently imp)
    //
/*
    hr = g_pISchedAgent -> IsTask(L"bar.job");
    wprintf(L"IsTask (bad) returned hr = %x\n",hr);
    hr = g_pISchedAgent -> IsTask(L"foo.job");
    wprintf(L"IsTask (good) returned hr = %x\n\n",hr);
*/
    //
    // We were going to test Enum here,
    // but wait until later when we need it.
    //

    //
    // Delete Method
    //

    hr = g_pISchedAgent -> Delete(L"foo.job");
    if (FAILED(hr))
        wprintf(L"FAILURE! Delete foo.job returned hr = %x\n",hr);
    hr = g_pISchedAgent -> Delete(L"bar.job");
    if (SUCCEEDED(hr))
        wprintf(L"FAILURE! Delete bar.job returned hr = %x\n",hr);
    hr = g_pISchedAgent -> Delete(L"bar\foo.job");
    if (SUCCEEDED(hr))
        wprintf(L"FAILURE! Delete bar\\foo.job returned hr = %x\n\n",hr);

    return S_OK;
}


//+----------------------------------------------------------------
//
//  function:   TestITask();
//
//  Arguments: none
//
//  returns: HRESULT of S_OK.  E_FAIL, if bad handle in
//              g_pITask.  Typically discarded.
//
//  Synopsis:  Exercises ITask interface.
//             Relies on foo2.job from TestISchedAgent.
//
//  History: 11-4-96    camerone    created
//
//-------------------------------------------------------------------

HRESULT TestITask()
{
    HRESULT hr = S_OK;

    if (g_pITask == 0)
    {
        return E_FAIL;
    }

//    wprintf(L"------------------------------------------\n\n");
//    wprintf(L"Testing ITask interface\n\n");

    //
    // Need a second job, local
    //

    IUnknown *pIU = NULL;
    ITask *pITask = NULL;
    IPersistFile *pIPF = NULL, *pIPF2 = NULL;

    pIU = NULL;
    pITask = NULL;
    pIPF = NULL;
    pIPF2 = NULL;

    hr = g_pISchedAgent -> NewWorkItem(L"foo.job", CLSID_CTask, IID_ITask, &pIU);
    if (FAILED(hr))
    {
       wprintf(L"Failed to create a second test job");
       return hr;
    }

    hr = pIU -> QueryInterface(IID_ITask, (void **) &pITask);
    if (FAILED(hr))
    {
        wprintf(L"Failed to get ITask on foo.job");
        return hr;
    }
    hr = pIU -> QueryInterface(IID_IPersistFile, (void **) &pIPF);
    if (FAILED(hr))
    {
        wprintf(L"Failed to get IPersistFile on foo.job");
        return hr;
    }
    pIPF -> Save(NULL, FALSE);
    pIU -> Release();
    pIU = NULL;

    hr = g_pITask -> QueryInterface(IID_IPersistFile, (void **) &pIPF2);
    if (FAILED(hr))
    {
        wprintf(L"Failed to get IPersistFile on foo2.job");
        return hr;
    }

    //
    // SetCreator Method
    //

    hr = pITask -> SetCreator(L"Arnold Palmer");
    if (FAILED(hr))
        wprintf(L"FAILURE! SetCreator on Arnold Palmer returned hr = %x\n",hr);
    if (pIPF -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF -> Save(NULL, FALSE);
    }
    hr = pITask -> SetCreator(L"gomer");
//    wprintf(L"SetCreator on gomer returned hr = %x\n",hr);
    if (pIPF -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF -> Save(NULL, FALSE);
    }

    //
    // GetCreator Method
    //

    LPWSTR wszName;

    hr = pITask -> GetCreator(&wszName);
    if (FAILED(hr))
        wprintf(L"\nFAILURE! GetCreator on foo.job returned %s, hr = %x. Should be gomer.\n",wszName,hr);
    CoTaskMemFree(wszName);
    hr = g_pITask -> GetCreator(&wszName);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetCreator on foo2.job returned %s, hr = %x. Should be you.\n\n",wszName,hr);
    CoTaskMemFree(wszName);

    //
    // SetComment method
    //

    hr = g_pITask -> SetComment(L"This is a comment");
    if (FAILED(hr))
        wprintf(L"FAILURE! SetComment returned hr = %x\n",hr);
    if (pIPF2 -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF2 -> Save(NULL,FALSE);
    }

    //
    //  GetComment Method
    //

    hr = g_pITask -> GetComment(&wszName);
    if (FAILED(hr))
        wprintf(L"\nFAILURE! GetComment returned %s, hr = %x\n\n",wszName,hr);
    CoTaskMemFree(wszName);

    //
    // SetApplicationName method
    //

    hr = g_pITask -> SetApplicationName(L"cmd.exe");
    if (FAILED(hr))
        wprintf(L"FAILURE! SetApplicationName to calc.exe returned hr = %x\n",hr);
    if (pIPF2 -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF2 -> Save(NULL,FALSE);
    }


    //
    // GetApplicationName method
    //

    hr = g_pITask -> GetApplicationName(&wszName);
    if (FAILED(hr))
        wprintf(L"\nFAILURE! GetApplicationName returned %s, hr = %x\n\n",wszName,hr);
    CoTaskMemFree(wszName);


#ifndef _CHICAGO_
    // Real OS's support user accounts and credentials

    //
    //  SetAccountInformation method
    //

    hr = g_pITask -> SetAccountInformation(L"Administrator",L"");
    if (FAILED(hr))
        wprintf(L"FAILURE! SetAccountInformation returned hr = %x\n",hr);
    if (pIPF2 -> IsDirty() == S_OK)
    {
        pIPF2 -> Save(NULL,FALSE);
    }

    //
    //  GetAccountInformation method
    //

    hr = g_pITask -> GetAccountInformation(&wszName);
    if (FAILED(hr))
        wprintf(L"\nFAILURE! GetAccountInformation returned hr = %x\n\n",hr);
    CoTaskMemFree(wszName);

#endif
// Back to universal stuff

    //
    //  GetWorkingDirectory/SetworkingDirectory
    //

    hr = g_pITask -> GetWorkingDirectory(&wszName);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetWorkingDirectory returned %s, should be NULL, hr = %x\n",wszName,hr);
    CoTaskMemFree(wszName);
    hr = g_pITask -> SetWorkingDirectory(L"C:\\");
    if (FAILED(hr))
        wprintf(L"FAILURE! SetWorking directory to C:\\ returned hr = %x\n",hr);
    hr = g_pITask -> GetWorkingDirectory(&wszName);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetWorkingDirectory returned %s, hr = %x\n\n",wszName,hr); CoTaskMemFree(wszName) ;

    //
    // GetPriority/SetPriority
    //

    DWORD dwPriority;

    hr = g_pITask -> GetPriority(&dwPriority);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetPriority returned ");
    switch(dwPriority)
    {
        case REALTIME_PRIORITY_CLASS:
//            wprintf(L"REALTIME ");
            break;
        case HIGH_PRIORITY_CLASS:
//            wprintf(L"HIGH ");
            break;
        case NORMAL_PRIORITY_CLASS:
//            wprintf(L"NORMAL ");
            break;
        case IDLE_PRIORITY_CLASS:
//            wprintf(L"IDLE ");
            break;
        default: ;
//            wprintf(L"Unknown result %x ",dwPriority);
    }
//    wprintf(L"hr = %x\n",hr);
    hr = g_pITask -> SetPriority(IDLE_PRIORITY_CLASS);
    if (FAILED(hr))
        wprintf(L"FAILURE! SetPriority to IDLE returned hr = %x\n",hr);
    if (pIPF2 -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF2 -> Save(NULL,FALSE);
    }
    hr = g_pITask -> GetPriority(&dwPriority);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetPriority returned hr = %x \n",hr);
    switch(dwPriority)
    {
        case REALTIME_PRIORITY_CLASS:
//            wprintf(L"REALTIME ");
            break;
        case HIGH_PRIORITY_CLASS:
//            wprintf(L"HIGH ");
            break;
        case NORMAL_PRIORITY_CLASS:
//            wprintf(L"NORMAL ");
            break;
        case IDLE_PRIORITY_CLASS:
//            wprintf(L"IDLE ");
            break;
        default:
//            wprintf(L"Unknown result %x ",dwPriority);
 ;   }
//    wprintf(L"hr = %x\n",hr);
    hr = g_pITask -> SetPriority(NORMAL_PRIORITY_CLASS);
    if (FAILED(hr))
        wprintf(L"FAILURE! SetPriority to NORMAL returned hr = %x\n\n",hr);

    //
    //  GetFlags/SetFlags methods
    //

    DWORD dwFlags;

    hr = g_pITask -> GetFlags(&dwFlags);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetFlags gave %x with hr = %x\n",dwFlags,hr);
    dwFlags = TASK_FLAG_INTERACTIVE | TASK_FLAG_DELETE_WHEN_DONE
            | TASK_FLAG_KILL_IF_GOING_ON_BATTERIES;
    hr = g_pITask -> SetFlags(dwFlags);
    if (FAILED(hr))
        wprintf(L"FAILURE! SetFlags INTERACTIVE, DELETEWHENDONE, KILLIFGOINGONBATTERIES gave hr = %x\n",hr);
    if (pIPF2 -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF2 -> Save(NULL,FALSE);
    }
    hr = g_pITask -> GetFlags(&dwFlags);
    if (FAILED(hr))
    {
        wprintf(L"FAILURE! GetFlags gave hr = %x and flags: \n",hr);
         if (dwFlags & TASK_FLAG_INTERACTIVE)
              wprintf(L"INTERACTIVE ");
         if (dwFlags & TASK_FLAG_DELETE_WHEN_DONE)
              wprintf(L"DELETEWHENDONE ");
         if (dwFlags & TASK_FLAG_DISABLED)
              wprintf(L"DISABLED ");
         if (dwFlags & TASK_FLAG_HIDDEN)
            wprintf(L"HIDDEN ");
         if (dwFlags & TASK_FLAG_START_ONLY_IF_IDLE)
            wprintf(L"STARTONLYIFIDLE ");
         if (dwFlags & TASK_FLAG_KILL_ON_IDLE_END)
            wprintf(L"KILLONIDLEEND ");
         if (dwFlags & TASK_FLAG_DONT_START_IF_ON_BATTERIES)
            wprintf(L"DONTSTARTONBATTERIES ");
         if (dwFlags & TASK_FLAG_KILL_IF_GOING_ON_BATTERIES)
            wprintf(L"KILLIFGOINGONBATTERIES ");
         wprintf(L"\n\n");
    }

/*
    //
    // SetIdleWait/GetIdleWait methods
    //

    WORD wMinutes;

    hr = g_pITask -> GetIdleWait(&wMinutes);
    wprintf(L"GetIdleWait returned %d Minutes, hr = %x\n",wMinutes,hr);
    hr = g_pITask -> SetIdleWait(12);
    wprintf(L"SetIdleWait 12 minutes returned hr = %x\n",hr);
    if (pIPF2 -> IsDirty() == S_OK)
    {
        wprintf(L"Persisting changes...\n");
        pIPF2 -> Save(NULL,FALSE);
    }
    hr = g_pITask -> GetIdleWait(&wMinutes);
    wprintf(L"GetIdleWait returned %d Minutes, hr = %x\n\n",wMinutes,hr);
*/
    //
    // Get/SetMaxRunTime methods
    //

    DWORD dwMaxRun;

    hr = g_pITask -> GetMaxRunTime(&dwMaxRun);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetMaxRunTime returned %d Minutes, hr = %x\n",dwMaxRun/1000/60,hr);
    dwMaxRun = 12000*60;
    hr = g_pITask -> SetMaxRunTime(dwMaxRun);
    if (FAILED(hr))
        wprintf(L"FAILURE! SetMaxRunTime for 12 minutes returned hr = %x\n",hr);
    if (pIPF2 -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF2 -> Save(NULL,FALSE);
    }

    hr = g_pITask -> GetMaxRunTime(&dwMaxRun);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetMaxRunTime returned %d Minutes, hr = %x\n\n",dwMaxRun/1000/60,hr);

    //
    // Get/Set Parameters methods
    //

    hr = g_pITask -> GetParameters(&wszName);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetParameters returned %s, hr = %x\n",wszName,hr);
    CoTaskMemFree(wszName);
    hr = g_pITask -> SetParameters(L"These are my parameters");
    if (FAILED(hr))
        wprintf(L"FAILURE! SetParameters returned hr = %x\n",hr);
    if (pIPF2 -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF2 -> Save(NULL,FALSE);
    }
    hr = g_pITask -> GetParameters(&wszName);
    if (FAILED(hr))
         wprintf(L"FAILURE! GetParameters returned %s, hr = %x\n\n",wszName,hr);
    CoTaskMemFree(wszName);

    //
    // GetMostRecentRunTime method (will revisit)
    //

    SYSTEMTIME tTime;

    hr = g_pITask -> GetMostRecentRunTime(&tTime);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetMostRecentRunTime returned hr = %x (should not have run)\n\n",hr);

    //
    // Run Method
    //

    hr = g_pITask -> Run();
    if (FAILED(hr))
        wprintf(L"FAILURE! Foo2 run attempt hr = %x\n",hr);

    for (int nLoop = 0; nLoop < 50; nLoop++)
    {
        Sleep(100);
    }

    //
    // Need to reload off of Disk
    //

    IUnknown *pIUtemp;

    g_pITask -> Release();
    g_pITask = NULL;
    hr = g_pISchedAgent -> Activate(L"foo2.job", IID_ITask, &pIUtemp);
    if (FAILED(hr))
        wprintf(L"FAILURE! Activate foo2.job returned hr = %x\n\n",hr);
    hr = pIUtemp -> QueryInterface(IID_ITask,(void **) &g_pITask);
    pIUtemp -> Release();
    pIUtemp = NULL;

    // Get Status
    HRESULT hrStatus;
    hr = g_pITask -> GetStatus(&hrStatus);
    if (FAILED(hr))
        wprintf(L"FAILURE! Status of job Foo2 is %x, hr = %x\n",hrStatus, hr);

    hr = pITask -> Run();
    if (SUCCEEDED(hr))
        wprintf(L"FAILURE! Foo run attempt (should be error) hr = %x\n\n",hr);
    hr = g_pITask -> GetStatus(&hrStatus);
    if (FAILED(hr))
        wprintf(L"Status of job Foo is %x, hr = %x\n",hrStatus, hr);

    //
    // Terminate Method
    //

//    wprintf(L"Sleeping for 10 seconds to let job catch up.\n");
    Sleep(5000);
    Sleep(5000);

    // Reload again
    g_pITask -> Release();
    g_pITask = NULL;
    hr = g_pISchedAgent -> Activate(L"foo2.job", IID_ITask, &pIUtemp);
    if (FAILED(hr))
        wprintf(L"FAILURE! Activate foo2.job returned hr = %x\n\n",hr);
    hr = pIUtemp -> QueryInterface(IID_ITask,(void **) &g_pITask);
    pIUtemp -> Release();
    pIUtemp = NULL;

    hr = g_pITask -> Terminate();
    if (FAILED(hr) && (hr != SCHED_E_TASK_NOT_RUNNING))
        wprintf(L"FAILURE! Foo2 termination returned = %x\n", hr);
    int k = 0;
    if (FAILED(hr) && (hr != SCHED_E_TASK_NOT_RUNNING))
    {
        wprintf(L"Foo2 would not die.  Trying again.\n");
        do
        {
            wprintf(L"Sleeping for another second...hr was %x\n",hr);
            Sleep(1000);  // Let job catch up
            k++;
            hr = g_pITask -> Terminate();
        } while ((k < 10) && (hr != S_OK));
    }
    if (k == 10)
        wprintf(L"Tried 10 times and just gave up.\n");
    hr = pITask -> Terminate();
    if (SUCCEEDED(hr))
        wprintf(L"FAILURE! Foo termination (not running) hr = %x\n\n",hr);

    //
    //  GetMostRecentRunTime revisited
    //

    hr = g_pITask -> GetMostRecentRunTime(&tTime);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetMostRecentRunTime returned hr = %x\n",hr);
/*    if (hr != SCHED_S_TASK_HAS_NOT_RUN)
    {
        // Dump Time Structure
        wprintf(L"%d/%d/%d %d:%d:%d.%d day %d\n",
                tTime.wDay, tTime.wMonth, tTime.wYear,
                tTime.wHour, tTime.wMinute, tTime.wSecond,
                tTime.wMilliseconds, tTime.wDayOfWeek);
    }
*/
    //
    //  GetExitCode method
    //  The return code is the task's last start error, not an error in
    //  retrieving the exit code
    //

    DWORD dwExitCode;

    hr = pITask -> GetExitCode(&dwExitCode);
    hr = g_pITask -> GetExitCode(&dwExitCode);

    //
    //  Clean up...
    //

//    wprintf(L"Now cleaning up...");
    pITask -> Release();
//    wprintf(L"pITask ");
    pIPF -> Release();
//    wprintf(L"pIPF ");
    pIPF2 -> Release();
//    wprintf(L"pIPF2 ");
    hr = g_pISchedAgent -> Delete(L"foo.job");
    if (FAILED(hr))
        wprintf(L"\nFAILURE! Cleaning up foo.job delete returned %x\n\n",hr);

    return S_OK;
}



//+-----------------------------------------------------------------
//
// function: TestITaskTrigger();
//
// synopsis: Tests ITaskTrigger, plus associated functionality
//              within ITask, as related to ITaskTrigger
//
// Arguments: none
//
// returns:  HRESULT, usually S_OK, almost always discarded
//
// history: 11-5-96 camerone    created
//
//-------------------------------------------------------------------

HRESULT TestITaskTrigger()
{
    HRESULT hr;

    //
    // Where we are
    //

//    wprintf(L"----------------------------------------------------\n");
//    wprintf(L"Testing ITaskTrigger and related ITask parts\n\n");

    //
    // Need to reload off of Disk
    //

    IUnknown *pIUtemp;

    g_pITask -> Release();
    g_pITask = NULL;
    hr = g_pISchedAgent -> Activate(L"foo2.job", IID_ITask, &pIUtemp);
    if (FAILED(hr))
        wprintf(L"FAILURE! Activate foo2.job returned hr = %x\n\n",hr);
    hr = pIUtemp -> QueryInterface(IID_ITask,(void **) &g_pITask);
    pIUtemp -> Release();
    pIUtemp = NULL;

    //
    // Allow persistant changes
    //

    IPersistFile *pIPF = NULL;

    hr = g_pITask -> QueryInterface(IID_IPersistFile, (void **) &pIPF);
    if (FAILED(hr))
    {
        wprintf(L"QueryInterface for IPersistFile failed %x\n",hr);
        return E_FAIL;
    }

    //
    // To test one, we need one.
    // CreateTrigger method
    //

    ITaskTrigger *pITTrig;
    WORD iTrig, iTrig2, iTrig3;

    hr = g_pITask -> CreateTrigger(&iTrig, &g_pITaskTrigger);
    if (FAILED(hr))
        wprintf(L"FAILURE! CreateTrigger returned trigger #%d, hr = %x\n",iTrig,hr);

    if (FAILED(hr))
    {
        wprintf(L"Failure to initialize a trigger\n");
        return E_FAIL;
    }

    hr = g_pITask -> CreateTrigger(&iTrig2, &pITTrig);
    if (FAILED(hr))
        wprintf(L"FAILURE! CreateTrigger returned trigger #%d, hr = %x\n",iTrig2,hr);
    pITTrig -> Release();
    pITTrig = NULL;
    hr = g_pITask -> CreateTrigger(&iTrig3, &pITTrig);
    if (FAILED(hr))
        wprintf(L"FAILURE! CreateTrigger returned trigger #%d, hr = %x\n",iTrig3,hr);

    if (pIPF -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF -> Save(NULL,FALSE);
    }

    //
    // Delete the last trigger
    //

    pITTrig -> Release();
    pITTrig = NULL;

    hr = g_pITask -> DeleteTrigger(iTrig3);
    if (FAILED(hr))
        wprintf(L"\nFAILURE! DeleteTrigger on %d returned hr = %x\n",iTrig3,hr);
    if (pIPF -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF -> Save(NULL,FALSE);
    }

    //
    // GetTriggerString
    //    we will revisit this one later.
    //

    LPWSTR pwszTriggerString;

    hr = g_pITask -> GetTriggerString(iTrig, &pwszTriggerString);
    if (FAILED(hr))
        wprintf(L"\nFAILURE! GetTrigger string - %s, hr = %x\n\n",pwszTriggerString,hr);
    CoTaskMemFree(pwszTriggerString);

    //
    // GetMostRecentRunTimes again.
    //

    SYSTEMTIME tTime;

    hr = g_pITask -> GetMostRecentRunTime(&tTime);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetMostRecentRunTime returned hr = %x\n",hr);
/*    if (hr != SCHED_S_TASK_HAS_NOT_RUN)
    {
        // Dump Time Structure
        wprintf(L"%d/%d/%d %d:%d:%d.%d day %d\n",
                tTime.wDay, tTime.wMonth, tTime.wYear,
                tTime.wHour, tTime.wMinute, tTime.wSecond,
                tTime.wMilliseconds, tTime.wDayOfWeek);
    }
*/
    //
    // GetTriggerCount Method
    //

    WORD wTrigCount;

    hr = g_pITask -> GetTriggerCount(&wTrigCount);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetTriggerCount shows %d triggers, hr = %x\n\n",wTrigCount,hr);

    //
    // TaskTrigger GetTriggerString
    //

    hr = g_pITaskTrigger -> GetTriggerString(&pwszTriggerString);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetTriggerString (TaskTrig) - %s, hr = %x\n\n",pwszTriggerString,hr);
    CoTaskMemFree(pwszTriggerString);

    //
    // GetTrigger
    //

    TASK_TRIGGER Trigger;

    Trigger.cbTriggerSize = sizeof(TASK_TRIGGER);

    hr = g_pITaskTrigger -> GetTrigger(&Trigger);
    if (FAILED(hr))
    {
        wprintf(L"FAILURE! GetTrigger returned hr = %x\nDumping structure:\n",hr);
        wprintf(L"From %d/%d/%d to %d/%d/%d\n",Trigger.wBeginDay,
                Trigger.wBeginMonth,Trigger.wBeginYear,
                Trigger.wEndDay,Trigger.wEndMonth,Trigger.wEndYear);
        wprintf(L"Starting at %d:%d, running for %d or at Interval %d\n",
                Trigger.wStartHour,Trigger.wStartMinute,
                Trigger.MinutesDuration,Trigger.MinutesInterval);
        wprintf(L"Flag mask %x, Trigger Type = %d\n\n",Trigger.rgFlags,
                Trigger.TriggerType);
    }

    //
    // SetTrigger
    //

    Trigger.wBeginDay = 7;
    Trigger.wBeginMonth = 10;
    Trigger.wBeginYear = 1996;
    Trigger.wEndDay = 21;
    Trigger.wEndMonth = 1;
    Trigger.wEndYear = 1997;
    Trigger.wStartHour = 15;
    Trigger.wStartMinute = 42;
    Trigger.MinutesDuration = 2;
    Trigger.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
    Trigger.rgFlags = TASK_TRIGGER_FLAG_HAS_END_DATE;
    Trigger.Type.Weekly.WeeksInterval = 2;
    Trigger.Type.Weekly.rgfDaysOfTheWeek = TASK_SUNDAY | TASK_FRIDAY;

    hr = g_pITaskTrigger -> SetTrigger(&Trigger);
    if (FAILED(hr))
    {
        wprintf(L"FAILURE! Set trigger returned hr = %x\nSet To: \n",hr);
        wprintf(L"From %d/%d/%d to %d/%d/%d\n",Trigger.wBeginDay,
                Trigger.wBeginMonth,Trigger.wBeginYear,
                Trigger.wEndDay,Trigger.wEndMonth,Trigger.wEndYear);
        wprintf(L"Starting at %d:%d, running for %d or at Interval %d\n",
                Trigger.wStartHour,Trigger.wStartMinute,
                Trigger.MinutesDuration,Trigger.MinutesInterval);
        wprintf(L"Flag mask %x, Trigger Type = %d\n\n",Trigger.rgFlags,
                Trigger.TriggerType);
    }
    if (pIPF -> IsDirty() == S_OK)
    {
//        wprintf(L"Persisting changes...\n");
        pIPF -> Save(NULL,FALSE);
    }

    // Get Again

    hr = g_pITaskTrigger -> GetTrigger(&Trigger);
    if (FAILED(hr))
    {
        wprintf(L"FAILURE! GetTrigger returned hr = %x\nDumping structure:\n",hr);
        wprintf(L"From %d/%d/%d to %d/%d/%d\n",Trigger.wBeginDay,
                Trigger.wBeginMonth,Trigger.wBeginYear,
                Trigger.wEndDay,Trigger.wEndMonth,Trigger.wEndYear);
        wprintf(L"Starting at %d:%d, running for %d or at Interval %d\n",
                Trigger.wStartHour,Trigger.wStartMinute,
                Trigger.MinutesDuration,Trigger.MinutesInterval);
        wprintf(L"Flag mask %x, Trigger Type = %d\n\n",Trigger.rgFlags,
                Trigger.TriggerType);
    }

    //
    // Get Trigger String last time
    //

    hr = g_pITaskTrigger -> GetTriggerString(&pwszTriggerString);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetTriggerString (TaskTrig) - %s, hr = %x\n\n",pwszTriggerString,hr);
    CoTaskMemFree(pwszTriggerString);

    //
    // Some Cleanup
    //

    g_pITaskTrigger -> Release();
    g_pITaskTrigger = NULL;

    //
    // Get the other trigger
    //

    hr = g_pITask -> GetTrigger(iTrig2,&g_pITaskTrigger);
    if (FAILED(hr))
        wprintf(L"GetTrigger on #%d returned hr = %x\n\n",iTrig2,hr);

    //
    // Dump this one
    //

    hr = g_pITaskTrigger -> GetTrigger(&Trigger);
    if (FAILED(hr))
    {
        wprintf(L"FAILURE! GetTrigger returned hr = %x\nDumping structure:\n",hr);
        wprintf(L"From %d/%d/%d to %d/%d/%d\n",Trigger.wBeginDay,
                Trigger.wBeginMonth,Trigger.wBeginYear,
                Trigger.wEndDay,Trigger.wEndMonth,Trigger.wEndYear);
        wprintf(L"Starting at %d:%d, running for %d or at Interval %d\n",
                Trigger.wStartHour,Trigger.wStartMinute,
                Trigger.MinutesDuration,Trigger.MinutesInterval);
        wprintf(L"Flag mask %x, Trigger Type = %d\n\n",Trigger.rgFlags,
                Trigger.TriggerType);
    }

    //
    // Get Trigger String last time
    //

    hr = g_pITaskTrigger -> GetTriggerString(&pwszTriggerString);
    if (FAILED(hr))
        wprintf(L"FAILURE! GetTriggerString (TaskTrig) - %s, hr = %x\n\n",pwszTriggerString,hr);
    CoTaskMemFree(pwszTriggerString);

    // More cleanup
    g_pITaskTrigger -> Release();
    g_pITaskTrigger = NULL;

    pIPF -> Release();
    pIPF = NULL;

    return S_OK;
}


//+-------------------------------------------------------------------
//
// function:    TestIEnum
//
// Synopsis:    Tests IEnumTasks methods
//
// Arguments:   None
//
// returns:     S_OK, possibly others.  Basically, discarded.
//
// history:     11-5-96 camerone    created
//
//---------------------------------------------------------------------

HRESULT TestIEnum()
{
    HRESULT hr;

    //
    // Where we are
    //

//    wprintf(L"------------------------------------------------------\n");
//    wprintf(L"Testing IEnumTasks\n");

    //
    // Get the pointer to the interface
    //

    hr = g_pISchedAgent -> Enum(&g_pIEnumTasks);
    if (FAILED(hr))
        wprintf(L"FAILURE! ISA Enum returned hr = %x\n\n",hr);

    //
    // Clean up the folder
    //

    LPWSTR *rgpwszNames;
    ULONG celt, celtGot;

    celt = 10;
    hr = g_pIEnumTasks -> Next(celt, &rgpwszNames, &celtGot);
    if (FAILED(hr))
        wprintf(L"FAILURE - Next returned %d results, hr = %x\n",celtGot, hr);
    for (ULONG i = 0; i < celtGot; i++)
    {
//        wprintf(L"%s\n",rgpwszNames[i]);
        g_pISchedAgent -> Delete(rgpwszNames[i]);
        CoTaskMemFree(rgpwszNames[i]);
    }
    CoTaskMemFree(rgpwszNames);
return S_OK;
}

//+----------------------------------------------------------------------
//
// function: TestGRT()
//
// synopsis: Tests GetRunTimes
//
// Arguments: None
//
// Returns: S_OK.  Throw it away!
//
// history: 11-15-96    camerone    created
//
// Notes: Requires the global pointers to be init'd. Should
//        be the last thing called, too, since we need that empty
//        tasks folder.
//
//------------------------------------------------------------------------

HRESULT TestGRT()
{
    HRESULT hr = S_OK;
    IUnknown *pIU = NULL;
    ITask *pITask = NULL;
    IPersistFile *pIPF = NULL;
    ITaskTrigger *pITT1 = NULL, *pITT2 = NULL, *pITT3 = NULL;
    WORD wTrig1, wTrig2, wTrig3;

//    wprintf(L"-----------------------------------------------\n");
//    wprintf(L"TestGRT!\n\n");

    hr = g_pISchedAgent -> NewWorkItem(L"bar.job", CLSID_CTask, IID_ITask, &pIU);
    if (FAILED(hr))
    {
        wprintf(L"Failed to allocate New Task bar.job\n");
        return E_FAIL;
    }
//    wprintf(L"New Task (good - bar.job) returned hr = %x\n\n",hr);

    hr = pIU -> QueryInterface(IID_ITask, (void **) &pITask);
    if (FAILED(hr))
    {
        wprintf(L"QI for ITask failed %x\n",hr);
        return E_FAIL;
    }
    pIU -> Release();
    pIU = NULL;

    hr = pITask -> QueryInterface(IID_IPersistFile, (void **) &pIPF);
    if (FAILED(hr))
    {
        wprintf(L"QueryInterface for IPersistFile failed %x\n",hr);
        return E_FAIL;
    }

    //
    // Set up legitimate task parameters.
    //

//    wprintf(L"Setting Application name to calc.exe\n");
    hr = pITask -> SetApplicationName(L"calc.exe");
    if (FAILED(hr))
    {
        wprintf(L"SetApplicationName failed %x\n",hr);
        return E_FAIL;
    }

//    wprintf(L"Setting Account Information security\n");
#ifndef _CHICAGO_

    hr = pITask -> SetAccountInformation(L"Administrator",L"");
    if (FAILED(hr))
    {
        wprintf(L"Failed to set account info %x\n",hr);
        return E_FAIL;
    }
#endif
    DWORD dwFlags = 0;

    hr = pITask -> SetFlags(dwFlags);

    //
    // Great.  We now have empty task "foo.job"
    // The plan is as follows:
    //      1. Create 3 triggers of the following types:
    //          a. One at Logon
    //          b. Two set to run Once, in the future
    //      2. Call GetRunTimes the following ways:
    //          a. Asking for 1 run time, in the interval w/trigs
    //          b. Asking for 2 run times, in the interval w/trigs
    //      3. Verify S_OK returned each time
    //      4. Call asking for 2 runtimes, when only one possible.
    //      5. Verify S_FALSE and pCount == 1 returned
    //      6. Call for one trigger, outside of the interval w/trigs
    //      7. Verify that SCHED_S_EVENT_TRIGGER returned
    //      8. Delete the "LOGON" Trigger
    //      9. Call for one trigger, outside possible run interval.
    //      10. Verify S_FALSE, pCount == 0 returned.
    //      11. Disable task
    //      12. Call for one trigger, in the good interval.
    //      13. Verify return of SCHED_S_TASK_DISABLED
    //      14. Enable Task
    //      15. Delete remaining two triggers
    //      16. Call for a single trigger, any time.
    //      17. Verify return of SCHED_S_NO_VALID_TRIGGERS
    //      18. Delete task.

    // Create 3 triggers

    hr = pITask -> CreateTrigger(&wTrig1, &pITT1);
    if (hr != S_OK)
    {
        wprintf(L"Failed to create first trigger\n");
        return E_FAIL;
    }

    hr = pITask -> CreateTrigger(&wTrig2, &pITT2);
    if (hr != S_OK)
    {
        wprintf(L"Failed to create second trigger\n");
        return E_FAIL;
    }

    hr = pITask -> CreateTrigger(&wTrig3, &pITT3);
    if (hr != S_OK)
    {
        wprintf(L"Failed to create third trigger\n");
        return E_FAIL;
    }

    if (pIPF -> IsDirty() == S_OK)
    {
        wprintf(L"Persisting changes...\n");
        pIPF -> Save(NULL,FALSE);
    }

    // Setup the three triggers

    TASK_TRIGGER TT1, TT2, TT3;

    TT1.cbTriggerSize = sizeof(TASK_TRIGGER);
    TT2.cbTriggerSize = sizeof(TASK_TRIGGER);
    TT3.cbTriggerSize = sizeof(TASK_TRIGGER);

    TT1.Reserved1 = 0;
    TT1.Reserved2 = 0;
    TT1.wRandomMinutesInterval = 0;
    TT1.wBeginYear = 1997;
    TT1.wBeginMonth = 1;
    TT1.wBeginDay = 1;
    TT1.wStartHour = 10;
    TT1.wStartMinute = 0;
    TT1.MinutesDuration = 10;
    TT1.rgFlags = TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
    TT1.TriggerType = TASK_TIME_TRIGGER_ONCE;
    TT1.wEndYear = 0;
    TT1.wEndMonth = 0;
    TT1.wEndDay = 0;
    TT1.MinutesInterval = 0;
    TT1.Type.Daily.DaysInterval = 1;

    TT2.Reserved1 = 0;
    TT2.Reserved2 = 0;
    TT2.wRandomMinutesInterval = 0;
    TT2.wBeginYear = 1997;
    TT2.wBeginMonth = 1;
    TT2.wBeginDay = 1;
    TT2.wStartHour = 11;
    TT2.wStartMinute = 0;
    TT2.MinutesDuration = 10;
    TT2.rgFlags = TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
    TT2.TriggerType = TASK_TIME_TRIGGER_ONCE;
    TT2.wEndYear = 0;
    TT2.wEndMonth = 0;
    TT2.wEndDay = 0;
    TT2.MinutesInterval = 0;
    TT2.Type.Daily.DaysInterval = 1;

    TT3.Reserved1 = 0;
    TT3.Reserved2 = 0;
    TT3.wRandomMinutesInterval = 0;
    TT3.wBeginYear = 1997;
    TT3.wBeginMonth = 1;
    TT3.wBeginDay = 1;
    TT3.wStartHour = 11;
    TT3.wStartMinute = 0;
    TT3.MinutesDuration = 10;
    TT3.rgFlags = TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
    TT3.TriggerType = TASK_EVENT_TRIGGER_AT_LOGON;
    TT3.wEndYear = 0;
    TT3.wEndMonth = 0;
    TT3.wEndDay = 0;
    TT3.MinutesInterval = 0;
    TT3.Type.Daily.DaysInterval = 1;

    hr = pITT1 -> SetTrigger(&TT1);
    if (hr != S_OK)
    {
        wprintf(L"Failed to set trigger 1 hr = %x\n",hr);
        return E_FAIL;
    }
    hr = pITT2 -> SetTrigger(&TT2);
    if (hr != S_OK)
    {
        wprintf(L"Failed to set trigger 2 hr = %x\n",hr);
        return E_FAIL;
    }
    hr = pITT3 -> SetTrigger(&TT3);
    if (hr != S_OK)
    {
        wprintf(L"Failed to set trigger 3 hr = %x\n",hr);
        return E_FAIL;
    }

    // Persist.

    if (pIPF -> IsDirty() == S_OK)
    {
        wprintf(L"Persisting changes...\n");
        pIPF -> Save(NULL,FALSE);
    }

    // Call GetRunTimes, asking for one and two trigs in interval
    SYSTEMTIME tStart, tEnd;
    WORD wTrigCount;
    SYSTEMTIME *rgstTaskTimes;

    tStart.wDay = 1;
    tStart.wMonth = 1;
    tStart.wYear = 1997;
    tStart.wHour = 9;
    tStart.wMinute = 0;
    tStart.wDayOfWeek = 0;
    tStart.wSecond = 0;
    tStart.wMilliseconds = 0;
    tEnd.wDay = 1;
    tEnd.wMonth = 1;
    tEnd.wYear = 1997;
    tEnd.wHour = 12;
    tEnd.wMinute = 0;
    tEnd.wDayOfWeek = 0;
    tEnd.wSecond = 0;
    tEnd.wMilliseconds = 0;

    wTrigCount = 1;

    hr = pITask -> GetRunTimes(&tStart, &tEnd, &wTrigCount, &rgstTaskTimes);
    wprintf(L"GetRunTimes(1) returned %x, should be S_OK. #Trig=%d\n",hr,wTrigCount);
    CoTaskMemFree(rgstTaskTimes);
    wTrigCount = 2;
    hr = pITask -> GetRunTimes(&tStart, &tEnd, &wTrigCount, &rgstTaskTimes);
    wprintf(L"GetRunTimes(2) returned %x, should be S_OK. #Trig=%d\n",hr,wTrigCount);
    CoTaskMemFree(rgstTaskTimes);

    tStart.wHour = 10;
    tStart.wMinute = 30;

    // Ask for two, where there is only one.

    hr = pITask -> GetRunTimes(&tStart, &tEnd, &wTrigCount, &rgstTaskTimes);
    wprintf(L"GetRunTimes ask two, get one returned %x, should be S_FALSE. #Trig=%d\n",hr,wTrigCount);
    CoTaskMemFree(rgstTaskTimes);


    // Call for two, outside of trigger area, get EVENT

    wTrigCount = 2;
    tStart.wHour = 11;
    hr = pITask -> GetRunTimes(&tStart, &tEnd, &wTrigCount, &rgstTaskTimes);
    wprintf(L"GetRunTimes ask outside returned %x, should be SCHED_S_EVENT_TRIGGER #Trig=%d\n",hr,wTrigCount);
    CoTaskMemFree(rgstTaskTimes);

    // Delete trigger 3, remake the call.

    pITT3 -> Release();
    pITT3 = NULL;

    wprintf(L"Now deleting the event trigger\n");

    hr = pITask -> DeleteTrigger(wTrig3);
    if (hr != S_OK)
    {
        wprintf(L"Deleting trigger 3 failed\n");
        return E_FAIL;
    }

    WORD wCount;
    hr = pITask -> GetTriggerCount(&wCount);
    if (hr != S_OK)
    {
        wprintf(L"GetTriggerCount failed\n");
        return(E_FAIL);
    }
    wprintf(L"There are now %d triggers\n",wCount);

    wTrigCount = 2;
    hr = pITask -> GetRunTimes(&tStart, &tEnd, &wTrigCount, &rgstTaskTimes);
    wprintf(L"GetRunTimes ask outside returned %x, should be S_FALSE #Trig=%d\n",hr,wTrigCount);
    CoTaskMemFree(rgstTaskTimes);

    // Disable task

    dwFlags = TASK_FLAG_DISABLED;

    hr = pITask -> SetFlags(dwFlags);
    if (hr != S_OK)
    {
        wprintf(L"Couldn't set disabled flag\n");
        return E_FAIL;
    }

    tStart.wHour = 9;
    wTrigCount = 2;
    hr = pITask -> GetRunTimes(&tStart, &tEnd, &wTrigCount, &rgstTaskTimes);
    wprintf(L"GetRunTimes disabled (2) returned %x, should be SCHED_S_TASK_DISABLED #Trig=%d\n",hr,wTrigCount);
    CoTaskMemFree(rgstTaskTimes);

    // Enable, remove other trigs

    dwFlags ^= TASK_FLAG_DISABLED;

    hr = pITask -> SetFlags(dwFlags);
    if (hr != S_OK)
    {
        wprintf(L"Couldn't set disabled flag\n");
        return E_FAIL;
    }

    pITT1 -> Release();
    pITT1 = NULL;
    pITT2 -> Release();
    pITT2 = NULL;

    hr = pITask -> DeleteTrigger(wTrig2);
    if (hr != S_OK)
    {
        wprintf(L"Deleting trigger 2 failed\n");
        return E_FAIL;
    }

    hr = pITask -> DeleteTrigger(wTrig1);
    if (hr != S_OK)
    {
        wprintf(L"Deleting trigger 1 failed\n");
        return E_FAIL;
    }

    // Persist.

    if (pIPF -> IsDirty() == S_OK)
    {
        wprintf(L"Persisting changes...\n");
        pIPF -> Save(NULL,FALSE);
    }

    // Now call for SCHED_S_NO_VALID_TRIGGERS

    wTrigCount = 2;
    hr = pITask -> GetRunTimes(&tStart, &tEnd, &wTrigCount, &rgstTaskTimes);
    wprintf(L"GetRunTimes (2) no trigs returned %x, should be SCHED_S_TASK_NO_VALID_TRIGGERS #Trig=%d\n",hr,wTrigCount);
    CoTaskMemFree(rgstTaskTimes);

    // Cleanup

    pITask -> Release();
    pITask = NULL;
    pIPF -> Release();
    pIPF = NULL;

    // Delete job

    g_pISchedAgent -> Delete(L"bar.job");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\daily.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       daily.cxx
//
//  Contents:   Task wizard daily trigger property page implementation.
//
//  Classes:    CDailyPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// Constants
//
// NDAYS_MIN - minimum value for daily_ndays_ud spin control
// NDAYS_MAX - maximum value for daily_ndays_ud spin control
//

#define NDAYS_MIN       1
#define NDAYS_MAX       365

#define TASK_WEEKDAYS       (TASK_MONDAY    | \
                             TASK_TUESDAY   | \
                             TASK_WEDNESDAY | \
                             TASK_THURSDAY  | \
                             TASK_FRIDAY)



//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::CDailyPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDailyPage::CDailyPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CTriggerPage(IDD_DAILY,
                     IDS_DAILY_HDR2,
                     ptszFolderPath,
                     phPSP)
{
    TRACE_CONSTRUCTOR(CDailyPage);
    _idSelectedRadio = 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::~CDailyPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDailyPage::~CDailyPage()
{
    TRACE_DESTRUCTOR(CDailyPage);
}




//===========================================================================
//
// CPropPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::_OnCommand
//
//  Synopsis:   Handle user input
//
//  Arguments:  [id]         - resource id of control affected
//              [hwndCtl]    - window handle of control affected
//              [codeNotify] - indicates what happened to control
//
//  Returns:    0 (handled), 1 (not handled)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CDailyPage::_OnCommand(
    INT id,
    HWND hwndCtl,
    UINT codeNotify)
{
    LRESULT lr = 0;

    switch (codeNotify)
    {
    case BN_CLICKED:
        switch (id)
        {
        case daily_day_rb:
        case daily_weekday_rb:
        case daily_ndays_rb:
            _idSelectedRadio = (USHORT) id;
            _EnableNDaysControls(id == daily_ndays_rb);
            break;

        default:
            lr = 1;
            break;
        }
        break;

    case EN_UPDATE:
    {
        //
        // If the user just pasted non-numeric text or an illegal numeric
        // value, overwrite it and complain.
        //

        INT iNewPos = GetDlgItemInt(Hwnd(), daily_ndays_edit, NULL, FALSE);

        if (iNewPos < NDAYS_MIN || iNewPos > NDAYS_MAX)
        {
            HWND hUD = _hCtrl(daily_ndays_ud);
            UpDown_SetPos(hUD, UpDown_GetPos(hUD));
            MessageBeep(MB_ICONASTERISK);
        }
    }

    default:
        lr = 1;
        break;
    }
    return lr;
}



//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CDailyPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CDailyPage, _OnInitDialog);

    _UpdateTimeFormat();
    _idSelectedRadio = daily_day_rb;
    CheckDlgButton(Hwnd(), _idSelectedRadio, BST_CHECKED);

    _EnableNDaysControls(FALSE);
    UpDown_SetRange(_hCtrl(daily_ndays_ud), NDAYS_MIN, NDAYS_MAX);
    UpDown_SetPos(_hCtrl(daily_ndays_ud), 1);
    Edit_LimitText(_hCtrl(daily_ndays_edit), 3);
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::_OnPSNSetActive
//
//  Synopsis:   Enable the back and next buttons, since this page cannot
//              have invalid data
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CDailyPage::_OnPSNSetActive(
    LPARAM lParam)
{
    _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    return CPropPage::_OnPSNSetActive(lParam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::_EnableNDaysControls
//
//  Synopsis:   Enable or disable the 'run every n days' controls
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CDailyPage::_EnableNDaysControls(
    BOOL fEnable)
{
    EnableWindow(_hCtrl(daily_ndays_ud), fEnable);
    EnableWindow(_hCtrl(daily_ndays_edit), fEnable);
    EnableWindow(_hCtrl(daily_ndays_lbl), fEnable);
}




//===========================================================================
//
// CTriggerPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CDailyPage::FillInTrigger
//
//  Synopsis:   Fill in the fields of the trigger structure according to the
//              settings specified for this type of trigger
//
//  Arguments:  [pTrigger] - trigger struct to fill in
//
//  Modifies:   *[pTrigger]
//
//  History:    5-06-1997   DavidMun   Created
//
//  Notes:      Precondition is that trigger's cbTriggerSize member is
//              initialized.
//
//---------------------------------------------------------------------------

VOID
CDailyPage::FillInTrigger(
    TASK_TRIGGER *pTrigger)
{
    switch (_idSelectedRadio)
    {
    case daily_day_rb:
        pTrigger->TriggerType = TASK_TIME_TRIGGER_DAILY;
        pTrigger->Type.Daily.DaysInterval = 1;
        break;

    case daily_weekday_rb:
        pTrigger->TriggerType = TASK_TIME_TRIGGER_WEEKLY;
        pTrigger->Type.Weekly.WeeksInterval = 1;
        pTrigger->Type.Weekly.rgfDaysOfTheWeek = TASK_WEEKDAYS;
        break;

    case daily_ndays_rb:
        pTrigger->TriggerType = TASK_TIME_TRIGGER_DAILY;
        pTrigger->Type.Daily.DaysInterval =
            UpDown_GetPos(_hCtrl(daily_ndays_ud));
        break;

    default:
        DEBUG_ASSERT(FALSE);
        break;
    }
    FillInStartDateTime(_hCtrl(startdate_dp), _hCtrl(starttime_dp), pTrigger);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\complete.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       complete.cxx
//
//  Contents:   Task wizard completion (final) property page implementation.
//
//  Classes:    CCompletionPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"




//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::CCompletionPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CCompletionPage::CCompletionPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CWizPage(MAKEINTRESOURCE(IDD_COMPLETION), ptszFolderPath)
{
    TRACE_CONSTRUCTOR(CCompletionPage);

    _pParent = pParent;
    _hIcon = NULL;
    _pJob = NULL;

#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97

    *phPSP = CreatePropertySheetPage(&m_psp);

    if (!*phPSP)
    {
        DEBUG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::~CCompletionPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CCompletionPage::~CCompletionPage()
{
    TRACE_DESTRUCTOR(CCompletionPage);

    if (_pJob)
    {
        _pJob->Release();
    }

    if (_hIcon)
    {
        VERIFY(DestroyIcon(_hIcon));
    }
}



//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//              4-14-1998   CameronE   Added Policy Support
//
//---------------------------------------------------------------------------

LRESULT
CCompletionPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CCompletionPage, _OnInitDialog);

    //
    // Policy Support - remove "open advanced" checkbox if
    // we find a registry key for that policy
    //
	
    if (RegReadPolicyKey(TS_KEYPOLICY_DISABLE_ADVANCED))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy DISABLE_ADVANCED active to remove checkbox\n"));
        EnableWindow(_hCtrl(complete_advanced_ckbox), FALSE);
        ShowWindow(_hCtrl(complete_advanced_ckbox), SW_HIDE);
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::_OnPSNSetActive
//
//  Synopsis:   Create a task object (in-memory only) and update the
//              summary information on this page.
//
//  Arguments:  [lParam] - LPNMHDR (unused)
//
//  Returns:    TRUE
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CCompletionPage::_OnPSNSetActive(
    LPARAM lParam)
{
    TRACE_METHOD(CCompletionPage, _OnPSNSetActive);

    HRESULT hr = S_OK;
    LPWSTR pwszTrigger = NULL;

    do
    {
        //
        // Update the summary info to reflect the user's latest
        // choices.
        //

        CSelectProgramPage *pSelProg = GetSelectProgramPage(_pParent);
        CSelectTriggerPage *pSelTrig = GetSelectTriggerPage(_pParent);

        HICON hIcon;

        hIcon = pSelProg->GetSelectedAppIcon();

        SendDlgItemMessage(Hwnd(),
                           complete_task_icon,
                           STM_SETICON,
                           (WPARAM) hIcon,
                           0L);
        if (_hIcon)
        {
            VERIFY(DestroyIcon(_hIcon));
        }
        _hIcon = hIcon;

        Static_SetText(_hCtrl(complete_taskname_lbl), pSelTrig->GetTaskName());
        Static_SetText(_hCtrl(complete_trigger_lbl), TEXT(""));

        //
        // Create the task object so we can ask it for its trigger string.
        // The object won't be persisted until the user hits the Finish
        // button.
        //

        hr = _UpdateTaskObject();

        if (FAILED(hr))
        {
            _SetWizButtons(PSWIZB_BACK | PSWIZB_DISABLEDFINISH);
            break;
        }

        //
        // _pJob is now valid, so enable the finish button.
        //

        _SetWizButtons(PSWIZB_BACK | PSWIZB_FINISH);

        //
        // Put the trigger string in the ui so the user can see a
        // description of when the task will run.
        //

        hr = _pJob->GetTriggerString(0, &pwszTrigger);

        if (FAILED(hr))
        {
            DEBUG_OUT_HRESULT(hr);
            break;
        }

#if defined(UNICODE)
        Static_SetText(_hCtrl(complete_trigger_lbl), pwszTrigger);
#else
        TCHAR tszTrigger[SCH_XBIGBUF_LEN];
        hr = UnicodeToAnsi(tszTrigger, pwszTrigger, ARRAYLEN(tszTrigger));
        Static_SetText(_hCtrl(complete_trigger_lbl), tszTrigger);
#endif // defined(UNICODE)

    } while (0);

    CoTaskMemFree(pwszTrigger);
    return CPropPage::_OnPSNSetActive(lParam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::_OnWizBack
//
//  Synopsis:   Set the current page to the one that should precede this.
//
//  Returns:    -1
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CCompletionPage::_OnWizBack()
{
    TRACE_METHOD(CCompletionPage, _OnWizBack);

#if defined(_CHICAGO_)
    ULONG iddPage = GetSelectTriggerPage(_pParent)->GetSelectedTriggerPageID();
    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, iddPage);
#else
    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, IDD_PASSWORD);
#endif // defined(_CHICAGO_)
    return -1;
}



//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::_OnWizFinish
//
//  Synopsis:   Persist the task object.
//
//  Returns:    0
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CCompletionPage::_OnWizFinish()
{
    TRACE_METHOD(CCompletionPage, _OnWizFinish);

    HRESULT             hr = S_OK;
    LPCTSTR             ptszJob = NULL;
    CSelectTriggerPage *pSelTrig = GetSelectTriggerPage(_pParent);
#if !defined(_CHICAGO_)
    CPasswordPage      *pPasswdPage = GetPasswordPage(_pParent);
#endif // !defined(_CHICAGO_)
    BOOL                fSaveSucceeded = FALSE;

    do
    {
        if (!_pJob)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Persist the new job object.
        //

        ptszJob = pSelTrig->GetJobObjectFullPath();
        CWaitCursor HourGlass;

        if (FileExists((LPTSTR)ptszJob))
        {
            if (!DeleteFile(ptszJob))
            {
                //
                // Complain but leave hr alone so we don't pop up a second
                // error
                //

                DEBUG_OUT_LASTERROR;
                SchedUIErrorDialog(Hwnd(),
                                   IDS_CANT_DELETE_EXISTING,
                                   (LPTSTR) pSelTrig->GetTaskName());
                break;
            }
        }

#ifdef UNICODE
        hr = _pJob->Save(ptszJob, TRUE);
#else
        WCHAR wszBuf[MAX_PATH];
        hr = AnsiToUnicode(wszBuf, ptszJob, MAX_PATH);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pJob->Save(wszBuf, TRUE);
#endif
        BREAK_ON_FAIL_HRESULT(hr);

        fSaveSucceeded = TRUE;

#if !defined(_CHICAGO_)
        //
        // (NT only) set the account information.  Caller must ensure
        // service is running.
        //

        hr = _pJob->SetAccountInformation(pPasswdPage->GetAccountName(),
                                          pPasswdPage->GetPassword());
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pJob->Save(NULL, FALSE);
        BREAK_ON_FAIL_HRESULT(hr);

#endif // !defined(_CHICAGO_)
    } while (0);

#if !defined(_CHICAGO_)
    //
    // Don't leave account name & password in memory
    //

    pPasswdPage->ZeroCredentials();
#endif // !defined(_CHICAGO_)

    //
    // If advanced checkbox is checked, indicate to DoTaskWizard.  Also,
    // give it a reference to the job object so it can do any terminal
    // processing necessary (e.g., displaying the property pages).
    //

    if (fSaveSucceeded)
    {
        BOOL fAdvanced = IsDlgButtonChecked(Hwnd(), complete_advanced_ckbox);

        _pParent->SetAdvancedMode(fAdvanced);

        _pJob->AddRef();
        _pParent->SetTaskObject(_pJob);

        _pParent->SetJobObjectPath(ptszJob);
    }

    //
    // Notify the user if anything went wrong.
    //

    if (FAILED(hr))
    {
        if (fSaveSucceeded)
        {
            SchedUIErrorDialog(Hwnd(), IDS_WIZFINISH_NONFATAL, hr);
        }
        else
        {
            SchedUIErrorDialog(Hwnd(), IDS_WIZFINISH_FATAL, hr);
        }
    }
    return 0;
}



//+--------------------------------------------------------------------------
//
//  Member:     CCompletionPage::_UpdateTaskObject
//
//  Synopsis:   Create a task object in memory that matches all the
//              settings the user made on previous pages.
//
//  Returns:    HRESULT
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      If a task object already exists, it is freed and replaced
//              with a new one.
//
//              The task object is not persisted until the user hits the
//              finish button.
//
//---------------------------------------------------------------------------

HRESULT
CCompletionPage::_UpdateTaskObject()
{
    TRACE_METHOD(CCompletionPage, _CreateTaskObject);

    HRESULT             hr = S_OK;
    ITaskTrigger       *pTrigger = NULL;
    CSelectTriggerPage *pSelTrig = GetSelectTriggerPage(_pParent);
    CSelectProgramPage *pSelProg = GetSelectProgramPage(_pParent);

    do
    {
        //
        // If there's already a task object, get rid of it.  This would
        // be the case if the user got to the finish page, then hit
        // the back button.
        //

        if (_pJob)
        {
            _pJob->Release();
            _pJob = NULL;
        }

        //
        // Create the task object
        //

        _pJob = CJob::Create();

        if (_pJob == NULL)
        {
            hr = E_OUTOFMEMORY;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        //
        // Add default flags
        //

        DWORD dwAddFlags = TASK_FLAG_DONT_START_IF_ON_BATTERIES |
                           TASK_FLAG_KILL_IF_GOING_ON_BATTERIES;

        hr = _pJob->SetFlags(dwAddFlags);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Fill in the trigger struct
        //

        TASK_TRIGGER Trigger;

        ZeroMemory(&Trigger, sizeof(Trigger));
        Trigger.cbTriggerSize = sizeof(Trigger);

        CTriggerPage *pTriggerPage = pSelTrig->GetSelectedTriggerPage();

        if (pTriggerPage)
        {
            pTriggerPage->FillInTrigger(&Trigger);
        }
        else
        {
            ULONG idTrigger = pSelTrig->GetSelectedTriggerType();

            switch (idTrigger)
            {
            case seltrig_startup_rb:
                Trigger.TriggerType = TASK_EVENT_TRIGGER_AT_SYSTEMSTART;
                break;

            case seltrig_logon_rb:
                Trigger.TriggerType = TASK_EVENT_TRIGGER_AT_LOGON;
                break;

            default:
                DEBUG_ASSERT(FALSE);
                hr = E_UNEXPECTED;
                break;
            }
            BREAK_ON_FAIL_HRESULT(hr);

            SYSTEMTIME   stStart;
            GetSystemTime(&stStart);

            Trigger.wBeginYear = stStart.wYear;
            Trigger.wBeginMonth = stStart.wMonth;
            Trigger.wBeginDay = stStart.wDay;
        }

        //
        // Create a trigger object and init it with the struct
        //

        WORD iTrigger = (WORD)-1;

        hr = _pJob->CreateTrigger(&iTrigger, &pTrigger);
        BREAK_ON_FAIL_HRESULT(hr);

        DEBUG_ASSERT(iTrigger == 0);

        hr = pTrigger->SetTrigger(&Trigger);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Set the application name
        //

        TCHAR tszExeFullPath[MAX_PATH + 1];

        pSelProg->GetExeFullPath(tszExeFullPath, ARRAYLEN(tszExeFullPath));

#ifdef UNICODE
        hr = _pJob->SetApplicationName(tszExeFullPath);
#else
        WCHAR wszBuf[MAX_PATH + 1];

        hr = AnsiToUnicode(wszBuf, tszExeFullPath, ARRAYLEN(wszBuf));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pJob->SetApplicationName(wszBuf);
#endif
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Set the arguments
        //

#ifdef UNICODE
        hr = _pJob->SetParameters(pSelProg->GetArgs());
#else
        //
        // Since unicode is not defined, we're running on chicago, which
        // means that the app chosen might be sage-aware.  If it is,
        // it will need a /sagerun:n argument.
        //
        // BUGBUG if the wizard is made remotable then this will need
        // to be performed while running on nt if the target is win9x.
        //

        TCHAR tszExeName[MAX_PATH + 1];
        int iSageParam;

        pSelProg->GetExeName(tszExeName, ARRAYLEN(tszExeName));

        LPCTSTR ptzArgs = pSelProg->GetArgs();

        if (IsSageAware(tszExeName, ptzArgs, &iSageParam) &&
            MAX_CCH_SAGERUN_PARAM + lstrlen(ptzArgs) < ARRAYLEN(wszBuf))
        {
            TCHAR tszBuf[MAX_PATH + 1];

            wsprintf(tszBuf,
                     TEXT("%s %s%u"),
                     pSelProg->GetArgs(),
                     SAGERUN_PARAM,
                     iSageParam);

            hr = AnsiToUnicode(wszBuf, tszBuf, ARRAYLEN(wszBuf));

            CreateSageRunKey(tszExeName, iSageParam);
        }
        else
        {
            hr = AnsiToUnicode(wszBuf, ptzArgs, ARRAYLEN(wszBuf));
        }
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pJob->SetParameters(wszBuf);
#endif
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Set the working directory
        //

        TCHAR tszWorkingDir[MAX_PATH + 1];

        pSelProg->GetExeDir(tszWorkingDir, ARRAYLEN(tszWorkingDir));

#ifdef UNICODE
        hr = _pJob->SetWorkingDirectory(tszWorkingDir);
#else

        hr = AnsiToUnicode(wszBuf, tszWorkingDir, ARRAYLEN(wszBuf));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pJob->SetWorkingDirectory(wszBuf);
#endif
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    if (pTrigger)
    {
        pTrigger->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\monthly.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       monthly.cxx
//
//  Contents:   Task wizard monthly trigger property page implementation.
//
//  Classes:    CMonthlyPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// Constants
//
// NMONTHDAYS_MIN - minimum value for monthly_day_ud spin control
// NMONTHDAYS_MAX - maximun value for monthly_day_ud spin control
// MONTHS_WITHOUT_DAY_31 - used to ensure trigger settings will allow task
//                          to run
//

#define NMONTHDAYS_MIN              1
#define NMONTHDAYS_MAX              31

#define MONTHS_WITHOUT_DAY_31       (TASK_FEBRUARY  | \
                                     TASK_APRIL     | \
                                     TASK_JUNE      | \
                                     TASK_SEPTEMBER | \
                                     TASK_NOVEMBER)


//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::CMonthlyPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CMonthlyPage::CMonthlyPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CTriggerPage(IDD_MONTHLY,
                     IDS_MONTHLY_HDR2,
                     ptszFolderPath,
                     phPSP)
{
    TRACE_CONSTRUCTOR(CMonthlyPage);

    _idSelectedDayType = 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::~CMonthlyPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CMonthlyPage::~CMonthlyPage()
{
    TRACE_DESTRUCTOR(CMonthlyPage);
}




//===========================================================================
//
// CPropPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_OnCommand
//
//  Synopsis:   Handle user input
//
//  Arguments:  [id]         - resource id of control affected
//              [hwndCtl]    - window handle of control affected
//              [codeNotify] - indicates what happened to control
//
//  Returns:    0 (handled), 1 (not handled)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CMonthlyPage::_OnCommand(
    INT id,
    HWND hwndCtl,
    UINT codeNotify)
{
    LRESULT lr = 0;

    switch (codeNotify)
    {
    case BN_CLICKED:
        switch (id)
        {
        case monthly_day_rb:
        case monthly_combo_rb:
            _idSelectedDayType = (WORD)id;
            _EnableDayCombos(id == monthly_combo_rb);
            EnableWindow(_hCtrl(monthly_day_edit), id == monthly_day_rb);
            EnableWindow(_hCtrl(monthly_day_ud), id == monthly_day_rb);
            break;
        }
        _UpdateWizButtons();
        break;

    case EN_UPDATE:
    {
        //
        // If the user just pasted non-numeric text or an illegal numeric
        // value, overwrite it and complain.
        //

        INT iNewPos = GetDlgItemInt(Hwnd(), monthly_day_edit, NULL, FALSE);

        if (iNewPos < NMONTHDAYS_MIN || iNewPos > NMONTHDAYS_MAX)
        {
            HWND hUD = _hCtrl(monthly_day_ud);
            UpDown_SetPos(hUD, UpDown_GetPos(hUD));
            MessageBeep(MB_ICONASTERISK);
        }
    }

    default:
        lr = 1;
        break;
    }
    return lr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CMonthlyPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CMonthlyPage, _OnInitDialog);

    TCHAR tszBuff[SCH_BIGBUF_LEN];
    ULONG i;
    HWND  hCombo = _hCtrl(monthly_ordinality_combo);

    _UpdateTimeFormat();

    for (i = 0; i < ARRAYLEN(g_aWeekData); i++)
    {
        LoadStr(g_aWeekData[i].ids, tszBuff, SCH_BIGBUF_LEN);
        ComboBox_AddString(hCombo, tszBuff);
    }
    ComboBox_SetCurSel(hCombo, 0);

    hCombo = _hCtrl(monthly_day_combo);

    for (i = 0; i < ARRAYLEN(g_aDayData); i++)
    {
        LoadStr(g_aDayData[i].ids, tszBuff, SCH_BIGBUF_LEN);
        ComboBox_AddString(hCombo, tszBuff);
    }
    ComboBox_SetCurSel(hCombo, 0);

    _EnableDayCombos(FALSE);
    UpDown_SetRange(_hCtrl(monthly_day_ud), NMONTHDAYS_MIN, NMONTHDAYS_MAX);
    UpDown_SetPos(_hCtrl(monthly_day_ud), NMONTHDAYS_MIN);
    Edit_LimitText(_hCtrl(monthly_day_edit), 3);

    for (i = monthly_jan_ckbox; i <= monthly_dec_ckbox; i++)
    {
        CheckDlgButton(Hwnd(), i, BST_CHECKED);
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_OnPSNSetActive
//
//  Synopsis:   Enable Next button if this page's data is valid
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      Some of the page verification is left to the _OnWizNext
//              routine.  This allows us to respond to invalid data by
//              displaying an explanatory message rather than simply
//              disabling the Next button.
//
//---------------------------------------------------------------------------

LRESULT
CMonthlyPage::_OnPSNSetActive(
    LPARAM lParam)
{
    _UpdateWizButtons();
    return CPropPage::_OnPSNSetActive(lParam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_OnWizNext
//
//  Synopsis:   Validate the selections not already checked by
//              _OnPSNSetActive and _OnCommand.
//
//  Returns:     0 - advance to next page
//              -1 - stay on this page
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CMonthlyPage::_OnWizNext()
{
    USHORT flMonths = _ReadSelectedMonths();

    //
    // Verify at least one month is selected
    //

    if (!flMonths)
    {
        SchedUIMessageDialog(Hwnd(),
                             IERR_INVALID_MONTHLY_TASK,
                             MB_OK | MB_ICONERROR | MB_SETFOREGROUND,
                             (LPTSTR) NULL);
        return -1;
    }

    //
    // If the user specified that the trigger should fire on a specific day,
    // verify that at least one of the selected months contains that day.
    //

    if (_idSelectedDayType == monthly_day_rb)
    {
        USHORT usDay = (USHORT) UpDown_GetPos(_hCtrl(monthly_day_ud));
        ULONG  idsErrMsg = 0;

        if (usDay == 31 &&
            (flMonths & MONTHS_WITHOUT_DAY_31) &&
            !(flMonths & ~MONTHS_WITHOUT_DAY_31))
        {
            idsErrMsg = IDS_MONTHS_HAVE_LT_31_DAYS;
        }
        else if (usDay == 30 && flMonths == TASK_FEBRUARY)
        {
            idsErrMsg = IDS_MONTHS_HAVE_LT_30_DAYS;
        }

        if (idsErrMsg)
        {
            SchedUIMessageDialog(Hwnd(),
                                 idsErrMsg,
                                 MB_OK | MB_ICONERROR | MB_SETFOREGROUND,
                                 (LPTSTR) NULL);

            SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, IDD_MONTHLY);
            return -1;
        }
    }

    //
    // Trigger is valid, delegate to base to advance to the next page.
    //

    return CTriggerPage::_OnWizNext();
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_UpdateWizButtons
//
//  Synopsis:   Enable the Next button if a preliminary analysis indicates
//              that the user's selections are valid.
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      _OnWizNext does additional checking
//
//---------------------------------------------------------------------------

VOID
CMonthlyPage::_UpdateWizButtons()
{
    BOOL fEnableNext = TRUE;

    if (!_ReadSelectedMonths() || !_idSelectedDayType)
    {
        fEnableNext = FALSE;
    }

    if (fEnableNext)
    {
        _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        _SetWizButtons(PSWIZB_BACK);
    }
}




//===========================================================================
//
// CTriggerPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::FillInTrigger
//
//  Synopsis:   Fill in the fields of the trigger structure according to the
//              settings specified for this type of trigger
//
//  Arguments:  [pTrigger] - trigger struct to fill in
//
//  Modifies:   *[pTrigger]
//
//  History:    5-06-1997   DavidMun   Created
//
//  Notes:      Precondition is that trigger's cbTriggerSize member is
//              initialized.
//
//---------------------------------------------------------------------------

VOID
CMonthlyPage::FillInTrigger(
    TASK_TRIGGER *pTrigger)
{
    INT i;
    WORD *prgfMonths;

    if (_idSelectedDayType == monthly_day_rb)
    {
        pTrigger->TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
        USHORT usDay = (USHORT) UpDown_GetPos(_hCtrl(monthly_day_ud));

        pTrigger->Type.MonthlyDate.rgfDays = 1 << (usDay - 1);
        prgfMonths = &pTrigger->Type.MonthlyDate.rgfMonths;
    }
    else
    {
        DEBUG_ASSERT(_idSelectedDayType == monthly_combo_rb);
        pTrigger->TriggerType = TASK_TIME_TRIGGER_MONTHLYDOW;

        i = ComboBox_GetCurSel(_hCtrl(monthly_ordinality_combo));
        pTrigger->Type.MonthlyDOW.wWhichWeek = (WORD)g_aWeekData[i].week;

        i = ComboBox_GetCurSel(_hCtrl(monthly_day_combo));
        pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek = (WORD)g_aDayData[i].day;

        prgfMonths = &pTrigger->Type.MonthlyDOW.rgfMonths;
    }

    *prgfMonths = _ReadSelectedMonths();

    SYSTEMTIME st;

    GetLocalTime(&st);

    pTrigger->wBeginYear   = st.wYear;
    pTrigger->wBeginMonth  = st.wMonth;
    pTrigger->wBeginDay    = 1;

    DateTime_GetSystemtime(_hCtrl(starttime_dp), &st);

    pTrigger->wStartHour   = st.wHour;
    pTrigger->wStartMinute = st.wMinute;
}




//===========================================================================
//
// CMonthlyPage methods
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_ReadSelectedMonths
//
//  Synopsis:   Return a bitmask representing the checked day of week buttons
//
//  History:    07-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

WORD
CMonthlyPage::_ReadSelectedMonths()
{
    WORD flMonths = 0;
    INT i;

    for (i = monthly_jan_ckbox; i <= monthly_dec_ckbox; i++)
    {
        if (IsDlgButtonChecked(Hwnd(), i))
        {
            flMonths |= 1 << (i - monthly_jan_ckbox);
        }
    }
    return flMonths;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMonthlyPage::_EnableDayCombos
//
//  Synopsis:   Enable or disable the monthly DOW controls
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CMonthlyPage::_EnableDayCombos(
    BOOL fEnable)
{
    EnableWindow(_hCtrl(monthly_ordinality_combo), fEnable);
    EnableWindow(_hCtrl(monthly_day_combo), fEnable);
    EnableWindow(_hCtrl(monthly_combo_lbl), fEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\password.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       once.cxx
//
//  Contents:   Task wizard once trigger property page implementation.
//
//  Classes:    CPasswordPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// External functions
//

void
GetDefaultDomainAndUserName(
    LPTSTR ptszDomainAndUserName,
    ULONG  cchBuf);



//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::CPasswordPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CPasswordPage::CPasswordPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        _pParent(pParent),
        CWizPage(MAKEINTRESOURCE(IDD_PASSWORD), ptszFolderPath)
{
    TRACE_CONSTRUCTOR(CPasswordPage);

    *_tszUserName = TCHAR('\0');
    *_tszPassword = TCHAR('\0');
    *_tszConfirmPassword = TCHAR('\0');

    _CreatePage(IDS_TRIGGER_HDR1, IDS_PASSWORD_HDR2, phPSP);
}




//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::~CPasswordPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CPasswordPage::~CPasswordPage()
{
    TRACE_DESTRUCTOR(CPasswordPage);
    ZeroCredentials();
}




//===========================================================================
//
// CPropPage overrides
//
//===========================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::_OnCommand
//
//  Synopsis:   Update stored credential information and Next button state
//              in response to user input to the account or password edits.
//
//  Arguments:  [id]         - resource id of control affected
//              [hwndCtl]    - window handle of control affected
//              [codeNotify] - indicates what happened to control
//
//  Returns:    0 (handled), 1 (not handled)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CPasswordPage::_OnCommand(
    INT id,
    HWND hwndCtl,
    UINT codeNotify)
{
    LRESULT lr = 0;

    if (codeNotify == EN_UPDATE)
    {
        switch (id)
        {
        case password_name_edit:
            Edit_GetText(hwndCtl, _tszUserName, ARRAYLEN(_tszUserName));
            StripLeadTrailSpace(_tszUserName);
            break;

        case password_password_edit:
            Edit_GetText(hwndCtl, _tszPassword, ARRAYLEN(_tszPassword));
            break;

        case password_confirm_edit:
            Edit_GetText(hwndCtl,
                         _tszConfirmPassword,
                         ARRAYLEN(_tszConfirmPassword));
            break;
        }
        _UpdateWizButtons();
    }
    else
    {
        lr = 1;
    }
    return lr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CPasswordPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CPasswordPage, _OnInitDialog);

    Edit_LimitText(_hCtrl(password_name_edit), MAX_PATH);
    Edit_LimitText(_hCtrl(password_password_edit), MAX_PATH);
    Edit_LimitText(_hCtrl(password_confirm_edit), MAX_PATH);

    GetDefaultDomainAndUserName(_tszUserName, ARRAYLEN(_tszUserName));

    Edit_SetText(_hCtrl(password_name_edit), _tszUserName);
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::_OnPSNSetActive
//
//  Synopsis:   Enable the Next button iff this page's data is valid
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CPasswordPage::_OnPSNSetActive(
    LPARAM lParam)
{
    _UpdateWizButtons();
    return CPropPage::_OnPSNSetActive(lParam);
}




//===========================================================================
//
// CWizPage overrides
//
//===========================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::_OnWizBack
//
//  Synopsis:   Set the current page to the selected trigger page
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CPasswordPage::_OnWizBack()
{
    TRACE_METHOD(CPasswordPage, _OnWizBack);

    ULONG iddPage = GetSelectTriggerPage(_pParent)->GetSelectedTriggerPageID();
    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, iddPage);
    return -1;
}




//===========================================================================
//
// CPasswordPage methods
//
//===========================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CPasswordPage::_UpdateWizButtons
//
//  Synopsis:   Enable the Next button iff this page's data is valid.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CPasswordPage::_UpdateWizButtons()
{
    if (*_tszUserName                               && // name nonempty
        !lstrcmp(_tszPassword, _tszConfirmPassword))   // pwd == confirm
    {
        _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        _SetWizButtons(PSWIZB_BACK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\once.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       once.cxx
//
//  Contents:   Task wizard once trigger property page implementation.
//
//  Classes:    COncePage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"




//+--------------------------------------------------------------------------
//
//  Member:     COncePage::COncePage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

COncePage::COncePage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CTriggerPage(IDD_ONCE,
                     IDS_ONCE_HDR2,
                     ptszFolderPath,
                     phPSP)
{
    TRACE_CONSTRUCTOR(COncePage);
}




//+--------------------------------------------------------------------------
//
//  Member:     COncePage::~COncePage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

COncePage::~COncePage()
{
    TRACE_DESTRUCTOR(COncePage);
}



//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     COncePage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
COncePage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(COncePage, _OnInitDialog);

    _UpdateTimeFormat();
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     COncePage::_OnPSNSetActive
//
//  Synopsis:   Enable back and next buttons.
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      (This page can never have invalid data, so Next should
//              always be enabled.)
//
//---------------------------------------------------------------------------

LRESULT
COncePage::_OnPSNSetActive(
    LPARAM lParam)
{
    _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    return CPropPage::_OnPSNSetActive(lParam);
}



//===========================================================================
//
// CTriggerPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     COncePage::FillInTrigger
//
//  Synopsis:   Fill in the fields of the trigger structure according to the
//              settings specified for this type of trigger
//
//  Arguments:  [pTrigger] - trigger struct to fill in
//
//  Modifies:   *[pTrigger]
//
//  History:    5-06-1997   DavidMun   Created
//
//  Notes:      Precondition is that trigger's cbTriggerSize member is
//              initialized.
//
//---------------------------------------------------------------------------

VOID
COncePage::FillInTrigger(
    TASK_TRIGGER *pTrigger)
{
    pTrigger->TriggerType = TASK_TIME_TRIGGER_ONCE;
    FillInStartDateTime(_hCtrl(startdate_dp), _hCtrl(starttime_dp), pTrigger);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\resource.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       resource.h
//
//  Contents:   Resource identifiers for create new task wizard.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

//
// Task Scheduler string ID usage:
//
// 0-6          "..\inc\resource.h"
// 32           "..\inc\resource.h"      (NORMAL_PRIORITY_CLASS)
// 64           "..\inc\resource.h"      (IDLE_PRIORITY_CLASS)    
// 100-110      "..\folderui\resource.h" 
// 128          "..\inc\resource.h"      (HIGH_PRIORITY_CLASS)     
// 151-167      "..\folderui\resource.h"  
// 256          "..\inc\resource.h"      (REALTIME_PRIORITY_CLASS)
// 300-400      "..\wizard\resource.h"
// 1034         "..\inc\resource.h"
// 1067-1177    "..\inc\resource.h"
// 2000-2999    "..\folderui\resource.h"
// 3330-3333    "..\inc\resource.h"
// 3400-3406    "..\inc\resource.h"
// 3800-3810    "..\folderui\resource.h"
// 4000         "..\folderui\resource.h"
// 4101-4152    "..\schedui\rc.h"
//
// Task Scheduler dialog ID usage:
//
// 102-104      "..\schedui\rc.h"
// 300-350      "..\wizard\resource.h"
// 401-403      "..\schedui\rc.h"
// 1771         "..\schedui\rc.h"
//


/////////////////////////////////////////////////////////////////////////////
//
// Strings
//


#define IDB_BANNER256                   300 // these are bitmaps, but put 
#define IDB_BANNER16                    301 // here because it's a safe range
#define IDB_WATERMARK16                 302
#define IDB_WATERMARK256                303
#define IDS_LARGEFONTNAME               304
#define IDS_LARGEFONTSIZE               305
#define IDC_BIGBOLDTITLE                306
#define IDC_BOLDTITLE                   307
#define IDS_SELPROG_HDR1                308
#define IDS_SELPROG_HDR2                309
#define IDS_SELTRIG_HDR1                310
#define IDS_SELTRIG_HDR2                311
#define IDS_TRIGGER_HDR1                312
#define IDS_DAILY_HDR2                  313
#define IDS_WEEKLY_HDR2                 314
#define IDS_MONTHLY_HDR2                315
#define IDS_ONCE_HDR2                   316
#define IDS_PASSWORD_HDR2               317
#define IDS_FIRSTCOLUMN                 IDS_APPLICATION
#define IDS_APPLICATION                 318
#define IDS_VERSION                     319
//#define                               320   reserved for column expansion
//#define                               321
//#define                               322
//#define                               323
//#define                               324
#define IDS_ALLUSERS_PATH               325
#define IDS_CAPTION                     326
#define IDS_BAD_FILENAME                327
#define IDS_WIZARD_FILTER               328
#define IDS_WIZARD_BROWSE_CAPTION       329
#define IDS_TASK_ALREADY_EXISTS         330
#define IDS_CANT_DELETE_EXISTING        331
#define IDS_MONTHS_HAVE_LT_31_DAYS      332
#define IDS_MONTHS_HAVE_LT_30_DAYS      333
#define IDB_SPLASH                      334
#define IDS_TEMPLATE_NAME               335
#define IDS_WIZFINISH_NONFATAL          336
#define IDS_WIZFINISH_FATAL             337    

/////////////////////////////////////////////////////////////////////////////
//
// Dialogs
//

#define IDC_STATIC                      -1


#define IDD_WELCOME                     300
#define IDD_SELECT_PROGRAM              301
#define IDD_COMPLETION                  302
#define IDD_SELECT_TRIGGER              303
#define IDD_DAILY                       304
#define IDD_WEEKLY                      305
#define IDD_MONTHLY                     306
#define IDD_ONCE                        307
#define IDD_PASSWORD                    308
#define IDD_SELMONTH                    309

#define starttime_dp                    900
#define startdate_dp                    901

#define selprog_programs_lv             1001
#define selprogs_browse_pb              1002
#define selprogs_static_text_browse     1003

#define complete_task_icon              1001
#define complete_taskname_lbl           1002
#define complete_trigger_lbl            1003
#define complete_time_lbl               1004
#define complete_advanced_ckbox         1005
#define complete_date_lbl               1006

#define seltrig_taskname_edit           1001
#define seltrig_first_rb                seltrig_daily_rb
#define seltrig_daily_rb                1002
#define seltrig_weekly_rb               1003
#define seltrig_monthly_rb              1004
#define seltrig_once_rb                 1005
#define seltrig_startup_rb              1006
#define seltrig_logon_rb                1007
#define seltrig_last_rb                 seltrig_logon_rb

#define daily_day_rb                    1001
#define daily_weekday_rb                1002
#define daily_ndays_rb                  1003
#define daily_ndays_ud                  1004
#define daily_ndays_edit                1005
#define daily_ndays_lbl                 1006

#define weekly_nweeks_rb                1003
#define weekly_nweeks_edit              1004
#define weekly_nweeks_ud                1005
#define weekly_nweeks_lbl               1006
#define weekly_monday_ckbox             1007
#define weekly_tuesday_ckbox            1008
#define weekly_wednesday_ckbox          1009
#define weekly_thursday_ckbox           1010
#define weekly_friday_ckbox             1011
#define weekly_saturday_ckbox           1012
#define weekly_sunday_ckbox             1013

#define monthly_day_rb                  1003
#define monthly_day_edit                1004
#define monthly_day_ud                  1005
#define monthly_combo_rb                1006
#define monthly_ordinality_combo        1007
#define monthly_day_combo               1008
#define monthly_combo_lbl               1009
#define monthly_day_lbl                 1010
#define monthly_jan_ckbox               1011
#define monthly_feb_ckbox               1012
#define monthly_mar_ckbox               1013
#define monthly_apr_ckbox               1014
#define monthly_may_ckbox               1015
#define monthly_jun_ckbox               1016
#define monthly_jul_ckbox               1017
#define monthly_aug_ckbox               1018
#define monthly_sep_ckbox               1019
#define monthly_oct_ckbox               1020
#define monthly_nov_ckbox               1021
#define monthly_dec_ckbox               1022

#define password_name_edit              1001
#define password_password_edit          1002
#define password_confirm_edit           1003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\seltrig.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       selprog.cxx
//
//  Contents:   Task wizard trigger selection property page implementation.
//
//  Classes:    CSelectTriggerPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// Constants
//
// ILLEGAL_FILENAME_CHARS - characters to reject in task name edit control
//

#define ILLEGAL_FILENAME_CHARS      TEXT("<>:/\\|")


#define ARRAY_LEN(a)    (sizeof(a)/sizeof(a[0]))


//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::CSelectTriggerPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSelectTriggerPage::CSelectTriggerPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        _pParent(pParent),
        CWizPage(MAKEINTRESOURCE(IDD_SELECT_TRIGGER), ptszFolderPath)
{
    TRACE_CONSTRUCTOR(CSelectTriggerPage);

    DEBUG_ASSERT(pParent);
    _tszDisplayName[0] = TCHAR('\0');
    _tszJobObjectFullPath[0] = TCHAR('\0');
    _idSelectedTrigger = 0;
    _CreatePage(IDS_SELTRIG_HDR1, IDS_SELTRIG_HDR2, phPSP);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::~CSelectTriggerPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSelectTriggerPage::~CSelectTriggerPage()
{
    TRACE_DESTRUCTOR(CSelectTriggerPage);
}




//===========================================================================
//
// CPropPage overrides
//
//===========================================================================


LRESULT
CSelectTriggerPage::_OnCommand(
    INT id,
    HWND hwndCtl,
    UINT codeNotify)
{
    TRACE_METHOD(CSelectTriggerPage, _OnCommand);

    LRESULT lr = 1;

    if (codeNotify == BN_CLICKED &&
        id >= seltrig_first_rb && id <= seltrig_last_rb)
    {
        lr = 0;

        if (!_idSelectedTrigger && *_tszDisplayName)
        {
            _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
        }
        _idSelectedTrigger = id;
    }
    else if (codeNotify == EN_UPDATE)
    {
        Edit_GetText(_hCtrl(seltrig_taskname_edit),
                     _tszDisplayName,
                     ARRAYLEN(_tszDisplayName));

        StripLeadTrailSpace(_tszDisplayName);

        if (!*_tszDisplayName)
        {
            _SetWizButtons(PSWIZB_BACK);
        }
        else if (_idSelectedTrigger)
        {
            _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
        }
    }
    return lr;
}




//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::_OnInitDialog
//
//  Synopsis:   Initialize the controls on this page, only called once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectTriggerPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CSelectTriggerPage, _OnInitDialog);

    HWND hwndEdit = _hCtrl(seltrig_taskname_edit);

    Edit_LimitText(hwndEdit,
                   ARRAYLEN(_tszDisplayName)
                   - 1                      // null terminator
                   - lstrlen(GetTaskPath()) // path to tasks folder
                   - 1                      // backslash
                   - (ARRAY_LEN(TSZ_DOTJOB) - 1));  // extension

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::_OnPSNSetActive
//
//  Synopsis:   Init wizard buttons and other controls, called whenever
//              this page becomes the current page.
//
//  Arguments:  [lParam] - unused
//
//  Returns:    TRUE
//
//  History:    5-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectTriggerPage::_OnPSNSetActive(
    LPARAM lParam)
{
    if (_idSelectedTrigger)
    {
        _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        _SetWizButtons(PSWIZB_BACK);
    }

    if (!*_tszDisplayName)
    {
        CSelectProgramPage *pSelProg = GetSelectProgramPage(_pParent);

        pSelProg->GetDefaultDisplayName(_tszDisplayName,
                                        ARRAYLEN(_tszDisplayName));
        Edit_SetText(_hCtrl(seltrig_taskname_edit), _tszDisplayName);
    }
    return CPropPage::_OnPSNSetActive(lParam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::_OnWizBack
//
//  Synopsis:   Handle the user's selection of the 'Back' button.
//
//  History:    5-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectTriggerPage::_OnWizBack()
{
    *_tszDisplayName = TEXT('\0');
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectTriggerPage::_OnWizNext
//
//  Synopsis:   Handle the user's selection of the 'Next' button
//
//  Returns:    -1 (DWLP_MSGRESULT contains next page number)
//
//  History:    5-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectTriggerPage::_OnWizNext()
{
    TRACE_METHOD(CSelectTriggerPage, _OnWizNext);

    LONG lNextPage;

    do
    {
        //
        // Check the filename for invalid characters
        //

        if (_tcspbrk(_tszDisplayName, ILLEGAL_FILENAME_CHARS))
        {
            SchedUIErrorDialog(Hwnd(), IDS_BAD_FILENAME, (LPTSTR) NULL);
            lNextPage = IDD_SELECT_TRIGGER; // stay on this page
            break;
        }

        //
        // Build the full pathname to the .job object
        //

        ULONG cchPath = lstrlen(GetTaskPath());

        lstrcpy(_tszJobObjectFullPath, GetTaskPath());
        lstrcpyn(&_tszJobObjectFullPath[cchPath],
                 GetTaskName(),
                 ARRAYLEN(_tszJobObjectFullPath) - (cchPath + ARRAY_LEN(TSZ_DOTJOB) - 1));
        lstrcat(_tszJobObjectFullPath, TSZ_DOTJOB);
        DeleteQuotes(_tszJobObjectFullPath);

        //
        // If the name collides with an existing task, get the user's
        // confirmation before proceeding to next page
        //

        if (FileExists(_tszJobObjectFullPath))
        {
            INT iAnswer = SchedUIMessageDialog(Hwnd(),
                                               IDS_TASK_ALREADY_EXISTS,
                                               MB_APPLMODAL      |
                                                MB_SETFOREGROUND |
                                                MB_ICONQUESTION  |
                                                MB_YESNO,
                                               _tszDisplayName);
            if (iAnswer != IDYES)
            {
                lNextPage = IDD_SELECT_TRIGGER;
                break;
            }
        }

        //
        // If the selected trigger type doesn't have its own page,
        // go directly to the end
        //

        if (_idSelectedTrigger == seltrig_startup_rb ||
            _idSelectedTrigger == seltrig_logon_rb)
        {
#if defined(_CHICAGO_)
            lNextPage = IDD_COMPLETION;
#else
            lNextPage = IDD_PASSWORD;
#endif // defined(_CHICAGO_)
            break;
        }

        lNextPage = IDD_DAILY + (_idSelectedTrigger - seltrig_first_rb);
    } while (0);

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, lNextPage);
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\sources.inc ===
#+----------------------------------------------------------------------------
#
#  Microsoft Windows
#  Copyright (C) Microsoft Corporation, 1995 - 1997.
#
#  Synopsis:    Source list file for the scheduler create/edit task wizard.
#
#  History:     04-28-1997  DavidMun    Created.
#
#-----------------------------------------------------------------------------



TARGETNAME=wizard
TARGETTYPE=LIBRARY
    
INCLUDES=..;$(INCLUDES)

              
SOURCES=        \
                ..\complete.cxx \
                ..\daily.cxx    \
                ..\monthly.cxx  \
                ..\once.cxx     \
                ..\selprog.cxx  \
                ..\seltrig.cxx  \
                ..\taskwiz.cxx  \
                ..\trigpage.cxx \
                ..\util.cxx     \
                ..\walklib.cxx  \
                ..\weekly.cxx   \
                ..\welcome.cxx  \
                ..\wizpage.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\selprog.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       selprog.cxx
//
//  Contents:   Task wizard program selection property page implementation.
//
//  Classes:    CSelectProgramPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

#include "commdlg.h"
#include "..\schedui\rc.h"
#include "..\inc\resource.h"

//
// Types
//
// COLUMNS - indexes to the columns in the listview displaying the results
//  of walking the start menu
//


enum COLUMNS
{
    COL_APP,
    COL_VERSION,

    NUM_COLUMNS
};

//
// Forward references
//

INT
InsertSmallIcon(
    HIMAGELIST  hSmallImageList,
    LPCTSTR     tszExeName);


//
// Externals
//

extern HICON
GetDefaultAppIcon(
    BOOL fLarge);




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::CSelectProgramPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSelectProgramPage::CSelectProgramPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CWizPage(MAKEINTRESOURCE(IDD_SELECT_PROGRAM), ptszFolderPath)
{
    TRACE_CONSTRUCTOR(CSelectProgramPage);

    _hwndLV = NULL;
    _pSelectedLinkInfo = NULL;
    _idxSelectedIcon = 0;
    _fUseBrowseSelection = FALSE;
    _tszExePath[0] = TEXT('\0');
    _tszExeName[0] = TEXT('\0');

    _CreatePage(IDS_SELPROG_HDR1, IDS_SELPROG_HDR2, phPSP);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::~CSelectProgramPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSelectProgramPage::~CSelectProgramPage()
{
    TRACE_DESTRUCTOR(CSelectProgramPage);
}



//===========================================================================
//
// CPropPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_OnCommand
//
//  Synopsis:   Handle the browse button being clicked, ignore all else.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectProgramPage::_OnCommand(
    int id,
    HWND hwndCtl,
    UINT codeNotify)
{
    TRACE_METHOD(CSelectProgramPage, _OnCommand);

    LRESULT lr = 0;

    if (codeNotify == BN_CLICKED && id == selprogs_browse_pb)
    {
        _OnBrowse();
    }
    else
    {
        lr = 1; // not handled
    }
    return lr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectProgramPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CSelectProgramPage, _OnInitDialog);
    HRESULT hr = S_OK;

    // Policy dictates whether we have a browse button or not
    // true means don't allow us to browse

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_BROWSE))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy DENY_BROWSE active - removing browse btn\n"));
        EnableWindow(_hCtrl(selprogs_browse_pb), FALSE);
        ShowWindow(_hCtrl(selprogs_browse_pb), SW_HIDE);
        ShowWindow(_hCtrl(selprogs_static_text_browse), SW_HIDE);
    }

    // Next not enabled till user picks app

    _SetWizButtons(PSWIZB_BACK);

    _hwndLV = _hCtrl(selprog_programs_lv);

    hr = _InitListView();

    if (SUCCEEDED(hr))
    {
        _PopulateListView();
    }
    return (HRESULT) TRUE; // wm_initdialog wants BOOL for setfocus info
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_OnPSNSetActive
//
//  Synopsis:   Enable the Next button if an item has been selected in the
//              listview.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectProgramPage::_OnPSNSetActive(
    LPARAM lParam)
{
    _fUseBrowseSelection = FALSE;

    if (_pSelectedLinkInfo)
    {
        _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        _SetWizButtons(PSWIZB_BACK);
    }
    return CPropPage::_OnPSNSetActive(lParam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_OnDestroy
//
//  Synopsis:   Free all the linkinfos stored as user data in the listview.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CSelectProgramPage::_OnDestroy()
{
    DEBUG_ASSERT(IsWindow(_hwndLV));

    ULONG cItems = ListView_GetItemCount(_hwndLV);
    ULONG i;
    LV_ITEM lvi;

    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM;

    for (i = 0; i < cItems; i++)
    {
        lvi.iItem = i;
        lvi.lParam = 0;

        BOOL fOk = ListView_GetItem(_hwndLV, &lvi);

        if (fOk)
        {
            delete (LINKINFO *) lvi.lParam;
        }
        else
        {
            DEBUG_OUT_LASTERROR;
        }
    }
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_ProcessListViewNotifications
//
//  Synopsis:   If the user makes a selection in the listview, remember the
//              associated linkinfo and enable the next button.
//
//  Returns:    FALSE
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      Ignores all other notifications.
//
//---------------------------------------------------------------------------

BOOL
CSelectProgramPage::_ProcessListViewNotifications(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT code = ((LPNMHDR)lParam)->code;

    if (((LPNMHDR)lParam)->idFrom != selprog_programs_lv)
    {
        return FALSE;
    }

    DEBUG_ASSERT(code != LVN_GETDISPINFO); // not using callbacks
    DEBUG_ASSERT(code != LVN_SETDISPINFO); // items are r/o

    if (code == LVN_ITEMCHANGED)
    {
        NM_LISTVIEW *pnmLV = (NM_LISTVIEW *) lParam;

        if ((pnmLV->uChanged & LVIF_STATE) &&
            (pnmLV->uNewState & LVIS_SELECTED))
        {
            // translate the index into a LinkInfo pointer

            LV_ITEM lvi;

            lvi.iItem = pnmLV->iItem;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM | LVIF_IMAGE;

            if (!ListView_GetItem(_hwndLV, &lvi))
            {
                DEBUG_OUT_LASTERROR;
                return FALSE;
            }

            _pSelectedLinkInfo = (LINKINFO *) lvi.lParam;
            _idxSelectedIcon = lvi.iImage;
            _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
        }
    }
    return FALSE;
}




//===========================================================================
//
// CSelectProgramPage members
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::GetDefaultDisplayName
//
//  Synopsis:   Fill [tszDisplayName] with the string to offer the user
//              as the new task object name.
//
//  Arguments:  [tszDisplayName] - buffer to receive string
//              [cchDisplayName] - size, in chars, of buffer
//
//  Modifies:   *[tszDisplayName]
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectProgramPage::GetDefaultDisplayName(
    LPTSTR tszDisplayName,
    ULONG  cchDisplayName)
{
    LPTSTR ptszToCopy;

    if (_fUseBrowseSelection)
    {
        ptszToCopy = _tszExeName;
    }
    else if (*_pSelectedLinkInfo->szLnkName)
    {
        ptszToCopy = _pSelectedLinkInfo->szLnkName;
    }
    else
    {
        ptszToCopy = _pSelectedLinkInfo->szExeName;
    }

    lstrcpyn(tszDisplayName, ptszToCopy, cchDisplayName);

    //
    // Truncate at the file extension
    //

    LPTSTR ptszExt = PathFindExtension(tszDisplayName);

    if (ptszExt)
    {
        *ptszExt = TEXT('\0');
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::GetSelectedAppIcon
//
//  Synopsis:   Retrieve the icon associated with the selected appliation.
//
//  Returns:    The selected app's small icon, or NULL if no small icon is
//              available.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HICON
CSelectProgramPage::GetSelectedAppIcon()
{
    if (_fUseBrowseSelection)
    {
        HICON hicon = NULL;
        TCHAR tszFullPath[MAX_PATH];

        GetExeFullPath(tszFullPath, ARRAYLEN(tszFullPath));
        ExtractIconEx(tszFullPath, 0, NULL, &hicon, 1);
        return hicon;
    }

    if (_idxSelectedIcon == -1)
    {
        return NULL;
    }

    HIMAGELIST hSmallImageList = ListView_GetImageList(_hwndLV, LVSIL_SMALL);

    if (!hSmallImageList)
    {
        return NULL;
    }

    return ImageList_ExtractIcon(0, hSmallImageList, _idxSelectedIcon);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_InitListView
//
//  Synopsis:   Initialize the listview's columns and image lists.
//
//  Returns:    HRESULT
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSelectProgramPage::_InitListView()
{
    HRESULT     hr = S_OK;
    HIMAGELIST  himlSmall = NULL;
    INT         cxSmall = GetSystemMetrics(SM_CXSMICON);
    INT         cySmall = GetSystemMetrics(SM_CYSMICON);
    DWORD       dwFlag = ILC_MASK;

    do
    {
        if (!_hwndLV || !cxSmall || !cySmall)
        {
            hr = E_UNEXPECTED;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        //
        // Create the listview image list.  Only the small image list is
        // required, since this listview will be restricted to report
        // mode.
        //
#ifdef UNICODE
        if (GetWindowLongPtr(_hwndLV, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
            dwFlag |= ILC_MIRROR;
        }
#endif
        himlSmall = ImageList_Create(cxSmall, cySmall, dwFlag, 1, 1);

        if (!himlSmall)
        {
            hr = HRESULT_FROM_LASTERROR;
            DEBUG_OUT_LASTERROR;
            break;
        }

        // Add the generic icon

        HICON hiconGeneric = GetDefaultAppIcon(FALSE);
        DEBUG_ASSERT(hiconGeneric);
        INT index = ImageList_AddIcon(himlSmall, hiconGeneric);
        DEBUG_ASSERT(index != -1);

        // Assign the image list to the listview

        if (!ListView_SetImageList(_hwndLV, himlSmall, LVSIL_SMALL))
        {
            himlSmall = NULL;
        }
        else
        {
            hr = HRESULT_FROM_LASTERROR;
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Create 2 listview columns.  If more are added, the column
        // width calculation needs to change.
        //

        DEBUG_ASSERT(NUM_COLUMNS == 2);

        LV_COLUMN   lvc;
        RECT        rcLV;
        TCHAR       tszColumnLabel[MAX_LVIEW_HEADER_CCH];

        VERIFY(GetClientRect(_hwndLV, &rcLV));
        rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

        ZeroMemory(&lvc, sizeof lvc);
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = (2 * rcLV.right) / 3;
        lvc.pszText = tszColumnLabel;

        int iCol;

        for (iCol = 0; iCol < NUM_COLUMNS; iCol++)
        {
            lvc.iSubItem = iCol;

            LoadStr(IDS_FIRSTCOLUMN + iCol,
                    tszColumnLabel,
                    ARRAYLEN(tszColumnLabel));

            //
            // Once the first column has been inserted, allocate the
            // remaining width to the second column.
            //

            if (iCol)
            {
                lvc.cx = rcLV.right - lvc.cx;
            }

            if (ListView_InsertColumn(_hwndLV, iCol, &lvc) == -1)
            {
                hr = HRESULT_FROM_LASTERROR;
                DEBUG_OUT_LASTERROR;
                break;
            }
        }
        BREAK_ON_FAIL_HRESULT(hr);

    } while (0);

    if (FAILED(hr))
    {
        if (himlSmall)
        {
            VERIFY(ImageList_Destroy(himlSmall));
        }

        if (_hwndLV)
        {
            EnableWindow(_hwndLV, FALSE);
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_PopulateListView
//
//  Synopsis:   Fill the listview from the shortcuts found under the start
//              menu directory.
//
//  Returns:    HRESULT
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      Searches both under the current user and the all users
//              start menu directories.  Note the walk link code ignores
//              links to certain programs, e.g. notepad.exe.  These would
//              generally not make interesting tasks.
//
//---------------------------------------------------------------------------

HRESULT
CSelectProgramPage::_PopulateListView()
{
    TRACE_METHOD(CSelectProgramPage, _PopulateListView);

    HRESULT     hr = S_OK;
    LPLINKINFO  pLinkInfo = new LINKINFO;
    HWALK      hWalk = NULL;
    ERR         errWalk;
    LV_ITEM     lvi;
    HIMAGELIST  hSmallImageList = ListView_GetImageList(_hwndLV, LVSIL_SMALL);

    ZeroMemory(&lvi, sizeof lvi);

    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;

    if (hSmallImageList)
    {
        lvi.mask |= LVIF_IMAGE;
    }

    CWaitCursor HourGlass;
    do
    {
        if (!pLinkInfo)
        {
            hr = E_OUTOFMEMORY;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        TCHAR tszAllUsersStartMenuPath[MAX_PATH];
        TCHAR tszAllUsersStartMenuPathExpanded[MAX_PATH];

#if !defined(_CHICAGO_)

        //
        // This CSIDL is valid on NT only
        //
        hr = SHGetFolderPath(NULL,
                             CSIDL_COMMON_STARTMENU,
                             NULL,
                             0,
                             tszAllUsersStartMenuPath);

        if (FAILED(hr))
        {
            DEBUG_OUT_HRESULT(hr);
            break;
        }

#else

        LoadStr(IDS_ALLUSERS_PATH,
                tszAllUsersStartMenuPath,
                ARRAYLEN(tszAllUsersStartMenuPath));

#endif  // !defined(_CHICAGO_)

        VERIFY(ExpandEnvironmentStrings(tszAllUsersStartMenuPath,
                                        tszAllUsersStartMenuPathExpanded,
                                        MAX_PATH));

        hWalk = GetFirstFileLnkInfo(pLinkInfo,
                                    INPTYPE_STARTMENU   |
                                      INPTYPE_ANYFOLDER |
                                      INPFLAG_SKIPFILES,
                                    tszAllUsersStartMenuPathExpanded,
                                    &errWalk);

        if (!hWalk || FAILED(errWalk))
        {
            DEBUG_OUT((DEB_ERROR,
                      "_PopulateListView: GetFirstFileLnkInfo %dL\n",
                      errWalk));
            hr = E_FAIL;
            break; // no links in start menu (!) or error
        }

        hr = _AddAppToListView(&lvi, hSmallImageList, pLinkInfo);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    //
    // If the first link was found, continue until no more are found
    // or an error occurs.
    //

    while (SUCCEEDED(hr))
    {
        pLinkInfo = new LINKINFO;

        if (!pLinkInfo)
        {
            hr = E_OUTOFMEMORY;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        if (GetNextFileLnkInfo(hWalk, pLinkInfo) > 0)
        {
            if (!_AppAlreadyInListView(pLinkInfo))
            {
                hr = _AddAppToListView(&lvi, hSmallImageList, pLinkInfo);
                BREAK_ON_FAIL_HRESULT(hr);
            }
            else
            {
                DEBUG_OUT((DEB_TRACE,
                           "Discarding duplicate link %S %S\n",
                           pLinkInfo->szLnkName,
                           pLinkInfo->szExeVersionInfo));
                delete pLinkInfo;
            }
        }
        else
        {
            break; // no more links or error
        }
    }

    delete pLinkInfo;
    CloseWalk(hWalk); // no-op on null

    //
    // If anything was added to the listview, make the first item focused
    // (but not selected).
    //

    if (ListView_GetItemCount(_hwndLV))
    {
        ListView_SetItemState(_hwndLV, 0, LVIS_FOCUSED, LVIS_FOCUSED);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_AppAlreadyInListView
//
//  Synopsis:   Return TRUE if a link with the same name and version info
//              as [pLinkInfo] has already been inserted in the listview.
//
//  Arguments:  [pLinkInfo] - contains link name to check
//
//  Returns:    TRUE  - same link name found
//              FALSE - same link not found, or error
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      This eliminates links that have the same name, even if they
//              point to different programs, or have different arguments.
//
//---------------------------------------------------------------------------

BOOL
CSelectProgramPage::_AppAlreadyInListView(
    LPLINKINFO pLinkInfo)
{
    LV_FINDINFO lvfi;

    lvfi.flags = LVFI_STRING;
    lvfi.psz = pLinkInfo->szLnkName;

    INT iItem = ListView_FindItem(_hwndLV, -1, &lvfi);

    if (iItem == -1)
    {
        return FALSE;
    }

    LV_ITEM lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;

    BOOL fOk = ListView_GetItem(_hwndLV, &lvi);

    if (!fOk)
    {
        DEBUG_OUT_LASTERROR;
        return FALSE;
    }

    LPLINKINFO pliInserted = (LPLINKINFO) lvi.lParam;
    DEBUG_ASSERT(pliInserted);

    return !lstrcmpi(pLinkInfo->szExeVersionInfo,
                     pliInserted->szExeVersionInfo);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_AddAppToListView
//
//  Synopsis:   Add an entry to the listview and its image list for the
//              application specified by [pLinkInfo].
//
//  Arguments:  [plvi]            - all fields valid except pszText, lParam,
//                                   and iImage.
//              [hSmallImageList] - listview's small icon imagelist
//              [pLinkInfo]       - describes app to insert info on
//
//  Returns:    HRESULT
//
//  Modifies:   pszText, lparam, and iImage fields of [plvi]; contents of
//              [hSmallImageList].
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSelectProgramPage::_AddAppToListView(
    LV_ITEM *plvi,
    HIMAGELIST hSmallImageList,
    LPLINKINFO pLinkInfo)
{
    HRESULT hr = S_OK;

    plvi->pszText = pLinkInfo->szLnkName;
    plvi->lParam = (LPARAM) pLinkInfo;

    if (hSmallImageList)
    {
        TCHAR tszExeFullPath[MAX_PATH];

        wsprintf(tszExeFullPath,
                 TEXT("%s\\%s"),
                 pLinkInfo->szExePath,
                 pLinkInfo->szExeName);
        plvi->iImage = InsertSmallIcon(hSmallImageList, tszExeFullPath);

        if (plvi->iImage == -1)
        {
            plvi->iImage = 0;
        }
    }

    INT iIndex = ListView_InsertItem(_hwndLV, plvi);

    if (iIndex == -1)
    {
        hr = E_FAIL;
        DEBUG_OUT_LASTERROR;
        return hr;
    }

    ListView_SetItemText(_hwndLV,
                         iIndex,
                         COL_VERSION,
                         pLinkInfo->szExeVersionInfo);
    plvi->iItem++;

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   InsertSmallIcon
//
//  Synopsis:   Extract the small icon from [tszExeName] and add it to
//              [hSmallImageList].
//
//  Arguments:  [hSmallImageList] - handle to small icon imagelist
//              [tszExeName]      - full path to executable
//
//  Returns:    Index of new entry or -1 if [tszExeName] doesn't have a
//              small icon or an error occurred.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT
InsertSmallIcon(
    HIMAGELIST  hSmallImageList,
    LPCTSTR     tszExeName)
{
    HICON   hSmallIcon = NULL;
    UINT    uiResult;

    uiResult = ExtractIconEx(tszExeName, 0, NULL, &hSmallIcon, 1);

    if (!hSmallIcon)
    {
        DEBUG_OUT((DEB_IWARN, "Can't find icon for app '%s'\n", tszExeName));
    }

    if (uiResult)
    {
        INT retVal;

        DEBUG_ASSERT(hSmallIcon);
        retVal = ImageList_AddIcon(hSmallImageList, hSmallIcon);

        if( hSmallIcon && !DestroyIcon( hSmallIcon ) )
        {
           CHECK_LASTERROR(GetLastError());
        }
        return retVal;
    }

    CHECK_LASTERROR(GetLastError());
    return -1;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::GetExeName
//
//  Synopsis:   Fill [tszBuf] with the name of the executable selected by
//              the user.
//
//  Arguments:  [tszBuf] - buffer to receive name
//              [cchBuf] - size, in characters, of buffer
//
//  Modifies:   *[tszBuf]
//
//  History:    10-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectProgramPage::GetExeName(
   LPTSTR tszBuf,
   ULONG cchBuf)
{
    LPTSTR ptszExeName;

    if (_fUseBrowseSelection)
    {
        ptszExeName  = _tszExeName;
    }
    else
    {
        ptszExeName  = _pSelectedLinkInfo->szExeName;
    }

    lstrcpyn(tszBuf, ptszExeName, cchBuf);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::GetExeFullPath
//
//  Synopsis:   Fill [tszBuf] with the full path to the executable selected
//              by the user.
//
//  Arguments:  [tszBuf] - buffer to receive path
//              [cchBuf] - size, in characters, of buffer
//
//  Modifies:   *[tszBuf]
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSelectProgramPage::GetExeFullPath(
    LPTSTR tszBuf,
    ULONG cchBuf)
{
    LPTSTR ptszExePath;
    LPTSTR ptszExeName;

    if (_fUseBrowseSelection)
    {
        ptszExePath = _tszExePath;
        ptszExeName  = _tszExeName;
    }
    else
    {
        ptszExePath = _pSelectedLinkInfo->szExePath;
        ptszExeName  = _pSelectedLinkInfo->szExeName;
    }

    ULONG cchRequired = lstrlen(ptszExePath) +
                        1 + // backslash
                        lstrlen(ptszExeName) +
                        1;  // terminating null

    if (cchRequired > cchBuf)
    {
        lstrcpyn(tszBuf, ptszExeName, cchBuf);
    }
    else
    {
        lstrcpy(tszBuf, ptszExePath);
        lstrcat(tszBuf, TEXT("\\"));
        lstrcat(tszBuf, ptszExeName);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSelectProgramPage::_OnBrowse
//
//  Synopsis:   Allow the user to set the task's application via a common
//              file open dialog.
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      If successful, advances to the next page.
//
//---------------------------------------------------------------------------

VOID
CSelectProgramPage::_OnBrowse()
{
    TRACE_METHOD(CSelectProgramPage, _OnBrowse);

    TCHAR tszDefExt[5];
    TCHAR tszFilter[MAX_PATH];
    TCHAR tszTitle[100];

    DWORD dwFlags = OFN_HIDEREADONLY    |
                    OFN_FILEMUSTEXIST   |
                    OFN_NOCHANGEDIR     |
                    OFN_NONETWORKBUTTON |
                    OFN_PATHMUSTEXIST;

    LoadStr(IDS_EXE, tszDefExt, ARRAYLEN(tszDefExt));
    LoadStr(IDS_WIZARD_BROWSE_CAPTION, tszTitle, ARRAYLEN(tszTitle));

    ZeroMemory(tszFilter, ARRAYLEN(tszFilter));

    LoadStr(IDS_WIZARD_FILTER, tszFilter, ARRAYLEN(tszFilter));

    OPENFILENAME ofn;
    ZeroMemory(&ofn, sizeof(ofn));

    _tszExeName[0] = TEXT('\0');
    _tszExePath[0] = TEXT('\0');

    // Set up info for common file open dialog.
    ofn.lStructSize       = CDSIZEOF_STRUCT(OPENFILENAME, lpTemplateName);
    ofn.hwndOwner         = Hwnd();
    ofn.lpstrFilter       = tszFilter;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = _tszExePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = _tszExeName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrInitialDir   = TEXT("\\");
    ofn.lpstrTitle        = tszTitle;
    ofn.Flags             = dwFlags;
    ofn.lpstrDefExt       = tszDefExt;

    //
    // Invoke the dialog.  If the user makes a selection and hits OK, record
    // the name selected and go on to the trigger selection page.
    //

    if (GetOpenFileName(&ofn))
    {
        PathRemoveFileSpec(_tszExePath);

        LPTSTR ptszLastSlash = _tcsrchr(_tszExePath, TEXT('\\'));

        if (ptszLastSlash && lstrlen(ptszLastSlash) == 1)
        {
            *ptszLastSlash = TEXT('\0');
        }
        _fUseBrowseSelection = TRUE;
        PropSheet_PressButton(GetParent(Hwnd()), PSBTN_NEXT);
    }
    else
    {
        // user hit cancel or an error occurred

        if (CommDlgExtendedError())
        {
            DEBUG_OUT((DEB_ERROR,
                       "GetOpenFileName failed<0x%x>\n",
                       CommDlgExtendedError()));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\taskwiz.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       taskwiz.cxx
//
//  Contents:   Class which creates and invokes the 'create new task' wizard.
//
//  Classes:    CTaskWizard
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"
#include "..\folderui\jobidl.hxx"

//
// Types
//
// SFindWiz - passed to window enumeration function. BUGBUG when wizard
//  on remote machine is supported, the 'tszFocus' member should be the
//  server name.  For now, it is just the path to the tasks folder.
//

struct SFindWiz
{
    BOOL    fFound;
    LPCTSTR tszFocus;
};

//
// Globals
//
// g_msgFindWizard - private window message used to interrogate the wizard
//  dialog proc during the find operation.
//
// TEMPLATE_STR - string used to create private message, also used by
//  folderui code to identify the template icon.
//

UINT g_msgFindWizard;
extern const TCHAR TEMPLATE_STR[];

//
// External references
//

extern HRESULT
QuietStartContinueService(); // ..\folderui\schstate.cxx

extern HRESULT
JFGetDataObject(
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidlFolder,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    BOOL            fCut,
    LPVOID        * ppvObj);

extern HRESULT
DisplayJobProperties(
    LPDATAOBJECT    pdtobj);


//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::CTaskWizard
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - path to tasks folder
//
//  History:    5-12-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CTaskWizard::CTaskWizard(
    LPCTSTR         ptszFolderPath,
    LPITEMIDLIST    pidlFolder)
{
    TRACE_CONSTRUCTOR(CTaskWizard);

    ZeroMemory(_apWizPages, sizeof _apWizPages);
    _fAdvanced = FALSE;
    _tszJobObjectFullPath[0] = TEXT('\0');
    _pTask = NULL;
    lstrcpyn(_tszFolderPath, ptszFolderPath, ARRAYLEN(_tszFolderPath));
    _pidlFolder = pidlFolder;
#ifdef WIZARD97
    _fUse256ColorBmp = Is256ColorSupported();
#endif // WIZARD97
}




//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::~CTaskWizard
//
//  Synopsis:   dtor
//
//  History:    5-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CTaskWizard::~CTaskWizard()
{
    TRACE_DESTRUCTOR(CTaskWizard);

    if (_pTask)
    {
        _pTask->Release();
    }

    ILFree(_pidlFolder);
}




//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::Launch, static
//
//  Synopsis:   Run the task wizard in a separate thread.
//
//  Arguments:  [ptszFolderPath] - path to tasks folder.
//
//  Returns:    HRESULT
//
//  History:    5-19-1997   DavidMun   Created
//
//  Notes:      If an instance of the wizard is already running for the
//              target machine, makes that the foreground window and
//              returns.
//
//---------------------------------------------------------------------------

HRESULT
CTaskWizard::Launch(
    LPCTSTR ptszFolderPath,
    LPCITEMIDLIST   pidlFolder)
{
    TRACE_FUNCTION(CTaskWizard::Launch);

    HRESULT      hr = S_OK;
    CTaskWizard *pNewWiz = NULL;

    do
    {
        //
        // Start the service if it isn't running, or continue it if it is
        // paused.  Since this is the wizard, do it on behalf of the user
        // without asking first.
        //
        // Continue on failure, since it is better to let the user at least
        // create the task, even if the service can't be started (user might
        // not have permission).
        //

        hr = QuietStartContinueService();
        CHECK_HRESULT(hr);

        //
        // Create a path string that CPropPage will store.  This is the
        // full path to the tasks folder, with a trailing backslash.  The
        // CPropPage will truncate at the last backslash, since most other
        // callers give it a task filename.
        //

        ULONG cchPath = lstrlen(ptszFolderPath);

        if (cchPath >= MAX_PATH - 1) // reserve space for trailing backslash
        {
            hr = E_INVALIDARG;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        TCHAR tszFolderPath[MAX_PATH + 1];

        lstrcpy(tszFolderPath, ptszFolderPath);
        tszFolderPath[cchPath] = TEXT('\\');
        tszFolderPath[cchPath + 1] = TEXT('\0');

        //
        // Look for an instance of the wizard running and focused on our
        // folder path.  If one is found, it will make itself foreground
        // window, and we can quit.
        //

        hr = _FindWizard(tszFolderPath);

        if (hr == S_OK)
        {
            break;
        }

        //
        // No wizard is up for the current focus.  Create a wizard object
        // and run it in a new thread.
        //

        LPITEMIDLIST pidlFolderCopy = ILClone(pidlFolder);

        if (!pidlFolderCopy)
        {
            hr = E_OUTOFMEMORY;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        pNewWiz = new CTaskWizard(tszFolderPath, pidlFolderCopy);

        if (!pNewWiz)
        {
            ILFree(pidlFolderCopy);
            hr = E_OUTOFMEMORY;
            DEBUG_OUT_HRESULT(hr);
            break;
        }

        HANDLE  hThread;
        DWORD   idThread;

        hThread = CreateThread(NULL,
                               0,
                               _WizardThreadProc,
                               (LPVOID) pNewWiz,
                               0,
                               &idThread);

        if (!hThread)
        {
            delete pNewWiz;
            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_LASTERROR;
            break;
        }

        VERIFY(CloseHandle(hThread));
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::_WizardThreadProc, static
//
//  Synopsis:   Displays the wizard (and optionally task property sheet)
//              using a separate thread.
//
//  Arguments:  [pvThis] - CTaskWizard pointer
//
//  Returns:    HRESULT
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      The wizard runs in a separate thread so the explorer ui
//              isn't stalled.
//
//---------------------------------------------------------------------------

DWORD WINAPI
CTaskWizard::_WizardThreadProc(
    LPVOID pvThis)
{
    HRESULT hr = OleInitialize(NULL);

    if (FAILED(hr))
    {
        DEBUG_OUT_HRESULT(hr);
        return hr;
    }

    CTaskWizard *pThis = (CTaskWizard *)pvThis;

    __try
    {
        hr = pThis->_DoWizard();

        //
        // Once _DoWizard returns, the wizard property sheet has closed.
        //
        // If the user elected to see the new task's property sheet, then
        // _fAdvanced will be set, and the completion page should have
        // set a valid filename and interface pointer for the task.
        //
        // Open the property sheet while we're still in the thread.
        //

        if (SUCCEEDED(hr) && pThis->_fAdvanced)
        {
            DEBUG_ASSERT(pThis->_pTask);
            DEBUG_ASSERT(*pThis->_tszJobObjectFullPath);

            //
            // Since we want to see the security page if the object is on NT
            // on an NTFS partition, we'll have to call the version of
            // DisplayJobProperties that takes a data object.
            //
            // To get a data object describing the task object, we need an
            // itemid for the job, so create one.
            //

            CJobID jid;

            jid.LoadDummy(pThis->_tszJobObjectFullPath);
            LPCITEMIDLIST pidl = (LPCITEMIDLIST) &jid;

            LPDATAOBJECT pdo = NULL;
            TCHAR tszFolderPath[MAX_PATH + 1];

            lstrcpy(tszFolderPath, pThis->_tszFolderPath);
            LPTSTR ptszLastSlash = _tcsrchr(tszFolderPath, TEXT('\\'));

            if (ptszLastSlash && lstrlen(ptszLastSlash) == 1)
            {
                *ptszLastSlash = TEXT('\0');
            }

            hr = JFGetDataObject(tszFolderPath,    // path to tasks dir
                                 pThis->_pidlFolder, // itemid of tasks folder
                                 1,                // one itemid in array
                                 &pidl,            // namely, this one
                                 FALSE,            // not doing cut/paste
                                 (VOID **) &pdo);

            if (SUCCEEDED(hr))
            {
                hr = DisplayJobProperties(pdo);
                CHECK_HRESULT(hr);
            }
            else
            {
                DEBUG_OUT_HRESULT(hr);
            }
        }

        delete pThis;
    }
    __finally
    {
        OleUninitialize();
    }

    return (DWORD) hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::_DoWizard
//
//  Synopsis:   Create the wizard pages and invoke the wizard.
//
//  Returns:    HRESULT
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      If wizard is successfully created, doesn't return until
//              user hits Cancel or Finish.
//
//---------------------------------------------------------------------------

HRESULT
CTaskWizard::_DoWizard()
{
    TRACE_METHOD(CTaskWizard, _DoWizard);

    HRESULT         hr = S_OK;
    UINT            i = 0;
    HPROPSHEETPAGE  ahpsp[NUM_TASK_WIZARD_PAGES];

    ZeroMemory(ahpsp, sizeof(ahpsp));

    do
    {
        //
        // Create all the wizard pages
        //

        _apWizPages[TWP_WELCOME       ] = new CWelcomePage      (this, _tszFolderPath, &ahpsp[TWP_WELCOME       ]);
        _apWizPages[TWP_SELECT_PROGRAM] = new CSelectProgramPage(this, _tszFolderPath, &ahpsp[TWP_SELECT_PROGRAM]);
        _apWizPages[TWP_SELECT_TRIGGER] = new CSelectTriggerPage(this, _tszFolderPath, &ahpsp[TWP_SELECT_TRIGGER]);
        _apWizPages[TWP_DAILY         ] = new CDailyPage        (this, _tszFolderPath, &ahpsp[TWP_DAILY         ]);
        _apWizPages[TWP_WEEKLY        ] = new CWeeklyPage       (this, _tszFolderPath, &ahpsp[TWP_WEEKLY        ]);
        _apWizPages[TWP_MONTHLY       ] = new CMonthlyPage      (this, _tszFolderPath, &ahpsp[TWP_MONTHLY       ]);
        _apWizPages[TWP_ONCE          ] = new COncePage         (this, _tszFolderPath, &ahpsp[TWP_ONCE          ]);
#if !defined(_CHICAGO_)
        _apWizPages[TWP_PASSWORD      ] = new CPasswordPage     (this, _tszFolderPath, &ahpsp[TWP_PASSWORD      ]);
#endif // !defined(_CHICAGO_)
        _apWizPages[TWP_COMPLETION    ] = new CCompletionPage   (this, _tszFolderPath, &ahpsp[TWP_COMPLETION    ]);

        //
        // Check that all objects and pages could be created
        //

        for (i = 0; i < NUM_TASK_WIZARD_PAGES; i++)
        {
            if (!_apWizPages[i] || !ahpsp[i])
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        //
        // Manually destroy the pages if one could not be created, then exit
        //

        if (FAILED(hr))
        {
            DEBUG_OUT((DEB_ERROR, "Creation failed, destroying pages\n"));

            for (i = 0; i < NUM_TASK_WIZARD_PAGES; i++)
            {
                if (ahpsp[i])
                {
                    VERIFY(DestroyPropertySheetPage(ahpsp[i]));
                }
                else if (_apWizPages[i])
                {
                    delete _apWizPages[i];
                }
            }
            break;
        }

        //
        // All pages created, display the wizard
        //

        PROPSHEETHEADER psh;

        ZeroMemory(&psh, sizeof(psh));

#ifdef WIZARD97
        psh.dwFlags             = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
        psh.pszbmWatermark      = _fUse256ColorBmp ? MAKEINTRESOURCE(IDB_WATERMARK256)   : MAKEINTRESOURCE(IDB_WATERMARK16);
        psh.pszbmHeader         = _fUse256ColorBmp ? MAKEINTRESOURCE(IDB_BANNER256)      : MAKEINTRESOURCE(IDB_BANNER16);
#else
        psh.dwFlags             = PSH_WIZARD;
#endif // WIZARD97
        psh.dwSize              = sizeof(psh);
        psh.hInstance           = g_hInstance;
        psh.hwndParent          = NULL;
        psh.pszCaption          = NULL; // ignored for wizards; see CWelcome init
        psh.phpage              = ahpsp;
        psh.nStartPage          = 0;
        psh.nPages              = NUM_TASK_WIZARD_PAGES;

        if (PropertySheet(&psh) == -1)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_HRESULT(hr);
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   FindWizardEnumWndProc
//
//  Synopsis:   EnumWindows callback used to search for a create new task
//              wizard opened on the specified focus.
//
//  Arguments:  [hwnd]   - top level window handle
//              [lParam] - pointer to SFindWiz struct
//
//  Returns:    TRUE - not found, continue enumeration
//              FALSE - found wizard, quit enumerating
//
//  Modifies:   SFindWiz struct pointed to by [lParam]
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL CALLBACK
FindWizardEnumWndProc(
    HWND hwnd,
    LPARAM lParam)
{
    SFindWiz *pfw = (SFindWiz *) lParam;
    ULONG     pid;

    GetWindowThreadProcessId(hwnd, &pid);

    do
    {
        //
        // If the window isn't in this process (explorer.exe) then ignore
        // it.
        //

        if (pid != GetCurrentProcessId())
        {
            break;
        }

        //
        // If it isn't the dialog class, it can't be a wizard.
        //

        if (!IsDialogClass(hwnd))
        {
            break;
        }

        //
        // Found a dialog window that was created by this process.  If it's
        // a wizard, then it should return a valid window which is also of
        // dialog class.
        //

        HWND hwndPage = PropSheet_GetCurrentPageHwnd(hwnd);

        if (!IsWindow(hwndPage) || !IsDialogClass(hwndPage))
        {
            break;
        }

        //
        // Could be a wizard page.  Ask it if it's THE wizard for the
        // focus.  Note it's only possible to get away with sending a pointer
        // in the message because we've guaranteed the window belongs to this
        // process.
        //

        ULONG ulResult = (ULONG)SendMessage(hwndPage,
                                            g_msgFindWizard,
                                            0,
                                            (LPARAM) pfw->tszFocus);

        if (ulResult == g_msgFindWizard)
        {
            pfw->fFound = TRUE;
        }
    } while (0);

    return !pfw->fFound; // continue enumerating if not found
}




//+--------------------------------------------------------------------------
//
//  Member:     CTaskWizard::_FindWizard
//
//  Synopsis:   Search through top level windows to find a create new task
//              wizard which is focused on [ptszFolderPath].
//
//  Arguments:  [ptszFolderPath] - wizard focus
//
//  Returns:    S_OK    - found
//              S_FALSE - not found
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      BUGBUG change ptszFolderPath to server name
//
//---------------------------------------------------------------------------

HRESULT
CTaskWizard::_FindWizard(
    LPCTSTR ptszFolderPath)
{
    SFindWiz    fw = { FALSE, ptszFolderPath };

    if (!g_msgFindWizard)
    {
        g_msgFindWizard = RegisterWindowMessage(TEMPLATE_STR);
    }

    EnumWindows(FindWizardEnumWndProc, (LPARAM) &fw);

    return fw.fFound ? S_OK : S_FALSE;
}




#if (DBG == 1 && defined(_CHICAGO_))

//+--------------------------------------------------------------------------
//
//  Function:   DebugMessageBox
//
//  Synopsis:   Display a message box for debugging output.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
DebugMessageBox(ULONG flLevel, LPTSTR ptszFormat, ...)
{
    va_list args;

    va_start(args, ptszFormat);
    if (flLevel & JobInfoLevel)
    {
        TCHAR   tszBuf[SCH_XBIGBUF_LEN];

        wvsprintf(tszBuf, ptszFormat, args);
        MessageBox(NULL, tszBuf, TEXT("Debug"), MB_OK);
    }
    va_end(args);
}

#endif // (DBG == 1 && defined(_CHICAGO_))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\trigpage.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       trigpage.cxx
//
//  Contents:   Implementation of common trigger page class
//
//  Classes:    CTriggerPage
//
//  History:    5-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"




//+--------------------------------------------------------------------------
//
//  Member:     CTriggerPage::CTriggerPage
//
//  Synopsis:   ctor
//
//  Arguments:  [iddPage]        - resource id of trigger page dialog
//              [idsHeader2]     - resource id of sub-title string
//              [ptszFolderPath] - tasks folder path
//              [phPSP]          - filled with handle returned by
//                                  CreatePropertySheetPage
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CTriggerPage::CTriggerPage(
    ULONG iddPage,
    ULONG idsHeader2,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CWizPage(MAKEINTRESOURCE(iddPage), ptszFolderPath)
{
    _CreatePage(IDS_TRIGGER_HDR1, idsHeader2, phPSP);
}



//+--------------------------------------------------------------------------
//
//  Member:     CTriggerPage::_UpdateTimeFormat
//
//  Synopsis:   Update the start time datetimepicker control's time format
//
//  History:    07-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CTriggerPage::_UpdateTimeFormat()
{
    ::UpdateTimeFormat(_tszTimeFormat, ARRAYLEN(_tszTimeFormat));
    DateTime_SetFormat(_hCtrl(starttime_dp), _tszTimeFormat);
}




//===========================================================================
//
// CPropPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CTriggerPage::_OnWinIniChange
//
//  Synopsis:   Handle win.ini settings change
//
//  History:    07-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CTriggerPage::_OnWinIniChange(
    WPARAM wParam,
    LPARAM lParam)
{
    _UpdateTimeFormat();
    return FALSE;
}




//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CTriggerPage::_OnWizBack
//
//  Synopsis:   Set the current page to the select trigger page.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CTriggerPage::_OnWizBack()
{
    TRACE_METHOD(CTriggerPage, _OnWizBack);

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, IDD_SELECT_TRIGGER);
    return -1;
}




//+--------------------------------------------------------------------------
//
//  Member:     CTriggerPage::_OnWizNext
//
//  Synopsis:   Advance to the next page: for NT, the security page.  For
//              Win9x, the completion page.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CTriggerPage::_OnWizNext()
{
    TRACE_METHOD(CTriggerPage, _OnWizNext);

#ifdef _CHICAGO_
    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, IDD_COMPLETION);
#else
    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, IDD_PASSWORD);
#endif // _CHICAGO_

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\util.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       util.cxx
//
//  Contents:   Utility functions
//
//  History:    4-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"



//+--------------------------------------------------------------------------
//
//  Function:   IsDialogClass
//
//  Synopsis:   Return TRUE if [hwnd]'s window class is the dialog class.
//
//  History:    5-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsDialogClass(
    HWND hwnd)
{
    TCHAR tszClassName[20]; // looking for "#32770"

    if (!GetClassName(hwnd, tszClassName, ARRAYLEN(tszClassName)))
    {
        DEBUG_OUT_LASTERROR;
        tszClassName[0] = TEXT('\0');
    }

    return 0 == _tcscmp(tszClassName, TEXT("#32770"));
}



//+--------------------------------------------------------------------------
//
//  Function:   LoadStr
//
//  Synopsis:   Load string with resource id [ids] into buffer [tszBuf],
//              which is of size [cchBuf] characters.
//
//  Arguments:  [ids]        - string to load
//              [tszBuf]     - buffer for string
//              [cchBuf]     - size of buffer
//              [tszDefault] - NULL or string to use if load fails
//
//  Returns:    S_OK or error from LoadString
//
//  Modifies:   *[tszBuf]
//
//  History:    12-11-1996   DavidMun   Created
//
//  Notes:      If the load fails and no default is supplied, [tszBuf] is
//              set to an empty string.
//
//---------------------------------------------------------------------------

HRESULT
LoadStr(
    ULONG ids,
    LPTSTR tszBuf,
    ULONG cchBuf,
    LPCTSTR tszDefault)
{
    HRESULT hr = S_OK;
    ULONG cchLoaded;

    cchLoaded = LoadString(g_hInstance, ids, tszBuf, cchBuf);

    if (!cchLoaded)
    {
        DEBUG_OUT_LASTERROR;
        hr = HRESULT_FROM_LASTERROR;

        if (tszDefault)
        {
            lstrcpyn(tszBuf, tszDefault, cchBuf);
        }
        else
        {
            *tszBuf = TEXT('\0');
        }
    }
    return hr;
}




#ifdef WIZARD97

//+--------------------------------------------------------------------------
//
//  Function:   Is256ColorSupported
//
//  Synopsis:   Return TRUE if this machine supports 256 color bitmaps
//
//  History:    5-20-1997   DavidMun   Stolen from wizard97 sample code
//
//---------------------------------------------------------------------------

BOOL
Is256ColorSupported()
{
    BOOL bRetval = FALSE;

    HDC hdc = GetDC(NULL);

    if (hdc)
    {
        if (GetDeviceCaps(hdc, BITSPIXEL) >= 8)
        {
            bRetval = TRUE;
        }
        ReleaseDC(NULL, hdc);
    }
    return bRetval;
}

#endif // WIZARD97




//+--------------------------------------------------------------------------
//
//  Function:   FillInStartDateTime
//
//  Synopsis:   Fill [pTrigger]'s starting date and time values from the
//              values in the date/time picker controls.
//
//  Arguments:  [hwndDatePick] - handle to control with start date
//              [hwndTimePick] - handle to control with start time
//              [pTrigger]     - trigger to init
//
//  Modifies:   *[pTrigger]
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
FillInStartDateTime(
    HWND hwndDatePick,
    HWND hwndTimePick,
    TASK_TRIGGER *pTrigger)
{
    SYSTEMTIME st;

    DateTime_GetSystemtime(hwndDatePick, &st);

    pTrigger->wBeginYear  = st.wYear;
    pTrigger->wBeginMonth = st.wMonth;
    pTrigger->wBeginDay   = st.wDay;

    DateTime_GetSystemtime(hwndTimePick, &st);

    pTrigger->wStartHour   = st.wHour;
    pTrigger->wStartMinute = st.wMinute;
}



#ifdef WIZARD95

//+--------------------------------------------------------------------------
//
//  Function:   CreateDIBPalette
//
//  Synopsis:   Create palette based on bitmap info
//
//  Arguments:  [lpbmi]        - bitmap info
//              [lpiNumColors] - number of colors in palette
//
//  Returns:    handle to created palette, or NULL on error
//
//  History:    5-22-1997   DavidMun   Taken directly from sdk sample
//
//  Notes:      Caller must DeleteObject returned palette.
//
//---------------------------------------------------------------------------

HPALETTE
CreateDIBPalette(
    LPBITMAPINFO lpbmi,
    LPINT lpiNumColors)
{
    LPBITMAPINFOHEADER  lpbi;
    LPLOGPALETTE     lpPal;
    HANDLE           hLogPal;
    HPALETTE         hPal = NULL;
    int              i;

    lpbi = (LPBITMAPINFOHEADER)lpbmi;
    if (lpbi->biBitCount <= 8)
    {
        *lpiNumColors = (1 << lpbi->biBitCount);
    }
    else
    {
        DEBUG_OUT((DEB_ITRACE, "no palette needed\n"));
        *lpiNumColors = 0;  // No palette needed for 24 BPP DIB
    }

    if (*lpiNumColors)
    {
        hLogPal = GlobalAlloc(GHND,
                              sizeof (LOGPALETTE) + sizeof (PALETTEENTRY)
                                   * (*lpiNumColors));

        if (!hLogPal)
        {
            DEBUG_OUT_HRESULT(E_OUTOFMEMORY);
            return NULL;
        }

        lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
        lpPal->palVersion    = 0x300;
        lpPal->palNumEntries = (WORD)*lpiNumColors;

        for (i = 0;  i < *lpiNumColors;  i++)
        {
            lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
            lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
            lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
            lpPal->palPalEntry[i].peFlags = 0;
        }

        hPal = CreatePalette (lpPal);

        if (!hPal)
        {
            DEBUG_OUT_LASTERROR;
        }
        GlobalUnlock (hLogPal);
        GlobalFree   (hLogPal);
    }

    return hPal;
}





//+--------------------------------------------------------------------------
//
//  Function:   LoadResourceBitmap
//
//  Synopsis:   Load the bitmap with resource id [idBitmap] and put its
//              palette in *[phPalette].
//
//  Arguments:  [idBitmap]  - resource id of bitmap to load
//              [phPalette] - filled with bitmap's palette
//
//  Returns:    Device dependent bitmap with palette mapped to system's,
//              or NULL on error.
//
//  Modifies:   *[phPalette]
//
//  History:    5-22-1997   DavidMun   Created from sdk sample
//
//  Notes:      Caller must DeleteObject returned bitmap and palette. On
//              error, *[phPalette] is NULL.
//
//---------------------------------------------------------------------------

HBITMAP
LoadResourceBitmap(
    ULONG      idBitmap,
    HPALETTE  *phPalette)
{
    TRACE_FUNCTION(LoadResourceBitmap);

    HRESULT hr = E_FAIL;
    HBITMAP hBitmapFinal = NULL;
    HDC hdc = NULL;

    //
    // Init out pointer for failure case
    //

    *phPalette = NULL;

    do
    {
        HRSRC hRsrc = FindResource(g_hInstance,
                                   MAKEINTRESOURCE(idBitmap),
                                   RT_BITMAP);
        if (!hRsrc)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Load the resource; note win32 will automatically unload it
        //

        HGLOBAL hGlobal = LoadResource(g_hInstance, hRsrc);

        if (!hGlobal)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Convert the loaded handle into a bitmap handle.  Again, win32
        // will automatically unlock this resource.
        //

        LPBITMAPINFOHEADER pbih = (LPBITMAPINFOHEADER) LockResource(hGlobal);

        if (!pbih)
        {
            DEBUG_OUT_LASTERRO