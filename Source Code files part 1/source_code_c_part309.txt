       EOAC_NONE,
                                 0 );
	    if ( hr == S_OK ) {
      
         if ( DialogBox(hInstance,
                        MAKEINTRESOURCE(IDD_MAIN), 
                        NULL,
                        MainDlgProc) == -1 ) {
            PrintError( HRESULT_FROM_WIN32(GetLastError()),
                      __LINE__,
                      TEXT(__FILE__),
                      TEXT("Failed to create the dialog box, ")
                      TEXT("program exiting...") );
        }
     }
     else {
        PrintError( hr,
                  __LINE__,
                  TEXT(__FILE__),
                  TEXT("CoInitializeSecurity failed, program exiting...") );
     }

     CoUninitialize();
  }

  return 0;
}

//
// Windows procedure for the main dialog box.
//

INT_PTR CALLBACK MainDlgProc (HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam)
{
  IWbemServices *pIWbemServices;
  LPNMTREEVIEW  lpnmTreeView;


  switch (uMsg) {

     case WM_INITDIALOG:


             //
             // Connect to the default namespace.
             //

             pIWbemServices = ConnectToNamespace();

             if ( !pIWbemServices ) {

                EndDialog( hwndDlg, 0 );
             }

             //
             // At DWLP_USER offset, we store pIWbemServices so we can
             // get to it later.
             //

             SetWindowLongPtr(
                      hwndDlg,
                      DWLP_USER,
                      (LONG_PTR)pIWbemServices );
             //
             // Enumerate default classes and its instances. Also,
             // show properties of the first instance.
             //

             ListDefaults( hwndDlg );

             return TRUE; // Tell Windows to continue creating the dialog box.

     case WM_COMMAND:

          switch( LOWORD(wParam) ) {

             case IDL_CLASSES:
                  if ( HIWORD(wParam) == LBN_SELCHANGE ) {

                     //
                     // User selected a class. Show its instances and
                     // the properties of the first instance.
                     //

                     RefreshOnClassSelection( hwndDlg );
                  }
                  
                  break;
          }

          break;

     case WM_NOTIFY:

          switch( wParam ) {

             case IDT_INSTANCES:

                lpnmTreeView = (LPNMTREEVIEW)lParam;

                if ( (lpnmTreeView->hdr.code == TVN_SELCHANGED) &&
                     (lpnmTreeView->action != TVC_UNKNOWN) ) {

                   //
                   // User has clicked on an instance, list its properties.
                   //     

                   ShowProperties( hwndDlg,
                                   lpnmTreeView->hdr.hwndFrom );

                }
                break;

             case IDT_PROPERTIES:

                lpnmTreeView = (LPNMTREEVIEW)lParam;

                if ( lpnmTreeView->hdr.code == NM_DBLCLK ) {

                   //
                   // User has double-clicked on a property.
                   //     

                   EditProperty( hwndDlg,
                                 lpnmTreeView->hdr.hwndFrom );
                }

                break;
             }

             break;

     case WM_SYSCOMMAND:

             //
             // Before exiting...
             //    .Make sure to disconnect from the namespace.
             //

             if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                 pIWbemServices = (IWbemServices *)GetWindowLongPtr(
                                                          hwndDlg,
                                                          DWLP_USER );
                pIWbemServices->Release();

                EndDialog( hwndDlg, 0 );
             }
  }

  return FALSE;
}

//
// Windows procedure to view/modify scalar properties.
//

INT_PTR CALLBACK DlgProcScalar (HWND hwndDlg,
                                UINT uMsg,
                                WPARAM wParam,
                                LPARAM lParam)
{
  LPPROPERTY_INFO  pPropInfo;
  VARIANT          vaTemp;
  LPTSTR           lpszValue;
  HRESULT          hr;

  switch (uMsg) {

     case WM_INITDIALOG:

          //
          // lParam points to PROPERTY_INFO structure which contains information
          // the property whose valuse is to be viewed/modified. We store this
          // pointer at DWLP_USER offset, so we get to it later.
          //

          SetWindowLongPtr( hwndDlg,
                            DWLP_USER,
                            (LONG_PTR)lParam );

          pPropInfo = (LPPROPERTY_INFO)lParam;

          //
          // Property name is the title of the dialog box.
          //

          SetWindowText( hwndDlg,
                         pPropInfo->lpszProperty );

          //
          // Show the property type.
          //

          if ( pPropInfo->lpszType ) {
             SetWindowText( GetDlgItem(hwndDlg,
                                       IDS_PROPERTY_TYPE),
                            pPropInfo->lpszType );
          }

          //
          // Change the property value to a string so it can be displayed
          // if the property has a value.
          //

          if ( (V_VT(pPropInfo->pvaValue) != VT_NULL) &&
               (V_VT(pPropInfo->pvaValue) != VT_EMPTY) ) {

             VariantInit( &vaTemp );

             hr = VariantChangeType( &vaTemp,
                                     pPropInfo->pvaValue,
                                     VARIANT_LOCALBOOL,
                                     VT_BSTR );

             if ( hr != S_OK ) {

                PrintError( hr,
                            __LINE__,
                            TEXT(__FILE__),
                            TEXT("Couldn't format the value of %s into ")
                            TEXT("displayable text. The value cannot be ")
                            TEXT(" viewed/modified."),
                            pPropInfo->lpszProperty );

                EndDialog( hwndDlg, 0 );
             }

             lpszValue = BstrToString( V_BSTR(&vaTemp),
                                       -1 );

             if ( lpszValue ) {
                SetWindowText( GetDlgItem(hwndDlg,
                                          IDE_PROPERTY_VALUE),
                               lpszValue );

                SysFreeString( (BSTR)((PVOID)lpszValue));
             }
             else {
                PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                            __LINE__,
                            TEXT(__FILE__),
                            TEXT("Cannot show the value of %s."),
                            pPropInfo->lpszProperty );

                EndDialog( hwndDlg, 0 );
             }
             
             VariantClear( &vaTemp );
          }

          return TRUE; // Tell Windows to continue creating the dialog box.

     case WM_COMMAND:

          switch( LOWORD(wParam) ) {

             case IDB_MODIFY:
                  
                  if ( HIWORD(wParam) == BN_CLICKED ) {

                     //
                     // User wants to update the instance after modifying the
                     // property value.
                     //

                     if ( ModifyProperty(hwndDlg) ) {

                        EndDialog( hwndDlg, 0 );
                     }
                  }

                  break;

             case IDB_CANCEL:
                  
                  if ( HIWORD(wParam) == BN_CLICKED ) {

                     EndDialog( hwndDlg, 0 );
                  }

                  break;
          }

          break;

     case WM_SYSCOMMAND:

             if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                EndDialog( hwndDlg, 0 );
             }
  }

  return FALSE;
}

//
// Windows procedure to view/modify array properties.
//

INT_PTR CALLBACK DlgProcArray (HWND hwndDlg,
                               UINT uMsg,
                               WPARAM wParam,
                               LPARAM lParam)
{
  LPPROPERTY_INFO  pPropInfo;

  switch (uMsg) {

     case WM_INITDIALOG:

          //
          // lParam points to PROPERTY_INFO structure which contains information
          // the property whose valuse is to be viewed/modified. We store this
          // pointer at DWLP_USER offset, so we get to it later.
          //

          SetWindowLongPtr( hwndDlg,
                            DWLP_USER,
                            (LONG_PTR)lParam );

          pPropInfo = (LPPROPERTY_INFO)lParam;

          //
          // Property name is the title of the dialog box.
          //

          SetWindowText( hwndDlg,
                         pPropInfo->lpszProperty );

          //
          // Show the property type.
          //

          SetWindowText( GetDlgItem(hwndDlg,
                                    IDS_PROPERTY_TYPE),
                         pPropInfo->lpszType );

          if ( DisplayArrayProperty(pPropInfo->lpszProperty,
                                    pPropInfo->pvaValue,
                                    hwndDlg) ) {
             return TRUE;
          }

          EndDialog( hwndDlg, 0 );


     case WM_COMMAND:

          switch( LOWORD(wParam) ) {

             case IDB_MODIFY:
                  
                  if ( HIWORD(wParam) == BN_CLICKED ) {

                     //
                     // User wants to update the instance after modifying the
                     // property value.
                     //

                     pPropInfo = (LPPROPERTY_INFO)GetWindowLongPtr( hwndDlg,
                                                                    DWLP_USER );
                     ModifyArrayProperty( hwndDlg,
                                          pPropInfo );

                     EndDialog( hwndDlg, 0 );
                  }

                  break;

             case IDB_CANCEL:
                  
                  if ( HIWORD(wParam) == BN_CLICKED ) {

                     EndDialog( hwndDlg, 0 );
                  }

                  break;
          }

          break;

     case WM_SYSCOMMAND:

             if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                EndDialog( hwndDlg, 0 );
             }
  }

  return FALSE;
}

//
// The function populates the combo box of the main window with the classes
// defined in the lpszClasses array, selects the first class of the combo box,
// shows its instances, and properties of the first instance.
//

VOID ListDefaults (HWND hwndDlg)
{
  HWND  hwndClassList;
  UINT  i;

  hwndClassList = GetDlgItem( hwndDlg,
                              IDL_CLASSES );
  //
  // Add the default classes to the combo box.
  //

  for (i=0; i < sizeof(lpszClasses)/sizeof(LPTSTR); ++i) {

     SendMessage( hwndClassList,
                  CB_ADDSTRING,
                  0,
                  (LPARAM)lpszClasses[i] );
  }

  //
  // By default, select the first one in the list which maybe different from
  // the first element in the lpszClasses array since the list is sorted.
  //

  SendMessage( hwndClassList,
               CB_SETCURSEL,
               0,
               0 );

  //
  // Show the instances and properties of the first instance.
  //

  RefreshOnClassSelection( hwndDlg );

  return;
}

//
// The function lists all the properties of the class instance selected by the
// user.
//

VOID ShowProperties (HWND hwndDlg,
                     HWND hwndInstTree)
{
  IWbemServices *pIWbemServices;
  LPTSTR        lpszInstance;
  LPTSTR        lpszClass;


  lpszClass = GetSelectedClass( GetDlgItem(hwndDlg,
                                           IDL_CLASSES) );

  lpszInstance = GetSelectedItem( hwndInstTree );

  if ( lpszInstance && lpszClass ) {

     pIWbemServices = (IWbemServices *)GetWindowLongPtr(
                                              hwndDlg,
                                              DWLP_USER );
     //
     // Show properties of the selected instance.
     //

     TreeView_DeleteAllItems( GetDlgItem(hwndDlg,
                                         IDT_PROPERTIES) );
     EnumProperties( pIWbemServices,
                     lpszClass,
                     lpszInstance,
                     GetDlgItem(hwndDlg,
                                IDT_PROPERTIES) );

  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Properties of the selected ")
                 TEXT("instance will not be listed.") );
  }

  if ( lpszClass ) {
     SysFreeString( (BSTR)((PVOID)lpszClass) );
  }

  if ( lpszInstance ) {
     SysFreeString( (BSTR)((PVOID)lpszInstance) );
  }

  return;
}

//
// The function shows a dialog box displaying the value of the selected property
// and allows the user to modify it.
//

VOID EditProperty (HWND hwndDlg,
                   HWND hwndPropTree)
{
  PROPERTY_INFO    propertyInfo;
  LPTSTR           lpszInstance;
  LPTSTR           lpszClass;
  VARIANT          vaValue;

  //
  // Get the selected class name.
  //

  lpszClass = GetSelectedClass( GetDlgItem(hwndDlg,
                                           IDL_CLASSES) );

  //
  // Get the selected instance name which is __RELPATH value.
  //

  lpszInstance = GetSelectedItem( GetDlgItem(hwndDlg,
                                             IDT_INSTANCES) );

  //
  // Get the selected property name.
  //

  propertyInfo.lpszProperty = GetSelectedItem( hwndPropTree );

  if ( lpszInstance && lpszClass && propertyInfo.lpszProperty ) {

     propertyInfo.pIWbemServices = (IWbemServices *)GetWindowLongPtr(
                                                             hwndDlg,
                                                             DWLP_USER );

     propertyInfo.pInstance = GetInstanceReference( propertyInfo.pIWbemServices,
                                                    lpszClass,
                                                    lpszInstance );

     if ( propertyInfo.pInstance ) {

        if ( GetPropertyValue( propertyInfo.pInstance,
                               propertyInfo.lpszProperty,
                               &vaValue,
                               &propertyInfo.lpszType) ) {

           propertyInfo.pvaValue = &vaValue;

           if ( V_ISARRAY(&vaValue) ) {

              DialogBoxParam( hInstance,
                              MAKEINTRESOURCE(IDD_ARRAY_PROPERTY),
                              hwndDlg,
                              DlgProcArray,
                              (LPARAM)&propertyInfo );
           }
           else {

              DialogBoxParam( hInstance,
                              MAKEINTRESOURCE(IDD_SCALAR_PROPERTY),
                              hwndDlg,
                              DlgProcScalar,
                              (LPARAM)&propertyInfo );
           }

           VariantClear( &vaValue );
           SysFreeString( (BSTR)((PVOID)propertyInfo.lpszType) );
        }
        else {
           PrintError( HRESULT_FROM_WIN32(ERROR_WMI_TRY_AGAIN),
                       __LINE__,
                       TEXT(__FILE__),
                       TEXT("Couldn't read %s."),
                       propertyInfo.lpszProperty );
        }

        propertyInfo.pInstance->Release();
     }
     else {
        PrintError( HRESULT_FROM_WIN32(ERROR_WMI_INSTANCE_NOT_FOUND),
                    __LINE__,
                    TEXT(__FILE__),
                    TEXT("Couldn't get a pointer to %s."),
                    lpszInstance );
     }

  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Properties of the selected ")
                 TEXT("instance will not be listed.") );
  }

  if ( lpszClass ) {
     SysFreeString( (BSTR)((PVOID)lpszClass) );
  }

  if ( lpszInstance ) {
     SysFreeString( (BSTR)((PVOID)lpszInstance) );
  }

  if ( propertyInfo.lpszProperty ) {
     SysFreeString( (BSTR)((PVOID)propertyInfo.lpszProperty) );
  }

  return;
}

//
// The function updates the property that is modified a the user.
//

BOOL ModifyProperty (HWND hwndDlg)
{
  LPPROPERTY_INFO pPropInfo;
  HWND            hwndValue;
  VARIANT         vaTemp;
  VARIANT         vaNewValue;
  LPTSTR          lpszValue;
  ULONG           ulLen;
  HRESULT         hr;


  hr = S_FALSE;

  pPropInfo = (LPPROPERTY_INFO)GetWindowLongPtr( hwndDlg,
                                                 DWLP_USER );

  //
  // Allocate memory and get new value of the property.
  //

  hwndValue = GetDlgItem( hwndDlg,
                          IDE_PROPERTY_VALUE );

  ulLen = (ULONG)SendMessage( hwndValue,
                              WM_GETTEXTLENGTH,
                              0,
                              0 );
  if ( ulLen > 0 ) {

     lpszValue = (LPTSTR)SysAllocStringLen( NULL,
                                    ulLen+1 );

     if ( lpszValue ) {

        SendMessage( hwndValue,
                     WM_GETTEXT,
                     ulLen+1,
                     (LPARAM)lpszValue );


        VariantInit( &vaTemp );

        //
        // Change the new value from string to its original type.
        //

        V_VT(&vaTemp) = VT_BSTR;
        V_BSTR(&vaTemp) = StringToBstr( lpszValue,
                                          -1 );
        if ( V_BSTR(&vaTemp) == NULL ) {
           PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                       __LINE__,
                       TEXT(__FILE__),
                       TEXT("Couldn't modify the value of %s."),
                       pPropInfo->lpszProperty );
        }
        else {
           VariantInit( &vaNewValue );

           hr = VariantChangeType( &vaNewValue,
                                   &vaTemp,
                                   VARIANT_LOCALBOOL,
                                   V_VT(pPropInfo->pvaValue) );

           if ( hr == S_OK ) {

              //
              // Update the property and its instance.
              //

              hr = UpdatePropertyValue( pPropInfo->pIWbemServices,
                                        pPropInfo->pInstance,
                                        pPropInfo->lpszProperty,
                                        &vaNewValue );

              if ( hr == WBEM_S_NO_ERROR ) {

                 PrintError(  0,
                              __LINE__,
                              TEXT(__FILE__),
                              TEXT("%s is successfully updated with value %s."),
                              pPropInfo->lpszProperty,
                              lpszValue );
              }

              VariantClear( &vaNewValue );
           }
           else {
              PrintError( hr,
                          __LINE__,
                          TEXT(__FILE__),
                          TEXT("Couldn't convert the specified value '%s' of ")
                          TEXT("property %s into %s type."),
                          lpszValue,
                          pPropInfo->lpszProperty,
                          pPropInfo->lpszType );
           }

           SysFreeString( V_BSTR(&vaTemp) );
        }

        SysFreeString( (BSTR)((PVOID)lpszValue) );
     }
     else {
        PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                    __LINE__,
                    TEXT(__FILE__),
                    TEXT("Couldn't modify the value of %s."),
                    pPropInfo->lpszProperty );
     }
  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_WMI_TRY_AGAIN),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("You must specify a value to modify %s."),
                 pPropInfo->lpszProperty );
  }
  
  return hr == WBEM_S_NO_ERROR;
}

//
// The function populates a tree list with the values of a property of array
// type. The property could be an array of string or integer.
//

BOOL DisplayArrayProperty (LPTSTR lpszProperty,
                           VARIANT *pvaValue,
                           HWND hwndDlg)
{
  SAFEARRAY   *psaValue;
  VARIANT     vaTemp;
  VARIANT     vaElement;
  VARTYPE     vt;
  long        lLBound;
  long        lUBound;
  long        i;
  UINT        uiSize;
  BSTR        lpsz;
  LPVOID      pv;
  HRESULT     hr;

  //
  // Make a copy of the property value.
  //

  psaValue = NULL;
  hr = SafeArrayCopy( V_ARRAY(pvaValue),
                      &psaValue );

  if ( hr == S_OK ) {
     hr = SafeArrayGetVartype( psaValue,
                               &vt );
  }

  if ( hr == S_OK ) {
     hr = SafeArrayGetLBound( psaValue,
                              1,
                              &lLBound );
  }
  
  if ( hr == S_OK ) {
     hr = SafeArrayGetUBound( psaValue,
                              1,
                              &lUBound );
  }

  if ( hr == S_OK ) {
     uiSize = SafeArrayGetElemsize( psaValue );
  }

  if ( hr == S_OK ) {
     hr = SafeArrayAccessData( psaValue,
                               &pv );
  }

  if ( hr == S_OK ) {

     lpsz = (BSTR)pv;

     //
     // Change each element into string.
     //

     for (i=0; (hr == S_OK) && (i < (lUBound-lLBound+1)); ++i) {

        VariantInit( &vaElement );
        V_VT(&vaElement) = VT_BYREF | vt;
        V_BYREF(&vaElement) = (LPVOID)lpsz;

        VariantInit( &vaTemp );

        hr = VariantChangeType( &vaTemp,
                                &vaElement,
                                VARIANT_LOCALBOOL,
                                VT_BSTR );

        if ( hr == S_OK ) {

           hr = AddToList( hwndDlg,
                           &vaTemp );

           VariantClear( &vaTemp );
        }
        else {
           PrintError( hr,
                       __LINE__,
                       TEXT(__FILE__),
                       TEXT("Couldn't format the value of %s into ")
                       TEXT("displayable text. The value cannot be ")
                       TEXT(" viewed/modified."),
                       lpszProperty );
        }

        lpsz = (BSTR)((LONG_PTR)lpsz + uiSize);
     }

     SafeArrayUnaccessData( psaValue );
  }
  else {
     PrintError( hr,
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Couldn't read the values of %s."),
                 lpszProperty );
  }

  if ( psaValue ) {
     SafeArrayDestroy( psaValue );
  }

  return hr == S_OK;
}

//
// The function add a property value to the tree list.
//

HRESULT AddToList (HWND hwndDlg,
                  VARIANT *pvaValue)
{
  TV_INSERTSTRUCT tvInsertStruc;
  
  ZeroMemory(
        &tvInsertStruc,
        sizeof(TV_INSERTSTRUCT) );

  tvInsertStruc.hParent = TVI_ROOT;

  tvInsertStruc.hInsertAfter = TVI_LAST;

  tvInsertStruc.item.mask = TVIF_TEXT | TVIF_PARAM;

  tvInsertStruc.item.pszText = BstrToString( V_BSTR(pvaValue),
                                             -1 );

  if ( tvInsertStruc.item.pszText ) {
     tvInsertStruc.item.cchTextMax = _tcslen( tvInsertStruc.item.pszText ) + 1;

     tvInsertStruc.item.lParam = (LPARAM)tvInsertStruc.item.cchTextMax;

     TreeView_InsertItem( GetDlgItem(hwndDlg,
                                     IDT_PROPERTY_VALUE),
                          &tvInsertStruc );

     SysFreeString( (BSTR)((PVOID)tvInsertStruc.item.pszText) );
  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Cannot show the values of the property.") );

     return S_FALSE;
  }

  return S_OK;
}


VOID ModifyArrayProperty(HWND hwndDlg,
                         LPPROPERTY_INFO pPropInfo)
{
  MessageBox( hwndDlg,
              TEXT("This feature is currently not implemented."),
              TEXT("Modify Array"),
              MB_ICONINFORMATION | MB_OK );

  return;
}



//
// The function lists the instances of the selected class and properties of
// the first instance.
//

VOID RefreshOnClassSelection (HWND hwndDlg)
{
  IWbemServices *pIWbemServices;
  HWND           hwndClassList;
  HWND           hwndInstTree;
  HWND           hwndPropTree;
  LPTSTR         lpszClass;
  LPTSTR         lpszInstance;
  HTREEITEM      hItem;

  pIWbemServices = (IWbemServices *)GetWindowLongPtr( hwndDlg,
                                                      DWLP_USER );
  //
  // Find the selected class.
  //
  //

  hwndClassList = GetDlgItem( hwndDlg,
                              IDL_CLASSES );

  hwndInstTree = GetDlgItem( hwndDlg,
                             IDT_INSTANCES );

  hwndPropTree = GetDlgItem( hwndDlg,
                             IDT_PROPERTIES );

  TreeView_DeleteAllItems( hwndInstTree );
  TreeView_DeleteAllItems( hwndPropTree );

  lpszClass = GetSelectedClass( hwndClassList );

  if ( lpszClass ) {

     //
     // List all the instances of the selected class.
     //

     EnumInstances( pIWbemServices,
                    lpszClass,
                    hwndInstTree );    // Tree to populate.

     //
     // By default, first instance is selected and its properties
     // are shown.
     //

     hItem = TreeView_GetChild( hwndInstTree,
                                TVI_ROOT );

     //
     // hItem == NULL ==> No instances found.
     //

     if ( hItem ) {

        //
        // Select the first instance.
        //

        TreeView_SelectItem( hwndInstTree,
                             hItem );

        //
        // Find the selected instance.
        //

        lpszInstance = GetSelectedItem( hwndInstTree );

        if ( lpszInstance ) {

           //
           // Show properties of the selected instance.
           //

           EnumProperties( pIWbemServices,
                           lpszClass,
                           lpszInstance,
                           hwndPropTree );  // Tree to populate.

           SysFreeString( (BSTR)((PVOID)lpszInstance) );
        }
        else {
           PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                       __LINE__,
                       TEXT(__FILE__),
                       TEXT("Properties of the selected ")
                       TEXT("instance will not be listed.") );
        }
     }

     SysFreeString( (BSTR)((PVOID)lpszClass) );
  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Instances of the selected ")
                 TEXT("class will not be listed.") );
  }

  return;
}

//
// Given a handle to a combo box, the function returns the name of the
// selected item i.e. class.
//

LPTSTR GetSelectedClass (HWND hwndClassList)
{
  LPTSTR    lpszClass;
  ULONG     ulIndex;
  ULONG     ulLen;

  lpszClass = NULL;

  //
  // Find the selected class.
  //

  ulIndex = (ULONG)SendMessage( hwndClassList,
                                CB_GETCURSEL,
                                0,
                                0 );

  //
  // Find the length of the selected class name.
  //

  ulLen = (ULONG)SendMessage( hwndClassList,
                              CB_GETLBTEXTLEN,
                              (WPARAM)ulIndex,
                              0 );

  lpszClass = (LPTSTR)SysAllocStringLen( NULL,
                                 ulLen + 1 );

  if ( lpszClass ) {
     SendMessage( hwndClassList,
                  CB_GETLBTEXT,
                  (WPARAM)ulIndex,
                  (LPARAM)lpszClass );
  }

  return lpszClass;
}

//
// Given a handle to the tree list, the function returns the name of the
// selected item.
//

LPTSTR GetSelectedItem (HWND hwndTree)
{
  LPTSTR    lpszItem;
  HTREEITEM hItem;
  TVITEM    tvItem;

  lpszItem = NULL;

  //
  // Find the selected item.
  //

  hItem = TreeView_GetSelection( hwndTree );

  if ( hItem ) {

     //
     // Find out the length of the selected item and allocate memory.
     //

     ZeroMemory( &tvItem,
                 sizeof(TVITEM) );

     tvItem.hItem = hItem;
     tvItem.mask = TVIF_PARAM;

     TreeView_GetItem( hwndTree,
                       &tvItem );

     
     lpszItem = (LPTSTR)SysAllocStringLen( NULL,
                                           (UINT)tvItem.lParam );

     if ( lpszItem ) {

         tvItem.hItem = hItem;
        tvItem.mask = TVIF_TEXT;
        tvItem.pszText = lpszItem;
        tvItem.cchTextMax = (INT)tvItem.lParam;

        TreeView_GetItem( hwndTree,
                          &tvItem );
     }
  }

  return lpszItem;
}

//
// The function inserts an item into a tree list.
//

VOID InsertItem (HWND hwndTree,
                 LPTSTR lpszItem)
{
  TVINSERTSTRUCT  tvInsertStruc;

  ZeroMemory(
        &tvInsertStruc,
        sizeof(TVINSERTSTRUCT) );

  tvInsertStruc.hParent = TVI_ROOT;

  tvInsertStruc.hInsertAfter = TVI_LAST;

  tvInsertStruc.item.mask = TVIF_TEXT | TVIF_PARAM;

  tvInsertStruc.item.pszText = lpszItem;

  tvInsertStruc.item.cchTextMax = _tcslen(lpszItem) + 1;

  tvInsertStruc.item.lParam = tvInsertStruc.item.cchTextMax;

  TreeView_InsertItem( hwndTree,
                       &tvInsertStruc );

  return;
}

VOID PrintError (HRESULT hr,
                 UINT    uiLine,
                 LPTSTR  lpszFile,
                 LPCTSTR  lpFmt,
                 ...)
{

  LPTSTR   lpSysMsg;
  TCHAR    buf[400];
  ULONG    offset;
  va_list  vArgList; 


  if ( hr != 0 ) {
     _stprintf( buf,
               TEXT("Error %#lx (%s, %d): "),
               hr,
               lpszFile,
               uiLine );
  }
  else {
     _stprintf( buf,
               TEXT("(%s, %d): "),
               lpszFile,
               uiLine );
  }

  offset = _tcslen( buf );
  
  va_start( vArgList,
            lpFmt );
  _vstprintf( buf+offset,
              lpFmt,
              vArgList );

  va_end( vArgList );

  if ( hr != 0 ) {
     FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    hr,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR)&lpSysMsg,
                    0,
                    NULL );
     if ( lpSysMsg ) {

        offset = _tcslen( buf );

        _stprintf( buf+offset,
                   TEXT("\n\nPossible cause:\n\n") );

        offset = _tcslen( buf );

        _tcscat( buf+offset,
                 lpSysMsg );

        LocalFree( (HLOCAL)lpSysMsg );
     }

     MessageBox( NULL,
                 buf,
                 TEXT("TestWMI"),
                 MB_ICONERROR | MB_OK );
  }
  else {
     MessageBox( NULL,
                 buf,
                 TEXT("TestWMI"),
                 MB_ICONINFORMATION | MB_OK );
  }

  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\ne2000\card.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved.

Module Name:

    card.c

Abstract:

    Card-specific functions for the NDIS 3.0 Novell 2000 driver.

Author:

    Sean Selitrennikoff

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include "precomp.h"

BOOLEAN
CardSlotTest(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardRamTest(
    IN PNE2000_ADAPTER Adapter
    );


#pragma NDIS_PAGEABLE_FUNCTION(CardCheckParameters)

BOOLEAN CardCheckParameters(
    IN PNE2000_ADAPTER Adapter
)

/*++

Routine Description:

    Checks that the I/O base address is correct.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    TRUE, if IoBaseAddress appears correct.

--*/

{
    UCHAR Tmp;

    //
    // If adapter responds to a stop command correctly -- assume it is there.
    //

    //
    // Turn off interrupts first.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_MASK, 0);

    //
    // Stop the card.
    //
    SyncCardStop(Adapter);

    //
    // Pause
    //
    NdisStallExecution(2000);

    //
    // Read response
    //
    NdisRawReadPortUchar(Adapter->IoPAddr + NIC_COMMAND, &Tmp);

    if ((Tmp == (CR_NO_DMA | CR_STOP)) ||
        (Tmp == (CR_NO_DMA | CR_STOP | CR_START))
    )
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}
#ifdef NE2000

#pragma NDIS_PAGEABLE_FUNCTION(CardSlotTest)


BOOLEAN CardSlotTest(
    IN PNE2000_ADAPTER Adapter
)

/*++

Routine Description:

    Checks if the card is in an 8 or 16 bit slot and sets a flag in the
    adapter structure.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    TRUE, if all goes well, else FALSE.

--*/

{
    UCHAR Tmp;
    UCHAR RomCopy[32];
    UCHAR i;
	BOOLEAN found;

    //
    // Reset the chip
    //
    NdisRawReadPortUchar(Adapter->IoPAddr + NIC_RESET, &Tmp);
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RESET, 0xFF);

    //
    // Go to page 0 and stop
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_STOP | CR_NO_DMA);

    //
    // Pause
    //
    NdisStallExecution(2000);

    //
    // Check that it is stopped
    //
    NdisRawReadPortUchar(Adapter->IoPAddr + NIC_COMMAND, &Tmp);
    if (Tmp != (CR_NO_DMA | CR_STOP))
    {
        IF_LOUD(DbgPrint("Could not stop the card\n");)

        return(FALSE);
    }

    //
    // Setup to read from ROM
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_DATA_CONFIG,
        DCR_BYTE_WIDE | DCR_FIFO_8_BYTE | DCR_NORMAL
    );

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_MASK, 0x0);

    //
    // Ack any interrupts that may be hanging around
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_STATUS, 0xFF);

    //
    // Setup to read in the ROM, the address and byte count.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_LSB, 0x0);

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_MSB, 0x0);

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 32);

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0);

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_DMA_READ | CR_START
    );

    //
    // Read first 32 bytes in 16 bit mode
    //
	for (i = 0; i < 32; i++)
	{
		NdisRawReadPortUchar(Adapter->IoPAddr + NIC_RACK_NIC, RomCopy + i);
	}

    IF_VERY_LOUD( DbgPrint("Resetting the chip\n"); )

    //
    // Reset the chip
    //
    NdisRawReadPortUchar(Adapter->IoPAddr + NIC_RESET, &Tmp);
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RESET, 0xFF);

    //
    // Check ROM for 'B' (byte) or 'W' (word)
    // NOTE: If the buffer has bot BB and WW then use WW instead of BB
    IF_VERY_LOUD( DbgPrint("Checking slot type\n"); )

	found = FALSE;
	for (i = 16; i < 31; i++)
	{
		if (((RomCopy[i] == 'B') && (RomCopy[i+1] == 'B')) ||
			((RomCopy[i] == 'W') && (RomCopy[i+1] == 'W'))
		)
		{
			if (RomCopy[i] == 'B')
			{
				Adapter->EightBitSlot = TRUE;
				found = TRUE;
			}
			else
			{
				Adapter->EightBitSlot = FALSE;
				found = TRUE;
				break;		// Go no farther
			}
		}
	}

	if (found)
	{
		IF_VERY_LOUD( (Adapter->EightBitSlot?DbgPrint("8 bit slot\n"):
							  DbgPrint("16 bit slot\n")); )
	}
	else
	{
		//
		// If neither found -- then not an NE2000
		//
		IF_VERY_LOUD( DbgPrint("Failed slot type\n"); )
	}

    return(found);
}

#endif // NE2000




#pragma NDIS_PAGEABLE_FUNCTION(CardRamTest)

BOOLEAN
CardRamTest(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Finds out how much RAM the adapter has.  It starts at 1K and checks thru
    60K.  It will set Adapter->RamSize to the appropriate value iff this
    function returns TRUE.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    TRUE, if all goes well, else FALSE.

--*/

{
    PUCHAR RamBase, RamPointer;
    PUCHAR RamEnd;

	UCHAR TestPattern[]={ 0xAA, 0x55, 0xFF, 0x00 };
	PULONG pTestPattern = (PULONG)TestPattern;
	UCHAR ReadPattern[4];
	PULONG pReadPattern = (PULONG)ReadPattern;

    for (RamBase = (PUCHAR)0x400; RamBase < (PUCHAR)0x10000; RamBase += 0x400) {

        //
        // Write Test pattern
        //

        if (!CardCopyDown(Adapter, RamBase, TestPattern, 4)) {

            continue;

        }

        //
        // Read pattern
        //

        if (!CardCopyUp(Adapter, ReadPattern, RamBase, 4)) {

            continue;

        }

        IF_VERY_LOUD( DbgPrint("Addr 0x%x: 0x%x, 0x%x, 0x%x, 0x%x\n",
                               RamBase,
                               ReadPattern[0],
                               ReadPattern[1],
                               ReadPattern[2],
                               ReadPattern[3]
                              );
                    )


        //
        // If they are the same, find the end
        //

        if (*pReadPattern == *pTestPattern) {

            for (RamEnd = RamBase; !(PtrToUlong(RamEnd) & 0xFFFF0000); RamEnd += 0x400) {

                //
                // Write test pattern
                //

                if (!CardCopyDown(Adapter, RamEnd, TestPattern, 4)) {

                    break;

                }

                //
                // Read pattern
                //

                if (!CardCopyUp(Adapter, ReadPattern, RamEnd, 4)) {

                    break;

                }

                if (*pReadPattern != *pTestPattern) {

                    break;

                }

            }

            break;

        }

    }

    IF_LOUD( DbgPrint("RamBase 0x%x, RamEnd 0x%x\n", RamBase, RamEnd); )

    //
    // If not found, error out
    //

    if ((RamBase >= (PUCHAR)0x10000) || (RamBase == RamEnd)) {

        return(FALSE);

    }

    //
    // Watch for boundary case when RamEnd is maximum value
    //

    if ((ULONG_PTR)RamEnd & 0xFFFF0000) {

        RamEnd -= 0x100;

    }

    //
    // Check all of ram
    //

    for (RamPointer = RamBase; RamPointer < RamEnd; RamPointer += 4) {

        //
        // Write test pattern
        //

        if (!CardCopyDown(Adapter, RamPointer, TestPattern, 4)) {

            return(FALSE);

        }

        //
        // Read pattern
        //

        if (!CardCopyUp(Adapter, ReadPattern, RamBase, 4)) {

            return(FALSE);

        }

        if (*pReadPattern != *pTestPattern) {

            return(FALSE);

        }

    }

    //
    // Store Results
    //

    Adapter->RamBase = RamBase;
    Adapter->RamSize = (ULONG)(RamEnd - RamBase);

    return(TRUE);

}

#pragma NDIS_PAGEABLE_FUNCTION(CardInitialize)

BOOLEAN
CardInitialize(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Initializes the card into a running state.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    TRUE, if all goes well, else FALSE.

--*/

{
    UCHAR Tmp;
    USHORT i;

    //
    // Stop the card.
    //
    SyncCardStop(Adapter);

    //
    // Initialize the Data Configuration register.
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_DATA_CONFIG,
        DCR_AUTO_INIT | DCR_FIFO_8_BYTE
    );

    //
    // Set Xmit start location
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_START, 0xA0);

    //
    // Set Xmit configuration
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_CONFIG, 0x0);

    //
    // Set Receive configuration
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RCV_CONFIG, RCR_MONITOR);

    //
    // Set Receive start
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_PAGE_START, 0x4);

    //
    // Set Receive end
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_PAGE_STOP, 0xFF);

    //
    // Set Receive boundary
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_BOUNDARY, 0x4);

    //
    // Set Xmit bytes
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_COUNT_LSB, 0x3C);
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_COUNT_MSB, 0x0);

    //
    // Pause
    //
    NdisStallExecution(2000);

    //
    // Ack all interrupts that we might have produced
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_STATUS, 0xFF);

    //
    // Change to page 1
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_PAGE1 | CR_STOP);

    //
    // Set current
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_CURRENT, 0x4);

    //
    // Back to page 0
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_PAGE0 | CR_STOP);

    //
    // Pause
    //
    NdisStallExecution(2000);

    //
    // Check that Command register reflects this last command
    //
    NdisRawReadPortUchar(Adapter->IoPAddr + NIC_COMMAND, &Tmp);
    if (!(Tmp & CR_STOP))
    {
        IF_LOUD(DbgPrint("Invalid command register\n");)

        return(FALSE);
    }

    //
    // Do initialization errata
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 55);

    //
    // Setup for a read
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_DMA_READ | CR_START
    );

#ifdef NE2000

    //
    // Check if the slot is 8 or 16 bit (affects data transfer rate).
    //

    if ((Adapter->BusType == NdisInterfaceMca) ||
		(NE2000_PCMCIA == Adapter->CardType))
    {
        Adapter->EightBitSlot = FALSE;
    }
    else
    {
        IF_VERY_LOUD(DbgPrint("CardSlotTest\n");)

        if (CardSlotTest(Adapter) == FALSE)
        {
            //
            // Stop chip
            //
            SyncCardStop(Adapter);

            IF_LOUD(DbgPrint("  -- Failed\n");)
            return(FALSE);
        }

    }

#else // NE2000

    Adapter->EightBitSlot = TRUE;

#endif // NE2000

    //
    // Mask Interrupts
    //

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_MASK, 0x0);

    //
    // Setup the Adapter for reading ram
    //

// NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_PAGE0);   // robin

    if (Adapter->EightBitSlot)
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_DATA_CONFIG,
            DCR_FIFO_8_BYTE | DCR_NORMAL | DCR_BYTE_WIDE
        );
    }
    else
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_DATA_CONFIG,
            DCR_FIFO_8_BYTE | DCR_NORMAL | DCR_WORD_WIDE
        );
    }

    //
    // Clear transmit configuration.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_CONFIG, 0);

    //
    // Clear receive configuration.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RCV_CONFIG, 0);

    //
    // Clear any interrupts
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_STATUS, 0xFF);

    //
    // Stop the chip
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_NO_DMA | CR_STOP);

    //
    // Clear any DMA values
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0);

    //
    // Clear any DMA values
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0);

    //
    // Wait for the reset to complete.
    //
    i = 0x3FFF;

    while (--i)
    {
        NdisRawReadPortUchar(Adapter->IoPAddr + NIC_INTR_STATUS, &Tmp);

        if (Tmp & ISR_RESET)
            break;

        NdisStallExecution(4);
    }

    //
    // Put card in loopback mode
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_CONFIG, TCR_LOOPBACK);

    //
    // Start the chip.
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_NO_DMA | CR_START
    );

    //
    // Test for the amount of RAM
    //
    if (NE2000_ISA == Adapter->CardType)
    {
        if (CardRamTest(Adapter) == FALSE)
        {
            //
            // Stop the chip
            //
            SyncCardStop(Adapter);

            return(FALSE);
        }
    }
    else
    {
        //
        //  We know what it is for the pcmcia adapters,
        //  so don't waste time on detecting it.
        //
        Adapter->RamBase = (PUCHAR)0x4000;
        Adapter->RamSize = 0x4000;
    }

    //
    // Stop the chip
    //
    SyncCardStop(Adapter);

    return(TRUE);
}


#pragma NDIS_PAGEABLE_FUNCTION(CardReadEthernetAddress)

BOOLEAN CardReadEthernetAddress(
    IN PNE2000_ADAPTER Adapter
)

/*++

Routine Description:

    Reads in the Ethernet address from the Novell 2000.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    The address is stored in Adapter->PermanentAddress, and StationAddress if it
    is currently zero.

--*/

{
    UINT    c;

    //
    //  Things are done a little differently for PCMCIA adapters.
    //
    if (NE2000_PCMCIA == Adapter->CardType)
    {
#if 0
    
        NDIS_STATUS             Status;
        PUCHAR                  pAttributeWindow;
        NDIS_PHYSICAL_ADDRESS   AttributePhysicalAddress;
        //
        //  Setup the physical address for the attribute window.
        //
        NdisSetPhysicalAddressHigh(AttributePhysicalAddress, 0);
        NdisSetPhysicalAddressLow(
            AttributePhysicalAddress,
            Adapter->AttributeMemoryAddress
        );

        //
        //  We need to get the pcmcia information from the tuple.
        //
        Status = NdisMMapIoSpace(
                     (PVOID *)&pAttributeWindow,
                     Adapter->MiniportAdapterHandle,
                     AttributePhysicalAddress,
                     Adapter->AttributeMemorySize
                 );
        if (NDIS_STATUS_SUCCESS != Status)
        {
            //
            //  Failed to setup the attribute window.
            //
            return(FALSE);
        }

        //
        //  Read the ethernet address from the card.
        //
        for (c = 0; c < ETH_LENGTH_OF_ADDRESS; c++)
        {
			NdisReadRegisterUchar(
				(PUCHAR)(pAttributeWindow + CIS_NET_ADDR_OFFSET + c * 2),
				&Adapter->PermanentAddress[c]);
        }
#endif
		if (ETH_LENGTH_OF_ADDRESS != NdisReadPcmciaAttributeMemory(
													Adapter->MiniportAdapterHandle,
													CIS_NET_ADDR_OFFSET/2,
													Adapter->PermanentAddress,
													ETH_LENGTH_OF_ADDRESS
													))
		{
			return(FALSE);
		}

    }
    else
    {
        //
        // Setup to read the ethernet address
        //
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 12);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_LSB, 0);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_MSB, 0);
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_COMMAND,
            CR_START | CR_DMA_READ
        );

        //
        // Read in the station address. (We have to read words -- 2 * 6 -- bytes)
        //
        for (c = 0; c < NE2000_LENGTH_OF_ADDRESS; c++)
        {
            NdisRawReadPortUchar(
                Adapter->IoPAddr + NIC_RACK_NIC,
                &Adapter->PermanentAddress[c]
            );
        }
    }

    IF_LOUD(
        DbgPrint(
            "Ne2000: PermanentAddress [ %02x-%02x-%02x-%02x-%02x-%02x ]\n",
            Adapter->PermanentAddress[0],
            Adapter->PermanentAddress[1],
            Adapter->PermanentAddress[2],
            Adapter->PermanentAddress[3],
            Adapter->PermanentAddress[4],
            Adapter->PermanentAddress[5]
        );
    )

    //
    // Use the burned in address as the station address, unless the
    // registry specified an override value.
    //
    if ((Adapter->StationAddress[0] == 0x00) &&
        (Adapter->StationAddress[1] == 0x00) &&
        (Adapter->StationAddress[2] == 0x00) &&
        (Adapter->StationAddress[3] == 0x00) &&
        (Adapter->StationAddress[4] == 0x00) &&
        (Adapter->StationAddress[5] == 0x00)
    )
    {
        Adapter->StationAddress[0] = Adapter->PermanentAddress[0];
        Adapter->StationAddress[1] = Adapter->PermanentAddress[1];
        Adapter->StationAddress[2] = Adapter->PermanentAddress[2];
        Adapter->StationAddress[3] = Adapter->PermanentAddress[3];
        Adapter->StationAddress[4] = Adapter->PermanentAddress[4];
        Adapter->StationAddress[5] = Adapter->PermanentAddress[5];
    }

    return(TRUE);
}


BOOLEAN
CardSetup(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Sets up the card.

Arguments:

    Adapter - pointer to the adapter block, which must be initialized.

Return Value:

    TRUE if successful.

--*/

{
    UINT i;
    UINT Filter;
    UCHAR Tmp;


    //
    // Write to and read from CR to make sure it is there.
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_STOP | CR_NO_DMA | CR_PAGE0
    );

    NdisRawReadPortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        &Tmp
    );
    if ((Tmp & (CR_STOP | CR_NO_DMA | CR_PAGE0)) !=
        (CR_STOP | CR_NO_DMA | CR_PAGE0)
    )
    {
        return(FALSE);
    }

    //
    // Set up the registers in the correct sequence, as defined by
    // the 8390 specification.
    //
    if (Adapter->EightBitSlot)
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_DATA_CONFIG,
            DCR_BYTE_WIDE | DCR_NORMAL | DCR_FIFO_8_BYTE
        );
    }
    else
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_DATA_CONFIG,
            DCR_WORD_WIDE | DCR_NORMAL | DCR_FIFO_8_BYTE
        );
    }


    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0);

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0);

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_RCV_CONFIG,
        Adapter->NicReceiveConfig
    );

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_XMIT_CONFIG,
        TCR_LOOPBACK
    );

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_BOUNDARY,
        Adapter->NicPageStart
    );

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_PAGE_START,
        Adapter->NicPageStart
    );

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_PAGE_STOP,
        Adapter->NicPageStop
    );

    Adapter->Current = Adapter->NicPageStart + (UCHAR)1;
    Adapter->NicNextPacket = Adapter->NicPageStart + (UCHAR)1;
    Adapter->BufferOverflow = FALSE;

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_STATUS, 0xff);

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_INTR_MASK,
        Adapter->NicInterruptMask
    );


    //
    // Move to page 1 to write the station address
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_STOP | CR_NO_DMA | CR_PAGE1
    );

    for (i = 0; i < NE2000_LENGTH_OF_ADDRESS; i++)
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + (NIC_PHYS_ADDR + i),
            Adapter->StationAddress[i]
        );
    }

    Filter = Adapter->PacketFilter;

    //
    // Write out the multicast addresses
    //
    for (i = 0; i < 8; i++)
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + (NIC_MC_ADDR + i),
            (UCHAR)((Filter & NDIS_PACKET_TYPE_ALL_MULTICAST) ?
                    0xff : Adapter->NicMulticastRegs[i])
        );
    }

    //
    // Write out the current receive buffer to receive into
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_CURRENT,
        Adapter->Current
    );


    //
    // move back to page 0 and start the card...
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_STOP | CR_NO_DMA | CR_PAGE0
    );

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_START | CR_NO_DMA | CR_PAGE0
    );

    //
    // ... but it is still in loopback mode.
    //
    return(TRUE);
}

VOID CardStop(
    IN PNE2000_ADAPTER Adapter
)

/*++

Routine Description:

    Stops the card.

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    None.

--*/

{
    UINT i;
    UCHAR Tmp;

    //
    // Turn on the STOP bit in the Command register.
    //
    SyncCardStop(Adapter);

    //
    // Clear the Remote Byte Count register so that ISR_RESET
    // will come on.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0);
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0);


    //
    // Wait for ISR_RESET, but only for 1.6 milliseconds (as
    // described in the March 1991 8390 addendum), since that
    // is the maximum time for a software reset to occur.
    //
    //
    for (i = 0; i < 4; i++)
    {
        NdisRawReadPortUchar(Adapter->IoPAddr+NIC_INTR_STATUS, &Tmp);
        if (Tmp & ISR_RESET)
            break;

        NdisStallExecution(500);
    }

    if (i == 4)
    {
        IF_LOUD( DbgPrint("RESET\n");)
        IF_LOG( Ne2000Log('R');)
    }

    //
    // Put the card in loopback mode, then start it.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_CONFIG, TCR_LOOPBACK);
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_START | CR_NO_DMA);

    //
    // At this point the card is still in loopback mode.
    //
}

BOOLEAN CardReset(
    IN PNE2000_ADAPTER Adapter
)

/*++

Routine Description:

    Resets the card.

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    TRUE if everything is OK.

--*/

{
    //
    // Stop the chip
    //
    CardStop(Adapter);

    //
    // Wait for the card to finish any receives or transmits
    //
    NdisStallExecution(2000);

    //
    // CardSetup() does a software reset.
    //
    if (!CardSetup(Adapter))
    {
        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_HARDWARE_FAILURE,
            2,
            cardReset,
            NE2000_ERRMSG_CARD_SETUP
        );

        return(FALSE);
    }

    //
    // Restart the chip
    //
    CardStart(Adapter);

    return TRUE;
}



BOOLEAN CardCopyDownPacket(
    IN PNE2000_ADAPTER  Adapter,
    IN PNDIS_PACKET     Packet,
    OUT PUINT           Length
)

/*++

Routine Description:

    Copies the packet Packet down starting at the beginning of
    transmit buffer XmitBufferNum, fills in Length to be the
    length of the packet.

Arguments:

    Adapter - pointer to the adapter block
    Packet - the packet to copy down

Return Value:

    Length - the length of the data in the packet in bytes.
    TRUE if the transfer completed with no problems.

--*/

{
    //
    // Addresses of the Buffers to copy from and to.
    //
    PUCHAR CurBufAddress;
    PUCHAR OddBufAddress;
    PUCHAR XmitBufAddress;

    //
    // Length of each of the above buffers
    //
    UINT CurBufLen;
    UINT PacketLength;

    //
    // Was the last transfer of an odd length?
    //
    BOOLEAN OddBufLen = FALSE;

    //
    // Current NDIS_BUFFER that is being copied from
    //
    PNDIS_BUFFER CurBuffer;

    //
    // Programmed I/O, have to transfer the data.
    //
    NdisQueryPacket(Packet, NULL, NULL, &CurBuffer, &PacketLength);

    //
    // Skip 0 length copies
    //
    if (PacketLength == 0) {
        return(TRUE);
    }

    //
    // Get the starting buffer address
    //
    XmitBufAddress = (PUCHAR)Adapter->XmitStart +
                    Adapter->NextBufToFill*TX_BUF_SIZE;

    //
    // Get address and length of the first buffer in the packet
    //
    NdisQueryBuffer(CurBuffer, (PVOID *)&CurBufAddress, &CurBufLen);

    while (CurBuffer && (CurBufLen == 0)) {

        NdisGetNextBuffer(CurBuffer, &CurBuffer);

        NdisQueryBuffer(CurBuffer, (PVOID *)&CurBufAddress, &CurBufLen);

    }

    //
    // set up the card
    //
    {

        //
        // Temporary places for holding values for transferring to
        // an odd aligned address on 16-bit slots.
        //
        UCHAR Tmp;
        UCHAR Tmp1;
        USHORT TmpShort;

        //
        // Values for waiting for noticing when a DMA completes.
        //
        USHORT OldAddr, NewAddr;

        //
        // Count of transfers to do
        //
        USHORT Count;

        //
        // Buffer to read from for odd aligned transfers
        //
        PUCHAR ReadBuffer;

        if (!Adapter->EightBitSlot && ((ULONG_PTR)XmitBufAddress & 0x1)) {

            //
            // Avoid transfers to odd addresses in word mode.
            //
            // For odd addresses we need to read first to get the previous
            // byte and then merge it with our first byte.
            //

            //
            // Set Count and Source address
            //

//          NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_PAGE0);  // robin

            NdisRawWritePortUchar(
                Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                LSB(PtrToUlong(XmitBufAddress - 1))
            );

            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                                  MSB((PtrToUlong(XmitBufAddress) - 1))
                                 );

// NE2000 PCMCIA CHANGE START

            //
            //  NE2000 PCMCIA CHANGE!!!
            //
            //NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x1 );
            //NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0 );
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2 );
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0 );

            //
            // Set direction (Read)
            //

            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_COMMAND,
                           CR_START | CR_PAGE0 | CR_DMA_READ );

            //
            //  NE2000 PCMCIA CHANGE!!!
            //
            //NdisRawReadPortUchar( Adapter->IoPAddr + NIC_RACK_NIC, &Tmp1 );
            NdisRawReadPortUshort( Adapter->IoPAddr + NIC_RACK_NIC, &TmpShort );
            Tmp1 = LSB(TmpShort);

// NE2000 PCMCIA CHANGE END

            //
            // Do Write errata as described on pages 1-143 and
            // 1-144 of the 1992 LAN databook
            //

            //
            // Set Count and destination address
            //
            ReadBuffer = XmitBufAddress + ((ULONG_PTR)XmitBufAddress & 1);

            OldAddr = NewAddr = (USHORT)(ReadBuffer);

//          NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND,   // robin
//                                CR_PAGE0                          // robin
//                                );                                // robin
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                                  LSB(PtrToUlong(ReadBuffer))
                                 );
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                                  MSB(PtrToUlong(ReadBuffer))
                                 );
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2 );
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0 );

            //
            // Set direction (Read)
            //
            NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_COMMAND,
                           CR_START | CR_PAGE0 | CR_DMA_READ
                           );

            //
            // Read from port
            //
            NdisRawReadPortUshort( Adapter->IoPAddr + NIC_RACK_NIC, &TmpShort );

            //
            // Wait for addr to change
            //
            TmpShort = 0xFFFF;

            while (TmpShort != 0) {

                NdisRawReadPortUchar( Adapter->IoPAddr + NIC_CRDA_LSB, &Tmp );
                NewAddr = Tmp;
                NdisRawReadPortUchar( Adapter->IoPAddr + NIC_CRDA_MSB, &Tmp );
                NewAddr |= (Tmp << 8);

                if (NewAddr != OldAddr) {

                    break;

                }

                NdisStallExecution(1);

                TmpShort--;
            }

            if (NewAddr == OldAddr) {

                NdisWriteErrorLogEntry(
                    Adapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_HARDWARE_FAILURE,
                    2,
                    cardCopyDownPacket,
                    (ULONG_PTR)XmitBufAddress
                    );

                return(FALSE);

            }

            //
            // Set Count and destination address
            //
            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                               LSB(PtrToUlong(XmitBufAddress - 1)) );

            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                               MSB(PtrToUlong(XmitBufAddress - 1)) );

            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2 );

            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0 );

            //
            // Set direction (Write)
            //
            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_COMMAND,
                           CR_START | CR_PAGE0 | CR_DMA_WRITE );

            //
            // It seems that the card stores words in LOW:HIGH order
            //
            NdisRawWritePortUshort( Adapter->IoPAddr + NIC_RACK_NIC,
                           (USHORT)(Tmp1 | ((*CurBufAddress) << 8)) );

            //
            // Wait for DMA to complete
            //
            Count = 0xFFFF;

            while (Count) {

                NdisRawReadPortUchar( Adapter->IoPAddr + NIC_INTR_STATUS, &Tmp1 );

                if (Tmp1 & ISR_DMA_DONE) {

                    break;

                } else {

                    Count--;
                    NdisStallExecution(4);

                }

            }

            CurBufAddress++;
            XmitBufAddress++;
            PacketLength--;
            CurBufLen--;

        }

        //
        // Do Write errata as described on pages 1-143 and 1-144 of
        // the 1992 LAN databook
        //

        //
        // Set Count and destination address
        //
        ReadBuffer = XmitBufAddress + ((ULONG_PTR)XmitBufAddress & 1);

        OldAddr = NewAddr = (USHORT)(ReadBuffer);

//      NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND,   // robin
//                            CR_PAGE0                          // robin
//                           );                                 // robin
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                              LSB(PtrToUlong(ReadBuffer))
                             );

        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                              MSB(PtrToUlong(ReadBuffer))
                             );
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                              0x2
                             );
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                              0x0
                             );

        //
        // Set direction (Read)
        //
        NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_COMMAND,
                       CR_START | CR_PAGE0 | CR_DMA_READ
                       );

        if (Adapter->EightBitSlot) {

            //
            // Read from port
            //
            NdisRawReadPortUchar( Adapter->IoPAddr + NIC_RACK_NIC, &Tmp );
            NdisRawReadPortUchar( Adapter->IoPAddr + NIC_RACK_NIC, &Tmp );

        } else {

            //
            // Read from port
            //
            NdisRawReadPortUshort( Adapter->IoPAddr + NIC_RACK_NIC, &TmpShort );

        }

        //
        // Wait for addr to change
        //
        TmpShort = 0xFFFF;

        while (TmpShort != 0) {

            NdisRawReadPortUchar( Adapter->IoPAddr + NIC_CRDA_LSB, &Tmp );
            NewAddr = Tmp;
            NdisRawReadPortUchar( Adapter->IoPAddr + NIC_CRDA_MSB, &Tmp );
            NewAddr |= (Tmp << 8);

            if (NewAddr != OldAddr) {

                break;

            }

            NdisStallExecution(1);

            TmpShort--;
        }

        if (NewAddr == OldAddr) {

            NdisWriteErrorLogEntry(
                Adapter->MiniportAdapterHandle,
                NDIS_ERROR_CODE_HARDWARE_FAILURE,
                2,
                cardCopyDownPacket,
                (ULONG_PTR)XmitBufAddress
                );

            return(FALSE);

        }

        //
        // Set Count and destination address
        //

//      NdisRawWritePortUchar( Adapter->IoPAddr + NIC_COMMAND, CR_PAGE0 ); // robin

        NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                           LSB(PtrToUlong(XmitBufAddress)) );

        NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                           MSB(PtrToUlong(XmitBufAddress)) );

        NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                           LSB(PacketLength) );

        NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                           MSB(PacketLength) );
        //
        // Set direction (Write)
        //
        NdisRawWritePortUchar( Adapter->IoPAddr + NIC_COMMAND,
                       CR_START | CR_PAGE0 | CR_DMA_WRITE );

    } // setup

    //
    // Copy the data now
    //

    do {

        UINT Count;
        UCHAR Tmp;

        //
        // Write the previous byte with this one
        //
        if (OddBufLen) {

            //
            // It seems that the card stores words in LOW:HIGH order
            //
            NdisRawWritePortUshort( Adapter->IoPAddr + NIC_RACK_NIC,
                       (USHORT)(*OddBufAddress | ((*CurBufAddress) << 8)) );

            OddBufLen = FALSE;
            CurBufAddress++;
            CurBufLen--;

        }

        if (Adapter->EightBitSlot) { // byte mode

            NdisRawWritePortBufferUchar(
                Adapter->IoPAddr + NIC_RACK_NIC,
                CurBufAddress,
                CurBufLen
                );

        } else { // word mode

            NdisRawWritePortBufferUshort(
                Adapter->IoPAddr + NIC_RACK_NIC,
                (PUSHORT)CurBufAddress,
                (CurBufLen >> 1));

            //
            // Save trailing byte (if an odd lengthed transfer)
            //
            if (CurBufLen & 0x1) {
                OddBufAddress = CurBufAddress + (CurBufLen - 1);
                OddBufLen = TRUE;
            }

        }

        //
        // Wait for DMA to complete
        //
        Count = 0xFFFF;
        while (Count) {

            NdisRawReadPortUchar(
                Adapter->IoPAddr + NIC_INTR_STATUS,
                &Tmp );

            if (Tmp & ISR_DMA_DONE) {

                break;

            } else {

                Count--;
                NdisStallExecution(4);

            }

        }

        //
        // Move to the next buffer
        //
        NdisGetNextBuffer(CurBuffer, &CurBuffer);

        if (CurBuffer){
            NdisQueryBuffer(CurBuffer, (PVOID *)&CurBufAddress, &CurBufLen);
        }

        //
        // Get address and length of the next buffer
        //
        while (CurBuffer && (CurBufLen == 0)) {

            NdisGetNextBuffer(CurBuffer, &CurBuffer);

            if (CurBuffer){
                NdisQueryBuffer(CurBuffer, (PVOID *)&CurBufAddress, &CurBufLen);
            }

        }

    } while (CurBuffer);

    //
    // Write trailing byte (if necessary)
    //
    if (OddBufLen)
    {
      UINT    Count;
      UCHAR   Tmp;
      USHORT  TmpShort;

      if (NE2000_PCMCIA == Adapter->CardType) {
//  NE2000 PCMCIA CHANGE!!! start
          TmpShort = (USHORT)*OddBufAddress;
          NdisRawWritePortUshort(Adapter->IoPAddr + NIC_RACK_NIC, TmpShort);
//  NE2000 PCMCIA CHANGE!!! end
      }
      else {
          NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RACK_NIC, *OddBufAddress);
      }

      //
      // Wait for DMA to complete                      robin-2
      //
      Count = 0xFFFF;
      while (Count) {

          NdisRawReadPortUchar(
              Adapter->IoPAddr + NIC_INTR_STATUS,
              &Tmp );

          if (Tmp & ISR_DMA_DONE) {
              break;
          } else {
              Count--;
              NdisStallExecution(4);
          }
      }
    }

    //
    // Return length written
    //
    *Length = PacketLength;

    return TRUE;
}

BOOLEAN
CardCopyDown(
    IN PNE2000_ADAPTER Adapter,
    IN PUCHAR TargetBuffer,
    IN PUCHAR SourceBuffer,
    IN UINT Length
    )

/*++

Routine Description:

    Copies Length bytes from the SourceBuffer to the card buffer space
    at card address TargetBuffer.

Arguments:

    Adapter - pointer to the adapter block

    SourceBuffer - Buffer in virtual address space

    TargetBuffer - Buffer in card address space

    Length - number of bytes to transfer to card

Return Value:

    TRUE if the transfer completed with no problems.

--*/

{
    //
    // Temporary place holders for odd alignment transfers
    //
    UCHAR Tmp, TmpSave;
    USHORT TmpShort;

    //
    // Values for waiting for noticing when a DMA completes.
    //
    USHORT OldAddr, NewAddr;

    //
    // Count of transfers to do
    //
    USHORT Count;

    //
    // Address the copy if coming from
    //
    PUCHAR ReadBuffer;


    //
    // Skip 0 length copies
    //

    if (Length == 0) {

        return(TRUE);

    }


    if (!Adapter->EightBitSlot && ((ULONG_PTR)TargetBuffer & 0x1)) {

        //
        // For odd addresses we need to read first to get the previous
        // byte and then merge it with our first byte.
        //

        //
        // Set Count and Source address
        //
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
            LSB(PtrToUlong(TargetBuffer - 1))
        );

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
            MSB(PtrToUlong(TargetBuffer - 1))
        );

// NE2000 PCMCIA CHANGE!!!  start
        //NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x1);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0);
// NE2000 PCMCIA CHANGE!!!  end

        //
        // Set direction (Read)
        //

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_COMMAND,
            CR_START | CR_PAGE0 | CR_DMA_READ
        );

// NE2000 PCMCIA CHANGE!!!  start
        //NdisRawReadPortUchar(Adapter->IoPAddr + NIC_RACK_NIC, &TmpSave);
        NdisRawReadPortUshort(Adapter->IoPAddr + NIC_RACK_NIC, &TmpShort);
        TmpSave = LSB(TmpShort);
// NE2000 PCMCIA CHANGE!!!  end

        //
        // Do Write errata as described on pages 1-143 and 1-144 of the 1992
        // LAN databook
        //

        //
        // Set Count and destination address
        //

        ReadBuffer = TargetBuffer + ((ULONG_PTR)TargetBuffer & 1);

        OldAddr = NewAddr = (USHORT)(ReadBuffer);

//      NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_PAGE0); // robin

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
            LSB(PtrToUlong(ReadBuffer))
        );

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
            MSB(PtrToUlong(ReadBuffer))
        );

        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0);

        //
        // Set direction (Read)
        //

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_COMMAND,
            CR_START | CR_PAGE0 | CR_DMA_READ
        );

        //
        // Read from port
        //

        NdisRawReadPortUshort(Adapter->IoPAddr + NIC_RACK_NIC, &TmpShort);

        //
        // Wait for addr to change
        //

        TmpShort = 0xFFFF;

        while (TmpShort != 0) {

            NdisRawReadPortUchar(
                          Adapter->IoPAddr + NIC_CRDA_LSB,
                          &Tmp
                         );

            NewAddr = Tmp;

            NdisRawReadPortUchar(
                          Adapter->IoPAddr + NIC_CRDA_MSB,
                          &Tmp
                         );

            NewAddr |= (Tmp << 8);

            if (NewAddr != OldAddr) {

                break;
            }

            NdisStallExecution(1);

            TmpShort--;

        }

        if (NewAddr == OldAddr) {

            return(FALSE);

        }

        //
        // Set Count and destination address
        //
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
            LSB(PtrToUlong(TargetBuffer - 1))
        );

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
            MSB(PtrToUlong(TargetBuffer - 1))
        );

        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0);

        //
        // Set direction (Write)
        //

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_COMMAND,
            CR_START | CR_PAGE0 | CR_DMA_WRITE
        );

        //
        // It seems that the card stores words in LOW:HIGH order
        //

        NdisRawWritePortUshort(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       (USHORT)(TmpSave | ((*SourceBuffer) << 8))
                       );

        //
        // Wait for DMA to complete
        //

        Count = 0xFFFF;

        while (Count) {

            NdisRawReadPortUchar(
                          Adapter->IoPAddr + NIC_INTR_STATUS,
                          &Tmp
                         );

            if (Tmp & ISR_DMA_DONE) {

                break;

            } else {

                Count--;

                NdisStallExecution(4);

            }

        }

        SourceBuffer++;
        TargetBuffer++;
        Length--;

    }

    //
    // Do Write errata as described on pages 1-143 and 1-144 of the 1992
    // LAN databook
    //

    //
    // Set Count and destination address
    //

    ReadBuffer = TargetBuffer + ((ULONG_PTR)TargetBuffer & 1);

    OldAddr = NewAddr = (USHORT)(ReadBuffer);

//  NdisRawWritePortUchar(                              // robin
//                     Adapter->IoPAddr + NIC_COMMAND,  // robin
//                     CR_PAGE0                         // robin
//                    );                                // robin

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                       LSB(PtrToUlong(ReadBuffer))
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                       MSB(PtrToUlong(ReadBuffer))
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                       0x2
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                       0x0
                      );

    //
    // Set direction (Read)
    //

    NdisRawWritePortUchar(
                   Adapter->IoPAddr + NIC_COMMAND,
                   CR_START | CR_PAGE0 | CR_DMA_READ
                  );

    if (Adapter->EightBitSlot) {

        //
        // Read from port
        //

        NdisRawReadPortUchar(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       &Tmp
                      );


        NdisRawReadPortUchar(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       &Tmp
                      );

    } else {

        //
        // Read from port
        //

        NdisRawReadPortUshort(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       &TmpShort
                      );

    }

    //
    // Wait for addr to change
    //

    TmpShort = 0xFFFF;

    while (TmpShort != 0) {

        NdisRawReadPortUchar(
                      Adapter->IoPAddr + NIC_CRDA_LSB,
                      &Tmp
                     );

        NewAddr = Tmp;

        NdisRawReadPortUchar(
                      Adapter->IoPAddr + NIC_CRDA_MSB,
                      &Tmp
                     );

        NewAddr |= (Tmp << 8);

        if (NewAddr != OldAddr) {

            break;
        }

        NdisStallExecution(1);

        TmpShort--;

    }

    if (NewAddr == OldAddr) {

        return(FALSE);

    }

    //
    // Set Count and destination address
    //

//  NdisRawWritePortUchar(                              // robin
//                     Adapter->IoPAddr + NIC_COMMAND,  // robin
//                     CR_PAGE0                         // robin
//                    );                                // robin

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                       LSB(PtrToUlong(TargetBuffer))
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                       MSB(PtrToUlong(TargetBuffer))
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                       LSB(Length)
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                       MSB(Length)
                      );

    //
    // Set direction (Write)
    //

    NdisRawWritePortUchar(
                   Adapter->IoPAddr + NIC_COMMAND,
                   CR_START | CR_PAGE0 | CR_DMA_WRITE
                  );

    if (Adapter->EightBitSlot) {

        //
        // Repeatedly write to out port
        //

        NdisRawWritePortBufferUchar(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       SourceBuffer,
                       Length);

    } else {

        //
        // Write words to out ports
        //

        NdisRawWritePortBufferUshort(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       (PUSHORT)SourceBuffer,
                       (Length >> 1));

        //
        // Write trailing byte (if necessary)
        //
        if (Length & 0x1)
        {
            SourceBuffer += (Length - 1);

// NE2000 PCMCIA CHANGE!!!  start

            //NdisRawWritePortUchar(
            //    Adapter->IoPAddr + NIC_RACK_NIC,
            //    *SourceBuffer
            //);

            TmpShort = (USHORT)(*SourceBuffer);
            NdisRawWritePortUshort(
                Adapter->IoPAddr + NIC_RACK_NIC,
                TmpShort
            );
// NE2000 PCMCIA CHANGE!!!  end


        }

    }

    //
    // Wait for DMA to complete
    //

    Count = 0xFFFF;

    while (Count) {

        NdisRawReadPortUchar(
                      Adapter->IoPAddr + NIC_INTR_STATUS,
                      &Tmp
                     );

        if (Tmp & ISR_DMA_DONE) {

            break;

        } else {

            Count--;

            NdisStallExecution(4);

        }

#if DBG
        if (!(Tmp & ISR_DMA_DONE)) {

            DbgPrint("CopyDownDMA didn't finish!");

        }
#endif // DBG

    }

    IF_LOG(Ne2000Log('>');)

    return TRUE;
}


BOOLEAN
CardCopyUp(
    IN PNE2000_ADAPTER Adapter,
    IN PUCHAR TargetBuffer,
    IN PUCHAR SourceBuffer,
    IN UINT BufferLength
    )

/*++

Routine Description:

    Copies data from the card to memory.

Arguments:

    Adapter - pointer to the adapter block

    Target - the target address

    Source - the source address (on the card)

    BufferLength - the number of bytes to copy

Return Value:

    TRUE if the transfer completed with no problems.

--*/

{

    //
    // Used to check when the dma is done
    //
    UCHAR IsrValue;

    //
    // Count of the number of transfers to do
    //
    USHORT Count;

    //
    // Place holder for port values
    //
    UCHAR Temp;

    if (BufferLength == 0) {

        return TRUE;

    }

    //
    // Read the Command Register, to make sure it is ready for a write
    //
    NdisRawReadPortUchar(Adapter->IoPAddr+NIC_COMMAND, &Temp);

    if (Adapter->EightBitSlot) {

        //
        // If byte mode
        //

        //
        // Set Count and destination address
        //

//      NdisRawWritePortUchar(                               // robin
//                         Adapter->IoPAddr + NIC_COMMAND,   // robin
//                         CR_PAGE0                          // robin
//                        );                                 // robin

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                           LSB(PtrToUlong(SourceBuffer))
                          );

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                           MSB(PtrToUlong(SourceBuffer))
                          );

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                           LSB(BufferLength)
                          );

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                           MSB(BufferLength)
                          );

        //
        // Set direction (Read)
        //

        NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_COMMAND,
                       CR_START | CR_PAGE0 | CR_DMA_READ
                      );
        //
        // Repeatedly read from port
        //

        NdisRawReadPortBufferUchar(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       TargetBuffer,
                       BufferLength
                      );

    } else {

        //
        // Else word mode
        //

        USHORT Tmp;

//      NdisRawWritePortUchar(                                   // robin
//                             Adapter->IoPAddr + NIC_COMMAND,   // robin
//                             CR_PAGE0                          // robin
//                            );                                 // robin

        //
        // Avoid transfers to odd addresses
        //

        if ((ULONG_PTR)SourceBuffer & 0x1) {

            //
            // For odd addresses we need to read previous word and store the
            // second byte
            //

            //
            // Set Count and Source address
            //

            NdisRawWritePortUchar(
                               Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                               LSB(PtrToUlong(SourceBuffer - 1))
                              );

            NdisRawWritePortUchar(
                               Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                               MSB(PtrToUlong(SourceBuffer - 1))
                              );

            NdisRawWritePortUchar(
                               Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                               0x2
                              );

            NdisRawWritePortUchar(
                               Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                               0x0
                              );

            //
            // Set direction (Read)
            //

            NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_COMMAND,
                           CR_START | CR_PAGE0 | CR_DMA_READ
                          );

            NdisRawReadPortUshort(
                           Adapter->IoPAddr + NIC_RACK_NIC,
                           &Tmp
                           );

            *TargetBuffer = MSB(Tmp);

            //
            // Wait for DMA to complete
            //

            Count = 0xFFFF;

            while (Count) {

                NdisRawReadPortUchar(
                              Adapter->IoPAddr + NIC_INTR_STATUS,
                              &IsrValue
                             );

                if (IsrValue & ISR_DMA_DONE) {

                    break;

                } else {

                    Count--;

                    NdisStallExecution(4);

                }

#if DBG
                if (!(IsrValue & ISR_DMA_DONE)) {

                    DbgPrint("CopyUpDMA didn't finish!");

                }
#endif // DBG

            }

            SourceBuffer++;
            TargetBuffer++;
            BufferLength--;
        }

        //
        // Set Count and destination address
        //

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                           LSB(PtrToUlong(SourceBuffer))
                          );

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                           MSB(PtrToUlong(SourceBuffer))
                          );

// NE2000 PCMCIA CHANGE!!!  start

//        NdisRawWritePortUchar(
//            Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
//            LSB(BufferLength)
//        );
//
//        NdisRawWritePortUchar(
//            Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
//            MSB(BufferLength)
//        );

        if (BufferLength & 1)
        {
            NdisRawWritePortUchar(
                Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                LSB(BufferLength + 1)
            );

            NdisRawWritePortUchar(
                Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                MSB(BufferLength + 1)
            );
        }
        else
        {
            NdisRawWritePortUchar(
                Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                LSB(BufferLength)
            );

            NdisRawWritePortUchar(
                Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                MSB(BufferLength)
            );
        }

// NE2000 PCMCIA CHANGE!!!  end


        //
        // Set direction (Read)
        //

        NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_COMMAND,
                       CR_START | CR_PAGE0 | CR_DMA_READ
                      );

        //
        // Read words from port
        //

        NdisRawReadPortBufferUshort(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       (PUSHORT)TargetBuffer,
                       (BufferLength >> 1));

        //
        // Read trailing byte (if necessary)
        //

        if (BufferLength & 1) {

            TargetBuffer += (BufferLength - 1);

// NE2000 PCMCIA CHANGE!!!  start

            //NdisRawReadPortUchar(
            //    Adapter->IoPAddr + NIC_RACK_NIC,
            //    TargetBuffer
            //);

            NdisRawReadPortUshort(
                Adapter->IoPAddr + NIC_RACK_NIC,
                &Tmp
            );

            *TargetBuffer = LSB(Tmp);

// NE2000 PCMCIA CHANGE!!!  end
        }

    }

    //
    // Wait for DMA to complete
    //

    Count = 0xFFFF;

    while (Count) {

        NdisRawReadPortUchar(
                      Adapter->IoPAddr + NIC_INTR_STATUS,
                      &IsrValue
                     );

        if (IsrValue & ISR_DMA_DONE) {

            break;

        } else {

            Count--;

            NdisStallExecution(4);

        }

    }

#if DBG
    if (!(IsrValue & ISR_DMA_DONE)) {

        DbgPrint("CopyUpDMA didn't finish!\n");

    }

    IF_LOG(Ne2000Log('<');)

#endif // DBG

    return TRUE;

}

ULONG
CardComputeCrc(
    IN PUCHAR Buffer,
    IN UINT Length
    )

/*++

Routine Description:

    Runs the AUTODIN II CRC algorithm on buffer Buffer of
    length Length.

Arguments:

    Buffer - the input buffer

    Length - the length of Buffer

Return Value:

    The 32-bit CRC value.

Note:

    This is adapted from the comments in the assembly language
    version in _GENREQ.ASM of the DWB NE1000/2000 driver.

--*/

{
    ULONG Crc, Carry;
    UINT i, j;
    UCHAR CurByte;

    Crc = 0xffffffff;

    for (i = 0; i < Length; i++) {

        CurByte = Buffer[i];

        for (j = 0; j < 8; j++) {

            Carry = ((Crc & 0x80000000) ? 1 : 0) ^ (CurByte & 0x01);

            Crc <<= 1;

            CurByte >>= 1;

            if (Carry) {

                Crc = (Crc ^ 0x04c11db6) | Carry;

            }

        }

    }

    return Crc;

}


VOID
CardGetMulticastBit(
    IN UCHAR Address[NE2000_LENGTH_OF_ADDRESS],
    OUT UCHAR * Byte,
    OUT UCHAR * Value
    )

/*++

Routine Description:

    For a given multicast address, returns the byte and bit in
    the card multicast registers that it hashes to. Calls
    CardComputeCrc() to determine the CRC value.

Arguments:

    Address - the address

    Byte - the byte that it hashes to

    Value - will have a 1 in the relevant bit

Return Value:

    None.

--*/

{
    ULONG Crc;
    UINT BitNumber;

    //
    // First compute the CRC.
    //

    Crc = CardComputeCrc(Address, NE2000_LENGTH_OF_ADDRESS);


    //
    // The bit number is now in the 6 most significant bits of CRC.
    //

    BitNumber = (UINT)((Crc >> 26) & 0x3f);

    *Byte = (UCHAR)(BitNumber / 8);
    *Value = (UCHAR)((UCHAR)1 << (BitNumber % 8));
}

VOID
CardFillMulticastRegs(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Erases and refills the card multicast registers. Used when
    an address has been deleted and all bits must be recomputed.

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    None.

--*/

{
    UINT i;
    UCHAR Byte, Bit;

    //
    // First turn all bits off.
    //

    for (i=0; i<8; i++) {

        Adapter->NicMulticastRegs[i] = 0;

    }

    //
    // Now turn on the bit for each address in the multicast list.
    //

    for ( ; i > 0; ) {

        i--;

        CardGetMulticastBit(Adapter->Addresses[i], &Byte, &Bit);

        Adapter->NicMulticastRegs[Byte] |= Bit;

    }

}








BOOLEAN SyncCardStop(
    IN PVOID SynchronizeContext
)

/*++

Routine Description:

    Sets the NIC_COMMAND register to stop the card.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    TRUE if the power has failed.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_STOP | CR_NO_DMA
    );

    return(FALSE);
}

VOID
CardStartXmit(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Sets the NIC_COMMAND register to start a transmission.
    The transmit buffer number is taken from Adapter->CurBufXmitting
    and the length from Adapter->PacketLens[Adapter->CurBufXmitting].

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    TRUE if the power has failed.

--*/

{
    UINT Length = Adapter->PacketLens[Adapter->CurBufXmitting];
    UCHAR Tmp;

    //
    // Prepare the NIC registers for transmission.
    //

    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_XMIT_START,
        (UCHAR)(Adapter->NicXmitStart + (UCHAR)(Adapter->CurBufXmitting*BUFS_PER_TX)));

    //
    // Pad the length to 60 (plus CRC will be 64) if needed.
    //

    if (Length < 60) {

        Length = 60;

    }

    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_XMIT_COUNT_MSB, MSB(Length));
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_XMIT_COUNT_LSB, LSB(Length));

    //
    // Start transmission, check for power failure first.
    //

    NdisRawReadPortUchar(Adapter->IoPAddr+NIC_COMMAND, &Tmp);
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_COMMAND,
            CR_START | CR_XMIT | CR_NO_DMA);

    IF_LOG( Ne2000Log('x');)

}

BOOLEAN
SyncCardGetCurrent(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Gets the value of the CURRENT NIC register and stores it in Adapter->Current

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);

    //
    // Have to go to page 1 to read this register
    //

    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_COMMAND,
                       CR_START | CR_NO_DMA | CR_PAGE1);

    NdisRawReadPortUchar(Adapter->IoPAddr+NIC_CURRENT,
                       &Adapter->Current);

    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_COMMAND,
                       CR_START | CR_NO_DMA | CR_PAGE0);

    return FALSE;

}

BOOLEAN
SyncCardGetXmitStatus(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Gets the value of the "transmit status" NIC register and stores
    it in Adapter->XmitStatus.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);

    NdisRawReadPortUchar( Adapter->IoPAddr+NIC_XMIT_STATUS, &Adapter->XmitStatus);

    return FALSE;

}

VOID
CardSetBoundary(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Sets the value of the "boundary" NIC register to one behind
    Adapter->NicNextPacket, to prevent packets from being received
    on top of un-indicated ones.

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    None.

--*/

{
    //
    // Have to be careful with "one behind NicNextPacket" when
    // NicNextPacket is the first buffer in receive area.
    //

    if (Adapter->NicNextPacket == Adapter->NicPageStart) {

        NdisRawWritePortUchar( Adapter->IoPAddr+NIC_BOUNDARY,
                    (UCHAR)(Adapter->NicPageStop-(UCHAR)1));

    } else {

        NdisRawWritePortUchar( Adapter->IoPAddr+NIC_BOUNDARY,
                    (UCHAR)(Adapter->NicNextPacket-(UCHAR)1));

    }

}

BOOLEAN
SyncCardSetReceiveConfig(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Sets the value of the "receive configuration" NIC register to
    the value of Adapter->NicReceiveConfig.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_RCV_CONFIG, Adapter->NicReceiveConfig);

    return FALSE;

}

BOOLEAN
SyncCardSetAllMulticast(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Turns on all the bits in the multicast register. Used when
    the card must receive all multicast packets.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);
    UINT i;

    //
    // Have to move to page 1 to set these registers.
    //

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_COMMAND,
                    CR_START | CR_NO_DMA | CR_PAGE1);

    for (i=0; i<8; i++) {

        NdisRawWritePortUchar( Adapter->IoPAddr+(NIC_MC_ADDR+i), 0xff);

    }

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_COMMAND,
                    CR_START | CR_NO_DMA | CR_PAGE0);

    return FALSE;

}

BOOLEAN
SyncCardCopyMulticastRegs(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Sets the eight bytes in the card multicast registers.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);
    UINT i;

    //
    // Have to move to page 1 to set these registers.
    //

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_COMMAND,
                    CR_START | CR_NO_DMA | CR_PAGE1);

    for (i=0; i<8; i++) {

        NdisRawWritePortUchar( Adapter->IoPAddr+(NIC_MC_ADDR+i),
                        Adapter->NicMulticastRegs[i]);

    }

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_COMMAND,
                    CR_START | CR_NO_DMA | CR_PAGE0);

    return FALSE;

}

BOOLEAN
SyncCardAcknowledgeOverflow(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Sets the "buffer overflow" bit in the NIC interrupt status register,
    which re-enables interrupts of that type.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);
    UCHAR AcknowledgeMask = 0;

    if (Adapter->InterruptStatus & ISR_RCV_ERR) {

        SyncCardUpdateCounters(Adapter);

    }

    return FALSE;

}

BOOLEAN
SyncCardUpdateCounters(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Updates the values of the three counters (frame alignment errors,
    CRC errors, and missed packets).

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);
    UCHAR Tmp;

    NdisRawReadPortUchar( Adapter->IoPAddr+NIC_FAE_ERR_CNTR, &Tmp);
    Adapter->FrameAlignmentErrors += Tmp;

    NdisRawReadPortUchar( Adapter->IoPAddr+NIC_CRC_ERR_CNTR, &Tmp);
    Adapter->CrcErrors += Tmp;

    NdisRawReadPortUchar( Adapter->IoPAddr+NIC_MISSED_CNTR, &Tmp);
    Adapter->MissedPackets += Tmp;

    return FALSE;

}

BOOLEAN
SyncCardHandleOverflow(
    IN PVOID SynchronizeContext
    )

/*++<

Routine Description:

    Sets all the flags for dealing with a receive overflow, stops the card
    and acknowledges all outstanding interrupts.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);
    UCHAR Status;

    IF_LOG( Ne2000Log('F');)

    //
    // Turn on the STOP bit in the Command register.
    //

    SyncCardStop(Adapter);

    //
    // Wait for ISR_RESET, but only for 1.6 milliseconds (as
    // described in the March 1991 8390 addendum), since that
    // is the maximum time for a software reset to occur.
    //
    //

    NdisStallExecution(2000);

    //
    // Save whether we were transmitting to avoid a timing problem
    // where an indication resulted in a send.
    //

    if (!(Adapter->InterruptStatus & (ISR_XMIT | ISR_XMIT_ERR))) {

        CardGetInterruptStatus(Adapter,&Status);
        if (!(Status & (ISR_XMIT | ISR_XMIT_ERR))) {

            Adapter->OverflowRestartXmitDpc = Adapter->TransmitInterruptPending;

            IF_LOUD( DbgPrint("ORXD=%x\n",Adapter->OverflowRestartXmitDpc); )
        }

    }

    Adapter->TransmitInterruptPending = FALSE;

    //
    // Clear the Remote Byte Count register so that ISR_RESET
    // will come on.
    //

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_RMT_COUNT_MSB, 0);
    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_RMT_COUNT_LSB, 0);

    //
    // According to National Semiconductor, the next check is necessary
    // See Step 5. of the overflow process
    //
    // NOTE: The setting of variables to check if the transmit has completed
    // cannot be done here because anything in the ISR has already been ack'ed
    // inside the main DPC.  Thus, the setting of the variables, described in
    // the Handbook was moved to the main DPC.
    //
    // Continued: If you did the check here, you will doubly transmit most
    // packets that happened to be on the card when the overflow occurred.
    //

    //
    // Put the card in loopback mode, then start it.
    //

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_XMIT_CONFIG, TCR_LOOPBACK);

    //
    // Start the card.  This does not Undo the loopback mode.
    //

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_COMMAND, CR_START | CR_NO_DMA);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\ne2000\ne2000.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved.

Module Name:

    ne2000.c

Abstract:

    This is the main file for the Novel 2000 Ethernet controller.
    This driver conforms to the NDIS 3.0 miniport interface.

Author:

    Sean Selitrennikoff (Dec 1993)

Environment:

Revision History:

--*/

#include "precomp.h"


//
// On debug builds tell the compiler to keep the symbols for
// internal functions, otw throw them out.
//
#if DBG
#define STATIC
#else
#define STATIC static
#endif

//
// Debugging definitions
//
#if DBG

//
// Default debug mode
//
ULONG Ne2000DebugFlag = NE2000_DEBUG_LOG;

//
// Debug tracing defintions
//
#define NE2000_LOG_SIZE 256
UCHAR Ne2000LogBuffer[NE2000_LOG_SIZE]={0};
UINT Ne2000LogLoc = 0;

extern
VOID
Ne2000Log(UCHAR c) {

    Ne2000LogBuffer[Ne2000LogLoc++] = c;

    Ne2000LogBuffer[(Ne2000LogLoc + 4) % NE2000_LOG_SIZE] = '\0';

    if (Ne2000LogLoc >= NE2000_LOG_SIZE)
        Ne2000LogLoc = 0;
}

#endif



//
// The global Miniport driver block.
//

DRIVER_BLOCK Ne2000MiniportBlock={0};

//
// List of supported OID for this driver.
//
STATIC UINT Ne2000SupportedOids[] = {
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_ID,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS
    };

//
// Determines whether failing the initial card test will prevent
// the adapter from being registered.
//
#ifdef CARD_TEST

BOOLEAN InitialCardTest = TRUE;

#else  // CARD_TEST

BOOLEAN InitialCardTest = FALSE;

#endif // CARD_TEST

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#pragma NDIS_INIT_FUNCTION(DriverEntry)


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the primary initialization routine for the NE2000 driver.
    It is simply responsible for the intializing the wrapper and registering
    the Miniport driver.  It then calls a system and architecture specific
    routine that will initialize and register each adapter.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - Path to the parameters for this driver in the registry.

Return Value:

    The status of the operation.

--*/

{


    //
    // Receives the status of the NdisMRegisterMiniport operation.
    //
    NDIS_STATUS Status;

    //
    // Characteristics table for this driver.
    //
    NDIS_MINIPORT_CHARACTERISTICS NE2000Char;

    //
    // Pointer to the global information for this driver
    //
    PDRIVER_BLOCK NewDriver = &Ne2000MiniportBlock;

    //
    // Handle for referring to the wrapper about this driver.
    //
    NDIS_HANDLE NdisWrapperHandle;

    //
    // Initialize the wrapper.
    //
    NdisMInitializeWrapper(
                &NdisWrapperHandle,
                DriverObject,
                RegistryPath,
                NULL
                );

    //
    // Save the global information about this driver.
    //
    NewDriver->NdisWrapperHandle = NdisWrapperHandle;
    NewDriver->AdapterQueue = (PNE2000_ADAPTER)NULL;

    //
    // Initialize the Miniport characteristics for the call to
    // NdisMRegisterMiniport.
    //
    NE2000Char.MajorNdisVersion = NE2000_NDIS_MAJOR_VERSION;
    NE2000Char.MinorNdisVersion = NE2000_NDIS_MINOR_VERSION;
    NE2000Char.CheckForHangHandler = NULL;
    NE2000Char.DisableInterruptHandler = Ne2000DisableInterrupt;
    NE2000Char.EnableInterruptHandler = Ne2000EnableInterrupt;
    NE2000Char.HaltHandler = Ne2000Halt;
    NE2000Char.HandleInterruptHandler = Ne2000HandleInterrupt;
    NE2000Char.InitializeHandler = Ne2000Initialize;
    NE2000Char.ISRHandler = Ne2000Isr;
    NE2000Char.QueryInformationHandler = Ne2000QueryInformation;
    NE2000Char.ReconfigureHandler = NULL;
    NE2000Char.ResetHandler = Ne2000Reset;
    NE2000Char.SendHandler = Ne2000Send;
    NE2000Char.SetInformationHandler = Ne2000SetInformation;
    NE2000Char.TransferDataHandler = Ne2000TransferData;

    Status = NdisMRegisterMiniport(
                 NdisWrapperHandle,
                 &NE2000Char,
                 sizeof(NE2000Char)
                 );

    if (Status == NDIS_STATUS_SUCCESS) {

        return STATUS_SUCCESS;

    }

    return STATUS_UNSUCCESSFUL;

}


#pragma NDIS_PAGEABLE_FUNCTION(Ne2000Initialize)
extern
NDIS_STATUS
Ne2000Initialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE ConfigurationHandle
    )

/*++

Routine Description:

    Ne2000Initialize starts an adapter and registers resources with the
    wrapper.

Arguments:

    OpenErrorStatus - Extra status bytes for opening token ring adapters.

    SelectedMediumIndex - Index of the media type chosen by the driver.

    MediumArray - Array of media types for the driver to chose from.

    MediumArraySize - Number of entries in the array.

    MiniportAdapterHandle - Handle for passing to the wrapper when
       referring to this adapter.

    ConfigurationHandle - A handle to pass to NdisOpenConfiguration.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING

--*/

{
    //
    // Pointer to our newly allocated adapter.
    //
    PNE2000_ADAPTER Adapter;

    //
    // The handle for reading from the registry.
    //
    NDIS_HANDLE ConfigHandle;

    //
    // The value read from the registry.
    //
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;

    //
    // String names of all the parameters that will be read.
    //
    NDIS_STRING IOAddressStr = NDIS_STRING_CONST("IoBaseAddress");
    NDIS_STRING InterruptStr = NDIS_STRING_CONST("InterruptNumber");
    NDIS_STRING MaxMulticastListStr = NDIS_STRING_CONST("MaximumMulticastList");
    NDIS_STRING NetworkAddressStr = NDIS_STRING_CONST("NetworkAddress");
    NDIS_STRING BusTypeStr = NDIS_STRING_CONST("BusType");
    NDIS_STRING CardTypeStr = NDIS_STRING_CONST("CardType");

    //
    // TRUE if there is a configuration error.
    //
    BOOLEAN ConfigError = FALSE;

    //
    // A special value to log concerning the error.
    //
    ULONG ConfigErrorValue = 0;

    //
    // The slot number the adapter is located in, used for
    // Microchannel adapters.
    //
    UINT SlotNumber = 0;

    //
    // TRUE if it is unnecessary to read the Io Base Address
    // and Interrupt from the registry.  Used for Microchannel
    // adapters, which get this information from the slot
    // information.
    //
    BOOLEAN SkipIobaseAndInterrupt = FALSE;

    //
    // The network address the adapter should use instead of the
    // the default burned in address.
    //
    PVOID NetAddress;

    //
    // The number of bytes in the address.  It should be
    // NE2000_LENGTH_OF_ADDRESS
    //
    ULONG Length;

    //
    // These are used when calling Ne2000RegisterAdapter.
    //

    //
    // The physical address of the base I/O port.
    //
    PVOID IoBaseAddr;

    //
    // The interrupt number to use.
    //
    CCHAR InterruptNumber;

    //
    // The number of multicast address to be supported.
    //
    UINT MaxMulticastList;

    //
    // Temporary looping variable.
    //
    ULONG i;

    //
    // Status of Ndis calls.
    //
    NDIS_STATUS Status;

    NDIS_MCA_POS_DATA McaData;

    //
    // Search for the medium type (802.3) in the given array.
    //
    for (i = 0; i < MediumArraySize; i++){

        if (MediumArray[i] == NdisMedium802_3){

            break;

        }

    }

    if (i == MediumArraySize){

        return( NDIS_STATUS_UNSUPPORTED_MEDIA );

    }

    *SelectedMediumIndex = i;


    //
    // Set default values.
    //
    IoBaseAddr = DEFAULT_IOBASEADDR;
    InterruptNumber = DEFAULT_INTERRUPTNUMBER;
    MaxMulticastList = DEFAULT_MULTICASTLISTMAX;

    //
    // Allocate memory for the adapter block now.
    //
    Status = NdisAllocateMemoryWithTag( (PVOID *)&Adapter,
                   sizeof(NE2000_ADAPTER),
                   'k2EN'
                   );

    if (Status != NDIS_STATUS_SUCCESS) {

        return Status;

    }

    //
    // Clear out the adapter block, which sets all default values to FALSE,
    // or NULL.
    //
    NdisZeroMemory (Adapter, sizeof(NE2000_ADAPTER));

    //
    // Open the configuration space.
    //
    NdisOpenConfiguration(
            &Status,
            &ConfigHandle,
            ConfigurationHandle
            );

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisFreeMemory(Adapter, sizeof(NE2000_ADAPTER), 0);

        return Status;

    }

    //
    //  Read in the card type.
    //
    Adapter->CardType = NE2000_ISA;

    NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigHandle,
            &CardTypeStr,
            NdisParameterHexInteger
            );
    if (Status == NDIS_STATUS_SUCCESS)
        Adapter->CardType = (UINT)ReturnedValue->ParameterData.IntegerData;

    //
    // Read net address
    //
    NdisReadNetworkAddress(
                    &Status,
                    &NetAddress,
                    &Length,
                    ConfigHandle
                    );

    if ((Length == NE2000_LENGTH_OF_ADDRESS) && (Status == NDIS_STATUS_SUCCESS)) {

        //
        // Save the address that should be used.
        //
        NdisMoveMemory(
                Adapter->StationAddress,
                NetAddress,
                NE2000_LENGTH_OF_ADDRESS
                );

    }

    //
    // Disallow multiple adapters in the same MP machine because of hardware
    // problems this results in random packet corruption.
    //
    if ((NdisSystemProcessorCount() > 1) && (Ne2000MiniportBlock.AdapterQueue != NULL)) {

        ConfigError = TRUE;
        ConfigErrorValue = (ULONG)NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION;
        goto RegisterAdapter;

        return NDIS_STATUS_FAILURE;

    }


    //
    // Read Bus Type (for NE2/AE2 support)
    //
    Adapter->BusType = NdisInterfaceIsa;

    NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigHandle,
            &BusTypeStr,
            NdisParameterHexInteger
            );

    if (Status == NDIS_STATUS_SUCCESS) {

        Adapter->BusType = (UCHAR)ReturnedValue->ParameterData.IntegerData;

    }

    if (!SkipIobaseAndInterrupt) {
        //
        // Read I/O Address
        //
        NdisReadConfiguration(
                &Status,
                &ReturnedValue,
                ConfigHandle,
                &IOAddressStr,
                NdisParameterHexInteger
                );

        if (Status == NDIS_STATUS_SUCCESS) {

            IoBaseAddr = UlongToPtr(ReturnedValue->ParameterData.IntegerData);

        }

        if (Adapter->BusType != NdisInterfacePcMcia)
        {
            //
            // Check that the value is valid.
            //
            if ((IoBaseAddr < (PVOID)MIN_IOBASEADDR) ||
                (IoBaseAddr > (PVOID)MAX_IOBASEADDR)) {

                ConfigError = TRUE;
                ConfigErrorValue = PtrToUlong(IoBaseAddr);
                goto RegisterAdapter;

            }
        }

        //
        // Read interrupt number
        //
        NdisReadConfiguration(
                &Status,
                &ReturnedValue,
                ConfigHandle,
                &InterruptStr,
                NdisParameterHexInteger
                );


        if (Status == NDIS_STATUS_SUCCESS) {

            InterruptNumber = (CCHAR)(ReturnedValue->ParameterData.IntegerData);

        }

        //
        // Verify that the value is valid.
        //
        if ((InterruptNumber < MIN_IRQ) ||
            (InterruptNumber > MAX_IRQ)) {

            ConfigError = TRUE;
            ConfigErrorValue = (ULONG)InterruptNumber;
            goto RegisterAdapter;

        }

        //
        //  If the adapter is a pcmcia card then get the memory window
        //  address for later use.
        //
        if (NE2000_PCMCIA == Adapter->CardType)
        {
#if 0
            NDIS_STRING AttributeMemoryAddrStr =
                            NDIS_STRING_CONST("MemoryMappedBaseAddress");
            NDIS_STRING AttributeMemorySizeStr =
                            NDIS_STRING_CONST("PCCARDAttributeMemorySize");

            //
            //  Read the attribute memory address.
            //
            Adapter->AttributeMemoryAddress = 0xd4000;

            NdisReadConfiguration(
                &Status,
                &ReturnedValue,
                ConfigHandle,
                &AttributeMemoryAddrStr,
                NdisParameterHexInteger
            );
            if (NDIS_STATUS_SUCCESS == Status)
            {
                Adapter->AttributeMemoryAddress =
                            (ULONG)ReturnedValue->ParameterData.IntegerData;
            }

            //
            //  Read the size of the attribute memory range.
            //
            Adapter->AttributeMemorySize = 0x1000;

            NdisReadConfiguration(
                &Status,
                &ReturnedValue,
                ConfigHandle,
                &AttributeMemorySizeStr,
                NdisParameterHexInteger
            );
            if (NDIS_STATUS_SUCCESS == Status)
            {
                Adapter->AttributeMemorySize =
                            (ULONG)ReturnedValue->ParameterData.IntegerData;
            }
#endif

        }
    }

    //
    // Read MaxMulticastList
    //
    NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigHandle,
            &MaxMulticastListStr,
            NdisParameterInteger
            );

    if (Status == NDIS_STATUS_SUCCESS) {

        MaxMulticastList = ReturnedValue->ParameterData.IntegerData;
        if (ReturnedValue->ParameterData.IntegerData <= DEFAULT_MULTICASTLISTMAX)
            MaxMulticastList = ReturnedValue->ParameterData.IntegerData;
    }


RegisterAdapter:

    //
    // Now to use this information and register with the wrapper
    // and initialize the adapter.
    //

    //
    // First close the configuration space.
    //
    NdisCloseConfiguration(ConfigHandle);

    IF_LOUD( DbgPrint(
        "Registering adapter # buffers %ld\n"
        "Card type: 0x%x\n"
        "I/O base addr 0x%lx\n"
        "interrupt number %ld\n"
        "max multicast %ld\nattribute memory address 0x%X\n"
        "attribute memory size 0x%X\n"
        "CardType: %d\n",
        DEFAULT_NUMBUFFERS,
        Adapter->CardType,
        IoBaseAddr,
        InterruptNumber,
        DEFAULT_MULTICASTLISTMAX,
        Adapter->AttributeMemoryAddress,
        Adapter->AttributeMemorySize,
        Adapter->CardType );)



    //
    // Set up the parameters.
    //
    Adapter->NumBuffers = DEFAULT_NUMBUFFERS;
    Adapter->IoBaseAddr = IoBaseAddr;

    Adapter->InterruptNumber = InterruptNumber;

    Adapter->MulticastListMax = MaxMulticastList;
    Adapter->MiniportAdapterHandle = MiniportAdapterHandle;

    Adapter->MaxLookAhead = NE2000_MAX_LOOKAHEAD;

    //
    // Now do the work.
    //
    if (Ne2000RegisterAdapter(Adapter,
          ConfigurationHandle,
          ConfigError,
          ConfigErrorValue
          ) != NDIS_STATUS_SUCCESS) {

        //
        // Ne2000RegisterAdapter failed.
        //
        NdisFreeMemory(Adapter, sizeof(NE2000_ADAPTER), 0);

        return NDIS_STATUS_FAILURE;

    }


    IF_LOUD( DbgPrint( "Ne2000RegisterAdapter succeeded\n" );)

    return NDIS_STATUS_SUCCESS;
}


#pragma NDIS_PAGEABLE_FUNCTION(Ne2000RegisterAdapter)
NDIS_STATUS
Ne2000RegisterAdapter(
    IN PNE2000_ADAPTER Adapter,
    IN NDIS_HANDLE ConfigurationHandle,
    IN BOOLEAN ConfigError,
    IN ULONG ConfigErrorValue
    )

/*++

Routine Description:

    Called when a new adapter should be registered. It allocates space for
    the adapter, initializes the adapter's block, registers resources
    with the wrapper and initializes the physical adapter.

Arguments:

    Adapter - The adapter structure.

    ConfigurationHandle - Handle passed to Ne2000Initialize.

    ConfigError - Was there an error during configuration reading.

    ConfigErrorValue - Value to log if there is an error.

Return Value:

    Indicates the success or failure of the registration.

--*/

{

    //
    // Temporary looping variable.
    //
    UINT i;

    //
    // General purpose return from NDIS calls
    //
    NDIS_STATUS status;

    //
    // check that NumBuffers <= MAX_XMIT_BUFS
    //

    if (Adapter->NumBuffers > MAX_XMIT_BUFS)
        return(NDIS_STATUS_RESOURCES);

    //
    // Check for a configuration error
    //
    if (ConfigError)
    {
        //
        // Log Error and exit.
        //
        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
            1,
            ConfigErrorValue
            );

        return(NDIS_STATUS_FAILURE);
    }

    //
    // Inform the wrapper of the physical attributes of this adapter.
    //
    NdisMSetAttributes(
        Adapter->MiniportAdapterHandle,
        (NDIS_HANDLE)Adapter,
        FALSE,
        Adapter->BusType
    );

    //
    // Register the port addresses.
    //
    status = NdisMRegisterIoPortRange(
                 (PVOID *)(&(Adapter->IoPAddr)),
                 Adapter->MiniportAdapterHandle,
                 PtrToUint(Adapter->IoBaseAddr),
                 0x20
             );

    if (status != NDIS_STATUS_SUCCESS)
        return(status);

    if (NE2000_ISA == Adapter->CardType)
    {
        //
        // Check that the IoBaseAddress seems to be correct.
        //
        IF_VERY_LOUD( DbgPrint("Checking Parameters\n"); )

        if (!CardCheckParameters(Adapter))
        {
            //
            // The card does not seem to be there, fail silently.
            //
            IF_VERY_LOUD( DbgPrint("  -- Failed\n"); )

            NdisWriteErrorLogEntry(
                Adapter->MiniportAdapterHandle,
                NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
                0
            );

            status = NDIS_STATUS_ADAPTER_NOT_FOUND;

            goto fail2;
        }

        IF_VERY_LOUD( DbgPrint("  -- Success\n"); )
    }

    //
    // Initialize the card.
    //
    IF_VERY_LOUD( DbgPrint("CardInitialize\n"); )

    if (!CardInitialize(Adapter))
    {
        //
        // Card seems to have failed.
        //

        IF_VERY_LOUD( DbgPrint("  -- Failed\n"); )

        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
            0
        );

        status = NDIS_STATUS_ADAPTER_NOT_FOUND;

        goto fail2;
    }

    IF_VERY_LOUD( DbgPrint("  -- Success\n"); )

    //
    //
    // For programmed I/O, we will refer to transmit/receive memory in
    // terms of offsets in the card's 64K address space.
    //
    Adapter->XmitStart = Adapter->RamBase;

    //
    // For the NicXXX fields, always use the addressing system
    // containing the MSB only).
    //
    Adapter->NicXmitStart = (UCHAR)((PtrToUlong(Adapter->XmitStart)) >> 8);

    //
    // The start of the receive space.
    //
    Adapter->PageStart = Adapter->XmitStart +
            (Adapter->NumBuffers * TX_BUF_SIZE);

    Adapter->NicPageStart = Adapter->NicXmitStart +
            (UCHAR)(Adapter->NumBuffers * BUFS_PER_TX);

    ASSERT(Adapter->PageStart < (Adapter->RamBase + Adapter->RamSize));

    //
    // The end of the receive space.
    //
    Adapter->PageStop = Adapter->XmitStart + Adapter->RamSize;
    Adapter->NicPageStop = Adapter->NicXmitStart + (UCHAR)(Adapter->RamSize >> 8);

    ASSERT(Adapter->PageStop <= (Adapter->RamBase + Adapter->RamSize));

    IF_LOUD( DbgPrint("Xmit Start (0x%x, 0x%x) : Rcv Start (0x%x, 0x%x) : Rcv End (0x%x, 0x%x)\n",
              Adapter->XmitStart,
              Adapter->NicXmitStart,
              Adapter->PageStart,
              Adapter->NicPageStart,
              (ULONG_PTR)Adapter->PageStop,
              Adapter->NicPageStop
             );
       )


    //
    // Initialize the receive variables.
    //
    Adapter->NicReceiveConfig = RCR_REJECT_ERR;

    //
    // Initialize the transmit buffer control.
    //
    Adapter->CurBufXmitting = (XMIT_BUF)-1;

    //
    // Initialize the transmit buffer states.
    //
    for (i = 0; i < Adapter->NumBuffers; i++)
        Adapter->BufferStatus[i] = EMPTY;

    //
    // Read the Ethernet address off of the PROM.
    //
    if (!CardReadEthernetAddress(Adapter))
    {
        IF_LOUD(DbgPrint("Could not read the ethernet address\n");)

        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
            0
            );

        status = NDIS_STATUS_ADAPTER_NOT_FOUND;

        goto fail2;
    }

    //
    // Now initialize the NIC and Gate Array registers.
    //
    Adapter->NicInterruptMask = IMR_RCV | IMR_XMIT | IMR_XMIT_ERR | IMR_OVERFLOW;

    //
    // Link us on to the chain of adapters for this driver.
    //
    Adapter->NextAdapter = Ne2000MiniportBlock.AdapterQueue;
    Ne2000MiniportBlock.AdapterQueue = Adapter;


    //
    // Setup the card based on the initialization information
    //

    IF_VERY_LOUD( DbgPrint("Setup\n"); )

    if (!CardSetup(Adapter))
    {
        //
        // The NIC could not be written to.
        //

        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
            0
        );

        IF_VERY_LOUD( DbgPrint("  -- Failed\n"); )

        status = NDIS_STATUS_ADAPTER_NOT_FOUND;

        goto fail3;
    }

    IF_VERY_LOUD( DbgPrint("  -- Success\n"); )

    //
    // Initialize the interrupt.
    //
    
    Adapter->InterruptMode = NdisInterruptLatched;
    
    status = NdisMRegisterInterrupt(
                 &Adapter->Interrupt,
                 Adapter->MiniportAdapterHandle,
                 Adapter->InterruptNumber,
                 Adapter->InterruptNumber,
                 FALSE,
                 FALSE,
                 Adapter->InterruptMode
             );

    if (status != NDIS_STATUS_SUCCESS)
    {
        //
        // Maybe it is a level interrupt
        //
        
        Adapter->InterruptMode = NdisInterruptLevelSensitive;
        Adapter->InterruptsEnabled = TRUE;
        
        status = NdisMRegisterInterrupt(
                     &Adapter->Interrupt,
                     Adapter->MiniportAdapterHandle,
                     Adapter->InterruptNumber,
                     Adapter->InterruptNumber,
                     TRUE,
                     TRUE,
                     Adapter->InterruptMode
                     );
       
        if (status != NDIS_STATUS_SUCCESS)
        {
    
            NdisWriteErrorLogEntry(
                Adapter->MiniportAdapterHandle,
                NDIS_ERROR_CODE_INTERRUPT_CONNECT,
                0
            );
           
            goto fail3;
        }            
    }

    IF_LOUD( DbgPrint("Interrupt Connected\n");)

    //
    // Start up the adapter.
    //
    CardStart(Adapter);

    //
    // Initialization completed successfully. Register a shutdown handler.
    //

    NdisMRegisterAdapterShutdownHandler(
        Adapter->MiniportAdapterHandle,
        (PVOID)Adapter,
        Ne2000Shutdown
        );

    IF_LOUD( DbgPrint(" [ Ne2000 ] : OK\n");)

    return(NDIS_STATUS_SUCCESS);

    //
    // Code to unwind what has already been set up when a part of
    // initialization fails, which is jumped into at various
    // points based on where the failure occured. Jumping to
    // a higher-numbered failure point will execute the code
    // for that block and all lower-numbered ones.
    //

fail3:

    //
    // Take us out of the AdapterQueue.
    //

    if (Ne2000MiniportBlock.AdapterQueue == Adapter)
    {
        Ne2000MiniportBlock.AdapterQueue = Adapter->NextAdapter;
    }
    else
    {
        PNE2000_ADAPTER TmpAdapter = Ne2000MiniportBlock.AdapterQueue;

        while (TmpAdapter->NextAdapter != Adapter)
        {
            TmpAdapter = TmpAdapter->NextAdapter;
        }

        TmpAdapter->NextAdapter = TmpAdapter->NextAdapter->NextAdapter;
    }

    //
    // We already enabled the interrupt on the card, so
    // turn it off.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_COMMAND, CR_STOP);

fail2:

    NdisMDeregisterIoPortRange(
        Adapter->MiniportAdapterHandle,
        PtrToUint(Adapter->IoBaseAddr),
        0x20,
        (PVOID)Adapter->IoPAddr
    );

    return(status);
}


extern
VOID
Ne2000Halt(
    IN NDIS_HANDLE MiniportAdapterContext
    )

/*++

Routine Description:

    NE2000Halt removes an adapter that was previously initialized.

Arguments:

    MiniportAdapterContext - The context value that the Miniport returned
        from Ne2000Initialize; actually as pointer to an NE2000_ADAPTER.

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter;

    Adapter = PNE2000_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    //
    // Shut down the chip.
    //
    CardStop(Adapter);

    //
    // Deregister the adapter shutdown handler.
    //
    NdisMDeregisterAdapterShutdownHandler(Adapter->MiniportAdapterHandle);

    //
    // Disconnect the interrupt line.
    //
    NdisMDeregisterInterrupt(&Adapter->Interrupt);

    //
    // Pause, waiting for any DPC stuff to clear.
    //
    NdisStallExecution(250000);

    NdisMDeregisterIoPortRange(Adapter->MiniportAdapterHandle,
                               PtrToUint(Adapter->IoBaseAddr),
                               0x20,
                               (PVOID)Adapter->IoPAddr
                               );

    //
    // Remove the adapter from the global queue of adapters.
    //
    if (Ne2000MiniportBlock.AdapterQueue == Adapter) {

        Ne2000MiniportBlock.AdapterQueue = Adapter->NextAdapter;

    } else {

        PNE2000_ADAPTER TmpAdapter = Ne2000MiniportBlock.AdapterQueue;

        while (TmpAdapter->NextAdapter != Adapter) {

            TmpAdapter = TmpAdapter->NextAdapter;

        }

        TmpAdapter->NextAdapter = TmpAdapter->NextAdapter->NextAdapter;
    }

    //
    // Free up the memory
    //
    NdisFreeMemory(Adapter, sizeof(NE2000_ADAPTER), 0);

    return;

}


VOID
Ne2000Shutdown(
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:

    This is called by NDIS when the system is shutting down or restarting
    on an unrecoverable error. Do the minimum set of operations to make the
    card silent.

Arguments:

    MiniportAdapterContext - pointer to our adapter structure

Return Value:

    None.

--*/
{
    //
    // Pointer to the adapter structure.
    //
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)MiniportAdapterContext;

    (VOID)SyncCardStop(Adapter);
}


NDIS_STATUS
Ne2000Reset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:

    The NE2000Reset request instructs the Miniport to issue a hardware reset
    to the network adapter.  The driver also resets its software state.  See
    the description of NdisMReset for a detailed description of this request.

Arguments:

    AddressingReset - Does the adapter need the addressing information reloaded.

    MiniportAdapterContext - Pointer to the adapter structure.

Return Value:

    The function value is the status of the operation.

--*/

{

    //
    // Pointer to the adapter structure.
    //
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)MiniportAdapterContext;

    //
    // Temporary looping variable
    //
    UINT i;

    //
    // Clear the values for transmits, they will be reset these for after
    // the reset is completed.
    //
    Adapter->NextBufToFill = 0;
    Adapter->NextBufToXmit = 0;
    Adapter->CurBufXmitting = (XMIT_BUF)-1;

    Adapter->FirstPacket = NULL;
    Adapter->LastPacket = NULL;

    for (i=0; i<Adapter->NumBuffers; i++) {
            Adapter->BufferStatus[i] = EMPTY;
    }

    //
    // Physically reset the card.
    //
    Adapter->NicInterruptMask = IMR_RCV | IMR_XMIT | IMR_XMIT_ERR | IMR_OVERFLOW;

    return (CardReset(Adapter) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
}


NDIS_STATUS
Ne2000QueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
)

/*++

Routine Description:

    The NE2000QueryInformation process a Query request for
    NDIS_OIDs that are specific about the Driver.

Arguments:

    MiniportAdapterContext - a pointer to the adapter.

    Oid - the NDIS_OID to process.

    InformationBuffer -  a pointer into the
    NdisRequest->InformationBuffer into which store the result of the query.

    InformationBufferLength - a pointer to the number of bytes left in the
    InformationBuffer.

    BytesWritten - a pointer to the number of bytes written into the
    InformationBuffer.

    BytesNeeded - If there is not enough room in the information buffer
    then this will contain the number of bytes needed to complete the
    request.

Return Value:

    The function value is the status of the operation.

--*/
{

    //
    // Pointer to the adapter structure.
    //
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)MiniportAdapterContext;

    //
    //   General Algorithm:
    //
    //      Switch(Request)
    //         Get requested information
    //         Store results in a common variable.
    //      default:
    //         Try protocol query information
    //         If that fails, fail query.
    //
    //      Copy result in common variable to result buffer.
    //   Finish processing

    UINT BytesLeft = InformationBufferLength;
    PUCHAR InfoBuffer = (PUCHAR)(InformationBuffer);
    NDIS_STATUS StatusToReturn = NDIS_STATUS_SUCCESS;
    NDIS_HARDWARE_STATUS HardwareStatus = NdisHardwareStatusReady;
    NDIS_MEDIUM Medium = NdisMedium802_3;

    //
    // This variable holds result of query
    //
    ULONG GenericULong;
    USHORT GenericUShort;
    UCHAR GenericArray[6];
    UINT MoveBytes = sizeof(ULONG);
    PVOID MoveSource = (PVOID)(&GenericULong);

    //
    // Make sure that int is 4 bytes.  Else GenericULong must change
    // to something of size 4.
    //
    ASSERT(sizeof(ULONG) == 4);

    //
    // Switch on request type
    //

    switch (Oid) {

    case OID_GEN_MAC_OPTIONS:

        GenericULong = (ULONG)(NDIS_MAC_OPTION_TRANSFERS_NOT_PEND  |
                               NDIS_MAC_OPTION_RECEIVE_SERIALIZED  |
                               NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA |
                               NDIS_MAC_OPTION_NO_LOOPBACK
                               );

        break;

    case OID_GEN_SUPPORTED_LIST:

        MoveSource = (PVOID)(Ne2000SupportedOids);
        MoveBytes = sizeof(Ne2000SupportedOids);
        break;

    case OID_GEN_HARDWARE_STATUS:

        HardwareStatus = NdisHardwareStatusReady;
        MoveSource = (PVOID)(&HardwareStatus);
        MoveBytes = sizeof(NDIS_HARDWARE_STATUS);

        break;

    case OID_GEN_MEDIA_SUPPORTED:
    case OID_GEN_MEDIA_IN_USE:

        MoveSource = (PVOID) (&Medium);
        MoveBytes = sizeof(NDIS_MEDIUM);
        break;

    case OID_GEN_MAXIMUM_LOOKAHEAD:

        GenericULong = NE2000_MAX_LOOKAHEAD;

        break;


    case OID_GEN_MAXIMUM_FRAME_SIZE:

        GenericULong = (ULONG)(1514 - NE2000_HEADER_SIZE);

        break;


    case OID_GEN_MAXIMUM_TOTAL_SIZE:

        GenericULong = (ULONG)(1514);

        break;


    case OID_GEN_LINK_SPEED:

        GenericULong = (ULONG)(100000);

        break;


    case OID_GEN_TRANSMIT_BUFFER_SPACE:

        GenericULong = (ULONG)(Adapter->NumBuffers * TX_BUF_SIZE);

        break;

    case OID_GEN_RECEIVE_BUFFER_SPACE:

        GenericULong = (ULONG)(0x2000 - (Adapter->NumBuffers * TX_BUF_SIZE));

        break;

    case OID_GEN_TRANSMIT_BLOCK_SIZE:

        GenericULong = (ULONG)(TX_BUF_SIZE);

        break;

    case OID_GEN_RECEIVE_BLOCK_SIZE:

        GenericULong = (ULONG)(256);

        break;

#ifdef NE2000

    case OID_GEN_VENDOR_ID:

        NdisMoveMemory(
            (PVOID)&GenericULong,
            Adapter->PermanentAddress,
            3
            );
        GenericULong &= 0xFFFFFF00;
        MoveSource = (PVOID)(&GenericULong);
        MoveBytes = sizeof(GenericULong);
        break;

    case OID_GEN_VENDOR_DESCRIPTION:

        MoveSource = (PVOID)"Novell 2000 Adapter.";
        MoveBytes = 21;

        break;

#else

    case OID_GEN_VENDOR_ID:

        NdisMoveMemory(
            (PVOID)&GenericULong,
            Adapter->PermanentAddress,
            3
            );
        GenericULong &= 0xFFFFFF00;
        GenericULong |= 0x01;
        MoveSource = (PVOID)(&GenericULong);
        MoveBytes = sizeof(GenericULong);
        break;

    case OID_GEN_VENDOR_DESCRIPTION:

        MoveSource = (PVOID)"Novell 1000 Adapter.";
        MoveBytes = 21;

        break;

#endif

    case OID_GEN_DRIVER_VERSION:

        GenericUShort = ((USHORT)NE2000_NDIS_MAJOR_VERSION << 8) |
                NE2000_NDIS_MINOR_VERSION;

        MoveSource = (PVOID)(&GenericUShort);
        MoveBytes = sizeof(GenericUShort);
        break;

    case OID_GEN_CURRENT_LOOKAHEAD:

        GenericULong = (ULONG)(Adapter->MaxLookAhead);
        break;

    case OID_802_3_PERMANENT_ADDRESS:

        NE2000_MOVE_MEM((PCHAR)GenericArray,
                    Adapter->PermanentAddress,
                    NE2000_LENGTH_OF_ADDRESS);

        MoveSource = (PVOID)(GenericArray);
        MoveBytes = sizeof(Adapter->PermanentAddress);

        break;

    case OID_802_3_CURRENT_ADDRESS:

        NE2000_MOVE_MEM((PCHAR)GenericArray,
                    Adapter->StationAddress,
                    NE2000_LENGTH_OF_ADDRESS);

        MoveSource = (PVOID)(GenericArray);
        MoveBytes = sizeof(Adapter->StationAddress);

        break;

    case OID_802_3_MAXIMUM_LIST_SIZE:

        GenericULong = (ULONG) (Adapter->MulticastListMax);
        break;

    case OID_GEN_XMIT_OK:

        GenericULong = (UINT)(Adapter->FramesXmitGood);
        break;

    case OID_GEN_RCV_OK:

        GenericULong = (UINT)(Adapter->FramesRcvGood);
        break;

    case OID_GEN_XMIT_ERROR:

        GenericULong = (UINT)(Adapter->FramesXmitBad);
        break;

    case OID_GEN_RCV_ERROR:

        GenericULong = (UINT)(Adapter->CrcErrors);
        break;

    case OID_GEN_RCV_NO_BUFFER:

        GenericULong = (UINT)(Adapter->MissedPackets);
        break;

    case OID_802_3_RCV_ERROR_ALIGNMENT:

        GenericULong = (UINT)(Adapter->FrameAlignmentErrors);
        break;

    case OID_802_3_XMIT_ONE_COLLISION:

        GenericULong = (UINT)(Adapter->FramesXmitOneCollision);
        break;

    case OID_802_3_XMIT_MORE_COLLISIONS:

        GenericULong = (UINT)(Adapter->FramesXmitManyCollisions);
        break;

    default:

        StatusToReturn = NDIS_STATUS_INVALID_OID;
        break;

    }


    if (StatusToReturn == NDIS_STATUS_SUCCESS) {

        if (MoveBytes > BytesLeft) {

            //
            // Not enough room in InformationBuffer. Punt
            //

            *BytesNeeded = MoveBytes;

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;

        } else {

            //
            // Store result.
            //

            NE2000_MOVE_MEM(InfoBuffer, MoveSource, MoveBytes);

            (*BytesWritten) = MoveBytes;

        }
    }

    return StatusToReturn;
}


extern
NDIS_STATUS
Ne2000SetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    )

/*++

Routine Description:

    NE2000SetInformation handles a set operation for a
    single OID.

Arguments:

    MiniportAdapterContext - Context registered with the wrapper, really
        a pointer to the adapter.

    Oid - The OID of the set.

    InformationBuffer - Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead - If the call is successful, returns the number
        of bytes read from InformationBuffer.

    BytesNeeded - If there is not enough data in InformationBuffer
        to satisfy the OID, returns the amount of storage needed.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID

--*/
{
    //
    // Pointer to the adapter structure.
    //
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)MiniportAdapterContext;

    //
    // General Algorithm:
    //
    //     Verify length
    //     Switch(Request)
    //        Process Request
    //

    UINT BytesLeft = InformationBufferLength;
    PUCHAR InfoBuffer = (PUCHAR)(InformationBuffer);

    //
    // Variables for a particular request
    //
    UINT OidLength;

    //
    // Variables for holding the new values to be used.
    //
    ULONG LookAhead;
    ULONG Filter;

    //
    // Status of the operation.
    //
    NDIS_STATUS StatusToReturn = NDIS_STATUS_SUCCESS;


    IF_LOUD( DbgPrint("In SetInfo\n");)

    //
    // Get Oid and Length of request
    //
    OidLength = BytesLeft;

    switch (Oid) {

    case OID_802_3_MULTICAST_LIST:

        //
        // Verify length
        //
        if ((OidLength % NE2000_LENGTH_OF_ADDRESS) != 0){

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;

            *BytesRead = 0;
            *BytesNeeded = 0;

            break;

        }

        //
        // Set the new list on the adapter.
        //
        NdisMoveMemory(Adapter->Addresses, InfoBuffer, OidLength);

        //
        //  If we are currently receiving all multicast or
        //  we are promsicuous then we DO NOT call this, or
        //  it will reset thoes settings.
        //
        if
        (
            !(Adapter->PacketFilter & (NDIS_PACKET_TYPE_ALL_MULTICAST |
                                       NDIS_PACKET_TYPE_PROMISCUOUS))
        )
        {
            StatusToReturn = DispatchSetMulticastAddressList(Adapter);
        }
        else
        {
            //
            //  Our list of multicast addresses is kept by the
            //  wrapper.
            //
            StatusToReturn = NDIS_STATUS_SUCCESS;
        }

        break;

    case OID_GEN_CURRENT_PACKET_FILTER:

        //
        // Verify length
        //

        if (OidLength != 4 ) {

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;

            *BytesRead = 0;
            *BytesNeeded = 0;

            break;

        }

        NE2000_MOVE_MEM(&Filter, InfoBuffer, 4);

        //
        // Verify bits
        //
        if (!(Filter & (NDIS_PACKET_TYPE_ALL_MULTICAST |
                            NDIS_PACKET_TYPE_PROMISCUOUS |
                            NDIS_PACKET_TYPE_MULTICAST |
                            NDIS_PACKET_TYPE_BROADCAST |
                            NDIS_PACKET_TYPE_DIRECTED)) &&
            (Filter != 0))
        {
            StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;

            *BytesRead = 4;
            *BytesNeeded = 0;

            break;

        }

        //
        // Set the new value on the adapter.
        //
        Adapter->PacketFilter = Filter;
        StatusToReturn = DispatchSetPacketFilter(Adapter);
        break;

    case OID_GEN_CURRENT_LOOKAHEAD:

        //
        // Verify length
        //

        if (OidLength != 4) {

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;

            *BytesRead = 0;
            *BytesNeeded = 4;

            break;

        }

        //
        // Store the new value.
        //

        NE2000_MOVE_MEM(&LookAhead, InfoBuffer, 4);

        if (LookAhead <= NE2000_MAX_LOOKAHEAD) {
            Adapter->MaxLookAhead = LookAhead;
        } else {
            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        }

        break;

    default:

        StatusToReturn = NDIS_STATUS_INVALID_OID;

        *BytesRead = 0;
        *BytesNeeded = 0;

        break;

    }


    if (StatusToReturn == NDIS_STATUS_SUCCESS) {

        *BytesRead = BytesLeft;
        *BytesNeeded = 0;

    }

    return(StatusToReturn);
}


NDIS_STATUS
DispatchSetPacketFilter(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Sets the appropriate bits in the adapter filters
    and modifies the card Receive Configuration Register if needed.

Arguments:

    Adapter - Pointer to the adapter block

Return Value:

    The final status (always NDIS_STATUS_SUCCESS).

Notes:

  - Note that to receive all multicast packets the multicast
    registers on the card must be filled with 1's. To be
    promiscuous that must be done as well as setting the
    promiscuous physical flag in the RCR. This must be done
    as long as ANY protocol bound to this adapter has their
    filter set accordingly.

--*/


{
    //
    // See what has to be put on the card.
    //

    if
    (
        Adapter->PacketFilter & (NDIS_PACKET_TYPE_ALL_MULTICAST |
                                 NDIS_PACKET_TYPE_PROMISCUOUS)
    )
    {
        //
        // need "all multicast" now.
        //
        CardSetAllMulticast(Adapter);    // fills it with 1's
    }
    else
    {
        //
        // No longer need "all multicast".
        //
        DispatchSetMulticastAddressList(Adapter);
    }

    //
    // The multicast bit in the RCR should be on if ANY protocol wants
    // multicast/all multicast packets (or is promiscuous).
    //
    if
    (
        Adapter->PacketFilter & (NDIS_PACKET_TYPE_ALL_MULTICAST |
                                 NDIS_PACKET_TYPE_MULTICAST |
                                 NDIS_PACKET_TYPE_PROMISCUOUS)
    )
    {
        Adapter->NicReceiveConfig |= RCR_MULTICAST;
    }
    else
    {
        Adapter->NicReceiveConfig &= ~RCR_MULTICAST;
    }

    //
    // The promiscuous physical bit in the RCR should be on if ANY
    // protocol wants to be promiscuous.
    //
    if (Adapter->PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS)
    {
        Adapter->NicReceiveConfig |= RCR_ALL_PHYS;
    }
    else
    {
        Adapter->NicReceiveConfig &= ~RCR_ALL_PHYS;
    }

    //
    // The broadcast bit in the RCR should be on if ANY protocol wants
    // broadcast packets (or is promiscuous).
    //
    if
    (
        Adapter->PacketFilter & (NDIS_PACKET_TYPE_BROADCAST |
                                 NDIS_PACKET_TYPE_PROMISCUOUS)
    )
    {
        Adapter->NicReceiveConfig |= RCR_BROADCAST;
    }
    else
    {
        Adapter->NicReceiveConfig &= ~RCR_BROADCAST;
    }

    CardSetReceiveConfig(Adapter);

    return(NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
DispatchSetMulticastAddressList(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Sets the multicast list for this open

Arguments:

    Adapter - Pointer to the adapter block

Return Value:

    NDIS_STATUS_SUCESS

Implementation Note:

    When invoked, we are to make it so that the multicast list in the filter
    package becomes the multicast list for the adapter. To do this, we
    determine the required contents of the NIC multicast registers and
    update them.


--*/
{
    //
    // Update the local copy of the NIC multicast regs and copy them to the NIC
    //
    CardFillMulticastRegs(Adapter);
    CardCopyMulticastRegs(Adapter);

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\ne2000\keywords.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved.

Module Name:

    keywords.h

Abstract:

    Contains all Ndis2 and Ndis3 mac-specific keywords.

Author:

    Bob Noradki

Environment:

    This driver is expected to work in DOS, OS2 and NT at the equivalent
    of kernal mode.

    Architecturally, there is an assumption in this driver that we are
    on a little endian machine.

Notes:

    optional-notes

Revision History:



--*/

#define IOADDRESS  NDIS_STRING_CONST("IoBaseAddress")
#define INTERRUPT  NDIS_STRING_CONST("InterruptNumber")
#define MAX_MULTICAST_LIST  NDIS_STRING_CONST("MaximumMulticastList")
#define NETWORK_ADDRESS  NDIS_STRING_CONST("NetworkAddress")
#define BUS_TYPE  NDIS_STRING_CONST("BusType")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\nec\detect\nia35det\sources.inc ===
TARGETNAME=nia35det
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\netdtect.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\netdet.lib

DLLENTRY=Nia35DetInit

INCLUDES=..; \
         $(BASEDIR)\private\ntos\inc; \
         $(BASEDIR)\private\inc\net

C_DEFINES=$(C_DEFINES) -D_PNP_POWER=1

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\nia35det.c  \
        ..\nia35det.rc

DLLDEF=..\nia35det.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\ne2000\ne2000sw.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved.

Module Name:

    ne2000sw.h

Abstract:

    The main header for an Novell 2000 Miniport driver.

Author:

    Sean Selitrennikoff

Environment:

    Architecturally, there is an assumption in this driver that we are
    on a little endian machine.

Notes:

    optional-notes

Revision History:

--*/

#ifndef _NE2000SFT_
#define _NE2000SFT_

#define NE2000_NDIS_MAJOR_VERSION 3
#define NE2000_NDIS_MINOR_VERSION 0

//
// This macro is used along with the flags to selectively
// turn on debugging.
//

#if DBG

#define IF_NE2000DEBUG(f) if (Ne2000DebugFlag & (f))
extern ULONG Ne2000DebugFlag;

#define NE2000_DEBUG_LOUD               0x00000001  // debugging info
#define NE2000_DEBUG_VERY_LOUD          0x00000002  // excessive debugging info
#define NE2000_DEBUG_LOG                0x00000004  // enable Ne2000Log
#define NE2000_DEBUG_CHECK_DUP_SENDS    0x00000008  // check for duplicate sends
#define NE2000_DEBUG_TRACK_PACKET_LENS  0x00000010  // track directed packet lens
#define NE2000_DEBUG_WORKAROUND1        0x00000020  // drop DFR/DIS packets
#define NE2000_DEBUG_CARD_BAD           0x00000040  // dump data if CARD_BAD
#define NE2000_DEBUG_CARD_TESTS         0x00000080  // print reason for failing

//
// Macro for deciding whether to print a lot of debugging information.
//

#define IF_LOUD(A) IF_NE2000DEBUG( NE2000_DEBUG_LOUD ) { A }
#define IF_VERY_LOUD(A) IF_NE2000DEBUG( NE2000_DEBUG_VERY_LOUD ) { A }

//
// Whether to use the Ne2000Log buffer to record a trace of the driver.
//
#define IF_LOG(A) IF_NE2000DEBUG( NE2000_DEBUG_LOG ) { A }
extern VOID Ne2000Log(UCHAR);

//
// Whether to do loud init failure
//
#define IF_INIT(A) A

//
// Whether to do loud card test failures
//
#define IF_TEST(A) IF_NE2000DEBUG( NE2000_DEBUG_CARD_TESTS ) { A }

#else

//
// This is not a debug build, so make everything quiet.
//
#define IF_LOUD(A)
#define IF_VERY_LOUD(A)
#define IF_LOG(A)
#define IF_INIT(A)
#define IF_TEST(A)

#endif




//
// Adapter->NumBuffers
//
// controls the number of transmit buffers on the packet.
// Choices are 1 through 12.
//

#define DEFAULT_NUMBUFFERS 12


//
// Create a macro for moving memory from place to place.  Makes
// the code more readable and portable in case we ever support
// a shared memory Ne2000 adapter.
//
#define NE2000_MOVE_MEM(dest,src,size) NdisMoveMemory(dest,src,size)

//
// The status of transmit buffers.
//

typedef enum {
    EMPTY = 0x00,
    FULL = 0x02
} BUFFER_STATUS;

//
// Type of an interrupt.
//

typedef enum {
    RECEIVE    = 0x01,
    TRANSMIT   = 0x02,
    OVERFLOW   = 0x04,
    COUNTER    = 0x08,
    UNKNOWN    = 0x10
} INTERRUPT_TYPE;

//
// Result of Ne2000IndicatePacket().
//
typedef enum {
    INDICATE_OK,
    SKIPPED,
    ABORT,
    CARD_BAD
} INDICATE_STATUS;



//
// Size of the ethernet header
//
#define NE2000_HEADER_SIZE 14

//
// Size of the ethernet address
//
#define NE2000_LENGTH_OF_ADDRESS 6

//
// Number of bytes allowed in a lookahead (max)
//
#define NE2000_MAX_LOOKAHEAD (252 - NE2000_HEADER_SIZE)

//
// Maximum number of transmit buffers on the card.
//
#define MAX_XMIT_BUFS   12

//
// Definition of a transmit buffer.
//
typedef UINT XMIT_BUF;

//
// Number of 256-byte buffers in a transmit buffer.
//
#define BUFS_PER_TX 1

//
// Size of a single transmit buffer.
//
#define TX_BUF_SIZE (BUFS_PER_TX*256)




//
// This structure contains information about the driver
// itself.  There is only have one of these structures.
//
typedef struct _DRIVER_BLOCK {

    //
    // NDIS wrapper information.
    //
    NDIS_HANDLE NdisMacHandle;          // returned from NdisRegisterMac
    NDIS_HANDLE NdisWrapperHandle;      // returned from NdisInitializeWrapper

    //
    // Adapters registered for this Miniport driver.
    //
    struct _NE2000_ADAPTER * AdapterQueue;

} DRIVER_BLOCK, * PDRIVER_BLOCK;



//
// This structure contains all the information about a single
// adapter that this driver is controlling.
//
typedef struct _NE2000_ADAPTER {

    //
    // This is the handle given by the wrapper for calling ndis
    // functions.
    //
    NDIS_HANDLE MiniportAdapterHandle;

    //
    // Interrupt object.
    //
    NDIS_MINIPORT_INTERRUPT Interrupt;

    //
    // used by DriverBlock->AdapterQueue
    //
    struct _NE2000_ADAPTER * NextAdapter;

    //
    // This is a count of the number of receives that have been
    // indicated in a row.  This is used to limit the number
    // of sequential receives so that one can periodically check
    // for transmit complete interrupts.
    //
    ULONG ReceivePacketCount;

    //
    // Configuration information
    //

    //
    // Number of buffer in this adapter.
    //
    UINT NumBuffers;

    //
    // Physical address of the IoBaseAddress
    //
    PVOID IoBaseAddr;

    //
    // Interrupt number this adapter is using.
    //
    CHAR InterruptNumber;

    //
    // Number of multicast addresses that this adapter is to support.
    //
    UINT MulticastListMax;

    //
    // The type of bus that this adapter is running on.  Either ISA or
    // MCA.
    //
    UCHAR BusType;

    //
    // InterruptMode is whether the interrupt is latched or level sensitive
    //
    NDIS_INTERRUPT_MODE InterruptMode;
    
    //
    // Current status of the interrupt mask
    //
    BOOLEAN InterruptsEnabled;


    //
    //  Type of ne2000 card.
    //
    UINT    CardType;

    //
    //  Address of the memory window.
    //
    ULONG   AttributeMemoryAddress;
    ULONG   AttributeMemorySize;

    //
    // Transmit information.
    //

    //
    // The next available empty transmit buffer.
    //
    XMIT_BUF NextBufToFill;

    //
    // The next full transmit buffer waiting to transmitted.  This
    // is valid only if CurBufXmitting is -1
    //
    XMIT_BUF NextBufToXmit;

    //
    // This transmit buffer that is currently transmitting.  If none,
    // then the value is -1.
    //
    XMIT_BUF CurBufXmitting;

    //
    // TRUE if a transmit has been started, and have not received the
    // corresponding transmit complete interrupt.
    //
    BOOLEAN TransmitInterruptPending;

    //
    // TRUE if a receive buffer overflow occurs while a
    // transmit complete interrupt was pending.
    //
    BOOLEAN OverflowRestartXmitDpc;

    //
    // The current status of each transmit buffer.
    //
    BUFFER_STATUS BufferStatus[MAX_XMIT_BUFS];

    //
    // Used to map packets to transmit buffers and visa-versa.
    //
    PNDIS_PACKET Packets[MAX_XMIT_BUFS];

    //
    // The length of each packet in the Packets list.
    //
    UINT PacketLens[MAX_XMIT_BUFS];

    //
    // The first packet we have pending.
    //
    PNDIS_PACKET FirstPacket;

    //
    // The tail of the pending queue.
    //
    PNDIS_PACKET LastPacket;

    //
    // The address of the start of the transmit buffer space.
    //
    PUCHAR XmitStart;

    //
    // The address of the start of the receive buffer space.
    PUCHAR PageStart;

    //
    // The address of the end of the receive buffer space.
    //
    PUCHAR PageStop;

    //
    // Status of the last transmit.
    //
    UCHAR XmitStatus;

    //
    // The value to write to the adapter for the start of
    // the transmit buffer space.
    //
    UCHAR NicXmitStart;

    //
    // The value to write to the adapter for the start of
    // the receive buffer space.
    //
    UCHAR NicPageStart;

    //
    // The value to write to the adapter for the end of
    // the receive buffer space.
    //
    UCHAR NicPageStop;




    //
    // Receive information
    //

    //
    // The value to write to the adapter for the next receive
    // buffer that is free.
    //
    UCHAR NicNextPacket;

    //
    // The next receive buffer that will be filled.
    //
    UCHAR Current;

    //
    // Total length of a received packet.
    //
    UINT PacketLen;




    //
    // Operational information.
    //

    //
    // Mapped address of the base io port.
    //
    ULONG_PTR IoPAddr;

    //
    // InterruptStatus tracks interrupt sources that still need to be serviced,
    // it is the logical OR of all card interrupts that have been received and not
    // processed and cleared. (see also INTERRUPT_TYPE definition in ne2000.h)
    //
    UCHAR InterruptStatus;

    //
    // The ethernet address currently in use.
    //
    UCHAR StationAddress[NE2000_LENGTH_OF_ADDRESS];

    //
    // The ethernet address that is burned into the adapter.
    //
    UCHAR PermanentAddress[NE2000_LENGTH_OF_ADDRESS];

    //
    // The adapter space address of the start of on board memory.
    //
    PUCHAR RamBase;

    //
    // The number of K on the adapter.
    //
    ULONG RamSize;

    //
    // The current packet filter in use.
    //
    ULONG PacketFilter;

    //
    // TRUE if a receive buffer overflow occured.
    //
    BOOLEAN BufferOverflow;

    //
    // TRUE if the driver needs to call NdisMEthIndicateReceiveComplete
    //
    BOOLEAN IndicateReceiveDone;

    //
    // TRUE if this is an NE2000 in an eight bit slot.
    //
    BOOLEAN EightBitSlot;


    //
    // Statistics used by Set/QueryInformation.
    //

    ULONG FramesXmitGood;               // Good Frames Transmitted
    ULONG FramesRcvGood;                // Good Frames Received
    ULONG FramesXmitBad;                // Bad Frames Transmitted
    ULONG FramesXmitOneCollision;       // Frames Transmitted with one collision
    ULONG FramesXmitManyCollisions;     // Frames Transmitted with > 1 collision
    ULONG FrameAlignmentErrors;         // FAE errors counted
    ULONG CrcErrors;                    // CRC errors counted
    ULONG MissedPackets;                // missed packet counted

    //
    // Reset information.
    //

    UCHAR NicMulticastRegs[8];          // contents of card multicast registers
    UCHAR NicReceiveConfig;             // contents of NIC RCR
    UCHAR NicInterruptMask;             // contents of NIC IMR

    //
    // The lookahead buffer size in use.
    //
    ULONG MaxLookAhead;

    //
    // These are for the current packet being indicated.
    //

    //
    // The NIC appended header.  Used to find corrupted receive packets.
    //
    UCHAR PacketHeader[4];

    //
    // Ne2000 address of the beginning of the packet.
    //
    PUCHAR PacketHeaderLoc;

    //
    // Lookahead buffer
    //
    UCHAR Lookahead[NE2000_MAX_LOOKAHEAD + NE2000_HEADER_SIZE];

    //
    // List of multicast addresses in use.
    //
    CHAR Addresses[DEFAULT_MULTICASTLISTMAX][NE2000_LENGTH_OF_ADDRESS];

} NE2000_ADAPTER, * PNE2000_ADAPTER;



//
// Given a MiniportContextHandle return the PNE2000_ADAPTER
// it represents.
//
#define PNE2000_ADAPTER_FROM_CONTEXT_HANDLE(Handle) \
    ((PNE2000_ADAPTER)(Handle))

//
// Given a pointer to a NE2000_ADAPTER return the
// proper MiniportContextHandle.
//
#define CONTEXT_HANDLE_FROM_PNE2000_ADAPTER(Ptr) \
    ((NDIS_HANDLE)(Ptr))

//
// Macros to extract high and low bytes of a word.
//
#define MSB(Value) ((UCHAR)((((ULONG)Value) >> 8) & 0xff))
#define LSB(Value) ((UCHAR)(((ULONG)Value) & 0xff))

//
// What we map into the reserved section of a packet.
// Cannot be more than 8 bytes (see ASSERT in ne2000.c).
//
typedef struct _MINIPORT_RESERVED {
    PNDIS_PACKET Next;    // used to link in the queues (4 bytes)
} MINIPORT_RESERVED, * PMINIPORT_RESERVED;


//
// Retrieve the MINIPORT_RESERVED structure from a packet.
//
#define RESERVED(Packet) ((PMINIPORT_RESERVED)((Packet)->MiniportReserved))

//
// Procedures which log errors.
//

typedef enum _NE2000_PROC_ID {
    cardReset,
    cardCopyDownPacket,
    cardCopyDownBuffer,
    cardCopyUp
} NE2000_PROC_ID;


//
// Special error log codes.
//
#define NE2000_ERRMSG_CARD_SETUP          (ULONG)0x01
#define NE2000_ERRMSG_DATA_PORT_READY     (ULONG)0x02
#define NE2000_ERRMSG_HANDLE_XMIT_COMPLETE (ULONG)0x04

//
// Declarations for functions in ne2000.c.
//
NDIS_STATUS
Ne2000SetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    );

VOID
Ne2000Halt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

VOID
Ne2000Shutdown(
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
Ne2000RegisterAdapter(
    IN PNE2000_ADAPTER Adapter,
    IN NDIS_HANDLE ConfigurationHandle,
    IN BOOLEAN ConfigError,
    IN ULONG ConfigErrorValue
    );

NDIS_STATUS
Ne2000Initialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE ConfigurationHandle
    );

NDIS_STATUS
Ne2000TransferData(
    OUT PNDIS_PACKET Packet,
    OUT PUINT BytesTransferred,
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportReceiveContext,
    IN UINT ByteOffset,
    IN UINT BytesToTransfer
    );

NDIS_STATUS
Ne2000Send(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet,
    IN UINT Flags
    );

NDIS_STATUS
Ne2000Reset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
Ne2000QueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    );

VOID
Ne2000Halt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

VOID
OctogmetusceratorRevisited(
    IN PNE2000_ADAPTER Adapter
    );

NDIS_STATUS
DispatchSetPacketFilter(
    IN PNE2000_ADAPTER Adapter
    );

NDIS_STATUS
DispatchSetMulticastAddressList(
    IN PNE2000_ADAPTER Adapter
    );


//
// Interrup.c
//

VOID
Ne2000EnableInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

VOID
Ne2000DisableInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

VOID
Ne2000Isr(
    OUT PBOOLEAN InterruptRecognized,
    OUT PBOOLEAN QueueDpc,
    IN PVOID Context
    );

VOID
Ne2000HandleInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

BOOLEAN
Ne2000PacketOK(
    IN PNE2000_ADAPTER Adapter
    );

VOID
Ne2000XmitDpc(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
Ne2000RcvDpc(
    IN PNE2000_ADAPTER Adapter
    );


//
// Declarations of functions in card.c.
//

BOOLEAN
CardCheckParameters(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardInitialize(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardReadEthernetAddress(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardSetup(
    IN PNE2000_ADAPTER Adapter
    );

VOID
CardStop(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardTest(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardReset(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardCopyDownPacket(
    IN PNE2000_ADAPTER Adapter,
    IN PNDIS_PACKET Packet,
    OUT UINT * Length
    );

BOOLEAN
CardCopyDown(
    IN PNE2000_ADAPTER Adapter,
    IN PUCHAR TargetBuffer,
    IN PUCHAR SourceBuffer,
    IN UINT Length
    );

BOOLEAN
CardCopyUp(
    IN PNE2000_ADAPTER Adapter,
    IN PUCHAR Target,
    IN PUCHAR Source,
    IN UINT Length
    );

ULONG
CardComputeCrc(
    IN PUCHAR Buffer,
    IN UINT Length
    );

VOID
CardGetPacketCrc(
    IN PUCHAR Buffer,
    IN UINT Length,
    OUT UCHAR Crc[4]
    );

VOID
CardGetMulticastBit(
    IN UCHAR Address[NE2000_LENGTH_OF_ADDRESS],
    OUT UCHAR * Byte,
    OUT UCHAR * Value
    );

VOID
CardFillMulticastRegs(
    IN PNE2000_ADAPTER Adapter
    );

VOID
CardSetBoundary(
    IN PNE2000_ADAPTER Adapter
    );

VOID
CardStartXmit(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
SyncCardStop(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardGetXmitStatus(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardGetCurrent(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardSetReceiveConfig(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardSetAllMulticast(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardCopyMulticastRegs(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardSetInterruptMask(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardAcknowledgeOverflow(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardUpdateCounters(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardHandleOverflow(
    IN PVOID SynchronizeContext
    );

/*++

Routine Description:

    Determines the type of the interrupt on the card. The order of
    importance is overflow, then transmit complete, then receive.
    Counter MSB is handled first since it is simple.

Arguments:

    Adapter - pointer to the adapter block

    InterruptStatus - Current Interrupt Status.

Return Value:

    The type of the interrupt

--*/
#define CARD_GET_INTERRUPT_TYPE(_A, _I)                 \
  (_I & ISR_COUNTER) ?                               \
      COUNTER :                                      \
      (_I & ISR_OVERFLOW ) ?                         \
      SyncCardUpdateCounters(_A), OVERFLOW :                 \
        (_I & (ISR_XMIT|ISR_XMIT_ERR)) ?           \
          TRANSMIT :                                     \
        (_I & ISR_RCV) ?                               \
          RECEIVE :                                  \
        (_I & ISR_RCV_ERR) ?                           \
              SyncCardUpdateCounters(_A), RECEIVE :  \
              UNKNOWN

#endif // NE2000SFT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\ne2000\ne2000hw.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    ne2000hw.h

Abstract:

    Hardware definitions.

Author:

    Sean Selitrennikoff

Environment:

Notes:

    optional-notes

Revision History:

--*/

#ifndef _NE2000HARDWARE_
#define _NE2000HARDWARE_


//
// Definitions for supporting clone adapters.
//

//
// Valid value ranges for the IoBaseAddress.
//
#ifdef NE1000
#define MIN_IOBASEADDR 0x0200
#else
#define MIN_IOBASEADDR 0x0120
#endif

#define MAX_IOBASEADDR 0xc3d0



//
// Valid value ranges for the InterruptNumber.
//
#define MIN_IRQ 2

#ifdef NE1000
#define MAX_IRQ 9
#else
#define MAX_IRQ 15
#endif


//
//  Types of Ne2000 cards.
//
#define NE2000_ISA                  0
#define NE2000_PCMCIA               1

//
// ID for MCA Ne2000 clone cards
//
#define AE2_ADAPTER_ID               0x67b0
#define UB_ADAPTER_ID                0x611f
#define NE2_ADAPTER_ID               0x7154

//
// Microchannel IRQ POS register mask and shift count
//
#define MC_IRQ_MASK     0x60
#define MC_IRQ_MASK_UB  0x0E


//
// Microchannel I/O base address mask and shift count
//
#define MC_IO_BASE_MASK      0x0E
#define MC_IO_BASE_MASK_UB   0xE0

//
// Default value for Adapter->IoBaseAddr
//
#define DEFAULT_IOBASEADDR (PVOID)0x300

#define CIS_NET_ADDR_OFFSET 0xff0

//
// Default value for Adapter->InterruptNumber
//
#define DEFAULT_INTERRUPTNUMBER 3


//
// Default value for Adapter->MulticastListMax
//
#define DEFAULT_MULTICASTLISTMAX 8


//
// Offsets from Adapter->IoPAddr of the ports used to access
// the 8390 NIC registers.
//
// The names in parenthesis are the abbreviations by which
// the registers are referred to in the 8390 data sheet.
//
// Some of the offsets appear more than once
// because they have have relevant page 0 and page 1 values,
// or they are different registers when read than they are
// when written. The notation MSB indicates that only the
// MSB can be set for this register, the LSB is assumed 0.
//

#define NIC_COMMAND         0x0     // (CR)
#define NIC_PAGE_START      0x1     // (PSTART)   MSB, write-only
#define NIC_PHYS_ADDR       0x1     // (PAR0)     page 1
#define NIC_PAGE_STOP       0x2     // (PSTOP)    MSB, write-only
#define NIC_BOUNDARY        0x3     // (BNRY)     MSB
#define NIC_XMIT_START      0x4     // (TPSR)     MSB, write-only
#define NIC_XMIT_STATUS     0x4     // (TSR)      read-only
#define NIC_XMIT_COUNT_LSB  0x5     // (TBCR0)    write-only
#define NIC_XMIT_COUNT_MSB  0x6     // (TBCR1)    write-only
#define NIC_FIFO            0x6     // (FIFO)     read-only
#define NIC_INTR_STATUS     0x7     // (ISR)
#define NIC_CURRENT         0x7     // (CURR)     page 1
#define NIC_MC_ADDR         0x8     // (MAR0)     page 1
#define NIC_CRDA_LSB        0x8     // (CRDA0)
#define NIC_RMT_ADDR_LSB    0x8     // (RSAR0)
#define NIC_CRDA_MSB        0x9     // (CRDA1)
#define NIC_RMT_ADDR_MSB    0x9     // (RSAR1)
#define NIC_RMT_COUNT_LSB   0xa     // (RBCR0)    write-only
#define NIC_RMT_COUNT_MSB   0xb     // (RBCR1)    write-only
#define NIC_RCV_CONFIG      0xc     // (RCR)      write-only
#define NIC_RCV_STATUS      0xc     // (RSR)      read-only
#define NIC_XMIT_CONFIG     0xd     // (TCR)      write-only
#define NIC_FAE_ERR_CNTR    0xd     // (CNTR0)    read-only
#define NIC_DATA_CONFIG     0xe     // (DCR)      write-only
#define NIC_CRC_ERR_CNTR    0xe     // (CNTR1)    read-only
#define NIC_INTR_MASK       0xf     // (IMR)      write-only
#define NIC_MISSED_CNTR     0xf     // (CNTR2)    read-only
#define NIC_RACK_NIC        0x10    // Byte to read or write
#define NIC_RESET           0x1f    // (RESET)


//
// Constants for the NIC_COMMAND register.
//
// Start/stop the card, start transmissions, and select
// which page of registers was seen through the ports.
//

#define CR_STOP         (UCHAR)0x01        // reset the card
#define CR_START        (UCHAR)0x02        // start the card
#define CR_XMIT         (UCHAR)0x04        // begin transmission
#define CR_NO_DMA       (UCHAR)0x20        // stop remote DMA

#define CR_PS0          (UCHAR)0x40        // low bit of page number
#define CR_PS1          (UCHAR)0x80        // high bit of page number
#define CR_PAGE0        (UCHAR)0x00        // select page 0
#define CR_PAGE1        CR_PS0             // select page 1
#define CR_PAGE2        CR_PS1             // select page 2

#define CR_DMA_WRITE    (UCHAR)0x10        // Write
#define CR_DMA_READ     (UCHAR)0x08        // Read
#define CR_SEND         (UCHAR)0x18        // send


//
// Constants for the NIC_XMIT_STATUS register.
//
// Indicate the result of a packet transmission.
//

#define TSR_XMIT_OK     (UCHAR)0x01        // transmit with no errors
#define TSR_COLLISION   (UCHAR)0x04        // collided at least once
#define TSR_ABORTED     (UCHAR)0x08        // too many collisions
#define TSR_NO_CARRIER  (UCHAR)0x10        // carrier lost
#define TSR_NO_CDH      (UCHAR)0x40        // no collision detect heartbeat


//
// Constants for the NIC_INTR_STATUS register.
//
// Indicate the cause of an interrupt.
//

#define ISR_EMPTY       (UCHAR)0x00        // no bits set in ISR
#define ISR_RCV         (UCHAR)0x01        // packet received with no errors
#define ISR_XMIT        (UCHAR)0x02        // packet transmitted with no errors
#define ISR_RCV_ERR     (UCHAR)0x04        // error on packet reception
#define ISR_XMIT_ERR    (UCHAR)0x08        // error on packet transmission
#define ISR_OVERFLOW    (UCHAR)0x10        // receive buffer overflow
#define ISR_COUNTER     (UCHAR)0x20        // MSB set on tally counter
#define ISR_DMA_DONE    (UCHAR)0x40        // RDC
#define ISR_RESET       (UCHAR)0x80        // (not an interrupt) card is reset


//
// Constants for the NIC_RCV_CONFIG register.
//
// Configure what type of packets are received.
//

#define RCR_REJECT_ERR  (UCHAR)0x00        // reject error packets
#define RCR_BROADCAST   (UCHAR)0x04        // receive broadcast packets
#define RCR_MULTICAST   (UCHAR)0x08        // receive multicast packets
#define RCR_ALL_PHYS    (UCHAR)0x10        // receive ALL directed packets
#define RCR_MONITOR     (UCHAR)0x20        // don't collect packets


//
// Constants for the NIC_RCV_STATUS register.
//
// Indicate the status of a received packet.
//
// These are also used to interpret the status byte in the
// packet header of a received packet.
//

#define RSR_PACKET_OK   (UCHAR)0x01        // packet received with no errors
#define RSR_CRC_ERROR   (UCHAR)0x02        // packet received with CRC error
#define RSR_MULTICAST   (UCHAR)0x20        // packet received was multicast
#define RSR_DISABLED    (UCHAR)0x40        // received is disabled
#define RSR_DEFERRING   (UCHAR)0x80        // receiver is deferring


//
// Constants for the NIC_XMIT_CONFIG register.
//
// Configures how packets are transmitted.
//

#define TCR_NO_LOOPBACK (UCHAR)0x00        // normal operation
#define TCR_LOOPBACK    (UCHAR)0x02        // loopback (set when NIC is stopped)

#define TCR_INHIBIT_CRC (UCHAR)0x01        // inhibit appending of CRC

#define TCR_NIC_LBK     (UCHAR)0x02        // loopback through the NIC
#define TCR_SNI_LBK     (UCHAR)0x04        // loopback through the SNI
#define TCR_COAX_LBK    (UCHAR)0x06        // loopback to the coax


//
// Constants for the NIC_DATA_CONFIG register.
//
// Set data transfer sizes.
//

#define DCR_BYTE_WIDE   (UCHAR)0x00        // byte-wide DMA transfers
#define DCR_WORD_WIDE   (UCHAR)0x01        // word-wide DMA transfers

#define DCR_LOOPBACK    (UCHAR)0x00        // loopback mode (TCR must be set)
#define DCR_NORMAL      (UCHAR)0x08        // normal operation

#define DCR_FIFO_2_BYTE (UCHAR)0x00        // 2-byte FIFO threshhold
#define DCR_FIFO_4_BYTE (UCHAR)0x20        // 4-byte FIFO threshhold
#define DCR_FIFO_8_BYTE (UCHAR)0x40        // 8-byte FIFO threshhold
#define DCR_FIFO_12_BYTE (UCHAR)0x60       // 12-byte FIFO threshhold
#define DCR_AUTO_INIT   (UCHAR)0x10        // Auto-init to remove packets from ring


//
// Constants for the NIC_INTR_MASK register.
//
// Configure which ISR settings actually cause interrupts.
//

#define IMR_RCV         (UCHAR)0x01        // packet received with no errors
#define IMR_XMIT        (UCHAR)0x02        // packet transmitted with no errors
#define IMR_RCV_ERR     (UCHAR)0x04        // error on packet reception
#define IMR_XMIT_ERR    (UCHAR)0x08        // error on packet transmission
#define IMR_OVERFLOW    (UCHAR)0x10        // receive buffer overflow
#define IMR_COUNTER     (UCHAR)0x20        // MSB set on tally counter


//++
//
// VOID
// CardStart(
//    IN PNE2000_ADAPTER Adapter
//    )
//
//
// Routine Description:
//
//    Starts the card.
//
// Arguments:
//
//    Adapter - pointer to the adapter block
//
// Return Value:
//
//    None.
//
//--
    //
    // Assume that the card has been stopped as in CardStop.
    //

#define CardStart(Adapter) \
    NdisRawWritePortUchar(((Adapter->IoPAddr)+NIC_XMIT_CONFIG), TCR_NO_LOOPBACK)



//++
//
// VOID
// CardSetAllMulticast(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Enables every bit in the card multicast bit mask.
//  Calls SyncCardSetAllMulticast.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardSetAllMulticast(Adapter) \
    NdisMSynchronizeWithInterrupt(&(Adapter)->Interrupt, \
                SyncCardSetAllMulticast, (PVOID)(Adapter))


//++
//
// VOID
// CardCopyMulticastRegs(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Writes out the entire multicast bit mask to the card from
//  Adapter->NicMulticastRegs.  Calls SyncCardCopyMulticastRegs.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardCopyMulticastRegs(Adapter) \
    NdisMSynchronizeWithInterrupt(&(Adapter)->Interrupt, \
                SyncCardCopyMulticastRegs, (PVOID)(Adapter))



//++
//
// VOID
// CardGetInterruptStatus(
//     IN PNE2000_ADAPTER Adapter,
//     OUT PUCHAR InterrupStatus
//     )
//
// Routine Description:
//
//  Reads the interrupt status (ISR) register from the card. Only
//  called at IRQL INTERRUPT_LEVEL.
//
// Arguments:
//
//  Adapter - The adapter block.
//
//  InterruptStatus - Returns the value of ISR.
//
// Return Value:
//
//--

#define CardGetInterruptStatus(_Adapter,_InterruptStatus) \
    NdisRawReadPortUchar(((_Adapter)->IoPAddr+NIC_INTR_STATUS), (_InterruptStatus))


//++
//
// VOID
// CardSetReceiveConfig(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Sets the receive configuration (RCR) register on the card.
//  The value used is Adapter->NicReceiveConfig. Calls
//  SyncCardSetReceiveConfig.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardSetReceiveConfig(Adapter) \
    NdisMSynchronizeWithInterrupt(&(Adapter)->Interrupt, \
                SyncCardSetReceiveConfig, (PVOID)(Adapter))


//++
//
// VOID
// CardBlockInterrupts(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Blocks all interrupts from the card by clearing the
//  interrupt mask (IMR) register. Only called from
//  IRQL INTERRUPT_LEVEL.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardBlockInterrupts(Adapter) \
    NdisRawWritePortUchar(((Adapter)->IoPAddr+NIC_INTR_MASK), 0)


//++
//
// VOID
// CardUnblockInterrupts(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Unblocks all interrupts from the card by setting the
//  interrupt mask (IMR) register. Only called from IRQL
//  INTERRUPT_LEVEL.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardUnblockInterrupts(Adapter) \
    NdisRawWritePortUchar(\
            ((Adapter)->IoPAddr+NIC_INTR_MASK), \
            (Adapter)->NicInterruptMask)

//++
//
// VOID
// CardAcknowledgeOverflowInterrupt(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Acknowledges an overflow interrupt by setting the bit in
//  the interrupt status (ISR) register. Calls
//  SyncCardAcknowledgeOverflow.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardAcknowledgeOverflowInterrupt(Adapter) \
     SyncCardAcknowledgeOverflow(Adapter)


//++
//
// VOID
// CardAcknowledgeCounterInterrupt(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Acknowledges a counter interrupt by setting the bit in
//  the interrupt status (ISR) register.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardAcknowledgeCounterInterrupt(Adapter) \
    NdisRawWritePortUchar(((Adapter)->IoPAddr+NIC_INTR_STATUS), ISR_COUNTER)

//++
//
// VOID
// CardUpdateCounters(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Updates the values of the three counters (frame alignment
//  errors, CRC errors, and missed packets) by reading in their
//  current values from the card and adding them to the ones
//  stored in the Adapter structure. Calls SyncCardUpdateCounters.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardUpdateCounters(Adapter) \
    NdisMSynchronizeWithInterrupt(&(Adapter)->Interrupt, \
                SyncCardUpdateCounters, (PVOID)(Adapter))


#endif // _NE2000HARDWARE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\nec\detect\nibcdet\sources.inc ===
MAJORCOMP = net
MINORCOMP = nibcdet

TARGETNAME=nibcdet
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=\
    $(SDK_LIB_PATH)\netdtect.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\netdet.lib

DLLENTRY=NibcDetInit

INCLUDES=..; \
         $(BASEDIR)\private\ntos\inc; \
         $(BASEDIR)\private\inc\net

C_DEFINES=$(C_DEFINES) -D_PNP_POWER=1

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\nibcdet.c  \
        ..\nibcdet.rc

DLLDEF=..\nibcdet.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\ne2000\precomp.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    precomp.h

Abstract:

    Precompile header file.

Author:

    Sean Selitrennikoff

Environment:

Notes:

    optional-notes

Revision History:

--*/

#include <ndis.h>
#include "ne2000hw.h"
#include "ne2000sw.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\nec\drivers\nec_98\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\nec\detect\r81wdet\r81wdet.c ===
#if 1 // The following includes are used when building with the microsoft internal build tree.
  #include <nt.h>
  #include <ntrtl.h>
  #include <nturtl.h>
  #include <windows.h>
#else // These headers are used when building with the microsoft DDK.
  #include <ntddk.h>
  #include <windef.h>
  #include <winerror.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ntddnetd.h>
#include <ncnet.h>
#include <netdet.h>

BOOLEAN
R81wDetInit(
  IN  HANDLE  hModule,
  IN  DWORD   dwReason,
  IN  DWORD   dwReserved
  )
/*++

Routine Description:
  This routine is the entry point into the detection dll.
  This routine only return "TRUE".

++*/
{
  return (TRUE);
}



ULONG
R81wNextIoAddress(
  IN  ULONG  IoBaseAddress
  )
/*++

Routine Description:
  This routine provide next I/O address for detect PC-9801-111.

++*/
{
  switch(IoBaseAddress){
    case 0x0888:
      return (0x1888);
    case 0x1888:
      return (0x2888);
    case 0x2888:
      return (0x3888);
    default:
      return (0xffff);
  }
}



NTSTATUS
FindR81wAdapter(
  OUT  PMND_ADAPTER_INFO	*pDetectedAdapter,
  IN   INTERFACE_TYPE		InterfaceType,
  IN   ULONG				BusNumber,
  IN   ULONG				IoBaseAddress,
  IN   PWSTR				pPnpId
  )
{
  NTSTATUS  NtStatus;
  UCHAR     Data;
  USHORT    CheckSum = 0;
  USHORT    StoredCheckSum;
  UINT      Place;
  UCHAR     Interrupt = 0;
  HANDLE    TrapHandle;
  UCHAR     InterruptList[8];
  UCHAR     ResultList[8] = {0};
  UINT      cResources;
  UINT      c;
  UCHAR     Value;
  ULONG     MemoryBaseAddress = 0;

  do{

    // check I/O port range.
    NtStatus = NDetCheckPortUsage(InterfaceType,
                                  BusNumber,
                                  IoBaseAddress,
                                  0x4);

    if(!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("FindR81wAdapter : Port range in use. IoBaseAddress = %x\n", IoBaseAddress);
      #endif

      break;
    }

    // check board ID.
    // 111's ID is 0x67.
    NDetWritePortUchar(InterfaceType,
                       BusNumber,
                       IoBaseAddress + 0x003,
                       0x88);
    NDetReadPortUchar(InterfaceType,
                      BusNumber,
                      IoBaseAddress + 0x001,
                      &Value);
    if(Value != 0x67){
      NtStatus = STATUS_NOT_FOUND;
      #if DBG
        DbgPrint("R81WDET : Board ID is invalid.\n");
        DbgPrint("R81WDET : I/O port is %x.\n",IoBaseAddress);
      #endif
      break;
    }

    // check interrupt.
    InterruptList[0] = 3;
    InterruptList[1] = 5;
    InterruptList[2] = 6;
    InterruptList[3] = 9;
    InterruptList[4] = 10;
    InterruptList[5] = 12;
    InterruptList[6] = 13;

    NtStatus = NDetSetInterruptTrap(InterfaceType,
                                    BusNumber,
                                    &TrapHandle,
                                    InterruptList,
                                    7);
    if(NT_SUCCESS(NtStatus)){
      NtStatus = NDetQueryInterruptTrap(TrapHandle, ResultList, 7);
      NtStatus = NDetRemoveInterruptTrap(TrapHandle);
  
      if(!NT_SUCCESS(NtStatus)){
        #if DBG
          DbgPrint("R81WDET : RemoveInterrupt failed.");
        #endif
        break;
      }
  
      for(c=0 ; c<7 ; c++){
        if((ResultList[c] == 1) || (ResultList[c] == 2)){
          Interrupt = InterruptList[c];
          break;
        }
      }
    }else{
      #if DBG
        DbgPrint("R81WDET : SetInterrupt failed\n");
      #endif
    }

    for(c=0 ; c<16 ; c++){
      MemoryBaseAddress = 0xc0000 + (0x2000 * c);
      if(MemoryBaseAddress == 0xd0000){
        continue;
      }
      NtStatus = NDetCheckMemoryUsage(
                   InterfaceType,
                   BusNumber,
                   MemoryBaseAddress,
                   0x2000);
      if (NT_SUCCESS(NtStatus))
      {
        break;
      }
    }

    // Allocate the adapter information.
    NtStatus = NetDetectAllocAdapterInfo(pDetectedAdapter,
                                         InterfaceType,
                                         BusNumber,
                                         pPnpId,
                                         0,
                                         0,
                                         0,
                                         2);
    if (!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("FindR81wAdapter: Unable to allocate adapter info\n");
      #endif
      break;
    }

    #if DBG
      DbgPrint("I/O port is %x\n",IoBaseAddress);
      DbgPrint("IRQ is %x\n",Interrupt);
      DbgPrint("Memory address is %x\n",MemoryBaseAddress);
    #endif

    //	Initialize the resources.
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                IoBaseAddress,
                                0x4);
    if(Interrupt != 0){
      NetDetectInitializeResource(*pDetectedAdapter,
                                  1,
                                  MndResourceInterrupt,
                                  Interrupt,
                                  MND_RESOURCE_INTERRUPT_LATCHED);
    }
    if(MemoryBaseAddress != 0){
      NetDetectInitializeResource(*pDetectedAdapter,
                                  1,
                                  MndResourceMemory,
                                  MemoryBaseAddress,
                                  0x2000);
    }

    NtStatus = STATUS_SUCCESS;

  }while(FALSE);

  return (NtStatus);

}

NTSTATUS
WINAPI
FindAdapterHandler(
  IN  OUT  PMND_ADAPTER_INFO  *pDetectedAdapter,
  IN  INTERFACE_TYPE          InterfaceType,
  IN  ULONG                   BusNumber,
  IN  PDET_ADAPTER_INFO       pAdapterInfo,
  IN  PDET_CONTEXT            pDetContext
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
  NTSTATUS  NtStatus;
  ULONG     IoBaseAddress;

  if(InterfaceType != Isa){
    return(STATUS_INVALID_PARAMETER);
  }

  // Are we looking for the first adapter?
  if (fDET_CONTEXT_FIND_FIRST == (pDetContext->Flags & fDET_CONTEXT_FIND_FIRST)){
    // Initialize the context information so that we start detecting
    // at the initialize port range.
    pDetContext->ISA.IoBaseAddress = 0x0888;
  }

  for (IoBaseAddress = pDetContext->ISA.IoBaseAddress;
       IoBaseAddress <= 0x3888;
       IoBaseAddress = R81wNextIoAddress(IoBaseAddress)){

    //  Look for the PC-9801-111 adapter at the current port.
    NtStatus = FindR81wAdapter(pDetectedAdapter,
                           InterfaceType,
                           BusNumber,
                           IoBaseAddress,
                           pAdapterInfo->PnPId);

    if (NT_SUCCESS(NtStatus)){
      // We found an adapter. Save the next IO address to check.
      #if DBG
        DbgPrint("R81WDET : We found an PC-9801-111\n");
      #endif
      pDetContext->ISA.IoBaseAddress = R81wNextIoAddress(IoBaseAddress);
      break;
    }
  }

  if (0xffff == IoBaseAddress){
    NtStatus = STATUS_NO_MORE_ENTRIES;
  }

  return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\nec\detect\nia35det\nia35det.c ===
#if 1 // The following includes are used when building with the microsoft internal build tree.
  #include <nt.h>
  #include <ntrtl.h>
  #include <nturtl.h>
  #include <windows.h>
#else // These headers are used when building with the microsoft DDK.
  #include <ntddk.h>
  #include <windef.h>
  #include <winerror.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ntddnetd.h>
#include <ncnet.h>
#include <netdet.h>

BOOLEAN
Nia35DetInit(
  IN  HANDLE  hModule,
  IN  DWORD   dwReason,
  IN  DWORD   dwReserved
  )
/*++

Routine Description:
  This routine is the entry point into the detection dll.
  This routine only return "TRUE".

++*/
{
  return (TRUE);
}



ULONG
Nia35NextIoAddress(
  IN  ULONG  IoBaseAddress
  )
/*++

Routine Description:
  This routine provide next I/O address for detect PC-9801-107/108.

++*/
{
  switch(IoBaseAddress){
    case 0x0770:
      return (0x2770);
    case 0x2770:
      return (0x4770);
    case 0x4770:
      return (0x6770);
    default:
      return (0xffff);
  }
}


VOID
Nia35CardSetup(
    IN   INTERFACE_TYPE  InterfaceType,
    IN   ULONG           BusNumber,
    IN   ULONG           IoBaseAddress,
    OUT  PULONG          MemoryBaseAddress,
    IN   BOOLEAN         EightBitSlot
    )
/*++

Routine Description:

    Sets up the card, using the sequence given in the Etherlink II
    technical reference.

Arguments:

    InterfaceType               -       The type of bus, ISA or EISA.
    BusNumber                   -       The bus number in the system.
    IoBaseAddress               -       The IO port address of the card.
    MemoryBaseAddress           -       Pointer to store the base address of card memory.
    EightBitSlot                -       TRUE if the adapter is in an 8-bit slot.

Return Value:

    None.

--*/
{
  UINT           i;
  UCHAR          Tmp;
  NTSTATUS       NtStatus;
  LARGE_INTEGER  Delay;

  *MemoryBaseAddress = 0;

  // Stop the card.
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x21); // STOP | ABORT_DMA
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

    // Initialize the Data Configuration register.
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100c, // NIC_DATA_CONFIG
                                0x50); // DCR_AUTO_INIT | DCR_FIFO_8_BYTE
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Xmit start location
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x0008, // NIC_XMIT_START
                                0xA0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Xmit configuration
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100a, // NIC_XMIT_CONFIG
                                0x0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Receive configuration
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1008, // NIC_RCV_CONFIG
                                0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Receive start
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x0002, // NIC_PAGE_START
                                0x4);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Receive end
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x0004, // NIC_PAGE_STOP
                                0xFF);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Receive boundary
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x0006, // NIC_BOUNDARY
                                0x4);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Xmit bytes
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000a, // NIC_XMIT_COUNT_LSB
                                0x3C);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000c, //  NIC_XMIT_COUNT_MSB
                                0x0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Pause

  // Wait for reset to complete. (100 ms)
  Delay.LowPart = 100000;
  Delay.HighPart = 0;

  NtDelayExecution(FALSE, &Delay);

  // Ack all interrupts that we might have produced
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000e, // NIC_INTR_STATUS
                                0xFF);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Change to page 1
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x61); // CR_PAGE1 | CR_STOP

  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set current
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000e, // NIC_CURRENT
                                0x4);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Back to page 0
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x21); // CR_PAGE0 | CR_STOP
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Pause
  Delay.LowPart = 2000;
  Delay.HighPart = 0;

  NtDelayExecution(FALSE, &Delay);

  // Do initialization errata
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1004, // NIC_RMT_COUNT_LSB
                                55);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Reset the chip
  NtStatus = NDetReadPortUchar(InterfaceType,
                               BusNumber,
                               ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                               &Tmp);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                                0xFF);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Start the chip
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x22);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Mask Interrupts
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100e, // NIC_INTR_MASK
                                0xFF);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  if(EightBitSlot){
    NtStatus = NDetWritePortUchar(InterfaceType,
                                  BusNumber,
                                  IoBaseAddress + 0x100c, // NIC_DATA_CONFIG
                                  0x48); // DCR_FIFO_8_BYTE | DCR_NORMAL | DCR_BYTE_WIDE
  }else{
    NtStatus = NDetWritePortUchar(InterfaceType,
                                  BusNumber,
                                  IoBaseAddress + 0x100c, // NIC_DATA_CONFIG
                                  0x49); // DCR_FIFO_8_BYTE | DCR_NORMAL | DCR_WORD_WIDE
  }

  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100a, // NIC_XMIT_CONFIG
                                0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1008, // NIC_RCV_CONFIG
                                0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000e, // NIC_INTR_STATUS
                                0xFF);
 if(!NT_SUCCESS(NtStatus)){
   return;
 }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x21); // CR_NO_DMA | CR_STOP

  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1004, // NIC_RMT_COUNT_LSB
                                0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1006, // NIC_RMT_COUNT_MSB
                                0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Wait for STOP to complete
  i = 0xFF;
  while (--i){
    NtStatus = NDetReadPortUchar(InterfaceType,
                                 BusNumber,
                                 IoBaseAddress + 0x000e, // NIC_INTR_STATUS
                                 &Tmp);
    if(!NT_SUCCESS(NtStatus)){
      return;
    }

    // ISR_RESET
    if(Tmp & 0x80){
      break;
    }
  }

  // Put card in loopback mode
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100a, // NIC_XMIT_CONFIG
                                0x2); // TCR_LOOPBACK

  if(NtStatus != STATUS_SUCCESS){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x22); // CR_NO_DMA | CR_START

  if(NtStatus != STATUS_SUCCESS){
    return;
  }

  // ... but it is still in loopback mode.
  return;
}


NTSTATUS
Nia35CardSlotTest(
    IN   INTERFACE_TYPE  InterfaceType,
    IN   ULONG           BusNumber,
    IN   ULONG           IoBaseAddress,
    OUT  PBOOLEAN        EightBitSlot
    )
/*++

Routine Description:

    Checks if the card is in an 8 or 16 bit slot and sets a flag in the
    adapter structure.

Arguments:


    InterfaceType       -       The type of bus, ISA or EISA.
    BusNumber           -       The bus number in the system.
    IoBaseAddress       -       The IO port address of the card.
    EightBitSlot        -       Result of test.

Return Value:

    TRUE, if all goes well, else FALSE.

--*/

{
  UCHAR          Tmp;
  UCHAR          RomCopy[32];
  UCHAR          i;
  NTSTATUS       NtStatus;
  LARGE_INTEGER  Delay;

  // Reset the chip
  NtStatus = NDetReadPortUchar(InterfaceType,
                               BusNumber,
                               ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                               &Tmp);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                                0xFF);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  // Go to page 0 and stop
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x21); // CR_STOP | CR_NO_DMA

  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  // Pause
  Delay.LowPart = 2000;
  Delay.HighPart = 0;

  NtDelayExecution(FALSE, &Delay);

  // Setup to read from ROM
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100c, // NIC_DATA_CONFIG
                                0x48); // DCR_BYTE_WIDE | DCR_FIFO_8_BYTE | DCR_NORMAL

  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100e, // NIC_INTR_MASK
                                0x0);

  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  // Ack any interrupts that may be hanging around
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000e, // NIC_INTR_STATUS
                                0xFF);

  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1000, // NIC_RMT_ADDR_LSB
                                0x0);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1002, // NIC_RMT_ADDR_MSB,
                                0x0);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1004, // NIC_RMT_COUNT_LSB
                                32);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1006, // NIC_RMT_COUNT_MSB
                                0x0);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0xA); // CR_DMA_READ | CR_START

  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  // Read first 32 bytes in 16 bit mode
  for (i = 0; i < 32; i++){
    NtStatus = NDetReadPortUchar(InterfaceType,
                                 BusNumber,
                                 ((IoBaseAddress >> 1) & 0xf000) + 0x0888, //NIC_RACK_NIC
                                 RomCopy + i);

    if(NtStatus != STATUS_SUCCESS){
      return(NtStatus);
    }
  }

  // Reset the chip
  NtStatus = NDetReadPortUchar(InterfaceType,
                               BusNumber,
                               ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                               &Tmp);

  if(NtStatus != STATUS_SUCCESS){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                                0xFF);
  if(NtStatus != STATUS_SUCCESS){
    return(NtStatus);
  }

  // Check ROM for 'B' (byte) or 'W' (word)
  for (i = 16; i < 31; i++){
    if (((RomCopy[i] == 'B') && (RomCopy[i+1] == 'B')) ||
       ((RomCopy[i] == 'W') && (RomCopy[i+1] == 'W'))){
         if(RomCopy[i] == 'B'){
           *EightBitSlot = TRUE;
         }else{
           *EightBitSlot = FALSE;
         }

         // Now check that the address is singular.  On an Ne1000 the
         // ethernet address is store in offsets 0 thru 5.  On the Ne2000 and Nia35
         // the address is stored in offsets 0 thru 11, where each byte
         // is duplicated.
         //
         if ((RomCopy[0] == RomCopy[1]) &&
             (RomCopy[2] == RomCopy[3]) &&
             (RomCopy[4] == RomCopy[5]) &&
             (RomCopy[6] == RomCopy[7]) &&
             (RomCopy[8] == RomCopy[9]) &&
             (RomCopy[10] == RomCopy[11])){
               return(STATUS_SUCCESS);
         }

         return(STATUS_UNSUCCESSFUL);
    }
  }

  // If neither found -- then not an NIA35
  return(STATUS_UNSUCCESSFUL);
}



NTSTATUS
FindNia35Adapter(
  OUT  PMND_ADAPTER_INFO        *pDetectedAdapter,
  IN   INTERFACE_TYPE           InterfaceType,
  IN   ULONG                            BusNumber,
  IN   ULONG                            IoBaseAddress,
  IN   PWSTR                            pPnpId
  )
{
  NTSTATUS  NtStatus;
  UCHAR     Data;
  USHORT    CheckSum = 0;
  USHORT    StoredCheckSum;
  UINT      Place;
  UCHAR     Interrupt = 0;
  HANDLE    TrapHandle;
  UCHAR     InterruptList[4];
  UCHAR     ResultList[4] = {0};
  UINT      cResources;
  UINT      c;
  UCHAR     Value;
  ULONG     RamAddr = 0;

  do{

    // check I/O port range.
    NtStatus = NDetCheckPortUsage(InterfaceType,
                                  BusNumber,
                                  IoBaseAddress,
                                  0x10);
    NtStatus |= NDetCheckPortUsage(InterfaceType,
                                   BusNumber,
                                   IoBaseAddress + 0x1000,  // upper range
                                   0x10);
    NtStatus |= NDetCheckPortUsage(InterfaceType,
                                   BusNumber,
                                   ((IoBaseAddress >> 1) & 0xf000) + 0x0888, // NIC_RACK_NIC
                                   0x2);
    NtStatus |= NDetCheckPortUsage(InterfaceType,
                                   BusNumber,
                                   ((IoBaseAddress >> 1) & 0xf000) + 0x088a, // NIC_RESET
                                   0x2);

    if(!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("FindNia35Adapter : Port range in use. IoBaseAddress = %x\n", IoBaseAddress);
      #endif
      break;
    }

    NDetReadPortUchar(InterfaceType,
                      BusNumber,
                      ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                      &Value);
    NDetWritePortUchar(InterfaceType,
                       BusNumber,
                       ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                       0xFF);
    NDetWritePortUchar(InterfaceType,
                       BusNumber,
                       IoBaseAddress, // COMMAND
                       0x21);

    // check interrupt.
    InterruptList[0] = 3;
    InterruptList[1] = 5;
    InterruptList[2] = 6;
    InterruptList[3] = 12;

    NtStatus = NDetSetInterruptTrap(InterfaceType,
                                    BusNumber,
                                    &TrapHandle,
                                    InterruptList,
                                    4);
    if(NT_SUCCESS(NtStatus)){

      NtStatus = Nia35CardSlotTest(InterfaceType,
                                   BusNumber,
                                   IoBaseAddress,
                                   &Value);
      if(!NT_SUCCESS(NtStatus)){
        NDetRemoveInterruptTrap(TrapHandle);
        break;
      }

      // CardSetup
      Nia35CardSetup(InterfaceType,
                    BusNumber,
                    IoBaseAddress,
                    &RamAddr,
                    Value);

      // Check for interrupt.
      NtStatus = NDetQueryInterruptTrap(TrapHandle, ResultList, 4);

      // Stop the chip.
      NDetReadPortUchar(InterfaceType,
                        BusNumber,
                        ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                        &Value);

      NDetWritePortUchar(InterfaceType,
                         BusNumber,
                         ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                         0xFF);

      NDetWritePortUchar(InterfaceType,
                         BusNumber,
                         IoBaseAddress, // COMMAND
                         0x21);

      NtStatus = NDetRemoveInterruptTrap(TrapHandle);
      if(!NT_SUCCESS(NtStatus)){
        break;
      }
  
      for(c=0 ; c<4 ; c++){
        if((ResultList[c] == 1) || (ResultList[c] == 2)){
          Interrupt = InterruptList[c];
          break;
        }
      }
    }

    // Allocate the adapter information.
    NtStatus = NetDetectAllocAdapterInfo(pDetectedAdapter,
                                         InterfaceType,
                                         BusNumber,
                                         pPnpId,
                                         0,
                                         0,
                                         0,
                                         2);
    if (!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("FindNia35Adapter: Unable to allocate adapter info\n");
      #endif
      break;
    }

    //  Initialize the resources.
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                IoBaseAddress,
                                0x10);
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                IoBaseAddress + 0x1000,
                                0x10);
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                ((IoBaseAddress >> 1) & 0xf000) + 0x0888, // NIC_RACK_NIC
                                0x2);
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                ((IoBaseAddress >> 1) & 0xf000) + 0x088a, // NIC_RESET
                                0x2);


    if(Interrupt != 0){
      NetDetectInitializeResource(*pDetectedAdapter,
                                  1,
                                  MndResourceInterrupt,
                                  Interrupt,
                                  MND_RESOURCE_INTERRUPT_LATCHED);
    }

    NtStatus = STATUS_SUCCESS;

  }while(FALSE);

  return (NtStatus);

}

NTSTATUS
WINAPI
FindAdapterHandler(
  IN  OUT  PMND_ADAPTER_INFO  *pDetectedAdapter,
  IN  INTERFACE_TYPE          InterfaceType,
  IN  ULONG                   BusNumber,
  IN  PDET_ADAPTER_INFO       pAdapterInfo,
  IN  PDET_CONTEXT            pDetContext
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
  NTSTATUS  NtStatus;
  ULONG     IoBaseAddress;

  if(InterfaceType != Isa){
    return(STATUS_INVALID_PARAMETER);
  }

  // Are we looking for the first adapter?
  if (fDET_CONTEXT_FIND_FIRST == (pDetContext->Flags & fDET_CONTEXT_FIND_FIRST)){
    // Initialize the context information so that we start detecting
    // at the initialize port range.
    pDetContext->ISA.IoBaseAddress = 0x0770;
  }

  for (IoBaseAddress = pDetContext->ISA.IoBaseAddress;
       IoBaseAddress <= 0x6770;
       IoBaseAddress = Nia35NextIoAddress(IoBaseAddress)){

    //  Look for the ee16 adapter at the current port.
    NtStatus = FindNia35Adapter(pDetectedAdapter,
                           InterfaceType,
                           BusNumber,
                           IoBaseAddress,
                           pAdapterInfo->PnPId);

    if (NT_SUCCESS(NtStatus)){
      // We found an adapter. Save the next IO address to check.
      pDetContext->ISA.IoBaseAddress = Nia35NextIoAddress(IoBaseAddress);
      break;
    }
  }

  if (0xffff == IoBaseAddress){
    NtStatus = STATUS_NO_MORE_ENTRIES;
  }

  return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\nec\detect\nibcdet\nibcdet.c ===
#if 1 // The following includes are used when building with the microsoft internal build tree.
  #include <nt.h>
  #include <ntrtl.h>
  #include <nturtl.h>
  #include <windows.h>
#else // These headers are used when building with the microsoft DDK.
  #include <ntddk.h>
  #include <windef.h>
  #include <winerror.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ntddnetd.h>
#include <ncnet.h>
#include <netdet.h>

BOOLEAN
NibcDetInit(
  IN  HANDLE  hModule,
  IN  DWORD   dwReason,
  IN  DWORD   dwReserved
  )
/*++

Routine Description:
  This routine is the entry point into the detection dll.
  This routine only return "TRUE".

++*/
{
  return (TRUE);
}



ULONG
NibcNextIoAddress(
  IN  ULONG  IoBaseAddress
  )
/*++

Routine Description:
  This routine provide next I/O address for detect PC-9801-83/84/103/104.

++*/
{
  switch(IoBaseAddress){
    case 0x0888:
      return (0x1888);
    case 0x1888:
      return (0x2888);
    case 0x2888:
      return (0x3888);
    default:
      return (0xffff);
  }
}



NTSTATUS
FindNibcAdapter(
  OUT  PMND_ADAPTER_INFO	*pDetectedAdapter,
  IN   INTERFACE_TYPE		InterfaceType,
  IN   ULONG				BusNumber,
  IN   ULONG				IoBaseAddress,
  IN   PWSTR				pPnpId
  )
{
  NTSTATUS  NtStatus;
  UCHAR     Data;
  USHORT    CheckSum = 0;
  USHORT    StoredCheckSum;
  UINT      Place;
  UCHAR     Interrupt = 0;
  HANDLE    TrapHandle;
  UCHAR     InterruptList[8];
  UCHAR     ResultList[8] = {0};
  UINT      cResources;
  UINT      c;
  UCHAR     Value;
  ULONG     MemoryBaseAddress = 0;

  do{

    // check I/O port range.
    NtStatus = NDetCheckPortUsage(InterfaceType,
                                  BusNumber,
                                  IoBaseAddress,
                                  0x4);

    if(!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("FindNibcAdapter : Port range in use. IoBaseAddress = %x\n", IoBaseAddress);
      #endif
      break;
    }

    // check board ID.
    // 83/84's ID is 0x05.
    NDetWritePortUchar(InterfaceType,
                       BusNumber,
                       IoBaseAddress + 0x003,
                       0x88);
    NDetReadPortUchar(InterfaceType,
                      BusNumber,
                      IoBaseAddress + 0x001,
                      &Value);
    if(Value != 0x05){
      NtStatus = STATUS_NOT_FOUND;
      #if DBG
        DbgPrint("ID is invalid. ID = %x\n",Value);
      #endif
      break;
    }

    // check interrupt.
    InterruptList[0] = 3;
    InterruptList[1] = 5;
    InterruptList[2] = 6;
    InterruptList[3] = 9;
    InterruptList[4] = 10;
    InterruptList[5] = 12;
    InterruptList[6] = 13;

    NtStatus = NDetSetInterruptTrap(InterfaceType,
                                    BusNumber,
                                    &TrapHandle,
                                    InterruptList,
                                    7);
    if(NT_SUCCESS(NtStatus)){
      NtStatus = NDetQueryInterruptTrap(TrapHandle, ResultList, 7);
      NtStatus = NDetRemoveInterruptTrap(TrapHandle);
  
      if(!NT_SUCCESS(NtStatus)){
        #if DBG
          DbgPrint("NDetRemoveInterruptTrap failed. Status = %x\n",NtStatus);
        #endif
        break;
      }
  
      for(c=0 ; c<7 ; c++){
        if((ResultList[c] == 1) || (ResultList[c] == 2)){
          Interrupt = InterruptList[c];
          break;
        }
      }
    }else{
      #if DBG
        DbgPrint("NDetSetInterruptTrap failed. Status = %x\n",NtStatus);
      #endif
    }

    for(c=0 ; c<16 ; c++){
      MemoryBaseAddress = 0xc0000 + (0x2000 * c);
      if(MemoryBaseAddress == 0xd0000){
        continue;
      }
      NtStatus = NDetCheckMemoryUsage(
                   InterfaceType,
                   BusNumber,
                   MemoryBaseAddress,
                   0x2000);
      if (NT_SUCCESS(NtStatus))
      {
        #if DBG
          DbgPrint("NDetCheckMemoryUsage success. Address = %x\n",MemoryBaseAddress);
        #endif
        break;
      }
    }

    // Allocate the adapter information.
    NtStatus = NetDetectAllocAdapterInfo(pDetectedAdapter,
                                         InterfaceType,
                                         BusNumber,
                                         pPnpId,
                                         0,
                                         0,
                                         0,
                                         2);
    if (!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("NetDetectAllocAdapterInfo failed. Status = %x\n",NtStatus);
      #endif
      break;
    }

    #if DBG
      DbgPrint("IoBaseAddress = %x\n",IoBaseAddress);
      DbgPrint("Interrupt = %x\n",Interrupt);
      DbgPrint("MemoryAddress = %x\n",MemoryBaseAddress);
    #endif

    //	Initialize the resources.
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                IoBaseAddress,
                                0x4);
    if(Interrupt != 0){
      NetDetectInitializeResource(*pDetectedAdapter,
                                  1,
                                  MndResourceInterrupt,
                                  Interrupt,
                                  MND_RESOURCE_INTERRUPT_LATCHED);
    }
    if(MemoryBaseAddress != 0){
      NetDetectInitializeResource(*pDetectedAdapter,
                                  1,
                                  MndResourceMemory,
                                  MemoryBaseAddress,
                                  0x2000);
    }

    NtStatus = STATUS_SUCCESS;

  }while(FALSE);

  return (NtStatus);

}

NTSTATUS
WINAPI
FindAdapterHandler(
  IN  OUT  PMND_ADAPTER_INFO  *pDetectedAdapter,
  IN  INTERFACE_TYPE          InterfaceType,
  IN  ULONG                   BusNumber,
  IN  PDET_ADAPTER_INFO       pAdapterInfo,
  IN  PDET_CONTEXT            pDetContext
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
  NTSTATUS  NtStatus;
  ULONG     IoBaseAddress;

  if(InterfaceType != Isa){
    return(STATUS_INVALID_PARAMETER);
  }

  // Are we looking for the first adapter?
  if (fDET_CONTEXT_FIND_FIRST == (pDetContext->Flags & fDET_CONTEXT_FIND_FIRST)){
    // Initialize the context information so that we start detecting
    // at the initialize port range.
    pDetContext->ISA.IoBaseAddress = 0x0888;
  }

  for (IoBaseAddress = pDetContext->ISA.IoBaseAddress;
       IoBaseAddress <= 0x3888;
       IoBaseAddress = NibcNextIoAddress(IoBaseAddress)){

    //  Look for the PC-9801-83/84/103/104 adapter at the current port.
    NtStatus = FindNibcAdapter(pDetectedAdapter,
                               InterfaceType,
                               BusNumber,
                               IoBaseAddress,
                               pAdapterInfo->PnPId);

    if (NT_SUCCESS(NtStatus)){
      // We found an adapter. Save the next IO address to check.
      #if DBG
        DbgPrint("Found an adapter. I/O port is %x\n",IoBaseAddress);
      #endif
      pDetContext->ISA.IoBaseAddress = NibcNextIoAddress(IoBaseAddress);
      break;
    }
  }

  if (0xffff == IoBaseAddress){
    NtStatus = STATUS_NO_MORE_ENTRIES;
  }

  return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\nec\detect\r81wdet\sources.inc ===
MAJORCOMP = net
MINORCOMP = r81wdet

TARGETNAME=r81wdet
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\netdtect.lib $(SDK_LIB_PATH)\kernel32.lib $(SDK_LIB_PATH)\user32.lib $(SDK_LIB_PATH)\netdet.lib

DLLENTRY=R81wDetInit

INCLUDES=..; \
         $(BASEDIR)\private\ntos\inc; \
         $(BASEDIR)\private\inc\net

C_DEFINES=$(C_DEFINES) -D_PNP_POWER=1

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\r81wdet.c  \
        ..\r81wdet.rc

DLLDEF=..\r81wdet.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\nec\drivers\sources.inc ===
TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=notarget

SOURCES=

NTTARGETFILE0=\
    $(O)\netnec98.inf

!if $(FREEBUILD)
BDIR = ..\retail
!else
BDIR = ..\debug
!endif

!if "$(ALT_PROJECT)"!=""
!if "$(ALT_PROJECT)"=="NEC_98"
MISCFILES = \
    $(BDIR)\b80crdr.sys     \
    $(BDIR)\b80nibc.sys     \
    $(BDIR)\b80r81j.sys     \
    $(BDIR)\b80r81w.sys     \
    $(BDIR)\nia35.sys       \
    $(BDIR)\r8100cfg.cpl    \
    $(BDIR)\r8100cfg.chm    \
    $(O)\netnec98.inf
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\nec\drivers\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

STAMP=stampinf -f $@ -d date -v
            
_LNG=..\$(LANGUAGE)
_INX=..

!IFDEF SERVERINF
!IFDEF BINPLACE_CMD
BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
!ENDIF
!ENDIF

$(O)\netnec98.inf: $(_INX)\netnec98.inx $(_LNG)\netnec98.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\sna\ibmmg\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.

$(O)\ibmsync.inf: $(_INX)\ibmsync.inx $(_LNG)\ibmsync.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\sna\mgate\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.

$(O)\mgsync.inf: $(_INX)\mgsync.inx $(_LNG)\mgsync.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\nlsmsg\ioerror.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    TEST.C

Abstract:

    Test program for the eventlog service. This program calls the Elf
    APIs to test out the operation of the service.

Author:

    Rajen Shah  (rajens) 05-Aug-1991

Revision History:


--*/
/*----------------------*/
/* INCLUDES             */
/*----------------------*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>      // printf
#include <string.h>     // stricmp
#include <stdlib.h>
#include <process.h>    // exit
#include <elfcommn.h>
#include <windows.h>
#include <ntiolog.h>
#include <malloc.h>
#include <time.h>

#define     READ_BUFFER_SIZE        1024*2      // Use 2K buffer

#define     SIZE_DATA_ARRAY         65

//
// Global buffer used to emulate "binary data" when writing an event
// record.
//
ULONG    Data[SIZE_DATA_ARRAY];
enum _OPERATION_TYPE {
   Invalid,
   Clear,
   Read,
   Write,
   LPC
} Operation = Invalid;
ULONG ReadFlags;
ULONG NumberofRecords = 1;
ULONG DelayInMilliseconds = 0;
CHAR DefaultModuleName[] = "System";
PCHAR pModuleName = DefaultModuleName;

// Function prototypes

VOID ParseParms(ULONG argc, PCHAR *argv);

VOID
Initialize (
    VOID
    )
{
    ULONG   i;

    // Initialize the values in the data buffer.
    //
    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] = i;

}

VOID
Usage (
    VOID
    )
{
    printf( "usage: \n" );
    printf( "-c              Clears the specified log\n");
    printf( "-rsb            Reads nn event log records sequentially backwards\n");
    printf( "-rsf nn         Reads nn event log records sequentially forwards\n");
    printf( "-rrb <record>   Reads event log from <record> backwards\n");
    printf( "-rrf <record>   Reads event log from <record> forwards\n");
    printf( "-m <modulename> Module name to use for read/clear\n");
    exit(0);

} // Usage

VOID
DisplayEventRecords( PVOID Buffer,
                     ULONG  BufSize,
                     PULONG NumRecords)

{
    PEVENTLOGRECORD pLogRecord;
    IO_ERROR_LOG_PACKET UNALIGNED  *errorPacket;
    NTSTATUS Status;
    ANSI_STRING         StringA;
    UNICODE_STRING      StringU;
    PWSTR               pwString;
    PCHAR               paString;
    ULONG               Count = 0;
    ULONG               Offset = 0;
    ULONG               i;
    UCHAR MessageBuffer[265];
    BOOLEAN             ioRecord;

    pLogRecord = (PEVENTLOGRECORD) Buffer;

    if (getenv("TZ") == NULL) {
        _putenv("TZ=PDT");
    }

    while (Offset < BufSize && Count < *NumRecords) {

        printf("\nRecord # %lu\n", pLogRecord->RecordNumber);

        if (/* pLogRecord->EventType != IO_TYPE_ERROR_MESSAGE || */
            pLogRecord->DataLength < sizeof(IO_ERROR_LOG_PACKET)) {

            ioRecord = FALSE;

            printf("Length: 0x%lx TimeGenerated: 0x%lx  EventID: 0x%lx EventType: 0x%x\n",
                    pLogRecord->Length, pLogRecord->TimeGenerated, pLogRecord->EventID,
                    pLogRecord->EventType);

            printf("NumStrings: 0x%x StringOffset: 0x%lx UserSidLength: 0x%lx TimeWritten: 0x%lx\n",
                    pLogRecord->NumStrings, pLogRecord->StringOffset,
                    pLogRecord->UserSidLength, pLogRecord->TimeWritten);

            printf("UserSidOffset: 0x%lx    DataLength: 0x%lx    DataOffset:  0x%lx \n",
                    pLogRecord->UserSidOffset, pLogRecord->DataLength,
                    pLogRecord->DataOffset);
        } else {

            ioRecord = TRUE;
            errorPacket = (PIO_ERROR_LOG_PACKET)
                ((PCHAR) pLogRecord + pLogRecord->DataOffset);
        }

        //
        // Print out module name
        //

        pwString = (PWSTR)((LPBYTE) pLogRecord + sizeof(EVENTLOGRECORD));
        RtlInitUnicodeString (&StringU, pwString);
        RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

        printf("ModuleName:  %s \t", StringA.Buffer);
        RtlFreeAnsiString (&StringA);

        //
        // Display ComputerName
        //
        pwString += wcslen(pwString) + 1;

        RtlInitUnicodeString (&StringU, pwString);
        RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

        printf("ComputerName: %s\n",StringA.Buffer);
        RtlFreeAnsiString (&StringA);

        //
        // Display strings
        //

        pwString = (PWSTR)((LPBYTE)pLogRecord + pLogRecord->StringOffset);

        printf("Strings: ");
        for (i=0; i<pLogRecord->NumStrings; i++) {

            RtlInitUnicodeString (&StringU, pwString);
            RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

            printf("  %s  ",StringA.Buffer);

            RtlFreeAnsiString (&StringA);

            pwString = (PWSTR)((LPBYTE)pwString + StringU.MaximumLength);
        }

        printf("\n");

        if (ioRecord) {

            MessageBuffer[0] = '\0';
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                errorPacket->ErrorCode,
                0,
                MessageBuffer,
                256,
                NULL
                );

#if 0
            printf("Event id: %8lx, => %s",
                errorPacket->ErrorCode, MessageBuffer);
#endif
            printf(MessageBuffer, errorPacket->DumpData[0], errorPacket->DumpData[1], errorPacket->DumpData[2]);
            printf("Major Function code: %2x, IoControlCode: %8x\n",
                errorPacket->MajorFunctionCode, errorPacket->IoControlCode);
            paString = ctime((time_t *) &pLogRecord->TimeGenerated);

            if (pwString != NULL) {
                printf("Sequence number: %ld, Time of error: %s",
                    errorPacket->SequenceNumber, paString);
            }

            printf("Unique Error Value: %ld, Final Status: %8lx\n",
                errorPacket->UniqueErrorValue, errorPacket->FinalStatus);

            printf("Device Offset: %08lx%08lx\n",
                errorPacket->DeviceOffset.HighPart, errorPacket->DeviceOffset.LowPart);

            printf("Dump Data:");

            for (i = 0; i < 1 + (errorPacket->DumpDataSize +3)/ 4; i++) {

                if (!(i % 4)) {
                    printf("\n");
                }

                printf("%08lx ", errorPacket->DumpData[i]);
            }

            printf("\n");

        }

        // Get next record
        //
        Offset += pLogRecord->Length;

        pLogRecord = (PEVENTLOGRECORD)((ULONG)Buffer + Offset);

        Count++;

    }

    *NumRecords = Count;

}


NTSTATUS
ReadFromLog ( HANDLE LogHandle,
             PVOID  Buffer,
             PULONG pBytesRead,
             ULONG  ReadFlag,
             ULONG  Record
             )
{
    NTSTATUS    Status;
    ULONG       MinBytesNeeded;

    Status = ElfReadEventLogW (
                        LogHandle,
                        ReadFlag,
                        Record,
                        Buffer,
                        READ_BUFFER_SIZE,
                        pBytesRead,
                        &MinBytesNeeded
                        );


    if (Status == STATUS_NO_MORE_FILES)
        printf("Buffer too small. Need %lu bytes min\n", MinBytesNeeded);

    return (Status);
}




NTSTATUS
TestReadEventLog (
    ULONG Count,
    ULONG ReadFlag,
    ULONG Record
    )

{
    NTSTATUS    Status, IStatus;

    HANDLE      LogHandle;
    UNICODE_STRING  ModuleNameU;
    ANSI_STRING ModuleNameA;
    ULONG   NumRecords, BytesReturned;
    PVOID   Buffer;
    ULONG   RecordOffset;
    ULONG   NumberOfRecords;
    ULONG   OldestRecord;

    printf("Testing ElfReadEventLog API to read %lu entries\n",Count);

    Buffer = malloc (READ_BUFFER_SIZE);

    //
    // Initialize the strings
    //
    NumRecords = Count;
    RtlInitAnsiString(&ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);

    //
    // Open the log handle
    //
    printf("ElfOpenEventLog - ");
    Status = ElfOpenEventLogW (
                    NULL,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        //
        // Get and print record information
        //

        Status = ElfNumberOfRecords(LogHandle, & NumberOfRecords);
        if (NT_SUCCESS(Status)) {
           Status = ElfOldestRecord(LogHandle, & OldestRecord);
        }

        if (!NT_SUCCESS(Status)) {
           printf("Query of record information failed with %X", Status);
           return(Status);
        }

        printf("\nThere are %d records in the file, %d is the oldest"
         " record number\n", NumberOfRecords, OldestRecord);

        RecordOffset = Record;

        while (Count && NT_SUCCESS(Status)) {

            printf("Read %u records\n", NumRecords);
            //
            // Read from the log
            //
            Status = ReadFromLog ( LogHandle,
                                   Buffer,
                                   &BytesReturned,
                                   ReadFlag,
                                   RecordOffset
                                 );
            if (NT_SUCCESS(Status)) {

                printf("Bytes read = 0x%lx\n", BytesReturned);
                NumRecords = Count;
                DisplayEventRecords(Buffer, BytesReturned, &NumRecords);
                Count -= NumRecords;
            }

        }
        printf("\n");

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_END_OF_FILE) {
               printf("Tried to read more records than in log file\n");
            }
            else {
                printf ("Error - 0x%lx. Remaining count %lu\n", Status, Count);
            }
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling ElfCloseEventLog\n");
        IStatus = ElfCloseEventLog (LogHandle);
    }

    return (Status);
}

NTSTATUS
TestElfClearLogFile(
    VOID
    )

{
    NTSTATUS    Status, IStatus;
    HANDLE      LogHandle;
    UNICODE_STRING  BackupU, ModuleNameU;
    ANSI_STRING ModuleNameA;

    printf("Testing ElfClearLogFile API\n");
    //
    // Initialize the strings
    //
    RtlInitAnsiString( &ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);

    //
    // Open the log handle
    //
    printf("Calling ElfOpenEventLog for CLEAR - ");
    Status = ElfOpenEventLogW (
                    NULL,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        //
        // Clear the log file and back it up to "view.log"
        //

        printf("Calling ElfClearEventLogFile backing up to view.log  ");
        RtlInitUnicodeString( &BackupU, L"view.log" );

        Status = ElfClearEventLogFileW (
                        LogHandle,
                        &BackupU
                        );

        if (!NT_SUCCESS(Status)) {
            printf ("Error - 0x%lx\n", Status);
        } else {
            printf ("SUCCESS\n");
        }

        //
        // Now just clear the file without backing it up
        //
        printf("Calling ElfClearEventLogFile with no backup  ");
        Status = ElfClearEventLogFileW (
                        LogHandle,
                        NULL
                        );

        if (!NT_SUCCESS(Status)) {
            printf ("Error - 0x%lx\n", Status);
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling ElfCloseEventLog\n");
        IStatus = ElfCloseEventLog (LogHandle);
    }

    return(Status);
}


VOID
main (
    IN SHORT argc,
    IN PSZ argv[]
    )
{

    Initialize();           // Init any data

    //
    // Parse the command line
    //

    ParseParms(argc, argv);

    if ( Operation == Invalid) {
        printf( "Must specify an operation\n");
        Usage( );
    }

    switch (Operation) {
       case Clear:

          TestElfClearLogFile();

       case Read:

          if (ReadFlags & EVENTLOG_SEEK_READ) {
              TestReadEventLog(1, ReadFlags, NumberofRecords) ;
          }
          else {
              TestReadEventLog(NumberofRecords, ReadFlags, 0) ;
          }
          break;

    }
}

VOID
ParseParms(
    ULONG argc,
    PCHAR *argv
    )
{

   ULONG i;
   PCHAR pch;

   for (i = 1; i < argc; i++) {    /* for each argument */
       if (*(pch = argv[i]) == '-') {
           while (*++pch) {
               switch (*pch) {
                  case 'r':
                     //
                     // Different Read options
                     //

                     if (Operation != Invalid) {
                        printf("Only one operation at a time\n");
                        Usage();
                     }

                     Operation = Read;
                     if (*++pch == 's') {
                        ReadFlags |= EVENTLOG_SEQUENTIAL_READ;
                     }
                     else if (*pch == 'r') {
                        ReadFlags |= EVENTLOG_SEEK_READ;
                     }
                     else {
                        Usage();
                     }

                     if (*++pch == 'f') {
                        ReadFlags |= EVENTLOG_FORWARDS_READ;
                     }
                     else if (*pch == 'b') {
                        ReadFlags |= EVENTLOG_BACKWARDS_READ;
                     }
                     else {
                        Usage();
                     }

                     //
                     // See if they specified a number of records
                     //

                     if (i + 1 < argc && argv[i+1][0] != '-') {
                        NumberofRecords = atoi(argv[++i]);
                        if (NumberofRecords == 0) {
                           Usage();
                        }
                     }

                     break;

                  case 'c':

                     if (Operation != Invalid) {
                        printf("Only one operation at a time\n");
                        Usage();
                     }

                     Operation = Clear;
                     break;

                  case 'm':
                     if (i+1 < argc) {
                        pModuleName = argv[++i];
                     }
                     else {
                        Usage();
                     }
                     break;

                  case '?':
                  case 'h':
                  case 'H':
                     Usage();
                     break;

                  default:        /* Invalid options */
                     printf("Invalid option %c\n\n", *pch);
                     Usage();
                     break;
               }
           }
       }
       //
       // There aren't any non switch parms
       else {
          Usage();
       }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\adddevice.c ===
//
// addDevice.c
//

#include "pch.h"

NTSTATUS
P5AddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  Pdo
    )
/*++

Routine Description:

    This is the WDM AddDevice routine for parport devices.

Arguments:

    DriverObject - Driver Object
    Pdo          - PDO

Return Value:

    STATUS_SUCCESS - on SUCCESS
    Error Status   - otherwise

--*/
{
    NTSTATUS        status              = STATUS_SUCCESS;
    PDEVICE_OBJECT  fdo                 = NULL;
    PDEVICE_OBJECT  lowerDevObj         = NULL;
    PFDO_EXTENSION  fdx                 = NULL;
    BOOLEAN         haveDeviceInterface = FALSE;

    __try {

        fdo = PptBuildFdo( DriverObject, Pdo );
        if( !fdo ) {
            status = STATUS_UNSUCCESSFUL;
            __leave;
        }
        fdx = fdo->DeviceExtension;
        
        status = IoRegisterDeviceInterface( Pdo, &GUID_PARALLEL_DEVICE, NULL, &fdx->DeviceInterface);
        if( status != STATUS_SUCCESS ) {
            __leave;
        }
        haveDeviceInterface = TRUE;
        
        lowerDevObj = IoAttachDeviceToDeviceStack( fdo, Pdo );
        if( !lowerDevObj ) {
            status = STATUS_UNSUCCESSFUL;
            __leave;
        }
        fdx->ParentDeviceObject = lowerDevObj;
        
        KeInitializeEvent( &fdx->FdoThreadEvent, NotificationEvent, FALSE );

        // legacy drivers may use this count
        IoGetConfigurationInformation()->ParallelCount++;
        
        // done initializing - tell IO system we are ready to receive IRPs
        fdo->Flags &= ~DO_DEVICE_INITIALIZING;
        
        DD((PCE)fdx,DDT,"P5AddDevice - SUCCESS\n");

    } 
    __finally {

        if( status != STATUS_SUCCESS ) {
            if( haveDeviceInterface ) {
                RtlFreeUnicodeString( &fdx->DeviceInterface );
            }
            if( fdo ) {
                IoDeleteDevice( fdo );
            }
        }

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\byte.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    Byte.c

Abstract:

    This module contains the code to do byte mode reads.

Author:

    Don Redford 30-Aug-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
    

BOOLEAN
ParIsByteSupported(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine determines whether or not byte mode is suported
    by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    NTSTATUS Status;
    
    if (Pdx->BadProtocolModes & BYTE_BIDIR) {
        DD((PCE)Pdx,DDT,"ParIsByteSupported - BAD PROTOCOL\n");
        return FALSE;
    }

    if (!(Pdx->HardwareCapabilities & PPT_BYTE_PRESENT)) {
        DD((PCE)Pdx,DDT,"ParIsByteSupported - NO\n");
        return FALSE;
    }

    if (Pdx->ProtocolModesSupported & BYTE_BIDIR) {
        DD((PCE)Pdx,DDT,"ParIsByteSupported - Already Checked - YES\n");
        return TRUE;
    }

    // Must use Byte Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterByteMode (Pdx, FALSE);
    ParTerminateByteMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsByteSupported - SUCCESS\n");
        Pdx->ProtocolModesSupported |= BYTE_BIDIR;
        return TRUE;
    }
   
    DD((PCE)Pdx,DDT,"ParIsByteSupported - UNSUCCESSFUL\n");
    return FALSE;    
}

NTSTATUS
ParEnterByteMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    byte mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    // Make sure Byte mode Harware is still there
    Status = Pdx->TrySetChipMode( Pdx->PortContext, ECR_BYTE_PIO_MODE );
    
    if( NT_SUCCESS(Status) ) {

        if ( SAFE_MODE == Pdx->ModeSafety ) {

            if( DeviceIdRequest ) {
                // RMT - not sure if we want to support non-nibble 1284 ID query
                Status = IeeeEnter1284Mode( Pdx, BYTE_EXTENSIBILITY | DEVICE_ID_REQ );
            } else {
                Status = IeeeEnter1284Mode( Pdx, BYTE_EXTENSIBILITY );
            }

        } else {
            // UNSAFE_MODE
            Pdx->Connected = TRUE;
        }

    }
    
    if (NT_SUCCESS(Status)) {

        P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
        Pdx->IsIeeeTerminateOk = TRUE;

    } else {

        ParTerminateByteMode ( Pdx );
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->IsIeeeTerminateOk = FALSE;
    }

    DD((PCE)Pdx,DDT,"ParEnterByteMode - exit w/Status=%x\n",Status);
    
    return Status; 
}    

VOID
ParTerminateByteMode(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    if ( Pdx->ModeSafety == SAFE_MODE ) {

        IeeeTerminate1284Mode( Pdx );

    } else {

        Pdx->Connected = FALSE;

    }

    Pdx->ClearChipMode( Pdx->PortContext, ECR_BYTE_PIO_MODE );

    DD((PCE)Pdx,DDT,"ParTerminateByteMode - exit\n");
}

NTSTATUS
ParByteModeRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
/*++

Routine Description:

    This routine performs a 1284 byte mode read into the given
    buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/
{
    PUCHAR          Controller;    
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          lpsBufPtr = (PUCHAR)Buffer;
    ULONG           i;
    UCHAR           dsr, dcr;
    UCHAR           HDReady, HDAck, HDFinished;

    Controller = Pdx->Controller;

    // Read Byte according to 1284 spec.
    DD((PCE)Pdx,DDT,"ParByteModeRead: Start\n");

    dcr = GetControl (Controller);

    // Set Direction to be in reverse
    dcr |= DCR_DIRECTION;
    StoreControl (Controller, dcr);    

    HDReady = SET_DCR( ACTIVE, INACTIVE, ACTIVE, INACTIVE, INACTIVE, ACTIVE );
    HDAck = SET_DCR( ACTIVE, INACTIVE, ACTIVE, INACTIVE, ACTIVE, INACTIVE );
    HDFinished = SET_DCR( ACTIVE, INACTIVE, ACTIVE, INACTIVE, ACTIVE, ACTIVE );

    switch( Pdx->CurrentPhase ) {
    
        case PHASE_REVERSE_IDLE:

            // Check to see if the peripheral has indicated Interrupt Phase and if so, 
            // get us ready to reverse transfer.

            for (;;) {

                // See if data is available (looking for state 7)
                dsr = GetStatus(Controller);

                if (dsr & DSR_NOT_DATA_AVAIL) {

                    // Data is NOT available - do nothing
                    // The device doesn't report any data, it still looks like it is
                    // in ReverseIdle.  Just to make sure it hasn't powered off or somehow
                    // jumped out of Byte mode, test also for AckDataReq high and XFlag low
                    // and nDataAvaul high.
                    if( (dsr & DSR_BYTE_VALIDATION) != DSR_BYTE_TEST_RESULT ) {

                        Status = STATUS_IO_DEVICE_ERROR;
                        P5SetPhase( Pdx, PHASE_UNKNOWN );

                        DD((PCE)Pdx,DDE,"ParByteModeRead - Failed State 7 - dcr=%x\n",dcr);
                    }
                    goto ByteReadExit;

                } else {

                    // Data is available, go to Reverse Transfer Phase
                    P5SetPhase( Pdx, PHASE_REVERSE_XFER);
                    // Go to Reverse XFER phase
                    goto PhaseReverseXfer;
                }

            }
        
PhaseReverseXfer:

        case PHASE_REVERSE_XFER: 
        
            for (i = 0; i < BufferSize; i++) {
            
                // Host enters state 7
                StoreControl (Controller, HDReady);

                // =============== Periph State 9     ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = low (signals state 9)
                // nAckReverse/AckDataReq   = Don't Care
                // XFlag                    = Don't Care
                // nPeriphReq/nDataAvail    = Don't Care
                if (!CHECK_DSR(Controller, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL)) {
                    // Time out.
                    // Bad things happened - timed out on this state,
                    // Mark Status as bad and let our mgr kill current mode.
                    Status = STATUS_IO_DEVICE_ERROR;

                    DD((PCE)Pdx,DDE,"ParByteModeRead - Failed State 9 - dcr=%x\n",dcr);
                    P5SetPhase( Pdx, PHASE_UNKNOWN );
                    goto ByteReadExit;
                }

                // Read the Byte                
                P5ReadPortBufferUchar( Controller, lpsBufPtr++, (ULONG)0x01 );

                // Set host lines to indicate state 10.
                StoreControl (Controller, HDAck);

                // =============== Periph State 11     ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = High (signals state 11)
                // nAckReverse/AckDataReq   = Don't Care
                // XFlag                    = Don't Care
                // nPeriphReq/nDataAvail    = Don't Care
                if( !CHECK_DSR(Controller, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL)) {
                    // Time out.
                    // Bad things happened - timed out on this state,
                    // Mark Status as bad and let our mgr kill current mode.
                    Status = STATUS_IO_DEVICE_ERROR;

                    DD((PCE)Pdx,DDE,"ParByteModeRead - Failed State 11 - dcr=%x\n",dcr);
                    P5SetPhase( Pdx, PHASE_UNKNOWN );
                    goto ByteReadExit;
                }


                // Set host lines to indicate state 16.
                StoreControl (Controller, HDFinished);

                // At this point, we've either received the number of bytes we
                // were looking for, or the peripheral has no more data to
                // send, or there was an error of some sort (of course, in the
                // error case we shouldn't get to this comment).  Set the
                // phase to indicate reverse idle if no data available or
                // reverse data transfer if there's some waiting for us
                // to get next time.

                dsr = GetStatus(Controller);
                
                if (dsr & DSR_NOT_DATA_AVAIL) {
                
                    // Data is NOT available - go to Reverse Idle
                    // Really we are going to HBDNA, but if we set
                    // current phase to reverse idle, the next time
                    // we get into this function all we have to do
                    // is set hostbusy low to indicate idle and
                    // we have infinite time to do that.
                    // Break out of the loop so we don't try to read
                    // data that isn't there.
                    // NOTE - this is a successful case even if we
                    // didn't read all that the caller requested
                    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
                    i++; // account for this last byte transferred
                    break;

                } else {
                    // Data is available, go to (remain in ) Reverse Transfer Phase
                    P5SetPhase( Pdx, PHASE_REVERSE_XFER);
                }

            } // end for i loop

            *BytesTransferred = i;

            dsr = GetStatus(Controller);

            // DON'T FALL THRU THIS ONE
            break;

        default:
        
            Status = STATUS_IO_DEVICE_ERROR;
            P5SetPhase( Pdx, PHASE_UNKNOWN );

            DD((PCE)Pdx,DDE,"ParByteModeRead:Failed State 9: Unknown Phase - dcr=%x\n",dcr);
            goto ByteReadExit;

    } // end switch

ByteReadExit:

    if( Pdx->CurrentPhase == PHASE_REVERSE_IDLE ) {
        // Host enters state 7  - officially in Reverse Idle now
        dcr |= DCR_NOT_HOST_BUSY;

        StoreControl (Controller, dcr);
    }

    // Set Direction to be in forward
    dcr &= ~DCR_DIRECTION;
    StoreControl (Controller, dcr);    

    DD((PCE)Pdx,DDT,"ParByteModeRead - exit, status=%x, bytes read=%d\n", Status, *BytesTransferred);
    Pdx->log.ByteReadCount += *BytesTransferred;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\chipmode.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    parmode.c

Abstract:

    This is the main module for Extended Parallel Port (ECP) and
    Enhanced Parallel Port (EPP) detection.  This module 
    will detect for invalid chipshets and do ECR detection 
    for ECP and EPP hardware support if the invalid chipset
    is not found.

Author:

    Don Redford (v-donred) 4-Mar-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

#define USE_PARCHIP_ECRCONTROLLER 1


NTSTATUS
PptDetectChipFilter(
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This routine is called once per DeviceObject to see if the filter driver 
    for detecting parallel chip capabilities is there and to get the chip
    capabilities if there of the port in question.
    
Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if we were able detect the chip and modes possible.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS                    Status = STATUS_NO_SUCH_DEVICE;
    PIRP                        Irp;
    KEVENT                      Event;
    IO_STATUS_BLOCK             IoStatus;
    UCHAR                       ecrLast;
    PUCHAR                      Controller, EcpController;
            
    Controller = Fdx->PortInfo.Controller;
    EcpController = Fdx->PnpInfo.EcpController;
    
    // Setting variable to FALSE to make sure we do not acidentally succeed
    Fdx->ChipInfo.success = FALSE;

    // Setting the Address to send to the filter driver to check the chips
    Fdx->ChipInfo.Controller = Controller;

    // Setting the Address to send to the filter driver to check the chips
    Fdx->ChipInfo.EcrController = EcpController;

#ifndef USE_PARCHIP_ECRCONTROLLER
    // if there is not value in the ECR controller then PARCHIP and PARPORT
    // will conflict and PARCHIP will not work with PARPORT unless we
    // use the ECR controller found by PARCHIP.
    if ( !EcpController ) {
         return Status;
    }
#endif    
    //
    // Initialize
    //
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    // Send a Pointer to the ChipInfo structure to and from the filter
    Irp = IoBuildDeviceIoControlRequest( IOCTL_INTERNAL_PARCHIP_CONNECT,
                                         Fdx->ParentDeviceObject, 
                                         &Fdx->ChipInfo,
                                         sizeof(PARALLEL_PARCHIP_INFO),
                                         &Fdx->ChipInfo,
                                         sizeof(PARALLEL_PARCHIP_INFO),
                                         TRUE, &Event, &IoStatus);

    if (!Irp) { 
        // couldn't create an IRP
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Call down to our parent and see if Filter is present
    //
    Status = IoCallDriver(Fdx->ParentDeviceObject, Irp);
            
    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Suspended, KernelMode, FALSE, NULL);
        Status = Irp->IoStatus.Status;
    }
            
    //
    // If successful then we have a filter driver and we need to get the modes supported
    //
    if ( NT_SUCCESS(Status) ) {

        //
        // check to see if the filter driver was able to determine the I/O chip
        //
        if ( Fdx->ChipInfo.success ) {
            Fdx->PnpInfo.HardwareCapabilities = Fdx->ChipInfo.HardwareModes;
#ifdef USE_PARCHIP_ECRCONTROLLER
            // only replace it if defined
            if ( Fdx->PnpInfo.EcpController != Fdx->ChipInfo.EcrController ) {
                Fdx->PnpInfo.EcpController = Fdx->ChipInfo.EcrController;
                EcpController = Fdx->PnpInfo.EcpController;
            }
#endif
            // Set variable to say we have a filter driver
            Fdx->FilterMode = TRUE;
        }
    }

    // if there is a filter and ECP capable we need to get the Fifo Size
    if ( Fdx->FilterMode && Fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT ) {

        Status = Fdx->ChipInfo.ParChipSetMode ( Fdx->ChipInfo.Context, ECR_ECP_MODE );

        // if able to set ECP mode
        if ( NT_SUCCESS( Status ) ) {
            PUCHAR wPortECR;

            wPortECR = EcpController + ECR_OFFSET;

            // get value from ECR reg & save it
            ecrLast = P5ReadPortUchar( wPortECR );

            // Determining Fifo Size
            PptDetermineFifoWidth(Fdx);    
            PptDetermineFifoDepth(Fdx);

            // return ecr to original
            P5WritePortUchar( wPortECR, ecrLast);

            Status = Fdx->ChipInfo.ParChipClearMode ( Fdx->ChipInfo.Context, ECR_ECP_MODE );
        }    
    
    }    

    return Status;
}

NTSTATUS
PptDetectPortType(
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This routine is called once per DeviceObject to detect the type of 
    parallel chip capabilities of the port in question.
    
Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if we were able detect the chip and modes possible.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS                    Status;
    UNICODE_STRING              ParportPath;
    RTL_QUERY_REGISTRY_TABLE    RegTable[2];
    ULONG                       IdentifierHex = 12169;
    ULONG                       zero = 0;

    //
    // -- May want to get detection order from Registry.
    // -- May also want to store/retrieve last known good configuration in/from registry.
    // -- Finally we should set a registry flag during dection so that we'll know
    //    if we crashed while attempting to detect and not try it again.
    //
    RtlInitUnicodeString(&ParportPath, (PWSTR)L"Parport");

    // Setting up to get the Parport info
    RtlZeroMemory( RegTable, sizeof(RegTable) );

    RegTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    RegTable[0].Name = (PWSTR)L"ModeCheckedStalled";
    RegTable[0].EntryContext = &IdentifierHex;
    RegTable[0].DefaultType = REG_DWORD;
    RegTable[0].DefaultData = &zero;
    RegTable[0].DefaultLength = sizeof(ULONG);

    //
    // Querying the registry for Parport to see if we tried to go check mode and we crashed
    // the registry key would still be there 
    //
    Status = RtlQueryRegistryValues(
                                RTL_REGISTRY_SERVICES,
                                ParportPath.Buffer,
                                RegTable,
                                NULL,
                                NULL );

    //
    // if registry key is there then we will just check ECP and Byte
    //
    if ( !(NT_SUCCESS( Status ) && IdentifierHex == 0) && (Status != STATUS_OBJECT_NAME_NOT_FOUND) ) {

        // dvtw, Check for ECP anyway!  We just won't turn it on

        PptDetectEcpPort(Fdx);
        PptDetectBytePort(Fdx);

        if( Fdx->PnpInfo.HardwareCapabilities & (PPT_ECP_PRESENT | PPT_BYTE_PRESENT) ) {
            return STATUS_SUCCESS;
        } else {
            return STATUS_NO_SUCH_DEVICE;
        }
    }
    
    IdentifierHex = 12169;
    // Write the registry key out there just in case we crash
    Status = RtlWriteRegistryValue(
                                RTL_REGISTRY_SERVICES,
                                ParportPath.Buffer,
                                (PWSTR)L"ModeCheckedStalled",
                                REG_DWORD,
                                &IdentifierHex,
                                sizeof(ULONG) );
            
    //
    // Now we can start detecting the parallel port chip capabilities
    //
    Status = PptDetectPortCapabilities( Fdx );

    // Delete the registry key out there since we finished
    Status = RtlDeleteRegistryValue( RTL_REGISTRY_SERVICES, ParportPath.Buffer, (PWSTR)L"ModeCheckedStalled" ); 
    return Status;
}

NTSTATUS
PptDetectPortCapabilities(
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This is the "default" detection code, which looks for an ECR.  If the ECR
    is present it tries to set mode 100b in <7:5>. If it sticks we'll call it
    EPP.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS    Status;

    PptDetectEcpPort( Fdx );
    
    // dvdr 
    // 
    // if we did not detect an ECR for ECP mode and ECP mode failed
    // EPP mode would fail also
    // Also cannot have EPP mode at an address that ends with a "C"
    // 
    if ( (Fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT) &&
         (((ULONG_PTR)Fdx->PortInfo.Controller & 0x0F) != 0x0C) ) {

        // Need to check for National chipsets before trying EPP mode
        // dvdr - need to add detection for old Winbond

        Status = PptFindNatChip( Fdx );

        if ( NT_SUCCESS( Status ) ) {
            if ( !Fdx->NationalChipFound ) {
                // National chipset was NOT found so we can see if generic EPP is supported

                PptDetectEppPortIfDot3DevicePresent( Fdx );

                if( !Fdx->CheckedForGenericEpp ) {
                    // we didn't have a dot3 device to use for screening, do check anyway
                    //   if user has explicitly requested EPP detection
                    PptDetectEppPortIfUserRequested( Fdx );
                }
            } else {
                // National chipset was found so can't do generic EPP
                Fdx->CheckedForGenericEpp = TRUE; // check is complete - generic EPP is unsafe
            }
        }
    } else {
        // ECP failed no check for Generic EPP
        Fdx->CheckedForGenericEpp = TRUE; // check is complete - generic EPP is unsafe
    }

    PptDetectBytePort( Fdx );
    
    if (Fdx->PnpInfo.HardwareCapabilities & (PPT_ECP_PRESENT | PPT_EPP_PRESENT | PPT_BYTE_PRESENT) ) {
        return STATUS_SUCCESS;
    }

    return STATUS_NO_SUCH_DEVICE;    
}

VOID
PptDetectEcpPort(
    IN  PFDO_EXTENSION   Fdx
    )
    
/*++
      
Routine Description:
      
    This routine looks for the presence of an ECR register to determine that
      it has ECP.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
    
{
    PUCHAR  Controller;
    PUCHAR  wPortDCR;       // IO address of Device Control Register (DCR)
    PUCHAR  wPortECR;       // IO address of Extended Control Register (ECR)
    UCHAR   ecrLast, ecr, dcr;
    
    Controller = Fdx->PortInfo.Controller;
    wPortDCR = Controller + DCR_OFFSET;

    if( 0 == Fdx->PnpInfo.EcpController ) {
        // PnP didn't give us an ECP Register set - we're done here
        return;
    }
    wPortECR = Fdx->PnpInfo.EcpController + ECR_OFFSET;

    ecrLast = ecr = P5ReadPortUchar(wPortECR);

    // Initialize the DCR's nAutoFeed and nStrobe to a harmless combination
    // that could be returned by the ECR, but is not likely to be returned if
    // the ECR isn't present.  Depending on the host's address decode logic,
    // reading a non-existant ECR could have one of two results:  the ECR address
    // could decode on top of the DCR, so we'll read the value we are about to set.
    // Alternately, we might just read a floating bus and get a random value.
    dcr = SET_DCR( DIR_WRITE, IRQEN_DISABLE, INACTIVE, ACTIVE, INACTIVE, ACTIVE );
    P5WritePortUchar( wPortDCR, dcr );

    ecrLast = ecr = P5ReadPortUchar(wPortECR);
    
    
    // Attempt to read the ECR.  If ECP hardware is present, the ECR register's
    // bit 1 and bit 0 should read a 00 (some data in the FIFO), 01 (FIFO empty),
    // or 10 (FIFO full).  If we read a 11 (illegal combination) then we know for
    // sure that no ECP hardware is present.  Also, a valid ECR should never return
    // 0xFF (but a nonexistant register probably would), so we'll test for that 
    // specific value also.
    if ( ( TEST_ECR_FIFO( ecr, ECR_FIFO_MASK ) ) || ( ecrLast == 0xFF ) ) {
        // ECR[1:0] returned a value of 11, so this can't be hardware ECP.
        DD((PCE)Fdx,DDT,"ParMode::PptDetectEcpPort:  illegal FIFO status\n");

        // Restore the DCR so that all lines are inactive.
        dcr = SET_DCR( DIR_WRITE, IRQEN_DISABLE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
        P5WritePortUchar( wPortDCR, dcr );
        return;
    }

    // OK, so we got either a 00, 01, or 10 for ECR[1:0].  If it was 10, the
    if( TEST_ECR_FIFO( ecr, ECR_FIFO_FULL ) ) { // Looking for ECR[1:0] of 10...

        // The ECR[1:0] returned 10.  This is a legal value, but possibly the
        // hardware might have just decoded the DCR and we merely read back the
        // DCR value we set earlier.  Or, we might have just read back a value
        // that was hanging on the bus due to bus capacitance.  So, we'll change 
        // the DCR, read the ECR again, and see if the two registers continue to 
        // track each other.  If they do track, we'll conclude that there is no
        // ECP hardware.

        // Put the DCR's nAutoFeed and nStrobe register bits back to zero.
        dcr = SET_DCR( DIR_WRITE, IRQEN_DISABLE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
        P5WritePortUchar( wPortDCR, dcr );

        // Read the ECR again
        ecr = P5ReadPortUchar( wPortECR );

        if ( TEST_ECR_FIFO( ecr, ECR_FIFO_SOME_DATA ) ) {
            // ECR[1:0] is tracking DCR[1:0], so this can't be hardware ECP.

            // Restore the DCR so that all lines are inactive.
            dcr = SET_DCR( DIR_WRITE, IRQEN_DISABLE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
            P5WritePortUchar( wPortDCR, dcr );
            return;
        }
    }
    
    // If we get this far, then the ECR appears to be returning something valid that
    // doesn't track the DCR.  It is beginning to look promising.  We're going
    // to take a chance, and write the ECR to put the chip in compatiblity
    // mode.  Doing so will reset the FIFO, so when we read FIFO status it should
    // come back empty.  However, if we're wrong and this isn't ECP hardware, the
    // value we're about to write will turn on 1284Active (nSelectIn) and this might
    // cause headaches for the peripheral.
    P5WritePortUchar( wPortECR, DEFAULT_ECR_COMPATIBILITY );

    // Read the ECR again
    ecr = P5ReadPortUchar( wPortECR );

    // Now test the ECR snapshot to see if the FIFO status is correct.  The FIFO
    // should test empty.
    if (!TEST_ECR_FIFO( ecr, ECR_FIFO_EMPTY ) )
    {
        // Restore the DCR so that all lines are inactive.
        dcr = SET_DCR( DIR_WRITE, IRQEN_DISABLE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
        P5WritePortUchar( wPortDCR, dcr );
        return;
    }

    // OK, it looks very promising.  Perform a couple of additional tests that
    // will give us a lot of confidence, as well as providing some information
    // we need about the ECP chip.
    
    // return ecr to original
    P5WritePortUchar(wPortECR, ecrLast);

    //
    // Test here for ECP capable
    //

    // get value from ECR reg & save it
    ecrLast = P5ReadPortUchar( wPortECR );
    ecr     = (UCHAR)(ecrLast & ECR_MODE_MASK);

    // Put the chip into test mode; the FIFO should start out empty
    P5WritePortUchar(wPortECR, (UCHAR)(ecr | ECR_TEST_MODE) );

    PptDetermineFifoWidth(Fdx);    
    if( 0 != Fdx->PnpInfo.FifoWidth) {
        Fdx->PnpInfo.HardwareCapabilities |= PPT_ECP_PRESENT;
 
        PptDetermineFifoDepth( Fdx );

        if( 0 == Fdx->PnpInfo.FifoDepth ) {
            // Probe for FIFO depth failed - mark ECP as bad chip mode
            Fdx->PnpInfo.HardwareCapabilities &= ~(PPT_ECP_PRESENT);
        }
    }
    
    // return ecr to original
    P5WritePortUchar( wPortECR, ecrLast );

    return;
}

VOID
PptDetectEppPortIfDot3DevicePresent(
    IN  PFDO_EXTENSION   Fdx
    )
    
/*++
      
Routine Description:
      
    If a 1284.3 daisy chain device is present, use the dot3 device to screen
    any printer from signal leakage while doing EPP detection. Otherwise
    abort detection.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
    
{
    NTSTATUS status;
    PUCHAR   Controller = Fdx->PortInfo.Controller;
    PARALLEL_1284_COMMAND Command;

    if( 0 == Fdx->PnpInfo.Ieee1284_3DeviceCount ) {
        // No dot3 DC device present - aborting - unsafe for some printers if we check for EPP here
        return;
    }
        
    //
    // 1284.3 daisy chain device is present. Use device to screen printer from
    //   possible signal leakage.
    //

    //
    // Select 1284.3 daisy chain  device
    //
    Command.ID           = 0;
    Command.Port         = 0;
    Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT;
    status = PptTrySelectDevice( Fdx, &Command );
    if( !NT_SUCCESS( status ) ) {
        // unable to select device - something is wrong - just bail out
        return;
    }

    //
    // do the detection for chipset EPP capability
    //
    // DOT3 Device Present and selected
    PptDetectEppPort( Fdx );

    //
    // Deselect 1284.3 daisy chain device
    //
    Command.ID           = 0;
    Command.Port         = 0;
    Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT;
    status = PptDeselectDevice( Fdx, &Command );
    if( !NT_SUCCESS( status ) ) {
        // deselect failed??? - this shouldn't happen - our daisy chain interface is likely hung
        DD((PCE)Fdx,DDE,"PptDetectEppPort - deselect of 1284.3 device FAILED - Controller=%x\n", Controller);
    }
    
    return;
}

VOID
PptDetectEppPortIfUserRequested(
    IN  PFDO_EXTENSION   Fdx
    )
/*++
      
Routine Description:
      
    If user explicitly requested Generic EPP detection then do the check.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
{
    ULONG RequestEppTest = 0;
    PptRegGetDeviceParameterDword( Fdx->PhysicalDeviceObject, (PWSTR)L"RequestEppTest", &RequestEppTest );
    if( RequestEppTest ) {
        DD((PCE)Fdx,DDT,"-- User Requested EPP detection - %x\n", RequestEppTest);
        PptDetectEppPort( Fdx );
    } else {
        DD((PCE)Fdx,DDT,"-- User did not request EPP detection\n");
    }
    return;
}

VOID
PptDetectEppPort(
    IN  PFDO_EXTENSION   Fdx
    )
    
/*++
      
Routine Description:
      
    This routine checks for EPP capable port after ECP was found.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
    
{
    PUCHAR   Controller;
    UCHAR    dcr, i;
    UCHAR    Reverse = (UCHAR)(DCR_DIRECTION | DCR_NOT_INIT | DCR_AUTOFEED | DCR_DSTRB);
    UCHAR    Forward = (UCHAR)(DCR_NOT_INIT | DCR_AUTOFEED | DCR_DSTRB);

    ASSERTMSG(FALSE, "PptDetectEppPort shouldn't be called in current driver version");

    DD((PCE)Fdx,DDT,"-- PptDetectEppPort - Enter\n");
    DD((PCE)Fdx,DDT,"ParMode::PptDetectEppPort: Enter\n");

    Controller = Fdx->PortInfo.Controller;
    
    // Get current DCR
    dcr = P5ReadPortUchar( Controller + DCR_OFFSET );

    //
    // Temporarily set capability to true to bypass PptEcrSetMode validity
    //   check. We'll clear the flag before we return if EPP test fails.
    //
    Fdx->PnpInfo.HardwareCapabilities |= PPT_EPP_PRESENT;

    // Setting EPP mode
    DD((PCE)Fdx,DDT,"ParMode::PptDetectEppPort: Setting EPP Mode\n");
    PptEcrSetMode( Fdx, ECR_EPP_PIO_MODE );

    //
    // Testing the hardware for EPP capable
    //
    for ( i = 0x01; i <= 0x02; i++ ) {
        // Put it into reverse phase so it doesn't talk to a device
        P5WritePortUchar( Controller + DCR_OFFSET, Reverse );
        KeStallExecutionProcessor( 5 );
        P5WritePortUchar( Controller + EPP_OFFSET, (UCHAR)i );

        // put it back into forward phase to read the byte we put out there
        P5WritePortUchar( Controller + DCR_OFFSET, Forward );
        KeStallExecutionProcessor( 5 );
        if ( P5ReadPortUchar( Controller ) != i ) {
            // failure so clear EPP flag
            Fdx->PnpInfo.HardwareCapabilities &= ~PPT_EPP_PRESENT;
            break;
        }
    }

    // Clearing EPP Mode
    PptEcrClearMode( Fdx );
    // Restore DCR
    P5WritePortUchar( Controller + DCR_OFFSET, dcr );

    Fdx->CheckedForGenericEpp = TRUE; // check is complete

    if( Fdx->PnpInfo.HardwareCapabilities & PPT_EPP_PRESENT ) {
        DD((PCE)Fdx,DDT,"ParMode::PptDetectEppPort: EPP present - Controller=%x\n", Controller);
        DD((PCE)Fdx,DDT,"-- PptDetectEppPort - HAVE Generic EPP\n");
    } else {
        DD((PCE)Fdx,DDT,"ParMode::PptDetectEppPort: EPP NOT present - Controller=%x\n", Controller);
        DD((PCE)Fdx,DDT,"-- PptDetectEppPort - DON'T HAVE Generic EPP\n");
    }

    DD((PCE)Fdx,DDT,"-- PptDetectEppPort - Exit\n");
    return;
}

VOID
PptDetectBytePort(
    IN  PFDO_EXTENSION   Fdx
    )
    
/*++
      
Routine Description:
      
    This routine check to see if the port is Byte capable.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
    
{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    DD((PCE)Fdx,DDT,"ParMode::PptDetectBytePort Enter.\n" );

    Status = PptSetByteMode( Fdx, ECR_BYTE_PIO_MODE );

    if ( NT_SUCCESS(Status) ) {
        // Byte Mode found
        DD((PCE)Fdx,DDT,"ParMode::PptDetectBytePort: Byte Found\n");
        Fdx->PnpInfo.HardwareCapabilities |= PPT_BYTE_PRESENT;
    } else {
        // Byte Mode Not Found
        DD((PCE)Fdx,DDT,"ParMode::PptDetectBytePort: Byte Not Found\n");
    }    
    
    (VOID)PptClearByteMode( Fdx );

}

VOID PptDetermineFifoDepth(
    IN PFDO_EXTENSION   Fdx
    )
{
    PUCHAR  Controller;
    PUCHAR  wPortECR;       // IO address of Extended Control Register (ECR)
    PUCHAR  wPortDFIFO;
    UCHAR   ecr, ecrLast;
    ULONG   wFifoDepth;
    UCHAR   writeFifoDepth;     // Depth calculated while writing FIFO
    UCHAR   readFifoDepth;      // Depth calculated while reading FIFO
    ULONG   limitCount;         // Prevents infinite looping on FIFO status
    UCHAR   testData;
    
    Controller = Fdx->PortInfo.Controller;
    wPortECR =  Fdx->PnpInfo.EcpController+ ECR_OFFSET;
    wPortDFIFO = Fdx->PnpInfo.EcpController;
    wFifoDepth = 0;

    ecrLast = P5ReadPortUchar(wPortECR );

    P5WritePortUchar(wPortECR, DEFAULT_ECR_TEST );

    ecr = P5ReadPortUchar(wPortECR );
    
    if ( TEST_ECR_FIFO( ecr, ECR_FIFO_EMPTY ) ) {
    
        // Write bytes into the FIFO until it indicates full.
        writeFifoDepth = 0;
        limitCount     = 0;
        
        while (((P5ReadPortUchar (wPortECR) & ECR_FIFO_MASK) != ECR_FIFO_FULL ) &&
                    (limitCount <= ECP_MAX_FIFO_DEPTH)) {
                    
            P5WritePortUchar( wPortDFIFO, (UCHAR)(writeFifoDepth & 0xFF) );
            writeFifoDepth++;
            limitCount++;
        }
        
        DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoDepth::  write fifo depth = %d\r\n", writeFifoDepth);

        // Now read the bytes back, comparing what comes back.
        readFifoDepth = 0;
        limitCount    = 0;
        
        while (((P5ReadPortUchar( wPortECR ) & ECR_FIFO_MASK ) != ECR_FIFO_EMPTY ) &&
                    (limitCount <= ECP_MAX_FIFO_DEPTH)) {
                    
            testData = P5ReadPortUchar( wPortDFIFO );
            if ( testData != (readFifoDepth & (UCHAR)0xFF )) {
            
                // Data mismatch indicates problems...
                // FIFO status didn't pan out, may not be an ECP chip after all
                P5WritePortUchar( wPortECR, ecrLast);
                DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoDepth:::  data mismatch\n");
                return;
            }
            
            readFifoDepth++;
            limitCount++;
        }

        DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoDepth:::  read fifo depth = %d\r\n", readFifoDepth);

        // The write depth should match the read depth...
        if ( writeFifoDepth == readFifoDepth ) {
        
            wFifoDepth = readFifoDepth;
            
        } else {
        
            // Assume no FIFO
            P5WritePortUchar( wPortECR, ecrLast);
            DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoDepth:::  No Fifo\n");
            return;
        }
                
    } else {
    
        // FIFO status didn't pan out, may not be an ECP chip after all
        DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoDepth::  Bad Fifo\n");
        P5WritePortUchar(wPortECR, ecrLast);
        return;
    }

    // put chip into spp mode
    P5WritePortUchar( wPortECR, ecrLast );
    Fdx->PnpInfo.FifoDepth = wFifoDepth;
}

VOID
PptDetermineFifoWidth(
    IN PFDO_EXTENSION   Fdx
    )
{
    PUCHAR Controller;
    UCHAR   bConfigA;
    PUCHAR wPortECR;

    DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoWidth: Start\n");
    Controller = Fdx->PortInfo.Controller;

    wPortECR = Fdx->PnpInfo.EcpController + ECR_OFFSET;

    // Put chip into configuration mode so we can access the ConfigA register
    P5WritePortUchar( wPortECR, DEFAULT_ECR_CONFIGURATION );

    // The FIFO width is bits <6:4> of the ConfigA register.
    bConfigA = P5ReadPortUchar( Fdx->PnpInfo.EcpController );
    Fdx->PnpInfo.FifoWidth = (ULONG)(( bConfigA & CNFGA_IMPID_MASK ) >> CNFGA_IMPID_SHIFT);

    // Put the chip back in compatibility mode.
    P5WritePortUchar(wPortECR, DEFAULT_ECR_COMPATIBILITY );
    return;
}

NTSTATUS
PptSetChipMode (
    IN  PFDO_EXTENSION  Fdx,
    IN  UCHAR              ChipMode
    )

/*++

Routine Description:

    This function will put the current parallel chip into the
    given mode if supported.  The determination of supported mode 
    was in the PptDetectPortType function.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    UCHAR EcrMode = (UCHAR)( ChipMode & ~ECR_MODE_MASK );

    // Also allow PptSetChipMode from PS/2 mode - we need this for HWECP
    //   bus flip from Forward to Reverse in order to meet the required
    //   sequence specified in the Microsoft ECP Port Spec version 1.06,
    //   July 14, 1993, to switch directly from PS/2 mode with output 
    //   drivers disabled (direction bit set to "read") to HWECP via 
    //   the ECR. Changed 2000-02-11.
    if ( Fdx->PnpInfo.CurrentMode != INITIAL_MODE && Fdx->PnpInfo.CurrentMode != ECR_BYTE_MODE ) {

        DD((PCE)Fdx,DDW,"PptSetChipMode - CurrentMode invalid\n");

        // Current mode is not valid to put in EPP or ECP mode
        Status = STATUS_INVALID_DEVICE_STATE;

        goto ExitSetChipModeNoChange;
    }

    // need to find out what mode it was and try to take it out of it
    
    // Check to see if we need to use the filter to set the mode
    if ( Fdx->FilterMode ) {
        Status = Fdx->ChipInfo.ParChipSetMode ( Fdx->ChipInfo.Context, ChipMode );
    } else {

        // If asked for ECP check to see if we can do it
        if ( EcrMode == ECR_ECP_MODE ) {
            if ((Fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT) ^ PPT_ECP_PRESENT) {
                // ECP Not Present
                return STATUS_NO_SUCH_DEVICE;
            }
            Status = PptEcrSetMode ( Fdx, ChipMode );
            goto ExitSetChipModeWithChanges;
        }
        
        // If asked for EPP check to see if we can do it
        if ( EcrMode == ECR_EPP_MODE ) {
            if ((Fdx->PnpInfo.HardwareCapabilities & PPT_EPP_PRESENT) ^ PPT_EPP_PRESENT) {
                // EPP Not Present
                return STATUS_NO_SUCH_DEVICE;
            }
            Status = PptEcrSetMode ( Fdx, ChipMode );
            goto ExitSetChipModeWithChanges;
        }

        // If asked for Byte Mode check to see if it is still enabled
        if ( EcrMode == ECR_BYTE_MODE ) {
            if ((Fdx->PnpInfo.HardwareCapabilities & PPT_BYTE_PRESENT) ^ PPT_BYTE_PRESENT) {
                // BYTE Not Present
                return STATUS_NO_SUCH_DEVICE;
            }
            Status = PptSetByteMode ( Fdx, ChipMode );
            goto ExitSetChipModeWithChanges;
        }
    }
    
ExitSetChipModeWithChanges:

    if ( NT_SUCCESS(Status) ) {
        Fdx->PnpInfo.CurrentMode = EcrMode;
    } else {
        DD((PCE)Fdx,DDW,"PptSetChipMode - failed w/status = %x\n",Status);
    }

ExitSetChipModeNoChange:

    return Status;
}

NTSTATUS
PptClearChipMode (
    IN  PFDO_EXTENSION  Fdx,
    IN  UCHAR              ChipMode
    )
/*++

Routine Description:

    This routine Clears the Given chip mode.

Arguments:

    Fdx   - Supplies the device extension.
    ChipMode    - The given mode to clear from the Chip

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    ULONG EcrMode = ChipMode & ~ECR_MODE_MASK;

    // make sure we have a mode to clear
    if ( EcrMode != Fdx->PnpInfo.CurrentMode ) {
                
        DD((PCE)Fdx,DDW,"ParMode::PptClearChipMode: Mode to Clear != CurrentModen");

        // Current mode is not the same as requested to take it out of
        Status = STATUS_INVALID_DEVICE_STATE;

        goto ExitClearChipModeNoChange;
    }

    // need to find out what mode it was and try to take it out of it
    
    // check to see if we used the filter to set the mode
    if ( Fdx->FilterMode ) {
        Status = Fdx->ChipInfo.ParChipClearMode ( Fdx->ChipInfo.Context, ChipMode );
    } else {

        // If ECP mode check to see if we can clear it
        if ( EcrMode == ECR_ECP_MODE ) {
            Status = PptEcrClearMode( Fdx );
            goto ExitClearChipModeWithChanges;
        }
    
        // If EPP mode check to see if we can clear it
        if ( EcrMode == ECR_EPP_MODE ) {
            Status = PptEcrClearMode( Fdx );
            goto ExitClearChipModeWithChanges;
        }

        // If BYTE mode clear it if use ECR register
        if ( EcrMode == ECR_BYTE_MODE ) {
            Status = PptClearByteMode( Fdx );
            goto ExitClearChipModeWithChanges;
        }    
    }
    
ExitClearChipModeWithChanges:

    if( NT_SUCCESS(Status) ) {
        Fdx->PnpInfo.CurrentMode = INITIAL_MODE;
    }

ExitClearChipModeNoChange:

    return Status;
}

NTSTATUS
PptEcrSetMode(
    IN  PFDO_EXTENSION   Fdx,
    IN  UCHAR               ChipMode
    )

/*++

Routine Description:

    This routine enables EPP mode through the ECR register.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/

{

    UCHAR   ecr;
    PUCHAR  Controller;
    PUCHAR  wPortECR;
            
    Controller = Fdx->PortInfo.Controller;
    
    //
    // Store the prior mode.
    //
    wPortECR = Fdx->PnpInfo.EcpController + ECR_OFFSET;

    ecr = P5ReadPortUchar( wPortECR );
    Fdx->EcrPortData = ecr;
    
    // get rid of prior mode which is the top three bits
    ecr &= ECR_MODE_MASK;

    // Write out SPP mode first to the chip
    P5WritePortUchar( wPortECR, (UCHAR)(ecr | ECR_BYTE_MODE) );

    // Write new mode to ECR register    
    P5WritePortUchar( wPortECR, ChipMode );
    
    return STATUS_SUCCESS;

}

NTSTATUS
PptSetByteMode( 
    IN  PFDO_EXTENSION   Fdx,
    IN  UCHAR               ChipMode
    )

/*++

Routine Description:

    This routine enables Byte mode either through the ECR register 
    (if available).  Or just checks it to see if it works

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/
{
    NTSTATUS    Status;
    
    // Checking to see if ECR register is there and if there use it
    if ( Fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT ) {
        Status = PptEcrSetMode( Fdx, ChipMode );    
    }
    
    Status = PptCheckByteMode( Fdx );

    return Status;

}    

NTSTATUS
PptClearByteMode( 
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This routine Clears Byte mode through the ECR register if there otherwise
    just returns success because nothing needs to be done.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    // Put ECR register back to original if it was there
    if ( Fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT ) {
        Status = PptEcrClearMode( Fdx );    
    }
    
    return Status;
}    

NTSTATUS
PptCheckByteMode(
    IN  PFDO_EXTENSION   Fdx
    )
    
/*++
      
Routine Description:
      
    This routine checks to make sure we are still Byte capable before doing
    any transfering of data.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
    
{
    PUCHAR  Controller;
    UCHAR   dcr;
    
    Controller = Fdx->PortInfo.Controller;

    //
    // run the test again to make sure somebody didn't take us out of a
    // bi-directional capable port.
    //
    // 1. put in extended read mode.
    // 2. write data pattern
    // 3. read data pattern
    // 4. if bi-directional capable, then data patterns will be different.
    // 5. if patterns are the same, then check one more pattern.
    // 6. if patterns are still the same, then port is NOT bi-directional.
    //

    // get the current control port value for later restoration
    dcr = P5ReadPortUchar( Controller + DCR_OFFSET );

    // put port into extended read mode
    P5WritePortUchar( Controller + DCR_OFFSET, (UCHAR)(dcr | DCR_DIRECTION) );

    // write the first pattern to the port
    P5WritePortUchar( Controller, (UCHAR)0x55 );
    if ( P5ReadPortUchar( Controller ) == (UCHAR)0x55 ) {
        // same pattern, try the second pattern
        P5WritePortUchar( Controller, (UCHAR)0xaa );
        if ( P5ReadPortUchar( Controller ) == (UCHAR)0xaa ) {
            // the port is NOT bi-directional capable
            return STATUS_UNSUCCESSFUL;
        }
    }

    // restore the control port to its original value
    P5WritePortUchar( Controller + DCR_OFFSET, (UCHAR)dcr );

    return STATUS_SUCCESS;

}

NTSTATUS
PptEcrClearMode(
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This routine disables EPP or ECP mode whichever one the chip
    was in through the ECR register.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if it was successful.
   !STATUS_SUCCESS  - otherwise.

--*/

{

    UCHAR   ecr;
    PUCHAR  Controller;
    PUCHAR  wPortECR;
    
    Controller = Fdx->PortInfo.Controller;
    
    //
    // Restore the prior mode.
    //

    // Get original ECR register
    ecr = Fdx->EcrPortData;
    Fdx->EcrPortData = 0;

    // some chips require to change modes only after 
    // you put it into spp mode

    wPortECR = Fdx->PnpInfo.EcpController + ECR_OFFSET;

    P5WritePortUchar( wPortECR, (UCHAR)(ecr & ECR_MODE_MASK) );

    // Back to original mode
    P5WritePortUchar( wPortECR, ecr );
    
    return STATUS_SUCCESS;

}


NTSTATUS
PptBuildResourceList(
    IN  PFDO_EXTENSION   Fdx,
    IN  ULONG               Partial,
    IN  PUCHAR             *Addresses,
    OUT PCM_RESOURCE_LIST   Resources
    )

/*++

Routine Description:

    This routine Builds a CM_RESOURCE_LIST with 1 Full Resource
    Descriptor and as many Partial resource descriptors as you want
    with the same parameters for the Full.  No Interrupts or anything
    else just IO addresses.

Arguments:

    Fdx   - Supplies the device extension.
    Partial     - Number (array size) of partial descriptors in Addresses[]
    Addresses   - Pointer to an Array of addresses of the partial descriptors
    Resources   - The returned CM_RESOURCE_LIST

Return Value:

    STATUS_SUCCESS       - if the building of the list was successful.
    STATUS_UNSUCCESSFUL  - otherwise.

--*/

{

    UCHAR       i;

    //
    // Number of Full Resource descriptors
    //
    Resources->Count = 1;
    
    Resources->List[0].InterfaceType = Fdx->InterfaceType;
    Resources->List[0].BusNumber = Fdx->BusNumber;
    Resources->List[0].PartialResourceList.Version = 0;
    Resources->List[0].PartialResourceList.Revision = 0;
    Resources->List[0].PartialResourceList.Count = Partial;

    //
    // Going through the loop for each partial descriptor
    //
    for ( i = 0; i < Partial ; i++ ) {

        //
        // Setup port
        //
        Resources->List[0].PartialResourceList.PartialDescriptors[i].Type = CmResourceTypePort;
        Resources->List[0].PartialResourceList.PartialDescriptors[i].ShareDisposition = CmResourceShareDriverExclusive;
        Resources->List[0].PartialResourceList.PartialDescriptors[i].Flags = CM_RESOURCE_PORT_IO;
        Resources->List[0].PartialResourceList.PartialDescriptors[i].u.Port.Start.QuadPart = (ULONG_PTR)Addresses[i];
        Resources->List[0].PartialResourceList.PartialDescriptors[i].u.Port.Length = (ULONG)2;

    }


    return ( STATUS_SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\daisychain.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    par12843.c

Abstract:

    This is the main module for 1284.3 functionality.  These
      function enable the selection and deselection of 1284.3
      compatable devices on the parallel port.

    The devices can be selected and deselected IRQL <= DISPATCH_LEVEL 
    by calling IOCTL_INTERNAL_SELECT_DEVICE, or 'TrySelectDevice'.
    The first call is the simplest:  the IRP will be queued in the
    parallel port driver until the port is free and then it will 
    try to select the device with the given ID from the structure
    PARALLEL_1284_COMMAND.  If successful it will with a successful 
    status, otherwise it will return with an unsuccessful status.
    The class driver may cancel this IRP at any time which serves 
    as a mechanism to timeout an allocate request.

    The 'TrySelectDevice' call returns immediately from the port
    driver with a TRUE status if the port was allocated and the
    device was able to be selected or a FALSE status if the port 
    was either busy or the device was not able to be selected.

    Once the device is selected, the port is owned by the selecting class
    driver until a 'DeselectDevice' call is made.  This deselects the
    device and also releases the port and wakes up the next caller.

Author:

    Don E. Redford  3-Mar-1998

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

ULONG
PptInitiate1284_3(
    IN  PVOID   Extension
    );

NTSTATUS
PptTrySelectDevice(
    IN  PVOID   Context,
    IN  PVOID   TrySelectCommand
    );

NTSTATUS
PptDeselectDevice(
    IN  PVOID   Context,
    IN  PVOID   DeselectCommand
    );

ULONG
Ppt1284_3AssignAddress(
    IN  PFDO_EXTENSION    DeviceExtension
    );

BOOLEAN
PptSend1284_3Command(
    IN  PUCHAR  CurrentPort,
    IN  UCHAR   Command
    );

BOOLEAN
PptCheckIfStl1284_3(
    IN PFDO_EXTENSION    DeviceExtension,
    IN ULONG    ulDaisyIndex,
    IN BOOLEAN  bNoStrobe
    );

BOOLEAN
PptCheckIfNon1284_3Present(
    IN PFDO_EXTENSION    Extension
    );

BOOLEAN
PptCheckIfStlProductId(
    IN PFDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    );
//
// Beginning of functions
//

ULONG
PptInitiate1284_3(
    IN  PVOID   Extension
    )

/*++

Routine Description:

    This routine initializes all of the 1284.3 devices out on the
    given parallel port.  It does this by assigning 1284.3 addresses to
    each device on the port.

Arguments:

    Extensioon    - Device extension structure.

Return Value:

    None.

--*/

{
    ULONG deviceCount1 = 0;
    ULONG deviceCount2 = 0;
    ULONG loopCount    = 0;
    ULONG maxTries     = 3; // picked 3 out of thin air as a "reasonable" value

    // Send command to assign addresses and count number of 1284.3 daisy chain devices 
    // Try multiple times to make sure we get the same count
    do {

        KeStallExecutionProcessor( 5 );
        deviceCount1 = Ppt1284_3AssignAddress( Extension );

        KeStallExecutionProcessor( 5 );
        deviceCount2 = Ppt1284_3AssignAddress( Extension );

        if( deviceCount1 != deviceCount2 ) {
            DD((PCE)Extension,DDW,"PptInitiate1284_3 - count unstable\n");
            PptAssert(deviceCount1 == deviceCount2);
        }

    } while( (deviceCount1 != deviceCount2) && (++loopCount < maxTries) );

    return deviceCount2;
}

NTSTATUS
PptTrySelectDevice(
    IN  PVOID   Context,
    IN  PVOID   TrySelectCommand
    )
/*++

Routine Description:

    This routine first tries to allocate the port.  If successful
      it will then try to select  the device with the ID given.

Arguments:

    Extension   -   Driver extension.
    Device      -   1284.3 Device Id.
    Command     -   Command to know whether to allocate the port

Return Value:

    TRUE            -  Able to allocate the port and select the device
    FALSE           -  1: Invalid ID    2: Not able to allocate port    3: Not able to select device

--*/
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PFDO_EXTENSION           Extension = Context;
    PPARALLEL_1284_COMMAND      Command = TrySelectCommand;
    BOOLEAN                     success = FALSE;
    SYNCHRONIZED_COUNT_CONTEXT  SyncContext;
    KIRQL                       CancelIrql;
    UCHAR                       i, DeviceID;

    if( ( Command->CommandFlags & PAR_LEGACY_ZIP_DRIVE ) ||
        ( Command->ID == DOT3_LEGACY_ZIP_ID )) {
        Status = PptTrySelectLegacyZip(Context, TrySelectCommand);
        DD((PCE)Extension,DDT,"PptTrySelectDevice - LegacyZip - status=%x\n",Status);
        return Status;
    }

    // get device ID to select
    DeviceID = Command->ID;
            
    // validate parameters - we will accept:
    //   - a Dot3 device with a valid DeviceID
    //   - an End-of-Chain device indicated by the PAR_END_OF_CHAIN_DEVICE flag, or
    //   - an End-of-Chain device indicated by a DeviceID value one past the last Dot3 device

    if ( !(Command->CommandFlags & PAR_END_OF_CHAIN_DEVICE) && DeviceID > Extension->PnpInfo.Ieee1284_3DeviceCount ) {
                
        // Requested device is not flagged as End-of-Chain device and DeviceID
        //   is more than one past the end of the Dot3 Devices, so FAIL the IRP
        DD((PCE)Extension,DDE,"PptTrySelectDevice - FAIL - invalid DeviceID parameter\n",DeviceID);
        PptAssertMsg("PptTrySelectDevice - FAIL - invalid DeviceID parameter",FALSE);
        Status = STATUS_INVALID_PARAMETER;
                
    } else {
                
        //
        // Request appears valid
        //

        // test to see if we need to grab port
        if( Command->CommandFlags & PAR_HAVE_PORT_KEEP_PORT ) {

            //
            // requester has already acquired port, just do a SELECT
            //
            if ( !(Command->CommandFlags & PAR_END_OF_CHAIN_DEVICE) &&
                    DeviceID < Extension->PnpInfo.Ieee1284_3DeviceCount ) {

                // SELECT the device
                for ( i = 0; i < PptDot3Retries && !success; i++ ) {
                    // Send command to to select device in compatability mode
                    success = PptSend1284_3Command( Extension->PortInfo.Controller, (UCHAR)(CPP_SELECT | DeviceID) );
                    // Stall a little in case we have to retry
                    KeStallExecutionProcessor( 5 );
                }                

                if ( success ) {
                    DD((PCE)Extension,DDT,"PptTrySelectDevice - had port - SUCCESS\n");
                    Status = STATUS_SUCCESS;
                } else {
                    DD((PCE)Extension,DDW,"PptTrySelectDevice - FAIL\n");
                    Status = STATUS_UNSUCCESSFUL;
                }
            } else {
                // End-of-Chain device, no SELECT required, SUCCEED the request
                DD((PCE)Extension,DDT,"PptTrySelectDevice - EOC\n");
                Status = STATUS_SUCCESS;
            }

        } else {

            // Don't have the port

            //
            // Try to acquire port and select device
            //
            IoAcquireCancelSpinLock(&CancelIrql);
                
            SyncContext.Count = &Extension->WorkQueueCount;
                    
            if (Extension->InterruptRefCount) {
                KeSynchronizeExecution(Extension->InterruptObject, PptSynchronizedIncrement, &SyncContext);
            } else {
                PptSynchronizedIncrement(&SyncContext);
            }
                    
            if (SyncContext.NewCount) {
                // Port is busy, queue request
                DD((PCE)Extension,DDT,"PptTrySelectDevice - Port Busy - Request Queued\n");
                IoReleaseCancelSpinLock(CancelIrql);
                Status = STATUS_PENDING;

            } else {

                IoReleaseCancelSpinLock(CancelIrql);
                        
                // Port is acquired
                DD((PCE)Extension,DDT,"PptTrySelectDevice - Port Acquired\n");

                Extension->WmiPortAllocFreeCounts.PortAllocates++;

                if ( !(Command->CommandFlags & PAR_END_OF_CHAIN_DEVICE) && DeviceID < Extension->PnpInfo.Ieee1284_3DeviceCount ) {
                            
                    // SELECT the device
                    for ( i = 0; i < PptDot3Retries && !success; i++ ) {
                        // Send command to to select device in compatability mode
                        success = PptSend1284_3Command( Extension->PortInfo.Controller, (UCHAR)(CPP_SELECT | DeviceID) );
                        // Stall a little in case we have to retry
                        KeStallExecutionProcessor( 5 );
                    }                

                    if ( success ) {
                        DD((PCE)Extension,DDT,"PptTrySelectDevice - SUCCESS\n");
                        Status = STATUS_SUCCESS;
                    } else {
                        DD((PCE)Extension,DDW,"PptTrySelectDevice - FAILED\n");

                        // RMT - 000831 - do we still have the port locked!?! - did we hang the port?

                        Status = STATUS_UNSUCCESSFUL;
                    }

                } else {
                    // End-of-Chain device, no SELECT required, SUCCEED the request
                    DD((PCE)Extension,DDT,"PptTrySelectDevice - EOC2\n");
                    Status = STATUS_SUCCESS;
                }

            }  // endif - test for port busy
                    
        } // endif - test if already have port

    } // endif - test for valid parameters

    return Status;
}

NTSTATUS
PptDeselectDevice(
    IN  PVOID   Context,
    IN  PVOID   DeselectCommand
    )
    
/*++

Routine Description:

    This routine deselects the current device and then frees the port

Arguments:


Return Value:

    TRUE            -  Able to deselect the device and free the port
    FALSE           -  1: Invalid ID    2: Not able to deselect the drive

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    PFDO_EXTENSION       fdx = Context;
    PPARALLEL_1284_COMMAND  Command = DeselectCommand;
    BOOLEAN                 success = FALSE;
    UCHAR                   i, DeviceID;

    if( ( Command->CommandFlags & PAR_LEGACY_ZIP_DRIVE ) ||
        ( Command->ID == DOT3_LEGACY_ZIP_ID ) ) {
        return PptDeselectLegacyZip( Context, DeselectCommand );
    }

    // get device ID to deselect
    DeviceID = Command->ID;

    // validate ID
    if ( !(Command->CommandFlags & PAR_END_OF_CHAIN_DEVICE) && DeviceID > fdx->PnpInfo.Ieee1284_3DeviceCount ) {

        // not End-of-Chain device and Dot3 DeviceID is invalid
        DD((PCE)fdx,DDE,"PptDeselectDevice - ID=%d - FAIL - invalid parameter\n",DeviceID);
        Status = STATUS_INVALID_PARAMETER;
                
    } else {
                
        // Check for End-of-Chain device
        if ( !(Command->CommandFlags & PAR_END_OF_CHAIN_DEVICE) &&
                DeviceID < fdx->PnpInfo.Ieee1284_3DeviceCount ) {
                    
            // first deselect the device 
            for ( i = 0; i < PptDot3Retries && !success; i++ ) {
                success = PptSend1284_3Command( fdx->PortInfo.Controller, (UCHAR)CPP_DESELECT );
                // Stall a little in case we have to retry
                KeStallExecutionProcessor( 5 );
            }

            if ( success ) {
                // Deselecting device was a success
                DD((PCE)fdx,DDT,"PptDeselectDevice\n");

                // check if requester wants to keep port or free port
                if( !(Command->CommandFlags & PAR_HAVE_PORT_KEEP_PORT) ) {
                    PptFreePort( fdx );
                }
                Status = STATUS_SUCCESS;
                        
            } else {
                // Unable to deselect device, something went very wrong,
                //   port is now in an unknown/blocked state
                DD((PCE)fdx,DDE,"PptDeselectDevice - ID=%d - FAIL\n",DeviceID);
                PptAssertMsg("PptDeselectDevice - FAIL - port in unknown state",FALSE);
                Status = STATUS_UNSUCCESSFUL;
            }
                    
        } else {

            // this is End-of-Chain device so no deselect neccessary
            DD((PCE)fdx,DDT,"PptDeselectDevice - End-of-Chain - SUCCESS\n",DeviceID);

            // check if requester wants to keep port or free port
            if( !(Command->CommandFlags & PAR_HAVE_PORT_KEEP_PORT) ) {
                PptFreePort( fdx );
            }
            Status = STATUS_SUCCESS;

        }  // endif - Check if End Of Chain

    } // endif - Validate ID

    return Status;
}


ULONG
Ppt1284_3AssignAddress(
    IN  PFDO_EXTENSION    DeviceExtension
    )

/*++

Routine Description:

    This routine initializes the 1284_3 bus.

Arguments:

    DeviceExtension    - Supplies Device Extension structure of the driver.

Return Value:

    Number of 1284.3 devices out there at the given address.

--*/

{

    //UCHAR  i, ii, value, newvalue, status;
    UCHAR  i, value, newvalue, status;
    PUCHAR CurrentPort, CurrentStatus, CurrentControl;
    ULONG  Delay = 5;
    UCHAR  number = 0;
    BOOLEAN lastdevice = FALSE;
    UCHAR   idx;

    CurrentPort = DeviceExtension->PortInfo.Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = P5ReadPortUchar( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {        

                // Device is out there
                KeStallExecutionProcessor( Delay );

                while ( number < 4 && !lastdevice ) {

                    // Asssign address byte
                    P5WritePortUchar( CurrentPort, number );
                    number = (UCHAR)(number + 1);

                    KeStallExecutionProcessor( Delay );                    // wait a bit
                    if ( (P5ReadPortUchar( CurrentStatus ) & (UCHAR)DSR_NOT_BUSY ) == 0 ) {
                        // we saw last device
                        lastdevice = TRUE;    
                    }

                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    KeStallExecutionProcessor( Delay );        // wait a bit
                }

                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

                if ( number ) {
                    BOOLEAN bStlNon1284_3Found ;
                    BOOLEAN bStlNon1284_3Valid ;
                    bStlNon1284_3Found = PptCheckIfNon1284_3Present(DeviceExtension);
                    bStlNon1284_3Valid = FALSE ;
                    // as the earlier 1284 spec does not give the
                    // lastdevice status is BSY, number needs to
                    // be corrected in such cases
                    for ( idx = 0 ; idx < number ; idx++ ) {
                        if ( TRUE == PptCheckIfStl1284_3(DeviceExtension, idx, bStlNon1284_3Found ) ) {
                            continue ;
                        }
                        if ( TRUE == bStlNon1284_3Found ) {
                            if ( TRUE == PptCheckIfStlProductId(DeviceExtension, idx) ) {
                                bStlNon1284_3Valid = TRUE ;
                                continue ;
                            }
                        }
                        break ;
                    }
                    if ( TRUE == bStlNon1284_3Valid ) {
                        // we alter the count only if old adapters
                        // are in the chain
                        number = idx;
                    }
                }

            } // Third status

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    // returns last device ID + 1 or number of devices out there
    return ( (ULONG)number );

}

BOOLEAN
PptCheckIfNon1284_3Present(
    IN PFDO_EXTENSION    Extension
    )
/*++

Routine Description:

    Indicates whether one of the devices of the earlier
    specification is present in the chain.


Arguments:

    Extension   - Device Extension structure


Return Value:

    TRUE    : Atleast one of the adapters are of earlier spec.
    FALSE   : None of the adapters of the earlier spec.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;
    UCHAR   ucAckStatus ;

    CurrentPort = Extension->PortInfo.Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        ucAckStatus = status & 0x40 ;

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            if ( ucAckStatus != ( status & 0x40 ) ) {

                // save current ack status
                ucAckStatus = status & 0x40 ;

                // continue with sixth byte
                P5WritePortUchar( CurrentPort, ModeQualifier[5] );
                KeStallExecutionProcessor( Delay );

                // check for correct status
                status = P5ReadPortUchar( CurrentStatus );

                // if status is valid there is a device out there responding
                if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {        

                    bReturnValue = TRUE ;

                } // Third status

            } // ack of earlier adapters not seen

            // last byte
            P5WritePortUchar( CurrentPort, ModeQualifier[6] );

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    return bReturnValue ;
} // PptCheckIfNon1284_3Present


// Define 1284 Commands
#define CPP_QUERY_PRODID    0x10

// 1284 related SHTL prod id equates
#define SHTL_EPAT_PRODID    0xAAFF
#define SHTL_EPST_PRODID    0xA8FF

BOOLEAN
PptCheckIfStl1284_3(
    IN PFDO_EXTENSION    DeviceExtension,
    IN ULONG    ulDaisyIndex,
    IN BOOLEAN  bNoStrobe
    )
/*++

Routine Description:

    This function checks to see whether the device indicated
    is a Shuttle 1284_3 type of device. 

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy chain id of the device that
                      this function will check on.

    bNoStrobe       - If set, indicates that the query
                      Ep1284 command issued by this function
                      need not assert strobe to latch the
                      command.

Return Value:

    TRUE            - Yes. Device is Shuttle 1284_3 type of device.
    FALSE           - No. This may mean that this device is either
                      non-shuttle or Shuttle non-1284_3 type of
                      device.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    UCHAR   ucExpectedPattern ;
    UCHAR   ucReadValue, ucReadPattern;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;

    CurrentPort = DeviceExtension->PortInfo.Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = P5ReadPortUchar( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {        

                // Device is out there
                KeStallExecutionProcessor( Delay );

                // issue shuttle specific CPP command
                P5WritePortUchar( CurrentPort, (UCHAR) ( 0x88 | ulDaisyIndex ) );
                KeStallExecutionProcessor( Delay );        // wait a bit

                if ( ulDaisyIndex && ( bNoStrobe == FALSE ) ) {

                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    KeStallExecutionProcessor( Delay );        // wait a bit

                }

                ucExpectedPattern = 0xF0 ;
                bReturnValue = TRUE ;

                while ( ucExpectedPattern ) {

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentPort, (UCHAR) (0x80 | ulDaisyIndex )) ;

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentPort, (UCHAR) (0x88 | ulDaisyIndex )) ;

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    ucReadValue = P5ReadPortUchar( CurrentStatus ) ;
                    ucReadPattern = ( ucReadValue << 1 ) & 0x70 ;
                    ucReadPattern |= ( ucReadValue & 0x80 ) ;

                    if ( ucReadPattern != ucExpectedPattern ) {
                        // not Shuttle 1284_3 behaviour
                        bReturnValue = FALSE ;
                        break ;
                    }

                    ucExpectedPattern -= 0x10 ;
                }


                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

            } // Third status

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    return bReturnValue ;
} // end  PptCheckIfStl1284_3()

BOOLEAN
PptCheckIfStlProductId(
    IN PFDO_EXTENSION    DeviceExtension,
    IN ULONG   ulDaisyIndex
    )
/*++

Routine Description:

    This function checks to see whether the device indicated
    is a Shuttle non-1284_3 type of device. 

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy chain id of the device that
                      this function will check on.

Return Value:

    TRUE            - Yes. Device is Shuttle non-1284_3 type of device.
    FALSE           - No. This may mean that this device is 
                      non-shuttle.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    UCHAR   ucProdIdHiByteHiNibble, ucProdIdHiByteLoNibble ;
    UCHAR   ucProdIdLoByteHiNibble, ucProdIdLoByteLoNibble ;
    UCHAR   ucProdIdHiByte, ucProdIdLoByte ;
    USHORT  usProdId ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;

    CurrentPort = DeviceExtension->PortInfo.Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = P5ReadPortUchar( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {

                P5WritePortUchar ( CurrentPort, (UCHAR) (CPP_QUERY_PRODID | ulDaisyIndex )) ;
                KeStallExecutionProcessor( Delay );

                // Device is out there
                KeStallExecutionProcessor( Delay );
                ucProdIdLoByteHiNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdLoByteHiNibble &= 0xF0 ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdLoByteLoNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdLoByteLoNibble >>= 4 ;
                ucProdIdLoByte = ucProdIdLoByteHiNibble | ucProdIdLoByteLoNibble ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdHiByteHiNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdHiByteHiNibble &= 0xF0 ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdHiByteLoNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdHiByteLoNibble >>= 4 ;
                ucProdIdHiByte = ucProdIdHiByteHiNibble | ucProdIdHiByteLoNibble ;

                // issue the last strobe
                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                usProdId = ( ucProdIdHiByte << 8 ) | ucProdIdLoByte ;

                if ( ( SHTL_EPAT_PRODID == usProdId ) ||\
                     ( SHTL_EPST_PRODID == usProdId ) ) {
                    // one of the devices that conform to the earlier
                    // draft is found
                    bReturnValue = TRUE ;
                }

                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

            } // Third status

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    return bReturnValue ;
} // end  PptCheckIfStlProductId()

BOOLEAN
PptSend1284_3Command(
    IN  PUCHAR  CurrentPort,
    IN  UCHAR   Command
    )
/*++

Routine Description:

    This routine sends the 1284_3 Command given to it
    down the parallel bus.

Arguments:


Return Value:

    None.

--*/
{
    UCHAR  i, value, newvalue, test;//, status;
    ULONG  ii;
    PUCHAR CurrentStatus, CurrentControl;
    ULONG  Delay = 3;
    BOOLEAN success = FALSE;

    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // Get Upper 4 bits to see what Command it is
    test = (UCHAR)(Command & (UCHAR)CPP_COMMAND_FILTER);

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );
    
    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);
    
    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );       // make sure we can write 
    
    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
    KeStallExecutionProcessor( Delay );
    
    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }
    
    // wait up to 5 us : Spec says about 2 but we will be lienient
    if (CHECK_DSR(CurrentPort, INACTIVE, DONT_CARE, ACTIVE, ACTIVE, ACTIVE, 5 )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );
        
        // wait up to 5 us : Spec says about 2 but we will be lienient
        if (CHECK_DSR(CurrentPort, ACTIVE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, 5 )) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );
            
            // wait up to 5 us : Spec says about 2 but we will be lienient
            if (CHECK_DSR(CurrentPort, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, 5 )) {

                // Device is out there
                
                KeStallExecutionProcessor( Delay );

                // Command byte
                P5WritePortUchar( CurrentPort, Command );
                KeStallExecutionProcessor( Delay );        // wait a bit

                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit

                // NOTE NOTE NOTE
                // Assertion of strobe to be done ONLY after checking for the
                // FAULT feedback, as per the 1284_3 specification.

                // Selection does not work correctly yet to be able to check for lines
                switch ( test ) {
                    
                case CPP_SELECT:
                    // Check to make sure we are selected

                    // wait for upto 250 micro Secs for for selection time out.
                    for ( ii = 25000; ii > 0; ii-- ) {
                        
                        if ( ( P5ReadPortUchar( CurrentStatus ) & DSR_NOT_FAULT ) == DSR_NOT_FAULT ) {
                            // selection...
                            success = TRUE;
                            break;
                        }
                    }
                    break;

                case CPP_DESELECT:
                    // Check to make sure we are deselected                    

                    // wait for upto 250 micro Secs for for deselection time out.
                    for ( ii = 25000; ii > 0; ii-- ) {

                        if ( (P5ReadPortUchar( CurrentStatus ) & DSR_NOT_FAULT) != DSR_NOT_FAULT ) {
                            // deselection...
                            success = TRUE;
                            break;
                        }
                    }
                    break;

                default :
                    // there is a device out there and Command completed sucessfully
                    KeStallExecutionProcessor( Delay );        // wait a bit
                    success = TRUE;
                    break;

                } // End Switch

                // NOTE NOTE NOTE
                // the strobe is de-asserted now and the command is completed here
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

            } // Third status
            
        } // Second status
        
    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    // return TRUE if command succeeded, FALSE otherwise
    return success;
}


BOOLEAN
ParSelectDevice(
    IN  PPDO_EXTENSION  Pdx,
    IN  BOOLEAN         HavePort
    )

/*++

Routine Description:

    This routine acquires the ParPort and selects a 1284.3 device

Arguments:

    Pdx   - Supplies the device extension.

    HavePort    - TRUE  indicates that caller has already acquired port
                    so we should only do a SELECT_DEVICE
                - FALSE indicates that caller has not already acquired port
                    so we should do a combination ACQUIRE_PORT/SELECT_DEVICE

Return Value:

    TRUE    - success - the device was selected (and port acquired if needed)
    FALSE   - failure

--*/
{
    NTSTATUS                    status;
    PDEVICE_OBJECT              pPortDeviceObject;
    PARALLEL_1284_COMMAND       par1284Command;
    LARGE_INTEGER               timeOut;
    enum _PdoType               pdoType;

    //
    // Initialize command structure and extract parameters from the DeviceExtension
    //

    // reserved - always set to 0
    par1284Command.Port = 0;

    if( HavePort ) {
        par1284Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT;
    } else {
        par1284Command.CommandFlags = 0;
    }

    pdoType = Pdx->PdoType;
    switch( pdoType ) {
    case PdoTypeRawPort:
    case PdoTypeEndOfChain:
        par1284Command.ID = 0; // ignored, but set anyway
        par1284Command.CommandFlags |= PAR_END_OF_CHAIN_DEVICE;
        break;
    case PdoTypeLegacyZip:
        par1284Command.ID = DOT3_LEGACY_ZIP_ID;
        break;
    case PdoTypeDaisyChain:
        par1284Command.ID = Pdx->Ieee1284_3DeviceId;
        break;
    default:
        DD((PCE)Pdx,DDE,"Invalid pdoType = %x\n",pdoType);
        PptAssert(FALSE);
        break;
    }

    pPortDeviceObject = Pdx->PortDeviceObject;

    //
    // Send the request
    //
    timeOut.QuadPart = -(10*1000*500); // 500ms ( 100ns units )

    status = ParBuildSendInternalIoctl(IOCTL_INTERNAL_SELECT_DEVICE,
                                       pPortDeviceObject,
                                       &par1284Command, sizeof(PARALLEL_1284_COMMAND),
                                       NULL, 0,
                                       &timeOut);

    if( NT_SUCCESS( status ) ) {
        // SELECT succeeded
        DD((PCE)Pdx,DDT,"ParSelectDevice - SUCCESS\n");
        if( !HavePort ) {
            // note in the device extension that we have the port
            Pdx->bAllocated = TRUE;
        }
        return TRUE;
    } else {
        // SELECT failed
        DD((PCE)Pdx,DDT,"ParSelectDevice - FAIL\n");
        return FALSE;
    }
}

BOOLEAN
ParDeselectDevice(
    IN  PPDO_EXTENSION  Pdx,
    IN  BOOLEAN         KeepPort
    )
/*++

Routine Description:

    This routine deselects a 1284.3 or Legacy Zip device and optionally
    releases the ParPort

Arguments:

    Pdx   - Supplies the device extension.

    KeepPort    - TRUE  indicates that we should keep the port acquired,
                    so we should only do a DESELECT_DEVICE
                - FALSE indicates that we should not keep the port acquired,
                    so we should do a combination DESELECT_DEVICE/FREE_PORT

Return Value:

    TRUE    - The device was deselected (and the port released if requested)

--*/
{
    PARALLEL_1284_COMMAND       par1284Command;
    NTSTATUS                    status;
    enum _PdoType               pdoType;
    PDEVICE_OBJECT              fdo = Pdx->Fdo;
    PFDO_EXTENSION              fdx = fdo->DeviceExtension;

    //
    // If we don't have the port, succeed and return
    //
    if( !Pdx->bAllocated ) {
        DD((PCE)Pdx,DDW,"ParDeselectDevice - we do not have the port\n");
        return TRUE;
    }

    //
    // Initialize command structure and extract parameters from the DeviceExtension
    //

    // reserved - always set to 0
    par1284Command.Port = 0;

    if( KeepPort ) {
        par1284Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT;
    } else {
        par1284Command.CommandFlags = 0;
    }

    pdoType = Pdx->PdoType;
    switch( pdoType ) {
    case PdoTypeRawPort:
    case PdoTypeEndOfChain:
        par1284Command.ID = 0; // ignored, but set anyway
        par1284Command.CommandFlags |= PAR_END_OF_CHAIN_DEVICE;
        break;
    case PdoTypeLegacyZip:
        par1284Command.ID = DOT3_LEGACY_ZIP_ID;
        break;
    case PdoTypeDaisyChain:
        par1284Command.ID = Pdx->Ieee1284_3DeviceId;
        break;
    default:
        DD((PCE)Pdx,DDE,"Invalid pdoType = %x\n",pdoType);
        par1284Command.ID = 0; // choose a 1284.3 type deselect since this is harmless
        PptAssert(FALSE);
        break;
    }

    status = PptDeselectDevice( fdx, &par1284Command );

    if( status != STATUS_SUCCESS ) {
        // DESELECT failed?!? - there isn't anything that we can do
        DD((PCE)Pdx,DDE,"ParDeselectDevice - FAILED - nothing we can do - status=%x\n", status);
    } else {
        DD((PCE)Pdx,DDT,"ParDeselectDevice - SUCCESS\n", status);
    }

    if( !KeepPort ) {
        // note in the device extension that we gave up the port
        DD((PCE)Pdx,DDT,"ParDeselectDevice - gave up port\n");
        Pdx->bAllocated = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       debug.c
//
//--------------------------------------------------------------------------

#include "pch.h"


// Diagnostic globals - used during development
ULONG d1;
ULONG d2;
ULONG d3;
ULONG d4;
ULONG d5;
ULONG d6;
ULONG d7;
ULONG d8;
ULONG d9;

// Debug globals
ULONG Trace;
ULONG Break;
ULONG AllowAsserts = 0;

//
// set bits using PPT_DD_* bit defs to mask off debug spew for a specific device
//
ULONG DbgMaskFdo         = 0;
ULONG DbgMaskRawPort     = 0;
ULONG DbgMaskDaisyChain0 = 0;
ULONG DbgMaskDaisyChain1 = 0;
ULONG DbgMaskEndOfChain  = 0;
ULONG DbgMaskLegacyZip   = 0;
ULONG DbgMaskNoDevice    = 0;

PCHAR PnpIrpName[] = {
    "0x00 - IRP_MN_START_DEVICE",
    "0x01 - IRP_MN_QUERY_REMOVE_DEVICE",
    "0x02 - IRP_MN_REMOVE_DEVICE",
    "0x03 - IRP_MN_CANCEL_REMOVE_DEVICE",
    "0x04 - IRP_MN_STOP_DEVICE",
    "0x05 - IRP_MN_QUERY_STOP_DEVICE",
    "0x06 - IRP_MN_CANCEL_STOP_DEVICE",
    "0x07 - IRP_MN_QUERY_DEVICE_RELATIONS",
    "0x08 - IRP_MN_QUERY_INTERFACE",
    "0x09 - IRP_MN_QUERY_CAPABILITIES",
    "0x0A - IRP_MN_QUERY_RESOURCES",
    "0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
    "0x0C - IRP_MN_QUERY_DEVICE_TEXT",
    "0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
    "0x0E - unused Pnp MinorFunction",
    "0x0F - IRP_MN_READ_CONFIG",
    "0x10 - IRP_MN_WRITE_CONFIG",
    "0x11 - IRP_MN_EJECT",
    "0x12 - IRP_MN_SET_LOCK",
    "0x13 - IRP_MN_QUERY_ID",
    "0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE",
    "0x15 - IRP_MN_QUERY_BUS_INFORMATION",
    "0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION",
    "0x17 - IRP_MN_SURPRISE_REMOVAL",
    "0x18 - IRP_MN_QUERY_LEGACY_BUS_INFORMATION"
};

PCHAR PhaseName[] = {
    "PHASE_UNKNOWN",
    "PHASE_NEGOTIATION",
    "PHASE_SETUP",                    // Used in ECP mode only
    "PHASE_FORWARD_IDLE",
    "PHASE_FORWARD_XFER",
    "PHASE_FWD_TO_REV",
    "PHASE_REVERSE_IDLE",
    "PHASE_REVERSE_XFER",
    "PHASE_REV_TO_FWD",
    "PHASE_TERMINATE",
    "PHASE_DATA_AVAILABLE",           // Used in nibble and byte modes only
    "PHASE_DATA_NOT_AVAIL",           // Used in nibble and byte modes only
    "PHASE_INTERRUPT_HOST"            // Used in nibble and byte modes only
};

#if 1 == DBG_SHOW_BYTES
ULONG DbgShowBytes = 1; // turn off via reg setting: Services\Parport\Parameters\DbgShowBytes : REG_DWORD : 0x0 
#endif

#if 1 == PptEnableDebugSpew
VOID
P5TraceIrpArrival( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PCOMMON_EXTENSION cdx = DevObj->DeviceExtension;
    DD(cdx,DDE,"Irp arrival %x\n",Irp);
}

VOID
P5TraceIrpCompletion( PIRP Irp ) {
    //PCOMMON_EXTENSION cdx = DevObj->DeviceExtension;
    DD(NULL,DDE,"Irp completion %x\n",Irp);
}

VOID
P5SetPhase( PPDO_EXTENSION Pdx, P1284_PHASE Phase ) {
    LARGE_INTEGER tickCount;
    KeQueryTickCount( &tickCount );
    if( Pdx->CurrentPhase != Phase ) {
        Pdx->CurrentPhase = Phase;
        PptAssert(Phase < arraysize(PhaseName));
        DD((PCE)Pdx,DDT,"P5SetPhase at %I64x to %2d - %s\n",tickCount,Phase,PhaseName[Phase]);
    }
}

VOID
P5BSetPhase( PIEEE_STATE IeeeState, P1284_PHASE Phase ) {
    LARGE_INTEGER tickCount;
    KeQueryTickCount( &tickCount );
    if( IeeeState->CurrentPhase != Phase ) {
        IeeeState->CurrentPhase = Phase;
        PptAssert(Phase < arraysize(PhaseName));
        DD(NULL,DDT,"P5BSetPhase at %I64x to %2d - %s\n",tickCount,Phase,PhaseName[Phase]);
    }
}

#include "stdarg.h"
VOID
PptPrint( PCOMMON_EXTENSION Ext, ULONG Flags, PCHAR FmtStr, ... )
{
    CHAR            buf[ 256 ];
    LONG            count;
    va_list         va;
    const LONG      bufSize           = sizeof(buf);
    const LONG      maxLocationLength = sizeof("LPTx.y: ");
    ULONG           trace;
    ULONG           mask;
    PPDO_EXTENSION  pdx;
    PCHAR           location;

    PptAssertMsg( "0 == Flags", Flags );
    PptAssertMsg( "NULL FmtStr", FmtStr );

    if( Ext ) {

        location = Ext->Location;

        if( (NULL == location) || ('\0' == *location) ) {
            location = "NoLoc";
        }

        switch( Ext->DevType ) {
            
        case DevTypeFdo:
            mask = DbgMaskFdo;
            break;
            
        case DevTypePdo:
            pdx = (PPDO_EXTENSION)Ext;
            
            switch( pdx->PdoType ) {
                
            case PdoTypeRawPort:
                mask = DbgMaskRawPort;
                break;
                
            case PdoTypeEndOfChain:
                mask = DbgMaskEndOfChain;
                break;
                
            case PdoTypeDaisyChain:
                
                switch( pdx->Ieee1284_3DeviceId ) {
                case 0:
                    mask = DbgMaskDaisyChain0;
                    break;
                case 1:
                    mask = DbgMaskDaisyChain1;
                    break;
                default:
                    mask = 0;
                    PptAssert(FALSE);
                }
                break;
                
            case PdoTypeLegacyZip:
                mask = DbgMaskLegacyZip;
                break;
                
            default:
                // PptAssertMsg( "Invalid PdoType", FALSE );
                mask = 0;
            }
            break;
            
        default:
            // PptAssert(FALSE);
            mask = 0;
        }

    } else {

        // not device specific
        location = "LPTx";
        mask = DbgMaskNoDevice;

    }

    trace = Flags & Trace & ~mask;

    if( trace != 0 ) {

        va_start( va, FmtStr );
        
        __try {
            
            count  = _snprintf( buf, maxLocationLength, "%-6s: ", location );
            if( count < 0 ) {
                __leave;
            }
            
            count += _vsnprintf( buf+count, bufSize-count-1, FmtStr, va );
            if( count >= bufSize ) {
                __leave;
            }
            
            DbgPrint( "%s", buf );

        } 
        __finally {
            va_end( va );
        }

    } // endif ( trace != 0 )
        
    return;
}

UCHAR
P5ReadPortUchar( PUCHAR Port ) {
    UCHAR value;
    value = READ_PORT_UCHAR( Port );
    if( d1 ) {
        DbgPrint("zzz - READ_ PORT_UCHAR %x %02x\n",Port,value);
    }
    return value;
}

VOID
P5ReadPortBufferUchar( PUCHAR Port, PUCHAR Buffer, ULONG Count ) {
    READ_PORT_BUFFER_UCHAR( Port, Buffer, Count );
    return;
}

VOID
P5WritePortUchar( PUCHAR Port, UCHAR Value ) {
    if( d1 ) {
        DbgPrint("zzz - WRITE_PORT_UCHAR %x %02x\n",Port,Value);
    }

    WRITE_PORT_UCHAR( Port, Value );
    return;
}

VOID
P5WritePortBufferUchar( PUCHAR Port, PUCHAR Buffer, ULONG Count )
{
    WRITE_PORT_BUFFER_UCHAR( Port, Buffer, Count );
    return;
}

VOID
PptFdoDumpPnpIrpInfo(
    PDEVICE_OBJECT Fdo,
    PIRP Irp
    ) 
{
    PFDO_EXTENSION      fdx           = Fdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp         = IoGetCurrentIrpStackLocation( Irp );
    ULONG               minorFunction = irpSp->MinorFunction;

    PptAssert( DevTypeFdo == fdx->DevType );

    if( minorFunction < arraysize(PnpIrpName) ) {
        DD((PCE)fdx,DDT,"PptFdoDumpPnpIrpInfo - %s\n",PnpIrpName[ minorFunction ]);
    } else {
        DD((PCE)fdx,DDT,"PptFdoDumpPnpIrpInfo - bogus MinorFunction = %x\n",minorFunction);
    }
}

VOID
PptPdoDumpPnpIrpInfo(
    PDEVICE_OBJECT Pdo,
    PIRP Irp
    ) 
{
    PPDO_EXTENSION      pdx           = Pdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp         = IoGetCurrentIrpStackLocation( Irp );
    ULONG               minorFunction = irpSp->MinorFunction;

    PptAssert( DevTypePdo == pdx->DevType );

    if( minorFunction < arraysize(PnpIrpName) ) {
        DD((PCE)pdx,DDT,"PptPdoDumpPnpIrpInfo - %s\n",PnpIrpName[ minorFunction ]);
    } else {
        DD((PCE)pdx,DDT,"PptPdoDumpPnpIrpInfo - bogus MinorFunction = %x\n",minorFunction);
    }
}

NTSTATUS
PptAcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    )
{
    return IoAcquireRemoveLock(RemoveLock, Tag);
}

VOID
PptReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    )
{
    IoReleaseRemoveLock(RemoveLock, Tag);
}

VOID
PptReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag
    )
{
    IoReleaseRemoveLockAndWait(RemoveLock, Tag);
}
#endif // 1 == PptEnableDebugSpew



#if (1 == DVRH_PAR_LOGFILE)

#include "stdarg.h"

/**************************************************************************
Function:	DVRH_LogMessage()
Description:Logs message to configured output
Inputs:		Parameter indicated message log level and 
			Format string and parameters
Outputs:	Boolean value indicating success or failure
***************************************************************************/
BOOLEAN DVRH_LogMessage(PCHAR szFormat, ...)
{
    ULONG Length;
    char messagebuf[256];
    va_list va;
    IO_STATUS_BLOCK  IoStatus;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    HANDLE FileHandle;
    UNICODE_STRING fileName;
    
    //format the string
    va_start(va,szFormat);
    _vsnprintf(messagebuf,sizeof(messagebuf),szFormat,va);
    va_end(va);
    
    //get a handle to the log file object
    fileName.Buffer = NULL;
    fileName.Length = 0;
    fileName.MaximumLength = sizeof(DEFAULT_LOG_FILE_NAME) + sizeof(UNICODE_NULL);
    fileName.Buffer = ExAllocatePool(PagedPool,
                                     fileName.MaximumLength);
    if (!fileName.Buffer) {
        DD(NULL,DDE,"LogMessage: FAIL. ExAllocatePool Failed.\n");
        return FALSE;
    }
    RtlZeroMemory(fileName.Buffer, fileName.MaximumLength);
    status = RtlAppendUnicodeToString(&fileName, (PWSTR)DEFAULT_LOG_FILE_NAME);
    
    InitializeObjectAttributes (&objectAttributes,
                                (PUNICODE_STRING)&fileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    
    status = ZwCreateFile( &FileHandle,
                           FILE_APPEND_DATA,
                           &objectAttributes,
                           &IoStatus,
                           0, 
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,     
                           0 );
    
    if( NT_SUCCESS(status) ) {
        CHAR buf[300];
        LARGE_INTEGER time;
        KeQuerySystemTime(&time);
        
        //put a time stamp on the output message
        sprintf(buf,"%10u-%10u  %s",time.HighPart,time.LowPart,messagebuf);
        
        //format the string to make sure it appends a newline carrage-return to the 
        //end of the string.
        Length=strlen(buf);
        if( buf[Length-1]=='\n' ) {
            buf[Length-1]='\r';
            strcat(buf,"\n");
            Length++;
        } else {
            strcat(buf,"\r\n");
            Length+=2;
        }
        
        ZwWriteFile( FileHandle, NULL, NULL, NULL, &IoStatus, buf, Length, NULL, NULL );
        
        ZwClose( FileHandle );
    }

    if( fileName.Buffer ) {
        ExFreePool (fileName.Buffer);
    }

    return STATUS_SUCCESS;
}

/**************************************************************************
Function:	DVRH_LogByteData()
Description:Formats byte data to be displayed in the configured output
Inputs:		Log level, Whether this is input or output data, a pointer to
			the byte data buffer and the size of the buffer
Outputs:	Boolean indicated success or failure
***************************************************************************/
BOOLEAN DVRH_LogByteData(BOOLEAN READ,PCHAR szBuff,ULONG dwTransferred)
{
	CString	cStr;
	ULONG MAX_SIZE=80;
	UNICODE_STRING UniStr;
	ANSI_STRING AnsiStr;
	WCHAR wStr[8];
	PCHAR   szTemp=szBuff;
	UCHAR   bTemp;  
	ULONG	dwDisplaySize;

	UniStr.Length=0;
	UniStr.MaximumLength=8;
	UniStr.Buffer=wStr;
	AnsiStr.Length=0;
	AnsiStr.MaximumLength=0;
	AnsiStr.Buffer=NULL;

	if(READ)
		cStr=L"<RCV";
	else            
		cStr=L"SND>";

	//make sure the size of the requested string is within the set range
	dwDisplaySize=(((dwTransferred*3)+10) > MAX_SIZE)?((MAX_SIZE-10)/3):dwTransferred;

	//format byte data
	while(dwDisplaySize)
	{   
		bTemp=szTemp[0];
		if(bTemp > 0xF)
			cStr+=L" ";
		else
			cStr+=L" 0";

		RtlIntegerToUnicodeString(bTemp,16,&UniStr);
        		
		cStr+=UniStr.Buffer;

		szTemp++;
		dwDisplaySize--;
	}

	cStr.StringToAnsiString(&AnsiStr);
	LogMessage("%5u %s",dwTransferred,AnsiStr.Buffer);
	RtlFreeAnsiString(&AnsiStr);

	return (TRUE);
}
#endif // (1 == DVRH_PAR_LOGFILE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\becp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    becp.c

Abstract:

    This module contains code for the host to utilize BoundedECP if it has been
    detected and successfully enabled.

Author:

    Robbie Harris (Hewlett-Packard) 27-May-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"


NTSTATUS
PptBecpExitReversePhase(
    IN  PPDO_EXTENSION  Pdx
    )
{
    //
    // When using BECP, test nPeriphRequest prior to negotiation 
    // from reverse phase to forward phase.  Do not negotiate unless the 
    // peripheral indicates it is finished sending.  If using any other
    // mode, negotiate immediately.
    //
    if( SAFE_MODE == Pdx->ModeSafety ) {
        if( PHASE_REVERSE_IDLE == Pdx->CurrentPhase ) {
            if( !CHECK_DSR( Pdx->Controller, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, IEEE_MAXTIME_TL) ) {
                DD((PCE)Pdx,DDT,"PptBecpExitReversePhase: Periph Stuck. Can't Flip Bus\n");
                return STATUS_IO_TIMEOUT;
            }
        }
    }
    return ParEcpHwExitReversePhase( Pdx );
}

//============================================================================
// NAME:    ECPFrame::Read()
//
//
// LAC FRAME  12Dec97
//      This function is used for two different kinds of reads:
//        1) continuing read - where we don't expect to exit reverse mode afterwards
//        2) non-continuing read - where we expect to exit reverse mode afterwards
//      The problem is that we have no way of knowing which is which.  I can
//      either wait after each read for nPeriphRequest to drop, or I can
//      check to see if it has dropped when I enter and handle it then.  
//
//      The other problem is that we have no way of communicating the fact that 
//      we have done this to the PortTuple.  It uses the last_direction member
//      to decide whether it should even look at entering or exiting some phase.
//
//      Lets face it, we are on our own with this.  It is safer to leave it 
//      connected and then try to straighten things out when we come back.  I
//      know that this wastes some time, but so does waiting at the end of 
//      every read when only half of them are going to drop the nPeriphRequest.
//
//      This routine performs a 1284 ECP mode read into the given
//      buffer for no more than 'BufferSize' bytes.
//
//      This routine runs at DISPATCH_LEVEL.
//
// PARAMETERS:
//      Controller      - Supplies the base address of the parallel port.
//      pPortInfoStruct - Supplies port information as defined in p1284.h
//      Buffer          - Supplies the buffer to read into.
//      BufferSize      - Supplies the number of bytes in the buffer.
//      BytesTransferred - Returns the number of bytes transferred.
//
// RETURNS:
//      NTSTATUS STATUS_SUCCESS or...
//      The number of bytes successfully read from the port is
//      returned via one of the arguments passed into this method.
//
// NOTES:
//      - Called ECP_PatchReverseTransfer in the original 16 bit code.
//
//============================================================================
NTSTATUS
PptBecpRead(
    IN  PPDO_EXTENSION  Pdx,
    IN  PVOID           Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          BytesTransferred
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    DD((PCE)Pdx,DDT,"PptBecpRead: Enter BufferSize[%d]\n", BufferSize);
    status = ParEcpHwRead( Pdx, Buffer, BufferSize, BytesTransferred );

    if (NT_SUCCESS(status)) {

        PUCHAR Controller;

        Controller = Pdx->Controller;
        if ( CHECK_DSR_WITH_FIFO( Controller, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE,
                                  ECR_FIFO_EMPTY, ECR_FIFO_SOME_DATA,
                                  DEFAULT_RECEIVE_TIMEOUT) ) {    
            DD((PCE)Pdx,DDT,"PptBecpRead: No more data. Flipping to Fwd\n");
            //
            // Bounded ECP rule - no more data from periph - flip bus to forward
            //
            status = ParReverseToForward( Pdx );

        } else {
            UCHAR bDSR = P5ReadPortUchar( Controller + OFFSET_DSR );
            
            //
            // Periph still has data, check for valid state
            //

            DD((PCE)Pdx,DDT,"PptBecpRead: Periph says there is more data.  Checking for stall.\n");
            // It's OK for the device to continue asserting nPeriphReq,
            // it may have more data to send.  However, nAckReverse and
            // XFlag should be in a known state, so double check them.
            if ( ! TEST_DSR( bDSR, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, DONT_CARE ) ) {
                #if DVRH_BUS_RESET_ON_ERROR
                    BusReset(Controller + OFFSET_DCR);  // Pass in the dcr address
                #endif
                status = STATUS_LINK_FAILED;
            	DD((PCE)Pdx,DDT,"PptBecpRead: nAckReverse and XFlag are bad.\n");
            } else {
                //
                // Periph has correctly acknowledged that it has data (state valid)
                //
                if ( (TRUE == Pdx->P12843DL.bEventActive) ) {
                    //
                    // Signal transport (e.g., dot4) that data is avail
                    //
                    KeSetEvent(Pdx->P12843DL.Event, 0, FALSE);
                }
            }

        }
    }
    
    DD((PCE)Pdx,DDT,"PptBecpRead: exit - status %x - BytesTransferred[%d]\n", status, *BytesTransferred);

    return status;
}

NTSTATUS
PptEnterBecpMode(
    IN  PPDO_EXTENSION  Pdx,
    IN  BOOLEAN         DeviceIdRequest
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    BECP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - FALSE - driver only supports Device ID Query in NIBBLE mode

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    
    if( DeviceIdRequest ) {
        // driver error if we hit this assert
        PptAssert(FALSE == DeviceIdRequest);
        status = STATUS_INVALID_PARAMETER;
        goto targetExit;
    }

    if( SAFE_MODE == Pdx->ModeSafety ) {
        status = IeeeEnter1284Mode( Pdx, BECP_EXTENSIBILITY );
    } else {
        Pdx->Connected = TRUE;
    }
    
    if( STATUS_SUCCESS == status ) {
        status = ParEcpHwSetupPhase( Pdx );
        Pdx->bSynchWrites = TRUE;     // NOTE this is a temp hack!!!  dvrh
        if (!Pdx->bShadowBuffer) {
            Queue_Create(&(Pdx->ShadowBuffer), Pdx->FifoDepth * 2);	
            Pdx->bShadowBuffer = TRUE;
        }
        Pdx->IsIeeeTerminateOk = TRUE;
    }

targetExit:

    DD((PCE)Pdx,DDT,"PptEnterBecpMode - exit w/status %x\n", status);
    return status;
}

BOOLEAN
PptIsBecpSupported(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the write direction by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    NTSTATUS status;

    if( Pdx->BadProtocolModes & BOUNDED_ECP ) {
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - FAILED - BOUNDED_ECP in BadProtocolModes\n");
        return FALSE;
    }

    if( Pdx->ProtocolModesSupported & BOUNDED_ECP ) {
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - PASSED - BOUNDED_ECP already cheacked\n");
        return TRUE;
    }

    if( !(Pdx->HardwareCapabilities & PPT_ECP_PRESENT) ) {
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - FAILED - HWECP not avail\n");
        return FALSE;
    }

    if( 0 == Pdx->FifoWidth ) {
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - FAILED - 0 == FifoWidth\n");
        return FALSE;
    }
        
    // Must use BECP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    status = PptEnterBecpMode( Pdx, FALSE );
    PptTerminateBecpMode( Pdx );

    if( STATUS_SUCCESS == status ) {
        Pdx->ProtocolModesSupported |= BOUNDED_ECP;
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - PASSED\n");
        return TRUE;
    } else {
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - FAILED - BOUNDED_ECP negotiate failed\n");
        return FALSE;
    }
}

VOID
PptTerminateBecpMode(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    DD((PCE)Pdx,DDT,"PptTerminateBecpMode - Enter - CurrentPhase %x\n", Pdx->CurrentPhase);

    // Need to check current phase -- if its reverse, need to flip bus
    // If its not forward -- its an incorrect phase and termination will fail.
    switch (Pdx->CurrentPhase) {

    case  PHASE_FORWARD_IDLE:	// Legal state to terminate

        break;

    case PHASE_REVERSE_IDLE:	// Flip the bus so we can terminate

        {
            NTSTATUS status = ParEcpHwExitReversePhase( Pdx );
            if( STATUS_SUCCESS == status ) {
                status = ParEcpEnterForwardPhase(Pdx );
            } else {
                DD((PCE)Pdx,DDT,"PptTerminateBecpMode: Couldn't flip the bus\n");
            }
        }
        break;

    case  PHASE_FORWARD_XFER:
    case  PHASE_REVERSE_XFER:

        // Dunno what to do here.  We probably will confuse the peripheral.
        DD((PCE)Pdx,DDE,"PptTerminateBecpMode: invalid wCurrentPhase (XFer in progress)\n");
        break;

    case PHASE_TERMINATE:

        // Included PHASE_TERMINATE in the switch so we won't return
        //   an error if we are already terminated.  We are already
        //   terminated, nothing more to do.
        break;

    default:

        DD((PCE)Pdx,DDE,"PptTerminateBecpMode: invalid CurrentPhase %x\n", Pdx->CurrentPhase);
        // Dunno what to do here.  We're lost and don't have a map to figure out where we are!
        break;
        
    }

    ParEcpHwWaitForEmptyFIFO( Pdx );

    ParCleanupHwEcpPort( Pdx );

    if ( Pdx->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode( Pdx );
    } else {
        Pdx->Connected = FALSE;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\datalink.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    p12843dl.c

Abstract:

    This module contains utility code used by 1284.3 Data Link.

Author:

    Robbie Harris (Hewlett-Packard) 10-September-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

UCHAR Dot3_StartOfFrame1 = 0x55;  
UCHAR Dot3_StartOfFrame2 = 0xaa;  
UCHAR Dot3_EndOfFrame1 = 0x00; 
UCHAR Dot3_EndOfFrame2 = 0xff; 


NTSTATUS
ParDot3Connect(
    IN  PPDO_EXTENSION    Pdx
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ParFwdSkip = 0, ParRevSkip = 0;
    ULONG ParResetChannel = (ULONG)~0, ParResetByteCount = 4, ParResetByte = 0;
    ULONG ParSkipDefault = 0;
    ULONG ParResetChannelDefault = (ULONG)~0;

    // If an MLC device hangs we can sometimes wake it up by wacking it with 
    //   4 Zeros sent to the reset channel (typically 78 or 0x4E). Make this
    //   configurable via registry setting.
    ULONG ParResetByteCountDefault = 4; // from MLC spec
    ULONG ParResetByteDefault      = 0; // from MLC spec

    BOOLEAN bConsiderEppDangerous = FALSE;

    DD((PCE)Pdx,DDT,"ParDot3Connect: enter\n");

    if (P12843DL_OFF == Pdx->P12843DL.DataLinkMode) {
        DD((PCE)Pdx,DDT,"ParDot3Connect: Neither Dot3 or MLC are supported - FAIL request\n");
        return STATUS_UNSUCCESSFUL;
    }

    if (Pdx->P12843DL.bEventActive) {
        DD((PCE)Pdx,DDT,"ParDot3Connect: Already connected - FAIL request\n");
        return STATUS_UNSUCCESSFUL;
    }

    // Let's get a Device Id so we can pull settings for this device
    ParTerminate(Pdx);

    {   // local block

        PCHAR                     buffer                    = NULL;
        ULONG                     bufferLength;
        UCHAR                     resultString[MAX_ID_SIZE];
        ANSI_STRING               AnsiIdString;
        UNICODE_STRING            UnicodeTemp;
        RTL_QUERY_REGISTRY_TABLE  paramTable[6];
        UNICODE_STRING            Dot3Key;
        USHORT                    Dot3NameSize;
        NTSTATUS                  status;

        RtlZeroMemory(resultString, MAX_ID_SIZE);
        // ask the device how large of a buffer is needed to hold it's raw device id
        if ( Pdx->Ieee1284Flags & ( 1 << Pdx->Ieee1284_3DeviceId ) ) {
            buffer = Par3QueryDeviceId(Pdx, NULL, 0, &bufferLength, FALSE, TRUE);
        } else{
            buffer = Par3QueryDeviceId(Pdx, NULL, 0, &bufferLength, FALSE, FALSE);
        }
        if( !buffer ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - Couldn't alloc pool for DevId - FAIL request\n");
            return STATUS_UNSUCCESSFUL;
        }

        DD((PCE)Pdx,DDT,"ParDot3Connect - 1284 ID string = <%s>\n",buffer);

        // extract the part of the ID that we want from the raw string 
        //   returned by the hardware
        Status = ParPnpGetId( buffer, BusQueryDeviceID, (PCHAR)resultString, NULL );
        StringSubst( (PCHAR)resultString, ' ', '_', (USHORT)strlen((const PCHAR)resultString) );

        DD((PCE)Pdx,DDT,"ParDot3Connect: resultString Post StringSubst = <%s>\n",resultString);

        // were we able to extract the info that we want from the raw ID string?
        if( !NT_SUCCESS(Status) ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - Call to ParPnpGetId Failed - FAIL request\n");
            if( buffer ) {
                ExFreePool( buffer );
            }
            return STATUS_UNSUCCESSFUL;
        }

        // Does the ID that we just retrieved from the device match the one 
        //   that we previously saved in the device extension?
        if(0 != strcmp( (const PCHAR)Pdx->DeviceIdString, (const PCHAR)resultString)) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - strcmp shows NO MATCH\n");
            // DVDF - we may want to trigger a reenumeration since we know that the device changed
        }

        // Ok, now we have what we need to look in the registry
        // and pull some prefs.
        RtlZeroMemory(&paramTable[0], sizeof(paramTable));
        paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name          = (PWSTR)L"ParFwdSkip";
        paramTable[0].EntryContext  = &ParFwdSkip;
        paramTable[0].DefaultType   = REG_DWORD;
        paramTable[0].DefaultData   = &ParSkipDefault;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name          = (PWSTR)L"ParRevSkip";
        paramTable[1].EntryContext  = &ParRevSkip;
        paramTable[1].DefaultType   = REG_DWORD;
        paramTable[1].DefaultData   = &ParSkipDefault;
        paramTable[1].DefaultLength = sizeof(ULONG);

        paramTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[2].Name          = (PWSTR)L"ParRC";
        paramTable[2].EntryContext  = &ParResetChannel;
        paramTable[2].DefaultType   = REG_DWORD;
        paramTable[2].DefaultData   = &ParResetChannelDefault;
        paramTable[2].DefaultLength = sizeof(ULONG);

        paramTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[3].Name          = (PWSTR)L"ParRBC";
        paramTable[3].EntryContext  = &ParResetByteCount;
        paramTable[3].DefaultType   = REG_DWORD;
        paramTable[3].DefaultData   = &ParResetByteCountDefault;
        paramTable[3].DefaultLength = sizeof(ULONG);

        paramTable[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[4].Name          = (PWSTR)L"ParRBD";
        paramTable[4].EntryContext  = &ParResetByte;
        paramTable[4].DefaultType   = REG_DWORD;
        paramTable[4].DefaultData   = &ParResetByteDefault;
        paramTable[4].DefaultLength = sizeof(ULONG);

        Dot3Key.Buffer = NULL;
        Dot3Key.Length = 0;
        Dot3NameSize = sizeof(L"Dot3\\") + sizeof(UNICODE_NULL);
        Dot3Key.MaximumLength = (USHORT)( Dot3NameSize + (MAX_ID_SIZE * sizeof(WCHAR)) );
        Dot3Key.Buffer = ExAllocatePool(PagedPool,
                                            Dot3Key.MaximumLength);
        if( !Dot3Key.Buffer ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - ExAllocatePool for Registry Check failed - FAIL request\n");
            if( buffer ) {
                ExFreePool( buffer );
            }
            return STATUS_UNSUCCESSFUL;
        }

        DD((PCE)Pdx,DDT,"ParDot3Connect: ready to Zero buffer, &Dot3Key= %x , MaximumLength=%d\n",&Dot3Key, Dot3Key.MaximumLength);
        RtlZeroMemory(Dot3Key.Buffer, Dot3Key.MaximumLength);

        status = RtlAppendUnicodeToString(&Dot3Key, (PWSTR)L"Dot3\\");
        ASSERT( NT_SUCCESS(status) );

        DD((PCE)Pdx,DDT,"ParDot3Connect:\"UNICODE\" Dot3Key S  = <%S>\n",Dot3Key.Buffer);
        DD((PCE)Pdx,DDT,"ParDot3Connect:\"UNICODE\" Dot3Key wZ = <%wZ>\n",&Dot3Key);
        DD((PCE)Pdx,DDT,"ParDot3Connect:\"RAW\" resultString string = <%s>\n",resultString);

        RtlInitAnsiString(&AnsiIdString,(const PCHAR)resultString);

        status = RtlAnsiStringToUnicodeString(&UnicodeTemp,&AnsiIdString,TRUE);
        if( NT_SUCCESS( status ) ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect:\"UNICODE\" UnicodeTemp = <%S>\n",UnicodeTemp.Buffer);

            Dot3Key.Buffer[(Dot3NameSize / sizeof(WCHAR)) - 1] = UNICODE_NULL;
            DD((PCE)Pdx,DDT,"ParDot3Connect:\"UNICODE\" Dot3Key (preappend)  = <%S>\n",Dot3Key.Buffer);

            status = RtlAppendUnicodeStringToString(&Dot3Key, &UnicodeTemp);
            if( NT_SUCCESS( status ) ) {
                DD((PCE)Pdx,DDT,"ParDot3Connect: ready to call RtlQuery...\n");
                Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL, Dot3Key.Buffer, &paramTable[0], NULL, NULL);
                DD((PCE)Pdx,DDT,"ParDot3Connect: RtlQueryRegistryValues Status = %x\n",Status);
            }
            
            RtlFreeUnicodeString(&UnicodeTemp);
        }

        if( Dot3Key.Buffer ) {
            ExFreePool (Dot3Key.Buffer);
        }

        // no longer needed
        ExFreePool(buffer);
        if (!NT_SUCCESS(Status)) {
            // registry read failed
            DD((PCE)Pdx,DDT,"ParDot3Connect: No Periph Defaults in Registry\n");
            DD((PCE)Pdx,DDT,"ParDot3Connect: No Periph Defaults in Registry\n");
            // registry read failed, use defaults and consider EPP to be dangerous
            ParRevSkip = ParFwdSkip = ParSkipDefault;
            bConsiderEppDangerous = TRUE; 
        }

        DD((PCE)Pdx,DDT,"ParDot3Connect: pre IeeeNegotiateBestMode\n");
        // if we don't have registry overrides then use what the
        // peripheral told us otherwise stick with defaults.
        if (ParSkipDefault == ParRevSkip) {
            ParRevSkip = Pdx->P12843DL.RevSkipMask;
        } else {
            Pdx->P12843DL.RevSkipMask = (USHORT)ParRevSkip;
        }

        if (ParSkipDefault == ParFwdSkip) {
            ParFwdSkip = Pdx->P12843DL.FwdSkipMask;
        } else {
            Pdx->P12843DL.FwdSkipMask = (USHORT)ParFwdSkip;
        }

        if( bConsiderEppDangerous ) {
            ParFwdSkip |= EPP_ANY;
            ParRevSkip |= EPP_ANY;
        }

        Status = IeeeNegotiateBestMode(Pdx, (USHORT)ParRevSkip, (USHORT)ParFwdSkip);
        if( !NT_SUCCESS(Status) ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - Peripheral Negotiation Failed - FAIL dataLink connect\n");
            return Status;
        }

        Pdx->ForwardInterfaceAddress = Pdx->P12843DL.DataChannel;
        if (Pdx->P12843DL.DataLinkMode == P12843DL_MLC_DL) {
            if (ParResetChannel != ParResetChannelDefault) {
                Pdx->P12843DL.ResetByte  = (UCHAR) ParResetByte & 0xff;
                Pdx->P12843DL.ResetByteCount = (UCHAR) ParResetByteCount & 0xff;
                if (ParResetChannel == PAR_COMPATIBILITY_RESET) {
                    Pdx->P12843DL.fnReset = ParMLCCompatReset;
                } else {
                    // Max ECP channel is 127 so let's mask off bogus bits.
                    Pdx->P12843DL.ResetChannel = (UCHAR) ParResetChannel & 0x7f;
                    Pdx->P12843DL.fnReset = ParMLCECPReset;
                }
            }
        }

        if (Pdx->P12843DL.fnReset) {
            DD((PCE)Pdx,DDT,"ParDot3Connect: MLCReset is supported on %x\n",Pdx->P12843DL.ResetChannel);
            Status = ((PDOT3_RESET_ROUTINE) (Pdx->P12843DL.fnReset))(Pdx);
        } else {
            DD((PCE)Pdx,DDT,"ParDot3Connect - MLCReset is not supported\n");
            Status = ParSetFwdAddress(Pdx);
        }
        if( !NT_SUCCESS(Status) ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - Couldn't Set Address - FAIL request\n");
            return Status;
        }

        // Check to make sure we are ECP, BECP, or EPP
        DD((PCE)Pdx,DDT,"ParDot3Connect: pre check of ECP, BECP, EPP\n");

        if (afpForward[Pdx->IdxForwardProtocol].ProtocolFamily != FAMILY_BECP &&
            afpForward[Pdx->IdxForwardProtocol].ProtocolFamily != FAMILY_ECP &&
            afpForward[Pdx->IdxForwardProtocol].ProtocolFamily != FAMILY_EPP) {

            DD((PCE)Pdx,DDT,"ParDot3Connect - We did not reach ECP or EPP - FAIL request\n");
            return STATUS_UNSUCCESSFUL;
        }

    } // end local block

    if (Pdx->P12843DL.DataLinkMode == P12843DL_DOT3_DL) {
        DD((PCE)Pdx,DDT,"ParDot3Connect - P12843DL_DOT3_DL\n");
        Pdx->P12843DL.fnRead  = arpReverse[Pdx->IdxReverseProtocol].fnRead;
        Pdx->P12843DL.fnWrite = afpForward[Pdx->IdxForwardProtocol].fnWrite;
        Pdx->fnRead           = ParDot3Read;
        Pdx->fnWrite          = ParDot3Write;
    }

    DD((PCE)Pdx,DDT,"ParDot3Connect - Exit with status %x\n",Status);

    return Status;
}

VOID
ParDot3CreateObject(
    IN  PPDO_EXTENSION   Pdx,
    IN PCHAR DOT3DL,
    IN PCHAR DOT3C
    )
{
    Pdx->P12843DL.DataLinkMode = P12843DL_OFF;
    Pdx->P12843DL.fnReset = NULL;
    DD((PCE)Pdx,DDT,"ParDot3CreateObject - DOT3DL [%s] DOT3C\n",DOT3DL, DOT3C);
    if (DOT3DL) {
        ULONG   dataChannel;
        ULONG   pid = 0x285; // pid for dot4

        // Only use the first channel.
        if( !String2Num(&DOT3DL, ',', &dataChannel) ) {
            dataChannel = 77;
            DD((PCE)Pdx,DDT,"ParDot3CreateObject - No DataChannel Defined\n");
        }
        if( DOT3C ) {
            if (!String2Num(&DOT3C, ',', &pid)) {
                pid = 0x285;
                DD((PCE)Pdx,DDT,"ParDot3CreateObject - No CurrentPID Defined\n");
            }
            DD((PCE)Pdx,DDT,"ParDot3CreateObject - .3 mode is ON\n");
        }
        Pdx->P12843DL.DataChannel = (UCHAR)dataChannel;
        Pdx->P12843DL.CurrentPID = (USHORT)pid;
        Pdx->P12843DL.DataLinkMode = P12843DL_DOT3_DL;
        DD((PCE)Pdx,DDT,"ParDot3CreateObject - Data [%x] CurrentPID [%x]\n",Pdx->P12843DL.DataChannel, Pdx->P12843DL.CurrentPID);
    }
    if (Pdx->P12843DL.DataLinkMode == P12843DL_OFF) {
        DD((PCE)Pdx,DDT,"ParDot3CreateObject - DANGER: .3 mode is OFF\n");
    }
}

VOID
ParDot4CreateObject(
    IN  PPDO_EXTENSION   Pdx,
    IN  PCHAR DOT4DL
    )
{
    Pdx->P12843DL.DataLinkMode = P12843DL_OFF;
    Pdx->P12843DL.fnReset = NULL;
    DD((PCE)Pdx,DDT,"ParDot3CreateObject: DOT4DL [%s]\n",DOT4DL);
    if (DOT4DL) {
        UCHAR numValues = StringCountValues( (PCHAR)DOT4DL, ',' );
        ULONG dataChannel, resetChannel, ResetByteCount;
        
        DD((PCE)Pdx,DDT,"ParDot3CreateObject: numValues [%d]\n",numValues);
        if (!String2Num(&DOT4DL, ',', &dataChannel)) {
            dataChannel = 77;
            DD((PCE)Pdx,DDT,"ParDot4CreateObject: No DataChannel Defined.\r\n");
        }

        if ((String2Num(&DOT4DL, ',', &resetChannel)) && (numValues > 1)) {

            if (resetChannel == -1) {
                Pdx->P12843DL.fnReset = ParMLCCompatReset;
            } else {
                Pdx->P12843DL.fnReset = ParMLCECPReset;
            }
            DD((PCE)Pdx,DDT,"ParDot4CreateObject: ResetChannel Defined.\r\n");

        } else {
            Pdx->P12843DL.fnReset = NULL;
            DD((PCE)Pdx,DDT,"ParDot4CreateObject: No ResetChannel Defined.\r\n");
        }

        if ((!String2Num(&DOT4DL, 0, &ResetByteCount)) && (numValues > 2)) {
            ResetByteCount = 4;
            DD((PCE)Pdx,DDT,"ParDot4CreateObject: No ResetByteCount Defined.\r\n");
        }

        Pdx->P12843DL.DataChannel = (UCHAR)dataChannel;
        Pdx->P12843DL.ResetChannel = (UCHAR)resetChannel;
        Pdx->P12843DL.ResetByteCount = (UCHAR)ResetByteCount;
        Pdx->P12843DL.DataLinkMode = P12843DL_DOT4_DL;
        DD((PCE)Pdx,DDT,"ParDot4CreateObject: .4DL mode is ON.\r\n");
        DD((PCE)Pdx,DDT,"ParDot4CreateObject: Data [%x] Reset [%x] Bytes [%x]\r\n",
                Pdx->P12843DL.DataChannel,
                Pdx->P12843DL.ResetChannel,
                Pdx->P12843DL.ResetByteCount);
    }
#if DBG
    if (Pdx->P12843DL.DataLinkMode == P12843DL_OFF) {
        DD((PCE)Pdx,DDT,"ParDot4CreateObject: DANGER: .4DL mode is OFF.\r\n");
    }
#endif
}


VOID
ParMLCCreateObject(
    IN  PPDO_EXTENSION   Pdx,
    IN PCHAR CMDField
    )
{
    Pdx->P12843DL.DataLinkMode = P12843DL_OFF;
    Pdx->P12843DL.fnReset = NULL;
    if (CMDField)
    {
        Pdx->P12843DL.DataChannel = 77;

        Pdx->P12843DL.DataLinkMode = P12843DL_MLC_DL;
        DD((PCE)Pdx,DDT,"ParMLCCreateObject: MLC mode is on.\r\n");
    }
#if DBG
    if (Pdx->P12843DL.DataLinkMode == P12843DL_OFF)
    {
        DD((PCE)Pdx,DDT,"ParMLCCreateObject: DANGER: MLC mode is OFF.\r\n");
    }
#endif
}

VOID
ParDot3DestroyObject(
    IN  PPDO_EXTENSION   Pdx
    )
{
    Pdx->P12843DL.DataLinkMode = P12843DL_OFF;
}

NTSTATUS
ParDot3Disconnect(
    IN  PPDO_EXTENSION   Pdx
    )
{
    if (Pdx->P12843DL.DataLinkMode == P12843DL_DOT3_DL) {
        Pdx->fnRead = arpReverse[Pdx->IdxReverseProtocol].fnRead;
        Pdx->fnWrite = afpForward[Pdx->IdxForwardProtocol].fnWrite;
    }

    Pdx->P12843DL.bEventActive = FALSE;
    Pdx->P12843DL.Event        = 0;

    return STATUS_SUCCESS;
}

VOID
ParDot3ParseModes(
    IN  PPDO_EXTENSION   Pdx,
    IN  PCHAR DOT3M
    )
{
    ULONG   fwd = 0;
    ULONG   rev = 0;
    DD((PCE)Pdx,DDT,"ParDot3ParseModes: DOT3M [%s]\n",DOT3M);
    if (DOT3M) {
        UCHAR numValues = StringCountValues((PCHAR)DOT3M, ',');

        if (numValues != 2) {
            // The periph gave me bad values. I'm not gonna read
            // them. I will set the defaults to the lowest
            // common denominator.
            DD((PCE)Pdx,DDT,"ParDot3ParseModes: Malformed 1284.3M field.\r\n");
            Pdx->P12843DL.FwdSkipMask = (USHORT) PAR_FWD_MODE_SKIP_MASK;
            Pdx->P12843DL.RevSkipMask = (USHORT) PAR_REV_MODE_SKIP_MASK;
            return;
        }
        
        // Only use the first channel.
        if (!String2Num(&DOT3M, ',', &fwd)) {
            fwd = (USHORT) PAR_FWD_MODE_SKIP_MASK;
            DD((PCE)Pdx,DDT,"ParDot3ParseModes: Couldn't read fwd of 1284.3M.\r\n");
        }
        if (!String2Num(&DOT3M, ',', &rev)) {
            rev = (USHORT) PAR_REV_MODE_SKIP_MASK;
            DD((PCE)Pdx,DDT,"ParDot3ParseModes: Couldn't read rev of 1284.3M.\r\n");
        }
    }
    Pdx->P12843DL.FwdSkipMask = (USHORT) fwd;
    Pdx->P12843DL.RevSkipMask = (USHORT) rev;
}

NTSTATUS
ParDot3Read(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
{
    NTSTATUS Status;
    UCHAR ucScrap1;
    UCHAR ucScrap2[2];
    USHORT usScrap1;
    ULONG bytesToRead;
    ULONG bytesTransferred;
    USHORT Dot3CheckSum;
    USHORT Dot3DataLen;

    // ================================== Read the first byte of SOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the first byte of SOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_StartOfFrame1)
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the second byte of SOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the second byte of SOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_StartOfFrame2)
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }
    
    // ================================== Read the PID (Should be in Big Endian)
    bytesToRead = 2;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &usScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the PID
    if (!NT_SUCCESS(Status) || usScrap1 != Pdx->P12843DL.CurrentPID)
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the DataLen
    bytesToRead = 2;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap2[0], bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    Dot3DataLen = (USHORT)((USHORT)(ucScrap2[0]<<8 | ucScrap2[1]));
    // ================================== Check the DataLen
    if (!NT_SUCCESS(Status))
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the Checksum
    bytesToRead = 2;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap2[0], bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    Dot3CheckSum = (USHORT)(ucScrap2[0]<<8 | ucScrap2[1]);
    // ================================== Check the DataLen
    if (!NT_SUCCESS(Status))
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }

    Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, Buffer, BufferSize, BytesTransferred);

    if (!NT_SUCCESS(Status))
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Data Read Failed.  We're Hosed!\n");
        return(Status);
    }

    // LengthOfData field from the Frame header is really the number of bytes of ClientData - 1
    if ( ((ULONG)Dot3DataLen + 1) > BufferSize)
    {
        // buffer overflow - abort operation
        DD((PCE)Pdx,DDE,"ParDot3Read: Bad 1284.3DL Data Len. Buffer overflow.  We're Hosed!\n");
        return  STATUS_BUFFER_OVERFLOW;
    }

    // Check Checksum
    {
        USHORT  pid = Pdx->P12843DL.CurrentPID;
        USHORT  checkSum;

        // 2's complement sum in 32 bit accumulator
        ULONG   sum = pid + Dot3DataLen + Dot3CheckSum;

        // fold 32 bit sum into 16 bits
        while( sum >> 16 ) {
            sum = (sum & 0xffff) + (sum >> 16);
        }

        // take 1's complement of folded sum - this should be Zero if there were no errors
        checkSum = (USHORT)(0xffff & ~sum);

        if( checkSum != 0 ) {
            DD((PCE)Pdx,DDE,"ParDot3Read: Bad 1284.3DL Checksum.  We're Hosed!\n");
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
    }


    // ================================== Read the first byte of EOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the first byte of EOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_EndOfFrame1)
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the second byte of EOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the second byte of EOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_EndOfFrame2)
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }
    return Status;
}

NTSTATUS
ParDot3Write(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
{
    NTSTATUS    Status;
    ULONG       frameBytesTransferred;
    ULONG       bytesToWrite;
    USHORT      scrap1;
    USHORT      scrap2;
    USHORT      scrapHigh;
    USHORT      scrapLow;
    PUCHAR      p;

    // valid range for data payload per Frame is 1..64K
    if( (BufferSize < 1) || (BufferSize > 64*1024) ) {
        return STATUS_INVALID_PARAMETER;
    };

    // =========================  Write out first Byte of SOF
    bytesToWrite = 1;
    frameBytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &Dot3_StartOfFrame1, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check first Byte of SOF
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out second Byte of SOF
    bytesToWrite = 1;
    frameBytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &Dot3_StartOfFrame2, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check second Byte of SOF
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out PID (which should be in Big Endian already)
    bytesToWrite = 2;
    frameBytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &Pdx->P12843DL.CurrentPID, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check PID
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out Length of Data
    bytesToWrite = 2;
    frameBytesTransferred = 0;
    scrap1 = (USHORT) (BufferSize - 1);
    scrapLow = (UCHAR) (scrap1 & 0xff);
    scrapHigh = (UCHAR) (scrap1 >> 8);
    p = (PUCHAR)&scrap2;
    *p++ = (UCHAR)scrapHigh;
    *p = (UCHAR)scrapLow;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &scrap2, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check Length of Data
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out Checksum
    bytesToWrite = 2;
    frameBytesTransferred = 0;

    {
        USHORT  pid                = Pdx->P12843DL.CurrentPID;
        USHORT  dataLengthMinusOne = (USHORT)(BufferSize - 1);
        USHORT  checkSum;

        // 2's complement sum in 32 bit accumulator
        ULONG   sum = pid + dataLengthMinusOne;

        // fold 32 bit sum into 16 bits
        while( sum >> 16 ) {
            sum = (sum & 0xffff) + (sum >> 16);
        }

        // final checksum is 1's complement of folded sum
        checkSum = (USHORT)(0xffff & ~sum);
        scrap1 = checkSum;
    }

    // send checksum big-endian
    scrapLow  = (UCHAR)(scrap1 & 0xff);
    scrapHigh = (UCHAR)(scrap1 >> 8);
    p         = (PUCHAR)&scrap2;
    *p++      = (UCHAR)scrapHigh;
    *p        = (UCHAR)scrapLow;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &scrap2, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check Checksum
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, Buffer, BufferSize, BytesTransferred);
    if (NT_SUCCESS(Status))
    {
        // =========================  Write out first Byte of EOF
        bytesToWrite = 1;
        frameBytesTransferred = 0;
        do
        {
            Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &Dot3_EndOfFrame1, bytesToWrite, &frameBytesTransferred);
        }
        while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

        // =========================  Check first Byte of EOF
        if (!NT_SUCCESS(Status))
        {
            *BytesTransferred = 0;
            return(Status);
        }

        // =========================  Write out second Byte of EOF
        bytesToWrite = 1;
        frameBytesTransferred = 0;
        do
        {
            Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &Dot3_EndOfFrame2, bytesToWrite, &frameBytesTransferred);
        }
        while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

        // =========================  Check second Byte of EOF
        if (!NT_SUCCESS(Status))
        {
            *BytesTransferred = 0;
            return(Status);
        }
    }
    return Status;
}

NTSTATUS
ParMLCCompatReset(
    IN  PPDO_EXTENSION   Pdx
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR Reset[256];       // Reset should not require more than 256 chars
    const ULONG ResetLen = Pdx->P12843DL.ResetByteCount;
    ULONG BytesWritten; 

    DD((PCE)Pdx,DDT,"ParMLCCompatReset: Start\n");
    if (Pdx->P12843DL.DataLinkMode != P12843DL_MLC_DL &&
        Pdx->P12843DL.DataLinkMode != P12843DL_DOT4_DL)
    {
        DD((PCE)Pdx,DDT,"ParMLCCompatReset: not MLC.\n");
        return STATUS_SUCCESS;
    }

    ParTerminate(Pdx);
    // Sending  NULLs for reset
    DD((PCE)Pdx,DDT,"ParMLCCompatReset: Zeroing Reset Bytes.\n");
    RtlFillMemory(Reset, ResetLen, Pdx->P12843DL.ResetByte);

    DD((PCE)Pdx,DDT,"ParMLCCompatReset: Sending Reset Bytes.\n");
    // Don't use the Dot3Write since we are in MLC Mode.
    Status = SppWrite(Pdx, Reset, ResetLen, &BytesWritten);
    if (!NT_SUCCESS(Status) || BytesWritten != ResetLen)
    {
        DD((PCE)Pdx,DDE,"ParMLCCompatReset: FAIL. Write Failed\n");
        return Status;
    }

    DD((PCE)Pdx,DDT,"ParMLCCompatReset: Reset Bytes were sent.\n");
    return Status;
}

NTSTATUS
ParMLCECPReset(
    IN  PPDO_EXTENSION   Pdx
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR Reset[256];       // Reset should not require more than 256 chars
    const ULONG ResetLen = Pdx->P12843DL.ResetByteCount;
    ULONG BytesWritten; 

    DD((PCE)Pdx,DDT,"ParMLCECPReset: Start\n");
    if (Pdx->P12843DL.DataLinkMode != P12843DL_MLC_DL &&
        Pdx->P12843DL.DataLinkMode != P12843DL_DOT4_DL)
    {
        DD((PCE)Pdx,DDT,"ParMLCECPReset: not MLC.\n");
        return STATUS_SUCCESS;
    }

    Status = ParReverseToForward(Pdx);
    Pdx->ForwardInterfaceAddress = Pdx->P12843DL.ResetChannel;
    Status = ParSetFwdAddress(Pdx);
    if (!NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDE,"ParMLCECPReset: FAIL. Couldn't Set Reset Channel\n");
        return Status;
    }

    // Sending  NULLs for reset
    DD((PCE)Pdx,DDT,"ParMLCECPReset: Zeroing Reset Bytes.\n");
    RtlFillMemory(Reset, ResetLen, Pdx->P12843DL.ResetByte);
    DD((PCE)Pdx,DDT,"ParMLCECPReset: Sending Reset Bytes.\n");
    // Don't use the Dot3Write since we are in MLC Mode.
    Status = afpForward[Pdx->IdxForwardProtocol].fnWrite(Pdx, Reset, ResetLen, &BytesWritten);
    if (!NT_SUCCESS(Status) || BytesWritten != ResetLen) {
        DD((PCE)Pdx,DDE,"ParMLCECPReset: FAIL. Write Failed\n");
        return Status;
    }

    DD((PCE)Pdx,DDT,"ParMLCECPReset: Reset Bytes were sent.\n");
    Pdx->ForwardInterfaceAddress = Pdx->P12843DL.DataChannel;
    Status = ParSetFwdAddress(Pdx);
    if (!NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDE,"ParMLCECPReset: FAIL. Couldn't Set Data Channel\n");
        return Status;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\dispatchredirect.c ===
//
// dispatch.c - Entry points for those Dispatch Routines where the 
//                FDO and the PDOs have distinct handlers.
// 
//            - Redirect calls based on the type of device object
//
#include "pch.h"


NTSTATUS
PptFdoRead(
    IN PDEVICE_OBJECT  Fdo,
    IN PIRP            Irp
    )
{
    UNREFERENCED_PARAMETER( Fdo );
    PptAssert(!"IRP_MJ_READ not supported on FDO");
    return P4CompleteRequest( Irp, STATUS_NOT_SUPPORTED, Irp->IoStatus.Information );
}

NTSTATUS
PptFdoWrite( 
    IN PDEVICE_OBJECT  Fdo,
    IN PIRP            Irp
    )
{
    UNREFERENCED_PARAMETER( Fdo );
    PptAssert(!"IRP_MJ_WRITE not supported on FDO");
    return P4CompleteRequest( Irp, STATUS_NOT_SUPPORTED, Irp->IoStatus.Information );
}

NTSTATUS
PptFdoDeviceControl(
    IN PDEVICE_OBJECT  Fdo,
    IN PIRP            Irp
    )
{
    UNREFERENCED_PARAMETER( Fdo );
    PptAssert(!"IRP_MJ_DEVICE_CONTROL not supported on FDO");
    return P4CompleteRequest( Irp, STATUS_NOT_SUPPORTED, Irp->IoStatus.Information );
}

NTSTATUS PptFdoQueryInformation(PDEVICE_OBJECT Fdo, PIRP Irp)
{
    UNREFERENCED_PARAMETER( Fdo );
    PptAssert(!"IRP_MJ_QUERY_INFORMATION not supported on FDO");
    return P4CompleteRequest( Irp, STATUS_NOT_SUPPORTED, Irp->IoStatus.Information );
}

NTSTATUS PptFdoSetInformation(PDEVICE_OBJECT Fdo, PIRP Irp)
{
    UNREFERENCED_PARAMETER( Fdo );
    PptAssert(!"IRP_MJ_SET_INFORMATION not supported on FDO");
    return P4CompleteRequest( Irp, STATUS_NOT_SUPPORTED, Irp->IoStatus.Information );
}

NTSTATUS PptPdoSystemControl(PDEVICE_OBJECT Pdo, PIRP Irp) {
    PPDO_EXTENSION      pdx    = Pdo->DeviceExtension;
    DD((PCE)pdx,DDT,"PptPdoSystemControl - stub function - %s\n", pdx->Location);
    return P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
}

NTSTATUS 
PptFdoUnhandledRequest(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
    // Unhandled IRP - just pass it down the stack
{
    PFDO_EXTENSION  devExt = DevObj->DeviceExtension;
    NTSTATUS        status = PptAcquireRemoveLock( &devExt->RemoveLock, Irp );

    if( STATUS_SUCCESS == status ) {
        // RemoveLock acquired, forward request to device object below us
        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( devExt->ParentDeviceObject, Irp );
        PptReleaseRemoveLock( &devExt->RemoveLock, Irp );
    } else {
        // unable to acquire RemoveLock - FAIL request
        Irp->IoStatus.Status = status;
        P4CompleteRequest( Irp, status, Irp->IoStatus.Information );
    }

    return status;
}

NTSTATUS 
PptPdoUnhandledRequest(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
    // Unhandled IRP - extract status from Irp and complete request
{
    NTSTATUS  status = Irp->IoStatus.Status;
    UNREFERENCED_PARAMETER( DevObj );
    P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
    return status;
}

NTSTATUS
PptDispatchPnp( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoPnp( DevObj, Irp );
    } else {
        return PptPdoPnp( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchPower( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoPower( DevObj, Irp );
    } else {
        return PptPdoPower( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchCreateOpen( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoCreateOpen( DevObj, Irp );
    } else {
        return PptPdoCreateOpen( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchClose( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoClose( DevObj, Irp );
    } else {
        return PptPdoClose( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchCleanup( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoCleanup( DevObj, Irp );
    } else {
        return PptPdoCleanup( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchRead( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoRead( DevObj, Irp );
    } else {
        return PptPdoReadWrite( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchWrite( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoWrite( DevObj, Irp );
    } else {
        return PptPdoReadWrite( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoDeviceControl( DevObj, Irp );
    } else {
        return ParDeviceControl( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchInternalDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoInternalDeviceControl( DevObj, Irp );
    } else {
        return ParInternalDeviceControl( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchQueryInformation( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoQueryInformation( DevObj, Irp );
    } else {
        return PptPdoQueryInformation( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchSetInformation( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoSetInformation( DevObj, Irp );
    } else {
        return PptPdoSetInformation( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchSystemControl( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoSystemControl( DevObj, Irp );
    } else {
        return PptPdoSystemControl( DevObj, Irp );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File: debug.h
//
//--------------------------------------------------------------------------

#ifndef _DEBUG_H_
#define _DEBUG_H_

//
// Debug Defines and Macros
//   

extern ULONG d1;
extern ULONG d2;
extern ULONG d3;
extern ULONG d4;
extern ULONG d5;
extern ULONG d6;
extern ULONG d7;
extern ULONG d8;
extern ULONG d9;

extern ULONG Trace;
extern ULONG Break;

extern ULONG AllowAsserts;

//
// set bits using DD_* bit defs to mask off debug spew for a specific device
//
extern ULONG DbgMaskFdo;
extern ULONG DbgMaskRawPort;
extern ULONG DbgMaskDaisyChain0;
extern ULONG DbgMaskDaisyChain1;
extern ULONG DbgMaskEndOfChain;
extern ULONG DbgMaskLegacyZip;
extern ULONG DbgMaskNoDevice;

#define PptAssert(_expr_) if( AllowAsserts ) ASSERT((_expr_))
#define PptAssertMsg(_msg_,_expr_) if( AllowAsserts ) ASSERTMSG((_msg_),(_expr_))

#define ASSERT_EVENT(E) {                             \
    ASSERT((E)->Header.Type == NotificationEvent ||   \
           (E)->Header.Type == SynchronizationEvent); \
}

//
// Break bit definitions:
//
#define PPT_BREAK_ON_DRIVER_ENTRY 0x00000001

#define PptBreakOnRequest( BREAK_CONDITION, STRING) \
                if( Break & (BREAK_CONDITION) ) { \
                    DbgPrint STRING; \
                    DbgBreakPoint(); \
                }

// driver logic analyzer - show data bytes xfer'd in NIBBLE and/or BECP/HWECP modes
// 1 == ON
// 0 == OFF
#define DBG_SHOW_BYTES 0
#if 1 == DBG_SHOW_BYTES
extern ULONG DbgShowBytes;
#endif

#if DBG
#define PptEnableDebugSpew 1
#else
#define PptEnableDebugSpew 0
#endif

#if 1 == PptEnableDebugSpew
#define DD PptPrint
#else
#define DD
#define P5ReadPortUchar( _PORT_ ) READ_PORT_UCHAR( (_PORT_) )
#define P5ReadPortBufferUchar( _PORT_, _BUFFER_, _COUNT_ ) READ_PORT_BUFFER_UCHAR( (_PORT_), (_BUFFER_), (_COUNT_) )
#define P5WritePortUchar( _PORT_, _VALUE_ ) WRITE_PORT_UCHAR( (_PORT_), (_VALUE_) )
#define P5WritePortBufferUchar( _PORT_, _BUFFER_, _COUNT_ ) WRITE_PORT_BUFFER_UCHAR( (_PORT_), (_BUFFER_), (_COUNT_) )
#define PptFdoDumpPnpIrpInfo( _FDO_, _IRP_ ) 
#define PptPdoDumpPnpIrpInfo( _PDO_, _IRP_ )
#define P5TraceIrpArrival( _DEVOBJ_, _IRP_ )
#define P5TraceIrpCompletion( _IRP_ )
#define PptAcquireRemoveLock( _REMOVELOCK_, _TAG_ ) IoAcquireRemoveLock( (_REMOVELOCK_), (_TAG_) )
#define PptReleaseRemoveLock( _REMOVELOCK_, _TAG_ ) IoReleaseRemoveLock( (_REMOVELOCK_), (_TAG_) )
#define PptReleaseRemoveLockAndWait( _REMOVELOCK_, _TAG_ ) IoReleaseRemoveLockAndWait( (_REMOVELOCK_), (_TAG_) )
#define P5SetPhase( _PDX_, _PHASE_ ) (_PDX_)->CurrentPhase = (_PHASE_)
#define P5BSetPhase( _IEEESTATE_, _PHASE_ ) (_IEEESTATE_)->CurrentPhase = (_PHASE_)
#endif

VOID
PptPrint( PCOMMON_EXTENSION Ext, ULONG Flags, PCHAR FmtStr, ... );

//
// Trace bit definitions:
//
#define DDE     0x00000001 // Error messages
#define DDW     0x00000002 // Warning messages
#define DDT     0x00000004 // program Trace messages
#define DDINFO  0x00000008 // Informational messages

#define DDP     0x00000010 // Pnp and Power messages
#define DDC     0x00000020 // daisy Chain messages - select/deselect
#define DDA     0x00000040 // port Arbitration messages - acquire/release of port
#define DDR     0x00000080 // Registry access

#define DD_SEL  0x01000000 // Acquire/Release port & DaisyChain Select/Deselect device
#define DD_DL   0x02000000 // 1284.3 DataLink (for dot4)

#define DDB     0x00000100 // show Bytes written to / read from i/o ports
#define DD_IU   0x00000200 // Init(DriverEntry)/Unload
#define DD_PNP1 0x00000400 // PnP on FDO
#define DD_PNP2 0x00000800 // PnP on PDO

#define DD_OC1  0x00001000 // Open/Close/Cleanup on FDO
#define DD_OC2  0x00002000 // Open/Close/Cleanup on PDO
#define DD_RW   0x00004000 // Read/Write
#define DD_RWV  0x00008000 // Read/Write Verbose

#define DD_IEEE 0x00010000 // IEEE negotiation/termination etc.
#define DD_CHIP 0x00020000 // parallel port chip info
#define DD_ERR  0x00040000 // Error detected
#define DD_WRN  0x00080000 // Warning

#define DD_CAN  0x00200000 // Cancel
#define DD_SM   0x00400000 // IEEE state machine (state & phase)
#define DD_EX   0x00800000 // Exported functions (to ppa/ppa3)

#define DD_TMP1 0x10000000 // temp 1 - used for temporary debugging
#define DD_TMP2 0x20000000 // temp 2 - used for temporary debugging

#define DD_VERB 0x80000000 // Verbose

#define DDPrint( _b_, _x_ ) if( (_b_) & Trace ) DbgPrint _x_

// 
// Specific Diagnostics
// 

//
// DVRH_SHOW_BYTE_LOG   0 - Byte Log off
//                      1 - Byte Log on
#define DVRH_SHOW_BYTE_LOG  0

//
// DVRH_PAR_LOGFILE is used to allow for debug logging to a file
//  This functionality is for debugging purposes only.
//          0 - off
//          1 - on
#define DVRH_PAR_LOGFILE    0

//
// DVRH_BUS_RESET_ON_ERROR
//  This functionality is for debugging purposes only.
// Holds a bus reset for 100us when a handshaking error
// is discovered. This is useful for triggering the
// logic analyzer
//          0 - off
//          1 - on
#define DVRH_BUS_RESET_ON_ERROR    0

#if (1 == DVRH_PAR_LOGFILE)
#define DEFAULT_LOG_FILE_NAME	L"\\??\\C:\\tmp\\parport.log"
#define DbgPrint   DVRH_LogMessage
BOOLEAN DVRH_LogMessage(PCHAR szFormat, ...);
#endif

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\ecp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    ecp.c

Abstract:

    Enhanced Capabilities Port (ECP)
    
    This module contains the common routines that aue used/ reused
    by swecp and hwecp.

Author:

    Robbie Harris (Hewlett-Packard) - May 27, 1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

//=========================================================
// ECP::EnterForwardPhase
//
// Description : Do what is necessary to enter forward phase for ECP
//
// Input Parameters : Controller,  pPortInfoStruct
//
// Modifies : ECR, DCR
//
//=========================================================
NTSTATUS
ParEcpEnterForwardPhase(IN  PPDO_EXTENSION  Pdx)
{
    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    return STATUS_SUCCESS;
}

// =========================================================
// ECP::EnterReversePhase
//
// Description : Move from the common phase (FwdIdle, wPortHWMode=PS2)
//               to ReversePhase.  
//
// Input Parameters : Controller, pPortInfoStruct
//
// Modifies : pPortInfoStruct->CurrentPhase, DCR
//
// Pre-conditions : CurrentPhase == PHASE_FORWARD_IDLE
//                  wPortHWMode == HW_MODE_PS2
//
// Post-conditions : Bus is in ECP State 40
//                   CurrentPhase = PHASE_REVERSE_IDLE
//
// Returns : status of operation
//
//=========================================================
NTSTATUS ParEcpEnterReversePhase(IN  PPDO_EXTENSION   Pdx)
{
    // Assume that we are in the common entry phase (FWDIDLE, and ECR mode=PS/2)
    // EnterReversePhase assumes that we are in PHASE_FORWARD_IDLE,
    // and that the ECPMode is set to PS/2 mode at entry.
    
    // Setup the status to indicate successful
    NTSTATUS status = STATUS_SUCCESS;
    PUCHAR wPortDCR;       // I/O address of Device Control Register
    PUCHAR wPortECR;       // I/O address of ECR
    UCHAR dcr;

    // Calculate I/O port addresses for common registers
    wPortDCR = Pdx->Controller + OFFSET_DCR;
    
    wPortECR = Pdx->EcrController + ECR_OFFSET;
    
    // Now, Check the current state to make sure that we are ready for
    // a change to reverse phase.
    if ( PHASE_FORWARD_IDLE == Pdx->CurrentPhase ) {
        // Okay, we are ready to proceed.  Set the CurrentPhase and go on to 
        // state 47
        //----------------------------------------------------------------------
        // Set CurrentPhase to indicate Forward To Reverse Mode.
        //----------------------------------------------------------------------
        P5SetPhase( Pdx, PHASE_FWD_TO_REV );
        
        //----------------------------------------------------------------------
        // Set Dir=1 in DCR for reading.
        //----------------------------------------------------------------------
        dcr = P5ReadPortUchar(wPortDCR);     // Get content of DCR.
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
        P5WritePortUchar(wPortDCR, dcr);
        
        // Set the data port bits to 1 so that other circuits can control them
        //P5WritePortUchar(Controller + OFFSET_DATA, 0xFF);
        
        //----------------------------------------------------------------------
        // Assert HostAck low.  (ECP State 38)
        //----------------------------------------------------------------------
        Pdx->CurrentEvent = 38;
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE );
        P5WritePortUchar(wPortDCR, dcr);
        
        // REVISIT: Should use TICKCount to get a finer granularity.
        // According to the spec we need to delay at least .5 us
        KeStallExecutionProcessor((ULONG) 1);       // Stall for 1 us
        
        //----------------------------------------------------------------------
        // Assert nReverseRequest low.  (ECP State 39)
        //----------------------------------------------------------------------
        Pdx->CurrentEvent = 39;
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE );
        P5WritePortUchar(wPortDCR, dcr);
        
        // NOTE: Let the caller check for State 40, since the error handling for
        // State 40 is different between hwecp and swecp.

    } else {

        DD((PCE)Pdx,DDE,"ParEcpEnterReversePhase - Invalid Phase on entry - broken state machine\n");
        PptAssertMsg("ParEcpEnterReversePhase - Invalid Phase on entry - broken state machine",FALSE);
        status = STATUS_LINK_FAILED;
    }
    
    return status;
}	

//=========================================================
// ECP::ExitReversePhase
//
// Description : Transition from the ECP reverse Phase to the 
//               common phase for all entry functions
//
// Input Parameters : Controller - offset to the I/O ports
//			pPortInfoStruct - pointer to port information
//
// Modifies : CurrentPhase, DCR
//
// Pre-conditions :
//
// Post-conditions : NOTE: This function does not completely move to 
//                   the common phase for entry functions.  Both the
//                   HW and SW ECP classes must do extra work
//
// Returns : Status of the operation
//
//=========================================================
NTSTATUS ParEcpExitReversePhase(IN  PPDO_EXTENSION   Pdx)
{
    NTSTATUS       status = STATUS_SUCCESS;
    PUCHAR         Controller = Pdx->Controller;
    PUCHAR wPortDCR;       // I/O address of Device Control Register
    PUCHAR wPortECR;       // I/O address of ECR
    UCHAR          dcr;

    wPortDCR = Controller + OFFSET_DCR;
    wPortECR = Pdx->EcrController + ECR_OFFSET;


    //----------------------------------------------------------------------
    // Set status byte to indicate Reverse To Forward Mode.
    //----------------------------------------------------------------------
    P5SetPhase( Pdx, PHASE_REV_TO_FWD );


    //----------------------------------------------------------------------
    // Set HostAck high
    //----------------------------------------------------------------------
    dcr = P5ReadPortUchar(wPortDCR);
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE );
    P5WritePortUchar(wPortDCR, dcr);


    //----------------------------------------------------------------------
    // Set nReverseRequest high.  (State 47)
    //----------------------------------------------------------------------
    Pdx->CurrentEvent = 47;
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE );
    P5WritePortUchar(wPortDCR, dcr);

    //----------------------------------------------------------------------
    // Check first for PeriphAck low and PeriphClk high. (State 48)
    //----------------------------------------------------------------------
    Pdx->CurrentEvent = 48;
    if( ! CHECK_DSR(Controller, INACTIVE, ACTIVE, DONT_CARE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL) ) {
        // Bad things happened - timed out on this state,
        // Mark Status as bad and let our mgr kill ECP mode.
        // status = SLP_RecoverPort( pSDCB, RECOVER_18 );   // Reset port.
        status = STATUS_LINK_FAILED;
    	DD((PCE)Pdx,DDE,"ParEcpExitReversePhase - state 48 Timeout\n");
        goto ParEcpExitReversePhase;
    }
    
    //----------------------------------------------------------------------
    // Check next for nAckReverse high.  (State 49) 
    //----------------------------------------------------------------------
    Pdx->CurrentEvent = 49;
    if ( ! CHECK_DSR(Controller ,INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL ) ) {
        // Bad things happened - timed out on this state,
        // Mark Status as bad and let our mgr kill ECP mode.
        //nError = RecoverPort( pSDCB, RECOVER_19 );   // Reset port.
        status = STATUS_LINK_FAILED;
    	DD((PCE)Pdx,DDE,"ParEcpExitReversePhase:state 49 Timeout\n");
        goto ParEcpExitReversePhase;
    }
    
    // Warning: Don't assume that the ECR is in PS/2 mode here.
    // You cannot change the direction in this routine.  It must be
    // done elsewhere (SWECP or HWECP).
    
ParEcpExitReversePhase:

    DD((PCE)Pdx,DDT,"ParEcpExitReversePhase - exit w/status=%x\n",status);
    return status;
}	

BOOLEAN
ParEcpHaveReadData (
    IN  PPDO_EXTENSION  Pdx
    )
{
    return ( (UCHAR)0 == (P5ReadPortUchar(Pdx->Controller + OFFSET_DSR) & DSR_NOT_PERIPH_REQUEST) );
}

NTSTATUS
ParEcpSetupPhase(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine performs 1284 Setup Phase.

Arguments:

    Controller      - Supplies the port address.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    PUCHAR         Controller;
    UCHAR          dcr;

    // The negotiation succeeded.  Current mode and phase.
    //
    P5SetPhase( Pdx, PHASE_SETUP );
    Controller = Pdx->Controller;
    // Negoiate leaves us in state 6, we need to be in state 30 to
    // begin transfer. Note that I am assuming that the controller
    // is already set as it should be for state 6.
    //

    // *************** State 30 Setup Phase ***************8
    //  DIR                     = Don't Care
    //  IRQEN                   = Don't Care
    //  1284/SelectIn           = High
    //  nReverseReq/**(ECP only)= High
    //  HostAck/HostBusy        = Low  (Signals state 30)
    //  HostClk/nStrobe         = High
    //
    Pdx->CurrentEvent = 30;
    dcr = P5ReadPortUchar(Controller + OFFSET_DCR);
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, INACTIVE, ACTIVE);
    P5WritePortUchar(Controller + OFFSET_DCR, dcr);

    // *************** State 31 Setup Phase ***************8
    // PeriphAck/PtrBusy        = low
    // PeriphClk/PtrClk         = high
    // nAckReverse/AckDataReq   = high  (Signals state 31)
    // XFlag                    = high
    // nPeriphReq/nDataAvail    = Don't Care
    Pdx->CurrentEvent = 31;
    if (!CHECK_DSR(Controller, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL)) {
        // Bad things happened - timed out on this state.
        // Set status to an error and let PortTuple kill ECP mode (Terminate).
        DD((PCE)Pdx,DDE,"ParEcpSetupPhase - State 31 Failed - dcr=%x\n",dcr);
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        return STATUS_IO_DEVICE_ERROR;
    }

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    DD((PCE)Pdx,DDT,"ParEcpSetupPhase - exit - STATUS_SUCCESS\n");
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\epp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    epp.c

Abstract:

    This module contains the common code to perform all EPP related tasks 
    for EPP Software and EPP Hardware modes.

Author:

    Don Redford - July 29, 1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

NTSTATUS
ParEppSetAddress(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Address
    );
    

NTSTATUS
ParEppSetAddress(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Address
    )

/*++

Routine Description:

    Sets an EPP Address.
    
Arguments:

    Pdx           - Supplies the device extension.

    Address             - The bus address to be set.
    
Return Value:

    None.

--*/
{
    PUCHAR  Controller;
    UCHAR   dcr;
    
    DD((PCE)Pdx,DDT,"ParEppSetAddress: Entering\n");

    Controller = Pdx->Controller;

    P5SetPhase( Pdx, PHASE_FORWARD_XFER );
    
    dcr = GetControl (Controller);
    
    P5WritePortUchar(Controller + DATA_OFFSET, Address);
    
    //
    // Event 56
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, INACTIVE );
    StoreControl (Controller, dcr);
            
    //
    // Event 58
    //
    if( !CHECK_DSR(Controller, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DEFAULT_RECEIVE_TIMEOUT) ) {

        //
        // Return the device to Idle.
        //
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE );

        StoreControl (Controller, dcr);
            
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE );
        StoreControl (Controller, dcr);
            
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

        DD((PCE)Pdx,DDE,"ParEppSetAddress: Leaving with IO Device Error Event 58\n");

        return STATUS_IO_DEVICE_ERROR;
    }
        
    //
    // Event 59
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE );
    StoreControl (Controller, dcr);
            
    //
    // Event 60
    //
    if( !CHECK_DSR(Controller, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DEFAULT_RECEIVE_TIMEOUT) ) {

        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE );
        StoreControl (Controller, dcr);

        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

        DD((PCE)Pdx,DDE,"ParEppSetAddress - Leaving with IO Device Error Event 60\n");

        return STATUS_IO_DEVICE_ERROR;
    }
        
    //
    // Event 61
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE );
    StoreControl( Controller, dcr );

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    return STATUS_SUCCESS;
            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\fdocleanup.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    parport.sys

File Name:

    cleanup.c

Abstract:

    This file contains the dispatch routine for handling IRP_MJ_CLEANUP.

Exports:

     - PptDispatchCleanup() - The dispatch routine for cleanup.

--*/

#include "pch.h"

NTSTATUS
PptFdoCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++dvdf3
      
Routine Description:
      
    This is the dispatch routine for handling IRP_MJ_CLEANUP IRPs.

    This routine cancels all of the IRPs currently queued on
      for the specified device.
      
Arguments:
      
    DeviceObject    - Supplies the device object.
      
    Irp             - Supplies the cleanup IRP.
      
Return Value:
      
    STATUS_SUCCESS  - Success.
      
--*/
    
{
    PFDO_EXTENSION   fdx   = DeviceObject->DeviceExtension;
    PIRP                nextIrp;
    KIRQL               cancelIrql;
    
    DD((PCE)fdx,DDT,"PptFdoCleanup\n");
    
    //
    // Verify that our device has not been SUPRISE_REMOVED. If we
    //   have been SUPRISE_REMOVED then we have already cleaned up
    //   as part of the handling of the surprise removal.
    //
    if( fdx->PnpState & PPT_DEVICE_SURPRISE_REMOVED ) {
        goto targetExit;
    }

    IoAcquireCancelSpinLock( &cancelIrql );
    
    while( !IsListEmpty( &fdx->WorkQueue ) ) {
        
        nextIrp = CONTAINING_RECORD(fdx->WorkQueue.Blink, IRP, Tail.Overlay.ListEntry);
        
        nextIrp->Cancel        = TRUE;
        nextIrp->CancelIrql    = cancelIrql;
        nextIrp->CancelRoutine = NULL;

        PptCancelRoutine(DeviceObject, nextIrp);
        
        // need to reacquire because PptCancelRoutine() releases the SpinLock
        IoAcquireCancelSpinLock(&cancelIrql);
    }
    
    IoReleaseCancelSpinLock( cancelIrql );
    
targetExit:

    return P4CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\driverentry.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Parport.sys - Parallel port (IEEE 1284, IEEE 1284.3) driver.

File Name:

        driverEntry.c

Abstract:

        DriverEntry routine - driver initialization

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        2000-07-25 - Doug Fritz
         - code cleanup, add comments, add copyright

Author(s):

        Doug Fritz

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* DriverEntry                                                          */
/************************************************************************/
//
// Routine Description:
//
//     This is the DriverEntry routine -- the first function called
//       after the driver has been loaded into memory.
//
// Arguments:
//
//     DriverObject - points to the DRIVER_OBJECT for this driver
//     RegPath      - the service registry key for this driver
//
// Return Value:
//
//     STATUS_SUCCESS   - on success
//     STATUS_NO_MEMORY - if unable to allocate pool
//
// Notes:
//
// Log:
//
/************************************************************************/
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegPath
    )
{
    //
    // Save a copy of *RegPath in driver global RegistryPath for future reference.
    //
    // UNICODE_NULL terminate the path so that we can safely use RegistryPath.Buffer
    //   as a PWSTR.
    //
    {
        USHORT size = RegPath->Length + sizeof(WCHAR);
        RegistryPath.Buffer = ExAllocatePool( (PagedPool | POOL_COLD_ALLOCATION), size );

        if( NULL == RegistryPath.Buffer ) {
            return STATUS_NO_MEMORY;
        }

        RegistryPath.Length        = 0;
        RegistryPath.MaximumLength = size;
        RtlCopyUnicodeString( &RegistryPath, RegPath );
        RegistryPath.Buffer[ size/sizeof(WCHAR) - 1 ] = UNICODE_NULL;
    }



    //
    // Initialize Driver Globals
    //

    // Non-zero means don't raise IRQL from PASSIVE_LEVEL to DISPATCH_LEVEL
    //   when doing CENTRONICS mode (SPP) writes.
    SppNoRaiseIrql = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"SppNoRaiseIrql", &SppNoRaiseIrql );

    // Non-zero means override CENTRONICS as the default Forward mode and/or NIBBLE as
    //   the default Reverse mode. Valid modes are those defined in ntddpar.h as
    //   parameters for IOCTL_IEEE1284_NEGOTIATE.
    // *** Warning: invalid settings and/or setting/device incompatibilities can render
    //       the port unusable until the settings are corrected
    DefaultModes = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DefaultModes", &DefaultModes );

    // Set tracing level for driver DbgPrint messages. Trace values defined in debug.h.
    // Zero means no trace output.
    Trace = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"Trace", &Trace );

    // Request DbgBreakPoint on driver events. Event values defined in debug.h.
    // Zero means no breakpoints requested.
    Break = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"Break", &Break );

    // Mask OFF debug spew for specific devices. See debug.h for flag definitions
    //  0 means allow debug spew for that device
    // ~0 means mask OFF all (show NO) debug spew for that device type
    DbgMaskFdo = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskFdo", &DbgMaskFdo );

    DbgMaskRawPort = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskRawPort", &DbgMaskRawPort );

    DbgMaskDaisyChain0 = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskDaisyChain0", &DbgMaskDaisyChain0 );

    DbgMaskDaisyChain1 = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskDaisyChain1", &DbgMaskDaisyChain1 );

    DbgMaskEndOfChain = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskEndOfChain", &DbgMaskEndOfChain );

    DbgMaskLegacyZip = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskLegacyZip", &DbgMaskLegacyZip );

    DbgMaskNoDevice = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskNoDevice", &DbgMaskNoDevice );

#if 1 == DBG_SHOW_BYTES
    DbgShowBytes = 1;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgShowBytes", &DbgShowBytes );
#endif

    //
    // Allow asserts? non-zero means allow assertions
    //
    AllowAsserts = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"AllowAsserts", &AllowAsserts );

    // Non-zero means enable detection of Iomega Legacy Zip-100 drives that use
    //   an Iomega proprietary Select/Deselect mechanism rather than the Select/Deselect
    //   mechanism defined by IEEE 1284.3. (These drives pre-date IEEE 1284.3)
    // *** Note: if zero, this registry setting is checked again during every PnP QDR/BusRelations
    //       query to see if the user has enabled detection via the Ports property page "Enable
    //       legacy Plug and Play detection" checkbox.
    ParEnableLegacyZip = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"ParEnableLegacyZip", &ParEnableLegacyZip );

    // Default timeout when trying to acquire exclusive access to the (shared) port
    {
        const ULONG halfSecond  =  500; // in milliseconds
        const ULONG fiveSeconds = 5000;

        ULONG requestedTimeout  = halfSecond;

        PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"AcquirePortTimeout", &requestedTimeout );

        if( requestedTimeout < halfSecond ) {
            requestedTimeout = halfSecond;
        } else if( requestedTimeout > fiveSeconds ) {
            requestedTimeout = fiveSeconds;
        }

        PPT_SET_RELATIVE_TIMEOUT_IN_MILLISECONDS( AcquirePortTimeout, requestedTimeout );
    }

    {
        //
        // register for callbacks so that we can detect switch between
        // AC and battery power and tone done "polling for printers"
        // when machine switches to battery power.
        //
        OBJECT_ATTRIBUTES objAttributes;
        UNICODE_STRING    callbackName;
        NTSTATUS          localStatus;

        RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");
        
        InitializeObjectAttributes(&objAttributes,
                                   &callbackName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
        
        localStatus = ExCreateCallback(&PowerStateCallbackObject,
                                       &objAttributes,
                                       FALSE,
                                       TRUE);
        
        if( STATUS_SUCCESS == localStatus ) {
            PowerStateCallbackRegistration = ExRegisterCallback(PowerStateCallbackObject,
                                                                PowerStateCallback,
                                                                NULL);
        }
    }



    //
    // Set dispatch table entries for IRP_MJ_* functions that we handle
    //
    DriverObject->MajorFunction[ IRP_MJ_CREATE                  ] = PptDispatchCreateOpen;
    DriverObject->MajorFunction[ IRP_MJ_CLOSE                   ] = PptDispatchClose;
    DriverObject->MajorFunction[ IRP_MJ_CLEANUP                 ] = PptDispatchCleanup;

    DriverObject->MajorFunction[ IRP_MJ_READ                    ] = PptDispatchRead;
    DriverObject->MajorFunction[ IRP_MJ_WRITE                   ] = PptDispatchWrite;

    DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL          ] = PptDispatchDeviceControl;
    DriverObject->MajorFunction[ IRP_MJ_INTERNAL_DEVICE_CONTROL ] = PptDispatchInternalDeviceControl;

    DriverObject->MajorFunction[ IRP_MJ_QUERY_INFORMATION       ] = PptDispatchQueryInformation;
    DriverObject->MajorFunction[ IRP_MJ_SET_INFORMATION         ] = PptDispatchSetInformation;

    DriverObject->MajorFunction[ IRP_MJ_PNP                     ] = PptDispatchPnp;
    DriverObject->MajorFunction[ IRP_MJ_POWER                   ] = PptDispatchPower;

    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL          ] = PptDispatchSystemControl;

    DriverObject->DriverExtension->AddDevice                      = P5AddDevice;
    DriverObject->DriverUnload                                    = PptUnload;



    //
    // Break on user request
    //   (typically via registry setting ...\Services\Parport\Parameters : Break : REG_DWORD : 0x1)
    //
    // This is a useful breakpoint in order to manually set appropriate breakpoints elsewhere in the driver.
    //
    PptBreakOnRequest( PPT_BREAK_ON_DRIVER_ENTRY, ("PPT_BREAK_ON_DRIVER_ENTRY - BreakPoint requested") );


    DD(NULL,DDT,"Parport DriverEntry - SUCCESS\n");

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\errlog.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       errlog.c
//
//--------------------------------------------------------------------------

#include "pch.h"

VOID
PptLogError(
            IN  PDRIVER_OBJECT      DriverObject,
            IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
            IN  PHYSICAL_ADDRESS    P1,
            IN  PHYSICAL_ADDRESS    P2,
            IN  ULONG               SequenceNumber,
            IN  UCHAR               MajorFunctionCode,
            IN  UCHAR               RetryCount,
            IN  ULONG               UniqueErrorValue,
            IN  NTSTATUS            FinalStatus,
            IN  NTSTATUS            SpecificIOStatus
            )
    
/*++
      
Routine Description:
      
    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.
      
Arguments:
      
    DriverObject        - Supplies a pointer to the driver object for the device
      
    DeviceObject        - Supplies a pointer to the device object associated
                            with the device that had the error, early in
                            initialization, one may not yet exist.
      
    P1,P2               - Supplies the physical addresses for the controller
                            ports involved with the error if they are available
                            and puts them through as dump data.
      
    SequenceNumber      - Supplies a ulong value that is unique to an IRP over
                            the life of the irp in this driver - 0 generally
                            means an error not associated with an irp.
      
    MajorFunctionCode   - Supplies the major function code of the irp if there
                            is an error associated with it.
      
    RetryCount          - Supplies the number of times a particular operation
                            has been retried.
      
    UniqueErrorValue    - Supplies a unique long word that identifies the
                            particular call to this function.
      
    FinalStatus         - Supplies the final status given to the irp that was
                            associated with this error.  If this log entry is
                            being made during one of the retries this value
                            will be STATUS_SUCCESS.
      
    SpecificIOStatus    - Supplies the IO status for this particular error.
      
Return Value:
      
    None.
      
--*/
    
{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    PVOID                   ObjectToUse;
    SHORT                   DumpToAllocate;
    
    DD(NULL,DDE,"PptLogError()\n");
    
    if (ARGUMENT_PRESENT(DeviceObject)) {
        ObjectToUse = DeviceObject;
    } else {
        ObjectToUse = DriverObject;
    }
    
    DumpToAllocate = 0;
    
    if (P1.LowPart != 0 || P1.HighPart != 0) {
        DumpToAllocate = (SHORT) sizeof(PHYSICAL_ADDRESS);
    }
    
    if (P2.LowPart != 0 || P2.HighPart != 0) {
        DumpToAllocate += (SHORT) sizeof(PHYSICAL_ADDRESS);
    }
    
    ErrorLogEntry = IoAllocateErrorLogEntry(ObjectToUse,
                                            (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + DumpToAllocate));
    
    if (!ErrorLogEntry) {
        return;
    }
    
    ErrorLogEntry->ErrorCode = SpecificIOStatus;
    ErrorLogEntry->SequenceNumber = SequenceNumber;
    ErrorLogEntry->MajorFunctionCode = MajorFunctionCode;
    ErrorLogEntry->RetryCount = RetryCount;
    ErrorLogEntry->UniqueErrorValue = UniqueErrorValue;
    ErrorLogEntry->FinalStatus = FinalStatus;
    ErrorLogEntry->DumpDataSize = DumpToAllocate;
    
    if (DumpToAllocate) {

        RtlCopyMemory(ErrorLogEntry->DumpData, &P1, sizeof(PHYSICAL_ADDRESS));
        
        if (DumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {
            
            RtlCopyMemory(((PUCHAR) ErrorLogEntry->DumpData) +
                          sizeof(PHYSICAL_ADDRESS), &P2,
                          sizeof(PHYSICAL_ADDRESS));
        }
    }
    
    IoWriteErrorLogEntry(ErrorLogEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\fdocreate.c ===
#include "pch.h"

NTSTATUS
PptFdoCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
      
Routine Description:
      
    This is the dispatch function for IRP_MJ_CREATE.
      
Arguments:
      
    DeviceObject    - The target device object for the request.

    Irp             - The I/O request packet.
      
Return Value:
      
    STATUS_SUCCESS        - If Success.

    STATUS_DELETE_PENDING - If this device is in the process of being removed 
                              and will go away as soon as all outstanding
                              requests are cleaned up.
      
--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;
    NTSTATUS          status    = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Verify that our device has not been SUPRISE_REMOVED. Generally
    //   only parallel ports on hot-plug busses (e.g., PCMCIA) and
    //   parallel ports in docking stations will be surprise removed.
    //
    // dvdf - RMT - It would probably be a good idea to also check
    //   here if we are in a "paused" state (stop-pending, stopped, or
    //   remove-pending) and queue the request until we either return to
    //   a fully functional state or are removed.
    //
    if( fdx->PnpState & PPT_DEVICE_SURPRISE_REMOVED ) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }


    //
    // Try to acquire RemoveLock to prevent the device object from going
    //   away while we're using it.
    //
    status = PptAcquireRemoveLockOrFailIrp( DeviceObject, Irp );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // We have the RemoveLock - handle CREATE
    //
    ExAcquireFastMutex(&fdx->OpenCloseMutex);
    InterlockedIncrement(&fdx->OpenCloseRefCount);
    ExReleaseFastMutex(&fdx->OpenCloseMutex);

    DD((PCE)fdx,DDT,"PptFdoCreateOpen - SUCCEED - new OpenCloseRefCount=%d\n",fdx->OpenCloseRefCount);

    PptReleaseRemoveLock(&fdx->RemoveLock, Irp);

    P4CompleteRequest( Irp, status, 0 );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\fdoioctl.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ioctl.c
//
//--------------------------------------------------------------------------

#include "pch.h"

NTSTATUS
PptFdoInternalDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++
      
Routine Description:
      
    This routine is the dispatch routine for IRP_MJ_INTERNAL_DEVICE_CONTROL.
      
Arguments:
      
    DeviceObject    - Supplies the device object.
      
    Irp             - Supplies the I/O request packet.
      
Return Value:
      
    STATUS_SUCCESS              - Success.
    STATUS_UNSUCCESSFUL         - The request was unsuccessful.
    STATUS_PENDING              - The request is pending.
    STATUS_INVALID_PARAMETER    - Invalid parameter.
    STATUS_CANCELLED            - The request was cancelled.
    STATUS_BUFFER_TOO_SMALL     - The supplied buffer is too small.
    STATUS_INVALID_DEVICE_STATE - The current chip mode is invalid to change to asked mode
    
--*/
    
{
    PIO_STACK_LOCATION                  IrpSp;
    PFDO_EXTENSION                      Extension = DeviceObject->DeviceExtension;
    NTSTATUS                            Status;
    PPARALLEL_PORT_INFORMATION          PortInfo;
    PPARALLEL_PNP_INFORMATION           PnpInfo;
    PMORE_PARALLEL_PORT_INFORMATION     MorePortInfo;
    KIRQL                               CancelIrql;
    SYNCHRONIZED_COUNT_CONTEXT          SyncContext;
    PPARALLEL_INTERRUPT_SERVICE_ROUTINE IsrInfo;
    PPARALLEL_INTERRUPT_INFORMATION     InterruptInfo;
    PISR_LIST_ENTRY                     IsrListEntry;
    SYNCHRONIZED_LIST_CONTEXT           ListContext;
    SYNCHRONIZED_DISCONNECT_CONTEXT     DisconnectContext;
    BOOLEAN                             DisconnectInterrupt;

    //
    // Verify that our device has not been SUPRISE_REMOVED. Generally
    //   only parallel ports on hot-plug busses (e.g., PCMCIA) and
    //   parallel ports in docking stations will be surprise removed.
    //
    // dvdf - RMT - It would probably be a good idea to also check
    //   here if we are in a "paused" state (stop-pending, stopped, or
    //   remove-pending) and queue the request until we either return to
    //   a fully functional state or are removed.
    //
    if( Extension->PnpState & PPT_DEVICE_SURPRISE_REMOVED ) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }


    //
    // Try to acquire RemoveLock to prevent the device object from going
    //   away while we're using it.
    //
    Status = PptAcquireRemoveLockOrFailIrp( DeviceObject, Irp );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    
    Irp->IoStatus.Information = 0;
    

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
        
    case IOCTL_INTERNAL_DISABLE_END_OF_CHAIN_BUS_RESCAN:

        Extension->DisableEndOfChainBusRescan = TRUE;
        Status = STATUS_SUCCESS;
        break;

    case IOCTL_INTERNAL_ENABLE_END_OF_CHAIN_BUS_RESCAN:

        Extension->DisableEndOfChainBusRescan = FALSE;
        Status = STATUS_SUCCESS;
        break;

    case IOCTL_INTERNAL_PARALLEL_PORT_FREE:

        PptFreePort(Extension);
        PptReleaseRemoveLock(&Extension->RemoveLock, Irp);
        return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );

    case IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE:
        
        IoAcquireCancelSpinLock(&CancelIrql);
        
        if( Irp->Cancel ) {
            
            Status = STATUS_CANCELLED;
            
        } else {
            
            SyncContext.Count = &Extension->WorkQueueCount;
            
            if( Extension->InterruptRefCount ) {
                
                KeSynchronizeExecution( Extension->InterruptObject, PptSynchronizedIncrement, &SyncContext );

            } else {
                
                PptSynchronizedIncrement( &SyncContext );

            }
            
            if (SyncContext.NewCount) {
                
                // someone else currently has the port, queue request
                PptSetCancelRoutine( Irp, PptCancelRoutine );
                IoMarkIrpPending( Irp );
                InsertTailList( &Extension->WorkQueue, &Irp->Tail.Overlay.ListEntry );
                Status = STATUS_PENDING;

            } else {
                // port aquired
                Extension->WmiPortAllocFreeCounts.PortAllocates++;
                Status = STATUS_SUCCESS;
            }
        } // endif Irp->Cancel
        
        IoReleaseCancelSpinLock(CancelIrql);

        break;
        
    case IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO:
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PARALLEL_PORT_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            Irp->IoStatus.Information = sizeof(PARALLEL_PORT_INFORMATION);
            PortInfo = Irp->AssociatedIrp.SystemBuffer;
            *PortInfo = Extension->PortInfo;
            Status = STATUS_SUCCESS;
        }
        break;
        
    case IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO:
        
        Status = STATUS_SUCCESS;
        break;
        
    case IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO:
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PARALLEL_PNP_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            Irp->IoStatus.Information = sizeof(PARALLEL_PNP_INFORMATION);
            PnpInfo  = Irp->AssociatedIrp.SystemBuffer;
            *PnpInfo = Extension->PnpInfo;
            
            Status = STATUS_SUCCESS;
        }
        break;
        
    case IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO:
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MORE_PARALLEL_PORT_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            Irp->IoStatus.Information = sizeof(MORE_PARALLEL_PORT_INFORMATION);
            MorePortInfo = Irp->AssociatedIrp.SystemBuffer;
            MorePortInfo->InterfaceType = Extension->InterfaceType;
            MorePortInfo->BusNumber = Extension->BusNumber;
            MorePortInfo->InterruptLevel = Extension->InterruptLevel;
            MorePortInfo->InterruptVector = Extension->InterruptVector;
            MorePortInfo->InterruptAffinity = Extension->InterruptAffinity;
            MorePortInfo->InterruptMode = Extension->InterruptMode;
            Status = STATUS_SUCCESS;
        }
        break;
        
    case IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE:
        
        //
        // Port already acquired?
        //
        // Make sure right parameters are sent in
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(PARALLEL_CHIP_MODE) ) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = PptSetChipMode (Extension, 
                                ((PPARALLEL_CHIP_MODE)Irp->AssociatedIrp.SystemBuffer)->ModeFlags );
        } // end check input buffer
        
        break;
        
    case IOCTL_INTERNAL_PARALLEL_CLEAR_CHIP_MODE:
        
        //
        // Port already acquired?
        //
        // Make sure right parameters are sent in
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(PARALLEL_CHIP_MODE) ){
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = PptClearChipMode (Extension, ((PPARALLEL_CHIP_MODE)Irp->AssociatedIrp.SystemBuffer)->ModeFlags);
        } // end check input buffer
        
        break;
        
    case IOCTL_INTERNAL_INIT_1284_3_BUS:

        // Initialize the 1284.3 bus

        // RMT - Port is locked out already?

        Extension->PnpInfo.Ieee1284_3DeviceCount = PptInitiate1284_3( Extension );

        Status = STATUS_SUCCESS;
        
        break;
            
    case IOCTL_INTERNAL_SELECT_DEVICE:
        // Takes a flat namespace Id for the device, also acquires the
        //   port unless HAVE_PORT_KEEP_PORT Flag is set
        

        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PARALLEL_1284_COMMAND) ) {

            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            if ( Irp->Cancel ) {
                Status = STATUS_CANCELLED;
            } else {
                // Call Function to try to select device
                Status = PptTrySelectDevice( Extension, Irp->AssociatedIrp.SystemBuffer );

                IoAcquireCancelSpinLock(&CancelIrql);
                if ( Status == STATUS_PENDING ) {
                    PptSetCancelRoutine(Irp, PptCancelRoutine);
                    IoMarkIrpPending(Irp);
                    InsertTailList(&Extension->WorkQueue, &Irp->Tail.Overlay.ListEntry);
                }
                IoReleaseCancelSpinLock(CancelIrql);
            }
        }
        
        break;
        
    case IOCTL_INTERNAL_DESELECT_DEVICE:
        // Deselects the current device, also releases the port unless HAVE_PORT_KEEP_PORT Flag set
        
        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PARALLEL_1284_COMMAND) ) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            Status = PptDeselectDevice( Extension, Irp->AssociatedIrp.SystemBuffer );

        }
        break;
        
    case IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT:
        
        {
            //
            // Verify that this interface has been explicitly enabled via the registry flag, otherwise
            //   FAIL the request with STATUS_UNSUCCESSFUL
            //
            ULONG EnableConnectInterruptIoctl = 0;
            PptRegGetDeviceParameterDword( Extension->PhysicalDeviceObject, 
                                           (PWSTR)L"EnableConnectInterruptIoctl", 
                                           &EnableConnectInterruptIoctl );
            if( 0 == EnableConnectInterruptIoctl ) {
                Status = STATUS_UNSUCCESSFUL;
                goto targetExit;
            }
        }


        //
        // This interface has been explicitly enabled via the registry flag, process request.
        //

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength  < sizeof(PARALLEL_INTERRUPT_SERVICE_ROUTINE) ||
            IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARALLEL_INTERRUPT_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            IsrInfo = Irp->AssociatedIrp.SystemBuffer;
            InterruptInfo = Irp->AssociatedIrp.SystemBuffer;
            IoAcquireCancelSpinLock(&CancelIrql);
            
            if (Extension->InterruptRefCount) {
                
                ++Extension->InterruptRefCount;
                IoReleaseCancelSpinLock(CancelIrql);
                Status = STATUS_SUCCESS;
                
            } else {
                
                IoReleaseCancelSpinLock(CancelIrql);
                Status = PptConnectInterrupt(Extension);
                if (NT_SUCCESS(Status)) {
                    IoAcquireCancelSpinLock(&CancelIrql);
                    ++Extension->InterruptRefCount;
                    IoReleaseCancelSpinLock(CancelIrql);
                }
            }
            
            if (NT_SUCCESS(Status)) {
                
                IsrListEntry = ExAllocatePool(NonPagedPool, sizeof(ISR_LIST_ENTRY));
                
                if (IsrListEntry) {
                    
                    IsrListEntry->ServiceRoutine           = IsrInfo->InterruptServiceRoutine;
                    IsrListEntry->ServiceContext           = IsrInfo->InterruptServiceContext;
                    IsrListEntry->DeferredPortCheckRoutine = IsrInfo->DeferredPortCheckRoutine;
                    IsrListEntry->CheckContext             = IsrInfo->DeferredPortCheckContext;
                    
                    // Put the ISR_LIST_ENTRY onto the ISR list.
                    
                    ListContext.List = &Extension->IsrList;
                    ListContext.NewEntry = &IsrListEntry->ListEntry;
                    KeSynchronizeExecution(Extension->InterruptObject, PptSynchronizedQueue, &ListContext);
                    
                    InterruptInfo->InterruptObject                 = Extension->InterruptObject;
                    InterruptInfo->TryAllocatePortAtInterruptLevel = PptTryAllocatePortAtInterruptLevel;
                    InterruptInfo->FreePortFromInterruptLevel      = PptFreePortFromInterruptLevel;
                    InterruptInfo->Context                         = Extension;
                    
                    Irp->IoStatus.Information = sizeof(PARALLEL_INTERRUPT_INFORMATION);
                    Status = STATUS_SUCCESS;
                    
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        break;
        
    case IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT:
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(PARALLEL_INTERRUPT_SERVICE_ROUTINE)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            IsrInfo = Irp->AssociatedIrp.SystemBuffer;
            
            // Take the ISR out of the ISR list.
            
            IoAcquireCancelSpinLock(&CancelIrql);
            
            if (Extension->InterruptRefCount) {
                
                IoReleaseCancelSpinLock(CancelIrql);
                
                DisconnectContext.Extension = Extension;
                DisconnectContext.IsrInfo = IsrInfo;
                
                if (KeSynchronizeExecution(Extension->InterruptObject, PptSynchronizedDisconnect, &DisconnectContext)) {
                    
                    Status = STATUS_SUCCESS;
                    IoAcquireCancelSpinLock(&CancelIrql);
                    
                    if (--Extension->InterruptRefCount == 0) {
                        DisconnectInterrupt = TRUE;
                    } else {
                        DisconnectInterrupt = FALSE;
                    }
                    
                    IoReleaseCancelSpinLock(CancelIrql);
                    
                } else {
                    Status = STATUS_INVALID_PARAMETER;
                    DisconnectInterrupt = FALSE;
                }
                
            } else {
                IoReleaseCancelSpinLock(CancelIrql);
                DisconnectInterrupt = FALSE;
                Status = STATUS_INVALID_PARAMETER;
            }
            
            //
            // Disconnect the interrupt if appropriate.
            //
            if (DisconnectInterrupt) {
                PptDisconnectInterrupt(Extension);
            }
        }
        break;

    default:
        
        DD((PCE)Extension,DDE,"PptDispatchDeviceControl - default case - invalid/unsupported request\n");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    
targetExit:

    if( Status != STATUS_PENDING ) {
        PptReleaseRemoveLock(&Extension->RemoveLock, Irp);
        P4CompleteRequest( Irp, Status, Irp->IoStatus.Information );
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\fdoclose.c ===
#include "pch.h"

NTSTATUS
PptFdoClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PFDO_EXTENSION   fdx = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // Always succeed an IRP_MJ_CLOSE.
    //

    //
    // Keep running count of CREATE requests vs CLOSE requests.
    //
    ExAcquireFastMutex( &fdx->OpenCloseMutex );
    if( fdx->OpenCloseRefCount > 0 ) {
        //
        // prevent rollover -  strange as it may seem, it is perfectly
        //   legal for us to receive more closes than creates - this
        //   info came directly from Mr. PnP himself
        //
        if( ((LONG)InterlockedDecrement( &fdx->OpenCloseRefCount )) < 0 ) {
            // handle underflow
            InterlockedIncrement( &fdx->OpenCloseRefCount );
        }
    }
    ExReleaseFastMutex( &fdx->OpenCloseMutex );
    
    DD((PCE)fdx,DDT,"PptFdoClose - OpenCloseRefCount after close = %d\n", fdx->OpenCloseRefCount);

    return P4CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\fdopower.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       power.c
//
//--------------------------------------------------------------------------

#include "pch.h"

VOID
PowerStateCallback(
    IN  PVOID CallbackContext,
    IN  PVOID Argument1,
    IN  PVOID Argument2
    )
{
    ULONG_PTR   action = (ULONG_PTR)Argument1;
    ULONG_PTR   state  = (ULONG_PTR)Argument2;

    UNREFERENCED_PARAMETER(CallbackContext);

    if( PO_CB_AC_STATUS == action ) {

        //
        // AC <-> DC Transition has occurred
        // state == TRUE if on AC, else FALSE.
        //
        PowerStateIsAC = (BOOLEAN)state;
        // DbgPrint("PowerState is now %s\n",PowerStateIsAC?"AC":"Battery");
    }

    return;
}


NTSTATUS
PptPowerComplete (
                  IN PDEVICE_OBJECT       pDeviceObject,
                  IN PIRP                 pIrp,
                  IN PFDO_EXTENSION    Fdx
                  )

/*++
      
Routine Description:
      
    This routine handles all IRP_MJ_POWER IRPs.
  
Arguments:
  
    pDeviceObject           - represents the port device
  
    pIrp                    - PNP irp
  
    Fdx               - Device Extension
  
Return Value:
  
    Status
  
--*/
{
    POWER_STATE_TYPE    powerType;
    POWER_STATE         powerState;
    PIO_STACK_LOCATION  pIrpStack;
    
    UNREFERENCED_PARAMETER( pDeviceObject );

    if( pIrp->PendingReturned ) {
        IoMarkIrpPending( pIrp );
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    
    powerType = pIrpStack->Parameters.Power.Type;
    powerState = pIrpStack->Parameters.Power.State;
    
    switch (pIrpStack->MinorFunction) {
        
    case IRP_MN_QUERY_POWER:
        
        ASSERTMSG ("Invalid power completion minor code: Query Power\n", FALSE);
        break;
        
    case IRP_MN_SET_POWER:
        
        DD((PCE)Fdx,DDT,"Power - Setting %s state to %d\n", 
               ( (powerType == SystemPowerState) ?  "System" : "Device" ), powerState.SystemState);
        
        switch (powerType) {
        case DevicePowerState:
            if (Fdx->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //
                
                ASSERTMSG ("Invalid power completion Device Down\n", FALSE);
                
            } else if (powerState.DeviceState < Fdx->DeviceState) {
                //
                // Powering Up
                //
                PoSetPowerState (Fdx->DeviceObject, powerType, powerState);
                
                if (PowerDeviceD0 == Fdx->DeviceState) {
                    
                    //
                    // Do the power on stuff here.
                    //
                    
                }
                Fdx->DeviceState = powerState.DeviceState;
            }
            break;
            
        case SystemPowerState:
            
            if (Fdx->SystemState < powerState.SystemState) {
                //
                // Powering down
                //
                
                ASSERTMSG ("Invalid power completion System Down\n", FALSE);
                
            } else if (powerState.SystemState < Fdx->SystemState) {
                //
                // Powering Up
                //
                if (PowerSystemWorking == powerState.SystemState) {
                    
                    //
                    // Do the system start up stuff here.
                    //
                    
                    powerState.DeviceState = PowerDeviceD0;
                    PoRequestPowerIrp (Fdx->DeviceObject,
                                       IRP_MN_SET_POWER,
                                       powerState,
                                       NULL, // no completion function
                                       NULL, // and no context
                                       NULL);
                }
                
                Fdx->SystemState = powerState.SystemState;
            }
            break;
        }
        
        
        break;
        
    default:
        ASSERTMSG ("Power Complete: Bad Power State", FALSE);
    }
    
    PoStartNextPowerIrp (pIrp);
    
    return STATUS_SUCCESS;
}


NTSTATUS
PptFdoPower (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )
/*++
      
Routine Description:
      
    This routine handles all IRP_MJ_POWER IRPs.
      
Arguments:
      
    pDeviceObject           - represents the port device
      
    pIrp                    - PNP irp
      
Return Value:
      
    Status
      
--*/
{
    POWER_STATE_TYPE    powerType;
    POWER_STATE         powerState;
    PIO_STACK_LOCATION  pIrpStack;
    NTSTATUS            status;
    PFDO_EXTENSION      fdx;
    BOOLEAN             hookit   = FALSE;
    BOOLEAN             bogusIrp = FALSE;
    
    //
    // WORKWORK.  THIS CODE DOESN'T DO MUCH...NEED TO CHECK OUT FULL POWER FUNCTIONALITY.
    //
    
    fdx = pDeviceObject->DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    
    status = PptAcquireRemoveLock(&fdx->RemoveLock, pIrp);
    if( !NT_SUCCESS(status) ) {
        PoStartNextPowerIrp(pIrp);
        return P4CompleteRequest( pIrp, status, pIrp->IoStatus.Information );
    }

    powerType = pIrpStack->Parameters.Power.Type;
    powerState = pIrpStack->Parameters.Power.State;
    
    switch (pIrpStack->MinorFunction) {
        
    case IRP_MN_QUERY_POWER:
        
        status = STATUS_SUCCESS;
        break;
        
    case IRP_MN_SET_POWER:
        
        DD((PCE)fdx,DDT,"Power - Setting %s state to %d\n",
               ( (powerType == SystemPowerState) ?  "System" : "Device" ), powerState.SystemState);
        
        status = STATUS_SUCCESS;

        switch (powerType) {
        case DevicePowerState:
            if (fdx->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //
                
                PoSetPowerState (fdx->DeviceObject, powerType, powerState);
                
                if (PowerDeviceD0 == fdx->DeviceState) {
                    
                    //
                    // Do the power on stuff here.
                    //
                    
                }
                fdx->DeviceState = powerState.DeviceState;
                
            } else if (powerState.DeviceState < fdx->DeviceState) {
                //
                // Powering Up
                //
                hookit = TRUE;

            }
            
            break;
            
        case SystemPowerState:
            
            if (fdx->SystemState < powerState.SystemState) {
                //
                // Powering down
                //
                if (PowerSystemWorking == fdx->SystemState) {
                    
                    //
                    // Do the system shut down stuff here.
                    //
                    
                }
                
                powerState.DeviceState = PowerDeviceD3;
                PoRequestPowerIrp (fdx->DeviceObject,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   NULL, // no completion function
                                   NULL, // and no context
                                   NULL);
                fdx->SystemState = powerState.SystemState;
                
            } else if (powerState.SystemState < fdx->SystemState) {
                //
                // Powering Up
                //
                hookit = TRUE;
            }
            break;
        }
        
        break;
        
    default:
        bogusIrp = TRUE;
        status = STATUS_NOT_SUPPORTED;
    }
    
    IoCopyCurrentIrpStackLocationToNext (pIrp);
    
    if (!NT_SUCCESS (status)) {

        PoStartNextPowerIrp (pIrp);

        if( bogusIrp ) {
            status = PoCallDriver( fdx->ParentDeviceObject, pIrp );
        } else {
            P4CompleteRequest( pIrp, status, pIrp->IoStatus.Information );
        }
        
    } else if (hookit) {
        
        IoSetCompletionRoutine( pIrp, PptPowerComplete, fdx, TRUE, TRUE, TRUE );
        status = PoCallDriver (fdx->ParentDeviceObject, pIrp);
        
    } else {

        PoStartNextPowerIrp (pIrp);
        status = PoCallDriver (fdx->ParentDeviceObject, pIrp);

    }
    
    PptReleaseRemoveLock(&fdx->RemoveLock, pIrp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\fdothread.c ===
#include "pch.h"

// experimental vars - to tweek debugging for this thread
ULONG x1; // set nonzero to disable port acquisition
ULONG x2; // set nonzero to try to select LPT1.0 and negotiate/terminate ECP_HW_NOIRQ
ULONG x3; // set nonzero to try to negotiate the periph to ECP and then terminate
ULONG x4;

ULONG t1; // timeout between thread polls (in ms)
ULONG t2; // time to sit on port before releasing it (in ms)

VOID
P5FdoThread(
    IN  PFDO_EXTENSION Fdx
    )
{
    LARGE_INTEGER   timeOut1;
    NTSTATUS        status;
    UCHAR           deviceStatus;
    PCHAR           devId;
    BOOLEAN         requestRescan;
    const ULONG     pollingFailureThreshold = 10; // pick an arbitrary but reasonable number

    do {

        if( PowerStateIsAC ) {

            PPT_SET_RELATIVE_TIMEOUT_IN_MILLISECONDS( timeOut1, (WarmPollPeriod * 1000) );

        } else {

            // running on batteries - use a longer (4x) timeout
            PPT_SET_RELATIVE_TIMEOUT_IN_MILLISECONDS( timeOut1, (WarmPollPeriod * 1000 * 4) );

        }

        status = KeWaitForSingleObject(&Fdx->FdoThreadEvent, Executive, KernelMode, FALSE, &timeOut1);

        if( Fdx->TimeToTerminateThread ) {

            //
            // another thread (PnP REMOVE handler) has requested that we die and is likely waiting on us to do so
            //
            DD((PCE)Fdx,DDT,"P5FdoThread - killing self\n");
            PsTerminateSystemThread( STATUS_SUCCESS );

        }

        if( !PowerStateIsAC ) {
            // Still on Batteries - don't "poll for printers" - just go back to sleep
            continue;
        }

        if( STATUS_TIMEOUT == status ) {

            if( NULL == Fdx->EndOfChainPdo ) {

                // try to acquire port
                if( PptTryAllocatePort( Fdx ) ) {
                
                    DD((PCE)Fdx,DDT,"P5FdoThread - port acquired\n");

                    requestRescan = FALSE;

                    // check for something connected
                    deviceStatus = GetStatus(Fdx->PortInfo.Controller);

                    if( PAR_POWERED_OFF(deviceStatus)   ||
                        PAR_NOT_CONNECTED(deviceStatus) ||
                        PAR_NO_CABLE(deviceStatus) ) {
                        
                        // doesn't appear to be anything connected - do nothing
                        DD((PCE)Fdx,DDT,"P5FdoThread - nothing connected? - deviceStatus = %02x\n",deviceStatus);

                    } else {

                        // we might have something connected

                        // try a device ID to confirm

                        DD((PCE)Fdx,DDT,"P5FdoThread - might be something connected - deviceStatus = %02x\n",deviceStatus);                        

                        devId = P4ReadRawIeee1284DeviceId( Fdx->PortInfo.Controller );

                        if( devId ) {

                            PCHAR  mfg, mdl, cls, des, aid, cid;

                            // RawIeee1284 string includes 2 bytes of length data at beginning
                            DD((PCE)Fdx,DDT,"P5FdoThread - EndOfChain device detected <%s>\n",(devId+2));

                            ParPnpFindDeviceIdKeys( &mfg, &mdl, &cls, &des, &aid, &cid, devId+2 );

                            if( mfg && mdl ) {
                                DD((PCE)Fdx,DDT,"P5FdoThread - found mfg - <%s>\n",mfg);
                                DD((PCE)Fdx,DDT,"P5FdoThread - found mdl - <%s>\n",mdl);
                                requestRescan = TRUE;
                            }

                            ExFreePool( devId );

                        } else {
                            DD((PCE)Fdx,DDT,"P5FdoThread - no EndOfChain device detected - NULL devId\n");
                        }

                        if( requestRescan ) {

                            // we appear to have retrieved a valid 1284 ID, reset failure counter
                            Fdx->PollingFailureCounter = 0;

                        } else {

                            // Our heuristics tell us that there is something
                            // connected to the port but we are unable to retrieve
                            // a valid IEEE 1284 Device ID

                            if( ++(Fdx->PollingFailureCounter) > pollingFailureThreshold ) {

                                // too many consecutive failures - we're burning CPU for no good reason, give up and die
                                Fdx->TimeToTerminateThread = TRUE;

                                // don't delay before killing self
                                KeSetEvent( &Fdx->FdoThreadEvent, 0, FALSE );

                            }

                        } 

                    }

                    DD((PCE)Fdx,DDT,"P5FdoThread - freeing port\n");
                    PptFreePort( Fdx );

                    if( requestRescan ) {
                        DD((PCE)Fdx,DDT,"P5FdoThread - requesting Rescan\n");
                        IoInvalidateDeviceRelations( Fdx->PhysicalDeviceObject, BusRelations );
                    }

                } else {
                    DD((PCE)Fdx,DDT,"P5FdoThread - unable to acquire port\n");
                }

            } else {
                DD((PCE)Fdx,DDT,"P5FdoThread - already have EndOfChain device\n");
            }

        }

    } while( TRUE );

}

NTSTATUS
P5FdoCreateThread(
    PFDO_EXTENSION Fdx
    )
{
    NTSTATUS        status;
    HANDLE          handle;
    OBJECT_ATTRIBUTES objAttrib;

    DD((PCE)Fdx,DDT,"P5CreateFdoWorkerThread - %s - enter\n",Fdx->Location);

    // Start the thread - save referenced pointer to thread in our extension
    InitializeObjectAttributes( &objAttrib, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );

    status = PsCreateSystemThread( &handle, THREAD_ALL_ACCESS, &objAttrib, NULL, NULL, P5FdoThread, Fdx );

    if( STATUS_SUCCESS == status ) {

        // We've got the thread.  Now get a pointer to it.

        status = ObReferenceObjectByHandle( handle, THREAD_ALL_ACCESS, NULL, KernelMode, &Fdx->ThreadObjectPointer, NULL );

        if( STATUS_SUCCESS == status ) {
            // Now that we have a reference to the thread we can simply close the handle.
            ZwClose(handle);

        } else {
            Fdx->TimeToTerminateThread = TRUE;

            // error, go ahead and close the thread handle
            ZwClose(handle);

        }

        DD((PCE)Fdx,DDT,"ParCreateSystemThread - %s - SUCCESS\n",Fdx->Location);

    } else {
        DD((PCE)Fdx,DDT,"ParCreateSystemThread - %s FAIL - status = %x\n",Fdx->Location, status);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\fdowmi.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wmi.c
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEPARWMI0, PptWmiInitWmi)
#pragma alloc_text(PAGEPARWMI0, PptWmiQueryWmiRegInfo)
#pragma alloc_text(PAGEPARWMI0, PptWmiQueryWmiDataBlock)
#endif


//
// Number of WMI GUIDs that we support
//
#define PPT_WMI_PDO_GUID_COUNT               1

//
// Index of GUID PptWmiAllocFreeCountsGuid in the array of supported WMI GUIDs
//
#define PPT_WMI_ALLOC_FREE_COUNTS_GUID_INDEX 0

//
// defined in wmidata.h:
//
// // {4BBB69EA-6853-11d2-8ECE-00C04F8EF481}
// #define PARPORT_WMI_ALLOCATE_FREE_COUNTS_GUID {0x4bbb69ea, 0x6853, 0x11d2, 0x8e, 0xce, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x81}
//
// typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS {
// 	ULONG PortAllocates;	// number of Port Allocate requests granted
// 	ULONG PortFrees;	// number of Port Free requests granted
// } PARPORT_WMI_ALLOC_FREE_COUNTS, *PPARPORT_WMI_ALLOC_FREE_COUNTS;
//


//
// Define the (only at the moment) WMI GUID that we support
//
GUID PptWmiAllocFreeCountsGuid = PARPORT_WMI_ALLOCATE_FREE_COUNTS_GUID;


//
// Array of WMI GUIDs supported by driver
//
WMIGUIDREGINFO PptWmiGuidList[ PPT_WMI_PDO_GUID_COUNT ] =
{
    { &PptWmiAllocFreeCountsGuid, 1, 0 }
};


//
// Initialize WMI Context that we pass to WMILIB during the handling of
//   IRP_MJ_SYSTEM_CONTROL. This context lives in our device extension
//
// Register w/WMI that we are able to process WMI IRPs
//
NTSTATUS
PptWmiInitWmi(PDEVICE_OBJECT DeviceObject)
{
    PFDO_EXTENSION devExt     = DeviceObject->DeviceExtension;
    PWMILIB_CONTEXT   wmiContext = &devExt->WmiLibContext;

    PAGED_CODE();

    wmiContext->GuidCount = sizeof(PptWmiGuidList) / sizeof(WMIGUIDREGINFO);
    wmiContext->GuidList  = PptWmiGuidList;

    wmiContext->QueryWmiRegInfo    = PptWmiQueryWmiRegInfo;   // required
    wmiContext->QueryWmiDataBlock  = PptWmiQueryWmiDataBlock; // required
    wmiContext->SetWmiDataBlock    = NULL; // optional
    wmiContext->SetWmiDataItem     = NULL; // optional
    wmiContext->ExecuteWmiMethod   = NULL; // optional
    wmiContext->WmiFunctionControl = NULL; // optional

    // Tell WMI that we can now accept WMI IRPs
    return IoWMIRegistrationControl( DeviceObject, WMIREG_ACTION_REGISTER );
}

NTSTATUS
//
// This is the dispatch routine for IRP_MJ_SYSTEM_CONTROL IRPs. 
//
// We call WMILIB to process the IRP for us. WMILIB returns a disposition
//   that tells us what to do with the IRP.
//
PptFdoSystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;
    PFDO_EXTENSION pDevExt = (PFDO_EXTENSION)DeviceObject->DeviceExtension;

    PAGED_CODE();

    status = WmiSystemControl( &pDevExt->WmiLibContext, DeviceObject, Irp, &disposition);
    switch(disposition) {
    case IrpProcessed:

        //
        // This irp has been processed and may be completed or pending.
        //
        break;
        
    case IrpNotCompleted:
    
        //
        // This irp has not been completed, but has been fully processed.
        // we will complete it now
        //
        P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
        break;
    
    case IrpForward:
    case IrpNotWmi:
    
        //
        // This irp is either not a WMI irp or is a WMI irp targetted
        // at a device lower in the stack.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(pDevExt->ParentDeviceObject, Irp);
        break;
                                    
    default:

        //
        // We really should never get here, but if we do just forward....
        //
        ASSERT(FALSE);
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(pDevExt->ParentDeviceObject, Irp);
        break;
    }
    
    return status;

}

//
// This is our callback routine that WMI calls when it wants to find out
//   information about the data blocks and/or events that the device provides.
//
NTSTATUS
PptWmiQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  PDevObj, 
    OUT PULONG          PRegFlags,
    OUT PUNICODE_STRING PInstanceName,
    OUT PUNICODE_STRING *PRegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo 
)
{
    PFDO_EXTENSION devExt = PDevObj->DeviceExtension;

    UNREFERENCED_PARAMETER( PInstanceName );
    UNREFERENCED_PARAMETER( MofResourceName );

    PAGED_CODE();

    DD((PCE)devExt,DDT,"wmi::PptWmiQueryWmiRegInfo\n");
    
    *PRegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *PRegistryPath = &RegistryPath;
    *Pdo           = devExt->PhysicalDeviceObject;
    
    return STATUS_SUCCESS;
}

//
// This is our callback routine that WMI calls to query a data block
//
NTSTATUS
PptWmiQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
{
    NTSTATUS          status;
    ULONG             size   = sizeof(PARPORT_WMI_ALLOC_FREE_COUNTS);
    PFDO_EXTENSION devExt = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // Only ever registers 1 instance per guid
    //
#if DBG
    ASSERT(InstanceIndex == 0 && InstanceCount == 1);
#else
    UNREFERENCED_PARAMETER( InstanceCount );
    UNREFERENCED_PARAMETER( InstanceIndex );
#endif
    
    switch (GuidIndex) {
    case PPT_WMI_ALLOC_FREE_COUNTS_GUID_INDEX:

        //
        // Request is for ParPort Alloc and Free Counts
        //
        // If caller's buffer is large enough then return the info, otherwise
        //   tell the caller how large of a buffer is required so they can
        //   call us again with a buffer of sufficient size.
        //
        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        *( (PPARPORT_WMI_ALLOC_FREE_COUNTS)Buffer ) = devExt->WmiPortAllocFreeCounts;
        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;
        break;

    default:

        //
        // Index value larger than our largest supported - invalid request
        //
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest( DeviceObject, Irp, status, size, IO_NO_INCREMENT );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\fdopnp.c ===
#include "pch.h"

VOID
PptDellNationalPC87364WorkAround( PUCHAR EcpController )
{
    PUCHAR  ecr      = EcpController+2;  // generic chipset Extended Control Register
    PUCHAR  eir      = EcpController+3;  // PC87364 chipset Extended Index   Register
    PUCHAR  edr      = EcpController+4;  // PC87364 chipset Extended Data    Register
    ULONG   delay    = 5;                // in microseconds (arbitrary - this seems to work)
    KIRQL   oldIrql;

    //
    // Raise IRQL to prevent BIOS from touching the registers at the
    // same time that we're updating them. This is a complete hack
    // since according to PnP we own the registers, but do it anyway
    // since we know that BIOS touches these same registers.
    //
    KeRaiseIrql( HIGH_LEVEL, &oldIrql );

    KeStallExecutionProcessor( delay );
    P5WritePortUchar( ecr, 0x15 );
    KeStallExecutionProcessor( delay );
    P5WritePortUchar( eir, 0x02 );
    KeStallExecutionProcessor( delay );
    P5WritePortUchar( edr, 0x90 );
    KeStallExecutionProcessor( delay );

    KeLowerIrql( oldIrql );
}

NTSTATUS
PptFdoStartDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_START IRPs.

     - Wait for the bus driver and any drivers beneath 
         us in the driver stack to handle this first.
     - Get, validate, and save the resources given to us by PnP.
     - Assign IDs to and get a count of 1284.3 daisy chain devices
         connected to the port.
     - Determine the capabilities of the chipset (BYTE, EPP, ECP).
     - Set our PnP device interface state to trigger
         an interface arrival callback to anyone listening 
         on our GUID.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS              - on success,
    an appropriate error status - otherwise

--*/
{
    PFDO_EXTENSION  fdx = DeviceObject->DeviceExtension;
    NTSTATUS        status;
    BOOLEAN         foundPort = FALSE;
    BOOLEAN         foundIrq  = FALSE;
    BOOLEAN         foundDma  = FALSE;


    //
    // This IRP must be handled first by the parent bus driver
    //   and then by each higher driver in the device stack.
    //
    status = PptPnpBounceAndCatchPnpIrp(fdx, Irp);
    if( !NT_SUCCESS( status ) && ( status != STATUS_NOT_SUPPORTED ) ) {
        // Someone below us in the driver stack explicitly failed the START.
        goto targetExit;
    }

    //
    // Extract resources from CM_RESOURCE_LIST and save them in our extension.
    //
    status = PptPnpStartScanCmResourceList(fdx, Irp, &foundPort, &foundIrq, &foundDma);
    if( !NT_SUCCESS( status ) ) {
        goto targetExit;
    }

    //
    // Do our resources appear to be valid?
    //
    status = PptPnpStartValidateResources(DeviceObject, foundPort, foundIrq, foundDma);
    if( !NT_SUCCESS( status ) ) {
        goto targetExit;
    }


    //
    // Check if ACPI set a flag for us based on entries in
    // BIOSINFO.INF to indicate that we are running on a Dell machine
    // with an incorrectly programmed National PC87364 SuperIO
    // chipset. If so try to work around the problem here so that the
    // user doesn't need to flash the BIOS to get the parallel port to
    // work.
    //
    // Symptoms of the problem are that the parallel port Data Lines
    // are wedged to all zeros regardless of the setting of the bits
    // in the parallel port data register or the Direction bit in the
    // control register.
    //
    // If the port base address is 0x3BC then this won't work and the
    // user will need to go to Device Manager and change the LPT port
    // resource settings to either 0x378 or 0x278 for the base
    // register address. We believe that ACPI defaults to a port base
    // address of 0x378 so this workaround should generally work.
    //
    {
        ULONG DellNationalPC87364 = 0;

        //
        // Check registry to see if ACPI set the flag based on
        // BIOSINFO.INF to indicate that we should try the workaround.
        //
        PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DellNationalPC87364", &DellNationalPC87364 );

        if( DellNationalPC87364 ) {

            //
            // we have a Dell machine with a National PC87364 chipset
            // and a version of BIOS that we believe doesn't
            // initialize the parallel port so that it works under
            // Win2k or WinXP.
            //

            if( fdx->PnpInfo.SpanOfEcpController > 4 ) {

                //
                // We have the extra Ecp registers needed to try the
                // workaround without stepping on I/O register space
                // owned by someone else.
                //

                if( ( (PUCHAR)0x678 == fdx->PnpInfo.EcpController ) ||
                    ( (PUCHAR)0x778 == fdx->PnpInfo.EcpController ) ) {

                    //
                    // The parallel port base register and ECP
                    // registers are located at one of the two
                    // traditional address ranges: ECP at 0x400 offset
                    // from base register address of 0x278 or 0x378,
                    // so let's try the workaround to try to unwedge
                    // the port data lines.
                    //

                    PptDellNationalPC87364WorkAround( fdx->PnpInfo.EcpController );
                }
            }
        }

    } // end new block scope for Dell/National chipset workaround


    //
    // Initialize the IEEE 1284.3 "bus" by assigning IDs [0..3] to 
    //   the 1284.3 daisy chain devices connected to the port. This
    //   function also gives us a count of the number of such 
    //   devices connected to the port.
    //
    fdx->PnpInfo.Ieee1284_3DeviceCount = PptInitiate1284_3( fdx );
    
    //
    // Determine the hardware modes supported (BYTE, ECP, EPP) by
    //   the parallel port chipset and save this information in our extension.
    //

    // Check to see if the filter parchip is there and use the modes it can set
    status = PptDetectChipFilter( fdx );

    // if filter driver was not found use our own generic port detection
    if ( !NT_SUCCESS( status ) ) {
        PptDetectPortType( fdx );
    }

    
    //
    // Register w/WMI
    //
    status = PptWmiInitWmi( DeviceObject );
    if( !NT_SUCCESS( status ) ) {
        goto targetExit;
    }


    //
    // Signal those who registered for PnP interface change notification 
    //   on our GUID that we have STARTED (trigger an INTERFACE_ARRIVAL
    //   PnP callback).
    //
    status = IoSetDeviceInterfaceState( &fdx->DeviceInterface, TRUE );
    if( !NT_SUCCESS(status) ) {
        status = STATUS_NOT_SUPPORTED;
    } else {
        fdx->DeviceInterfaceState = TRUE;
    }

targetExit:

    if( NT_SUCCESS( status ) ) {

        // 
        // Note in our extension that we have successfully STARTED.
        //
        ExAcquireFastMutex( &fdx->ExtensionFastMutex );
        PptSetFlags( fdx->PnpState, PPT_DEVICE_STARTED );
        ExReleaseFastMutex( &fdx->ExtensionFastMutex );

        // create warm poll thread to poll for printer arrivals
        if( NULL == fdx->ThreadObjectPointer ) {

            ULONG DisableWarmPoll;

            fdx->PollingFailureCounter = 0; // reset counter

            // check for registry flag to disable "polling for printers"
            DisableWarmPoll = 0;      // if non-zero then do not poll for printer arrivals
            PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DisableWarmPoll", &DisableWarmPoll );

            if( 0 == DisableWarmPoll ) {

                // how frequently should we check for printer arrivals? (in seconds)
                // (WarmPollPeriod is a driver global)
                PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"WarmPollPeriod", &WarmPollPeriod );
                if( WarmPollPeriod < 5 ) {
                    WarmPollPeriod = 5;
                } else {
                    if( WarmPollPeriod > 20 ) {
                        WarmPollPeriod = 20;
                    }
                }
                DD((PCE)fdx,DDT,"P5FdoThread - WarmPollPeriod = %d seconds\n",WarmPollPeriod);
            
                // side effect: set fdx->ThreadObjectPointer on SUCCESS
                P5FdoCreateThread( fdx );
            }

        }

    }

    P4CompleteRequest( Irp, status, 0 );

    PptReleaseRemoveLock( &fdx->RemoveLock, Irp );

    return status;
}


NTSTATUS
PptFdoQueryRemove(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_QUERY_REMOVE_DEVICE.

    FAIL the request if there are open handles, SUCCEED otherwise.
    
    This function is identical to PptPnpQueryStopDevice() except
      for the flag that gets set in fdx->PnpState.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS     - No open handles - SUCCEED IRP
    STATUS_DEVICE_BUSY - Open handles - FAIL IRP

--*/
{
    //
    // Always succeed query - PnP will veto Query Remove on our behalf if 
    //   there are open handles
    //

    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;

    ExAcquireFastMutex( &fdx->ExtensionFastMutex );
    PptSetFlags( fdx->PnpState, ( PPT_DEVICE_REMOVE_PENDING | PPT_DEVICE_PAUSED ) );
    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    Irp->IoStatus.Status = STATUS_SUCCESS;

    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );
}


NTSTATUS
PptFdoRemoveDevice(
    IN PDEVICE_OBJECT Fdo, 
    IN PIRP           Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_REMOVE_DEVICE.

    Notify those listening on our device interface GUID that 
      we have gone away, wait until all other IRPs that the
      device is processing have drained, and clean up.

Arguments:

    Fdo - The target device for the IRP
    Irp          - The IRP

Return Value:

    Status returned from IoCallDriver.

--*/
{
    PFDO_EXTENSION fdx = Fdo->DeviceExtension;
    NTSTATUS          status;

    //
    // clean up any child PDOs that are still here
    //
    if( fdx->RawPortPdo ) {
        PDEVICE_OBJECT pdo = fdx->RawPortPdo;
        DD((PCE)fdx,DDT,"PptFdoRemoveDevice - have RawPortPdo - cleaning up\n");
        P4DestroyPdo( pdo );
        fdx->RawPortPdo = NULL;
    }

    if( fdx->EndOfChainPdo ) {
        PDEVICE_OBJECT pdo = fdx->EndOfChainPdo;
        DD((PCE)fdx,DDT,"PptFdoRemoveDevice - have EndOfChainPdo - cleaning up\n");
        P4DestroyPdo( pdo );
        fdx->EndOfChainPdo = NULL;
    }

    {
        LONG        daisyChainId;
        const LONG  daisyChainMaxId = 1;

        for( daisyChainId = 0 ; daisyChainId <= daisyChainMaxId ; ++daisyChainId ) {

            if( fdx->DaisyChainPdo[ daisyChainId ] ) {
                PDEVICE_OBJECT pdo = fdx->DaisyChainPdo[ daisyChainId ];
                DD((PCE)fdx,DDT,"PptFdoRemoveDevice - have DaisyChainPdo[%d] - cleaning up\n",daisyChainId);
                P4DestroyPdo( pdo );
                fdx->DaisyChainPdo[ daisyChainId ] = NULL;
            }
        }
    }


    //
    // RMT - if fdx->DevDeletionListHead non-empty - clean it up?
    //
    PptAssert( IsListEmpty( &fdx->DevDeletionListHead) );

    //
    // Set flags in our extension to indicate that we have received 
    //   IRP_MN_REMOVE_DEVICE so that we can fail new requests as appropriate.
    //
    ExAcquireFastMutex( &fdx->ExtensionFastMutex );
    PptSetFlags( fdx->PnpState, PPT_DEVICE_REMOVED );
    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    //
    // if we still have a worker thread, kill it
    //
    {
        PVOID threadObjPointer = InterlockedExchangePointer( &fdx->ThreadObjectPointer, NULL );
        
        if( threadObjPointer ) {
            
            // set the flag for the worker thread to kill itself
            fdx->TimeToTerminateThread = TRUE;
            
            // wake thread so it can kill self
            KeSetEvent( &fdx->FdoThreadEvent, 0, TRUE );
            
            // wait for the thread to die
            KeWaitForSingleObject( threadObjPointer, Executive, KernelMode, FALSE, NULL );
            
            // allow the system to release the thread object
            ObDereferenceObject( threadObjPointer );

        }
    }

    //
    // Unregister w/WMI
    //
    IoWMIRegistrationControl(Fdo, WMIREG_ACTION_DEREGISTER);

    //
    // Tell those listening on our device interface GUID that we have
    //   gone away. Ignore status from the call since we can do
    //   nothing on failure.
    //
    IoSetDeviceInterfaceState( &fdx->DeviceInterface, FALSE );
    fdx->DeviceInterfaceState = FALSE;

    //
    // Pass the IRP down the stack and wait for all other IRPs
    //   that are being processed by the device to drain.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( fdx->ParentDeviceObject, Irp );
    PptReleaseRemoveLockAndWait( &fdx->RemoveLock, Irp );

    //
    // Clean up pool allocations
    // 
    RtlFreeUnicodeString( &fdx->DeviceName);
    RtlFreeUnicodeString( &fdx->DeviceInterface );
    if( fdx->PnpInfo.PortName ) {
        ExFreePool( fdx->PnpInfo.PortName );
        fdx->PnpInfo.PortName = NULL;
    }
    if( fdx->Location ) {
        ExFreePool( fdx->Location );
        fdx->Location = NULL;
    }

    //
    // Detach and delete our device object.
    //
    IoDetachDevice( fdx->ParentDeviceObject );
    IoDeleteDevice( Fdo );
    
    return status;
}


NTSTATUS
PptFdoCancelRemove(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_CANCEL_REMOVE_DEVICE.

    If we previously SUCCEEDed a QUERY_REMOVE (PPT_DEVICE_REMOVE_PENDING 
      flag is set) then we reset the appropriate device state flags 
      and resume normal operation. Otherwise treat this as an
      informational message. 

    This function is identical to PptPnpCancelStopDevice() except for
      the fdx->PnpState.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    Status returned from IoCallDriver.

--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;

    ExAcquireFastMutex( &fdx->ExtensionFastMutex );
    if( fdx->PnpState & PPT_DEVICE_REMOVE_PENDING ) {
        PptClearFlags( fdx->PnpState, ( PPT_DEVICE_REMOVE_PENDING | PPT_DEVICE_PAUSED ) );
    }
    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );
}


NTSTATUS
PptFdoStopDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_STOP_DEVICE.

    We previously SUCCEEDed QUERY_STOP. Set flags
      to indicate that we are now STOPPED.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    Status returned from IoCallDriver.

--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;

    ExAcquireFastMutex( &fdx->ExtensionFastMutex );

    //
    // Assert that we are in a STOP_PENDING state.
    //
    ASSERT( fdx->PnpState & PPT_DEVICE_STOP_PENDING );
    ASSERT( fdx->PnpState & PPT_DEVICE_PAUSED );

    //
    // PPT_DEVICE_PAUSED remains set
    //
    PptSetFlags( fdx->PnpState,   PPT_DEVICE_STOPPED );
    PptClearFlags( fdx->PnpState, ( PPT_DEVICE_STOP_PENDING | PPT_DEVICE_STARTED ) );

    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock(fdx, Irp);
}


NTSTATUS
PptFdoQueryStop(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_QUERY_STOP_DEVICE.

    FAIL the request if there are open handles, SUCCEED otherwise.
    
    Other drivers may cache pointers to the parallel port registers that 
      they obtained via IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO and there
      is currently no mechanism to find and inform all such drivers that the 
      parallel port registers have changed and their their cached pointers are 
      now invalid without breaking legacy drivers.

    This function is identical to PptPnpQueryStopDevice() except
      for the flag that gets set in fdx->PnpState.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS     - No open handles - SUCCEED IRP
    STATUS_DEVICE_BUSY - Open handles - FAIL IRP

--*/
{
    NTSTATUS          status       = STATUS_SUCCESS;
    PFDO_EXTENSION fdx    = DeviceObject->DeviceExtension;
    BOOLEAN           handlesOpen;

    //
    // RMT - dvdf - race condition - small timing window - sequence:
    //   1. Test indicates no open handles - decide to SUCCEED QUERY_STOP
    //   2. CREATE arrives and is SUCCEEDED - open handle
    //   3. We SUCCEED QUERY_STOP
    //   4. Client obtains register addresses via IOCTL
    //   5. PnP Rebalances us - registers change
    //   6. Client acquires port via IOCTL
    //   7. Client tries to access registers at pre-rebalance location
    //   8. BOOM!!!
    //

    ExAcquireFastMutex( &fdx->OpenCloseMutex );
    handlesOpen = (BOOLEAN)( fdx->OpenCloseRefCount > 0 );
    ExReleaseFastMutex( &fdx->OpenCloseMutex );

    if( handlesOpen ) {
        
        status = STATUS_DEVICE_BUSY;
        P4CompleteRequest( Irp, status, Irp->IoStatus.Information );
        PptReleaseRemoveLock( &fdx->RemoveLock, Irp );

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        status = PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );

        ExAcquireFastMutex( &fdx->ExtensionFastMutex );
        PptSetFlags( fdx->PnpState, ( PPT_DEVICE_STOP_PENDING | PPT_DEVICE_PAUSED ) );
        ExReleaseFastMutex( &fdx->ExtensionFastMutex );
    }
    
    return status;
}


NTSTATUS
PptFdoCancelStop(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_CANCEL_STOP_DEVICE.

    If we previously SUCCEEDed a QUERY_STOP (PPT_DEVICE_STOP_PENDING 
      flag is set) then we reset the appropriate device state flags 
      and resume normal operation. Otherwise treat this as an
      informational message. 

    This function is identical to PptPnpCancelRemoveDevice() except for
      the fdx->PnpState.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    Status returned from IoCallDriver.

--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;

    ExAcquireFastMutex( &fdx->ExtensionFastMutex );
    if( fdx->PnpState & PPT_DEVICE_STOP_PENDING ) {
        PptClearFlags( fdx->PnpState, ( PPT_DEVICE_STOP_PENDING | PPT_DEVICE_PAUSED ) );
    }
    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );
}


NTSTATUS
PptFdoQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )

/*++

Routine Description:

    This function handles PnP IRP_MN_QUERY_DEVICE_RELATIONS.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS              - on success,
    an appropriate error status - otherwise

--*/
{
    PIO_STACK_LOCATION   irpSp = IoGetCurrentIrpStackLocation( Irp );
    DEVICE_RELATION_TYPE type  = irpSp->Parameters.QueryDeviceRelations.Type;

    if( BusRelations == type ) {
        return PptFdoHandleBusRelations( DeviceObject, Irp );
    } else {
        return PptPnpPassThroughPnpIrpAndReleaseRemoveLock(DeviceObject->DeviceExtension, Irp);
    }
}


NTSTATUS
PptFdoFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_FILTER_RESOURCE_REQUIREMENTS IRPs.

     - Wait for the bus driver and any drivers beneath 
         us in the driver stack to handle this first.
     - Query the registry to find the type of filtering desired.
     - Filter out IRQ resources as specified by the registry setting.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS              - on success,
    an appropriate error status - otherwise

--*/
{
    PFDO_EXTENSION              fdx               = DeviceObject->DeviceExtension;
    ULONG                          filterResourceMethod    = PPT_FORCE_USE_NO_IRQ;
    PIO_RESOURCE_REQUIREMENTS_LIST pResourceRequirementsIn;
    NTSTATUS                       status;


    //
    // DDK Rule: Add on the way down, modify on the way up. We are modifying
    //   the resource list so let the drivers beneath us handle this IRP first.
    //
    status    = PptPnpBounceAndCatchPnpIrp(fdx, Irp);
    if( !NT_SUCCESS(status) && (status != STATUS_NOT_SUPPORTED) ) {
        // Someone below us in the driver stack explicitly failed the IRP.
        goto targetExit;
    }


    //
    // Find the "real" resource requirments list, either the PnP list
    //   or the list created by another driver in the stack.
    //
    if ( Irp->IoStatus.Information == 0 ) {
        //
        // No one else has created a new resource list. Use the original 
        //   list from the PnP Manager.
        //
        PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation( Irp );
        pResourceRequirementsIn = IrpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;

        if (pResourceRequirementsIn == NULL) {
            //
            // NULL list, nothing to do.
            //
            goto targetExit;
        }

    } else {
        //
        // Another driver has created a new resource list. Use the list that they created.
        //
        pResourceRequirementsIn = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;
    }


    //
    // Check the registry to find out the desired type of resource filtering.
    //
    // The following call sets the default value for filterResourceMethod 
    //   if the registry query fails.
    //
    PptRegGetDeviceParameterDword( fdx->PhysicalDeviceObject,
                                   (PWSTR)L"FilterResourceMethod",
                                   &filterResourceMethod );

    DD((PCE)fdx,DDT,"filterResourceMethod=%x\n",filterResourceMethod);


    //
    // Do filtering based on registry setting.
    //
    switch( filterResourceMethod ) {

    case PPT_FORCE_USE_NO_IRQ: 
        //
        // Registry setting dictates that we should refuse to accept IRQ resources.
        //
        // * This is the default behavior which means that we make the IRQ available 
        //     for legacy net and sound cards that may not work if they cannot get
        //     the IRQ.
        //
        // - If we find a resource alternative that does not contain an IRQ resource
        //     then we remove those resource alternatives that do contain IRQ 
        //     resources from the list of alternatives.
        //
        // - Otherwise we have to play hardball. Since all resource alternatives
        //     contain IRQ resources we simply "nuke" the IRQ resource descriptors
        //     by changing their resource Type from CmResourceTypeInterrupt to
        //     CmResourceTypeNull.
        //

        DD((PCE)fdx,DDT,"PPT_FORCE_USE_NO_IRQ\n");

        if( PptPnpFilterExistsNonIrqResourceList( pResourceRequirementsIn ) ) {

            DD((PCE)fdx,DDT,"Found Resource List with No IRQ - Filtering\n");
            PptPnpFilterRemoveIrqResourceLists( pResourceRequirementsIn );

        } else {

            DD((PCE)fdx,DDT,"Did not find Resource List with No IRQ - Nuking IRQ resource descriptors\n");
            PptPnpFilterNukeIrqResourceDescriptorsFromAllLists( pResourceRequirementsIn );

        }

        break;


    case PPT_TRY_USE_NO_IRQ: 
        //
        // Registry setting dictates that we should TRY to give up IRQ resources.
        //
        // - If we find a resource alternative that does not contain an IRQ resource
        //     then we remove those resource alternatives that do contain IRQ 
        //     resources from the list of alternatives.
        //
        // - Otherwise we do nothing.
        //

        DD((PCE)fdx,DDT,"PPT_TRY_USE_NO_IRQ\n");
        if( PptPnpFilterExistsNonIrqResourceList(pResourceRequirementsIn) ) {

            DD((PCE)fdx,DDT,"Found Resource List with No IRQ - Filtering\n");
            PptPnpFilterRemoveIrqResourceLists(pResourceRequirementsIn);

        } else {

            // leave the IO resource list as is
            DD((PCE)fdx,DDT,"Did not find Resource List with No IRQ - Do nothing\n");

        }
        break;


    case PPT_ACCEPT_IRQ: 
        //
        // Registry setting dictates that we should NOT filter out IRQ resources.
        //
        // - Do nothing.
        //
        DD((PCE)fdx,DDT,"PPT_ACCEPT_IRQ\n");
        break;


    default:
        //
        // Invalid registry setting. 
        //
        // - Do nothing.
        //
        // RMT dvdf - May be desirable to write an error log entry here.
        //
        DD((PCE)fdx,DDE,"ERROR:IGNORED: bad filterResourceMethod=%x\n", filterResourceMethod);
    }

targetExit:

    //
    // Preserve Irp->IoStatus.Information because it may point to a
    //   buffer and we don't want to cause a memory leak.
    //
    P4CompleteRequest( Irp, status, Irp->IoStatus.Information );

    PptReleaseRemoveLock(&fdx->RemoveLock, Irp);

    return status;
}


NTSTATUS
PptFdoSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    )
/*++dvdf6

Routine Description:

    This function handles PnP IRP_MN_SURPRISE_REMOVAL.

    Set flags accordingly in our extension, notify those 
      listening on our device interface GUID that 
      we have gone away, and pass the IRP down the
      driver stack.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    Status returned from IoCallDriver.

--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;

    //
    // Set flags in our extension to indicate that we have received 
    //   IRP_MN_SURPRISE_REMOVAL so that we can fail new requests 
    //   as appropriate.
    //
    ExAcquireFastMutex( &fdx->ExtensionFastMutex );
    PptSetFlags( fdx->PnpState, PPT_DEVICE_SURPRISE_REMOVED );
    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    //
    // Fail outstanding allocate/select requests for the port
    //
    {
        PIRP                nextIrp;
        KIRQL               cancelIrql;
        
        IoAcquireCancelSpinLock(&cancelIrql);
        
        while( !IsListEmpty( &fdx->WorkQueue ) ) {
                
            nextIrp = CONTAINING_RECORD( fdx->WorkQueue.Blink, IRP, Tail.Overlay.ListEntry );
            nextIrp->Cancel        = TRUE;
            nextIrp->CancelIrql    = cancelIrql;
            nextIrp->CancelRoutine = NULL;
            PptCancelRoutine( DeviceObject, nextIrp );
            
            // PptCancelRoutine() releases the cancel SpinLock so we need to reaquire
            IoAcquireCancelSpinLock( &cancelIrql );
        }
        
        IoReleaseCancelSpinLock( cancelIrql );
    }

    //
    // Tell those listening on our device interface GUID that we have
    //   gone away. Ignore status from the call since we can do
    //   nothing on failure.
    //
    IoSetDeviceInterfaceState( &fdx->DeviceInterface, FALSE );
    fdx->DeviceInterfaceState = FALSE;

    //
    // Succeed, pass the IRP down the stack, and release the RemoveLock.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );
}

NTSTATUS
PptFdoDefaultPnpHandler(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++dvdf8

Routine Description:

    This function is the default handler for PnP IRPs. 
      All PnP IRPs that are not explicitly handled by another 
      routine (via an entry in the PptPnpDispatchFunctionTable[]) are
      handled by this routine.

     - Pass the IRP down the stack to the device below us in the
         driver stack and release our device RemoveLock. 

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS              - on success,
    an appropriate error status - otherwise

--*/
{
    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock(DeviceObject->DeviceExtension, Irp);
}


PDRIVER_DISPATCH 
PptFdoPnpDispatchTable[] =
{ 
    PptFdoStartDevice,                // IRP_MN_START_DEVICE                 0x00
    PptFdoQueryRemove,                // IRP_MN_QUERY_REMOVE_DEVICE          0x01
    PptFdoRemoveDevice,               // IRP_MN_REMOVE_DEVICE                0x02
    PptFdoCancelRemove,               // IRP_MN_CANCEL_REMOVE_DEVICE         0x03
    PptFdoStopDevice,                 // IRP_MN_STOP_DEVICE                  0x04
    PptFdoQueryStop,                  // IRP_MN_QUERY_STOP_DEVICE            0x05
    PptFdoCancelStop,                 // IRP_MN_CANCEL_STOP_DEVICE           0x06
    PptFdoQueryDeviceRelations,       // IRP_MN_QUERY_DEVICE_RELATIONS       0x07
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_INTERFACE              0x08
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_CAPABILITIES           0x09
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_RESOURCES              0x0A
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_DEVICE_TEXT            0x0C
    PptFdoFilterResourceRequirements, // IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
    PptFdoDefaultPnpHandler,          // no such PnP request                 0x0E
    PptFdoDefaultPnpHandler,          // IRP_MN_READ_CONFIG                  0x0F
    PptFdoDefaultPnpHandler,          // IRP_MN_WRITE_CONFIG                 0x10
    PptFdoDefaultPnpHandler,          // IRP_MN_EJECT                        0x11
    PptFdoDefaultPnpHandler,          // IRP_MN_SET_LOCK                     0x12
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_ID                     0x13
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_BUS_INFORMATION        0x15
    PptFdoDefaultPnpHandler,          // IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
    PptFdoSurpriseRemoval,            // IRP_MN_SURPRISE_REMOVAL             0x17
    PptFdoDefaultPnpHandler           // IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
};


NTSTATUS 
PptFdoPnp(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    ) 
{ 
    PFDO_EXTENSION      fdx     = Fdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp   = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS            status;

    // diagnostic
    PptFdoDumpPnpIrpInfo( Fdo, Irp );

    //
    // Acquire RemoveLock to prevent DeviceObject from being REMOVED
    //   while we are using it. If we are unable to acquire the RemoveLock
    //   then the DeviceObject has already been REMOVED.
    //
    status = PptAcquireRemoveLock( &fdx->RemoveLock, Irp);
    if( STATUS_SUCCESS != status ) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }


    //
    // RemoveLock is held. Forward the request to the appropriate handler.
    //
    // Note that the handler must release the RemoveLock prior to returning
    //   control to this function.
    //
    
    if( irpSp->MinorFunction < arraysize(PptFdoPnpDispatchTable) ) {
        return PptFdoPnpDispatchTable[ irpSp->MinorFunction ]( Fdo, Irp );
    } else {
        return PptFdoDefaultPnpHandler( Fdo, Irp );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\hwepp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    epp.c

Abstract:

    This module contains the code to perform all Hardware EPP related tasks.

Author:

    Don Redford - July 30, 1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"


BOOLEAN
ParIsEppHwSupported(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine determines whether or not HW EPP mode is suported
    for either direction by negotiating when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Entering\n");

    // Check to see if the hardware is capable
    if (!(Pdx->HardwareCapabilities & PPT_EPP_PRESENT)) {
        DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Hardware Not Supported Leaving\n");
        return FALSE;
    }

    if (Pdx->BadProtocolModes & EPP_HW) {
        DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Bad Protocol Not Supported Leaving\n");
        return FALSE;
    }
        
    if (Pdx->ProtocolModesSupported & EPP_HW) {
        DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Already Checked Supported Leaving\n");
        return TRUE;
    }

    // Must use HWEPP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEppHwMode (Pdx, FALSE);
    ParTerminateEppHwMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Negotiated Supported Leaving\n");
        Pdx->ProtocolModesSupported |= EPP_HW;
        return TRUE;
    }
   
    DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Not Negotiated Not Supported Leaving\n");
    return FALSE;    
}

NTSTATUS
ParEnterEppHwMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    EPP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    DD((PCE)Pdx,DDT,"ParEnterEppHwMode: Entering\n");

    if ( Pdx->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            DD((PCE)Pdx,DDT,"ParEnterEppHwMode: Calling IeeeEnter1284Mode with DEVICE_ID_REQUEST\n");
            Status = IeeeEnter1284Mode (Pdx, EPP_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            DD((PCE)Pdx,DDT,"ParEnterEppHwMode: Calling IeeeEnter1284Mode\n");
            Status = IeeeEnter1284Mode (Pdx, EPP_EXTENSIBILITY);
        }
    } else {
        DD((PCE)Pdx,DDT,"ParEnterEppHwMode: In UNSAFE_MODE.\n");
        Pdx->Connected = TRUE;
    }
    
    if (NT_SUCCESS(Status)) {
        Status = Pdx->TrySetChipMode ( Pdx->PortContext, ECR_EPP_PIO_MODE );
        
        if (NT_SUCCESS(Status)) {
            DD((PCE)Pdx,DDT,"ParEnterEppHwMode: IeeeEnter1284Mode returned success\n");
            P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
            Pdx->IsIeeeTerminateOk = TRUE;
        } else {
            DD((PCE)Pdx,DDT,"ParEnterEppHwMode: TrySetChipMode returned unsuccessful\n");
            ParTerminateEppHwMode ( Pdx );
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            Pdx->IsIeeeTerminateOk = FALSE;
        }
    } else {
        DD((PCE)Pdx,DDT,"ParEnterEppHwMode: IeeeEnter1284Mode returned unsuccessful\n");
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->IsIeeeTerminateOk = FALSE;
    }
    
    DD((PCE)Pdx,DDT,"ParEnterEppHwMode: Leaving with Status : %x \n", Status);

    return Status; 
}    

VOID
ParTerminateEppHwMode(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Pdx  - The Device Extension which has the parallel port's controller address.

Return Value:

    None.

--*/

{
    DD((PCE)Pdx,DDT,"ParTerminateEppMode: Entering\n");
    Pdx->ClearChipMode( Pdx->PortContext, ECR_EPP_PIO_MODE );
    if ( Pdx->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode ( Pdx );
    } else {
        DD((PCE)Pdx,DDT,"ParTerminateEppMode: In UNSAFE_MODE.\n");
        Pdx->Connected = FALSE;
    }
    DD((PCE)Pdx,DDT,"ParTerminateEppMode: Leaving\n");
    return;    
}

NTSTATUS
ParEppHwWrite(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    Writes data to the peripheral using the EPP using Hardware flow control.
    
Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          wPortEPP;
    PUCHAR          pBuffer;
    ULONG           ulongSize = 0;  // represents how many ULONG's we are transfering if enabled
    
    DD((PCE)Pdx,DDT,"ParEppHwWrite: Entering\n");

    wPortEPP    = Pdx->Controller + EPP_OFFSET;
    pBuffer     = Buffer;

    P5SetPhase( Pdx, PHASE_FORWARD_XFER );
    
    // Check to see if hardware supports 32 bit reads and writes
    if ( Pdx->HardwareCapabilities & PPT_EPP_32_PRESENT ) {
        if ( !(BufferSize % 4) )
            ulongSize = BufferSize >> 2;
    }

    // ulongSize != 0 so EPP 32 bit is enabled and Buffersize / 4
    if ( ulongSize ) {
        WRITE_PORT_BUFFER_ULONG( (PULONG)wPortEPP,
                                 (PULONG)pBuffer,
                                 ulongSize );
    } else {
        P5WritePortBufferUchar( wPortEPP,
                                 (PUCHAR)pBuffer,
                                 BufferSize );
    }

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    *BytesTransferred = BufferSize;

    DD((PCE)Pdx,DDT,"ParEppHwWrite: Leaving with %i Bytes Transferred\n", BufferSize);
    
    return STATUS_SUCCESS;
}

NTSTATUS
ParEppHwRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 EPP mode read under software control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          wPortEPP;
    PUCHAR          pBuffer;
    ULONG           ulongSize = 0;  // represents how many ULONG's we are transfering if enabled
    
    DD((PCE)Pdx,DDT,"ParEppHwRead: Entering\n");

    wPortEPP    = Pdx->Controller + EPP_OFFSET;
    pBuffer     = Buffer;
    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
    
    // Check to see if hardware supports 32 bit reads and writes
    if ( Pdx->HardwareCapabilities & PPT_EPP_32_PRESENT ) {
        if ( !(BufferSize % 4) )
            ulongSize = BufferSize >> 2;
    }

    // ulongSize != 0 so EPP 32 bit is enabled and Buffersize / 4
    if ( ulongSize ) {
        READ_PORT_BUFFER_ULONG( (PULONG)wPortEPP,
                                (PULONG)pBuffer,
                                ulongSize );
    } else {
        P5ReadPortBufferUchar( wPortEPP,
                                (PUCHAR)pBuffer,
                                BufferSize );
    }

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    *BytesTransferred = BufferSize;

    DD((PCE)Pdx,DDT,"ParEppHwRead: Leaving with %i Bytes Transferred\n", BufferSize);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\hwecp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 2000

Module Name:

    hwecp.c

Abstract:

    This module contains code for the host to utilize HardwareECP if it has been
    detected and successfully enabled.

Author:

    Robbie Harris (Hewlett-Packard) 21-May-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

VOID 
ParCleanupHwEcpPort(
    IN PPDO_EXTENSION  Pdx
)
/*++

Routine Description:

   Cleans up prior to a normal termination from ECP mode.  Puts the
   port HW back into Compatibility mode.

Arguments:

   Controller  - Supplies the parallel port's controller address.

Return Value:

   None.

--*/
{
    //----------------------------------------------------------------------
    // Set the ECR to mode 001 (PS2 Mode).
    //----------------------------------------------------------------------
    Pdx->ClearChipMode( Pdx->PortContext, ECR_ECP_PIO_MODE );
    Pdx->PortHWMode = HW_MODE_PS2;
    
    ParCleanupSwEcpPort(Pdx);

    //----------------------------------------------------------------------
    // Set the ECR to mode 000 (Compatibility Mode).
    //----------------------------------------------------------------------
    Pdx->PortHWMode = HW_MODE_COMPATIBILITY;
}

// Drain data from Shadow Buffer
VOID PptEcpHwDrainShadowBuffer(
    IN  Queue  *pShadowBuffer,
    IN  PUCHAR  lpsBufPtr,
    IN  ULONG   dCount,
    OUT ULONG  *fifoCount)
{
    *fifoCount = 0;
    
    if( Queue_IsEmpty( pShadowBuffer ) ) {
        return;
    }

    while( dCount > 0 ) {
        // Break out the Queue_Dequeue from the pointer increment so we can
        // observe the data if needed.
        if( FALSE == Queue_Dequeue( pShadowBuffer, lpsBufPtr ) ) {  // Get byte from queue.
            return;
        }
        ++lpsBufPtr;
        --dCount;                       // Decrement count.
        ++(*fifoCount);
    }
}

//============================================================================
// NAME:    HardwareECP::EmptyFIFO()
//  
//      Empties HW FIFO into a shadow buffer.  This must be done before
//      turning the direction from reverse to forward, if the printer has
//      stuffed data in that no one has read yet.
//
// PARAMETERS: 
//      Controller      - Supplies the base address of the parallel port.
//
// RETURNS: STATUS_SUCCESS or ....
//
// NOTES:
//      Called ZIP_EmptyFIFO in the original 16 bit code.
//
//============================================================================
NTSTATUS ParEcpHwEmptyFIFO(IN  PPDO_EXTENSION   Pdx)
{
    NTSTATUS   nError = STATUS_SUCCESS;
    Queue      *pShadowBuffer;
    UCHAR      bData;
    PUCHAR     wPortDFIFO = Pdx->EcrController;  // IO address of ECP Data FIFO
    PUCHAR     wPortECR = Pdx->EcrController + ECR_OFFSET;    // IO address of Extended Control Register (ECR)
    
    // While data exists in the FIFO, read it and put it into shadow buffer.
    // If the shadow buffer fills up before the FIFO is exhausted, an
    // error condition exists.

    pShadowBuffer = &(Pdx->ShadowBuffer);

#if 1 == DBG_SHOW_BYTES
    if( DbgShowBytes ) {
        DbgPrint("r: ");
    }
#endif

    while ((P5ReadPortUchar(wPortECR) & ECR_FIFO_EMPTY) == 0 ) {
        // Break out the Port Read so we can observe the data if needed
        bData = P5ReadPortUchar(wPortDFIFO);

#if 1 == DBG_SHOW_BYTES
        if( DbgShowBytes ) {
            DbgPrint("%02x ",bData);
        }
#endif

        // Put byte in queue.
        if (FALSE == Queue_Enqueue(pShadowBuffer, bData)) {
            DD((PCE)Pdx,DDT,"ParEcpHwEmptyFIFO - Shadow buffer full, FIFO not empty\n");
            nError = STATUS_BUFFER_OVERFLOW;
            goto ParEcpHwEmptyFIFO_ExitLabel;
        }
    }
    
#if 1 == DBG_SHOW_BYTES
    if( DbgShowBytes ) {
        DbgPrint("zz\n");
    }
#endif

    if( ( !Queue_IsEmpty(pShadowBuffer) && (Pdx->P12843DL.bEventActive) )) {
        KeSetEvent(Pdx->P12843DL.Event, 0, FALSE);
    }

ParEcpHwEmptyFIFO_ExitLabel:
    return nError;
}

//=========================================================
// HardwareECP::ExitForwardPhase
//
// Description : Exit from HWECP Forward Phase to the common phase (FWD IDLE, PS/2)
//
//=========================================================
NTSTATUS ParEcpHwExitForwardPhase( IN  PPDO_EXTENSION  Pdx )
{
    NTSTATUS status;

    DD((PCE)Pdx,DDT,"ParEcpHwExitForwardPhase\n");
    
    // First, there could be data in the FIFO.  Wait for it to empty
    // and then put the bus in the common state (PHASE_FORWARD_IDLE with
    // ECRMode set to PS/2
    status = ParEcpHwWaitForEmptyFIFO( Pdx );

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    return status;
}	

//=========================================================
// HardwareECP::EnterReversePhase
//
// Description : Go from the common phase to HWECP Reverse Phase
//
//=========================================================
NTSTATUS PptEcpHwEnterReversePhase( IN  PPDO_EXTENSION   Pdx )
{
    NTSTATUS status;
    PUCHAR Controller;
    PUCHAR wPortECR;       // I/O address of Extended Control Register
    PUCHAR wPortDCR;       // I/O address of Device Control Register
    UCHAR  dcr;
    
    Controller = Pdx->Controller;
    wPortECR   = Pdx->EcrController + ECR_OFFSET;
    wPortDCR   = Controller + OFFSET_DCR;


    // EnterReversePhase assumes that we are in PHASE_FORWARD_IDLE,
    // and that the ECPMode is set to PS/2 mode at entry.

    //----------------------------------------------------------------------
    // Set the ECR to mode 001 (PS2 Mode).
    //----------------------------------------------------------------------
    Pdx->ClearChipMode( Pdx->PortContext, ECR_ECP_PIO_MODE );
    
    // We need to be in PS/2 (BiDi) mode in order to disable the host
    //   driving the data lines when we flip the direction bit in the DCR.
    //   This is a requirement for entering ECP state 38 in the 1284 spec.
    //   Changed - 2000-02-11
    status = Pdx->TrySetChipMode( Pdx->PortContext, ECR_BYTE_MODE );
    // ignore status - subsequent operations may still work

    Pdx->PortHWMode = HW_MODE_PS2;

    if ( Pdx->ModeSafety == SAFE_MODE ) {

    	// Reverse the bus first (using ECP::EnterReversePhase)
        status = ParEcpEnterReversePhase(Pdx);
    	if ( NT_SUCCESS(status) ) {
            //----------------------------------------------------------------------
            // Wait for nAckReverse low (ECP State 40)
            //----------------------------------------------------------------------
            if ( !CHECK_DSR(Controller, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL) ) {
                DD((PCE)Pdx,DDT,"PptEcpHwEnterReversePhase: State 40 failed\n");
                status = ParEcpHwRecoverPort( Pdx, RECOVER_28 );
                if ( NT_SUCCESS(status))
                    status = STATUS_LINK_FAILED;
                goto PptEcpHwEnterReversePhase_ExitLabel;
            } else {
                P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
            }
        }
    } else {
        //----------------------------------------------------------------------
        // Set Dir=1 in DCR for reading.
        //----------------------------------------------------------------------
        dcr = P5ReadPortUchar( wPortDCR );     // Get content of DCR.
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
        P5WritePortUchar(wPortDCR, dcr);
    }

    //----------------------------------------------------------------------
    // Set the ECR to mode 011 (ECP Mode).  DmaEnable=0.
    //----------------------------------------------------------------------
    status = Pdx->TrySetChipMode ( Pdx->PortContext, ECR_ECP_PIO_MODE );
    if ( !NT_SUCCESS(status) ) {
        DD((PCE)Pdx,DDT,"PptEcpHwEnterReversePhase - TrySetChipMode failed\n");
    }
    Pdx->PortHWMode = HW_MODE_ECP;

    //----------------------------------------------------------------------
    // Set nStrobe=0 and nAutoFd=0 in DCR, so that ECP HW can control.
    //----------------------------------------------------------------------
    dcr = P5ReadPortUchar( wPortDCR );               // Get content of DCR.
    dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar( wPortDCR, dcr );

    // Set the phase variable to ReverseIdle
    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );

PptEcpHwEnterReversePhase_ExitLabel:

    return status;
}

//=========================================================
// HardwareECP::ExitReversePhase
//
// Description : Get out of HWECP Reverse Phase to the common state
//
//=========================================================
NTSTATUS ParEcpHwExitReversePhase( IN  PPDO_EXTENSION  Pdx )
{
    NTSTATUS nError = STATUS_SUCCESS;
    UCHAR    bDCR;
    UCHAR    bECR;
    PUCHAR   wPortECR;
    PUCHAR   wPortDCR;
    PUCHAR   Controller;

    DD((PCE)Pdx,DDT,"ParEcpHwExitReversePhase - enter\n");
    Controller = Pdx->Controller;
    wPortECR = Pdx->EcrController + ECR_OFFSET;
    wPortDCR = Controller + OFFSET_DCR;

    //----------------------------------------------------------------------
    // Set status byte to indicate Reverse To Forward Mode.
    //----------------------------------------------------------------------
    P5SetPhase( Pdx, PHASE_REV_TO_FWD );
	
    if ( Pdx->ModeSafety == SAFE_MODE ) {

        //----------------------------------------------------------------------
        // Assert nReverseRequest high.  This should stop further data transfer
        // into the FIFO.  [[REVISIT:  does the chip handle this correctly
        // if it occurs in the middle of a byte transfer (states 43-46)??
        // Answer (10/9/95) no, it doesn't!!]]
        //----------------------------------------------------------------------
        bDCR = P5ReadPortUchar(wPortDCR);               // Get content of DCR.
        bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE );
        P5WritePortUchar(wPortDCR, bDCR );

        //----------------------------------------------------------------------
        // Wait for PeriphAck low and PeriphClk high (ECP state 48) together
        // with nAckReverse high (ECP state 49).
        //----------------------------------------------------------------------
        if( !CHECK_DSR(Controller, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE, DEFAULT_RECEIVE_TIMEOUT) ) {
            DD((PCE)Pdx,DDW,"ParEcpHwExitReversePhase: Periph failed state 48/49.\n");
            nError = ParEcpHwRecoverPort( Pdx, RECOVER_37 );   // Reset port.
            if( NT_SUCCESS(nError) ) {
                return STATUS_LINK_FAILED;
            }
            return nError;
        }

        //-----------------------------------------------------------------------
        // Empty the HW FIFO of any bytes that may have already come in.
        // This must be done before changing ECR modes because the FIFO is reset
        // when that occurs.
        //-----------------------------------------------------------------------
        bECR = P5ReadPortUchar(wPortECR);        // Get content of ECR.
        if ((bECR & ECR_FIFO_EMPTY) == 0) {      // Check if FIFO is not empty.
            if( (nError = ParEcpHwEmptyFIFO(Pdx)) != STATUS_SUCCESS ) {
                DD((PCE)Pdx,DDT,"ParEcpHwExitReversePhase: Attempt to empty ECP chip failed.\n");
                return nError;
            }
        }

        //----------------------------------------------------------------------
        // Assert HostAck and HostClk high.  [[REVISIT:  is this necessary? 
        //    should already be high...]]
        //----------------------------------------------------------------------
        bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        P5WritePortUchar(wPortDCR, bDCR );

    } // SAFE_MODE

    //----------------------------------------------------------------------
    // Set the ECR to PS2 Mode so we can change bus direction.
    //----------------------------------------------------------------------
    Pdx->ClearChipMode( Pdx->PortContext, ECR_ECP_PIO_MODE );
    Pdx->PortHWMode = HW_MODE_PS2;


    //----------------------------------------------------------------------
    // Set Dir=0 (Write) in DCR.
    //----------------------------------------------------------------------
    bDCR = P5ReadPortUchar(wPortDCR);
    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
    P5WritePortUchar(wPortDCR, bDCR );


    //----------------------------------------------------------------------
    // Set the ECR back to ECP Mode.  DmaEnable=0.
    //----------------------------------------------------------------------
    nError = Pdx->TrySetChipMode ( Pdx->PortContext, ECR_ECP_PIO_MODE );
    Pdx->PortHWMode = HW_MODE_ECP;


    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    return nError;
}

BOOLEAN
PptEcpHwHaveReadData (
    IN  PPDO_EXTENSION  Pdx
    )
{
    Queue     *pQueue;

    // check shadow buffer
    pQueue = &(Pdx->ShadowBuffer);
    if (!Queue_IsEmpty(pQueue)) {
        return TRUE;
    }

    // check periph
    if (ParEcpHaveReadData(Pdx))
        return TRUE;

    // Check if FIFO is not empty.
    return (BOOLEAN)( (UCHAR)0 == (P5ReadPortUchar(Pdx->EcrController + ECR_OFFSET) & ECR_FIFO_EMPTY) );
}

NTSTATUS
ParEcpHwHostRecoveryPhase(
    IN  PPDO_EXTENSION   Pdx
    )
{
    NTSTATUS  status = STATUS_SUCCESS;
    PUCHAR    pPortDCR;       // I/O address of Device Control Register
    PUCHAR    pPortDSR;       // I/O address of Device Status Register
    PUCHAR    pPortECR;       // I/O address of Extended Control Register
    UCHAR     bDCR;           // Contents of DCR
    UCHAR     bDSR;           // Contents of DSR

    if( !Pdx->bIsHostRecoverSupported ) {
        return STATUS_SUCCESS;
    }

    DD((PCE)Pdx,DDT,"ParEcpHwHostRecoveryPhase - enter\n");

    // Calculate I/O port addresses for common registers
    pPortDCR = Pdx->Controller + OFFSET_DCR;
    pPortDSR = Pdx->Controller + OFFSET_DSR;
    pPortECR = Pdx->EcrController + ECR_OFFSET;

    // Set the ECR to mode 001 (PS2 Mode)
    // Don't need to flip to Byte mode.  The ECR arbitrator will handle this.
    Pdx->PortHWMode = HW_MODE_PS2;
    
    // Set Dir=1 in DCR to disable host bus drive, because the peripheral may 
    // try to drive the bus during host recovery phase.  We are not really going
    // to let any data handshake across, because we don't set HostAck low, and
    // we don't enable the ECP chip during this phase.
    bDCR = P5ReadPortUchar(pPortDCR);               // Get content of DCR.
    bDCR = UPDATE_DCR( bDCR, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
    P5WritePortUchar(pPortDCR, bDCR );
    
    // Check the DCR to see if it has been stomped on
    bDCR = P5ReadPortUchar( pPortDCR );
    if( TEST_DCR( bDCR, DIR_WRITE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE ) ) {
        // DCR ok, now test DSR for valid state, ignoring PeriphAck since it could change
        bDSR = P5ReadPortUchar( pPortDSR );
        // 11/21/95 LLL, CGM: change test to look for XFlag high
        if( TEST_DSR( bDSR, DONT_CARE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) ) {
            // Drop ReverseRequest to initiate host recovery
            bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE );
            P5WritePortUchar( pPortDCR, bDCR );
            
            // Wait for nAckReverse response
            // 11/21/95 LLL, CGM: tightened test to include PeriphClk and XFlag.
            //                "ZIP_HRP: state 73, DSR" 
            if( CHECK_DSR( Pdx->Controller, DONT_CARE, ACTIVE, INACTIVE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL) ) {
                // Yes, raise nReverseRequest, HostClk and HostAck (HostAck high so HW can drive)
                bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, ACTIVE );
                P5WritePortUchar( pPortDCR, bDCR );

                // Wait for nAckReverse response
                // 11/21/95 LLL, CGM: tightened test to include XFlag and PeriphClk.
                //         "ZIP_HRP: state 75, DSR"
                if( CHECK_DSR( Pdx->Controller, DONT_CARE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL) ) {
                    // Let the host drive the bus again.
                    bDCR = P5ReadPortUchar(pPortDCR);               // Get content of DCR.
                    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
                    P5WritePortUchar(pPortDCR, bDCR );
                    
                    // Recovery is complete, let the caller decide what to do now
                    status = STATUS_SUCCESS;
                    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
                } else {
                    status = STATUS_IO_TIMEOUT;
                    DD((PCE)Pdx,DDW,"ParEcpHwHostRecoveryPhase - error prior to state 75\n");
                }
            } else {
                status = STATUS_IO_TIMEOUT;
                DD((PCE)Pdx,DDW,"ParEcpHwHostRecoveryPhase - error prior to state 73\n");
            }
        } else {
#if DVRH_BUS_RESET_ON_ERROR
            BusReset(pPortDCR);  // Pass in the dcr address
#endif
            DD((PCE)Pdx,DDT, "ParEcpHwHostRecoveryPhase: VE_LINK_FAILURE \n");
            status = STATUS_LINK_FAILED;
        }
    } else {
        DD((PCE)Pdx,DDW,"ParEcpHwHostRecoveryPhase: VE_PORT_STOMPED\n");
        status = STATUS_DEVICE_PROTOCOL_ERROR;
    }
    
    if (!NT_SUCCESS(status)) {
        // Make sure both HostAck and HostClk are high before leaving
        // Also let the host drive the bus again.
        bDCR = P5ReadPortUchar( pPortDCR );
        bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        P5WritePortUchar( pPortDCR, bDCR );
        
        // [[REVISIT]] pSDCB->wCurrentPhase = PHASE_UNKNOWN;
    }

    // Set the ECR to ECP mode, disable DMA
    status = Pdx->TrySetChipMode ( Pdx->PortContext, ECR_ECP_PIO_MODE );

    Pdx->PortHWMode = HW_MODE_ECP;
    
    DD((PCE)Pdx,DDT,"ParEcpHwHostRecoveryPhase - Exit w/status = %x\n", status);

    return status;
}

NTSTATUS
ParEcpHwRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 ECP mode read under Hardware control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    NTSTATUS  status = STATUS_SUCCESS;
    PUCHAR    lpsBufPtr = (PUCHAR)Buffer;    // Pointer to buffer cast to desired data type
    ULONG     dCount = BufferSize;             // Working copy of caller's original request count
    UCHAR     bDSR;               // Contents of DSR
    UCHAR     bPeriphRequest;     // Calculated state of nPeriphReq signal, used in loop
    PUCHAR    wPortDSR = Pdx->Controller + DSR_OFFSET;
    PUCHAR    wPortECR = Pdx->EcrController + ECR_OFFSET;
    PUCHAR    wPortDFIFO = Pdx->EcrController;
    LARGE_INTEGER   WaitPerByteTimer;
    LARGE_INTEGER   StartPerByteTimer;
    LARGE_INTEGER   EndPerByteTimer;
    BOOLEAN         bResetTimer = TRUE;
    ULONG           wBurstCount;        // Calculated amount of data in FIFO
    UCHAR           ecrFIFO;
    
    WaitPerByteTimer.QuadPart = (35 * 10 * 1000) + KeQueryTimeIncrement();
    
    //----------------------------------------------------------------------
    // Set status byte to indicate Reverse Transfer Phase.
    //----------------------------------------------------------------------
    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
    
    //----------------------------------------------------------------------
    // We've already checked the shadow in ParRead. So go right to the
    // Hardware FIFO and pull more data across.
    //----------------------------------------------------------------------
    KeQueryTickCount(&StartPerByteTimer);   // Start the timer
    
ParEcpHwRead_ReadLoopStart:
    //------------------------------------------------------------------
    // Determine whether the FIFO has any data and respond accordingly
    //------------------------------------------------------------------
    ecrFIFO = (UCHAR)(P5ReadPortUchar(wPortECR) & (UCHAR)ECR_FIFO_MASK);
    
    if (ECR_FIFO_FULL == ecrFIFO) {

        wBurstCount = ( dCount > Pdx->FifoDepth ? Pdx->FifoDepth : dCount );
        dCount -= wBurstCount;
        
        P5ReadPortBufferUchar(wPortDFIFO, lpsBufPtr, wBurstCount);
        lpsBufPtr += wBurstCount;

        bResetTimer = TRUE;

    } else if (ECR_FIFO_SOME_DATA == ecrFIFO) {
        // Read just one byte at a time, since we don't know exactly how much is
        // in the FIFO.
        *lpsBufPtr = P5ReadPortUchar(wPortDFIFO);
        lpsBufPtr++;
        dCount--;

        bResetTimer = TRUE;

    } else {   // ECR_FIFO_EMPTY

        DD((PCE)Pdx,DDW,"ParEcpHwRead - ECR_FIFO_EMPTY - slow or bad periph?\n");
        // Nothing to do. We either have a slow peripheral or a bad peripheral.
        // We don't have a good way to figure out if its bad.  Let's chew up our
        // time and hope for the best.

        bResetTimer = FALSE;

    }   //  ECR_FIFO_EMPTY a.k.a. else clause of (ECR_FIFO_FULL == ecrFIFO)
    
    if (dCount == 0)
        goto ParEcpHwRead_ReadLoopEnd;
    else {

        // Limit the overall time we spend in this loop.
        if (bResetTimer) {
            bResetTimer = FALSE;
            KeQueryTickCount(&StartPerByteTimer);   // Restart the timer
        } else {
            KeQueryTickCount(&EndPerByteTimer);
            if (((EndPerByteTimer.QuadPart - StartPerByteTimer.QuadPart) * KeQueryTimeIncrement()) > WaitPerByteTimer.QuadPart)
                goto ParEcpHwRead_ReadLoopEnd;
        }

    }

 goto ParEcpHwRead_ReadLoopStart;

ParEcpHwRead_ReadLoopEnd:

    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
    
    *BytesTransferred  = BufferSize - dCount;      // Set current count.
    
    Pdx->log.HwEcpReadCount += *BytesTransferred;
    
    if (0 == *BytesTransferred) {
        bDSR = P5ReadPortUchar(wPortDSR);
        bPeriphRequest = (UCHAR)TEST_DSR( bDSR, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE );
        // Only flag a timeout error if the device still said it had data to send.
        if ( bPeriphRequest ) {
            //
            // Periph still says that it has data, but we timed out trying to read the data.
            //
            DD((PCE)Pdx,DDE,"ParEcpHwRead - read timout with nPeriphRequest asserted and no data read - error - STATUS_IO_TIMEOUT\n");
            status = STATUS_IO_TIMEOUT;
            if ((TRUE == Pdx->P12843DL.bEventActive) ) {
                //
                // Signal transport that it should try another read
                //
                KeSetEvent(Pdx->P12843DL.Event, 0, FALSE);
            }
        }
    }

    DD((PCE)Pdx,DDT,"ParEcpHwRead: Exit - status=%x, BytesTransferred[%d] dsr[%02x] dcr[%02x] ecr[%02x]\n",
       status, *BytesTransferred, P5ReadPortUchar(wPortDSR), 
       P5ReadPortUchar(Pdx->Controller + OFFSET_DCR), P5ReadPortUchar(wPortECR));
    
#if 1 == DBG_SHOW_BYTES
    if( DbgShowBytes ) {
        if( NT_SUCCESS( status ) && (*BytesTransferred > 0) ) {
            const ULONG maxBytes = 32;
            ULONG i;
            PUCHAR bytePtr = (PUCHAR)Buffer;
            DbgPrint("R: ");
            for( i=0 ; (i < *BytesTransferred) && (i < maxBytes ) ; ++i ) {
                DbgPrint("%02x ",*bytePtr++);
            }
            if( *BytesTransferred > maxBytes ) {
                DbgPrint("... ");
            }
            DbgPrint("zz\n");
        }
    }
#endif

    return status;
}   // ParEcpHwRead

NTSTATUS
ParEcpHwRecoverPort(
    PPDO_EXTENSION Pdx,
    UCHAR  bRecoverCode
    )
{
    NTSTATUS   status = STATUS_SUCCESS;
    PUCHAR    wPortDCR;       // IO address of Device Control Register (DCR)
    PUCHAR    wPortDSR;       // IO address of Device Status Register (DSR)
    PUCHAR    wPortECR;       // IO address of Extended Control Register (ECR)
    PUCHAR    wPortData;      // IO address of Data Register
    UCHAR    bDCR;           // Contents of DCR
    UCHAR    bDSR;           // Contents of DSR
    UCHAR    bDSRmasked;     // DSR after masking low order bits

    DD((PCE)Pdx,DDT,"ParEcpHwRecoverPort:  enter %d\n", bRecoverCode );

    // Calculate I/O port addresses for common registers
    wPortDCR = Pdx->Controller + OFFSET_DCR;
    wPortDSR = Pdx->Controller + OFFSET_DSR;
    wPortECR = Pdx->EcrController + ECR_OFFSET;
    wPortData = Pdx->Controller + OFFSET_DATA;


    //----------------------------------------------------------------------
    // Check if port is stomped.
    //----------------------------------------------------------------------
    bDCR = P5ReadPortUchar(wPortDCR);               // Get content of DCR.

    if ( ! TEST_DCR( bDCR, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE ) )
    {
        #if DVRH_BUS_RESET_ON_ERROR
            BusReset(wPortDCR);  // Pass in the dcr address
        #endif
        DD((PCE)Pdx,DDE,"ParEcpHwRecoverPort - port stomped\n");
        status = STATUS_DEVICE_PROTOCOL_ERROR;
    }


    //----------------------------------------------------------------------
    // Attempt a termination phase to get the peripheral recovered.
    // Ignore the error return, we've already got that figured out.
    //----------------------------------------------------------------------
    IeeeTerminate1284Mode(Pdx );

    //----------------------------------------------------------------------
    // Set the ECR to PS2 Mode so we can change bus direction.
    //----------------------------------------------------------------------
    Pdx->ClearChipMode( Pdx->PortContext, ECR_ECP_PIO_MODE );
    Pdx->PortHWMode = HW_MODE_PS2;

    //----------------------------------------------------------------------
    // Assert nSelectIn low, nInit high, nStrobe high, and nAutoFd high.
    //----------------------------------------------------------------------
    bDCR = P5ReadPortUchar(wPortDCR);             // Get content of DCR.
    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
    P5WritePortUchar(wPortDCR, bDCR);
    P5WritePortUchar(wPortData, bRecoverCode);      // Output the error ID
    KeStallExecutionProcessor(100);                 // Hold long enough to capture
    P5WritePortUchar(wPortData, 0);                 // Now clear the data lines.


    //----------------------------------------------------------------------
    // Set the ECR to mode 000 (Compatibility Mode).
    //----------------------------------------------------------------------
    // Nothing needs to be done here.
    Pdx->PortHWMode = HW_MODE_COMPATIBILITY;


    //----------------------------------------------------------------------
    // Check for any link errors if nothing bad found yet.
    //----------------------------------------------------------------------
    bDSR = P5ReadPortUchar(wPortDSR);               // Get content of DSR.
    bDSRmasked = (UCHAR)(bDSR | 0x07);              // Set first 3 bits (don't cares).

    if( NT_SUCCESS(status) ) {

        if (bDSRmasked != 0xDF) {

            DD((PCE)Pdx,DDE,"ParEcpHwRecoverPort - DSR Exp value: 0xDF, Act value: 0x%X\n",bDSRmasked);

            // Get DSR again just to make sure...
            bDSR = P5ReadPortUchar(wPortDSR);           // Get content of DSR.
            bDSRmasked = (UCHAR)(bDSR | 0x07);          // Set first 3 bits (don't cares).

            if( (CHKPRNOFF1 == bDSRmasked ) || (CHKPRNOFF2 == bDSRmasked ) ) { // Check for printer off.
                DD((PCE)Pdx,DDW,"ParEcpHwRecoverPort - DSR value: 0x%X, Printer Off\n", bDSRmasked);
                status = STATUS_DEVICE_POWERED_OFF;
            } else {
                if( CHKNOCABLE == bDSRmasked ) {  // Check for cable unplugged.
                    DD((PCE)Pdx,DDW,"ParEcpHwRecoverPort - DSR value: 0x%X, Cable Unplugged\n",bDSRmasked);
                    status = STATUS_DEVICE_NOT_CONNECTED;
                } else {
                    DD((PCE)Pdx,DDW,"ParEcpHwRecoverPort - DSR value: 0x%X, Unknown error\n",bDSRmasked);
                    status = STATUS_LINK_FAILED;
                }
            }
        }
    }

    //----------------------------------------------------------------------
    // Set status byte to indicate Compatibility Mode.
    //----------------------------------------------------------------------
    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    return status;

}   // ParEcpHwRecoverPort

NTSTATUS
ParEcpHwSetAddress(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Address
    )

/*++

Routine Description:

    Sets the ECP Address.
    
Arguments:

    Pdx           - Supplies the device extension.

    Address             - The bus address to be set.
    
Return Value:

    None.

--*/
{
    NTSTATUS   status = STATUS_SUCCESS;
    PUCHAR    wPortDSR;       // IO address of Device Status Register
    PUCHAR    wPortECR;       // IO address of Extended Control Register
    PUCHAR    wPortAFIFO;     // IO address of ECP Address FIFO
    UCHAR    bDSR;           // Contents of DSR
    UCHAR    bECR;           // Contents of ECR
    BOOLEAN    bDone;

    DD((PCE)Pdx,DDT,"ParEcpHwSetAddress, Start\n");

    // Calculate I/O port addresses for common registers
    wPortDSR = Pdx->Controller + DSR_OFFSET;
    wPortECR = Pdx->EcrController + ECR_OFFSET;
    wPortAFIFO = Pdx->Controller + AFIFO_OFFSET;

    //----------------------------------------------------------------------
    // Check for any link errors.
    //----------------------------------------------------------------------
    //ZIP_CHECK_PORT( DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE,
    //                "ZIP_SCA: init DCR", RECOVER_40, errorExit );

    //ZIP_CHECK_LINK( DONT_CARE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE,
    //                "ZIP_SCA: init DSR", RECOVER_41, errorExit );


    // Set state to indicate ECP forward transfer phase
    P5SetPhase( Pdx, PHASE_FORWARD_XFER );


    //----------------------------------------------------------------------
    // Send ECP channel address to AFIFO.
    //----------------------------------------------------------------------
    if ( ! ( TEST_ECR_FIFO( P5ReadPortUchar( wPortECR), ECR_FIFO_EMPTY ) ? TRUE : 
             CheckPort( wPortECR, ECR_FIFO_MASK, ECR_FIFO_EMPTY, IEEE_MAXTIME_TL ) ) ) {

        status = ParEcpHwHostRecoveryPhase(Pdx);
        DD((PCE)Pdx,DDT,"ParEcpHwSetAddress: FIFO full, timeout sending ECP channel address\n");
        status = STATUS_IO_DEVICE_ERROR;

    } else {

        // Send the address byte.  The most significant bit must be set to distinquish
        // it as an address (as opposed to a run-length compression count).
        P5WritePortUchar(wPortAFIFO, (UCHAR)(Address | 0x80));
    }

    if ( NT_SUCCESS(status) ) {

        // If there have been no previous errors, and synchronous writes
        // have been requested, wait for the FIFO to empty and the device to
        // complete the last PeriphAck handshake before returning success.

        if ( Pdx->bSynchWrites ) {

            LARGE_INTEGER   Wait;
            LARGE_INTEGER   Start;
            LARGE_INTEGER   End;

            // we wait up to 35 milliseconds.
            Wait.QuadPart = (IEEE_MAXTIME_TL * 10 * 1000) + KeQueryTimeIncrement();  // 35ms

            KeQueryTickCount(&Start);

            bDone = FALSE;
            while ( ! bDone )
            {
                bECR = P5ReadPortUchar( wPortECR );
                bDSR = P5ReadPortUchar( wPortDSR );
                // LLL/CGM 10/9/95: Tighten up link test - PeriphClk high
                if ( TEST_ECR_FIFO( bECR, ECR_FIFO_EMPTY ) &&
                     TEST_DSR( bDSR, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) ) {
                    bDone = TRUE;

                } else {

                    KeQueryTickCount(&End);

                    if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart) {
                        DD((PCE)Pdx,DDT,"ParEcpHwSetAddress, timeout during synch\n");
                        bDone = TRUE;
                        status = ParEcpHwHostRecoveryPhase(Pdx);
                        status = STATUS_IO_DEVICE_ERROR;
                    }

                }

            } // of while...

        } // if bSynchWrites...

    }

    if ( NT_SUCCESS(status) ) {
        // Update the state to reflect that we are back in an idle phase
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    } else if ( status == STATUS_IO_DEVICE_ERROR ) {
        // Update the state to reflect that we are back in an idle phase
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    }       

    return status;
}

NTSTATUS
ParEcpHwSetupPhase(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine performs 1284 Setup Phase.

Arguments:

    Controller      - Supplies the port address.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS   Status = STATUS_SUCCESS;
    PUCHAR    pPortDCR;       // IO address of Device Control Register (DCR)
    PUCHAR    pPortDSR;       // IO address of Device Status Register (DSR)
    PUCHAR    pPortECR;       // IO address of Extended Control Register (ECR)
    UCHAR    bDCR;           // Contents of DCR

    // Calculate I/O port addresses for common registers
    pPortDCR = Pdx->Controller + OFFSET_DCR;
    pPortDSR = Pdx->Controller + OFFSET_DSR;
    pPortECR = Pdx->EcrController + ECR_OFFSET;

    // Get the DCR and make sure port hasn't been stomped
    //ZIP_CHECK_PORT( DIR_WRITE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE,
    //                "ZIP_SP: init DCR", RECOVER_44, exit1 );


    // Set HostAck low
    bDCR = P5ReadPortUchar(pPortDCR);               // Get content of DCR.
    bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE );
    P5WritePortUchar( pPortDCR, bDCR );

    // for some reason dvdr doesn't want an extra check in UNSAFE_MODE
    if ( Pdx->ModeSafety == SAFE_MODE ) {
        // Wait for nAckReverse to go high
        // LLL/CGM 10/9/95:  look for PeriphAck low, PeriphClk high as per 1284 spec.
        if ( !CHECK_DSR(Pdx->Controller, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE,
                        IEEE_MAXTIME_TL ) )
        {
            // Any failure leaves us in an unknown state to recover from.
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            Status = STATUS_IO_DEVICE_ERROR;
            goto HWECP_SetupPhaseExitLabel;
        }
    }

    //----------------------------------------------------------------------
    // Set the ECR to mode 001 (PS2 Mode).
    //----------------------------------------------------------------------
    Status = Pdx->TrySetChipMode ( Pdx->PortContext, ECR_ECP_PIO_MODE );            
    // Set DCR:  DIR=0 for output, HostAck and HostClk high so HW can drive
    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
    P5WritePortUchar( pPortDCR, bDCR );

    // Set the ECR to ECP mode, disable DMA

    Pdx->PortHWMode = HW_MODE_ECP;

    // If setup was successful, mark the new ECP phase.
    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    Status = STATUS_SUCCESS;

HWECP_SetupPhaseExitLabel:

    DD((PCE)Pdx,DDT,"ParEcpHwSetupPhase - exit w/status=%x\n",Status);

    return Status;
}

NTSTATUS ParEcpHwWaitForEmptyFIFO(IN PPDO_EXTENSION   Pdx)
/*++

Routine Description:

    This routine will babysit the Fifo.

Arguments:

    Pdx  - The device extension.

Return Value:

    NTSTATUS.

--*/
{
    UCHAR           bDSR;         // Contents of DSR
    UCHAR           bECR;         // Contents of ECR
    UCHAR           bDCR;         // Contents of ECR
    BOOLEAN         bDone = FALSE;
    PUCHAR          wPortDSR;
    PUCHAR          wPortECR;
    PUCHAR          wPortDCR;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    NTSTATUS        status = STATUS_SUCCESS;

    // Calculate I/O port addresses for common registers 
    wPortDSR = Pdx->Controller + OFFSET_DSR;
    wPortECR = Pdx->EcrController + ECR_OFFSET;
    wPortDCR = Pdx->Controller + OFFSET_DCR;

    Wait.QuadPart = (330 * 10 * 1000) + KeQueryTimeIncrement();  // 330ms
    
    KeQueryTickCount(&Start);

    //--------------------------------------------------------------------
    // wait for the FIFO to empty and the last
    // handshake of PeriphAck to complete before returning success.
    //--------------------------------------------------------------------

    while ( ! bDone )
    {
        bECR = P5ReadPortUchar(wPortECR);
        bDSR = P5ReadPortUchar(wPortDSR);
        bDCR = P5ReadPortUchar(wPortDCR);
        
#if 0 // one bit differs - keep alternate around until we know which to really use
        if ( TEST_ECR_FIFO( bECR, ECR_FIFO_EMPTY ) &&
            TEST_DCR( bDCR, INACTIVE, ***INACTIVE***, ACTIVE, ACTIVE, DONT_CARE, ACTIVE ) &&
            TEST_DSR( bDSR, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) )  {
#else
        if ( TEST_ECR_FIFO( bECR, ECR_FIFO_EMPTY ) &&
            TEST_DCR( bDCR, INACTIVE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, ACTIVE ) &&
            TEST_DSR( bDSR, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) )  {
#endif
            
            // FIFO is empty, exit without error.
            bDone = TRUE;

        } else {
        
            KeQueryTickCount(&End);
            
            if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart) {
                
                // FIFO not empty, timeout occurred, exit with error.
                // NOTE: There is not a good way to determine how many bytes
                // are stuck in the fifo
                DD((PCE)Pdx,DDT,"ParEcpHwWaitForEmptyFIFO: timeout during synch\n");
                status = STATUS_IO_TIMEOUT;
                bDone = TRUE;
            }
        }
     } // of while...
     
     return status;
}

NTSTATUS
ParEcpHwWrite(
    IN  PPDO_EXTENSION  Pdx,
    IN  PVOID           Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          BytesTransferred
    )
/*++

Routine Description:

    Writes data to the peripheral using the ECP protocol under hardware
    control.
    
Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          wPortDSR;
    PUCHAR          wPortECR;
    PUCHAR          wPortDFIFO;
    ULONG           bytesToWrite = BufferSize;
    UCHAR           dsr;
    UCHAR           ecr;
    UCHAR           ecrFIFO;
    LARGE_INTEGER   WaitPerByteTimer;
    LARGE_INTEGER   StartPerByteTimer;
    LARGE_INTEGER   EndPerByteTimer;
    BOOLEAN         bResetTimer = TRUE;
    ULONG           wBurstCount;    // Length of burst to write when FIFO empty
    PUCHAR          pBuffer;
    NTSTATUS        status = STATUS_SUCCESS;
    
    wPortDSR   = Pdx->Controller + DSR_OFFSET;
    wPortECR   = Pdx->EcrController + ECR_OFFSET;
    wPortDFIFO = Pdx->EcrController;
    pBuffer    = Buffer;

    status = ParTestEcpWrite(Pdx);
    if (!NT_SUCCESS(status)) {
        P5SetPhase( Pdx, PHASE_UNKNOWN );                     
        Pdx->Connected = FALSE;                                
        DD((PCE)Pdx,DDT,"ParEcpHwWrite: Invalid Entry State\n");
        goto ParEcpHwWrite_ExitLabel;       // Use a goto so we can see Debug info located at the end of proc!
    }

    P5SetPhase( Pdx, PHASE_FORWARD_XFER );
    //----------------------------------------------------------------------
    // Setup Timer Stuff.
    //----------------------------------------------------------------------
    // we wait up to 35 milliseconds.
    WaitPerByteTimer.QuadPart = (35 * 10 * 1000) + KeQueryTimeIncrement();  // 35ms

    // Set up the timer that limits the time allowed for per-byte handshakes.
    KeQueryTickCount(&StartPerByteTimer);
    
    //----------------------------------------------------------------------
    // Send the data to the DFIFO.
    //----------------------------------------------------------------------

HWECP_WriteLoop_Start:

    //------------------------------------------------------------------
    // Determine whether the FIFO has space and respond accordingly.
    //------------------------------------------------------------------
    ecrFIFO = (UCHAR)(P5ReadPortUchar(wPortECR) & ECR_FIFO_MASK);

    if ( ECR_FIFO_EMPTY == ecrFIFO ) {
        wBurstCount = (bytesToWrite > Pdx->FifoDepth) ? Pdx->FifoDepth : bytesToWrite;
        bytesToWrite -= wBurstCount;
        
        P5WritePortBufferUchar(wPortDFIFO, pBuffer, wBurstCount);
        pBuffer += wBurstCount;
        
        bResetTimer = TRUE;
    } else if (ECR_FIFO_SOME_DATA == ecrFIFO) {
        // Write just one byte at a time, since we don't know exactly how much
        // room there is in the FIFO.
        P5WritePortUchar(wPortDFIFO, *pBuffer++);
        bytesToWrite--;
        bResetTimer = TRUE;
    } else {    //  ECR_FIFO_FULL
        // Need to figure out whether to keep attempting to send, or to quit
        // with a timeout status.
        
        // Reset the per-byte timer if a byte was received since the last
        // timer check.
        if ( bResetTimer ) {
            KeQueryTickCount(&StartPerByteTimer);
            bResetTimer = FALSE;
        }
        
        KeQueryTickCount(&EndPerByteTimer);
        if ((EndPerByteTimer.QuadPart - StartPerByteTimer.QuadPart) * KeQueryTimeIncrement() > WaitPerByteTimer.QuadPart) {
            status = STATUS_TIMEOUT;
            // Peripheral is either busy or stalled.  If the peripheral
            // is busy then they should be using SWECP to allow for
            // relaxed timings.  Let's punt!
            goto HWECP_WriteLoop_End;
        }
    }

    if (bytesToWrite == 0) {
        goto HWECP_WriteLoop_End; // Transfer completed.
    }

    goto HWECP_WriteLoop_Start; // Start over
    
HWECP_WriteLoop_End:

    if ( NT_SUCCESS(status) ) {
        // If there have been no previous errors, and synchronous writes
        // have been requested, wait for the FIFO to empty and the last
        // handshake of PeriphAck to complete before returning success.
        if (Pdx->bSynchWrites ) {
            BOOLEAN         bDone = FALSE;
            

            KeQueryTickCount(&StartPerByteTimer);

            while( !bDone ) {
                ecr = P5ReadPortUchar(wPortECR);
                dsr = P5ReadPortUchar(wPortDSR);
                // LLL/CGM 10/9/95: tighten up DSR test - PeriphClk should be high
                if ( TEST_ECR_FIFO( ecr, ECR_FIFO_EMPTY ) &&
                     TEST_DSR( dsr, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) ) {
                    // FIFO is empty, exit without error.
                    bDone = TRUE;
                } else {

                    KeQueryTickCount(&EndPerByteTimer);
                    if ((EndPerByteTimer.QuadPart - StartPerByteTimer.QuadPart) * KeQueryTimeIncrement() > WaitPerByteTimer.QuadPart) {
                        // FIFO not empty, timeout occurred, exit with error.
                        status = STATUS_TIMEOUT;
                        bDone = TRUE;
                    }
                }
            } // of while...
        }
    }

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

ParEcpHwWrite_ExitLabel:

    *BytesTransferred = BufferSize - bytesToWrite;
    
    Pdx->log.HwEcpWriteCount += *BytesTransferred;
    
    DD((PCE)Pdx,DDT,"ParEcpHwWrite: exit w/status=%x, BytesTransferred=%d, dsr=%02x dcr=%02x, ecr=%02x\n",
       status, *BytesTransferred, P5ReadPortUchar(wPortDSR), P5ReadPortUchar(Pdx->Controller + OFFSET_DCR), P5ReadPortUchar(wPortECR));

#if 1 == DBG_SHOW_BYTES
    if( DbgShowBytes ) {
        if( NT_SUCCESS( status ) && (*BytesTransferred > 0) ) {
            const ULONG maxBytes = 32;
            ULONG i;
            PUCHAR bytePtr = (PUCHAR)Buffer;
            DbgPrint("W: ");
            for( i=0 ; (i < *BytesTransferred) && (i < maxBytes) ; ++i ) {
                DbgPrint("%02x ",*bytePtr++);
            }
            if( *BytesTransferred > maxBytes ) {
                DbgPrint("... ");
            }
            DbgPrint("zz\n");
        }
    }
#endif

    return status;
}

NTSTATUS
ParEnterEcpHwMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    ECP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Controller;

    Controller = Pdx->Controller;

    if ( Pdx->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Pdx, ECP_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Pdx, ECP_EXTENSIBILITY);
        }
    } else {
        Pdx->Connected = TRUE;
    }
    
    // LAC ENTEREXIT  5Dec97
    // Make sure that the ECR is in PS/2 mode, and that wPortHWMode
    // has the correct value.  (This is the common entry mode);
    Pdx->PortHWMode = HW_MODE_PS2;

    if (NT_SUCCESS(Status)) {
        Status = ParEcpHwSetupPhase(Pdx);
        Pdx->bSynchWrites = TRUE;     // NOTE this is a temp hack!!!  dvrh
        if (!Pdx->bShadowBuffer)
        {
            Queue_Create(&(Pdx->ShadowBuffer), Pdx->FifoDepth * 2);		
            Pdx->bShadowBuffer = TRUE;
        }
        Pdx->IsIeeeTerminateOk = TRUE;
    }

    return Status;
}

BOOLEAN
ParIsEcpHwSupported(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the write direction by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    NTSTATUS Status;

    if (Pdx->BadProtocolModes & ECP_HW_NOIRQ)
        return FALSE;

    if (Pdx->ProtocolModesSupported & ECP_HW_NOIRQ)
        return TRUE;

    if (!(Pdx->HardwareCapabilities & PPT_ECP_PRESENT))
        return FALSE;

    if (0 == Pdx->FifoWidth)
        return FALSE;
        
    if (Pdx->ProtocolModesSupported & ECP_SW)
        return TRUE;

    // Must use HWECP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEcpHwMode (Pdx, FALSE);
    ParTerminateHwEcpMode (Pdx);

    if (NT_SUCCESS(Status)) {

        Pdx->ProtocolModesSupported |= ECP_HW_NOIRQ;
        return TRUE;
    }
    return FALSE;
}

VOID
ParTerminateHwEcpMode(
    IN  PPDO_EXTENSION  Pdx
    )
/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{

    // Need to check current phase -- if its reverse, need to flip bus
    // If its not forward -- its an incorrect phase and termination will fail.
    if( Pdx->ModeSafety == SAFE_MODE ) {

        switch( Pdx->CurrentPhase ) {

        case  PHASE_FORWARD_IDLE:  // Legal state to terminate from
            break;

        case PHASE_TERMINATE:      // already terminated, nothing to do
            DD((PCE)Pdx,DDW,"ParTerminateHwEcpMode - Already Terminated - Why are we trying to terminate again?\n");
            goto target_exit;
            break;

        case PHASE_REVERSE_IDLE:   // Flip bus to forward so we can terminate
            {
                NTSTATUS status = ParEcpHwExitReversePhase( Pdx );
            	if( STATUS_SUCCESS == status ) {
                    status = ParEcpEnterForwardPhase( Pdx );
                }
            }
            break;

        case  PHASE_FORWARD_XFER:
        case  PHASE_REVERSE_XFER:
        default:
            DD((PCE)Pdx,DDE,"ParTerminateHwEcpMode - Invalid Phase [%x] for termination\n", Pdx->CurrentPhase);
            // Don't know what to do here!?!
        }

        ParEcpHwWaitForEmptyFIFO( Pdx );

        ParCleanupHwEcpPort( Pdx );

        IeeeTerminate1284Mode( Pdx );

    } else {
        // UNSAFE_MODE
        ParCleanupHwEcpPort(Pdx);
        Pdx->Connected = FALSE;
    }

target_exit:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\ieee1284.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    ieee1284.c

Abstract:

    This module contains the code to do ieee 1284 negotiation and termination.

Author:

    Timothy T. Wells (v-timtw)          13 Mar 97
    Robbie Harris (Hewlett-Packard)     21 May 98.  Added enough comments to the
                                                    Negotation proc to keep any developer happy.

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

VOID
IeeeTerminate1284Mode(
    IN  PPDO_EXTENSION   Pdx
    );

NTSTATUS
IeeeEnter1284Mode(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Extensibility
    );

//
// Definition of the Forward and Reverse Protocol Arrays
//
extern FORWARD_PTCL    afpForward[] = {

    //
    // Bounded ECP (Hardware)
    //
    PptIsBecpSupported,
    PptEnterBecpMode,
    PptTerminateBecpMode,
    ParEcpHwSetAddress,
    ParEcpEnterForwardPhase,           // Enter Forward
    ParEcpHwExitForwardPhase,           // Exit Forward
    ParEcpHwWrite,
    BOUNDED_ECP,
    FAMILY_BECP,             

    //
    // ECP Hardware
    //
    ParIsEcpHwSupported,        // This is resued for both read/write
    ParEnterEcpHwMode,
    ParTerminateHwEcpMode,
    ParEcpHwSetAddress,           
    ParEcpEnterForwardPhase,  // Enter Forward
    ParEcpHwExitForwardPhase,   // Exit Forward
    ParEcpHwWrite,
    ECP_HW_NOIRQ,
    FAMILY_ECP,

    //
    // Epp Hardware
    //
    ParIsEppHwSupported,
    ParEnterEppHwMode,
    ParTerminateEppHwMode,
    ParEppSetAddress,
    NULL,                               // Enter Forward
    NULL,                               // Exit Forward
    ParEppHwWrite,
    EPP_HW,
    FAMILY_EPP,

    //
    // Epp Software
    //
    ParIsEppSwWriteSupported,
    ParEnterEppSwMode,
    ParTerminateEppSwMode,
    ParEppSetAddress,
    NULL,                               // Enter Forward
    NULL,                               // Exit Forward
    ParEppSwWrite,
    EPP_SW,
    FAMILY_EPP,

    //
    // Ecp Software
    //
    ParIsEcpSwWriteSupported,
    ParEnterEcpSwMode,
    ParTerminateEcpMode,
    ParEcpSetAddress,
    NULL,                               // Enter Forward
    NULL,                               // Exit Forward
    ParEcpSwWrite,
    ECP_SW,
    FAMILY_ECP,

    //
    // IEEE Centronics
    //
    NULL,
    ParEnterSppMode,
    ParTerminateSppMode,
    NULL,
    NULL,           // Enter Forward
    NULL,           // Exit Forward
    SppIeeeWrite,
    IEEE_COMPATIBILITY,
    FAMILY_NONE,

    //
    // Centronics
    //
    NULL,
    ParEnterSppMode,
    ParTerminateSppMode,
    NULL,
    NULL,           // Enter Forward
    NULL,           // Exit Forward
    SppWrite,
    CENTRONICS,
    FAMILY_NONE,

    //
    // None...
    //
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,           // Enter Forward
    NULL,           // Exit Forward
    NULL,
    NONE,
    FAMILY_NONE
};

extern REVERSE_PTCL    arpReverse[] = {

    //
    // Bounded Ecp Mode
    //
    PptIsBecpSupported,
    PptEnterBecpMode,
    PptTerminateBecpMode,
    NULL,                       // Violates IEEE 1284.3 to set Reverse address for BECP
    PptEcpHwEnterReversePhase,   // Enter Reverse
    PptBecpExitReversePhase,     // Exit Reverse
    PptEcpHwDrainShadowBuffer,  // A read from Cached data
    PptEcpHwHaveReadData,         // Quick peek to see if Periph has reverse data without flipping the bus
                                // NOTE: This is crucial since it violates the 1284.3 BECP to flip
                                // blindly into reverse if the peripheral doesn't have data.
    PptBecpRead,
    BOUNDED_ECP,
    FAMILY_BECP,             

    //
    // Hardware Ecp Mode
    //
    ParIsEcpHwSupported,        // This is resued for both read/write
    ParEnterEcpHwMode,
    ParTerminateHwEcpMode,
    ParEcpHwSetAddress,           // Reuse the one in ecp.c
    PptEcpHwEnterReversePhase,  // Enter Reverse
    ParEcpHwExitReversePhase,   // Exit Reverse
    PptEcpHwDrainShadowBuffer,  // A read from Cached data
    PptEcpHwHaveReadData,       // Quick peek to see if Periph has reverse data without flipping the bus
    ParEcpHwRead,
    ECP_HW_NOIRQ,
    FAMILY_ECP,

    //
    // Epp Hardware
    //
    ParIsEppHwSupported,            // This is resued for both read/write
    ParEnterEppHwMode,
    ParTerminateEppHwMode,
    ParEppSetAddress,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParEppHwRead,
    EPP_HW,
    FAMILY_EPP,

    //
    // Epp Software Mode
    //
    ParIsEppSwReadSupported,
    ParEnterEppSwMode,
    ParTerminateEppSwMode,
    ParEppSetAddress,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParEppSwRead,
    EPP_SW,
    FAMILY_EPP,

    //
    // Ecp Software Mode
    //
    ParIsEcpSwReadSupported,
    ParEnterEcpSwMode,
    ParTerminateEcpMode,
    ParEcpSetAddress,
    ParEcpForwardToReverse,             // Enter Reverse
    ParEcpReverseToForward,             // Exit Reverse
    NULL,                               // A read from Cached data
    ParEcpHaveReadData,                 // Quick peek to see if Periph has reverse data without flipping the bus
    ParEcpSwRead,
    ECP_SW,
    FAMILY_ECP,

    //
    // Byte Mode
    //
    ParIsByteSupported,
    ParEnterByteMode,
    ParTerminateByteMode,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParByteModeRead,
    BYTE_BIDIR,
    FAMILY_REVERSE_BYTE,

    //
    // Nibble Mode
    //
    ParIsNibbleSupported,
    ParEnterNibbleMode,
    ParTerminateNibbleMode,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParNibbleModeRead,
    NIBBLE,
    FAMILY_REVERSE_NIBBLE,

    //
    // Channelized Nibble Mode
    //
    ParIsChannelizedNibbleSupported,
    ParEnterChannelizedNibbleMode,
    ParTerminateNibbleMode,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParNibbleModeRead,
    CHANNEL_NIBBLE,
    FAMILY_REVERSE_NIBBLE,
    
    //
    // None...
    //
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    NULL,
    NONE,
    FAMILY_NONE
};


VOID
IeeeTerminate1284Mode(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    PUCHAR Controller;
    PUCHAR wPortDCR;
    UCHAR  dcr, dsrMask, dsrValue;
    BOOLEAN bXFlag;
    BOOLEAN bUseXFlag = FALSE;

    Controller = Pdx->Controller;
    wPortDCR = Controller + OFFSET_DCR;
    dcr = P5ReadPortUchar(wPortDCR);

    if( PHASE_TERMINATE == Pdx->CurrentPhase )	{
        // We are already terminated.  This will fail if we don't
        // just bypass this mess.
        goto Terminate_ExitLabel;
    }

    // Keep Negotiated XFLAG to use for termination.
    //    xFlag,  // Technically we should have
    // cached this value from state
    // 6 of nego. This peripheral's XFlag
    // at pre state 22 should be the
    // same as state 6.
    bXFlag = P5ReadPortUchar(Controller + OFFSET_DSR) & 0x10;

    // REVISIT: Do we need to ensure the preceeding state is a valid
    //          state to terminate from.  In other words, is there there
    //          a black bar on the 1284 line for that state?


    // =============== Host State 22 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low (Signals state 22)
    //  nReverseReq/**(ECP only)    = Don't Care (High for ECP, otherwise unused)
    //  HostAck/HostBusy/nAutoFeed  = High
    //  HostClk/nStrobe             = High
    //
    Pdx->CurrentEvent = 22;
    dcr = P5ReadPortUchar(wPortDCR);
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, ACTIVE);

    //
    // Some devices start working if we add a delay here - no idea why
    // this works
    //
    // Make the delay configurable via registry setting so that devices that
    //   don't need this delay aren't penalized
    //
    if( Pdx->Event22Delay != 0 ) {
        if( Pdx->Event22Delay > 1000 ) {
            Pdx->Event22Delay = 1000;
        }
        KeStallExecutionProcessor( Pdx->Event22Delay );
    }

    P5WritePortUchar(wPortDCR, dcr);

    // Clear data lines so we don't have any random spew.
    P5WritePortUchar(Controller + OFFSET_DATA, 0);

    // *************** Periph State 23/24 Termination ***************8
    // PeriphAck/PtrBusy        = High  (Signals state 23 for ECP
    //                                   otherwise already high)
    // PeriphClk/PtrClk         = Low   (Signals state 24 for ecp
    //                                   Signals state 23 for Nibble)
    // nAckRev/AckDataReq/PE    = Don't Care
    // XFlag                    = Low  (ECP and Byte)   (State 24)
    //                          = High (Nibble)         (State 24)
    //                          = Low (All DeviceID Requests including Nibble) (State 24)
    //                          = Undefined (EPP)
    // nPeriphReq/nDataAvail    = High
    //                            Don't check nPeriphReq/nDataAvail
    //                            Since it was in a "Don't Care"
    //                            state (ie. Double bar in the spec)
    //                            until state 23 for ECP mode.
    if( Pdx->CurrentPhase == PHASE_REVERSE_IDLE || Pdx->CurrentPhase == PHASE_REVERSE_XFER) {

        // We must be in Nibble Reverse.  Let's double check!!!
        if( FAMILY_REVERSE_NIBBLE == arpReverse[Pdx->IdxReverseProtocol].ProtocolFamily ||
            FAMILY_REVERSE_BYTE   == arpReverse[Pdx->IdxReverseProtocol].ProtocolFamily )
            bUseXFlag = TRUE;   // We're in Nibble or Byte
        else
            bUseXFlag = FALSE;   // Don't know what mode we are in?

    } else {

        if (FAMILY_BECP == afpForward[Pdx->IdxForwardProtocol].ProtocolFamily ||
            FAMILY_ECP  == afpForward[Pdx->IdxForwardProtocol].ProtocolFamily )
            bUseXFlag = TRUE;   // We're in an ECP Flavor
        else
            bUseXFlag = FALSE;   // Don't know what mode we are in?
    }

    if( bUseXFlag ) {

        dsrMask = DSR_TEST_MASK( DONT_CARE, INACTIVE, DONT_CARE, bXFlag ? INACTIVE : ACTIVE, DONT_CARE );
        dsrValue = DSR_TEST_VALUE( DONT_CARE, INACTIVE, DONT_CARE, bXFlag ? INACTIVE : ACTIVE, DONT_CARE );

    } else {

        dsrMask = DSR_TEST_MASK( DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE );
        dsrValue = DSR_TEST_VALUE( DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE );
    }

    Pdx->CurrentEvent = 23;

    if( !CheckPort(Controller + OFFSET_DSR, dsrMask, dsrValue, IEEE_MAXTIME_TL)) {
        // We couldn't negotiate back to compatibility mode.
        // just terminate.
        DD((PCE)Pdx,DDW,"IeeeTerminate1284Mode:State 23/24 Failed: Controller %x dsr %x dcr %x\n",
           Controller, P5ReadPortUchar(Controller + OFFSET_DSR), dcr);
        goto Terminate_ExitLabel;
    }

    // =============== Host State 25 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low
    //  nReverseReq/**(ECP only)    = Don't Care (Possibly High)
    //  HostAck/HostBusy/nAutoFeed  = Low (Signals State 25)
    //  HostClk/nStrobe             = High
    //
    Pdx->CurrentEvent = 25;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, INACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // =============== State 26 Termination ===============8
    // Do nothing for state 26

    // =============== Periph State 27 Termination ===============8
    // PeriphAck/PtrBusy        = High
    // PeriphClk/PtrClk         = High   (Signals State 27)
    // nAckRev/AckDataReq/PE    = Don't Care  (Invalid from State 23)
    // XFlag                    = Don't Care (All Modes)   (Invlaid at State 27)
    // nPeriphReq/nDataAvial    = Don't Care (Invalid from State 26)
    // dvrh 6/16/97
    Pdx->CurrentEvent = 27;
    if( !CHECK_DSR(Controller, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL) ) {
        DD((PCE)Pdx,DDW,"IeeeTerminate1284Mode:State 27 Failed: Controller %x dsr %x dcr %x\n", 
           Controller, P5ReadPortUchar(Controller + OFFSET_DSR), dcr);
    }

Terminate_ExitLabel:

    // =============== Host State 28 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low
    //  nReverseReq/**(ECP only)    = Don't Care (Possibly High)
    //  HostAck/HostBusy/nAutoFeed  = High (Signals State 28)
    //  HostClk/nStrobe             = High
    //
    Pdx->CurrentEvent = 28;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // We are now back in compatibility mode.

    P5SetPhase( Pdx, PHASE_TERMINATE );
    Pdx->Connected = FALSE;
    Pdx->IsIeeeTerminateOk = FALSE;
    DD((PCE)Pdx,DDT,"IeeeTerminate1284Mode - exit - dcr=%x\n", dcr);
    return;
}

NTSTATUS
IeeeEnter1284Mode(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Extensibility
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    PUCHAR          wPortDCR;
    PUCHAR          Controller;
    UCHAR           dcr;
    const USHORT    sPeriphResponseTime = 35;

    Controller = Pdx->Controller;
    wPortDCR = Controller + OFFSET_DCR;

    /* =============== Host Prep for Pre State 0 ===============8
       Set the following just in case someone didn't
       put the port in compatibility mode before we got it.
      
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = Low
        nReverseReq/  (ECP only)= High for ECP / Don't Care for Nibble
                                    I will do ahead and set it to high
                                    since Nibble doesn't care.
        HostAck/HostBusy        = High
        HostClk/nStrobe         = Don't Care
    ============================================================ */
    dcr = P5ReadPortUchar(wPortDCR);               // Get content of DCR.
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, DONT_CARE);
    P5WritePortUchar(wPortDCR, dcr);
    KeStallExecutionProcessor(2);

    /* =============== Host Pre State 0 Negotiation ===============8
        DIR                     = Low ( Don't Care by spec )
        IRQEN                   = Low ( Don't Care by spec )
        1284/SelectIn           = Low
        nReverseReq/  (ECP only)= High ( Don't Care by spec )
        HostAck/HostBusy        = High
        HostClk/nStrobe         = High
    ============================================================ */
    
    dcr = UPDATE_DCR(dcr, INACTIVE, INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);
    KeStallExecutionProcessor(2);
    /* =============== Host State 0 Negotiation ===============8
       Place the extensibility request value on the data bus - state 0.
      
    ============================================================ */
    Pdx->CurrentEvent = 0;
    P5WritePortUchar(Controller + DATA_OFFSET, Extensibility);
    KeStallExecutionProcessor(2);

    /* =========== Host State 1 Negotiation Phase ===========8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High  (Signals State 1)
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = Low   (Signals state 1)
        HostClk/nStrobe         = High
      
    ============================================================ */
    Pdx->CurrentEvent = 1;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    /* =============== Periph State 2 Negotiation ===============8
       PeriphAck/PtrBusy        = Don't Care
       PeriphClk/PtrClk         = low   Signals State 2
       nAckReverse/AckDataReq   = high  Signals State 2
       XFlag                    = high  Signals State 2
                                    **Note: It is high at state 2
                                            for both ecp and nibble
       nPeriphReq/nDataAvail    = high  Signals State 2
    ============================================================ */
    Pdx->CurrentEvent = 2;
    if (!CHECK_DSR(Controller, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, ACTIVE,
                  sPeriphResponseTime)) {
        KeStallExecutionProcessor(2);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, DONT_CARE);
        P5WritePortUchar(wPortDCR, dcr);
        
        DD((PCE)Pdx,DDW,"IeeeEnter1284Mode - controller=%x - extensibility=%x, FAIL - TIMEOUT on Event 2\n",
           Pdx->Controller, Extensibility);

        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->Connected = FALSE;
        Pdx->IsIeeeTerminateOk = FALSE;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    /* =============== Host State 3 Negotiation ===============8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = Low
        HostClk/nStrobe         = Low (signals State 3)
      
        NOTE: Strobe the Extensibility byte
    ============================================================ */
    Pdx->CurrentEvent = 3;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, INACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // HostClk must be help low for at least .5 microseconds.
    //
    KeStallExecutionProcessor(2);

    /* =============== Host State 4 Negotiation ===============8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = High (signals State 4)
        HostClk/nStrobe         = High (signals State 4)
      
        NOTE: nReverseReq should be high in ECP, but this line is only
                valid for ECP.  Since it isn't used for signaling
                anything in negotiation, let's just ignore it for now.
    ============================================================ */
    Pdx->CurrentEvent = 4;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    /* ============== Periph State 5/6 Negotiation ===============
       PeriphAck/PtrBusy        = Don't Care. low (ECP) / Don't Care (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       PeriphClk/PtrClk         = high (Signals State 6)
       nAckReverse/AckDataReq   = Don't Care. low (ECP) / high (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       XFlag                    = Don't Care. high (ECP) / low (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       nPeriphReq/nDataAvail    = Don't Care. high (ECP) / low (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       ============== Periph State 5/6 Negotiation ==============8
      
        NOTES:
                - It's ok to lump states 5 and 6 together.  In state 5 Nibble,
                    the periph will set XFlag low and nPeriphReq/nDataAvail low.
                    The periph will then hold for .5ms then set PeriphClk/PtrClk
                    high.  In ECP, state 5 is nAckReverse/AckDataReq going low and
                    PeriphAck/PtrBusy going low.  Followed by a .5ms pause.
                    Followed by PeriphClk/PtrClk going high.
    ============================================================ */
    Pdx->CurrentEvent = 5;
    if (!CHECK_DSR(Controller, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE,
                  sPeriphResponseTime)) {
                  
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE);
        P5WritePortUchar(wPortDCR, dcr);

        DD((PCE)Pdx,DDW,"IeeeEnter1284Mode- controller=%x - extensibility=%x, FAIL - TIMEOUT on Events 5/6\n",
           Pdx->Controller, Extensibility);

        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->Connected = FALSE;
        Pdx->IsIeeeTerminateOk = FALSE;
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    KeStallExecutionProcessor(2);

    P5SetPhase( Pdx, PHASE_NEGOTIATION );
    Pdx->Connected = TRUE;
    return STATUS_SUCCESS;
}

VOID
IeeeDetermineSupportedProtocols(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine walks the list of all ieee1284 modes, and
    flags each of the ones the peripheral supports in
    Pdx->ProtocolModesSupported. This proc is called from
    external IOCTL.

Arguments:

    Pdx - The parallel device extension

Return Value:

--*/
{
    REVERSE_MODE    rm;
    FORWARD_MODE    fm;

    // Take CENTRONICS as a given since it is not a
    // mode we can neogitate to.
    //
    // n.b.
    // Let's go ahead and mark IEEE_COMPATIBILITY since we
    // cannot negotiate into it.  But if the someone sets 
    // IEEE_COMPATIBILITY and the peripheral does not support
    // IEEE 1284 compliant compatibility mode then we're gonna
    // create one very unhappy peripheral.      -- dvrh
    Pdx->ProtocolModesSupported = CENTRONICS | IEEE_COMPATIBILITY;

    //
    // Unlikely that we would be connected, but...
    //

    ParTerminate(Pdx);

    for (fm = FORWARD_FASTEST; fm < FORWARD_NONE; fm++) {

        if (afpForward[fm].fnIsModeSupported)
            afpForward[fm].fnIsModeSupported(Pdx);
    }

    for (rm = REVERSE_FASTEST; rm < REVERSE_NONE; rm++) {

        if (arpReverse[rm].fnIsModeSupported)
            arpReverse[rm].fnIsModeSupported(Pdx);
    }

    return;
}

NTSTATUS
IeeeNegotiateBestMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    )
/*++

Routine Description:

    This routine walks the list of supported modes, looking for the best
    (fastest) mode.  It will skip any mode(s) mask passed in.

Arguments:

    Pdx - The parallel device extension

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    REVERSE_MODE    rm;
    FORWARD_MODE    fm;

    //
    // A USHORT is provided in the extension so that each of the protocols
    // can decide whether they need to negotiate each time we go through this
    // process...
    //

    //
    // Unlikely that we would be connected, but...
    //

    DD((PCE)Pdx,DDT,"IeeeNegotiateBestMode - skipping Fwd=%x, Rev=%x\n",usWriteMask, usReadMask);

    ParTerminate(Pdx);

    Pdx->IdxForwardProtocol = FORWARD_NONE;
    Pdx->IdxReverseProtocol = REVERSE_NONE;

    for (fm = FORWARD_FASTEST; fm < FORWARD_NONE; fm++) {

        if (!(afpForward[fm].Protocol & usWriteMask)) {

            if (afpForward[fm].fnIsModeSupported) {

                if (afpForward[fm].fnIsModeSupported(Pdx)) {
                    Pdx->IdxForwardProtocol = (USHORT)fm;
                    break;
                }
            }
        }
    }

    for (rm = REVERSE_FASTEST; rm < REVERSE_NONE; rm++) {

        if (!(arpReverse[rm].Protocol & usReadMask)) {

            if (arpReverse[rm].fnIsModeSupported) {

                if (arpReverse[rm].fnIsModeSupported(Pdx)) {
                    Pdx->IdxReverseProtocol = (USHORT)rm;
                    break;
                }
            }
        }
    }

    Pdx->fnRead  = arpReverse[Pdx->IdxReverseProtocol].fnRead;
    Pdx->fnWrite = afpForward[Pdx->IdxForwardProtocol].fnWrite;

    DD((PCE)Pdx,DDT,"IeeeNegotiateBestMode - exit - Fwd=%x, Rev=%x\n",fm,rm);

    return STATUS_SUCCESS;
}


NTSTATUS
IeeeNegotiateMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    )

/*++

Routine Description:

    This routine walks the list of supported modes, looking for the best
    (fastest) mode which is also in the mode mask passed in.

Arguments:

    Pdx - The parallel device extension

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{

    REVERSE_MODE    rm;
    FORWARD_MODE    fm;

    //
    // A USHORT is provided in the extension so that each of the protocols
    // can decide whether they need to negotiate each time we go through this
    // process...
    //

    //
    // Unlikely that we would be connected, but...
    //

    ParTerminate(Pdx);

    Pdx->IdxForwardProtocol = FORWARD_NONE;
    Pdx->IdxReverseProtocol = REVERSE_NONE;

    for (fm = FORWARD_FASTEST; fm < FORWARD_NONE; fm++) {

        if (afpForward[fm].Protocol & usWriteMask) {

            if (afpForward[fm].fnIsModeSupported) {

                if (afpForward[fm].fnIsModeSupported(Pdx)) {
                    Pdx->IdxForwardProtocol = (USHORT)fm;
                    break;
                }

            } else {

                Pdx->IdxForwardProtocol = (USHORT)fm;
                break;
            }
        }
    }

    for (rm = REVERSE_FASTEST; rm < REVERSE_NONE; rm++) {

        if (arpReverse[rm].Protocol & usReadMask) {

            if (arpReverse[rm].fnIsModeSupported) {

                if (arpReverse[rm].fnIsModeSupported(Pdx)) {
                    Pdx->IdxReverseProtocol = (USHORT)rm;
                    break;
                }

            } else {

                Pdx->IdxReverseProtocol = (USHORT)rm;
                break;
            }
        }
    }

    DD((PCE)Pdx,DDT,"IeeeNegotiateMode - Fwd=%x, Rev=%x\n",fm,rm);

    Pdx->fnRead  = arpReverse[Pdx->IdxReverseProtocol].fnRead;
    Pdx->fnWrite = afpForward[Pdx->IdxForwardProtocol].fnWrite;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\funcdecl.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    parport.sys

File Name:

    funcdecl.h

Abstract:

    This file contains the parport function declarations for functions
    that are called from a translation unit other than the one in
    which the function is defined.

--*/

NTSTATUS
P5FdoCreateThread(
    PFDO_EXTENSION Fdx
    );

NTSTATUS
PptAcquirePortViaIoctl(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

VOID
P5SetPhase( PPDO_EXTENSION Pdx, P1284_PHASE Phase );

VOID
P5BSetPhase( PIEEE_STATE IeeeState, P1284_PHASE Phase );

VOID
P5TraceIrpArrival( PDEVICE_OBJECT DevObj, PIRP Irp );

VOID
P5TraceIrpCompletion( PIRP Irp );

// irpQueue.c
VOID
P2InitIrpQueueContext(
    IN PIRPQUEUE_CONTEXT IrpQueueContext
    );

VOID
P2CancelQueuedIrp(
    IN  PIRPQUEUE_CONTEXT  IrpQueueContext,
    IN  PIRP               Irp
    );

NTSTATUS 
P2QueueIrp(
    IN  PIRP               Irp,
    IN  PIRPQUEUE_CONTEXT  IrpQueueContext,
    IN  PDRIVER_CANCEL     CancelRoutine
    );

PIRP
P2DequeueIrp(
    IN  PIRPQUEUE_CONTEXT IrpQueueContext,
    IN  PDRIVER_CANCEL    CancelRoutine
    );

VOID
P2CancelRoutine(
    IN  PDEVICE_OBJECT  DevObj,
    IN  PIRP            Irp
    );

// test.c


//
// ieee1284.c
//

VOID
IeeeTerminate1284Mode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
IeeeEnter1284Mode(
    IN  PPDO_EXTENSION   Extension,
    IN  UCHAR               Extensibility
    );

VOID
IeeeDetermineSupportedProtocols(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
IeeeNegotiateBestMode(
    IN  PPDO_EXTENSION   Extension,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    );

NTSTATUS
IeeeNegotiateMode(
    IN  PPDO_EXTENSION   Extension,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    );

//
// port.c
//

VOID
ParReleasePortInfoToPortDevice(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParFreePort(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParAllocPortCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );

BOOLEAN
ParAllocPort(
    IN  PPDO_EXTENSION   Extension
    );



NTSTATUS
PptWmiQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  PDevObj, 
    OUT PULONG          PRegFlags,
    OUT PUNICODE_STRING PInstanceName,
    OUT PUNICODE_STRING *PRegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo 
);

NTSTATUS
PptWmiQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    );


NTSTATUS
ParGetPortInfoFromPortDevice(
    IN OUT  PPDO_EXTENSION   Extension
    );

VOID
ParReleasePortInfoToPortDevice(
    IN  PPDO_EXTENSION   Extension
    );
    
VOID
ParFreePort(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParAllocPortCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );

BOOLEAN
ParAllocPort(
    IN  PPDO_EXTENSION   Extension
    );

VOID
TstReadDeviceId( PFDO_EXTENSION Ext );

NTSTATUS
P4IeeeEnter1284Mode(
    IN     PUCHAR          Controller,                    
    IN     UCHAR           Extensibility,
    IN OUT PIEEE_STATE     State
    );

VOID
P4IeeeTerminate1284Mode(
    IN PUCHAR           Controller,
    IN OUT PIEEE_STATE  IeeeState,
    IN enum XFlagOnEvent24 XFlagOnEvent24
    );

NTSTATUS
P4NibbleModeRead(
    IN      PUCHAR       Controller,
    IN      PVOID        Buffer,
    IN      ULONG        BufferSize,
    OUT     PULONG       BytesTransferred,
    IN OUT  PIEEE_STATE  IeeeState
    );

VOID
P4MakeClassNameFromPortLptName(
    IN     PWSTR            LptName,
    IN OUT PUNICODE_STRING  ParallelName
    );

VOID
ParMakeClassNameFromNumber(
    IN  ULONG           Number,
    OUT PUNICODE_STRING ClassName
    );

//

NTSTATUS
PptFdoUnhandledRequest( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS 
PptPdoUnhandledRequest( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchPnp( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchPower( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchCreate( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchClose( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchCleanup( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchRead( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchWrite( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchInternalDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchQueryInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchSetInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchSystemControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoPnp( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoPower( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoCreateOpen( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoClose( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoCleanup( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoRead( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoWrite( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoInternalDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoQueryInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoSetInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoSystemControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoPnp( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoPower( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoCreate( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoClose( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoCleanup( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoRead( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoWrite( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoInternalDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoQueryInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoSetInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoSystemControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptWmiInitWmi(PDEVICE_OBJECT DeviceObject); 

NTSTATUS
PptDispatchSystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

//
// pnp.c - dvdf
//
VOID
PptPnpInitDispatchFunctionTable(
    VOID
    );

NTSTATUS
P5AddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

NTSTATUS
PptDispatchPnp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

//
//
//

NTSTATUS
PptFailRequest(
    IN PIRP Irp, 
    IN NTSTATUS Status
    );

NTSTATUS
PptDispatchPreProcessIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
PptDispatchPostProcessIrp();


//
// initunld.c
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PptUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );


//
// parport.c
//

NTSTATUS
PptSystemControl (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
PptSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

VOID
PptLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

NTSTATUS
PptConnectInterrupt(
    IN  PFDO_EXTENSION   Extension
    );

VOID
PptDisconnectInterrupt(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDispatchCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
PptDispatchClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

BOOLEAN
PptSynchronizedIncrement(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedDecrement(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedRead(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedQueue(
    IN  PVOID   Context
    );

BOOLEAN
PptSynchronizedDisconnect(
    IN  PVOID   Context
    );

VOID
PptCancelRoutine(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    );

VOID
PptFreePortDpc(
    IN      PKDPC   Dpc,
    IN OUT  PVOID   Extension,
    IN      PVOID   SystemArgument1,
    IN      PVOID   SystemArgument2
    );

BOOLEAN
PptTryAllocatePortAtInterruptLevel(
    IN  PVOID   Context
    );

VOID
PptFreePortFromInterruptLevel(
    IN  PVOID   Context
    );

BOOLEAN
PptInterruptService(
    IN  PKINTERRUPT Interrupt,
    IN  PVOID       Extension
    );

BOOLEAN
PptTryAllocatePort(
    IN  PVOID   Extension
    );

BOOLEAN
PptTraversePortCheckList(
    IN  PVOID   Extension
    );

VOID
PptFreePort(
    IN  PVOID   Extension
    );

ULONG
PptQueryNumWaiters(
    IN  PVOID   Extension
    );

NTSTATUS
PptDispatchInternalDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
PptCleanupDevice(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDispatchCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

BOOLEAN
PptIsNecR98Machine(
    void
    );

VOID
PowerStateCallback(
    IN  PVOID CallbackContext,
    IN  PVOID Argument1,
    IN  PVOID Argument2
    );

NTSTATUS
PptDispatchPower (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );

VOID
PptRegInitDriverSettings(
    PUNICODE_STRING   RegistryPath
    );

PWSTR
PptGetPortNameFromPhysicalDeviceObject(
  PDEVICE_OBJECT PhysicalDeviceObject
  );

PVOID
PptSetCancelRoutine(
    IN PIRP           Irp, 
    IN PDRIVER_CANCEL CancelRoutine
);

NTSTATUS
PptAcquireRemoveLockOrFailIrp(
    IN PDEVICE_OBJECT DeviceObject, 
    PIRP              Irp
);

//
// debug.c
//

UCHAR
P5ReadPortUchar( PUCHAR Port );

VOID
P5ReadPortBufferUchar( PUCHAR Port, PUCHAR Buffer, ULONG Count ); 

VOID
P5WritePortUchar( PUCHAR Port, UCHAR Value );

VOID
P5WritePortBufferUchar( PUCHAR Port, PUCHAR Buffer, ULONG Count ); 

VOID
PptFdoDumpPnpIrpInfo(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    );

VOID
PptPdoDumpPnpIrpInfo(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    );

NTSTATUS
PptAcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
PptReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
PptReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag
    );

VOID
PptDebugDumpResourceList(
    PIO_RESOURCE_LIST ResourceList
    );

VOID
PptDebugDumpResourceRequirementsList(
    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    );

//
//
//

VOID
PptLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

VOID
PptReportResourcesDevice(
    IN  PFDO_EXTENSION   Extension,
    IN  BOOLEAN             ClaimInterrupt,
    OUT PBOOLEAN            ConflictDetected
    );

VOID
PptUnReportResourcesDevice(
    IN OUT  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptConnectInterrupt(
    IN  PFDO_EXTENSION   Extension
    );

VOID
PptDisconnectInterrupt(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDispatchCreateClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

BOOLEAN
PptSynchronizedIncrement(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedDecrement(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedRead(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedQueue(
    IN  PVOID   Context
    );

BOOLEAN
PptSynchronizedDisconnect(
    IN  PVOID   Context
    );

VOID
PptCancelRoutine(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    );

VOID
PptFreePortDpc(
    IN      PKDPC   Dpc,
    IN OUT  PVOID   Extension,
    IN      PVOID   SystemArgument1,
    IN      PVOID   SystemArgument2
    );

BOOLEAN
PptTryAllocatePortAtInterruptLevel(
    IN  PVOID   Context
    );

VOID
PptFreePortFromInterruptLevel(
    IN  PVOID   Context
    );

BOOLEAN
PptInterruptService(
    IN  PKINTERRUPT Interrupt,
    IN  PVOID       Extension
    );

BOOLEAN
PptTryAllocatePort(
    IN  PVOID   Extension
    );

BOOLEAN
PptTraversePortCheckList(
    IN  PVOID   Extension
    );

VOID
PptFreePort(
    IN  PVOID   Extension
    );

ULONG
PptQueryNumWaiters(
    IN  PVOID   Extension
    );

NTSTATUS
PptDispatchDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
PptCleanupDevice(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDispatchCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
PptUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

BOOLEAN
PptIsNecR98Machine(
    void
    );

//
// parmode.c
//

NTSTATUS
PptDetectChipFilter(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDetectPortType(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptSetChipMode (
    IN  PFDO_EXTENSION  Extension,
    IN  UCHAR              ChipMode
    );

NTSTATUS
PptClearChipMode (
    IN  PFDO_EXTENSION  Extension,
    IN  UCHAR              ChipMode
    );

//
// par12843.c
//

ULONG
PptInitiate1284_3(
    IN  PVOID   Extension
    );

NTSTATUS
PptTrySelectDevice(
    IN  PVOID   Context,
    IN  PVOID   TrySelectCommand
    );

NTSTATUS
PptDeselectDevice(
    IN  PVOID   Context,
    IN  PVOID   DeselectCommand
    );

ULONG
Ppt1284_3AssignAddress(
    IN  PFDO_EXTENSION    DeviceExtension
    );

BOOLEAN
PptSend1284_3Command(
    IN  PUCHAR  CurrentPort,
    IN  UCHAR   Command
    );

//
// Ppt RemoveLock function declarations
//
NTSTATUS
PptAcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
PptReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
PptReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag
    );

//
// power management function declarations
//
NTSTATUS
PptPowerDispatch (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );



//
// other function declarations
//

PWSTR
PptGetPortNameFromPhysicalDeviceObject(
  PDEVICE_OBJECT PhysicalDeviceObject
  );

NTSTATUS
PptSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
PptTrySelectLegacyZip(
    IN  PVOID   Context,
    IN  PVOID   TrySelectCommand
    );

NTSTATUS
PptDeselectLegacyZip(
    IN  PVOID   Context,
    IN  PVOID   DeselectCommand
    );

NTSTATUS
PptRegGetDeviceParameterDword(
    IN     PDEVICE_OBJECT  Pdo,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    );

NTSTATUS
PptRegSetDeviceParameterDword(
    IN PDEVICE_OBJECT  Pdo,
    IN PWSTR           ParameterName,
    IN PULONG          ParameterValue
    );

NTSTATUS
PptBuildParallelPortDeviceName(
    IN  ULONG           Number,
    OUT PUNICODE_STRING DeviceName
    );

NTSTATUS
PptInitializeDeviceExtension(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PDEVICE_OBJECT  pPhysicalDeviceObject,
    IN PDEVICE_OBJECT  pDeviceObject,
    IN PUNICODE_STRING uniNameString,
    IN PWSTR           portName,
    IN ULONG           portNumber
    );

NTSTATUS
PptGetPortNumberFromLptName( 
    IN  PWSTR  PortName, 
    OUT PULONG PortNumber 
    );

PDEVICE_OBJECT
PptBuildFdo( 
    IN PDRIVER_OBJECT pDriverObject, 
    IN PDEVICE_OBJECT pPhysicalDeviceObject 
    );

VOID
PptDetectEppPort(
    IN  PFDO_EXTENSION   Extension
    );

// orig pnp.h follows

NTSTATUS
PptPnpFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    );

NTSTATUS
PptPnpCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpStopDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpUnhandledIrp(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpStartDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpStartValidateResources(
    IN PDEVICE_OBJECT DeviceObject,                              
    IN BOOLEAN        FoundPort,
    IN BOOLEAN        FoundIrq,
    IN BOOLEAN        FoundDma
    );

NTSTATUS
PptPnpStartScanCmResourceList(
    IN  PFDO_EXTENSION Extension,
    IN  PIRP              Irp, 
    OUT PBOOLEAN          FoundPort,
    OUT PBOOLEAN          FoundIrq,
    OUT PBOOLEAN          FoundDma
    );

NTSTATUS
PptPnpPassThroughPnpIrpAndReleaseRemoveLock(
    IN PFDO_EXTENSION Extension,
    IN PIRP              Irp
    );

NTSTATUS
PptPnpRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
PptPnpFilterNukeIrqResourceDescriptors(
    IN OUT PIO_RESOURCE_LIST IoResourceList
    );

VOID
PptPnpFilterNukeIrqResourceDescriptorsFromAllLists(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    );

BOOLEAN
PptPnpFilterExistsNonIrqResourceList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    );

PVOID
PptPnpFilterGetEndOfResourceRequirementsList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    );

BOOLEAN
PptPnpListContainsIrqResourceDescriptor(
    IN PIO_RESOURCE_LIST List
    );

VOID
PptPnpFilterRemoveIrqResourceLists(
    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    );

NTSTATUS
PptPnpBounceAndCatchPnpIrp(
    IN PFDO_EXTENSION Extension,
    IN PIRP              Irp
    );

PWSTR
P4MakePdoSymLinkName(
    IN PWSTR          LptName,
    IN enum _PdoType  PdoType,
    IN UCHAR          DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN UCHAR          RetryNumber
    );

PWSTR
P4MakePdoDeviceName(
    IN PWSTR          LptName,
    IN enum _PdoType  PdoType,
    IN UCHAR          DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN UCHAR          RetryNumber   // used if we had a name collision on IoCreateDevice
    );

PDEVICE_OBJECT
P4CreatePdo(
    IN PDEVICE_OBJECT  Fdo,
    IN enum _PdoType   PdoType,
    IN UCHAR           DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN PCHAR           Ieee1284Id    // NULL if device does not report IEEE 1284 Device ID
    );

VOID
P4DestroyPdo(
    IN PDEVICE_OBJECT  Pdo
    );             

NTSTATUS
PptFindNatChip(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptBuildResourceList(
    IN  PFDO_EXTENSION   Extension,
    IN  ULONG               Partial,
    IN  PUCHAR             *Addresses,
    OUT PCM_RESOURCE_LIST   Resources
    );

// parmode.h

NTSTATUS
PptDetectChipFilter(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDetectPortType(
    IN  PFDO_EXTENSION   Extension
    );
    
NTSTATUS
PptDetectPortCapabilities(
    IN  PFDO_EXTENSION   Extension
    );
    
VOID
PptDetectEcpPort(
    IN  PFDO_EXTENSION   Extension
    );

VOID
PptDetectEppPortIfDot3DevicePresent(
    IN  PFDO_EXTENSION   Extension
    );

VOID
PptDetectEppPortIfUserRequested(
    IN  PFDO_EXTENSION   Extension
    );

VOID
PptDetectBytePort(
    IN  PFDO_EXTENSION   Extension
    );

VOID 
PptDetermineFifoDepth(
    IN PFDO_EXTENSION   Extension
    );

VOID
PptDetermineFifoWidth(
    IN PFDO_EXTENSION   Extension
    );

NTSTATUS
PptSetChipMode (
    IN  PFDO_EXTENSION  Extension,
    IN  UCHAR              ChipMode
    );

NTSTATUS
PptClearChipMode (
    IN  PFDO_EXTENSION  Extension,
    IN  UCHAR              ChipMode
    );

NTSTATUS
PptEcrSetMode(
    IN  PFDO_EXTENSION   Extension,
    IN  UCHAR               ChipMode
    );

NTSTATUS
PptCheckBidiMode(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptEcrClearMode(
    IN  PFDO_EXTENSION   Extension
    );
    
NTSTATUS
PptSetByteMode( 
    IN  PFDO_EXTENSION   Extension,
    IN  UCHAR               ChipMode
    );

NTSTATUS
PptClearByteMode( 
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptCheckByteMode(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
P4CompleteRequest(
    IN PIRP       Irp,
    IN NTSTATUS   Status,
    IN ULONG_PTR  Information 
    );

NTSTATUS
P4CompleteRequestReleaseRemLock(
    IN PIRP             Irp,
    IN NTSTATUS         Status,
    IN ULONG_PTR        Information,
    IN PIO_REMOVE_LOCK  RemLock
    );

VOID
P4SanitizeId(
    IN OUT PWSTR DeviceId
    );

VOID
P4AcquireBus( IN PDEVICE_OBJECT Fdo ); // this call will block until bus can be acquired

VOID
P4ReleaseBus( PDEVICE_OBJECT Fdo );

PCHAR
P4ReadRawIeee1284DeviceId(
    IN  PUCHAR          Controller
    );

VOID
P4WritePortNameToDevNode( PDEVICE_OBJECT Pdo, PCHAR Location );

NTSTATUS
PptPdoCreateOpen(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    );


NTSTATUS PptFdoHandleBusRelations( IN PDEVICE_OBJECT Fdo, IN PIRP Irp );
NTSTATUS PptPnpStartScanPciCardCmResourceList( PFDO_EXTENSION Extension, PIRP Irp, PBOOLEAN FoundPort, PBOOLEAN FoundIrq, PBOOLEAN FoundDma );
BOOLEAN PptIsPci( PFDO_EXTENSION Extension, PIRP Irp );
NTSTATUS PptPnpStartScanCmResourceList( PFDO_EXTENSION Extension, PIRP Irp, PBOOLEAN FoundPort, PBOOLEAN FoundIrq, PBOOLEAN FoundDma );
NTSTATUS PptPnpStartValidateResources( PDEVICE_OBJECT DeviceObject, IN BOOLEAN FoundPort, IN BOOLEAN FoundIrq, IN BOOLEAN FoundDma );
BOOLEAN PptPnpFilterExistsNonIrqResourceList( IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList );
VOID PptPnpFilterRemoveIrqResourceLists( PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList );
PVOID PptPnpFilterGetEndOfResourceRequirementsList( IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList );
VOID PptPnpFilterNukeIrqResourceDescriptorsFromAllLists( PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList );
VOID PptPnpFilterNukeIrqResourceDescriptors( PIO_RESOURCE_LIST IoResourceList );
BOOLEAN PptPnpListContainsIrqResourceDescriptor( IN PIO_RESOURCE_LIST List );
NTSTATUS PptPnpBounceAndCatchPnpIrp( PFDO_EXTENSION Extension, PIRP Irp );
NTSTATUS PptPnpPassThroughPnpIrpAndReleaseRemoveLock( IN PFDO_EXTENSION Extension, IN PIRP Irp );


VOID PptPdoGetPortInfoFromFdo( PDEVICE_OBJECT Pdo );


NTSTATUS
ParForwardToReverse(
    IN  PPDO_EXTENSION   Extension
    );

BOOLEAN 
ParHaveReadData(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS 
ParPing(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParReverseToForward(
    IN  PPDO_EXTENSION   Extension
    );


NTSTATUS
ParRead(
    IN PPDO_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead
    );

VOID
ParReadIrp(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParSetFwdAddress(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParTerminate(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParWrite(
    IN PPDO_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten
    );

VOID
ParWriteIrp(
    IN  PPDO_EXTENSION   Extension
    );


NTSTATUS
ParWmiPdoQueryWmiDataBlock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  ULONG           GuidIndex,
    IN  ULONG           InstanceIndex,
    IN  ULONG           InstanceCount,
    IN  OUT PULONG      InstanceLengthArray,
    IN  ULONG           OutBufferSize,
    OUT PUCHAR          Buffer
    );

NTSTATUS
ParWmiPdoQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  PDevObj, 
    OUT PULONG          PRegFlags,
    OUT PUNICODE_STRING PInstanceName,
    OUT PUNICODE_STRING *PRegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo 
);


NTSTATUS
ParEcpEnterReversePhase(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpExitReversePhase(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpSetupPhase(
    IN  PPDO_EXTENSION   Extension
    );


VOID
ParCleanupHwEcpPort(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwEmptyFIFO(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwHostRecoveryPhase(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwRecoverPort(
    IN PPDO_EXTENSION Extension,
    UCHAR  bRecoverCode
    );

NTSTATUS
ParEcpHwWaitForEmptyFIFO(
    IN PPDO_EXTENSION   Extension
    );

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pcfuncdecl.h
//
//--------------------------------------------------------------------------

//
// Function declarations for the ParClass (parallel.sys) driver
//

VOID
ParDumpDevExtTable();

NTSTATUS 
ParWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN ULONG          Action
    );

BOOLEAN
ParIsPodo(
    IN PDEVICE_OBJECT DevObj
    );

NTSTATUS
ParWmiPdoInitWmi(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ParWmiPdoSystemControlDispatch(
    IN  PDEVICE_OBJECT  DeviceObject, 
    IN  PIRP            Irp
    );

PCHAR
Par3QueryDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               DeviceIdBuffer,
    IN  ULONG               BufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString, // TRUE == include the 2 size bytes in the returned string
    IN BOOLEAN              bBuildStlDeviceId
    );


PDEVICE_OBJECT
ParDetectCreatePdo(PDEVICE_OBJECT legacyPodo, UCHAR Dot3Id, BOOLEAN bStlDot3Id);

NTSTATUS
ParBuildSendInternalIoctl(
    IN  ULONG           IoControlCode,
    IN  PDEVICE_OBJECT  TargetDeviceObject,
    IN  PVOID           InputBuffer         OPTIONAL,
    IN  ULONG           InputBufferLength,
    OUT PVOID           OutputBuffer        OPTIONAL,
    IN  ULONG           OutputBufferLength,
    IN  PLARGE_INTEGER  Timeout             OPTIONAL
    );


//
// initunld.c - driver initialization and unload
//
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

VOID
ParUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

NTSTATUS
ParPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParPdoPower(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           pIrp
   );

NTSTATUS
ParFdoPower(
    IN PPDO_EXTENSION Extension,
    IN PIRP           pIrp
   );

// parclass.c ?

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

UCHAR
ParInitializeDevice(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParNotInitError(
    IN PPDO_EXTENSION    Extension,
    IN UCHAR                DeviceStatus
    );

VOID
PptPdoStartIo(
    IN  PPDO_EXTENSION   Extension
    );

VOID
PptPdoThread(
    IN PVOID    Context
    );

NTSTATUS
ParCreateSystemThread(
    PPDO_EXTENSION   Extension
    );

VOID
ParCancelRequest(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

// exports.c

USHORT
ParExportedDetermineIeeeModes(
    IN PPDO_EXTENSION    Extension
    );

NTSTATUS
ParExportedIeeeFwdToRevMode(
    IN PPDO_EXTENSION  Extension
    );

NTSTATUS
ParExportedIeeeRevToFwdMode(
    IN PPDO_EXTENSION  Extension
    );

NTSTATUS
ParExportedNegotiateIeeeMode(
    IN PPDO_EXTENSION  Extension,
	IN USHORT             ModeMaskFwd,
	IN USHORT             ModeMaskRev,
    IN PARALLEL_SAFETY    ModeSafety,
	IN BOOLEAN            IsForward
    );

NTSTATUS
ParExportedTerminateIeeeMode(
    IN PPDO_EXTENSION   Extension
    );

NTSTATUS
ParExportedParallelRead(
    IN PPDO_EXTENSION    Extension,
    IN  PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead,
    IN  UCHAR               Channel
    );

NTSTATUS
ParExportedParallelWrite(
    IN PPDO_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten,
    IN  UCHAR               Channel
    );
    
NTSTATUS
ParTerminateParclassMode(
    IN PPDO_EXTENSION   Extension
    );

VOID
ParWriteIo(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParReadIo(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParDeviceIo(
    IN  PPDO_EXTENSION   Extension
    );


// pnp?

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
ParPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

NTSTATUS
ParParallelPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParPdoParallelPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParFdoParallelPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

PDEVICE_OBJECT
ParPnpCreateDevice(
    IN PDRIVER_OBJECT pDriverObject
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParCheckParameters(
    IN OUT  PPDO_EXTENSION   Extension
    );

VOID
ParPnpFindDeviceIdKeys(
    OUT PCHAR   *lppMFG,
    OUT PCHAR   *lppMDL,
    OUT PCHAR   *lppCLS,
    OUT PCHAR   *lppDES,
    OUT PCHAR   *lppAID,
    OUT PCHAR   *lppCID,
    IN  PCHAR   lpDeviceID
    );

VOID
ParDot3ParseDevId(
    PCHAR   *lpp_DL,
    PCHAR   *lpp_C,
    PCHAR   *lpp_CMD,
    PCHAR   *lpp_4DL,
    PCHAR   *lpp_M,
    PCHAR   lpDeviceID
);

VOID
GetCheckSum(
    IN  PCHAR  Block,
    IN  USHORT  Len,
    OUT PUSHORT CheckSum
    );

BOOLEAN
String2Num(
    IN OUT PCHAR   *lpp_Str,
    IN CHAR         c,
    OUT ULONG       *num
    );

UCHAR
StringCountValues(
    IN PCHAR string, 
    IN CHAR  delimeter
    );

PCHAR
StringChr(
    IN  PCHAR string,
    IN  CHAR c
    );

ULONG
StringLen(
    IN  PUCHAR string
    );

VOID
StringSubst(
    IN OUT  PCHAR lpS,
    IN      CHAR chTargetChar,
    IN      CHAR chReplacementChar,
    IN      USHORT cbS
    );

BOOLEAN
ParSelectDevice(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             HavePort
    );

BOOLEAN
ParDeselectDevice(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             KeepPort
    );

NTSTATUS
ParAcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
ParReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
ParReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag
    );

NTSTATUS
ParPnpInterfaceChangeNotify(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION pDeviceInterfaceChangeNotification,
    IN  PVOID                                 pContext
    );

VOID
ParMakeClassNameFromNumber(
    IN  ULONG           Number,
    OUT PUNICODE_STRING ClassName
    );

VOID
ParMakeDotClassNameFromBaseClassName(
    IN  PUNICODE_STRING BaseClassName,
    IN  ULONG           Number,
    OUT PUNICODE_STRING DotClassName
    );

VOID
ParInitCommonDOPre(PDEVICE_OBJECT DevObj, PDEVICE_OBJECT Fdo, PUNICODE_STRING ClassName);

VOID
ParInitCommonDOPost(PDEVICE_OBJECT DevObj);

NTSTATUS
ParInitPdo(
    IN PDEVICE_OBJECT NewPdo, 
    IN PUCHAR         DeviceIdString,
    IN ULONG          DeviceIdLength,
    IN PDEVICE_OBJECT LegacyPodo,
    IN UCHAR          Dot3Id
    );

NTSTATUS
ParInitLegacyPodo(PDEVICE_OBJECT LegacyPodo, PUNICODE_STRING PortSymbolicLinkName);

VOID
ParAddDevObjToFdoList(PDEVICE_OBJECT DevObj);

PDEVICE_OBJECT
ParCreateLegacyPodo(PDEVICE_OBJECT Fdo, PUNICODE_STRING PortSymbolicLinkName);

VOID
ParAcquireListMutexAndKillDeviceObject(PDEVICE_OBJECT Fdo, PDEVICE_OBJECT DevObj);

VOID
ParKillDeviceObject(
    PDEVICE_OBJECT DeviceObject
    );

PWSTR
ParCreateWideStringFromUnicodeString(
    PUNICODE_STRING UnicodeString
    );

PDEVICE_OBJECT
ParDetectCreateEndOfChainPdo(PDEVICE_OBJECT LegacyPodo);

VOID
ParEnumerate1284_3Devices(
    IN  PDEVICE_OBJECT  pFdoDeviceObject,
    IN  PDEVICE_OBJECT  pPortDeviceObject,
    IN  PDEVICE_OBJECT  EndOfChainDeviceObject
    );

NTSTATUS
ParPnpNotifyTargetDeviceChange(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION pDeviceInterfaceChangeNotification,
    IN  PDEVICE_OBJECT                        pFdoDeviceObject
    );
    
NTSTATUS
ParPnpNotifyInterfaceChange(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION NotificationStruct,
    IN  PDEVICE_OBJECT                        Fdo
    );

NTSTATUS
ParPnpGetId(
    IN  PCHAR  DeviceIdString,
    IN  ULONG   Type,
    OUT PCHAR  resultString,
    OUT PCHAR  descriptionString
    );

NTSTATUS
ParPnpFdoQueryDeviceRelationsBusRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    );

// VOID ParAddPodoToDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PDEVICE_OBJECT CurrentDo);
// VOID ParAddEndOfChainPdoToDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PDEVICE_OBJECT CurrentDo);
// VOID ParAddDot3PdoToDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PDEVICE_OBJECT CurrentDo);
// VOID ParAddLegacyZipPdoToDevObjStruct(IN PPAR_DEVOBJ_STRUCT DevObjStructHead, IN PDEVICE_OBJECT CurrentDo);
// PPAR_DEVOBJ_STRUCT ParFindCreateDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PUCHAR Controller);
// VOID ParDumpDevObjStructList(PPAR_DEVOBJ_STRUCT DevObjStructHead);
// PPAR_DEVOBJ_STRUCT ParBuildDevObjStructList(PDEVICE_OBJECT Fdo);
// VOID ParDoParallelBusRescan(PPAR_DEVOBJ_STRUCT DevObjStructHead);

BOOLEAN
ParDeviceExists(
    PPDO_EXTENSION Extension,
    IN BOOLEAN        HavePortKeepPort
    );

NTSTATUS
ParAllocatePortDevice(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParAllocatePortDevice(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParAcquirePort(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

NTSTATUS
ParReleasePort(
    IN PDEVICE_OBJECT PortDeviceObject
    );

VOID
ParDetectDot3DataLink(
    IN  PPDO_EXTENSION   Extension,
    IN  PCHAR DeviceId
    );

VOID
ParMarkPdoHardwareGone(
    IN PPDO_EXTENSION Extension
    );

NTSTATUS
ParInit1284_3Bus(
    IN PDEVICE_OBJECT PortDeviceObject
    );

UCHAR
ParGet1284_3DeviceCount(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParSelect1284_3Device(
    IN  PDEVICE_OBJECT PortDeviceObject,
    IN  UCHAR          Dot3DeviceId
    );

NTSTATUS
ParDeselect1284_3Device(
    IN  PDEVICE_OBJECT PortDeviceObject,
    IN  UCHAR          Dot3DeviceId
    );

PCHAR
Par3QueryLegacyZipDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString // TRUE ==  include the 2 size bytes in the returned string
                                             // FALSE == discard the 2 size bytes
    );

PCHAR
ParStlQueryStlDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer,
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    ) ;

BOOLEAN
ParStlCheckIfStl(
    IN PPDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) ;

VOID
ParCheckEnableLegacyZipFlag();

BOOLEAN
P5LegacyZipDetected(
    IN  PUCHAR  Controller
    );

PWSTR
ParGetPortLptName(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParCreateDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  ULONG           DeviceExtensionSize,
    IN  PUNICODE_STRING DeviceName OPTIONAL,
    IN  DEVICE_TYPE     DeviceType,
    IN  ULONG           DeviceCharacteristics,
    IN  BOOLEAN         Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );

VOID
ParInitializeExtension1284Info(
    IN PPDO_EXTENSION Extension
    );

VOID
ParGetDriverParameterDword(
    IN     PUNICODE_STRING ServicePath,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    );

NTSTATUS
PptRegGetDword(
    IN     ULONG   RelativeTo,
    IN     PWSTR   Path,
    IN     PWSTR   ParameterName,
    IN OUT PULONG  ParameterValue
    );

NTSTATUS
PptRegSetDword(
    IN  ULONG  RelativeTo,               
    IN  PWSTR  Path,
    IN  PWSTR  ParameterName,
    IN  PULONG ParameterValue
    );

NTSTATUS
PptRegGetSz(
    IN      ULONG  RelativeTo,               
    IN      PWSTR  Path,
    IN      PWSTR  ParameterName,
    IN OUT  PUNICODE_STRING ParameterValue
    );

NTSTATUS
PptRegSetSz(
    IN  ULONG  RelativeTo,               
    IN  PWSTR  Path,
    IN  PWSTR  ParameterName,
    IN  PWSTR  ParameterValue
    );

VOID
ParFixupDeviceId(
    IN OUT PUCHAR DeviceId
    );

VOID
PptWriteMfgMdlToDevNode(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PCHAR           Mfg,
    IN  PCHAR           Mdl
    );

VOID
P4SanitizeMultiSzId( 
    IN OUT  PWSTR  WCharBuffer,
    IN      ULONG  BufWCharCount
    );

NTSTATUS
ParEnterByteMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateByteMode(
    IN  PPDO_EXTENSION   Extension
    );
    
NTSTATUS
ParByteModeRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\irpqueue.c ===
#include "pch.h"

VOID
P2InitIrpQueueContext(
    IN PIRPQUEUE_CONTEXT IrpQueueContext
    )
{
    InitializeListHead( &IrpQueueContext->irpQueue );
    KeInitializeSpinLock( &IrpQueueContext->irpQueueSpinLock );
}

VOID
P2CancelQueuedIrp(
    IN  PIRPQUEUE_CONTEXT  IrpQueueContext,
    IN  PIRP               Irp
    )
{
    KIRQL oldIrql;
    
    // Release the global cancel spin lock.  Do this while not holding
    //   any other spin locks so that we exit at the right IRQL.
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Dequeue and complete the IRP.  The enqueue and dequeue
    //    functions synchronize properly so that if this cancel routine
    //    is called, the dequeue is safe and only the cancel routine
    //    will complete the IRP. Hold the spin lock for the IRP queue
    //    while we do this.
    //
    KeAcquireSpinLock( &IrpQueueContext->irpQueueSpinLock, &oldIrql );
    RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
    KeReleaseSpinLock( &IrpQueueContext->irpQueueSpinLock, oldIrql);
    
    //  Complete the IRP.  This is a call outside the driver, so all
    //    spin locks must be released by this point.
    P4CompleteRequest( Irp, STATUS_CANCELLED, 0 );
    return;
}

NTSTATUS 
P2QueueIrp(
    IN  PIRP               Irp,
    IN  PIRPQUEUE_CONTEXT  IrpQueueContext,
    IN  PDRIVER_CANCEL     CancelRoutine
    )
{
    PDRIVER_CANCEL  oldCancelRoutine;
    KIRQL           oldIrql;
    NTSTATUS        status = STATUS_PENDING;
    
    KeAcquireSpinLock( &IrpQueueContext->irpQueueSpinLock, &oldIrql );
    
    // Queue the IRP and call IoMarkIrpPending to indicate that the
    //   IRP may complete on a different thread.
    //
    // N.B. It's okay to call these inside the spin lock because
    //   they're macros, not functions.
    IoMarkIrpPending( Irp );
    InsertTailList( &IrpQueueContext->irpQueue, &Irp->Tail.Overlay.ListEntry );
    
    // Must set a Cancel routine before checking the Cancel flag.
    #pragma warning( push ) 
    #pragma warning( disable : 4054 4055 )
    oldCancelRoutine = IoSetCancelRoutine( Irp, CancelRoutine );
    #pragma warning( pop ) 
    ASSERT( !oldCancelRoutine );

    if( Irp->Cancel ){
        // The IRP was canceled.  Check whether our cancel routine was called.
        #pragma warning( push ) 
        #pragma warning( disable : 4054 4055 )
        oldCancelRoutine = IoSetCancelRoutine( Irp, NULL );
        #pragma warning( pop ) 

        if( oldCancelRoutine ) {
            // The cancel routine was NOT called.  
            //   So dequeue the IRP now and complete it after releasing the spinlock.
            RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
            status = Irp->IoStatus.Status = STATUS_CANCELLED; 
        }
        else {
            // The cancel routine WAS called.  As soon as we drop our
            //   spin lock it will dequeue and complete the IRP.  So
            //   leave the IRP in the queue and otherwise don't touch
            //   it.  Return pending since we're not completing the IRP
            //   here.
        }
    }
    
    KeReleaseSpinLock(&IrpQueueContext->irpQueueSpinLock, oldIrql);
    
    // Normally you shouldn't call IoMarkIrpPending and return a
    //   status other than STATUS_PENDING.  But you can break this rule
    //   if you complete the IRP.
    if( status != STATUS_PENDING ) {
        P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
    }
    return status;
}

PIRP
P2DequeueIrp(
    IN  PIRPQUEUE_CONTEXT IrpQueueContext,
    IN  PDRIVER_CANCEL    CancelRoutine
    )
{
    KIRQL oldIrql;
    PIRP  nextIrp = NULL;

    KeAcquireSpinLock( &IrpQueueContext->irpQueueSpinLock, &oldIrql );

    while( !nextIrp && !IsListEmpty( &IrpQueueContext->irpQueue ) ){

        PDRIVER_CANCEL oldCancelRoutine;

        PLIST_ENTRY listEntry = RemoveHeadList( &IrpQueueContext ->irpQueue );
        
        // Get the next IRP off the queue.
        nextIrp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        
        //  Clear the IRP's cancel routine
        #pragma warning( push ) 
        #pragma warning( disable : 4054 4055 )
        oldCancelRoutine = IoSetCancelRoutine( nextIrp, NULL );
        #pragma warning( pop )

        //  IoCancelIrp() could have just been called on this IRP.
        //    What we're interested in is not whether IoCancelIrp() was called (nextIrp->Cancel flag set),
        //    but whether IoCancelIrp() called (or is about to call) our cancel routine.
        //    To check that, check the result of the test-and-set macro IoSetCancelRoutine.
        if( oldCancelRoutine ) {
            //  Cancel routine not called for this IRP.  Return this IRP.
            #if DBG
            ASSERT( oldCancelRoutine == CancelRoutine );
            #else
            UNREFERENCED_PARAMETER( CancelRoutine );
            #endif
        } else {
            //  This IRP was just canceled and the cancel routine was (or will be) called.
            //  The cancel routine will complete this IRP as soon as we drop the spin lock,
            //  so don't do anything with the IRP.
            //  Also, the cancel routine will try to dequeue the IRP, 
            //  so make the IRP's listEntry point to itself.
            ASSERT( nextIrp->Cancel );
            InitializeListHead( &nextIrp->Tail.Overlay.ListEntry );
            nextIrp = NULL;
        }
    }
    
    KeReleaseSpinLock( &IrpQueueContext ->irpQueueSpinLock, oldIrql );
    
    return nextIrp;
}

VOID
P2CancelRoutine(
    IN  PDEVICE_OBJECT  DevObj,
    IN  PIRP            Irp
    )
// this routine is driver specific - most other routines in this file are generic
{
    PFDO_EXTENSION     fdx             = DevObj->DeviceExtension;
    PIRPQUEUE_CONTEXT  irpQueueContext = &fdx->IrpQueueContext;
    P2CancelQueuedIrp( irpQueueContext, Irp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\natsemichipset.c ===
#include "pch.h"

// Register Definitions for National ChipSets
#define  REG_CR0                    0x00
#define  REG_CR1                    0x01
#define  REG_CR2                    0x02
#define  REG_CR3                    0x03
#define  REG_CR4                    0x04
#define  REG_CR5                    0x05
#define  REG_CR6                    0x06
#define  REG_CR7                    0x07
#define  REG_CR8                    0x08

// National Chip ID's
#define PC87303                     0x30
#define PC87306                     0x70
#define PC87307                     0xC0
#define PC87308                     0xA0
#define PC87323                     0x20
#define PC87332                     0x10
#define PC87334                     0x50
#define PC87336                     0x90
#define PC87338                     0xB0
#define PC873xx                     0x60

// Additional definitions for National PC87307 and PC87308
#define PC873_LOGICAL_DEV_REG       0x07
#define PC873_PP_LDN                0x04
#define PC873_DEVICE_ID             0x20
#define PC873_PP_MODE_REG           0xF0
#define PC873_ECP_MODE              0xF2
#define PC873_EPP_MODE              0x62
#define PC873_SPP_MODE              0x92
#define PC873_BASE_IO_ADD_MSB       0x60
#define PC873_BASE_IO_ADD_LSB       0x61


NTSTATUS
PptFindNatChip(
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This routine finds out if there is a National Semiconductor IO chip on
    this machine.  If it finds a National chip it then determines if this 
    instance of Parport is using this chips paralle port IO address.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS       - if we were able to check for the parallel chip.
    STATUS_UNSUCCESSFUL  - if we were not able to check for the parallel chip.

Updates:
    
    Fdx->
            NationalChecked
            NationalChipFound

--*/

{
    BOOLEAN             found = FALSE;              // return code, assumed value
    BOOLEAN             OkToLook = FALSE;
    BOOLEAN             Conflict;
    PUCHAR              ChipAddr[4] = { (PUCHAR)0x398, (PUCHAR)0x26e, (PUCHAR)0x15c, (PUCHAR)0x2e };  // list of valid chip addresses
    PUCHAR              AddrList[4] = { (PUCHAR)0x378, (PUCHAR)0x3bc, (PUCHAR)0x278, (PUCHAR)0x00 };  // List of valid Parallel Port addresses
    PUCHAR              PortAddr;                   // Chip Port Address
    ULONG_PTR           Port;                       // Chip Port Read Value
    UCHAR               SaveIdx;                    // Save the index register value
    UCHAR               cr;                         // config register value
    UCHAR               ii;                         // loop index
    NTSTATUS            Status;                     // Status of success
    ULONG               ResourceDescriptorCount;
    ULONG               ResourcesSize;
    PCM_RESOURCE_LIST   Resources;
    ULONG               NationalChecked   = 0;
    ULONG               NationalChipFound = 0;

    
    //
    // Quick exit if we already know the answer
    //
    if ( Fdx->NationalChecked == TRUE ) {
        return STATUS_SUCCESS;
    }

    //
    // Mark extension so that we can quick exit the next time we are asked this question
    //
    Fdx->NationalChecked = TRUE; 

    //
    // Check the registry - we should only need to check this once per installation
    //
    PptRegGetDeviceParameterDword(Fdx->PhysicalDeviceObject, (PWSTR)L"NationalChecked", &NationalChecked);
    if( NationalChecked ) {
        //
        // We previously performed the NatSemi Check - extract result from registry
        //
        PptRegGetDeviceParameterDword(Fdx->PhysicalDeviceObject, (PWSTR)L"NationalChipFound", &NationalChipFound);
        if( NationalChipFound ) {
            Fdx->NationalChipFound = TRUE;
        } else {
            Fdx->NationalChipFound = FALSE;
        }
        return STATUS_SUCCESS;
    }

    //
    // This is our first, and hopefully last time that we need to make this check
    //   for this installation
    //

    //
    // Allocate a block of memory for constructing a resource descriptor
    //

    // number of partial descriptors 
    ResourceDescriptorCount = sizeof(ChipAddr)/sizeof(ULONG);

    // size of resource descriptor list + space for (n-1) more partial descriptors
    //   (resource descriptor list includes one partial descriptor)
    ResourcesSize =  sizeof(CM_RESOURCE_LIST) +
        (ResourceDescriptorCount - 1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

    Resources = (PCM_RESOURCE_LIST)ExAllocatePool(NonPagedPool, ResourcesSize);

    if (Resources == NULL) {
        // Error out
        return(STATUS_UNSUCCESSFUL);
    }

    // zero out memory block as a precaution
    RtlZeroMemory(Resources, ResourcesSize);

    //
    // Build the Resource List
    //
    Status = PptBuildResourceList( Fdx,
                                   sizeof(ChipAddr)/sizeof(ULONG),
                                   &ChipAddr[0],
                                   Resources
                                   );
    
    // Check to see if it was successful    
    if ( !NT_SUCCESS( Status ) ) {
        ExFreePool( Resources );
        return ( Status );
    }

    // 
    // check to see if we can use the io addresses where
    // national chipsets are located
    //
    Status = IoReportResourceUsage( NULL,
                                    Fdx->DriverObject,
                                    Resources,
                                    sizeof(Resources),
                                    Fdx->DeviceObject,
                                    NULL,
                                    0,
                                    FALSE,
                                    &Conflict
                                    ); 

    // done with resource list
    ExFreePool( Resources );

    // Check to see if IoReportResourceUsage was successful    
    if( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    // Check to see if it was successful    
    if ( Conflict ) {
        return STATUS_UNSUCCESSFUL;
    }


    // Was successful so now we check each of the addresses that we have
    // the resources for
    //
    // the following for loop is a state machine that checks modes and
    // port addresses.
    //
    // state 0: check for Pc873 at primary port address
    // state 1: check for Pc873 at secondary port address
    // state 2: check for Pc873 at Ter port address
    // state 3: check for Pc873 at Quad port address
    
    for ( ii = 0; !found && ii < 4; ii++ ) {

        PortAddr = (PUCHAR)ChipAddr[ii];

        // After power up the index register will read back an 0xAA one time only.
        // So we'll check for that first.
        // Then it should read back a 0 or a valid register number
            
        if(( P5ReadPortUchar( PortAddr ) == 0x88 )
           && ( P5ReadPortUchar( PortAddr ) < 0x20 )) {

            OkToLook = TRUE;

        } else {

            // Or it could read back a 0 or a valid register number
            P5ReadPortUchar( PortAddr );        // may read back 0 here
            cr = P5ReadPortUchar( PortAddr );   // valid register no.
  
            // is it really valid?
            // if( cr < 0x20 ) { - dvdr
            if( cr != 0xff ) {
                // does it read back the same?
                if( P5ReadPortUchar( PortAddr ) == cr)
                    OkToLook = TRUE;
            }

        } // end else
            
        // take a closer look by writing to the chip
        if ( OkToLook ) {

            OkToLook = FALSE;
                    
            // setup for ID reg
            P5WritePortUchar( PortAddr, REG_CR8 );
                            
            // read it back
            cr = P5ReadPortUchar( PortAddr );
                            
            // does it read back the same?
            if( cr  == REG_CR8 ) {

                // get the ID number.
                cr = (UCHAR)( P5ReadPortUchar( PortAddr + 1 ) & 0xf0 );
                                    
                // if the up. nib. is 1,3,5,6,7,9,A,B,C
                if( cr == PC87332 || cr == PC87334 || cr == PC87306 || cr == PC87303 || 
                   cr == PC87323 || cr == PC87336 || cr == PC87338 || cr == PC873xx ) {

                    // we found a national chip
                    found = TRUE;

                    // setup for Address reg
                    P5WritePortUchar( PortAddr, REG_CR1 );
                    
                    // read it back
                    Port = P5ReadPortUchar( PortAddr + 1 ) & 0x03;
                    
                    // Check the base address
                    if ( Fdx->PortInfo.Controller == (PUCHAR)AddrList[ Port ] ) {

                        //
                        // it is using the same address that Parport is using
                        // so we set the flag to not use generic ECP and EPP
                        //
                        Fdx->NationalChipFound = TRUE;

                    }
                            
                }

            } // reads back ok
                            
        } // end OkToLook

        // check to see if we found it
        if ( !found ) {

            // Check for the 307/308 chips
            SaveIdx = P5ReadPortUchar( PortAddr );

            // Setup for SID Register
            P5WritePortUchar( PortAddr, PC873_DEVICE_ID );
                    
            // Zero the ID register to start and because it is read only it will
            // let us know whether it is this chip
            P5WritePortUchar( PortAddr + 1, REG_CR0 );
                    
            // get the ID number.
            cr = (UCHAR)( P5ReadPortUchar( PortAddr + 1 ) & 0xf8 );
                    
            if ( (cr == PC87307) || (cr == PC87308) ) {

                // we found a new national chip
                found = TRUE;

                // Set the logical device
                P5WritePortUchar( PortAddr, PC873_LOGICAL_DEV_REG );
                P5WritePortUchar( PortAddr+1, PC873_PP_LDN );

                // set up for the base address MSB register
                P5WritePortUchar( PortAddr, PC873_BASE_IO_ADD_MSB );
                            
                // get the MSB of the base address
                Port = (ULONG_PTR)((P5ReadPortUchar( PortAddr + 1 ) << 8) & 0xff00);
                            
                // Set up for the base address LSB register
                P5WritePortUchar( PortAddr, PC873_BASE_IO_ADD_LSB );
                            
                // Get the LSBs of the base address
                Port |= P5ReadPortUchar( PortAddr + 1 );
                            
                // Check the base address
                if ( Fdx->PortInfo.Controller == (PUCHAR)Port ) {
                    //
                    // it is using the same address that Parport is using
                    // so we set the flag to not use generic ECP and EPP
                    //
                    Fdx->NationalChipFound = TRUE;
                }

            } else {

                P5WritePortUchar( PortAddr, SaveIdx );
            }
        }

    } // end of for ii...
    

    //
    // Check for NatSemi chip is complete - save results in registry so that we never
    //   have to make this check again for this port
    //
    {
        PDEVICE_OBJECT pdo = Fdx->PhysicalDeviceObject;
        NationalChecked    = 1;
        NationalChipFound  = Fdx->NationalChipFound ? 1 : 0;
        
        // we ignore status here because there is nothing we can do if the calls fail
        PptRegSetDeviceParameterDword(pdo, (PWSTR)L"NationalChecked",   &NationalChecked);
        PptRegSetDeviceParameterDword(pdo, (PWSTR)L"NationalChipFound", &NationalChipFound);
    }


    // 
    // release the io addresses where we checked for the national chipsets
    // we do this by calling IoReportResourceUsage with all NULL parameters
    //
    Status = IoReportResourceUsage( NULL,
                                    Fdx->DriverObject,
                                    NULL,
                                    0,
                                    Fdx->DeviceObject,
                                    NULL,
                                    0,
                                    FALSE,
                                    &Conflict
                                    ); 

    DD((PCE)Fdx,DDT,"ParMode::PptFindNatChip: return isFound [%x]\n",Fdx->NationalChipFound);
    return ( Status );
    
} // end of ParFindNat()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\nibble.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    nibble.c

Abstract:

    This module contains the code to do nibble mode reads.

Author:

    Anthony V. Ercolano 1-Aug-1992
    Norbert P. Kusters 22-Oct-1993

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

BOOLEAN
ParIsNibbleSupported(
    IN  PPDO_EXTENSION   Pdx
    );
    
BOOLEAN
ParIsChannelizedNibbleSupported(
    IN  PPDO_EXTENSION   Pdx
    );
    
NTSTATUS
ParEnterNibbleMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    );
    
NTSTATUS
ParEnterChannelizedNibbleMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateNibbleMode(
    IN  PPDO_EXTENSION   Pdx
    );
    
NTSTATUS
ParNibbleModeRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    

BOOLEAN
ParIsNibbleSupported(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine determines whether or not nibble mode is suported
    by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    if (Pdx->BadProtocolModes & NIBBLE) {
        DD((PCE)Pdx,DDT,"ParIsNibbleSupported: BAD PROTOCOL Leaving\n");
        return FALSE;
    }

    if (Pdx->ProtocolModesSupported & NIBBLE) {
        DD((PCE)Pdx,DDT,"ParIsNibbleSupported: Already Checked YES Leaving\n");
        return TRUE;
    }

    Status = ParEnterNibbleMode (Pdx, FALSE);
    ParTerminateNibbleMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsNibbleSupported: SUCCESS Leaving\n");
        Pdx->ProtocolModesSupported |= NIBBLE;
        return TRUE;
    }
    
    DD((PCE)Pdx,DDT,"ParIsNibbleSupported: UNSUCCESSFUL Leaving\n");
    return FALSE;    
    
}

BOOLEAN
ParIsChannelizedNibbleSupported(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine determines whether or not channelized nibble mode is suported (1284.3)
    by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    if (Pdx->BadProtocolModes & CHANNEL_NIBBLE) {
        DD((PCE)Pdx,DDT,"ParIsChannelizedNibbleSupported: BAD PROTOCOL Leaving\n");
        return FALSE;
    }

    if (Pdx->ProtocolModesSupported & CHANNEL_NIBBLE) {
        DD((PCE)Pdx,DDT,"ParIsChannelizedNibbleSupported: Already Checked YES Leaving\n");
        return TRUE;
    }

    Status = ParEnterChannelizedNibbleMode (Pdx, FALSE);
    ParTerminateNibbleMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsChannelizedNibbleSupported: SUCCESS Leaving\n");
        Pdx->ProtocolModesSupported |= CHANNEL_NIBBLE;
        return TRUE;
    }
    
    DD((PCE)Pdx,DDT,"ParIsChannelizedNibbleSupported: UNSUCCESSFUL Leaving\n");
    return FALSE;    
    
}

NTSTATUS
ParEnterNibbleMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    DD((PCE)Pdx,DDT,"ParEnterNibbleMode: Start\n");

    if ( Pdx->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Pdx, NIBBLE_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Pdx, NIBBLE_EXTENSIBILITY);
        }
    } else {
        DD((PCE)Pdx,DDT,"ParEnterNibbleMode: In UNSAFE_MODE.\n");
        Pdx->Connected = TRUE;
    }

    // dvdr
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParEnterNibbleMode: IeeeEnter1284Mode returned success\n");
        Pdx->CurrentEvent = 6;
        P5SetPhase( Pdx, PHASE_NEGOTIATION );
        Pdx->IsIeeeTerminateOk = TRUE;
    } else {
        DD((PCE)Pdx,DDT,"ParEnterNibbleMode: IeeeEnter1284Mode returned unsuccessful\n");
        ParTerminateNibbleMode ( Pdx );
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->IsIeeeTerminateOk = FALSE;
    }

    DD((PCE)Pdx,DDT,"ParEnterNibbleMode: Leaving with Status : %x \n", Status);

    return Status; 
}    

NTSTATUS
ParEnterChannelizedNibbleMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    DD((PCE)Pdx,DDT,"ParEnterChannelizedNibbleMode: Start\n");

    if ( Pdx->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Pdx, CHANNELIZED_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Pdx, CHANNELIZED_EXTENSIBILITY);
        }
    } else {
        DD((PCE)Pdx,DDT,"ParEnterChannelizedNibbleMode: In UNSAFE_MODE.\n");
        Pdx->Connected = TRUE;
    }
    
    // dvdr
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParEnterChannelizedNibbleMode: IeeeEnter1284Mode returned success\n");
        Pdx->CurrentEvent = 6;
        P5SetPhase( Pdx, PHASE_NEGOTIATION );
        Pdx->IsIeeeTerminateOk = TRUE;
    } else {
        DD((PCE)Pdx,DDT,"ParEnterChannelizedNibbleMode: IeeeEnter1284Mode returned unsuccessful\n");
        ParTerminateNibbleMode ( Pdx );
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->IsIeeeTerminateOk = FALSE;
    }

    DD((PCE)Pdx,DDT,"ParEnterChannelizedNibbleMode: Leaving with Status : %x \n", Status);
    return Status; 
}    

VOID
ParTerminateNibbleMode(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    DD((PCE)Pdx,DDT,"ParTerminateNibbleMode: Enter.\n");
    if ( Pdx->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Pdx);
    } else {
        DD((PCE)Pdx,DDT,"ParTerminateNibbleMode: In UNSAFE_MODE.\n");
        Pdx->Connected = FALSE;
    }
    DD((PCE)Pdx,DDT,"ParTerminateNibbleMode: Exit.\n");
}

NTSTATUS
ParNibbleModeRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 nibble mode read into the given
    buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          Controller;
    PUCHAR          wPortDCR;
    PUCHAR          wPortDSR;
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          p = (PUCHAR)Buffer;
    UCHAR           dsr, dcr;
    UCHAR           nibble[2];
    ULONG           i, j;

    Controller = Pdx->Controller;
    wPortDCR = Controller + OFFSET_DCR;
    wPortDSR = Controller + OFFSET_DSR;
    
    // Read nibbles according to 1284 spec.
    DD((PCE)Pdx,DDT,"ParNibbleModeRead - enter\n");

    dcr = P5ReadPortUchar(wPortDCR);

    switch (Pdx->CurrentPhase) {
    
        case PHASE_NEGOTIATION: 
        
            DD((PCE)Pdx,DDT,"ParNibbleModeRead - case PHASE_NEGOTIATION\n");
            
            // Starting in state 6 - where do we go from here?
            // To Reverse Idle or Reverse Data Transfer Phase depending if
            // data is available.
            
            dsr = P5ReadPortUchar(wPortDSR);
            
            // =============== Periph State 6 ===============8
            // PeriphAck/PtrBusy        = Don't Care
            // PeriphClk/PtrClk         = Don't Care (should be high
            //                              and the nego. proc already
            //                              checked this)
            // nAckReverse/AckDataReq   = Don't Care (should be high)
            // XFlag                    = Don't Care (should be low)
            // nPeriphReq/nDataAvail    = High/Low (line status determines
            //                              which state we move to)
            Pdx->CurrentEvent = 6;
        #if (0 == DVRH_USE_NIBBLE_MACROS)
            if (dsr & DSR_NOT_DATA_AVAIL)
        #else
            if (TEST_DSR(dsr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE ))
        #endif
            {
                // Data is NOT available - go to Reverse Idle
                DD((PCE)Pdx,DDT,"ParNibbleModeRead - now in PHASE_REVERSE_IDLE\n");
                // Host enters state 7  - officially in Reverse Idle now
                
            	// Must stall for at least .5 microseconds before this state.
                KeStallExecutionProcessor(1);

                /* =============== Host State 7 Nibble Reverse Idle ===============8
                    DIR                     = Don't Care
                    IRQEN                   = Don't Care
                    1284/SelectIn           = High
                    nReverseReq/  (ECP only)= Don't Care
                    HostAck/HostBusy        = Low (signals State 7)
                    HostClk/nStrobe         = High
                  ============================================================ */
                Pdx->CurrentEvent = 7;
            #if (0 == DVRH_USE_NIBBLE_MACROS)
                dcr |= DCR_NOT_HOST_BUSY;
            #else
                dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, ACTIVE);
            #endif
                P5WritePortUchar(wPortDCR, dcr);

                P5SetPhase( Pdx,  PHASE_REVERSE_IDLE );
                // FALL THRU TO reverse idle
            } else {
            
                // Data is available, go to Reverse Transfer Phase
                P5SetPhase( Pdx,  PHASE_REVERSE_XFER );
                // DO NOT fall thru
                goto PhaseReverseXfer; // please save me from my sins!
            }


        case PHASE_REVERSE_IDLE:

            // Check to see if the peripheral has indicated Interrupt Phase and if so, 
            // get us ready to reverse transfer.

            // See if data is available (looking for state 19)
            dsr = P5ReadPortUchar(Controller + OFFSET_DSR);
                
            if (!(dsr & DSR_NOT_DATA_AVAIL)) {
                
                dcr = P5ReadPortUchar(wPortDCR);
                // =========== Host State 20 Interrupt Phase ===========8
                //  DIR                     = Don't Care
                //  IRQEN                   = Don't Care
                //  1284/SelectIn           = High
                //  nReverseReq/ (ECP only) = Don't Care
                //  HostAck/HostBusy        = High (Signals state 20)
                //  HostClk/nStrobe         = High
                //
                // Data is available, get us to Reverse Transfer Phase
                Pdx->CurrentEvent = 20;
                dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE, ACTIVE);
                P5WritePortUchar(wPortDCR, dcr);

                // =============== Periph State 21 HBDA ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = Don't Care (should be high)
                // nAckReverse/AckDataReq   = low (signals state 21)
                // XFlag                    = Don't Care (should be low)
                // nPeriphReq/nDataAvail    = Don't Care (should be low)
                Pdx->CurrentEvent = 21;
                if (CHECK_DSR(Controller,
                                DONT_CARE, DONT_CARE, INACTIVE,
                                DONT_CARE, DONT_CARE,
                                IEEE_MAXTIME_TL)) {
                                  
                // Got state 21
                    // Let's jump to Reverse Xfer and get the data
                    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
                    goto PhaseReverseXfer;
                        
                } else {
                    
                    // Timeout on state 21
                    Pdx->IsIeeeTerminateOk = TRUE;
                    Status = STATUS_IO_DEVICE_ERROR;
                    P5SetPhase( Pdx, PHASE_UNKNOWN );
                    DD((PCE)Pdx,DDT,"ParNibbleModeRead - Failed State 21: Controller %x dcr %x\n", Controller, dcr);
                    // NOTE:  Don't ASSERT Here.  An Assert here can bite you if you are in
                    //        Nibble Rev and you device is off/offline.
                    // dvrh 2/25/97
                    goto NibbleReadExit;
                }

            } else {
                
                // Data is NOT available - do nothing
                // The device doesn't report any data, it still looks like it is
                // in ReverseIdle.  Just to make sure it hasn't powered off or somehow
                // jumped out of Nibble mode, test also for AckDataReq high and XFlag low
                // and nDataAvaul high.
                Pdx->CurrentEvent = 18;
                dsr = P5ReadPortUchar(Controller + OFFSET_DSR);
                if(( dsr & DSR_NIBBLE_VALIDATION )== DSR_NIBBLE_TEST_RESULT ) {

                    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );

                } else {
                    #if DVRH_BUS_RESET_ON_ERROR
                        BusReset(wPortDCR);  // Pass in the dcr address
                    #endif
                    // Appears we failed state 19.
                    Pdx->IsIeeeTerminateOk = TRUE;
                    Status = STATUS_IO_DEVICE_ERROR;
                    P5SetPhase( Pdx, PHASE_UNKNOWN );
                    DD((PCE)Pdx,DDT,"ParNibbleModeRead - Failed State 19: Controller %x dcr %x\n", Controller, dcr);
                }
                goto NibbleReadExit;

            }
        
PhaseReverseXfer:

        case PHASE_REVERSE_XFER: 
        
            DD((PCE)Pdx,DDT,"ParNibbleModeRead - case PHASE_REVERSE_IDLE\n");
            
            for (i = 0; i < BufferSize; i++) {
            
                for (j = 0; j < 2; j++) {
                
                    // Host enters state 7 or 12 depending if nibble 1 or 2
//                    StoreControl (Controller, HDReady);
                    dcr |= DCR_NOT_HOST_BUSY;
                    P5WritePortUchar(wPortDCR, dcr);

                    // =============== Periph State 9     ===============8
                    // PeriphAck/PtrBusy        = Don't Care (Bit 3 of Nibble)
                    // PeriphClk/PtrClk         = low (signals state 9)
                    // nAckReverse/AckDataReq   = Don't Care (Bit 2 of Nibble)
                    // XFlag                    = Don't Care (Bit 1 of Nibble)
                    // nPeriphReq/nDataAvail    = Don't Care (Bit 0 of Nibble)
                    Pdx->CurrentEvent = 9;
                    if (!CHECK_DSR(Controller,
                                  DONT_CARE, INACTIVE, DONT_CARE,
                                  DONT_CARE, DONT_CARE,
                                  IEEE_MAXTIME_TL)) {
                        // Time out.
                        // Bad things happened - timed out on this state,
                        // Mark Status as bad and let our mgr kill current mode.
                        
                        Pdx->IsIeeeTerminateOk = FALSE;
                        Status = STATUS_IO_DEVICE_ERROR;
                        DD((PCE)Pdx,DDT,"ParNibbleModeRead - Failed State 9: Controller %x dcr %x\n", Controller, dcr);
                        P5SetPhase( Pdx, PHASE_UNKNOWN );
                        goto NibbleReadExit;
                    }

                    // Read Nibble
                    nibble[j] = P5ReadPortUchar(wPortDSR);

                    /* ============== Host State 10 Nibble Read ===============8
                        DIR                     = Don't Care
                        IRQEN                   = Don't Care
                        1284/SelectIn           = High
                        HostAck/HostBusy        = High (signals State 10)
                        HostClk/nStrobe         = High
                    ============================================================ */
                    Pdx->CurrentEvent = 10;
                    dcr &= ~DCR_NOT_HOST_BUSY;
                    P5WritePortUchar(wPortDCR, dcr);

                    // =============== Periph State 11     ===============8
                    // PeriphAck/PtrBusy        = Don't Care (Bit 3 of Nibble)
                    // PeriphClk/PtrClk         = High (signals state 11)
                    // nAckReverse/AckDataReq   = Don't Care (Bit 2 of Nibble)
                    // XFlag                    = Don't Care (Bit 1 of Nibble)
                    // nPeriphReq/nDataAvail    = Don't Care (Bit 0 of Nibble)
                    Pdx->CurrentEvent = 11;
                    if (!CHECK_DSR(Controller,
                                  DONT_CARE, ACTIVE, DONT_CARE,
                                  DONT_CARE, DONT_CARE,
                                  IEEE_MAXTIME_TL)) {
                        // Time out.
                        // Bad things happened - timed out on this state,
                        // Mark Status as bad and let our mgr kill current mode.
                        Status = STATUS_IO_DEVICE_ERROR;
                        Pdx->IsIeeeTerminateOk = FALSE;
                        DD((PCE)Pdx,DDT,"ParNibbleModeRead - Failed State 11: Controller %x dcr %x\n", Controller, dcr);
                        P5SetPhase( Pdx, PHASE_UNKNOWN );
                        goto NibbleReadExit;
                    }
                }

                // Read two nibbles - make them into one byte.
                
                p[i]  = (((nibble[0]&0x38)>>3)&0x07) | ((nibble[0]&0x80) ? 0x00 : 0x08);
                p[i] |= (((nibble[1]&0x38)<<1)&0x70) | ((nibble[1]&0x80) ? 0x00 : 0x80);

                // RMT - put this back in if needed - DD((PCE)Pdx,DDT,"ParNibbleModeRead:%x:%c\n", p[i], p[i]);

                // At this point, we've either received the number of bytes we
                // were looking for, or the peripheral has no more data to
                // send, or there was an error of some sort (of course, in the
                // error case we shouldn't get to this comment).  Set the
                // phase to indicate reverse idle if no data available or
                // reverse data transfer if there's some waiting for us
                // to get next time.

                dsr = P5ReadPortUchar(wPortDSR);
                
                if (dsr & DSR_NOT_DATA_AVAIL) {
                
                    // Data is NOT available - go to Reverse Idle
                    // Really we are going to HBDNA, but if we set
                    // current phase to reverse idle, the next time
                    // we get into this function all we have to do
                    // is set hostbusy low to indicate idle and
                    // we have infinite time to do that.
                    // Break out of the loop so we don't try to read
                    // data that isn't there.
                    // NOTE - this is a successful case even if we
                    // didn't read all that the caller requested
                    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
                    i++; // account for this last byte transferred
                    break;
                    
                } else {
                    // Data is available, go to (remain in ) Reverse Transfer Phase
                    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
                }
            } // end for i loop

            *BytesTransferred = i;
            // DON'T FALL THRU THIS ONE
            break;

        default:
            // I'm gonna mark this as false. There is not a correct answer here.
            //  The peripheral and the host are out of sync.  I'm gonna reset myself
            // and the peripheral.       
            Pdx->IsIeeeTerminateOk = FALSE;
            Status = STATUS_IO_DEVICE_ERROR;
            P5SetPhase( Pdx, PHASE_UNKNOWN );

            DD((PCE)Pdx,DDT,"ParNibbleModeRead - Failed State 9: Unknown Phase. Controller %x dcr %x\n", Controller, dcr);
            DD((PCE)Pdx,DDT, "ParNibbleModeRead: You're hosed man.\n" );
            DD((PCE)Pdx,DDT, "ParNibbleModeRead: If you are here, you've got a bug somewhere else.\n" );
            DD((PCE)Pdx,DDT, "ParNibbleModeRead: Go fix it!\n" );
            goto NibbleReadExit;
            break;
    } // end switch

NibbleReadExit:

    if( Pdx->CurrentPhase == PHASE_REVERSE_IDLE ) {
        // Host enters state 7  - officially in Reverse Idle now
        DD((PCE)Pdx,DDT,"ParNibbleModeRead - PHASE_REVERSE_IDLE\n");
        dcr |= DCR_NOT_HOST_BUSY;
        P5WritePortUchar (wPortDCR, dcr);
    }

    DD((PCE)Pdx,DDT,"ParNibbleModeRead:End [%d] bytes read = %d\n", NT_SUCCESS(Status), *BytesTransferred);
    Pdx->log.NibbleReadCount += *BytesTransferred;

#if 1 == DBG_SHOW_BYTES
    if( DbgShowBytes ) {
        if( NT_SUCCESS( Status ) && (*BytesTransferred > 0) ) {
            const ULONG maxBytes = 32;
            ULONG i;
            PUCHAR bytePtr = (PUCHAR)Buffer;
            DbgPrint("n: ");
            for( i=0 ; (i < *BytesTransferred) && (i < maxBytes ) ; ++i ) {
                DbgPrint("%02x ",*bytePtr++);
            }
            if( *BytesTransferred > maxBytes ) {
                DbgPrint("... ");
            }
            DbgPrint("zz\n");
        }
    }
#endif

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#define WANT_WDM                   1
#define DVRH_USE_CORRECT_PTRS      1

#pragma warning( disable : 4115 )   // named type definition in parentheses
#pragma warning( disable : 4127 )   // conditional expression is constant
#pragma warning( disable : 4201 )   // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4214 )   // nonstandard extension used : bit field types other than int
#pragma warning( disable : 4514 )   // unreferenced inline function has been removed

#include <ntddk.h>
#include <wdmguid.h>
#include <wmidata.h>
#include <wmilib.h>
#include <ntddser.h>                // IOCTL_SERIAL_[ SET | GET ]_TIMEOUTS
#include <stdio.h>
#define DVRH_USE_PARPORT_ECP_ADDR 1 // use ECP base + 0x2 rather than base + 0x402 for ECR 
#include <parallel.h>               // parallel.h includes ntddpar.h
#include "queueClass.h"
#include "parport.h"
#include "parlog.h"
#include "funcdecl.h"
#include "debug.h"
#include "utils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\parport.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name :

    parport.h

Abstract:

    Type definitions and data for the parallel port driver.

Revision History:

--*/

#ifndef _PARPORT_H_
#define _PARPORT_H_

#define arraysize(p) (sizeof(p)/sizeof((p)[0])) // From Walter Oney WDM book

// Used to keep track of the state of an IEEE negotiation, transfer, or termination
typedef struct _IEEE_STATE {
    ULONG         CurrentEvent;        // IEEE 1284 event - see IEEE 1284-1994 spec
    P1284_PHASE   CurrentPhase;        // see parallel.h for enum def - PHASE_UNKNOWN, ..., PHASE_INTERRUPT_HOST
    BOOLEAN       Connected;           // are we currently negotiated into a 1284 mode?
    BOOLEAN       IsIeeeTerminateOk;   // are we in a state where an IEEE Terminate is legal?
    USHORT        ProtocolFamily;      // what protocol family are we currently using (if connected)
} IEEE_STATE, *PIEEE_STATE;

// should we use or ignore XFlag on termination event 24 when terminating NIBBLE mode for 1284 ID query?
typedef enum {
    IgnoreXFlagOnEvent24,
       UseXFlagOnEvent24
}         XFlagOnEvent24;

// DVDF - 2000-08-16
// Used with IOCTL_INTERNAL_PARPORT_EXECUTE_TASK
typedef enum {
    Select,
    Deselect,
    Write,
    Read,
    MaxTask        
} ParportTask;

// Used with IOCTL_INTERNAL_PARPORT_EXECUTE_TASK
typedef struct _PARPORT_TASK {
    ParportTask Task;          // what type of request?
    PCHAR       Buffer;        // where is the buffer to use?
    ULONG       BufferLength;  // how big is the buffer?
    ULONG       RequestLength; // how many bytes of data is requested or supplied?
    CHAR        Requestor[8];  // diagnostic use only - suggest pdx->Location, e.g., "LPT2.4"
} PARPORT_TASK, *PPARPORT_TASK;

// handled by parport FDOs - execute a specified task
#define IOCTL_INTERNAL_PARPORT_EXECUTE_TASK                  CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 64, METHOD_BUFFERED, FILE_ANY_ACCESS)

struct _PDO_EXTENSION;
typedef struct _PDO_EXTENSION * PPDO_EXTENSION;

typedef
NTSTATUS
(*PPROTOCOL_READ_ROUTINE) (
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

typedef
NTSTATUS
(*PPROTOCOL_WRITE_ROUTINE) (
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

typedef
NTSTATUS
(*PDOT3_RESET_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef struct _DOT3DL_PCTL {
    PPROTOCOL_READ_ROUTINE           fnRead;
    PPROTOCOL_WRITE_ROUTINE           fnWrite;
    PDOT3_RESET_ROUTINE           fnReset;
    P12843_DL_MODES DataLinkMode;
    USHORT          CurrentPID;
    USHORT          FwdSkipMask;
    USHORT          RevSkipMask;
    UCHAR           DataChannel;
    UCHAR           ResetChannel;
    UCHAR           ResetByteCount;
    UCHAR           ResetByte;
    PKEVENT         Event;
    BOOLEAN         bEventActive;
} DOT3DL_PCTL, *PDOT3DL_PCTL;

//
// If we can't use our preferred \Device\ParallelN number due to name collision,
//   then start with N == PAR_CLASSNAME_OFFSET and increment until we are successful
//
#define PAR_CLASSNAME_OFFSET 8

//
// For pnp id strings
//
#define MAX_ID_SIZE 256

// used to construct IEEE 1284.3 "Dot" name suffixes 
// table lookup for integer to WCHAR conversion
#define PAR_UNICODE_PERIOD L'.'
#define PAR_UNICODE_COLON  L':'


//#define PAR_REV_MODE_SKIP_MASK    (CHANNEL_NIBBLE | BYTE_BIDIR | EPP_ANY)
#define PAR_REV_MODE_SKIP_MASK    (CHANNEL_NIBBLE | BYTE_BIDIR | EPP_ANY | ECP_ANY)
#define PAR_FWD_MODE_SKIP_MASK   (EPP_ANY | BOUNDED_ECP | ECP_HW_NOIRQ | ECP_HW_IRQ)
//#define PAR_FWD_MODE_SKIP_MASK  (EPP_ANY)
#define PAR_MAX_CHANNEL 127
#define PAR_COMPATIBILITY_RESET 300



#define PptSetFlags( FlagsVariable, FlagsToSet ) { (FlagsVariable) |= (FlagsToSet); }
#define PptClearFlags( FlagsVariable, FlagsToClear ) { (FlagsVariable) &= ~(FlagsToClear); }

// convert timeout in Milliseconds to relative timeout in 100ns units
//   suitable as parameter 5 to KeWaitForSingleObject(..., TimeOut)
#define PPT_SET_RELATIVE_TIMEOUT_IN_MILLISECONDS(VARIABLE, VALUE) (VARIABLE).QuadPart = -( (LONGLONG) (VALUE)*10*1000 )

#define MAX_PNP_IRP_MN_HANDLED IRP_MN_QUERY_LEGACY_BUS_INFORMATION

extern ULONG PptDebugLevel;
extern ULONG PptBreakOn;
extern UNICODE_STRING RegistryPath;       // copy of the registry path passed to DriverEntry()

extern UCHAR PptDot3Retries;    // variable to know how many times to try a select or
                                // deselect for 1284.3 if we do not succeed.

typedef enum _DevType {
    DevTypeFdo = 1,
    DevTypePdo = 2,
} DevType, *PDevType;

typedef enum _PdoType {
    PdoTypeRawPort    = 1,
    PdoTypeEndOfChain = 2,
    PdoTypeDaisyChain = 4,
    PdoTypeLegacyZip  = 8
} PdoType, *PPdoType;

extern const PHYSICAL_ADDRESS PhysicalZero;

#define PARPORT_TAG (ULONG) 'PraP'


#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,PARPORT_TAG)
#endif


//
// used for FilterResourceMethod in processing PnP IRP_MN_FILTER_RESOURCE_REQUIREMENTS
//
#define PPT_TRY_USE_NO_IRQ    0 // if alternatives exist that don't require an IRQ then
                                //   delete those alternatives that do, otherwise do nothing
#define PPT_FORCE_USE_NO_IRQ  1 // try previous method - if it fails (i.e., all alternatives 
                                //   require resources), then nuke IRQ resource descriptors 
                                //   in all alternatives
#define PPT_ACCEPT_IRQ        2 // don't do any resource filtering - accept resources that 
                                //   we are given


//
// Keep track of GET and RELEASE port info.
//
extern LONG PortInfoReferenceCount;
extern PFAST_MUTEX PortInfoMutex;

//
// DeviceStateFlags
//
#define PAR_DEVICE_PAUSED              ((ULONG)0x00000010) // stop-pending, stopped, or remove-pending states
#define PAR_DEVICE_PORT_REMOVE_PENDING ((ULONG)0x00000200) // our ParPort is in a Remove Pending State

//
// extension->PnpState - define the current PnP state of the device
//
#define PPT_DEVICE_STARTED          ((ULONG)0x00000001) // Device has succeeded START
#define PPT_DEVICE_DELETED          ((ULONG)0x00000002) // IoDeleteDevice has been called
#define PPT_DEVICE_STOP_PENDING     ((ULONG)0x00000010) // Device has succeeded QUERY_STOP, waiting for STOP or CANCEL
#define PPT_DEVICE_STOPPED          ((ULONG)0x00000020) // Device has received STOP
#define PPT_DEVICE_DELETE_PENDING   ((ULONG)0x00000040) // we have started the process of deleting device object
#define PPT_DEVICE_HARDWARE_GONE    ((ULONG)0x00000080) // our hardware is gone
#define PPT_DEVICE_REMOVE_PENDING   ((ULONG)0x00000100) // Device succeeded QUERY_REMOVE, waiting for REMOVE or CANCEL
#define PPT_DEVICE_REMOVED          ((ULONG)0x00000200) // Device has received REMOVE
#define PPT_DEVICE_SURPRISE_REMOVED ((ULONG)0x00001000) // Device has received SURPRISE_REMOVAL
#define PPT_DEVICE_PAUSED           ((ULONG)0x00010000) // stop-pending, stopped, or remove-pending - hold requests

//
// IEEE 1284 constants (Protocol Families)
//
#define FAMILY_NONE             0x0
#define FAMILY_REVERSE_NIBBLE   0x1
#define FAMILY_REVERSE_BYTE     0x2
#define FAMILY_ECP              0x3
#define FAMILY_EPP              0x4
#define FAMILY_BECP             0x5
#define FAMILY_MAX              FAMILY_BECP


typedef struct _IRPQUEUE_CONTEXT {
    LIST_ENTRY  irpQueue;
    KSPIN_LOCK  irpQueueSpinLock;
} IRPQUEUE_CONTEXT, *PIRPQUEUE_CONTEXT;

typedef struct _COMMON_EXTENSION {
    ULONG           Signature1;           // Used to increase our confidence that this is a ParPort extension
    enum _DevType   DevType;              // distinguish an FDO_EXTENSION from a PDO_EXTENSION
    PCHAR           Location;             // LPTx or LPTx.y location for PDO (symlink name less the \DosDevices prefix)
                                          // LPTxF for FDO
    PDEVICE_OBJECT  DeviceObject;         // back pointer to our DEVICE_OBJECT
    ULONG           PnpState;             // Device State - See Device State Flags: PPT_DEVICE_... above
    IO_REMOVE_LOCK  RemoveLock;           // Used to prevent PnP from removing us while requests are pending
    LONG            OpenCloseRefCount;    // keep track of the number of handles open to our device
    UNICODE_STRING  DeviceInterface;      // SymbolicLinkName returned from IoRegisterDeviceInterface
    BOOLEAN         DeviceInterfaceState; // Did we last set the DeviceInterface to True or False?
    BOOLEAN         TimeToTerminateThread;// TRUE == worker thread should kill itself via PsTerminateSystemThread()
    PVOID           ThreadObjectPointer;  // pointer to a worker thread for this Device
} COMMON_EXTENSION, *PCOMMON_EXTENSION, *PCE;


//
// Fdo Device Extension
//
typedef struct _FDO_EXTENSION {

    COMMON_EXTENSION;

    //
    // Devices that we have enumerated
    // 
    PDEVICE_OBJECT RawPortPdo;       // LPTx             - legacy "Raw Port" interface
    PDEVICE_OBJECT DaisyChainPdo[4]; // LPTx.0 -- LPTx.3 - IEEE 1284.3 daisy chain devices
    PDEVICE_OBJECT EndOfChainPdo;    // LPTx.4           - end-of-chain devices
    PDEVICE_OBJECT LegacyZipPdo;     // LPTx.5           - original (non-1284.3) Iomega Zip drive

    IEEE_STATE IeeeState;

    //
    // DisableEndOfChainBusRescan - if TRUE then do NOT rescan bus for change in End Of Chain (LPTx.4)
    //                              device in response to PnP IRP_MN_QUERY_DEVICE_RELATIONS / BusRelations,
    //                              simply report the LPTx.4 device that we found on the previous bus rescan.
    //                            - if we did not have an End Of Chain device on the previous rescan then this
    //                              flag is ignored.
    //
    BOOLEAN DisableEndOfChainBusRescan;

    //
    // Points to the driver object that contains this instance of parport.
    //
    PDRIVER_OBJECT DriverObject;

    //
    // Points to the PDO
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Points to our parent
    //
    PDEVICE_OBJECT ParentDeviceObject;

    //
    // Counter is incremented by the "polling for printers" thread on
    // each failed attempt at reading the IEEE 1284 Device ID from the
    // device. When the counter hits a defined threshold the polling
    // thread considers the error unrecoverable and stops polling
    //
    ULONG PollingFailureCounter;

    // list head for list of PDOs to delete on Driver Unload
    LIST_ENTRY DevDeletionListHead;

    //
    // Queue of ALLOCATE & SELECT irps waiting to be processed.  Access with cancel spin lock.
    //
    LIST_ENTRY WorkQueue;

    // Queue Irps while waiting to be processed
    IRPQUEUE_CONTEXT IrpQueueContext;

    //
    // The number of irps in the queue where -1 represents
    // a free port, 0 represents an allocated port with
    // zero waiters, 1 represents an allocated port with
    // 1 waiter, etc...
    //
    // This variable must be accessed with the cancel spin
    // lock or at interrupt level whenever interrupts are
    // being used.
    //
    LONG WorkQueueCount;

    //
    // These structures hold the port address and range for the parallel port.
    //
    PARALLEL_PORT_INFORMATION  PortInfo;
    PARALLEL_PNP_INFORMATION   PnpInfo;

    //
    // Information about the interrupt so that we
    // can connect to it when we have a client that
    // uses the interrupt.
    //
    ULONG AddressSpace;
    ULONG EcpAddressSpace;

    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;

    BOOLEAN FoundInterrupt;
    KIRQL InterruptLevel;
    ULONG InterruptVector;
    KAFFINITY InterruptAffinity;
    KINTERRUPT_MODE InterruptMode;


    //
    // This list contains all of the interrupt service
    // routines registered by class drivers.  All access
    // to this list should be done at interrupt level.
    //
    // This list also contains all of the deferred port check
    // routines.  These routines are called whenever
    // the port is freed if there are no IRPs queued for
    // the port.  Access this list only at interrupt level.
    //
    LIST_ENTRY IsrList;

    //
    // The parallel port interrupt object.
    //
    PKINTERRUPT InterruptObject;

    //
    // Keep a reference count for the interrupt object.
    // This count should be referenced with the cancel
    // spin lock.
    //
    ULONG InterruptRefCount;

    //
    // DPC for freeing the port from the interrupt routine.
    //
    KDPC FreePortDpc;

    //
    // Points to workitem for freeing the port
    //
    PIO_WORKITEM FreePortWorkItem;

    //
    // Set at initialization to indicate that on the current
    // architecture we need to unmap the base register address
    // when we unload the driver.
    //
    BOOLEAN UnMapRegisters;

    //
    // Flags for ECP and EPP detection and changing of the modes
    //
    BOOLEAN NationalChecked;
    BOOLEAN NationalChipFound;
    BOOLEAN FilterMode;
    UCHAR EcrPortData;
    
    //
    // Structure that hold information from the Chip Filter Driver
    //
    PARALLEL_PARCHIP_INFO   ChipInfo;    

    UNICODE_STRING DeviceName;

    //
    // Current Device Power State
    //
    DEVICE_POWER_STATE DeviceState;
    SYSTEM_POWER_STATE SystemState;

    FAST_MUTEX     ExtensionFastMutex;
    FAST_MUTEX     OpenCloseMutex;

    KEVENT         FdoThreadEvent; // polling for printers thread waits w/timeout on this event

    WMILIB_CONTEXT                WmiLibContext;
    PARPORT_WMI_ALLOC_FREE_COUNTS WmiPortAllocFreeCounts;

    BOOLEAN CheckedForGenericEpp; // did we check for Generic (via the ECR) EPP capability?
    BOOLEAN FdoWaitingOnPort;
    BOOLEAN spare[2];

    // Used to increase our confidence that this is a ParPort extension
    ULONG   Signature2; 

} FDO_EXTENSION, *PFDO_EXTENSION;

typedef struct _PDO_EXTENSION {

    COMMON_EXTENSION;

    ULONG   DeviceStateFlags;   // Device State - See Device State Flags above

    ULONG   DeviceType;         // - deprecated, use DevType in COMMON_EXTENSION - PAR_DEVTYPE_FDO=0x1, PODO=0x2, or PDO=0x4

    enum _PdoType PdoType;

    PDEVICE_OBJECT Fdo;         // Points to our FDO (bus driver/parent device)

    PCHAR  Mfg;                 // MFG field from device's IEEE 1284 ID string
    PCHAR  Mdl;                 // MDL field from device's IEEE 1284 ID string
    PCHAR  Cid;                 // CID (Compatible ID) field from device's IEEE 1284 ID string
    PWSTR  PdoName;             // name used in call to IoCreateDevice
    PWSTR  SymLinkName;         // name used in call to IoCreateUnprotectedSymbolicLink

    LIST_ENTRY DevDeletionList; // used by driver to create list of PDOs to delete on Driver Unload

    // UCHAR   DaisyChainId;       // 0..3 if PdoTypeDaisyChain, ignored otherwise

    UCHAR   Ieee1284_3DeviceId; // PDO - 0..3 is 1284.3 Daisy Chain device, 4 is End-Of-Chain Device, 5 is Legacy Zip
    BOOLEAN IsPdo;              // TRUE == this is either a PODO or a PDO - use DeviceIdString[0] to distinguish
    BOOLEAN EndOfChain;         // PODO - TRUE==NOT a .3 daisy chain dev - deprecated, use Ieee1284_3DeviceId==4 instead
    BOOLEAN PodoRegForWMI;      // has this PODO registered for WMI callbacks?

    PDEVICE_OBJECT ParClassFdo; // P[O]DO - points to the ParClass FDO

    PDEVICE_OBJECT ParClassPdo; // FDO    - points to first P[O]DO in list of ParClass created PODOs and PDOs

    PDEVICE_OBJECT Next;        // P[O]DO - points to the next DO in the list of ParClass ejected P[O]DOs

    PDEVICE_OBJECT PortDeviceObject;    // P[O]DO - points to the associated ParPort device object

    PFILE_OBJECT   PortDeviceFileObject;// P[O]DO - referenced pointer to a FILE created against PortDeviceObject

    UNICODE_STRING PortSymbolicLinkName;// P[O]DO - Sym link name of the assoc ParPort device - used to open a FILE

    PDEVICE_OBJECT PhysicalDeviceObject;// FDO - The PDO passed to ParPnPAddDevice

    PDEVICE_OBJECT ParentDeviceObject;  // FDO - parent DO returned by IoAttachDeviceToDeviceStack
    PIRP CurrentOpIrp;                  // IRP that our thread is currently processing
    PVOID NotificationHandle;           // PlugPlay Notification Handle

    ULONG Event22Delay;                 // time in microseconds to delay prior to setting event 22 in IEEE 1284 Termination

    ULONG TimerStart;           // initial value used for countdown when starting an operation

    BOOLEAN CreatedSymbolicLink; // P[O]DO - did we create a Symbolic Link for this device?

    BOOLEAN UsePIWriteLoop;     // P[O]DO - do we want to use processor independant write loop?

    BOOLEAN ParPortDeviceGone;  // Is our ParPort device object gone, possibly surprise removed?

    BOOLEAN RegForPptRemovalRelations; // Are we registered for ParPort removal relations?

    UCHAR   Ieee1284Flags;             // is device Stl older 1284.3 spec device?

    BOOLEAN DeleteOnRemoveOk;          // True means that it is OK to call IoDeleteDevice during IRP_MN_REMOVE_DEVICE processing
                                       // - FDO sets this to True during QDR/BusRelations processing if it detects that the hardware 
                                       //   is no longer present.

    USHORT        IdxForwardProtocol;  // see afpForward[] in ieee1284.c
    USHORT        IdxReverseProtocol;  // see arpReverse[] in ieee1284.c
    ULONG         CurrentEvent;        // IEEE 1284 event - see IEEE 1284-1994 spec
    P1284_PHASE   CurrentPhase;      // see parallel.h for enum def - PHASE_UNKNOWN, ..., PHASE_INTERRUPT_HOST
    P1284_HW_MODE PortHWMode;        // see parallel.h for enum def - HW_MODE_COMPATIBILITY, ..., HW_MODE_CONFIGURATION

    FAST_MUTEX OpenCloseMutex;  // protect manipulation of OpenCloseRefCount

    FAST_MUTEX DevObjListMutex; // protect manipulation of list of ParClass ejected DOs

    LIST_ENTRY WorkQueue;       // Queue of irps waiting to be processed.

    KSEMAPHORE RequestSemaphore;// dispatch routines use this to tell device worker thread that there is work to do

    //
    // PARALLEL_PORT_INFORMATION returned by IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO
    //
    PHYSICAL_ADDRESS                OriginalController;
    PUCHAR                          Controller;
    PUCHAR                          EcrController;
    ULONG                           SpanOfController;
    PPARALLEL_TRY_ALLOCATE_ROUTINE  TryAllocatePort; // nonblocking callback to allocate ParPort device
    PPARALLEL_FREE_ROUTINE          FreePort;        // callback to free ParPort device
    PPARALLEL_QUERY_WAITERS_ROUTINE QueryNumWaiters; // callback to query number of waiters in port allocation queue
    PVOID                           PortContext;     // context for callbacks to ParPort

    //
    // subset of PARALLEL_PNP_INFORMATION returned by IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO
    //
    ULONG                           HardwareCapabilities;
    PPARALLEL_SET_CHIP_MODE         TrySetChipMode;
    PPARALLEL_CLEAR_CHIP_MODE       ClearChipMode;
    PPARALLEL_TRY_SELECT_ROUTINE    TrySelectDevice;
    PPARALLEL_DESELECT_ROUTINE      DeselectDevice;
    ULONG                           FifoDepth;
    ULONG                           FifoWidth;

    BOOLEAN                         bAllocated; // have we allocated associated ParPort device?
                                                // Note: during some PnP processing we may have the port
                                                //   for a short duration without setting this value to TRUE

    ULONG BusyDelay;            // number of microseconds to wait after strobing a byte before checking the BUSY line.

    BOOLEAN BusyDelayDetermined;// Indicates if the BusyDelay parameter has been computed yet.

    PWORK_QUEUE_ITEM DeferredWorkItem; // Holds the work item used to defer printer initialization

    // If the registry entry by the same name is set, run the parallel
    // thread at the priority we used for NT 3.5 - this solves some
    // cases where a dos app spinning for input in the foreground is
    // starving the parallel thread
    BOOLEAN UseNT35Priority;

    ULONG InitializationTimeout;// timeout in seconds to wait for device to respond to an initialization request
                                //  - default == 15 seconds
                                //  - value overridden by registry entry of same name
                                //  - we will spin for max amount if no device attached

    LARGE_INTEGER AbsoluteOneSecond;// constants that are cheaper to put here rather 
    LARGE_INTEGER OneSecond;        //   than in bss

    //
    // IEEE 1284 Mode support
    //
    PPROTOCOL_READ_ROUTINE  fnRead;    // Current pointer to a valid read funtion
    PPROTOCOL_WRITE_ROUTINE fnWrite;   // Current pointer to a valid write Funtion
    BOOLEAN       Connected;           // are we currently negotiated into a 1284 mode?
    BOOLEAN       AllocatedByLockPort; // are we currently allocated via IOCTL_INTERNAL_LOCK_PORT?
    USHORT        spare4[2];
    LARGE_INTEGER IdleTimeout;         // how long do we hold the port on the caller's behalf following an operation?
    USHORT        ProtocolData[FAMILY_MAX];
    UCHAR         ForwardInterfaceAddress;
    UCHAR         ReverseInterfaceAddress;
    BOOLEAN       SetForwardAddress;
    BOOLEAN       SetReverseAddress;
    FAST_MUTEX    LockPortMutex;

    DEVICE_POWER_STATE DeviceState;// Current Device Power State
    SYSTEM_POWER_STATE SystemState;// Current System Power State

    ULONG         spare2;
    BOOLEAN       bShadowBuffer;
    Queue         ShadowBuffer;
    ULONG         spare3;
    BOOLEAN       bSynchWrites;      // TRUE if ECP HW writes should be synchronous
    BOOLEAN       bFirstByteTimeout; // TRUE if bus just reversed, means give the
                                     //   device some time to respond with some data
    BOOLEAN       bIsHostRecoverSupported;  // Set via IOCTL_PAR_ECP_HOST_RECOVERY.
                                            // HostRecovery will not be utilized unless this bit is set
    KEVENT        PauseEvent; // PnP dispatch routine uses this to pause worker thread during
                              //   during QUERY_STOP, STOP, and QUERY_REMOVE states

    USHORT        ProtocolModesSupported;
    USHORT        BadProtocolModes;

    PARALLEL_SAFETY       ModeSafety;
    BOOLEAN               IsIeeeTerminateOk;
    DOT3DL_PCTL           P12843DL;

    // WMI
    PARALLEL_WMI_LOG_INFO log;
    WMILIB_CONTEXT        WmiLibContext;
    LONG                  WmiRegistrationCount;  // number of times this device has registered with WMI

    // PnP Query ID results
    UCHAR DeviceIdString[MAX_ID_SIZE];    // IEEE 1284 DeviceID string massaged/checksum'd to match INF form
    UCHAR DeviceDescription[MAX_ID_SIZE]; // "Manufacturer<SPACE>Model" from IEEE 1284 DeviceID string

    ULONG                 dummy; // dummy word to force RemoveLock to QuadWord alignment
    PVOID                 HwProfileChangeNotificationHandle;
    ULONG                 Signature2; // keep this the last member in extension
} PDO_EXTENSION, *PPDO_EXTENSION;

typedef struct _SYNCHRONIZED_COUNT_CONTEXT {
    PLONG   Count;
    LONG    NewCount;
} SYNCHRONIZED_COUNT_CONTEXT, *PSYNCHRONIZED_COUNT_CONTEXT;

typedef struct _SYNCHRONIZED_LIST_CONTEXT {
    PLIST_ENTRY List;
    PLIST_ENTRY NewEntry;
} SYNCHRONIZED_LIST_CONTEXT, *PSYNCHRONIZED_LIST_CONTEXT;

typedef struct _SYNCHRONIZED_DISCONNECT_CONTEXT {
    PFDO_EXTENSION                   Extension;
    PPARALLEL_INTERRUPT_SERVICE_ROUTINE IsrInfo;
} SYNCHRONIZED_DISCONNECT_CONTEXT, *PSYNCHRONIZED_DISCONNECT_CONTEXT;

typedef struct _ISR_LIST_ENTRY {
    LIST_ENTRY                  ListEntry;
    PKSERVICE_ROUTINE           ServiceRoutine;
    PVOID                       ServiceContext;
    PPARALLEL_DEFERRED_ROUTINE  DeferredPortCheckRoutine;
    PVOID                       CheckContext;
} ISR_LIST_ENTRY, *PISR_LIST_ENTRY;

typedef struct _REMOVAL_RELATIONS_LIST_ENTRY {
    LIST_ENTRY                  ListEntry;
    PDEVICE_OBJECT              DeviceObject;
    ULONG                       Flags;
    UNICODE_STRING              DeviceName;
} REMOVAL_RELATIONS_LIST_ENTRY, *PREMOVAL_RELATIONS_LIST_ENTRY;


// former ecp.h follows:

#define DEFAULT_ECP_CHANNEL 0

#define ParTestEcpWrite(X)                                               \
                (X->CurrentPhase != PHASE_FORWARD_IDLE && X->CurrentPhase != PHASE_FORWARD_XFER)  \
                 ? STATUS_IO_DEVICE_ERROR : STATUS_SUCCESS

// ==================================================================
// The following RECOVER codes are used for Hewlett-Packard devices.
// Do not remove any of the error codes.  These recover codes are
// used to quickly get the host and periph back to a known state.
// When using a recover code, add a comment where it is used at...
#define RECOVER_0           0       // Reserved - not used anywhere
#define RECOVER_1           1       // ECP_Terminate
#define RECOVER_2           2       // SLP_SetupPhase init
#define RECOVER_3           3       // SLP_FTP init DCR
#define RECOVER_4           4       // SLP_FTP init DSR
#define RECOVER_5           5       // SLP_FTP data xfer DCR
#define RECOVER_6           6       // SLP_FRP init DCR
#define RECOVER_7           7       // SLP_FRP init DSR
#define RECOVER_8           8       // SLP_FRP state 38 DCR
#define RECOVER_9           9       // SLP_FRP state 39 DCR
#define RECOVER_10          10      // SLP_FRP state 40 DSR
#define RECOVER_11          11      // SLP_RTP init DCR
#define RECOVER_12          12      // SLP_RTP init DSR
#define RECOVER_13          13      // SLP_RTP state 43 DCR
#define RECOVER_14          14      // SLP_RFP init DCR
#define RECOVER_15          15      // SLP_RFP init DSR
#define RECOVER_16          16      // SLP_RFP state 47- DCR
#define RECOVER_17          17      // SLP_RFP state 47 DCR
#define RECOVER_18          18      // SLP_RFP state 48 DSR
#define RECOVER_19          19      // SLP_RFP state 49 DSR
#define RECOVER_20          20      // ZIP_EmptyFifo DCR
#define RECOVER_21          21      // ZIP_FTP init DCR
#define RECOVER_22          22      // ZIP_FTP init DSR
#define RECOVER_23          23      // ZIP_FTP data xfer DCR
#define RECOVER_24      24      // ZIP_FRP init DSR
#define RECOVER_25      25      // ZIP_FRP init DCR
#define RECOVER_26      26      // ZIP_FRP state 38 DCR
#define RECOVER_27      27      // ZIP_FRP state 39 DCR
#define RECOVER_28      28      // ZIP_FRP state 40 DSR
#define RECOVER_29      29      // ZIP_FRP state 41 DCR
#define RECOVER_30      30      // ZIP_RTP init DSR
#define RECOVER_31      31      // ZIP_RTP init DCR
#define RECOVER_32      32      // ZIP_RFP init DSR
#define RECOVER_33      33      // ZIP_RFP init DCR
#define RECOVER_34      34      // ZIP_RFP state 47- DCR
#define RECOVER_35      35      // ZIP_RFP state 47 DCR
#define RECOVER_36      36      // ZIP_RFP state 48 DSR
#define RECOVER_37      37      // ZIP_RFP state 49 DSR
#define RECOVER_38      38      // ZIP_RFP state 49+ DCR
#define RECOVER_39      39      // Slippy_Terminate 
#define RECOVER_40      40      // ZIP_SCA init DCR
#define RECOVER_41      41      // ZIP_SCA init DSR
#define RECOVER_42      42      // SLP_SCA init DCR
#define RECOVER_43      43      // SLP_SCA init DSR
#define RECOVER_44      44      // ZIP_SP init DCR
#define RECOVER_45      45      // SIP_FRP init DSR
#define RECOVER_46      46      // SIP_FRP init DCR
#define RECOVER_47      47      // SIP_FRP state 38 DCR
#define RECOVER_48      48      // SIP_FRP state 39 DCR
#define RECOVER_49      49      // SIP_FRP state 40 DSR
#define RECOVER_50      50      // SIP_RTP init DCR
#define RECOVER_51      51      // SIP_RFP init DSR
#define RECOVER_52      52      // SIP_RFP state 43 DCR

// former ecp.h preceeds

// former hwecp.h follows

//--------------------------------------------------------------------------
// Printer status constants.   Seem to only be used by hwecp
//--------------------------------------------------------------------------
#define CHKPRNOK        0xDF        // DSR value indicating printer ok.
#define CHKPRNOFF1      0x87        // DSR value indicating printer off.
#define CHKPRNOFF2      0x4F        // DSR value indicating printer off.
#define CHKNOCABLE      0x7F        // DSR value indicating no cable.
#define CHKPRNOFLIN     0xCF        // DSR value indicating printer offline.
#define CHKNOPAPER      0xEF        // DSR value indicating out of paper.
#define CHKPAPERJAM     0xC7        // DSR value indicating paper jam.

// former hwecp.h preceeds

// former parclass.h follows

#define REQUEST_DEVICE_ID   TRUE
#define HAVE_PORT_KEEP_PORT TRUE

// enable scans for Legacy Zip?
extern ULONG ParEnableLegacyZip;

#define PAR_LGZIP_PSEUDO_1284_ID_STRING "MFG:IMG;CMD:;MDL:VP0;CLS:SCSIADAPTER;DES:IOMEGA PARALLEL PORT"
extern PCHAR ParLegacyZipPseudoId;

#define USE_PAR3QUERYDEVICEID 1

extern LARGE_INTEGER  AcquirePortTimeout; // timeout for IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE
extern ULONG          g_NumPorts;         // used to generate N in \Device\ParallelN ClassName
extern UNICODE_STRING RegistryPath;       // copy of the registry path passed to DriverEntry()

extern ULONG DumpDevExtTable;

// Driver Globals
extern ULONG SppNoRaiseIrql; // 0  == original raise IRQL behavior in SPP
                             // !0 == new behavior - disable raise IRQL 
                             //   and insert some KeDelayExecutionThread 
                             //   calls while waiting for peripheral response

extern ULONG DefaultModes;   // Upper USHORT is Reverse Default Mode, Lower is Forward Default Mode
                             // if == 0, or invalid, then use default of Nibble/Centronics

extern ULONG WarmPollPeriod; // time between polls for printers (in seconds)

extern BOOLEAN           PowerStateIsAC;    
extern PCALLBACK_OBJECT  PowerStateCallbackObject;
extern PVOID             PowerStateCallbackRegistration;


#define PAR_NO_FAST_CALLS 1
#if PAR_NO_FAST_CALLS
VOID
ParCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

NTSTATUS
ParCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
#else
#define ParCompleteRequest(a,b) IoCompleteRequest(a,b)
#define ParCallDriver(a,b) IoCallDriver(a,b)
#endif

extern const PHYSICAL_ADDRESS PhysicalZero;

//
// For the above directory, the serial port will
// use the following name as the suffix of the serial
// ports for that directory.  It will also append
// a number onto the end of the name.  That number
// will start at 1.
//
#define DEFAULT_PARALLEL_NAME L"LPT"

//
// This is the parallel class name.
//
#define DEFAULT_NT_SUFFIX L"Parallel"


#define PARALLEL_DATA_OFFSET    0
#define PARALLEL_STATUS_OFFSET  1
#define PARALLEL_CONTROL_OFFSET 2
#define PARALLEL_REGISTER_SPAN  3

//
// Ieee 1284 constants (Protocol Families)
//
#define FAMILY_NONE             0x0
#define FAMILY_REVERSE_NIBBLE   0x1
#define FAMILY_REVERSE_BYTE     0x2
#define FAMILY_ECP              0x3
#define FAMILY_EPP              0x4
#define FAMILY_BECP             0x5
#define FAMILY_MAX              FAMILY_BECP

//
// For pnp id strings
//
#define MAX_ID_SIZE 256

// used to construct IEEE 1284.3 "Dot" name suffixes 
// table lookup for integer to WCHAR conversion
#define PAR_UNICODE_PERIOD L'.'
#define PAR_UNICODE_COLON  L':'


//
// DeviceStateFlags
//
#define PAR_DEVICE_DELETED             ((ULONG)0x00000002) // IoDeleteDevice has been called
#define PAR_DEVICE_PAUSED              ((ULONG)0x00000010) // stop-pending, stopped, or remove-pending states
#define PAR_DEVICE_PORT_REMOVE_PENDING ((ULONG)0x00000200) // our ParPort is in a Remove Pending State

#define PAR_REV_MODE_SKIP_MASK    (CHANNEL_NIBBLE | BYTE_BIDIR | EPP_ANY | ECP_ANY)
#define PAR_FWD_MODE_SKIP_MASK   (EPP_ANY | BOUNDED_ECP | ECP_HW_NOIRQ | ECP_HW_IRQ)
#define PAR_MAX_CHANNEL 127
#define PAR_COMPATIBILITY_RESET 300


//
// ParClass DeviceObject structure
// 
//   - Lists the ParClass created PODO and all PDOs associated with a specific ParPort device
//
typedef struct _PAR_DEVOBJ_STRUCT {
    PUCHAR                    Controller;    // host controller address for devices in this structure
    PDEVICE_OBJECT            LegacyPodo;    // legacy or "raw" port device
    PDEVICE_OBJECT            EndOfChainPdo; // End-Of-Chain PnP device
    PDEVICE_OBJECT            Dot3Id0Pdo;    // 1284.3 daisy chain device, 1284.3 deviceID == 0
    PDEVICE_OBJECT            Dot3Id1Pdo;
    PDEVICE_OBJECT            Dot3Id2Pdo;
    PDEVICE_OBJECT            Dot3Id3Pdo;    // 1284.3 daisy chain device, 1284.3 deviceID == 3
    PDEVICE_OBJECT            LegacyZipPdo;  // Legacy Zip Drive
    PFILE_OBJECT              pFileObject;   // Need an open handle to ParPort device to prevent it
                                             //    from being removed out from under us
    struct _PAR_DEVOBJ_STRUCT *Next;
} PAR_DEVOBJ_STRUCT, *PPAR_DEVOBJ_STRUCT;

//
// Used in device extension for DeviceType field
//
#define PAR_DEVTYPE_FDO    0x00000001
#define PAR_DEVTYPE_PODO   0x00000002
#define PAR_DEVTYPE_PDO    0x00000004



//
// Protocol structure definitions
//

typedef
BOOLEAN
(*PPROTOCOL_IS_MODE_SUPPORTED_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_CONNECT_ROUTINE) (
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

typedef
VOID
(*PPROTOCOL_DISCONNECT_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_ENTER_FORWARD_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_EXIT_FORWARD_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_ENTER_REVERSE_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_EXIT_REVERSE_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
VOID
(*PPROTOCOL_READSHADOW_ROUTINE) (
    IN Queue *pShadowBuffer,
    IN PUCHAR  lpsBufPtr,
    IN ULONG   dCount,
    OUT ULONG *fifoCount
    );

typedef
BOOLEAN
(*PPROTOCOL_HAVEREADDATA_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_SET_INTERFACE_ADDRESS_ROUTINE) (
    IN  PPDO_EXTENSION   Extension,
    IN  UCHAR               Address
    );

typedef struct _FORWARD_PTCL {
    PPROTOCOL_IS_MODE_SUPPORTED_ROUTINE     fnIsModeSupported;
    PPROTOCOL_CONNECT_ROUTINE               fnConnect;
    PPROTOCOL_DISCONNECT_ROUTINE            fnDisconnect;
    PPROTOCOL_SET_INTERFACE_ADDRESS_ROUTINE fnSetInterfaceAddress;
    PPROTOCOL_ENTER_FORWARD_ROUTINE         fnEnterForward;
    PPROTOCOL_EXIT_FORWARD_ROUTINE          fnExitForward;
    PPROTOCOL_WRITE_ROUTINE                 fnWrite;
    USHORT                                  Protocol;
    USHORT                                  ProtocolFamily;
} FORWARD_PTCL, *PFORWARD_PTCL;

typedef struct _REVERSE_PTCL {
    PPROTOCOL_IS_MODE_SUPPORTED_ROUTINE     fnIsModeSupported;
    PPROTOCOL_CONNECT_ROUTINE               fnConnect;
    PPROTOCOL_DISCONNECT_ROUTINE            fnDisconnect;
    PPROTOCOL_SET_INTERFACE_ADDRESS_ROUTINE fnSetInterfaceAddress;
    PPROTOCOL_ENTER_REVERSE_ROUTINE         fnEnterReverse;
    PPROTOCOL_EXIT_REVERSE_ROUTINE          fnExitReverse;
    PPROTOCOL_READSHADOW_ROUTINE            fnReadShadow;
    PPROTOCOL_HAVEREADDATA_ROUTINE          fnHaveReadData;
    PPROTOCOL_READ_ROUTINE                  fnRead;
    USHORT                                  Protocol;
    USHORT                                  ProtocolFamily;
} REVERSE_PTCL, *PREVERSE_PTCL;

extern FORWARD_PTCL    afpForward[];
extern REVERSE_PTCL    arpReverse[];

//
// WARNING...Make sure that enumeration matches the protocol array...
//
typedef enum _FORWARD_MODE {

    FORWARD_FASTEST     = 0,                // 0  
    BOUNDED_ECP_FORWARD = FORWARD_FASTEST,  // 0
    ECP_HW_FORWARD_NOIRQ,                   // 1
    EPP_HW_FORWARD,                         // 2
    EPP_SW_FORWARD,                         // 3
    ECP_SW_FORWARD, //......................// 4
    IEEE_COMPAT_MODE,                       // 6
    CENTRONICS_MODE,                        // 7
    FORWARD_NONE                            // 8

} FORWARD_MODE;

typedef enum _REVERSE_MODE {

    REVERSE_FASTEST     = 0,                // 0
    BOUNDED_ECP_REVERSE = REVERSE_FASTEST,  // 0
    ECP_HW_REVERSE_NOIRQ,                   // 1
    EPP_HW_REVERSE,                         // 2
    EPP_SW_REVERSE,                         // 3
    ECP_SW_REVERSE, //......................// 4
    BYTE_MODE,                              // 5
    NIBBLE_MODE,                            // 6
    CHANNELIZED_NIBBLE_MODE,                // 7
    REVERSE_NONE                            // 8 

} REVERSE_MODE;

//
// Ieee Extensibility constants
//

#define NIBBLE_EXTENSIBILITY        0x00
#define BYTE_EXTENSIBILITY          0x01
#define CHANNELIZED_EXTENSIBILITY   0x08
#define ECP_EXTENSIBILITY           0x10
#define BECP_EXTENSIBILITY          0x18
#define EPP_EXTENSIBILITY           0x40
#define DEVICE_ID_REQ               0x04

//
// Bit Definitions in the status register.
//

#define PAR_STATUS_NOT_ERROR    0x08 //not error on device
#define PAR_STATUS_SLCT         0x10 //device is selected (on-line)
#define PAR_STATUS_PE           0x20 //paper empty
#define PAR_STATUS_NOT_ACK      0x40 //not acknowledge (data transfer was not ok)
#define PAR_STATUS_NOT_BUSY     0x80 //operation in progress

//
//  Bit Definitions in the control register.
//

#define PAR_CONTROL_STROBE      0x01 //to read or write data
#define PAR_CONTROL_AUTOFD      0x02 //to autofeed continuous form paper
#define PAR_CONTROL_NOT_INIT    0x04 //begin an initialization routine
#define PAR_CONTROL_SLIN        0x08 //to select the device
#define PAR_CONTROL_IRQ_ENB     0x10 //to enable interrupts
#define PAR_CONTROL_DIR         0x20 //direction = read
#define PAR_CONTROL_WR_CONTROL  0xc0 //the 2 highest bits of the control
                                     // register must be 1
//
// More bit definitions.
//

#define DATA_OFFSET         0
#define DSR_OFFSET          1
#define DCR_OFFSET          2

#define OFFSET_DATA     DATA_OFFSET // Put in for compatibility with legacy code
#define OFFSET_DSR      DSR_OFFSET  // Put in for compatibility with legacy code
#define OFFSET_DCR      DCR_OFFSET  // Put in for compatibility with legacy code

//
// Bit definitions for the DSR.
//

#define DSR_NOT_BUSY            0x80
#define DSR_NOT_ACK             0x40
#define DSR_PERROR              0x20
#define DSR_SELECT              0x10
#define DSR_NOT_FAULT           0x08

//
// More bit definitions for the DSR.
//

#define DSR_NOT_PTR_BUSY        0x80
#define DSR_NOT_PERIPH_ACK      0x80
#define DSR_WAIT                0x80
#define DSR_PTR_CLK             0x40
#define DSR_PERIPH_CLK          0x40
#define DSR_INTR                0x40
#define DSR_ACK_DATA_REQ        0x20
#define DSR_NOT_ACK_REVERSE     0x20
#define DSR_XFLAG               0x10
#define DSR_NOT_DATA_AVAIL      0x08
#define DSR_NOT_PERIPH_REQUEST  0x08

//
// Bit definitions for the DCR.
//

#define DCR_RESERVED            0xC0
#define DCR_DIRECTION           0x20
#define DCR_ACKINT_ENABLED      0x10
#define DCR_SELECT_IN           0x08
#define DCR_NOT_INIT            0x04
#define DCR_AUTOFEED            0x02
#define DCR_STROBE              0x01

//
// More bit definitions for the DCR.
//

#define DCR_NOT_1284_ACTIVE     0x08
#define DCR_ASTRB               0x08
#define DCR_NOT_REVERSE_REQUEST 0x04
#define DCR_NOT_HOST_BUSY       0x02
#define DCR_NOT_HOST_ACK        0x02
#define DCR_DSTRB               0x02
#define DCR_NOT_HOST_CLK        0x01
#define DCR_WRITE               0x01

#define DCR_NEUTRAL (DCR_RESERVED | DCR_SELECT_IN | DCR_NOT_INIT)

//
// Give a timeout of 300 seconds.  Some postscript printers will
// buffer up a lot of commands then proceed to render what they
// have.  The printer will then refuse to accept any characters
// until it's done with the rendering.  This render process can
// take a while.  We'll give it 300 seconds.
//
// Note that an application can change this value.
//
#define PAR_WRITE_TIMEOUT_VALUE 300


#ifdef JAPAN // IBM-J printers

//
// Support for IBM-J printers.
//
// When the printer operates in Japanese (PS55) mode, it redefines
// the meaning of parallel lines so that extended error status can
// be reported.  It is roughly compatible with PC/AT, but we have to
// take care of a few cases where the status looks like PC/AT error
// condition.
//
// Status      Busy /AutoFdXT Paper Empty Select /Fault
// ------      ---- --------- ----------- ------ ------
// Not RMR      1    1         1           1      1
// Head Alarm   1    1         1           1      0
// ASF Jam      1    1         1           0      0
// Paper Empty  1    0         1           0      0
// No Error     0    0         0           1      1
// Can Req      1    0         0           0      1
// Deselect     1    0         0           0      0
//
// The printer keeps "Not RMR" during the parallel port
// initialization, then it takes "Paper Empty", "No Error"
// or "Deselect".  Other status can be thought as an
// H/W error condition.
//
// Namely, "Not RMR" conflicts with PAR_NO_CABLE and "Deselect"
// should also be regarded as another PAR_OFF_LINE.  When the
// status is PAR_PAPER_EMPTY, the initialization is finished
// (we should not send init purlse again.)
//
// See ParInitializeDevice() for more information.
//
// [takashim]

#define PAR_OFF_LINE_COMMON( Status ) ( \
            (IsNotNEC_98) ? \
            (Status & PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            !(Status & PAR_STATUS_SLCT) : \
\
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            !(Status & PAR_STATUS_SLCT) \
             )

#define PAR_OFF_LINE_IBM55( Status ) ( \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            ((Status & PAR_STATUS_SLCT) ^ PAR_STATUS_SLCT) && \
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR))

#define PAR_PAPER_EMPTY2( Status ) ( \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            (Status & PAR_STATUS_PE) && \
            ((Status & PAR_STATUS_SLCT) ^ PAR_STATUS_SLCT) && \
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR))

//
// Redefine this for Japan.
//

#define PAR_OFF_LINE( Status ) ( \
            PAR_OFF_LINE_COMMON( Status ) || \
            PAR_OFF_LINE_IBM55( Status ))

#else // JAPAN
//
// Busy, not select, not error
//
// !JAPAN

#define PAR_OFF_LINE( Status ) ( \
            (IsNotNEC_98) ? \
            (Status & PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            !(Status & PAR_STATUS_SLCT) : \
\
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            !(Status & PAR_STATUS_SLCT) \
            )

#endif // JAPAN

//
// Busy, PE
//

#define PAR_PAPER_EMPTY( Status ) ( \
            (Status & PAR_STATUS_PE) )

//
// error, ack, not busy
//

#define PAR_POWERED_OFF( Status ) ( \
            (IsNotNEC_98) ? \
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_ACK) ^ PAR_STATUS_NOT_ACK) && \
            (Status & PAR_STATUS_NOT_BUSY) : \
\
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            (Status & PAR_STATUS_NOT_ACK) && \
            (Status & PAR_STATUS_NOT_BUSY) \
            )

//
// not error, not busy, not select
//

#define PAR_NOT_CONNECTED( Status ) ( \
            (Status & PAR_STATUS_NOT_ERROR) && \
            (Status & PAR_STATUS_NOT_BUSY) &&\
            !(Status & PAR_STATUS_SLCT) )

//
// not error, not busy
//

#define PAR_OK(Status) ( \
            (Status & PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            (Status & PAR_STATUS_NOT_BUSY) )

//
// busy, select, not error
//

#define PAR_POWERED_ON(Status) ( \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            (Status & PAR_STATUS_SLCT) && \
            (Status & PAR_STATUS_NOT_ERROR))

//
// busy, not error
//

#define PAR_BUSY(Status) (\
             (( Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
             ( Status & PAR_STATUS_NOT_ERROR ) )

//
// selected
//

#define PAR_SELECTED(Status) ( \
            ( Status & PAR_STATUS_SLCT ) )

//
// No cable attached.
//

#define PAR_NO_CABLE(Status) ( \
            (IsNotNEC_98) ?                                           \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            (Status & PAR_STATUS_NOT_ACK) &&                          \
            (Status & PAR_STATUS_PE) &&                               \
            (Status & PAR_STATUS_SLCT) &&                             \
            (Status & PAR_STATUS_NOT_ERROR) :                         \
                                                                      \
            (Status & PAR_STATUS_NOT_BUSY) &&                         \
            (Status & PAR_STATUS_NOT_ACK) &&                          \
            (Status & PAR_STATUS_PE) &&                               \
            (Status & PAR_STATUS_SLCT) &&                             \
            (Status & PAR_STATUS_NOT_ERROR)                           \
            )

//
// not error, not busy, selected.
//

#define PAR_ONLINE(Status) (                              \
            (Status & PAR_STATUS_NOT_ERROR) &&            \
            (Status & PAR_STATUS_NOT_BUSY) &&             \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            (Status & PAR_STATUS_SLCT) )


//BOOLEAN
//ParCompareGuid(
//  IN LPGUID guid1,
//  IN LPGUID guid2
//  )
//
#define ParCompareGuid(g1, g2)  (                                    \
        ( (g1) == (g2) ) ?                                           \
        TRUE :                                                       \
        RtlCompareMemory( (g1), (g2), sizeof(GUID) ) == sizeof(GUID) \
        )


//VOID StoreData(
//      IN PUCHAR RegisterBase,
//      IN UCHAR DataByte
//      )
// Data must be on line before Strobe = 1;
// Strobe = 1, DIR = 0
// Strobe = 0
//
// We change the port direction to output (and make sure stobe is low).
//
// Note that the data must be available at the port for at least
// .5 microseconds before and after you strobe, and that the strobe
// must be active for at least 500 nano seconds.  We are going
// to end up stalling for twice as much time as we need to, but, there
// isn't much we can do about that.
//
// We put the data into the port and wait for 1 micro.
// We strobe the line for at least 1 micro
// We lower the strobe and again delay for 1 micro
// We then revert to the original port direction.
//
// Thanks to Olivetti for advice.
//

#define StoreData(RegisterBase,DataByte)                            \
{                                                                   \
    PUCHAR _Address = RegisterBase;                                 \
    UCHAR _Control;                                                 \
    _Control = GetControl(_Address);                                \
    ASSERT(!(_Control & PAR_CONTROL_STROBE));                       \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)(_Control & ~(PAR_CONTROL_STROBE | PAR_CONTROL_DIR)) \
        );                                                          \
    P5WritePortUchar(                                               \
        _Address+PARALLEL_DATA_OFFSET,                              \
        (UCHAR)DataByte                                             \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)((_Control | PAR_CONTROL_STROBE) & ~PAR_CONTROL_DIR) \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)(_Control & ~(PAR_CONTROL_STROBE | PAR_CONTROL_DIR)) \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)_Control                                             \
        );                                                          \
}

//
// Function prototypes
//

//
// parpnp.c
//
#ifndef STATIC_LOAD

NTSTATUS
ParPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

NTSTATUS
ParParallelPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParCheckParameters(
    IN OUT  PPDO_EXTENSION   Extension
    );

#endif

//
// oldinit.c
//

#ifdef STATIC_LOAD

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING PortName,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParInitializeClassDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath,
    IN  ULONG           ParallelPortNumber
    );

VOID
ParCheckParameters(
    IN      PUNICODE_STRING     RegistryPath,
    IN OUT  PPDO_EXTENSION   Extension
    );

#endif

//
// parclass.c
//

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

NTSTATUS
ParCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
PptPdoReadWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParInternalDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParQueryInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParSetInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParExportedNegotiateIeeeMode(
    IN PPDO_EXTENSION  Extension,
	IN USHORT             ModeMaskFwd,
	IN USHORT             ModeMaskRev,
    IN PARALLEL_SAFETY    ModeSafety,
	IN BOOLEAN            IsForward
    );

NTSTATUS
ParExportedTerminateIeeeMode(
    IN PPDO_EXTENSION   Extension
    );

//////////////////////////////////////////////////////////////////
//  Modes of operation
//////////////////////////////////////////////////////////////////

//
// spp.c
//

NTSTATUS
ParEnterSppMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

ULONG
SppWriteLoopPI(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite,
    IN  ULONG   BusyDelay
    );

ULONG
SppCheckBusyDelay(
    IN  PPDO_EXTENSION   Extension,
    IN  PUCHAR              WriteBuffer,
    IN  ULONG               NumBytesToWrite
    );

NTSTATUS
SppWrite(
    IN  PPDO_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    );

VOID
ParTerminateSppMode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
SppQueryDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR              DeviceIdBuffer,
    IN  ULONG               BufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    );

//
// sppieee.c
//
NTSTATUS
SppIeeeWrite(
    IN  PPDO_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    );

//
// nibble.c
//

BOOLEAN
ParIsChannelizedNibbleSupported(
    IN  PPDO_EXTENSION   Extension
    );
    
BOOLEAN
ParIsNibbleSupported(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEnterNibbleMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

NTSTATUS
ParEnterChannelizedNibbleMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateNibbleMode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParNibbleModeRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// Byte.c
//

BOOLEAN
ParIsByteSupported(
    IN  PPDO_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterByteMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateByteMode(
    IN  PPDO_EXTENSION   Extension
    );
    
NTSTATUS
ParByteModeRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// epp.c
//

NTSTATUS
ParEppSetAddress(
    IN  PPDO_EXTENSION   Extension,
    IN  UCHAR               Address
    );

//
// hwepp.c
//

BOOLEAN
ParIsEppHwSupported(
    IN  PPDO_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterEppHwMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

VOID
ParTerminateEppHwMode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEppHwWrite(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEppHwRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// swepp.c
//

BOOLEAN
ParIsEppSwWriteSupported(
    IN  PPDO_EXTENSION   Extension
    );
    
BOOLEAN
ParIsEppSwReadSupported(
    IN  PPDO_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterEppSwMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateEppSwMode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEppSwWrite(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEppSwRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// ecp.c and swecp.c
//

NTSTATUS
ParEcpEnterForwardPhase (
    IN  PPDO_EXTENSION   Extension
    );

BOOLEAN
ParEcpHaveReadData (
    IN  PPDO_EXTENSION   Extension
    );

BOOLEAN
ParIsEcpSwWriteSupported(
    IN  PPDO_EXTENSION   Extension
    );

BOOLEAN
ParIsEcpSwReadSupported(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEnterEcpSwMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

VOID 
ParCleanupSwEcpPort(
    IN  PPDO_EXTENSION   Extension
    );
    
VOID
ParTerminateEcpMode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpSetAddress(
    IN  PPDO_EXTENSION   Extension,
    IN  UCHAR               Address
    );

NTSTATUS
ParEcpSwWrite(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpSwRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpForwardToReverse(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpReverseToForward(
    IN  PPDO_EXTENSION   Extension
    );

//
// hwecp.c
//

BOOLEAN
PptEcpHwHaveReadData (
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwExitForwardPhase (
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
PptEcpHwEnterReversePhase (
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwExitReversePhase (
    IN  PPDO_EXTENSION   Extension
    );

VOID
PptEcpHwDrainShadowBuffer(IN Queue *pShadowBuffer,
                            IN PUCHAR  lpsBufPtr,
                            IN ULONG   dCount,
                            OUT ULONG *fifoCount);

NTSTATUS
ParEcpHwRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpHwWrite(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpHwSetAddress(
    IN  PPDO_EXTENSION   Extension,
    IN  UCHAR               Address
    );

NTSTATUS
ParEnterEcpHwMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

BOOLEAN
ParIsEcpHwSupported(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwSetupPhase(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParTerminateHwEcpMode(
    IN  PPDO_EXTENSION   Extension
    );

//
// becp.c
//

NTSTATUS
PptBecpExitReversePhase(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
PptBecpRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
PptEnterBecpMode(
    IN  PPDO_EXTENSION  Extension,
    IN  BOOLEAN         DeviceIdRequest
    );

BOOLEAN
PptIsBecpSupported(
    IN  PPDO_EXTENSION   Extension
    );
VOID
PptTerminateBecpMode(
    IN  PPDO_EXTENSION   Extension
    );

//
// p12843dl.c
//
NTSTATUS
ParDot3Connect(
    IN  PPDO_EXTENSION    Extension
    );

VOID
ParDot3CreateObject(
    IN  PPDO_EXTENSION   Extension,
    IN PCHAR DOT3DL,
    IN PCHAR DOT3C
    );

VOID
ParDot4CreateObject(
    IN  PPDO_EXTENSION   Extension,
    IN  PCHAR DOT4DL
    );

VOID
ParDot3ParseModes(
    IN  PPDO_EXTENSION   Extension,
    IN  PCHAR DOT3M
    );

VOID
ParMLCCreateObject(
    IN  PPDO_EXTENSION   Extension,
    IN PCHAR CMDField
    );

VOID
ParDot3DestroyObject(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParDot3Disconnect(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParDot3Read(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParDot3Write(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParMLCCompatReset(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParMLCECPReset(
    IN  PPDO_EXTENSION   Extension
    );

#if DBG
VOID
ParInitDebugLevel (
    IN PUNICODE_STRING RegistryPath
   );
#endif

// former parclass.h preceeds

#endif // _PARPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\legacyzip.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File: ppa3x.c
//
//--------------------------------------------------------------------------

#include "pch.h"

VOID
PptLegacyZipClockDiskModeByte(
    PUCHAR  Controller,
    UCHAR   ModeByte
    )
{
    P5WritePortUchar( Controller, ModeByte );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)DCR_NOT_INIT );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_NOT_INIT | DCR_AUTOFEED) );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)DCR_NOT_INIT );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_NOT_INIT | DCR_SELECT_IN) );

} // end PptLegacyZipClockDiskModeByte()

VOID
PptLegacyZipClockPrtModeByte(
    PUCHAR  Controller,
    UCHAR   ModeByte
    )
{
    P5WritePortUchar( Controller, ModeByte );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_SELECT_IN | DCR_NOT_INIT) );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_SELECT_IN | DCR_NOT_INIT | DCR_AUTOFEED) );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_SELECT_IN | DCR_NOT_INIT) );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)DCR_NOT_INIT );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_SELECT_IN | DCR_NOT_INIT) );

} // end PptLegacyZipClockPrtModeByte()

VOID
PptLegacyZipSetDiskMode(
    PUCHAR  Controller,
    UCHAR   Mode
    )
{
    ULONG i;

    for ( i = 0; i < LEGACYZIP_MODE_LEN; i++ ) {
        PptLegacyZipClockDiskModeByte( Controller, LegacyZipModeQualifier[i] );
    }

    PptLegacyZipClockDiskModeByte( Controller, Mode );

} // end of PptLegacyZipSetDiskMode()

BOOLEAN
PptLegacyZipCheckDevice(
    PUCHAR  Controller
    )
{
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_NOT_INIT | DCR_AUTOFEED) );

    if ( (P5ReadPortUchar( Controller+DSR_OFFSET ) & DSR_NOT_FAULT) == DSR_NOT_FAULT ) {

        P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)DCR_NOT_INIT );

        if ( (P5ReadPortUchar( Controller+DSR_OFFSET ) & DSR_NOT_FAULT) != DSR_NOT_FAULT ) {
            // A device was found
            return TRUE;
        }
    }

    // No device is there
    return FALSE;

} // end PptLegacyZipCheckDevice()

NTSTATUS
PptTrySelectLegacyZip(
    IN  PVOID   Context,
    IN  PVOID   TrySelectCommand
    )
{
    PFDO_EXTENSION           fdx   = Context;
    PPARALLEL_1284_COMMAND      Command     = TrySelectCommand;
    NTSTATUS                    Status      = STATUS_SUCCESS; // default success
    PUCHAR                      Controller  = fdx->PortInfo.Controller;
    SYNCHRONIZED_COUNT_CONTEXT  SyncContext;
    KIRQL                       CancelIrql;

    DD((PCE)fdx,DDT,"par12843::PptTrySelectLegacyZip - Enter\n");

    // test to see if we need to grab port
    if( !(Command->CommandFlags & PAR_HAVE_PORT_KEEP_PORT) ) {
        // Don't have the port
        //
        // Try to acquire port and select device
        //
        DD((PCE)fdx,DDT,"par12843::PptTrySelectLegacyZip Try get port.\n");

        IoAcquireCancelSpinLock(&CancelIrql);
                
        SyncContext.Count = &fdx->WorkQueueCount;
                    
        if (fdx->InterruptRefCount) {
            KeSynchronizeExecution(fdx->InterruptObject,
                                   PptSynchronizedIncrement,
                                   &SyncContext);
        } else {
            PptSynchronizedIncrement(&SyncContext);
        }
                    
        if (SyncContext.NewCount) {
            // Port is busy, queue request
            Status = STATUS_PENDING;
        }  // endif - test for port busy
                    
        IoReleaseCancelSpinLock(CancelIrql);

    } // endif - test if already have port


    //
    // If we have port select legacy Zip
    //
    if ( NT_SUCCESS( Status ) && (Status != STATUS_PENDING) ) {
        if ( Command->CommandFlags & PAR_LEGACY_ZIP_DRIVE_EPP_MODE ) {
            // Select in EPP mode
            PptLegacyZipSetDiskMode( Controller, (UCHAR)0xCF );
        } else {
            // Select in Nibble or Byte mode
            PptLegacyZipSetDiskMode( Controller, (UCHAR)0x8F );
        }

        if ( PptLegacyZipCheckDevice( Controller ) ) {
            DD((PCE)fdx,DDT,"par12843::PptTrySelectLegacyZip - SUCCESS\n");

            //
            // Legacy Zip is selected - test for EPP if we haven't previously done the test
            //
            if( !fdx->CheckedForGenericEpp ) {
                // haven't done the test yet
                if( fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT ) {
                    // we have an ECR - required for generic EPP

                    if( !fdx->NationalChipFound ) {
                        // we don't have a NationalSemi chipset - no generic EPP on NatSemi chips
                        PptDetectEppPort( fdx );
                    }

                }
                fdx->CheckedForGenericEpp = TRUE; // check is complete
            }

        } else {
            DD((PCE)fdx,DDT,"par12843::PptTrySelectLegacyZip - FAIL\n");
            PptDeselectLegacyZip( Context, TrySelectCommand );
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    
    return( Status );

} // end PptTrySelectLegacyZip()

NTSTATUS
PptDeselectLegacyZip(
    IN  PVOID   Context,
    IN  PVOID   DeselectCommand
    )
{
    ULONG i;
    PFDO_EXTENSION       fdx   = Context;
    PUCHAR                  Controller  = fdx->PortInfo.Controller;
    PPARALLEL_1284_COMMAND  Command     = DeselectCommand;

    DD((PCE)fdx,DDT,"par12843::PptDeselectLegacyZip - Enter\n");

    for ( i = 0; i < LEGACYZIP_MODE_LEN; i++ ) {
        PptLegacyZipClockPrtModeByte( Controller, LegacyZipModeQualifier[i] );
    }

    // set to printer pass thru mode
    PptLegacyZipClockPrtModeByte( Controller, (UCHAR)0x0F );

    // check if requester wants to keep port or free port
    if( !(Command->CommandFlags & PAR_HAVE_PORT_KEEP_PORT) ) {
        PptFreePort( fdx );
    }

    return STATUS_SUCCESS;

} // end  PptDeselectLegacyZip()


VOID
P5SelectLegacyZip(
    IN  PUCHAR  Controller
    )
// select Legacy Zip drive in NIBBLE/BYTE mode - use this only for PnP
//   detection of drive so that drive will answer a subsequent check
//   drive command
//
// N.B. caller must own (lock for exclusive access) the port prior to
//   calling this function
{
    PptLegacyZipSetDiskMode( Controller, (UCHAR)0x8F );
}


VOID
P5DeselectLegacyZip(
    IN  PUCHAR  Controller
    )
// deselect drive - set Legacy Zip drive to printer pass thru mode
{
    ULONG i;
    for ( i = 0; i < LEGACYZIP_MODE_LEN; i++ ) {
        PptLegacyZipClockPrtModeByte( Controller, LegacyZipModeQualifier[i] );
    }
    PptLegacyZipClockPrtModeByte( Controller, (UCHAR)0x0F );
    P5WritePortUchar( Controller, 0 ); // set data wires back to zero
}


BOOLEAN
P5LegacyZipDetected(
    IN  PUCHAR  Controller
    )
// Detect Legacy Zip drive - return TRUE if Legacy Zip found on port, FALSE otherwise
{
    BOOLEAN foundZip;

    // Try to select drive so that following CheckDevice will be able
    // to determine if there is a legacy zip connected
    P5SelectLegacyZip( Controller );

    // Try to talk to drive
    if( PptLegacyZipCheckDevice( Controller ) ) {
        foundZip = TRUE;
    } else {
        // no drive detected
        foundZip = FALSE;
    }

    // send deselect sequence whether we found the drive or not
    P5DeselectLegacyZip( Controller );

    return foundZip;
}

// parclass ppa3x.c follows

PCHAR ParBuildLegacyZipDeviceId() 
{
    ULONG size = sizeof(PAR_LGZIP_PSEUDO_1284_ID_STRING) + sizeof(CHAR);
    PCHAR id = ExAllocatePool(PagedPool, size);
    if( id ) {
        RtlZeroMemory( id, size );
        RtlCopyMemory( id, ParLegacyZipPseudoId, size - sizeof(CHAR) );
        return id;
    } else {
        return NULL;
    }
}
PCHAR
Par3QueryLegacyZipDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString // TRUE ==  include the 2 size bytes in the returned string
                                             // FALSE == discard the 2 size bytes
    )
{
    USHORT deviceIdSize;
    PCHAR  deviceIdBuffer;

    UNREFERENCED_PARAMETER( Extension );
    UNREFERENCED_PARAMETER( bReturnRawString );
    
    // initialize returned size in case we have an error
    *DeviceIdSize = 0;

    deviceIdBuffer = ParBuildLegacyZipDeviceId();
    if( !deviceIdBuffer ) {
        // error, likely out of resources
        return NULL;
    }

    deviceIdSize = (USHORT)strlen(deviceIdBuffer);
    *DeviceIdSize = deviceIdSize;
    if( (NULL != CallerDeviceIdBuffer) && (CallerBufferSize >= deviceIdSize + sizeof(CHAR) ) ) {
        // caller supplied buffer is large enough, use it
        RtlZeroMemory( CallerDeviceIdBuffer, CallerBufferSize );
        RtlCopyMemory( CallerDeviceIdBuffer, deviceIdBuffer, deviceIdSize );
        ExFreePool( deviceIdBuffer );
        return CallerDeviceIdBuffer;
    } else {
        // caller buffer too small, return pointer to our buffer
        return deviceIdBuffer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\parport.c ===
#include "pch.h"

#include <initguid.h>
#include <wdmguid.h>
#include <ntddpar.h>

//
// globals and constants
//
LARGE_INTEGER AcquirePortTimeout;

ULONG ParEnableLegacyZip   = 0;
PCHAR ParLegacyZipPseudoId = PAR_LGZIP_PSEUDO_1284_ID_STRING;
ULONG SppNoRaiseIrql = 0;
ULONG DefaultModes   = 0;

UNICODE_STRING RegistryPath = {0,0,0};

// track CREATE/CLOSE count - likely obsolete
LONG        PortInfoReferenceCount  = -1L;
PFAST_MUTEX PortInfoMutex           = NULL;

const PHYSICAL_ADDRESS PhysicalZero = {0};

// variable to know how many times to try a select or
// deselect for 1284.3 if we do not succeed.
UCHAR PptDot3Retries = 5;

ULONG WarmPollPeriod  = 5;      // time between polls for printers (in seconds)

BOOLEAN           PowerStateIsAC                 = TRUE; // FALSE means running on battery power
PCALLBACK_OBJECT  PowerStateCallbackObject       = NULL;
PVOID             PowerStateCallbackRegistration = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\pdoclose.c ===
#include "pch.h"

NTSTATUS
PptPdoClose(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch for a close requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/
{
    PPDO_EXTENSION   pdx = Pdo->DeviceExtension;
    BOOLEAN          haveShadowBuffer;
    PVOID            threadObject;

    DD((PCE)pdx,DDT,"PptPdoClose\n");

    // immediately stop signalling any dot4 event
    pdx->P12843DL.bEventActive = FALSE;


    //
    // Protect against two threads calling us concurrently
    //
    ExAcquireFastMutex( &pdx->OpenCloseMutex );

    haveShadowBuffer         = pdx->bShadowBuffer;
    pdx->bShadowBuffer       = FALSE;

    threadObject             = pdx->ThreadObjectPointer;
    pdx->ThreadObjectPointer = NULL;

    ExReleaseFastMutex( &pdx->OpenCloseMutex );

    //
    // clean up Bounded ECP shadow buffer
    //
    if( haveShadowBuffer ) {
        Queue_Delete( &(pdx->ShadowBuffer) );
    }

    //
    // if we still have a worker thread, kill it
    //
    if( threadObject ) {

        if (!pdx->TimeToTerminateThread) 
        {
            // set the flag for the worker thread to kill itself
            pdx->TimeToTerminateThread = TRUE;

            // wake up the thread so it can kill itself
            KeReleaseSemaphore(&pdx->RequestSemaphore, 0, 1, FALSE );
        }

        // allow thread to get past PauseEvent so it can kill self
        KeSetEvent( &pdx->PauseEvent, 0, TRUE );

        // wait for the thread to die
        KeWaitForSingleObject( threadObject, UserRequest, KernelMode, FALSE, NULL );
        
        // allow the system to release the thread object
        ObDereferenceObject( threadObject );
    }

    //
    // update open handle count
    //
    {
        ExAcquireFastMutex( &pdx->OpenCloseMutex );
        InterlockedDecrement( &pdx->OpenCloseRefCount );
        if( pdx->OpenCloseRefCount < 0) {
            // catch possible underflow
            pdx->OpenCloseRefCount = 0;
        }
        ExReleaseFastMutex(&pdx->OpenCloseMutex);
    }

    return P4CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\pdocleanup.c ===
#include "pch.h"

NTSTATUS
PptPdoCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch for a cleanup requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/
{
    PPDO_EXTENSION   pdx = DeviceObject->DeviceExtension;
    KIRQL            CancelIrql;
    PDRIVER_CANCEL   CancelRoutine;
    PIRP             CurrentLastIrp;

    DD((PCE)pdx,DDT,"ParCleanup - enter\n");

    //
    // While the list is not empty, go through and cancel each irp.
    //

    IoAcquireCancelSpinLock(&CancelIrql);

    //
    // Clean the list from back to front.
    //

    while (!IsListEmpty(&pdx->WorkQueue)) {

        CurrentLastIrp = CONTAINING_RECORD(pdx->WorkQueue.Blink,
                                           IRP, Tail.Overlay.ListEntry);

        RemoveEntryList(pdx->WorkQueue.Blink);

        CancelRoutine = CurrentLastIrp->CancelRoutine;
        CurrentLastIrp->CancelIrql    = CancelIrql;
        CurrentLastIrp->CancelRoutine = NULL;
        CurrentLastIrp->Cancel        = TRUE;

        CancelRoutine(DeviceObject, CurrentLastIrp);

        IoAcquireCancelSpinLock(&CancelIrql);
    }

    //
    // If there is a current irp then mark it as cancelled.
    //

    if (pdx->CurrentOpIrp) {
        pdx->CurrentOpIrp->Cancel = TRUE;
    }

    IoReleaseCancelSpinLock(CancelIrql);

    P4CompleteRequest( Irp, STATUS_SUCCESS, 0 );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\pdocreate.c ===
#include "pch.h"

NTSTATUS
PptPdoCreateOpen(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PIRP            Irp
    )
{
    NTSTATUS        status;
    PPDO_EXTENSION  pdx      = Pdo->DeviceExtension;

    // bail out if a delete is pending for this device object
    if(pdx->DeviceStateFlags & PPT_DEVICE_DELETE_PENDING) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, 0 );
    }

    // bail out if device has been removed
    if(pdx->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {
        return P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, 0 );
    }

    // bail out if caller is confused and thinks that we are a directory
    if( IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options & FILE_DIRECTORY_FILE ) {
        return P4CompleteRequest( Irp, STATUS_NOT_A_DIRECTORY, 0 );
    }

    // this is an exclusive access device - fail IRP if we are already open
    ExAcquireFastMutex(&pdx->OpenCloseMutex);
    if( InterlockedIncrement( &pdx->OpenCloseRefCount ) != 1 ) {
        InterlockedDecrement( &pdx->OpenCloseRefCount );
        ExReleaseFastMutex( &pdx->OpenCloseMutex );
        return P4CompleteRequest( Irp, STATUS_ACCESS_DENIED, 0 );
    }
    ExReleaseFastMutex(&pdx->OpenCloseMutex);

    PptPdoGetPortInfoFromFdo( Pdo );

    //
    // Set the default ieee1284 modes
    //
    ParInitializeExtension1284Info( pdx );

    // used to pause worker thread when we enter a "Hold Requests" state due to PnP requests
    KeInitializeEvent( &pdx->PauseEvent, NotificationEvent, TRUE );

    // set to TRUE to tell worker thread to kill itself
    pdx->TimeToTerminateThread = FALSE;

    // we are an exclusive access device - we should not already have a worker thread
    PptAssert( !pdx->ThreadObjectPointer );

    // dispatch routines signal worker thread on this semaphore when there is work for worker thread to do
    KeInitializeSemaphore(&pdx->RequestSemaphore, 0, MAXLONG);

    // create worker thread to handle serialized requests at Passive Level IRQL
    status = ParCreateSystemThread( pdx );
    if( status != STATUS_SUCCESS ) {
        DD((PCE)pdx,DDW,"PptPdoCreateOpen - FAIL worker thread creation\n");
        ExAcquireFastMutex( &pdx->OpenCloseMutex );
        InterlockedDecrement( &pdx->OpenCloseRefCount );
        if( pdx->OpenCloseRefCount < 0 ) {
            pdx->OpenCloseRefCount = 0;
        }
        ExReleaseFastMutex( &pdx->OpenCloseMutex );
    } else {
        DD((PCE)pdx,DDT,"PptPdoCreateOpen - SUCCESS\n");
    }

    return P4CompleteRequest( Irp, status, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\pdoexports.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       exports.c
//
//--------------------------------------------------------------------------

//
// This file contains the functions exported in response to IOCTL_INTERNAL_PARCLASS_CONNECT
//
    
#include "pch.h"
    
USHORT
ParExportedDetermineIeeeModes(
    IN PPDO_EXTENSION    Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to find out what Ieee Modes there Device Supports.
    
Arguments:
    
    Extension       - Device Extension
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
{
    Extension->BadProtocolModes = 0;
    IeeeDetermineSupportedProtocols(Extension);
    return Extension->ProtocolModesSupported;
}

NTSTATUS
ParExportedIeeeFwdToRevMode(
    IN PPDO_EXTENSION  Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to put there device into reverse Ieee Mode.
    The Mode is determined by what was passed into the function  
    ParExportedNegotiateIeeeMode() as the Reverse Protocol with the
    ModeMaskRev.
    
Arguments:
    
    Extension       - Device Extension
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
{
    return ( ParForwardToReverse( Extension ) );
}

NTSTATUS
ParExportedIeeeRevToFwdMode(
    IN PPDO_EXTENSION  Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to put there device into forward Ieee Mode.
    The Mode is determined by what was passed into the function  
    ParExportedNegotiateIeeeMode() as the Forward Protocol with the
    ModeMaskFwd.
    
Arguments:
    
    Extension       - Device Extension
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
{
    return ( ParReverseToForward( Extension ) );
}

NTSTATUS
ParExportedNegotiateIeeeMode(
    IN PPDO_EXTENSION  Extension,
    IN USHORT             ModeMaskFwd,
    IN USHORT             ModeMaskRev,
    IN PARALLEL_SAFETY    ModeSafety,
    IN BOOLEAN            IsForward
    )
    
/*++
    
Routine Description:
    
    Called by filter drivers to negotiate an IEEE mode.
    
Arguments:
    
    Extension       - Device Extension
    
    Extensibility   - IEEE 1284 Extensibility
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
    
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    if (Extension->Connected) {
        DD((PCE)Extension,DDE,"ParExportedNegotiateIeeeMode - FAIL - already connected\n");
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    
    if (ModeSafety == UNSAFE_MODE) {    

        // Checking to see if we are doing forward compatability and reverse Nibble or Byte
        if ( (ModeMaskFwd & CENTRONICS) || (ModeMaskFwd & IEEE_COMPATIBILITY) ) {

            if ( !((ModeMaskRev & NIBBLE) || (ModeMaskRev & CHANNEL_NIBBLE) || (ModeMaskRev & BYTE_BIDIR)) ) {
                DD((PCE)Extension,DDE,"ParExportedNegotiateIeeeMode - FAIL - invalid modes\n");
                return STATUS_UNSUCCESSFUL;
            }

        } else {

            // Unsafe mode is only possible if the Fwd and Rev PCTLs the same if other than above.
            if (ModeMaskFwd != ModeMaskRev) {
                DD((PCE)Extension,DDE,"ParExportedNegotiateIeeeMode - FAIL - Fwd and Rev modes do not match\n");
                return STATUS_UNSUCCESSFUL;
            }

        }
        // RMT - Need to fill in....
        // Todo....
        // Mark in the extension
        Extension->ModeSafety = ModeSafety;
        Status = IeeeNegotiateMode(Extension, ModeMaskRev, ModeMaskFwd);

    } else {

        Extension->ModeSafety = ModeSafety;
        Status = IeeeNegotiateMode(Extension, ModeMaskRev, ModeMaskFwd);

    }
   
    if (IsForward) {

        if (afpForward[Extension->IdxForwardProtocol].fnConnect) {
            Status = afpForward[Extension->IdxForwardProtocol].fnConnect(Extension, FALSE);
        }

    } else {

        if (arpReverse[Extension->IdxReverseProtocol].fnConnect) {
            Status = arpReverse[Extension->IdxReverseProtocol].fnConnect(Extension, FALSE);
        }

    }
  
    return Status;
}

NTSTATUS
ParExportedTerminateIeeeMode(
    IN PPDO_EXTENSION   Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to terminate from an IEEE mode.
    
Arguments:
    
    Extension   - Device Extension
    
Return Value:
  
    STATUS_SUCCESS if successful.
 
--*/
{
    // Check the extension for UNSAFE_MODE
    // and do the right thing
    if ( Extension->ModeSafety == UNSAFE_MODE ) {    
        DD((PCE)Extension,DDT,"ParExportedTerminateIeeeMode in UNSAFE_MODE\n");
        // Need to fill in....
        // Todo....
        // Mark in the extension
    }
    
    if (Extension->CurrentPhase == PHASE_REVERSE_IDLE || Extension->CurrentPhase == PHASE_REVERSE_XFER) {
        if (arpReverse[Extension->IdxReverseProtocol].fnDisconnect) {
            arpReverse[Extension->IdxReverseProtocol].fnDisconnect( Extension );
        }
    } else {
        if (afpForward[Extension->IdxForwardProtocol].fnDisconnect) {
            afpForward[Extension->IdxForwardProtocol].fnDisconnect( Extension );
        }
    }

    Extension->ModeSafety = SAFE_MODE;

    return STATUS_SUCCESS;
}

NTSTATUS
ParExportedParallelRead(
    IN PPDO_EXTENSION    Extension,
    IN  PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead,
    IN  UCHAR               Channel
    )
    
/*++
    
Routine Description:
    
    Called by filter drivers to terminate from a currently connected mode.
    
Arguments:
    
    Extension   - Device Extension
    
Return Value:
   
    STATUS_SUCCESS if successful.
    
--*/
    
{
    UNREFERENCED_PARAMETER( Channel );

    return ParRead( Extension, Buffer, NumBytesToRead, NumBytesRead);
}

NTSTATUS
ParExportedParallelWrite(
    IN  PPDO_EXTENSION   Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten,
    IN  UCHAR               Channel
    )
{
    UNREFERENCED_PARAMETER( Channel );
    return ParWrite( Extension, Buffer, NumBytesToWrite, NumBytesWritten);
}

NTSTATUS
ParExportedTrySelect(
    IN  PPDO_EXTENSION       Extension,
    IN  PARALLEL_1284_COMMAND   Command
    )
{
    UNREFERENCED_PARAMETER( Extension );
    UNREFERENCED_PARAMETER( Command );
    return STATUS_UNSUCCESSFUL;
}   

NTSTATUS
ParExportedDeSelect(
    IN  PPDO_EXTENSION       Extension,
    IN  PARALLEL_1284_COMMAND   Command
    )
{
    UNREFERENCED_PARAMETER( Extension );
    UNREFERENCED_PARAMETER( Command );
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\pdoioctl.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

File Name:

    ioctl.c

Contained in Module:

    parallel.sys

Abstract:

    This file contains functions associated with ParClass IOCTL processing.

    - The three main entry points in this file are:

      - ParDeviceControl()          - Dispatch function for non-internal IOCTLs

      - ParInternalDeviceControl()  - Dispatch function for internal IOCTLs

      - ParDeviceIo()               - Worker thread entry point for handling all 
                                        IOCTLs not completed in a dispatch function

    - Helper/Utility function naming conventions:
 
      - ParpIoctlDispatch...()      - private helper function called by dispatch function

      - ParpIoctlThread...()        - private helper function called by worker thread

Authors:

    Anthony V. Ercolano  1-Aug-1992
    Norbert P. Kusters  22-Oct-1993
    Douglas G. Fritz    24-Jul-1998

Revision History :

--*/

#include "pch.h"


VOID
ParpIoctlThreadLockPort(
    IN PPDO_EXTENSION Pdx
    )
{
    NTSTATUS status;
    PIRP     irp = Pdx->CurrentOpIrp;

    DD((PCE)Pdx,DDT,"ParpIoctlThreadLockPort - enter\n");

    if( ParSelectDevice(Pdx,TRUE) ) {
        DD((PCE)Pdx,DDT,"ParpIoctlThreadLockPort - SUCCESS\n");
        Pdx->AllocatedByLockPort = TRUE;
        status = STATUS_SUCCESS;
    } else {
        DD((PCE)Pdx,DDW,"ParpIoctlThreadLockPort - FAIL\n");
        Pdx->AllocatedByLockPort = FALSE;
        status = STATUS_UNSUCCESSFUL;
    }    
    
    irp->IoStatus.Status = status;
}

VOID
ParpIoctlThreadUnlockPort(
    IN PPDO_EXTENSION Pdx
    )
{
    PIRP     irp = Pdx->CurrentOpIrp;

    Pdx->AllocatedByLockPort = FALSE;

    DD((PCE)Pdx,DDT,"ParpIoctlThreadUnlockPort - enter\n");
    
    if( ParDeselectDevice(Pdx, FALSE) ) {
        DD((PCE)Pdx,DDT,"ParpIoctlThreadUnlockPort - SUCCESS\n");
    } else {
        DD((PCE)Pdx,DDW,"ParpIoctlThreadUnlockPort - FAIL - nothing we can do\n");
    }
    
    irp->IoStatus.Status = STATUS_SUCCESS;
}

NTSTATUS
ParDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch for device control requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_PENDING              - Request pending.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.
    STATUS_INVALID_PARAMETER    - Invalid io control request.
    STATUS_DELETE_PENDING       - This device object is being deleted

--*/

{
    PPDO_EXTENSION        Pdx = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION    IrpSp     = IoGetCurrentIrpStackLocation( Irp );
    PPAR_SET_INFORMATION  SetInfo;
    NTSTATUS              Status;
    PSERIAL_TIMEOUTS      SerialTimeouts;
    KIRQL                 OldIrql;

    Irp->IoStatus.Information = 0;

    //
    // bail out if a delete is pending for this device object
    //
    if(Pdx->DeviceStateFlags & PPT_DEVICE_DELETE_PENDING) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, 0 );
    }

    //
    // bail out if a remove is pending for our ParPort device object
    //
    if(Pdx->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, 0 );
    }

    //
    // bail out if device has been removed
    //
    if(Pdx->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {
        return P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, 0 );
    }

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_PAR_QUERY_LOCATION:
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_LOCATION\n");
        {
            ULONG  outBufLen   = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            ULONG  locationLen = strlen(Pdx->Location);

            if( outBufLen < locationLen+1 ) {
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                PCHAR buffer = (PCHAR)Irp->AssociatedIrp.SystemBuffer;
                RtlCopyMemory( buffer, Pdx->Location, locationLen + 1 );
                Irp->IoStatus.Information = locationLen + 1;
                Status = STATUS_SUCCESS;
            }
        }
        break;

    case IOCTL_PAR_SET_INFORMATION:
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_SET_INFORMATION\n");

        SetInfo = Irp->AssociatedIrp.SystemBuffer;
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(PAR_SET_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else if (SetInfo->Init != PARALLEL_INIT) {
            
            Status = STATUS_INVALID_PARAMETER;
            
        } else {
            
            //
            // This is a parallel reset
            //
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_PAR_QUERY_INFORMATION :
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_INFORMATION\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PAR_QUERY_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_SERIAL_SET_TIMEOUTS:
        
        DD((PCE)Pdx,DDT,"IOCTL_SERIAL_SET_TIMEOUTS\n");
        
        SerialTimeouts = Irp->AssociatedIrp.SystemBuffer;
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(SERIAL_TIMEOUTS)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else if (SerialTimeouts->WriteTotalTimeoutConstant < 2000) {
            
            Status = STATUS_INVALID_PARAMETER;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_SERIAL_GET_TIMEOUTS:
        
        DD((PCE)Pdx,DDT,"IOCTL_SERIAL_GET_TIMEOUTS\n");
        
        SerialTimeouts = Irp->AssociatedIrp.SystemBuffer;
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIAL_TIMEOUTS)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            //
            // We don't need to synchronize the read.
            //
            
            RtlZeroMemory(SerialTimeouts, sizeof(SERIAL_TIMEOUTS));
            SerialTimeouts->WriteTotalTimeoutConstant =
                1000 * Pdx->TimerStart;
            
            Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);
            Status = STATUS_SUCCESS;
        }
        break;
        
    case IOCTL_PAR_QUERY_DEVICE_ID:
    case IOCTL_PAR_QUERY_RAW_DEVICE_ID:
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_[RAW_]DEVICE_ID\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == 0) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_PAR_QUERY_DEVICE_ID_SIZE:
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_DEVICE_ID_SIZE\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PAR_DEVICE_ID_SIZE_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_PAR_IS_PORT_FREE:
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_IS_PORT_FREE\n");
        
        if( IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(BOOLEAN) ) {

            Status = STATUS_BUFFER_TOO_SMALL;

        } else {

            if( Pdx->bAllocated ) {
                // if we have the port then it is not free
                *((PBOOLEAN)Irp->AssociatedIrp.SystemBuffer) = FALSE;
            } else {
                // determine if the port is free by trying to allocate and free it
                //  - our alloc/free will only succeed if no one else has the port
                BOOLEAN tryAllocSuccess = Pdx->TryAllocatePort( Pdx->PortContext );
                if( tryAllocSuccess ) {
                    // we were able to allocate the port, free it and report that the port is free
                    Pdx->FreePort( Pdx->PortContext );
                    *((PBOOLEAN)Irp->AssociatedIrp.SystemBuffer) = TRUE;
                } else {
                    // we were unable to allocate the port, someone else must be using the port
                    *((PBOOLEAN)Irp->AssociatedIrp.SystemBuffer) = FALSE; 
                }
            }

            Irp->IoStatus.Information = sizeof(BOOLEAN);
            Status = STATUS_SUCCESS;

        }
        break;

    case IOCTL_PAR_GET_READ_ADDRESS:

        DD((PCE)Pdx,DDT,"IOCTL_PAR_GET_READ_ADDRESS\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(Pdx->ReverseInterfaceAddress)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            *((PUCHAR) Irp->AssociatedIrp.SystemBuffer) = Pdx->ReverseInterfaceAddress;
            Irp->IoStatus.Information = sizeof(Pdx->ReverseInterfaceAddress);
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_GET_WRITE_ADDRESS:

        DD((PCE)Pdx,DDT,"IOCTL_PAR_GET_WRITE_ADDRESS\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(Pdx->ForwardInterfaceAddress)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            *((PUCHAR) Irp->AssociatedIrp.SystemBuffer) = Pdx->ForwardInterfaceAddress;
            Irp->IoStatus.Information = sizeof(Pdx->ForwardInterfaceAddress);
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_SET_READ_ADDRESS:
    
        DD((PCE)Pdx,DDT,"  IOCTL_PAR_SET_READ_ADDRESS\n");
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(Pdx->ReverseInterfaceAddress)) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_PAR_SET_WRITE_ADDRESS:

        DD((PCE)Pdx,DDT,"  IOCTL_PAR_SET_WRITE_ADDRESS\n");
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(Pdx->ForwardInterfaceAddress)) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_IEEE1284_GET_MODE:
        
        DD((PCE)Pdx,DDT,"IOCTL_IEEE1284_GET_MODE\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARCLASS_NEGOTIATION_MASK)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {

            PPARCLASS_NEGOTIATION_MASK  ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;
            
            ppnmMask->usReadMask  = arpReverse[Pdx->IdxReverseProtocol].Protocol;
            ppnmMask->usWriteMask = afpForward[Pdx->IdxForwardProtocol].Protocol;
            
            Irp->IoStatus.Information = sizeof (PARCLASS_NEGOTIATION_MASK);
            
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_GET_DEFAULT_MODES:
        
        DD((PCE)Pdx,DDT,"IOCTL_IEEE1284_GET_MODE\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARCLASS_NEGOTIATION_MASK)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            
            PPARCLASS_NEGOTIATION_MASK  ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;
            
            ppnmMask->usReadMask  = NONE;            
            ppnmMask->usWriteMask = CENTRONICS;
            
            Irp->IoStatus.Information = sizeof (PARCLASS_NEGOTIATION_MASK);
            
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_ECP_HOST_RECOVERY:

        DD((PCE)Pdx,DDT,"IOCTL_PAR_ECP_HOST_RECOVERY\n");
        {
            BOOLEAN *isSupported;

            if( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(BOOLEAN) ) {
                Status = STATUS_INVALID_PARAMETER;                
            } else {
                isSupported = (BOOLEAN *)Irp->AssociatedIrp.SystemBuffer;
                Pdx->bIsHostRecoverSupported = *isSupported;
                Status = STATUS_SUCCESS;
            }
        }
        break;

    case IOCTL_PAR_PING:
        DD((PCE)Pdx,DDT,"IOCTL_PAR_PING\n");
        // No Parms to check!
        Status = STATUS_PENDING;        
        break;

    case IOCTL_PAR_GET_DEVICE_CAPS:
        DD((PCE)Pdx,DDT,"IOCTL_PAR_GET_DEVICE_CAPS\n");
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(Pdx->ProtocolModesSupported)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(Pdx->BadProtocolModes)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_IEEE1284_NEGOTIATE:
        
        DD((PCE)Pdx,DDT,"IOCTL_IEEE1284_NEGOTIATE\n");
        
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength  < sizeof(PARCLASS_NEGOTIATION_MASK) ||
             IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARCLASS_NEGOTIATION_MASK) ) {

            DD((PCE)Pdx,DDW,"ParDeviceControl: IOCTL_IEEE1284_NEGOTIATE STATUS_INVALID_PARAMETER\n");
            Status = STATUS_INVALID_PARAMETER;

        } else {

            PPARCLASS_NEGOTIATION_MASK  ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;
            
            if ((ppnmMask->usReadMask  == arpReverse[Pdx->IdxReverseProtocol].Protocol) &&
                (ppnmMask->usWriteMask == afpForward[Pdx->IdxForwardProtocol].Protocol)) {
                Irp->IoStatus.Information = sizeof(PARCLASS_NEGOTIATION_MASK);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_PENDING;
            }
        }
        break;

    default :

        DD((PCE)Pdx,DDT,"IOCTL default case\n");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    
    if (Status == STATUS_PENDING) {
        
        IoAcquireCancelSpinLock(&OldIrql);
        
        if (Irp->Cancel) {
            
            IoReleaseCancelSpinLock(OldIrql);
            Status = STATUS_CANCELLED;
            
        } else {
            
            //
            // This IRP takes more time, so it should be queued.
            //
            BOOLEAN needToSignalSemaphore = (IsListEmpty( &Pdx->WorkQueue ) &&
				!KeReadStateSemaphore( &Pdx->RequestSemaphore )) ? TRUE : FALSE;

            IoMarkIrpPending(Irp);

#pragma warning( push ) 
#pragma warning( disable : 4054 4055 )
            IoSetCancelRoutine(Irp, ParCancelRequest);
#pragma warning( pop ) 

            InsertTailList(&Pdx->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            IoReleaseCancelSpinLock(OldIrql);
            if( needToSignalSemaphore ) {
                KeReleaseSemaphore(&Pdx->RequestSemaphore, 0, 1, FALSE);
            }
        }
    }
    
    if (Status != STATUS_PENDING) {
        P4CompleteRequest( Irp, Status, Irp->IoStatus.Information );
    }

    return Status;
}

NTSTATUS
ParInternalDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for internal device control requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_PENDING              - Request pending.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.
    STATUS_INVALID_PARAMETER    - Invalid io control request.
    STATUS_DELETE_PENDING       - This device object is being deleted

--*/

{
    PIO_STACK_LOCATION              IrpSp;
    // PPAR_SET_INFORMATION            SetInfo;
    NTSTATUS                        Status;
    // PSERIAL_TIMEOUTS                SerialTimeouts;
    PPDO_EXTENSION               Pdx;
    KIRQL                           OldIrql;
    PPARCLASS_INFORMATION           pParclassInfo;

    Irp->IoStatus.Information = 0;

    IrpSp     = IoGetCurrentIrpStackLocation(Irp);
    Pdx = DeviceObject->DeviceExtension;

    //
    // bail out if a delete is pending for this device object
    //
    if(Pdx->DeviceStateFlags & PPT_DEVICE_DELETE_PENDING) {
        P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
        return STATUS_DELETE_PENDING;
    }

    //
    // bail out if a remove is pending for our ParPort device object
    //
    if(Pdx->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {
        P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
        return STATUS_DELETE_PENDING;
    }

    //
    // bail out if device has been removed
    //
    if(Pdx->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {
        P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, Irp->IoStatus.Information );
        return STATUS_DEVICE_REMOVED;
    }

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_INTERNAL_PARCLASS_CONNECT:
        
        DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_PARCLASS_CONNECT\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARCLASS_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            PFDO_EXTENSION              fdx      = Pdx->Fdo->DeviceExtension;
            PPARALLEL_PORT_INFORMATION  portInfo = &fdx->PortInfo;
            PPARALLEL_PNP_INFORMATION   pnpInfo  = &fdx->PnpInfo;

            pParclassInfo = Irp->AssociatedIrp.SystemBuffer;
            
            pParclassInfo->ParclassContext       = Pdx;
            pParclassInfo->Controller            = portInfo->Controller;
            pParclassInfo->SpanOfController      = portInfo->SpanOfController;
            pParclassInfo->EcrController         = pnpInfo->EcpController;
            pParclassInfo->HardwareCapabilities  = pnpInfo->HardwareCapabilities;
            pParclassInfo->FifoDepth             = pnpInfo->FifoDepth;
            pParclassInfo->FifoWidth             = pnpInfo->FifoWidth;
            pParclassInfo->DetermineIeeeModes    = ParExportedDetermineIeeeModes;
            pParclassInfo->TerminateIeeeMode     = ParExportedTerminateIeeeMode;
            pParclassInfo->NegotiateIeeeMode     = ParExportedNegotiateIeeeMode;
            pParclassInfo->IeeeFwdToRevMode      = ParExportedIeeeFwdToRevMode;
            pParclassInfo->IeeeRevToFwdMode      = ParExportedIeeeRevToFwdMode;
            pParclassInfo->ParallelRead          = ParExportedParallelRead;
            pParclassInfo->ParallelWrite         = ParExportedParallelWrite;
            
            Irp->IoStatus.Information = sizeof(PARCLASS_INFORMATION);
            
            Status = STATUS_SUCCESS;
        }
        
        break;
        
    case IOCTL_INTERNAL_GET_PARPORT_FDO:

        DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_GET_PARPORT_FDO\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PDEVICE_OBJECT)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {

            PDEVICE_OBJECT *pFdo = Irp->AssociatedIrp.SystemBuffer;
            *pFdo = Pdx->Fdo;
            Irp->IoStatus.Information = sizeof(PDEVICE_OBJECT);
            
            Status = STATUS_SUCCESS;
        }
        
        break;

    case IOCTL_INTERNAL_PARCLASS_DISCONNECT:
        
        Status = STATUS_SUCCESS;
        break;
        
    case IOCTL_INTERNAL_DISCONNECT_IDLE:
    case IOCTL_INTERNAL_LOCK_PORT:
    case IOCTL_INTERNAL_UNLOCK_PORT:
    case IOCTL_INTERNAL_LOCK_PORT_NO_SELECT:
    case IOCTL_INTERNAL_UNLOCK_PORT_NO_DESELECT:
    case IOCTL_INTERNAL_PARDOT3_CONNECT:
    case IOCTL_INTERNAL_PARDOT3_RESET:
    
        Status = STATUS_PENDING;
        break;

    case IOCTL_INTERNAL_PARDOT3_DISCONNECT:

        // immediately tell worker thread to stop signalling
        Pdx->P12843DL.bEventActive = FALSE;
        Status = STATUS_PENDING;
        break;

    case IOCTL_INTERNAL_PARDOT3_SIGNAL:
    
        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PKEVENT) ) {
            Status = STATUS_INVALID_PARAMETER;                
        } else {
            Status = STATUS_PENDING;
        }
        break;

    default :

        DD((PCE)Pdx,DDW,"IOCTL_INTERNAL... default case - invalid parameter\n");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    

    if (Status == STATUS_PENDING) {
        
        //
        // This IRP takes more time, queue it for the worker thread
        //

        IoAcquireCancelSpinLock(&OldIrql);
        
        if (Irp->Cancel) {
            
            IoReleaseCancelSpinLock(OldIrql);
            Status = STATUS_CANCELLED;
            
        } else {
            
            BOOLEAN needToSignalSemaphore = (IsListEmpty( &Pdx->WorkQueue ) &&
				!KeReadStateSemaphore( &Pdx->RequestSemaphore )) ? TRUE : FALSE;

            IoMarkIrpPending(Irp);
#pragma warning( push ) 
#pragma warning( disable : 4054 4055 )
            IoSetCancelRoutine(Irp, ParCancelRequest);
#pragma warning( pop ) 
            InsertTailList(&Pdx->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            IoReleaseCancelSpinLock(OldIrql);
            if( needToSignalSemaphore ) {
                KeReleaseSemaphore(&Pdx->RequestSemaphore, 0, 1, FALSE);
            }
        }
    }
    
    if (Status != STATUS_PENDING) {
        P4CompleteRequest( Irp, Status, Irp->IoStatus.Information );
    }

    return Status;
}

VOID
ParDeviceIo(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine implements a DEVICE_IOCTL request with the extension's current irp.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{

    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    ULONG                   IdLength;
    NTSTATUS                NtStatus;
    UCHAR                   Status;
    UCHAR                   Control;
    ULONG                   ioControlCode;

    Irp     = Pdx->CurrentOpIrp;
    IrpSp   = IoGetCurrentIrpStackLocation(Irp);

    ioControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    switch( ioControlCode ) {

    case IOCTL_PAR_SET_INFORMATION : 
        {

            Status = ParInitializeDevice(Pdx);
            
            if (!PAR_OK(Status)) {
                ParNotInitError(Pdx, Status); // Set the IoStatus.Status of the CurrentOpIrp appropriately
            } else {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            }
        }
        break;

    case IOCTL_PAR_QUERY_INFORMATION :
        {
            PPAR_QUERY_INFORMATION IrpBuffer = Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Status = STATUS_SUCCESS;

            Status  = GetStatus(Pdx->Controller);
            Control = GetControl(Pdx->Controller);

            // Interpretating Status & Control
            
            IrpBuffer->Status = 0x0;

            if (PAR_POWERED_OFF(Status) || PAR_NO_CABLE(Status)) {
                
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_POWER_OFF);
                
            } else if (PAR_PAPER_EMPTY(Status)) {
                
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_PAPER_EMPTY);
                
            } else if (PAR_OFF_LINE(Status)) {
                
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_OFF_LINE);
                
            } else if (PAR_NOT_CONNECTED(Status)) {

                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_NOT_CONNECTED);

            }
            
            if (PAR_BUSY(Status)) {
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_BUSY);
            }
            
            if (PAR_SELECTED(Status)) {
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_SELECTED);
            }
            
            Irp->IoStatus.Information = sizeof( PAR_QUERY_INFORMATION );
        }
        break;

    case IOCTL_PAR_QUERY_RAW_DEVICE_ID :

        // We always read the Device Id in Nibble Mode.
        NtStatus = SppQueryDeviceId(Pdx,
                                    Irp->AssociatedIrp.SystemBuffer,
                                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                    &IdLength, TRUE);

        Irp->IoStatus.Status = NtStatus;

        if (NT_SUCCESS(NtStatus)) {
            Irp->IoStatus.Information = IdLength + sizeof(CHAR);
        } else {
            Irp->IoStatus.Information = 0;
        }
        break;

    case IOCTL_PAR_QUERY_DEVICE_ID :

        // We always read the Device Id in Nibble Mode.
        NtStatus = SppQueryDeviceId(Pdx,
                                    Irp->AssociatedIrp.SystemBuffer,
                                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                    &IdLength, FALSE);

        Irp->IoStatus.Status = NtStatus;

        if( NT_SUCCESS( NtStatus ) ) {
            DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_ID - SUCCESS - size = %d\n", IdLength);
            // Include terminating NULL in the string to copy back to user buffer
            Irp->IoStatus.Information = IdLength + sizeof(CHAR);
        } else if( NtStatus == STATUS_BUFFER_TOO_SMALL) {
            DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_ID - FAIL - BUFFER_TOO_SMALL - supplied= %d, required=%d\n",
                                 IrpSp->Parameters.DeviceIoControl.OutputBufferLength, IdLength);
            Irp->IoStatus.Information = 0;
        } else {
            DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_ID - FAIL - QUERY ID FAILED\n");
            Irp->IoStatus.Information = 0;
        }
        break;

    case IOCTL_PAR_QUERY_DEVICE_ID_SIZE :

        //
        // Read the first two bytes of the Nibble Id, add room for the terminating NULL and
        // return this to the caller.
        //
        NtStatus = SppQueryDeviceId(Pdx, NULL, 0, &IdLength, FALSE);

        if (NtStatus == STATUS_BUFFER_TOO_SMALL) {

            DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_DEVICE_ID_SIZE - size required = %d\n", IdLength);

            Irp->IoStatus.Status = STATUS_SUCCESS;

            Irp->IoStatus.Information =
                sizeof(PAR_DEVICE_ID_SIZE_INFORMATION);

            // include space for terminating NULL
            ((PPAR_DEVICE_ID_SIZE_INFORMATION)
                Irp->AssociatedIrp.SystemBuffer)->DeviceIdSize = IdLength + sizeof(CHAR);

        } else {

            Irp->IoStatus.Status      = NtStatus;
            Irp->IoStatus.Information = 0;
        }
        break;

    case IOCTL_PAR_PING :

        // We need to do a quick terminate and negotiate of the current modes
        NtStatus = ParPing(Pdx);
        DD((PCE)Pdx,DDT,"ParDeviceIo:IOCTL_PAR_PING\n");
        Irp->IoStatus.Status      = NtStatus;
        Irp->IoStatus.Information = 0;
        break;
        
    case IOCTL_INTERNAL_DISCONNECT_IDLE :

        if ((Pdx->Connected) &&
            (afpForward[Pdx->IdxForwardProtocol].fnDisconnect)) {
            
            DD((PCE)Pdx,DDT,"ParDeviceIo:IOCTL_INTERNAL_DISCONNECT_IDLE: Calling afpForward.fnDisconnect\n");
            afpForward[Pdx->IdxForwardProtocol].fnDisconnect (Pdx);
        }
        
        Irp->IoStatus.Status      = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;

    case IOCTL_IEEE1284_NEGOTIATE:
        {
            PPARCLASS_NEGOTIATION_MASK  ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;

            ParTerminate(Pdx);
            Irp->IoStatus.Status = IeeeNegotiateMode(Pdx, ppnmMask->usReadMask, ppnmMask->usWriteMask);

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(PARCLASS_NEGOTIATION_MASK)) {
                DD((PCE)Pdx,DDT, "ParDeviceIo: IOCTL_IEEE1284_NEGOTIATE Passed.\n");
                ppnmMask->usReadMask  = arpReverse[Pdx->IdxReverseProtocol].Protocol;
                ppnmMask->usWriteMask = afpForward[Pdx->IdxForwardProtocol].Protocol;
                Irp->IoStatus.Information = sizeof (PARCLASS_NEGOTIATION_MASK);
            } else {
                DD((PCE)Pdx,DDT, "ParDeviceIo: IOCTL_IEEE1284_NEGOTIATE failed.\n");
                Irp->IoStatus.Information = 0;
            }
        }
        break;

    case IOCTL_PAR_GET_DEVICE_CAPS :

        Pdx->BadProtocolModes = *((USHORT *) Irp->AssociatedIrp.SystemBuffer);            
        IeeeDetermineSupportedProtocols(Pdx);
        *((USHORT *) Irp->AssociatedIrp.SystemBuffer) = Pdx->ProtocolModesSupported;
        Irp->IoStatus.Information = sizeof(Pdx->ProtocolModesSupported);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    case IOCTL_PAR_SET_READ_ADDRESS:
        {
            PUCHAR pAddress = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;
            
            if (Pdx->ReverseInterfaceAddress != *pAddress) {
                
                Pdx->ReverseInterfaceAddress = *pAddress;
                Pdx->SetReverseAddress = TRUE;
            }
            
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_SET_WRITE_ADDRESS :
        {
            PUCHAR pAddress = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;
            NtStatus = STATUS_SUCCESS;

            if (Pdx->ForwardInterfaceAddress != *pAddress) {
        
                Pdx->ForwardInterfaceAddress = *pAddress;
                
                if (Pdx->Connected) {
                    if (afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress) {
                        
                        if (Pdx->CurrentPhase != PHASE_FORWARD_IDLE &&
                            Pdx->CurrentPhase != PHASE_FORWARD_XFER) {
                            NtStatus = ParReverseToForward(Pdx);
                        }
                        
                        if (NT_SUCCESS(NtStatus)) {
                            NtStatus  = afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress(
                                Pdx,
                                Pdx->ForwardInterfaceAddress
                                );
                        }
                        
                        if (NT_SUCCESS(NtStatus)) {
                            Pdx->SetForwardAddress = FALSE;
                            Pdx->SetReverseAddress = FALSE;
                            Pdx->ReverseInterfaceAddress = *pAddress;
                        } else {
                            Pdx->SetForwardAddress = TRUE;
                            DD((PCE)Pdx,DDE,"ParDeviceIo: IOCTL_PAR_SET_WRITE_ADDRESS Failed\n");
                        }
                    } else {
                        DD((PCE)Pdx,DDE, "ParDeviceIo: Someone called IOCTL_PAR_SET_WRITE_ADDRESS.\n");
                        DD((PCE)Pdx,DDE, "ParDeviceIo: You don't have a fnSetInterfaceAddress.\n");
                        DD((PCE)Pdx,DDE, "ParDeviceIo: Either IEEE1284.c has wrong info or your caller is in error!\n");
                        NtStatus = STATUS_UNSUCCESSFUL;
                    }    
                } else {
                    Pdx->SetForwardAddress = TRUE;
                }
            }
            
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = NtStatus;
        }
        break;

    case IOCTL_INTERNAL_LOCK_PORT :

        ParpIoctlThreadLockPort(Pdx);
        break;

    case IOCTL_INTERNAL_UNLOCK_PORT :

        ParpIoctlThreadUnlockPort(Pdx);
        break;
        
    case IOCTL_INTERNAL_LOCK_PORT_NO_SELECT:

        DD((PCE)Pdx,DDT, "ParDeviceIo - IOCTL_INTERNAL_LOCK_PORT_NO_SELECT\n");
        Pdx->AllocatedByLockPort  = TRUE;
        Irp->IoStatus.Status      = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;

    case IOCTL_INTERNAL_UNLOCK_PORT_NO_DESELECT:

        DD((PCE)Pdx,DDT, "ParDeviceIo - IOCTL_INTERNAL_UNLOCK_PORT_NO_DESELECT\n");
        Pdx->AllocatedByLockPort  = FALSE;
        PptAssert(!Pdx->Connected && !Pdx->AllocatedByLockPort);
        Irp->IoStatus.Status      = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;

    case IOCTL_SERIAL_SET_TIMEOUTS:
        {
            PSERIAL_TIMEOUTS ptoNew = Irp->AssociatedIrp.SystemBuffer;

            //
            // The only other thing let through is setting
            // the timer start.
            //
            
            Pdx->TimerStart = ptoNew->WriteTotalTimeoutConstant / 1000;
            Irp->IoStatus.Status  = STATUS_SUCCESS;
        }
        break;
    
    case IOCTL_INTERNAL_PARDOT3_CONNECT:
        DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_PARDOT3_CONNECT - Dispatch\n");
        Irp->IoStatus.Status  = ParDot3Connect(Pdx);
        Irp->IoStatus.Information = 0;
        break;
    case IOCTL_INTERNAL_PARDOT3_DISCONNECT:
        DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_PARDOT3_DISCONNECT - Dispatch\n");
        Irp->IoStatus.Status  = ParDot3Disconnect(Pdx);
        Irp->IoStatus.Information = 0;
        break;
    case IOCTL_INTERNAL_PARDOT3_SIGNAL:
        if( Pdx->IdxReverseProtocol != NIBBLE_MODE ) {
            PKEVENT Event;// = (PKEVENT)Irp->AssociatedIrp.SystemBuffer;
            
            RtlCopyMemory(&Event, Irp->AssociatedIrp.SystemBuffer, sizeof(PKEVENT));
            
            ASSERT_EVENT(Event);
            
            DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_PARDOT3_SIGNAL - Dispatch. Event [%x]\n", Event);
            
            Pdx->P12843DL.Event        = Event;
            Pdx->P12843DL.bEventActive = TRUE;
            Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            // don't use signalling in NIBBLE mode - rely on dot4 polling
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        }
        Irp->IoStatus.Information = 0;
        break;
    case IOCTL_INTERNAL_PARDOT3_RESET:
        DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_PARDOT3_RESET - Dispatch\n");
        if (Pdx->P12843DL.fnReset)
            Irp->IoStatus.Status = ((PDOT3_RESET_ROUTINE) (Pdx->P12843DL.fnReset))(Pdx);
        else
            Irp->IoStatus.Status  = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;
    default:

        //
        // unrecognized IOCTL? - we should never get here because the 
        //   dispatch routines should have filtered this out
        //

        // probably harmless, but we want to know if this happens
        //   so we can fix the problem elsewhere
        ASSERTMSG("Unrecognized IOCTL in ParDeviceIo()\n",FALSE);

        Irp->IoStatus.Status  = STATUS_UNSUCCESSFUL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\pdopnp.c ===
#include "pch.h"

NTSTATUS PptPdoStartDevice( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryRemove( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoRemoveDevice( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoCancelRemove( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoStopDevice( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryStop( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoCancelStop( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryDeviceRelations( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryCapabilities( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryDeviceText( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryId( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryPnpDeviceState( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryBusInformation( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoSurpriseRemoval( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoDefaultPnpHandler( PDEVICE_OBJECT DevObj, PIRP Irp );

PDRIVER_DISPATCH 
PptPdoPnpDispatchTable[] =
{ 
    PptPdoStartDevice,          // IRP_MN_START_DEVICE                 0x00
    PptPdoQueryRemove,          // IRP_MN_QUERY_REMOVE_DEVICE          0x01
    PptPdoRemoveDevice,         // IRP_MN_REMOVE_DEVICE                0x02
    PptPdoCancelRemove,         // IRP_MN_CANCEL_REMOVE_DEVICE         0x03
    PptPdoStopDevice,           // IRP_MN_STOP_DEVICE                  0x04
    PptPdoQueryStop,            // IRP_MN_QUERY_STOP_DEVICE            0x05
    PptPdoCancelStop,           // IRP_MN_CANCEL_STOP_DEVICE           0x06
    PptPdoQueryDeviceRelations, // IRP_MN_QUERY_DEVICE_RELATIONS       0x07
    PptPdoDefaultPnpHandler,    // IRP_MN_QUERY_INTERFACE              0x08
    PptPdoQueryCapabilities,    // IRP_MN_QUERY_CAPABILITIES           0x09
    PptPdoDefaultPnpHandler,    // IRP_MN_QUERY_RESOURCES              0x0A
    PptPdoDefaultPnpHandler,    // IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
    PptPdoQueryDeviceText,      // IRP_MN_QUERY_DEVICE_TEXT            0x0C
    PptPdoDefaultPnpHandler,    // IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
    PptPdoDefaultPnpHandler,    // no such PnP request                 0x0E
    PptPdoDefaultPnpHandler,    // IRP_MN_READ_CONFIG                  0x0F
    PptPdoDefaultPnpHandler,    // IRP_MN_WRITE_CONFIG                 0x10
    PptPdoDefaultPnpHandler,    // IRP_MN_EJECT                        0x11
    PptPdoDefaultPnpHandler,    // IRP_MN_SET_LOCK                     0x12
    PptPdoQueryId,              // IRP_MN_QUERY_ID                     0x13
    PptPdoQueryPnpDeviceState,  // IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
    PptPdoQueryBusInformation,  // IRP_MN_QUERY_BUS_INFORMATION        0x15
    PptPdoDefaultPnpHandler,    // IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
    PptPdoSurpriseRemoval,      // IRP_MN_SURPRISE_REMOVAL             0x17
    PptPdoDefaultPnpHandler     // IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
};


NTSTATUS
PptPdoStartDevice(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    ) 
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    pdx->DeviceStateFlags = PPT_DEVICE_STARTED;
    KeSetEvent(&pdx->PauseEvent, 0, FALSE); // unpause any worker thread

    PptRegGetDeviceParameterDword( Pdo, L"Event22Delay", &pdx->Event22Delay );

    //
    // Register device interface for Legacy LPTx interface PDOs and set the interface active
    //  - succeed start even if the device interface code fails
    //
    if( PdoTypeRawPort == pdx->PdoType ) {

        // This is a legacy interface "raw port" PDO, don't set interface for other types of PDOs 

        NTSTATUS  status;
        BOOLEAN   setActive = FALSE;

        if( NULL == pdx->DeviceInterface.Buffer ) {
            // Register device interface
            status = IoRegisterDeviceInterface( Pdo, &GUID_PARCLASS_DEVICE, NULL, &pdx->DeviceInterface );
            if( STATUS_SUCCESS == status ) {
                setActive = TRUE;
            }
        }

        if( (TRUE == setActive) && (FALSE == pdx->DeviceInterfaceState) ) {
            // set interface active
            status = IoSetDeviceInterfaceState( &pdx->DeviceInterface, TRUE );
            if( STATUS_SUCCESS == status ) {
                pdx->DeviceInterfaceState = TRUE;
            }
        }
    }

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoQueryRemove(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    // DDpnp2( ("PptPdoQueryRemove\n") );

    // PnP won't remove us if there are open handles to us - so WE don't need to check for open handles

    pdx->DeviceStateFlags |= (PPT_DEVICE_REMOVE_PENDING | PAR_DEVICE_PAUSED);
    KeClearEvent(&pdx->PauseEvent); // pause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoRemoveDevice(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx     = Pdo->DeviceExtension;
    NTSTATUS        status;

    pdx->DeviceStateFlags = PAR_DEVICE_PAUSED;
    KeClearEvent(&pdx->PauseEvent); // pause any worker thread

    // Set Device Interface inactive for PdoTypeRawPort - other PDO types don't have device interfaces
    if( PdoTypeRawPort == pdx->PdoType ) {
        if( (pdx->DeviceInterface.Buffer != NULL) && (TRUE == pdx->DeviceInterfaceState) ) {
            IoSetDeviceInterfaceState( &pdx->DeviceInterface, FALSE );
            pdx->DeviceInterfaceState = FALSE;
        }
    }

    // If we were not reported in the last FDO BusRelations enumeration then it is safe to delete self
    if( pdx->DeleteOnRemoveOk ) {
        DD((PCE)pdx,DDT,"PptPdoRemoveDevice - DeleteOnRemoveOk == TRUE - cleaning up self\n");
        P4DestroyPdo( Pdo );
        status = P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
        return status;
    } else {
        return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
    }
}


NTSTATUS
PptPdoCancelRemove(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    pdx->DeviceStateFlags &= ~(PPT_DEVICE_REMOVE_PENDING | PAR_DEVICE_PAUSED);
    KeSetEvent(&pdx->PauseEvent, 0, FALSE); // unpause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoStopDevice(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    // DDpnp2( ("PptPdoStopDevice\n") );

    pdx->DeviceStateFlags |=  PAR_DEVICE_PAUSED;
    pdx->DeviceStateFlags &= ~PPT_DEVICE_STARTED;
    KeClearEvent(&pdx->PauseEvent); // pause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoQueryStop(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    // DDpnp2( ("PptPdoQueryStop\n") );

    pdx->DeviceStateFlags  |= (PPT_DEVICE_STOP_PENDING | PAR_DEVICE_PAUSED);
    KeClearEvent(&pdx->PauseEvent); // pause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoCancelStop(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    pdx->DeviceStateFlags &= ~PPT_DEVICE_STOP_PENDING;
    KeSetEvent(&pdx->PauseEvent, 0, FALSE); // unpause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoQueryDeviceRelations(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION        pdx         = Pdo->DeviceExtension;
    PIO_STACK_LOCATION    irpSp       = IoGetCurrentIrpStackLocation( Irp );
    DEVICE_RELATION_TYPE  requestType = irpSp->Parameters.QueryDeviceRelations.Type;
    NTSTATUS              status      = Irp->IoStatus.Status;
    ULONG_PTR             info        = Irp->IoStatus.Information;

    if( TargetDeviceRelation == requestType ) {
        PDEVICE_RELATIONS devRel = ExAllocatePool( PagedPool, sizeof(DEVICE_RELATIONS) );
        if( devRel ) {
            devRel->Count = 1;
            ObReferenceObject( Pdo );
            devRel->Objects[0] = Pdo;
            status = STATUS_SUCCESS;
            info   = (ULONG_PTR)devRel;
        } else {
            status = STATUS_NO_MEMORY;
        }
    } else {
        DD((PCE)pdx,DDT,"PptPdoQueryDeviceRelations - unhandled request Type = %d\n",requestType);
    }
    return P4CompleteRequest( Irp, status, info );
}


NTSTATUS
PptPdoQueryCapabilities(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION      pdx = Pdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation( Irp );

    irpSp->Parameters.DeviceCapabilities.Capabilities->RawDeviceOK       = TRUE;
    if( PdoTypeRawPort == pdx->PdoType ) {
        // This is the legacy LPTx interface device - no driver should
        //  ever be installed for this so don't bother the user with a popup.
        irpSp->Parameters.DeviceCapabilities.Capabilities->SilentInstall = TRUE;
    }

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoQueryDeviceText(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION      pdx        = Pdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp      = IoGetCurrentIrpStackLocation( Irp );
    PWSTR               buffer     = NULL;
    ULONG               bufLen;
    ULONG_PTR           info;
    NTSTATUS            status;

    if( DeviceTextDescription == irpSp->Parameters.QueryDeviceText.DeviceTextType ) {

        //
        // DeviceTextDescription is: catenation of MFG+<SPACE>+MDL
        //
        if( pdx->Mfg && pdx->Mdl ) {
            //
            // Construct UNICODE string to return from the ANSI strings
            //   that we have in our extension
            //
            // need space for <SPACE> and terminating NULL
            //
            bufLen = strlen( (const PCHAR)pdx->Mfg ) + strlen( (const PCHAR)pdx->Mdl ) + 2 * sizeof(CHAR);
            bufLen *= ( sizeof(WCHAR)/sizeof(CHAR) );
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
            if( buffer ) {
                RtlZeroMemory( buffer, bufLen );
                _snwprintf( buffer, bufLen/2, L"%S %S", pdx->Mfg, pdx->Mdl );
                DD((PCE)pdx,DDT,"PptPdoQueryDeviceText - DeviceTextDescription - <%S>\n",buffer);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NO_MEMORY;
            }
        } else {
            DD((PCE)pdx,DDE,"PptPdoQueryDeviceText - MFG and/or MDL NULL - FAIL DeviceTextDescription\n");
            status = STATUS_UNSUCCESSFUL;
        }
    } else if( DeviceTextLocationInformation == irpSp->Parameters.QueryDeviceText.DeviceTextType ) {

        //
        // DeviceTextLocationInformation is LPTx or LPTx.y (note that
        //   this is also the symlink name minus the L"\\DosDevices\\"
        //   prefix)
        //

        if( pdx->Location ) {
            bufLen = strlen( (const PCHAR)pdx->Location ) + sizeof(CHAR);
            bufLen *= ( sizeof(WCHAR)/sizeof(CHAR) );
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
            if( buffer ) {
                RtlZeroMemory( buffer, bufLen );
                _snwprintf( buffer, bufLen/2, L"%S", pdx->Location );
                DD((PCE)pdx,DDT,"PptPdoQueryDeviceText - DeviceTextLocationInformation - <%S>\n",buffer);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NO_MEMORY;
            }
        } else {
            DD((PCE)pdx,DDE,"PptPdoQueryDeviceText - Location NULL - FAIL DeviceTextLocationInformation\n");
            status = STATUS_UNSUCCESSFUL;
        }
    } else {

        // Unknown DeviceTextType - don't change anything in IRP
        buffer = NULL;
        status = Irp->IoStatus.Status;
    }

    if( (STATUS_SUCCESS == status) && buffer ) {
        info = (ULONG_PTR)buffer;
    } else {
        if( buffer ) {
            ExFreePool( buffer );
        }
        info = Irp->IoStatus.Information;
    }

    return P4CompleteRequest( Irp, status, info );
}


NTSTATUS
PptPdoQueryId( PDEVICE_OBJECT Pdo, PIRP Irp )
{
    PPDO_EXTENSION      pdx        = Pdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp      = IoGetCurrentIrpStackLocation( Irp );
    PWSTR               buffer     = NULL;
    ULONG               bufLen;
    NTSTATUS            status;
    ULONG_PTR           info;

    switch( irpSp->Parameters.QueryId.IdType ) {
        
    case BusQueryDeviceID :
        //
        // DeviceID generation: catenate MFG and MDL fields from the
        //   IEEE 1284 device ID string (no space between fields), append
        //   MFG+MDL catenation to LPTENUM\ prefix
        //
        if( pdx->Mfg && pdx->Mdl ) {
            //
            // Construct UNICODE string to return from the ANSI strings
            //   that we have in our extension
            //
            CHAR prefix[] = "LPTENUM\\";
            // sizeof(prefix) provides space for NULL terminator
            bufLen = sizeof(prefix) + strlen( (const PCHAR)pdx->Mfg ) + strlen( (const PCHAR)pdx->Mdl );
            bufLen *= ( sizeof(WCHAR)/sizeof(CHAR) );
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
            if( buffer ) {
                RtlZeroMemory( buffer, bufLen );
                _snwprintf( buffer, bufLen/2, L"%S%S%S", prefix, pdx->Mfg, pdx->Mdl );
                P4SanitizeId( buffer ); // replace any illegal characters with underscore
                DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryDeviceID - <%S>\n",buffer);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NO_MEMORY;
            }

        } else {

            DD((PCE)pdx,DDE,"PptPdoQueryId - MFG and/or MDL NULL - FAIL BusQueryDeviceID\n");
            status = STATUS_UNSUCCESSFUL;

        }
        break;
        
    case BusQueryInstanceID :
        //
        // InstanceID is LPTx or LPTx.y Location of the device (note
        //   that this is also the symlink name minus the
        //   \DosDevices\ prefix)
        //
        if( pdx->Location ) {
            //
            // Construct UNICODE string to return from the ANSI string
            //   that we have in our extension
            //
            bufLen = strlen( (const PCHAR)pdx->Location ) + sizeof(CHAR);
            bufLen *= ( sizeof(WCHAR)/sizeof(CHAR) );
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
            if( buffer ) {
                RtlZeroMemory( buffer, bufLen );
                _snwprintf( buffer, bufLen/2, L"%S", pdx->Location );
                P4SanitizeId( buffer ); // replace any illegal characters with underscore
                DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryInstanceID - <%S>\n",buffer);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NO_MEMORY;
            }
        } else {

            DD((PCE)pdx,DDE,"PptPdoQueryId - Location NULL - FAIL BusQueryInstanceID\n");
            status = STATUS_UNSUCCESSFUL;

        }
        break;
        
    case BusQueryHardwareIDs :
        //
        // HardwareID generation:
        //
        // Generate MfgMdlCrc string as follows:
        //   1) catenate MFG and MDL fields
        //   2) generate checksum on MFG+MDL catenation
        //   3) truncate MFG+MDL catenation
        //   4) append checksum
        //
        // Return as HardwareID MULTI_SZ: LPTENUM\%MfgMdlCrc% followed by bare %MfgMdlCrc%
        //
        //   example: LPTENUM\Acme_CorpFooBarPrint3FA5\0Acme_CorpFooBarPrint3FA5\0\0
        //
        if( pdx->Mfg && pdx->Mdl ) {
            ULONG  lengthOfMfgMdlBuffer = strlen( (const PCHAR)pdx->Mfg ) + strlen( (const PCHAR)pdx->Mdl ) + sizeof(CHAR);
            PCHAR  mfgMdlBuffer         = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, lengthOfMfgMdlBuffer );

            if( mfgMdlBuffer ) {
                const CHAR  prefix[]              = "LPTENUM\\";
                const ULONG mfgMdlTruncationLimit = 20;
                const ULONG checksumLength        = 4;
                USHORT      checksum;

                // 1) catenate MFG and MDL fields and 2) generate checksum on catenation
                RtlZeroMemory( mfgMdlBuffer, lengthOfMfgMdlBuffer );
                _snprintf( mfgMdlBuffer, lengthOfMfgMdlBuffer, "%s%s", pdx->Mfg, pdx->Mdl );
                GetCheckSum( mfgMdlBuffer, (USHORT)strlen(mfgMdlBuffer), &checksum );

                //
                // alloc buffer large enough for result returned to PnP,
                // include space for 4 checksum chars (twice) + 1 NULL between strings + 2 termination chars (MULTI_SZ)
                //
                bufLen = strlen( prefix ) + 2 * mfgMdlTruncationLimit + 2 * checksumLength + 3 * sizeof(CHAR); 
                bufLen *= (sizeof(WCHAR)/sizeof(CHAR)); // convert to size needed for WCHARs
                buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
                if( buffer ) {
                    ULONG wcharsWritten;
                    RtlZeroMemory( buffer, bufLen );

                    // Construct the HardwareID MULTI_SZ:
                    //
                    //  Write the first Hardware ID: LPTENUM\xxx
                    wcharsWritten = _snwprintf( buffer, bufLen/2, L"%S%.20S%04X", prefix, mfgMdlBuffer, checksum );

                    //  Skip forward a UNICODE_NULL past the end of the first Hardware ID and write the second
                    //    Hardware ID: bare xxx
                    _snwprintf( buffer+wcharsWritten+1, bufLen/2-wcharsWritten-1, L"%.20S%04X", mfgMdlBuffer, checksum );

                    ExFreePool( mfgMdlBuffer );

                    DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryHardwareIDs 1st ID - <%S>\n",buffer);
                    DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryHardwareIDs 2nd ID - <%S>\n",buffer+wcslen(buffer)+1);                    
                    // replace any illegal characters with underscore, preserve UNICODE_NULLs
                    P4SanitizeMultiSzId( buffer, bufLen/2 );

                    status = STATUS_SUCCESS;

                    // printing looks for PortName in the devnode - Pdo's Location is the PortName
                    P4WritePortNameToDevNode( Pdo, pdx->Location );

                } else {
                    ExFreePool( mfgMdlBuffer );
                    DD((PCE)pdx,DDT,"PptPdoQueryId - no pool for buffer - FAIL BusQueryHardwareIDs\n");
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

            } else {
                DD((PCE)pdx,DDT,"PptPdoQueryId - no pool for mfgMdlBuffer - FAIL BusQueryHardwareIDs\n");
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            DD((PCE)pdx,DDT,"PptPdoQueryId - MFG and/or MDL NULL - FAIL BusQueryHardwareIDs\n");
            status = STATUS_UNSUCCESSFUL;
        }

        //
        // Save the MFG and MDL fields from the IEEE 1284 Device ID string under the 
        //   "<DevNode>\Device Parameters" key so that user mode code (e.g., printing)
        //   can retrieve the fields.
        //
        PptWriteMfgMdlToDevNode( Pdo, pdx->Mfg, pdx->Mdl );

        break;
        
    case BusQueryCompatibleIDs :

        //
        // Printing group specified that we not report compatible IDs - 2000-04-24
        //
#define PPT_REPORT_COMPATIBLE_IDS 0
#if (0 == PPT_REPORT_COMPATIBLE_IDS)

        DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryCompatibleIDs - query not supported\n");
        status = Irp->IoStatus.Status;

#else
        //
        // Return the compatible ID string reported by device, if any
        //

        if( pdx->Cid ) {
            //
            // Construct UNICODE string to return from the ANSI string
            //   that we have in our extension
            //
            bufLen = strlen( pdx->Cid ) + 2 * sizeof(CHAR);
            bufLen *= ( sizeof(WCHAR)/sizeof(CHAR) );
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
            if( buffer ) {
                RtlZeroMemory( buffer, bufLen );
                _snwprintf( buffer, bufLen/2, L"%S", pdx->Cid );
                DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryCompatibleIDs - <%S>\n",buffer);

                //
                // convert the 1284 ID representation of a Compatible ID seperator (',') into
                //   a MULTI_SZ - (i.e., scan the WSTR and replace any L',' with L'\0')
                //
                {
                    PWCHAR p = buffer;
                    while( *p ) {
                        if( L',' == *p ) {
                            *p = L'\0';
                        }
                        ++p;
                    }
                }

                // replace any illegal characters with underscore, preserve UNICODE_NULLs
                P4SanitizeMultiSzId( buffer, bufLen/2 );

                status = STATUS_SUCCESS;

            } else {
                DD((PCE)pdx,DDT,"PptPdoQueryId - no pool - FAIL BusQueryCompatibleIDs\n");
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            DD((PCE)pdx,DDT,"PptPdoQueryId - CID NULL - BusQueryCompatibleIDs\n");
            status = Irp->IoStatus.Status;
        }
#endif //  #if (0 == PPT_REPORT_COMPATIBLE_IDS)

        break;
        
    default :
        //
        // Invalid irpSp->Parameters.QueryId.IdType
        //
        DD((PCE)pdx,DDT,"PptPdoQueryId - unrecognized irpSp->Parameters.QueryId.IdType\n");
        status = Irp->IoStatus.Status;
    }


    if( (STATUS_SUCCESS == status) && buffer ) {
        info = (ULONG_PTR)buffer;
    } else {
        if( buffer ) {
            ExFreePool( buffer );
        }
        info = Irp->IoStatus.Information;
    }

    return P4CompleteRequest( Irp, status, info );
}


NTSTATUS
PptPdoQueryPnpDeviceState( PDEVICE_OBJECT Pdo, PIRP Irp )
{
    PPDO_EXTENSION      pdx    = Pdo->DeviceExtension;
    NTSTATUS            status = Irp->IoStatus.Status;
    ULONG_PTR           info   = Irp->IoStatus.Information;


    if( PdoTypeRawPort == pdx->PdoType ) {
        info |= PNP_DEVICE_DONT_DISPLAY_IN_UI;
        status = STATUS_SUCCESS;
    }
    return P4CompleteRequest( Irp, status, info );
}

NTSTATUS
PptPdoQueryBusInformation( PDEVICE_OBJECT Pdo, PIRP Irp )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;
    NTSTATUS        status;
    ULONG_PTR       info;

    if( pdx->PdoType != PdoTypeRawPort ) {

        //
        // we are a "real" device enumerated by parport - report BusInformation
        //

        PPNP_BUS_INFORMATION  pBusInfo = ExAllocatePool( PagedPool, sizeof(PNP_BUS_INFORMATION) );

        if( pBusInfo ) {

            pBusInfo->BusTypeGuid   = GUID_BUS_TYPE_LPTENUM;
            pBusInfo->LegacyBusType = PNPBus;
            pBusInfo->BusNumber     = 0;

            status                  = STATUS_SUCCESS;
            info                    = (ULONG_PTR)pBusInfo;

        } else {

            // no pool
            status = STATUS_NO_MEMORY;
            info   = Irp->IoStatus.Information;

        }

    } else {

        //
        // we are a pseudo device (Legacy Interface Raw Port PDO LPTx) - don't report BusInformation
        //
        status = Irp->IoStatus.Status;
        info   = Irp->IoStatus.Information;

    }

    return P4CompleteRequest( Irp, status, info );
}


NTSTATUS
PptPdoSurpriseRemoval( 
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION      pdx = Pdo->DeviceExtension;

    // Set Device Interface inactive for PdoTypeRawPort - other PDO types don't have device interfaces
    if( PdoTypeRawPort == pdx->PdoType ) {
        if( (pdx->DeviceInterface.Buffer != NULL) && (TRUE == pdx->DeviceInterfaceState) ) {
            IoSetDeviceInterfaceState( &pdx->DeviceInterface, FALSE );
            pdx->DeviceInterfaceState = FALSE;
        }
    }

    pdx->DeviceStateFlags |= PPT_DEVICE_SURPRISE_REMOVED;
    KeClearEvent(&pdx->PauseEvent); // pause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoDefaultPnpHandler(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    UNREFERENCED_PARAMETER( Pdo );

    return P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
}


NTSTATUS 
PptPdoPnp(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    ) 
{ 
    PPDO_EXTENSION               pdx   = Pdo->DeviceExtension;
    PIO_STACK_LOCATION           irpSp = IoGetCurrentIrpStackLocation( Irp );

    // diagnostic
    PptPdoDumpPnpIrpInfo( Pdo, Irp);

    if( pdx->DeviceStateFlags & PPT_DEVICE_DELETE_PENDING ) {
        DD((PCE)pdx,DDT,"PptPdoPnp - PPT_DEVICE_DELETE_PENDING - bailing out\n");
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }

    if( irpSp->MinorFunction < arraysize(PptPdoPnpDispatchTable) ) {
        return PptPdoPnpDispatchTable[ irpSp->MinorFunction ]( Pdo, Irp );
    } else {
        DD((PCE)pdx,DDT,"PptPdoPnp - Default Handler - IRP_MN = %x\n",irpSp->MinorFunction);
        return PptPdoDefaultPnpHandler( Pdo, Irp );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\pdopower.c ===
#include "pch.h"

NTSTATUS
PptPdoPower(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PIRP            Irp
   )
{
    PPDO_EXTENSION      pdx           = Pdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp         = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS            status;
    ULONG_PTR           info          = Irp->IoStatus.Information;
    POWER_STATE         powerState    = irpSp->Parameters.Power.State;
    POWER_STATE_TYPE    powerType     = irpSp->Parameters.Power.Type;
    UCHAR               minorFunction = irpSp->MinorFunction;

    switch( minorFunction ) {

    case IRP_MN_QUERY_POWER:

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SET_POWER:

        switch( powerType ) {

        case DevicePowerState:

            PoSetPowerState( pdx->DeviceObject, powerType, powerState );
            pdx->DeviceState = powerState.DeviceState;
            status = STATUS_SUCCESS;
            break;

        case SystemPowerState:

            status = STATUS_SUCCESS;
            break;

        default:

            status = Irp->IoStatus.Status;

        }

        break;

    default:

        status = Irp->IoStatus.Status;

    }

    PoStartNextPowerIrp( Irp );

    P4CompleteRequest( Irp, status, info );

    DD((PCE)pdx,DDT,"PptPdoPower - minorFunction=%x, powerState=%x, powerType=%x, status=%x",minorFunction,powerState,powerType,status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\pdoquerysetinfo.c ===
#include "pch.h"

NTSTATUS
PptPdoQueryInformation(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_INVALID_PARAMETER    - Invalid file information request.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.

--*/

{
    NTSTATUS                    Status;
    PIO_STACK_LOCATION          IrpSp;
    PFILE_STANDARD_INFORMATION  StdInfo;
    PFILE_POSITION_INFORMATION  PosInfo;
    PPDO_EXTENSION           Extension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // bail out if device has been removed
    //
    if(Extension->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {
        P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, Irp->IoStatus.Information );
        return STATUS_DEVICE_REMOVED;
    }

    Irp->IoStatus.Information = 0;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {
        
    case FileStandardInformation:
        
        if (IrpSp->Parameters.QueryFile.Length < sizeof(FILE_STANDARD_INFORMATION)) {

            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            StdInfo = Irp->AssociatedIrp.SystemBuffer;
            StdInfo->AllocationSize.QuadPart = 0;
            StdInfo->EndOfFile               = StdInfo->AllocationSize;
            StdInfo->NumberOfLinks           = 0;
            StdInfo->DeletePending           = FALSE;
            StdInfo->Directory               = FALSE;
            
            Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);
            Status = STATUS_SUCCESS;
            
        }
        break;
        
    case FilePositionInformation:
        
        if (IrpSp->Parameters.SetFile.Length < sizeof(FILE_POSITION_INFORMATION)) {

            Status = STATUS_BUFFER_TOO_SMALL;

        } else {
            
            PosInfo = Irp->AssociatedIrp.SystemBuffer;
            PosInfo->CurrentByteOffset.QuadPart = 0;
            
            Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);
            Status = STATUS_SUCCESS;
        }
        break;
        
    default:
        Status = STATUS_INVALID_PARAMETER;
        break;
        
    }
    
    P4CompleteRequest( Irp, Status, Irp->IoStatus.Information );

    return Status;
}

NTSTATUS
PptPdoSetInformation(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_INVALID_PARAMETER    - Invalid file information request.

--*/

{
    NTSTATUS               Status;
    FILE_INFORMATION_CLASS fileInfoClass;
    PPDO_EXTENSION      Extension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // bail out if device has been removed
    //
    if(Extension->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {

        return P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, Irp->IoStatus.Information );

    }


    Irp->IoStatus.Information = 0;

    fileInfoClass = IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass;

    if (fileInfoClass == FileEndOfFileInformation) {

        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_INVALID_PARAMETER;

    }

    return P4CompleteRequest( Irp, Status, Irp->IoStatus.Information );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\queueclass.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    queue.c

Abstract:

   Creates a simple Queue that works in Kernel Mode.

Author:

    Robbie Harris (Hewlett-Packard) 22-May-1998

Environment:

    Kernel mode

Revision History :

--*/
#include "pch.h"

void Queue_Create(Queue *pQueue, int size)
{
    if( !pQueue ) {
        DD(NULL,DDE,"Queue_Create: Queue is Bad");
        return;
    }

    if (pQueue->theArray) {
        Queue_Delete(pQueue);
    }
        
    pQueue->theArray = (UCHAR *)ExAllocatePool(NonPagedPool, size);
    pQueue->max      = size;
    pQueue->head     = pQueue->tail = 0;
}

BOOLEAN Queue_Delete(Queue *pQueue)
{
    if( !pQueue ) {
        return FALSE;
    }

    if( pQueue->theArray ) {
        ExFreePool(pQueue->theArray);
        pQueue->theArray = NULL;
    }
    
    pQueue->head = 0;
    pQueue->tail = 0;
    pQueue->max  = 0;
    
    return TRUE;
}

BOOLEAN Queue_Dequeue(Queue *pQueue, PUCHAR data)
{
    // Validity of pQueue is checked in Queue_IsEmpty proc. 
    if( Queue_IsEmpty( pQueue ) ) {
        DD(NULL,DDE,"Queue_Dequeue: Queue is Empty");
        return FALSE;
    }

    *data = pQueue->theArray[pQueue->head++];
    return TRUE;
}

BOOLEAN Queue_Enqueue(Queue *pQueue, UCHAR data)
{
    // Validity of pQueue is checked in Queue_IsFull proc. 
    if( Queue_IsFull( pQueue ) ) {
        DD(NULL,DDE,"Queue_Enqueue: Queue is full. Data is lost");
        return FALSE;
    } else {
        pQueue->theArray[pQueue->tail++] = data;
    }

    return TRUE;
}

// Return TRUE if we were able to free some space in the Queue
BOOLEAN Queue_GarbageCollect(Queue *pQueue)
{
    int     iListSize;
    int     i;

    if (!pQueue)
    {
        DD(NULL,DDE,"Queue_GarbageCollect: Queue is Bad");
        return FALSE;
    }

    iListSize = pQueue->tail - pQueue->head;

    // Check to see if there is any free entries
    if (pQueue->head == 0 && pQueue->tail == pQueue->max)
        return FALSE;
         
    for (i = 0; i < iListSize; i++) {
    
        pQueue->theArray[i] = pQueue->theArray[pQueue->head+i];
    }

    pQueue->head = 0;
    pQueue->tail = iListSize;

    return TRUE;
}

//============================================================================
// NAME:    HPKQueue::IsEmpty()
//  
// PARAMETERS: None
//
// RETURNS: True is Queue is empty or doesn't exist.  Otherwise False.
//
//============================================================================
BOOLEAN Queue_IsEmpty(Queue *pQueue)
{
    if (!pQueue)
    {
        DD(NULL,DDE,"Queue_IsEmpty: Queue is Bad");
        return TRUE;
    }

    if (pQueue->theArray) {
    
        return (BOOLEAN)(pQueue->head == pQueue->tail);
    }
    DD(NULL,DDE,"Queue_IsEmpty: Queue->theArray is Bad");
    return TRUE;
}

//============================================================================
// NAME:    HPKQueue::IsFull()
//  
// PARAMETERS: None
//
// RETURNS: True is Queue is full or doesn't exist.  Otherwise False.
//
//============================================================================
BOOLEAN Queue_IsFull(Queue *pQueue)
{
    if( !pQueue ) {
        DD(NULL,DDE,"Queue_IsFull: Queue is Bad");
        return TRUE;
    }

    if( pQueue->theArray ) {
    
        if( pQueue->tail == pQueue->max ) {
            return !Queue_GarbageCollect(pQueue);
        } else {
            return FALSE;
        }
    }
    DD(NULL,DDE,"Queue_IsFull: Queue->theArray is Bad");
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\queueclass.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    queue.h

Abstract:

   Creates a simple Queue that works in Kernel Mode.

Author:

    Robbie Harris (Hewlett-Packard) 22-May-1998

Environment:

    Kernel mode

Revision History :

--*/
#ifndef _QUEUE_
#define _QUEUE_

typedef struct _Queue {
    int     head;
    int     max;
    int     tail;
    UCHAR   *theArray;
} Queue, *PQueue;

void Queue_Create(Queue *pQueue, int size);
BOOLEAN Queue_Delete(Queue *pQueue);
BOOLEAN Queue_Dequeue(Queue *pQueue, PUCHAR data);
BOOLEAN Queue_Enqueue(Queue *pQueue, UCHAR data);
BOOLEAN Queue_GarbageCollect(Queue *pQueue); 
BOOLEAN Queue_IsEmpty(Queue *pQueue);
BOOLEAN Queue_IsFull(Queue *pQueue);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\readwrite.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       readwrit.c
//
//--------------------------------------------------------------------------

//
// This file contains functions associated with handling Read and Write requests
//

#include "pch.h"


NTSTATUS
ParForwardToReverse(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine flips the bus from Forward to Reverse direction.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Do a quick check to see if we are where we want to be.  
    // Happy punt if everything is ok.
    if( Pdx->Connected &&
        ( Pdx->CurrentPhase == PHASE_REVERSE_IDLE || Pdx->CurrentPhase == PHASE_REVERSE_XFER) ) {

        DD((PCE)Pdx,DDT,"ParForwardToReverse - already in reverse mode\n");
        return Status;
    }

    if (Pdx->Connected) {
    
        if (Pdx->CurrentPhase != PHASE_REVERSE_IDLE &&
            Pdx->CurrentPhase != PHASE_REVERSE_XFER) {
        
            if (afpForward[Pdx->IdxForwardProtocol].ProtocolFamily ==
                arpReverse[Pdx->IdxReverseProtocol].ProtocolFamily) {

                // Protocol Families match and we are in Fwd.  Exit Fwd to cleanup the state
                // machine, fifo, etc.  We will call EnterReverse later to
                // actually bus flip.  Also only do this if in safe mode
                if ( (afpForward[Pdx->IdxForwardProtocol].fnExitForward) ) {
                    Status = afpForward[Pdx->IdxForwardProtocol].fnExitForward(Pdx);
                }
                    
            } else {

                //
                // Protocol Families don't match...need to terminate from the forward mode
                //
                if (afpForward[Pdx->IdxForwardProtocol].fnDisconnect) {
                    afpForward[Pdx->IdxForwardProtocol].fnDisconnect (Pdx);
                }
                if ((Pdx->ForwardInterfaceAddress != DEFAULT_ECP_CHANNEL) &&    
                    (afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress))
                    Pdx->SetForwardAddress = TRUE;
            }
            
        }                
    }

    if( (!Pdx->Connected) && (arpReverse[Pdx->IdxReverseProtocol].fnConnect) ) {

        //
        // If we are still connected the protocol families match...
        //
        Status = arpReverse[Pdx->IdxReverseProtocol].fnConnect(Pdx, FALSE);

        //
        // Makes the assumption that the connected address is always 0
        //
        if ((NT_SUCCESS(Status)) &&
            (arpReverse[Pdx->IdxReverseProtocol].fnSetInterfaceAddress) &&
            (Pdx->ReverseInterfaceAddress != DEFAULT_ECP_CHANNEL)) {
            
            Pdx->SetReverseAddress = TRUE;
        }    
    }

    //
    // Set the channel address if we need to.
    //
    if (NT_SUCCESS(Status) && Pdx->SetReverseAddress &&    
        (arpReverse[Pdx->IdxReverseProtocol].fnSetInterfaceAddress)) {

        Status  = arpReverse[Pdx->IdxReverseProtocol].fnSetInterfaceAddress (
                                                                    Pdx,
                                                                    Pdx->ReverseInterfaceAddress);
        if (NT_SUCCESS(Status))
            Pdx->SetReverseAddress = FALSE;
        else
            Pdx->SetReverseAddress = TRUE;
    }

    //
    // Do we need to reverse?
    //
    if ( (NT_SUCCESS(Status)) && 
           ((Pdx->CurrentPhase != PHASE_REVERSE_IDLE) &&
            (Pdx->CurrentPhase != PHASE_REVERSE_XFER)) ) {
            
        if ((arpReverse[Pdx->IdxReverseProtocol].fnEnterReverse))
            Status = arpReverse[Pdx->IdxReverseProtocol].fnEnterReverse(Pdx);
    }

    DD((PCE)Pdx,DDT,"ParForwardToReverse - exit w/status=%x\n",Status);

    return Status;
}

BOOLEAN 
ParHaveReadData(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:
    This method determines if the dot4 peripheral has any data ready
    to send to the host.

Arguments:
    Pdx    - Supplies the device EXTENSION.   

Return Value:
    TRUE    - Either the peripheral has data
    FALSE   - No data
--*/
{
    NTSTATUS  status;
    BOOLEAN   justAcquiredPort = FALSE;

    if( Pdx->CurrentPhase != PHASE_TERMINATE    &&
        Pdx->CurrentPhase != PHASE_REVERSE_IDLE &&
        Pdx->CurrentPhase != PHASE_REVERSE_XFER &&
        Pdx->CurrentPhase != PHASE_FORWARD_IDLE &&
        Pdx->CurrentPhase != PHASE_FORWARD_XFER ) {

        // unexpected phase - no idea what to do here - pretend that
        // there is no data avail and return

        DD((PCE)Pdx,DDE,"ParHaveReadData - unexpected CurrentPhase %x\n",Pdx->CurrentPhase);
        PptAssertMsg("ParHaveReadData - unexpected CurrentPhase",FALSE);
        return FALSE;
    }
    
    if( PHASE_TERMINATE == Pdx->CurrentPhase ) {

        //
        // we're not currently talking with the peripheral and we
        // likely don't have access to the port - try to acquire the
        // port and establish communication with the peripheral so
        // that we can check if the peripheral has data for us
        //

        // CurrentPhase indicates !Connected - do a check for consistency
        PptAssert( !Pdx->Connected );
        
        DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_TERMINATE\n");

        if( !Pdx->bAllocated ) {

            // we don't have the port - try to acquire port

            DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_TERMINATE - don't have port\n");

            status = PptAcquirePortViaIoctl( Pdx->Fdo, NULL );

            if( STATUS_SUCCESS == status ) {

                // we now have the port

                DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_TERMINATE - port acquired\n");

                // note that we have just now acquired the port so
                // that we can release the port below if we are unable
                // to establish communication with the peripheral
                justAcquiredPort = TRUE;

                Pdx->bAllocated  = TRUE;

            } else {

                // we couldn't get the port - bail out

                DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_TERMINATE - don't have port - acquire failed\n");
                return FALSE;

            }

        } // endif !Pdx->bAllocated


        //
        // we now have the port - try to negotiate into a forward
        // mode since we believe that the check for periph data
        // avail is more robust in forward modes
        //

        DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_TERMINATE - we have the port - try to Connect\n");

        DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - try to Connect - calling ParReverseToForward\n");

        //
        // ParReverseToForward:
        //
        // 1) tries to negotiate the peripheral into the forward mode
        // specified by a combination of the device specific
        // Pdx->IdxForwardProtocol and the driver global afpForward
        // array.
        //
        // 2) sets up our internal state machine, Pdx->CurrentPhase
        //
        // 3) as a side effect - sets Pdx->SetForwardAddress if we
        // need to use a non-Zero ECP (or EPP) address.
        //
        status = ParReverseToForward( Pdx );

        if( STATUS_SUCCESS == status ) {

            //
            // We are in communication with the peripheral
            //

            DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - connected - ParReverseToForward SUCCESS\n");

            // Set the channel address if we need to - use the side effect from ParReverseToForward here
            if( Pdx->SetForwardAddress ) {
                DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - connected - try to set Forward Address\n");
                if( afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress ) {
                    status = afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress ( Pdx, Pdx->ForwardInterfaceAddress );
                    if( STATUS_SUCCESS == status ) {

                        // success - set flag to indicate that we don't need to set the address again
                        DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - connected - set Forward Address - SUCCESS\n");
                        Pdx->SetForwardAddress = FALSE;

                    } else {

                        // couldn't set address - clean up and bail out - report no peripheral data avail
                        DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - connected - set Forward Address - FAIL\n");
                        Pdx->SetForwardAddress = TRUE;

                        // Return peripheral to quiescent state
                        // (Compatibility Mode Forward Idle) and set
                        // our state machine accordingly
                        ParTerminate( Pdx );

                        // if we just acquired the port in this function then give
                        // up the port, otherwise keep it for now
                        if( justAcquiredPort ) {
                            DD((PCE)Pdx,DDE,"ParHaveReadData - set address failed - giving up port\n");
                            ParFreePort( Pdx );
                        }
                        return FALSE;

                    }
                }

            } else {
                DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - connected - no need to set Forward Address\n");
            }

        } else {

            // unable to establish communication with peripheral

            DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - try to Connect - ParReverseToForward FAILED\n");

            // if we just acquired the port in this function then give
            // up the port, otherwise keep it for now
            if( justAcquiredPort ) {
                DD((PCE)Pdx,DDE,"ParHaveReadData - connect failed - giving up port\n");
                ParFreePort( Pdx );
            }
            return FALSE;
        }

        // we're communicating with the peripheral - fall through to below to check for data avail

    } // endif PHASE_TERMINATE == CurrentPhase
    

    if( Pdx->CurrentPhase == PHASE_REVERSE_IDLE ||
        Pdx->CurrentPhase == PHASE_REVERSE_XFER ) {

        DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_REVERSE_*\n");

        if( arpReverse[Pdx->IdxReverseProtocol].fnHaveReadData ) {

            if( arpReverse[Pdx->IdxReverseProtocol].fnHaveReadData( Pdx ) ) {
                DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_REVERSE_* - we have data\n");
                return TRUE;
            }

        }

        DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_REVERSE_* - no data - flip bus to forward\n");

        // Don't have data.  This could be a fluke. Let's flip the bus
        // and try again in Fwd mode since some peripherals reportedly
        // have broken firmware that does not properly signal that
        // they have data avail when in some reverse modes.
        ParReverseToForward( Pdx );

    }

    if( Pdx->CurrentPhase == PHASE_FORWARD_IDLE || 
        Pdx->CurrentPhase == PHASE_FORWARD_XFER ) {

        DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_FORWARD_*\n");

        if( afpForward[Pdx->IdxForwardProtocol].ProtocolFamily == FAMILY_BECP ||
            afpForward[Pdx->IdxForwardProtocol].Protocol & ECP_HW_NOIRQ       ||
            afpForward[Pdx->IdxForwardProtocol].Protocol & ECP_HW_IRQ) {

            if( PptEcpHwHaveReadData( Pdx ) ) {
                DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_FORWARD_* - ECP HW - have data\n");
                return TRUE;
            }

            // Hmmm.  No data. Is the chip stuck?
            DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_FORWARD_* - ECP HW - no data\n");
            return FALSE;

        } else {

            if( afpForward[Pdx->IdxForwardProtocol].Protocol & ECP_SW ) {
                DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_FORWARD_* - ECP SW - checking for data\n");
                return ParEcpHaveReadData( Pdx );
            }

        }
    }

    // DVRH  RMT
    // We got here because the protocol doesn't support peeking.
    //  - pretend there is data avail
    DD((PCE)Pdx,DDE,"ParHaveReadData - exit - returning TRUE\n");
    return TRUE;
}

NTSTATUS 
ParPing(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:
    This method was intended to ping the device, but it is currently a NOOP.

Arguments:
    Pdx    - Supplies the device EXTENSION.   

Return Value:
    none
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( Pdx );

    return NtStatus;
}

NTSTATUS
PptPdoReadWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This is the dispatch routine for READ and WRITE requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_PENDING              - Request pending - a worker thread will carry
                                    out the request at PASSIVE_LEVEL IRQL

    STATUS_SUCCESS              - Success - asked for a read or write of
                                    length zero.

    STATUS_INVALID_PARAMETER    - Invalid parameter.

    STATUS_DELETE_PENDING       - This device object is being deleted.

--*/

{
    PIO_STACK_LOCATION  IrpSp;
    PPDO_EXTENSION   Pdx;

    Irp->IoStatus.Information = 0;

    IrpSp     = IoGetCurrentIrpStackLocation(Irp);
    Pdx = DeviceObject->DeviceExtension;

    //
    // bail out if a delete is pending for this device object
    //
    if(Pdx->DeviceStateFlags & PPT_DEVICE_DELETE_PENDING) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }
    
    //
    // bail out if a remove is pending for our ParPort device object
    //
    if(Pdx->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }

    //
    // bail out if device has been removed
    //
    if(Pdx->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {
        return P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, Irp->IoStatus.Information );
    }


    //
    // Note that checks of the Write IRP parameters also handles Read IRPs
    //   because the Write and Read structures are identical in the
    //   IO_STACK_LOCATION.Parameters union
    //


    //
    // bail out on nonzero offset
    //
    if( (IrpSp->Parameters.Write.ByteOffset.HighPart != 0) || (IrpSp->Parameters.Write.ByteOffset.LowPart  != 0) ) {
        return P4CompleteRequest( Irp, STATUS_INVALID_PARAMETER, Irp->IoStatus.Information );
    }


    //
    // immediately succeed read or write request of length zero
    //
    if (IrpSp->Parameters.Write.Length == 0) {
        return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
    }


    //
    // Request appears to be valid, queue it for our worker thread to handle at
    // PASSIVE_LEVEL IRQL and wake up the thread to do the work
    //
    {
        KIRQL               OldIrql;

        // make sure IRP isn't cancelled out from under us
        IoAcquireCancelSpinLock(&OldIrql);
        if (Irp->Cancel) {
            
            // IRP has been cancelled, bail out
            IoReleaseCancelSpinLock(OldIrql);
            return STATUS_CANCELLED;
            
        } else {
            BOOLEAN needToSignalSemaphore = (IsListEmpty( &Pdx->WorkQueue ) &&
				!KeReadStateSemaphore( &Pdx->RequestSemaphore )) ? TRUE : FALSE;

#pragma warning( push ) 
#pragma warning( disable : 4054 4055 )
            IoSetCancelRoutine(Irp, ParCancelRequest);
#pragma warning( pop ) 
            IoMarkIrpPending(Irp);
            InsertTailList(&Pdx->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            IoReleaseCancelSpinLock(OldIrql);
            if( needToSignalSemaphore ) {
                KeReleaseSemaphore(&Pdx->RequestSemaphore, 0, 1, FALSE);
            }
            return STATUS_PENDING;
        }
    }
}

NTSTATUS
ParRead(
    IN PPDO_EXTENSION    Pdx,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR   lpsBufPtr = (PUCHAR)Buffer;    // Pointer to buffer cast to desired data type
    ULONG    Bytes = 0;

    *NumBytesRead = Bytes;

    // only do this if we are in safe mode
    if ( Pdx->ModeSafety == SAFE_MODE ) {

        if (arpReverse[Pdx->IdxReverseProtocol].fnReadShadow) {
            Queue     *pQueue;
   
            pQueue = &(Pdx->ShadowBuffer);

            arpReverse[Pdx->IdxReverseProtocol].fnReadShadow( pQueue, lpsBufPtr, NumBytesToRead, &Bytes );
            NumBytesToRead -= Bytes;
            *NumBytesRead += Bytes;
            lpsBufPtr += Bytes;
            if ( 0 == NumBytesToRead ) {

                Status = STATUS_SUCCESS;
                if ((!Queue_IsEmpty(pQueue)) &&
                    (TRUE == Pdx->P12843DL.bEventActive) ) {
                    KeSetEvent(Pdx->P12843DL.Event, 0, FALSE);
                }
    	        goto ParRead_ExitLabel;
            }
        }

        if (arpReverse[Pdx->IdxReverseProtocol].fnHaveReadData) {
            if (!arpReverse[Pdx->IdxReverseProtocol].fnHaveReadData(Pdx)) {
                DD((PCE)Pdx,DDT,"ParRead - periph doesn't have data - give cycles to someone else\n");
                Status = STATUS_SUCCESS;
                goto ParRead_ExitLabel;
            }
        }
        
    }

    // Go ahead and flip the bus if need be.  The proc will just make sure we're properly
    // connected and pointing in the right direction.
    Status = ParForwardToReverse( Pdx );


    //
    // The read mode will vary depending upon the currently negotiated mode.
    // Default: Nibble
    //

    if (NT_SUCCESS(Status)) {
        
        if (Pdx->fnRead || arpReverse[Pdx->IdxReverseProtocol].fnRead) {
            //
            // Do the read...
            //
            if(Pdx->fnRead) {
                Status = ((PPROTOCOL_READ_ROUTINE)Pdx->fnRead)( Pdx, (PVOID)lpsBufPtr, NumBytesToRead, &Bytes );
            } else {
                Status = arpReverse[Pdx->IdxReverseProtocol].fnRead( Pdx, (PVOID)lpsBufPtr, NumBytesToRead, &Bytes );
            }
            *NumBytesRead += Bytes;
            NumBytesToRead -= Bytes;
            
#if DVRH_SHOW_BYTE_LOG
            {
                ULONG i=0;
                DD((PCE)Pdx,DDT,"Parallel:Read: ");
                for (i=0; i<*NumBytesRead; ++i) {
                    DD((PCE)Pdx,DDT," %02x",((PUCHAR)lpsBufPtr)[i]);
                }
                DD((PCE)Pdx,DDT,"\n");
            }
#endif
            
        } else {
            // If you are here, you've got a bug somewhere else
            DD((PCE)Pdx,DDE,"ParRead - you're hosed man - no fnRead\n");
            PptAssertMsg("ParRead - don't have a fnRead! Can't Read!\n",FALSE);
        }
        
    } else {
        DD((PCE)Pdx,DDE,"ParRead - Bus Flip Forward->Reverse FAILED - can't read\n");
    }

ParRead_ExitLabel:

    return Status;
}


VOID
ParReadIrp(
    IN  PPDO_EXTENSION  Pdx
    )
/*++

Routine Description:

    This routine implements a READ request with the extension's current irp.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{
    PIRP                Irp = Pdx->CurrentOpIrp;
    PIO_STACK_LOCATION  IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG               bytesRead;
    NTSTATUS            status;

    status = ParRead( Pdx, Irp->AssociatedIrp.SystemBuffer, IrpSp->Parameters.Read.Length, &bytesRead );

    Irp->IoStatus.Status      = status;
    Irp->IoStatus.Information = bytesRead;

    DD((PCE)Pdx,DDT,"ParReadIrp - status = %x, bytesRead=%d\n", status, bytesRead);

    return;
}

NTSTATUS
ParReverseToForward(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine flips the bus from Reverse to Forward direction.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    // dvdr

    if (Pdx->Connected) {
        // Do a quick check to see if we are where we want to be.  
        // Happy punt if everything is ok.
        if( Pdx->CurrentPhase == PHASE_FORWARD_IDLE || Pdx->CurrentPhase == PHASE_FORWARD_XFER ) {

            DD((PCE)Pdx,DDT,"ParReverseToForward: Already in Fwd. Exit STATUS_SUCCESS\n");
            return Status;

        } else {

            if (afpForward[Pdx->IdxForwardProtocol].ProtocolFamily !=
                arpReverse[Pdx->IdxReverseProtocol].ProtocolFamily) {            

                //
                // Protocol Families don't match...need to terminate from the forward mode
                //
                if (arpReverse[Pdx->IdxReverseProtocol].fnDisconnect) {
                    arpReverse[Pdx->IdxReverseProtocol].fnDisconnect (Pdx);
                }

                if ((Pdx->ReverseInterfaceAddress != DEFAULT_ECP_CHANNEL) &&    
                    (arpReverse[Pdx->IdxReverseProtocol].fnSetInterfaceAddress)) {
                    Pdx->SetReverseAddress = TRUE;
                }

            } else if((Pdx->CurrentPhase == PHASE_REVERSE_IDLE) || (Pdx->CurrentPhase == PHASE_REVERSE_XFER)) {

                if ( (arpReverse[Pdx->IdxReverseProtocol].fnExitReverse) ) {
                    Status = arpReverse[Pdx->IdxReverseProtocol].fnExitReverse(Pdx);
                }

            } else {

                // We are in a screwy state.
                DD((PCE)Pdx,DDE,"ParReverseToForward: We're lost! Unknown state - Gonna start spewing!\n");
                Status = STATUS_IO_TIMEOUT;     // I picked a RetVal from thin air!
            }
        }
    }

    // Yes, we still want to check for connection since we might have
    //   terminated in the previous code block!
    if (!Pdx->Connected && afpForward[Pdx->IdxForwardProtocol].fnConnect) {

        Status = afpForward[Pdx->IdxForwardProtocol].fnConnect( Pdx, FALSE );
        //
        // Makes the assumption that the connected address is always 0
        //
        if ((NT_SUCCESS(Status)) && (Pdx->ForwardInterfaceAddress != DEFAULT_ECP_CHANNEL)) {
            Pdx->SetForwardAddress = TRUE;
        }    
    }

    //
    // Do we need to enter a forward mode?
    //
    if ( (NT_SUCCESS(Status)) && 
         (Pdx->CurrentPhase != PHASE_FORWARD_IDLE) &&
         (Pdx->CurrentPhase != PHASE_FORWARD_XFER) &&
         (afpForward[Pdx->IdxForwardProtocol].fnEnterForward) ) {
        
        Status = afpForward[Pdx->IdxForwardProtocol].fnEnterForward(Pdx);
    }

    DD((PCE)Pdx,DDT,"ParReverseToForward - exit w/status= %x\n", Status);

    return Status;
}

NTSTATUS
ParSetFwdAddress(
    IN  PPDO_EXTENSION   Pdx
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;

    DD((PCE)Pdx,DDT,"ParSetFwdAddress: Start: Channel [%x]\n", Pdx->ForwardInterfaceAddress);
    if (afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress) {
        Status = ParReverseToForward(Pdx);
        if (!NT_SUCCESS(Status)) {
            DD((PCE)Pdx,DDE,"ParSetFwdAddress: FAIL. Couldn't flip the bus for Set ECP/EPP Channel failed.\n");
            goto ParSetFwdAddress_ExitLabel;
        }
        Status  = afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress (
                                                                    Pdx,
                                                                    Pdx->ForwardInterfaceAddress);
        if (NT_SUCCESS(Status)) {
            Pdx->SetForwardAddress = FALSE;
        } else {
            DD((PCE)Pdx,DDE,"ParSetFwdAddress: FAIL. Set ECP/EPP Channel failed.\n");
            goto ParSetFwdAddress_ExitLabel;
        }
    } else {
        DD((PCE)Pdx,DDE,"ParSetFwdAddress: FAIL. Protocol doesn't support SetECP/EPP Channel\n");
        Status = STATUS_UNSUCCESSFUL;
        goto ParSetFwdAddress_ExitLabel;
    }

ParSetFwdAddress_ExitLabel:
    return Status;
}

VOID
ParTerminate(
    IN  PPDO_EXTENSION   Pdx
    )
{
    if (!Pdx->Connected) {
        return;
    }

    if (Pdx->CurrentPhase == PHASE_REVERSE_IDLE || Pdx->CurrentPhase == PHASE_REVERSE_XFER) {

        if (afpForward[Pdx->IdxForwardProtocol].ProtocolFamily !=
            arpReverse[Pdx->IdxReverseProtocol].ProtocolFamily) {

            if (arpReverse[Pdx->IdxReverseProtocol].fnDisconnect) {
                DD((PCE)Pdx,DDT,"ParTerminate: Calling arpReverse.fnDisconnect\r\n");
                arpReverse[Pdx->IdxReverseProtocol].fnDisconnect (Pdx);
            }

            return;
        }
        ParReverseToForward(Pdx);
    }

    if (afpForward[Pdx->IdxForwardProtocol].fnDisconnect) {
        DD((PCE)Pdx,DDT,"ParTerminate: Calling afpForward.fnDisconnect\r\n");
        afpForward[Pdx->IdxForwardProtocol].fnDisconnect (Pdx);
    }
}

NTSTATUS
ParWrite(
    IN PPDO_EXTENSION    Pdx,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;

    //
    // The routine which performs the write varies depending upon the currently
    // negotiated mode.  Start I/O moves the IRP into the Pdx (CurrentOpIrp)
    //
    // Default mode: Centronics
    //

    // Go ahead and flip the bus if need be.  The proc will just make sure we're properly
    // connected and pointing in the right direction.
    Status = ParReverseToForward( Pdx );

    // only do this if we are in safe mode
    if ( Pdx->ModeSafety == SAFE_MODE ) {

        //
        // Set the channel address if we need to.
        //
        if (NT_SUCCESS(Status) && Pdx->SetForwardAddress &&    
            (afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress))
        {
            Status  = afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress (
                                                                    Pdx,
                                                                    Pdx->ForwardInterfaceAddress);
            if (NT_SUCCESS(Status))
                Pdx->SetForwardAddress = FALSE;
            else
                Pdx->SetForwardAddress = TRUE;
        }
    }

    if (NT_SUCCESS(Status)) {

        if (Pdx->fnWrite || afpForward[Pdx->IdxForwardProtocol].fnWrite) {
            *NumBytesWritten = 0;

            #if DVRH_SHOW_BYTE_LOG
            {
                ULONG i=0;
                DD((PCE)Pdx,DDT,"Parallel:Write: ");
                for (i=0; i<NumBytesToWrite; ++i) { 
                    DD((PCE)Pdx,DDT," %02x",*((PUCHAR)Buffer+i));
                }
                DD((PCE)Pdx,DDT,"\n");
            }
            #endif
            
            if( Pdx->fnWrite) {
                Status = ((PPROTOCOL_WRITE_ROUTINE)Pdx->fnWrite)(Pdx,
                                                                       Buffer,
                                                                       NumBytesToWrite,
                                                                       NumBytesWritten);
            } else {
                Status = afpForward[Pdx->IdxForwardProtocol].fnWrite(Pdx,
                                                                           Buffer,
                                                                           NumBytesToWrite,
                                                                           NumBytesWritten);
            }
        }
    }
    return Status;
}


VOID
ParWriteIrp(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine implements a WRITE request with the extension's current irp.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    ULONG               NumBytesWritten = 0;

    Irp    = Pdx->CurrentOpIrp;
    IrpSp  = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = ParWrite(Pdx,
                                    Irp->AssociatedIrp.SystemBuffer,
                                    IrpSp->Parameters.Write.Length,
                                    &NumBytesWritten);

    Irp->IoStatus.Information = NumBytesWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\pnputils.c ===
#include "pch.h"

VOID
P5WorkItemFreePort( PDEVICE_OBJECT Fdo, PFDO_EXTENSION Fdx ) {
    PIO_WORKITEM workItem;

    UNREFERENCED_PARAMETER( Fdo );

    workItem = InterlockedExchangePointer( &Fdx->FreePortWorkItem, NULL );
    if( workItem ) {
        IoFreeWorkItem( workItem );
    }
    
    PptFreePort( Fdx );
}

BOOLEAN
P5SelectDaisyChainDevice(
    IN  PUCHAR  Controller,
    IN  UCHAR   DeviceId
    )
{
    const ULONG  maxRetries = 4;
    ULONG        retryCount = 0;
    BOOLEAN      selected   = FALSE;
    DD(NULL,DDE,"P5SelectDaisyChainDevice %x %d\n",Controller,DeviceId);
    while( !selected && retryCount < maxRetries ) {
        selected = PptSend1284_3Command( Controller, (UCHAR)(CPP_SELECT | DeviceId) );
        ++retryCount;
    }
    return selected;
}

BOOLEAN
P5DeselectAllDaisyChainDevices(
    IN  PUCHAR  Controller
    )
{
    const ULONG  maxRetries = 4;
    ULONG        retryCount = 0;
    BOOLEAN      deselected = FALSE;
    DD(NULL,DDE,"P5DeselectAllDaisyChainDevices %x\n",Controller);
    while( !deselected && retryCount < maxRetries ) {
        deselected = PptSend1284_3Command( Controller, (UCHAR)CPP_DESELECT );
        ++retryCount;
    }
    return deselected;
}

VOID
P5DeletePdoSymLink(
    IN  PDEVICE_OBJECT  Pdo
    )
//
// clean up symbolic link so we can reuse it immediately for a new PDO
//
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    if( pdx->SymLinkName ) {
        UNICODE_STRING  uniSymLinkName;
        NTSTATUS        status;

        DD((PCE)pdx,DDE,"P5DeletePdoSymLink\n");

        RtlInitUnicodeString( &uniSymLinkName, pdx->SymLinkName );
        status = IoDeleteSymbolicLink( &uniSymLinkName );
        PptAssert( STATUS_SUCCESS == status );
        ExFreePool( pdx->SymLinkName );
        pdx->SymLinkName = NULL;
    }

    return;
}

VOID
P5MarkPdoAsHardwareGone(
    IN  PDEVICE_OBJECT  Fdo,
    IN  enum _PdoType   PdoType,
    IN  ULONG           DaisyChainId  OPTIONAL // ignored if PdoType != PdoTypeDaisyChain
    )
{
    PFDO_EXTENSION  fdx = Fdo->DeviceExtension;
    PPDO_EXTENSION  pdx;
    PDEVICE_OBJECT  pdo;

    switch( PdoType ) {

    case PdoTypeRawPort:

        DD((PCE)fdx,DDE,"P5MarkPdoAsHardwareGone - PdoTypeRawPort\n");
        pdo = fdx->RawPortPdo;
        fdx->RawPortPdo = NULL;
        break;

    case PdoTypeEndOfChain:

        DD((PCE)fdx,DDE,"P5MarkPdoAsHardwareGone - PdoTypeEndOfChain\n");
        pdo = fdx->EndOfChainPdo;
        fdx->EndOfChainPdo = NULL;
        break;

    case PdoTypeDaisyChain:

        PptAssert( (0 == DaisyChainId) || (1 == DaisyChainId) );
        DD((PCE)fdx,DDE,"P5MarkPdoAsHardwareGone - PdoTypeDaisyChain - %d\n",DaisyChainId);
        pdo = fdx->DaisyChainPdo[ DaisyChainId ];
        fdx->DaisyChainPdo[ DaisyChainId ] = NULL;
        break;

    case PdoTypeLegacyZip:

        DD((PCE)fdx,DDE,"P5MarkPdoAsHardwareGone - PdoTypeLegacyZip\n");
        pdo = fdx->LegacyZipPdo;
        fdx->LegacyZipPdo = NULL;
        break;

    default:

        DD((PCE)fdx,DDE,"P5MarkPdoAsHardwareGone - Invalid PdoType parameter\n",FALSE);
        PptAssertMsg("P5MarkPdoAsHardwareGone - Invalid PdoType parameter",FALSE);
        return;

    }

    pdx = pdo->DeviceExtension;
    P5DeletePdoSymLink( pdo );
    InsertTailList( &fdx->DevDeletionListHead, &pdx->DevDeletionList );
    pdx->DeleteOnRemoveOk = TRUE;

    return;
}

BOOLEAN
P5IsDeviceStillThere( 
    IN  PDEVICE_OBJECT  Fdo,
    IN  PDEVICE_OBJECT  Pdo
    )
//
// Is the Pdo device still connected to the port represented by the Fdo?
//
// N.B. Fdo must own (have locked for exclusive access) the port before calling this function
//   or we can corrupt the data stream and hang devices connected to the port
//
{
    PFDO_EXTENSION  fdx              = Fdo->DeviceExtension;
    PPDO_EXTENSION  pdx              = Pdo->DeviceExtension;
    BOOLEAN         deviceStillThere = FALSE;
    PCHAR           devIdString      = NULL;
    PUCHAR          controller       = fdx->PortInfo.Controller;
        
    PptAssert( DevTypeFdo == fdx->DevType );
    PptAssert( DevTypePdo == pdx->DevType );

    //
    // Select device if needed, pull a fresh 1284 device ID string
    // from the device, and compare the Mfg and Mdl from the fresh
    // device ID with those stored in our extension. If the Mfg and
    // Mdl fields match then the device is still there.
    //

    switch( pdx->PdoType ) {

    case PdoTypeRawPort:
        
        // raw port is always present - it's a virtual device
        DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeRawPort - StillThere\n");
        deviceStillThere = TRUE;
        break;
        
    case PdoTypeLegacyZip:
        
        deviceStillThere = P5LegacyZipDetected( fdx->PortInfo.Controller );
        if( deviceStillThere ) {
            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeLegacyZip - StillThere\n");
        } else {
            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeLegacyZip - Gone\n");
        }
        break;
    
    case PdoTypeDaisyChain:
            
        //
        // Select device, pull a fresh 1284 device ID string
        // from the device, and compare the Mfg and Mdl from the fresh
        // device ID with those stored in our extension. If the Mfg and
        // Mdl fields match then the device is still there.
        //

        {
            UCHAR daisyChainId = pdx->Ieee1284_3DeviceId;

            // select device
            if( P5SelectDaisyChainDevice( controller, daisyChainId ) ) {

                BOOLEAN         bBuildStlDeviceId = FALSE;
                PPDO_EXTENSION  dummyPdx          = NULL;

                devIdString = NULL;

                // do a check to see if this is an SCM Micro device
                dummyPdx = ExAllocatePool( PagedPool, sizeof(PDO_EXTENSION) );
                if( dummyPdx != NULL ) {
                    RtlZeroMemory( dummyPdx, sizeof(PDO_EXTENSION) );
                    dummyPdx->Controller = fdx->PortInfo.Controller;
                    bBuildStlDeviceId = ParStlCheckIfStl( dummyPdx, daisyChainId );

                    if( bBuildStlDeviceId ) {
                        // SCM Micro device
                        ULONG DeviceIdSize;
                        devIdString = ParStlQueryStlDeviceId( dummyPdx, NULL, 0,&DeviceIdSize, TRUE );
                    } else {
                        // non-SCM Micro device
                        devIdString = P4ReadRawIeee1284DeviceId( controller );
                    }
                    ExFreePool( dummyPdx );
                }

                if( devIdString ) {
                    // got a 1284 device ID string from the device
                    PCHAR mfg, mdl, cls, des, aid, cid;
                    ParPnpFindDeviceIdKeys( &mfg, &mdl, &cls, &des, &aid, &cid, devIdString+2 );
                    if( mfg && mdl ) {
                        // we have a device, is it the same device?
                        if( (0 == strcmp( mfg, pdx->Mfg )) && (0 == strcmp( mdl, pdx->Mdl )) ) {
                            // same device
                            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeDaisyChain %d - StillThere\n",daisyChainId);
                            deviceStillThere = TRUE;
                        } else {
                            // different device - IDs don't match
                            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeDaisyChain %d - Gone - diff 1284 ID\n",daisyChainId);
                            deviceStillThere = FALSE;
                        }
                    } else {
                        // either mfg or mdl field not found
                        DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeDaisyChain %d - Gone - bad 1284 ID\n",daisyChainId);
                        deviceStillThere = FALSE;
                    }
                    // don't forget to free temp pool
                    ExFreePool( devIdString );
                    
                } else {
                    // unable to get a 1284 device ID string from the device
                    DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeDaisyChain %d - Gone - no 1284 ID\n",daisyChainId);
                    deviceStillThere = FALSE;
                }
                // don't forget to deselect device
                P5DeselectAllDaisyChainDevices( controller );
                
            } else {
                // unable to select device
                DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeDaisyChain %d - Gone - unable to select\n",daisyChainId);
                deviceStillThere = FALSE;
            }
        } // end new scope for case PdoTypeDaisyChain
        break;
            
    case PdoTypeEndOfChain:
        
        //
        // Pull a fresh 1284 device ID string from the device, and
        // compare the Mfg and Mdl from the fresh device ID with
        // those stored in our extension. If the Mfg and Mdl
        // fields match then the device is still there.
        //
        {
            ULONG        tryNumber = 0;
            const ULONG  maxTries  = 5; // arbitrary number

            do {

                ++tryNumber;

                devIdString = P4ReadRawIeee1284DeviceId( controller );            

                if( devIdString ) {
                    PCHAR mfg, mdl, cls, des, aid, cid;
                    ParPnpFindDeviceIdKeys( &mfg, &mdl, &cls, &des, &aid, &cid, devIdString+2 );
                    if( mfg && mdl ) {
                        // we have a device, is it the same device?
                        if( (0 == strcmp( mfg, pdx->Mfg )) && (0 == strcmp( mdl, pdx->Mdl )) ) {
                            // same device
                            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeEndOfChain - StillThere\n");
                            deviceStillThere = TRUE;
                        } else {
                            // different device - IDs don't match
                            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeEndOfChain - Gone - diff 1284 ID\n");
                            deviceStillThere = FALSE;
                        }
                    } else {
                        // either mfg or mdl field not found
                        DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeEndOfChain - Gone - bad 1284 ID\n");
                        deviceStillThere = FALSE;
                    }
                    // don't forget to free temp pool
                    ExFreePool( devIdString );
                } else {
                    // unable to get a 1284 device ID string from the device
                    DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeEndOfChain - Gone - no 1284 ID\n");
                    deviceStillThere = FALSE;
                }

                if( (FALSE == deviceStillThere ) && (PASSIVE_LEVEL == KeGetCurrentIrql()) ) {
                    LARGE_INTEGER delay;
                    delay.QuadPart = - 10 * 1000 * 120; // 120 ms - 3x the usual arbitrary delay 
                    KeDelayExecutionThread( KernelMode, FALSE, &delay);
                }

            } while( (FALSE == deviceStillThere) && (tryNumber < maxTries) );

        }
        break;
        
    default:
        
        PptAssertMsg("P5IsDeviceStillThere - invalid PdoType",FALSE);
        DD((PCE)Fdo,DDE,"P5IsDeviceStillThere - invalid PdoType\n");
        deviceStillThere = TRUE; // don't know what to do here - so, guess
    }
    
    return deviceStillThere;
}


NTSTATUS
PptAcquirePortViaIoctl(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
/*++dvdf

Routine Description:

    This routine acquires the specified parallel port from the parallel 
      port arbiter ParPort via an IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE.

Arguments:

    PortDeviceObject - points to the ParPort device to be acquired

Return Value:

    STATUS_SUCCESS  - if the port was successfully acquired
    !STATUS_SUCCESS - otherwise

--*/
{
    LARGE_INTEGER    localTimeout;
    
    if( Timeout ) {
        localTimeout = *Timeout;           // caller specified
    } else {
        localTimeout = AcquirePortTimeout; // driver global variable default
    }

    return ParBuildSendInternalIoctl(IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE, 
                                     PortDeviceObject, NULL, 0, NULL, 0, &localTimeout);
}


NTSTATUS
PptReleasePortViaIoctl(
    IN PDEVICE_OBJECT PortDeviceObject
    )
/*++dvdf

Routine Description:

    This routine releases the specified parallel port back to the the parallel 
      port arbiter ParPort via an IOCTL_INTERNAL_PARALLEL_PORT_FREE.

Arguments:

    PortDeviceObject - points to the ParPort device to be released

Return Value:

    STATUS_SUCCESS  - if the port was successfully released
    !STATUS_SUCCESS - otherwise

--*/
{
    return ParBuildSendInternalIoctl(IOCTL_INTERNAL_PARALLEL_PORT_FREE, 
                                     PortDeviceObject, NULL, 0, NULL, 0, NULL);
}


VOID
PptWriteMfgMdlToDevNode(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PCHAR           Mfg,
    IN  PCHAR           Mdl
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    if( Mfg && Mdl ) {
    
        NTSTATUS  status;
        HANDLE    handle;
        LONG      mfgLen = strlen( Mfg );
        LONG      mdlLen = strlen( Mdl );
        LONG      maxLen = mfgLen > mdlLen ? mfgLen : mdlLen;
        LONG      bufLen = ( maxLen + sizeof(CHAR) ) * sizeof(WCHAR);
        PWSTR     buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );

        if( buffer ) {

            status = IoOpenDeviceRegistryKey( Pdo, PLUGPLAY_REGKEY_DEVICE, KEY_ALL_ACCESS, &handle );
            
            if( STATUS_SUCCESS == status ) {
                UNICODE_STRING  uniValueName;
                LONG            wcharCount;
                
                //
                // Write MFG to DevNode
                //
                RtlInitUnicodeString( &uniValueName, L"IEEE_1284_Manufacturer" );
                wcharCount = _snwprintf( buffer, bufLen/sizeof(WCHAR), L"%S", Mfg );
                if( (wcharCount > 0) && (wcharCount < (LONG)(bufLen/sizeof(WCHAR))) ){
                    // no buffer overflow - continue
                    status = ZwSetValueKey( handle, &uniValueName, 0, REG_SZ, buffer, (wcharCount+1)*sizeof(WCHAR) );
                    PptAssert( STATUS_SUCCESS == status );
                } else {
                    // buffer overflow - skip writing this value to devnode
                    PptAssert(!"PptWriteMfgMdlToDevNode - buffer overflow on Mfg");
                    DD((PCE)pdx,DDW,"PptWriteMfgMdlToDevNode - buffer overflow on Mfg\n");
                }
                
                //
                // Write MDL to DevNode
                //
                RtlInitUnicodeString( &uniValueName, L"IEEE_1284_Model" );
                wcharCount = _snwprintf( buffer, bufLen/sizeof(WCHAR), L"%S", Mdl );
                if( (wcharCount > 0) && (wcharCount < (LONG)(bufLen/sizeof(WCHAR))) ){
                    // no buffer overflow - continue
                    status = ZwSetValueKey( handle, &uniValueName, 0, REG_SZ, buffer, (wcharCount+1)*sizeof(WCHAR) );
                    PptAssert( STATUS_SUCCESS == status );
                } else {
                    // buffer overflow - skip writing this value to devnode
                    PptAssert(!"PptWriteMfgMdlToDevNode - buffer overflow on Mdl");
                    DD((PCE)pdx,DDW,"PptWriteMfgMdlToDevNode - buffer overflow on Mdl\n");
                }
                
                ZwClose( handle );

            } else {
                DD((PCE)pdx,DDW,"PptWriteMfgMdlToDevNode - IoOpenDeviceRegistryKey FAILED - status = %x\n",status);
            }

            ExFreePool( buffer );

        } // end if( buffer )            

    } else {
        PptAssert(!"PptWriteMfgMdlToDevNode - Mfg or Mdl is NULL - calling function should catch this!");
        DD((PCE)pdx,DDW,"PptWriteMfgMdlToDevNode - Mfg or Mdl is NULL - calling function should catch this!");
    }
}


NTSTATUS
PptFdoHandleBusRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
{
    PFDO_EXTENSION     fdx         = Fdo->DeviceExtension;
    ULONG              deviceCount = 0;
    ULONG              daisyChainDevCount;
    PDEVICE_RELATIONS  devRel;
    ULONG              devRelSize;
    NTSTATUS           status;
    LARGE_INTEGER      acquirePortTimeout;
    BOOLEAN            acquiredPort;
    PUCHAR             controller  = fdx->PortInfo.Controller;
    BOOLEAN            changeDetected;

    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - enter\n");

    //
    // acquire exclusive access to bus
    //

    // timeout is in 100 ns units
    acquirePortTimeout.QuadPart = -(10 * 1000 * 1000 * 2); // 2 seconds
    
    // RMT - is it valid to send this IOCTL to FDO from here?
    status = PptAcquirePortViaIoctl( Fdo, &acquirePortTimeout );

    if( STATUS_SUCCESS == status ) {
        // we have the port
        acquiredPort = TRUE;
    } else {
        // failed to aquire port
        acquiredPort = FALSE;
        // skip rescanning port - just report same thing we reported during previous scan
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - failed to acquire port for rescan\n");
        goto target_failed_to_acquire_port;
    }

    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - Port Acquired\n");

    //
    // Rescan the bus, note changes, create new PDOs or mark existing
    //   PDOs for removal as required
    //


    //
    // Handle Raw Port Legacy Interface LPTx device
    //
    if( !fdx->RawPortPdo ) {
        // first time through this - create our LPTx legacy interface PDO
        DD((PCE)fdx,DDT,"PptFdoHandleBusRelations - attempting to create RawPortPdo\n");
        fdx->RawPortPdo = P4CreatePdo( Fdo, PdoTypeRawPort, 0, NULL );
    }


    //
    // Handle End of Chain Device
    //

    // make sure all 1284.3 daisy chain devices are deselected
    P5DeselectAllDaisyChainDevices( controller );

    {
        // A small delay here seems to improve reliablility of 1284 device ID queries below.
        LARGE_INTEGER delay;
        delay.QuadPart = -1;
        KeDelayExecutionThread( KernelMode, FALSE, &delay );
    }

    if( fdx->EndOfChainPdo ) {

        if( fdx->DisableEndOfChainBusRescan ) {

            //
            // Pretend that the LPTx.4 device from previous rescan is still present.
            // 
            // This is needed to work around firmware state machines that can't handle a 
            // 1284 Device ID query while a print job is active.
            //

            ; // do nothing

        } else {

            //
            // we had an end of chain device - verify that it's still there
            //
            if( !P5IsDeviceStillThere( Fdo, fdx->EndOfChainPdo ) ) {
                // End of chain device is gone - do some cleanup and mark the PDO for removal/deletion
                DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - EndOfChain device gone\n");
                // note - P5MarkPdoAsHardwareGone sets fdx->EndOfChainPdo to NULL
                P5MarkPdoAsHardwareGone( Fdo, PdoTypeEndOfChain, 0 );
            }
        }
    }

    if( NULL == fdx->EndOfChainPdo ) {
        //
        // we don't have an EndOfChain device - check for EndOfChain device arrival
        //
        PCHAR devId = P4ReadRawIeee1284DeviceId( controller );
        if( devId ) {
            // RawIeee1284 string includes 2 bytes of length data at beginning, omit these 2 bytes in call to P4CreatePdo
            PDEVICE_OBJECT EndOfChainPdo = P4CreatePdo( Fdo, PdoTypeEndOfChain, 0, (devId+2) );
            DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - EndOfChain device detected <%s>\n",(devId+2));
            if( EndOfChainPdo ) {
                fdx->EndOfChainPdo = EndOfChainPdo;
                DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - created EndOfChainPdo\n");
            } else {
                DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - FAILED to create EndOfChainPdo\n");
            }
            ExFreePool( devId );
        }
    }


#ifdef _X86_ // Zip drives not supported on 64bit systems

    //
    // Handle Legacy Zip device
    //

    if( fdx->LegacyZipPdo ) {
        //
        // we had a Legacy Zip device - verify that it's still there
        //
        if( !P5IsDeviceStillThere( Fdo, fdx->LegacyZipPdo ) ) {
            // Legacy Zip device is gone - do some cleanup and mark the PDO for removal/deletion
            DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - LegacyZip device gone\n");
            // note - P5MarkPdoAsHardwareGone sets fdx->LegacyZipPdo to NULL
            P5MarkPdoAsHardwareGone( Fdo, PdoTypeLegacyZip, 0 );
        }
    }

    if( NULL == fdx->LegacyZipPdo ) {
        // 
        // We don't have a LegacyZip - check for arrival
        //
        if( !ParEnableLegacyZip ) {
            
            //
            // Enumeration of LegacyZip drives was disabled, check the
            //   registry to see if user has enabled LegacyZip detection
            // 
            
            // Check under \HKLM\SYSTEM\CCS\Services\Parport\Parameters
            PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"ParEnableLegacyZip", &ParEnableLegacyZip );
            
            if( !ParEnableLegacyZip ) {
                // Check under \HKLM\SYSTEM\CCS\Services\Parallel\Parameters (upgrade case - under Win2k flag was here)
                PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parallel\\Parameters", L"ParEnableLegacyZip", &ParEnableLegacyZip );
                
                if( ParEnableLegacyZip ) {
                    // we found the setting in the old location, save
                    //   setting in new Parport location so that we find the
                    //   flag on the first check in the future
                    PptRegSetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"ParEnableLegacyZip", &ParEnableLegacyZip );
                }
            }
        } 
        
        if( ParEnableLegacyZip ) {
            
            //
            // Enumeration of LegacyZip drives is enabled - check for a LegacyZip arrival
            //
            
            if( P5LegacyZipDetected( controller ) ) {
                // detected drive - create LegacyZip PDO
                PDEVICE_OBJECT legacyZipPdo = P4CreatePdo( Fdo, PdoTypeLegacyZip, 0, NULL );
                DD((PCE)fdx,DDE,"legacy Zip arrival detected\n");
                if( legacyZipPdo ) {
                    fdx->LegacyZipPdo = legacyZipPdo;
                    DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - created LegacyZipPdo\n");
                } else {
                    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - FAILED to create LegacyZipPdo\n");
                }
            } else {
                // no legacy Zip detected - nothing more to do here
                DD((PCE)fdx,DDE,"no legacy Zip detected\n");
            }

        } // if( ParEnableLegacyZip ) -- Detection of LegacyZips is enabled

    } // if( fdx->LegacyZipPdo )


    //
    // Handle enumeration of IEEE 1284.3 Daisy Chain Devices
    //

    // did the 1284.3 daisy chain change since the last rescan?
    daisyChainDevCount = PptInitiate1284_3( fdx );
    DD((PCE)fdx,DDW,"daisyChainDevCount = %d\n",daisyChainDevCount);

    changeDetected = FALSE;

    {
        ULONG id;
        const ULONG maxId = 1;
        ULONG count = 0;
        for( id = 0 ; id <= maxId ; ++id ) {
            if( fdx->DaisyChainPdo[id] ) {
                ++count;
            }
        }
        if( count != daisyChainDevCount ) {
            // number of devices changed from previous scan
            DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - number of DC devices changed - count=%d, daisyChainDevCount=%d\n",
               count, daisyChainDevCount);
            changeDetected = TRUE;
        }
    }
    
    if( !changeDetected ) {
        // number of devices stayed the same - are any of the devices different?
        //
        // number of daisy chain devices didn't change
        // check if any of the devices changed
        ULONG id;
        const ULONG maxId = 1;
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - number of DC devices stayed same - check the devices\n");
        for( id = 0 ; id <= maxId ; ++id ) {
            if( fdx->DaisyChainPdo[id] && !P5IsDeviceStillThere( Fdo, fdx->DaisyChainPdo[id] ) ) {
                DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - a DC device changed\n");
                changeDetected = TRUE;
                break;
            }
        }
    }


    if( changeDetected ) {
        // we detected a change in the 1284.3 daisy chain devices - nuke all existing devices
        ULONG id;
        const ULONG maxId = 1;
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - changeDetected - nuking existing daisy chain PDOs\n");
        for( id = 0 ; id <= maxId ; ++id ) {
            if( fdx->DaisyChainPdo[id] ) {
                DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - nuking daisy chain %d\n",id);
                P5MarkPdoAsHardwareGone( Fdo, PdoTypeDaisyChain, id );
                PptAssert( NULL == fdx->DaisyChainPdo[id] );
            }
        }
        fdx->PnpInfo.Ieee1284_3DeviceCount = 0;
    } else {
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - !changeDetected in daisy chain PDOs\n");
    }

    // reinit daisy chain and assign addresses
    daisyChainDevCount = PptInitiate1284_3( fdx );
    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - daisyChainDevCount = %d\n",daisyChainDevCount);
    if( daisyChainDevCount > 2 ) {
        // we only support 2 devices per port even though the spec supports up to 4 devices per port
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - DaisyChainDevCount > 2, set to 2\n");
        daisyChainDevCount = 2;
    }

    if( changeDetected ) {
        // we detected a change in the 1284.3 daisy chain devices - we
        // previously nuked all old devices - now create a new PDO for
        // each device detected
        UCHAR id;
        PptAssert( 0 == fdx->PnpInfo.Ieee1284_3DeviceCount );
        for( id = 0 ; id < daisyChainDevCount ; ++id ) {

            BOOLEAN         bBuildStlDeviceId = FALSE;
            PPDO_EXTENSION  pdx               = NULL;


            DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - changeDetected - trying to create new daisy chain PDOs\n");

            if( P5SelectDaisyChainDevice( controller, id ) ) {

                PCHAR devId = NULL;

                // do a check to see if this is an SCM Micro device
                pdx = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, sizeof(PDO_EXTENSION) );
                if( pdx != NULL ) {
                    RtlZeroMemory( pdx, sizeof(PDO_EXTENSION) );
                    pdx->Controller   = fdx->PortInfo.Controller;
                    bBuildStlDeviceId = ParStlCheckIfStl( pdx, id );
                    ExFreePool( pdx );
                }


                if( bBuildStlDeviceId ) {
                    
                    // SCM Micro device
                    pdx = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, sizeof(PDO_EXTENSION) );
                    if( pdx != NULL ) {
                        ULONG DeviceIdSize;
                        RtlZeroMemory( pdx, sizeof(PDO_EXTENSION) );
                        pdx->Controller = fdx->PortInfo.Controller;
                        devId = ParStlQueryStlDeviceId(pdx, NULL, 0,&DeviceIdSize, TRUE);
                        ExFreePool (pdx);
                    }
                    
                } else {

                    // non-SCM Micro device
                    devId = P4ReadRawIeee1284DeviceId( controller );

                }

                if( devId ) {

                    // try to create a PDO for the daisy chain device
                    fdx->DaisyChainPdo[id] = P4CreatePdo( Fdo, PdoTypeDaisyChain, id, (devId+2) );

                    if( fdx->DaisyChainPdo[id] ) {
                        // have new PDO
                        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - new DaisyChainPdo[%d]\n",id);
                        ++(fdx->PnpInfo.Ieee1284_3DeviceCount);
                        
                        if( bBuildStlDeviceId ) {
                            // SCM Micro device - requires additional initialization
                            DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - new SCM Micro DaisyChainPdo[%d]\n",id);
                            pdx = fdx->DaisyChainPdo[id]->DeviceExtension;
                            pdx->Controller = fdx->PortInfo.Controller;
                            ParStlCheckIfStl( pdx, 0 ); // update IEEE 1284 flags in the new pdx
                        }

                    } else {
                        // create PDO failed
                        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - create DaisyChainPdo[%d] failed\n",id);
                    }
                    ExFreePool( devId );
                } else {
                    // devId failed
                    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - devId for DC %d failed\n",id);
                }
                P5DeselectAllDaisyChainDevices( controller );
            } else {
                // select failed
                DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - select for DC %d failed\n",id);
            }
        }
    }

    {
        ULONG i;
        ULONG count = 0;
        i = 0;
        for( i = 0 ; i < 2 ; ++i ) {
            if( fdx->DaisyChainPdo[i] ) {
                ++count;
            }
        }
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - Ieee1284_3DeviceCount=%d  count1 = %d\n",
           fdx->PnpInfo.Ieee1284_3DeviceCount,count);
        PptAssert( fdx->PnpInfo.Ieee1284_3DeviceCount == count );
    }

    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - daisyChainDevCount = %d, fdx->PnpInfo.Ieee1284_3DeviceCount = %d\n",
       daisyChainDevCount, fdx->PnpInfo.Ieee1284_3DeviceCount);

    // PptAssert( daisyChainDevCount == fdx->PnpInfo.Ieee1284_3DeviceCount );

#endif // _X86_

target_failed_to_acquire_port: // jump here if we couldn't get the port - result is that we report that nothing has changed

    //
    // Count the number of devices that we are going to report to PnP
    //   so that we can allocate a DEVICE_RELATIONS structure of the
    //   appropriate size.
    //

    if( fdx->RawPortPdo ) {
        ++deviceCount;
    }

    if( fdx->EndOfChainPdo ) {
        ++deviceCount;
    }

    if( fdx->LegacyZipPdo ) {
        ++deviceCount;
    }

    {
        const ULONG maxDaisyChainId = 1;
        ULONG i;
        for( i=0 ; i <= maxDaisyChainId; ++i ) {
            if( fdx->DaisyChainPdo[i] ) {
                ++deviceCount;
            } else {
                break;
            }
        }
    }

    if( deviceCount > 0 && fdx->RawPortPdo ) {

        //
        // Allocate and populate DEVICE_RELATIONS structure that we return to PnP
        //
        
        devRelSize = sizeof(DEVICE_RELATIONS) + (deviceCount-1)*sizeof(PDEVICE_OBJECT);
        devRel     = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, devRelSize );
        
        if( !devRel ) {
            // release port and fail IRP
            P4ReleaseBus( Fdo );
            return P4CompleteRequestReleaseRemLock( Irp, STATUS_INSUFFICIENT_RESOURCES, Irp->IoStatus.Information, &fdx->RemoveLock );
        }
        
        { // local block - begin
            ULONG idx = 0;
            
            RtlZeroMemory( devRel, devRelSize );
            
            ++(devRel->Count);
            ObReferenceObject( fdx->RawPortPdo );
            devRel->Objects[ idx++ ] = fdx->RawPortPdo;
            
            if( fdx->EndOfChainPdo ) {
                ++(devRel->Count);
                ObReferenceObject( fdx->EndOfChainPdo );
                devRel->Objects[ idx++ ] = fdx->EndOfChainPdo;
            }
            
            if( fdx->LegacyZipPdo ) {
                ++(devRel->Count);
                ObReferenceObject( fdx->LegacyZipPdo );
                devRel->Objects[ idx++ ] = fdx->LegacyZipPdo;
            }
            
            {
                const ULONG maxDaisyChainId = 3;
                ULONG       i;
                
                for( i=0 ; i <= maxDaisyChainId; ++i ) {
                    if( fdx->DaisyChainPdo[i] ) {
                        ++(devRel->Count);
                        ObReferenceObject( fdx->DaisyChainPdo[i] );
                        devRel->Objects[ idx++ ] = fdx->DaisyChainPdo[i];
                    } else {
                        break;
                    }
                }
            }
            
        } // local block - end
        
        PptAssert( deviceCount == devRel->Count ); // verify that our two counts match
        
        DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - reporting %d devices\n",devRel->Count);
        
        Irp->IoStatus.Status      = STATUS_SUCCESS;
        Irp->IoStatus.Information = (ULONG_PTR)devRel;
    } else {
        // deviceCount <= 0 - error somewhere - likely two ports
        //   have the same LPTx name in the FDO stack's devnode

        // RMT - this assert needs to be changed to ErrorLog msg 
        PptAssert(!"no RawPort device - likely multiple ports have same LPTx name - email: DFritz");
    }


    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - passing IRP down stack\n");

    status = PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );

    //
    // Release our lock on the bus and pass Irp down the stack
    //
    if( acquiredPort ) {
        PIO_WORKITEM workItem = IoAllocateWorkItem( Fdo );
        if( workItem ) {

            PIO_WORKITEM oldWorkItem = InterlockedCompareExchangePointer( &fdx->FreePortWorkItem, workItem, NULL );
            if( NULL == oldWorkItem ) {

                // no workitem currently in use, queue this one
                IoQueueWorkItem( workItem, P5WorkItemFreePort, DelayedWorkQueue, fdx );

            } else {

                // there is already a workitem in use, bail out and recover as best we can

                // We really shouldn't be able to get here - how in blazes did we
                // acquire the port at the top of this function if the workitem
                // that we queued to free the port during the previous invocation
                // of this function has not yet freed the port?

                PptAssertMsg( "workitem collision - port arbitration state may be hosed", (oldWorkItem != NULL) );
                IoFreeWorkItem( workItem );
                PptFreePort( fdx );

            }

        } else {
            PptFreePort( fdx );
        }
        // DbgPrint("xxx work item to free port has been queued\n");
        //DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - Releasing Port\n");
        //PptFreePort( fdx );
        //DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - Port Released\n");
    } else {
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - Port Not acquired so no need to release\n");
    }

    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - exit\n");

    return status;
}

NTSTATUS
PptPnpStartScanPciCardCmResourceList(
    IN  PFDO_EXTENSION Fdx,
    IN  PIRP              Irp, 
    OUT PBOOLEAN          FoundPort,
    OUT PBOOLEAN          FoundIrq,
    OUT PBOOLEAN          FoundDma
    )
/*++dvdf3

Routine Description:

    This routine is used to parse the resource list for what we
      believe are PCI parallel port cards.

    This function scans the CM_RESOURCE_LIST supplied with the Pnp 
      IRP_MN_START_DEVICE IRP, extracts the resources from the list, 
      and saves them in the device extension.

Arguments:

    Fdx    - The device extension of the target of the START IRP
    Irp          - The IRP
    FoundPort    - Did we find a  Port resource?
    FoundIrq     - Did we find an IRQ  resource?
    FoundDma     - Did we find a  DMA  resource?

Return Value:

    STATUS_SUCCESS                - if we were given a resource list,
    STATUS_INSUFFICIENT_RESOURCES - otherwise

--*/
{
    NTSTATUS                        status   = STATUS_SUCCESS;
    PIO_STACK_LOCATION              irpStack = IoGetCurrentIrpStackLocation( Irp );
    PCM_RESOURCE_LIST               ResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    FullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       PartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    ULONG                           i;
    ULONG                           length;
    
    *FoundPort = FALSE;
    *FoundIrq  = FALSE;
    *FoundDma  = FALSE;
    
    ResourceList = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
    
    FullResourceDescriptor = &ResourceList->List[0];
    
    if( FullResourceDescriptor ) {
        
        Fdx->InterfaceType = FullResourceDescriptor->InterfaceType;
        
        PartialResourceList = &FullResourceDescriptor->PartialResourceList;
        
        for (i = 0; i < PartialResourceList->Count; i++) {
            
            PartialResourceDescriptor = &PartialResourceList->PartialDescriptors[i];
            
            switch (PartialResourceDescriptor->Type) {
                
            case CmResourceTypePort:
                
                length = PartialResourceDescriptor->u.Port.Length;

                //
                // Use a heuristic based on length to guess which register set is
                //   SPP+EPP, which is ECP, and which is PCI Config or other.
                //
                switch( length ) {

                case 8: // SPP + EPP base address

                    Fdx->PortInfo.OriginalController = PartialResourceDescriptor->u.Port.Start;
                    Fdx->PortInfo.SpanOfController   = PartialResourceDescriptor->u.Port.Length;
                    Fdx->PortInfo.Controller         = (PUCHAR)(ULONG_PTR)Fdx->PortInfo.OriginalController.QuadPart;
                    Fdx->AddressSpace                = PartialResourceDescriptor->Flags;
                    *FoundPort = TRUE;
                    break;

                case 4: // ECP base address
                    
                    Fdx->PnpInfo.OriginalEcpController = PartialResourceDescriptor->u.Port.Start;
                    Fdx->PnpInfo.SpanOfEcpController   = PartialResourceDescriptor->u.Port.Length;
                    Fdx->PnpInfo.EcpController         = (PUCHAR)(ULONG_PTR)Fdx->PnpInfo.OriginalEcpController.QuadPart;
                    Fdx->EcpAddressSpace               = PartialResourceDescriptor->Flags;
                    break;

                default:
                    // don't know what this is - ignore it
                    ;
                }
                break;
                
            case CmResourceTypeBusNumber:
                
                Fdx->BusNumber = PartialResourceDescriptor->u.BusNumber.Start;
                break;
                
            case CmResourceTypeInterrupt:
                
                *FoundIrq = TRUE;
                Fdx->FoundInterrupt       = TRUE;
                Fdx->InterruptLevel       = (KIRQL)PartialResourceDescriptor->u.Interrupt.Level;
                Fdx->InterruptVector      = PartialResourceDescriptor->u.Interrupt.Vector;
                Fdx->InterruptAffinity    = PartialResourceDescriptor->u.Interrupt.Affinity;
                
                if (PartialResourceDescriptor->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                    
                    Fdx->InterruptMode = Latched;
                    
                } else {
                    
                    Fdx->InterruptMode = LevelSensitive;
                }
                break;
                
            case CmResourceTypeDma:
                
                // we don't do anything with DMA - fall through to default case
                
            default:

                break;

            } // end switch( PartialResourceDescriptor->Type )
        } // end for(... ; i < PartialResourceList->Count ; ...)
    } // end if( FullResourceDescriptor )
    
    return status;
}

BOOLEAN PptIsPci(
    PFDO_EXTENSION Fdx, 
    PIRP              Irp 
)
/*++

Does this look like a PCI card? Return TRUE if yes, FALSE otherwise

--*/
{
    PIO_STACK_LOCATION              irpStack = IoGetCurrentIrpStackLocation( Irp );
    PCM_RESOURCE_LIST               ResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    FullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       PartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    ULONG                           i;
    ULONG                           portResourceDescriptorCount = 0;
    BOOLEAN                         largePortRangeFound         = FALSE;
    ULONG                           rangeLength;
    
    //
    // If there are more than 2 IO resource descriptors, or if any IO resource
    //   descriptor has a range > 8 bytes, then assume that this is a PCI device
    //   and requires non-traditional handling.
    //

    ResourceList = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
    
    if (ResourceList == NULL) {
        // we weren't given any resources
        return FALSE;
    }

    FullResourceDescriptor = &ResourceList->List[0];
    
    if (FullResourceDescriptor) {
        
        PartialResourceList = &FullResourceDescriptor->PartialResourceList;
        
        for (i = 0; i < PartialResourceList->Count; i++) {
            
            PartialResourceDescriptor = &PartialResourceList->PartialDescriptors[i];
            
            switch (PartialResourceDescriptor->Type) {
                
            case CmResourceTypePort:
                
                rangeLength = PartialResourceDescriptor->u.Port.Length;
                DD((PCE)Fdx,DDT,"pnp::PptIsPCI - CmResourceTypePort - Start= %I64x, Length= %x , \n",
                                       PartialResourceDescriptor->u.Port.Start.QuadPart, rangeLength);

                ++portResourceDescriptorCount;

                if( rangeLength > 8 ) {
                    largePortRangeFound = TRUE;
                }
                break;
                
            default:
                ;
            } // end switch( PartialResourceDescriptor->Type )
        } // end for(... ; i < PartialResourceList->Count ; ...)
    } // end if( FullResourceDescriptor )
    
    if( (portResourceDescriptorCount > 2) || (TRUE == largePortRangeFound) ) {
        // looks like PCI
        return TRUE;
    } else {
        // does not look like PCI
        return FALSE;
    }
}

NTSTATUS
PptPnpStartScanCmResourceList(
    IN  PFDO_EXTENSION Fdx,
    IN  PIRP              Irp, 
    OUT PBOOLEAN          FoundPort,
    OUT PBOOLEAN          FoundIrq,
    OUT PBOOLEAN          FoundDma
    )
/*++dvdf3

Routine Description:

    This function is a helper function called by PptPnpStartDevice(). 

    This function scans the CM_RESOURCE_LIST supplied with the Pnp 
      IRP_MN_START_DEVICE IRP, extracts the resources from the list, 
      and saves them in the device Fdx.

Arguments:

    Fdx    - The device extension of the target of the START IRP
    Irp          - The IRP
    FoundPort    - Did we find a  Port resource?
    FoundIrq     - Did we find an IRQ  resource?
    FoundDma     - Did we find a  DMA  resource?

Return Value:

    STATUS_SUCCESS                - if we were given a resource list,
    STATUS_INSUFFICIENT_RESOURCES - otherwise

--*/
{
    NTSTATUS                        status   = STATUS_SUCCESS;
    PIO_STACK_LOCATION              irpStack = IoGetCurrentIrpStackLocation( Irp );
    PCM_RESOURCE_LIST               ResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    FullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       PartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    ULONG                           i;
    PHYSICAL_ADDRESS                start;
    ULONG                           length;
    BOOLEAN                         isPci = FALSE;
    
    *FoundPort = FALSE;
    *FoundIrq  = FALSE;
    *FoundDma  = FALSE;
    
    ResourceList = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
    
    if (ResourceList == NULL) {
        // we weren't given any resources, bail out
        DD((PCE)Fdx,DDT,"START - FAIL - No Resources - AllocatedResourcesTranslated == NULL\n");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetExit;
    }

    if( TRUE == PptIsPci( Fdx, Irp ) ) {
        // This appears to be a PCI card
        status = PptPnpStartScanPciCardCmResourceList(Fdx, Irp, FoundPort, FoundIrq, FoundDma);
        isPci=TRUE;
        goto targetExit;
    }
    
    //
    // Device appears to be traditional / non-PCI card parallel port
    //

    FullResourceDescriptor = &ResourceList->List[0];
    
    if (FullResourceDescriptor) {
        
        Fdx->InterfaceType = FullResourceDescriptor->InterfaceType;
        
        PartialResourceList = &FullResourceDescriptor->PartialResourceList;
        
        for (i = 0; i < PartialResourceList->Count; i++) {
            
            PartialResourceDescriptor = &PartialResourceList->PartialDescriptors[i];
            
            switch (PartialResourceDescriptor->Type) {
                
            case CmResourceTypePort:
                
                start  = PartialResourceDescriptor->u.Port.Start;
                length = PartialResourceDescriptor->u.Port.Length;
                DD((PCE)Fdx,DDT,"pnp::PptPnpStartScanCmResourceList - start= %I64x , length=%x\n",start, length);

                *FoundPort = TRUE;
                if ((Fdx->PortInfo.OriginalController.LowPart == 0) &&
                    (Fdx->PortInfo.OriginalController.HighPart == 0)) {
                    
                    DD((PCE)Fdx,DDT,"pnp::PptPnpStartScanCmResourceList - assuming Controller\n");

                    Fdx->PortInfo.OriginalController = PartialResourceDescriptor->u.Port.Start;
                    Fdx->PortInfo.SpanOfController   = PartialResourceDescriptor->u.Port.Length;
                    Fdx->PortInfo.Controller         = (PUCHAR)(ULONG_PTR)Fdx->PortInfo.OriginalController.QuadPart;
                    Fdx->AddressSpace                = PartialResourceDescriptor->Flags;
                    
                } else if ((Fdx->PnpInfo.OriginalEcpController.LowPart == 0) &&
                           (Fdx->PnpInfo.OriginalEcpController.HighPart == 0) &&
                           (IsNotNEC_98)) {
                    
                    if ((PartialResourceDescriptor->u.Port.Start.LowPart < Fdx->PortInfo.OriginalController.LowPart) &&
                        (PartialResourceDescriptor->u.Port.Start.HighPart < Fdx->PortInfo.OriginalController.HighPart)) {
                        
                        //
                        // Swapping address spaces
                        //
                        
                        DD((PCE)Fdx,DDT,"pnp::PptPnpStartScanCmResourceList - assuming Controller - Swapping Controller/EcpController\n");

                        Fdx->PnpInfo.OriginalEcpController = Fdx->PortInfo.OriginalController;
                        Fdx->PnpInfo.SpanOfEcpController   = Fdx->PortInfo.SpanOfController;
                        Fdx->PnpInfo.EcpController         = Fdx->PortInfo.Controller;
                        Fdx->EcpAddressSpace               = Fdx->AddressSpace;
                        
                        Fdx->PortInfo.OriginalController = PartialResourceDescriptor->u.Port.Start;
                        Fdx->PortInfo.SpanOfController   = PartialResourceDescriptor->u.Port.Length;
                        Fdx->PortInfo.Controller         = (PUCHAR)(ULONG_PTR)Fdx->PortInfo.OriginalController.QuadPart;
                        Fdx->AddressSpace                = PartialResourceDescriptor->Flags;
                        
                    } else {
                        DD((PCE)Fdx,DDT,"pnp::PptPnpStartScanCmResourceList - assuming EcpController\n");

                        Fdx->PnpInfo.OriginalEcpController = PartialResourceDescriptor->u.Port.Start;
                        Fdx->PnpInfo.SpanOfEcpController   = PartialResourceDescriptor->u.Port.Length;
                        Fdx->PnpInfo.EcpController         = (PUCHAR)(ULONG_PTR)Fdx->PnpInfo.OriginalEcpController.QuadPart;
                        Fdx->EcpAddressSpace               = PartialResourceDescriptor->Flags;
                    }
                    
                }
                break;
                
            case CmResourceTypeBusNumber:
                
                Fdx->BusNumber = PartialResourceDescriptor->u.BusNumber.Start;
                break;
                
            case CmResourceTypeInterrupt:
                
                *FoundIrq = TRUE;
                Fdx->FoundInterrupt       = TRUE;
                Fdx->InterruptLevel       = (KIRQL)PartialResourceDescriptor->u.Interrupt.Level;
                Fdx->InterruptVector      = PartialResourceDescriptor->u.Interrupt.Vector;
                Fdx->InterruptAffinity    = PartialResourceDescriptor->u.Interrupt.Affinity;
                
                if (PartialResourceDescriptor->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                    
                    Fdx->InterruptMode = Latched;
                    
                } else {
                    
                    Fdx->InterruptMode = LevelSensitive;
                }
                break;
                
            case CmResourceTypeDma:

                // we don't do anything with DMA - fall through to default case

            default:

                break;

            } // end switch( PartialResourceDescriptor->Type )
        } // end for(... ; i < PartialResourceList->Count ; ...)
    } // end if( FullResourceDescriptor )
    
targetExit:

    if( FALSE == isPci ) {
        // we scanned the resources - dump what we found
        DD((PCE)Fdx,DDT,"pnp::PptPnpStartScanCmResourceList - done, found:\n");
        DD((PCE)Fdx,DDT,"  OriginalEcpController= %I64x\n", Fdx->PnpInfo.OriginalEcpController);
        DD((PCE)Fdx,DDT,"  EcpController        = %p\n",    Fdx->PnpInfo.EcpController);
        DD((PCE)Fdx,DDT,"  SpanOfEcpController  = %x\n",    Fdx->PnpInfo.SpanOfEcpController);
    }
    return status;
}

NTSTATUS
PptPnpStartValidateResources(
    IN PDEVICE_OBJECT    DeviceObject,                              
    IN BOOLEAN           FoundPort,
    IN BOOLEAN           FoundIrq,
    IN BOOLEAN           FoundDma
    )
/*++dvdf3

Routine Description:

    This function is a helper function called by PptPnpStartDevice(). 

    This function does a sanity check of the resources saved in our
      extension by PptPnpStartScanCmResourceList() to determine 
      if those resources appear to be valid. Checks for for Irq 
      and Dma resource validity are anticipated in a future version.

Arguments:

    DeviceObject - The target of the START IRP
    FoundPort    - Did we find a  Port resource?
    FoundIrq     - Did we find an IRQ  resource?
    FoundDma     - Did we find a  DMA  resource?

Return Value:

    STATUS_SUCCESS        - on success,
    STATUS_NO_SUCH_DEVICE - if we weren't given a port resource,
    STATUS_NONE_MAPPED    - if we were given a port resource but our 
                              port address is NULL

--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;
    NTSTATUS          status    = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( FoundIrq ); // future use
    UNREFERENCED_PARAMETER( FoundDma ); // future use

    if( !FoundPort ) {
        status = STATUS_NO_SUCH_DEVICE;
    } else {
//         fdx->PortInfo.Controller = (PUCHAR)(ULONG_PTR)fdx->PortInfo.OriginalController.LowPart;
        fdx->PortInfo.Controller = (PUCHAR)(ULONG_PTR)fdx->PortInfo.OriginalController.QuadPart;

        if(!fdx->PortInfo.Controller) {
            // ( Controller == NULL ) is invalid
            PptLogError(DeviceObject->DriverObject, DeviceObject,
                        fdx->PortInfo.OriginalController, PhysicalZero, 0, 0, 0, 10,
                        STATUS_SUCCESS, PAR_REGISTERS_NOT_MAPPED);
            status = STATUS_NONE_MAPPED;
        }
    }
    return status;
}


BOOLEAN
PptPnpFilterExistsNonIrqResourceList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    )
/*++dvdf8

Routine Description:

    This function is a helper function called by 
      PptPnpFilterResourceRequirements(). 

    This function scans the IO_RESOURCE_REQUIREMENTS_LIST to determine
      whether there exists any resource alternatives that do NOT contain
      an IRQ resource descriptor. The method used to filter out IRQ
      resources may differ based on whether or not there exists a
      resource alternative that does not contain an IRQ resource
      descriptor.

Arguments:

    ResourceRequirementsList - The list to scan.

Return Value:

    TRUE  - There exists at least one resource alternative in the list that
              does not contain an IRQ resource descriptor.
    FALSE - Otherwise.           

--*/
{
    ULONG listCount = ResourceRequirementsList->AlternativeLists;
    PIO_RESOURCE_LIST curList;
    ULONG i;

    i=0;
    curList = ResourceRequirementsList->List;
    while( i < listCount ) {
        DD(NULL,DDT,"Searching List i=%d for an IRQ, curList= %x\n", i,curList);
        {
            ULONG                   remain   = curList->Count;
            PIO_RESOURCE_DESCRIPTOR curDesc  = curList->Descriptors;
            BOOLEAN                 foundIrq = FALSE;
            while( remain ) {
                DD(NULL,DDT," curDesc= %x , remain=%d\n", curDesc, remain);
                if(curDesc->Type == CmResourceTypeInterrupt) {
                    DD(NULL,DDT," Found IRQ - skip to next list\n");
                    foundIrq = TRUE;
                    break;
                }
                ++curDesc;
                --remain;
            }
            if( foundIrq == FALSE ) {
                //
                // We found a resource list that does not contain an IRQ resource. 
                //   Our search is over.
                //
                DD(NULL,DDT," Found a list with NO IRQ - return TRUE from PptPnpFilterExistsNonIrqResourceList\n");
                return TRUE;
            }
        }
        //
        // The next list starts immediately after the last descriptor of the current list.
        //
        curList = (PIO_RESOURCE_LIST)(curList->Descriptors + curList->Count);
        ++i;
    }

    //
    // All resource alternatives contain at least one IRQ resource descriptor.
    //
    DD(NULL,DDT,"all lists contain IRQs - return FALSE from PptPnpFilterExistsNonIrqResourceList\n");
    return FALSE;
}

VOID
PptPnpFilterRemoveIrqResourceLists(
    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    )
/*++dvdf8

Routine Description:

    This function is a helper function called by 
      PptPnpFilterResourceRequirements(). 

    This function removes all resource alternatives (IO_RESOURCE_LISTs) 
      that contain IRQ resources from the IO_RESOURCE_REQUIREMENTS_LIST 

Arguments:

    ResourceRequirementsList - The list to process.

Return Value:

    none.

--*/
{
    ULONG listCount = ResourceRequirementsList->AlternativeLists;
    PIO_RESOURCE_LIST curList;
    PIO_RESOURCE_LIST nextList;
    ULONG i;
    PCHAR currentEndOfResourceRequirementsList;
    LONG bytesToMove;

    DD(NULL,DDT,"Enter PptPnpFilterRemoveIrqResourceLists() - AlternativeLists= %d\n", listCount);

    //
    // We use the end of the list to compute the size of the memory
    //   block to move when we remove a resource alternative from the
    //   list of lists.
    //
    currentEndOfResourceRequirementsList = PptPnpFilterGetEndOfResourceRequirementsList(ResourceRequirementsList);

    i=0;
    curList = ResourceRequirementsList->List;

    //
    // Walk through the IO_RESOURCE_LISTs.
    //
    while( i < listCount ) {

        if( PptPnpListContainsIrqResourceDescriptor(curList) ) {
            //
            // The current list contains IRQ, remove it by shifting the 
            //   remaining lists into its place and decrementing the list count.
            //

            DD(NULL,DDT,"list contains an IRQ - Removing List\n");

            //
            // Get a pointer to the start of the next list.
            //
            nextList = (PIO_RESOURCE_LIST)(curList->Descriptors + curList->Count);

            //
            // compute the number of bytes to move
            //
            bytesToMove = (LONG)(currentEndOfResourceRequirementsList - (PCHAR)nextList);

            //
            // if (currentEndOfResourceRequirementsList == next list), 
            //   then this is the last list so there is nothing to move.
            //
            if( bytesToMove > 0 ) {
                //
                // More lists remain - shift them into the hole.
                //
                RtlMoveMemory(curList, nextList, bytesToMove);

                //
                // Adjust the pointer to the end of of the 
                //   IO_RESOURCE_REQUIREMENTS_LIST (list of lists) due to the shift.
                //
                currentEndOfResourceRequirementsList -= ( (PCHAR)nextList - (PCHAR)curList );
            }

            //
            // Note that we removed an IO_RESOURCE_LIST from the IO_RESOURCE_REQUIREMENTS_LIST.
            //
            --listCount;

        } else {
            //
            // The current list does not contain an IRQ resource, advance to next list.
            //
            DD(NULL,DDT,"list does not contain an IRQ - i=%d listCount=%d curList= %#x\n", i,listCount,curList);
            curList = (PIO_RESOURCE_LIST)(curList->Descriptors + curList->Count);
            ++i;
        }
    }

    //
    // Note the post filtered list count in the ResourceRequirementsList.
    //
    ResourceRequirementsList->AlternativeLists = listCount;

    DD(NULL,DDT,"Leave PptPnpFilterRemoveIrqResourceLists() - AlternativeLists= %d\n", listCount);

    return;
}

PVOID
PptPnpFilterGetEndOfResourceRequirementsList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    )
/*++dvdf8

Routine Description:

    This function is a helper function called by PptPnpFilterRemoveIrqResourceLists()

    This function finds the end of an IO_RESOURCE_REQUIREMENTS_LIST 
      (list of IO_RESOURCE_LISTs).

Arguments:

    ResourceRequirementsList - The list to scan.

Return Value:

    Pointer to the next address past the end of the IO_RESOURCE_REQUIREMENTS_LIST.

--*/
{
    ULONG listCount = ResourceRequirementsList->AlternativeLists;
    PIO_RESOURCE_LIST curList;
    ULONG i;

    i=0;
    curList = ResourceRequirementsList->List;
    while( i < listCount ) {
        //
        // Pointer arithmetic based on the size of an IO_RESOURCE_DESCRIPTOR.
        //
        curList = (PIO_RESOURCE_LIST)(curList->Descriptors + curList->Count);
        ++i;
    }
    return (PVOID)curList;
}

VOID
PptPnpFilterNukeIrqResourceDescriptorsFromAllLists(
    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    )
/*++dvdf8

Routine Description:

    This function is a helper function called by 
      PptPnpFilterResourceRequirements(). 

    This function "nukes" all IRQ resources descriptors
      in the IO_RESOURCE_REQUIREMENTS_LIST by changing the descriptor
      types from CmResourceTypeInterrupt to CmResourceTypeNull.

Arguments:

    ResourceRequirementsList - The list to process.

Return Value:

    none.

--*/
{
    ULONG             listCount = ResourceRequirementsList->AlternativeLists;
    ULONG             i         = 0;
    PIO_RESOURCE_LIST curList   = ResourceRequirementsList->List;

    DD(NULL,DDT,"Enter PptPnpFilterNukeIrqResourceDescriptorsFromAllLists() - AlternativeLists= %d\n", listCount);

    //
    // Walk through the list of IO_RESOURCE_LISTs in the IO_RESOURCE_REQUIREMENTS list.
    //
    while( i < listCount ) {
        DD(NULL,DDT,"Nuking IRQs from List i=%d, curList= %x\n", i,curList);
        //
        // Nuke all IRQ resources from the current IO_RESOURCE_LIST.
        //
        PptPnpFilterNukeIrqResourceDescriptors( curList );
        curList = (PIO_RESOURCE_LIST)(curList->Descriptors + curList->Count);
        ++i;
    }
}

VOID
PptPnpFilterNukeIrqResourceDescriptors(
    PIO_RESOURCE_LIST IoResourceList
    )
/*++dvdf8

Routine Description:

    This function is a helper function called by 
      PptPnpFilterNukeIrqResourceDescriptorsFromAllLists().

    This function "nukes" all IRQ resources descriptors
      in the IO_RESOURCE_LIST by changing the descriptor
      types from CmResourceTypeInterrupt to CmResourceTypeNull.

Arguments:

    IoResourceList - The list to process.

Return Value:

    none.

--*/
{
    PIO_RESOURCE_DESCRIPTOR  pIoResourceDescriptorIn  = IoResourceList->Descriptors;
    ULONG                    i;

    //
    // Scan the descriptor list for Interrupt descriptors.
    //
    for (i = 0; i < IoResourceList->Count; ++i) {

        if (pIoResourceDescriptorIn->Type == CmResourceTypeInterrupt) {
            //
            // Found one - change resource type from Interrupt to Null.
            //
            pIoResourceDescriptorIn->Type = CmResourceTypeNull;
            DD(NULL,DDT," - giving up IRQ resource - MinimumVector: %d MaximumVector: %d\n",
                       pIoResourceDescriptorIn->u.Interrupt.MinimumVector,
                       pIoResourceDescriptorIn->u.Interrupt.MaximumVector);
        }
        ++pIoResourceDescriptorIn;
    }
}

BOOLEAN
PptPnpListContainsIrqResourceDescriptor(
    IN PIO_RESOURCE_LIST List
)
{
    ULONG i;
    PIO_RESOURCE_DESCRIPTOR curDesc = List->Descriptors;

    for(i=0; i<List->Count; ++i) {
        if(curDesc->Type == CmResourceTypeInterrupt) {
            return TRUE;
        } else {
            ++curDesc;
        }
    }
    return FALSE;
}

NTSTATUS
PptPnpBounceAndCatchPnpIrp(
    PFDO_EXTENSION Fdx,
    PIRP              Irp
)
/*++

  Pass a PnP IRP down the stack to our parent and catch it on the way back
    up after it has been handled by the drivers below us in the driver stack.

--*/
{
    NTSTATUS       status;
    KEVENT         event;
    PDEVICE_OBJECT parentDevObj = Fdx->ParentDeviceObject;

    DD((PCE)Fdx,DDT,"PptBounceAndCatchPnpIrp()\n");

    // setup
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, PptSynchCompletionRoutine, &event, TRUE, TRUE, TRUE);

    // send
    status = IoCallDriver(parentDevObj, Irp);

    // wait for completion routine to signal that it has caught the IRP on
    //   its way back out
    KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);

    if (status == STATUS_PENDING) {
        // If IoCallDriver returned STATUS_PENDING, then we must
        //   extract the "real" status from the IRP
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
PptPnpPassThroughPnpIrpAndReleaseRemoveLock(
    IN PFDO_EXTENSION Fdx,
    IN PIRP              Irp
)
/*++

  Pass a PnP IRP down the stack to our parent, 
    release RemoveLock, and return status from IoCallDriver.

--*/
{
    NTSTATUS status;

    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(Fdx->ParentDeviceObject, Irp);
    PptReleaseRemoveLock(&Fdx->RemoveLock, Irp);
    return status;
}


VOID
P4DestroyPdo(
    IN PDEVICE_OBJECT  Pdo
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;
    PDEVICE_OBJECT  fdo = pdx->Fdo;
    PFDO_EXTENSION  fdx = fdo->DeviceExtension;

    DD((PCE)pdx,DDT,"P4DestroyPdo\n");

    //
    // Remove registry entry under HKLM\HARDWARE\DEVICEMAP\PARALLEL PORTS
    //
    if( pdx->PdoName ) {
        NTSTATUS status = RtlDeleteRegistryValue( RTL_REGISTRY_DEVICEMAP, (PWSTR)L"PARALLEL PORTS", pdx->PdoName );
        if( status != STATUS_SUCCESS ) {
            DD((PCE)pdx,DDW,"P4DestroyPdo - Failed to Delete DEVICEMAP registry entry - status=%x\n",status);
        }
    }

    //
    // remove self from FDO's DevDeletionListHead list
    //
    if( !IsListEmpty( &fdx->DevDeletionListHead ) ) {

        BOOLEAN      done  = FALSE;
        PLIST_ENTRY  first = NULL;
        
        while( !done ) {
            
            // look for self on list - remove if found

            PLIST_ENTRY current = RemoveHeadList( &fdx->DevDeletionListHead );        

            if( CONTAINING_RECORD( current, PDO_EXTENSION, DevDeletionList ) != pdx ) {

                // this is not the entry that we are looking for

                if( !first ) {

                    // note the first entry so we can stop if we search the entire list and don't find self

                    first = current;
                    InsertTailList( &fdx->DevDeletionListHead, current );

                } else {

                    // have we searched the entire list?

                    if( first == current ) {

                        // we searched the entire list and didn't find self - we must not be on the list
                        // put entry back on front of list, then we're done with search
                        DD((PCE)pdx,DDT,"P4DestroyPdo - searched entire list - we're not on it - done with search\n");
                        InsertHeadList( &fdx->DevDeletionListHead, current );
                        done = TRUE;

                    } else {

                        // not the entry that we're looking for - place at end of list - continue search
                        InsertTailList( &fdx->DevDeletionListHead, current );
                    }
                }

            } else {

                // found self - self removed from list - done with search
                DD((PCE)pdx,DDT,"P4DestroyPdo - found self on FDO's DevDeletionListHead and removed self - done with search\n");
                done = TRUE;
            }

        } // end while( !done )

    } // endif( !IsListEmpty... )


    //
    // clean up any ShadowBuffer queue used by hardware ECP modes
    //
    if( pdx->bShadowBuffer ) {
        BOOLEAN queueDeleted = Queue_Delete( &(pdx->ShadowBuffer) );
        if( !queueDeleted ) {
            PptAssertMsg( "Failed to delete queue?!?", FALSE );
        }
        pdx->bShadowBuffer = FALSE;
    }
    PptAssert( NULL == pdx->ShadowBuffer.theArray );


    //
    // clean up symbolic link - unless it has been previously cleaned up elsewhere
    //
    if( pdx->SymLinkName ) {
        P5DeletePdoSymLink( Pdo );
    }

    //
    // clean up other device extension pool allocations
    //
    if( pdx->Mfg ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up Mfg <%s>\n", pdx->Mfg);
        ExFreePool( pdx->Mfg );
        pdx->Mfg = NULL;
    }
    if( pdx->Mdl ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up Mdl <%s>\n", pdx->Mdl);
        ExFreePool( pdx->Mdl );
        pdx->Mdl = NULL;
    }
    if( pdx->Cid ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up Cid <%s>\n", pdx->Cid);
        ExFreePool( pdx->Cid );
        pdx->Cid = NULL;
    }
    if( pdx->DeviceInterface.Buffer ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up DeviceInterface <%S>\n", pdx->PdoName);
        RtlFreeUnicodeString( &pdx->DeviceInterface );
        pdx->DeviceInterfaceState = FALSE;
    }
    if( pdx->PdoName ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up PdoName <%S>\n", pdx->PdoName);
        ExFreePool( pdx->PdoName );
        pdx->PdoName = NULL;
    }
    if( pdx->Location ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up Location <%s>\n", pdx->Location);
        ExFreePool( pdx->Location );
        pdx->Location = NULL;
    }

    //
    // delete device object
    //
    IoDeleteDevice( Pdo );
}


VOID
P4SanitizeId(
    IN OUT PWSTR DeviceId
    )
/*++

Routine Description:

    This routine parses the UNICODE_NULL terminated string and replaces any invalid
    characters with an underscore character.

    Invalid characters are:
        c <= 0x20 (L' ')
        c >  0x7F
        c == 0x2C (L',')

Arguments:

    DeviceId - specifies a device id string (or part of one), must be
               UNICODE_NULL terminated.

Return Value:

    None.

--*/

{
    PWCHAR p;
    for( p = DeviceId; *p; ++p ) {
        if( (*p <= L' ') || (*p > (WCHAR)0x7F) || (*p == L',') ) {
            *p = L'_';
        }
    }
}


NTSTATUS
P4InitializePdo(
    IN PDEVICE_OBJECT  Fdo,
    IN PDEVICE_OBJECT  Pdo,
    IN enum _PdoType   PdoType,
    IN UCHAR           DaisyChainId, // Ignored unless PdoTypeDaisyChain == PdoType
    IN PCHAR           Ieee1284Id,   // NULL if none
    IN PWSTR           PdoName,
    IN PWSTR           SymLinkName
    )
{
    PFDO_EXTENSION   fdx = Fdo->DeviceExtension;
    PPDO_EXTENSION   pdx = Pdo->DeviceExtension;
    
    // we do buffered IO rather than direct IO
    Pdo->Flags |= DO_BUFFERED_IO;

    // DO_POWER_PAGABLE should be set same as parent FDO
    Pdo->Flags |= ( Fdo->Flags & DO_POWER_PAGABLE );

    // need to be able to forward Irps to parent
    Pdo->StackSize = Fdo->StackSize + 1;

    RtlZeroMemory( pdx, sizeof(PDO_EXTENSION) );

    // used by debugger extension
    pdx->Signature1 = PARPORT_TAG;
    pdx->Signature2 = PARPORT_TAG;

    // frequently need to know what type of PDO we have in order to do special case handling 
    pdx->PdoType = PdoType;

    // Save name used in call to IoCreateDevice (for debugging use)
    pdx->PdoName     = PdoName;

    // Save name used in call to IoCreateUnprotectedSymbolicLink for later call to IoDeleteSymbolicLink
    pdx->SymLinkName = SymLinkName;

    // initialize Mfg, Mdl, and Cid
    if( Ieee1284Id ) {
        //
        // Extract Mfg, Mdl, and Cid from Ieee1284Id and save in extension
        //

        // ParPnpFindDeviceIdKeys modifies deviceID passed in so make
        // a copy of the 1284 ID and pass in a pointer to the copy
        PCHAR tmpBuffer;
        ULONG tmpBufLen = strlen(Ieee1284Id) + sizeof(CHAR);

        DD((PCE)fdx,DDT,"P4InitializePdo - have Ieee1284Id\n");

        tmpBuffer = ExAllocatePool( PagedPool, tmpBufLen );
        if( tmpBuffer ) {
            PCHAR  mfg, mdl, cls, des, aid, cid;
            RtlZeroMemory( tmpBuffer, tmpBufLen );
            strcpy( tmpBuffer, Ieee1284Id );
            DD((PCE)fdx,DDT,"P4InitializePdo - calling ParPnpFindDeviceIdKeys\n");
            ParPnpFindDeviceIdKeys( &mfg, &mdl, &cls, &des, &aid, &cid, tmpBuffer );
            if( mfg ) {
                PCHAR buffer;
                ULONG bufLen = strlen(mfg) + sizeof(CHAR);
                DD((PCE)fdx,DDT,"P4InitializePdo - found mfg - <%s>\n",mfg);
                buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
                if( buffer ) {
                    RtlZeroMemory( buffer, bufLen );
                    strcpy( buffer, mfg );
                    pdx->Mfg = buffer;
                }
            }
            if( mdl ) {
                PCHAR buffer;
                ULONG bufLen = strlen(mdl) + sizeof(CHAR);
                DD((PCE)fdx,DDT,"P4InitializePdo - found mdl - <%s>\n",mdl);
                buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
                if( buffer ) {
                    RtlZeroMemory( buffer, bufLen );
                    strcpy( buffer, mdl );
                    pdx->Mdl = buffer;
                }
            }
            if( cid ) {
                PCHAR buffer;
                ULONG bufLen = strlen(cid) + sizeof(CHAR);
                DD((PCE)fdx,DDT,"P4InitializePdo - found cid - <%s>\n",cid);
                buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
                if( buffer ) {
                    RtlZeroMemory( buffer, bufLen );
                    strcpy( buffer, cid );
                    pdx->Cid = buffer;
                }
            } else {
                DD((PCE)fdx,DDT,"P4InitializePdo - no cid found\n");
            }
            ExFreePool( tmpBuffer );
        } else {
            DD((PCE)fdx,DDT,"P4InitializePdo - out of pool\n");
        }

    } else {
        //
        // PdoType doesn't have a Mfg, Mdl, or Cid, make up Mfg and Mdl, no Cid
        //
        const CHAR rawPortMfg[]   = "Microsoft";
        const CHAR rawPortMdl[]   = "RawPort";
        const CHAR legacyZipMfg[] = "IMG";
        const CHAR legacyZipMdl[] = "VP0";
        PCHAR      mfgStr;
        ULONG      mfgLen;
        PCHAR      mdlStr;
        ULONG      mdlLen;
        PCHAR      buffer;

        if( PdoTypeRawPort == PdoType ) {
            mfgStr = (PCHAR)rawPortMfg;
            mfgLen = sizeof(rawPortMfg);
            mdlStr = (PCHAR)rawPortMdl;
            mdlLen = sizeof(rawPortMdl);
        } else {
            // PdoTypeLegacyZip
            PptAssert( PdoTypeLegacyZip == PdoType );
            mfgStr = (PCHAR)legacyZipMfg;
            mfgLen = sizeof(legacyZipMfg);
            mdlStr = (PCHAR)legacyZipMdl;
            mdlLen = sizeof(legacyZipMdl);
        }
        buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, mfgLen );
        if( buffer ) {
            RtlZeroMemory( buffer, mfgLen );
            strcpy( buffer, mfgStr );
            pdx->Mfg = buffer;
        }
        buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, mdlLen );
        if( buffer ) {
            RtlZeroMemory( buffer, mdlLen );
            strcpy( buffer, mdlStr );
            pdx->Mdl = buffer;
        }
        pdx->Cid = NULL;
    }

    // initialize Location information - LPTx or LPTx.y
    PptAssert( fdx->PnpInfo.PortName &&
               ( (0 == wcscmp(fdx->PnpInfo.PortName, L"LPT1") ) ||
                 (0 == wcscmp(fdx->PnpInfo.PortName, L"LPT2") ) ||
                 (0 == wcscmp(fdx->PnpInfo.PortName, L"LPT3") ) ) );

    switch( PdoType ) {
        PCHAR buffer;
        ULONG bufLen;

    case PdoTypeRawPort :
        bufLen = sizeof("LPTx");
        buffer = ExAllocatePool( NonPagedPool, bufLen );
        if( buffer ) {
            RtlZeroMemory( buffer, bufLen );
            _snprintf( buffer, bufLen, "%S", fdx->PnpInfo.PortName );
            pdx->Location = buffer;
        } else {
            DD((PCE)fdx,DDT,"P4InitializePdo - out of pool");
        }
        break;

    case PdoTypeDaisyChain :
        bufLen = sizeof("LPTx.y");
        buffer = ExAllocatePool( NonPagedPool, bufLen );
        if( buffer ) {
            PptAssert( DaisyChainId >= 0 && DaisyChainId < 4 );
            RtlZeroMemory( buffer, bufLen );
            _snprintf( buffer, bufLen, "%S.%1d", fdx->PnpInfo.PortName, DaisyChainId );
            pdx->Location = buffer;
        } else {
            DD((PCE)fdx,DDT,"P4InitializePdo - out of pool");
        }
        break;

    case PdoTypeEndOfChain :
        bufLen = sizeof("LPTx.y");
        buffer = ExAllocatePool( NonPagedPool, bufLen );
        if( buffer ) {
            RtlZeroMemory( buffer, bufLen );
            _snprintf( buffer, bufLen, "%S.4", fdx->PnpInfo.PortName );
            pdx->Location = buffer;
        } else {
            DD((PCE)fdx,DDT,"P4InitializePdo - out of pool");
        }
        break;

    case PdoTypeLegacyZip :
        bufLen = sizeof("LPTx.y");
        buffer = ExAllocatePool( NonPagedPool, bufLen );
        if( buffer ) {
            RtlZeroMemory( buffer, bufLen );
            _snprintf( buffer, bufLen, "%S.5", fdx->PnpInfo.PortName );
            pdx->Location = buffer;
        } else {
            DD((PCE)fdx,DDT,"P4InitializePdo - out of pool");
        }
        break;

    default :
        PptAssert(!"Invalid PdoType");
    }


    // initialize synchronization and list mechanisms
    ExInitializeFastMutex( &pdx->OpenCloseMutex );
    InitializeListHead( &pdx->WorkQueue );
    KeInitializeSemaphore( &pdx->RequestSemaphore, 0, MAXLONG );
    KeInitializeEvent( &pdx->PauseEvent, NotificationEvent, TRUE );


    // general info
    pdx->DeviceObject         = Pdo;
    pdx->DevType              = DevTypePdo;

    pdx->EndOfChain           = (PdoTypeEndOfChain == PdoType) ? TRUE : FALSE; // override later if this is a
    pdx->Ieee1284_3DeviceId   = (PdoTypeDaisyChain == PdoType) ? DaisyChainId : 0; //   1284.3 Daisy Chain device

    pdx->IsPdo                = TRUE;       // really means !FDO
    pdx->Fdo                  = Fdo;
    pdx->ParClassFdo          = Fdo;        // depricated - use Fdo field on prev line
    pdx->PortDeviceObject     = Fdo;        // depricated - use Fdo field 2 lines up - modify functions to use it
    pdx->BusyDelay            = 0;
    pdx->BusyDelayDetermined  = FALSE;
    
    // timing constants
    pdx->TimerStart                  = PAR_WRITE_TIMEOUT_VALUE;
    pdx->AbsoluteOneSecond.QuadPart  = 10*1000*1000;
    pdx->IdleTimeout.QuadPart        = - 250*10*1000;       // 250 ms
    pdx->OneSecond.QuadPart          = - pdx->AbsoluteOneSecond.QuadPart;

    // init IEEE 1284 protocol settings
    ParInitializeExtension1284Info( pdx );

    pdx->DeviceType = PAR_DEVTYPE_PDO; // deprecated - use DevType in common extension

    if( Ieee1284Id ) {
        ULONG length = strlen(Ieee1284Id) + 1;
        PCHAR copyOfIeee1284Id = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, length );
        if( copyOfIeee1284Id ) {
            RtlZeroMemory( copyOfIeee1284Id, length );
            strcpy( copyOfIeee1284Id, Ieee1284Id );
            ParDetectDot3DataLink( pdx, Ieee1284Id );
            ExFreePool( copyOfIeee1284Id );
        }
    }

    // RMT - doug - need to put this back in - ParCheckParameters(DevObj->DeviceExtension);   // Check the registry for parameter overrides

    // Write symbolic link map info to the registry.
    {
        NTSTATUS status = RtlWriteRegistryValue( RTL_REGISTRY_DEVICEMAP,
                                                 (PWSTR)L"PARALLEL PORTS",
                                                 pdx->PdoName,
                                                 REG_SZ,
                                                 pdx->SymLinkName,
                                                 wcslen(pdx->SymLinkName)*sizeof(WCHAR) + sizeof(WCHAR) );
        if( NT_SUCCESS( status ) ) {
            DD((PCE)fdx,DDT,"Created DEVICEMAP registry entry - %S -> %S\n",pdx->PdoName,pdx->SymLinkName);
        } else {
            DD((PCE)fdx,DDT,"Failed to create DEVICEMAP registry entry - status = %x\n", status);
        }
    }

    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;      // Tell the IO system that we are ready to receive IRPs
    return STATUS_SUCCESS;
}


PWSTR
P4MakePdoSymLinkName(
    IN PWSTR          LptName,
    IN enum _PdoType  PdoType,
    IN UCHAR          DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN UCHAR          RetryNumber
    )
/*

    Generate \DosDevices\LPTx or \DosDevices\LPTx.y PdoSymbolicLinkName from LPTx Name

    In:  LPTx
    Out: \DosDevices\LPTx or \DosDevices\LPTx.y depending on PdoType

    examples: 
    
      LPT1 PdoTypeEndOfChain                  -> \DosDevices\LPT1.4
      LPT2 PdoTypeDaisyChain DaisyChainId==3  -> \DosDevices\LPT2.3
      LPT3 PdoTypeRawPort                     -> \DosDevices\LPT3
    
    returns - pointer to pool allocation containing PdoSymbolicLinkName on success (caller frees), or
            - NULL on error 
    
*/
{
    const UCHAR  maxDaisyChainSuffix = 3;
    const UCHAR  endOfChainSuffix    = 4;
    const UCHAR  legacyZipSuffix     = 5;
    const ULONG  maxSymLinkNameLength = sizeof(L"\\DosDevices\\LPTx.y-z");
    
    UCHAR        suffix = 0;
    PWSTR        buffer;

    if( !LptName ) {
        PptAssert( !"NULL LptName" );
        return NULL;
    }

    DD(NULL,DDT,"P4MakePdoSymLinkName - LptName = %S\n",LptName);

    switch( PdoType ) {
    case PdoTypeDaisyChain :
        if( DaisyChainId > maxDaisyChainSuffix ) {
            PptAssert( !"DaisyChainId > maxDaisyChainSuffix" );
            return NULL;
        }
        suffix = DaisyChainId;
        break;
    case PdoTypeEndOfChain :
        suffix = endOfChainSuffix;
        break;
    case PdoTypeLegacyZip :
        suffix = legacyZipSuffix;
        break;
    case PdoTypeRawPort :
        break; // no suffix
    default :
        PptAssert( !"Unrecognised PdoType" );
        return NULL;
    }

    if( 0 == RetryNumber ) {
        buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, maxSymLinkNameLength );
        if( buffer ) {
            RtlZeroMemory( buffer, maxSymLinkNameLength );
            if( PdoTypeRawPort == PdoType ) {
                swprintf( buffer, L"\\DosDevices\\%s\0", LptName );
            } else {
                swprintf( buffer, L"\\DosDevices\\%s.%d\0", LptName, suffix );
            }
        }
    } else if( RetryNumber <= 9 ) {
        buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, maxSymLinkNameLength );
        if( buffer ) {
            RtlZeroMemory( buffer, maxSymLinkNameLength );
            if( PdoTypeRawPort == PdoType ) {
                swprintf( buffer, L"\\DosDevices\\%s-%1d\0", LptName, RetryNumber );
            } else {
                swprintf( buffer, L"\\DosDevices\\%s.%d-%1d\0", LptName, suffix, RetryNumber );
            }
        }
    } else {
        buffer = NULL;
    }

    return buffer;
}


PWSTR
P4MakePdoDeviceName(
    IN PWSTR          LptName,
    IN enum _PdoType  PdoType,
    IN UCHAR          DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN UCHAR          RetryNumber   // used if we had a name collision on IoCreateDevice
    )
/*

    Generate \Device\Parallely or \Device\Parallely.z PDO DeviceName from LPTx Name

    In:  LPTx
    Out: \Device\Parallely or \Device\Parallely.z depending on PdoType

    y == (x-1), optional .z suffix is based on type of Pdo
    
    examples: 
    
      LPT1 PdoTypeEndOfChain                  -> \Device\Parallel0.4
      LPT2 PdoTypeDaisyChain DaisyChainId==3  -> \Device\Parallel1.3
      LPT3 PdoTypeRawPort                     -> \Device\Parallel2
    
    returns - pointer to pool allocation containing PdoDeviceName on success (caller frees), or
            - NULL on error 
    
*/
{
    const UCHAR  maxDaisyChainSuffix = 3;
    const UCHAR  endOfChainSuffix    = 4;
    const UCHAR  legacyZipSuffix     = 5;
    ULONG        maxDeviceNameLength;

    UCHAR  lptNumber;
    UCHAR  suffix = 0;
    PWSTR  buffer = NULL;

    DD(NULL,DDT,"P4MakePdoDeviceName - LptName=<%S>, PdoType=%d, DaisyChainId=%d\n",LptName,PdoType,DaisyChainId);  


    if( !LptName ) {
        PptAssert( !"NULL LptName" );
        return NULL;
    }

    switch( PdoType ) {
    case PdoTypeDaisyChain :
        if( DaisyChainId > maxDaisyChainSuffix ) {
            PptAssert( !"DaisyChainId > maxDaisyChainSuffix" );
            return NULL;
        }
        suffix = DaisyChainId;
        break;
    case PdoTypeEndOfChain :
        suffix = endOfChainSuffix;
        break;
    case PdoTypeLegacyZip :
        suffix = legacyZipSuffix;
        break;
    case PdoTypeRawPort :
        break; // no suffix
    default :
        PptAssert( !"Unrecognised PdoType" );
        return NULL;
    }

    if     ( 0 == wcscmp( (PCWSTR)L"LPT1", LptName ) ) { lptNumber = 1; } 
    else if( 0 == wcscmp( (PCWSTR)L"LPT2", LptName ) ) { lptNumber = 2; }
    else if( 0 == wcscmp( (PCWSTR)L"LPT3", LptName ) ) { lptNumber = 3; }
    else {
        PptAssert( !"LptName not of the form LPTx where 1 <= x <= 3" );
        return NULL;
    }

    DD(NULL,DDT,"P4MakePdoDeviceName - suffix=%d\n",suffix);

    if( 0 == RetryNumber ) {
        maxDeviceNameLength = sizeof(L"\\Device\\Parallelx.y");
        buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, maxDeviceNameLength );
        if( buffer ) {
            RtlZeroMemory( buffer, maxDeviceNameLength );
            if( PdoTypeRawPort == PdoType ) {
                swprintf( buffer, L"\\Device\\Parallel%d\0", lptNumber-1 );
            } else {
                swprintf( buffer, L"\\Device\\Parallel%d.%d\0", lptNumber-1, suffix );
            }
        }
    } else {
        if( RetryNumber <= 9 ) {
            maxDeviceNameLength = sizeof(L"\\Device\\Parallelx.y-z");
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, maxDeviceNameLength );
            if( buffer ) {
                RtlZeroMemory( buffer, maxDeviceNameLength );
                if( PdoTypeRawPort == PdoType ) {
                    swprintf( buffer, L"\\Device\\Parallel%d-%1d\0", lptNumber-1, RetryNumber );
                } else {
                    swprintf( buffer, L"\\Device\\Parallel%d.%d-%1d\0", lptNumber-1, suffix, RetryNumber );
                }
            }
        }
    }

    if( buffer ) {
        DD(NULL,DDT,"P4MakePdoDeviceName <%S>\n",buffer);
    }

    return buffer;
}


PDEVICE_OBJECT
P4CreatePdo(
    IN PDEVICE_OBJECT  Fdo,
    IN enum _PdoType   PdoType,
    IN UCHAR           DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN PCHAR           Ieee1284Id    // NULL if device does not report IEEE 1284 Device ID
    )
{
    PFDO_EXTENSION  fdx             = Fdo->DeviceExtension;
    PWSTR           lptName         = fdx->PnpInfo.PortName;
    NTSTATUS        status          = STATUS_UNSUCCESSFUL;
    PDEVICE_OBJECT  pdo             = NULL;
    PWSTR           wstrDeviceName  = NULL;
    PWSTR           wstrSymLinkName = NULL;
    BOOLEAN         createdSymLink  = FALSE;
    UCHAR           retryNumber     = 0;

    UNICODE_STRING  deviceName;
    UNICODE_STRING  symLinkName;

    DD((PCE)fdx,DDT,"P4CreatePdo - enter - PdoType= %d, DaisyChainId=%d, Ieee1284Id=<%s>\n", PdoType, DaisyChainId, Ieee1284Id);

    __try {

        if( !lptName ) {
            DD((PCE)fdx,DDT,"P4CreatePdo - no lptName\n");
            __leave;
        }

        DD((PCE)fdx,DDT,"P4CreatePdo - lptName = %S\n",lptName);
        
targetRetryDeviceName:

        wstrDeviceName = P4MakePdoDeviceName( lptName, PdoType, DaisyChainId, retryNumber );
        if( !wstrDeviceName ) {
            DD((PCE)fdx,DDT,"P4MakePdoDeviceName FAILED\n");
            __leave;
        }

        DD((PCE)fdx,DDT,"P4CreatePdo - wstrDeviceName = %S\n",wstrDeviceName);
        RtlInitUnicodeString( &deviceName, wstrDeviceName );

        status = IoCreateDevice( fdx->DriverObject, 
                                 sizeof(PDO_EXTENSION),
                                 &deviceName,
                                 FILE_DEVICE_PARALLEL_PORT,
                                 FILE_DEVICE_SECURE_OPEN,
                                 TRUE,
                                 &pdo );
        
        if( STATUS_SUCCESS != status ) {
            DD((PCE)fdx,DDT,"P4CreatePdo - FAILED\n");
            pdo = NULL; // just to make sure that we don't try to use this later
            if( STATUS_OBJECT_NAME_COLLISION == status ) {
                // try again with another name
                DD(NULL,DDE,"P4CreatePdo - STATUS_OBJECT_NAME_COLLISION on %S\n",wstrDeviceName);
                ExFreePool( wstrDeviceName );
                ++retryNumber;
                goto targetRetryDeviceName;
            }
            __leave;
        }

        retryNumber = 0;

targetRetrySymLink:

        wstrSymLinkName = P4MakePdoSymLinkName( lptName, PdoType, DaisyChainId, retryNumber );
        if( !wstrSymLinkName ) {
            DD((PCE)fdx,DDT,"P4MakePdoSymLinkName FAILED\n");
            __leave;
        }
        RtlInitUnicodeString( &symLinkName, wstrSymLinkName );

        status = IoCreateUnprotectedSymbolicLink( &symLinkName , &deviceName );
        if( STATUS_SUCCESS != status ) {
            if( STATUS_OBJECT_NAME_COLLISION == status ) {
                DD(NULL,DDE,"P4CreatePdo - STATUS_OBJECT_NAME_COLLISION on %S\n", wstrSymLinkName);
                ExFreePool( wstrSymLinkName );
                ++retryNumber;
                goto targetRetrySymLink;
            }
            DD((PCE)fdx,DDT,"P4CreatePdo - create SymLink FAILED\n");
            __leave;
        } else {
            createdSymLink = TRUE;
        }

        if( (NULL == Ieee1284Id) && (PdoTypeDaisyChain == PdoType) ) {
            // SCM Micro device?
            PPDO_EXTENSION              pdx = pdo->DeviceExtension;
            PPARALLEL_PORT_INFORMATION  PortInfo = &fdx->PortInfo;
            BOOLEAN                     bBuildStlDeviceId;
            ULONG                       DeviceIdSize;

            pdx->Controller =  PortInfo->Controller;

            bBuildStlDeviceId = ParStlCheckIfStl( pdx, DaisyChainId ) ;

            if( TRUE == bBuildStlDeviceId ) {
                Ieee1284Id = ParStlQueryStlDeviceId( pdx, NULL, 0, &DeviceIdSize, FALSE );
            }

            pdx->OriginalController = PortInfo->OriginalController;

            P4InitializePdo( Fdo, pdo, PdoType, DaisyChainId, Ieee1284Id, wstrDeviceName, wstrSymLinkName );
            
            if (Ieee1284Id) {
                 ExFreePool (Ieee1284Id);
                 Ieee1284Id = NULL;
            }

        } else {
            P4InitializePdo( Fdo, pdo, PdoType, DaisyChainId, Ieee1284Id, wstrDeviceName, wstrSymLinkName );
        }

    } // __try

    __finally {
        if( STATUS_SUCCESS != status ) {
            // failure - do cleanup
            if( createdSymLink ) {
                IoDeleteSymbolicLink( &symLinkName );
            }
            if( pdo ) {
                IoDeleteDevice( pdo );
                pdo = NULL;
            }
            if( wstrDeviceName ) {
                ExFreePool( wstrDeviceName );
            }
            if( wstrSymLinkName ) {
                ExFreePool( wstrSymLinkName );
            }
        }
    } // __finally

    return pdo;
}


VOID
P4SanitizeMultiSzId( 
    IN OUT  PWSTR  WCharBuffer,
    IN      ULONG  BufWCharCount
    )
    // BufWCharCount == number of WCHARs (not bytes) in the string
    //
    // Sanitize the MULTI_SZ (HardwareID or CompatibleID) for PnP:
    //   1) Leave UNICODE_NULLs (L'\0') alone, otherwise
    //   2) Convert illegal characters to underscores (L'_')
    //      illegal characters are ( == L',' ) || ( <= L' ' ) || ( > (WCHAR)0x7F )
{
    PWCHAR p = WCharBuffer;
    ULONG  i;
    for( i = 0; i < BufWCharCount ; ++i, ++p ) {
        if( L'\0'== *p ) {
            continue;
        } else if( (*p <= L' ') || (*p > (WCHAR)0x7F) || (L',' == *p) ) {
            *p = L'_';
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\shuttle.h ===
#ifndef     _PARSTL_H_
#define     _PARSTL_H_

// Define 1284 Commands
#define CPP_QUERY_PRODID    0x10

// 1284 related SHTL prod id equates
#define SHTL_EPAT_PRODID    0xAAFF
#define SHTL_EPST_PRODID    0xA8FF

// typedefs for device type
typedef unsigned char   DEVICE_STATE ;
typedef unsigned int    STL_DEVICE_TYPE ;
typedef unsigned int    IMPACT_DEVICE_TYPE ;

// device type equates
#define DEVICE_TYPE_AUTO_DETECT     -1
#define TRUE    1
#define FALSE   0

#define DEVICE_TYPE_NONE            0x0000
#define DEVICE_TYPE_ATA             0x0001
#define DEVICE_TYPE_ATAPI           0x0002
#define DEVICE_TYPE_SCSI            0x0003
#define DEVICE_TYPE_SSFDC           0x0004
#define DEVICE_TYPE_MMC             0x0005
#define DEVICE_TYPE_FLASH           0x0006
#define DEVICE_TYPE_EPP_DEVICE      0x0007
#define DEVICE_TYPE_SOUND           0x0008
#define DEVICE_TYPE_HIFD            0x0009
#define DEVICE_TYPE_LS120           0x000A
#define DEVICE_TYPE_PCMCIA_CF       0x000B
#define DEVICE_TYPE_FLP_TAPE_DSK    0x000C
#define DEVICE_TYPE_ATA_ATAPI_8BIT  0x000D
#define DEVICE_TYPE_UMAX            0x000E
#define DEVICE_TYPE_AVISION         0x000F
#define DEVICE_TYPE_DAZZLE          0x0010
#define DEVICE_TYPE_EXT_HWDETECT    0x40000000 // to OR with expected pers.

#define DEVICE_TYPE_ATA_BIT             1 << ( DEVICE_TYPE_ATA - 1 )
#define DEVICE_TYPE_ATAPI_BIT           1 << ( DEVICE_TYPE_ATAPI - 1 )
#define DEVICE_TYPE_SCSI_BIT            1 << ( DEVICE_TYPE_SCSI - 1 )
#define DEVICE_TYPE_SSFDC_BIT           1 << ( DEVICE_TYPE_SSFDC - 1 )
#define DEVICE_TYPE_MMC_BIT             1 << ( DEVICE_TYPE_MMC - 1 )
#define DEVICE_TYPE_FLASH_BIT           1 << ( DEVICE_TYPE_FLASH - 1 )
#define DEVICE_TYPE_EPP_DEVICE_BIT      1 << ( DEVICE_TYPE_EPP_DEVICE - 1 )
#define DEVICE_TYPE_SOUND_BIT           1 << ( DEVICE_TYPE_SOUND - 1 )
#define DEVICE_TYPE_HIFD_BIT            1 << ( DEVICE_TYPE_HIFD - 1 )
#define DEVICE_TYPE_LS120_BIT           1 << ( DEVICE_TYPE_LS120 - 1 )
#define DEVICE_TYPE_PCMCIA_CF_BIT       1 << ( DEVICE_TYPE_PCMCIA_CF - 1 )
#define DEVICE_TYPE_FLP_TAPE_DSK_BIT    1 << ( DEVICE_TYPE_FLP_TAPE_DSK - 1 )
#define DEVICE_TYPE_ATA_ATAPI_8BIT_BIT  1 << ( DEVICE_TYPE_ATA_ATAPI_8BIT - 1 )
#define DEVICE_TYPE_UMAX_BIT            1 << ( DEVICE_TYPE_UMAX - 1 )
#define DEVICE_TYPE_AVISION_BIT         1 << ( DEVICE_TYPE_AVISION - 1 )
#define DEVICE_TYPE_DAZZLE_BIT          1 << ( DEVICE_TYPE_DAZZLE - 1 )

// possible Device states
#define DEVICE_STATE_INVALID    0
#define DEVICE_STATE_VALID      1
#define DEVICE_STATE_ATAPI      2

// epp dev equates
#define EPPDEV_SIGN        0x03
#define PERSONALITY_MASK    0x03

// flash related equates
#define FLASH_SIGN              0x01
#define FLASH_PERSONALITY_MASK  0x03

// dazzle related equates
#define DAZ_SELECT_BLK          0x18
#define DAZ_BLK0                0x00
#define DAZ_REG1                0x19
#define DAZ_CONFIGURED          0x5A
#define DAZ_NOT_CONFIGURED      0xBC

// umax related equates
#define    BUSY         0x20
#define    PE           0x08

#define    DATAPORT             0x18
#define    STATUSPORT           0x19
#define    CONTROLPORT          0x1A
#define    EPPADDRPORT          0x1B
#define    EPPDATA0PORT         0x1C
#define    EPPDATA1PORT         0x1D
#define    EPPDATA2PORT         0x1E
#define    EPPDATA3PORT         0x1F

// HIFD related equates
#define HIFD_CONTROLLER_READY_STATUS    0x80
#define HIFD_DIGITAL_OUTPUT_REGISTER    0x02
#define HIFD_DOR_RESET_BIT              0x04
#define HIFD_ENABLE_DMA_BIT             0x08
#define HIFD_MAIN_STATUS_REGISTER       0x04
#define HIFD_DATA_RATE_SELECT_REGISTER  0x04
#define HIFD_STATUS_REGISTER_A          0x00
#define HIFD_STATUS_REGISTER_B          0x01

#define HIFD_COMMAND_TO_CONTROLLER      0x55
#define HIFD_TERMINATE_SEQUENCE         0xAA
#define HIFD_CTL_REG_0D                 0x0D
#define HIFD_CTL_REG_03                 0x03
#define HIFD_WAIT_10_MILLISEC           10000   // 10 * 1000 
#define HIFD_WAIT_1_MILLISEC            1000   // 1 * 1000 

#define SMC_ENABLE_MODE2        0x72
#define SMC_DEVICE_ID           0x78

// LS120 related equates
#define LS120_ENGINE_VERSION            0xE2
#define LS120_ENGINE_VERSION_REGISTER   0x07

// MMC engine specific equates
#define MMC_ENGINE_INDEX    0x1E
#define MMC_ENGINE_DATA     0x1F
#define MMC_FREQ_SELECT_REG 0x00
#define MMC_BLOCK_SIZE_REG  0x06

// Though these are test patterns, they may be possible commands
// for ATA/ATAPI devices, as they are written to a possible
// ATA/ATAPI command register. These values have been fixed
// carefully, to minimize, if not eliminate, possible failure.
#define MMC_TEST_PATTERN_1  0x00    // ATA Nop commands for ATA/ATAPI type devices.
#define MMC_TEST_PATTERN_2  0xA1    // ATAPI Ident. command for ATAPI type devices.
#define MMC_TEST_PATTERN_3  0x00    // ATA Nop commands for ATA/ATAPI type devices.

// some IO register equates that are inevitable
#define CYLLOW_REG          0x0004
#define CYLHIGH_REG         0x0005

// ATAPI signature equates
#define ATAPI_SIGN_LOW      0x14
#define ATAPI_SIGN_HI       0xEB

// delay equates
#define MAX_RETRIES_FOR_5_SECS      5 * 1000    //   5 secs
#define MAX_RETRIES_FOR_10_SECS     10 * 1000   //   10 secs
#define DELAY_10MICROSECONDS        10          //  10 mu sec.
#define DELAY_1MILLISECONDS         1000        //  1 milli sec.
#define DELAY_1SECOND               1000*1000   //  1 sec.

// ATA/ATAPI command opcodes
#define ATA_NOP_COMMAND            0x00
#define ATAPI_IDENTIFY             0xA1

// ATA/ATAPI drive select values 
#define ATAPI_MASTER        0xA0
#define ATAPI_SLAVE         0xB0
#define ATAPI_MAX_DRIVES    2

//  ATA register definitions
#define ATA_DATA_REG            0x0000
#define ATA_ERROR_REG           0x0001
#define ATA_PRECOMP_REG         0x0001
#define ATA_SECCNT_REG          0x0002
#define ATA_SECNUM_REG          0x0003
#define ATA_CYLLOW_REG          0x0004
#define ATA_CYLHIGH_REG         0x0005
#define ATA_DRVHD_REG           0x0006
#define ATA_TASK_STAT_REG       0x0007
#define ATA_TASK_CMD_REG        0x0007
#define ATA_ALT_STAT_REG        0x0008

// ATA status register equates
#define ATA_ST_ERROR        0x01
#define ATA_ST_INDEX        0x02
#define ATA_ST_CORRCTD      0x04
#define ATA_ST_DRQ          0x08
#define ATA_ST_SEEK_COMPL   0x10
#define ATA_ST_WRT_FLT      0x20
#define ATA_ST_READY        0x40
#define ATA_ST_BUSY         0x80

// ATA error register equates
#define ATA_ERROR_ABORTED_COMMAND   0x04

// miscellaneous equates
#define BUS_LINES_IN_HIGH_IMPEDANCE         0xFF
#define SKIP_MEMORY_ADDRESS                 ((unsigned long)(-1L))
#define SHTL_NO_ERROR                       0x0000

#define IsShtlError(x) (x & 0x8000)
#define IsImpactPresent() ( IMPACT_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsImpactSPresent() ( IMPACTS_VERSION <= ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEp1284Present() ( EP1284_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpatPlusPresent() ( EPATP_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpezPresent() ( EPEZ_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpatPresent() ( EPAT_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpstPresent() ( EPST_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define NeedToEnableIoPads() ( EP1284_VERSION <= ParStlReadReg ( Extension, VERSION_REGISTER ) )

// Identify command processing related defines..
#define ATAPI_IDENTIFY_LENGTH               512
#define ATAPI_NAME_LENGTH                   10
#define ATAPI_NAME_OFFSET                   84

// EP1284 related equates
#define EP1284_BLK_ADDR_REGISTER    0x0A
#define EP1284_MODE_REGISTER        0x0C
#define VERSION_REGISTER            0x0B
#define EP1284_TRANSFER_CONTROL_REG 0x12
#define EP1284_PERSONALITY_REG      0x01
#define EPAT_MODE_REGISTER          0x0C
#define SOCKET_CONTROL_REGISTER     0x0C
#define ISA_CONTROL_REGISTER        0x0D
#define CONFIG_INDEX_REGISTER       0x0E
#define CONFIG_DATA_REGISTER        0x0F
#define SHTL_CARD_INSERTED_STATUS   0x02
#define XFER_IRQ_BIT                0x20
#define EP1284_POWER_CONTROL_REG    0x0F
#define ENABLE_IOPADS               0x04

// IMPACT related equates
#define IMPACT_PERSONALITY_REG  0x01

// IMPACT-S related equates
#define IMPACTS_EXT_PERSONALITY_PRESENT 0x0A // 0xA0 >> 4
#define IMPACTS_EXT_PERSONALITY_XREG    0x29

// shuttle version number related equates
#define EPST_VERSION            0xB2
#define EPAT_VERSION            0xC3
#define EPEZ_VERSION            0xC5
#define EPATP_VERSION           0xC6
#define EP1284_VERSION          0xC7
#define IMPACT_VERSION          0xC8
#define IMPACTS_VERSION         0xC9
#define EP1284_ENABLE_16BIT     0x10
#define EPAT_RESET_POLARITY     0x20
#define ISA_IO_SWAP             0x20
#define SOCKET_0                0x00
#define SOCKET_1                0x01
#define PERIPHERAL_RESET_1      0x20
#define PERIPHERAL_RESET_0      0x10

// block xfer related op-codes
#define OP_NIBBLE_BLOCK_READ    0x07

// test pattern equates
#define TEST_PATTERN_1  0x55
#define TEST_PATTERN_2  0xAA

// Memory detection related equates
#define SELECT_DRAM 0x80
#define SELECT_SRAM 0x7F
#define RESET_PTR   0x01
#define ENABLE_MEM  0x04
#define EP1284_CONTROL_REG      0x13
#define EP1284_BUFFER_DATA_REG  0x10

// IMPACT device type defines
#define IMPACT_DEVICE_TYPE_NONE                 0
#define IMPACT_DEVICE_TYPE_ATA_ATAPI            1
#define IMPACT_DEVICE_TYPE_PCMCIA_CF            2
#define IMPACT_DEVICE_TYPE_SSFDC                3
#define IMPACT_DEVICE_TYPE_MMC                  4
#define IMPACT_DEVICE_TYPE_HIFD                 5
#define IMPACT_DEVICE_TYPE_SOUND                6
#define IMPACT_DEVICE_TYPE_FLP_TAPE_DSK         7
#define IMPACT_DEVICE_TYPE_CF                   8
#define IMPACT_DEVICE_TYPE_ATA_ATAPI_8BIT       9

// parallel port signal equates
#define SLCT_IN_DISABLE     0x04
#define SLCT_IN_ENABLE      0x0C
#define STB_INIT_LOW        0x01
#define STB_INIT_AFXT_LO    0x03
#define INIT_AFXT_HIGH      0x05
#define STB_INIT_AFXT_HI    0x04
#define STB_INIT_HIGH       0x04

#define AFXT_HI_STB_HI      0x04
#define AFXT_LO_STB_HI      0x06
#define AFXT_HI_STB_LO      0x05
#define AFXT_LO_STB_LO      0x07

// structure definitions

typedef struct  _ATAPI_PARAMS{
    DEVICE_STATE    dsDeviceState[ATAPI_MAX_DRIVES];
    char            szAtapiNameString [ ATAPI_NAME_LENGTH ] ;
} ATAPIPARAMS, *PATAPIPARAMS ;

// function prototypes 
BOOLEAN
ParStlCheckIfStl(
    IN PPDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) ;

BOOLEAN
ParStlCheckIfNon1284_3Present(
    IN PPDO_EXTENSION    Extension
    ) ;

BOOLEAN
ParStlCheckIfStl1284_3(
    IN PPDO_EXTENSION    Extension,
    IN ULONG    ulDaisyIndex,
    IN BOOLEAN  bNoStrobe
    ) ;

BOOLEAN
ParStlCheckIfStlProductId(
    IN PPDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) ;

PCHAR
ParQueryStlDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    ) ;

PCHAR
ParBuildStlDeviceId(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN          bReturnRawString                
    ) ;

STL_DEVICE_TYPE __cdecl 
ParStlGetDeviceType (
    IN PPDO_EXTENSION    Extension,
    IN int                  nPreferredDeviceType
    ) ;

VOID
ParStlSet16BitOperation (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckDrivePresent (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN
ParStlWaitForBusyToClear (
    IN  PPDO_EXTENSION   Extension,
    IN  int                 nRegisterToWaitOn 
    ) ;

BOOLEAN
ParStlWaitForDrq (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlWaitForIrq (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfAtaAtapiDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN
ParStlAtapiInitialize ( 
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    );

BOOLEAN
ParStlAtaInitialize ( 
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfScsiDevice (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfSSFDC (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfMMC (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfFlash (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfDazzle (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfAtapiDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfLS120 (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfImpactLS120 (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfHiFD (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfAtaDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN
ParStlCheckCardInsertionStatus ( 
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlSelectAdapterSocket (
    IN  PPDO_EXTENSION   Extension,
    int     nSocketNumber
    ) ;

VOID
ParStlWaitForMicroSeconds (
    int nMicroSecondsToWait
    ) ;

STL_DEVICE_TYPE
ParStlGetImpactDeviceType (
    IN  PPDO_EXTENSION       Extension,
    IN  OUT  PATAPIPARAMS       atapiParams,
    IN  int                     nPreferredDeviceType
    ) ;

STL_DEVICE_TYPE
ParStlGetImpactSDeviceType (
    IN  PPDO_EXTENSION       Extension,
    IN  OUT  PATAPIPARAMS       atapiParams,
    IN  int                     nPreferredDeviceType
    ) ;

BOOLEAN 
ParStlCheckIfEppDevice (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckPersonalityForEppDevice (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckFlashPersonality (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlHIFDCheckIfControllerReady (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlHIFDCheckSMCController (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlIsMMCEnginePresent(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParStlAssertIdleState (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckUMAXScannerPresence(
    IN PPDO_EXTENSION    Extension
    ) ;

BOOLEAN
ParStlCheckAvisionScannerPresence(
    IN PPDO_EXTENSION    Extension
    ) ;

BOOLEAN
ParStlSetEPPMode(
    IN PPDO_EXTENSION    Extension
    ) ;

USHORT
ParStlEPPWrite(
    IN PPDO_EXTENSION    Extension,
    IN UCHAR value
    ) ;

USHORT
ParStlEPPRead(
    IN PPDO_EXTENSION
    ) ;

int __cdecl
ParStlReadReg(
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned int    reg
    ) ;

int __cdecl
ParStlWriteReg(
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned int        reg,
    IN  int                 databyte
    ) ;

int __cdecl
ParStlReadIoPort(
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned int        reg
    ) ;

int __cdecl
ParStlWriteIoPort(
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned int        reg,
    IN  int                 databyte
    ) ;

int __cdecl
ParStlReceiveData(
    IN  PPDO_EXTENSION   Extension,
    OUT void                *hostBufferPointer,
    IN  long                shuttleMemoryAddress,
    IN  unsigned            count
    ) ;

int  __cdecl
ParStlGetMemorySize (
    IN  PPDO_EXTENSION   Extension
    ) ;

#endif  // for _PARSTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\registry.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       registry.c
//
//--------------------------------------------------------------------------

#include "pch.h"

NTSTATUS
PptRegGetDeviceParameterDword(
    IN     PDEVICE_OBJECT  Pdo,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    )
/*++

Routine Description:

    retrieve a devnode registry parameter of type dword

Arguments:

    Pdo - ParPort PDO

    ParameterName - parameter name to look up

    ParameterValue - default parameter value

Return Value:

    Status - if RegKeyValue does not exist or other failure occurs,
               then default is returned via ParameterValue

--*/
{
    NTSTATUS                 status;
    HANDLE                   hKey;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    defaultValue;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(Pdo, PLUGPLAY_REGKEY_DEVICE, KEY_READ, &hKey);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    defaultValue = *ParameterValue;

    RtlZeroMemory(queryTable, sizeof(queryTable));

    queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name          = ParameterName;
    queryTable[0].EntryContext  = ParameterValue;
    queryTable[0].DefaultType   = REG_DWORD;
    queryTable[0].DefaultData   = &defaultValue;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE, hKey, queryTable, NULL, NULL);

    if ( !NT_SUCCESS(status) ) {
        *ParameterValue = defaultValue;
    }

    ZwClose(hKey);

    return status;
}

NTSTATUS
PptRegSetDeviceParameterDword(
    IN PDEVICE_OBJECT  Pdo,
    IN PWSTR           ParameterName,
    IN PULONG          ParameterValue
    )
/*++

Routine Description:

    Create/set a devnode registry parameter of type dword

Arguments:

    Pdo - ParPort PDO

    ParameterName - parameter name

    ParameterValue - parameter value

Return Value:

    Status - status from attempt

--*/
{
    NTSTATUS        status;
    HANDLE          hKey;
    UNICODE_STRING  valueName;
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(Pdo, PLUGPLAY_REGKEY_DEVICE, KEY_WRITE, &hKey);

    if( !NT_SUCCESS( status ) ) {
        DD((PCE)pdx,DDE,"PptRegSetDeviceParameterDword - openKey FAILED w/status=%x",status);
        return status;
    }

    RtlInitUnicodeString( &valueName, ParameterName );

    status = ZwSetValueKey( hKey, &valueName, 0, REG_DWORD, ParameterValue, sizeof(ULONG) );
    if( !NT_SUCCESS( status ) ) {
        DD((PCE)pdx,DDE,"PptRegSetDeviceParameterDword - setValue FAILED w/status=%x",status);
    }

    ZwClose(hKey);

    return status;
}

/************************************************************************/
/* PptRegGetDword                                                       */
/************************************************************************/
//
// Routine Description:
//
//     Read a REG_DWORD from the registry. This is a wrapper for
//       function RtlQueryRegistryValues.
//
// Arguments: 
//
//     RelativeTo     - starting point for the Path
//     Path           - path to the registry key
//     ParameterName  - name of the value to be read
//     ParameterValue - used to return the DWORD value read from the registry
//
// Return Value:                                          
//                                                            
//     NTSTATUS
//                                                        
// Notes:
//
//     - On an ERROR or if the requested registry value does not exist, 
//         *ParameterValue retains its original value.
//
// Log:
//
/************************************************************************/
NTSTATUS
PptRegGetDword(
    IN     ULONG  RelativeTo,               
    IN     PWSTR  Path,
    IN     PWSTR  ParameterName,
    IN OUT PULONG ParameterValue
    )
{
    NTSTATUS                  status;
    RTL_QUERY_REGISTRY_TABLE  paramTable[2];
    ULONG                     defaultValue;

    if( ( NULL == Path ) || ( NULL == ParameterName ) || ( NULL == ParameterValue ) ) {
        return STATUS_INVALID_PARAMETER;
    }

    DD(NULL,DDT,"PptRegGetDword - RelativeTo= %x, Path=<%S>, ParameterName=<%S>\n", RelativeTo, Path, ParameterName);

    //
    // set up table entries for call to RtlQueryRegistryValues
    //
    // leave paramTable[1] as all zeros to terminate the table
    //
    // use original value as default value
    //
    // use RtlQueryRegistryValues to do the grunge work
    //
    RtlZeroMemory( paramTable, sizeof(paramTable) );

    defaultValue = *ParameterValue;

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = ParameterName;
    paramTable[0].EntryContext  = ParameterValue;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &defaultValue;
    paramTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues( RelativeTo | RTL_REGISTRY_OPTIONAL,
                                     Path,
                                     &paramTable[0],
                                     NULL,
                                     NULL);
       
    if( status != STATUS_SUCCESS ) {
        DD(NULL,DDW,"PptRegGetDword - RtlQueryRegistryValues FAILED w/status=%x\n",status);
    }

    DD(NULL,DDT,"PptRegGetDword - post-query <%S> *ParameterValue = %x\n", ParameterName, *ParameterValue);

    return status;
}


/************************************************************************/
/* PptRegSetDword                                                       */
/************************************************************************/
//
// Routine Description:
//
//     Write a REG_DWORD to the registry. This is a wrapper for
//       function RtlWriteRegistryValue.
//
// Arguments: 
//
//     RelativeTo     - starting point for the Path
//     Path           - path to the registry key
//     ParameterName  - name of the value to write
//     ParameterValue - points to the DWORD value to write to the registry
//
// Return Value:                                          
//                                                            
//     NTSTATUS
//                                                        
// Notes:
//
// Log:
//
/************************************************************************/
NTSTATUS
PptRegSetDword(
    IN  ULONG  RelativeTo,               
    IN  PWSTR  Path,
    IN  PWSTR  ParameterName,
    IN  PULONG ParameterValue
    )
{
    NTSTATUS status;

    if( (NULL == Path) || (NULL == ParameterName) || (NULL == ParameterValue) ) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        status = RtlWriteRegistryValue( RelativeTo,
                                        Path,
                                        ParameterName,
                                        REG_DWORD,
                                        ParameterValue,
                                        sizeof(ULONG) );
    }
    return status;
}

/************************************************************************/
/* PptRegGetSz                                                          */
/************************************************************************/
//
// Routine Description:
//
//     Read a REG_SZ from the registry. This is a wrapper for
//       function RtlQueryRegistryValues.
//
// Arguments: 
//
//     RelativeTo     - starting point for the Path
//     Path           - path to the registry key
//     ParameterName  - name of the value to be read
//     ParameterValue - points to a UNICODE_STRING structure used to return 
//                        the REG_SZ read from the registry
//
// Return Value:                                          
//                                                            
//     NTSTATUS
//                                                        
//
// Notes:
//
//     - All fields of *ParameterValue UNICODE_STRING structure must be 
//         initialized to zero by the caller.
//     - On SUCCESS ParameterValue->Buffer points to an allocated buffer. The
//         caller is responsible for freeing this buffer when done.
//     - On SUCCESS ParameterValue->Buffer is UNICODE_NULL terminated and is
//         safe to use as a PWSTR.
//
// Log:
//
/************************************************************************/
NTSTATUS
PptRegGetSz(
    IN      ULONG  RelativeTo,               
    IN      PWSTR  Path,
    IN      PWSTR  ParameterName,
    IN OUT  PUNICODE_STRING ParameterValue
    )
{
    NTSTATUS                  status;
    RTL_QUERY_REGISTRY_TABLE  paramTable[2];

    //
    // sanity check parameters - reject NULL pointers and invalid
    //   UNICODE_STRING field initializations
    //
    if( ( NULL == Path ) || ( NULL == ParameterName ) || ( NULL == ParameterValue ) ) {
        return STATUS_INVALID_PARAMETER;
    }
    if( (ParameterValue->Length != 0) || (ParameterValue->MaximumLength !=0) || (ParameterValue->Buffer != NULL) ) {
        return STATUS_INVALID_PARAMETER;
    }

    DD(NULL,DDT,"PptRegGetSz - RelativeTo=%x, Path=<%S>, ParameterName=<%S>\n", RelativeTo, Path, ParameterName);

    //
    // set up table entries for call to RtlQueryRegistryValues
    //
    // leave paramTable[1] as all zeros to terminate the table
    //
    // use RtlQueryRegistryValues to do the grunge work
    //
    RtlZeroMemory( paramTable, sizeof(paramTable) );

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = ParameterName;
    paramTable[0].EntryContext  = ParameterValue;
    paramTable[0].DefaultType   = REG_SZ;
    paramTable[0].DefaultData   = L"";
    paramTable[0].DefaultLength = 0;

    status = RtlQueryRegistryValues( RelativeTo | RTL_REGISTRY_OPTIONAL,
                                     Path,
                                     &paramTable[0],
                                     NULL,
                                     NULL);
       
    if( status != STATUS_SUCCESS ) {
        DD(NULL,DDW,"PptRegGetSz - RtlQueryRegistryValues FAILED w/status=%x\n",status);
    }

    //
    // Try to make ParameterValue->Buffer safe to use as a PWSTR parameter. 
    //   Clean up the allocation and fail this request if we are unable to do so.
    //
    if( (STATUS_SUCCESS == status) && (ParameterValue->Buffer != NULL) ) {

        if( ParameterValue->MaximumLength >= (ParameterValue->Length + sizeof(WCHAR)) ) {

            (ParameterValue->Buffer)[ ParameterValue->Length / sizeof(WCHAR) ] = UNICODE_NULL;
            DD(NULL,DDT,"PptRegGetSz - post-query *ParameterValue=<%S>\n", ParameterValue->Buffer);

        } else {

            ExFreePool( ParameterValue->Buffer );
            ParameterValue->Length        = 0;
            ParameterValue->MaximumLength = 0;
            ParameterValue->Buffer        = 0;
            status = STATUS_UNSUCCESSFUL;

        }
    }

    return status;
}

/************************************************************************/
/* PptRegSetSz                                                          */
/************************************************************************/
//
// Routine Description:
//
//     Write a REG_SZ to the registry. This is a wrapper for
//       function RtlWriteRegistryValue.
//
// Arguments: 
//
//     RelativeTo     - starting point for the Path
//     Path           - path to the registry key
//     ParameterName  - name of the value to write
//     ParameterValue - points to the PWSTR to write to the registry
//
// Return Value:                                          
//                                                            
//     NTSTATUS
//                                                        
// Notes:
//
// Log:
//
/************************************************************************/
NTSTATUS
PptRegSetSz(
    IN  ULONG  RelativeTo,               
    IN  PWSTR  Path,
    IN  PWSTR  ParameterName,
    IN  PWSTR  ParameterValue
    )
{
    NTSTATUS status;

    if( (NULL == Path) || (NULL == ParameterName) || (NULL == ParameterValue) ) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        status = RtlWriteRegistryValue( RelativeTo,
                                        Path,
                                        ParameterName,
                                        REG_SZ,
                                        ParameterValue,
                                        ( wcslen(ParameterValue) + 1 ) * sizeof(WCHAR) );
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\spp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    spp.c

Abstract:

    This module contains the code for standard parallel ports
    (centronics mode).

Author:

    Anthony V. Ercolano 1-Aug-1992
    Norbert P. Kusters 22-Oct-1993

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

ULONG
SppWriteLoopPI(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite,
    IN  ULONG   BusyDelay
    );
    
ULONG
SppCheckBusyDelay(
    IN  PPDO_EXTENSION   Pdx,
    IN  PUCHAR              WriteBuffer,
    IN  ULONG               NumBytesToWrite
    );

NTSTATUS
ParEnterSppMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )
{
    UNREFERENCED_PARAMETER( DeviceIdRequest );

    DD((PCE)Pdx,DDT,"ParEnterSppMode: Enter!\n");

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    Pdx->Connected = TRUE;	
    return STATUS_SUCCESS;
}

ULONG
SppWriteLoopPI(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite,
    IN  ULONG   BusyDelay
    )

/*++

Routine Description:

    This routine outputs the given write buffer to the parallel port
    using the standard centronics protocol.

Arguments:

    Controller  - Supplies the base address of the parallel port.

    WriteBuffer - Supplies the buffer to write to the port.

    NumBytesToWrite - Supplies the number of bytes to write out to the port.

    BusyDelay   - Supplies the number of microseconds to delay before
                    checking the busy bit.

Return Value:

    The number of bytes successfully written out to the parallel port.

--*/

{
    ULONG   i;
    UCHAR   DeviceStatus;
    BOOLEAN atPassiveIrql = FALSE;

    if( KeGetCurrentIrql() == PASSIVE_LEVEL ) {
        atPassiveIrql = TRUE;
    }

    if (!BusyDelay) {
        BusyDelay = 1;
    }

    for (i = 0; i < NumBytesToWrite; i++) {

        DeviceStatus = GetStatus(Controller);

        if (PAR_ONLINE(DeviceStatus)) {

            //
            // Anytime we write out a character we will restart
            // the count down timer.
            //

            P5WritePortUchar(Controller + PARALLEL_DATA_OFFSET, *WriteBuffer++);

            KeStallExecutionProcessor(1);

            StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                      PAR_CONTROL_SLIN |
                                      PAR_CONTROL_NOT_INIT |
                                      PAR_CONTROL_STROBE));

            KeStallExecutionProcessor(1);

            StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                      PAR_CONTROL_SLIN |
                                      PAR_CONTROL_NOT_INIT));

            KeStallExecutionProcessor(BusyDelay);

        } else {
            DD(NULL,DDT,"spp::SppWriteLoopPI - DeviceStatus = %x - NOT ONLINE\n", DeviceStatus);
            break;
        }
    }

    DD(NULL,DDT,"SppWriteLoopPI - exit - bytes written = %ld\n",i);

    return i;
}

ULONG
SppCheckBusyDelay(
    IN  PPDO_EXTENSION   Pdx,
    IN  PUCHAR              WriteBuffer,
    IN  ULONG               NumBytesToWrite
    )

/*++

Routine Description:

    This routine determines if the current busy delay setting is
    adequate for this printer.

Arguments:

    Pdx       - Supplies the device extension.

    WriteBuffer     - Supplies the write buffer.

    NumBytesToWrite - Supplies the size of the write buffer.

Return Value:

    The number of bytes strobed out to the printer.

--*/

{
    PUCHAR          Controller;
    ULONG           BusyDelay;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   PerfFreq;
    LARGE_INTEGER   End;
    LARGE_INTEGER   GetStatusTime;
    LARGE_INTEGER   CallOverhead;
    UCHAR           DeviceStatus;
    ULONG           i;
    ULONG           NumberOfCalls;
    ULONG           maxTries;
    KIRQL           OldIrql = PASSIVE_LEVEL;

    UNREFERENCED_PARAMETER( NumBytesToWrite );

    Controller = Pdx->Controller;
    BusyDelay  = Pdx->BusyDelay;
    
    // If the current busy delay value is 10 or greater then something
    // is weird and settle for 10.

    if (Pdx->BusyDelay >= 10) {
        Pdx->BusyDelayDetermined = TRUE;
        return 0;
    }

    // Take some performance measurements.

    if (0 == SppNoRaiseIrql)
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    Start = KeQueryPerformanceCounter(&PerfFreq);
    
    DeviceStatus = GetStatus(Controller);
    
    End = KeQueryPerformanceCounter(&PerfFreq);
    
    GetStatusTime.QuadPart = End.QuadPart - Start.QuadPart;

    Start = KeQueryPerformanceCounter(&PerfFreq);
    End   = KeQueryPerformanceCounter(&PerfFreq);
    
    if (0 == SppNoRaiseIrql)
        KeLowerIrql(OldIrql);

    CallOverhead.QuadPart = End.QuadPart - Start.QuadPart;
    
    GetStatusTime.QuadPart -= CallOverhead.QuadPart;
    
    if (GetStatusTime.QuadPart <= 0) {
        GetStatusTime.QuadPart = 1;
    }

    // Figure out how many calls to 'GetStatus' can be made in 20 us.

    NumberOfCalls = (ULONG) (PerfFreq.QuadPart*20/GetStatusTime.QuadPart/1000000) + 1;

    //
    // - check to make sure the device is ready to receive a byte before we start clocking
    //    data out
    // 
    // DVDF - 25Jan99 - added check
    // 

    //
    // - nothing magic about 25 - just catch the case where NumberOfCalls may be bogus
    //    and try something reasonable - empirically NumberOfCalls has ranged from 8-24
    //
    maxTries = (NumberOfCalls > 25) ? 25 : NumberOfCalls;

    for( i = 0 ; i < maxTries ; i++ ) {
        // spin for slow device to get ready to receive data - roughly 20us max
        DeviceStatus = GetStatus( Controller );
        if( PAR_ONLINE( DeviceStatus ) ) {
            // break out of loop as soon as device is ready
            break;
        }
    }
    if( !PAR_ONLINE( DeviceStatus ) ) {
        // device is still not online - bail out
        return 0;
    }

    // The printer is ready to accept a byte.  Strobe one out
    // and check out the reaction time for BUSY.

    if (BusyDelay) {

        if (0 == SppNoRaiseIrql)
            KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

        P5WritePortUchar(Controller + PARALLEL_DATA_OFFSET, *WriteBuffer++);
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT |
                                  PAR_CONTROL_STROBE));
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT));
        KeStallExecutionProcessor(BusyDelay);

        for (i = 0; i < NumberOfCalls; i++) {
            DeviceStatus = GetStatus(Controller);
            if (!(DeviceStatus & PAR_STATUS_NOT_BUSY)) {
                break;
            }
        }

        if (0 == SppNoRaiseIrql)
            KeLowerIrql(OldIrql);

    } else {

        if (0 == SppNoRaiseIrql)
            KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

        P5WritePortUchar(Controller + PARALLEL_DATA_OFFSET, *WriteBuffer++);
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT |
                                  PAR_CONTROL_STROBE));
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT));

        for (i = 0; i < NumberOfCalls; i++) {
            DeviceStatus = GetStatus(Controller);
            if (!(DeviceStatus & PAR_STATUS_NOT_BUSY)) {
                break;
            }
        }

        if (0 == SppNoRaiseIrql)
            KeLowerIrql(OldIrql);
    }

    if (i == 0) {

        // In this case the BUSY was set as soon as we checked it.
        // Use this busyDelay with the PI code.

        Pdx->UsePIWriteLoop = TRUE;
        Pdx->BusyDelayDetermined = TRUE;

    } else if (i == NumberOfCalls) {

        // In this case the BUSY was never seen.  This is a very fast
        // printer so use the fastest code possible.

        Pdx->BusyDelayDetermined = TRUE;

    } else {

        // The test failed.  The lines showed not BUSY and then BUSY
        // without strobing a byte in between.

        Pdx->UsePIWriteLoop = TRUE;
        Pdx->BusyDelay++;
    }

    return 1;
}

NTSTATUS
SppWrite(
    IN  PPDO_EXTENSION Pdx,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    )

/*++

Routine Description:

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS            status;
    UCHAR               DeviceStatus;
    ULONG               TimerStart;
    LONG                CountDown;
    PUCHAR              IrpBuffer;
    LARGE_INTEGER       StartOfSpin;
    LARGE_INTEGER       NextQuery;
    LARGE_INTEGER       Difference;
    BOOLEAN             DoDelays;
    BOOLEAN             PortFree;
    ULONG               NumBytesWritten; 
    ULONG               LoopNumber;
    ULONG               NumberOfBusyChecks;
    ULONG               MaxBusyDelay;
    ULONG               MaxBytes;
    
    DD((PCE)Pdx,DDT,"SppWrite - enter, BytesToWrite = %d\n",BytesToWrite);

    *BytesTransferred = 0; // initialize to none

    IrpBuffer  = (PUCHAR)Buffer;
    MaxBytes   = BytesToWrite;
    TimerStart = Pdx->TimerStart;
    CountDown  = (LONG)TimerStart;
    
    NumberOfBusyChecks = 9;
    MaxBusyDelay = 0;
    
    // Turn off the strobe in case it was left on by some other device sharing the port.
    StoreControl(Pdx->Controller, (PAR_CONTROL_WR_CONTROL |
                                         PAR_CONTROL_SLIN |
                                         PAR_CONTROL_NOT_INIT));

PushSomeBytes:

    //
    // While we are strobing data we don't want to get context
    // switched away.  Raise up to dispatch level to prevent that.
    //
    // The reason we can't afford the context switch is that
    // the device can't have the data strobe line on for more
    // than 500 microseconds.
    //
    // We never want to be at raised irql form more than
    // 200 microseconds, so we will do no more than 100
    // bytes at a time.
    //

    LoopNumber = 512;
    if (LoopNumber > BytesToWrite) {
        LoopNumber = BytesToWrite;
    }

    //
    // Enter the write loop
    //
    
    if (!Pdx->BusyDelayDetermined) {
        DD((PCE)Pdx,DDT,"SppWrite: Calling SppCheckBusyDelay\n");
        NumBytesWritten = SppCheckBusyDelay(Pdx, IrpBuffer, LoopNumber);
        
        if (Pdx->BusyDelayDetermined) {
        
            if (Pdx->BusyDelay > MaxBusyDelay) {
                MaxBusyDelay = Pdx->BusyDelay;
                NumberOfBusyChecks = 10;
            }
            
            if (NumberOfBusyChecks) {
                NumberOfBusyChecks--;
                Pdx->BusyDelayDetermined = FALSE;
                
            } else {
            
                Pdx->BusyDelay = MaxBusyDelay + 1;
            }
        }
        
    } else if( Pdx->UsePIWriteLoop ) {
        NumBytesWritten = SppWriteLoopPI( Pdx->Controller, IrpBuffer, LoopNumber, Pdx->BusyDelay );
    } else {
        NumBytesWritten = SppWriteLoopPI( Pdx->Controller, IrpBuffer, LoopNumber, 1 );
    }


    if (NumBytesWritten) {
    
        CountDown     = TimerStart;
        IrpBuffer    += NumBytesWritten;
        BytesToWrite -= NumBytesWritten;
        
    }

    //
    // Check to see if the io is done.  If it is then call the
    // code to complete the request.
    //

    if (!BytesToWrite) {
    
        *BytesTransferred = MaxBytes;

        status = STATUS_SUCCESS;
        goto returnTarget;

    } else if ((Pdx->CurrentOpIrp)->Cancel) {

        //
        // See if the IO has been canceled.  The cancel routine
        // has been removed already (when this became the
        // current irp).  Simply check the bit.  We don't even
        // need to capture the lock.   If we miss a round
        // it won't be that bad.
        //

        *BytesTransferred = MaxBytes - BytesToWrite;

        status = STATUS_CANCELLED;
        goto returnTarget;

    } else {

        //
        // We've taken care of the reasons that the irp "itself"
        // might want to be completed.
        // printer to see if it is in a state that might
        // cause us to complete the irp.
        //
        // First let's check if the device status is
        // ok and online.  If it is then simply go back
        // to the byte pusher.
        //


        DeviceStatus = GetStatus(Pdx->Controller);

        if (PAR_ONLINE(DeviceStatus)) {
            goto PushSomeBytes;
        }

        //
        // Perhaps the operator took the device off line,
        // or forgot to put in enough paper.  If so, then
        // let's hang out here for the until the timeout
        // period has expired waiting for them to make things
        // all better.
        //

        if (PAR_PAPER_EMPTY(DeviceStatus) ||
            PAR_OFF_LINE(DeviceStatus)) {

            if (CountDown > 0) {

                //
                // We'll wait 1 second increments.
                //

                DD((PCE)Pdx,DDT,"decrementing countdown for PAPER_EMPTY/OFF_LINE - countDown: %d status: 0x%x\n", CountDown, DeviceStatus);
                    
                CountDown--;

                // If anyone is waiting for the port then let them have it,
                // since the printer is busy.

                ParFreePort(Pdx);

                KeDelayExecutionThread(
                    KernelMode,
                    FALSE,
                    &Pdx->OneSecond
                    );

                if (!ParAllocPort(Pdx)) {
                
                    *BytesTransferred = MaxBytes - BytesToWrite;

                    DD((PCE)Pdx,DDT,"In SppWrite(...): returning STATUS_DEVICE_BUSY\n");
                    
                    status = STATUS_DEVICE_BUSY;
                    goto returnTarget;
                }

                goto PushSomeBytes;

            } else {

                //
                // Timer has expired.  Complete the request.
                //

                *BytesTransferred = MaxBytes - BytesToWrite;
                                                
                DD((PCE)Pdx,DDT,"In SppWrite(...): Timer expired - DeviceStatus = %08x\n", DeviceStatus);

                if (PAR_OFF_LINE(DeviceStatus)) {

                    DD((PCE)Pdx,DDT,"In SppWrite(...): returning STATUS_DEVICE_OFF_LINE\n");

                    status = STATUS_DEVICE_OFF_LINE;
                    goto returnTarget;
                    
                } else if (PAR_NO_CABLE(DeviceStatus)) {

                    DD((PCE)Pdx,DDT,"In SppWrite(...): returning STATUS_DEVICE_NOT_CONNECTED\n");

                    status = STATUS_DEVICE_NOT_CONNECTED;
                    goto returnTarget;

                } else {

                    DD((PCE)Pdx,DDT,"In SppWrite(...): returning STATUS_DEVICE_PAPER_EMPTY\n");

                    status = STATUS_DEVICE_PAPER_EMPTY;
                    goto returnTarget;

                }
            }


        } else if (PAR_POWERED_OFF(DeviceStatus) ||
                   PAR_NOT_CONNECTED(DeviceStatus) ||
                   PAR_NO_CABLE(DeviceStatus)) {

            //
            // We are in a "bad" state.  Is what
            // happened to the printer (power off, not connected, or
            // the cable being pulled) something that will require us
            // to reinitialize the printer?  If we need to
            // reinitialize the printer then we should complete
            // this IO so that the driving application can
            // choose what is the best thing to do about it's
            // io.
            //

            DD((PCE)Pdx,DDT,"In SppWrite(...): \"bad\" state - need to reinitialize printer?");

            *BytesTransferred = MaxBytes - BytesToWrite;
                        
            if (PAR_POWERED_OFF(DeviceStatus)) {

                DD((PCE)Pdx,DDT,"SppWrite: returning STATUS_DEVICE_POWERED_OFF\n");

                status = STATUS_DEVICE_POWERED_OFF;
                goto returnTarget;
                
            } else if (PAR_NOT_CONNECTED(DeviceStatus) ||
                       PAR_NO_CABLE(DeviceStatus)) {

                DD((PCE)Pdx,DDT,"SppWrite: STATUS_DEVICE_NOT_CONNECTED\n");

                status = STATUS_DEVICE_NOT_CONNECTED;
                goto returnTarget;

            }
        }

        //
        // The device could simply be busy at this point.  Simply spin
        // here waiting for the device to be in a state that we
        // care about.
        //
        // As we spin, get the system ticks.  Every time that it looks
        // like a second has passed, decrement the countdown.  If
        // it ever goes to zero, then timeout the request.
        //

        KeQueryTickCount(&StartOfSpin);
        DoDelays = FALSE;
        
        do {

            //
            // After about a second of spinning, let the rest of the
            // machine have time for a second.
            //

            if (DoDelays) {

                ParFreePort(Pdx);
                PortFree = TRUE;

                DD((PCE)Pdx,DDT,"Before delay thread of one second, dsr=%x DCR[%x]\n",
                        P5ReadPortUchar(Pdx->Controller + OFFSET_DSR),
                        P5ReadPortUchar(Pdx->Controller + OFFSET_DCR));
                KeDelayExecutionThread(KernelMode, FALSE, &Pdx->OneSecond);

                DD((PCE)Pdx,DDT,"Did delay thread of one second, CountDown=%d\n", CountDown);

                CountDown--;

            } else {

                if (Pdx->QueryNumWaiters(Pdx->PortContext)) {
                
                    ParFreePort(Pdx);
                    PortFree = TRUE;
                    
                } else {
                
                    PortFree = FALSE;
                }

                KeQueryTickCount(&NextQuery);

                Difference.QuadPart = NextQuery.QuadPart - StartOfSpin.QuadPart;

                if (Difference.QuadPart*KeQueryTimeIncrement() >=
                    Pdx->AbsoluteOneSecond.QuadPart) {

                    DD((PCE)Pdx,DDT,"Countdown: %d - device Status: %x lowpart: %x highpart: %x\n",
                            CountDown, DeviceStatus, Difference.LowPart, Difference.HighPart);
                    
                    CountDown--;
                    DoDelays = TRUE;

                }
            }

            if (CountDown <= 0) {
            
                *BytesTransferred = MaxBytes - BytesToWrite;
                status = STATUS_DEVICE_BUSY;
                goto returnTarget;

            }

            if (PortFree && !ParAllocPort(Pdx)) {
            
                *BytesTransferred = MaxBytes - BytesToWrite;
                status = STATUS_DEVICE_BUSY;
                goto returnTarget;
            }

            DeviceStatus = GetStatus(Pdx->Controller);

        } while ((!PAR_ONLINE(DeviceStatus)) &&
                 (!PAR_PAPER_EMPTY(DeviceStatus)) &&
                 (!PAR_POWERED_OFF(DeviceStatus)) &&
                 (!PAR_NOT_CONNECTED(DeviceStatus)) &&
                 (!PAR_NO_CABLE(DeviceStatus)) &&
                  !(Pdx->CurrentOpIrp)->Cancel);

        if (CountDown != (LONG)TimerStart) {

            DD((PCE)Pdx,DDT,"Leaving busy loop - countdown %d status %x\n", CountDown, DeviceStatus);

        }
        
        goto PushSomeBytes;

    }

returnTarget:
    // added single return point so we can save log of bytes transferred
    Pdx->log.SppWriteCount += *BytesTransferred;

    DD((PCE)Pdx,DDT,"SppWrite - exit, BytesTransferred = %d\n",*BytesTransferred);

    return status;

}

NTSTATUS
SppQueryDeviceId(
    IN   PPDO_EXTENSION  Pdx,
    OUT  PCHAR           DeviceIdBuffer,
    IN   ULONG           BufferSize,
    OUT  PULONG          DeviceIdSize,
    IN   BOOLEAN         bReturnRawString
    )
/*++

Routine Description:

    This routine is now a wrapper function around Par3QueryDeviceId that
      preserves the interface of the original SppQueryDeviceId function.

    Clients of this function should consider switching to Par3QueryDeviceId
      if possible because Par3QueryDeviceId will allocate and return a pointer
      to a buffer if the caller supplied buffer is too small to hold the 
      device ID.
    
Arguments:

    Pdx         - DeviceExtension/Legacy - used to get controller.
    DeviceIdBuffer    - Buffer used to return ID.
    BufferSize        - Size of supplied buffer.
    DeviceIdSize      - Size of returned ID.
    bReturnRawString  - Should the 2 byte size prefix be included? (TRUE==Yes)

Return Value:

    STATUS_SUCCESS          - ID query was successful
    STATUS_BUFFER_TOO_SMALL - We were able to read an ID from the device but the caller
                                supplied buffer was not large enough to hold the ID. The
                                size required to hold the ID is returned in DeviceIdSize.
    STATUS_UNSUCCESSFUL     - ID query failed - Possibly interface or device is hung, missed
                                timeouts during the handshake, or device may not be connected.

--*/
{
    PCHAR idBuffer;

    DD((PCE)Pdx,DDT,"spp::SppQueryDeviceId: Enter - buffersize=%d\n", BufferSize);
    if ( Pdx->Ieee1284Flags & ( 1 << Pdx->Ieee1284_3DeviceId ) ) {
        idBuffer = Par3QueryDeviceId( Pdx, DeviceIdBuffer, BufferSize, DeviceIdSize, bReturnRawString, TRUE );
    }
    else {
        idBuffer = Par3QueryDeviceId( Pdx, DeviceIdBuffer, BufferSize, DeviceIdSize, bReturnRawString, FALSE );
    }

    if( idBuffer == NULL ) {
        //
        // Error at lower level - FAIL query
        //
        DD((PCE)Pdx,DDT,"spp::SppQueryDeviceId: call to Par3QueryDeviceId hard FAIL\n");
        return STATUS_UNSUCCESSFUL;
    } else if( idBuffer != DeviceIdBuffer ) {
        //
        // We got a deviceId from the device, but caller's buffer was too small to hold it.
        //   Free the buffer and tell the caller that the supplied buffer was too small.
        //
        DD((PCE)Pdx,DDT,"spp::SppQueryDeviceId: buffer too small - have buffer size=%d, need buffer size=%d\n", BufferSize, *DeviceIdSize);
        ExFreePool( idBuffer );
        return STATUS_BUFFER_TOO_SMALL;
    } else {
        //
        // Query succeeded using caller's buffer (idBuffer == DeviceIdBuffer)
        //
        DD((PCE)Pdx,DDT,"spp::SppQueryDeviceId: SUCCESS - deviceId=<%s>\n", idBuffer);
        return STATUS_SUCCESS;
    }
}

VOID
ParTerminateSppMode(
    IN  PPDO_EXTENSION   Pdx
    )
{
    DD((PCE)Pdx,DDT,"ParTerminateSppMode\n");
    Pdx->Connected    = FALSE;
    P5SetPhase( Pdx, PHASE_TERMINATE );
    return;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\shuttle.c ===
/*++

Copyright (C) SCM Micro Systems.

Module Name:

    parstl.c

Abstract:

    This is the module that generates unique device id
    for shuttle adapters, that do not have the capability
    to do so, by themselves.

Author:

    Devanathan NR   21-Jun-1999
    Sudheendran TL

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"
#include "shuttle.h"

BOOLEAN
ParStlCheckIfStl(
    IN PPDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) 
/*++

Routine Description:

    This function checks whether the indicated device
    is a shuttle device or not.

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy index on which to do the check.

Return Value:

    TRUE            - Yes, it was a Shuttle device.
    FALSE           - No, not a shuttle.

--*/
{
    BOOLEAN     bStlNon1284_3Found = FALSE ;

    DD(NULL,DDW,"ParStlCheckIfStl - enter\n");

    Extension->Ieee1284Flags &= ( ~ ( 1 << ulDaisyIndex ) ) ;
    bStlNon1284_3Found = ParStlCheckIfNon1284_3Present( Extension ) ;

    if ( TRUE == ParStlCheckIfStl1284_3 ( Extension, ulDaisyIndex, bStlNon1284_3Found ) ) {
        // this adapter is a Shuttle 1284_3 adapter
        Extension->Ieee1284Flags |= ( 1 << ulDaisyIndex ) ;
        return TRUE ;
    }
    if ( TRUE == bStlNon1284_3Found ) {
        if ( TRUE == ParStlCheckIfStlProductId ( Extension, ulDaisyIndex ) ) {
            // this adapter is Shuttle non-1284_3 adapter
            Extension->Ieee1284Flags |= ( 1 << ulDaisyIndex ) ;
            return TRUE ;
        }
    }
    return FALSE ;
}

BOOLEAN
ParStlCheckIfNon1284_3Present(
    IN PPDO_EXTENSION    Extension
    )
/*++

Routine Description:

    Indicates whether one of the devices of the earlier
    specification is present in the chain.


Arguments:

    Extension   - Device Extension structure


Return Value:

    TRUE    : Atleast one of the adapters are of earlier spec.
    FALSE   : None of the adapters of the earlier spec.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;
    UCHAR   ucAckStatus ;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        ucAckStatus = status & 0x40 ;

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            if ( ucAckStatus != ( status & 0x40 ) ) {

                // save current ack status
                ucAckStatus = status & 0x40 ;

                // continue with sixth byte
                P5WritePortUchar( CurrentPort, ModeQualifier[5] );
                KeStallExecutionProcessor( Delay );

                // check for correct status
                status = P5ReadPortUchar( CurrentStatus );

                // if status is valid there is a device out there responding
                if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {        

                    bReturnValue = TRUE ;

                } // Third status

            } // ack of earlier adapters not seen

            // last byte
            P5WritePortUchar( CurrentPort, ModeQualifier[6] );

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    DD(NULL,DDW,"ParStlCheckIfNon1284_3Present - returning %s\n",bReturnValue?"TRUE":"FALSE");

    return bReturnValue ;
} // ParStlCheckIfNon1284_3Present

BOOLEAN
ParStlCheckIfStl1284_3(
    IN PPDO_EXTENSION    Extension,
    IN ULONG    ulDaisyIndex,
    IN BOOLEAN  bNoStrobe
    )
/*++

Routine Description:

    This function checks to see whether the device indicated
    is a Shuttle 1284_3 type of device. 

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy chain id of the device that
                      this function will check on.

    bNoStrobe       - If set, indicates that the query
                      Ep1284 command issued by this function
                      need not assert strobe to latch the
                      command.

Return Value:

    TRUE            - Yes. Device is Shuttle 1284_3 type of device.
    FALSE           - No. This may mean that this device is either
                      non-shuttle or Shuttle non-1284_3 type of
                      device.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    UCHAR   ucExpectedPattern ;
    UCHAR   ucReadValue, ucReadPattern;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = P5ReadPortUchar( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {        

                // Device is out there
                KeStallExecutionProcessor( Delay );

                // issue shuttle specific CPP command
                P5WritePortUchar( CurrentPort, (UCHAR) ( 0x88 | ulDaisyIndex ) );
                KeStallExecutionProcessor( Delay );        // wait a bit

                if ( ulDaisyIndex && ( bNoStrobe == FALSE ) ) {

                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    KeStallExecutionProcessor( Delay );        // wait a bit

                }

                ucExpectedPattern = 0xF0 ;
                bReturnValue = TRUE ;

                while ( ucExpectedPattern ) {

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentPort, (UCHAR) (0x80 | ulDaisyIndex )) ;

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentPort, (UCHAR) (0x88 | ulDaisyIndex )) ;

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    ucReadValue = P5ReadPortUchar( CurrentStatus ) ;
                    ucReadPattern = ( ucReadValue << 1 ) & 0x70 ;
                    ucReadPattern |= ( ucReadValue & 0x80 ) ;

                    if ( ucReadPattern != ucExpectedPattern ) {
                        // not Shuttle 1284_3 behaviour
                        bReturnValue = FALSE ;
                        break ;
                    }

                    ucExpectedPattern -= 0x10 ;
                }


                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

            } // Third status

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    DD(NULL,DDW,"ParStlCheckIfStl1284_3 - returning %s\n",bReturnValue?"TRUE":"FALSE");

    return bReturnValue ;
} // end  ParStlCheckIfStl1284_3()

BOOLEAN
ParStlCheckIfStlProductId(
    IN PPDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    )
/*++

Routine Description:

    This function checks to see whether the device indicated
    is a Shuttle non-1284_3 type of device. 

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy chain id of the device that
                      this function will check on.

Return Value:

    TRUE            - Yes. Device is Shuttle non-1284_3 type of device.
    FALSE           - No. This may mean that this device is 
                      non-shuttle.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    UCHAR   ucProdIdHiByteHiNibble, ucProdIdHiByteLoNibble ;
    UCHAR   ucProdIdLoByteHiNibble, ucProdIdLoByteLoNibble ;
    UCHAR   ucProdIdHiByte, ucProdIdLoByte ;
    USHORT  usProdId ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = P5ReadPortUchar( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {

                P5WritePortUchar ( CurrentPort, (UCHAR) (CPP_QUERY_PRODID | ulDaisyIndex )) ;
                KeStallExecutionProcessor( Delay );

                // Device is out there
                KeStallExecutionProcessor( Delay );
                ucProdIdLoByteHiNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdLoByteHiNibble &= 0xF0 ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdLoByteLoNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdLoByteLoNibble >>= 4 ;
                ucProdIdLoByte = ucProdIdLoByteHiNibble | ucProdIdLoByteLoNibble ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdHiByteHiNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdHiByteHiNibble &= 0xF0 ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdHiByteLoNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdHiByteLoNibble >>= 4 ;
                ucProdIdHiByte = ucProdIdHiByteHiNibble | ucProdIdHiByteLoNibble ;

                // last strobe
                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                usProdId = ( ucProdIdHiByte << 8 ) | ucProdIdLoByte ;

                if ( ( SHTL_EPAT_PRODID == usProdId ) ||\
                     ( SHTL_EPST_PRODID == usProdId ) ) {
                    // one of the devices that conform to the earlier
                    // draft is found
                    bReturnValue = TRUE ;
                }

                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

            } // Third status

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    DD(NULL,DDW,"ParStlCheckIfStlProductId - returning %s\n",bReturnValue?"TRUE":"FALSE");

    return bReturnValue ;
} // end  ParStlCheckIfStlProductId()

PCHAR
ParStlQueryStlDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer,
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    )
/*++

Routine Description:

    This routine retrieves/constructs the unique device id
    string from the selected shuttle device on the chain
    and updates the caller's buffer with the same.

Arguments:

    IN  Extension               : The device extension
    OUT CallerDeviceIdBuffer    : Caller's buffer
    IN  CallerBufferSize        : Size of caller's buffer
    OUT DeviceIdSize            : Updated device id's size
    IN  bReturnRawString        : Whether to return raw
                                  string with the first two
                                  bytes or not.

Return Value:

    Pointer to the read device ID string, if successful.

    NULL otherwise.

--*/
{
    PUCHAR              Controller = Extension->Controller;
    NTSTATUS            Status;
    UCHAR               idSizeBuffer[2];
    ULONG               bytesToRead;
    ULONG               bytesRead = 0;
    USHORT              deviceIdSize;
    USHORT              deviceIdBufferSize;
    PCHAR               deviceIdBuffer;
    PCHAR               readPtr;

    DD(NULL,DDW,"ParStlQueryStlDeviceId - enter\n");

    *DeviceIdSize = 0;

    // assert idle state, to recover from undefined state,
    // just in case it gets into
    ParStlAssertIdleState ( Extension ) ;

    //
    // If we are currently connected to the peripheral via any 1284 mode
    //   other than Compatibility/Spp mode (which does not require an IEEE
    //   negotiation), we must first terminate the current mode/connection.
    // 
    // dvdf - RMT - what if we are connected in a reverse mode?
    //
    if( (Extension->Connected) && (afpForward[Extension->IdxForwardProtocol].fnDisconnect) ) {
        afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
    }

    //
    // Negotiate the peripheral into nibble device id mode.
    //
    Status = ParEnterNibbleMode(Extension, REQUEST_DEVICE_ID);
    if( !NT_SUCCESS(Status) ) {
        ParTerminateNibbleMode(Extension);
        goto targetContinue;
    }
    
    
    //
    // Read first two bytes to get the total (including the 2 size bytes) size 
    //   of the Device Id string.
    //
    bytesToRead = 2;
    Status = ParNibbleModeRead(Extension, idSizeBuffer, bytesToRead, &bytesRead);
    if( !NT_SUCCESS( Status ) || ( bytesRead != bytesToRead ) ) {
        goto targetContinue;
    }
    
    
    //
    // Compute size of DeviceId string (including the 2 byte size prefix)
    //
    deviceIdSize = (USHORT)( idSizeBuffer[0]*0x100 + idSizeBuffer[1] );
    
    {
        const USHORT minValidDevId    =   14; // 2 size bytes + "MFG:x;" + "MDL:y;"
        const USHORT maxValidDevId    = 2048; // arbitrary, but we've never seen one > 1024
        
        if( (deviceIdSize < minValidDevId) || (deviceIdSize > maxValidDevId) ) {
            //
            // The device is reporting a 1284 ID string length that is probably bogus.
            //   Ignore the device reported ID and skip to the code below that makes
            //   up a VID/PID based 1284 ID based on the specific SCM Micro chip used
            //   by the device.
            //
            goto targetContinue; 
        }
    }
    
    //
    // Allocate a buffer to hold the DeviceId string and read the DeviceId into it.
    //
    if( bReturnRawString ) {
        //
        // Caller wants the raw string including the 2 size bytes
        //
        *DeviceIdSize      = deviceIdSize;
        deviceIdBufferSize = (USHORT)(deviceIdSize + sizeof(CHAR));     // ID size + ID + terminating NULL
    } else {
        //
        // Caller does not want the 2 byte size prefix
        //
        *DeviceIdSize      = deviceIdSize - 2*sizeof(CHAR);
        deviceIdBufferSize = (USHORT)(deviceIdSize - 2*sizeof(CHAR) + sizeof(CHAR)); //           ID + terminating NULL
    }
    
    deviceIdBuffer = (PCHAR)ExAllocatePool(PagedPool, deviceIdBufferSize);
    if( !deviceIdBuffer ) {
        goto targetContinue;
    }


    //
    // NULL out the ID buffer to be safe
    //
    RtlZeroMemory( deviceIdBuffer, deviceIdBufferSize );
    
    
    //
    // Does the caller want the 2 byte size prefix?
    //
    if( bReturnRawString ) {
        //
        // Yes, caller wants the size prefix. Copy prefix to buffer to return.
        //
        *(deviceIdBuffer+0) = idSizeBuffer[0];
        *(deviceIdBuffer+1) = idSizeBuffer[1];
        readPtr = deviceIdBuffer + 2;
    } else {
        //
        // No, discard size prefix
        //
        readPtr = deviceIdBuffer;
    }
    
    
    //
    // Read remainder of DeviceId from device
    //
    bytesToRead = deviceIdSize -  2; // already have the 2 size bytes
    Status = ParNibbleModeRead(Extension, readPtr, bytesToRead, &bytesRead);
    
    
    ParTerminateNibbleMode( Extension );
    
    if( !NT_SUCCESS(Status) || (bytesRead < 1) ) {
        ExFreePool( deviceIdBuffer );
        goto targetContinue;
    }
    
    if ( strstr ( readPtr, "MFG:" ) == 0 ) {
        ExFreePool( deviceIdBuffer ) ;
        goto targetContinue;
    }
    
    deviceIdSize = (USHORT)strlen(deviceIdBuffer);
    *DeviceIdSize = deviceIdSize;
    if( (NULL != CallerDeviceIdBuffer) && (CallerBufferSize >= deviceIdSize + sizeof(CHAR)) ) {
        // caller supplied buffer is large enough, use it
        RtlZeroMemory( CallerDeviceIdBuffer, CallerBufferSize );
        RtlCopyMemory( CallerDeviceIdBuffer, deviceIdBuffer, deviceIdSize );
        ExFreePool( deviceIdBuffer );
        return CallerDeviceIdBuffer;
    } 
    return deviceIdBuffer;

 targetContinue:

// Builds later than 2080 fail to terminate in Compatibility mode.
//IEEETerminate1284Mode fails after  Event 23 (Extension->CurrentEvent equals 23)
// with earlier 1284 draft.
//So, we terminate the adapter ourselves, in some cases may be redundant.
    P5WritePortUchar(Controller + DCR_OFFSET, DCR_SELECT_IN | DCR_NOT_INIT);
    KeStallExecutionProcessor( 5 );
    P5WritePortUchar(Controller + DCR_OFFSET, DCR_SELECT_IN | DCR_NOT_INIT | DCR_AUTOFEED);
    KeStallExecutionProcessor( 5 );
    P5WritePortUchar(Controller + DCR_OFFSET, DCR_SELECT_IN | DCR_NOT_INIT);
     
    ParStlAssertIdleState ( Extension ) ;

    deviceIdBuffer = ParBuildStlDeviceId(Extension, bReturnRawString);

    if( !deviceIdBuffer ) {
        return NULL;
    }

    deviceIdSize = (USHORT)strlen(deviceIdBuffer);
    *DeviceIdSize = deviceIdSize;
    if( (NULL != CallerDeviceIdBuffer) && (CallerBufferSize >= deviceIdSize + sizeof(CHAR)) ) {
        // caller supplied buffer is large enough, use it
        RtlZeroMemory( CallerDeviceIdBuffer, CallerBufferSize );
        RtlCopyMemory( CallerDeviceIdBuffer, deviceIdBuffer, deviceIdSize );
        ExFreePool( deviceIdBuffer );
        return CallerDeviceIdBuffer;
    }
    return deviceIdBuffer;
}

PCHAR
ParBuildStlDeviceId(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN          bReturnRawString
    )
/*++

Routine Description:

    This function detects the type of shuttle adapter and
    builds an appropriate device id string and returns it
    back.

    It is assumed that the device is already in the 
    selected state.

Arguments:

    Nil. 


Return Value:

    Pointer to the read/built device ID string, if successful.

    NULL otherwise.

--*/
{
    LONG size = 0x80 ;
    PCHAR id ;
    STL_DEVICE_TYPE dtDeviceType ;
    CHAR szDeviceIdString[0x80] = {0};
    CHAR szVidPidString[] = "MFG:VID_04E6;CLS:SCSIADAPTER;MDL:PID_" ;
    CHAR szVidPidStringScan[] = "MFG:VID_04E6;CLS:IMAGE;MDL:PID_" ;
    LONG charsWritten;

    RtlZeroMemory(szDeviceIdString, sizeof(szDeviceIdString));

    // identify the shuttle adapter type by calling
    // Devtype routines here and build an unique id
    // string here.
    dtDeviceType = ParStlGetDeviceType(Extension, DEVICE_TYPE_AUTO_DETECT);

    switch ( dtDeviceType ) {

        case DEVICE_TYPE_NONE :
            return NULL;

        case DEVICE_TYPE_EPP_DEVICE :
            dtDeviceType |= 0x80000000 ;
            charsWritten = _snprintf(szDeviceIdString, size, "%s%08X;", szVidPidStringScan, dtDeviceType);
            if( (charsWritten >= size) || charsWritten < 0 ) {
                // insufficient room in array buffer, bail out
                ASSERT(FALSE); // should never happen
                return NULL;
            }
            break;

        default :
            dtDeviceType |= 0x80000000 ;
            charsWritten = _snprintf(szDeviceIdString, size, "%s%08X;", szVidPidString, dtDeviceType);
            if( (charsWritten >= size) || charsWritten < 0 ) {
                // insufficient room in array buffer, bail out
                ASSERT(FALSE); // should never happen
                return NULL;
            }
            break;

    }

    id = ExAllocatePool(PagedPool, size);
    if( id ) {
        RtlZeroMemory( id, size );
        if( bReturnRawString ) {
            //
            // Yes, caller wants the size prefix. Copy prefix to buffer to return.
            //
            *(id+0) = 0;
            *(id+1) = 0x80-2;
            RtlCopyMemory( id+2, szDeviceIdString, size - sizeof(NULL) - 2 );
        } else {
            RtlCopyMemory( id, szDeviceIdString, size - sizeof(NULL) );
        }
        return id;
    }
    return NULL;
}

STL_DEVICE_TYPE __cdecl 
ParStlGetDeviceType (
    IN PPDO_EXTENSION    Extension,
    IN int                  nPreferredDeviceType
    )
{
    STL_DEVICE_TYPE dtDeviceType    = DEVICE_TYPE_NONE ;
    ATAPIPARAMS atapiParams ;
    int i;

    for ( i=0 ; i<ATAPI_MAX_DRIVES ; i++){
        atapiParams.dsDeviceState[i] = DEVICE_STATE_INVALID ;
    }

    do
    {
        if ( TRUE == ParStlCheckIfScsiDevice(Extension))
        {
// SCSI Device identified.
            dtDeviceType |= DEVICE_TYPE_SCSI_BIT ;
            break ;
        }

        if ( TRUE == NeedToEnableIoPads () )
        {
// in some adapters, the IO pads need to be enabled, before
// doing the device detection
            ParStlWriteReg( Extension, CONFIG_INDEX_REGISTER, EP1284_POWER_CONTROL_REG );
            ParStlWriteReg( Extension, CONFIG_DATA_REGISTER, ENABLE_IOPADS );
        }

        if ( TRUE == IsImpactSPresent() )
        {
// as impact-s has been identified, the device type identification
// can be done through personality configuration info
            dtDeviceType |= ParStlGetImpactSDeviceType( Extension, &atapiParams, nPreferredDeviceType );
            break;
        }

        if ( TRUE == IsImpactPresent() )
        {
// as impact has been identified, the device type identification
// can be done through personality configuration info
            dtDeviceType |= ParStlGetImpactDeviceType( Extension, &atapiParams, nPreferredDeviceType );
            break;
        }

        if (TRUE == ParStlCheckIfEppDevice(Extension))
        {
// epp device identified
            if ( TRUE == ParStlCheckUMAXScannerPresence(Extension) ) {
// umax identified
                dtDeviceType |= DEVICE_TYPE_UMAX_BIT;
                break;
            }
            if ( TRUE == ParStlCheckAvisionScannerPresence(Extension) ) {
// avision identified
                dtDeviceType |= DEVICE_TYPE_AVISION_BIT;
                break;
            }
// generice scanner peripheral detected
            dtDeviceType |= DEVICE_TYPE_EPP_DEVICE_BIT;
            break;
        }

        if (TRUE == ParStlCheckIfSSFDC(Extension))
        {
// SSFDC identified
            dtDeviceType |= DEVICE_TYPE_SSFDC_BIT;
            break;
        }

        if (TRUE == ParStlCheckIfMMC(Extension,&atapiParams))
        {
// MMC device identified
            dtDeviceType |= DEVICE_TYPE_MMC_BIT;
            break;
        }

// set the 16 bit mode of the adapter
        ParStlSet16BitOperation(Extension) ;

        if (TRUE == ParStlCheckIfAtaAtapiDevice(Extension, &atapiParams))
        {
// necessary but not sufficient condition has passed
// proceed for sufficency checks
            if (TRUE == ParStlCheckIfAtapiDevice(Extension, &atapiParams))
            {
// sub-classify between HiFD and LS-120.
                if ( TRUE == ParStlCheckIfLS120(Extension))
                {
// LS Engine is found.            
                    dtDeviceType |= DEVICE_TYPE_LS120_BIT ;
                    break ;
                }
// Check for HiFD.  
                if (TRUE == ParStlCheckIfHiFD(Extension))
                {
// HiFD device identified.
                    dtDeviceType |=   DEVICE_TYPE_HIFD_BIT ;
                    break ;
                }
// OtherWise, it is a generic ATAPI device.
                dtDeviceType |= DEVICE_TYPE_ATAPI_BIT;
                break ;
            }

            if (TRUE == ParStlCheckIfAtaDevice(Extension, &atapiParams))
            {
// ata identified
                dtDeviceType |= DEVICE_TYPE_ATA_BIT;
                break;
            }
        }

        if (TRUE == ParStlCheckIfDazzle(Extension))
        {
// dazzle identified
            dtDeviceType |= DEVICE_TYPE_DAZZLE_BIT;
            break;
        }

        if (TRUE == ParStlCheckIfFlash(Extension))
        {
// flash identified
            dtDeviceType |= DEVICE_TYPE_FLASH_BIT;
            break;
        }
    }
    while ( FALSE ) ;

    return dtDeviceType & nPreferredDeviceType ;
}

VOID
ParStlWaitForMicroSeconds (
    int nMicroSecondsToWait
    ) {
    KeStallExecutionProcessor ( nMicroSecondsToWait ) ;
}

BOOLEAN
ParStlCheckCardInsertionStatus ( 
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    UCHAR   byPowerRegData ;
    do
    {
        if ( FALSE == IsEp1284Present() )
        {
            break ;
        }

        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER , 0x0F ) ;
        byPowerRegData  =  (UCHAR) ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) ;
        
        if ( byPowerRegData & SHTL_CARD_INSERTED_STATUS )
        {
// as the card not inserted status is reported, it is ATA / ATAPI
// possibly, not flash. hence, we break here.
            break ;
        }

        bReturnValue    =   TRUE ;
    }
    while ( FALSE ) ;

    return ( bReturnValue ) ;
}

BOOLEAN
ParStlSelectAdapterSocket (
    IN  PPDO_EXTENSION   Extension,
    IN  int                 nSocketNumber
    )
{
    BOOLEAN bReturnValue    =   FALSE ;
    UCHAR   bySCRControlReg , byISAControlReg ;

    do
    {
        if ( ( nSocketNumber != SOCKET_0 ) &&
             ( nSocketNumber != SOCKET_1 ) )
        {
// as an invalid socket number is provided, we
// break here with error.
            break ;
        } 

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , SOCKET_CONTROL_REGISTER ) ;
        bySCRControlReg = (UCHAR) ParStlReadReg (Extension, CONFIG_DATA_REGISTER ) ;

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , ISA_CONTROL_REGISTER ) ;
        byISAControlReg = (UCHAR) ParStlReadReg (Extension, CONFIG_DATA_REGISTER ) ;

        if ( SOCKET_1 == nSocketNumber )
        {
            bySCRControlReg |=  (UCHAR)SOCKET_1 ;
            bySCRControlReg |=  (UCHAR)PERIPHERAL_RESET_1 ;
            byISAControlReg &=  ~(UCHAR)ISA_IO_SWAP ;
        }
        else
        {
            bySCRControlReg &=  ~(UCHAR)SOCKET_1 ;
            bySCRControlReg &=  ~(UCHAR)PERIPHERAL_RESET_0 ;
        }

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , ISA_CONTROL_REGISTER ) ;
        ParStlWriteReg(Extension, CONFIG_DATA_REGISTER , byISAControlReg ) ;

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , SOCKET_CONTROL_REGISTER ) ;
        ParStlWriteReg(Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;

        if ( SOCKET_1 == nSocketNumber )
        {
// Wait for a few milliseconds to provide an optimal puse width
// for reset.
            ParStlWaitForMicroSeconds(1000);
            bySCRControlReg &=  ~(UCHAR)PERIPHERAL_RESET_1 ;
        }
        else
        {
            bySCRControlReg &=  ~(UCHAR)PERIPHERAL_RESET_0 ;
        }
        ParStlWriteReg(Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;

        bReturnValue    =   TRUE ;
    }
    while ( FALSE ) ;

    return  bReturnValue ;
}

BOOLEAN 
ParStlCheckIfAtaAtapiDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( TRUE == ParStlCheckCardInsertionStatus(Extension) )
        {
// as the card insertion status is valid, its probably
// a flash
            break ;
        }
        if ( FALSE == ParStlCheckDrivePresent(Extension, atapiParams) ) 
        {
// as the ATA/ATAPI controller is not present, it cant be
// an ATA/ATAPI device
            break ;
        }
        bReturnValue = TRUE;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfAtapiDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
// return whatever ATAPI initialization module says
        bReturnValue = ParStlAtapiInitialize(Extension, atapiParams) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfAtaDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
// return whatever ATA initialization module says
        bReturnValue = ParStlAtaInitialize(Extension, atapiParams) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckDrivePresent (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    UCHAR   byOrgCylHigh, byOrgCylLow ;
    int     nCurrentDrive = 0 , i ;
    UCHAR   nDrvHdArray[]={ATAPI_MASTER, ATAPI_SLAVE};

    do
    {
        if ( atapiParams->dsDeviceState[nCurrentDrive] == DEVICE_STATE_VALID )
        {
// this means that the MMC module had detected the presence
// of an ATA/ATAPI device. So, we make use of that and break out
            bReturnValue = TRUE ;
            break ;
        }

        ParStlWriteIoPort(Extension, ATA_DRVHD_REG, nDrvHdArray[nCurrentDrive]);

//  The Atapi Fuji MO drive is found to de-assert BSY and still
//  does not respond to reg. r/w when configured as slave with no media.
//  However, after a delay, it works ok.
        if ( nCurrentDrive )
        {
            ParStlWaitForMicroSeconds ( DELAY_1SECOND ) ;
        }

// this dummy write of 0 is to zero out a possible 
// floating bus
        for ( i = 0 ; i < 16 ; i++ )
        {
            ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER, i) ;
            if ( !( ParStlReadIoPort (Extension, ATA_TASK_STAT_REG ) & ATA_ST_BUSY ) )
            {
                break ;
            }
        }

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as the busy has been found permanently set, we check
// for the slave also
            continue;
        }

// as the drive head setup might have been performed in a busy state,
// we set it up again after busy clears.
        ParStlWriteIoPort(Extension, ATA_DRVHD_REG, nDrvHdArray[nCurrentDrive]);

        if ( ( ParStlReadIoPort(Extension, ATA_DRVHD_REG) & ATAPI_SLAVE ) != nDrvHdArray[nCurrentDrive] )
        {
            continue ;
        }

// read original contents of the cyl ATA high/low registers
        byOrgCylLow  = (UCHAR) ParStlReadIoPort(Extension, ATA_CYLLOW_REG);
        byOrgCylHigh = (UCHAR) ParStlReadIoPort(Extension, ATA_CYLHIGH_REG);

// write a test pattern in the cyl ATA high/low registers
        ParStlWriteIoPort(Extension, ATA_CYLLOW_REG, TEST_PATTERN_1);
        ParStlWriteIoPort(Extension, ATA_CYLHIGH_REG, TEST_PATTERN_2);

// read the test pattern in the cyl ATA high/low registers
        if ( ( TEST_PATTERN_1 != ParStlReadIoPort(Extension, ATA_CYLLOW_REG) ) ||\
             ( TEST_PATTERN_2 != ParStlReadIoPort(Extension, ATA_CYLHIGH_REG) ) )
        {
// as we were not able to read back the written values
// we break out here, indicating the absence of the device
            continue ;
        }

// write back original contents in the cyl ATA high/low registers
        ParStlWriteIoPort(Extension, ATA_CYLLOW_REG, byOrgCylLow);
        ParStlWriteIoPort(Extension, ATA_CYLHIGH_REG, byOrgCylHigh);
        bReturnValue = TRUE ;
        atapiParams->dsDeviceState[nCurrentDrive] = DEVICE_STATE_VALID ;
    }
    while ( ++nCurrentDrive < ATAPI_MAX_DRIVES );

// reset back to master state, as check drive present
// will be called successively
    ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);

    return bReturnValue ;
}

BOOLEAN
ParStlAtapiInitialize ( 
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    int     nCurrentDrive   = 0, i ;
    UCHAR   byTempValue ;
    UCHAR   chAtapiIdentifyBuffer [ ATAPI_IDENTIFY_LENGTH ] ;
    do
    {
        if ( DEVICE_STATE_VALID != atapiParams->dsDeviceState[nCurrentDrive] )
        {
// the device is absent
            continue ;
        }

        if ( nCurrentDrive ) 
        {
// as it is the next drive, choose the slave
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_SLAVE);
        }
        else
        {
// choose the master
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);
        }

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set after master/slave, we fail
// the detection process
            continue ;
        }

// check if the ATAPI signature is present in the cyl hi/lo
// registers. If present, it is definitely an ATAPI device
        if ( ( ParStlReadIoPort(Extension, ATA_CYLLOW_REG) == ATAPI_SIGN_LOW ) &&\
             ( ParStlReadIoPort(Extension, ATA_CYLHIGH_REG) == ATAPI_SIGN_HI ) )
        {
// as ATAPI signature is present, it is ATAPI type
            bReturnValue = TRUE ;

// set this flag so that, ATA initialize will skip this
// target
            atapiParams->dsDeviceState[nCurrentDrive] = DEVICE_STATE_ATAPI ;
// for Impact, since Ls120 engine is always present,
// issuing ATAPI_IDENTIFY is mandatory. 
            if ( !IsImpactPresent())
            {
                continue ;
            }
        }

// issue the ata nop command
        ParStlWriteIoPort(Extension, ATA_TASK_CMD_REG, ATA_NOP_COMMAND) ;

        if ( FALSE == ParStlWaitForIrq(Extension) )
        {
// ATAPI devices are expected to give interrrupt on NOP command
// mandatorily.
            continue ;
        }
        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set, we proceed with the next
// drive
            continue ;
        }

// issue the atapi packet command
        ParStlWriteIoPort(Extension, ATA_TASK_CMD_REG, ATAPI_IDENTIFY) ;

        if ( FALSE == ParStlWaitForIrq(Extension) )
        {
// ATAPI devices are expected to give interrrupt on 0xA1 command
// mandatorily.
            continue ;
        }
        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set, we proceed with the next
// drive
            continue ;
        }

        byTempValue = (UCHAR) ParStlReadIoPort ( Extension, ATA_TASK_STAT_REG ) ;
        if ( ! ( byTempValue & ATA_ST_ERROR ) )
        {
// as the drive has passed the packet command, this is an atapi
// drive
// Wait for DRQ to be sit, as some drives are known
// to remove busy too early and set DRQ after some time.
            if ( FALSE == ParStlWaitForDrq(Extension) )
            {
// as there was no DRQ set, we proceed with the next
// drive
                continue ;
            }
            bReturnValue = TRUE ;
// as the DRQ is still asserted, quell it, as certain ATA/ATAPI-4
// spec. dictates it so
// There is a need to check the device identifier returned in the 
// ATAPI Identify cmd. to determine the presence of Ls-120.
            ParStlReceiveData ( Extension, chAtapiIdentifyBuffer , SKIP_MEMORY_ADDRESS , ATAPI_IDENTIFY_LENGTH ) ;
            for ( i = 0 ; i < ATAPI_NAME_LENGTH ; i++ )
            {
                atapiParams->szAtapiNameString[i] = chAtapiIdentifyBuffer[ ATAPI_NAME_OFFSET + i ] ;
            }

// set this flag so that, ATA initialize will skip this
// target
            atapiParams->dsDeviceState[nCurrentDrive] = DEVICE_STATE_ATAPI ;
        }
    }
    while ( ++nCurrentDrive < ATAPI_MAX_DRIVES );

// reset back to master state, as check drive present
// will be called successively
    ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);

    return ( bReturnValue ) ;
}

BOOLEAN
ParStlAtaInitialize ( 
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    UCHAR   byTempValue ;
    int     nCurrentDrive   = 0 ;
    do
    {
        if ( DEVICE_STATE_VALID != atapiParams->dsDeviceState[nCurrentDrive] )
        {
// atapi module has marked its presence or the device is absent
            continue ;
        }

// select the possibly present device
        if ( nCurrentDrive ) 
        {
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_SLAVE ) ;
        }
        else
        {
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER ) ;
        }

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set after master/slave, we fail the
// detection process
            continue ;
        }

// issue the ata NOP command
        ParStlWriteIoPort(Extension, ATA_TASK_CMD_REG, ATA_NOP_COMMAND) ;

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set, we fail the detection process
            continue ;
        }

        byTempValue = (UCHAR) ParStlReadIoPort ( Extension, ATA_TASK_STAT_REG ) ;
        if ( ( byTempValue != BUS_LINES_IN_HIGH_IMPEDANCE ) &&\
             ( byTempValue & ATA_ST_ERROR ) )
        {
// as the bus is not reading 0xFF and the status register
// indicates an error, this is likely to be an ATA device
            if ( ATA_ERROR_ABORTED_COMMAND == ( (UCHAR) ParStlReadIoPort ( Extension, ATA_ERROR_REG ) & 0x0F ) )
            {
// as the error register, contains the ata aborted error 
// in response to our ATA NOP command, we conclude that
// it is ATA! as it is already known that it is not ATAPI
                bReturnValue = TRUE ;
                break;
            }
        }
    }
    while ( ++nCurrentDrive < ATAPI_MAX_DRIVES );

// reset back to master state, as check drive present
// will be called successively
    ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);

    return ( bReturnValue ) ;
}

BOOLEAN
ParStlWaitForBusyToClear (
    IN  PPDO_EXTENSION   Extension,
    IN  int                 nRegisterToWaitOn 
    ) 
{
// The default timeout increased to 10secs as Fujitsu MO is found to set
// BUSY for >5secs for 0xA1 command.
    int nMaxRetrials  = MAX_RETRIES_FOR_10_SECS ;
    BOOLEAN    bRetVal =   FALSE ;

    while ( nMaxRetrials-- )
    {
// the following service will be implemented by the caller
// the driver can use the STLMPORT service.
        ParStlWaitForMicroSeconds ( DELAY_1MILLISECONDS ) ;
        if ( ! ( ParStlReadIoPort ( Extension, nRegisterToWaitOn ) & ATA_ST_BUSY ) )
        {
// as busy has cleared, we return clear here
            bRetVal = TRUE ;
            break ;
        }
    }
    return  bRetVal ;
}

BOOLEAN
ParStlWaitForDrq (
    IN  PPDO_EXTENSION   Extension
    ) 
{
    int nMaxRetrials  = MAX_RETRIES_FOR_5_SECS ;
    BOOLEAN    bRetVal =   FALSE ;
    while ( nMaxRetrials-- )
    {
        if ( ParStlReadIoPort ( Extension, ATA_TASK_STAT_REG ) & ATA_ST_DRQ )
        {
// as busy has cleared, we return clear here
            bRetVal = TRUE ;
            break ;
        }
// the following service will be implemented by the caller
// the driver can use the STLMPORT service.
        ParStlWaitForMicroSeconds ( DELAY_1MILLISECONDS ) ;
    }
    return  bRetVal ;
}

BOOLEAN
ParStlWaitForIrq (
    IN  PPDO_EXTENSION   Extension
    ) 
{
    int nMaxRetrials  = MAX_RETRIES_FOR_10_SECS ;
    BOOLEAN    bRetVal =   FALSE ;
    while ( nMaxRetrials-- )
    {
        if ( ParStlReadReg ( Extension, EP1284_TRANSFER_CONTROL_REG ) & XFER_IRQ_BIT )
        {
// as Irq has asserted, we return true here
            bRetVal = TRUE ;
            break ;
        }
        ParStlWaitForMicroSeconds ( DELAY_1MILLISECONDS ) ;
    }
    return  bRetVal ;
}

VOID
ParStlSet16BitOperation (
    IN  PPDO_EXTENSION   Extension
    ) 
{
    int nModeReg ;

    nModeReg = ParStlReadReg ( Extension, EP1284_MODE_REGISTER ) ;

    if ( 0 == ( nModeReg & EP1284_ENABLE_16BIT ) )
    {
// as the bit is not already set, this needs to be set now
        ParStlWriteReg ( Extension, EP1284_MODE_REGISTER, nModeReg | EP1284_ENABLE_16BIT ) ; 
    }
}

BOOLEAN 
ParStlCheckIfEppDevice (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == IsEp1284Present() )
        {
// as EPPDEVs live only on EP1284 we break here
            break;
        }

        bReturnValue = ParStlCheckPersonalityForEppDevice(Extension) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckPersonalityForEppDevice (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE ;

    ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, EP1284_PERSONALITY_REG ) ;
    if ( EPPDEV_SIGN == ( ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) & PERSONALITY_MASK ) )
    {
// as the EPPDEV sign is found in the personality
// we break with success here
        bReturnValue   = TRUE ;
    }

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfFlash (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN    bReturnValue = FALSE ;

    do 
    {
        if ( !IsEp1284Present() && !IsImpactPresent() && !IsEpatPlusPresent() )
        {
// Check the sign-on version checks for the existence of Shuttle
// adapter. If nothing is found, we break here.
            break ;
        }

// Perform a ATA-16bit check just in case, it turns out to be something else
        bReturnValue = ParStlCheckFlashPersonality(Extension) ;
    }
    while ( FALSE ) ;

    return  bReturnValue ;
}

BOOLEAN
ParStlCheckFlashPersonality (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE ;

    if ( IsEp1284Present() )
    {
// as the personality configuration check only works for
// Ep1284, confim its presence before the actual check.
        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, EP1284_PERSONALITY_REG ) ;
        if ( FLASH_SIGN == ( ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) & FLASH_PERSONALITY_MASK ) )
        {
// as the flash sign ATA-16bit device is found in the personality
// we break with success here
            bReturnValue   = TRUE ;
        }
    }
    else
    {
// always return true, if a shuttle adapter other than ep1284 is
// identified and assume it might be flash!
        bReturnValue    =   TRUE ;
    }

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfDazzle (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   ucSignature ;

    do 
    {
        if ( !IsEp1284Present() )
        {
// Check for EP1284 presence, as Dazzle is ONLY on EP1284
// adapters. If the adapter is not EP1284, we break.
            break ;
        }

// Check whether any card insertion is detected, to eliminate
// possible flash adapters with the card in
        if ( TRUE == ParStlCheckCardInsertionStatus( Extension ) ) {
            break ;
        }

// code to read the pulled up pattern present on dazzle
// adapters.
        ParStlWriteReg( Extension, DAZ_SELECT_BLK, DAZ_BLK0 ) ;
        ucSignature = (UCHAR) ParStlReadReg( Extension, DAZ_REG1 ) ;

        if ( ( ucSignature == DAZ_CONFIGURED ) ||\
             ( ucSignature == DAZ_NOT_CONFIGURED ) ) {
            // the pulled up pattern generally found ONLY
            // on the DAZZLE adapter is found. So, we
            // conclude that it is a Dazzle adapter 
                bReturnValue = TRUE ;
        }

    }
    while ( FALSE ) ;

    return  bReturnValue ;
}

BOOLEAN 
ParStlCheckIfHiFD (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;

    do
    {
        if ( FALSE == ParStlSelectAdapterSocket(Extension, SOCKET_1) )
        {
// as the socket 1 selection failed,
// we break out here.
            break ;
        }

// check for the ready status of the floppy controller,
// after clearing the reset bit of the floppy controller.

        if ( FALSE == ParStlHIFDCheckIfControllerReady(Extension) )
        {
// since the controller didnot wake up after the
// reset pin was asserted, we break here.

            break ;
        }

        if ( FALSE == ParStlHIFDCheckSMCController(Extension) )
        {
// as the SMC ID retrieval failed,
// we break out here.
            break ;
        }

        bReturnValue = TRUE ;

    }
    while ( FALSE ) ;
// Reset the socket to zero.
    ParStlSelectAdapterSocket(Extension, SOCKET_0);
    return bReturnValue ;
}

BOOLEAN
ParStlHIFDCheckIfControllerReady (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue    =   FALSE ;
    UCHAR   bySCRControlReg ;
    do
    {
        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER , SOCKET_CONTROL_REGISTER ) ;
        bySCRControlReg = (UCHAR) ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) ;
        bySCRControlReg |=  (UCHAR)PERIPHERAL_RESET_1 ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;
        ParStlWaitForMicroSeconds ( HIFD_WAIT_10_MILLISEC ) ;

        ParStlWriteIoPort ( Extension, HIFD_DIGITAL_OUTPUT_REGISTER ,
                              0x00 ) ;
        ParStlWaitForMicroSeconds ( HIFD_WAIT_1_MILLISEC ) ;

        ParStlWriteIoPort ( Extension, HIFD_DIGITAL_OUTPUT_REGISTER ,
                              HIFD_DOR_RESET_BIT | HIFD_ENABLE_DMA_BIT ) ;
        ParStlWaitForMicroSeconds ( HIFD_WAIT_10_MILLISEC ) ;

        if ( HIFD_CONTROLLER_READY_STATUS == ParStlReadIoPort ( Extension, HIFD_MAIN_STATUS_REGISTER ) )
        {
            bReturnValue = TRUE ;
        }

        bySCRControlReg     &= ~(UCHAR)PERIPHERAL_RESET_1 ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;

    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlHIFDCheckSMCController (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN    bReturnValue = FALSE ;
    do
    {
        ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_COMMAND_TO_CONTROLLER ) ;
        ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_COMMAND_TO_CONTROLLER ) ;
        ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_CTL_REG_0D ) ;
        if ( SMC_DEVICE_ID == ParStlReadIoPort ( Extension, HIFD_STATUS_REGISTER_B ) )
        {
            bReturnValue = TRUE ;
            ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_CTL_REG_03 ) ;
            ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_B , SMC_ENABLE_MODE2 ) ;        
        }
        ParStlWriteReg ( Extension, HIFD_STATUS_REGISTER_A , HIFD_TERMINATE_SEQUENCE ) ;

    }
    while ( FALSE ) ;

    return bReturnValue ;
}

STL_DEVICE_TYPE
ParStlGetImpactDeviceType (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams,
    IN  int                 nPreferredDeviceType
    )
{
    IMPACT_DEVICE_TYPE      idtImpactDeviceType ;
    STL_DEVICE_TYPE         dtDeviceType = DEVICE_TYPE_NONE ;

    ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, IMPACT_PERSONALITY_REG ) ;
    idtImpactDeviceType    = ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) >> 4 ;

    switch ( idtImpactDeviceType )
    {
        case IMPACT_DEVICE_TYPE_ATA_ATAPI:

            // set the 16 bit mode of the adapter
            ParStlSet16BitOperation(Extension) ;

            if (TRUE == ParStlCheckIfAtaAtapiDevice(Extension,atapiParams))
            {
// necessary but not sufficient condition has passed
// proceed for sufficency checks
                if (TRUE == ParStlCheckIfAtapiDevice(Extension,atapiParams))
                {
// atapi identified
// Check for Impact LS-120 device
                    if ( TRUE == ParStlCheckIfImpactLS120(Extension, atapiParams))
                    {
                        dtDeviceType |= DEVICE_TYPE_LS120_BIT ;
                        break ;
                    }
                    dtDeviceType |= DEVICE_TYPE_ATAPI_BIT;
                    break ;
                }

                if (TRUE == ParStlCheckIfAtaDevice(Extension, atapiParams))
                {
// ata identified
                    dtDeviceType |= DEVICE_TYPE_ATA_BIT;
                    break;
                }
            }
            break ;

        case IMPACT_DEVICE_TYPE_CF:
            dtDeviceType |= DEVICE_TYPE_FLASH_BIT;
            break ;

        case IMPACT_DEVICE_TYPE_PCMCIA_CF:
            dtDeviceType |= DEVICE_TYPE_PCMCIA_CF_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SSFDC:
            dtDeviceType |= DEVICE_TYPE_SSFDC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_MMC:
            dtDeviceType |= DEVICE_TYPE_MMC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_HIFD:
            dtDeviceType |= DEVICE_TYPE_HIFD_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SOUND:
            dtDeviceType |= DEVICE_TYPE_SOUND_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_FLP_TAPE_DSK:
            dtDeviceType |= DEVICE_TYPE_FLP_TAPE_DSK_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_ATA_ATAPI_8BIT:
            dtDeviceType |= DEVICE_TYPE_ATA_ATAPI_8BIT_BIT ;
            break;

        default:
            break;
    }

    return dtDeviceType & nPreferredDeviceType ;
}

STL_DEVICE_TYPE
ParStlGetImpactSDeviceType (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams,
    IN  int                 nPreferredDeviceType
    )
{
    IMPACT_DEVICE_TYPE      idtImpactDeviceType ;
    IMPACT_DEVICE_TYPE      idtImpactSDeviceType ;
    STL_DEVICE_TYPE         dtDeviceType = DEVICE_TYPE_NONE ;

    ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, IMPACT_PERSONALITY_REG ) ;
    idtImpactDeviceType    = ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) >> 4 ;

    switch ( idtImpactDeviceType )
    {
        case IMPACT_DEVICE_TYPE_ATA_ATAPI:

            // set the 16 bit mode of the adapter
            ParStlSet16BitOperation(Extension) ;

            if (TRUE == ParStlCheckIfAtaAtapiDevice(Extension,atapiParams))
            {
// necessary but not sufficient condition has passed
// proceed for sufficency checks
                if (TRUE == ParStlCheckIfAtapiDevice(Extension,atapiParams))
                {
// atapi identified
                    dtDeviceType |= DEVICE_TYPE_ATAPI_BIT;
                    break ;
                }

                if (TRUE == ParStlCheckIfAtaDevice(Extension,atapiParams))
                {
// ata identified
                    dtDeviceType |= DEVICE_TYPE_ATA_BIT;
                    break;
                }
            }
            break ;

        case IMPACT_DEVICE_TYPE_CF:
            dtDeviceType |= DEVICE_TYPE_FLASH_BIT;
            break ;

        case IMPACT_DEVICE_TYPE_PCMCIA_CF:
            dtDeviceType |= DEVICE_TYPE_PCMCIA_CF_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SSFDC:
            dtDeviceType |= DEVICE_TYPE_SSFDC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_MMC:
            dtDeviceType |= DEVICE_TYPE_MMC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_HIFD:
            dtDeviceType |= DEVICE_TYPE_HIFD_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SOUND:
            dtDeviceType |= DEVICE_TYPE_SOUND_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_FLP_TAPE_DSK:
            dtDeviceType |= DEVICE_TYPE_FLP_TAPE_DSK_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_ATA_ATAPI_8BIT:
            dtDeviceType |= DEVICE_TYPE_ATA_ATAPI_8BIT_BIT ;
            break;

        case IMPACTS_EXT_PERSONALITY_PRESENT:
            ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, IMPACTS_EXT_PERSONALITY_XREG ) ;
            idtImpactSDeviceType    = ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) ;
            dtDeviceType = DEVICE_TYPE_EXT_HWDETECT ;
            dtDeviceType |= idtImpactSDeviceType ;
            break ;

        default:
            break;
    }

    return dtDeviceType & nPreferredDeviceType ;
}

BOOLEAN 
ParStlCheckIfLS120 (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == ParStlSelectAdapterSocket(Extension, SOCKET_1) )
        {
// as the socket 1 selection failed,
// we break out here.
            break ;
        }

// check for engine version.                    

        if ( LS120_ENGINE_VERSION == ParStlReadIoPort( Extension, LS120_ENGINE_VERSION_REGISTER ) )
        {
// if the ls120 engine version is correct, we have
// found LS120.

            bReturnValue    =   TRUE ;
        }

// Reset the socket to zero.
        ParStlSelectAdapterSocket ( Extension, SOCKET_0 ) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfImpactLS120 (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE ;
    BOOLEAN bLs120NameFound= TRUE ;
    char chLs120Name[] = "HU DlFpoyp";
    char *pszAtapiName = atapiParams->szAtapiNameString ;
    int  i , nMemoryOnBoard ;

    do
    {
        for ( i = 0 ;i < sizeof(chLs120Name)-1 ; i++ )
        {
            if ( pszAtapiName[i] != chLs120Name[i] )
            {
                bLs120NameFound = FALSE ;
                break ;
            }
        }
        if ( TRUE != bLs120NameFound )
        {
// as LS-120 name string is not found, we conclude that it is
// not LS-120
            break ;
        }
        nMemoryOnBoard =  ParStlGetMemorySize(Extension) ;
        if ( ( !IsShtlError ( nMemoryOnBoard ) ) && \
             ( nMemoryOnBoard ) )
        {
// there is memory on-board.
// hence, we return ls120 here
            bReturnValue = TRUE ;
            break ;
        }
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfMMC (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;

    do
    {
        if ( FALSE == IsEpatPlusPresent() )
        {
// as mmc device can exist only on EPAT Plus adapter only
// we break out of here
            break;
        }
        if ( TRUE == ParStlCheckIfAtaAtapiDevice (Extension,atapiParams) )
        {
// as an ATA/ATAPI device is probably present,
// we break out of here
            break;
        }
        bReturnValue = ParStlIsMMCEnginePresent(Extension) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlIsMMCEnginePresent(
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;

    do
    {
// check if the ATAPI signature is present in the cyl hi/lo
// registers. If present, it is definitely an ATAPI device
        if ( ( ParStlReadIoPort(Extension, CYLLOW_REG) == ATAPI_SIGN_LOW ) &&\
             ( ParStlReadIoPort(Extension, CYLHIGH_REG) == ATAPI_SIGN_HI ) )
        {
// as ATAPI signature is present, it cant be MMC
            break ;
        }

// write a zero pattern ( which will be a NOP for ATA/ATAPI devices ) 
// in the block size / possible ATA/ATAPI command register
        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_BLOCK_SIZE_REG);
        ParStlWriteReg(Extension, MMC_ENGINE_DATA, MMC_TEST_PATTERN_1);
        if ( MMC_TEST_PATTERN_1 != ParStlReadReg(Extension, MMC_ENGINE_DATA) )
        {
// as the written value is not available, it means device present
// has responded to the written value, in a way different from
// how an MMC would have.
            break ;
        }

// write a test pattern in the freq register
        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_FREQ_SELECT_REG);
        ParStlWriteReg(Extension, MMC_ENGINE_DATA, MMC_TEST_PATTERN_2);

// write another in the block size register
        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_BLOCK_SIZE_REG);
        ParStlWriteReg(Extension, MMC_ENGINE_DATA, MMC_TEST_PATTERN_3);

        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_FREQ_SELECT_REG);
        if ( MMC_TEST_PATTERN_2 != ParStlReadReg(Extension, MMC_ENGINE_DATA) )
        {
// as we were not able to read back the written value
// we quit here
            break;
        }

        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_BLOCK_SIZE_REG);
        if ( MMC_TEST_PATTERN_3 != ParStlReadReg(Extension, MMC_ENGINE_DATA) )
        {
// as we were not able to read back the written value
// we quit here
            break;
        }
// as all tests have passed, engine presence is confirmed
// here
        bReturnValue = TRUE ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfScsiDevice (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == IsEpstPresent() )
        {
// as SCSI devices live only on EPST we break here
            break;
        }

        bReturnValue = TRUE ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfSSFDC (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == IsEp1284Present() )
        {
// SSFDC lives on EP1284 alone, other than impact
// which is already taken care
            break;
        }

//check to see if the loop back of the EPCS and EPDO pins
//of the INDEX 00 register read the same. If so, it is 
//SSFDC board characteristic
        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER , 0x00 ) ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , 0x10 ) ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , 0x12 ) ;
        if ( 0x1A == ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) )
        {
            ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , 0x10 ) ;
            if ( ! ( ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) & 0x08 ) )
            {
//as they are equal, SSFDC present
                bReturnValue    =   TRUE ;
                break ;
            }
        }

    }
    while ( FALSE ) ;

    return bReturnValue ;
}

VOID
ParStlAssertIdleState (
    IN  PPDO_EXTENSION   Extension
    )
{
    PUCHAR  CurrentPort, CurrentControl ;
    ULONG   Delay = 5 ;

    CurrentPort = Extension->Controller;
    CurrentControl = CurrentPort + 2;

// place op-code for idle state in port base
    P5WritePortUchar ( CurrentPort, (UCHAR) 0x00 ) ;
    KeStallExecutionProcessor( Delay );

// bring down DCR_INIT and DCR_STROBE
    P5WritePortUchar ( CurrentControl, (UCHAR) STB_INIT_LOW ) ;
    KeStallExecutionProcessor( Delay );

// lift DCR_INIT and DCR_STROBE to high
    P5WritePortUchar ( CurrentControl, (UCHAR) STB_INIT_AFXT_HI ) ;
    KeStallExecutionProcessor( Delay );
}

BOOLEAN
ParStlCheckAvisionScannerPresence(
        IN PPDO_EXTENSION Extension
    )
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   data;

    do {

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) == 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x08 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x08 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) != 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) == 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x02 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x02 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) != 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) == 0) {
            break ;
        }

        bReturnValue = TRUE ;

    } while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckUMAXScannerPresence(
    IN PPDO_EXTENSION    Extension
    )
{
    UCHAR   commandPacket_[6] = {0x55,0xaa,0,0,0,0} ;
    PUCHAR  commandPacket ;
    USHORT  status;
    UCHAR   idx;
    PUCHAR  saveCommandPacket;
    ULONG   dataLength;

    ParStlWriteReg ( Extension, CONTROLPORT, 0 ) ;  // scannner reset
    KeStallExecutionProcessor ( 2000 ) ;            // 2 m.secs delay
    ParStlWriteReg ( Extension, CONTROLPORT, 0x0C ) ;

    commandPacket = commandPacket_ ;
    saveCommandPacket = commandPacket;

    if ( TRUE == ParStlSetEPPMode(Extension) ) {

        commandPacket+=2;
        dataLength = *(ULONG*)commandPacket;
        dataLength &= 0xffffff; //data bytes ordering (msb to lsb) will
                                // wrong .What we need here is whether the
                                // dataLength is 0 or not.

        commandPacket = saveCommandPacket;

        //Command phase

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700) != 0){
            return FALSE;      //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;     //TIMEOUT_ERROR);
        }

        for(idx=0; idx<= 6 ;idx++){

            if(status & 0x800){
                break;
            }

            status = ParStlEPPRead(Extension);
        }

        if(idx == 7){

            status = (status & 0xf800)  | 0x100; 
            if ( status & 0x700 )
                return FALSE;
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;          //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;         //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;         //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *commandPacket);
        if((status & 0x700 ) != 0){
            return FALSE;         //TIMEOUT_ERROR);
        }

        //Response phase

        status    =    ParStlEPPRead(Extension);
        commandPacket = saveCommandPacket;

        if((status & 0x700) == 0){

            if((commandPacket[5] == 0xc2)&& (dataLength == 0)){

                status = ParStlEPPRead(Extension);

                if((status & 0x0700) != 0){
                    return FALSE;  //TIMEOUT_ERROR);
                }
            }
        }
    
        return  TRUE;
    }
    return FALSE;
}

BOOLEAN
ParStlSetEPPMode(
    IN PPDO_EXTENSION    Extension
    )
{
    UCHAR   idx;
    BOOLEAN timeout = TRUE ;

    ParStlWriteReg( Extension, CONTROLPORT, 0x0C ) ;
    ParStlWriteReg( Extension, DATAPORT, 0x40 ) ;
    ParStlWriteReg( Extension, CONTROLPORT, 0x06 ) ;

    for(idx=0; idx<10; idx++){

        if((ParStlReadReg(Extension, STATUSPORT) & 0x78) == 0x38){

            timeout = FALSE;
            break;

        }

    }

    if(timeout == FALSE){

        ParStlWriteReg( Extension, CONTROLPORT,0x7 );
        timeout = TRUE;

        for(idx=0; idx<10; idx++){

            if((ParStlReadReg( Extension, STATUSPORT) & 0x78) == 0x38){
                timeout = FALSE;
                break;
            }

        }

        if(timeout == FALSE){

            ParStlWriteReg( Extension, CONTROLPORT,0x4 ) ;
            timeout = TRUE;

            for(idx=0; idx<10; idx++){

                if((ParStlReadReg( Extension, STATUSPORT) & 0xf8) == 0xf8){
                    timeout = FALSE;
                    break;
                }

            }

            if(timeout == FALSE){

                timeout = TRUE;

                ParStlWriteReg( Extension, CONTROLPORT, 0x5 );

                for(idx=0; idx<10; idx++){

                    if( ParStlReadReg( Extension, CONTROLPORT ) == 0x5){

                        timeout = FALSE;
                        break;

                    }
                }

                if(timeout == FALSE){

                    ParStlWriteReg( Extension, CONTROLPORT, 0x84) ;
                    return TRUE ;

                } // final check

            } // third check

        } // second check

    } // first check

    return(FALSE);
}

USHORT
ParStlEPPWrite(
    IN PPDO_EXTENSION    Extension,
    IN UCHAR                value
    )
{
    UCHAR   idx;
    USHORT  statusData = 0;
    BOOLEAN timeout;

    timeout = TRUE;

    for(idx=0; idx<10; idx++){

        if( !( (statusData = (USHORT)ParStlReadReg( Extension, STATUSPORT)) & BUSY)){
            timeout = FALSE;
            break;
        }

    }

    if(timeout == TRUE){

        return(((statusData<<8) & 0xf800)|0x100);

    }

    ParStlWriteReg( Extension, EPPDATA0PORT,value );
    return(((statusData & 0xf8) << 8)|value);
}

USHORT
ParStlEPPRead(
    IN PPDO_EXTENSION Extension
    )
{
    UCHAR   idx;
    UCHAR   eppData;
    USHORT  statusData = 0;
    BOOLEAN timeout    = TRUE ;

    for(idx=0; idx<10; idx++){

        if(!( (statusData = (USHORT)ParStlReadReg( Extension, STATUSPORT)) & PE)){
            timeout = FALSE;
            break;
        }

    }

    if(timeout == TRUE){

        return(((statusData<<8) & 0xf800)|0x100);

    }

    eppData = (UCHAR)ParStlReadReg( Extension, EPPDATA0PORT) ;
    return(((statusData & 0x00f8)<<8) | eppData );
}

int  __cdecl
ParStlReadReg (
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned            reg
    )
{
    UCHAR   byReadNibble ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl ;
    ULONG   Delay = 5 ;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

// select the register to read
    P5WritePortUchar ( CurrentPort, (UCHAR)reg ) ;
    KeStallExecutionProcessor( Delay );

// issue nibble ctl signals to read
    P5WritePortUchar ( CurrentControl, STB_INIT_LOW ) ;
    KeStallExecutionProcessor( Delay );
    P5WritePortUchar ( CurrentControl, STB_INIT_AFXT_LO ) ;
    KeStallExecutionProcessor( Delay );

// read first nibble
    byReadNibble = P5ReadPortUchar (CurrentStatus);
    KeStallExecutionProcessor( Delay );
    byReadNibble >>= 4 ;

// issue nibble ctl signals to read
    P5WritePortUchar ( CurrentControl, STB_INIT_AFXT_HI ) ;
    KeStallExecutionProcessor( Delay );

// read next nibble
    byReadNibble |= ( P5ReadPortUchar ( CurrentStatus ) & 0xF0 ) ;

    return (int)byReadNibble ;
}

int  __cdecl
ParStlWriteReg ( 
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned            reg, 
    IN  int                 databyte 
    )
{
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl ;
    ULONG   Delay = 5 ;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

// select the register to write
    P5WritePortUchar ( CurrentPort, (UCHAR)( reg | 0x60 ) ) ;
    KeStallExecutionProcessor( Delay );

// write to printer ctl port
    P5WritePortUchar ( CurrentControl, STB_INIT_LOW ) ;
    KeStallExecutionProcessor( Delay );

// write the requested data
    P5WritePortUchar ( CurrentPort, (UCHAR)databyte ) ;
    KeStallExecutionProcessor( Delay );

// write to printer ctl port
    P5WritePortUchar ( CurrentControl, STB_INIT_AFXT_HI ) ;
    KeStallExecutionProcessor( Delay );

    return SHTL_NO_ERROR ;
}

int __cdecl
ParStlReceiveData (
    IN  PPDO_EXTENSION   Extension,
    IN  VOID                *hostBufferPointer,
    IN  long                shuttleMemoryAddress,
    IN  unsigned            count
    )
{
    PCHAR   pchDataBuffer = (PCHAR) hostBufferPointer ;
    unsigned int i = 0 ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl ;
    ULONG   Delay = 5 ;

    UNREFERENCED_PARAMETER( shuttleMemoryAddress );

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

// set the block address register to ATA/ATAPI data register,
// as this function is currently used ONLY for ATA/ATAPI devices
// ATA/ATAPI data register 0x1F0 corresponds to 0x18 value
    ParStlWriteReg ( Extension, EP1284_BLK_ADDR_REGISTER, 0x18 ) ;

// do the nibble block read sequence
// write the nibble block read op-code
    P5WritePortUchar ( CurrentPort, OP_NIBBLE_BLOCK_READ ) ;
    KeStallExecutionProcessor( Delay );

// set control ports to correct signals.
    P5WritePortUchar ( CurrentControl, STB_INIT_AFXT_LO ) ;
    KeStallExecutionProcessor( Delay );

// set data port to 0xFF
    P5WritePortUchar ( CurrentPort, 0xFF ) ;
    KeStallExecutionProcessor( Delay );
    P5WritePortUchar ( CurrentControl, INIT_AFXT_HIGH ) ;
    KeStallExecutionProcessor( Delay );

    do
    {
// low nibble is available in status after
// toggling sequences as in EP1284 manual
        P5WritePortUchar ( CurrentControl, AFXT_LO_STB_HI ) ;
        KeStallExecutionProcessor( Delay );
        pchDataBuffer[i] = P5ReadPortUchar( CurrentStatus ) >> 4 ;
        KeStallExecutionProcessor( Delay );

// high nibble is available in status after
// toggling sequences as in EP1284 manual
        P5WritePortUchar ( CurrentControl, AFXT_HI_STB_HI ) ;
        KeStallExecutionProcessor( Delay );

        pchDataBuffer[i++] |= ( P5ReadPortUchar ( CurrentStatus ) & 0xF0 ) ;
        KeStallExecutionProcessor( Delay );
        if ( count - 1 == i )
        {
// to read the last byte 
            P5WritePortUchar ( CurrentPort, 0xFD ) ;
            KeStallExecutionProcessor( Delay );
        }

        P5WritePortUchar ( CurrentControl, AFXT_LO_STB_LO ) ;
        KeStallExecutionProcessor( Delay );

        pchDataBuffer[i] = P5ReadPortUchar ( CurrentStatus ) >> 4 ;
        KeStallExecutionProcessor( Delay );

        P5WritePortUchar ( CurrentControl, AFXT_HI_STB_LO ) ;
        KeStallExecutionProcessor( Delay );
        pchDataBuffer[i++] |= ( P5ReadPortUchar ( CurrentStatus ) & 0xF0 ) ;
        KeStallExecutionProcessor( Delay );
    }
    while ( i <= count ) ;

// clean up
    P5WritePortUchar ( CurrentPort, 0x00 ) ;
    KeStallExecutionProcessor( Delay );

// done
    return SHTL_NO_ERROR ;
}

int  __cdecl
ParStlReadIoPort (
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned            reg 
    )
{
    switch ( reg )
    {
    case 0x08 :
        reg = 0x16 ;
        break ;
    case 0x09 :
        reg = 0x17 ;
        break ;
    default :
        reg |= 0x18 ;
        break;
    }
    return ParStlReadReg ( Extension, reg ) ;
}

int  __cdecl
ParStlWriteIoPort (
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned            reg,
    IN  int                 databyte
    )
{
    switch ( reg )
    {
    case 0x08 :
        reg = 0x16 ;
        break ;
    case 0x09 :
        reg = 0x17 ;
        break ;
    default :
        reg |= 0x18 ;
        break;
    }
    return ParStlWriteReg ( Extension, reg, databyte ) ;
}

int  __cdecl
ParStlGetMemorySize (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN    bReturnValue = FALSE ;
    UCHAR      byTempValue ;
    do
    {
// Issue reset through control register
// first try on DRAM
        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|SELECT_DRAM|RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// write to the first location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_1 ) ;
// write to the next location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_2 ) ;

        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|SELECT_DRAM|RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// read from the first and next location in the memory
        if ( ( TEST_PATTERN_1 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) &&\
             ( TEST_PATTERN_2 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) )
        {
            bReturnValue = TRUE ;
            break ;
        }
        
        if ( !IsImpactPresent () )
        {
// as only DRAM can be present on non-impact adapters
            break ;
        }
// Issue reset through control register
// and next try on SRAM
        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|RESET_PTR ;
        byTempValue &= SELECT_SRAM ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// write to the first location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_1 ) ;
// write to the next location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_2 ) ;

        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// read from the first location in the memory
        if ( ( TEST_PATTERN_1 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) &&\
             ( TEST_PATTERN_2 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) )
        {
            bReturnValue = TRUE ;
            break ;
        }
    }
    while ( FALSE ) ;
    return bReturnValue ;
}
// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\sppieee.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    sppieee.c

Abstract:

    This module contains code for the host to utilize an ieee version of
    compatibility mode

Author:

    Robbie Harris (Hewlett-Packard) 29-July-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

NTSTATUS
SppIeeeWrite(
    IN  PPDO_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    )

/*++

Routine Description:

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PUCHAR      Controller = Extension->Controller;
    PUCHAR      pPortDCR = Extension->Controller + OFFSET_DCR;
    PUCHAR      pPortData = Extension->Controller + OFFSET_DATA;
    ULONG       wByteCount = BytesToWrite;
    UCHAR       bDCRstrobe;		// Holds precomputed value for state 35
    UCHAR       bDCRnormal;		// Holds precomputed value for state 37
    PUCHAR      lpsBufPtr = (PUCHAR)Buffer;    // Pointer to buffer cast to desired data type

    
    // Make precomputed DCR values for strobe and periph ack
    bDCRstrobe = SET_DCR(DIR_WRITE, IRQEN_DISABLE, ACTIVE, ACTIVE, ACTIVE, INACTIVE);
    bDCRnormal = SET_DCR(DIR_WRITE, IRQEN_DISABLE, ACTIVE, ACTIVE, ACTIVE, ACTIVE);

    // Wait a bit to give nBusy a chance to settle, because 
    // WriteComm will bail immediately if the device says busy
    if ( CHECK_DSR( Controller,
                    INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE,
                    IEEE_MAXTIME_TL ) )
    {
        while (wByteCount)
        {
                // Place a data byte on the bus
            P5WritePortUchar(pPortData, *lpsBufPtr);
            
                // Start handshake by dropping strobe
            P5WritePortUchar(pPortDCR, bDCRstrobe);
            
                // Wait for Periph Busy Response
            if ( !CHECK_DSR(Controller, ACTIVE, DONT_CARE, DONT_CARE,
                    DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL) )        
            {
                status = STATUS_DEVICE_BUSY;
                break;
            }

                // Printer responded by making Busy high -- the byte has
            // been accepted.  Adjust the data pointer.
            lpsBufPtr++;
            
                // Finish handshake by raising strobe
            P5WritePortUchar(pPortDCR, bDCRnormal);

                // Adjust count while we're waiting for the peripheral
            // to respond with state 32
            wByteCount--;
            
                // Wait for PeriphAck and PeriphBusy response
            if ( !CHECK_DSR(Controller, INACTIVE, ACTIVE, DONT_CARE, DONT_CARE,
                    DONT_CARE, IEEE_MAXTIME_TL) )
            {
                // Set appropriate error based on relaxed timeout.
                status = STATUS_DEVICE_BUSY;
                break;
            }
        }	// while...                            
    
        *BytesTransferred  = BytesToWrite - wByteCount;      // Set current count.
    }
                
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\swepp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    epp.c

Abstract:

    This module contains the code to perform all EPP related tasks (including
    EPP Software and EPP Hardware modes.)

Author:

    Timothy T. Wells (WestTek, L.L.C.) - April 16, 1997

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"


BOOLEAN
ParIsEppSwWriteSupported(
    IN  PPDO_EXTENSION   Pdx
    );
    
BOOLEAN
ParIsEppSwReadSupported(
    IN  PPDO_EXTENSION   Pdx
    );
    
NTSTATUS
ParEnterEppSwMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateEppSwMode(
    IN  PPDO_EXTENSION   Pdx
    );

NTSTATUS
ParEppSwWrite(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEppSwRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    

BOOLEAN
ParIsEppSwWriteSupported(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine determines whether or not EPP mode is suported
    in the write direction by trying negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    // dvdr
    DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Entering\n");

    if (!(Pdx->HardwareCapabilities & PPT_ECP_PRESENT) &&
        !(Pdx->HardwareCapabilities & PPT_BYTE_PRESENT)) {
        DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Hardware Not Supported Leaving\n");
        // Only use EPP Software in the reverse direction if an ECR is 
        // present or we know that we can put the data register into Byte mode.
        return FALSE;
    }
        

    if (Pdx->BadProtocolModes & EPP_SW) {
        // dvdr
        DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Not Supported Leaving\n");
        return FALSE;
    }

    if (Pdx->ProtocolModesSupported & EPP_SW) {
        // dvdr
        DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Supported Leaving\n");
        return TRUE;
    }

    // Must use SWEPP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEppSwMode (Pdx, FALSE);
    ParTerminateEppSwMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Negotiated Supported Leaving\n");
        Pdx->ProtocolModesSupported |= EPP_SW;
        return TRUE;
    }
   
    DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Not Negotiated Not Supported Leaving\n");
    return FALSE;    
}

BOOLEAN
ParIsEppSwReadSupported(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine determines whether or not EPP mode is suported
    in the read direction (need to be able to float the data register
    drivers in order to do byte wide reads) by trying negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    if (!(Pdx->HardwareCapabilities & PPT_ECP_PRESENT) &&
        !(Pdx->HardwareCapabilities & PPT_BYTE_PRESENT)) {
        DD((PCE)Pdx,DDT,"ParIsEppSwReadSupported: Hardware Not Supported Leaving\n");
        // Only use EPP Software in the reverse direction if an ECR is 
        // present or we know that we can put the data register into Byte mode.
        return FALSE;
    }
        
    if (Pdx->BadProtocolModes & EPP_SW)
        return FALSE;

    if (Pdx->ProtocolModesSupported & EPP_SW)
        return TRUE;

    // Must use SWEPP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEppSwMode (Pdx, FALSE);
    ParTerminateEppSwMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsEppSwReadSupported: Negotiated Supported Leaving\n");
        Pdx->ProtocolModesSupported |= EPP_SW;
        return TRUE;
    }
   
    DD((PCE)Pdx,DDT,"ParIsEppSwReadSupported: Not Negotiated Not Supported Leaving\n");
    return FALSE;    
}

NTSTATUS
ParEnterEppSwMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    EPP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    // dvdr
    DD((PCE)Pdx,DDT,"ParEnterEppSwMode: Entering\n");

    // Parport Set Chip mode will put the Chip into Byte Mode if Capable
    // We need it for Epp Sw Mode
    Status = Pdx->TrySetChipMode( Pdx->PortContext, ECR_BYTE_PIO_MODE );

    if ( NT_SUCCESS(Status) ) {
        if ( Pdx->ModeSafety == SAFE_MODE ) {
            if (DeviceIdRequest) {
                // dvdr
                DD((PCE)Pdx,DDT,"ParEnterEppSwMode: Calling IeeeEnter1284Mode with DEVICE_ID_REQUEST\n");
                Status = IeeeEnter1284Mode (Pdx, EPP_EXTENSIBILITY | DEVICE_ID_REQ);
            } else {
                // dvdr
                DD((PCE)Pdx,DDT,"ParEnterEppSwMode: Calling IeeeEnter1284Mode\n");
                Status = IeeeEnter1284Mode (Pdx, EPP_EXTENSIBILITY);
            }
        } else {
            DD((PCE)Pdx,DDT,"ParEnterEppSwMode: In UNSAFE_MODE.\n");
            Pdx->Connected = TRUE;
        }
    }
        
    if ( NT_SUCCESS(Status) ) {
        // dvdr
        DD((PCE)Pdx,DDT,"ParEnterEppSwMode: IeeeEnter1284Mode returned success\n");
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
        Pdx->IsIeeeTerminateOk = TRUE;

    } else {
        // dvdr
        DD((PCE)Pdx,DDT,"ParEnterEppSwMode: IeeeEnter1284Mode returned unsuccessful\n");
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->IsIeeeTerminateOk = FALSE;
    }
    
    DD((PCE)Pdx,DDT,"ParEnterEppSwMode: Leaving with Status : %x \n", Status);

    return Status; 
}    

VOID
ParTerminateEppSwMode(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Pdx  - The Device Extension which has the parallel port's controller address.

Return Value:

    None.

--*/

{
    // dvdr
    DD((PCE)Pdx,DDT,"ParTerminateEppMode: Entering\n");
    if ( Pdx->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Pdx);
    } else {
        DD((PCE)Pdx,DDT,"ParTerminateEppMode: In UNSAFE_MODE.\n");
        Pdx->Connected = FALSE;
    }
    Pdx->ClearChipMode( Pdx->PortContext, ECR_BYTE_PIO_MODE );
    DD((PCE)Pdx,DDT,"ParTerminateEppMode: Leaving\n");
    return;    
}

NTSTATUS
ParEppSwWrite(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    Writes data to the peripheral using the EPP protocol under software
    control.
    
Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          Controller;
    PUCHAR          pBuffer = (PUCHAR)Buffer;
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           i, j;
    UCHAR           HDReady, HDAck, HDFinished;
    
    // dvdr
    DD((PCE)Pdx,DDT,"ParEppSwWrite: Entering\n");

    Controller = Pdx->Controller;

    P5SetPhase( Pdx, PHASE_FORWARD_XFER );
    
    // BIT5 of DCR needs to be low to be in BYTE forward mode
    HDReady = SET_DCR( INACTIVE, INACTIVE, ACTIVE, ACTIVE, INACTIVE, INACTIVE );
    HDAck = SET_DCR( INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE, INACTIVE );
    HDFinished = SET_DCR( INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE, ACTIVE );

    for (i = 0; i < BufferSize; i++) {

        // dvdr
        DD((PCE)Pdx,DDT,"ParEppSwWrite: Writing Byte to port\n");

        P5WritePortBufferUchar( Controller, pBuffer++, (ULONG)0x01 );

        //
        // Event 62
        //
        StoreControl (Controller, HDReady);

        // =============== Periph State 58     ===============
        // Should wait up to 10 micro Seconds but waiting up
        // to 15 micro just in case
        for ( j = 16; j > 0; j-- ) {
            if( !(GetStatus(Controller) & DSR_NOT_BUSY) )
                break;
            KeStallExecutionProcessor(1);
        }

        // see if we timed out on state 58
        if ( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            DD((PCE)Pdx,DDE,"ParEppSwModeWrite:Failed State 58: Controller %x\n", Controller);
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            break;
        }

        //
        // Event 63
        //
        StoreControl (Controller, HDAck);

        // =============== Periph State 60     ===============
        // Should wait up to 125 nano Seconds but waiting up
        // to 5 micro seconds just in case
        for ( j = 6; j > 0; j-- ) {
            if( GetStatus(Controller) & DSR_NOT_BUSY )
                break;
            KeStallExecutionProcessor(1);
        }

        if( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            DD((PCE)Pdx,DDE,"ParEppSwModeWrite:Failed State 60: Controller %x\n", Controller);
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            break;
        }
            
        //
        // Event 61
        //
        StoreControl (Controller, HDFinished);
            
        // Stall a little bit between data bytes
        KeStallExecutionProcessor(1);

    }
        
    *BytesTransferred = i;

    // dvdr
    DD((PCE)Pdx,DDT,"ParEppSwWrite: Leaving with %i Bytes Transferred\n", i);

    if ( Status == STATUS_SUCCESS )
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    
    return Status;

}

NTSTATUS
ParEppSwRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 EPP mode read under software control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          Controller;
    PUCHAR          pBuffer = (PUCHAR)Buffer;
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           i, j;
    UCHAR           dcr;
    UCHAR           HDReady, HDAck;
    
    // dvdr
    DD((PCE)Pdx,DDT,"ParEppSwRead: Entering\n");

    Controller = Pdx->Controller;

    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
    
    // Save off Control
    dcr = GetControl (Controller);
    
    // BIT5 of DCR needs to be high to be in BYTE reverse mode
    HDReady = SET_DCR( ACTIVE, INACTIVE, ACTIVE, ACTIVE, INACTIVE, ACTIVE );
    HDAck = SET_DCR( ACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE, ACTIVE );

    // First time to get into reverse mode quickly
    StoreControl (Controller, HDReady);

    for (i = 0; i < BufferSize; i++) {

        //
        // Event 67
        //
        StoreControl (Controller, HDReady);
            
        // =============== Periph State 58     ===============
        // Should wait up to 10 micro Seconds but waiting up
        // to 15 micro just in case
        for ( j = 16; j > 0; j-- ) {
            if( !(GetStatus(Controller) & DSR_NOT_BUSY) )
                break;
            KeStallExecutionProcessor(1);
        }

        // see if we timed out on state 58
        if ( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            DD((PCE)Pdx,DDE,"ParEppSwRead:Failed State 58: Controller %x\n", Controller);
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            break;
        }

        // Read the Byte                
        P5ReadPortBufferUchar( Controller, 
                                pBuffer++, 
                                (ULONG)0x01 );

        //
        // Event 63
        //
        StoreControl (Controller, HDAck);
            
        // =============== Periph State 60     ===============
        // Should wait up to 125 nano Seconds but waiting up
        // to 5 micro seconds just in case
        for ( j = 6; j > 0; j-- ) {
            if( GetStatus(Controller) & DSR_NOT_BUSY )
                break;
            KeStallExecutionProcessor(1);
        }

        if( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            DD((PCE)Pdx,DDE,"ParEppSwRead:Failed State 60: Controller %x\n", Controller);
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            break;
        }
        
        // Stall a little bit between data bytes
        KeStallExecutionProcessor(1);
    }
    
    dcr &= ~DCR_DIRECTION;
    StoreControl (Controller, dcr);
    
    *BytesTransferred = i;

    // dvdr
    DD((PCE)Pdx,DDT,"ParEppSwRead: Leaving with %x Bytes Transferred\n", i);

    if ( Status == STATUS_SUCCESS )
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\test.c ===
#include "pch.h"

NTSTATUS
P4NibbleModeRead(
    IN      PUCHAR       Controller,
    IN      PVOID        Buffer,
    IN      ULONG        BufferSize,
    OUT     PULONG       BytesTransferred,
    IN OUT  PIEEE_STATE  IeeeState
    )
/*++

Routine Description:

    This routine performs a 1284 nibble mode read into the given
    buffer for no more than 'BufferSize' bytes.

Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/
{
    PUCHAR          wPortDCR;
    PUCHAR          wPortDSR;
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          p = (PUCHAR)Buffer;
    UCHAR           dsr, dcr;
    UCHAR           nibble[2];
    ULONG           i, j;

    wPortDCR = Controller + OFFSET_DCR;
    wPortDSR = Controller + OFFSET_DSR;
    
    // Read nibbles according to 1284 spec.

    dcr = P5ReadPortUchar(wPortDCR);

    switch (IeeeState->CurrentPhase) {
    
        case PHASE_NEGOTIATION: 
        
            // Starting in state 6 - where do we go from here?
            // To Reverse Idle or Reverse Data Transfer Phase depending if
            // data is available.
            
            dsr = P5ReadPortUchar(wPortDSR);
            
            // =============== Periph State 6 ===============8
            // PeriphAck/PtrBusy        = Don't Care
            // PeriphClk/PtrClk         = Don't Care (should be high
            //                              and the nego. proc already
            //                              checked this)
            // nAckReverse/AckDataReq   = Don't Care (should be high)
            // XFlag                    = Don't Care (should be low)
            // nPeriphReq/nDataAvail    = High/Low (line status determines
            //                              which state we move to)
            IeeeState->CurrentEvent = 6;
            if (TEST_DSR(dsr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE )) {
                // Data is NOT available - go to Reverse Idle
                DD(NULL,DDT,"P4NibbleModeRead - DataNotAvail - set PHASE_REVERSE_IDLE\n");
                // Host enters state 7  - officially in Reverse Idle now
                
            	// Must stall for at least .5 microseconds before this state.
                KeStallExecutionProcessor(1);

                /* =============== Host State 7 Nibble Reverse Idle ===============8
                    DIR                     = Don't Care
                    IRQEN                   = Don't Care
                    1284/SelectIn           = High
                    nReverseReq/  (ECP only)= Don't Care
                    HostAck/HostBusy        = Low (signals State 7)
                    HostClk/nStrobe         = High
                  ============================================================ */
                IeeeState->CurrentEvent = 7;
                dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, ACTIVE);
                P5WritePortUchar(wPortDCR, dcr);

                P5BSetPhase( IeeeState, PHASE_REVERSE_IDLE );
                // FALL THRU TO reverse idle
            } else {
            
                // Data is available, go to Reverse Transfer Phase
                P5BSetPhase( IeeeState, PHASE_REVERSE_XFER );
                // DO NOT fall thru
                goto PhaseReverseXfer; // please save me from my sins!
            }


        case PHASE_REVERSE_IDLE:

            // Check to see if the peripheral has indicated Interrupt Phase and if so, 
            // get us ready to reverse transfer.

            // See if data is available (looking for state 19)
            dsr = P5ReadPortUchar(Controller + OFFSET_DSR);
                
            if (!(dsr & DSR_NOT_DATA_AVAIL)) {
                
                dcr = P5ReadPortUchar(wPortDCR);
                // =========== Host State 20 Interrupt Phase ===========8
                //  DIR                     = Don't Care
                //  IRQEN                   = Don't Care
                //  1284/SelectIn           = High
                //  nReverseReq/ (ECP only) = Don't Care
                //  HostAck/HostBusy        = High (Signals state 20)
                //  HostClk/nStrobe         = High
                //
                // Data is available, get us to Reverse Transfer Phase
                IeeeState->CurrentEvent = 20;
                dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE, ACTIVE);
                P5WritePortUchar(wPortDCR, dcr);

                // =============== Periph State 21 HBDA ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = Don't Care (should be high)
                // nAckReverse/AckDataReq   = low (signals state 21)
                // XFlag                    = Don't Care (should be low)
                // nPeriphReq/nDataAvail    = Don't Care (should be low)
                IeeeState->CurrentEvent = 21;
                if (CHECK_DSR(Controller,
                                DONT_CARE, DONT_CARE, INACTIVE,
                                DONT_CARE, DONT_CARE,
                                IEEE_MAXTIME_TL)) {
                                  
                // Got state 21
                    // Let's jump to Reverse Xfer and get the data
                    P5BSetPhase( IeeeState, PHASE_REVERSE_XFER);
                    goto PhaseReverseXfer;
                        
                } else {
                    
                    // Timeout on state 21
                    IeeeState->IsIeeeTerminateOk = TRUE;
                    Status = STATUS_IO_DEVICE_ERROR;
                    P5BSetPhase( IeeeState, PHASE_UNKNOWN );
                    DD(NULL,DDT,"P4NibbleModeRead - Failed State 21: Controller %x dcr %x\n", Controller, dcr);
                    // NOTE:  Don't ASSERT Here.  An Assert here can bite you if you are in
                    //        Nibble Rev and you device is off/offline.
                    // dvrh 2/25/97
                    goto NibbleReadExit;
                }

            } else {
                
                // Data is NOT available - do nothing
                // The device doesn't report any data, it still looks like it is
                // in ReverseIdle.  Just to make sure it hasn't powered off or somehow
                // jumped out of Nibble mode, test also for AckDataReq high and XFlag low
                // and nDataAvaul high.
                IeeeState->CurrentEvent = 18;
                dsr = P5ReadPortUchar(Controller + OFFSET_DSR);
                if(( dsr & DSR_NIBBLE_VALIDATION )== DSR_NIBBLE_TEST_RESULT ) {

                    P5BSetPhase( IeeeState, PHASE_REVERSE_IDLE );

                } else {
                    #if DVRH_BUS_RESET_ON_ERROR
                        BusReset(wPortDCR);  // Pass in the dcr address
                    #endif
                    // Appears we failed state 19.
                    IeeeState->IsIeeeTerminateOk = TRUE;
                    Status = STATUS_IO_DEVICE_ERROR;
                    P5BSetPhase( IeeeState, PHASE_UNKNOWN );
                    DD(NULL,DDT,"P4NibbleModeRead - Failed State 19: Controller %x dcr %x\n", Controller, dcr);
                }
                goto NibbleReadExit;

            }
        
PhaseReverseXfer:

        case PHASE_REVERSE_XFER: 
        
            DD(NULL,DDT,"P4NibbleModeRead - case PHASE_REVERSE_XFER\n");
            
            for (i = 0; i < BufferSize; i++) {
            
                for (j = 0; j < 2; j++) {
                
                    // Host enters state 7 or 12 depending if nibble 1 or 2
                    dcr |= DCR_NOT_HOST_BUSY;
                    P5WritePortUchar(wPortDCR, dcr);

                    // =============== Periph State 9     ===============8
                    // PeriphAck/PtrBusy        = Don't Care (Bit 3 of Nibble)
                    // PeriphClk/PtrClk         = low (signals state 9)
                    // nAckReverse/AckDataReq   = Don't Care (Bit 2 of Nibble)
                    // XFlag                    = Don't Care (Bit 1 of Nibble)
                    // nPeriphReq/nDataAvail    = Don't Care (Bit 0 of Nibble)
                    IeeeState->CurrentEvent = 9;
                    if (!CHECK_DSR(Controller,
                                  DONT_CARE, INACTIVE, DONT_CARE,
                                  DONT_CARE, DONT_CARE,
                                  IEEE_MAXTIME_TL)) {
                        // Time out.
                        // Bad things happened - timed out on this state,
                        // Mark Status as bad and let our mgr kill current mode.
                        
                        IeeeState->IsIeeeTerminateOk = FALSE;
                        Status = STATUS_IO_DEVICE_ERROR;
                        DD(NULL,DDT,"P4NibbleModeRead - Failed State 9: Controller %x dcr %x\n", Controller, dcr);
                        P5BSetPhase( IeeeState,PHASE_UNKNOWN );
                        goto NibbleReadExit;
                    }

                    // Read Nibble
                    nibble[j] = P5ReadPortUchar(wPortDSR);

                    /* ============== Host State 10 Nibble Read ===============8
                        DIR                     = Don't Care
                        IRQEN                   = Don't Care
                        1284/SelectIn           = High
                        HostAck/HostBusy        = High (signals State 10)
                        HostClk/nStrobe         = High
                    ============================================================ */
                    IeeeState->CurrentEvent = 10;
                    dcr &= ~DCR_NOT_HOST_BUSY;
                    P5WritePortUchar(wPortDCR, dcr);

                    // =============== Periph State 11     ===============8
                    // PeriphAck/PtrBusy        = Don't Care (Bit 3 of Nibble)
                    // PeriphClk/PtrClk         = High (signals state 11)
                    // nAckReverse/AckDataReq   = Don't Care (Bit 2 of Nibble)
                    // XFlag                    = Don't Care (Bit 1 of Nibble)
                    // nPeriphReq/nDataAvail    = Don't Care (Bit 0 of Nibble)
                    IeeeState->CurrentEvent = 11;
                    if (!CHECK_DSR(Controller,
                                  DONT_CARE, ACTIVE, DONT_CARE,
                                  DONT_CARE, DONT_CARE,
                                  IEEE_MAXTIME_TL)) {
                        // Time out.
                        // Bad things happened - timed out on this state,
                        // Mark Status as bad and let our mgr kill current mode.
                        Status = STATUS_IO_DEVICE_ERROR;
                        IeeeState->IsIeeeTerminateOk = FALSE;
                        DD(NULL,DDT,"P4NibbleModeRead - Failed State 11: Controller %x dcr %x\n", Controller, dcr);
                        P5BSetPhase( IeeeState,PHASE_UNKNOWN );
                        goto NibbleReadExit;
                    }
                }

                // Read two nibbles - make them into one byte.
                
                p[i]  = (((nibble[0]&0x38)>>3)&0x07) | ((nibble[0]&0x80) ? 0x00 : 0x08);
                p[i] |= (((nibble[1]&0x38)<<1)&0x70) | ((nibble[1]&0x80) ? 0x00 : 0x80);

                // DD(NULL,DDT,"P4NibbleModeRead:%x:%c\n", p[i], p[i]);

                // At this point, we've either received the number of bytes we
                // were looking for, or the peripheral has no more data to
                // send, or there was an error of some sort (of course, in the
                // error case we shouldn't get to this comment).  Set the
                // phase to indicate reverse idle if no data available or
                // reverse data transfer if there's some waiting for us
                // to get next time.

                dsr = P5ReadPortUchar(wPortDSR);
                
                if (dsr & DSR_NOT_DATA_AVAIL) {
                
                    // Data is NOT available - go to Reverse Idle
                    // Really we are going to HBDNA, but if we set
                    // current phase to reverse idle, the next time
                    // we get into this function all we have to do
                    // is set hostbusy low to indicate idle and
                    // we have infinite time to do that.
                    // Break out of the loop so we don't try to read
                    // data that isn't there.
                    // NOTE - this is a successful case even if we
                    // didn't read all that the caller requested
                    P5BSetPhase( IeeeState, PHASE_REVERSE_IDLE );
                    i++; // account for this last byte transferred
                    break;
                    
                } else {
                    // Data is available, go to (remain in ) Reverse Transfer Phase
                    P5BSetPhase( IeeeState, PHASE_REVERSE_XFER );
                }
            } // end for i loop

            *BytesTransferred = i;
            // DON'T FALL THRU THIS ONE
            break;

        default:
            // I'm gonna mark this as false. There is not a correct answer here.
            //  The peripheral and the host are out of sync.  I'm gonna reset myself
            // and the peripheral.       
            IeeeState->IsIeeeTerminateOk = FALSE;
            Status = STATUS_IO_DEVICE_ERROR;
            P5BSetPhase( IeeeState, PHASE_UNKNOWN );

            DD(NULL,DDT,"P4NibbleModeRead:Failed State 9: Unknown Phase. Controller %x dcr %x\n",
                                Controller, dcr);
            DD(NULL,DDT,"P4NibbleModeRead: You're hosed man.\n" );
            DD(NULL,DDT,"P4NibbleModeRead: If you are here, you've got a bug somewhere else.\n" );
            DD(NULL,DDT,"P4NibbleModeRead: Go fix it!\n" );
            goto NibbleReadExit;
            break;
    } // end switch

NibbleReadExit:

    if( IeeeState->CurrentPhase == PHASE_REVERSE_IDLE ) {
        // Host enters state 7  - officially in Reverse Idle now
        dcr |= DCR_NOT_HOST_BUSY;

        P5WritePortUchar (wPortDCR, dcr);
    }

    DD(NULL,DDT,"P4NibbleModeRead - returning status = %x\n",Status);
    if(NT_SUCCESS(Status)) {
        DD(NULL,DDT,"P4NibbleModeRead - bytes read = %d\n",*BytesTransferred);
    }
    return Status;
}


VOID
P4IeeeTerminate1284Mode(
    IN PUCHAR           Controller,
    IN OUT PIEEE_STATE  IeeeState,
    IN enum XFlagOnEvent24 XFlagOnEvent24
    )
/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    PUCHAR wPortDCR;
    UCHAR  dcr, dsrMask, dsrValue;
    BOOLEAN bXFlag;
    BOOLEAN bUseXFlag = FALSE;

    DD(NULL,DDT,"P4IeeeTerminate1284Mode - enter - Controller=%x, IeeeState=%x\n",Controller,IeeeState);

    wPortDCR = Controller + OFFSET_DCR;
    dcr = P5ReadPortUchar(wPortDCR);

    if( PHASE_TERMINATE == IeeeState->CurrentPhase ) {
        // We are already terminated.  This will fail if we don't just bypass this mess.
        goto Terminate_ExitLabel;
    }

    // Keep Negotiated XFLAG to use for termination.
    //    xFlag,  // Technically we should have
            // cached this value from state
            // 6 of nego. This peripheral's XFlag
            // at pre state 22 should be the
            // same as state 6.
    bXFlag = P5ReadPortUchar(Controller + OFFSET_DSR) & 0x10;

    // REVISIT: Do we need to ensure the preceeding state is a valid
    //          state to terminate from.  In other words, is there there
    //          a black bar on the 1284 line for that state?

    // =============== Host State 22 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low (Signals state 22)
    //  nReverseReq/**(ECP only)    = Don't Care (High for ECP, otherwise unused)
    //  HostAck/HostBusy/nAutoFeed  = High
    //  HostClk/nStrobe             = High
	//
    IeeeState->CurrentEvent = 22;
    dcr = P5ReadPortUchar(wPortDCR);
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // Clear data lines so we don't have any random spew.
    P5WritePortUchar(Controller + OFFSET_DATA, 0);

    // *************** Periph State 23/24 Termination ***************8
    // PeriphAck/PtrBusy        = High  (Signals state 23 for ECP
    //                                   otherwise already high)
    // PeriphClk/PtrClk         = Low   (Signals state 24 for ecp
    //                                   Signals state 23 for Nibble)
    // nAckRev/AckDataReq/PE    = Don't Care
    // XFlag                    = Low  (ECP and Byte)   (State 24)
    //                          = High (Nibble)         (State 24)
    //                          = Low (All DeviceID Requests including Nibble) (State 24)
    //                          = Undefined (EPP)
    // nPeriphReq/nDataAvail    = High
    //                            Don't check nPeriphReq/nDataAvail
    //                            Since it was in a "Don't Care"
    //                            state (ie. Double bar in the spec)
    //                            until state 23 for ECP mode.
    if (IeeeState->CurrentPhase == PHASE_REVERSE_IDLE ||
        IeeeState->CurrentPhase == PHASE_REVERSE_XFER) {

        // We must be in Nibble Reverse.  Let's double check!!!
        if( FAMILY_REVERSE_NIBBLE == IeeeState->ProtocolFamily ||
            FAMILY_REVERSE_BYTE   == IeeeState->ProtocolFamily ) {
            bUseXFlag = TRUE;   // We're in Nibble or Byte
        
            if( XFlagOnEvent24 == IgnoreXFlagOnEvent24 ) {
                // normally we would honor XFlag but we need to work around Brother MFC-8700 firmware
                bUseXFlag = FALSE;
            }
        
        } else
            bUseXFlag = FALSE;   // Don't know what mode we are in?

    } else {

        if( FAMILY_BECP == IeeeState->ProtocolFamily ||
            FAMILY_ECP  == IeeeState->ProtocolFamily )
            bUseXFlag = TRUE;   // We're in an ECP Flavor
        else
            bUseXFlag = FALSE;   // Don't know what mode we are in?
        
    }

    if( bUseXFlag ) {
        dsrMask  = DSR_TEST_MASK(  DONT_CARE, INACTIVE, DONT_CARE, bXFlag ? INACTIVE : ACTIVE, DONT_CARE );
        dsrValue = DSR_TEST_VALUE( DONT_CARE, INACTIVE, DONT_CARE, bXFlag ? INACTIVE : ACTIVE, DONT_CARE );
    }
    else {
        dsrMask  = DSR_TEST_MASK(  DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE );
        dsrValue = DSR_TEST_VALUE( DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE );
    }
    IeeeState->CurrentEvent = 23;
    if( !CheckPort( Controller + OFFSET_DSR, dsrMask, dsrValue, IEEE_MAXTIME_TL ) ) {
        // We couldn't negotiate back to compatibility mode - just terminate.
        DD(NULL,DDT,"IeeeTerminate1284Mode:State 23/24 Failed: Controller %x dsr %x dcr %x\n", 
               Controller, P5ReadPortUchar(Controller + OFFSET_DSR), dcr);
        goto Terminate_ExitLabel;
    }

    // =============== Host State 25 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low
    //  nReverseReq/**(ECP only)    = Don't Care (Possibly High)
    //  HostAck/HostBusy/nAutoFeed  = Low (Signals State 25)
    //  HostClk/nStrobe             = High
    //
    IeeeState->CurrentEvent = 25;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, INACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // =============== State 26 Termination ===============8
    // Do nothing for state 26

    // =============== Periph State 27 Termination ===============8
    // PeriphAck/PtrBusy        = High
    // PeriphClk/PtrClk         = High   (Signals State 27)
    // nAckRev/AckDataReq/PE    = Don't Care  (Invalid from State 23)
    // XFlag                    = Don't Care (All Modes)   (Invlaid at State 27)
    // nPeriphReq/nDataAvial    = Don't Care (Invalid from State 26)
    // dvrh 6/16/97
    IeeeState->CurrentEvent = 27;
    if( !CHECK_DSR(Controller, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL) ) {
        DD(NULL,DDE,"P4IeeeTerminate1284Mode - State 27 Failed -  Controller %x dsr %x dcr %x\n",
           Controller, P5ReadPortUchar(Controller + OFFSET_DSR), dcr);
    }

Terminate_ExitLabel:

    // =============== Host State 28 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low
    //  nReverseReq/**(ECP only)    = Don't Care (Possibly High)
    //  HostAck/HostBusy/nAutoFeed  = High (Signals State 28)
    //  HostClk/nStrobe             = High
    //
    IeeeState->CurrentEvent = 28;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // We are now back in compatibility mode.

    IeeeState->CurrentPhase      = PHASE_TERMINATE;
    IeeeState->Connected         = FALSE;
    IeeeState->IsIeeeTerminateOk = FALSE;

    return;
}

NTSTATUS
P4IeeeEnter1284Mode(
    IN  PUCHAR          Controller,                    
    IN  UCHAR           Extensibility,
    IN OUT PIEEE_STATE  IeeeState
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - supplies the port base address

    Extensibility   - supplies the IEEE 1284 mode desired

    IeeeState           - tracks the state of the negotiation with the peripheral

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    PUCHAR          wPortDCR;
    UCHAR           dcr;
    const USHORT    sPeriphResponseTime = 35;

    wPortDCR = Controller + OFFSET_DCR;

    /* =============== Host Prep for Pre State 0 ===============8
       Set the following just in case someone didn't
       put the port in compatibility mode before we got it.
      
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = Low
        nReverseReq/  (ECP only)= High for ECP / Don't Care for Nibble
                                    I will do ahead and set it to high
                                    since Nibble doesn't care.
        HostAck/HostBusy        = High
        HostClk/nStrobe         = Don't Care
    ============================================================ */
    dcr = P5ReadPortUchar(wPortDCR);               // Get content of DCR.
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, DONT_CARE);
    P5WritePortUchar(wPortDCR, dcr);
    KeStallExecutionProcessor(2);

    /* =============== Host Pre State 0 Negotiation ===============8
        DIR                     = Low ( Don't Care by spec )
        IRQEN                   = Low ( Don't Care by spec )
        1284/SelectIn           = Low
        nReverseReq/  (ECP only)= High ( Don't Care by spec )
        HostAck/HostBusy        = High
        HostClk/nStrobe         = High
    ============================================================ */
    
    dcr = UPDATE_DCR(dcr, INACTIVE, INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);
    KeStallExecutionProcessor(2);
    /* =============== Host State 0 Negotiation ===============8
       Place the extensibility request value on the data bus - state 0.
      
    ============================================================ */
    IeeeState->CurrentEvent = 0;
    P5WritePortUchar(Controller + DATA_OFFSET, Extensibility);
    KeStallExecutionProcessor(2);

    /* =========== Host State 1 Negotiation Phase ===========8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High  (Signals State 1)
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = Low   (Signals state 1)
        HostClk/nStrobe         = High
      
    ============================================================ */
    IeeeState->CurrentEvent = 1;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    /* =============== Periph State 2 Negotiation ===============8
       PeriphAck/PtrBusy        = Don't Care
       PeriphClk/PtrClk         = low   Signals State 2
       nAckReverse/AckDataReq   = high  Signals State 2
       XFlag                    = high  Signals State 2
                                    **Note: It is high at state 2
                                            for both ecp and nibble
       nPeriphReq/nDataAvail    = high  Signals State 2
    ============================================================ */
    IeeeState->CurrentEvent = 2;
    if (!CHECK_DSR(Controller, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, ACTIVE,
                  sPeriphResponseTime)) {
        KeStallExecutionProcessor(2);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, DONT_CARE);
        P5WritePortUchar(wPortDCR, dcr);
        
        DD(NULL,DDT,"IeeeEnter1284Mode: %x - Extensibility=%x, FAIL - TIMEOUT on Event 2\n", Controller, Extensibility);
        P5BSetPhase( IeeeState, PHASE_UNKNOWN );
        IeeeState->Connected = FALSE;
        IeeeState->IsIeeeTerminateOk = FALSE;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    /* =============== Host State 3 Negotiation ===============8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = Low
        HostClk/nStrobe         = Low (signals State 3)
      
        NOTE: Strobe the Extensibility byte
    ============================================================ */
    IeeeState->CurrentEvent = 3;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, INACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // HostClk must be help low for at least .5 microseconds.
    //
    KeStallExecutionProcessor(2);

    /* =============== Host State 4 Negotiation ===============8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = High (signals State 4)
        HostClk/nStrobe         = High (signals State 4)
      
        NOTE: nReverseReq should be high in ECP, but this line is only
                valid for ECP.  Since it isn't used for signaling
                anything in negotiation, let's just ignore it for now.
    ============================================================ */
    IeeeState->CurrentEvent = 4;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    /* ============== Periph State 5/6 Negotiation ===============
       PeriphAck/PtrBusy        = Don't Care. low (ECP) / Don't Care (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       PeriphClk/PtrClk         = high (Signals State 6)
       nAckReverse/AckDataReq   = Don't Care. low (ECP) / high (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       XFlag                    = Don't Care. high (ECP) / low (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       nPeriphReq/nDataAvail    = Don't Care. high (ECP) / low (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       ============== Periph State 5/6 Negotiation ==============8
      
        NOTES:
                - It's ok to lump states 5 and 6 together.  In state 5 Nibble,
                    the periph will set XFlag low and nPeriphReq/nDataAvail low.
                    The periph will then hold for .5ms then set PeriphClk/PtrClk
                    high.  In ECP, state 5 is nAckReverse/AckDataReq going low and
                    PeriphAck/PtrBusy going low.  Followed by a .5ms pause.
                    Followed by PeriphClk/PtrClk going high.
    ============================================================ */
    IeeeState->CurrentEvent = 5;
    if (!CHECK_DSR(Controller, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE,
                  sPeriphResponseTime)) {
                  
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE);
        P5WritePortUchar(wPortDCR, dcr);

        DD(NULL,DDE,"P4IeeeEnter1284Mode - controller=%x - Extensibility=%x, FAIL - TIMEOUT on Events 5/6\n"
           , Controller, Extensibility);
        P5BSetPhase( IeeeState, PHASE_UNKNOWN );
        IeeeState->Connected = FALSE;
        IeeeState->IsIeeeTerminateOk = FALSE;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    KeStallExecutionProcessor(2);

    P5BSetPhase( IeeeState, PHASE_NEGOTIATION );
    IeeeState->Connected    = TRUE;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\swecp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 2000

Module Name:

    swecp.c

Abstract:

    Enhanced Capabilities Port (ECP)
    
    This module contains the code to perform all ECP related tasks (including
    ECP Software and ECP Hardware modes.)

Author:

    Tim Wells (WESTTEK) - April 16, 1997

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

BOOLEAN
ParIsEcpSwWriteSupported(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the write direction by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    
    NTSTATUS Status;
    
    //
    // Has a client driver or user mode app told us to avoid this mode 
    //   for this device via IOCTL_PAR_GET_DEVICE_CAPS?
    //
    if( Pdx->BadProtocolModes & ECP_SW ) {
        return FALSE;
    }

    //
    // Have we previously checked for and found that this mode is
    //   supported with this device?
    //
    if( Pdx->ProtocolModesSupported & ECP_SW ) {
        return TRUE;
    }

    //
    // Determine if the mode is supported by trying to negotiate the
    //   device the device into the requested mode.
    //

    // RMT - DVDF - 000709 - the following 2 lines really handle two distinct operations
    //   each: (1) negotiating the peripheral into ECP, and (2) setting/clearing our
    //   driver state machine. Consider breaking these operations out into two
    //   distinct functions each.
    Status = ParEnterEcpSwMode( Pdx, FALSE );
    ParTerminateEcpMode( Pdx );

    if( NT_SUCCESS(Status) ) {
        Pdx->ProtocolModesSupported |= ECP_SW;
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOLEAN
ParIsEcpSwReadSupported(
    IN  PPDO_EXTENSION  Pdx
    )
/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the read direction (need to be able to float the data register
    drivers in order to do byte wide reads) by trying negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    
    NTSTATUS Status;
    
    if( !(Pdx->HardwareCapabilities & PPT_ECP_PRESENT) &&
        !(Pdx->HardwareCapabilities & PPT_BYTE_PRESENT) ) {

        // Only use ECP Software in the reverse direction if an
        // ECR is present or we know that we can put the data register into Byte mode.

        return FALSE;
    }
        
    if (Pdx->BadProtocolModes & ECP_SW)
        return FALSE;

    if (Pdx->ProtocolModesSupported & ECP_SW)
        return TRUE;

    // Must use SWECP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEcpSwMode (Pdx, FALSE);
    ParTerminateEcpMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
    
        Pdx->ProtocolModesSupported |= ECP_SW;
        return TRUE;
    }
   
    return FALSE;    
}

NTSTATUS
ParEnterEcpSwMode(
    IN  PPDO_EXTENSION  Pdx,
    IN  BOOLEAN         DeviceIdRequest
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    ECP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS  status = STATUS_SUCCESS;

    if( Pdx->ModeSafety == SAFE_MODE ) {
        if( DeviceIdRequest ) {
            status = IeeeEnter1284Mode( Pdx, ECP_EXTENSIBILITY | DEVICE_ID_REQ );
        } else {
            status = IeeeEnter1284Mode( Pdx, ECP_EXTENSIBILITY );
        }
    } else {
        DD((PCE)Pdx,DDT,"ParEnterEcpSwMode: In UNSAFE_MODE\n");
        Pdx->Connected = TRUE;
    }
    
    if( NT_SUCCESS(status) ) {
        status = ParEcpSetupPhase( Pdx );
    }
      
    return status; 
}    

VOID 
ParCleanupSwEcpPort(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

   Cleans up prior to a normal termination from ECP mode.  Puts the
   port HW back into Compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    PUCHAR  Controller;
    UCHAR   dcr;           // Contents of DCR

    Controller = Pdx->Controller;

    //----------------------------------------------------------------------
    // Set data bus for output
    //----------------------------------------------------------------------
    dcr = P5ReadPortUchar(Controller + OFFSET_DCR);               // Get content of DCR
    dcr = UPDATE_DCR( dcr, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
    P5WritePortUchar( Controller + OFFSET_DCR, dcr );
    return;
}


VOID
ParTerminateEcpMode(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    ParCleanupSwEcpPort(Pdx);
    if ( Pdx->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Pdx);
    } else {
        DD((PCE)Pdx,DDT,"ParTerminateEcpMode: In UNSAFE_MODE\n");
        Pdx->Connected = FALSE;
    }
    return;    
}

NTSTATUS
ParEcpSetAddress(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Address
    )

/*++

Routine Description:

    Sets the ECP Address.
    
Arguments:

    Pdx           - Supplies the device extension.

    Address             - The bus address to be set.
    
Return Value:

    None.

--*/
{
    PUCHAR          Controller;
    PUCHAR          DCRController;
    UCHAR           dcr;
    
    DD((PCE)Pdx,DDT,"ParEcpSetAddress: Start: Channel [%x]\n", Address);
    Controller = Pdx->Controller;
    DCRController = Controller + OFFSET_DCR;
    
    //
    // Event 34
    //
    // HostAck low indicates a command byte
    Pdx->CurrentEvent = 34;
    dcr = P5ReadPortUchar(DCRController);
    dcr = UPDATE_DCR( dcr, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE );
    P5WritePortUchar(DCRController, dcr);
    // Place the channel address on the bus
    // Bit 7 of the byte sent must be 1 to indicate that this is an address
    // instead of run length count.
    //
    P5WritePortUchar(Controller + DATA_OFFSET, (UCHAR)(Address | 0x80));
    
    //
    // Event 35
    //
    // Start handshake by dropping HostClk
    Pdx->CurrentEvent = 35;
    dcr = UPDATE_DCR( dcr, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE );
    P5WritePortUchar(DCRController, dcr);


    // =============== Periph State 36     ===============8
    // PeriphAck/PtrBusy        = High (signals state 36)
    // PeriphClk/PtrClk         = Don't Care
    // nAckReverse/AckDataReq   = Don't Care
    // XFlag                    = Don't Care
    // nPeriphReq/nDataAvail    = Don't Care
    Pdx->CurrentEvent = 35;
    if (!CHECK_DSR(Controller,
                  ACTIVE, DONT_CARE, DONT_CARE,
                  DONT_CARE, DONT_CARE,
                  DEFAULT_RECEIVE_TIMEOUT))
    {
	    DD((PCE)Pdx,DDE,"ECP::SendChannelAddress:State 36 Failed: Controller %x\n", Controller);
        // Make sure both HostAck and HostClk are high before leaving
        // HostClk should be high in forward transfer except when handshaking
        // HostAck should be high to indicate that what follows is data (not commands)
        //
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        P5WritePortUchar(DCRController, dcr);
        return STATUS_IO_DEVICE_ERROR;
    }
        
    //
    // Event 37
    //
    // Finish handshake by raising HostClk
    // HostClk is high when it's 0
    //
    Pdx->CurrentEvent = 37;
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE );
    P5WritePortUchar(DCRController, dcr);
            
    // =============== Periph State 32     ===============8
    // PeriphAck/PtrBusy        = Low (signals state 32)
    // PeriphClk/PtrClk         = Don't Care
    // nAckReverse/AckDataReq   = Don't Care
    // XFlag                    = Don't Care
    // nPeriphReq/nDataAvail    = Don't Care
    Pdx->CurrentEvent = 32;
    if (!CHECK_DSR(Controller,
                  INACTIVE, DONT_CARE, DONT_CARE,
                  DONT_CARE, DONT_CARE,
                  DEFAULT_RECEIVE_TIMEOUT))
    {
	    DD((PCE)Pdx,DDE,"ECP::SendChannelAddress:State 32 Failed: Controller %x\n", Controller);
        // Make sure both HostAck and HostClk are high before leaving
        // HostClk should be high in forward transfer except when handshaking
        // HostAck should be high to indicate that what follows is data (not commands)
        //
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        P5WritePortUchar(DCRController, dcr);
        return STATUS_IO_DEVICE_ERROR;
    }
    
    // Make sure both HostAck and HostClk are high before leaving
    // HostClk should be high in forward transfer except when handshaking
    // HostAck should be high to indicate that what follows is data (not commands)
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
    P5WritePortUchar(DCRController, dcr);

    DD((PCE)Pdx,DDT,"ParEcpSetAddress, Exit [%d]\n", NT_SUCCESS(STATUS_SUCCESS));
    return STATUS_SUCCESS;

}

NTSTATUS
ParEcpSwWrite(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    Writes data to the peripheral using the ECP protocol under software
    control.
    
Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          Controller;
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          pBuffer;
    LARGE_INTEGER   Timeout;
    LARGE_INTEGER   StartWrite;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    UCHAR           dsr;
    UCHAR           dcr;
    ULONG           i = 0;

    Controller = Pdx->Controller;
    pBuffer    = Buffer;

    Status = ParTestEcpWrite(Pdx);

    if( !NT_SUCCESS(Status) ) {
        P5SetPhase( Pdx, PHASE_UNKNOWN );                     
        Pdx->Connected = FALSE;                                
        DD((PCE)Pdx,DDE,"ParEcpSwWrite: Invalid Entry State\n");
        goto ParEcpSwWrite_ExitLabel;
    }

    Wait.QuadPart = DEFAULT_RECEIVE_TIMEOUT * 10 * 1000 + KeQueryTimeIncrement();
    
    Timeout.QuadPart  = Pdx->AbsoluteOneSecond.QuadPart * Pdx->TimerStart;
    
    KeQueryTickCount(&StartWrite);
    
    dcr = GetControl (Controller);
    
    // clear direction bit - enable output
    dcr &= ~(DCR_DIRECTION);
    StoreControl(Controller, dcr);
    KeStallExecutionProcessor(1);

    for (i = 0; i < BufferSize; i++) {

        //
        // Event 34
        //
        Pdx->CurrentEvent = 34;
        P5WritePortUchar(Controller + DATA_OFFSET, *pBuffer++);
    
        //
        // Event 35
        //
        Pdx->CurrentEvent = 35;
        dcr &= ~DCR_AUTOFEED;
        dcr |= DCR_STROBE;
        StoreControl (Controller, dcr);
            
        //
        // Waiting for Event 36
        //
        Pdx->CurrentEvent = 36;
        while (TRUE) {

            KeQueryTickCount(&End);

            dsr = GetStatus(Controller);
            if (!(dsr & DSR_NOT_BUSY)) {
                break;
            }

            if ((End.QuadPart - StartWrite.QuadPart) * 
                    KeQueryTimeIncrement() > Timeout.QuadPart) {

                dsr = GetStatus(Controller);
                if (!(dsr & DSR_NOT_BUSY)) {
                    break;
                }
                //
                // Return the device to Idle.
                //
                dcr &= ~(DCR_STROBE);
                StoreControl (Controller, dcr);
            
                *BytesTransferred = i;
                Pdx->log.SwEcpWriteCount += *BytesTransferred;
                return STATUS_DEVICE_BUSY;
            }
        }
        
        //
        // Event 37
        //
        Pdx->CurrentEvent = 37;
        dcr &= ~DCR_STROBE;
        StoreControl (Controller, dcr);
            
        //
        // Waiting for Event 32
        //
        Pdx->CurrentEvent = 32;
        KeQueryTickCount(&Start);
        while (TRUE) {

            KeQueryTickCount(&End);

            dsr = GetStatus(Controller);
            if (dsr & DSR_NOT_BUSY) {
                break;
            }

            if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() >
                Wait.QuadPart) {

                dsr = GetStatus(Controller);
                if (dsr & DSR_NOT_BUSY) {
                    break;
                }
                #if DVRH_BUS_RESET_ON_ERROR
                    BusReset(Controller+OFFSET_DCR);  // Pass in the dcr address
                #endif
                *BytesTransferred = i;
                Pdx->log.SwEcpWriteCount += *BytesTransferred;
                return STATUS_IO_DEVICE_ERROR;
            }
        }
    }

ParEcpSwWrite_ExitLabel:

    *BytesTransferred = i;
    Pdx->log.SwEcpWriteCount += *BytesTransferred;

    return Status;

}

NTSTATUS
ParEcpSwRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 ECP mode read under software control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          Controller;
    PUCHAR          pBuffer;
    USHORT          usTime;
    UCHAR           dcr;
    ULONG           i;
    UCHAR           ecr = 0;
    
    Controller = Pdx->Controller;
    pBuffer    = Buffer;

    dcr = GetControl (Controller);
    
    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
    
    //
    // Put ECR into PS/2 mode and float the drivers.
    //
    if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
        // Save off the ECR register 
        ecr = P5ReadPortUchar(Controller + ECR_OFFSET);
    }
        
    dcr |= DCR_DIRECTION;
    StoreControl (Controller, dcr);
    KeStallExecutionProcessor(1);
    
    for (i = 0; i < BufferSize; i++) {

        // dvtw - READ TIMEOUTS
        //
        // If it is the first byte then give it more time
        //
        if (!(GetStatus (Controller) & DSR_NOT_FAULT) || i == 0) {
        
            usTime = DEFAULT_RECEIVE_TIMEOUT;
            
        } else {
        
            usTime = IEEE_MAXTIME_TL;
        }        
        
        // *************** State 43 Reverse Phase ***************8
        // PeriphAck/PtrBusy        = DONT CARE
        // PeriphClk/PtrClk         = LOW ( State 43 )
        // nAckReverse/AckDataReq   = LOW 
        // XFlag                    = HIGH
        // nPeriphReq/nDataAvail    = DONT CARE
        
        Pdx->CurrentEvent = 43;
        if (!CHECK_DSR(Controller, DONT_CARE, INACTIVE, INACTIVE, ACTIVE, DONT_CARE,
                      usTime)) {
                  
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            
            dcr &= ~DCR_DIRECTION;
            StoreControl (Controller, dcr);
                
            // restore ecr register
            if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
                P5WritePortUchar(Controller + ECR_OFFSET, ecr);
            }
                
            *BytesTransferred = i;
            Pdx->log.SwEcpReadCount += *BytesTransferred;                
            return STATUS_IO_DEVICE_ERROR;
    
        }

        // *************** State 44 Setup Phase ***************8
        //  DIR                     = DONT CARE
        //  IRQEN                   = DONT CARE
        //  1284/SelectIn           = DONT CARE
        //  nReverseReq/**(ECP only)= DONT CARE
        //  HostAck/HostBusy        = HIGH ( State 44 )
        //  HostClk/nStrobe         = DONT CARE
        //
        Pdx->CurrentEvent = 44;
        dcr = P5ReadPortUchar(Controller + OFFSET_DCR);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE);
        P5WritePortUchar(Controller + OFFSET_DCR, dcr);

        // *************** State 45 Reverse Phase ***************8
        // PeriphAck/PtrBusy        = DONT CARE
        // PeriphClk/PtrClk         = HIGH ( State 45 )
        // nAckReverse/AckDataReq   = LOW 
        // XFlag                    = HIGH
        // nPeriphReq/nDataAvail    = DONT CARE
        Pdx->CurrentEvent = 45;
        if (!CHECK_DSR(Controller, DONT_CARE, ACTIVE, INACTIVE, ACTIVE, DONT_CARE,
                      IEEE_MAXTIME_TL)) {
                  
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            
            dcr &= ~DCR_DIRECTION;
            StoreControl (Controller, dcr);
                
            // restore ecr register
            if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
                P5WritePortUchar(Controller + ECR_OFFSET, ecr);
            }
                
            *BytesTransferred = i;
            Pdx->log.SwEcpReadCount += *BytesTransferred;                
            return STATUS_IO_DEVICE_ERROR;
    
        }

        //
        // Read the data
        //
        *pBuffer = P5ReadPortUchar (Controller + DATA_OFFSET);
        pBuffer++;
        
        // *************** State 46 Setup Phase ***************8
        //  DIR                     = DONT CARE
        //  IRQEN                   = DONT CARE
        //  1284/SelectIn           = DONT CARE
        //  nReverseReq/**(ECP only)= DONT CARE
        //  HostAck/HostBusy        = LOW ( State 46 )
        //  HostClk/nStrobe         = DONT CARE
        //
        Pdx->CurrentEvent = 46;
        dcr = P5ReadPortUchar(Controller + OFFSET_DCR);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE);
        P5WritePortUchar(Controller + OFFSET_DCR, dcr);

    }
    
    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
    
    dcr &= ~DCR_DIRECTION;
    StoreControl (Controller, dcr);
    
    // restore ecr register
    if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
        P5WritePortUchar(Controller + ECR_OFFSET, ecr);
    }

    *BytesTransferred = i;
    Pdx->log.SwEcpReadCount += *BytesTransferred;                
    return STATUS_SUCCESS;

}

NTSTATUS
ParEcpForwardToReverse(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine reverses the channel (ECP).

Arguments:

    Pdx  - Supplies the device extension.

--*/

{
    PUCHAR          Controller;
    LARGE_INTEGER   Wait35ms;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    UCHAR           dsr;
    UCHAR           dcr;
    UCHAR           ecr;
    
    Controller = Pdx->Controller;

    Wait35ms.QuadPart = 10*35*1000 + KeQueryTimeIncrement();
    
    dcr = GetControl (Controller);
    
    //
    // Put ECR into PS/2 mode to flush the FIFO.
    //

    // Save off the ECR register 

    // Note: Don't worry about checking to see if it's
    // safe to touch the ecr since we've already checked 
    // that before we allowed this mode to be activated.
    ecr = P5ReadPortUchar(Controller + ECR_OFFSET);

    //
    // Event 38
    //
    Pdx->CurrentEvent = 38;
    dcr |= DCR_AUTOFEED;
    StoreControl (Controller, dcr);
    KeStallExecutionProcessor(1);
    
    //
    // Event  39
    //
    Pdx->CurrentEvent = 39;
    dcr &= ~DCR_NOT_INIT;
    StoreControl (Controller, dcr);
    
    //
    // Wait for Event 40
    //
    Pdx->CurrentEvent = 40;
    KeQueryTickCount(&Start);
    while (TRUE) {

        KeQueryTickCount(&End);

        dsr = GetStatus(Controller);
        if (!(dsr & DSR_PERROR)) {
            break;
        }

        if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait35ms.QuadPart) {

            dsr = GetStatus(Controller);
            if (!(dsr & DSR_PERROR)) {
                break;
            }
#if DVRH_BUS_RESET_ON_ERROR
            BusReset(Controller+OFFSET_DCR);  // Pass in the dcr address
#endif
            // restore the ecr register
            if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
                P5WritePortUchar(Controller + ECR_OFFSET, ecr);
            }
            
            DD((PCE)Pdx,DDE,"ParEcpForwardToReverse: Failed to get State 40\n");
            return STATUS_IO_DEVICE_ERROR;
        }
    }
        
    // restore the ecr register
    if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
        P5WritePortUchar(Controller + ECR_OFFSET, ecr);
    }

    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
    return STATUS_SUCCESS;

}

NTSTATUS
ParEcpReverseToForward(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine puts the channel back into forward mode (ECP).

Arguments:

    Pdx           - Supplies the device extension.

--*/
{
    PUCHAR          Controller;
    LARGE_INTEGER   Wait35ms;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    UCHAR           dsr;
    UCHAR           dcr;
    UCHAR           ecr;
    
    Controller = Pdx->Controller;

    Wait35ms.QuadPart = 10*35*1000 + KeQueryTimeIncrement();
    
    dcr = GetControl (Controller);
    
    //
    // Put ECR into PS/2 mode to flush the FIFO.
    //

    // Save off the ECR register 
    
    // Note: Don't worry about checking to see if it's
    // safe to touch the ecr since we've already checked 
    // that before we allowed this mode to be activated.
    ecr = P5ReadPortUchar(Controller + ECR_OFFSET);

    //
    // Event 47
    //
    Pdx->CurrentEvent = 47;
    dcr |= DCR_NOT_INIT;
    StoreControl (Controller, dcr);
    
    //
    // Wait for Event 49
    //
    Pdx->CurrentEvent = 49;
    KeQueryTickCount(&Start);
    while (TRUE) {

        KeQueryTickCount(&End);

        dsr = GetStatus(Controller);
        if (dsr & DSR_PERROR) {
            break;
        }

        if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() >
            Wait35ms.QuadPart) {

            dsr = GetStatus(Controller);
            if (dsr & DSR_PERROR) {
                break;
            }
#if DVRH_BUS_RESET_ON_ERROR
            BusReset(Controller+OFFSET_DCR);  // Pass in the dcr address
#endif
            // Restore the ecr register
            if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
                P5WritePortUchar(Controller + ECR_OFFSET, ecr);
            }

            DD((PCE)Pdx,DDE,"ParEcpReverseToForward: Failed to get State 49\n");
            return STATUS_IO_DEVICE_ERROR;
        }
    }
        
    // restore the ecr register
    if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
        P5WritePortUchar(Controller + ECR_OFFSET, ecr);
    }

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\thread.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       thread.c
//
//--------------------------------------------------------------------------

//
// This file contains functions associated with ParClass worker threads
//

#include "pch.h"

VOID
PptPdoThread(
    IN PVOID Context
    )

/*++

Routine Description:

    This is the parallel thread routine.  Loops performing I/O operations.

Arguments:

    Context -- Really the extension

Return Value:

    None

--*/

{
    
    PPDO_EXTENSION  pdx = Context;
    KIRQL           OldIrql;
    NTSTATUS        Status;
    LARGE_INTEGER   Timeout;
    PIRP            CurrentIrp;

    DD((PCE)pdx,DDT,"PptPdoThread - %s - enter\n",pdx->Location);

    do {

        Timeout = pdx->IdleTimeout;

        Status  = KeWaitForSingleObject( &pdx->RequestSemaphore, UserRequest, KernelMode, FALSE, &Timeout );
        
        if( Status == STATUS_TIMEOUT ) {

            if( pdx->P12843DL.bEventActive ) {

                // Dot4.sys has a worker thread blocked on this event
                // waiting for us to signal if the peripheral has data
                // available for dot4 to read. When we signal this
                // event dot4.sys generates a read request to retrieve
                // the data from the peripheral.

                if( ParHaveReadData( pdx ) ) {
                    // the peripheral has data - signal dot4.sys
                    DD((PCE)pdx,DDT,"PptPdoThread: Signaling Event [%x]\n", pdx->P12843DL.Event);
                    KeSetEvent(pdx->P12843DL.Event, 0, FALSE);
                }
            }

            if( pdx->QueryNumWaiters( pdx->PortContext ) != 0 ) {

                // someone else is waiting on the port - give up the
                // port - we'll attempt to reaquire the port later
                // when we have a request to process

                ParTerminate(pdx);
                ParFreePort(pdx);
                continue;
            }

        } // endif STATUS_TIMEOUT


        // wait here if PnP has paused us (e.g., QUERY_STOP, STOP, QUERY_REMOVE)
        KeWaitForSingleObject(&pdx->PauseEvent, Executive, KernelMode, FALSE, 0);

        if ( pdx->TimeToTerminateThread ) {

            // A dispatch thread has signalled us that we should clean
            // up any communication with our peripheral and then
            // terminate self. The dispatch thread is blocked waiting
            // for us to terminate self.

            if( pdx->Connected ) {

                // We currently have the port acquired and have the
                // peripheral negotiated into an IEEE mode. Terminate
                // the peripheral back to Compatibility mode forward
                // idle and release the port.

                ParTerminate( pdx );
                ParFreePort( pdx );
            }

            // terminate self

            PsTerminateSystemThread( STATUS_SUCCESS );
        }


        //
        // process the next request from the work queue - use the
        // Cancel SpinLock to protect the queue
        //

        IoAcquireCancelSpinLock(&OldIrql);

        ASSERT(!pdx->CurrentOpIrp);

        while (!IsListEmpty(&pdx->WorkQueue)) {

            // get next IRP from our list of work items
            PLIST_ENTRY HeadOfList;
            HeadOfList = RemoveHeadList(&pdx->WorkQueue);
            CurrentIrp = CONTAINING_RECORD(HeadOfList, IRP, Tail.Overlay.ListEntry);

            // we have started processing, this IRP can no longer be cancelled
#pragma warning( push ) 
#pragma warning( disable : 4054 4055 )
            IoSetCancelRoutine(CurrentIrp, NULL);
#pragma warning( pop ) 
            ASSERT(NULL == CurrentIrp->CancelRoutine);
            ASSERT(!CurrentIrp->Cancel);

            pdx->CurrentOpIrp = CurrentIrp;

            IoReleaseCancelSpinLock(OldIrql);

            //
            // Do the Io - PptPdoStartIo will exectute and complete the IRP: pdx->CurrentIrp
            //
            PptPdoStartIo(pdx);

            if( pdx->P12843DL.bEventActive ) {

                // Dot4.sys has a worker thread blocked on this event
                // waiting for us to signal if the peripheral has data
                // available for dot4 to read. When we signal this
                // event dot4.sys generates a read request to retrieve
                // the data from the peripheral.

                if( ParHaveReadData( pdx ) ) {
                    // the peripheral has data - signal dot4.sys
                    DD((PCE)pdx,DDT,"PptPdoThread: Signaling Eventb [%x]\n", pdx->P12843DL.Event);
                    KeSetEvent(pdx->P12843DL.Event, 0, FALSE);
                }
            }

            // wait here if PnP has paused us (e.g., QUERY_STOP, STOP, QUERY_REMOVE)
            KeWaitForSingleObject(&pdx->PauseEvent, Executive, KernelMode, FALSE, 0);

            IoAcquireCancelSpinLock(&OldIrql);
        }
        IoReleaseCancelSpinLock(OldIrql);

    } while (TRUE);
}

NTSTATUS
ParCreateSystemThread(
    PPDO_EXTENSION Pdx
    )

{
    NTSTATUS        Status;
    HANDLE          ThreadHandle;
    OBJECT_ATTRIBUTES objAttrib;

    DD((PCE)Pdx,DDT,"ParCreateSystemThread - %s - enter\n",Pdx->Location);

    // Start the thread - save referenced pointer to thread in our extension
    InitializeObjectAttributes( &objAttrib, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );
    Status = PsCreateSystemThread( &ThreadHandle, THREAD_ALL_ACCESS, &objAttrib, NULL, NULL, PptPdoThread, Pdx );
    if (!NT_ERROR(Status)) {
        // We've got the thread.  Now get a pointer to it.
        Status = ObReferenceObjectByHandle( ThreadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, &Pdx->ThreadObjectPointer, NULL );
        if (NT_ERROR(Status)) {
            if (!Pdx->TimeToTerminateThread) 
            {
                // set the flag for the worker thread to kill itself
                Pdx->TimeToTerminateThread = TRUE;

                // wake up the thread so it can kill itself
                KeReleaseSemaphore(&Pdx->RequestSemaphore, 0, 1, FALSE );

            }

            // error, go ahead and close the thread handle
            ZwClose(ThreadHandle);

        } else {
            // Now that we have a reference to the thread we can simply close the handle.
            ZwClose(ThreadHandle);
        }
        DD((PCE)Pdx,DDT,"ParCreateSystemThread - %s - SUCCESS\n",Pdx->Location);
    } else {
        DD((PCE)Pdx,DDT,"ParCreateSystemThread - %s FAIL - status = %x\n",Pdx->Location, Status);
    }
    return Status;
}

VOID
PptPdoStartIo(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine starts an I/O operation for the driver and
    then returns

Arguments:

    Pdx - The parallel device extension

Return Value:

    None

--*/

{
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    KIRQL                   CancelIrql;

    Irp = Pdx->CurrentOpIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Information = 0;

    if (!Pdx->Connected && !ParAllocPort(Pdx)) {
        // #pragma message( "dvrh Left bad stuff in thread.c") 
        DD((PCE)Pdx,DDE,"PptPdoStartIo - %s - threads are hosed\n",Pdx->Location);
        //        __asm int 3   
        //
        // If the allocation didn't succeed then fail this IRP.
        //
        goto CompleteIrp;
    }

    switch (IrpSp->MajorFunction) {

        case IRP_MJ_WRITE:
            ParWriteIrp(Pdx);
            break;

        case IRP_MJ_READ:
            ParReadIrp(Pdx);
            break;

        default:
            ParDeviceIo(Pdx);
            break;
    }

    if (!Pdx->Connected && !Pdx->AllocatedByLockPort) {
    
        // if we're not connected in a 1284 mode, then release host port
        // otherwise let the watchdog timer do it.

        ParFreePort(Pdx);
    }

CompleteIrp:

    IoAcquireCancelSpinLock(&CancelIrql);
    Pdx->CurrentOpIrp = NULL;
    IoReleaseCancelSpinLock(CancelIrql);

    P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\utils.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       util.c
//
//--------------------------------------------------------------------------

#include "pch.h"

#define		IDMFG				0
#define		IDMDL				1
#define		NUMOFBROTHERPRODUCT	14


CHAR *XflagOnEvent24Devices[NUMOFBROTHERPRODUCT][2] =
{

	//	Brother
      {"Brother",		"MFC"	},				//	0
      {"Brother",		"FAX"	},				//	1
      {"Brother",		"HL-P"	},				//	2
      {"Brother",		"DCP"	},				//	3
	//	PB
      {"PitneyBowes",	"1630"	},				//	4
      {"PitneyBowes",	"1640"	},				//	5
	//	LEGEND
      {"LEGEND",		"LJ6112MFC"	},			//	6
      {"LEGEND",		"LJ6212MFC"	},			//	7
	//
      {"HBP",			"MFC 6550"	},			//	8
      {"HBP",			"OMNI L621"	},			//	9
      {"HBP",			"LJ 6106MFC"	},		//	10
      {"HBP",			"LJ 6206MFC"	},		//	11

	// P2500
      {"Legend",		"LJ6012MFP"	},			//	12

	//Terminater
      {NULL,		NULL	}					//	13
	
};
    

NTSTATUS
PptAcquireRemoveLockOrFailIrp(PDEVICE_OBJECT DevObj, PIRP Irp)
{
    PFDO_EXTENSION   fdx    = DevObj->DeviceExtension;
    NTSTATUS         status = PptAcquireRemoveLock( &fdx->RemoveLock, Irp );

    if( status != STATUS_SUCCESS ) {
        P4CompleteRequest( Irp, status, Irp->IoStatus.Information );
    }
    return status;
}

NTSTATUS
PptDispatchPreProcessIrp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
/*++

    - Acquire removelock
    - If(!Special Handling IRP) {
          check if we are running, stalled
         

--*/
{
    PFDO_EXTENSION Fdx = DevObj->DeviceExtension;
    NTSTATUS status = PptAcquireRemoveLock(&Fdx->RemoveLock, Irp);
    UNREFERENCED_PARAMETER(DevObj);
    UNREFERENCED_PARAMETER(Irp);


        if ( !NT_SUCCESS( status ) ) {
            //
            // Someone gave us a pnp irp after a remove.  Unthinkable!
            //
            PptAssertMsg("Someone gave us a PnP IRP after a Remove",FALSE);
            P4CompleteRequest( Irp, status, 0 );
        }

    return status;
}

NTSTATUS
PptSynchCompletionRoutine(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++
      
Routine Description:
      
    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.
      
Arguments:
      
    DriverObject - Pointer to driver object created by system.
      
    Irp          - Irp that just completed
      
    Event        - Event we'll signal to say Irp is done
      
Return Value:
      
    None.
      
--*/
{
    UNREFERENCED_PARAMETER( Irp );
    UNREFERENCED_PARAMETER( DevObj );

    KeSetEvent((PKEVENT) Event, 0, FALSE);
    return (STATUS_MORE_PROCESSING_REQUIRED);
}

PWSTR
PptGetPortNameFromPhysicalDeviceObject(
  PDEVICE_OBJECT PhysicalDeviceObject
)

/*++

Routine Description:

    Retrieve the PortName for the ParPort from the registry. This PortName
      will be used as the symbolic link name for the end of chain device 
      object created by ParClass for this ParPort.

    *** This function allocates pool. ExFreePool must be called when
          result is no longer needed.

Arguments:

    PortDeviceObject - The ParPort Device Object

Return Value:

    PortName - if successful
    NULL     - otherwise

--*/

{
    NTSTATUS                    status;
    HANDLE                      hKey;
    PKEY_VALUE_FULL_INFORMATION buffer;
    ULONG                       bufferLength;
    ULONG                       resultLength;
    PWSTR                       valueNameWstr;
    UNICODE_STRING              valueName;
    PWSTR                       portName = NULL;

    PAGED_CODE ();

    //
    // try to open the registry key
    //

    status = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_ALL,
                                     &hKey);

    if( !NT_SUCCESS(status) ) {
        // unable to open key, bail out
        DD(NULL,DDT,"PptGetPortNameFromPhysicalDeviceObject(): FAIL w/status = %x\n", status);
        return NULL;    
    }

    //
    // we have a handle to the registry key
    //
    // loop trying to read registry value until either we succeed or
    //   we get a hard failure, grow the result buffer as needed
    //

    bufferLength  = 0;          // we will ask how large a buffer we need
    buffer        = NULL;
    valueNameWstr = (PWSTR)L"PortName";
    RtlInitUnicodeString(&valueName, valueNameWstr);
    status        = STATUS_BUFFER_TOO_SMALL;

    while(status == STATUS_BUFFER_TOO_SMALL) {

      status = ZwQueryValueKey(hKey,
                               &valueName,
                               KeyValueFullInformation,
                               buffer,
                               bufferLength,
                               &resultLength);

      if(status == STATUS_BUFFER_TOO_SMALL) {
          // 
          // buffer too small, free it and allocate a larger buffer
          //
          if(buffer) ExFreePool(buffer);
          buffer       = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, resultLength);
          bufferLength = resultLength;
          if(!buffer) {
              // unable to allocate pool, clean up and exit
              ZwClose(hKey);
              return NULL;
          }
      }
      
    } // end while BUFFER_TOO_SMALL

    
    //
    // query is complete
    //

    // no longer need the handle so close it
    ZwClose(hKey);

    // check the status of our query
    if( !NT_SUCCESS(status) ) {
        if(buffer) ExFreePool(buffer);
        return NULL;
    }

    // make sure we have a buffer
    if( buffer ) {

        // sanity check our result, should be of the form L"LPTx" where x is L'1', L'2', or L'3'
        if( (buffer->Type != REG_SZ) || (buffer->DataLength < (5 * sizeof(WCHAR)) ) ) {
            ExFreePool(buffer);       // query succeeded, so we know we have a buffer
            return NULL;
        }

        {
            PWSTR portName = (PWSTR)((PCHAR)buffer + buffer->DataOffset);
            if( portName[0] != L'L' ||
                portName[1] != L'P' ||
                portName[2] != L'T' ||
                portName[3] <  L'0' ||
                portName[3] >  L'9' || 
                portName[4] != L'\0' ) {

                DD(NULL,DDW,"PptGetPortNameFromPhysicalDeviceObject(): PortName in registry != \"LPTx\" format\n");
                ExFreePool(buffer);
                return NULL;
            }
        }    


        // 
        // result looks ok, copy PortName to its own allocation of the proper size
        //   and return a pointer to it
        //

        portName = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, buffer->DataLength);

        if(!portName) {
            // unable to allocate pool, clean up and exit
            ExFreePool(buffer);
            return NULL;
        }

        RtlCopyMemory(portName, (PUCHAR)buffer + buffer->DataOffset, buffer->DataLength);

        ExFreePool( buffer );
    }

    return portName;
}

NTSTATUS
PptConnectInterrupt(
    IN  PFDO_EXTENSION   Fdx
    )

/*++
      
Routine Description:
      
    This routine connects the port interrupt service routine
      to the interrupt.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    NTSTATUS code.
      
--*/
    
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    if (!Fdx->FoundInterrupt) {
        
        return STATUS_NOT_SUPPORTED;
        
    }
    
    //
    // Connect the interrupt.
    //
    
    Status = IoConnectInterrupt(&Fdx->InterruptObject,
                                PptInterruptService,
                                Fdx,
                                NULL,
                                Fdx->InterruptVector,
                                Fdx->InterruptLevel,
                                Fdx->InterruptLevel,
                                Fdx->InterruptMode,
                                TRUE,
                                Fdx->InterruptAffinity,
                                FALSE);
    
    if (!NT_SUCCESS(Status)) {
        
        PptLogError(Fdx->DeviceObject->DriverObject,
                    Fdx->DeviceObject,
                    Fdx->PortInfo.OriginalController,
                    PhysicalZero, 0, 0, 0, 14,
                    Status, PAR_INTERRUPT_CONFLICT);
        
    }
    
    return Status;
}

VOID
PptDisconnectInterrupt(
    IN  PFDO_EXTENSION   Fdx
    )

/*++
      
Routine Description:
      
    This routine disconnects the port interrupt service routine
      from the interrupt.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    None.
      
--*/
    
{
    IoDisconnectInterrupt(Fdx->InterruptObject);
}

BOOLEAN
PptSynchronizedIncrement(
    IN OUT  PVOID   SyncContext
    )

/*++
      
Routine Description:
      
    This routine increments the 'Count' variable in the context and returns
      its new value in the 'NewCount' variable.
      
Arguments:
      
    SyncContext - Supplies the synchronize count context.
      
Return Value:
      
    TRUE
      
--*/
    
{
    ((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->NewCount =
        ++(*(((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->Count));
    return(TRUE);
}

BOOLEAN
PptSynchronizedDecrement(
    IN OUT  PVOID   SyncContext
    )

/*++
      
Routine Description:
      
    This routine decrements the 'Count' variable in the context and returns
      its new value in the 'NewCount' variable.
      
Arguments:
      
    SyncContext - Supplies the synchronize count context.
      
Return Value:
      
    TRUE
      
--*/
    
{
    ((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->NewCount =
        --(*(((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->Count));
    return(TRUE);
}

BOOLEAN
PptSynchronizedRead(
    IN OUT  PVOID   SyncContext
    )

/*++
      
Routine Description:
      
    This routine reads the 'Count' variable in the context and returns
      its value in the 'NewCount' variable.
      
Arguments:
      
    SyncContext - Supplies the synchronize count context.
      
Return Value:
      
    None.
      
--*/
    
{
    ((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->NewCount =
        *(((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->Count);
    return(TRUE);
}

BOOLEAN
PptSynchronizedQueue(
    IN  PVOID   Context
    )

/*++
      
Routine Description:
      
    This routine adds the given list entry to the given list.
      
Arguments:
      
    Context - Supplies the synchronized list context.
      
Return Value:
      
    TRUE
      
--*/
    
{
    PSYNCHRONIZED_LIST_CONTEXT  ListContext;
    
    ListContext = Context;
    InsertTailList(ListContext->List, ListContext->NewEntry);
    return(TRUE);
}

BOOLEAN
PptSynchronizedDisconnect(
    IN  PVOID   Context
    )

/*++
      
Routine Description:
    
    This routine removes the given list entry from the ISR
      list.
      
Arguments:
      
    Context - Supplies the synchronized disconnect context.
      
Return Value:
      
    FALSE   - The given list entry was not removed from the list.
    TRUE    - The given list entry was removed from the list.
      
--*/
    
{
    PSYNCHRONIZED_DISCONNECT_CONTEXT    DisconnectContext;
    PKSERVICE_ROUTINE                   ServiceRoutine;
    PVOID                               ServiceContext;
    PLIST_ENTRY                         Current;
    PISR_LIST_ENTRY                     ListEntry;
    
    DisconnectContext = Context;
    ServiceRoutine = DisconnectContext->IsrInfo->InterruptServiceRoutine;
    ServiceContext = DisconnectContext->IsrInfo->InterruptServiceContext;
    
    for (Current = DisconnectContext->Extension->IsrList.Flink;
         Current != &(DisconnectContext->Extension->IsrList);
         Current = Current->Flink) {
        
        ListEntry = CONTAINING_RECORD(Current, ISR_LIST_ENTRY, ListEntry);
        if (ListEntry->ServiceRoutine == ServiceRoutine &&
            ListEntry->ServiceContext == ServiceContext) {
            
            RemoveEntryList(Current);
            return TRUE;
        }
    }
    
    return FALSE;
}

VOID
PptCancelRoutine(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )

/*++
      
Routine Description:
      
    This routine is called on when the given IRP is cancelled.  It
      will dequeue this IRP off the work queue and complete the
      request as CANCELLED.  If it can't get if off the queue then
      this routine will ignore the CANCEL request since the IRP
      is about to complete anyway.
      
Arguments:
      
    DeviceObject    - Supplies the device object.
      
    Irp             - Supplies the IRP.
      
Return Value:
      
    None.
      
--*/
    
{
    PFDO_EXTENSION           Fdx = DeviceObject->DeviceExtension;
    SYNCHRONIZED_COUNT_CONTEXT  SyncContext;
    
    DD((PCE)Fdx,DDT,"CANCEL IRP %x\n", Irp);
    
    SyncContext.Count = &Fdx->WorkQueueCount;
    
    if (Fdx->InterruptRefCount) {
        
        KeSynchronizeExecution( Fdx->InterruptObject, PptSynchronizedDecrement, &SyncContext );
    } else {
        PptSynchronizedDecrement( &SyncContext );
    }
    
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    IoReleaseCancelSpinLock(Irp->CancelIrql);
    
    PptReleaseRemoveLock(&Fdx->RemoveLock, Irp);

    P4CompleteRequest( Irp, STATUS_CANCELLED, 0 );
}

VOID
PptFreePortDpc(
    IN      PKDPC   Dpc,
    IN OUT  PVOID   Fdx,
    IN      PVOID   SystemArgument1,
    IN      PVOID   SystemArgument2
    )

/*++
      
Routine Description:
      
    This routine is a DPC that will free the port and if necessary
      complete an alloc request that is waiting.
      
Arguments:
      
    Dpc             - Not used.
      
    Fdx       - Supplies the device extension.
      
    SystemArgument1 - Not used.
      
    SystemArgument2 - Not used.
      
Return Value:
      
    None.
      
--*/
    
{
    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    PptFreePort(Fdx);
}

BOOLEAN
PptTryAllocatePortAtInterruptLevel(
    IN  PVOID   Context
    )

/*++
      
Routine Description:
      
    This routine is called at interrupt level to quickly allocate
      the parallel port if it is available.  This call will fail
      if the port is not available.
      
Arguments:
      
    Context - Supplies the device extension.
      
Return Value:
      
    FALSE   - The port was not allocated.
    TRUE    - The port was successfully allocated.
     
--*/
    
{
    if (((PFDO_EXTENSION) Context)->WorkQueueCount == -1) {
        
        ((PFDO_EXTENSION) Context)->WorkQueueCount = 0;
        
        ( (PFDO_EXTENSION)Context )->WmiPortAllocFreeCounts.PortAllocates++;

        return(TRUE);
        
    } else {
        
        return(FALSE);
    }
}

VOID
PptFreePortFromInterruptLevel(
    IN  PVOID   Context
    )

/*++
      
Routine Description:
      
    This routine frees the port that was allocated at interrupt level.
      
Arguments:
      
    Context - Supplies the device extension.
      
Return Value:
      
    None.
      
--*/
    
{
    // If no one is waiting for the port then this is simple operation,
    // otherwise queue a DPC to free the port later on.
    
    if (((PFDO_EXTENSION) Context)->WorkQueueCount == 0) {
        
        ((PFDO_EXTENSION) Context)->WorkQueueCount = -1;
        
    } else {
        
        KeInsertQueueDpc(&((PFDO_EXTENSION) Context)->FreePortDpc, NULL, NULL);
    }
}

BOOLEAN
PptInterruptService(
    IN  PKINTERRUPT Interrupt,
    IN  PVOID       Fdx
    )
/*++
      
Routine Description:
      
    This routine services the interrupt for the parallel port.
      This routine will call out to all of the interrupt routines
      that connected with this device via
      IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT in order until
      one of them returns TRUE.
      
Arguments:
      
    Interrupt   - Supplies the interrupt object.
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    FALSE   - The interrupt was not handled.
    TRUE    - The interrupt was handled.
      
--*/
{
    PLIST_ENTRY      Current;
    PISR_LIST_ENTRY  IsrListEntry;
    PFDO_EXTENSION   fdx = Fdx;
    
    for( Current = fdx->IsrList.Flink; Current != &fdx->IsrList; Current = Current->Flink ) {
        
        IsrListEntry = CONTAINING_RECORD(Current, ISR_LIST_ENTRY, ListEntry);

        if (IsrListEntry->ServiceRoutine(Interrupt, IsrListEntry->ServiceContext)) {
            return TRUE;
        }
    }
    
    return FALSE;
}

BOOLEAN
PptTryAllocatePort(
    IN  PVOID   Fdx
    )

/*++
      
Routine Description:
      
    This routine attempts to allocate the port.  If the port is
      available then the call will succeed with the port allocated.
      If the port is not available the then call will fail
      immediately.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    FALSE   - The port was not allocated.
    TRUE    - The port was allocated.
      
--*/
    
{
    PFDO_EXTENSION   fdx = Fdx;
    KIRQL            CancelIrql;
    BOOLEAN          b;
    
    if (fdx->InterruptRefCount) {
        
        b = KeSynchronizeExecution( fdx->InterruptObject, PptTryAllocatePortAtInterruptLevel, fdx );
        
    } else {
        
        IoAcquireCancelSpinLock(&CancelIrql);
        b = PptTryAllocatePortAtInterruptLevel(fdx);
        IoReleaseCancelSpinLock(CancelIrql);
    }
    
    DD((PCE)fdx,DDT,"PptTryAllocatePort on %x returned %x\n", fdx->PortInfo.Controller, b);

    return b;
}

BOOLEAN
PptTraversePortCheckList(
    IN  PVOID   Fdx
    )

/*++
      
Routine Description:
      
    This routine traverses the deferred port check routines.  This
      call must be synchronized at interrupt level so that real
      interrupts are blocked until these routines are completed.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    FALSE   - The port is in use so no action taken by this routine.
    TRUE    - All of the deferred interrupt routines were called.
      
--*/
    
{
    PFDO_EXTENSION   fdx = Fdx;
    PLIST_ENTRY         Current;
    PISR_LIST_ENTRY     CheckEntry;
    
    //
    // First check to make sure that the port is still free.
    //
    if (fdx->WorkQueueCount >= 0) {
        return FALSE;
    }
    
    for (Current = fdx->IsrList.Flink;
         Current != &fdx->IsrList;
         Current = Current->Flink) {
        
        CheckEntry = CONTAINING_RECORD(Current,
                                       ISR_LIST_ENTRY,
                                       ListEntry);
        
        if (CheckEntry->DeferredPortCheckRoutine) {
            CheckEntry->DeferredPortCheckRoutine(CheckEntry->CheckContext);
        }
    }
    
    return TRUE;
}

VOID
PptFreePort(
    IN  PVOID   Fdx
    )
/*++
      
Routine Description:
      
    This routine frees the port.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    None.
      
--*/
{
    PFDO_EXTENSION              fdx = Fdx;
    SYNCHRONIZED_COUNT_CONTEXT  SyncContext;
    KIRQL                       CancelIrql;
    PLIST_ENTRY                 Head;
    PIRP                        Irp;
    PIO_STACK_LOCATION          IrpSp;
    ULONG                       InterruptRefCount;
    PPARALLEL_1284_COMMAND      Command;
    BOOLEAN                     Allocated;

    DD((PCE)fdx,DDT,"PptFreePort\n");

    SyncContext.Count = &fdx->WorkQueueCount;
    
    IoAcquireCancelSpinLock( &CancelIrql );
    if (fdx->InterruptRefCount) {
        KeSynchronizeExecution( fdx->InterruptObject, PptSynchronizedDecrement, &SyncContext );
    } else {
        PptSynchronizedDecrement( &SyncContext );
    }
    IoReleaseCancelSpinLock( CancelIrql );

    //
    // Log the free for WMI
    //
    fdx->WmiPortAllocFreeCounts.PortFrees++;

    //
    // Port is free, check for queued ALLOCATE and/or SELECT requests
    //

    Allocated = FALSE;

    while( !Allocated && SyncContext.NewCount >= 0 ) {

        //
        // We have ALLOCATE and/or SELECT requests queued, satisfy the first request
        //
        IoAcquireCancelSpinLock(&CancelIrql);
        Head = RemoveHeadList(&fdx->WorkQueue);
        if( Head == &fdx->WorkQueue ) {
            // queue is empty - we're done - exit while loop
            IoReleaseCancelSpinLock(CancelIrql);
            break;
        }
        Irp = CONTAINING_RECORD(Head, IRP, Tail.Overlay.ListEntry);
        PptSetCancelRoutine(Irp, NULL);

        if ( Irp->Cancel ) {

            Irp->IoStatus.Status = STATUS_CANCELLED;

            // Irp was cancelled so have to get next in line
            SyncContext.Count = &fdx->WorkQueueCount;
    
            if (fdx->InterruptRefCount) {
                KeSynchronizeExecution(fdx->InterruptObject, PptSynchronizedDecrement, &SyncContext);
            } else {
                PptSynchronizedDecrement(&SyncContext);
            }

            IoReleaseCancelSpinLock(CancelIrql);

        } else {

            Allocated = TRUE;
            IoReleaseCancelSpinLock(CancelIrql);
        
            // Finding out what kind of IOCTL it was
            IrpSp = IoGetCurrentIrpStackLocation(Irp);
        
            // Check to see if we need to select a 
            if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_INTERNAL_SELECT_DEVICE ) {

                // request at head of queue was a SELECT
                // so call the select function with the device command saying we already have port

                Command  = (PPARALLEL_1284_COMMAND)Irp->AssociatedIrp.SystemBuffer;
                Command->CommandFlags |= PAR_HAVE_PORT_KEEP_PORT;

                // Call Function to try to select device
                Irp->IoStatus.Status = PptTrySelectDevice( Fdx, Command );
            
            } else {
                // request at head of queue was an ALLOCATE
                Irp->IoStatus.Status = STATUS_SUCCESS;
            }

            // Note that another Allocate request has been granted (WMI counts allocs)
            fdx->WmiPortAllocFreeCounts.PortAllocates++;
        }

        // Remove remove lock on Irp and Complete request whether the Irp
        // was cancelled or we acquired the port
        PptReleaseRemoveLock(&fdx->RemoveLock, Irp);
        P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
    }

    if( !Allocated ) {

        //
        // ALLOCATE/SELECT request queue was empty
        //
        IoAcquireCancelSpinLock(&CancelIrql);
        InterruptRefCount = fdx->InterruptRefCount;
        IoReleaseCancelSpinLock(CancelIrql);
        if ( InterruptRefCount ) {
            KeSynchronizeExecution( fdx->InterruptObject, PptTraversePortCheckList, fdx );
        }
    }

    return;
}

ULONG
PptQueryNumWaiters(
    IN  PVOID   Fdx
    )

/*++
      
Routine Description:
      
    This routine returns the number of irps queued waiting for
      the parallel port.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    The number of irps queued waiting for the port.
      
--*/
    
{
    PFDO_EXTENSION           fdx = Fdx;
    KIRQL                       CancelIrql;
    SYNCHRONIZED_COUNT_CONTEXT  SyncContext;
    LONG                        count;
    
    SyncContext.Count = &fdx->WorkQueueCount;
    if (fdx->InterruptRefCount) {
        KeSynchronizeExecution(fdx->InterruptObject,
                               PptSynchronizedRead,
                               &SyncContext);
    } else {
        IoAcquireCancelSpinLock(&CancelIrql);
        PptSynchronizedRead(&SyncContext);
        IoReleaseCancelSpinLock(CancelIrql);
    }
    
    count = (SyncContext.NewCount >= 0) ? ((ULONG)SyncContext.NewCount) : 0;

    if( fdx->FdoWaitingOnPort ) {
        ++count;
    }

    return count;
}

PVOID
PptSetCancelRoutine(PIRP Irp, PDRIVER_CANCEL CancelRoutine)
{
// #pragma warning( push )
// 4054: 'type cast' : from function pointer to data pointer
// 4055: 'type cast' : from data pointer to function pointer
// 4152:  nonstandard extension, function/data pointer conversion in expression
#pragma warning( disable : 4054 4055 4152 )
    return IoSetCancelRoutine(Irp, CancelRoutine);
    // #pragma warning( pop )
}

// this is the version from Win2k parclass
BOOLEAN
CheckPort(
    IN  PUCHAR  wPortAddr,
    IN  UCHAR   bMask,
    IN  UCHAR   bValue,
    IN  USHORT  msTimeDelay
    )
/*++

Routine Description:
    This routine will loop for a given time period (actual time is
    passed in as an arguement) and wait for the dsr to match
    predetermined value (dsr value is passed in).

Arguments:
    wPortAddr   - Supplies the base address of the parallel port + some offset.
                  This will have us point directly to the dsr (controller + 1).
    bMask       - Mask used to determine which bits we are looking at
    bValue      - Value we are looking for.
    msTimeDelay - Max time to wait for peripheral response (in ms)

Return Value:
    TRUE if a dsr match was found.
    FALSE if the time period expired before a match was found.
--*/

{
    UCHAR  dsr;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;

    // Do a quick check in case we have one stinkingly fast peripheral!
    dsr = P5ReadPortUchar(wPortAddr);
    if ((dsr & bMask) == bValue)
        return TRUE;

    Wait.QuadPart = (msTimeDelay * 10 * 1000) + KeQueryTimeIncrement();
    KeQueryTickCount(&Start);

CheckPort_Start:
    KeQueryTickCount(&End);
    dsr = P5ReadPortUchar(wPortAddr);
    if ((dsr & bMask) == bValue)
        return TRUE;

    if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart)
    {
        // We timed out!!!

        // do one last check
        dsr = P5ReadPortUchar(wPortAddr);
        if ((dsr & bMask) == bValue)
            return TRUE;

#if DVRH_BUS_RESET_ON_ERROR
            BusReset(wPortAddr+1);  // Pass in the dcr address
#endif

#if DBG
            DD(NULL,DDW,"CheckPort: Timeout\n");
            {
                int i;
                for (i = 3; i < 8; i++) {
                    if ((bMask >> i) & 1) {
                        if (((bValue >> i) & 1) !=  ((dsr >> i) & 1)) {
                            DD(NULL,DDW,"Bit %d is %d and should be %d!!!\n", i, (dsr >> i) & 1, (bValue >> i) & 1);
                        }
                    }
                }
            }
#endif
        goto CheckPort_TimeOut;
    }
    goto CheckPort_Start;

CheckPort_TimeOut:

    return FALSE;    
}

NTSTATUS
PptBuildParallelPortDeviceName(
    IN  ULONG           Number,
    OUT PUNICODE_STRING DeviceName
    )
/*++
      
Routine Description:
      
    Build a Device Name of the form: \Device\ParallelPortN
      
    *** On success this function returns allocated memory that must be freed by the caller

Arguments:
      
    DriverObject          - ParPort driver object
    PhysicalDeviceObject  - PDO whose stack the ParPort FDO will attach to
    DeviceObject          - ParPort FDO
    UniNameString         - the DeviceName (e.g., \Device\ParallelPortN)
    PortName              - the "LPTx" PortName from the devnode
    PortNumber            - the "N" in \Device\ParallelPortN
      
Return Value:
      
    STATUS_SUCCESS on success

    error status otherwise
      
--*/
{
    UNICODE_STRING      uniDeviceString;
    UNICODE_STRING      uniBaseNameString;
    UNICODE_STRING      uniPortNumberString;
    WCHAR               wcPortNum[10];
    NTSTATUS            status;

    //
    // Init strings
    //
    RtlInitUnicodeString( DeviceName, NULL );
    RtlInitUnicodeString( &uniDeviceString, (PWSTR)L"\\Device\\" );
    RtlInitUnicodeString( &uniBaseNameString, (PWSTR)DD_PARALLEL_PORT_BASE_NAME_U );


    //
    // Convert Port Number to UNICODE_STRING
    //
    uniPortNumberString.Length        = 0;
    uniPortNumberString.MaximumLength = sizeof( wcPortNum );
    uniPortNumberString.Buffer        = wcPortNum;

    status = RtlIntegerToUnicodeString( Number, 10, &uniPortNumberString);
    if( !NT_SUCCESS( status ) ) {
        return status;
    }


    //
    // Compute size required and alloc a buffer
    //
    DeviceName->MaximumLength = (USHORT)( uniDeviceString.Length +
                                          uniBaseNameString.Length +
                                          uniPortNumberString.Length +
                                          sizeof(UNICODE_NULL) );

    DeviceName->Buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, DeviceName->MaximumLength );
    if( NULL == DeviceName->Buffer ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory( DeviceName->Buffer, DeviceName->MaximumLength );


    //
    // Catenate the parts to construct the DeviceName
    //
    RtlAppendUnicodeStringToString(DeviceName, &uniDeviceString);
    RtlAppendUnicodeStringToString(DeviceName, &uniBaseNameString);
    RtlAppendUnicodeStringToString(DeviceName, &uniPortNumberString);

    return STATUS_SUCCESS;
}

NTSTATUS
PptInitializeDeviceExtension(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject,
    IN PDEVICE_OBJECT  DeviceObject,
    IN PUNICODE_STRING UniNameString,
    IN PWSTR           PortName,
    IN ULONG           PortNumber
    )
/*++
      
Routine Description:
      
    Initialize a ParPort FDO DeviceExtension
      
Arguments:
      
    DriverObject          - ParPort driver object
    PhysicalDeviceObject  - PDO whose stack the ParPort FDO will attach to
    DeviceObject          - ParPort FDO
    UniNameString         - the DeviceName (e.g., \Device\ParallelPortN)
    PortName              - the "LPTx" PortName from the devnode
    PortNumber            - the "N" in \Device\ParallelPortN
      
Return Value:
      
    STATUS_SUCCESS on success

    error status otherwise
      
--*/
{
    PFDO_EXTENSION Fdx = DeviceObject->DeviceExtension;

    RtlZeroMemory( Fdx, sizeof(FDO_EXTENSION) );

    //
    // Signature1 helps confirm that we are looking at a Parport DeviceExtension
    //
    Fdx->Signature1 = PARPORT_TAG;
    Fdx->Signature2 = PARPORT_TAG;

    //
    // Standard Info
    //
    Fdx->DriverObject         = DriverObject;
    Fdx->PhysicalDeviceObject = PhysicalDeviceObject;
    Fdx->DeviceObject         = DeviceObject;
    Fdx->PnpInfo.PortNumber   = PortNumber; // this is the "N" in \Device\ParallelPortN

    //
    // We are an FDO
    //
    Fdx->DevType = DevTypeFdo;

    //
    // Mutual Exclusion initialization
    //
    IoInitializeRemoveLock(&Fdx->RemoveLock, PARPORT_TAG, 1, 10);
    ExInitializeFastMutex(&Fdx->OpenCloseMutex);
    ExInitializeFastMutex(&Fdx->ExtensionFastMutex);

    //
    // chipset detection initialization - redundant, but safer
    //
    Fdx->NationalChipFound = FALSE;
    Fdx->NationalChecked   = FALSE;

    //
    // List Head for List of PDOs to delete during driver unload, if not before
    //
    InitializeListHead(&Fdx->DevDeletionListHead);

    //
    // Initialize 'WorkQueue' - a Queue for Allocate and Select requests
    //
    InitializeListHead(&Fdx->WorkQueue);
    Fdx->WorkQueueCount = -1;

    //
    // Initialize Exports - Exported via Internal IOCTLs
    //
    Fdx->PortInfo.FreePort            = PptFreePort;
    Fdx->PortInfo.TryAllocatePort     = PptTryAllocatePort;
    Fdx->PortInfo.QueryNumWaiters     = PptQueryNumWaiters;
    Fdx->PortInfo.Context             = Fdx;

    Fdx->PnpInfo.HardwareCapabilities = PPT_NO_HARDWARE_PRESENT;
    Fdx->PnpInfo.TrySetChipMode       = PptSetChipMode;
    Fdx->PnpInfo.ClearChipMode        = PptClearChipMode;
    Fdx->PnpInfo.TrySelectDevice      = PptTrySelectDevice;
    Fdx->PnpInfo.DeselectDevice       = PptDeselectDevice;
    Fdx->PnpInfo.Context              = Fdx;
    Fdx->PnpInfo.PortName             = PortName;

    //
    // Save location info in common extension
    //
    {
        ULONG bufLen = sizeof("LPTxF");
        PCHAR buffer = ExAllocatePool( NonPagedPool, bufLen );
        if( buffer ) {
            RtlZeroMemory( buffer, bufLen );
            _snprintf( buffer, bufLen, "%.4SF", PortName );
            Fdx->Location = buffer;
        }
    }

    //
    // Empty list of interrupt service routines, interrupt NOT connected
    //
    InitializeListHead( &Fdx->IsrList );
    Fdx->InterruptObject   = NULL;
    Fdx->InterruptRefCount = 0;

    //
    // Initialize the free port DPC.
    //
    KeInitializeDpc( &Fdx->FreePortDpc, PptFreePortDpc, Fdx );

    //
    // Save Device Name in our extension
    //
    {
        ULONG bufferLength = UniNameString->MaximumLength + sizeof(UNICODE_NULL);
        Fdx->DeviceName.Buffer = ExAllocatePool(NonPagedPool, bufferLength);
        if( !Fdx->DeviceName.Buffer ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlZeroMemory( Fdx->DeviceName.Buffer, bufferLength );
        Fdx->DeviceName.Length        = 0;
        Fdx->DeviceName.MaximumLength = UniNameString->MaximumLength;
        RtlCopyUnicodeString( &Fdx->DeviceName, UniNameString );
    }

    //
    // Port is in default mode and mode has not been set 
    //   by a lower filter driver
    //
    Fdx->PnpInfo.CurrentMode  = INITIAL_MODE;
    Fdx->FilterMode           = FALSE;

    return STATUS_SUCCESS;
}

NTSTATUS
PptGetPortNumberFromLptName( 
    IN  PWSTR  PortName, 
    OUT PULONG PortNumber 
    )
/*++
      
Routine Description:
      
    Verify that the LptName is of the form LPTn, if so then return
    the integer value of n
      
Arguments:
      
    PortName   - the PortName extracted from the devnode - expected to be 
                   of the form: "LPTn"

    PortNumber - points to the UNLONG that will hold the result on success
      
Return Value:
      
    STATUS_SUCCESS on success - *PortNumber will contain the integer value of n

    error status otherwise
      
--*/
{
    NTSTATUS       status;
    UNICODE_STRING str;

    //
    // Verify that the PortName looks like LPTx where x is a number
    //

    if( PortName[0] != L'L' || PortName[1] != L'P' || PortName[2] != L'T' ) {
        DD(NULL,DDE,"PptGetPortNumberFromLptName - name prefix doesn't look like LPT\n");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // prefix is LPT, check for integer suffix with value > 0
    //
    RtlInitUnicodeString( &str, (PWSTR)&PortName[3] );

    status = RtlUnicodeStringToInteger( &str, 10, PortNumber );

    if( !NT_SUCCESS( status ) ) {
        DD(NULL,DDT,"util::PptGetPortNumberFromLptName - name suffix doesn't look like an integer\n");
        return STATUS_UNSUCCESSFUL;
    }

    if( *PortNumber == 0 ) {
        DD(NULL,DDT,"util::PptGetPortNumberFromLptName - name suffix == 0 - FAIL - Invalid value\n");
        return STATUS_UNSUCCESSFUL;
    }

    DD(NULL,DDT,"util::PptGetPortNumberFromLptName - LPT name suffix= %d\n", *PortNumber);

    return STATUS_SUCCESS;
}

PDEVICE_OBJECT
PptBuildFdo( 
    IN PDRIVER_OBJECT DriverObject, 
    IN PDEVICE_OBJECT PhysicalDeviceObject 
    )
/*++
      
Routine Description:
      
    This routine constructs and initializes a parport FDO
      
Arguments:
      
    DriverObject         - Pointer to the parport driver object
    PhysicalDeviceObject - Pointer to the PDO whose stack we will attach to
      
Return Value:
      
    Pointer to the new ParPort Device Object on Success

    NULL otherwise
      
--*/
{
    UNICODE_STRING      uniNameString = {0,0,0};
    ULONG               portNumber    = 0;
    PWSTR               portName      = NULL;
    NTSTATUS            status        = STATUS_SUCCESS;
    PDEVICE_OBJECT      deviceObject = NULL;

    //
    // Get the LPTx name for this port from the registry.
    //
    // The initial LPTx name for a port is determined by the ports class installer 
    //   msports.dll, but the name can subsequently be changed by the user via
    //   a device manager property page.
    //
    portName = PptGetPortNameFromPhysicalDeviceObject( PhysicalDeviceObject );
    if( NULL == portName ) {
        DD(NULL,DDE,"PptBuildFdo - get LPTx Name from registry - FAILED\n");
        goto targetExit;
    }

    //
    // Extract the preferred port number N to use for the \Device\ParallelPortN 
    //   DeviceName from the LPTx name
    //
    // Preferred DeviceName for LPT(n) is ParallelPort(n-1) - e.g., LPT3 -> ParallelPort2
    //
    status = PptGetPortNumberFromLptName( portName, &portNumber );
    if( !NT_SUCCESS( status ) ) {
        DD(NULL,DDE,"PptBuildFdo - extract portNumber from LPTx Name - FAILED\n");
        ExFreePool( portName );
        goto targetExit;
    }
    --portNumber;               // convert 1 (LPT) based number to 0 (ParallelPort) based number

    //
    // Build a DeviceName of the form: \Device\ParallelPortN
    //
    status = PptBuildParallelPortDeviceName(portNumber, &uniNameString);
    if( !NT_SUCCESS( status ) ) {
        // we couldn't make up a name - bail out
        DD(NULL,DDE,"PptBuildFdo - Build ParallelPort DeviceName - FAILED\n");
        ExFreePool( portName );
        goto targetExit;
    }

    //
    // Create the device object for this device.
    //
    status = IoCreateDevice(DriverObject, sizeof(FDO_EXTENSION), &uniNameString, 
                            FILE_DEVICE_PARALLEL_PORT, FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);

    
    if( STATUS_OBJECT_NAME_COLLISION == status ) {
        //
        // Preferred DeviceName already exists - try made up names
        // 

        DD(NULL,DDW,"PptBuildFdo - Initial Device Creation FAILED - Name Collision\n");

        //
        // use an offset so that our made up names won't collide with 
        //   the preferred names of ports that have not yet started
        //   (start with ParallelPort8)
        //
        #define PPT_CLASSNAME_OFFSET 7
        portNumber = PPT_CLASSNAME_OFFSET;

        do {
            RtlFreeUnicodeString( &uniNameString );
            ++portNumber;
            status = PptBuildParallelPortDeviceName(portNumber, &uniNameString);
            if( !NT_SUCCESS( status ) ) {
                // we couldn't make up a name - bail out
                DD(NULL,DDE,"PptBuildFdo - Build ParallelPort DeviceName - FAILED\n");
                ExFreePool( portName );
                goto targetExit;
            }
            DD(NULL,DDT,"PptBuildFdo - Trying Device Creation <%wZ>\n", &uniNameString);
            status = IoCreateDevice(DriverObject, sizeof(FDO_EXTENSION), &uniNameString, 
                                    FILE_DEVICE_PARALLEL_PORT, FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);

        } while( STATUS_OBJECT_NAME_COLLISION == status );
    }

    if( !NT_SUCCESS( status ) ) {
        // we got a failure other than a name collision - bail out
        DD(NULL,DDE,"PptBuildFdo - Device Creation FAILED - status=%x\n",status);
        deviceObject = NULL;
        ExFreePool( portName );
        goto targetExit;
    }

    //
    // We have a deviceObject - Initialize DeviceExtension
    //
    status = PptInitializeDeviceExtension( DriverObject, PhysicalDeviceObject, deviceObject, 
                                           &uniNameString, portName, portNumber );
    if( !NT_SUCCESS( status ) ) {
        // failure initializing the device extension - clean up and bail out
        DD(NULL,DDE,"PptBuildFdo - Device Initialization FAILED - status=%x\n",status);
        IoDeleteDevice( deviceObject );
        deviceObject = NULL;
        ExFreePool( portName );
        goto targetExit;
    }

    //
    // Propagate the power pagable flag of the PDO to our new FDO
    //
    if( PhysicalDeviceObject->Flags & DO_POWER_PAGABLE ) {
        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    DD(NULL,DDT,"PptBuildFdo - SUCCESS\n");

targetExit:

    RtlFreeUnicodeString( &uniNameString );

    return deviceObject;
}


VOID
PptPdoGetPortInfoFromFdo( PDEVICE_OBJECT Pdo )
{
    PPDO_EXTENSION              pdx = Pdo->DeviceExtension;
    PDEVICE_OBJECT              fdo = pdx->Fdo;
    PFDO_EXTENSION              fdx = fdo->DeviceExtension;

    pdx->OriginalController   = fdx->PortInfo.OriginalController;
    pdx->Controller           = fdx->PortInfo.Controller;
    pdx->SpanOfController     = fdx->PortInfo.SpanOfController;
    pdx->TryAllocatePort      = fdx->PortInfo.TryAllocatePort;
    pdx->FreePort             = fdx->PortInfo.FreePort;
    pdx->QueryNumWaiters      = fdx->PortInfo.QueryNumWaiters;
    pdx->PortContext          = fdx->PortInfo.Context;
    
    pdx->EcrController        = fdx->PnpInfo.EcpController;
    pdx->HardwareCapabilities = fdx->PnpInfo.HardwareCapabilities;
    pdx->TrySetChipMode       = fdx->PnpInfo.TrySetChipMode;
    pdx->ClearChipMode        = fdx->PnpInfo.ClearChipMode;
    pdx->TrySelectDevice      = fdx->PnpInfo.TrySelectDevice;
    pdx->DeselectDevice       = fdx->PnpInfo.DeselectDevice;
    pdx->FifoDepth            = fdx->PnpInfo.FifoDepth;
    pdx->FifoWidth            = fdx->PnpInfo.FifoWidth;
}


VOID
P4WritePortNameToDevNode( PDEVICE_OBJECT Pdo, PCHAR Location )
{
#define PORTNAME_BUFF_SIZE 10
    HANDLE          handle;
    NTSTATUS        status;
    WCHAR           portName[PORTNAME_BUFF_SIZE]; // expect: L"LPTx:" (L"LPTx.y:" for DaisyChain PDOs)
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;
                
    RtlZeroMemory( portName, sizeof(portName) );
    
    PptAssert( NULL != Location );

    switch( pdx->PdoType ) {

    case PdoTypeLegacyZip:
    case PdoTypeDaisyChain:
        // At least one vendor uses the y from LPTx.y to determine the
        // location of their device in the 1284.3 daisy chain.  We
        // have chastised this vendor for using this undocumented
        // interface and they have apologized profusely and promised
        // to try to avoid using undocumented interfaces in the future
        // (at least without telling us that they are doing so).
        _snwprintf( portName, PORTNAME_BUFF_SIZE - 1, L"%.6S:\0", Location );
        PptAssert( 7 == wcslen(portName) );
        break;

    case PdoTypeRawPort:
    case PdoTypeEndOfChain:
        // don't confuse printing with the .4 suffix for an EndOfChain device
        _snwprintf( portName, PORTNAME_BUFF_SIZE - 1, L"%.4S:\0", Location );
        PptAssert( 5 == wcslen(portName) );
        break;

    default:
        DD((PCE)pdx,DDE,"P4WritePortNameToDevNode - invalid pdx->PdoType\n");
    }
    
    PptAssert( wcsncmp( portName, L"LPT", sizeof(L"LPT")/sizeof(WCHAR)) ) ;

    status = IoOpenDeviceRegistryKey( Pdo, PLUGPLAY_REGKEY_DEVICE, KEY_ALL_ACCESS, &handle );

    if( STATUS_SUCCESS == status ) {
        UNICODE_STRING name;
        RtlInitUnicodeString( &name, L"PortName" );
        ZwSetValueKey( handle, &name, 0, REG_SZ, portName, (wcslen(portName)+1)*sizeof(WCHAR) );
        ZwClose(handle);
    }
}                


PCHAR
P4ReadRawIeee1284DeviceId(
    IN  PUCHAR          Controller
    )
{
    IEEE_STATE ieeeState = { 0,                  // CurrentEvent
                             PHASE_FORWARD_IDLE, // CurrentPhase
                             FALSE,              // Connected in IEEE mode?
                             FALSE,              // IsIeeeTerminateOk
                             FAMILY_NONE };      // ProtocolFamily - Centronics => FAMILY_NONE
    NTSTATUS    status;
    PCHAR       devIdBuffer      = NULL;
    ULONG       bytesTransferred = 0;
    ULONG       tryCount         = 1;
    const ULONG maxTries         = 3;
    const ULONG minValidDevId    = 14; // 2 size bytes + "MFG:x;" + "MDL:y;"
    BOOLEAN     ignoreXflag        = FALSE;
    ULONG       deviceIndex;


 targetRetry:

    status = P4IeeeEnter1284Mode( Controller, ( NIBBLE_EXTENSIBILITY | DEVICE_ID_REQ ), &ieeeState );

    if( STATUS_SUCCESS == status ) {

        // Negotiation for 1284 device ID succeeded

        const ULONG  tmpBufLen        = 1024; // reasonable max length for IEEE 1284 Device ID string
        PCHAR        tmpBuf           = ExAllocatePool( PagedPool, tmpBufLen );

        if( tmpBuf ) {

            RtlZeroMemory( tmpBuf, tmpBufLen );
            
            // try to read the 1284 device ID from the peripheral

            ieeeState.CurrentPhase = PHASE_NEGOTIATION;
            status = P4NibbleModeRead( Controller, tmpBuf, tmpBufLen-1, &bytesTransferred, &ieeeState );
            
            if( NT_SUCCESS( status ) ) {

                UCHAR highLengthByte = 0xff & tmpBuf[0];
                UCHAR lowLengthByte  = 0xff & tmpBuf[1];
                PCHAR idString       = &tmpBuf[2];
                
                DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - len:%02x %02x - string:<%s>\n",highLengthByte,lowLengthByte,idString);
                
                if( highLengthByte > 2 ) {
                    
                    DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - len:%02x %02x - looks bogus - ignore this ID\n",highLengthByte,lowLengthByte);
                    devIdBuffer = NULL;
                    
                } else {
                    
                    if( bytesTransferred >= minValidDevId ) {
                        // looks like this might be a valid 1284 id
                        devIdBuffer = ExAllocatePool( PagedPool, bytesTransferred + 1 );
                        if( devIdBuffer ) {
                            ULONG length          = (highLengthByte * 256) + lowLengthByte;
                            ULONG truncationIndex = ( (length >= minValidDevId) && (length < bytesTransferred) ) ? length : bytesTransferred;
                            RtlCopyMemory( devIdBuffer, tmpBuf, bytesTransferred );
                            devIdBuffer[ truncationIndex ] = '\0';
                        } else {
                            DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - P4IeeeEnter1284Mode FAILED - no pool for devIdBuffer\n");
                        }
                    }
                }

            } else {
                DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - P4NibbleModeRead FAILED - looks like no device there\n");
            }

            ExFreePool( tmpBuf );

        } else {
            DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - P4IeeeEnter1284Mode FAILED - no pool for tmpBuf\n");
        }

        ieeeState.ProtocolFamily = FAMILY_REVERSE_NIBBLE;

	    //check brother product
        if(devIdBuffer && 
        	(	strstr(devIdBuffer+2,"Brother")	||
        		strstr(devIdBuffer+2,"PitneyBowes")	||
        		strstr(devIdBuffer+2,"LEGEND")	||
        		strstr(devIdBuffer+2,"Legend")	||
        		strstr(devIdBuffer+2,"HBP")		))
        {
        		
            // look for device that needs to ignore XFlag on event 24
            for(deviceIndex = 0; deviceIndex < NUMOFBROTHERPRODUCT;
            			deviceIndex++)
            {
            	if(XflagOnEvent24Devices[deviceIndex][0] == NULL)
            	{
            		break;
            	}

	            if(strstr(devIdBuffer+2,
	                		XflagOnEvent24Devices[deviceIndex][IDMFG] ) ) 
	            {
	                if(strstr(devIdBuffer+2,
	                		XflagOnEvent24Devices[deviceIndex][IDMDL] ) ) 
	                {
    	                // found a match, so set our flag and get out
	                    ignoreXflag = TRUE;
        	            break;
        	        }
                }
            }
        }

        if(ignoreXflag)
        {
            // work around Brother's firmware handling of XFlag on Event 24
            P4IeeeTerminate1284Mode( Controller, &ieeeState, IgnoreXFlagOnEvent24 );
        } else {
            // normal handling
            P4IeeeTerminate1284Mode( Controller, &ieeeState, UseXFlagOnEvent24 );
        }

    } else {
        DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - P4IeeeEnter1284Mode FAILED - looks like no device there\n");
    }


    //
    // add retry if we got some bytes, but not enough for a valid ID
    //
    if( (NULL == devIdBuffer) &&                  // we didn't get an ID
        (bytesTransferred > 0 ) &&                // peripheral reported some bytes
        (bytesTransferred < minValidDevId ) &&    //   but not enough
        (tryCount < maxTries ) ) {                // we haven't exhausted our retries
            
        ++tryCount;
        bytesTransferred = 0;
        goto targetRetry;
    }

    return devIdBuffer;
}

VOID
P4ReleaseBus( PDEVICE_OBJECT Fdo )
{
    PFDO_EXTENSION fdx = Fdo->DeviceExtension;
    DD((PCE)fdx,DDT,"P4ReleaseBus\n");
    fdx->FdoWaitingOnPort = FALSE;
    if( 0 == d3 ) {
        PptFreePort( fdx );
    }
}

NTSTATUS
P4CompleteRequest(
    IN PIRP       Irp,
    IN NTSTATUS   Status,
    IN ULONG_PTR  Information 
    )
{
    P5TraceIrpCompletion( Irp );
    Irp->IoStatus.Status      = Status;
    Irp->IoStatus.Information = Information;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;
}


NTSTATUS
P4CompleteRequestReleaseRemLock(
    IN PIRP             Irp,
    IN NTSTATUS         Status,
    IN ULONG_PTR        Information,
    IN PIO_REMOVE_LOCK  RemLock
    )
{
    P4CompleteRequest( Irp, Status, Information );
    PptReleaseRemoveLock( RemLock, Irp );
    return Status;
}


// pcutil.c follows:


//============================================================================
// NAME:    BusReset()
//
//    Performs a bus reset as defined in Chapter 7.2 of the
//    1284-1994 spec.
//
// PARAMETERS:
//      DCRController   - Supplies the base address of of the DCR.
//
// RETURNS:
//      nothing
//============================================================================
void BusReset(
    IN  PUCHAR DCRController
    )
{
    UCHAR dcr;

    dcr = P5ReadPortUchar(DCRController);
    // Set 1284 and nInit low.
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, INACTIVE, DONT_CARE, DONT_CARE);
    P5WritePortUchar(DCRController, dcr);
    KeStallExecutionProcessor(100); // Legacy Zip will hold what looks to be
                                    // a bus reset for 9us.  Since this proc is used
                                    // to trigger a logic analyzer... let's hold
                                    // for 100us
}    

BOOLEAN
CheckTwoPorts(
    PUCHAR  pPortAddr1,
    UCHAR   bMask1,
    UCHAR   bValue1,
    PUCHAR  pPortAddr2,
    UCHAR   bMask2,
    UCHAR   bValue2,
    USHORT  msTimeDelay
    )
{
    UCHAR           bPort1;
    UCHAR           bPort2;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;

    // Do a quick check in case we have one stinkingly fast peripheral!
    bPort1 = P5ReadPortUchar( pPortAddr1 );
    if ( ( bPort1 & bMask1 ) == bValue1 ) {
        return TRUE;
    }
    bPort2 = P5ReadPortUchar( pPortAddr2 );
    if ( ( bPort2 & bMask2 ) == bValue2 ) {
        return FALSE;
    }

    Wait.QuadPart = (msTimeDelay * 10 * 1000) + KeQueryTimeIncrement();
    KeQueryTickCount(&Start);

    for(;;) {
        KeQueryTickCount(&End);
        
        bPort1 = P5ReadPortUchar( pPortAddr1 );
        if ( ( bPort1 & bMask1 ) == bValue1 ) {
            return TRUE;
        }
        bPort2 = P5ReadPortUchar( pPortAddr2 );
        if ( ( bPort2 & bMask2 ) == bValue2 ) {
            return FALSE;
        }
        
        if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart) {
            // We timed out!!! -  Recheck the values
            bPort1 = P5ReadPortUchar( pPortAddr1 );
            if ( ( bPort1 & bMask1 ) == bValue1 ) {
                return TRUE;
            }
            bPort2 = P5ReadPortUchar( pPortAddr2 );
            if ( ( bPort2 & bMask2 ) == bValue2 ) {
                return FALSE;
            }
            
#if DVRH_BUS_RESET_ON_ERROR
            BusReset(pPortAddr1+1);  // Pass in the dcr address
#endif
            // Device never responded, return timeout status.
            return FALSE;
        }

    } // forever;

} // CheckPort2...


PWSTR
ParCreateWideStringFromUnicodeString(PUNICODE_STRING UnicodeString)
/*++

Routine Description:

    Create a UNICODE_NULL terminated WSTR given a UNICODE_STRING.

    This function allocates PagedPool, copies the UNICODE_STRING buffer
      to the allocation, and appends a UNICODE_NULL to terminate the WSTR
    
    *** This function allocates pool. ExFreePool must be called to free
          the allocation when the buffer is no longer needed.

Arguments:

    UnicodeString - The source

Return Value:

    PWSTR  - if successful

    NULL   - otherwise

--*/
{
    PWSTR buffer;
    ULONG length = UnicodeString->Length;

    buffer = ExAllocatePool( PagedPool, length + sizeof(UNICODE_NULL) );
    if(!buffer) {
        return NULL;      // unable to allocate pool, bail out
    } else {
        RtlCopyMemory(buffer, UnicodeString->Buffer, length);
        buffer[length/2] = UNICODE_NULL;
        return buffer;
    }
}

VOID
ParInitializeExtension1284Info(
    IN PPDO_EXTENSION Pdx
    )
// make this a function since it is now called from two places:
//  - 1) when initializing a new devobj
//  - 2) from CreateOpen
{
    USHORT i;

    Pdx->Connected               = FALSE;
    if (DefaultModes)
    {
        USHORT rev = (USHORT) (DefaultModes & 0xffff);
        USHORT fwd = (USHORT)((DefaultModes & 0xffff0000)>>16);
        
        switch (fwd)
        {
            case BOUNDED_ECP:
                Pdx->IdxForwardProtocol      = BOUNDED_ECP_FORWARD;       
                break;
            case ECP_HW_NOIRQ:
            case ECP_HW_IRQ:
                Pdx->IdxForwardProtocol      = ECP_HW_FORWARD_NOIRQ;       
                break;
            case ECP_SW:
                Pdx->IdxForwardProtocol      = ECP_SW_FORWARD;       
                break;
            case EPP_HW:
                Pdx->IdxForwardProtocol      = EPP_HW_FORWARD;       
                break;
            case EPP_SW:
                Pdx->IdxForwardProtocol      = EPP_SW_FORWARD;       
                break;
            case IEEE_COMPATIBILITY:
                Pdx->IdxForwardProtocol      = IEEE_COMPAT_MODE;
                break;
            case CENTRONICS:
            default:
                Pdx->IdxForwardProtocol      = CENTRONICS_MODE;       
                break;
        }
        
        switch (rev)
        {
            case BOUNDED_ECP:
                Pdx->IdxReverseProtocol      = BOUNDED_ECP_REVERSE;       
                break;
            case ECP_HW_NOIRQ:
            case ECP_HW_IRQ:
                Pdx->IdxReverseProtocol      = ECP_HW_REVERSE_NOIRQ;       
                break;
            case ECP_SW:
                Pdx->IdxReverseProtocol      = ECP_SW_REVERSE;       
                break;
            case EPP_HW:
                Pdx->IdxReverseProtocol      = EPP_HW_REVERSE;       
                break;
            case EPP_SW:
                Pdx->IdxReverseProtocol      = EPP_SW_REVERSE;       
                break;
            case BYTE_BIDIR:
                Pdx->IdxReverseProtocol      = BYTE_MODE;       
                break;
            case CHANNEL_NIBBLE:
            case NIBBLE:
            default:
                Pdx->IdxReverseProtocol      = NIBBLE_MODE;
                break;
        }
    }
    else
    {
        Pdx->IdxReverseProtocol      = NIBBLE_MODE;
        Pdx->IdxForwardProtocol      = CENTRONICS_MODE;
    }
    Pdx->bShadowBuffer           = FALSE;
    Pdx->ProtocolModesSupported  = 0;
    Pdx->BadProtocolModes        = 0;
    Pdx->fnRead  = NULL;
    Pdx->fnWrite = NULL;

    Pdx->ForwardInterfaceAddress = DEFAULT_ECP_CHANNEL;
    Pdx->ReverseInterfaceAddress = DEFAULT_ECP_CHANNEL;
    Pdx->SetForwardAddress       = FALSE;
    Pdx->SetReverseAddress       = FALSE;
    Pdx->bIsHostRecoverSupported = FALSE;
    Pdx->IsIeeeTerminateOk       = FALSE;

    for (i = FAMILY_NONE; i < FAMILY_MAX; i++) {
        Pdx->ProtocolData[i] = 0;
    }
}


NTSTATUS
ParBuildSendInternalIoctl(
    IN  ULONG           IoControlCode,
    IN  PDEVICE_OBJECT  TargetDeviceObject,
    IN  PVOID           InputBuffer         OPTIONAL,
    IN  ULONG           InputBufferLength,
    OUT PVOID           OutputBuffer        OPTIONAL,
    IN  ULONG           OutputBufferLength,
    IN  PLARGE_INTEGER  RequestedTimeout    OPTIONAL
    )
/*++dvdf

Routine Description:

    This routine builds and sends an Internal IOCTL to the TargetDeviceObject, waits
    for the IOCTL to complete, and returns status to the caller.

    *** WORKWORK - dvdf 12Dec98: This function does not support Input and Output in the same IOCTL

Arguments:

    IoControlCode       - the IOCTL to send
    TargetDeviceObject  - who to send the IOCTL to
    InputBuffer         - pointer to input buffer, if any
    InputBufferLength,  - length of input buffer
    OutputBuffer        - pointer to output buffer, if any
    OutputBufferLength, - length of output buffer
    Timeout             - how long to wait for request to complete, NULL==use driver global AcquirePortTimeout

Return Value:

    Status

--*/
{
    NTSTATUS           status;
    PIRP               irp;
    LARGE_INTEGER      timeout;
    KEVENT             event;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // Current limitation is that this function does not handle a request with
    //   both InputBufferLength and OutputBufferLength > 0
    //
    if( InputBufferLength != 0 && OutputBufferLength != 0 ) {
        return STATUS_UNSUCCESSFUL;
    }


    //
    // Allocate and initialize IRP
    //
    irp = IoAllocateIrp( (CCHAR)(TargetDeviceObject->StackSize + 1), FALSE );
    if( !irp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength  = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode      = IoControlCode;


    if( InputBufferLength != 0 ) {
        irp->AssociatedIrp.SystemBuffer = InputBuffer;
    } else if( OutputBufferLength != 0 ) {
        irp->AssociatedIrp.SystemBuffer = OutputBuffer;
    }


    //
    // Set completion routine and send IRP
    //
    KeInitializeEvent( &event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( irp, ParSynchCompletionRoutine, &event, TRUE, TRUE, TRUE );

    status = ParCallDriver(TargetDeviceObject, irp);

    if( !NT_SUCCESS(status) ) {
        DD(NULL,DDE,"ParBuildSendInternalIoctl - ParCallDriver FAILED w/status=%x\n",status);
        IoFreeIrp( irp );
        return status;
    }

    //
    // Set timeout and wait
    //
    //                                      user specified   : default
    timeout = (NULL != RequestedTimeout) ? *RequestedTimeout : AcquirePortTimeout;
    status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &timeout);

    //
    // Did we timeout or did the IRP complete?
    //
    if( status == STATUS_TIMEOUT ) {
        // we timed out - cancel the IRP
        IoCancelIrp( irp );
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    //
    // Irp is complete, grab the status and free the irp
    //
    status = irp->IoStatus.Status;
    IoFreeIrp( irp );

    return status;
}


UCHAR
ParInitializeDevice(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine is invoked to initialize the parallel port drive.
    It performs the following actions:

        o   Send INIT to the driver and if the device is online.

Arguments:

    Context - Really the device extension.

Return Value:

    The last value that we got from the status register.

--*/

{

    UCHAR               DeviceStatus = 0;
    LARGE_INTEGER       StartOfSpin = {0,0};
    LARGE_INTEGER       NextQuery   = {0,0};
    LARGE_INTEGER       Difference  = {0,0};
    LARGE_INTEGER       Delay;

    //
    // Tim Wells (WestTek, L.L.C.)
    //
    // -  Removed the deferred initialization code from DriverEntry, device creation
    // code.  This code will be better utilized in the Create/Open logic or from
    // the calling application.
    //
    // -  Changed this code to always reset when asked, and to return after a fixed
    // interval reqardless of the response.  Additional responses can be provided by
    // read and write code.
    //

    //
    // Clear the register.
    //

    if (GetControl(Pdx->Controller) & PAR_CONTROL_NOT_INIT) {

        //
        // We should stall for at least 60 microseconds after the init.
        //

        StoreControl( Pdx->Controller, (UCHAR)(PAR_CONTROL_WR_CONTROL | PAR_CONTROL_SLIN) );

        Delay.QuadPart = -60 * 10; // delay for 60us (in 100ns units), negative for relative delay

        KeDelayExecutionThread(KernelMode, FALSE, &Delay);
    }

    StoreControl( Pdx->Controller, 
                  (UCHAR)(PAR_CONTROL_WR_CONTROL | PAR_CONTROL_NOT_INIT | PAR_CONTROL_SLIN) );

    //
    // Spin waiting for the device to initialize.
    //

    KeQueryTickCount(&StartOfSpin);

    do {

        KeQueryTickCount(&NextQuery);

        Difference.QuadPart = NextQuery.QuadPart - StartOfSpin.QuadPart;

        ASSERT(KeQueryTimeIncrement() <= MAXLONG);

        if (Difference.QuadPart*KeQueryTimeIncrement() >= Pdx->AbsoluteOneSecond.QuadPart) {

            //
            // Give up on getting PAR_OK.
            //

            DD((PCE)Pdx,DDT,"Did spin of one second - StartOfSpin: %x NextQuery: %x\n", StartOfSpin.LowPart,NextQuery.LowPart);

            break;
        }

        DeviceStatus = GetStatus(Pdx->Controller);

    } while (!PAR_OK(DeviceStatus));

    return (DeviceStatus);
}

VOID
ParNotInitError(
    IN PPDO_EXTENSION Pdx,
    IN UCHAR             DeviceStatus
    )

/*++

Routine Description:

Arguments:

    Pdx       - Supplies the device extension.

    deviceStatus    - Last read status.

Return Value:

    None.

--*/

{

    PIRP Irp = Pdx->CurrentOpIrp;

    if (PAR_OFF_LINE(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
        DD((PCE)Pdx,DDE,"Init Error - off line - STATUS/INFORMATON: %x/%x\n", Irp->IoStatus.Status, Irp->IoStatus.Information);

    } else if (PAR_NO_CABLE(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        DD((PCE)Pdx,DDE,"Init Error - no cable - not connected - STATUS/INFORMATON: %x/%x\n", Irp->IoStatus.Status, Irp->IoStatus.Information);

    } else if (PAR_PAPER_EMPTY(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_PAPER_EMPTY;
        DD((PCE)Pdx,DDE,"Init Error - paper empty - STATUS/INFORMATON: %x/%x\n", Irp->IoStatus.Status, Irp->IoStatus.Information);

    } else if (PAR_POWERED_OFF(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_POWERED_OFF;
        DD((PCE)Pdx,DDE,"Init Error - power off - STATUS/INFORMATON: %x/%x\n", Irp->IoStatus.Status, Irp->IoStatus.Information);

    } else {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        DD((PCE)Pdx,DDE,"Init Error - not conn - STATUS/INFORMATON: %x/%x\n", Irp->IoStatus.Status, Irp->IoStatus.Information);
    }

}

VOID
ParCancelRequest(
    PDEVICE_OBJECT DevObj,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel any request in the parallel driver.

Arguments:

    DevObj - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER( DevObj );

    //
    // The only reason that this irp can be on the queue is
    // if it's not the current irp.  Pull it off the queue
    // and complete it as canceled.
    //

    ASSERT(!IsListEmpty(&Irp->Tail.Overlay.ListEntry));

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    P4CompleteRequest( Irp, STATUS_CANCELLED, 0 );

}



#if PAR_NO_FAST_CALLS
// temp debug functions so params show up on stack trace

NTSTATUS
ParCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    return IoCallDriver(DeviceObject, Irp);
}
#endif // PAR_NO_FAST_CALLS


NTSTATUS
ParSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp          - Irp that just completed

    Event        - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
ParCheckParameters(
    IN OUT  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine reads the parameters section of the registry and modifies
    the device extension as specified by the parameters.

Arguments:

    RegistryPath    - Supplies the registry path.

    Pdx       - Supplies the device extension.

Return Value:

    None.

--*/

{
    RTL_QUERY_REGISTRY_TABLE ParamTable[4];
    ULONG                    UsePIWriteLoop;
    ULONG                    UseNT35Priority;
    ULONG                    Zero = 0;
    NTSTATUS                 Status;
    HANDLE                   hRegistry;

    if (Pdx->PhysicalDeviceObject) {

        Status = IoOpenDeviceRegistryKey (Pdx->PhysicalDeviceObject,
                                          PLUGPLAY_REGKEY_DRIVER,
                                          STANDARD_RIGHTS_ALL,
                                          &hRegistry);

        if (NT_SUCCESS(Status)) {

            RtlZeroMemory(ParamTable, sizeof(ParamTable));

            ParamTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
            ParamTable[0].Name          = (PWSTR)L"UsePIWriteLoop";
            ParamTable[0].EntryContext  = &UsePIWriteLoop;
            ParamTable[0].DefaultType   = REG_DWORD;
            ParamTable[0].DefaultData   = &Zero;
            ParamTable[0].DefaultLength = sizeof(ULONG);

            ParamTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
            ParamTable[1].Name          = (PWSTR)L"UseNT35Priority";
            ParamTable[1].EntryContext  = &UseNT35Priority;
            ParamTable[1].DefaultType   = REG_DWORD;
            ParamTable[1].DefaultData   = &Zero;
            ParamTable[1].DefaultLength = sizeof(ULONG);

            ParamTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
            ParamTable[2].Name          = (PWSTR)L"InitializationTimeout";
            ParamTable[2].EntryContext  = &(Pdx->InitializationTimeout);
            ParamTable[2].DefaultType   = REG_DWORD;
            ParamTable[2].DefaultData   = &Zero;
            ParamTable[2].DefaultLength = sizeof(ULONG);

            Status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                                            hRegistry, ParamTable, NULL, NULL);

            if (NT_SUCCESS(Status)) {

                if(UsePIWriteLoop) {
                    Pdx->UsePIWriteLoop = TRUE;
                }

                if(UseNT35Priority) {
                    Pdx->UseNT35Priority = TRUE;
                }

                if(Pdx->InitializationTimeout == 0) {
                    Pdx->InitializationTimeout = 15;
                }
            }

        } else {
            Pdx->InitializationTimeout = 15;
        }

        ZwClose (hRegistry);

    } else {
        Pdx->InitializationTimeout = 15;
    }
}

BOOLEAN
String2Num(
    IN OUT PCHAR   *lpp_Str,
    IN     CHAR     c,
    OUT    ULONG   *num
    )
{
    int cc;
    int cnt = 0;

    DD(NULL,DDT,"String2Num. string [%s]\n", lpp_Str);
    *num = 0;
    if (!*lpp_Str) {
        *num = 0;
        return FALSE;
    }
    // At this point, we should have a string that is a
    // positive hex value.  I will not be checking for
    // validity of the string.  If peripheral handed me a
    // bogus value then I'm gonna make their life
    // miserable.
String2Num_Start:
    cc = (int)(unsigned char)**lpp_Str;
    if (cc >= '0' && cc <= '9') {    
        *num = 16 * *num + (cc - '0');    /* accumulate digit */
    } else if (cc >= 'A' && cc <= 'F') {
        *num = 16 * *num + (cc - 55);     /* accumulate digit */
    } else if (cc >= 'a' && cc <= 'f') {
        *num = 16 * *num + (cc - 87);     /* accumulate digit */
    } else if (cc == c || cc == 0) {
        *lpp_Str = 0;
        return TRUE;
    } else if (cc == 'y' || cc == 'Y') {
        *lpp_Str = 0;
        *num = (ULONG)~0;     /* Special case */
        return FALSE;
    } else {
        *lpp_Str = 0;
        *num = 0;     /* It's all messed up */
        return FALSE;
    }
    DD(NULL,DDT,"String2Num. num [%x]\n", *num);
    (*lpp_Str)++;
    if (cnt++ > 100) {
        // If our string is this large, then I'm gonna assume somethings wrong
        DD(NULL,DDE,"String2Num. String too long\n");
        goto String2Num_End;
    }
    goto String2Num_Start;

String2Num_End:
    DD(NULL,DDE,"String2Num. Something's wrong with String\n");
    *num = 0;
    return FALSE;
}

UCHAR
StringCountValues(
    IN PCHAR string, 
    IN CHAR  delimeter
    )
{
    PUCHAR  lpKey = (PUCHAR)string;
    UCHAR   cnt = 1;

    if(!string) {
        return 0;
    }

    while(*lpKey) {
        if( *lpKey==delimeter ) {
            ++cnt;
        }
        lpKey++;
    }

    return cnt;
}

PCHAR
StringChr(
    IN PCHAR string, 
    IN CHAR  c
    )
{
    if(!string) {
        return(NULL);
    }

    while(*string) {
        if( *string==c ) {
            return string;
        }
        string++;
    }

    return NULL;
}

VOID
StringSubst(
    IN PCHAR lpS,
    IN CHAR  chTargetChar,
    IN CHAR  chReplacementChar,
    IN USHORT cbS
    )
{
    USHORT  iCnt = 0;

    while ((lpS != '\0') && (iCnt++ < cbS))
        if (*lpS == chTargetChar)
            *lpS++ = chReplacementChar;
        else
            ++lpS;
}

VOID
ParFixupDeviceId(
    IN OUT PUCHAR DeviceId
    )
/*++

Routine Description:

    This routine parses the NULL terminated string and replaces any invalid
    characters with an underscore character.

    Invalid characters are:
        c <= 0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

Arguments:

    DeviceId - specifies a device id string (or part of one), must be
               null-terminated.

Return Value:

    None.

--*/

{
    PUCHAR p;
    for( p = DeviceId; *p; ++p ) {
        if( (*p <= ' ') || (*p > (UCHAR)0x7F) || (*p == ',') ) {
            *p = '_';
        }
    }
}

VOID
ParDetectDot3DataLink(
    IN  PPDO_EXTENSION   Pdx,
    IN  PCHAR DeviceId
    )
{
    PCHAR       DOT3DL   = NULL;     // 1284.3 Data Link Channels
    PCHAR       DOT3C    = NULL;     // 1284.3 Data Link Services
    PCHAR       DOT4DL   = NULL;     // 1284.4 Data Link for peripherals that were implemented prior to 1284.3
    PCHAR       CMDField = NULL;     // The command field for parsing legacy MLC
    PCHAR       DOT3M    = NULL;     // 1284 physical layer modes that will break this device

    DD((PCE)Pdx,DDT,"ParDetectDot3DataLink: DeviceId [%s]\n", DeviceId);
    ParDot3ParseDevId(&DOT3DL, &DOT3C, &CMDField, &DOT4DL, &DOT3M, DeviceId);
    ParDot3ParseModes(Pdx,DOT3M);
    if (DOT4DL) {
        DD((PCE)Pdx,DDT,"ParDot3ParseModes - 1284.4 with MLC Data Link Detected. DOT4DL [%s]\n", DOT4DL);
        ParDot4CreateObject(Pdx, DOT4DL);
    } else if (DOT3DL) {
        DD((PCE)Pdx,DDT,"ParDot4CreateObject - 1284.3 Data Link Detected DL:[%s] C:[%s]\n", DOT3DL, DOT3C);
        ParDot3CreateObject(Pdx, DOT3DL, DOT3C);
    } else if (CMDField) {
        DD((PCE)Pdx,DDT,"ParDot3CreateObject - MLC Data Link Detected. MLC [%s]\n", CMDField);
        ParMLCCreateObject(Pdx, CMDField);
    } else {
        DD((PCE)Pdx,DDT,"ParDot3CreateObject - No Data Link Detected\n");
    }
}

VOID
ParDot3ParseDevId(
    PCHAR   *lpp_DL,
    PCHAR   *lpp_C,
    PCHAR   *lpp_CMD,
    PCHAR   *lpp_4DL,
    PCHAR   *lpp_M,
    PCHAR   lpDeviceID
)
{
    PCHAR    lpKey = lpDeviceID;     // Pointer to the Key to look at
    PCHAR    lpValue;                // Pointer to the Key's value
    USHORT   wKeyLength;             // Length for the Key (for stringcmps)

    // While there are still keys to look at.
    while (lpKey != NULL) {

        while (*lpKey == ' ')
            ++lpKey;

        // Is there a terminating COLON character for the current key?
        lpValue = StringChr((PCHAR)lpKey, ':');
        if( NULL == lpValue ) {
            // N: OOPS, somthing wrong with the Device ID
            return;
        }

        // The actual start of the Key value is one past the COLON
        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //
        wKeyLength = (USHORT)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //
        switch (*lpKey) {
        case '1':
            // Look for DOT3 Datalink
            if((RtlCompareMemory(lpKey, "1284.4DL:", wKeyLength)==9))
            {
                *lpp_4DL = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=NULL)
                {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((RtlCompareMemory(lpKey, "1284.3DL:", wKeyLength)==9))
            {
                *lpp_DL = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=NULL)
                {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((RtlCompareMemory(lpKey, "1284.3C:", wKeyLength)==8))
            {
                *lpp_C = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((RtlCompareMemory(lpKey, "1284.3M:", wKeyLength)==8))
            {
                *lpp_M = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;

        case '.':
            // Look for for .3 extras
            if ((RtlCompareMemory(lpKey, ".3C:", wKeyLength)==4) ) {

                *lpp_C = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if ((RtlCompareMemory(lpKey, ".3M:", wKeyLength)==4) ) {

                *lpp_M = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;

        case 'C':
            // Look for MLC Datalink
            if( (RtlCompareMemory(lpKey, "CMD:",         wKeyLength)==4 ) ||
                (RtlCompareMemory(lpKey, "COMMAND SET:", wKeyLength)==12) ) {

                *lpp_CMD = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }

            break;

        default:
            // The key is uninteresting.  Go to the next Key
            if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;
        }
    }
}

NTSTATUS
ParPnpGetId(
    IN PCHAR DeviceIdString,
    IN ULONG Type,
    OUT PCHAR resultString,
    OUT PCHAR descriptionString OPTIONAL
    )
/*
    Description:

        Creates Id's from the device id retrieved from the printer

    Parameters:

        DeviceId - String with raw device id
        Type - What of id we want as a result
        Id - requested id

    Return Value:
        NTSTATUS

*/
{
    NTSTATUS        status       = STATUS_SUCCESS;
    USHORT          checkSum     = 0;             // A 16 bit check sum
    CHAR            nodeName[16] = "LPTENUM\\";
    // The following are used to generate sub-strings from the Device ID string
    // to get the DevNode name, and to update the registry
    PCHAR           MFG = NULL;                   // Manufacturer name
    PCHAR           MDL = NULL;                   // Model name
    PCHAR           CLS = NULL;                   // Class name
    PCHAR           AID = NULL;                   // Hardare ID
    PCHAR           CID = NULL;                   // Compatible IDs
    PCHAR           DES = NULL;                   // Device Description

    switch(Type) {

    case BusQueryDeviceID:

        // Extract the usefull fields from the DeviceID string.  We want
        // MANUFACTURE (MFG):
        // MODEL (MDL):
        // AUTOMATIC ID (AID):
        // COMPATIBLE ID (CID):
        // DESCRIPTION (DES):
        // CLASS (CLS):

        ParPnpFindDeviceIdKeys(&MFG, &MDL, &CLS, &DES, &AID, &CID, DeviceIdString);

        // Check to make sure we got MFG and MDL as absolute minimum fields.  If not
        // we cannot continue.
        if (!MFG || !MDL)
        {
            status = STATUS_NOT_FOUND;
            goto ParPnpGetId_Cleanup;
        }
        //
        // Concatenate the provided MFG and MDL P1284 fields
        // Checksum the entire MFG+MDL string
        //
        sprintf(resultString, "%s%s\0",MFG,MDL);
        
        if (descriptionString) {
            sprintf((PCHAR)descriptionString, "%s %s\0",MFG,MDL);
        }
            
        break;

    case BusQueryHardwareIDs:

        GetCheckSum(DeviceIdString, (USHORT)strlen((const PCHAR)DeviceIdString), &checkSum);
        sprintf(resultString,"%s%.20s%04X",nodeName,DeviceIdString,checkSum);
        break;

    case BusQueryCompatibleIDs:

        //
        // return only 1 id
        //
        GetCheckSum(DeviceIdString, (USHORT)strlen((const PCHAR)DeviceIdString), &checkSum);
        sprintf(resultString,"%.20s%04X",DeviceIdString,checkSum);

        break;
    }

    if (Type!=BusQueryDeviceID) {

        //
        // Convert and spaces in the Hardware ID to underscores
        //
        StringSubst (resultString, ' ', '_', (USHORT)strlen((const PCHAR)resultString));
    }

ParPnpGetId_Cleanup:

    return(status);
}

VOID
ParPnpFindDeviceIdKeys(
    PCHAR   *lppMFG,
    PCHAR   *lppMDL,
    PCHAR   *lppCLS,
    PCHAR   *lppDES,
    PCHAR   *lppAID,
    PCHAR   *lppCID,
    PCHAR   lpDeviceID
    )
/*

    Description:
        This function will parse a P1284 Device ID string looking for keys
        of interest to the LPT enumerator. Got it from win95 lptenum

    Parameters:
        lppMFG      Pointer to MFG string pointer
        lppMDL      Pointer to MDL string pointer
        lppMDL      Pointer to CLS string pointer
        lppDES      Pointer to DES string pointer
        lppCIC      Pointer to CID string pointer
        lppAID      Pointer to AID string pointer
        lpDeviceID  Pointer to the Device ID string

    Return Value:
        no return VALUE.
        If found the lpp parameters are set to the approprate portions
        of the DeviceID string, and they are NULL terminated.
        The actual DeviceID string is used, and the lpp Parameters just
        reference sections, with appropriate null thrown in.

*/
{
    PCHAR   lpKey = lpDeviceID;     // Pointer to the Key to look at
    PCHAR   lpValue;                // Pointer to the Key's value
    USHORT   wKeyLength;             // Length for the Key (for stringcmps)

    // While there are still keys to look at.

    DD(NULL,DDT,"ParPnpFindDeviceIdKeys - enter\n");

    if( lppMFG ) { *lppMFG = NULL; }
    if( lppMDL ) { *lppMDL = NULL; }
    if( lppCLS ) { *lppCLS = NULL; }
    if( lppDES ) { *lppDES = NULL; }
    if( lppAID ) { *lppAID = NULL; }
    if( lppCID ) { *lppCID = NULL; }

    if( !lpDeviceID ) { 
        PptAssert(!"ParPnpFindDeviceIdKeys - NULL lpDeviceID");
        return; 
    }

    while (lpKey != NULL)
    {
        while (*lpKey == ' ')
            ++lpKey;

        // Is there a terminating COLON character for the current key?
        lpValue = StringChr(lpKey, ':');
        if( NULL == lpValue ) {
            // N: OOPS, somthing wrong with the Device ID
            return;
        }

        // The actual start of the Key value is one past the COLON
        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //
        wKeyLength = (USHORT)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //
        switch (*lpKey) {
        case 'M':
            // Look for MANUFACTURE (MFG) or MODEL (MDL)
            if((RtlCompareMemory(lpKey, "MANUFACTURER", wKeyLength)>5) ||
               (RtlCompareMemory(lpKey, "MFG", wKeyLength)==3) ) {

                *lppMFG = lpValue;
                if ((lpKey = StringChr(lpValue, ';'))!=NULL) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if((RtlCompareMemory(lpKey, "MODEL", wKeyLength)==5) ||
                      (RtlCompareMemory(lpKey, "MDL", wKeyLength)==3) ) {

                *lppMDL = lpValue;
                if ((lpKey = StringChr(lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if((lpKey = StringChr(lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;

        case 'C':
            // Look for CLASS (CLS) or COMPATIBLEID (CID)
            if ((RtlCompareMemory(lpKey, "CLASS", wKeyLength)==5) ||
                (RtlCompareMemory(lpKey, "CLS", wKeyLength)==3) ) {

                *lppCLS = lpValue;
                if ((lpKey = StringChr(lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((RtlCompareMemory(lpKey, "COMPATIBLEID", wKeyLength)>5) ||
                       (RtlCompareMemory(lpKey, "CID", wKeyLength)==3) ) {

                *lppCID = lpValue;
                if ((lpKey = StringChr(lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((lpKey = StringChr(lpValue,';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
        
            break;

        case 'D':
            // Look for DESCRIPTION (DES)
            if(RtlCompareMemory(lpKey, "DESCRIPTION", wKeyLength) ||
                RtlCompareMemory(lpKey, "DES", wKeyLength) ) {

                *lppDES = lpValue;
                if((lpKey = StringChr(lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((lpKey = StringChr(lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            
            break;

        case 'A':
            // Look for AUTOMATIC ID (AID)
            if (RtlCompareMemory(lpKey, "AUTOMATICID", wKeyLength) ||
                RtlCompareMemory(lpKey, "AID", wKeyLength) ) {

                *lppAID = lpValue;
                if ((lpKey = StringChr(lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((lpKey = StringChr(lpValue, ';'))!=0) {

                *lpKey = '\0';
                ++lpKey;

            }
            break;

        default:
            // The key is uninteresting.  Go to the next Key
            if ((lpKey = StringChr(lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;
        }
    }
}


VOID
GetCheckSum(
    PCHAR  Block,
    USHORT  Len,
    PUSHORT CheckSum
    )
{
    USHORT i;
    //    UCHAR  lrc;
    USHORT crc = 0;

    unsigned short crc16a[] = {
        0000000,  0140301,  0140601,  0000500,
        0141401,  0001700,  0001200,  0141101,
        0143001,  0003300,  0003600,  0143501,
        0002400,  0142701,  0142201,  0002100,
    };
    unsigned short crc16b[] = {
        0000000,  0146001,  0154001,  0012000,
        0170001,  0036000,  0024000,  0162001,
        0120001,  0066000,  0074000,  0132001,
        0050000,  0116001,  0104001,  0043000,
    };

    //
    // Calculate CRC using tables.
    //

    UCHAR tmp;
    for ( i=0; i<Len;  i++) {
         tmp = (UCHAR)(Block[i] ^ (UCHAR)crc);
         crc = (USHORT)((crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4]);
    }

    *CheckSum = crc;
}


PCHAR
Par3QueryDeviceId(
    IN  PPDO_EXTENSION   Pdx,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString, // TRUE ==  include the 2 size bytes in the returned string
                                              // FALSE == discard the 2 size bytes
    IN BOOLEAN              bBuildStlDeviceId
    )
/*++

  This is the replacement function for SppQueryDeviceId.

  This function uses the caller supplied buffer if the supplied buffer
    is large enough to hold the device id. Otherwise, a buffer is
    allocated from paged pool to hold the device ID and a pointer to
    the allocated buffer is returned to the caller. The caller determines
    whether a buffer was allocated by comparing the returned PCHAR with
    the DeviceIdBuffer parameter passed to this function. A NULL return
    value indicates that an error occurred.

    *** this function assumes that the caller has already acquired
          the port (and selected the device if needed in the case
          of a 1284.3 daisy chain device).

    *** If this function returns a pointer to a paged pool allocation then
          the caller is responsible for freeing the buffer when it is no
          longer needed.

--*/
{
    PUCHAR              Controller = Pdx->Controller;
    NTSTATUS            Status;
    UCHAR               idSizeBuffer[2];
    ULONG               bytesToRead;
    ULONG               bytesRead = 0;
    USHORT              deviceIdSize;
    USHORT              deviceIdBufferSize;
    PCHAR               deviceIdBuffer;
    PCHAR               readPtr;
    BOOLEAN             allocatedBuffer = FALSE;

    DD((PCE)Pdx,DDT,"Enter pnp::Par3QueryDeviceId: Controller=%x\n", Controller);
                    
    if( TRUE == bBuildStlDeviceId ) {
        // if this is a legacy stl, forward call to special handler
        return ParStlQueryStlDeviceId(Pdx, 
                                          CallerDeviceIdBuffer, CallerBufferSize,
                                          DeviceIdSize, bReturnRawString);
    }

    if( Pdx->Ieee1284_3DeviceId == DOT3_LEGACY_ZIP_ID ) {
        // if this is a legacy Zip, forward call to special handler
        return Par3QueryLegacyZipDeviceId(Pdx, 
                                          CallerDeviceIdBuffer, CallerBufferSize,
                                          DeviceIdSize, bReturnRawString);
    }

    //
    // Take a 40ms nap - there is at least one printer that can't handle
    //   back to back 1284 device ID queries without a minimum 20-30ms delay
    //   between the queries which breaks PnP'ing the printer
    //
    if( KeGetCurrentIrql() == PASSIVE_LEVEL ) {
        LARGE_INTEGER delay;
        delay.QuadPart = - 10 * 1000 * 40; // 40 ms
        KeDelayExecutionThread( KernelMode, FALSE, &delay );
    }

    *DeviceIdSize = 0;

    //
    // If we are currently connected to the peripheral via any 1284 mode
    //   other than Compatibility/Spp mode (which does not require an IEEE
    //   negotiation), we must first terminate the current mode/connection.
    // 
    ParTerminate( Pdx );

    //
    // Negotiate the peripheral into nibble device id mode.
    //
    Status = ParEnterNibbleMode(Pdx, REQUEST_DEVICE_ID);
    if( !NT_SUCCESS(Status) ) {
        DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: call to ParEnterNibbleMode FAILED\n");
        ParTerminateNibbleMode(Pdx);
        return NULL;
    }


    //
    // Read first two bytes to get the total (including the 2 size bytes) size 
    //   of the Device Id string.
    //
    bytesToRead = 2;
    Status = ParNibbleModeRead(Pdx, idSizeBuffer, bytesToRead, &bytesRead);
    if( !NT_SUCCESS( Status ) || ( bytesRead != bytesToRead ) ) {
        DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: read of DeviceID size FAILED\n");
        return NULL;
    }


    //
    // Compute size of DeviceId string (including the 2 byte size prefix)
    //
    deviceIdSize = (USHORT)( idSizeBuffer[0]*0x100 + idSizeBuffer[1] );
    DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: DeviceIdSize (including 2 size bytes) reported as %d\n", deviceIdSize);


    //
    // Allocate a buffer to hold the DeviceId string and read the DeviceId into it.
    //
    if( bReturnRawString ) {
        //
        // Caller wants the raw string including the 2 size bytes
        //
        *DeviceIdSize      = deviceIdSize;
        deviceIdBufferSize = (USHORT)(deviceIdSize + sizeof(CHAR));     // ID size + ID + terminating NULL
    } else {
        //
        // Caller does not want the 2 byte size prefix
        //
        *DeviceIdSize      = deviceIdSize - 2*sizeof(CHAR);
        deviceIdBufferSize = (USHORT)(deviceIdSize - 2*sizeof(CHAR) + sizeof(CHAR)); //           ID + terminating NULL
    }


    //
    // If caller's buffer is large enough use it, otherwise allocate a buffer
    //   to hold the device ID
    //
    if( CallerDeviceIdBuffer && (CallerBufferSize >= (deviceIdBufferSize + sizeof(CHAR))) ) {
        //
        // Use caller's buffer - *** NOTE: we are creating an alias for the caller buffer
        //
        deviceIdBuffer = CallerDeviceIdBuffer;
        DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: using Caller supplied buffer\n");
    } else {
        //
        // Either caller did not supply a buffer or supplied a buffer that is not
        //   large enough to hold the device ID, so allocate a buffer.
        //
        DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: Caller's Buffer TOO_SMALL - CallerBufferSize= %d, deviceIdBufferSize= %d\n",
                   CallerBufferSize, deviceIdBufferSize);
        DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: will allocate and return ptr to buffer\n");
        deviceIdBuffer = (PCHAR)ExAllocatePool(PagedPool, (deviceIdBufferSize + sizeof(CHAR)));
        if( !deviceIdBuffer ) {
            DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: ExAllocatePool FAILED\n");
            return NULL;
        }
        allocatedBuffer = TRUE; // note that we allocated our own buffer rather than using caller's buffer
    }


    //
    // NULL out the ID buffer to be safe
    //
    RtlZeroMemory( deviceIdBuffer, (deviceIdBufferSize + sizeof(CHAR)));


    //
    // Does the caller want the 2 byte size prefix?
    //
    if( bReturnRawString ) {
        //
        // Yes, caller wants the size prefix. Copy prefix to buffer to return.
        //
        *(deviceIdBuffer+0) = idSizeBuffer[0];
        *(deviceIdBuffer+1) = idSizeBuffer[1];
        readPtr = deviceIdBuffer + 2;
    } else {
        //
        // No, discard size prefix
        //
        readPtr = deviceIdBuffer;
    }


    //
    // Read remainder of DeviceId from device
    //
    bytesToRead = deviceIdSize -  2; // already have the 2 size bytes
    Status = ParNibbleModeRead(Pdx, readPtr, bytesToRead, &bytesRead);
            

    ParTerminateNibbleMode( Pdx );
    P5WritePortUchar(Controller + DCR_OFFSET, DCR_NEUTRAL);

    if( !NT_SUCCESS(Status) || (bytesRead < 1) ) {
        if( allocatedBuffer ) {
            // we're using our own allocated buffer rather than a caller supplied buffer - free it
            DD((PCE)Pdx,DDE,"Par3QueryDeviceId:: read of DeviceId FAILED - discarding buffer\n");
            ExFreePool( deviceIdBuffer );
        }
        return NULL;
    }

    if ( bytesRead < bytesToRead ) {
        //
        // Device likely reported incorrect value for IEEE 1284 Device ID length
        //
        // This spew is on by default in checked builds to try to get
        //   a feel for how many types of devices are broken in this way
        //
        DD((PCE)Pdx,DDE,"pnp::Par3QueryDeviceId - ID shorter than expected\n");
    }

    return deviceIdBuffer;
}


VOID
ParReleasePortInfoToPortDevice(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine will release the port information back to the port driver.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    //
    // ParPort treats this as a NO-OP in Win2K, so don't bother sending the IOCTL.
    //
    // In follow-on to Win2K parport may use this to page the entire driver as
    //   it was originally intended, so we'll turn this back on then.
    //

    UNREFERENCED_PARAMETER( Pdx );

    return;
}

VOID
ParFreePort(
    IN  PPDO_EXTENSION Pdx
    )
/*++

Routine Description:

    This routine calls the internal free port ioctl.  This routine
    should be called before completing an IRP that has allocated
    the port.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    // Don't allow multiple releases
    if( Pdx->bAllocated ) {
        DD((PCE)Pdx,DDT,"ParFreePort - calling ParPort's FreePort function\n");
        Pdx->FreePort( Pdx->PortContext );
    } else {
        DD((PCE)Pdx,DDT,"ParFreePort - we don't have the Port! (!Ext->bAllocated)\n");
    }
        
    Pdx->bAllocated = FALSE;
}


NTSTATUS
ParAllocPortCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    )

/*++

Routine Description:

    This routine is the completion routine for a port allocate request.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.
    Context         - Supplies the notification event.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - The Irp still requires processing.

--*/

{
    UNREFERENCED_PARAMETER( Irp );
    UNREFERENCED_PARAMETER( DeviceObject );

    KeSetEvent((PKEVENT) Event, 0, FALSE);
    
    return STATUS_MORE_PROCESSING_REQUIRED;
}

BOOLEAN
ParAllocPort(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine takes the given Irp and sends it down as a port allocate
    request.  When this request completes, the Irp will be queued for
    processing.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    FALSE   - The port was not successfully allocated.
    TRUE    - The port was successfully allocated.

--*/

{
    PIO_STACK_LOCATION  NextSp;
    KEVENT              Event;
    PIRP                Irp;
    BOOLEAN             bAllocated;
    NTSTATUS            Status;
    LARGE_INTEGER       Timeout;

    // Don't allow multiple allocations
    if (Pdx->bAllocated) {
        DD((PCE)Pdx,DDT,"ParAllocPort - controller=%x - port already allocated\n", Pdx->Controller);
        return TRUE;
    }

    Irp = Pdx->CurrentOpIrp;
    
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    NextSp = IoGetNextIrpStackLocation(Irp);
    NextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE;

    IoSetCompletionRoutine( Irp, ParAllocPortCompletionRoutine, &Event, TRUE, TRUE, TRUE );

    ParCallDriver(Pdx->PortDeviceObject, Irp);

    Timeout.QuadPart = -((LONGLONG) Pdx->TimerStart*10*1000*1000);

    Status = KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, &Timeout);

    if (Status == STATUS_TIMEOUT) {
    
        IoCancelIrp(Irp);
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
    }

    bAllocated = (BOOLEAN)NT_SUCCESS(Irp->IoStatus.Status);
    
    Pdx->bAllocated = bAllocated;
    
    if (!bAllocated) {
        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        DD((PCE)Pdx,DDE,"ParAllocPort - controller=%x - FAILED - DEVICE_BUSY timeout\n",Pdx->Controller);
    }

    return bAllocated;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\unload.c ===
#include "pch.h"

VOID
PptUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++
      
Routine Description:
      
    This routine cleans up all of the memory associated with
      any of the devices belonging to the driver.  It  will
      loop through the device list.
      
Arguments:
      
    DriverObject    - Supplies the driver object controlling all of the
                        devices.
      
Return Value:
      
    None.
      
--*/
    
{
    PDEVICE_OBJECT                  CurrentDevice;
    PFDO_EXTENSION               Extension;
    PLIST_ENTRY                     Head;
    PISR_LIST_ENTRY                 Entry;
    
    CurrentDevice = DriverObject->DeviceObject;

    while( CurrentDevice ) {
        
        Extension = CurrentDevice->DeviceExtension;
        
        if (Extension->InterruptRefCount) {
            PptDisconnectInterrupt(Extension);
        }
        
        while (!IsListEmpty(&Extension->IsrList)) {
            Head = RemoveHeadList(&Extension->IsrList);
            Entry = CONTAINING_RECORD(Head, ISR_LIST_ENTRY, ListEntry);
            ExFreePool(Entry);
        }
        
        ExFreePool(Extension->DeviceName.Buffer);

        IoDeleteDevice(CurrentDevice);
        
        IoGetConfigurationInformation()->ParallelCount--;

        CurrentDevice = DriverObject->DeviceObject;
    }
    
    if( PortInfoMutex ) {
        ExFreePool( PortInfoMutex );
        PortInfoMutex = NULL;
    }

    if( PowerStateCallbackRegistration ) {
        ExUnregisterCallback( PowerStateCallbackRegistration );
        PowerStateCallbackRegistration = NULL; // probably not needed, but shouldn't hurt
    }
    if( PowerStateCallbackObject ) {
        ObDereferenceObject( PowerStateCallbackObject );
        PowerStateCallbackObject = NULL;
    }

    RtlFreeUnicodeString( &RegistryPath );

    DD(NULL,DDE,"PptUnload\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parport2\utils.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       util.h
//
//--------------------------------------------------------------------------


#ifndef _UTIL_
#define _UTIL_

#define GetStatus(RegisterBase) \
    (P5ReadPortUchar((RegisterBase)+DSR_OFFSET))

#define GetControl(RegisterBase) \
    (P5ReadPortUchar((RegisterBase)+DCR_OFFSET))


#define StoreControl(RegisterBase,ControlByte)  \
{                                               \
    P5WritePortUchar((RegisterBase)+DCR_OFFSET, \
                     (UCHAR)ControlByte );      \
}

// The following macros may be used to test the contents of the Device
// Status Regisger (DSR).  These macros account for the hardware
// inversion of the nBusy (aka PtrBusy, PeriphAck) signal.
//////////////////////////////////////////////////////////////////////////////

#if (1 == DVRH_USE_FAST_MACROS)
    #define DSR_TEST_MASK(b7,b6,b5,b4,b3)  \
    ((UCHAR)(b7==DONT_CARE? 0:  BIT_7_SET) | \
            (b6==DONT_CARE? 0:  BIT_6_SET) | \
            (b5==DONT_CARE? 0:  BIT_5_SET) | \
            (b4==DONT_CARE? 0:  BIT_4_SET) | \
            (b3==DONT_CARE? 0:  BIT_3_SET) )
#else
    #define DSR_TEST_MASK(b7,b6,b5,b4,b3)  \
    ((UCHAR)((b7==DONT_CARE?0:1)<<BIT_7) | \
            ((b6==DONT_CARE?0:1)<<BIT_6) | \
            ((b5==DONT_CARE?0:1)<<BIT_5) | \
            ((b4==DONT_CARE?0:1)<<BIT_4) | \
            ((b3==DONT_CARE?0:1)<<BIT_3) )
#endif

#if (1 == DVRH_USE_FAST_MACROS)
    #define DSR_TEST_VALUE(b7,b6,b5,b4,b3)  \
    ((UCHAR) ((b7==DONT_CARE?0:(b7==ACTIVE?0        : BIT_7_SET)) | \
            (b6==DONT_CARE?0:(b6==ACTIVE?  BIT_6_SET: 0)) | \
            (b5==DONT_CARE?0:(b5==ACTIVE?  BIT_5_SET: 0)) | \
            (b4==DONT_CARE?0:(b4==ACTIVE?  BIT_4_SET: 0)) | \
            (b3==DONT_CARE?0:(b3==ACTIVE?  BIT_3_SET: 0)) ) )
#else
    #define DSR_TEST_VALUE(b7,b6,b5,b4,b3)  \
    ((UCHAR) (((b7==DONT_CARE?0:(b7==ACTIVE?0:1))<<BIT_7) | \
            ((b6==DONT_CARE?0:(b6==ACTIVE?1:0))<<BIT_6) | \
            ((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?1:0))<<BIT_3) ) )
#endif

#define TEST_DSR(registerValue,b7,b6,b5,b4,b3)  \
(((registerValue) & DSR_TEST_MASK(b7,b6,b5,b4,b3)) == DSR_TEST_VALUE(b7,b6,b5,b4,b3))


#define CHECK_DSR( addr, b7, b6, b5, b4, b3, usTime )                    \
    (TEST_DSR(P5ReadPortUchar(addr + DSR_OFFSET), b7, b6, b5, b4, b3 ) ? TRUE :   \
    CheckPort( addr + DSR_OFFSET,                                               \
             DSR_TEST_MASK( b7, b6, b5, b4, b3 ),                                   \
             DSR_TEST_VALUE( b7, b6, b5, b4, b3 ),                                  \
             usTime ) )

////////////////////////////////////////////////////////////////////////////////
// The CHECK_DSR_AND_FIFO macro may be used to invoke the CheckPort2 function, 
// without having to specify the mask and value components twice.
// CHECK_DSR_AND_FIFO does quick tests of the DSR and ECR ports first.
// If the peripheral has already responded with either of the
//  desired values, CheckPort2 need not be called.
////////////////////////////////////////////////////////////////////////////////

#define CHECK_DSR_WITH_FIFO( addr, b7, b6, b5, b4, b3, ecr_mask, ecr_value, msTime ) \
( TEST_DSR( P5ReadPortUchar( addr + OFFSET_DSR ), b7, b6, b5, b4, b3 ) ? TRUE :       \
  CheckTwoPorts( addr + OFFSET_DSR,                                  \
                 DSR_TEST_MASK( b7, b6, b5, b4, b3 ),                \
                 DSR_TEST_VALUE( b7, b6, b5, b4, b3 ),               \
                 addr + ECR_OFFSET,                                  \
                 ecr_mask,                                           \
                 ecr_value,                                          \
                 msTime) )

//////////////////////////////////////////////////////////////////////////////
// The following defines and macros may be used to set, test, and
// update the Device Control Register (DCR).
//////////////////////////////////////////////////////////////////////////////

// The DCR_AND_MASK macro generates a byte constant that is used by
// the UPDATE_DCR macro.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_AND_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==DONT_CARE?   BIT_5_SET:(b5==ACTIVE?  BIT_5_SET:  0)) | \
            (b4==DONT_CARE?    BIT_4_SET:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?    BIT_3_SET:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?    BIT_2_SET:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?    BIT_1_SET:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?    BIT_0_SET:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_AND_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==DONT_CARE?1:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?1:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?1:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?1:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?1:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?1:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif  

// The DCR_OR_MASK macro generates a byte constant that is used by
// the UPDATE_DCR macro.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_OR_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==DONT_CARE?   0:(b5==ACTIVE?  BIT_5_SET:  0)) | \
            (b4==DONT_CARE?    0:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?    0:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?    0:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?    0:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?    0:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_OR_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?0:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?0:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?0:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif
// The UPDATE_DCR macro generates provides a selective update of specific bits
// in the DCR.  Any bit positions specified as DONT_CARE will be left
// unchanged.  The macro accounts for the hardware inversion of
// certain signals.

#define UPDATE_DCR(registerValue,b5,b4,b3,b2,b1,b0) \
((UCHAR)(((registerValue) & DCR_AND_MASK(b5,b4,b3,b2,b1,b0)) | DCR_OR_MASK(b5,b4,b3,b2,b1,b0)))

// The DCR_TEST_MASK macro generates a byte constant which may be used
// to mask of DCR bits that we don't care about

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)((b5==DONT_CARE?0:BIT_5_SET) | \
            (b4==DONT_CARE?0:BIT_4_SET) | \
            (b3==DONT_CARE?0:BIT_3_SET) | \
            (b2==DONT_CARE?0:BIT_2_SET) | \
            (b1==DONT_CARE?0:BIT_1_SET) | \
            (b0==DONT_CARE?0:BIT_0_SET) ) )
#else
    #define DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)( ((b5==DONT_CARE?0:1)<<BIT_5) | \
            ((b4==DONT_CARE?0:1)<<BIT_4) | \
            ((b3==DONT_CARE?0:1)<<BIT_3) | \
            ((b2==DONT_CARE?0:1)<<BIT_2) | \
            ((b1==DONT_CARE?0:1)<<BIT_1) | \
            ((b0==DONT_CARE?0:1)<<BIT_0) ) )
#endif
// The DCR_TEST_VALUE macro generates a byte constant that may be used
// to compare against a masked DCR value.  This macro takes into
// account which signals are inverted by hardware before driving the
// signal line.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)((b5==DONT_CARE?0:(b5==ACTIVE? BIT_5_SET:  0)) | \
            (b4==DONT_CARE?0:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?0:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?0:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?0:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?0:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)(((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?0:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?0:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?0:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif
// The TEST_DCR macro may be used to generate a boolean result that is
// TRUE if the DCR value matches the specified signal levels and FALSE
// otherwise.

#define TEST_DCR(registerValue,b5,b4,b3,b2,b1,b0)  \
(((registerValue) & DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)) == DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0))

BOOLEAN CheckPort(IN PUCHAR offset_Controller,
                  IN UCHAR dsrMask,
                  IN UCHAR dsrValue,
                  IN USHORT msTimeDelay);


// *** original parclass util.h follows ***

// Standard Maximum Timing values
#define IEEE_MAXTIME_TL    35       // Max time Tl from the IEEE spec
#define DEFAULT_RECEIVE_TIMEOUT     330

#define ParEnterCriticalSection(Xtension)  xTension->bCriticalSection = TRUE
#define ParExitCriticalSection(Xtension)   xTension->bCriticalSection = FALSE

// The following macros may be used to test the contents of the Device
// Status Regisger (DSR).  These macros account for the hardware
// inversion of the nBusy (aka PtrBusy, PeriphAck) signal.
//////////////////////////////////////////////////////////////////////////////

#if (1 == DVRH_USE_FAST_MACROS)
    #define DSR_TEST_MASK(b7,b6,b5,b4,b3)  \
    ((UCHAR)(b7==DONT_CARE? 0:  BIT_7_SET) | \
            (b6==DONT_CARE? 0:  BIT_6_SET) | \
            (b5==DONT_CARE? 0:  BIT_5_SET) | \
            (b4==DONT_CARE? 0:  BIT_4_SET) | \
            (b3==DONT_CARE? 0:  BIT_3_SET) )
#else
    #define DSR_TEST_MASK(b7,b6,b5,b4,b3)  \
    ((UCHAR)((b7==DONT_CARE?0:1)<<BIT_7) | \
            ((b6==DONT_CARE?0:1)<<BIT_6) | \
            ((b5==DONT_CARE?0:1)<<BIT_5) | \
            ((b4==DONT_CARE?0:1)<<BIT_4) | \
            ((b3==DONT_CARE?0:1)<<BIT_3) )
#endif

#if (1 == DVRH_USE_FAST_MACROS)
    #define DSR_TEST_VALUE(b7,b6,b5,b4,b3)  \
    ((UCHAR) ((b7==DONT_CARE?0:(b7==ACTIVE?0        : BIT_7_SET)) | \
            (b6==DONT_CARE?0:(b6==ACTIVE?  BIT_6_SET: 0)) | \
            (b5==DONT_CARE?0:(b5==ACTIVE?  BIT_5_SET: 0)) | \
            (b4==DONT_CARE?0:(b4==ACTIVE?  BIT_4_SET: 0)) | \
            (b3==DONT_CARE?0:(b3==ACTIVE?  BIT_3_SET: 0)) ) )
#else
    #define DSR_TEST_VALUE(b7,b6,b5,b4,b3)  \
    ((UCHAR) (((b7==DONT_CARE?0:(b7==ACTIVE?0:1))<<BIT_7) | \
            ((b6==DONT_CARE?0:(b6==ACTIVE?1:0))<<BIT_6) | \
            ((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?1:0))<<BIT_3) ) )
#endif

#define TEST_DSR(registerValue,b7,b6,b5,b4,b3)  \
(((registerValue) & DSR_TEST_MASK(b7,b6,b5,b4,b3)) == DSR_TEST_VALUE(b7,b6,b5,b4,b3))


#if 0 // use parport's util.h versions
#define CHECK_DSR( addr, b7, b6, b5, b4, b3, msTime )                    \
    (TEST_DSR(P5ReadPortUchar(addr + OFFSET_DSR), b7, b6, b5, b4, b3 ) ? TRUE :   \
    CheckPort( addr + OFFSET_DSR,                                               \
             DSR_TEST_MASK( b7, b6, b5, b4, b3 ),                                   \
             DSR_TEST_VALUE( b7, b6, b5, b4, b3 ),                                  \
             msTime ) )

////////////////////////////////////////////////////////////////////////////////
// The CHECK_DSR_AND_FIFO macro may be used to invoke the CheckPort2 function, 
// without having to specify the mask and value components twice.
// CHECK_DSR_AND_FIFO does quick tests of the DSR and ECR ports first.
// If the peripheral has already responded with either of the
//  desired values, CheckPort2 need not be called.
////////////////////////////////////////////////////////////////////////////////
#endif // 0

#if 0 // use parport's util.h versions
#define CHECK_DSR_WITH_FIFO( addr, b7, b6, b5, b4, b3, ecr_mask, ecr_value, msTime ) \
( TEST_DSR( P5ReadPortUchar( addr + OFFSET_DSR ), b7, b6, b5, b4, b3 ) ? TRUE :       \
  CheckTwoPorts( addr + OFFSET_DSR,                                  \
                 DSR_TEST_MASK( b7, b6, b5, b4, b3 ),                \
                 DSR_TEST_VALUE( b7, b6, b5, b4, b3 ),               \
                 addr + ECR_OFFSET,                                  \
                 ecr_mask,                                           \
                 ecr_value,                                          \
                 msTime) )
#endif // 0

//////////////////////////////////////////////////////////////////////////////
// The following defines and macros may be used to set, test, and
// update the Device Control Register (DCR).
//////////////////////////////////////////////////////////////////////////////

// The DCR_AND_MASK macro generates a byte constant that is used by
// the UPDATE_DCR macro.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_AND_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==DONT_CARE?   BIT_5_SET:(b5==ACTIVE?  BIT_5_SET:  0)) | \
            (b4==DONT_CARE?    BIT_4_SET:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?    BIT_3_SET:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?    BIT_2_SET:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?    BIT_1_SET:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?    BIT_0_SET:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_AND_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==DONT_CARE?1:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?1:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?1:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?1:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?1:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?1:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif  

// The DCR_OR_MASK macro generates a byte constant that is used by
// the UPDATE_DCR macro.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_OR_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==DONT_CARE?   0:(b5==ACTIVE?  BIT_5_SET:  0)) | \
            (b4==DONT_CARE?    0:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?    0:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?    0:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?    0:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?    0:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_OR_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?0:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?0:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?0:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif
// The UPDATE_DCR macro generates provides a selective update of specific bits
// in the DCR.  Any bit positions specified as DONT_CARE will be left
// unchanged.  The macro accounts for the hardware inversion of
// certain signals.

#define UPDATE_DCR(registerValue,b5,b4,b3,b2,b1,b0) \
((UCHAR)(((registerValue) & DCR_AND_MASK(b5,b4,b3,b2,b1,b0)) | DCR_OR_MASK(b5,b4,b3,b2,b1,b0)))

// The DCR_TEST_MASK macro generates a byte constant which may be used
// to mask of DCR bits that we don't care about

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)((b5==DONT_CARE?0:BIT_5_SET) | \
            (b4==DONT_CARE?0:BIT_4_SET) | \
            (b3==DONT_CARE?0:BIT_3_SET) | \
            (b2==DONT_CARE?0:BIT_2_SET) | \
            (b1==DONT_CARE?0:BIT_1_SET) | \
            (b0==DONT_CARE?0:BIT_0_SET) ) )
#else
    #define DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)( ((b5==DONT_CARE?0:1)<<BIT_5) | \
            ((b4==DONT_CARE?0:1)<<BIT_4) | \
            ((b3==DONT_CARE?0:1)<<BIT_3) | \
            ((b2==DONT_CARE?0:1)<<BIT_2) | \
            ((b1==DONT_CARE?0:1)<<BIT_1) | \
            ((b0==DONT_CARE?0:1)<<BIT_0) ) )
#endif
// The DCR_TEST_VALUE macro generates a byte constant that may be used
// to compare against a masked DCR value.  This macro takes into
// account which signals are inverted by hardware before driving the
// signal line.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)((b5==DONT_CARE?0:(b5==ACTIVE? BIT_5_SET:  0)) | \
            (b4==DONT_CARE?0:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?0:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?0:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?0:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?0:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)(((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?0:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?0:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?0:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif
// The TEST_DCR macro may be used to generate a boolean result that is
// TRUE if the DCR value matches the specified signal levels and FALSE
// otherwise.

#define TEST_DCR(registerValue,b5,b4,b3,b2,b1,b0)  \
(((registerValue) & DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)) == DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0))

//  mask all but AckDataReq, XFlag, and nDataAvail to validate if it is still NIBBLE mode
//  00111000b
//#define DSR_NIBBLE_VALIDATION       (0x38)
#define DSR_NIBBLE_VALIDATION       (0x30)
//  AckDataReq high, XFlag low, nDataAvail high
//  00101000b
//#define DSR_NIBBLE_TEST_RESULT      (0x28)
#define DSR_NIBBLE_TEST_RESULT      (0x20)

//  mask all but AckDataReq, XFlag, and nDataAvail to validate if it is still BYTE mode
//  00111000b
#define DSR_BYTE_VALIDATION         (0x38)
//  AckDataReq high, XFlag high, nDataAvail high
//  00111000b
#define DSR_BYTE_TEST_RESULT        (0x38)

#define DVRH_LOGIC_ANALYZER_START(CNT)      \
            int DVRH_temp;                  \
            int DVRH_max = CNT;             \
            int DVRH_cnt = 0;               \
            UCHAR DVRH_dsr;                 \
            UCHAR DVRH_Statedsr[CNT];       \
            LARGE_INTEGER DVRH_Statetime[CNT];
#define DVRH_LOGIC_ANALYZER_READ_TIMER(DSR)          \
            DVRH_dsr = P5ReadPortUchar(DSR);                \
            KeQuerySystemTime(&DVRH_Statetime[DVRH_cnt]);   \
            DVRH_Statedsr[DVRH_cnt++] = DVRH_dsr;
#define DVRH_LOGIC_ANALYZER_READ_STATE(DSR)          \
            DVRH_dsr = P5ReadPortUchar(DSR);                \
            KeQuerySystemTime(&DVRH_Statetime[DVRH_cnt]);   \
            DVRH_Statedsr[DVRH_cnt ? ((DVRH_dsr != DVRH_Statedsr[DVRH_cnt-1]) ? DVRH_cnt++ : DVRH_cnt) : 0] = DVRH_dsr;

#define DVRH_LOGIC_ANALYZER_END                                 \
        KdPrint("0. %10u-%10u dsr [%x]\n",                      \
            DVRH_Statetime[0].HighPart,                         \
            DVRH_Statetime[0].LowPart/10,                       \
            DVRH_Statedsr[0]);                                  \
        for (DVRH_temp=1; DVRH_temp<DVRH_cnt; DVRH_temp++)      \
        {                                                       \
            KdPrint("%d. %10u-%10u diff [%10u]us dsr [%x]\n",   \
                DVRH_temp,                                      \
                DVRH_Statetime[DVRH_temp].HighPart,             \
                DVRH_Statetime[DVRH_temp].LowPart/10,           \
                ((DVRH_Statetime[DVRH_temp].LowPart/10) - (DVRH_Statetime[DVRH_temp-1].LowPart/10)),    \
                DVRH_Statedsr[DVRH_temp]);                      \
        }

void BusReset(
    IN  PUCHAR DCRController
    );

BOOLEAN CheckPort(IN PUCHAR offset_Controller,
                  IN UCHAR dsrMask,
                  IN UCHAR dsrValue,
                  IN USHORT msTimeDelay);

BOOLEAN
CheckTwoPorts(
    PUCHAR  pPortAddr1,
    UCHAR   bMask1,
    UCHAR   bValue1,
    PUCHAR  pPortAddr2,
    UCHAR   bMask2,
    UCHAR   bValue2,
    USHORT  msTimeDelay
    );

#endif // _PC_UTIL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parvdm\parvdm.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    parvdm.c

Abstract:

    This module contains the code for a simple parallel class driver.

    Unload and Cleanup are supported.  The model for grabing and
    releasing the parallel port is embodied in the code for IRP_MJ_READ.
    Other IRP requests could be implemented similarly.

    Basically, every READ requests that comes in gets
    passed down to the port driver as a parallel port allocate
    request.  This IRP will return to this driver when the driver

Environment:

    Kernel mode

Revision History :

--*/

#include "ntosp.h"
#include "parallel.h"
#include "ntddvdm.h"
#include "parvdm.h"
#include "parlog.h"

static const PHYSICAL_ADDRESS PhysicalZero = {0};

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING PortName,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParInitializeDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  ULONG           ParallelPortNumber
    );

NTSTATUS
ParGetPortInfoFromPortDevice(
    IN OUT  PDEVICE_EXTENSION   Extension
    );

VOID
ParReleasePortInfoToPortDevice(
    IN OUT PDEVICE_EXTENSION    Extension
    );

NTSTATUS
ParAllocPort(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP Irp
    );

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,ParInitializeDeviceObject)
#pragma alloc_text(INIT,ParMakeNames)
#endif
//
// Keep track of OPEN and CLOSE.
//
ULONG OpenCloseReferenceCount = 1;
PFAST_MUTEX OpenCloseMutex = NULL;

#define ParClaimDriver()                        \
    ExAcquireFastMutex(OpenCloseMutex);         \
    if(++OpenCloseReferenceCount == 1) {        \
    MmResetDriverPaging(DriverEntry);       \
    }                                           \
    ExReleaseFastMutex(OpenCloseMutex);         \

#define ParReleaseDriver()                      \
    ExAcquireFastMutex(OpenCloseMutex);         \
    if(--OpenCloseReferenceCount == 0) {        \
    MmPageEntireDriver(DriverEntry);        \
    }                                           \
    ExReleaseFastMutex(OpenCloseMutex);         \


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

--*/

{
    ULONG       i;

    PAGED_CODE();

    //
    // allocate the mutex to protect driver reference count
    //

    OpenCloseMutex = ExAllocatePool(NonPagedPool, sizeof(FAST_MUTEX));
    if (!OpenCloseMutex) {

    //
    // NOTE - we could probably do without bailing here and just
    // leave a note for ourselves to never page out, but since we
    // don't have enough memory to allocate a mutex we should probably
    // avoid leaving the driver paged in at all times
    //

    return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeFastMutex(OpenCloseMutex);


    for (i = 0; i < IoGetConfigurationInformation()->ParallelCount; i++) {
    ParInitializeDeviceObject(DriverObject, i);
    }

    if (!DriverObject->DeviceObject) {
        if( OpenCloseMutex ) {
            ExFreePool( OpenCloseMutex );
            OpenCloseMutex = NULL;
        }
    return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Initialize the Driver Object with driver's entry points
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = ParCreateOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = ParClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ParDeviceControl;
    DriverObject->DriverUnload = ParUnload;

    //
    // page out the driver if we can
    //

    ParReleaseDriver();


    return STATUS_SUCCESS;
}

NTSTATUS
ParOpenFileAgainstParport(PDEVICE_EXTENSION extension)
{
    NTSTATUS status;

    status = IoGetDeviceObjectPointer(&extension->ParPortName, FILE_READ_ATTRIBUTES,
                                      &extension->ParPortFileObject,
                      &extension->PortDeviceObject);
    return status;
}

VOID
ParCloseFileAgainstParport(PDEVICE_EXTENSION extension)
{
    if( extension->ParPortFileObject ) {
        ObDereferenceObject( extension->ParPortFileObject );
        extension->ParPortFileObject = NULL;
    }
}

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject        - Supplies a pointer to the driver object for the
                device.

    DeviceObject        - Supplies a pointer to the device object associated
                with the device that had the error, early in
                initialization, one may not yet exist.

    P1,P2               - Supplies the physical addresses for the controller
                ports involved with the error if they are available
                and puts them through as dump data.

    SequenceNumber      - Supplies a ulong value that is unique to an IRP over
                the life of the irp in this driver - 0 generally
                means an error not associated with an irp.

    MajorFunctionCode   - Supplies the major function code of the irp if there
                is an error associated with it.

    RetryCount          - Supplies the number of times a particular operation
                has been retried.

    UniqueErrorValue    - Supplies a unique long word that identifies the
                particular call to this function.

    FinalStatus         - Supplies the final status given to the irp that was
                associated with this error.  If this log entry is
                being made during one of the retries this value
                will be STATUS_SUCCESS.

    SpecificIOStatus    - Supplies the IO status for this particular error.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET    errorLogEntry;
    PVOID                   objectToUse;
    SHORT                   dumpToAllocate;

    if (ARGUMENT_PRESENT(DeviceObject)) {
    objectToUse = DeviceObject;
    } else {
    objectToUse = DriverObject;
    }

    dumpToAllocate = 0;

    if (P1.LowPart != 0 || P1.HighPart != 0) {
    dumpToAllocate = (SHORT) sizeof(PHYSICAL_ADDRESS);
    }

    if (P2.LowPart != 0 || P2.HighPart != 0) {
    dumpToAllocate += (SHORT) sizeof(PHYSICAL_ADDRESS);
    }

    errorLogEntry = IoAllocateErrorLogEntry(objectToUse,
        (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + dumpToAllocate));

    if (!errorLogEntry) {
    return;
    }

    errorLogEntry->ErrorCode = SpecificIOStatus;
    errorLogEntry->SequenceNumber = SequenceNumber;
    errorLogEntry->MajorFunctionCode = MajorFunctionCode;
    errorLogEntry->RetryCount = RetryCount;
    errorLogEntry->UniqueErrorValue = UniqueErrorValue;
    errorLogEntry->FinalStatus = FinalStatus;
    errorLogEntry->DumpDataSize = dumpToAllocate;

    if (dumpToAllocate) {

    RtlCopyMemory(errorLogEntry->DumpData, &P1, sizeof(PHYSICAL_ADDRESS));

    if (dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

        RtlCopyMemory(((PUCHAR) errorLogEntry->DumpData) +
              sizeof(PHYSICAL_ADDRESS), &P2,
              sizeof(PHYSICAL_ADDRESS));
    }
    }

    IoWriteErrorLogEntry(errorLogEntry);
}

VOID
ParInitializeDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  ULONG           ParallelPortNumber
    )

/*++

Routine Description:

    This routine is called for every parallel port in the system.  It
    will create a class device upon connecting to the port device
    corresponding to it.

Arguments:

    DriverObject        - Supplies the driver object.

    ParallelPortNumber  - Supplies the number for this port.

Return Value:

    None.

--*/

{
    UNICODE_STRING      portName, className, linkName;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   extension;
    PFILE_OBJECT        fileObject;

    PAGED_CODE();

    // Cobble together the port and class device names.

    if (!ParMakeNames(ParallelPortNumber, &portName, &className, &linkName)) {

    ParLogError(DriverObject, NULL, PhysicalZero, PhysicalZero, 0, 0, 0, 1,
            STATUS_SUCCESS, PAR_INSUFFICIENT_RESOURCES);

    return;
    }


    // Create the device object.

    status = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),
                &className, FILE_DEVICE_PARALLEL_PORT, 0, FALSE,
                &deviceObject);
    if (!NT_SUCCESS(status)) {

    ParLogError(DriverObject, NULL, PhysicalZero, PhysicalZero, 0, 0, 0, 2,
            STATUS_SUCCESS, PAR_INSUFFICIENT_RESOURCES);

    ExFreePool(linkName.Buffer);
    ExFreePool(portName.Buffer);
    ExFreePool(className.Buffer);
    return;
    }


    // Now that the device has been created,
    // set up the device extension.

    extension = deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(DEVICE_EXTENSION));

    extension->DeviceObject = deviceObject;
    deviceObject->Flags |= DO_BUFFERED_IO;

    status = IoGetDeviceObjectPointer(&portName, FILE_READ_ATTRIBUTES,
                      &fileObject,
                      &extension->PortDeviceObject);
    if (!NT_SUCCESS(status)) {

    ParLogError(DriverObject, deviceObject, PhysicalZero, PhysicalZero,
            0, 0, 0, 3, STATUS_SUCCESS, PAR_CANT_FIND_PORT_DRIVER);

    IoDeleteDevice(deviceObject);
    ExFreePool(linkName.Buffer);
    ExFreePool(portName.Buffer);
    ExFreePool(className.Buffer);
    return;
    }

    ObDereferenceObject(fileObject);

    extension->DeviceObject->StackSize =
        extension->PortDeviceObject->StackSize + 1;


    // We don't own parallel ports initially

    extension->PortOwned = FALSE;

    // Get the port information from the port device object.

    status = ParGetPortInfoFromPortDevice(extension);
    if (!NT_SUCCESS(status)) {

    ParLogError(DriverObject, deviceObject, PhysicalZero, PhysicalZero,
            0, 0, 0, 4, STATUS_SUCCESS, PAR_CANT_FIND_PORT_DRIVER);

    IoDeleteDevice(deviceObject);
    ExFreePool(linkName.Buffer);
        ExFreePool(portName.Buffer);
        ExFreePool(className.Buffer);
    return;
    }


    // Set up the symbolic link for windows apps.

    status = IoCreateUnprotectedSymbolicLink(&linkName, &className);
    if (!NT_SUCCESS(status)) {

    ParLogError(DriverObject, deviceObject, extension->OriginalController,
            PhysicalZero, 0, 0, 0, 5, STATUS_SUCCESS,
            PAR_NO_SYMLINK_CREATED);

    extension->CreatedSymbolicLink = FALSE;
    ExFreePool(linkName.Buffer);
    goto Cleanup;
    }


    // We were able to create the symbolic link, so record this
    // value in the extension for cleanup at unload time.

    extension->CreatedSymbolicLink = TRUE;
    extension->SymbolicLinkName = linkName;

Cleanup:
    // release the port info so the port driver can be paged out
    ParReleasePortInfoToPortDevice(extension);
    // ExFreePool(portName.Buffer); - save this in extension for
    // future CreateFiles against parport
    if( portName.Buffer ) {
        RtlInitUnicodeString( &extension->ParPortName, portName.Buffer );
    }
    ExFreePool(className.Buffer);
}

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING PortName,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    )

/*++

Routine Description:

    This routine generates the names \Device\ParallelPortN and
    \Device\ParallelVdmN, \DosDevices\PARVDMN.

Arguments:

    ParallelPortNumber  - Supplies the port number.

    PortName            - Returns the port name.

    ClassName           - Returns the class name.

    LinkName            - Returns the symbolic link name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNICODE_STRING  prefix, digits, linkPrefix, linkDigits;
    WCHAR           digitsBuffer[10], linkDigitsBuffer[10];
    UNICODE_STRING  portSuffix, classSuffix, linkSuffix;
    NTSTATUS        status;

    // Put together local variables for constructing names.

    RtlInitUnicodeString(&prefix, L"\\Device\\");
    RtlInitUnicodeString(&linkPrefix, L"\\DosDevices\\");
    RtlInitUnicodeString(&portSuffix, DD_PARALLEL_PORT_BASE_NAME_U);
    RtlInitUnicodeString(&classSuffix, L"ParallelVdm");
    RtlInitUnicodeString(&linkSuffix, L"$VDMLPT");
    digits.Length = 0;
    digits.MaximumLength = 20;
    digits.Buffer = digitsBuffer;
    linkDigits.Length = 0;
    linkDigits.MaximumLength = 20;
    linkDigits.Buffer = linkDigitsBuffer;
    status = RtlIntegerToUnicodeString(ParallelPortNumber, 10, &digits);
    if (!NT_SUCCESS(status)) {
    return FALSE;
    }
    status = RtlIntegerToUnicodeString(ParallelPortNumber + 1, 10, &linkDigits);
    if (!NT_SUCCESS(status)) {
    return FALSE;
    }

    // Make the port name.

    PortName->Length = 0;
    PortName->MaximumLength = prefix.Length + portSuffix.Length +
                  digits.Length + sizeof(WCHAR);
    PortName->Buffer = ExAllocatePool(PagedPool, PortName->MaximumLength);
    if (!PortName->Buffer) {
    return FALSE;
    }
    RtlZeroMemory(PortName->Buffer, PortName->MaximumLength);
    RtlAppendUnicodeStringToString(PortName, &prefix);
    RtlAppendUnicodeStringToString(PortName, &portSuffix);
    RtlAppendUnicodeStringToString(PortName, &digits);


    // Make the class name.

    ClassName->Length = 0;
    ClassName->MaximumLength = prefix.Length + classSuffix.Length +
                   digits.Length + sizeof(WCHAR);
    ClassName->Buffer = ExAllocatePool(PagedPool, ClassName->MaximumLength);
    if (!ClassName->Buffer) {
    ExFreePool(PortName->Buffer);
    return FALSE;
    }
    RtlZeroMemory(ClassName->Buffer, ClassName->MaximumLength);
    RtlAppendUnicodeStringToString(ClassName, &prefix);
    RtlAppendUnicodeStringToString(ClassName, &classSuffix);
    RtlAppendUnicodeStringToString(ClassName, &digits);


    // Make the link name.

    LinkName->Length = 0;
    LinkName->MaximumLength = linkPrefix.Length + linkSuffix.Length +
                 linkDigits.Length + sizeof(WCHAR);
    LinkName->Buffer = ExAllocatePool(PagedPool, LinkName->MaximumLength);
    if (!LinkName->Buffer) {
    ExFreePool(PortName->Buffer);
    ExFreePool(ClassName->Buffer);
    return FALSE;
    }
    RtlZeroMemory(LinkName->Buffer, LinkName->MaximumLength);
    RtlAppendUnicodeStringToString(LinkName, &linkPrefix);
    RtlAppendUnicodeStringToString(LinkName, &linkSuffix);
    RtlAppendUnicodeStringToString(LinkName, &linkDigits);

    return TRUE;
}

VOID
ParReleasePortInfoToPortDevice(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine will release the port information back to the port driver.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    KEVENT          event;
    PIRP            irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS        status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO,
                    Extension->PortDeviceObject,
                    NULL, 0, NULL, 0,
                    TRUE, &event, &ioStatus);

    if (!irp) {
    return;
    }

    status = IoCallDriver(Extension->PortDeviceObject, irp);

    if (!NT_SUCCESS(status)) {
    return;
    }

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
}

NTSTATUS
ParGetPortInfoFromPortDevice(
    IN OUT  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine will request the port information from the port driver
    and fill it in the device extension.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - Success.
    !STATUS_SUCCESS - Failure.

--*/

{
    KEVENT                      event;
    PIRP                        irp;
    PARALLEL_PORT_INFORMATION   portInfo;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO,
                    Extension->PortDeviceObject,
                    NULL, 0, &portInfo,
                    sizeof(PARALLEL_PORT_INFORMATION),
                    TRUE, &event, &ioStatus);

    if (!irp) {
    return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Extension->PortDeviceObject, irp);

    if (!NT_SUCCESS(status)) {
    return status;
    }

    status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    if (!NT_SUCCESS(status)) {
    return status;
    }

    Extension->OriginalController = portInfo.OriginalController;
    Extension->Controller = portInfo.Controller;
    Extension->SpanOfController = portInfo.SpanOfController;
    Extension->FreePort = portInfo.FreePort;
    Extension->FreePortContext = portInfo.Context;

    if (Extension->SpanOfController < PARALLEL_REGISTER_SPAN) {
    return STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}

VOID
ParCompleteRequest(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP  Irp
    )

/*++

Routine Description:

    This routine completes the 'CurrentIrp' after it was returned
    from the port driver.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    // DbgPrint("ParVDMCompleteRequest: Enter with irp = %#08x\n", Irp);
    //
    // If the allocate failed, then fail this request
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        // failed to allocate port, release port info back to port driver
        // and paged ourselves out.
        ParReleasePortInfoToPortDevice(Extension);
        ParReleaseDriver();
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        Extension->CreateOpenLock = 0;
        return;
    }

    //
    // This is where the driver specific stuff should go.  The driver
    // has exclusive access to the parallel port in this space.
    //

    // DbgPrint("ParVDMCompleteRequest: We own the port\n");
    Extension->PortOwned = TRUE;

    //
    // Complete the IRP, free the port, and start up the next IRP in
    // the queue.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_PARALLEL_INCREMENT);

    return;
}


VOID
ParCancel(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This is the cancel routine for this driver.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    None.

--*/

{
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
ParCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for create requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS          - Success.
    STATUS_NOT_A_DIRECTORY  - This device is not a directory.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;
    PDEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    //
    // Enforce exclusive access to this device
    //
    if( InterlockedExchange( &extension->CreateOpenLock, 1 ) ) {
        Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_ACCESS_DENIED;
    }

    if(extension->PortOwned) {
        //
        // Do an early exit if we can detect that another client has
        //   already acquired the port for exclusive use.
        //
        Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        extension->CreateOpenLock = 0;
        return STATUS_ACCESS_DENIED;
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->MajorFunction == IRP_MJ_CREATE &&
    irpSp->Parameters.Create.Options & FILE_DIRECTORY_FILE) {
        //
        // Bail out if client thinks that we are a directory.
        //
        Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        extension->CreateOpenLock = 0;
        return STATUS_NOT_A_DIRECTORY;
    }

    // DVDF - open FILE against parport device
    status = ParOpenFileAgainstParport( extension );
    if( !NT_SUCCESS( status ) ) {
        //
        // We couldn't open a handle to the parport device - bail out
        //
        Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        extension->CreateOpenLock = 0;
        return STATUS_ACCESS_DENIED;
    }

    //Lock in driver code
    ParClaimDriver();

    // lock in ParPort driver
    ParGetPortInfoFromPortDevice(extension);

    // try to allocate the port for our exclusive use
    status = ParAllocPort(extension, Irp);

    // DbgPrint("ParVDMDeviceControl: ParAllocPort returned %#08lx\n");

    if( !NT_SUCCESS( status ) ) {
        extension->CreateOpenLock = 0;
    }
    return status;
}


NTSTATUS
ParClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a close requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    PDEVICE_EXTENSION   extension;
    NTSTATUS            statusOfWait;


    extension = DeviceObject->DeviceExtension;

    if (!extension->PortOwned)
        return STATUS_ACCESS_DENIED;


    // free the port for other uses
    extension->FreePort(extension->FreePortContext);
    extension->PortOwned = FALSE;

    // Allow the port driver to be paged.
    ParReleasePortInfoToPortDevice(extension);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    // DVDF - close our FILE
    ParCloseFileAgainstParport(extension);

    // Unlock the code that was locked during the open.

    ParReleaseDriver();

    // DbgPrint("ParVDMClose: Close device, we no longer own the port\n");

    extension->CreateOpenLock = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
ParAllocateCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    )

/*++

Routine Description:

    This is the completion routine for the device control request.
    This driver has exclusive access to the parallel port in this
    routine.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

    Extension       - Supplies the device extension.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    KIRQL               oldIrql;
    LONG                irpRef;

    if( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    ParCompleteRequest(Extension, Irp);

    // If the IRP was completed.  It was completed with 'IoCompleteRequest'.

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ParAllocPort(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP Irp
    )

/*++

Routine Description:

    This routine takes the 'CurrentIrp' and sends it down to the
    port driver as an allocate parallel port request.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION  nextSp;
    // DbgPrint("ParVDMAllocPort: Entry\n");

    nextSp = IoGetNextIrpStackLocation(Irp);
    nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextSp->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE;

    IoSetCompletionRoutine(Irp,
               ParAllocateCompletionRoutine,
               Extension, TRUE, TRUE, TRUE);

    // DbgPrint("ParVDMAllocPort: Sending Request and exiting\n");
    return IoCallDriver(Extension->PortDeviceObject, Irp);
}

NTSTATUS
ParDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for device control requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_PENDING  - Request pending.

--*/

{
    PDEVICE_EXTENSION   extension;
    PIO_STACK_LOCATION  currentStack;
    NTSTATUS            status = STATUS_INVALID_PARAMETER;

    extension = DeviceObject->DeviceExtension;
    currentStack = IoGetCurrentIrpStackLocation(Irp);

    switch(currentStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_VDM_PAR_WRITE_DATA_PORT: {

        // DbgPrint("ParVDMDeviceControl: IOCTL_VDM_PAR_WRITE_DATA_PORT\n");
        if(extension->PortOwned) {
        UCHAR *data = (PUCHAR) Irp->AssociatedIrp.SystemBuffer;
        ULONG length = currentStack->Parameters.DeviceIoControl.InputBufferLength;

        Irp->IoStatus.Information = 0;

        if (length == 1) {
            WRITE_PORT_UCHAR(extension->Controller +
                     PARALLEL_DATA_OFFSET,
                     *data);
        } else {

            for(; length != 0; length--, data++) {
            WRITE_PORT_UCHAR(extension->Controller +
                     PARALLEL_DATA_OFFSET,
                     *data);
            // KeStallExecutionProcessor(1);
            }
        }

        status = STATUS_SUCCESS;

        } else {

        status = STATUS_ACCESS_DENIED;

        }

        break;
    }

    case IOCTL_VDM_PAR_READ_STATUS_PORT: {

        // DbgPrint("ParVDMDeviceControl: IOCTL_VDM_PAR_READ_STATUS_PORT\n");
        if (extension->PortOwned) {

        if(currentStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(UCHAR)) {

            *(PUCHAR)(Irp->AssociatedIrp.SystemBuffer) =
            READ_PORT_UCHAR(extension->Controller +
                    PARALLEL_STATUS_OFFSET);

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(UCHAR);

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
        } else {
        status = STATUS_ACCESS_DENIED;
        }
        break;
    }

    case IOCTL_VDM_PAR_WRITE_CONTROL_PORT: {

        // DbgPrint("ParVDMDeviceControl: IOCTL_VDM_PAR_WRITE_CONTROL_PORT\n");
        if(extension->PortOwned) {

        if(currentStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(UCHAR)) {

            WRITE_PORT_UCHAR(
            extension->Controller + PARALLEL_CONTROL_OFFSET,
            *(PUCHAR)(Irp->AssociatedIrp.SystemBuffer)
            );

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(UCHAR);
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
        } else {
        status = STATUS_ACCESS_DENIED;
        }
        break;
    }

    default: {
        // DbgPrint("ParVDMDeviceControl: Unknown IOCTL\n");
        status = STATUS_INVALID_PARAMETER;
        break;
    }
    }

    // DbgPrint("ParVDMDeviceControl: Exit with status %#08lx\n", status);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_PARALLEL_INCREMENT);
    return status;
}

VOID
ParUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++

Routine Description:

    This routine loops through the device list and cleans up after
    each of the devices.

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT                      currentDevice;
    PDEVICE_EXTENSION                   extension;
    KEVENT                              event;
    PARALLEL_INTERRUPT_SERVICE_ROUTINE  interruptService;
    PIRP                                irp;
    IO_STATUS_BLOCK                     ioStatus;

    while (currentDevice = DriverObject->DeviceObject) {

    extension = currentDevice->DeviceExtension;

    if (extension->CreatedSymbolicLink) {
        IoDeleteSymbolicLink(&extension->SymbolicLinkName);
        ExFreePool(extension->SymbolicLinkName.Buffer);
    }

        if( extension->ParPortName.Buffer ) {
            RtlFreeUnicodeString( &extension->ParPortName );
        }

    IoDeleteDevice(currentDevice);
    }

    if( OpenCloseMutex ) {
        ExFreePool( OpenCloseMutex );
        OpenCloseMutex = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\published\ddk\inc\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

all: $(DDK_INC_PATH)\dderror.h  $(O)\hbapiwmi.h

clean: cleansrc all

cleansrc:
    -erase dderror.w $(O)\hbapiwmi.h

$(O)\hbapiwmi.h: hbaapi.mof
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS) hbaapi.mof > $(O)\hbaapi.mof
    mofcomp /b:$O\hbaapi.bmf $(O)\hbaapi.mof
    wmimofck -h$O\hbapiwmi.h -m -u $O\hbaapi.bmf
    $(PUBLISH_CMD) {$(O)\hbapiwmi.h=$(DDK_INC_PATH)\hbapiwmi.h}

$(DDK_INC_PATH)\dderror.h: dderror.w
    $(PUBLISH_CMD) {$**=$@}

dderror.w: $(SDK_INC_PATH)\winerror.h makefile.inc
    type << > $@

/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    dderror.h

Abstract:

    This module defines the 32-Bit Windows error codes that are useable by
    portable kernel drivers.

Revision History:

--*/

#ifndef _DDERROR_
#define _DDERROR_

/*
 * This file is a subset of Win32 error codes. Other win32 error codes
 * are not supported by portable drivers and should not beused.
 * This #define removes the definitions of all other error codes.
 */

#define _WINERROR_

<<
    hextract -o $@ -lt dderror -bt begin_dderror end_dderror $(SDK_INC_PATH)\winerror.h
    type << >> $@

#endif /* _DDERROR_ */

<<
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parvdm\test\test.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    chngcnt.c

Abstract:

        User mode program to retrive media change counts from a scsi driver

Author:

    13-May-1995 Peter Wieland (peterwie)

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#include <winioctl.h>
#include <ntddpar.h>
#include "..\..\..\..\inc\ntddvdm.h"

int __cdecl main(int argc, char *argv[])       {

    HANDLE h;
    ULONG in;
    ULONG out;
    ULONG bytesBack;
    UCHAR cmd;
    ULONG num;
    UCHAR buf[128];

    ULONG ioctlCode;

    h = CreateFile(argv[1], 
                   GENERIC_READ | GENERIC_WRITE, 
                   FILE_SHARE_READ | FILE_SHARE_WRITE, 
                   NULL, 
                   OPEN_EXISTING, 
                   FILE_ATTRIBUTE_NORMAL, 
                   NULL);

    if(h == INVALID_HANDLE_VALUE) {
        printf("Error [%d] opening device %s\n", GetLastError(), argv[1]);
        return -1;
    }

    do {

        printf("Command>");
        fflush(stdout);

        if((gets(buf) == NULL) && (feof(stdin))) {
            printf("EOF - exiting\n");
            break;
        }

        cmd = 'x';
        num = 75;
        bytesBack = 0;
        in = out = 0xff;

        sscanf(buf, "%c %d", &cmd, &num);

        switch(cmd) {

            case 'c': {

		printf("IOCTL_VDM_PAR_WRITE_CONTROL_PORT %d\n", num);
		ioctlCode = IOCTL_VDM_PAR_WRITE_CONTROL_PORT;
                in = num;
                break;
            }

            case 's': {

		printf("IOCTL_VDM_PAR_READ_STATUS_PORT\n");
		ioctlCode = IOCTL_VDM_PAR_READ_STATUS_PORT;
                out = 0;
                break;
            }

            case 'w': {

		printf("IOCTL_VDM_PAR_WRITE_DATA_PORT %d\n", num);
		ioctlCode = IOCTL_VDM_PAR_WRITE_DATA_PORT;
                in = num;
                break;
            }

            case 'q': {
                printf("Quitting\n");
                goto Done;
                break;
            }

            default: {

                printf("Unknown command %c\n", cmd);
                ioctlCode = 0;
                break;
            }
        }
                
        if(ioctlCode == 0) {
            continue;
        }

        if(!DeviceIoControl(h, 
                            ioctlCode, 
                            &in, 
                            sizeof(in), 
                            &out,
                            sizeof(out),
                            &bytesBack,
                            NULL )) {
            printf("Error [%d] sending ioctl\n", GetLastError());
            continue;
        } else {
            printf("Ioctl sent - %d bytes back - %d back\n", bytesBack,  out);
        }
    } while(TRUE);

Done:

    CloseHandle(h);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\parallel\parvdm\parvdm.h ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name :

    parsimp.h

Abstract:

    Type definitions and data for a simple parallel class driver.

Author:

    Norbert P. Kusters 4-Feb-1994

Revision History:

--*/

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ParV')
#endif

#define PARALLEL_DATA_OFFSET 0
#define PARALLEL_STATUS_OFFSET 1
#define PARALLEL_CONTROL_OFFSET 2
#define PARALLEL_REGISTER_SPAN 3

typedef struct _DEVICE_EXTENSION {

    //
    // Points to the device object that contains
    // this device extension.
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // Points to the port device object that this class device is
    // connected to.
    //
    PDEVICE_OBJECT PortDeviceObject;

    //
    // Keeps track of whether or not we actually own the
    // parallel hardware
    //
    BOOLEAN PortOwned;

    BOOLEAN spare[3]; // force to DWORD alignment

    //
    // Enforce exclusive Create/Open - 1 == either handle open or Create/Open in process
    //                                 0 == no handle open to device
    //
    ULONG CreateOpenLock;

    //
    // This holds the result of the get parallel port info
    // request to the port driver.
    //
    PHYSICAL_ADDRESS OriginalController;
    PUCHAR Controller;
    ULONG SpanOfController;
    PPARALLEL_FREE_ROUTINE FreePort;
    PVOID FreePortContext;

    //
    // Records whether we actually created the symbolic link name
    // at driver load time and the symbolic link itself.  If we didn't
    // create it, we won't try to destroy it when we unload.
    //
    BOOLEAN CreatedSymbolicLink;
    UNICODE_STRING SymbolicLinkName;

#ifdef INTERRUPT_NEEDED

    //
    // Set 'IgnoreInterrupts' to TRUE unless the port is owned by
    // this device.
    //

    BOOLEAN IgnoreInterrupts;
    PKINTERRUPT InterruptObject;

    //
    // Keep the interrupt level alloc and free routines.
    //

    PPARALLEL_TRY_ALLOCATE_ROUTINE TryAllocatePortAtInterruptLevel;
    PVOID TryAllocateContext;

#endif

#ifdef TIMEOUT_ALLOCS

    //
    // This timer is used to timeout allocate requests that are sent
    // to the port device.
    //
    KTIMER AllocTimer;
    KDPC AllocTimerDpc;
    LARGE_INTEGER AllocTimeout;

    //
    // This variable is used to indicate outstanding references
    // to the current irp.  This solves the contention problem between
    // the timer DPC and the completion routine.  Access using
    // 'ControlLock'.
    //

#define IRP_REF_TIMER               1
#define IRP_REF_COMPLETION_ROUTINE  2

    LONG CurrentIrpRefCount;
    KSPIN_LOCK ControlLock;

    //
    // Indicates that the current request timed out.
    //
    BOOLEAN TimedOut;

#endif

    //
    // Name of the parport device that we use when opening a FILE
    //
    UNICODE_STRING ParPortName;
    PFILE_OBJECT   ParPortFileObject;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#ifdef INTERRUPT_NEEDED

BOOLEAN
ParInterruptService(
    IN      PKINTERRUPT Interrupt,
    IN OUT  PVOID       Extension
    );

VOID
ParDpcForIsr(
    IN  PKDPC           Dpc,
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    );

VOID
ParDeferredPortCheck(
    IN  PVOID   Extension
    );

#endif

#ifdef TIMEOUT_ALLOCS

VOID
ParAllocTimerDpc(
    IN  PKDPC   Dpc,
    IN  PVOID   Extension,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    );

#endif

NTSTATUS
ParCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParClose(
    IN PDEVICE_OBJECT	DeviceObject,
    IN PIRP		Irp
    );

NTSTATUS
ParDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
ParUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\published\internal\inc\rt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.


Module Name:

    rt.h

Abstract:

    This is the public include file for realtime executive (rt.sys) clients.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




#ifdef __cplusplus
extern "C" {
#endif


// The following values can be ORed together and the result passed as the Flags argument
// to the RtCreateThread and RtAdjustCpuLoad routines.

#define CPUCYCLES		0x10000
#define INSTRUCTIONS	0x20000

#define USESFLOAT		0x00001
#define USESMMX			0x00002


// These should be used when calculating the desired period and duration to be
// passed to RtCreateThread and RtAdjustCpuLoad.

#define WEEK 604800000000000000I64
#define DAY   86400000000000000I64
#define HOUR   3600000000000000I64
#define MIN      60000000000000I64
#define SEC       1000000000000I64
#define MSEC         1000000000I64
#define USEC            1000000I64
#define NSEC               1000I64
#define PSEC                  1I64


#define X86 1


#define INTEL 1
#define AMD 2



typedef struct {
	ULONG ProcessorCount;	// Number of CPUs in the system.
	ULONG CpuArchitecture;	// Architecture of CPU, currently always X86==1
	ULONG CpuManufacturer;	// Manufacturer ID, Intel==1, AMD==2
	ULONG CpuFamily;		// CPU Family as reported by cpuid instruction.  0x0-0xf
	ULONG CpuModel;			// CPU Model as reported by cpuid instruction.  0x0-0xf
	ULONG CpuStepping;		// CPU Stepping as reported by cpuid instruction.  0x0-0xf
	ULONGLONG CpuFeatures;	// CPU features as reported by cpuid instruction.
	ULONGLONG CpuExtendedFeatures;	// AMD extended features.  (Not implemented.)  Always 0.
	ULONGLONG ProcessorID[2];		// Processor Unique ID.  If enabled.
	ULONG CpuCyclesPerMsec;			// Number of cpu cycles per MSEC.
	ULONG SystemBusCyclesPerMsec;	// Number of system bus cycles per MSEC.
	ULONG ReservedCpuPerMsec;		// Total cpu time reserved per ms by existing rt threads. (in picoseconds)
	ULONG UsedCpuPerMsec;			// Estimate of cpu time used per ms by existing rt threads. (in picoseconds)
	ULONG AvailableCpuPerMsec;		// Cpu time available per ms for allocation to new rt threads. (in picoseconds)
	} SystemInfo;



// The following realtime thread statistics are updated just before control is
// passed by the realtime executive to the realtime thread.  Everytime a realtime
// thread is being switched in, these statistics are updated before control is transfered.
// This means the statistics will change over time, but not while a realtime
// thread is running between thread switches.

#pragma pack(push,2)

typedef struct threadstats {
	ULONGLONG Period;		// Period as passed to RtCreateThread or latest RtAdjustCpuLoad call.
	ULONGLONG Duration;		// Duration from RtCreateThread or latest RtAdjustCpuLoad call.
	ULONG Flags;			// Flags from RtCreateThread or latest RtAdjustCpuLoad call.
	ULONG StackSize;		// StackSize from RtCreateThread call.
	ULONGLONG PeriodIndex;					// Number of periods since start of thread.
	ULONGLONG TimesliceIndex;				// Number of times thread has been switched to.
	ULONGLONG TimesliceIndexThisPeriod;		// Number of times thread switch to this period.
	ULONGLONG ThisPeriodStartTime;			// Starting time for current period.
	ULONGLONG ThisTimesliceStartTime;		// Starting time for current timeslice.
	ULONGLONG DurationRunThisPeriod;		// Total time run so far this period.
	ULONGLONG DurationRunLastPeriod;		// Total time run in the last period.
	} ThreadStats;

#pragma pack(pop)


typedef VOID (*RTTHREADPROC)(PVOID Context, ThreadStats *Statistics);



NTSTATUS
RtVersion (
	OUT PULONG Version
	);

// RtVersion will return the version number of the currently running
// realtime executive.

// If the realtime executive is running, this function returns
// STATUS_SUCCESS.  If for some reason the realtime executive
// cannot run on the current machine then STATUS_NOT_SUPPORTED
// is returned.

// Currently the realtime executive will only run on PII class or newer
// machines.

// If the pointer to the version number is non NULL, then the
// version information for the currently loaded realtime executive
// is returned.  The version information will be returned regardless
// of the NTSTATUS code returned by the function.

// The version number returned is in the format xx.xx.xx.xx where each
// xx is 1 byte of the ULONG and the ordering left to right is high
// order byte - > low order byte.  ie: 0x01020304 is version 1.2.3.4

// It IS acceptable to pass in a NULL version pointer.  In that case
// no version information is returned.

// If this function is called from a real time thread, then the version
// pointer MUST either be NULL, or it MUST point to a local variable on 
// that real time thread's stack.  Otherwise this function will return 
// STATUS_INVALID_PARAMETER.

// If this function is called from Windows, then the pointer must be
// valid for writing.  Otherwise it will return STATUS_INVALID_PARAMETER.

// This function may be called from any thread.  Windows or realtime.



BOOLEAN
RtThread (
    VOID
    );

// RtThread returns TRUE if called from within a realtime thread.  Otherwise
// it returns FALSE.



NTSTATUS
RtSystemInfo (
	ULONG Processor,
	SystemInfo *pSystemInfo
	);

// RtSystemInfo copies the pertinant processor and system information into the memory 
// pointed to by pSystemInfo.  If pSystemInfo is null or invalid, then RtSystemInfo 
// returns STATUS_INVALID_PARAMETER_2.  Otherwise RtSystemInfo will return STATUS_SUCCESS.

// For uniprocessor systems, the Processor number should be zero.  For N processor
// systems, the processor numbers range from 0 to N-1.  An invalid processor number
// will cause a STATUS_INVALID_PARAMETER_1 to be returned.



NTSTATUS
RtCreateThread (
	ULONGLONG Period,
	ULONGLONG Duration,
	ULONG Flags,
	ULONG StackSize,
	RTTHREADPROC RtThread,
	IN PVOID pRtThreadContext,
	OUT PHANDLE pRtThreadHandle
	);

// RtCreateThread is used to create a realtime thread.

// Period is the used to determine the frequency at which the realtime thread must be
// run.  The current minimum period that can be specified is 1ms.

// Duration is the amount of time within the period that the realtime thread will
// need to run.  Percentage CPU load can be calculated as 100*(Duration/Period) as long
// as Duration and Period are both specified in units of time.

// Flags
// This parameter is used to indicate specific requirements of the realtime thread
// being created.  Currently supported values for Flags are USESFLOAT and USESMMX.
// A realtime thread that can use floating point instructions must specify the
// USESFLOAT flag.  A realtime thread that can use MMX instructions must specify the
// USESMMX flag.

// StackSize is the size of the stack required by the realtime thread in 4k blocks.
// Currently StackSize must be between 1 and 8 inclusive.  RtCreateThread will fail
// with STATUS_UNSUCCESSFUL for any other values of StackSize.

// pRtThreadContext is a pointer to the context that should be passed to the thread.
// It may be NULL.  It is passed to the realtime thread as the Context parameter.

// pRtThreadHandle is a pointer to an RtThreadHandle that can be output from
// RtCreateThread.  pRtThreadHandle can be NULL, in which case no RtThreadHandle is
// returned.  Storage for the HANDLE RtThreadHandle must be allocated by the code
// that calls RtCreateThread.

// RtCreateThread may only be called from within a standard windows thread.  It MUST NOT
// be called from within a realtime thread.



NTSTATUS
RtDestroyThread (
	HANDLE RtThreadHandle
	);

// RtDestroyThread removes the realtime thread identified by RtThreadHandle from the
// list of running realtime threads, and releases all resources that were allocated when
// the thread was created.  RtThreadHandle must be a handle returned from RtCreateThread.

// RtDestroyThread may only be called from within a standard windows thread.  It MUST NOT
// be called from within a realtime thread.



NTSTATUS
RtAdjustCpuLoad (
	ULONGLONG Period,
	ULONGLONG Duration,
	ULONGLONG Phase,
	ULONG Flags
	);

// This function allows a realtime thread to adjust the amount of CPU that is allocated
// to it.  The Flags parameter must currently match that passed in at thread creation
// time, however, the Period and Duration may be different from the Period and Duration
// passed at thread create time.  If there is sufficient CPU to meet the new request,
// the function will return STATUS_SUCCESS and the Period and Duration in the thread's
// statistics will be updated to match the values passed in to this function.  If
// there is not enough CPU available to meet the request, this function will leave
// the Period and Duration recorded in Statistics unchanged and will return
// STATUS_INSUFFICIENT_RESOURCES.

// This function MUST be called from within a realtime thread.  A realtime thread can
// only change its OWN allocation.  It cannot change the allocation of any other
// realtime thread.



VOID
RtYield (
	ULONGLONG Mark,
	ULONGLONG Delta
	);

// RtYield will yield execution to other realtime threads in the system.

// It should be called whenever a realtime thread does not require further CPU resources.

// Parameters:
//  Mark
//		This is the reference time which will be subtracted from the current
//		realtime executive scheduler time.  Note that this time is ALWAYS
//		considered by the scheduler to be in the past.  Do NOT pass a time
//		which occurs in the future to this parameter.
//	Delta
//		This is the time that will be compared to the difference between the current
//		scheduler time and the mark.  The thread will yield execution until
//		the difference between the current scheduler time and the mark is greater 
//		than delta.

//		After a thread has called RtYield it will only be run when the following
//		code evaluates TRUE.  ( (RtTime() - Mark) >= Delta )  Until that occurs
//		the thread will NOT run.  Unless it is holding a spinlock required by
//		some other realtime thread - in which case it will run until it releases
//		the spinlock at which point it will again yield.



PVOID
RtAddLogEntry (
    ULONG Size
    );

// RtAddLogEntry reserves space for a new entry in the realtime logging buffer.
// It returns a pointer to the reserved space.  Note that if an unsupported Size
// is specified, or if there is no realtime logging buffer available on the
// system, this routine will return NULL.

// Parameters:
//  Size
//      This is the size in bytes of the chunk to reserve in the log.  It MUST be
//      an integral multiple of 16.



// The following standard WDM functions are also safe to call from within a real time 
// thread:  KeAcquireSpinLock and KeReleaseSpinLock.

// They have been modified to support realtime threads in the following ways:



// KeAcquireSpinLock

// KeAcquireSpinLock will now always attempt to take the spinlock regardless of whether it
// is running on a multiproc or uniproc machine.  If the spinlock is already acquired,
// then KeAcquireSpinLock will spin in a loop that calls RtYield(THISTIMESLICE) until
// the spinlock is released.

// It will then claim the spinlock.  This means that realtime threads that attempt to 
// acquire a held spinlock will BLOCK until the spinlock is free.  If you don't HAVE to use 
// spinlocks in your realtime threads, DON'T.

// Note that other realtime threads will continue to run as scheduled, but the thread
// waiting for the spinlock will continue yielding all its timeslices until the spinlock
// is released.

// If KeAcquireSpinLock is called from a realtime thread, then it will NOT attempt to
// change any irql levels.  This is important, since the current Windows IRQL level may
// be at higher than DISPATCH_LEVEL when this function is called.  Furthermore, the OldIrql
// returned by this function when it is called from a realtime thread is always 0xff - 
// which is an INVALID irql level.

// If you call KeAcquireSpinLock from a realtime thread you MUST call KeReleaseSpinLock
// for that spinlock from a realtime thread.

// Evenutally, KeAcquireSpinLock will be modified to do an RtDirectedYield to the realtime
// thread that is holding the spinlock.

// KeAcquireSpinLock may be called from within any thread.  Realtime or windows.



// KeReleaseSpinLock

// KeReleaseSpinLock now always attempts to release a held spinlock regardless of whether
// it is running on a multiproc or uniproc machine.

// If KeReleaseSpinLock is called from a realtime thread, then it will NOT change any irql
// levels.  It will also validate that it has been called with a new irql level of 0xff
// as would have been returned by the KeAcquireSpinLock call in the realtime thread to
// acquire the spinlock.

// At some point KeReleaseSpinLock may do an RtDirectedYield back to the realtime thread
// that yielded when it attempted to acquire the spinlock.

// KeReleaseSpinLock may be called from within any thread.  Realtime or windows.


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\published\sdk\inc\makefile.inc ===
#
# ksmedia.h, ksmediap.h
#
$(O)\ksmedia.w: $(O)\ksmedia.h $(O)\ksmediap.h

$(O)\ksmedia.h : ksmedia.w
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ $?
    
$(O)\ksmediap.h: ksmedia.w
    copy $? $@


#
# 1394wmi.h, 1394wmi.bmf
#
$(O)\1394wmi.bmf: $(O)\1394wmi.mof
$(O)\1394wmi.w : $(O)\1394wmi.bmf
    wmimofck -m -h$@ $?

$(O)\ntddredb.bmf: $(O)\ntddredb.mof
$(O)\ntddredb.w : $(O)\ntddredb.bmf
    wmimofck -h$@ $?

WINIOCTL_DEPENDS = $(SDK_INC_PATH)\devioctl.h \
                   ntddstor.w \
                   ntdddisk.w \
                   ntddchgr.w \
                   ntddser.w \
                   $(SDK_INC_PATH)\ntioapi.h \
                   ntddvol.w


########################################################################
# winioctl.h
#

$(O)\winioctl.w: $(WINIOCTL_DEPENDS) makefile.inc
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    winioctl.h

Abstract:

    This module defines the 32-Bit Windows Device I/O control codes.

Revision History:

--*/


//
// Device interface class GUIDs.
//
// need these GUIDs outside conditional includes so that user can
//   #include <winioctl.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <winioctl.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

<<
    hextract -f -o $@ -lt wioctlguids -bt begin_wioctlguids end_wioctlguids $(WINIOCTL_DEPENDS)
    type << >> $@

//
// Obsolete device interface class GUID names.
// (use of above GUID_DEVINTERFACE_* names is recommended).
//
<<
    hextract -f -o $@ -lt wioctlobsoleteguids -bt begin_wioctlobsoleteguids end_wioctlobsoleteguids $(WINIOCTL_DEPENDS)
    type << >> $@

#endif // DEFINE_GUID

#ifndef _WINIOCTL_
#define _WINIOCTL_

<<
    hextract -f -o $@ -lt winioctl -bt begin_winioctl end_winioctl $(WINIOCTL_DEPENDS)
    type << >> $@

#endif // _WINIOCTL_

<<
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\chanmgr.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    chanmgr.c

Abstract:

    Routines for managing channels in the sac.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#include "sac.h"

/////////////////////////////////////////////////////////
//
// Begin global data
// 

//
// The max number of times we attempt to reap a channel
// when shutting down the channel manager
//                                      
#define SHUTDOWN_MAX_ATTEMPT_COUNT 100

//
// Delay between channel each reap attempt (ms)
//
#define SHUTDOWN_REAP_ATTEMP_DELAY 500

//
// This is where the channel objects are stored
//
PSAC_CHANNEL    ChannelArray[MAX_CHANNEL_COUNT];

//
// Macros for managing the different channel locks
//

#if DBG
#define MAX_REF_COUNT   100
#endif

#define INIT_CHANMGR_LOCKS(_i)                  \
    INITIALIZE_LOCK(ChannelSlotLock[_i]);       \
    InterlockedExchange((volatile long *)&ChannelRefCount[_i], 0);\
    InterlockedExchange((volatile long *)&ChannelReaped[_i], 1);

//
// This macro increments the ref count of a channel
// if the ref count was already non-zero (in use).
//
#define CHANNEL_REF_COUNT_INCREMENT_IN_USE(_i)\
    if (CHANNEL_SLOT_IS_IN_USE(_i)) {           \
        CHANNEL_REF_COUNT_INCREMENT(_i);        \
        ASSERT(ChannelRefCount[_i] >= 2);       \
    }                                           \

#define CHANNEL_REF_COUNT_INCREMENT(_i)\
    ASSERT(ChannelRefCount[_i] <= MAX_REF_COUNT);   \
    ASSERT(ChannelRefCount[_i] >= 1);                \
    InterlockedIncrement((volatile long *)&ChannelRefCount[_i]);     \
    ASSERT(ChannelRefCount[_i] <= MAX_REF_COUNT);
    
#define CHANNEL_REF_COUNT_DECREMENT(_i)\
    ASSERT(ChannelRefCount[_i] <= MAX_REF_COUNT);   \
    ASSERT(ChannelRefCount[_i] > 1);                \
    InterlockedDecrement((volatile long *)&ChannelRefCount[_i]);     \
    ASSERT(ChannelRefCount[_i] >= 1);    

#define CHANNEL_REF_COUNT_ZERO(_i)\
    ASSERT(ChannelRefCount[_i] == 1);               \
    ASSERT(!ChannelIsActive(ChannelArray[_i]));     \
    InterlockedExchange((volatile long *)&ChannelRefCount[_i], 0);

#define CHANNEL_REF_COUNT_ONE(_i)\
    ASSERT(ChannelRefCount[_i] == 0);               \
    InterlockedExchange((volatile long *)&ChannelRefCount[_i], 1);

#define CHANNEL_REF_COUNT_DECREMENT_WITH_LOCK(_i)\
    LOCK_CHANNEL_SLOT(_i);                          \
    CHANNEL_REF_COUNT_DECREMENT(_i);                \
    UNLOCK_CHANNEL_SLOT(_i);            

#define CHANNEL_SLOT_IS_IN_USE(_i)\
    (ChannelRefCount[_i] > 0)                     
    
#define CHANNEL_SLOT_IS_REAPED(_i)\
    (ChannelReaped[_i])

#define CHANNEL_SLOT_IS_REAPED_SET(_i)\
    InterlockedExchange((volatile long *)&ChannelReaped[_i], 1);                  

#define CHANNEL_SLOT_IS_REAPED_CLEAR(_i)\
    ASSERT(ChannelReaped[_i] == 1);    \
    InterlockedExchange((volatile long *)&ChannelReaped[_i], 0);                  

#define CHANNEL_SLOT_IS_IN_USE(_i)\
    (ChannelRefCount[_i] > 0)                     

#define LOCK_CHANNEL_SLOT(_i)    \
    ACQUIRE_LOCK(ChannelSlotLock[_i])

#define UNLOCK_CHANNEL_SLOT(_i)  \
    RELEASE_LOCK(ChannelSlotLock[_i])

//
// Corresponding array of mutex's for each channel
//
ULONG       ChannelRefCount[MAX_CHANNEL_COUNT];
ULONG       ChannelReaped[MAX_CHANNEL_COUNT];
SAC_LOCK    ChannelSlotLock[MAX_CHANNEL_COUNT];

//
// This lock is used to prevent >= 2 threads from 
// creating a channel at the same time.  By holding this
// lock while we create a channel, we can ensure that
// when we check for name uniqueness, that there isn't
// another thread creating a channel with the same name.
//
SAC_LOCK    ChannelCreateLock;

//
// Flag indicating if the channel manager is allowed to
// create new channels.  This is used, for instance,
// when we shutdown the channel manager to prevent
// new channels from being created after we shutdown.
//
BOOLEAN     ChannelCreateEnabled;

#define IsChannelCreateEnabled()    (ChannelCreateEnabled)

//
// prototypes
//
NTSTATUS
ChanMgrReapChannels(
    VOID
    );

NTSTATUS
ChanMgrReapChannel(
    IN ULONG    ChannelIndex
    );

//
// End global data
//
/////////////////////////////////////////////////////////

NTSTATUS
ChanMgrInitialize(
    VOID
    )
/*++

Routine Description:

    This routine allocates and initializes the channel manager structures
      
Arguments:

    NONE
                        
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    ULONG   i;

    //
    // Initialize the channel create lock
    //
    INITIALIZE_LOCK(ChannelCreateLock);
    
    //
    // Channel creation is enabled
    //
    ChannelCreateEnabled = TRUE;

    //
    // initialize each channel slot
    //
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
    
        //
        // initialize the channel as available
        //
        ChannelArray[i] = NULL;

        //
        // initialize the locks for this channel
        //
        INIT_CHANMGR_LOCKS(i);

    }

    return STATUS_SUCCESS;

}

NTSTATUS
ChanMgrShutdown(
    VOID
    )
/*++

Routine Description:

    This routine allocates and initializes the channel manager structures
      
Arguments:

    NONE
                        
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    NTSTATUS        Status;
    ULONG           i;
    ULONG           AttemptCount;
    PSAC_CHANNEL    Channel;

    //
    // NOT YET TESTED
    //               

    //
    // Hold the channel create lock and prevent any new channels from
    // being created while we shutdown
    //
    ACQUIRE_LOCK(ChannelCreateLock);

    //
    // Channel creation is disabled
    //
    ChannelCreateEnabled = TRUE;
    
    //
    // Close each channel
    //
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
    
        //
        // Get the ith channel
        //
        Status = ChanMgrGetByIndex(
            i,
            &Channel
            );
        
        //
        // skip empty channel slots
        //
        if (Status == STATUS_NOT_FOUND) {
            
            //
            // advance to the next channel slot
            //
            continue;
        
        }

        //
        // break if we hit an error...
        //
        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // Close the channel
        //
        Status = ChannelClose(Channel);

        //
        // break if we hit an error...
        //
        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // Release the channel
        //
        Status = ChanMgrReleaseChannel(Channel);
        
        //
        // break if we hit an error...
        //
        if (! NT_SUCCESS(Status)) {
            break;
        }
    
    }

    //
    // At this point, all the channels are closed.
    // However, it is possible that a channel is still
    // being used - the ref count of the channel is > 1.
    // We need to attempt to reap the channels until
    // all are reaped, or we give up.
    //

    //
    // Attempt to reap each channel
    //
    AttemptCount = 0;
    
    while(AttemptCount < SHUTDOWN_MAX_ATTEMPT_COUNT) {

        BOOLEAN         bContinue;
        
        //
        // Attempt to reap all unreaped channels
        //
        Status = ChanMgrReapChannels();
        
        if (!NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // See if any channels are not reaped
        //
        bContinue = FALSE;

        for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
            
            //
            // If the channel is not reaped, delay before attempting again
            //
            if (! CHANNEL_SLOT_IS_REAPED(i)) {
                
                //
                // We need to continue reaping
                //
                bContinue = TRUE;

                break;
            
            }
        
        }
        
        //
        // if we need to continue reaping, 
        // then increment our attempt count and delay
        // otherwise, we are done.
        //
        if (bContinue) {
            
            LARGE_INTEGER   WaitTime;
            
            //
            // When attempting to reap a channel, this is the delay we use
            // between each reap attempt.
            //
            WaitTime.QuadPart = Int32x32To64((LONG)SHUTDOWN_REAP_ATTEMP_DELAY, -1000); 

            //
            // Keep track of how many times we have tried
            //
            AttemptCount++;

            //
            // Wait...
            //
            KeDelayExecutionThread(KernelMode, FALSE, &WaitTime);
        
        } else {

            //
            // all channels are reaped
            // 
            break;

        }
    
    }

    //
    // Release the channel create lock and let the create threads
    // unblock.  They will fail their creation attempt because creation
    // is now disabled.
    //
    RELEASE_LOCK(ChannelCreateLock);
    
    return STATUS_SUCCESS;

}

NTSTATUS
ChanMgrGetChannelIndex(
    IN  PSAC_CHANNEL    Channel,
    OUT PULONG          ChannelIndex
    )
/*++

Routine Description:

    This routine determines a channel's index in teh channel array.
                          
Arguments:

    Channel         - the channel to get the index of
    ChannelIndex    - the index of the channel 

Return Value:

    STATUS_SUCCESS      - if the mapping was successful
    
    otherwise, error status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(ChannelIndex, STATUS_INVALID_PARAMETER_2);

    *ChannelIndex = ChannelGetIndex(Channel);

    return STATUS_SUCCESS;
}

BOOLEAN
ChanMgrIsUniqueName(
    IN PCWSTR   Name
    )
/*++

Routine Description:

    This routine determines if a channel name already is used
      
Arguments:

    Name    - the name to search for    
                        
Return Value:

    TRUE    - if the channel name is unique
    
    otherwise, FALSE

--*/
{
    BOOLEAN             IsUnique;
    NTSTATUS            Status;
    PSAC_CHANNEL        Channel;

    IsUnique = FALSE;

    //
    // see if a channel already has the name
    //
    Status = ChanMgrGetChannelByName(
        Name, 
        &Channel
        );

    //
    // if we get a not found status, 
    // then we know the name is unique
    //
    if (Status == STATUS_NOT_FOUND) {
        IsUnique = TRUE;
    }

    //
    // we are done with the channel
    //
    if (NT_SUCCESS(Status)) {
        ChanMgrReleaseChannel(Channel);
    }
    
    return IsUnique;

}

NTSTATUS
ChanMgrGenerateUniqueCmdName(
    OUT PWSTR   ChannelName
    )
/*++

Routine Description:

    This routine generates a unique channel name for the cmd console channels
    
Arguments:

    ChannelName - destination buffer for the new channel name

Return Value:

    STATUS_SUCCESS      - if the mapping was successful
    
    otherwise, error status

--*/
{
    //
    // Counter for generating unique cmd names
    //
    static ULONG CmdConsoleChannelIndex = 0;
    
    ASSERT_STATUS(ChannelName, STATUS_INVALID_PARAMETER);

    //
    // Keep constructing a new name unti it is unique
    //
    do {
        
        //
        // restrict the channel enumeration to 0-9999
        //
        CmdConsoleChannelIndex = (CmdConsoleChannelIndex + 1) % 10000;

        //
        // construct the channel name
        //
        swprintf(ChannelName, L"Cmd%04d", CmdConsoleChannelIndex);

    } while ( !ChanMgrIsUniqueName(ChannelName) );

    return STATUS_SUCCESS;
}

NTSTATUS
ChanMgrReleaseChannel(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This routine is the counterpart for the GetChannelByXXX routines.
    These routines hold the mutex for the channel if it is found;
    This routine release the mutex.
    
Arguments:

    ChannelIndex    - The index of the channel to release

Return Value:

    Status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    LOCK_CHANNEL_SLOT(ChannelGetIndex(Channel));
    
    CHANNEL_REF_COUNT_DECREMENT(ChannelGetIndex(Channel));
    
    //
    // the reference count should never be 0 at this point
    //
    ASSERT(ChannelRefCount[ChannelGetIndex(Channel)] > 0);
    
    if (ChannelRefCount[ChannelGetIndex(Channel)] == 1) {
        
        do {

            if (! ChannelIsActive(Channel)) {
                
                //
                // If the channel doesn't have the preserve bit set, dereference the channel
                //
                if (! (ChannelArray[ChannelGetIndex(Channel)]->Flags & SAC_CHANNEL_FLAG_PRESERVE)) {

                    //
                    // Channel is officially closed
                    //
                    CHANNEL_REF_COUNT_ZERO(ChannelGetIndex(Channel));

                    break;
                } 
            
                //
                // if the channel is not active and 
                // the channel has the preserve bit set but no longer has new data in 
                // the obuffer, then the channel is now completely closed and the reference
                // can be removed.
                //
                if (! ((ChannelArray[ChannelGetIndex(Channel)]->Flags & SAC_CHANNEL_FLAG_PRESERVE) && 
                        ChannelHasNewOBufferData(ChannelArray[ChannelGetIndex(Channel)]))) {

                    //
                    // Channel is officially closed
                    //
                    CHANNEL_REF_COUNT_ZERO(ChannelGetIndex(Channel));

                    break;
                }
            }
        
        } while ( FALSE );
    
    }

    UNLOCK_CHANNEL_SLOT(ChannelGetIndex(Channel));

    return STATUS_SUCCESS;
}

NTSTATUS
ChanMgrGetByHandle(
    IN  SAC_CHANNEL_HANDLE  TargetChannelHandle,
    OUT PSAC_CHANNEL*       TargetChannel
    )
/*++

Routine Description:

    This routine provides the means to map the Channel Handle which is
    owned by the user mode code to the Channel structure which is owned
    by the driver.
    
    The mapping is done simply by scanning the existing Channels for one with 
    a matching Handle.

    Note: if we successfully find the channel, 
          then the mutex is held for this channel and the caller is 
          responsible for releasing it
    
Arguments:

    TargetChannelHandle    - the handle to the channel to look for
    TargetChannel          - if the search is successful, this contains the
                          a pointer to the SAC_CHANNEL structure of the
                          channel we want

Return Value:

    STATUS_SUCCESS      - if the mapping was successful
    
    otherwise, error status

--*/
{
    NTSTATUS        Status;
    PSAC_CHANNEL    Channel;
    ULONG           i;

    ASSERT_STATUS(TargetChannel, STATUS_INVALID_PARAMETER_2);

    //
    // initialize our response
    //
    *TargetChannel = NULL;
    
    //
    // default: we didn't find the channel
    //
    Status = STATUS_NOT_FOUND;

    //
    // search
    //
    // Note: Since the channel handles are really GUIDs, we can use normal
    //       GUID comparison tools
    //
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {

        //
        // Increment the ref count of channels that are in use,
        // otherwise skip empty channel slots
        //
        LOCK_CHANNEL_SLOT(i);
        CHANNEL_REF_COUNT_INCREMENT_IN_USE(i);
        if (! CHANNEL_SLOT_IS_IN_USE(i)) {
            UNLOCK_CHANNEL_SLOT(i);
            continue;
        }
        UNLOCK_CHANNEL_SLOT(i);
        
        //
        // get the ith channel
        //
        Channel = ChannelArray[i];

        //
        // The channel slot should not be null since the channel is present
        //
        ASSERT(Channel != NULL);

        //
        // compare the handles
        //
        if (ChannelIsEqual(Channel, &TargetChannelHandle)) {

            //
            // we have a match
            //
            Status = STATUS_SUCCESS;

            //
            // Send back the channel
            //
            *TargetChannel = Channel;

            break;

        }
    
        CHANNEL_REF_COUNT_DECREMENT_WITH_LOCK(i);
    
    }

    return Status;
}


NTSTATUS
ChanMgrGetByHandleAndFileObject(
    IN  SAC_CHANNEL_HANDLE  TargetChannelHandle,
    IN  PFILE_OBJECT        FileObject,
    OUT PSAC_CHANNEL*       TargetChannel
    )
/*++

Routine Description:

    This routine provides the same functionality as GetByHandle with the
    added bonus of comparing a channel against the file object that was 
    used to create the channel.

    A successful match implies that the caller specified a valid channel
    handle, and is indeed the process that created the channel.
        
    Note: if we successfully find the channel, 
          then the mutex is held for this channel and the caller is 
          responsible for releasing it
    
Arguments:

    TargetChannelHandle    - the handle to the channel to look for
    FileObject             - the file object to compare against after we have
                             found the channel by its handle
    TargetChannel          - if the search is successful, this contains the
                          a pointer to the SAC_CHANNEL structure of the
                          channel we want

Return Value:

    STATUS_SUCCESS      - if the mapping was successful
    
    otherwise, error status

--*/
{
    NTSTATUS        Status;
    PSAC_CHANNEL    Channel;

    //
    // Get the channel by its handle
    //
    Status = ChanMgrGetByHandle(
        TargetChannelHandle,
        &Channel
        );

    if (NT_SUCCESS(Status)) {
        
        //
        // Compare the channel's file object with the specified object
        //
        if (ChannelGetFileObject(Channel) == FileObject) {

            //
            // They are equal, so send the channel back
            //
            *TargetChannel = Channel;

        } else {
            
            //
            // we are done with the channel
            //
            ChanMgrReleaseChannel(Channel);
            
            //
            // They are not equal, so dont send it back
            //
            *TargetChannel = NULL;
        
            //
            // tell the caller we didnt find the channel
            //
            Status = STATUS_NOT_FOUND;
        
        }
    
    }

    return Status;

}

NTSTATUS
ChanMgrGetChannelByName(
    IN  PCWSTR              Name,
    OUT PSAC_CHANNEL*       pChannel
    )
/*++

Routine Description:

    This is a convenience routine to fetch a channel by its name
    
    Note: if we successfully find the channel, 
          then the mutex is held for this channel and the caller is 
          responsible for releasing it

Arguments:

    Name        - channel name to key on
    pChannel    - if successful, contains the channel

Return Value:

    STATUS_SUCCESS      - channel was found
    
    otherwise, error status

--*/
{
    NTSTATUS        Status;
    NTSTATUS        tmpStatus;
    PSAC_CHANNEL    Channel;
    ULONG           i;
    PWSTR           ChannelName;
    ULONG           l;

    ASSERT_STATUS(Name, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(pChannel, STATUS_INVALID_PARAMETER_2);

    //
    // initialize our response
    //
    *pChannel = NULL;

    //
    // default: we didn't find the channel
    //
    Status = STATUS_NOT_FOUND;
    
    //
    // Find the channel
    //  
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
    
        //
        // Increment the ref count of channels that are in use,
        // otherwise skip empty channel slots
        //
        LOCK_CHANNEL_SLOT(i);
        CHANNEL_REF_COUNT_INCREMENT_IN_USE(i);
        if (! CHANNEL_SLOT_IS_IN_USE(i)) {
            UNLOCK_CHANNEL_SLOT(i);
            continue;
        }
        UNLOCK_CHANNEL_SLOT(i);

        //
        // get the ith channel
        //
        Channel = ChannelArray[i];
        
        //
        // The channel slot should not be null since the channel is present
        //
        ASSERT(Channel != NULL);

        //
        // compare the name
        //
        tmpStatus = ChannelGetName(
            Channel,
            &ChannelName
            );
        
        ASSERT(NT_SUCCESS(tmpStatus));

        if (NT_SUCCESS(tmpStatus)) {
            
            //
            // Compare the names
            //
            l = _wcsicmp(Name, ChannelName);

            //
            // Release the name
            //
            FREE_POOL(&ChannelName);

            //
            // If the names are equal, then we are done
            //
            if (l == 0) {

                //
                // we have a match
                //
                Status = STATUS_SUCCESS;

                //
                // Send back the channel
                //
                *pChannel = Channel;

                break;

            }
        
        }
        
        CHANNEL_REF_COUNT_DECREMENT_WITH_LOCK(i);
    
    }

    return Status;

}

NTSTATUS
ChanMgrGetByIndex(
    IN  ULONG               TargetIndex,
    OUT PSAC_CHANNEL*       TargetChannel
    )
/*++

Routine Description:

    This routine provides the means to retrieve a channel by its index
    in the global channel array.

    Note: if we successfully find the channel, 
          then the mutex is held for this channel and the caller is 
          responsible for releasing it
    
Arguments:

    TargetIndex     - the index of the channel to find
    TargetChannel   - if the search is successful, this contains the
                          a pointer to the SAC_CHANNEL structure of the
                          channel we want

Return Value:

    STATUS_SUCCESS      - if the mapping was successful
    
    otherwise, error status

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(TargetIndex < MAX_CHANNEL_COUNT, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(TargetChannel, STATUS_INVALID_PARAMETER_2);

    //
    // default: the channel slot is empty
    //
    *TargetChannel = NULL;
    Status = STATUS_NOT_FOUND;

    //
    // attempt to get a reference to the specified channel
    //
    LOCK_CHANNEL_SLOT(TargetIndex);
    
    CHANNEL_REF_COUNT_INCREMENT_IN_USE(TargetIndex);
    
    if (CHANNEL_SLOT_IS_IN_USE(TargetIndex)) {
    
        //
        // directly access the channel from teh array
        //
        *TargetChannel = ChannelArray[TargetIndex];

        //
        // We have succeeded
        //
        Status = STATUS_SUCCESS;

    } 
    
    UNLOCK_CHANNEL_SLOT(TargetIndex);
    
    return Status;
}

NTSTATUS
ChanMgrGetNextActiveChannel(
    IN  PSAC_CHANNEL        CurrentChannel,
    OUT PULONG              TargetIndex,
    OUT PSAC_CHANNEL*       TargetChannel
    )
/*++

Routine Description:

    Search the channel array for the next active channel.
    
    Note: if we successfully find the channel, 
          then the mutex is held for this channel and the caller is 
          responsible for releasing it

Arguments:

    CurrentChannel  - Start the search at the entry after this one
    TargetIndex     - If found, this contains the index of the channel
    TargetChannel   - if found, this contains the channel

Return Value:

    Status

--*/
{
    BOOLEAN             Found;
    NTSTATUS            Status;
    ULONG               ScanIndex;
    PSAC_CHANNEL        Channel;
    ULONG               StartIndex;
    ULONG               CurrentIndex;

    ASSERT_STATUS(CurrentChannel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(TargetIndex, STATUS_INVALID_PARAMETER_2);
    ASSERT_STATUS(TargetChannel, STATUS_INVALID_PARAMETER_3);

    //
    // get the index of the current channel
    //
    Status = ChanMgrGetChannelIndex(
        CurrentChannel,
        &CurrentIndex
        );

    if (! NT_SUCCESS(Status)) {
        return Status;
    }
    
    //
    // default: we didn't find any active channels
    //
    Found   = FALSE;
    
    //
    // start searching from the next entry after the current index
    //
    StartIndex = (CurrentIndex + 1) % MAX_CHANNEL_COUNT;
    ScanIndex = StartIndex;

    //
    // scan until we find an active channel, or end up where we started
    //
    // Note: we have a halting condition at the SAC channel, since it
    //       is always active and present.
    //
    do {

        //
        // get the ith channel
        //
        Status = ChanMgrGetByIndex(
            ScanIndex,
            &Channel
            );

        //
        // skip empty channel slots
        //
        if (Status == STATUS_NOT_FOUND) {
            
            //
            // advance to the next channel slot
            //
            ScanIndex = (ScanIndex + 1) % MAX_CHANNEL_COUNT;
            
            continue;
        }

        //
        // break if we hit an error...
        //
        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // A channel is active if:
        // 1. The state is Active or
        // 2. The state is Inactive AND the channel has new data
        //
        if (ChannelIsActive(Channel) || 
            (!ChannelIsActive(Channel) && ChannelHasNewOBufferData(Channel))
            ) {

            Found = TRUE;

            break;
        
        }

        //
        // we are done with the channel slot
        //
        Status = ChanMgrReleaseChannel(Channel);
        
        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // advance to the next channel slot
        //
        ScanIndex = (ScanIndex + 1) % MAX_CHANNEL_COUNT;

    } while ( ScanIndex != StartIndex );

    //
    // If we were successful, send back the results
    //
    if (NT_SUCCESS(Status) && Found) {

        *TargetIndex    = ScanIndex;
        *TargetChannel  = Channel;

    }
    
    return Status;
}

NTSTATUS
ChanMgrCreateChannel(
    OUT PSAC_CHANNEL*                   Channel,
    IN  PSAC_CHANNEL_OPEN_ATTRIBUTES    Attributes
    )
/*++

Routine Description:

    This adds a channel to the Global Channel List.
    
    Note: if we successfully create the channel, 
          then the mutex is held for this channel and the caller is 
          responsible for releasing it
                          
Arguments:

    Channel     - the channel to add
    Attributes  - the new channel's attributes
                
Return Value:

    STATUS_SUCCESS      - if the mapping was successful
    
    otherwise, error status

Security:

    interface:
    
    external -> internal (when using the IOCTL path)
    
        event HANDLES have not yet been validated as referencing
            valid event objects
        everything else has been validated

--*/
{
    NTSTATUS            Status;
    ULONG               i;
    SAC_CHANNEL_HANDLE  Handle;
    PSAC_CHANNEL        NewChannel;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);
    ASSERT_STATUS(Attributes, STATUS_INVALID_PARAMETER_2);

    //
    // Hold the channel create lock while we attempt to create a channel
    //
    ACQUIRE_LOCK(ChannelCreateLock);
    
    do {

        //
        // If channel creation is disabled, then bail
        //
        // Note: we do this check here so that if we
        //       were blocked on the ChannelCreateLock
        //       while the chanmgr was shutting down,
        //       we will notice that channel creation
        //       is disabled.
        //
        if (! IsChannelCreateEnabled()) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // Do lazy garbage collection on closed channels
        //
        Status = ChanMgrReapChannels();

        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // verify that there isn't another channel by the same name
        //
        if (! ChanMgrIsUniqueName(Attributes->Name)) {
            Status = STATUS_DUPLICATE_NAME;
            break;
        }

        //
        // default: we assume there are no vacant channels
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // Allocate memory for the channel
        //
        NewChannel = ALLOCATE_POOL(sizeof(SAC_CHANNEL), CHANNEL_POOL_TAG);
        ASSERT_STATUS(NewChannel, STATUS_NO_MEMORY);
        
        //
        // Initialize the channel memory region
        //
        RtlZeroMemory(NewChannel, sizeof(SAC_CHANNEL));

        //
        // attempt to add the channel to the channel list
        //
        for (i = 0; i < MAX_CHANNEL_COUNT; i++) {

            //
            // find reaped channel slots
            //
            if (! CHANNEL_SLOT_IS_REAPED(i)) {
                continue;
            }

            //
            // Make sure this slot should be available
            //
            ASSERT(! CHANNEL_SLOT_IS_IN_USE(i));

            //
            // Attempt to find an open slot in the channel array
            //
            InterlockedCompareExchangePointer(
                &ChannelArray[i], 
                NewChannel,
                NULL
                );

            //
            // did we get the slot?
            //
            if (ChannelArray[i] != NewChannel) {
                continue;
            }

            //
            // Initialize the SAC_CHANNEL_HANDLE structure
            //
            RtlZeroMemory(&Handle, sizeof(SAC_CHANNEL_HANDLE));

            Status = ExUuidCreate(&Handle.ChannelHandle);

            if (! NT_SUCCESS(Status)) {

                IF_SAC_DEBUG( 
                    SAC_DEBUG_FAILS, 
                    KdPrint(("SAC Create Channel :: Failed to get GUID\n"))
                    );

                break;

            }

            //
            // Instantiate the new channel
            //
            Status = ChannelCreate(
                NewChannel,
                Attributes,
                Handle
                );

            if (! NT_SUCCESS(Status)) {
                break;
            }

            //
            // Set the channel array index for this channel
            //
            ChannelSetIndex(NewChannel, i);

            //
            // This channel slot is now in use
            //
            LOCK_CHANNEL_SLOT(i);
            CHANNEL_REF_COUNT_ONE(i);
            UNLOCK_CHANNEL_SLOT(i);

            //
            // send back the new channel
            //
            *Channel = NewChannel;

            //
            // this channel slot is no longer reaped
            // that is, it contains a live channel
            //
            CHANNEL_SLOT_IS_REAPED_CLEAR(i);    

            break;

        }

        //
        // free the channel memory
        //
        if (!NT_SUCCESS(Status)) {
            FREE_POOL(&NewChannel);
        }
    
    } while ( FALSE );
    
    //
    // We are done attempting to create a channel
    //
    RELEASE_LOCK(ChannelCreateLock);
    
    return Status;
}

NTSTATUS
ChanMgrChannelDestroy(
    PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine destroys the given channel 

    Note: caller must hold channel mutex
    
Arguments:

    Channel   - the channel to remove

Return Value:

    STATUS_SUCCESS      - if the mapping was successful
    
    otherwise, error status

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    //
    // Make sure the caller isn't trying to destroy an active channel
    //
    ASSERT_STATUS(!CHANNEL_SLOT_IS_IN_USE(ChannelGetIndex(Channel)), STATUS_INVALID_PARAMETER);

    //
    // Do channel specific destruction
    //
    Status = Channel->Destroy(Channel);
    
    //
    // Decrement the # of 
    //

    return Status;
}

NTSTATUS
ChanMgrCloseChannelsWithFileObject(
    IN  PFILE_OBJECT    FileObject
    )
/*++

Routine Description:

    This routine closes all channels that have the specified FileObject

Arguments:

    FileObject  - the file object to search for    

Return Value:

    STATUS_SUCCESS
    
    otherwise, error status

--*/
{
    NTSTATUS        Status;
    PSAC_CHANNEL    Channel;
    ULONG           i;

    ASSERT_STATUS(FileObject, STATUS_INVALID_PARAMETER_1);

    //
    // default: we didn't find the channel
    //
    Status = STATUS_NOT_FOUND;
    
    //
    // Find the channels with equal File Objects
    //  
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
    
        //
        // get the ith channel
        //
        Status = ChanMgrGetByIndex(i, &Channel);
    
        //
        // skip empty channel slots
        //
        if (Status == STATUS_NOT_FOUND) {
            
            //
            // advance to the next channel slot
            //
            continue;
        
        }

        //
        // break if we hit an error...
        //
        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // if the file objects are equal,
        // then close the channel
        //
        if (ChannelGetFileObject(Channel) == FileObject) {

            //
            // They are equal, so close the channel
            //
            Status = ChanMgrCloseChannel(Channel);

        }

        //
        // Release the channel
        //
        Status = ChanMgrReleaseChannel(Channel);
        
        //
        // break if we hit an error...
        //
        if (! NT_SUCCESS(Status)) {
            break;
        }

    }

    return Status;

}

NTSTATUS
ChanMgrCloseChannel(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This routine closes the given channel

Arguments:

    Channel   - the channel to close

Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    do {

        //
        // Make sure the channel is not already inactive
        //
        if (! ChannelIsActive(Channel)) {
            Status = STATUS_ALREADY_DISCONNECTED;
            break;
        }

        //
        // Call the channel's close routine first
        //
        Status = ChannelClose(Channel);
    
    } while ( FALSE );
    
    //
    // notify the io mgr that we made an attempt to
    // close the channel.
    //
    IoMgrHandleEvent(
        IO_MGR_EVENT_CHANNEL_CLOSE,
        Channel,
        (PVOID)&Status
        );
    
    return Status;
}

NTSTATUS
ChanMgrReapChannel(
    IN ULONG    ChannelIndex
    )
/*++

Routine Description:

    This routine serves as a garbage collector by scanning
    all channels for those that are ready to be removed.  A
    channel is ready to be removed when its state is both
    inactive and it has no new data in its buffer - i.e.,
    the stored data has been viewed.
    
    Note: caller must hold channel mutex

Arguments:

        ChannelIndex     - index of the channel to reap                        

Return Value:

    STATUS_SUCCESS  if there were no problems,
    
    NOTE: Success doesn't imply that any channels were removed, it
          only means there were no errors during the process.
                             
    otherwise, failure status

--*/
{
    NTSTATUS        Status;
    
    ASSERT_STATUS(ChannelArray[ChannelIndex], STATUS_INVALID_PARAMETER);
    ASSERT_STATUS(ChannelIsClosed(ChannelArray[ChannelIndex]), STATUS_INVALID_PARAMETER);

    //
    // Destroy and free the channel from the channel manager's pool
    //

    do {

        //
        // Make sure all the channel locks are signaled
        //
        ASSERT_CHANNEL_LOCKS_SIGNALED(ChannelArray[ChannelIndex]);

        //
        // destroy the channel
        //
        Status = ChanMgrChannelDestroy(ChannelArray[ChannelIndex]);

        ASSERT(NT_SUCCESS(Status));

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // free the channel memory
        //
        FREE_POOL(&ChannelArray[ChannelIndex]);

        //
        // indicate that this channel slot is available for reuse
        //
        InterlockedExchangePointer(
            &ChannelArray[ChannelIndex], 
            NULL
            );

        //
        // mark this channel slot as reaped
        //
        // Note: this keeps the reaper from re-reaping
        //       a channel while we are creating a new one
        //       in a slot that looks like it can be reaped
        //       that is, the ref count == 0, etc.
        //
        CHANNEL_SLOT_IS_REAPED_SET(ChannelIndex);    

    } while ( FALSE );

    return Status;
}

NTSTATUS
ChanMgrReapChannels(
    VOID
    )
/*++

Routine Description:

    This routine serves as a garbage collector by scanning
    all channels for those that are ready to be removed.  A
    channel is ready to be removed when its state is both
    inactive and it has no new data in its buffer - i.e.,
    the stored data has been viewed.
                          
Arguments:

    Channel   - the channel to add

Return Value:

    Status

--*/
{
    NTSTATUS            Status;
    ULONG               i;

    //
    // default: reap pass was successful
    //
    Status = STATUS_SUCCESS;

    //
    // add the channel to the global channel list
    //
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
    
        //
        // Lock this channel slot
        //
        LOCK_CHANNEL_SLOT(i);

        do {

            //
            // skip reaped channels
            //
            if (CHANNEL_SLOT_IS_REAPED(i)) {
                break;
            }
            ASSERT(ChannelArray[i] != NULL);
            
            //
            // Skip active channel slots
            //
            if (CHANNEL_SLOT_IS_IN_USE(i)) {
                break;
            }

            //
            // Force channels that don't have the preserve bit set into a closed state.
            // That is, status is inactive and the channel has no new data
            //
            ChannelSetIBufferHasNewData(ChannelArray[i], FALSE);
            ChannelSetOBufferHasNewData(ChannelArray[i], FALSE);

            //
            // Do "lazy" garbage collection by only removing channels
            // when we want to create a new one
            //
            Status = ChanMgrReapChannel(i);

            if (! NT_SUCCESS(Status)) {
                break;
            }
        
        } while ( FALSE );
            
        //
        // We are done with this channel
        //
        UNLOCK_CHANNEL_SLOT(i);
        
        if (! NT_SUCCESS(Status)) {
            break;
        }

    }
    
    return Status;
}

NTSTATUS
ChanMgrGetChannelCount(
    OUT PULONG  ChannelCount
    )
/*++

Routine Description:

    This routine determines the current # of channel slots that
    are currently occupied by either an active channel
    or an inactive channel that has it's preserve bit set
    and the data has not been seen (quasi-active state).

Arguments:

    ChannelCount

Return Value:

    Status

--*/
{
    ULONG               i;
    NTSTATUS            Status;
    PSAC_CHANNEL        Channel;

    ASSERT_STATUS(ChannelCount, STATUS_INVALID_PARAMETER);

    //
    // default
    //
    Status = STATUS_SUCCESS;
    
    //
    // Initialize
    //
    *ChannelCount = 0;
    
    //
    // Iterate through the channels count the # of channel slots that
    // are currently occupied by either an active channel
    // or an inactive channel that has it's preserve bit set
    // and the data has not been seen (quasi-active state).
    //
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
        
        //
        // Query the channel manager for a list of all currently active channels
        //
        Status = ChanMgrGetByIndex(
            i,
            &Channel
            );

        //
        // skip empty slots
        //
        if (Status == STATUS_NOT_FOUND) {

            //
            // revert to Success since this isn't an error condition
            //
            Status = STATUS_SUCCESS;

            continue;
        
        }

        ASSERT(NT_SUCCESS(Status));
        if (! NT_SUCCESS(Status)) {
            break;
        }

        ASSERT(Channel != NULL);

        //
        // A channel is active if:
        // 1. The state is Active or
        // 2. The state is Inactive AND the channel has new data
        //
        if (ChannelIsActive(Channel) || 
            (!ChannelIsActive(Channel) && ChannelHasNewOBufferData(Channel))
            ) {

            *ChannelCount += 1;

        }

        //
        // We are done with the channel
        //
        Status = ChanMgrReleaseChannel(Channel);
    
        if (! NT_SUCCESS(Status)) {
            break;
        }

    }
    
    ASSERT(NT_SUCCESS(Status));

    return Status;
}

NTSTATUS
ChanMgrIsFull(
    OUT PBOOLEAN    bStatus
    )
/*++

Routine Description:

    Determine if it is possible to add another channel

Arguments:

    bSuccess    - the channel count status

Return Value:

    TRUE    - the max channel count has been reached
    FALSE   - otherwise        
        
--*/
{
    NTSTATUS    Status;
    ULONG       ChannelCount;

    //
    // Get the current channel count
    //
    Status = ChanMgrGetChannelCount(&ChannelCount);

    //
    // This operation should be successful
    //
    ASSERT(Status == STATUS_SUCCESS);

    if (!NT_SUCCESS(Status)) {
        *bStatus = FALSE;
    } else {
        *bStatus = (ChannelCount == MAX_CHANNEL_COUNT ? TRUE : FALSE);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\chanmgr.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    chanmgr.h

Abstract:

    Routines for managing channels.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#ifndef CHAN_MGR_H
#define CHAN_MGR_H

#include <ntddsac.h>

//
// The maximum # of channels allowed to be created - including SAC
//
#define MAX_CHANNEL_COUNT 10

//
// Prototypes
//
NTSTATUS
ChanMgrInitialize(
    VOID
    );

NTSTATUS
ChanMgrShutdown(
    VOID
    );

BOOLEAN
ChanMgrIsUniqueName(
    IN PCWSTR   Name
    );

NTSTATUS
ChanMgrGenerateUniqueCmdName(
    PWSTR   ChannelName
    );

NTSTATUS
ChanMgrCreateChannel(
    OUT PSAC_CHANNEL*                   Channel,
    IN  PSAC_CHANNEL_OPEN_ATTRIBUTES    Attributes
    );

NTSTATUS
ChanMgrGetChannelByName(
    IN  PCWSTR              Name,
    OUT PSAC_CHANNEL*       pChannel
    );

NTSTATUS
ChanMgrGetByIndex(
    IN  ULONG               TargetIndex,
    OUT PSAC_CHANNEL*       TargetChannel
    );

NTSTATUS
ChanMgrGetNextActiveChannel(
    IN  PSAC_CHANNEL        CurrentChannel,
    OUT PULONG              TargetIndex,
    OUT PSAC_CHANNEL*       TargetChannel
    );

NTSTATUS
ChanMgrReleaseChannel(
    IN PSAC_CHANNEL Channel
    );

NTSTATUS
ChanMgrAddChannel(
    PSAC_CHANNEL    Channel
    );

NTSTATUS
ChanMgrRemoveChannel(
    PSAC_CHANNEL    Channel
    );

NTSTATUS
ChanMgrGetByHandle(
    IN  SAC_CHANNEL_HANDLE  ChannelHandle,
    OUT PSAC_CHANNEL*       TargetChannel
    );

NTSTATUS
ChanMgrGetByHandleAndFileObject(
    IN  SAC_CHANNEL_HANDLE  TargetChannelHandle,
    IN  PFILE_OBJECT        FileObject,
    OUT PSAC_CHANNEL*       TargetChannel
    );

VOID
ChanMgrSetChannel(
    IN PSAC_CHANNEL Channel,
    IN BOOLEAN SendToScreen
    );

NTSTATUS
ChanMgrAdvanceCurrentChannel(
    VOID
    );

NTSTATUS
ChanMgrDisplayCurrentChannel(
    VOID
    );

NTSTATUS
ChanMgrGetChannelIndex(
    IN  PSAC_CHANNEL    Channel,
    OUT PULONG          ChannelIndex
    );

NTSTATUS
ChanMgrCloseChannelsWithFileObject(
    IN  PFILE_OBJECT    FileObject
    );

NTSTATUS
ChanMgrCloseChannel(
    IN PSAC_CHANNEL Channel
    );

NTSTATUS
ChanMgrGetChannelCount(
    OUT PULONG  ChannelCount
    );

NTSTATUS
ChanMgrIsFull(
    OUT PBOOLEAN    bStatus
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\cmdchan.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    cmdchan.h

Abstract:

    Routines for managing Cmd channels.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#ifndef CMD_CHAN_H
#define CMD_CHAN_H

//
// The size of the I/O Buffers for cmd channels
//
#define SAC_CMD_IBUFFER_SIZE ((MEMORY_INCREMENT*2) / sizeof(UCHAR))

//
// prototypes
//
NTSTATUS
CmdChannelCreate(
    IN OUT PSAC_CHANNEL     Channel
    );

NTSTATUS
CmdChannelDestroy(
    IN OUT PSAC_CHANNEL     Channel
    );

NTSTATUS
CmdChannelOEcho(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
CmdChannelOWrite(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );


NTSTATUS
CmdChannelOFlush(
    IN PSAC_CHANNEL Channel
    );

NTSTATUS
CmdChannelORead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\channel.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    channel.h

Abstract:

    Common Channel routines.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#ifndef CHANNEL_H
#define CHANNEL_H

//
// The maximum buffer size an EMS app may write to it's channel
//
#define CHANNEL_MAX_OWRITE_BUFFER_SIZE  0x8000

//
// Channel function types
//

struct _SAC_CHANNEL;

typedef NTSTATUS 
(*CHANNEL_FUNC_CREATE)(
    IN struct _SAC_CHANNEL* Channel
    );

typedef NTSTATUS 
(*CHANNEL_FUNC_DESTROY)(
    IN struct _SAC_CHANNEL* Channel
    );

typedef NTSTATUS
(*CHANNEL_FUNC_OFLUSH)(
    IN struct _SAC_CHANNEL* Channel
    );

typedef NTSTATUS 
(*CHANNEL_FUNC_OECHO)(
    IN struct _SAC_CHANNEL* Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

typedef NTSTATUS 
(*CHANNEL_FUNC_OWRITE)(
    IN struct _SAC_CHANNEL* Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

typedef NTSTATUS 
(*CHANNEL_FUNC_OREAD)(
    IN struct _SAC_CHANNEL* Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount
    );

typedef NTSTATUS 
(*CHANNEL_FUNC_IWRITE)(
    IN struct _SAC_CHANNEL* Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

typedef NTSTATUS 
(*CHANNEL_FUNC_IREAD)(
    IN struct _SAC_CHANNEL* Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount   
    );

typedef WCHAR
(*CHANNEL_FUNC_IREADLAST)(
    IN struct _SAC_CHANNEL* Channel
    );

typedef NTSTATUS
(*CHANNEL_FUNC_IBUFFERISFULL)(
    IN struct _SAC_CHANNEL* Channel,
    OUT BOOLEAN*            BufferStatus
    );

typedef ULONG
(*CHANNEL_FUNC_IBUFFERLENGTH)(
    IN struct _SAC_CHANNEL* Channel
    );

//
// This struct is all the information necessary to maintian a single channel.
//
typedef struct _SAC_CHANNEL { 

    /////////////////////////////////////////
    // BEGIN: ATTRIBUTES SET UPON CREATION
    /////////////////////////////////////////

    //
    // Index of the channel in the channel manager's channel array
    //
    ULONG               Index;

    //
    // Handle for use by Channel applications
    //
    SAC_CHANNEL_HANDLE  Handle;
    
    //
    // Events specified by the channel application
    //
    HANDLE              CloseEvent;
    PVOID               CloseEventObjectBody;
    PVOID               CloseEventWaitObjectBody;
    
    HANDLE              HasNewDataEvent;
    PVOID               HasNewDataEventObjectBody;
    PVOID               HasNewDataEventWaitObjectBody;
    
#if ENABLE_CHANNEL_LOCKING
    HANDLE              LockEvent;
    PVOID               LockEventObjectBody;
    PVOID               LockEventWaitObjectBody;
#endif

    HANDLE              RedrawEvent;
    PVOID               RedrawEventObjectBody;
    PVOID               RedrawEventWaitObjectBody;
    
    /////////////////////////////////////////
    // END: ATTRIBUTES SET UPON CREATION
    /////////////////////////////////////////
    
    /////////////////////////////////////////
    // BEGIN: REQUIRES CHANNEL_ACCESS_ATTRIBUTES
    /////////////////////////////////////////

    //
    // General channel attributes
    //

    //
    // The pointer to the file object used to reference
    // the SAC driver for the process that created
    // the channel.  We use this file object to make
    // sure no other process operates on a channel they
    // didnt create.
    //
    PFILE_OBJECT        FileObject;

    //
    // Channel Type
    //
    //  Determines the channel implementation 
    //
    SAC_CHANNEL_TYPE    Type;

    //
    // Channel Status (Active/Inactive)
    //
    //  Active - the channel may send/receive data
    //  Inactive - channel may not receive data
    //             if the preserve flag is set, the channel
    //                will not be reaped until the data is sent
    //             otherwise the channel is reapable
    //
    SAC_CHANNEL_STATUS  Status;
    
    //
    // Channel Name
    //
    WCHAR               Name[SAC_MAX_CHANNEL_NAME_LENGTH+1];
    
    //
    // Channel Description
    //
    WCHAR               Description[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH+1];
    
    //
    // Channel behavior attribute flags 
    //
    //  Example:
    //  
    //  SAC_CHANNEL_FLAG_PRESERVE - don't reap the channel until the data
    //                              in the obuffer has been sent
    //
    SAC_CHANNEL_FLAG    Flags;
    
    //
    // Channel Attribute type
    //
    //  Application determined identifier that is used primarily
    //  by the remote management app to determine how to handle
    //  the channel data
    //
    GUID                ApplicationType;

    //
    // Status of OBuffer
    //
    // TRUE when the OBuffer has been flushed
    // Otherwise FALSE
    //
    // This is primarily intended for use with an IOMGR like the console
    // manager.  For instance, this flag gets set to FALSE when we 
    // fast-channel-switch to another channel, and set to TRUE when we
    // select a channel and flush it's contents to the current channel.
    //
    // Note: we use ULONG for this so we can use InterlockedExchange
    //
    ULONG               SentToScreen;
    
    /////////////////////////////////////////
    // END: REQUIRES CHANNEL_ACCESS_ATTRIBUTES
    /////////////////////////////////////////
    
    /////////////////////////////////////////
    // BEGIN: REQUIRES CHANNEL_ACCESS_IBUFFER
    /////////////////////////////////////////
    
    //
    // Common Input Buffer
    //
    ULONG   IBufferIndex;
    PUCHAR  IBuffer;
    ULONG   IBufferHasNewData;

    /////////////////////////////////////////
    // END: REQUIRES CHANNEL_ACCESS_IBUFFER
    /////////////////////////////////////////

    /////////////////////////////////////////
    // BEGIN: REQUIRES CHANNEL_ACCESS_OBUFFER
    /////////////////////////////////////////

    //
    // VTUTF8 Channel Screen details
    //
    UCHAR CursorRow;
    UCHAR CursorCol;
    UCHAR CurrentFg;
    UCHAR CurrentBg;
    UCHAR CurrentAttr;

    //
    // Output Buffer 
    PVOID   OBuffer;
    
    //
    // OBuffer management vars for RawChannels
    //
    ULONG   OBufferIndex;
    ULONG   OBufferFirstGoodIndex;
    
    //
    // This gets set when new data is inserted into OBuffer
    //
    ULONG   OBufferHasNewData;

    /////////////////////////////////////////
    // END: REQUIRES CHANNEL_ACCESS_OBUFFER
    /////////////////////////////////////////
    
    //
    // Channel Function VTABLE
    //
    CHANNEL_FUNC_CREATE     Create;
    CHANNEL_FUNC_DESTROY    Destroy;
    
    CHANNEL_FUNC_OFLUSH     OFlush;
    CHANNEL_FUNC_OECHO      OEcho;
    CHANNEL_FUNC_OWRITE     OWrite;
    CHANNEL_FUNC_OREAD      ORead;
    
    CHANNEL_FUNC_IWRITE         IWrite;
    CHANNEL_FUNC_IREAD          IRead;
    CHANNEL_FUNC_IREADLAST      IReadLast;
    CHANNEL_FUNC_IBUFFERISFULL  IBufferIsFull;
    CHANNEL_FUNC_IBUFFERLENGTH  IBufferLength;

    //
    // Channel access locks
    //
    SAC_LOCK    ChannelAttributeLock;
    SAC_LOCK    ChannelOBufferLock;
    SAC_LOCK    ChannelIBufferLock;

} SAC_CHANNEL, *PSAC_CHANNEL;

//
// Macros for managing channel locks
//
#define INIT_CHANNEL_LOCKS(_Channel)                    \
    INITIALIZE_LOCK(_Channel->ChannelAttributeLock);    \
    INITIALIZE_LOCK(_Channel->ChannelOBufferLock);      \
    INITIALIZE_LOCK(_Channel->ChannelIBufferLock);    

#define ASSERT_CHANNEL_LOCKS_SIGNALED(_Channel) \
    ASSERT(LOCK_IS_SIGNALED(_Channel->ChannelAttributeLock));           \
    ASSERT(LOCK_HAS_ZERO_REF_COUNT(_Channel->ChannelAttributeLock));    \
    ASSERT(LOCK_IS_SIGNALED(_Channel->ChannelOBufferLock));             \
    ASSERT(LOCK_HAS_ZERO_REF_COUNT(_Channel->ChannelOBufferLock));      \
    ASSERT(LOCK_IS_SIGNALED(_Channel->ChannelIBufferLock));             \
    ASSERT(LOCK_HAS_ZERO_REF_COUNT(_Channel->ChannelIBufferLock));

#define LOCK_CHANNEL_ATTRIBUTES(_Channel)    \
    ACQUIRE_LOCK(_Channel->ChannelAttributeLock)
#define UNLOCK_CHANNEL_ATTRIBUTES(_Channel)  \
    RELEASE_LOCK(_Channel->ChannelAttributeLock)

#define LOCK_CHANNEL_OBUFFER(_Channel)    \
    ACQUIRE_LOCK(_Channel->ChannelOBufferLock)
#define UNLOCK_CHANNEL_OBUFFER(_Channel)  \
    RELEASE_LOCK(_Channel->ChannelOBufferLock)

#define LOCK_CHANNEL_IBUFFER(_Channel)    \
    ACQUIRE_LOCK(_Channel->ChannelIBufferLock)
#define UNLOCK_CHANNEL_IBUFFER(_Channel)  \
    RELEASE_LOCK(_Channel->ChannelIBufferLock)

//
// Macros for get/set operations on most of the channel's attributes
// 
// Note: If the operation can be done use InterlockedXXX, 
//       then it should be done here.
//
#define ChannelGetHandle(_Channel)                  (_Channel->Handle)

#define ChannelGetType(_Channel)                    (_Channel->Type)
#define ChannelSetType(_Channel, _v)                (InterlockedExchange((volatile long *)&(_Channel->Status), _v))

#define ChannelSentToScreen(_Channel)               ((BOOLEAN)_Channel->SentToScreen)
#define ChannelSetSentToScreen(_Channel, _f)        (InterlockedExchange((volatile long *)&(_Channel->SentToScreen), _f))

#define ChannelHasNewOBufferData(_Channel)          ((BOOLEAN)_Channel->OBufferHasNewData)
#define ChannelSetOBufferHasNewData(_Channel, _f)   (InterlockedExchange((volatile long *)&(_Channel->OBufferHasNewData), _f))

#define ChannelHasNewIBufferData(_Channel)          ((BOOLEAN)_Channel->IBufferHasNewData)
#define ChannelSetIBufferHasNewData(_Channel, _f)   (InterlockedExchange((volatile long *)&(_Channel->IBufferHasNewData), _f))

#define ChannelGetFlags(_Channel)                   (_Channel->Flags)
#define ChannelSetFlags(_Channel, _f)               (InterlockedExchange((volatile long *)&(_Channel->Flags), _f))

#define ChannelGetIndex(_Channel)                   (_Channel->Index)
#define ChannelSetIndex(_Channel, _v)               (InterlockedExchange((volatile long *)&(_Channel->Index), _v))

#define ChannelGetFileObject(_Channel)              (_Channel->FileObject)
#define ChannelSetFileObject(_Channel, _v)          (InterlockedExchangePointer(&(_Channel->FileObject), _v))

#if ENABLE_CHANNEL_LOCKING
#define ChannelHasLockEvent(_Channel)               (_Channel->LockEvent ? TRUE : FALSE)
#endif

//
// Prototypes
//
BOOLEAN
ChannelIsValidType(
    SAC_CHANNEL_TYPE    ChannelType
    );

BOOLEAN
ChannelIsActive(
    IN PSAC_CHANNEL Channel
    );

BOOLEAN
ChannelIsEqual(
    IN PSAC_CHANNEL         Channel,
    IN PSAC_CHANNEL_HANDLE  ChannelHandle
    );

BOOLEAN
ChannelIsClosed(
    IN PSAC_CHANNEL Channel
    );

NTSTATUS
ChannelCreate(
    OUT PSAC_CHANNEL                    Channel,
    IN  PSAC_CHANNEL_OPEN_ATTRIBUTES    Attributes,
    IN  SAC_CHANNEL_HANDLE              ChannelHandle
    );

NTSTATUS
ChannelClose(
    PSAC_CHANNEL    Channel
    );


NTSTATUS
ChannelDestroy(
    IN  PSAC_CHANNEL    Channel
    );


WCHAR
ChannelIReadLast(
    IN PSAC_CHANNEL Channel
    );

NTSTATUS
ChannelInitializeVTable(
    IN PSAC_CHANNEL Channel
    );

NTSTATUS 
ChannelOWrite(    
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
ChannelOFlush(
    IN PSAC_CHANNEL Channel
    );

NTSTATUS 
ChannelOEcho(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS 
ChannelORead(
    IN PSAC_CHANNEL  Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount
    );

NTSTATUS 
ChannelIWrite(    
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );
    
NTSTATUS 
ChannelIRead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount   
    );

WCHAR
ChannelIReadLast(    
    IN PSAC_CHANNEL Channel
    );

NTSTATUS
ChannelIBufferIsFull(
    IN  PSAC_CHANNEL Channel,
    OUT BOOLEAN*     BufferStatus
    );

ULONG
ChannelIBufferLength(
    IN  PSAC_CHANNEL Channel
    );

NTSTATUS
ChannelGetName(
    IN  PSAC_CHANNEL Channel,
    OUT PWSTR*       Name
    );

NTSTATUS
ChannelSetName(
    IN PSAC_CHANNEL Channel,
    IN PCWSTR       Name
    );

NTSTATUS
ChannelGetDescription(
    IN  PSAC_CHANNEL Channel,
    OUT PWSTR*       Name
    );

NTSTATUS
ChannelSetDescription(
    IN PSAC_CHANNEL Channel,
    IN PCWSTR       Name
    );

NTSTATUS
ChannelSetStatus(
    IN PSAC_CHANNEL         Channel,
    IN SAC_CHANNEL_STATUS   Status
    );

NTSTATUS
ChannelGetStatus(
    IN  PSAC_CHANNEL         Channel,
    OUT SAC_CHANNEL_STATUS*  Status
    );

NTSTATUS
ChannelSetApplicationType(
    IN PSAC_CHANNEL Channel,
    IN GUID         ApplicationType
    );

NTSTATUS
ChannelGetApplicationType(
    IN PSAC_CHANNEL Channel,
    IN GUID*        ApplicationType
    );

#if ENABLE_CHANNEL_LOCKING
NTSTATUS
ChannelSetLockEvent(
    IN  PSAC_CHANNEL Channel
    );
#endif

NTSTATUS
ChannelSetRedrawEvent(
    IN  PSAC_CHANNEL Channel
    );

NTSTATUS
ChannelClearRedrawEvent(
    IN  PSAC_CHANNEL Channel
    );

NTSTATUS
ChannelHasRedrawEvent(
    IN  PSAC_CHANNEL Channel,
    OUT PBOOLEAN     Present
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\cmdchan.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    cmdchan.c

Abstract:

    Routines for managing channels in the sac.

Author:

    Sean Selitrennikoff (v-seans) Sept, 2000.
    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#include "sac.h"

NTSTATUS
CmdChannelCreate(
    IN OUT PSAC_CHANNEL     Channel
    )
/*++

Routine Description:

    This routine allocates a channel and returns a pointer to it.
    
Arguments:

    Channel         - The resulting channel.
    
    OpenChannelCmd  - All the parameters for the new channel
    
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);
    
    Channel->IBuffer = (PUCHAR)ALLOCATE_POOL(SAC_CMD_IBUFFER_SIZE, GENERAL_POOL_TAG);
    ASSERT_STATUS(Channel->IBuffer, STATUS_NO_MEMORY);
    
    ChannelSetIBufferHasNewData(Channel, FALSE);

    return STATUS_SUCCESS;
}

NTSTATUS
CmdChannelDestroy(
    IN OUT PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine closes a channel.
    
Arguments:

    Channel - The channel to be closed
    
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    //
    // Free the dynamically allocated memory
    //

    if (Channel->IBuffer) {
        FREE_POOL(&(Channel->IBuffer));
        Channel->IBuffer = NULL;
    }
    
    //
    // Now that we've done our channel specific destroy, 
    // Call the general channel destroy
    //
    Status = ChannelDestroy(Channel);

    return Status;
}


NTSTATUS
CmdChannelOWrite(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      String,
    IN ULONG        Size
    )
/*++

Routine Description:

    This routine takes a string and prints it to the specified channel.  If the channel
    is the currently active channel, it puts the string out the headless port as well.
    
    Note: Current Channel lock must be held by caller            

Arguments:

    Channel - Previously created channel.
    String  - Output string.
    Length  - The # of String bytes to process
    
Return Value:

    STATUS_SUCCESS if successful, otherwise status

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(String, STATUS_INVALID_PARAMETER_2);
    ASSERT_STATUS(Size > 0, STATUS_INVALID_PARAMETER_3);
    
    ASSERT(FIELD_OFFSET(HEADLESS_CMD_PUT_STRING, String) == 0);  // ASSERT if anyone changes this structure.
    
    //
    // default: we succeeded
    //
    Status = STATUS_SUCCESS;

    //
    // if the current channel is the active channel and the user has selected
    // to display this channel, relay the output directly to the user
    //
    if (IoMgrIsWriteEnabled(Channel) && ChannelSentToScreen(Channel)){

        Status = Channel->OEcho(
            Channel, 
            String,
            Size
            );

    } 

    return Status;
}

NTSTATUS
CmdChannelOFlush(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

     Send all the data in the cmd buffer since the channel was last active
     (or since the channel was created)
    
Arguments:

    Channel - Previously created channel.
    
Return Value:

    STATUS_SUCCESS if successful, otherwise status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    
    return STATUS_SUCCESS;
}

NTSTATUS
CmdChannelORead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount
    )
/*++

Routine Description:

    This routine attempts to read BufferSize characters from the output buffer.  
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - Outgoing buffer   
    BufferSize  - Outgoing buffer size
    ByteCount   - The number of bytes actually read
    
    
    Note: if the buffered data stored in the channel has now been sent.
          If Channel is also in the Inactive state, the channel will
          now be qualified for removal.
    
Return Value:

    Status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(Buffer,  STATUS_INVALID_PARAMETER_2);
    ASSERT_STATUS(BufferSize > 0,  STATUS_INVALID_PARAMETER_3);
    ASSERT_STATUS(ByteCount,  STATUS_INVALID_PARAMETER_4);
    
    //
    // don't return anything
    //
    *ByteCount = 0;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\concmd.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    conmgr.h

Abstract:

    Routines for managing channels.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#ifndef CON_CMD_H
#define CON_CMD_H

VOID
DoHelpCommand(
    VOID
    );

VOID
DoKillCommand(
    PUCHAR InputLine
    );

VOID
DoLowerPriorityCommand(
    PUCHAR InputLine
    );

VOID
DoRaisePriorityCommand(
    PUCHAR InputLine
    );

VOID
DoLimitMemoryCommand(
    PUCHAR InputLine
    );

VOID
DoSetTimeCommand(
    PUCHAR InputLine
    );

VOID
DoSetIpAddressCommand(
    PUCHAR InputLine
    );

VOID
DoRebootCommand(
    BOOLEAN Reboot
    );

VOID
DoCrashCommand(
    VOID
    );

VOID
DoFullInfoCommand(
    VOID
    );

VOID
DoPagingCommand(
    VOID
    );

VOID
DoTlistCommand(
    VOID
    );

VOID
SubmitIPIoRequest(
    );

VOID
CancelIPIoRequest(
    );

VOID
DoMachineInformationCommand(
    VOID
    );

VOID
DoChannelCommand(
    IN PUCHAR Name
    );

VOID
DoCmdCommand(
    IN PUCHAR Name
    );

VOID
DoKernelLogCommand(
    VOID
    );

#if ENABLE_CHANNEL_LOCKING
VOID
DoLockCommand(
    VOID
    );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\channel.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    channel.c

Abstract:

    Routines for managing channels in the sac.

Author:

    Brian Guarraci (briangu) March, 2001.
    Sean Selitrennikoff (v-seans) Sept, 2000.

Revision History:

--*/

#include "sac.h"

BOOLEAN
ChannelIsValidType(
    SAC_CHANNEL_TYPE    ChannelType
    )
/*++

Routine Description:

    This is a convenience routine to determine if a the given type
    is a valid Channel type
    
Arguments:

    ChannelType - the type to be investigated

Return Value:

    TRUE    - if type is valid
    
    otherwise, FALSE

--*/
{
    BOOLEAN     isValid;

    switch(ChannelType) {
    case ChannelTypeVTUTF8:
    case ChannelTypeRaw:
    case ChannelTypeCmd:
        isValid = TRUE;
        break;
    default:
        isValid = FALSE;
        break;
    }

    return isValid;

}
        
BOOLEAN
ChannelIsActive(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    Determine if a channel is active.
      
Arguments:

    Channel - Channel to see if has new data                
                        
Return Value:

    TRUE    - if the channel is active
    
    otherwise, FALSE

--*/
{
    SAC_CHANNEL_STATUS  Status;

    ChannelGetStatus(
        Channel, 
        &Status
        );

    return (BOOLEAN)(Status == ChannelStatusActive);
}

BOOLEAN
ChannelIsEqual(
    IN PSAC_CHANNEL         Channel,
    IN PSAC_CHANNEL_HANDLE  Handle
    )
/*++

Routine Description:

    Determine if a channel is the same as the one in question

    Note: this is to encapsulate the GUID implementation of 
          channel handles
      
Arguments:

    Channel         - Channel to see if has new data                
    ChannelHandle   - The channel handle in question
                        
Return Value:

    TRUE    - if the channel is active
    
    otherwise, FALSE

--*/
{

    return (BOOLEAN)IsEqualGUID(
        &(ChannelGetHandle(Channel).ChannelHandle),
        &(Handle->ChannelHandle)
        );

}


BOOLEAN
ChannelIsClosed(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    Determine if a channel is available for reuse.  The criterion
    for reuse are:
    
    1. The channel must be inactive
    2. If the preserve bit is FALSE, then HasNewData must == FALSE
      
Arguments:

    Channel - Channel to see if has new data                
                        
Return Value:

    TRUE    - if the channel has unsent data
    
    otherwise, FALSE

--*/
{
    SAC_CHANNEL_STATUS  Status;

    ChannelGetStatus(
        Channel, 
        &Status
        );

    return (BOOLEAN)(
        (Status == ChannelStatusInactive) &&
        (ChannelHasNewOBufferData(Channel) == FALSE)
        );

}

NTSTATUS
ChannelInitializeVTable(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This routine assigns channel type specific functions.
    
Arguments:

    Channel         - The channel to assign the functions to.
    
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    
    //
    // Fill out the channel's vtable according to channel type
    //

    switch(ChannelGetType(Channel)){
    case ChannelTypeVTUTF8:
        
        Channel->Create         = VTUTF8ChannelCreate;
        Channel->Destroy        = VTUTF8ChannelDestroy;
        Channel->OFlush         = VTUTF8ChannelOFlush;
        Channel->OEcho          = VTUTF8ChannelOEcho;
        Channel->OWrite         = VTUTF8ChannelOWrite;
        Channel->ORead          = VTUTF8ChannelORead;
        Channel->IWrite         = VTUTF8ChannelIWrite;
        Channel->IRead          = VTUTF8ChannelIRead;
        Channel->IReadLast      = VTUTF8ChannelIReadLast;
        Channel->IBufferIsFull  = VTUTF8ChannelIBufferIsFull;
        Channel->IBufferLength  = VTUTF8ChannelIBufferLength;

        break;
    case ChannelTypeRaw:
        
        Channel->Create         = RawChannelCreate;
        Channel->Destroy        = RawChannelDestroy;
        Channel->OFlush         = RawChannelOFlush;
        Channel->OEcho          = RawChannelOEcho;
        Channel->OWrite         = RawChannelOWrite;
        Channel->ORead          = RawChannelORead;
        Channel->IWrite         = RawChannelIWrite;
        Channel->IRead          = RawChannelIRead;
        Channel->IReadLast      = RawChannelIReadLast;
        Channel->IBufferIsFull  = RawChannelIBufferIsFull;
        Channel->IBufferLength  = RawChannelIBufferLength;
        
        break;
    
    case ChannelTypeCmd:

        Channel->Create         = CmdChannelCreate;
        Channel->Destroy        = CmdChannelDestroy;
        Channel->OFlush         = CmdChannelOFlush;
        Channel->OEcho          = VTUTF8ChannelOEcho;
        Channel->OWrite         = CmdChannelOWrite;
        Channel->ORead          = CmdChannelORead;
        Channel->IWrite         = VTUTF8ChannelIWrite;
        Channel->IRead          = VTUTF8ChannelIRead;
        Channel->IReadLast      = VTUTF8ChannelIReadLast;
        Channel->IBufferIsFull  = VTUTF8ChannelIBufferIsFull;
        Channel->IBufferLength  = VTUTF8ChannelIBufferLength;
    
        break;
    
    default:

        return STATUS_INVALID_PARAMETER;

        break;
    }

    return STATUS_SUCCESS;

}

NTSTATUS
ChannelCreate(
    OUT PSAC_CHANNEL                    Channel,
    IN  PSAC_CHANNEL_OPEN_ATTRIBUTES    Attributes,
    IN  SAC_CHANNEL_HANDLE              Handle
    )
/*++

Routine Description:

    This routine allocates a channel and returns a pointer to it.
    
Arguments:

    Channel     - The resulting channel.
    Attributes  - All the parameters for the new channel
    Handle      - The new channel's handle
    
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    NTSTATUS    Status;
    BOOLEAN     b;
    PVOID       EventObjectBody;
    PVOID       EventWaitObjectBody;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(Attributes, STATUS_INVALID_PARAMETER_2);

    //
    // Verify that if the user wants to use the CLOSE_EVENT, we received on to use
    //
    if (Attributes->Flags & SAC_CHANNEL_FLAG_CLOSE_EVENT) {
        ASSERT_STATUS(Attributes->CloseEvent != NULL, STATUS_INVALID_PARAMETER);
    } else {
        ASSERT_STATUS(Attributes->CloseEvent == NULL, STATUS_INVALID_PARAMETER);
    }
    
    //
    // Verify that if the user wants to use the HAS_NEW_DATA_EVENT, we received one to use
    //
    if (Attributes->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) {
        ASSERT_STATUS(Attributes->HasNewDataEvent != NULL, STATUS_INVALID_PARAMETER);
    } else {
        ASSERT_STATUS(Attributes->HasNewDataEvent == NULL, STATUS_INVALID_PARAMETER);
    }

#if ENABLE_CHANNEL_LOCKING
    //
    // Verify that if the user wants to use the LOCK_EVENT, we received one to use
    //
    if (Attributes->Flags & SAC_CHANNEL_FLAG_LOCK_EVENT) {
        ASSERT_STATUS(Attributes->LockEvent != NULL, STATUS_INVALID_PARAMETER);
    } else {
        ASSERT_STATUS(Attributes->LockEvent == NULL, STATUS_INVALID_PARAMETER);
    }
#endif

    //
    // Verify that if the user wants to use the LOCK_EVENT, we received one to use
    //
    if (Attributes->Flags & SAC_CHANNEL_FLAG_REDRAW_EVENT) {
        ASSERT_STATUS(Attributes->RedrawEvent != NULL, STATUS_INVALID_PARAMETER);
    } else {
        ASSERT_STATUS(Attributes->RedrawEvent == NULL, STATUS_INVALID_PARAMETER);
    }
    
    //
    // Initialize the channel structure
    //
    do {

        //
        // Initialize the channel structure
        // 
        RtlZeroMemory(Channel, sizeof(SAC_CHANNEL));

        //
        // Initialize the channel access locks
        //
        INIT_CHANNEL_LOCKS(Channel);

        //
        // copy the name and force NULL termination at the end of the buffer
        //
        ChannelSetName(
            Channel,
            Attributes->Name
            );

        //
        // copy the description and force NULL termination at the end of the buffer
        // 
        ChannelSetDescription(
            Channel,
            Attributes->Description
            );

        //
        // Attempt to get the wait object from the event
        //
        if (Attributes->CloseEvent) {
            
            b = VerifyEventWaitable(
                Attributes->CloseEvent,
                &EventObjectBody,
                &EventWaitObjectBody
                );

            if(!b) {
                Status = STATUS_INVALID_HANDLE;
                break;
            }

            //
            // We successfully got the wait object, so keep it.
            //
            Channel->CloseEvent                 = Attributes->CloseEvent;
            Channel->CloseEventObjectBody       = EventObjectBody;
            Channel->CloseEventWaitObjectBody   = EventWaitObjectBody;

        }
        
        //
        // Attempt to get the wait object from the event
        //
        if (Attributes->HasNewDataEvent) {

            b = VerifyEventWaitable(
                Attributes->HasNewDataEvent,
                &EventObjectBody,
                &EventWaitObjectBody
                );

            if(!b) {
                Status = STATUS_INVALID_HANDLE;
                break;
            }

            //
            // We successfully got the wait object, so keep it.
            //
            Channel->HasNewDataEvent                = Attributes->HasNewDataEvent;
            Channel->HasNewDataEventObjectBody      = EventObjectBody;
            Channel->HasNewDataEventWaitObjectBody  = EventWaitObjectBody;

        }
        
#if ENABLE_CHANNEL_LOCKING
        //
        // Attempt to get the wait object from the event
        //
        if (Attributes->LockEvent) {
            
            b = VerifyEventWaitable(
                Attributes->LockEvent,
                &EventObjectBody,
                &EventWaitObjectBody
                );

            if(!b) {
                Status = STATUS_INVALID_HANDLE;
                break;
            }

            //
            // We successfully got the wait object, so keep it.
            //
            Channel->LockEvent                 = Attributes->LockEvent;
            Channel->LockEventObjectBody       = EventObjectBody;
            Channel->LockEventWaitObjectBody   = EventWaitObjectBody;

        }
#endif
        
        //
        // Attempt to get the wait object from the event
        //
        if (Attributes->RedrawEvent) {
            
            b = VerifyEventWaitable(
                Attributes->RedrawEvent,
                &EventObjectBody,
                &EventWaitObjectBody
                );

            if(!b) {
                Status = STATUS_INVALID_HANDLE;
                break;
            }

            //
            // We successfully got the wait object, so keep it.
            //
            Channel->RedrawEvent                 = Attributes->RedrawEvent;
            Channel->RedrawEventObjectBody       = EventObjectBody;
            Channel->RedrawEventWaitObjectBody   = EventWaitObjectBody;

        }
        
        //
        // Copy the remaining attributes
        //
        // Note: use the channel handle sent to use by the channel manager
        //
        Channel->Handle             = Handle;
        Channel->Type               = Attributes->Type;
        Channel->Flags              = Attributes->Flags;
        
        //
        // If we have the ApplicationType, 
        // then save it
        //
        if (Attributes->Flags & SAC_CHANNEL_FLAG_APPLICATION_TYPE) {
            Channel->ApplicationType = Attributes->ApplicationType;
        }

        //
        // Assign the appropriate channel functions base on type
        //
        Status = ChannelInitializeVTable(Channel);
        
        if (! NT_SUCCESS(Status)) {
            
            IF_SAC_DEBUG( 
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC Create Channel :: Failed to initialize vtable\n"))
                );
            
            break;
        
        }

        //
        // Do Channel type specific initialization
        //
        Status = Channel->Create(Channel);
        
        if (! NT_SUCCESS(Status)) {
            
            IF_SAC_DEBUG( 
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC Create Channel :: Failed channel specific initialization\n"))
                );
            
            break;
        
        }

        //
        // The channel is now Active
        //
        ChannelSetStatus(Channel, ChannelStatusActive);
    
    } while (FALSE);

    //
    // If the creation failed, destroy the channel object
    //
    if (! NT_SUCCESS(Status)) {
        Channel->Destroy(Channel);
    }

    return Status;
}

NTSTATUS
ChannelDereferenceHandles(
    PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine dereferences and NULLs the channel's event handles,
    if appropriate.

    Note: caller must hold channel mutex
    
Arguments:

    Channel   - the channel to close

Return Value:

    STATUS_SUCCESS      - if the mapping was successful
    
    otherwise, error status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    //
    // Release the has new data event if we have it
    //
    if (Channel->HasNewDataEvent) {
        
        //
        // validate that the channel's attributes for this event
        // are properly set
        //
        ASSERT(ChannelGetFlags(Channel) & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT);
        ASSERT(Channel->HasNewDataEventObjectBody);
        ASSERT(Channel->HasNewDataEventWaitObjectBody);

        if (Channel->HasNewDataEventObjectBody) {
            
            ObDereferenceObject(Channel->HasNewDataEventObjectBody);

            //
            // NULL the event pointers
            //
            ChannelSetFlags(
                Channel, 
                ChannelGetFlags(Channel) & ~SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT
                );
            Channel->HasNewDataEvent = NULL;
            Channel->HasNewDataEventObjectBody =  NULL;
            Channel->HasNewDataEventWaitObjectBody = NULL;
        
        }

    }

    //
    // do we have the Close Channel Event?
    //
    if (Channel->CloseEvent) {

        //
        // validate that the channel's attributes for this event
        // are properly set
        //
        ASSERT(ChannelGetFlags(Channel) & SAC_CHANNEL_FLAG_CLOSE_EVENT);
        ASSERT(Channel->CloseEventObjectBody);
        ASSERT(Channel->CloseEventWaitObjectBody);

        if (Channel->CloseEventObjectBody) {
            
            //
            // release the events
            //
            ObDereferenceObject(Channel->CloseEventObjectBody);

            //
            // NULL the event pointers
            //
            ChannelSetFlags(
                Channel, 
                ChannelGetFlags(Channel) & ~SAC_CHANNEL_FLAG_CLOSE_EVENT
                );
            Channel->CloseEvent = NULL;
            Channel->CloseEventObjectBody =  NULL;
            Channel->CloseEventWaitObjectBody = NULL;
        
        }
    
    }
    
#if ENABLE_CHANNEL_LOCKING
    //
    // do we have the Lock Channel Event?
    //
    if (Channel->LockEvent) {

        //
        // validate that the channel's attributes for this event
        // are properly set
        //
        ASSERT(ChannelGetFlags(Channel) & SAC_CHANNEL_FLAG_LOCK_EVENT);
        ASSERT(Channel->LockEventObjectBody);
        ASSERT(Channel->LockEventWaitObjectBody);

        if (Channel->LockEventObjectBody) {
            
            //
            // release the events
            //
            ObDereferenceObject(Channel->LockEventObjectBody);

            //
            // NULL the event pointers
            //
            ChannelSetFlags(
                Channel, 
                ChannelGetFlags(Channel) & ~SAC_CHANNEL_FLAG_LOCK_EVENT
                );
            Channel->LockEvent = NULL;
            Channel->LockEventObjectBody =  NULL;
            Channel->LockEventWaitObjectBody = NULL;
        
        }
    
    }
#endif

    //
    // do we have the Redraw Channel Event?
    //
    if (Channel->RedrawEvent) {

        //
        // validate that the channel's attributes for this event
        // are properly set
        //
        ASSERT(ChannelGetFlags(Channel) & SAC_CHANNEL_FLAG_REDRAW_EVENT);
        ASSERT(Channel->RedrawEventObjectBody);
        ASSERT(Channel->RedrawEventWaitObjectBody);

        if (Channel->RedrawEventObjectBody) {
            
            //
            // release the events
            //
            ObDereferenceObject(Channel->RedrawEventObjectBody);

            //
            // NULL the event pointers
            //
            ChannelSetFlags(
                Channel, 
                ChannelGetFlags(Channel) & ~SAC_CHANNEL_FLAG_REDRAW_EVENT
                );
            Channel->RedrawEvent = NULL;
            Channel->RedrawEventObjectBody =  NULL;
            Channel->RedrawEventWaitObjectBody = NULL;
        
        }
    
    }
    
    return STATUS_SUCCESS;
}

NTSTATUS
ChannelClose(
    PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine closes the given channel and
    fires the CloseEvent if specified

    Note: caller must hold channel mutex
    
Arguments:

    Channel   - the channel to close

Return Value:

    STATUS_SUCCESS      - if the mapping was successful
    
    otherwise, error status

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    //
    // Set the channel's state to inactive
    //
    ChannelSetStatus(Channel, ChannelStatusInactive);
        
    //
    // do we need to fire the Close Channel Event?
    //
    if (ChannelGetFlags(Channel) & SAC_CHANNEL_FLAG_CLOSE_EVENT) {

        ASSERT(Channel->CloseEvent);
        ASSERT(Channel->CloseEventObjectBody);
        ASSERT(Channel->CloseEventWaitObjectBody);

        if (Channel->CloseEventWaitObjectBody) {
            
            //
            // Yes, fire the event
            //
            KeSetEvent(
                Channel->CloseEventWaitObjectBody,
                EVENT_INCREMENT,
                FALSE
                );
        
        }

    }
    
    //
    // Let go of any handles this channel may own
    //
    Status = ChannelDereferenceHandles(Channel);
    
    return Status;
}


NTSTATUS
ChannelDestroy(
    IN  PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine does the final steps of channel destruction.
    
Arguments:

    Channel - The channel to be closed
    
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    //
    // Let go of any handles this channel may own
    //
    Status = ChannelDereferenceHandles(Channel);

    return Status;
}

NTSTATUS 
ChannelOWrite(    
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    )
/*++

Routine Description:

    This is the common entry point for all channel owrite methods.
    The purpose of this entry point is to provide a uniform locking
    scheme for the obuffer.  Channel apps should not call the owrite method
    directly, but should use this instead.
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - The buffer to write
    BufferSize  - The size of the buffer to write
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    //
    // Make sure the caller isn't sending an unacceptably
    // large sized buffer.  This prevents an app from blocking
    // the console manager from being blocked while a channel
    // dumps it's buffer.
    //
    ASSERT_STATUS(
        BufferSize < CHANNEL_MAX_OWRITE_BUFFER_SIZE, 
        STATUS_INVALID_PARAMETER_3
        );

    LOCK_CHANNEL_OBUFFER(Channel);
    
    Status = Channel->OWrite(
        Channel,
        Buffer,
        BufferSize
        );
    
    UNLOCK_CHANNEL_OBUFFER(Channel);

    return Status;
}

NTSTATUS
ChannelOFlush(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This is the common entry point for all channel OFlush methods.
    The purpose of this entry point is to provide a uniform locking
    scheme for the obuffer.  Channel apps should not call the OFlush method
    directly, but should use this instead.
    
Arguments:

    Channel     - Previously created channel.
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    LOCK_CHANNEL_OBUFFER(Channel);
    
    Status = Channel->OFlush(Channel);
    
    UNLOCK_CHANNEL_OBUFFER(Channel);

    return Status;
}

NTSTATUS 
ChannelOEcho(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    )
/*++

Routine Description:

    This is the common entry point for all channel OEcho methods.
    The purpose of this entry point is to provide a uniform locking
    scheme for the obuffer.  Channel apps should not call the OEcho method
    directly, but should use this instead.
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - The buffer to write
    BufferSize  - The size of the buffer to write
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    LOCK_CHANNEL_OBUFFER(Channel);
    
    Status = Channel->OEcho(
        Channel,
        Buffer,
        BufferSize
        );
    
    UNLOCK_CHANNEL_OBUFFER(Channel);

    return Status;
}

NTSTATUS 
ChannelORead(
    IN PSAC_CHANNEL  Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount
    )
/*++

Routine Description:

    This is the common entry point for all channel ORead methods.
    The purpose of this entry point is to provide a uniform locking
    scheme for the obuffer.  Channel apps should not call the ORead method
    directly, but should use this instead.
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - The buffer to write
    BufferSize  - The size of the buffer to write
    ByteCount   - The number bytes read
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    LOCK_CHANNEL_OBUFFER(Channel);
    
    Status = Channel->ORead(
        Channel,
        Buffer,
        BufferSize,
        ByteCount
        );
    
    UNLOCK_CHANNEL_OBUFFER(Channel);

    return Status;
}

NTSTATUS 
ChannelIWrite(    
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    )
/*++

Routine Description:

    This is the common entry point for all channel iwrite methods.
    The purpose of this entry point is to provide a uniform locking
    scheme for the ibuffer.  Channel apps should not call the iwrite method
    directly, but should use this instead.
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - The buffer to write
    BufferSize  - The size of the buffer to write
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    LOCK_CHANNEL_IBUFFER(Channel);
    
    Status = Channel->IWrite(
        Channel,
        Buffer,
        BufferSize
        );
    
    UNLOCK_CHANNEL_IBUFFER(Channel);

    return Status;
}

NTSTATUS 
ChannelIRead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount   
    )
/*++

Routine Description:

    This is the common entry point for all channel iread methods.
    The purpose of this entry point is to provide a uniform locking
    scheme for the ibuffer.  Channel apps should not call the iread method
    directly, but should use this instead.
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - The buffer to read into
    BufferSize  - The size of the buffer 
    ByteCount   - The # of bytes read
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    LOCK_CHANNEL_IBUFFER(Channel);
    
    Status = Channel->IRead(
        Channel,
        Buffer,
        BufferSize,
        ByteCount
        );
    
    UNLOCK_CHANNEL_IBUFFER(Channel);

    return Status;
}

WCHAR
ChannelIReadLast(    
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This is the common entry point for all channel ireadlast methods.
    The purpose of this entry point is to provide a uniform locking
    scheme for the ibuffer.  Channel apps should not call the ireadlast method
    directly, but should use this instead.
    
Arguments:

    Channel     - Previously created channel.
    
Return Value:

    The last character, otherwise UNICODE_NULL

--*/
{
    WCHAR   wch;

    LOCK_CHANNEL_IBUFFER(Channel);
    
    wch = Channel->IReadLast(Channel);
    
    UNLOCK_CHANNEL_IBUFFER(Channel);

    return wch;
}

NTSTATUS
ChannelIBufferIsFull(
    IN  PSAC_CHANNEL Channel,
    OUT BOOLEAN*     BufferStatus
    )
/*++

Routine Description:

    This is the common entry point for all channel IBufferIsFull methods.
    The purpose of this entry point is to provide a uniform locking
    scheme for the ibuffer.  Channel apps should not call the IBufferIsFull method
    directly, but should use this instead.
    
Arguments:

    Channel         - Previously created channel.
    BufferStatus    - The query result
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    LOCK_CHANNEL_IBUFFER(Channel);
    
    Status = Channel->IBufferIsFull(
        Channel,
        BufferStatus
        );
    
    UNLOCK_CHANNEL_IBUFFER(Channel);

    return Status;
}

ULONG
ChannelIBufferLength(
    IN  PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This is the common entry point for all channel IBufferLength methods.
    The purpose of this entry point is to provide a uniform locking
    scheme for the ibuffer.  Channel apps should not call the IBufferLength method
    directly, but should use this instead.
    
Arguments:

    Channel     - Previously created channel.
    
Return Value:

    The last character, otherwise UNICODE_NULL

--*/
{
    ULONG   Length;

    LOCK_CHANNEL_IBUFFER(Channel);
    
    Length = Channel->IBufferLength(Channel);
    
    UNLOCK_CHANNEL_IBUFFER(Channel);

    return Length;
}

NTSTATUS
ChannelGetName(
    IN  PSAC_CHANNEL Channel,
    OUT PWSTR*       Name
    )
/*++

Routine Description:

    This routine retrieves the channel's description and stores it
    in a newly allocated buffer

    Note: the caller is responsible for releasing the memory holding
          the description
    
Arguments:

    Channel     - Previously created channel.
    Name        - the retrieved name
    
Return Value:

    Status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(Name, STATUS_INVALID_PARAMETER_2);

    *Name = ALLOCATE_POOL(SAC_MAX_CHANNEL_NAME_SIZE, GENERAL_POOL_TAG);
    ASSERT_STATUS(*Name, STATUS_NO_MEMORY);

    LOCK_CHANNEL_ATTRIBUTES(Channel);

    SAFE_WCSCPY(
        SAC_MAX_CHANNEL_NAME_SIZE,
        *Name,
        Channel->Name
        );

    UNLOCK_CHANNEL_ATTRIBUTES(Channel);
    
    return STATUS_SUCCESS;
}

NTSTATUS
ChannelSetName(
    IN PSAC_CHANNEL Channel,
    IN PCWSTR       Name
    )
/*++

Routine Description:

    This routine sets the channel's name.
    
Arguments:

    Channel     - Previously created channel.
    Name        - The new channel name
    
    Note: this routine does not check to see if the name is unique
    
Return Value:

    Status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(Name, STATUS_INVALID_PARAMETER_2);

    LOCK_CHANNEL_ATTRIBUTES(Channel);
    
    SAFE_WCSCPY(
        SAC_MAX_CHANNEL_NAME_SIZE,
        Channel->Name,
        Name
        );
    
    Channel->Name[SAC_MAX_CHANNEL_NAME_LENGTH] = UNICODE_NULL;

    UNLOCK_CHANNEL_ATTRIBUTES(Channel);

    return STATUS_SUCCESS;
}

NTSTATUS
ChannelGetDescription(
    IN  PSAC_CHANNEL Channel,
    OUT PWSTR*       Description
    )
/*++

Routine Description:

    This routine retrieves the channel's description and stores it
    in a newly allocated buffer

    Note: the caller is responsible for releasing the memory holding
          the description
    
Arguments:

    Channel     - Previously created channel.
    Description - the retrieved description
    
Return Value:

    Status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(Description, STATUS_INVALID_PARAMETER_2);

    *Description = ALLOCATE_POOL(SAC_MAX_CHANNEL_DESCRIPTION_SIZE, GENERAL_POOL_TAG);
    ASSERT_STATUS(*Description, STATUS_NO_MEMORY);

    LOCK_CHANNEL_ATTRIBUTES(Channel);
    
    SAFE_WCSCPY(
        SAC_MAX_CHANNEL_DESCRIPTION_SIZE,
        *Description,
        Channel->Description
        );
    
    UNLOCK_CHANNEL_ATTRIBUTES(Channel);

    return STATUS_SUCCESS;
}

NTSTATUS
ChannelSetDescription(
    IN PSAC_CHANNEL Channel,
    IN PCWSTR       Description
    )
/*++

Routine Description:

    This routine sets the channels description.
    
Arguments:

    Channel     - Previously created channel.
    Description - The new description
    
Return Value:

    Status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);

    LOCK_CHANNEL_ATTRIBUTES(Channel);
    
    if (Description != NULL) {
        
        SAFE_WCSCPY(
            SAC_MAX_CHANNEL_DESCRIPTION_SIZE,
            Channel->Description,
            Description
            );

        //
        // Force a null termination at the end of the description
        //
        Channel->Description[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH] = UNICODE_NULL;
    
    } else {
        
        //
        // make the description 0 length
        //
        Channel->Description[0] = UNICODE_NULL;
    
    }

    UNLOCK_CHANNEL_ATTRIBUTES(Channel);
    
    return STATUS_SUCCESS;
}

NTSTATUS
ChannelSetStatus(
    IN PSAC_CHANNEL         Channel,
    IN SAC_CHANNEL_STATUS   Status
    )
/*++

Routine Description:

    This routine sets the channels status.
    
Arguments:

    Channel     - Previously created channel.
    Status      - The channel's new status
    
Return Value:

    NTStatus

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);

    LOCK_CHANNEL_ATTRIBUTES(Channel);
    
    Channel->Status = Status;

    UNLOCK_CHANNEL_ATTRIBUTES(Channel);
    
    return STATUS_SUCCESS;
}

NTSTATUS
ChannelGetStatus(
    IN  PSAC_CHANNEL         Channel,
    OUT SAC_CHANNEL_STATUS*  Status
    )
/*++

Routine Description:

    This routine Gets the channels status.
    
Arguments:

    Channel     - Previously created channel.
    Status      - The channel's new status
    
Return Value:

    NTStatus

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);

    LOCK_CHANNEL_ATTRIBUTES(Channel);
        
    *Status = Channel->Status;

    UNLOCK_CHANNEL_ATTRIBUTES(Channel);
    
    return STATUS_SUCCESS;
}

NTSTATUS
ChannelSetApplicationType(
    IN PSAC_CHANNEL Channel,
    IN GUID         ApplicationType
    )
/*++

Routine Description:

    This routine sets the channel's application type.
    
Arguments:

    Channel             - Previously created channel.
    ApplicationType     - Application type
    
Return Value:

    NTStatus

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);

    LOCK_CHANNEL_ATTRIBUTES(Channel);
    
    Channel->ApplicationType = ApplicationType;

    UNLOCK_CHANNEL_ATTRIBUTES(Channel);
    
    return STATUS_SUCCESS;
}

NTSTATUS
ChannelGetApplicationType(
    IN  PSAC_CHANNEL Channel,
    OUT GUID*        ApplicationType
    )
/*++

Routine Description:

    This routine gets the channel's application type.
    
Arguments:

    Channel             - Previously created channel.
    ApplicationType     - Application type
    
Return Value:

    NTStatus

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);

    LOCK_CHANNEL_ATTRIBUTES(Channel);
    
    *ApplicationType = Channel->ApplicationType;

    UNLOCK_CHANNEL_ATTRIBUTES(Channel);
    
    return STATUS_SUCCESS;
}

#if ENABLE_CHANNEL_LOCKING

NTSTATUS
ChannelSetLockEvent(
    IN  PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    Set the channel lock event
    
Arguments:

    Channel  - The channel to fire the event for
    
Return Value:

    NTStatus

--*/
{

    ASSERT_STATUS(Channel->LockEvent, STATUS_UNSUCCESSFUL);
    ASSERT_STATUS(Channel->LockEventObjectBody, STATUS_UNSUCCESSFUL);
    ASSERT_STATUS(Channel->LockEventWaitObjectBody, STATUS_UNSUCCESSFUL);

    if (Channel->LockEventWaitObjectBody) {
        
        //
        // fire the event
        //
        KeSetEvent(
            Channel->LockEventWaitObjectBody,
            EVENT_INCREMENT,
            FALSE
            );
    
    }

    return STATUS_SUCCESS;

}

#endif

NTSTATUS
ChannelSetRedrawEvent(
    IN  PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    Set the channel redraw event
    
Arguments:

    Channel  - The channel to fire the event for
    
Return Value:

    NTStatus

--*/
{

    ASSERT_STATUS(Channel->RedrawEvent, STATUS_UNSUCCESSFUL);
    ASSERT_STATUS(Channel->RedrawEventObjectBody, STATUS_UNSUCCESSFUL);
    ASSERT_STATUS(Channel->RedrawEventWaitObjectBody, STATUS_UNSUCCESSFUL);

    if (Channel->RedrawEventWaitObjectBody) {
        
        //
        // fire the event
        //
        KeSetEvent(
            Channel->RedrawEventWaitObjectBody,
            EVENT_INCREMENT,
            FALSE
            );
    
    }

    return STATUS_SUCCESS;

}

NTSTATUS
ChannelClearRedrawEvent(
    IN  PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    Clear the channel redraw event
    
Arguments:

    Channel  - The channel to fire the event for
    
Return Value:

    NTStatus

--*/
{

    ASSERT_STATUS(Channel->RedrawEvent, STATUS_UNSUCCESSFUL);
    ASSERT_STATUS(Channel->RedrawEventObjectBody, STATUS_UNSUCCESSFUL);
    ASSERT_STATUS(Channel->RedrawEventWaitObjectBody, STATUS_UNSUCCESSFUL);

    if (Channel->RedrawEventWaitObjectBody) {
        
        //
        // clear the event
        //
        KeClearEvent( Channel->RedrawEventWaitObjectBody );
    
    }

    return STATUS_SUCCESS;

}

NTSTATUS
ChannelHasRedrawEvent(
    IN  PSAC_CHANNEL Channel,
    OUT PBOOLEAN     Present
    )
/*++

Routine Description:

    This routine determines if the channel has the Redraw event present.

Arguments:

    Channel - the channel to query                                                                        
                                                                        
Return Value:

    TRUE    - the channel has the event
    FALSE   - Otherwise

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(Present, STATUS_INVALID_PARAMETER_2);

    *Present = (ChannelGetFlags(Channel) & SAC_CHANNEL_FLAG_REDRAW_EVENT) ? TRUE : FALSE;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\conmgr.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    ConMgr.c

Abstract:

    Routines for managing channels in the sac.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#include "sac.h"
#include "concmd.h"
#include "iomgr.h"

//
// Definitions for this file.
//

//
// The maximum # of times we will try to write data via
// headless dispatch 
//
#define MAX_HEADLESS_DISPATCH_ATTEMPTS 32

//
// Spinlock macros
//

//
// we need this lock to:
// 
// 1. prevent asynchronous messages being put to the sac channel
// 2. channels from dissapearing while they are the current channel
//
//  we could get rid of this lock by:
//
// 1. providing some sort of event cue that gets processed when it's safe
// 2. providing a means to notify channels when they are not the current channel
//    and have them stop outputting anymore
//    This goes back to the unresolved issue of having the Oecho and OFlush routines
//    managed by the conmgr - they could stop the outptu if the current channel changes,
//    rather than having the channel do the work. This is definitely a TODO since
//    having Headless dispatch calls in the channel I/O breaks the abstraction of the IoMgr.
//
#define INIT_CURRENT_CHANNEL_LOCK()                     \
    KeInitializeMutex(                                  \
        &CurrentChannelLock,                            \
        0                                               \
        );                                              \
    CurrentChannelRefCount = 0;

#define LOCK_CURRENT_CHANNEL()                          \
    KeWaitForMutexObject(                               \
        &CurrentChannelLock,                            \
        Executive,                                      \
        KernelMode,                                     \
        FALSE,                                          \
        NULL                                            \
        );                                              \
    ASSERT(CurrentChannelRefCount == 0);                \
    InterlockedIncrement((volatile long *)&CurrentChannelRefCount);

#define UNLOCK_CURRENT_CHANNEL()                        \
    ASSERT(CurrentChannelRefCount == 1);                \
    InterlockedDecrement((volatile long *)&CurrentChannelRefCount);      \
    KeReleaseMutex(                                     \
        &CurrentChannelLock,                            \
        FALSE                                           \
        );

#define ASSERT_LOCK_CURRENT_CHANNEL()                   \
    ASSERT(CurrentChannelRefCount == 1);                \
    ASSERT(KeReadStateMutex(&CurrentChannelLock)==0);

//
// Serial Port Consumer globals
//
BOOLEAN ConMgrLastCharWasCR = FALSE;
BOOLEAN InputInEscape = FALSE;
BOOLEAN InputInEscTab = FALSE;
UCHAR   InputBuffer[SAC_VTUTF8_COL_WIDTH];

//
// Pointer to the SAC channel object
//
PSAC_CHANNEL    SacChannel = NULL;

//
// The index the SAC in the channel array
//
#define SAC_CHANNEL_INDEX   0

//
// lock for r/w access on current channel globals
//
KMUTEX  CurrentChannelLock;
ULONG   CurrentChannelRefCount;

//
//
//
EXECUTE_POST_CONSUMER_COMMAND_ENUM  ExecutePostConsumerCommand      = Nothing;
PVOID                               ExecutePostConsumerCommandData  = NULL;

//
// Channel Manager info for the current channel.  
// Depending on the application, the current channel
// can be accessed using one of these references.
//
PSAC_CHANNEL    CurrentChannel = NULL;

//
// prototypes
//
VOID
ConMgrSerialPortConsumer(
    VOID
    );

VOID
ConMgrProcessInputLine(
    VOID
    );

NTSTATUS
ConMgrResetCurrentChannel(
    BOOLEAN SwitchDirectlyToChannel
    );


NTSTATUS
ConMgrInitialize(
    VOID
    )
/*++

Routine Description:

    This is the Console Manager's IoMgrInitialize implementation.
    
    Initialize the console manager

Arguments:
    
    none
    
Return Value:

    Status

--*/
{
    NTSTATUS                Status;
    PSAC_CHANNEL            TmpChannel;

    //
    // Initialize the current channel lock 
    //
    INIT_CURRENT_CHANNEL_LOCK();
    
    //
    // Lock down the current channel globals
    //
    // Note: we need to do this here since many of the ConMgr support
    //       routines do ASSERTs to ensure the current channel lock is held
    //
    LOCK_CURRENT_CHANNEL();

    //
    // Initialize
    //
    do {

        PCWSTR  pcwch;

        SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;
            
        //
        // Initialize the SAC channel attributes
        //
        RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

        Attributes.Type             = ChannelTypeVTUTF8;
        
        // attempt to copy the channel name
        pcwch = GetMessage(PRIMARY_SAC_CHANNEL_NAME);
        ASSERT(pcwch);
        if (!pcwch) {
            Status = STATUS_NO_MEMORY;
            break;
        }
        wcsncpy(Attributes.Name, pcwch, SAC_MAX_CHANNEL_NAME_LENGTH);
        Attributes.Name[SAC_MAX_CHANNEL_NAME_LENGTH] = UNICODE_NULL;

        // attempt to copy the channel description
        pcwch = GetMessage(PRIMARY_SAC_CHANNEL_DESCRIPTION);
        ASSERT(pcwch);
        if (!pcwch) {
            Status = STATUS_NO_MEMORY;
            break;
        }
        wcsncpy(Attributes.Description, pcwch, SAC_MAX_CHANNEL_DESCRIPTION_LENGTH);
        Attributes.Description[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH] = UNICODE_NULL;
        
        Attributes.Flags            = SAC_CHANNEL_FLAG_PRESERVE |
                                      SAC_CHANNEL_FLAG_APPLICATION_TYPE;
        Attributes.CloseEvent       = NULL;
        Attributes.HasNewDataEvent  = NULL;
#if ENABLE_CHANNEL_LOCKING
        Attributes.LockEvent        = NULL;
#endif
        Attributes.RedrawEvent      = NULL;
        Attributes.ApplicationType  = PRIMARY_SAC_CHANNEL_APPLICATION_GUID;
       
        //
        // create the SAC channel
        //
        Status = ChanMgrCreateChannel(
            &SacChannel, 
            &Attributes
            );

        if (! NT_SUCCESS(Status)) {
            break;        
        }

        //
        // Get a reference to the SAC channel
        //
        // Note: this is the channel manager's policy 
        //          we need to get the reference of the channel
        //          before we use it.
        //
        Status = ChanMgrGetByHandle(
            ChannelGetHandle(SacChannel),
            &TmpChannel
            );
        
        if (! NT_SUCCESS(Status)) {
            break;        
        }
        
        SacChannel = TmpChannel;

        //
        // Assign the new current channel
        //
        CurrentChannel = SacChannel;

        //
        // Update the sent to screen status
        //
        ChannelSetSentToScreen(CurrentChannel, FALSE);
        
        //
        // Display the prompt
        //
        Status = HeadlessDispatch(
            HeadlessCmdClearDisplay, 
            NULL, 
            0,
            NULL,
            NULL
            );

        if (! NT_SUCCESS(Status)) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC ConMgrInitialize: Failed dispatch\n")));

        }

        //
        // Initialize the SAC display
        //
        SacPutSimpleMessage( SAC_ENTER );
        SacPutSimpleMessage( SAC_INITIALIZED );
        SacPutSimpleMessage( SAC_ENTER );
        SacPutSimpleMessage( SAC_PROMPT );
    
        //
        // Flush the channel data to the screen
        //
        Status = ConMgrDisplayCurrentChannel();

        if (! NT_SUCCESS(Status)) {
            break;        
        }
        
    } while (FALSE);
    
    //
    // We are done with the current channel globals
    //
    UNLOCK_CURRENT_CHANNEL();
    
    return STATUS_SUCCESS;
}

NTSTATUS
ConMgrShutdown(
    VOID
    )
/*++

Routine Description:

    This is the Console Manager's IoMgrShutdown implementation.
    
    Shutdown the console manager

Arguments:

    none
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    //
    // close the sac channel
    //
    if (SacChannel) {

        Status = ChannelClose(SacChannel);

        if (!NT_SUCCESS(Status)) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC ConMgrShutdown: failed closing SAC channel.\n"))
                );

        }

        SacChannel = NULL;

    }
    
    //
    // Release the current channel
    //
    if (CurrentChannel) {
        
        Status = ChanMgrReleaseChannel(CurrentChannel);

        if (!NT_SUCCESS(Status)) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC ConMgrShutdown: failed releasing current channel\n"))
                );

        }
    
        CurrentChannel = NULL;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
ConMgrDisplayFastChannelSwitchingInterface(
    PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine displays the fast-channel-switching interface
    
    Note: caller must hold channel mutex

Arguments:

    Channel - Channel to display
    
Return Value:

    Status

--*/
{
    HEADLESS_CMD_POSITION_CURSOR SetCursor;
    HEADLESS_CMD_SET_COLOR SetColor;
    PCWSTR              Message;
    NTSTATUS            Status;
    ULONG               OutputBufferSize;
    PWSTR               OutputBuffer;
    PWSTR               Name;
    PWSTR               Description;
    PWSTR               DescriptionWrapped;
    GUID                ApplicationType;
    PWSTR               ChannelTypeString;
    SAC_CHANNEL_HANDLE  Handle;

    ASSERT_LOCK_CURRENT_CHANNEL();

    //
    // Initialize 
    //
    OutputBufferSize = (11*SAC_VTUTF8_COL_WIDTH+1)*sizeof(WCHAR);
    OutputBuffer = ALLOCATE_POOL(OutputBufferSize, GENERAL_POOL_TAG);
    ASSERT_STATUS(OutputBuffer, STATUS_NO_MEMORY);

    Name = NULL;
    Description = NULL;
    DescriptionWrapped = NULL;

    //
    // Display the Fast-Channel-Switching interface
    //
    do {

        //
        // We cannot use the standard SacPutString() functions, because those write 
        // over the channel screen buffer.  We force directly onto the terminal here.
        //
        ASSERT(Utf8ConversionBuffer);
        if (!Utf8ConversionBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        
        //
        // Clear the terminal screen.
        //
        Status = HeadlessDispatch(
            HeadlessCmdClearDisplay,
            NULL,
            0,
            NULL,
            NULL
            );
        if (! NT_SUCCESS(Status)) {
            break;
        }

        SetCursor.Y = 0;
        SetCursor.X = 0;
        
        Status = HeadlessDispatch(
            HeadlessCmdPositionCursor,
            &SetCursor,
            sizeof(HEADLESS_CMD_POSITION_CURSOR),
            NULL,
            NULL
            );
        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // Send starting colors.
        //
        SetColor.BkgColor = HEADLESS_TERM_DEFAULT_BKGD_COLOR;
        SetColor.FgColor = HEADLESS_TERM_DEFAULT_TEXT_COLOR;
        
        Status = HeadlessDispatch(
            HeadlessCmdSetColor,
            &SetColor,
            sizeof(HEADLESS_CMD_SET_COLOR),
            NULL,
            NULL
            );
        if (! NT_SUCCESS(Status)) {
            break;
        }

        Status = HeadlessDispatch(
            HeadlessCmdDisplayAttributesOff, 
            NULL, 
            0, 
            NULL, 
            NULL
            );
        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // Display xml bundle
        //
        Status = UTF8EncodeAndSend(L"<channel-switch>\r\n");

        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // Get the channel's name
        //
        Status = ChannelGetName(
            Channel,
            &Name
            );
        
        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // Get the channel's description
        //
        Status = ChannelGetDescription(
            Channel,
            &Description
            );
        
        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // Get the channel handle
        //
        Handle = ChannelGetHandle(Channel);
        
        //
        // Get the channel's application type
        //
        ChannelGetApplicationType(
            Channel, 
            &ApplicationType
            );

        //
        // Determine the channel type string
        //
        switch (ChannelGetType(Channel)) {
        case ChannelTypeVTUTF8:
        case ChannelTypeCmd:
            ChannelTypeString = L"VT-UTF8";
            break;
        case ChannelTypeRaw:
            ChannelTypeString = L"Raw";
            break;
        default:
            ChannelTypeString = L"UNKNOWN";
            ASSERT(0);
            break;
        }

        //
        // Assemble xml blob
        //
        SAFE_SWPRINTF(
            OutputBufferSize,
            (OutputBuffer,
            L"<name>%s</name>\r\n<description>%s</description>\r\n<type>%s</type>\r\n",
            Name,
            Description,
            ChannelTypeString
            ));
            
        Status = UTF8EncodeAndSend(OutputBuffer);

        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        SAFE_SWPRINTF(
            OutputBufferSize,
            (OutputBuffer,
            L"<guid>%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x</guid>\r\n",
            Handle.ChannelHandle.Data1,
            Handle.ChannelHandle.Data2,
            Handle.ChannelHandle.Data3,
            Handle.ChannelHandle.Data4[0],
            Handle.ChannelHandle.Data4[1],
            Handle.ChannelHandle.Data4[2],
            Handle.ChannelHandle.Data4[3],
            Handle.ChannelHandle.Data4[4],
            Handle.ChannelHandle.Data4[5],
            Handle.ChannelHandle.Data4[6],
            Handle.ChannelHandle.Data4[7]
            ));

        Status = UTF8EncodeAndSend(OutputBuffer);

        if (! NT_SUCCESS(Status)) {
            break;
        }

        SAFE_SWPRINTF(
            OutputBufferSize,
            (OutputBuffer,
            L"<application-type>%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x</application-type>\r\n",
            ApplicationType.Data1,
            ApplicationType.Data2,
            ApplicationType.Data3,
            ApplicationType.Data4[0],
            ApplicationType.Data4[1],
            ApplicationType.Data4[2],
            ApplicationType.Data4[3],
            ApplicationType.Data4[4],
            ApplicationType.Data4[5],
            ApplicationType.Data4[6],
            ApplicationType.Data4[7]
            ));
        
        Status = UTF8EncodeAndSend(OutputBuffer);
        
        if (! NT_SUCCESS(Status)) {
            break;
        }

        Status = UTF8EncodeAndSend(L"</channel-switch>\r\n");

        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // Clear the terminal screen.
        //
        Status = HeadlessDispatch(
            HeadlessCmdClearDisplay,
            NULL,
            0,
            NULL,
            NULL
            );
        if (! NT_SUCCESS(Status)) {
            break;
        }

        SetCursor.Y = 0;
        SetCursor.X = 0;
        
        Status = HeadlessDispatch(
            HeadlessCmdPositionCursor,
            &SetCursor,
            sizeof(HEADLESS_CMD_POSITION_CURSOR),
            NULL,
            NULL
            );
        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // Send starting colors.
        //
        SetColor.BkgColor = HEADLESS_TERM_DEFAULT_BKGD_COLOR;
        SetColor.FgColor = HEADLESS_TERM_DEFAULT_TEXT_COLOR;
        
        Status = HeadlessDispatch(
            HeadlessCmdSetColor,
            &SetColor,
            sizeof(HEADLESS_CMD_SET_COLOR),
            NULL,
            NULL
            );
        if (! NT_SUCCESS(Status)) {
            break;
        }

        Status = HeadlessDispatch(
            HeadlessCmdDisplayAttributesOff, 
            NULL, 
            0, 
            NULL, 
            NULL
            );
        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // Display the plaintext FCSwitching header
        //

        //
        // Modify the Descripto to wrap if necessary
        //
        Status = CopyAndInsertStringAtInterval(
            Description,
            60,
            L"\r\n                  ",
            &DescriptionWrapped
            );
        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // Get the Channel Switching Header
        //
        Message = GetMessage(SAC_CHANNEL_SWITCHING_HEADER);

//        Name:             %%s
//        Description:      %%s
//        Type:             %%s
//        Channel GUID:     %%08lx-%%04x-%%04x-%%02x%%02x-%%02x%%02x%%02x%%02x%%02x%%02x
//        Application Type: %%08lx-%%04x-%%04x-%%02x%%02x-%%02x%%02x%%02x%%02x%%02x%%02x
//        
//        Use <esc> then <tab> for next channel.
//        Use <esc> then 0 to return to the SAC channel.
//        Use any other key to view this channel.

        SAFE_SWPRINTF(
            OutputBufferSize,
            (OutputBuffer,
            Message,
            Name,
            DescriptionWrapped,
            ChannelTypeString,
            Handle.ChannelHandle.Data1,
            Handle.ChannelHandle.Data2,
            Handle.ChannelHandle.Data3,
            Handle.ChannelHandle.Data4[0],
            Handle.ChannelHandle.Data4[1],
            Handle.ChannelHandle.Data4[2],
            Handle.ChannelHandle.Data4[3],
            Handle.ChannelHandle.Data4[4],
            Handle.ChannelHandle.Data4[5],
            Handle.ChannelHandle.Data4[6],
            Handle.ChannelHandle.Data4[7],
            ApplicationType.Data1,
            ApplicationType.Data2,
            ApplicationType.Data3,
            ApplicationType.Data4[0],
            ApplicationType.Data4[1],
            ApplicationType.Data4[2],
            ApplicationType.Data4[3],
            ApplicationType.Data4[4],
            ApplicationType.Data4[5],
            ApplicationType.Data4[6],
            ApplicationType.Data4[7]
            ));

            Status = UTF8EncodeAndSend(OutputBuffer);

            if (! NT_SUCCESS(Status)) {
                break;
            }

    } while ( FALSE );

    SAFE_FREE_POOL(&Name);
    SAFE_FREE_POOL(&Description);
    SAFE_FREE_POOL(&DescriptionWrapped);
    SAFE_FREE_POOL(&OutputBuffer);

    return Status;
}

NTSTATUS
ConMgrResetCurrentChannel(
    BOOLEAN SwitchDirectlyToChannel
    )
/*++

Routine Description:

    This routine makes the SAC the current channel
    
    Note: caller must hold channel mutex

Arguments:

    SwitchDirectlyToChannel - 
        if false, 
        then show the switching interface,
        else switch directly to the channel
    
Return Value:

    Status

--*/
{
    NTSTATUS        Status;
    PSAC_CHANNEL    TmpChannel;

    ASSERT_LOCK_CURRENT_CHANNEL();
    
    //
    // Get a reference to the SAC channel
    //
    // Note: this is the channel manager's policy 
    //          we need to get the reference of the channel
    //          before we use it.
    //
    Status = ChanMgrGetByHandle(
        ChannelGetHandle(SacChannel),
        &TmpChannel
        );
    
    if (! NT_SUCCESS(Status)) {
        return Status;
    }
    
    SacChannel = TmpChannel;

    //
    // Make the SAC the current channel
    //
    Status = ConMgrSetCurrentChannel(SacChannel);
                
    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    //
    //
    //
    if (SwitchDirectlyToChannel) {
        
        //
        // Flush the buffered channel data to the screen
        //
        // Note: we don't need to lock down the SAC, since we own it
        //
        Status = ConMgrDisplayCurrentChannel();
    
    } else {
        
        //
        // Let the user know we switched via the Channel switching interface
        //
        Status = ConMgrDisplayFastChannelSwitchingInterface(CurrentChannel);
    
    }

    return Status;

}


NTSTATUS
ConMgrSetCurrentChannel(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This routine release the current channel's ref count and sets 
    the currently active channel to the one given. This routine
    assumes that the current channel was not release after it
    became the current channel.  Hence, the typical use sequence
    for making a channel the current channel is:
    
    1. ChanMgrGetByXXX --> Channel
        (This gets a channel and increments its ref count by 1)
    2. ConMgrSetCurrentChannel(Channel)
        (This releases the current channel and makes the specified
         channel the current channel)
    3. ...
    4. goto 1. 
        ( a new channel is made teh current channel)

Arguments:

    NewChannel   - the new current channel
    
Return Value:

    Status

--*/
{
    NTSTATUS        Status;
    BOOLEAN         Present;

    ASSERT_LOCK_CURRENT_CHANNEL();
    
    //
    // Check to see if the channel has a redraw event
    //
    Status = ChannelHasRedrawEvent(
        CurrentChannel,
        &Present
        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Tell the channel to start the drawing
    //
    if (Present) {
        ChannelClearRedrawEvent(CurrentChannel);
    }

    //
    // Update the sent to screen status
    //
    ChannelSetSentToScreen(CurrentChannel, FALSE);
    
    //
    // We are done with the current channel
    //
    Status = ChanMgrReleaseChannel(CurrentChannel);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    //
    // Assign the new current channel
    //
    CurrentChannel = Channel;

    //
    // Update the sent to screen status
    //
    ChannelSetSentToScreen(CurrentChannel, FALSE);

    return STATUS_SUCCESS;

}

NTSTATUS
ConMgrDisplayCurrentChannel(
    VOID
    )
/*++

Routine Description:

    This routine sets the currently active channel to the one given.  It will transmit
    the channel buffer to the terminal if SendToScreen is TRUE.
    
    Note: caller must hold channel mutex

Arguments:

    None
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;
    BOOLEAN     Present;        

    ASSERT_LOCK_CURRENT_CHANNEL();

    //
    // Check to see if the channel has a redraw event
    //
    Status = ChannelHasRedrawEvent(
        CurrentChannel,
        &Present
        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    
    //
    // The channel buffer has been sent to the screen
    //
    ChannelSetSentToScreen(CurrentChannel, TRUE);

    //
    // Tell the channel to start the drawing
    //
    if (Present) {
        ChannelSetRedrawEvent(CurrentChannel);
    }
    
    //
    // Flush the buffered data to the screen
    //
    Status = ChannelOFlush(CurrentChannel);

    return Status;

}

NTSTATUS
ConMgrAdvanceCurrentChannel(
    VOID
    )
/*++

Routine Description:

    This routine queries the channel manager for the next available
    active channel and makes it the current channel. 
    
    Note: The SAC channel is always active and cannot be deleted.
          Hence, we have a halting condition in that we will always
          stop at the SAC channel.  For example, if the SAC is the 
          only active channel, the current channel will remain the 
          SAC channel.  

Arguments:

    None
    
Return Value:

    Status

--*/
{
    NTSTATUS            Status;
    ULONG               NewIndex;
    PSAC_CHANNEL        Channel;

    ASSERT_LOCK_CURRENT_CHANNEL();
    
    do {
        
        //
        // Query the channel manager for an array of currently active channels
        //
        Status = ChanMgrGetNextActiveChannel(
            CurrentChannel,
            &NewIndex,
            &Channel
            );
    
        if (! NT_SUCCESS(Status)) {
            break;
        }
    
        //
        // Change the current channel to the next active channel
        //
        Status = ConMgrSetCurrentChannel(Channel);
    
        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // Let the user know we switched via the Channel switching interface
        //
        Status = ConMgrDisplayFastChannelSwitchingInterface(Channel);
    
        if (! NT_SUCCESS(Status)) {
            break;
        }
        
    } while ( FALSE );

    return Status;
}

BOOLEAN
ConMgrIsWriteEnabled(
    PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This is the Console Manager's IoMgrIsWriteEnabled implementation.

    This routine determines if the channel in question is authorized
    to write to use the IoMgr's WriteData routine.  In the console
    manager's case, this is TRUE if the channel is the current channel.
    From the channel's perspective, if the channel is not enabled to
    write, then it should buffer the data - to be released at a later
    time by the io manager.

Arguments:

    ChannelHandle   - channel handle to compare against

Return Value:

    TRUE - the specified channel is the current channel    

--*/
{
    SAC_CHANNEL_HANDLE  Handle;

    //
    // Get the current channel's handle to compare against
    //
    Handle = ChannelGetHandle(CurrentChannel);

    //
    // Determine if the channel in question is the current channel
    //
    return ChannelIsEqual(
        Channel,
        &Handle
        );

}

VOID
ConMgrWorkerProcessEvents(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This is the Console Manager's IoMgrWorkerProcessEvents implementation.
    
    This is the routine for the worker thread.  It blocks on an event, when
    the event is signalled, then that indicates a request is ready to be processed.    

Arguments:

    DeviceContext - A pointer to this device.

Return Value:

    None.

--*/
{
    NTSTATUS    Status;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC WorkerProcessEvents: Entering.\n")));

    //
    // Loop forever.
    //
    while (1) {
        
        //
        // Block until there is work to do.
        //
        Status = KeWaitForSingleObject(
            (PVOID)&(DeviceContext->ProcessEvent), 
            Executive, 
            KernelMode,  
            FALSE, 
            NULL
            );

        //
        // Process the serial port buffer and return a processing state
        //
        ConMgrSerialPortConsumer();
        
        //
        // if there is work to do,
        // then something in the consumer wanted to perform
        //      some action that would result in deadlock
        //      contention for the Current channel lock.
        //
        switch(ExecutePostConsumerCommand) {
        case Reboot:
            
            DoRebootCommand(TRUE);
            
            //
            // we are done with this work
            //
            ExecutePostConsumerCommand = Nothing;
            
            break;
        
        case Shutdown:
            
            DoRebootCommand(FALSE);
            
            //
            // we are done with this work
            //
            ExecutePostConsumerCommand = Nothing;
            
            break;
        
        case CloseChannel: {

            PSAC_CHANNEL Channel;

            //
            // get the channel to close
            //
            Channel = (PSAC_CHANNEL)ExecutePostConsumerCommandData;

            //
            // attempt to close the channel
            //
            // Note: any error reporting necessary resulting
            //       from this action will be carried out via
            //       the IoMgrCloseChannel method
            //
            ChanMgrCloseChannel(Channel);

            //
            // We are done with the channel
            //
            ChanMgrReleaseChannel(Channel);

            //
            // we are done with this work
            //
            ExecutePostConsumerCommand      = Nothing;
            ExecutePostConsumerCommandData  = NULL;
            
            break;
        }

        case Nothing:
        default:
            break;
        }

    }

    ASSERT(0);
}


VOID
ConMgrSerialPortConsumer(
    VOID
    )

/*++

Routine Description:

        This is a DPC routine that is queue'd by DriverEntry.  It is used to check for any
    user input and then processes them.

Arguments:

    None

Return Value:

        None.

--*/
{
    NTSTATUS            Status;
    UCHAR               LocalTmpBuffer[4];
    ULONG               i;
    UCHAR               ch;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE_LOUD, KdPrint(("SAC TimerDpcRoutine: Entering.\n")));

    //
    // lock down the current channel globals
    //
    LOCK_CURRENT_CHANNEL();

    //
    // Make sure we have a current channel 
    //
    // NOTE: we should at least have the SAC channel
    //
    ASSERT(CurrentChannel);
    if (CurrentChannel == NULL) {
        goto ConMgrSerialPortConsumerDone;
    }

GetNextByte:

    //
    // Attempt to get a character from the serial port
    // 
    Status = SerialBufferGetChar(&ch);
    
    //
    // Bail if there are no new characters to read or if there was an error
    //
    if (!NT_SUCCESS(Status) || Status == STATUS_NO_DATA_DETECTED) {
        goto ConMgrSerialPortConsumerDone;
    }
    
    //
    // Possible states and actions:
    //
    // Note: <x> == <something else>
    //
    // <esc> 
    //      <tab> --> advance channel
    //          <0> --> reset current channel to SAC
    //          <x> --> display current channel
    //      <x> --> if CurrentChannel != SacChannel, then write <esc> in channel->ibuffer
    //              and write <x> in channel->ibuffer
    // <x> --> write <x> to current channel->ibuffer
    //

    //
    // Check for <esc>
    //
    // Note: we can arrive at this routine from:
    // 
    // <x>
    // <esc><x>
    // <esc><tab><x>
    //
    // So we need to clear the InputInEscTab flag
    //
    // If we are already in the <esc><x> sequence, then
    // skip this block.  This way we can receive <esc><esc>
    // sequences.
    //
    if (ch == 0x1B && (InputInEscape == FALSE)) {

        //
        // We are no longer in an <esc><tab><x> sequence 
        //
        InputInEscTab = FALSE;
        
        //
        // We are now in an <esc><x> sequence
        //
        InputInEscape = TRUE;

        goto GetNextByte;

    } 
    
    //
    // Check for <esc><tab>
    //
    // Note: we can arrive at this routine from:
    //
    // <esc><x>
    //
    if ((ch == '\t') && InputInEscape) {
        
        //
        // We should not be in an <esc><tab><x> sequence already
        //
        ASSERT(InputInEscTab == FALSE);

        //
        // We are no longer in an <esc><x> sequence 
        //
        InputInEscape = FALSE;

        //
        // Find the next active channel and make it the current
        //
        Status = ConMgrAdvanceCurrentChannel();

        if (! NT_SUCCESS(Status)) {
            goto ConMgrSerialPortConsumerDone;
        }

        //
        // We are now in an <esc><tab><x> sequence
        //
        InputInEscTab = TRUE;
        
        goto GetNextByte;

    } 
    
    //
    // If this screen has not yet been displayed and the user entered a 0,
    // then switch to the SAC Channel
    //
    // Note: we can arrive at this routine from:
    //
    // <esc><tab><x>
    //
    if ((ch == '0') && InputInEscTab) {

        //
        // We should not be in an <esc><x> sequence at this point
        //
        ASSERT(InputInEscape == FALSE);
        
        //
        // We are no longer in an <esc><tab><x> sequence 
        //
        InputInEscTab = FALSE;
        
        //
        // It is possible that the current channel has already been sent
        // to the screen without having received the <x> of <esc><tab><x>
        //
        // For instance:
        //
        // 1. we received <esc><tab>
        //    a. InputInEscTab = TRUE
        //    b. the fast-channel-switching header is displayed
        //    c. sent to screen for current channel == false
        //    d. sent to screen for SAC channel == false
        // 2. we leave the consumer since there is no new input
        // 3. the current channel is closed by it's owner
        //    a. the current channel is removed
        //    b. the current channel becomes the SAC channel
        //    c. the current channel is displayed
        //    d. sent to screen for SAC channel == true
        // 4. we receive <x> of <esc><tab><x> sequence
        // 5. we end up here and are no longer in an EscTab sequence.
        //
        if (!ChannelSentToScreen(CurrentChannel)) {
            
            //
            // Make the current channel the SAC
            //
            // Note: There should not be anything modifying the SacChannel
            //       at this time, so this should be safe
            //
            Status = ConMgrResetCurrentChannel(FALSE);
                
            if (! NT_SUCCESS(Status)) {
                goto ConMgrSerialPortConsumerDone;
            }
                
        }

        goto GetNextByte;

    }

    //
    // If this screen has not yet been displayed, 
    // and the user entered a keystroke then display it.
    //
    // Note: we can arrive at this routine from:
    // 
    // <x>
    // <esc><x>
    // <esc><tab><x>
    //
    // So we need to clear the esc sequence flags
    //
    if (!ChannelSentToScreen(CurrentChannel)) {

        //
        // We are no longer in an <esc><x> sequence 
        //
        InputInEscape = FALSE;

        //
        // We are no longer in an <esc><tab><x> sequence 
        //
        InputInEscTab = FALSE;
        
        //
        // Attempt to display the buffered contents of the current channel
        //
        Status = ConMgrDisplayCurrentChannel();
        
        if (! NT_SUCCESS(Status)) {
            goto ConMgrSerialPortConsumerDone;
        }
        
        goto GetNextByte;

    } else {

        //
        // It is possible that the current channel has already been sent
        // to the screen without having received the <x> of <esc><tab><x>
        //
        // For instance:
        //
        // 1. we received <esc><tab>
        //    a. InputInEscTab = TRUE
        //    b. the fast-channel-switching header is displayed
        //    c. sent to screen for current channel == false
        //    d. sent to screen for SAC channel == false
        // 2. we leave the consumer since there is no new input
        // 3. the current channel is closed by it's owner
        //    a. the current channel is removed
        //    b. the current channel becomes the SAC channel
        //    c. the current channel is displayed
        //    d. sent to screen for SAC channel == true
        // 4. we receive <x> of <esc><tab><x> sequence
        // 5. we skip the (!ChannelSentToScreen(CurrentChannel)) block
        // 6. we end up here.  Since the <x> != 0 and we have already
        //    sent the current data to the screen, we are no longer
        //    in an EscTab sequence.
        //

        InputInEscTab = FALSE;

    }

    //
    // This is the beginning of the fall-through block.
    // That is, if we get here, then the character is not a part
    // of some special sequence that should have been processed
    // above.  Characters processed here are inserted into the
    // current channel's input buffer.
    //
    // Note: we should not be in an <esc><tab><x> sequence here
    //
    ASSERT(InputInEscTab == FALSE);

    //
    // If the user was entering <esc><x> and the current channel
    // is not the SAC, then store the <esc> in the current channel's
    // ibuffer.
    //
    // Note: <esc><esc> buffers a single <esc>.  
    //       This allows sending an real <esc><tab> to the channel.
    //
    if (InputInEscape && (CurrentChannel != SacChannel)) {
        LocalTmpBuffer[0] = 0x1B;
        Status = ChannelIWrite(
            CurrentChannel, 
            LocalTmpBuffer, 
            sizeof(LocalTmpBuffer[0])
            );
    }
    
    //
    // If the current character is <esc>, 
    // then we still are in an escape sequence so
    // don't change the InputInEscape.
    // This allows <esc><esc> to be followed by <tab>
    // and form a valid <esc><tab> sequence.
    // 
    if (ch != 0x1B) {
        //
        // We are no longer in an <esc><x> sequence
        //
        InputInEscape = FALSE;
    }

    //
    // Buffer this input to the current channel's IBuffer
    //
    ChannelIWrite(
        CurrentChannel, 
        &ch, 
        sizeof(ch)
        );

    //
    // If the current channel is not the SAC, then go and get more input.
    // Otherwise, process the SAC's input buffer
    //
    if (CurrentChannel != SacChannel) {
    
        goto GetNextByte;

    } else {
        
        ULONG   ResponseLength;
        WCHAR   wch;

        //
        // Now do processing if the SAC is the active channel.
        //

        //
        // Strip the LF if the last character was a CR
        //
        if (ConMgrLastCharWasCR && ch == (UCHAR)0x0A) {
            ChannelIReadLast(CurrentChannel);
            ConMgrLastCharWasCR = FALSE;
            goto GetNextByte;
        }

        //
        // Keep track of the of when we receive a CR so
        // we can strip of the LF if it is next
        //
        ConMgrLastCharWasCR = (ch == 0x0D ? TRUE : FALSE);

        // 
        // If this is a return, then we are done and need to return the line
        //
        if ((ch == '\n') || (ch == '\r')) {
            SacPutString(L"\r\n");
            ChannelIReadLast(CurrentChannel);
            LocalTmpBuffer[0] = '\0';
            ChannelIWrite(CurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));
            goto StripWhitespaceAndReturnLine;
        }

        //
        // If this is a backspace or delete, then we need to do that.
        //
        if ((ch == 0x8) || (ch == 0x7F)) {  // backspace (^H) or delete

            //
            // We want to:
            //  1. remove the backspace or delete character
            //  2. if the input buffer is non-empty, remove the last character 
            //     (which is the character the user wanted to delete)
            //
            if (ChannelIBufferLength(CurrentChannel) > 0) {
                ChannelIReadLast(CurrentChannel);
            }
            if (ChannelIBufferLength(CurrentChannel) > 0) {
                SacPutString(L"\010 \010");
                ChannelIReadLast(CurrentChannel);
            }
        } else if (ch == 0x3) { // Control-C

            //
            // Terminate the string and return it.
            //
            ChannelIReadLast(CurrentChannel);
            LocalTmpBuffer[0] = '\0';
            ChannelIWrite(CurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));
            goto StripWhitespaceAndReturnLine;

        } else if (ch == 0x9) { // Tab

            //
            // Ignore tabs
            //
            ChannelIReadLast(CurrentChannel);
            SacPutString(L"\007"); // send a BEL
            goto GetNextByte;

        } else if (ChannelIBufferLength(CurrentChannel) == SAC_VTUTF8_COL_WIDTH - 2) {

            WCHAR   Buffer[4];

            //
            // We are at the end of the screen - remove the last character from 
            // the terminal screen and replace it with this one.
            //
            swprintf(Buffer, L"\010%c", ch);
            SacPutString(Buffer);
            ChannelIReadLast(CurrentChannel);
            ChannelIReadLast(CurrentChannel);
            LocalTmpBuffer[0] = ch;
            ChannelIWrite(CurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));

        } else {

            WCHAR   Buffer[4];
            
            //
            // Echo the character to the screen
            //
            swprintf(Buffer, L"%c", ch);
            SacPutString(Buffer);
        }

        goto GetNextByte;

StripWhitespaceAndReturnLine:

        //
        // Before returning the input line, strip off all leading and trailing blanks
        //
        do {
            LocalTmpBuffer[0] = (UCHAR)ChannelIReadLast(CurrentChannel);
        } while (((LocalTmpBuffer[0] == '\0') ||
                  (LocalTmpBuffer[0] == ' ')  ||
                  (LocalTmpBuffer[0] == '\t')) &&
                 (ChannelIBufferLength(CurrentChannel) > 0)
                );

        ChannelIWrite(CurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));
        LocalTmpBuffer[0] = '\0';
        ChannelIWrite(CurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));

        do {

            Status = ChannelIRead(
                CurrentChannel, 
                (PUCHAR)&wch, 
                sizeof(WCHAR),
                &ResponseLength
                );

            LocalTmpBuffer[0] = (UCHAR)wch;

        } while ((ResponseLength != 0) &&
                 ((LocalTmpBuffer[0] == ' ')  ||
                  (LocalTmpBuffer[0] == '\t')));

        InputBuffer[0] = LocalTmpBuffer[0];
        i = 1;

        do {
            
            Status = ChannelIRead(
                CurrentChannel, 
                (PUCHAR)&wch, 
                sizeof(WCHAR),
                &ResponseLength
                );
            
            ASSERT(i < SAC_VTUTF8_COL_WIDTH);       
            InputBuffer[i++] = (UCHAR)wch; 

        } while (ResponseLength != 0);

        //
        // Lower case all the characters.  We do not use strlwr() or the like, so that
        // the SAC (expecting ASCII always) doesn't accidently get DBCS or the like 
        // translation of the UCHAR stream.
        //
        for (i = 0; InputBuffer[i] != '\0'; i++) {
            ASSERT(i < SAC_VTUTF8_COL_WIDTH);       
            if ((InputBuffer[i] >= 'A') && (InputBuffer[i] <= 'Z')) {
                InputBuffer[i] = InputBuffer[i] - 'A' + 'a';
            }
        }

        ASSERT(ExecutePostConsumerCommand == Nothing);

        //
        // Process the input line.
        //
        ConMgrProcessInputLine();

        //
        // Put the next command prompt
        //
        SacPutSimpleMessage(SAC_PROMPT);
        
        //
        // exit if we need to do some work
        //
        if (ExecutePostConsumerCommand != Nothing) {
            goto ConMgrSerialPortConsumerDone;
        }

        //
        // Keep on processing characters
        //
        goto GetNextByte;

    }
    
ConMgrSerialPortConsumerDone:

    //
    // We are done with current channel globals
    //
    UNLOCK_CURRENT_CHANNEL();
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE_LOUD, KdPrint(("SAC TimerDpcRoutine: Exiting.\n")));

    return;
}


VOID
ConMgrProcessInputLine(
    VOID
    )
/*++

Routine Description:

    This routine is called to process an input line.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HEADLESS_CMD_DISPLAY_LOG Command;
    PUCHAR          InputLine;
    BOOLEAN         CommandFound = FALSE;

    InputLine = &(InputBuffer[0]);

    do {

        if (!strcmp((LPSTR)InputLine, TLIST_COMMAND_STRING)) {
            DoTlistCommand();
            CommandFound = TRUE;
            break;
        } 
        
        if ((!strcmp((LPSTR)InputLine, HELP1_COMMAND_STRING)) ||
            (!strcmp((LPSTR)InputLine, HELP2_COMMAND_STRING))) {
            DoHelpCommand();
            CommandFound = TRUE;
            break;
        } 
        
        if (!strcmp((LPSTR)InputLine, DUMP_COMMAND_STRING)) {

            NTSTATUS    Status;

            Command.Paging = GlobalPagingNeeded;

            Status = HeadlessDispatch(
                HeadlessCmdDisplayLog,
                &Command,
                sizeof(HEADLESS_CMD_DISPLAY_LOG),
                NULL,
                NULL
                );

            if (! NT_SUCCESS(Status)) {

                IF_SAC_DEBUG(
                    SAC_DEBUG_FAILS, 
                    KdPrint(("SAC Display Log failed.\n"))
                    );

            }

            CommandFound = TRUE;
            break;
        } 
        
        if (!strcmp((LPSTR)InputLine, FULLINFO_COMMAND_STRING)) {
            DoFullInfoCommand();
            CommandFound = TRUE;
            break;
        } 
        
        if (!strcmp((LPSTR)InputLine, PAGING_COMMAND_STRING)) {
            DoPagingCommand();
            CommandFound = TRUE;
            break;
        } 
        
        if (!strncmp((LPSTR)InputLine, 
                            CHANNEL_COMMAND_STRING, 
                            strlen(CHANNEL_COMMAND_STRING))) {
            ULONG   Length;

            Length = (ULONG)strlen(CHANNEL_COMMAND_STRING);

            if (((strlen((LPSTR)InputLine) > 1) && (InputLine[Length] == ' ')) ||
                (strlen((LPSTR)InputLine) == strlen(CHANNEL_COMMAND_STRING))) {
                DoChannelCommand(InputLine);
                CommandFound = TRUE;
                break;
            }
        } 
        
        if (!strcmp((LPSTR)InputLine, CMD_COMMAND_STRING)) {

#if ENABLE_CMD_SESSION_PERMISSION_CHECKING

            //
            // If we are not able to launch cmd sessions,
            // then notify that we cannot peform this action
            //
            if (IsCommandConsoleLaunchingEnabled()) {
                DoCmdCommand(InputLine);
            } else {

                //
                // Notify the user
                //
                SacPutSimpleMessage(SAC_CMD_LAUNCHING_DISABLED);

            }

#else 

            DoCmdCommand(InputLine);

#endif

            CommandFound = TRUE;
            break;
        } 
        
        if (!strcmp((LPSTR)InputLine, REBOOT_COMMAND_STRING)) {
            //
            // Set the reboot flag so that when we exit the serial consumer
            // we know to reboot the computer.  This way, the reboot
            // command is executed when we dont have the Current Channel mutex
            //
            ExecutePostConsumerCommand = Reboot;
            CommandFound = TRUE;
            break;
        } 
        
        if (!strcmp((LPSTR)InputLine, SHUTDOWN_COMMAND_STRING)) {
            //
            // Set the shutdown flag so that when we exit the serial consumer
            // we know to shutdown the computer.  This way, the shutdown
            // command is executed when we dont have the Current Channel mutex
            //
            ExecutePostConsumerCommand = Shutdown;
            CommandFound = TRUE;
            break;
        } 
        
        if (!strcmp((LPSTR)InputLine, CRASH_COMMAND_STRING)) {
            CommandFound = TRUE;
            DoCrashCommand(); // this call does not return
            break;
        } 
        
        if (!strncmp((LPSTR)InputLine, 
                            KILL_COMMAND_STRING, 
                            sizeof(KILL_COMMAND_STRING) - sizeof(UCHAR))) {
            if (((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) ||
                 (strlen((LPSTR)InputLine) == 1)
                ) {
                DoKillCommand(InputLine);
                CommandFound = TRUE;
                break;
            }
        
        } 

#if ENABLE_CHANNEL_LOCKING
        if (!strcmp((LPSTR)InputLine, LOCK_COMMAND_STRING)) {
            DoLockCommand();
            CommandFound = TRUE;
            break;
        } 
#endif    
        
        if (!strncmp((LPSTR)InputLine, 
                            LOWER_COMMAND_STRING, 
                            sizeof(LOWER_COMMAND_STRING) - sizeof(UCHAR))) {
            if (((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) ||
                (strlen((LPSTR)InputLine) == 1)
                ) {
                DoLowerPriorityCommand(InputLine);
                CommandFound = TRUE;
                break;
            }
        } 
        
        if (!strncmp((LPSTR)InputLine, 
                            RAISE_COMMAND_STRING, 
                            sizeof(RAISE_COMMAND_STRING) - sizeof(UCHAR))) {
            if (((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) ||
                (strlen((LPSTR)InputLine) == 1)
                ) {
                DoRaisePriorityCommand(InputLine);
                CommandFound = TRUE;
                break;
            }
        } 
        
        if (!strncmp((LPSTR)InputLine, 
                            LIMIT_COMMAND_STRING, 
                            sizeof(LIMIT_COMMAND_STRING) - sizeof(UCHAR))) {
            if (((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) ||
                (strlen((LPSTR)InputLine) == 1)
                ) {
                DoLimitMemoryCommand(InputLine);
                CommandFound = TRUE;
                break;
            }
        } 
        
        if (!strncmp((LPSTR)InputLine, 
                            TIME_COMMAND_STRING, 
                            sizeof(TIME_COMMAND_STRING) - sizeof(UCHAR))) {
            if (((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) ||
                (strlen((LPSTR)InputLine) == 1)
                ) {
                DoSetTimeCommand(InputLine);
                CommandFound = TRUE;
                break;
            }
        } 
        
        if (!strcmp((LPSTR)InputLine, INFORMATION_COMMAND_STRING)) {
            DoMachineInformationCommand();
            CommandFound = TRUE;
            break;
        }
        
        if (!strncmp((LPSTR)InputLine, 
                            SETIP_COMMAND_STRING, 
                            sizeof(SETIP_COMMAND_STRING) - sizeof(UCHAR))) {
            if (((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) ||
                (strlen((LPSTR)InputLine) == 1)
                ) {
                DoSetIpAddressCommand(InputLine);
                CommandFound = TRUE;
                break;
            }
        }
        
        if ((InputLine[0] == '\n') || (InputLine[0] == '\0')) {
            CommandFound = TRUE;
        }
    
    } while ( FALSE );

    if( !CommandFound ) {
        //
        // We don't know what this is.
        //
        SacPutSimpleMessage(SAC_UNKNOWN_COMMAND);
    }
        
}

//
// Utility routines for writing to the SAC
//


VOID
ConMgrEventMessageHaveLock(
    IN PCWSTR   String
    )
/*++

Routine Description:

    This routine is for callers that want to deploy an event
    message and already own the Current Channel Lock.
    
Arguments:

    String                  - The string to display.

Return Value:

        None.

--*/
{

    //
    // Currently, event messages are sent to the SAC channel
    //
    
    SacPutString(String);

}

VOID
ConMgrEventMessage(
    IN PCWSTR   String,
    IN BOOLEAN  HaveCurrentChannelLock
    )

/*++

Routine Description:

    This routine deploys an event message 
    
Arguments:

    String      - The string to display.
    HaveLock    - Whether or not the caller currently owns the Current Channel Lock

Return Value:

        None.

--*/
{

    //
    // Currently, event messages are sent to the SAC channel
    //
    
    if (! HaveCurrentChannelLock) {
        LOCK_CURRENT_CHANNEL();
    }

    SacPutSimpleMessage(SAC_ENTER);
    ConMgrEventMessageHaveLock(String);
    SacPutSimpleMessage(SAC_PROMPT);

    if (! HaveCurrentChannelLock) {
        UNLOCK_CURRENT_CHANNEL();
    }

}

BOOLEAN
ConMgrSimpleEventMessage(
    IN ULONG    MessageId,
    IN BOOLEAN  HaveCurrentChannelLock
    )
/*++

Routine Description:

    This routine retrieves a message resource and sends it as an event message
    
Arguments:

    MessageId   - The message id of the resource to send

Return Value:

    TRUE - the message was found
    otherwise, FALSE

--*/
{
    PCWSTR   p;

    p = GetMessage(MessageId);
       
    if (p) {
        ConMgrEventMessage(
            p,
            HaveCurrentChannelLock
            );        
        return(TRUE);
    }
    
    return(FALSE);

}

VOID
SacPutString(
    PCWSTR  String
    )
/*++

Routine Description:

    This routine takes a string and packages it into a command structure for the
    HeadlessDispatch routine.

Arguments:

    String - The string to display.

Return Value:

        None.

--*/
{
    NTSTATUS    Status;

    ASSERT(FIELD_OFFSET(HEADLESS_CMD_PUT_STRING, String) == 0);  // ASSERT if anyone changes this structure.
    
    //
    // Write the to the sac channel
    //
    Status = ChannelOWrite(
        SacChannel, 
        (PCUCHAR)String,
        (ULONG)(wcslen(String)*sizeof(WCHAR))
        );
    
    if (! NT_SUCCESS(Status)) {

        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC XmlMgrSacPutString: OWrite failed\n"))
            );

    }
    
}

BOOLEAN
SacPutSimpleMessage(
    ULONG MessageId
    )
/*++

Routine Description:

    This routine retrieves a message resource and sends it to the SAC channel
    
Arguments:

    MessageId   - The message id of the resource to send

Return Value:

    TRUE - the message was found
    otherwise, FALSE

--*/
{
    PCWSTR   p;

    p = GetMessage(MessageId);
       
    if (p) {
        SacPutString(p);        
        return(TRUE);
    }
    
    return(FALSE);

}

NTSTATUS
ConMgrChannelOWrite(
    IN PSAC_CHANNEL             Channel,
    IN PSAC_CMD_WRITE_CHANNEL   ChannelWriteCmd
    )
/*++

Routine Description:

    This routine attempts to write data to a channel

Arguments:

    Channel         - the channel to write to
    ChannelWriteCmd - the write IOCTL command structure

Return Value:

    Status

--*/
{
    NTSTATUS            Status;

    //
    //
    //
    LOCK_CURRENT_CHANNEL();

    //
    // Write the data to the channel's output buffer
    //
    Status = ChannelOWrite(
        Channel, 
        &(ChannelWriteCmd->Buffer[0]),
        ChannelWriteCmd->Size
        );

    //
    //
    //
    UNLOCK_CURRENT_CHANNEL();

    ASSERT(NT_SUCCESS(Status) || Status == STATUS_NOT_FOUND);

    return Status;

}

NTSTATUS
ConMgrGetChannelCloseMessage(
    IN  PSAC_CHANNEL    Channel,
    IN  NTSTATUS        CloseStatus,
    OUT PWSTR*          OutputBuffer
    )
/*++

Routine Description:

    This routine constructs an event message based
    on the status of attempting to close a channel

Arguments:

    Channel         - the channel being closed
    CloseStatus     - the resulting status
    OutputBuffer    - on exit, contains the message

Return Value:

    Status

--*/
{
    NTSTATUS    Status;
    ULONG       Size;
    PWSTR       Name;
    PCWSTR      Message;

    //
    // default: we succeded
    //
    Status = STATUS_SUCCESS;

    do {

        //
        // Get the channel's name
        //
        Status = ChannelGetName(
            Channel,
            &Name
            );

        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // Allocate a local temp buffer for display
        //

        if (NT_SUCCESS(CloseStatus)) {

            //
            // get the string resource
            //
            Message = GetMessage(SAC_CHANNEL_CLOSED);
            
            if (Message == NULL) {
                Status = STATUS_RESOURCE_DATA_NOT_FOUND;
                break;
            }

            //
            // Allocate the buffer memory
            //
            Size = (ULONG)((wcslen(Message) + SAC_MAX_CHANNEL_NAME_LENGTH + 1) * sizeof(WCHAR));
            *OutputBuffer = ALLOCATE_POOL(Size, GENERAL_POOL_TAG);
            ASSERT_STATUS(*OutputBuffer, STATUS_NO_MEMORY);
            
            //
            // report the channel has been closed
            //
            SAFE_SWPRINTF(
                Size,
                (*OutputBuffer, 
                 Message, 
                 Name
                ));

        } else if (CloseStatus == STATUS_ALREADY_DISCONNECTED) {

            //
            // get the string resource
            //
            Message = GetMessage(SAC_CHANNEL_ALREADY_CLOSED);
            
            if (Message == NULL) {
                Status = STATUS_RESOURCE_DATA_NOT_FOUND;
                break;
            }
            
            //
            // Allocate the buffer memory
            //
            Size = (ULONG)((wcslen(Message) + SAC_MAX_CHANNEL_NAME_LENGTH + 1) * sizeof(WCHAR));
            *OutputBuffer = ALLOCATE_POOL(Size, GENERAL_POOL_TAG);
            ASSERT_STATUS(*OutputBuffer, STATUS_NO_MEMORY);
            
            //
            // report the channel was already closed
            //
            SAFE_SWPRINTF(
                Size,
                (*OutputBuffer, 
                 Message, 
                 Name
                ));

        } else {

            //
            // get the string resource
            //
            Message = GetMessage(SAC_CHANNEL_FAILED_CLOSE);
            
            if (Message == NULL) {
                Status = STATUS_RESOURCE_DATA_NOT_FOUND;
                break;
            }
            
            //
            // Allocate the buffer memory
            //
            Size = (ULONG)((wcslen(Message) + SAC_MAX_CHANNEL_NAME_LENGTH + 1) * sizeof(WCHAR));
            *OutputBuffer = ALLOCATE_POOL(Size, GENERAL_POOL_TAG);
            ASSERT_STATUS(*OutputBuffer, STATUS_NO_MEMORY);
            
            //
            // report that we failed to close the channel 
            //
            SAFE_SWPRINTF(
                Size,
                (*OutputBuffer, 
                 Message, 
                 Name
                ));

        }

        SAFE_FREE_POOL(&Name);
    
    } while ( FALSE );
    
    return Status;
}

NTSTATUS
ConMgrChannelClose(
    PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine attempts to close a channel. 
    If we successfully close the channel and this channel was 
    the current channel, we reset the current channel to the SAC channel

Arguments:

    Channel     - the channel to close

Return Value:

    STATUS_SUCCESS              - the channel was closed
    STATUS_ALREADY_DISCONNECTED - the channel was already closed
    otherwise, error status

--*/
{
    NTSTATUS        Status;

    //
    // default
    //
    Status = STATUS_SUCCESS;

    //
    // Attempt to make the specified channel inactive
    //
    do {

        //
        // The current channel is being closed, 
        // so reset the current channel to the SAC
        //
        // Note: disable this check if you don't want
        //       the conmgr to switch to the SAC channel
        //       when the current chanenl is closed.
        //
        if (ConMgrIsWriteEnabled(Channel)) {

            Status = ConMgrResetCurrentChannel(FALSE);

        }
        
    } while ( FALSE );
        
    ASSERT(NT_SUCCESS(Status));
    
    return Status;
}

NTSTATUS
ConMgrHandleEvent(
    IN IO_MGR_EVENT     Event,
    IN PSAC_CHANNEL     Channel,    OPTIONAL
    IN PVOID            Data        OPTIONAL
    )
/*++

Routine Description:

    This is the Console Manager's IoMgrHandleEvent implementation.
    
    This routine handles asynchronous events that effect
    the channels, the console manager and the SAC driver as a whole.

    Note that this routine only handles events that are important for
    the proper operation of the console manager.  Hence, not all 
    possible events that can happen in the SAC driver are here.  

Arguments:

    ChannelWriteCmd - the write IOCTL command structure
    Channel         - Optional: the channel the event is targeted at
    Data            - Optional: data for the specified event

Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    switch(Event) {
    case IO_MGR_EVENT_CHANNEL_CREATE: {

        PWCHAR          OutputBuffer;
        ULONG           Size;
        PWSTR           Name;
        PCWSTR          Message;

        ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_2);
        
        //
        // get the string resource
        //
        Message = GetMessage(SAC_NEW_CHANNEL_CREATED);

        if (Message == NULL) {
            Status = STATUS_RESOURCE_DATA_NOT_FOUND;
            break;
        }

        //
        // Determine the size of the string buffer
        //
        Size = (ULONG)((wcslen(Message) + SAC_MAX_CHANNEL_NAME_LENGTH + 1) * sizeof(WCHAR));
        
        //
        // Allocate the buffer
        //
        OutputBuffer = ALLOCATE_POOL(Size, GENERAL_POOL_TAG);
        ASSERT_STATUS(OutputBuffer, STATUS_NO_MEMORY);
        
        do {

            //
            // Get the channel's name
            //
            Status = ChannelGetName(
                Channel,
                &Name
                );

            if (! NT_SUCCESS(Status)) {
                break;
            }

            //
            // Notify the SAC that a channel was created
            // 
            SAFE_SWPRINTF(
                Size,
                (OutputBuffer, 
                Message, 
                Name
                ));

            FREE_POOL(&Name);

            ConMgrEventMessage(OutputBuffer, FALSE);
        
        } while ( FALSE );
        
        FREE_POOL(&OutputBuffer);

        break;
    
    }

    case IO_MGR_EVENT_CHANNEL_CLOSE: {
    
        PWCHAR  OutputBuffer;

        OutputBuffer = NULL;

        ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_2);
        ASSERT_STATUS(Data, STATUS_INVALID_PARAMETER_3);

        //
        // We need to lock down current channel globals
        // in case we need to close the current channel
        // which will result in the resetting of the 
        // current channel to the SAC channel.
        //
        LOCK_CURRENT_CHANNEL();

        //
        // Perform the console mgrs close channel response
        //
        ConMgrChannelClose(Channel);

        //
        // get the channel close status message
        // using the status sent in by the channel
        // manager when it tried to close the channel.
        //
        Status = ConMgrGetChannelCloseMessage(
            Channel,
            *((NTSTATUS*)Data),
            &OutputBuffer
            );

        if (NT_SUCCESS(Status)) {

            //
            // Display the message
            //
            ConMgrEventMessage(OutputBuffer, TRUE);

            //
            // cleanup
            //
            SAFE_FREE_POOL(&OutputBuffer);

        }

        //
        // We are done with the current channel globals
        //
        UNLOCK_CURRENT_CHANNEL();

        break;
    }

    case IO_MGR_EVENT_CHANNEL_WRITE:
        
        Status = ConMgrChannelOWrite(
            Channel,
            (PSAC_CMD_WRITE_CHANNEL)Data
            );
        
        break;

    case IO_MGR_EVENT_REGISTER_SAC_CMD_EVENT:
        
        Status = ConMgrSimpleEventMessage(SAC_CMD_SERVICE_REGISTERED, FALSE) ? 
            STATUS_SUCCESS :
            STATUS_UNSUCCESSFUL;
        
        break;

    case IO_MGR_EVENT_UNREGISTER_SAC_CMD_EVENT:
        
        Status = ConMgrSimpleEventMessage(SAC_CMD_SERVICE_UNREGISTERED, FALSE) ? 
            STATUS_SUCCESS :
            STATUS_UNSUCCESSFUL;
        
        break;

    case IO_MGR_EVENT_SHUTDOWN:
        
        //
        // We need to lock down current channel globals
        // in case we need to close the current channel
        // which will result in the resetting of the 
        // current channel to the SAC channel.
        //
        LOCK_CURRENT_CHANNEL();
        
        //
        // Send the event message to the SAC
        //
        Status = ConMgrSimpleEventMessage(SAC_SHUTDOWN, TRUE) ? 
            STATUS_SUCCESS :
            STATUS_UNSUCCESSFUL;
        
        //
        // switch to the SAC channel if it is not the current channel
        //
        if (SacChannel != CurrentChannel) {

            //
            // switch directly to the SAC channel so the user
            // can see that the system is shutting down
            //
            ConMgrResetCurrentChannel(TRUE);

        }
        
        //
        // We are done with the current channel globals
        //
        UNLOCK_CURRENT_CHANNEL();
        
        break;

    default:

        Status = STATUS_INVALID_PARAMETER_1;

        break;
    }

    return Status;

}

NTSTATUS
ConMgrWriteData(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    )
/*++

Routine Description:

    This is the Console Manager's IoMgrWriteData implementation.
    
    This routine takes the channel's data buffer and 
    sends it to the headless port.  

    Note: The channel sending the data should only call this function
          if they received a TRUE from the IoMgrIsWriteEnabled.  In
          the console manager's implementation, the channel only receives
          TRUE if the current channel lock is held for this channel.  This
          is how the virtual terminal scheme works.
                                         
Arguments:

    Channel     - The channel sending the data   
    Buffer      - The data to be written to the headless port
    BufferSize  - The size in bytes of the data to be written
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;
    ULONG       Attempts;

    //
    // default: we were successful
    //
    Status = STATUS_SUCCESS;

    //
    // We don't use teh channel structure in this implementation
    //
    UNREFERENCED_PARAMETER(Channel);

    //
    // default: we have made 0 attempts
    //
    Attempts = 0;

    do {

        //
        // We are making another attempt
        //
        Attempts++;

        //
        // Attempt to write
        //
        Status = HeadlessDispatch(
            HeadlessCmdPutData,
            (PUCHAR)Buffer,
            BufferSize,
            NULL,
            NULL
            );

        //
        // If we have made enough attempts to write,
        // then don't attempt again, just return status.
        //
        if (Attempts > MAX_HEADLESS_DISPATCH_ATTEMPTS) {
            break;    
        }

        //
        // If the HeadlessDispatch was unsuccessful,
        // this means it was still processing another command,
        // so delay for a short period and try again.
        //
        if (Status == STATUS_UNSUCCESSFUL) {

            LARGE_INTEGER   WaitTime;

            //
            // Define a delay of 10 ms
            //
            WaitTime.QuadPart = Int32x32To64((LONG)1, -100000); 

            //
            // Wait...
            //
            KeDelayExecutionThread(KernelMode, FALSE, &WaitTime);

        }

    } while ( Status == STATUS_UNSUCCESSFUL );

    //
    // Catch any HeadlessDispatch failures
    //
    ASSERT(NT_SUCCESS(Status));

    return Status;

}

NTSTATUS
ConMgrFlushData(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This is the Console Manager's IoMgrFlushData implementation.
    
    This routine completes the write data operation for a channel's
    previous write data calls.  For instance, if they console manager
    were packet based - that is, it formed packets when we wrote data,
    this function would tell the console manager to complete the packet
    and send it, rather than wait for more data.
    
Arguments:

    Channel     - The channel sending the data   
    
Return Value:

    Status

--*/
{

    UNREFERENCED_PARAMETER(Channel);

    NOTHING;

    return STATUS_SUCCESS;

}

BOOLEAN
ConMgrIsSacChannel(
    IN PSAC_CHANNEL Channel
)
/*++

Routine Description:

    This routine determines if the specified channel is a SAC channel       
       
Arguments:

    Channel - The channel to compare
                                                                     
Return Value:

    TRUE    - the channel is a SAC channel
    FALSE   - otherwise

--*/
{
    return (Channel == SacChannel) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\conmgr.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    conmgr.h

Abstract:

    Routines for managing channels.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#ifndef CON_MGR_H
#define CON_MGR_H

//
//
//
typedef enum {
    Nothing,
    Shutdown,
    CloseChannel,
    Reboot
} EXECUTE_POST_CONSUMER_COMMAND_ENUM;
    
extern EXECUTE_POST_CONSUMER_COMMAND_ENUM  ExecutePostConsumerCommand;
extern PVOID                               ExecutePostConsumerCommandData;

//
// Commands
//
#define HELP1_COMMAND_STRING            "?"
#define HELP2_COMMAND_STRING            "help"
#define EXTENDED_HELP_SUBCOMMAND        "-?"
#define CRASH_COMMAND_STRING            "crashdump"
#define CHANNEL_COMMAND_STRING                  "ch"
#define CHANNEL_CLOSE_NAME_COMMAND_STRING       "-cn"
#define CHANNEL_CLOSE_INDEX_COMMAND_STRING      "-ci"
#if ENABLE_KILL_COMMAND
#define CHANNEL_KILL_COMMAND_STRING             "-k"
#endif
#define CHANNEL_SWITCH_NAME_COMMAND_STRING      "-sn"
#define CHANNEL_SWITCH_INDEX_COMMAND_STRING     "-si"
#define CHANNEL_LIST_COMMAND_STRING             "-l"
#define CMD_COMMAND_STRING              "cmd"
#define DUMP_COMMAND_STRING             "d"
#define FULLINFO_COMMAND_STRING         "f"
#define SETIP_COMMAND_STRING            "i"
#define INFORMATION_COMMAND_STRING      "id"
#define KILL_COMMAND_STRING             "k"
#define LOWER_COMMAND_STRING            "l"
#define LOCK_COMMAND_STRING             "lock"
#define LOWER_COMMAND_STRING            "l"
#define LIMIT_COMMAND_STRING            "m"
#define PAGING_COMMAND_STRING           "p"
#define RAISE_COMMAND_STRING            "r"
#define REBOOT_COMMAND_STRING           "restart"
#define TIME_COMMAND_STRING             "s"
#define SHUTDOWN_COMMAND_STRING         "shutdown"
#define TLIST_COMMAND_STRING            "t"

//
// prototypes
//
NTSTATUS
ConMgrInitialize(
    VOID
    );

NTSTATUS
ConMgrShutdown(
    VOID
    );


NTSTATUS
ConMgrSetCurrentChannel(
    IN PSAC_CHANNEL CurrentChannel
    );

NTSTATUS
ConMgrAdvanceCurrentChannel(
    VOID
    );

NTSTATUS
ConMgrDisplayCurrentChannel(
    VOID
    );

BOOLEAN
ConMgrIsWriteEnabled(
    PSAC_CHANNEL    Channel
    );

BOOLEAN
SacPutSimpleMessage(
    ULONG MessageId
    );

VOID
SacPutString(
    PCWSTR  String
    );

VOID
ConMgrTimerDpcRoutine(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
ConMgrWorkerProcessEvents(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );

NTSTATUS
ConMgrHandleEvent(
    IN IO_MGR_EVENT Event,
    IN PSAC_CHANNEL Channel,
    IN PVOID        Data
    );

VOID
ConMgrEventMessageHaveLock(
    IN PCWSTR   String
    );

VOID
ConMgrEventMessage(
    IN PCWSTR   String,
    IN BOOLEAN  HaveCurrentChannelLock
    );

BOOLEAN
ConMgrSimpleEventMessage(
    IN ULONG    MessageId,
    IN BOOLEAN  HaveCurrentChannelLock
    );

NTSTATUS
ConMgrChannelClose(
    IN PSAC_CHANNEL    Channel
    );

NTSTATUS
ConMgrGetChannelCloseMessage(
    IN  PSAC_CHANNEL    Channel,
    IN  NTSTATUS        CloseStatus,
    OUT PWSTR*          OutputBuffer
    );

NTSTATUS
ConMgrWriteData(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
ConMgrFlushData(
    IN PSAC_CHANNEL Channel
    );

BOOLEAN
ConMgrIsSacChannel(
    IN PSAC_CHANNEL Channel
);

NTSTATUS
ConMgrDisplayFastChannelSwitchingInterface(
    PSAC_CHANNEL    Channel
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\concmd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cmd.c

Abstract:

    This module contains the routines for handling each command.

Author:

    Sean Selitrennikoff (v-seans) - Dec 2, 1999
    Brian Guarraci (briangu)

Revision History:

--*/

#include "sac.h"
#include <ntddip.h>
#include <ntddtcp.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <stdlib.h>

#include "iomgr.h"

#define SAC_PUT_ERROR_STRING(_Status)\
    swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR ) , _Status); \
    SacPutString((PWSTR)GlobalBuffer);


//
// Forward declarations.
//
NTSTATUS
GetTListInfo(
    OUT PSAC_RSP_TLIST ResponseBuffer,
    IN  LONG ResponseBufferSize,
    OUT PULONG ResponseDataSize
    );

VOID
PrintTListInfo(
    IN PSAC_RSP_TLIST Buffer
    );

VOID
PutMore(
    OUT PBOOLEAN Stop
    );

VOID
DoGetNetInfo(
    IN BOOLEAN PrintToTerminal
    );
    
VOID
NetAPCRoutine(IN PVOID ApcContext,
              IN PIO_STATUS_BLOCK IoStatusBlock,
              IN ULONG Reserved
              );

NTSTATUS 
CallQueryIPIOCTL(
    HANDLE IpDeviceHandle,
    PKEVENT Event,
    HANDLE EventHandle,
    IO_STATUS_BLOCK *IoStatusBlock,
    PVOID  InputBuffer,
    ULONG  InputBufferSize,
    PVOID  OutputBuffer,
    ULONG  OutputBufferSize,
    BOOLEAN PrintToTerminal,
    BOOLEAN *putPrompt
    );

//
// The purpose of this macro is to provide implicit "more-ing"
// when printing arbitrarily localized text.
//
#define SAC_PRINT_WITH_MORE(_m)\
{                                                   \
    ULONG   c;                                      \
    BOOLEAN Stop;                                   \
    c = GetMessageLineCount(_m);                    \
    if ((c + LineNumber) > SAC_VTUTF8_ROW_HEIGHT) { \
        PutMore(&Stop);                             \
        if (Stop) {                                 \
            break;                                  \
        }                                           \
        LineNumber = 0;                             \
    }                                               \
    SacPutSimpleMessage( _m );                      \
    LineNumber += c;                                \
}

VOID
DoHelpCommand(
    VOID
    )

/*++

Routine Description:

    This routine displays the help text on the terminal.

Arguments:

    None.

Return Value:

        None.

--*/
{
    ULONG   LineNumber;

    LineNumber = 0;

    do {

        SAC_PRINT_WITH_MORE(SAC_HELP_CH_CMD);
        SAC_PRINT_WITH_MORE( SAC_HELP_CMD_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_D_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_F_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_HELP_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_I1_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_I2_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_IDENTIFICATION_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_K_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_L_CMD );
#if ENABLE_CHANNEL_LOCKING
        SAC_PRINT_WITH_MORE( SAC_HELP_LOCK_CMD );
#endif    
        SAC_PRINT_WITH_MORE( SAC_HELP_M_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_P_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_R_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_S1_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_S2_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_T_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_RESTART_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_SHUTDOWN_CMD );
        SAC_PRINT_WITH_MORE( SAC_HELP_CRASHDUMP1_CMD );
    
    } while ( FALSE );

}


VOID
DoFullInfoCommand(
    VOID
    )

/*++

Routine Description:

    This routine toggles on and off full thread information on tlist.

Arguments:

    None.

Return Value:

        None.

--*/
{
    GlobalDoThreads = (BOOLEAN)!GlobalDoThreads;

    if (GlobalDoThreads) {
        SacPutSimpleMessage(SAC_THREAD_ON);
    } else {
        SacPutSimpleMessage(SAC_THREAD_OFF);
    }
}

VOID
DoPagingCommand(
    VOID
    )

/*++

Routine Description:

    This routine toggles on and off paging information on tlist.

Arguments:

    None.

Return Value:

        None.

--*/
{
    GlobalPagingNeeded = (BOOLEAN)!GlobalPagingNeeded;
    
    if (GlobalPagingNeeded) {
        SacPutSimpleMessage(SAC_PAGING_ON);
    } else {
        SacPutSimpleMessage(SAC_PAGING_OFF);
    }
}

VOID
DoSetTimeCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine sets the current system time.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    TIME_FIELDS TimeFields;
    LARGE_INTEGER Time;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (1).\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }

    RtlZeroMemory(&TimeFields, sizeof(TIME_FIELDS));

    //
    // Skip the command.
    //
    pch += (sizeof(TIME_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (*pch == '\0') {

        //
        // This is a display time request.
        //
        Status = ZwQuerySystemInformation(SystemTimeOfDayInformation,
                                          &TimeOfDay,
                                          sizeof(TimeOfDay),
                                          NULL
                                         );

        if (!NT_SUCCESS(Status)) {
            SAC_PUT_ERROR_STRING(Status);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (2).\n")));
            return;
        }

        RtlTimeToTimeFields(&(TimeOfDay.CurrentTime), &TimeFields);

        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_DATETIME_FORMAT ),
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                TimeFields.Milliseconds
               );

        SacPutString((PWSTR)GlobalBuffer);
        return;
    }

    pchTmp = pch;
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (3).\n")));
        return;
    }

    //
    // Skip all the numbers.
    //
    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);


    //
    // If there is something other than the divider, it is a mal-formed line.
    //
    if (*pchTmp != '/') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (4).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Month = (USHORT)(atoi((LPCSTR)pch));

    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (4b).\n")));
        return;
    }

    //
    // Skip all the numbers.
    //
    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    //
    // If there is something other than the divider, it is a mal-formed line.
    //
    if (*pchTmp != '/') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (5).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Day = (USHORT)(atoi((LPCSTR)pch));

    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (5b).\n")));
        return;
    }

    //
    // Skip all the numbers.
    //
    SKIP_NUMBERS(pchTmp);

    //
    // If there is something other than whitespace, it is a mal-formed line.
    //
    if (!IS_WHITESPACE(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (6).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Year = (USHORT)(atoi((LPCSTR)pch));

    if ((TimeFields.Year < 1980) || (TimeFields.Year > 2099)) {
        SacPutSimpleMessage(SAC_DATETIME_LIMITS);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (6b).\n")));
        return;
    }

    pch = pchTmp;

    //
    // Skip to the hours
    //
    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (7).\n")));
        return;
    }

    pch = pchTmp;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != ':') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (8).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Hour = (USHORT)(atoi((LPCSTR)pch));

    pch = pchTmp;

    //
    // Verify nothing else on the line but numbers
    //
    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (8a).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (8b).\n")));
        return;
    }

    //
    // Get the minutes.
    //
    TimeFields.Minute = (USHORT)(atoi((LPCSTR)pch));

    if (!RtlTimeFieldsToTime(&TimeFields, &Time)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (9).\n")));
        return;
    }

    Status = ZwSetSystemTime(&Time, NULL);

    if (!NT_SUCCESS(Status)) {
        sprintf((LPSTR)GlobalBuffer, "Failed with status 0x%X.\r\n", Status);
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (10).\n")));
        return;
    }

    swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_DATETIME_FORMAT2 ),    
            TimeFields.Month,
            TimeFields.Day,
            TimeFields.Year,
            TimeFields.Hour,
            TimeFields.Minute
           );
    SacPutString((PWSTR)GlobalBuffer);
    return;
}
BOOLEAN
RetrieveIpAddressFromString(
    IN  PUCHAR  InputString,
    OUT PULONG  IPAddress
    )
/*++

Routine Description:

    This routine parses through a string and digs
    out the 32-bit IP address.

Arguments:

    InputString - The users input line to parse.
    
    IPAddress - Holds the 32-bit IP address when we're done.

Return Value:

    TRUE - We successfully retrieved an IP address.
    
    FALSE - We failed.  Input was probably bad.

--*/
{
    ULONG       TmpValue = 0;
    UCHAR       TmpChar;
    PUCHAR      pchTmp, pch;



    //
    // Init
    //
    if( (InputString == NULL) ||
        (IPAddress == NULL) ) {
        return FALSE;
    }

    *IPAddress = 0;


    //
    // Skip ahead to the divider and make it a \0.
    //
    pchTmp = InputString;
    pch = InputString;
    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (1).\n")));
        return FALSE;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (1a).\n")));
        return FALSE;
    }

    TmpChar = *pchTmp;
    *pchTmp = '\0';


    //
    // Now get the digits this side of the divider.
    //
    TmpValue = atoi((LPCSTR)pch);
    *pchTmp = TmpChar;
    pchTmp++;

    if( TmpValue > 255 ) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (1b).\n")));
        return FALSE;
    }
    *IPAddress = TmpValue;

    //
    // Get 2nd part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (1c).\n")));
        return FALSE;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (1d).\n")));
        return FALSE;
    }

    TmpChar = *pchTmp;
    *pchTmp = '\0';

    TmpValue = atoi((LPCSTR)pch);
    *pchTmp = TmpChar;
    pchTmp++;

    if( TmpValue > 255 ) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (1e).\n")));
        return FALSE;
    }
    *IPAddress |= (TmpValue << 8);

    //
    // Get 3rd part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (2a).\n")));
        return FALSE;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (2b).\n")));
        return FALSE;
    }

    TmpChar = *pchTmp;
    *pchTmp = '\0';

    TmpValue = atoi((LPCSTR)pch);
    *pchTmp = TmpChar;
    pchTmp++;

    if( TmpValue > 255 ) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (2c).\n")));
        return FALSE;
    }
    *IPAddress |= (TmpValue << 16);

    //
    // Get 4th part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (2d).\n")));
        return FALSE;
    }

    SKIP_NUMBERS(pchTmp);

    TmpChar = *pchTmp;
    *pchTmp = '\0';

    TmpValue = atoi((LPCSTR)pch);
    *pchTmp = TmpChar;
    pchTmp++;

    if( TmpValue > 255 ) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC RetrieveIpAddressFromString: Exiting (2f).\n")));
        return FALSE;
    }
    *IPAddress |= (TmpValue << 24);


    return TRUE;

}

VOID
DoSetIpAddressCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine sets the IP address and subnet mask.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PUCHAR              pch = InputLine;
    PUCHAR              pchTmp;
    HANDLE              Handle = 0;
    HANDLE              EventHandle = 0;
    ULONG               IpAddress;
    ULONG               SubnetMask;
    ULONG               GatewayAddress;
    ULONG               NetworkNumber;
    LARGE_INTEGER       TimeOut;
    IO_STATUS_BLOCK     IoStatusBlock;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    PIP_SET_ADDRESS_REQUEST IpRequest;
    IPRouteEntry        *RouteEntry = NULL;
    ULONG               i, j;
    PTCP_REQUEST_QUERY_INFORMATION_EX TcpRequestQueryInformationEx = NULL;
    PTCP_REQUEST_SET_INFORMATION_EX TcpRequestSetInformationEx = NULL;
    IPAddrEntry         *AddressArray = NULL;
    IPSNMPInfo          *IpsiInfo = NULL;
    BOOLEAN             putPrompt = FALSE;
    ULONG               InterfaceIndex;


    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (1).\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }

    //
    // Skip the command.
    //
    pch += (sizeof(SETIP_COMMAND_STRING) - sizeof(UCHAR));
    
    SKIP_WHITESPACE(pch);

    if (*pch == '\0') {       
        //
        // No other parameters, get the network numbers and their IP addresses.
        //
        DoGetNetInfo( TRUE );
        return;
    }

    //
    // Retrieve the network interface number they want to operate on.
    //
    pchTmp = pch;

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (1b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    
    if (!IS_WHITESPACE(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_NETWORK_INTERFACE_NUMBER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (1c).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;
    NetworkNumber = atoi((LPCSTR)pch);
    pch = pchTmp;

    //
    // Get the IP address.
    //
    if( !RetrieveIpAddressFromString( pchTmp, &IpAddress) ) {
        SacPutSimpleMessage(SAC_INVALID_IPADDRESS);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (2).\n")));
        return;
    }


    //
    // Jump over the IP address we just got and get
    // to the next bit of white space.  Then get the
    // subnet mask.
    //
    while( (*pchTmp != ' ') &&
           (*pchTmp != '\0') ) {
        pchTmp++;
    }
    SKIP_WHITESPACE(pchTmp);

    if( !RetrieveIpAddressFromString( pchTmp, &SubnetMask) ) {
        SacPutSimpleMessage(SAC_INVALID_SUBNETMASK);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (3).\n")));
        return;
    }

    //
    // We should validate the subnet mask is valid.  By that
    // we should check to make sure that there are no bits
    // set to the right of the first 0 bit we find.  In other
    // words, all 1's in the address should be in the most
    // significant bits and all the 0 bits should be in the
    // least signficant bits.
    //
    // The bytes are in LE order.  For example, an address 
    // of 255.255.248.0 turns into 00f8ffff.  Therefore, we
    // need to check each byte seperately.
    //
    putPrompt = FALSE;
    for (i = 0; i < 4; i++) {
        ULONG ByteValue;

        // isolate the next byte into the low-order 8 bits of ByteValue
        ByteValue = ((SubnetMask >> 8*i) & 0xFF);

        for (j = 0; j < 8; j++) {

            if( (ByteValue << j) & 0x80 ) {

                if( putPrompt == TRUE ) {
                    // this bit is set and we've already come across a 0.
                    SacPutSimpleMessage(SAC_INVALID_SUBNETMASK);
                    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (3a).\n")));
                    return;
                }
            } else {
                putPrompt = TRUE;
            }
        }
    }
    putPrompt = FALSE;


    //
    // Jump over the IP address we just got and get
    // to the next bit of white space.  Then get the
    // gateway.
    //
    while( (*pchTmp != ' ') &&
           (*pchTmp != '\0') ) {
        pchTmp++;
    }
    SKIP_WHITESPACE(pchTmp);

    if( !RetrieveIpAddressFromString( pchTmp, &GatewayAddress) ) {
        SacPutSimpleMessage(SAC_INVALID_GATEWAY_IPADDRESS);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (4).\n")));
        return;
    }




    //
    // In order to set the gateway, we need to get the iae_index value
    // from the data structure that holds the IP address and subnet mask.
    // The iae_index in turn will give us an index into the data structure
    // which contains the gateways.
    //
    // To do this, we need to get the list if IP addresses/subnet masks
    // and go through them, looking for the one with the interface
    // number the user has specified on the command line.  Once we
    // have the right structure, we need to remember the iae_index 
    // from that structure so we know which gateway value to set later.
    //
    
    //
    // Opening the TCP driver
    //
    RtlInitUnicodeString(&UnicodeString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                       );

    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_IPADDRESS_SET_FAILURE);
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: failed to open TCP device, ec = 0x%X\n",
                     Status)));
        goto DoSetIpAddressCommand_Exit;
    }


    //
    // Build a command to ask for the number of interfaces, then call the ioctl
    //
    TcpRequestQueryInformationEx = ALLOCATE_POOL( 
                                        sizeof(TCP_REQUEST_QUERY_INFORMATION_EX), 
                                        GENERAL_POOL_TAG );
    if (TcpRequestQueryInformationEx == NULL) {
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (5).\n")));
        Status = STATUS_NO_MEMORY;
        goto DoSetIpAddressCommand_Exit;
    }


    IpsiInfo = ALLOCATE_POOL( sizeof(IPSNMPInfo), 
                              GENERAL_POOL_TAG );

    if (IpsiInfo == NULL) {
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (6).\n")));
        Status = STATUS_NO_MEMORY;
        goto DoSetIpAddressCommand_Exit;
    }
    RtlZeroMemory(TcpRequestQueryInformationEx, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
    TcpRequestQueryInformationEx->ID.toi_id = IP_MIB_STATS_ID;
    TcpRequestQueryInformationEx->ID.toi_type = INFO_TYPE_PROVIDER;
    TcpRequestQueryInformationEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_instance = 0;
    
    Status = CallQueryIPIOCTL(
                   Handle,
                   SACEvent,
                   SACEventHandle,
                   &IoStatusBlock,
                   TcpRequestQueryInformationEx,
                   sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                   IpsiInfo,
                   sizeof(IPSNMPInfo),
                   FALSE,
                   &putPrompt);

    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_IPADDRESS_SET_FAILURE);
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: failed to query TCP device, ec = 0x%X\n",
                     Status)));
        goto DoSetIpAddressCommand_Exit;
    }

    if (IpsiInfo->ipsi_numaddr == 0) {
        SacPutSimpleMessage( SAC_IPADDR_NONE );
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (10).\n")));
        Status = STATUS_NO_MEMORY;
        goto DoSetIpAddressCommand_Exit;
    }


    //
    // Allocate space for the array of IP addresses
    //
    AddressArray = ALLOCATE_POOL(IpsiInfo->ipsi_numaddr*sizeof(IPAddrEntry), 
                                 GENERAL_POOL_TAG);
    if (AddressArray == NULL) {    
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));
        Status = STATUS_NO_MEMORY;
        goto DoSetIpAddressCommand_Exit;
    }

    //
    // zero out the context information and preload with the info we're gonna
    // request (we want information on each of the interfaces on this machine)
    //
    RtlZeroMemory(TcpRequestQueryInformationEx, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
    TcpRequestQueryInformationEx->ID.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    TcpRequestQueryInformationEx->ID.toi_type = INFO_TYPE_PROVIDER;
    TcpRequestQueryInformationEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_instance = 0;

    Status = CallQueryIPIOCTL(
                   Handle,
                   SACEvent,
                   SACEventHandle,
                   &IoStatusBlock,
                   TcpRequestQueryInformationEx,
                   sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                   AddressArray,
                   IpsiInfo->ipsi_numaddr*sizeof(IPAddrEntry),
                   FALSE,
                   &putPrompt);

    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_IPADDRESS_SET_FAILURE);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (20).\n")));        
        goto DoSetIpAddressCommand_Exit;
    }


    //
    // Now cycle through the list and figure out the context number of
    // the interface the user wants to set.  We need this so we can later
    // tell which context to apply the new gateway to.
    //
    InterfaceIndex = 0xFFFFFFFF;
    for (i = 0; i < IpsiInfo->ipsi_numaddr; i++) {
        if( (ULONG)(AddressArray[i].iae_context) == NetworkNumber ) {
            //
            // remember the index of this interface.
            //
            InterfaceIndex = AddressArray[i].iae_index;
            break;
        }
    }



    //
    // Get rid of the memory and handles that we don't need any longer.
    //
    FREE_POOL(&TcpRequestQueryInformationEx);
    FREE_POOL(&AddressArray);
    FREE_POOL(&IpsiInfo);    
    ZwClose(Handle);
    Handle = 0;


    if( InterfaceIndex == 0xFFFFFFFF ) {
        //
        // We couldn't find the NIC they're trying to talk to.
        //
        SacPutSimpleMessage(SAC_IPADDRESS_RETRIEVE_FAILURE);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (20).\n")));        
        return;
    }




    //
    // We now know which gateway entry they want to change.
    // We can now go update the ip address, subnet mask, and
    // gateway.
    //




    //
    // Setup notification event.  We'll use this in case the IOCTLs
    // tell us to wait while the address updates take place.
    //
    Status = NtCreateEvent(
                 &EventHandle,                      // EventHandle
                 EVENT_ALL_ACCESS,                  // DesiredAccess
                 NULL,                              // ObjectAttributes
                 SynchronizationEvent,              // EventType
                 FALSE                              // InitialState
                 );
        
    if (! NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_IPADDRESS_RETRIEVE_FAILURE);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Event is NULL.\n")));
        return;
    }

    //
    // Set IP address and subnet mask.
    //


    //
    // Start by opening the driver
    //
    RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                       );

    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_IPADDRESS_SET_FAILURE);
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: failed to open IP device, ec = 0x%X\n",
                     Status)));
        goto DoSetIpAddressCommand_Exit;
    }

    
    //
    // Setup the IOCTL buffer to delete the old address.
    //
    IpRequest = (PIP_SET_ADDRESS_REQUEST)GlobalBuffer;
    RtlZeroMemory(IpRequest, sizeof(IP_SET_ADDRESS_REQUEST));
    IpRequest->Address = 0;
    IpRequest->SubnetMask = 0;
    IpRequest->Context = (USHORT)NetworkNumber;

    //
    // Submit the IOCTL
    //
    Status = NtDeviceIoControlFile(Handle,
                                   EventHandle,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_IP_SET_ADDRESS,
                                   IpRequest,
                                   sizeof(IP_SET_ADDRESS_REQUEST),
                                   NULL,
                                   0
                                  );
                                  
    if (Status == STATUS_PENDING) {

        //
        // Wait up to 30 seconds for it to finish
        //
        TimeOut.QuadPart = Int32x32To64((LONG)30000, -1000);
        
        Status = NtWaitForSingleObject((PVOID)EventHandle, FALSE, &TimeOut);
        
        if (Status == STATUS_SUCCESS) {
            Status = IoStatusBlock.Status;
        }

    }

    if (Status != STATUS_SUCCESS) {
        SacPutSimpleMessage( SAC_IPADDRESS_CLEAR_FAILURE );
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: Exiting because it couldn't clear existing IP Address (0x%X).\n",
                     Status)));
        goto DoSetIpAddressCommand_Exit;
    }


    //
    // Now add our address.
    //
    IpRequest = (PIP_SET_ADDRESS_REQUEST)GlobalBuffer;
    RtlZeroMemory(IpRequest, sizeof(IP_SET_ADDRESS_REQUEST));
    IpRequest->Address = IpAddress;
    IpRequest->SubnetMask = SubnetMask;
    IpRequest->Context = (USHORT)NetworkNumber;

    //
    // Submit the IOCTL
    //
    Status = NtDeviceIoControlFile(Handle,
                                   EventHandle,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_IP_SET_ADDRESS,
                                   IpRequest,
                                   sizeof(IP_SET_ADDRESS_REQUEST),
                                   NULL,
                                   0
                                  );
                                  
    if (Status == STATUS_PENDING) {

        //
        // Wait up to 30 seconds for it to finish
        //
        TimeOut.QuadPart = Int32x32To64((LONG)30000, -1000);
        
        Status = NtWaitForSingleObject((PVOID)EventHandle, FALSE, &TimeOut);
        
        if (NT_SUCCESS(Status)) {
            Status = IoStatusBlock.Status;
        }

    }

    
    //
    // Don't need this anymore.
    //
    ZwClose(Handle);
    Handle = 0;
    
    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage( SAC_IPADDRESS_SET_FAILURE );                
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: Exiting because it couldn't set existing IP Address (0x%X).\n",
                     Status)));
        goto DoSetIpAddressCommand_Exit;
    }






    //
    // Now set the default gateway address based on the information we dug up
    // at the top of the function.
    //



    //
    // Start by opening the TCP driver
    //
    RtlInitUnicodeString(&UnicodeString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                       );

    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_IPADDRESS_SET_FAILURE);
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: failed to open TCP device, ec = 0x%X\n",
                     Status)));
        goto DoSetIpAddressCommand_Exit;
    }


    //
    // Fill in the route entry and submit the IOCTL
    //
    RouteEntry = ALLOCATE_POOL( sizeof(IPRouteEntry), GENERAL_POOL_TAG );
    if (RouteEntry == NULL) {
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (21).\n")));
        Status = STATUS_NO_MEMORY;
        goto DoSetIpAddressCommand_Exit;
    }
    
    RouteEntry->ire_dest = 0;
    RouteEntry->ire_index = InterfaceIndex;
    RouteEntry->ire_metric1 = 1;
    RouteEntry->ire_metric2 = (ULONG)(-1);
    RouteEntry->ire_metric3 = (ULONG)(-1);
    RouteEntry->ire_metric4 = (ULONG)(-1);
    RouteEntry->ire_metric5 = (ULONG)(-1);
    RouteEntry->ire_nexthop = GatewayAddress;
    RouteEntry->ire_type = 
        ((IpAddress == GatewayAddress) ? IRE_TYPE_DIRECT : IRE_TYPE_INDIRECT);
    RouteEntry->ire_proto = IRE_PROTO_NETMGMT;
    RouteEntry->ire_age = 0;
    RouteEntry->ire_mask = 0;
    RouteEntry->ire_context = 0;

    i = FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) + sizeof(IPRouteEntry);
    TcpRequestSetInformationEx = ALLOCATE_POOL( i, GENERAL_POOL_TAG );
    if (TcpRequestSetInformationEx == NULL) {
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (22).\n")));
        Status = STATUS_NO_MEMORY;
        goto DoSetIpAddressCommand_Exit;
    }
    
    RtlZeroMemory(TcpRequestSetInformationEx, i);
    TcpRequestSetInformationEx->ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
    TcpRequestSetInformationEx->ID.toi_type = INFO_TYPE_PROVIDER;
    TcpRequestSetInformationEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    TcpRequestSetInformationEx->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    TcpRequestSetInformationEx->ID.toi_entity.tei_instance = 0;
    TcpRequestSetInformationEx->BufferSize = sizeof(IPRouteEntry);
    memcpy(&TcpRequestSetInformationEx->Buffer[0], RouteEntry, sizeof(IPRouteEntry)); 



    //
    // set the default gateway address.
    //

    Status = NtDeviceIoControlFile(Handle,                  // driver handle
                                   EventHandle,             // sync event
                                   NULL,                    // APC routine
                                   NULL,                    // APC context
                                   &IoStatusBlock,
                                   IOCTL_TCP_SET_INFORMATION_EX,
                                   TcpRequestSetInformationEx,
                                   i,
                                   NULL,
                                   0
                                  );

    if (Status == STATUS_PENDING) {

       //
       // Wait up to 30 seconds for it to finish
       //
       TimeOut.QuadPart = Int32x32To64((LONG)30000, -1000);

       Status = NtWaitForSingleObject((PVOID)EventHandle, FALSE, &TimeOut);

       if (Status == STATUS_SUCCESS) {
           Status = IoStatusBlock.Status;
       }

   }

   if (Status != STATUS_SUCCESS) {
       SacPutSimpleMessage( SAC_IPADDRESS_SET_FAILURE );
       IF_SAC_DEBUG(
           SAC_DEBUG_FUNC_TRACE, 
           KdPrint(("SAC DoSetIpAddressCommand: Exiting because it couldn't set gateway Address (0x%X).\n",
                    Status)));
       goto DoSetIpAddressCommand_Exit;
   }


DoSetIpAddressCommand_Exit:
    if( EventHandle != 0 ) { 
        ZwClose(EventHandle);
    }

    if( Handle != 0 ) {
        ZwClose(Handle);
    }

    if( TcpRequestQueryInformationEx != NULL ) {
        FREE_POOL( &TcpRequestQueryInformationEx );
    }

    if( TcpRequestSetInformationEx != NULL ) {
        FREE_POOL( &TcpRequestSetInformationEx );
    }

    if( IpsiInfo != NULL ) {
        FREE_POOL( &IpsiInfo );
    }

    if( RouteEntry != NULL ) {
        FREE_POOL( &RouteEntry );
    }



    if( Status == STATUS_SUCCESS ) {
        SacPutSimpleMessage( SAC_IPADDRESS_SET_SUCCESS );
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting.\n")));
    return;
}

VOID
DoKillCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine kill a process.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    NTSTATUS StatusOfJobObject;
    HANDLE Handle = NULL;
    HANDLE JobHandle = NULL;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    CLIENT_ID ClientId;
    BOOLEAN TerminateJobObject;
    BOOLEAN TerminateProcessObject;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (1).\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


    //
    // Skip to next argument (process id)
    //
    pch += (sizeof(KILL_COMMAND_STRING) - sizeof(UCHAR));
    
    SKIP_WHITESPACE(pch);

    if (*pch == '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (2).\n")));
        return;
    }

    pchTmp = pch;

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (2b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (3).\n")));
        return;
    }

    ProcessId = atoi((LPCSTR)pch);

    //
    // Try and open an existing job object
    //
    swprintf((PWCHAR)GlobalBuffer, L"\\BaseNamedObjects\\SAC%d", ProcessId);
    RtlInitUnicodeString(&UnicodeString, (PWCHAR)GlobalBuffer);
    InitializeObjectAttributes(&ObjectAttributes,                
                               &UnicodeString,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    StatusOfJobObject = ZwOpenJobObject(&JobHandle, MAXIMUM_ALLOWED, &ObjectAttributes);

    //
    // Also open a handle to the process itself.
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&Handle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );

    if (!NT_SUCCESS(Status) && !NT_SUCCESS(StatusOfJobObject)) {
        SacPutSimpleMessage(SAC_KILL_FAILURE);
        SAC_PUT_ERROR_STRING(Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (4).\n")));
        return;
    }

    //
    // To make the logic here more understandable, I use two booleans.  We have to use
    // ZwIsProcessInJob because there may be a previous JobObject for a process that we 
    // have killed, but has not yet been fully cleaned up by the system to determine if
    // the process we are trying to kill is, in fact, in the JobObject we have opened.
    //
    TerminateJobObject = (BOOLEAN)(NT_SUCCESS(StatusOfJobObject) &&
                          (BOOLEAN)NT_SUCCESS(Status) &&
                          (BOOLEAN)(ZwIsProcessInJob(Handle, JobHandle) == STATUS_PROCESS_IN_JOB)
                         );

    TerminateProcessObject = !TerminateJobObject && (BOOLEAN)NT_SUCCESS(Status);
         
    if (TerminateJobObject) {

        Status = ZwTerminateJobObject(JobHandle, 1); 

        //
        // Make the job object temporary so that when we do our close it
        // will remove it.
        //
        ZwMakeTemporaryObject(JobHandle);

    } else if (TerminateProcessObject) {

        Status = ZwTerminateProcess(Handle, 1);

    }

    if (JobHandle != NULL) {
        ZwClose(JobHandle);
    }

    if (Handle != NULL) {
        ZwClose(Handle);
    }

    if (!TerminateProcessObject && !TerminateJobObject) {

        SacPutSimpleMessage(SAC_PROCESS_STALE);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (5).\n")));
        return;

    } else if (!NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_KILL_FAILURE);
        SAC_PUT_ERROR_STRING(Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (6).\n")));
        return;

    }

    //
    // All done
    //
    
    SacPutSimpleMessage(SAC_KILL_SUCCESS);
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting.\n")));
    
    return;
}

VOID
DoLowerPriorityCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine slams the priority of a process down to the lowest possible, IDLE.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ProcessHandle = NULL;
    PROCESS_BASIC_INFORMATION BasicInfo;
    ULONG LoopCounter;


    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (1).\n")));
            goto Exit;            
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


    //
    // Skip to next argument (process id)
    //
    pch += (sizeof(LOWER_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (!IS_NUMBER(*pch)) {
        
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (2).\n")));
        
        goto Exit;

    }

    pchTmp = pch;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (3).\n")));
        return;
    }

    ProcessId = atoi((LPCSTR)pch);



    //
    // Try to open the process
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&ProcessHandle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );

    if (!NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_LOWERPRI_FAILURE);
        SAC_PUT_ERROR_STRING(Status);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (4).\n")));
        goto Exit;

    }



    //
    // Query information on the process.
    //
    Status = ZwQueryInformationProcess( ProcessHandle,
                                        ProcessBasicInformation,
                                        &BasicInfo,
                                        sizeof(PROCESS_BASIC_INFORMATION),
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_LOWERPRI_FAILURE);
        SAC_PUT_ERROR_STRING(Status);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (5).\n")));
        goto Exit;

    }


    //
    // Lower the priority and set.  Keep lowering it until we fail.  Remember
    // that we're supposed to lower it as far as it will go.
    //
    Status = STATUS_SUCCESS;
    LoopCounter = 0;
    while( (Status == STATUS_SUCCESS) &&
           (BasicInfo.BasePriority > 0) ) {

        BasicInfo.BasePriority--;
        Status = ZwSetInformationProcess( ProcessHandle,
                                          ProcessBasePriority,
                                          &BasicInfo.BasePriority,
                                          sizeof(BasicInfo.BasePriority) );

        //
        // Only treat a failure on the first time through.
        //
        if( (!NT_SUCCESS(Status)) && (LoopCounter == 0) ) {

            SacPutSimpleMessage(SAC_LOWERPRI_FAILURE);
            SAC_PUT_ERROR_STRING(Status);

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (6).\n")));
            goto Exit;

        }

        LoopCounter++;
    }


    //
    // All done.
    //
    SacPutSimpleMessage(SAC_LOWERPRI_SUCCESS);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting.\n")));

Exit:

    if (ProcessHandle != NULL) {
        ZwClose(ProcessHandle);    
    }

    return;
}

VOID
DoRaisePriorityCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine raises the priority of a process up one increment.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ProcessHandle = NULL;
    PROCESS_BASIC_INFORMATION BasicInfo;


    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (1).\n")));
            goto Exit;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


    //
    // Skip to next argument (process id)
    //
    pch += (sizeof(RAISE_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (!IS_NUMBER(*pch)) {
        
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (2).\n")));
        
        goto Exit;

    }

    pchTmp = pch;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (3).\n")));
        return;
    }

    ProcessId = atoi((LPCSTR)pch);


    //
    // See if the process even exists.
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&ProcessHandle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );

    if (!NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_RAISEPRI_FAILURE);
        SAC_PUT_ERROR_STRING(Status);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (4).\n")));
        goto Exit;

    }




    //
    // Query information on the process.
    //
    Status = ZwQueryInformationProcess( ProcessHandle,
                                        ProcessBasicInformation,
                                        &BasicInfo,
                                        sizeof(PROCESS_BASIC_INFORMATION),
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_LOWERPRI_FAILURE);
        SAC_PUT_ERROR_STRING(Status);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (5).\n")));
        goto Exit;

    }


    //
    // Lower the priority and set.  Keep lowering it until we fail.  Remember
    // that we're supposed to lower it as far as it will go.
    //
    BasicInfo.BasePriority++;
    Status = ZwSetInformationProcess( ProcessHandle,
                                      ProcessBasePriority,
                                      &BasicInfo.BasePriority,
                                      sizeof(BasicInfo.BasePriority) );

    //
    // Only treat a failure on the first time through.
    //
    if( !NT_SUCCESS(Status) ) {

        SacPutSimpleMessage(SAC_LOWERPRI_FAILURE);
        SAC_PUT_ERROR_STRING(Status);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (6).\n")));
        goto Exit;

    }


    //
    // All done.
    //
    SacPutSimpleMessage(SAC_RAISEPRI_SUCCESS);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting.\n")));

Exit:

    if (ProcessHandle != NULL) {
        ZwClose(ProcessHandle);    
    }

    return;
}

VOID
DoLimitMemoryCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine reduces the memory working set of a process to the values in
    the input line given.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    NTSTATUS StatusOfJobObject;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    ULONG MemoryLimit;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE JobHandle = NULL;
    HANDLE ProcessHandle = NULL;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ProposedLimits;
    ULONG ReturnedLength;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (1).\n")));
            goto Exit;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


    //
    // Get process id
    //
    pch += (sizeof(LIMIT_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (!IS_NUMBER(*pch)) {
        
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (2).\n")));
        
        goto Exit;

    }

    pchTmp = pch;

    SKIP_NUMBERS(pchTmp);

    if (!IS_WHITESPACE(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (3).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    ProcessId = atoi((LPCSTR)pch);

    //
    // Now get memory limit
    //
    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (4).\n")));
        return;
    }


    pch = pchTmp;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (5).\n")));
        return;
    }

    MemoryLimit = atoi((LPCSTR)pch);

    if (MemoryLimit == 0) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (6).\n")));
        goto Exit;
    }

    //
    // Create the name for the job object
    //
    swprintf((PWCHAR)GlobalBuffer, L"\\BaseNamedObjects\\SAC%d", ProcessId);

    //
    // Try and open the existing job object
    //
    RtlInitUnicodeString(&UnicodeString, (PWCHAR)GlobalBuffer);
    InitializeObjectAttributes(&ObjectAttributes,                
                               &UnicodeString,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    StatusOfJobObject = ZwOpenJobObject(&JobHandle, MAXIMUM_ALLOWED, &ObjectAttributes);


    //
    // Try to open the process
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&ProcessHandle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );

    if (!NT_SUCCESS(Status) && !NT_SUCCESS(StatusOfJobObject)) {

        SacPutSimpleMessage(SAC_LOWERMEM_FAILURE);
        SAC_PUT_ERROR_STRING(Status);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (7).\n")));
        goto Exit;

    }

    if (NT_SUCCESS(Status) && 
        NT_SUCCESS(StatusOfJobObject) &&
        (ZwIsProcessInJob(ProcessHandle, JobHandle) != STATUS_PROCESS_IN_JOB)) {

        SacPutSimpleMessage(SAC_DUPLICATE_PROCESS);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (8).\n")));
        goto Exit;

    }

    if (!NT_SUCCESS(StatusOfJobObject)) {
        
        //
        // Now try and create a job object to wrap around this process.
        //
        InitializeObjectAttributes(&ObjectAttributes,                
                                   &UnicodeString,       
                                   OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,  
                                   NULL,                  
                                   NULL                   
                                  );

        Status = ZwCreateJobObject(&JobHandle, MAXIMUM_ALLOWED, &ObjectAttributes);

        if (!NT_SUCCESS(Status)) {
            SacPutSimpleMessage(SAC_LOWERMEM_FAILURE);
            SAC_PUT_ERROR_STRING(Status);
            
            ZwClose(ProcessHandle);

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (8b).\n")));
            
            goto Exit;
        }

        //
        // Assign the process to this new job object.
        //
        Status = ZwAssignProcessToJobObject(JobHandle, ProcessHandle);

        ZwClose(ProcessHandle);

        if (!NT_SUCCESS(Status)) {
            SacPutSimpleMessage(SAC_LOWERMEM_FAILURE);
            SAC_PUT_ERROR_STRING(Status);
        
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (9).\n")));
            goto Exit;        
        }

    }

    //
    // Get the current set of limits
    //
    Status = ZwQueryInformationJobObject(JobHandle, 
                                         JobObjectExtendedLimitInformation, 
                                         &ProposedLimits, 
                                         sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
                                         &ReturnedLength
                                        );
    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_LOWERMEM_FAILURE);
        SAC_PUT_ERROR_STRING(Status);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (10).\n")));
        goto Exit;
    }

    //
    // Change the memory limits
    //
    ProposedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;
    ProposedLimits.ProcessMemoryLimit = MemoryLimit * 1024 * 1024;
    ProposedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_JOB_MEMORY;
    ProposedLimits.JobMemoryLimit = MemoryLimit * 1024 * 1024;

    Status = ZwSetInformationJobObject(JobHandle, 
                                       JobObjectExtendedLimitInformation, 
                                       &ProposedLimits, 
                                       sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
                                      );
    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_LOWERMEM_FAILURE);
        SAC_PUT_ERROR_STRING(Status);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (11).\n")));\
        goto Exit;
    }

    //
    // All done.
    //

    SacPutSimpleMessage(SAC_LOWERMEM_SUCCESS);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting.\n")));

Exit:
    if (JobHandle != NULL) {
        ZwClose(JobHandle);
    }

    if (ProcessHandle != NULL) {
        ZwClose(ProcessHandle);
    }

    return;
}

VOID
DoRebootCommand(
    BOOLEAN Reboot
    )

/*++

Routine Description:

    This routine does a shutdown and an optional reboot.

Arguments:

    Reboot - To Reboot or not to reboot, that is the question answered here.

Return Value:

        None.

--*/
{
    #define         RESTART_DELAY_TIME (60)
    NTSTATUS        Status;
    LARGE_INTEGER   TickCount;
    LARGE_INTEGER   ElapsedTime;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRebootCommand: Entering.\n")));


    //
    // If we attempt to shutdown the system before smss.exe has initialized
    // properly, and if there's no debugger, the machine may bugcheck.  Figuring
    // out exactly what's going on is difficult because if we put a debugger on
    // the machine, he won't repro the problem.  To work around this, we're going
    // to make sure the machine has had time to initialize before we tell it to
    // restart/shutdown.
    //

    // Elapsed TickCount
    KeQueryTickCount( &TickCount );

    // ElapsedTime in seconds.
    ElapsedTime.QuadPart = (TickCount.QuadPart)/(10000000/KeQueryTimeIncrement());

    if( ElapsedTime.QuadPart < RESTART_DELAY_TIME ) {

        KEVENT Event;

        ConMgrSimpleEventMessage(
            Reboot ? SAC_PREPARE_RESTART : SAC_PREPARE_SHUTDOWN, 
            TRUE
            );

        // wait until the machine has been up for at least RESTART_DELAY_TIME seconds.
        KeInitializeEvent( &Event,
                           SynchronizationEvent,
                           FALSE );

        ElapsedTime.QuadPart = Int32x32To64((LONG)((RESTART_DELAY_TIME-ElapsedTime.LowPart)*10000), // milliseconds until we reach RESTART_DELAY_TIME
                                            -1000);
        KeWaitForSingleObject((PVOID)&Event, Executive, KernelMode,  FALSE, &ElapsedTime);

    }

    Status = NtShutdownSystem(Reboot ? ShutdownReboot : ShutdownPowerOff);

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRebootCommand: Exiting (1).\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


    SacPutSimpleMessage(Reboot ? SAC_RESTART_FAILURE : SAC_SHUTDOWN_FAILURE);
    SAC_PUT_ERROR_STRING(Status);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRebootCommand: Exiting.\n")));
}

VOID
DoCrashCommand(
    VOID
    )

/*++

Routine Description:

    This routine does a shutdown and bugcheck.

Arguments:

    None.

Return Value:

        None.

--*/
{
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCrashCommand: Entering.\n")));

    //
    // this call does not return
    //
    KeBugCheckEx(MANUALLY_INITIATED_CRASH, 0, 0, 0, 0);

    // SacPutSimpleMessage( SAC_CRASHDUMP_FAILURE );
    // IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCrashCommand: Exiting.\n")));
}

VOID
DoTlistCommand(
    VOID
    )

/*++

Routine Description:

    This routine gets a Tlist and displays it.

Arguments:

    None.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    ULONG DataLength;
    PVOID NewBuffer;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Entering.\n")));

    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Exiting.\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


RetryTList:

    Status = GetTListInfo((PSAC_RSP_TLIST)GlobalBuffer, 
                          (LONG)GlobalBufferSize, 
                          &DataLength
                         );

    if ((Status == STATUS_NO_MEMORY) ||
        (Status == STATUS_INFO_LENGTH_MISMATCH)) {
        //
        // Try to get more memory, if not available, then just fail without out of memory error.
        //
        NewBuffer = ALLOCATE_POOL(GlobalBufferSize + MEMORY_INCREMENT, GENERAL_POOL_TAG);
                                         
        if (NewBuffer != NULL) {

            FREE_POOL(&GlobalBuffer);
            GlobalBuffer = NewBuffer;
            GlobalBufferSize += MEMORY_INCREMENT;
            goto RetryTList;                            
        }
                    
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Exiting.\n")));
        return;

    }

    if (NT_SUCCESS(Status)) {
        PrintTListInfo((PSAC_RSP_TLIST)GlobalBuffer);
    } else {
        SacPutSimpleMessage( SAC_TLIST_FAILURE );
        SAC_PUT_ERROR_STRING(Status);
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Exiting.\n")));
}


NTSTATUS
GetTListInfo(
    OUT PSAC_RSP_TLIST ResponseBuffer,
    IN  LONG ResponseBufferSize,
    OUT PULONG ResponseDataSize
    )

/*++

Routine Description:

    This routine gets all the information necessary for the TList command.

Arguments:

    ResponseBuffer - The buffer to put the results into.
    
    ResponseBufferSize - The length of the above buffer.
    
    ResponseDataSize - The length of the resulting buffer.

Return Value:

        None.

--*/

{
    NTSTATUS Status;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;

    PUCHAR DataBuffer;
    PUCHAR StartProcessInfo;
    LONG CurrentBufferSize;
    ULONG ReturnLength;
    ULONG TotalOffset;
    ULONG OffsetIncrement = 0;
        
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Entering.\n")));
    
    *ResponseDataSize = 0;

    if (ResponseBufferSize < sizeof(ResponseBuffer)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory.\n")));
        return(STATUS_NO_MEMORY);
    }
    
    DataBuffer = (PUCHAR)(ResponseBuffer + 1);
    CurrentBufferSize = ResponseBufferSize - sizeof(SAC_RSP_TLIST);
    
    if (CurrentBufferSize < 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory (2).\n")));
        return STATUS_NO_MEMORY;
    }

    //
    // Get system-wide information
    //
    Status = ZwQuerySystemInformation(SystemTimeOfDayInformation,
                                      &(ResponseBuffer->TimeOfDayInfo),
                                      sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error.\n")));
        return(Status);
    }

    Status = ZwQuerySystemInformation(SystemBasicInformation,
                                      &(ResponseBuffer->BasicInfo),
                                      sizeof(SYSTEM_BASIC_INFORMATION),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(2).\n")));
        return(Status);
    }

    //
    // Get pagefile information
    //
    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)DataBuffer;
    Status = ZwQuerySystemInformation(SystemPageFileInformation,
                                      PageFileInfo,
                                      CurrentBufferSize,
                                      &ReturnLength
                                     );

    if (NT_SUCCESS(Status) && (ReturnLength != 0)) {

        ResponseBuffer->PagefileInfoOffset = ResponseBufferSize - CurrentBufferSize;
        CurrentBufferSize -= ReturnLength;
        DataBuffer += ReturnLength;
    
        if (CurrentBufferSize < 0) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(3).\n")));
            return STATUS_NO_MEMORY;
        }

        //
        // Go thru each pagefile and fixup the names...
        //
        for (; ; ) {

            if (PageFileInfo->PageFileName.Length > CurrentBufferSize) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(3).\n")));
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            RtlCopyMemory(DataBuffer, 
                          (PUCHAR)(PageFileInfo->PageFileName.Buffer), 
                          PageFileInfo->PageFileName.Length
                         );

            PageFileInfo->PageFileName.Buffer = (PWSTR)DataBuffer;
            DataBuffer += PageFileInfo->PageFileName.Length;
            CurrentBufferSize -= PageFileInfo->PageFileName.Length;

            if (CurrentBufferSize < 0) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory (4).\n")));
                return STATUS_NO_MEMORY;
            }

            if (PageFileInfo->NextEntryOffset == 0) {
                break;
            }

            PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);
        }

    } else if (((ULONG)CurrentBufferSize) < ReturnLength) {
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(5).\n")));
        return(STATUS_NO_MEMORY);
     
    } else {

        //
        // Either failure or no paging file present.
        //
        ResponseBuffer->PagefileInfoOffset = 0;

    }

    //
    // Get process information
    //
    Status = ZwQuerySystemInformation(SystemFileCacheInformation,
                                      &(ResponseBuffer->FileCache),
                                      sizeof(ResponseBuffer->FileCache),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(4).\n")));
        return(Status);
    }


    Status = ZwQuerySystemInformation(SystemPerformanceInformation,
                                      &(ResponseBuffer->PerfInfo),
                                      sizeof(ResponseBuffer->PerfInfo),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {     
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(5).\n")));
        return(Status);
    }

    //
    // Realign DataBuffer for the next query
    //
    DataBuffer = ALIGN_UP_POINTER(DataBuffer, SYSTEM_PROCESS_INFORMATION);
    CurrentBufferSize = (ULONG)(ResponseBufferSize - (((ULONG_PTR)DataBuffer) - ((ULONG_PTR)ResponseBuffer)));
        
    if (CurrentBufferSize < 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory (6).\n")));
        return STATUS_NO_MEMORY;
    }


    Status = ZwQuerySystemInformation(SystemProcessInformation,
                                      DataBuffer,
                                      CurrentBufferSize,
                                      &ReturnLength
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(6).\n")));
        return(Status);
    }


    StartProcessInfo = DataBuffer;

    ResponseBuffer->ProcessInfoOffset = ResponseBufferSize - CurrentBufferSize;
    DataBuffer += ReturnLength;
    CurrentBufferSize -= ReturnLength;

    if (CurrentBufferSize < 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(7).\n")));
        return STATUS_NO_MEMORY;
    }

    OffsetIncrement = 0;
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)StartProcessInfo;

    do {

        //
        // We have to take the name of each process and pack the UNICODE_STRING
        // buffer in our buffer so it doesn't collide with the subsequent data
        //
        if (ProcessInfo->ImageName.Buffer) {
                
            if (CurrentBufferSize < ProcessInfo->ImageName.Length ) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(7).\n")));
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            RtlCopyMemory(DataBuffer, (PUCHAR)(ProcessInfo->ImageName.Buffer), ProcessInfo->ImageName.Length);                        

            ProcessInfo->ImageName.Buffer = (PWSTR)DataBuffer;

            DataBuffer += ProcessInfo->ImageName.Length;
            CurrentBufferSize -= ProcessInfo->ImageName.Length;
            
            if (CurrentBufferSize < 0) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(8).\n")));
                return STATUS_NO_MEMORY;
            }

        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&(StartProcessInfo[TotalOffset]);

    } while( OffsetIncrement != 0 );

    *ResponseDataSize = (ULONG)(ResponseBufferSize - CurrentBufferSize);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting.\n")));
    return STATUS_SUCCESS;
}

VOID
PrintTListInfo(
    IN PSAC_RSP_TLIST Buffer
    )

/*++

Routine Description:

    This routine prints TList info to the headless terminal.

Arguments:

    Buffer - The buffer with the results.

Return Value:

        None.

--*/

{
    LARGE_INTEGER Time;
    
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS UpTime;
    
    ULONG TotalOffset;
    ULONG OffsetIncrement = 0;
    SIZE_T SumCommit;
    SIZE_T SumWorkingSet;

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;

    ULONG i;

    PUCHAR ProcessInfoStart;
    PUCHAR BufferStart = (PUCHAR)Buffer;

    ULONG LineNumber = 0;

    ULONG   OutputBufferSize;
    PWCHAR  OutputBuffer;
    
    UNICODE_STRING Process;
    
    BOOLEAN Stop;
    
    PCWSTR  Message;

    //
    // Allocate work buffer
    // should never be more than 80, but just to be safe....
    //
    OutputBufferSize = 200*sizeof(WCHAR);
    OutputBuffer = ALLOCATE_POOL(OutputBufferSize, GENERAL_POOL_TAG);
    ASSERT(OutputBuffer);
    if (OutputBuffer == NULL) {
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC PrintTlistInfo: Failed to allocate OuputBuffer\n"))
            );
        return;
    }
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Entering.\n")));

    Time.QuadPart = Buffer->TimeOfDayInfo.CurrentTime.QuadPart - Buffer->TimeOfDayInfo.BootTime.QuadPart;

    RtlTimeToElapsedTimeFields(&Time, &UpTime);

    SAFE_SWPRINTF(
        OutputBufferSize,
        (OutputBuffer, 
        GetMessage( SAC_TLIST_HEADER1_FORMAT ),
        Buffer->BasicInfo.NumberOfPhysicalPages * (Buffer->BasicInfo.PageSize / 1024),
        UpTime.Day,
        UpTime.Hour,
        UpTime.Minute,
        UpTime.Second,
        UpTime.Milliseconds
        ));

    SacPutString(OutputBuffer);

    LineNumber += 2;

    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)(BufferStart + Buffer->PagefileInfoOffset);
        
    //
    // Print out the page file information.
    //

    if (Buffer->PagefileInfoOffset == 0) {
    
        SacPutSimpleMessage(SAC_TLIST_NOPAGEFILE);
        LineNumber++;
        
    } else {
    
        for (; ; ) {

            //
            // ensure that the OutputBuffer is big enough to hold the string
            //
            Message = GetMessage(SAC_TLIST_PAGEFILE_NAME);
            
            if (Message == NULL) {
                
                //
                // we must have this resource
                //
                ASSERT(0);
                
                //
                // give up trying to print page file info
                //
                break;
            
            }

            if (((wcslen(Message) + 
                  wcslen((PWSTR)&(PageFileInfo->PageFileName))) * sizeof(WCHAR)) > (OutputBufferSize-2)) {
                
                //
                // Since we don't expect the pagefilename to be > 80 chars, we should stop and 
                // take a look at the name if this does happen
                //
                ASSERT(0);
                
                //
                // give up trying to print page file info
                //
                break;

            }

            SAFE_SWPRINTF(
                OutputBufferSize,
                (OutputBuffer, 
                Message,
                &PageFileInfo->PageFileName
                ));
            
            SacPutString(OutputBuffer);
            LineNumber++;
            

            SAFE_SWPRINTF(
                OutputBufferSize,
                (OutputBuffer,
                GetMessage(SAC_TLIST_PAGEFILE_DATA),            
                PageFileInfo->TotalSize * (Buffer->BasicInfo.PageSize/1024),
                PageFileInfo->TotalInUse * (Buffer->BasicInfo.PageSize/1024),
                PageFileInfo->PeakUsage * (Buffer->BasicInfo.PageSize/1024)
                ));
            
            SacPutString(OutputBuffer);
            LineNumber++;
            
            if (PageFileInfo->NextEntryOffset == 0) {
                break;
            }

            PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);

        }

    }

    //
    // display pmon style process output, then detailed output that includes
    // per thread stuff
    //
    if (Buffer->ProcessInfoOffset == 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Exiting (1).\n")));
        goto PrintTListInfoCleanup;
    }

    OffsetIncrement = 0;
    TotalOffset = 0;
    SumCommit = 0;
    SumWorkingSet = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);
    ProcessInfoStart = (PUCHAR)ProcessInfo;
    
    do {
        SumCommit += ProcessInfo->PrivatePageCount / 1024;
        SumWorkingSet += ProcessInfo->WorkingSetSize / 1024;
        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart +TotalOffset);
    } while( OffsetIncrement != 0 );

    SumWorkingSet += Buffer->FileCache.CurrentSize/1024;

    if (LineNumber > 17) {
        PutMore(&Stop);

        if (Stop) {
            goto PrintTListInfoCleanup;
        }

        LineNumber = 0;
    }

    SAFE_SWPRINTF(
        OutputBufferSize,
        (OutputBuffer, 
        GetMessage(SAC_TLIST_MEMORY1_DATA),
        Buffer->BasicInfo.NumberOfPhysicalPages * (Buffer->BasicInfo.PageSize/1024),
        Buffer->PerfInfo.AvailablePages * (Buffer->BasicInfo.PageSize/1024),
        SumWorkingSet,
        (Buffer->PerfInfo.ResidentSystemCodePage + Buffer->PerfInfo.ResidentSystemDriverPage) * 
        (Buffer->BasicInfo.PageSize/1024),
        (Buffer->PerfInfo.ResidentPagedPoolPage) * (Buffer->BasicInfo.PageSize/1024)
        ));
    
    SacPutString(OutputBuffer);
    LineNumber += 2;
    if (LineNumber > 18) {
        PutMore(&Stop);

        if (Stop) {
            goto PrintTListInfoCleanup;
        }

        LineNumber = 0;
    }

    SAFE_SWPRINTF(
        OutputBufferSize,
        (OutputBuffer,
        GetMessage(SAC_TLIST_MEMORY2_DATA),
        Buffer->PerfInfo.CommittedPages * (Buffer->BasicInfo.PageSize/1024),
        SumCommit,
        Buffer->PerfInfo.CommitLimit * (Buffer->BasicInfo.PageSize/1024),
        Buffer->PerfInfo.PeakCommitment * (Buffer->BasicInfo.PageSize/1024),
        Buffer->PerfInfo.NonPagedPoolPages * (Buffer->BasicInfo.PageSize/1024),
        Buffer->PerfInfo.PagedPoolPages * (Buffer->BasicInfo.PageSize/1024)
        ));

    SacPutString(OutputBuffer);

    LineNumber++;
    if (LineNumber > 18) {
        PutMore(&Stop);

        if (Stop) {
            goto PrintTListInfoCleanup;
        }

        LineNumber = 0;
    }


    SacPutSimpleMessage(SAC_ENTER);
    PutMore(&Stop);

    if (Stop) {
        goto PrintTListInfoCleanup;
    }

    LineNumber = 0;

    SacPutSimpleMessage( SAC_TLIST_PROCESS1_HEADER );
    LineNumber++;

    SAFE_SWPRINTF(
        OutputBufferSize,
        (OutputBuffer,
        GetMessage( SAC_TLIST_PROCESS2_HEADER ),
        Buffer->FileCache.CurrentSize/1024,
        Buffer->FileCache.PageFaultCount 
        ));

    SacPutString(OutputBuffer);
    LineNumber++;
    
    OffsetIncrement = 0;
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);

    do {
        
        RtlTimeToElapsedTimeFields(&ProcessInfo->UserTime, &UserTime);
        RtlTimeToElapsedTimeFields(&ProcessInfo->KernelTime, &KernelTime);

        Process.Buffer = NULL;
        if (ProcessInfo->UniqueProcessId == 0) {
            RtlInitUnicodeString( &Process, L"Idle Process" );
        } else if (!ProcessInfo->ImageName.Buffer) {
            RtlInitUnicodeString( &Process, L"System" );
        }

        SAFE_SWPRINTF(
            OutputBufferSize,
            (OutputBuffer, 
            GetMessage( SAC_TLIST_PROCESS1_DATA ),
            UserTime.Hour,
            UserTime.Minute,
            UserTime.Second,
            UserTime.Milliseconds,
            KernelTime.Hour,
            KernelTime.Minute,
            KernelTime.Second,
            KernelTime.Milliseconds,
            ProcessInfo->WorkingSetSize / 1024,
            ProcessInfo->PageFaultCount,
            ProcessInfo->PrivatePageCount / 1024,
            ProcessInfo->BasePriority,
            ProcessInfo->HandleCount,
            ProcessInfo->NumberOfThreads,
            HandleToUlong(ProcessInfo->UniqueProcessId),
            Process.Buffer ? &Process : &ProcessInfo->ImageName 
            ));

        SacPutString(OutputBuffer);

        LineNumber++;

        if( wcslen( OutputBuffer ) >= 80 ) {
            //
            // We line-wrapped, so include the additional line in our running-count.
            //
            LineNumber++;
        }
        
        //
        // update the position in the process list before we check to see if we need
        // to prompt for more.  This way, if we are done, we don't prompt.
        //
        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart + TotalOffset);
        
        //
        // if there are more records and we have displayed a screen's worth of data
        // Prompt for more and reset the line counter
        //
        if (( OffsetIncrement != 0 ) && (LineNumber > 18)) {
            PutMore(&Stop);

            if (Stop) {
                goto PrintTListInfoCleanup;
            }

            LineNumber = 0;
            
            if (GlobalPagingNeeded) {
                SacPutSimpleMessage( SAC_TLIST_PROCESS1_HEADER );                
            }

            LineNumber++;
        }

    } while( OffsetIncrement != 0 );


    if (!GlobalDoThreads) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Exiting (2).\n")));
        goto PrintTListInfoCleanup;
    }

    //
    // Beginning of normal old style pstat output
    //

    TotalOffset = 0;
    OffsetIncrement = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);

    PutMore(&Stop);

    if (Stop) {
        goto PrintTListInfoCleanup;
    }

    LineNumber = 0;

    SacPutSimpleMessage(SAC_ENTER);
    LineNumber++;

    do {

        Process.Buffer = NULL;
        if (ProcessInfo->UniqueProcessId == 0) {
            RtlInitUnicodeString( &Process, L"Idle Process" );
        } else if (!ProcessInfo->ImageName.Buffer) {
            RtlInitUnicodeString( &Process, L"System" );
        }

        SAFE_SWPRINTF(
            OutputBufferSize,
            (OutputBuffer, 
            GetMessage(SAC_TLIST_PSTAT_HEADER),
            HandleToUlong(ProcessInfo->UniqueProcessId),
            ProcessInfo->BasePriority,
            ProcessInfo->HandleCount,
            ProcessInfo->PageFaultCount,
            ProcessInfo->WorkingSetSize / 1024,
            Process.Buffer ? &Process : &ProcessInfo->ImageName
            ));

        SacPutString(OutputBuffer);
        LineNumber++;
        
        if( wcslen( OutputBuffer ) >= 80 ) {
            //
            // We line-wrapped, so include the additional line in our running-count.
            //
            LineNumber++;
        }
        
        if (LineNumber > 18) {
            PutMore(&Stop);

            if (Stop) {
                goto PrintTListInfoCleanup;
            }

            LineNumber = 0;
        }

        i = 0;
        
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        
        if (ProcessInfo->NumberOfThreads) {

            if ((LineNumber < 18) || !GlobalPagingNeeded) {
                SacPutSimpleMessage( SAC_TLIST_PSTAT_THREAD_HEADER );                
                LineNumber++;
            } else {
                PutMore(&Stop);

                if (Stop) {
                    goto PrintTListInfoCleanup;
                }

                LineNumber = 0;
            }

        }

        while (i < ProcessInfo->NumberOfThreads) {
            RtlTimeToElapsedTimeFields ( &ThreadInfo->UserTime, &UserTime);

            RtlTimeToElapsedTimeFields ( &ThreadInfo->KernelTime, &KernelTime);
            
            SAFE_SWPRINTF(
                OutputBufferSize,
                (OutputBuffer, 
                GetMessage( SAC_TLIST_PSTAT_THREAD_DATA ),
                ProcessInfo->UniqueProcessId == 0 ? 0 : HandleToUlong(ThreadInfo->ClientId.UniqueThread),
                ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->Priority,
                ThreadInfo->ContextSwitches,
                ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->StartAddress,
                UserTime.Hour,
                UserTime.Minute,
                UserTime.Second,
                UserTime.Milliseconds,
                KernelTime.Hour,
                KernelTime.Minute,
                KernelTime.Second,
                KernelTime.Milliseconds,
                StateTable[ThreadInfo->ThreadState],
                (ThreadInfo->ThreadState == 5) ? WaitTable[ThreadInfo->WaitReason] : Empty
                ));

            SacPutString(OutputBuffer);

            LineNumber++;
            
            
            if( wcslen( OutputBuffer ) >= 80 ) {
                //
                // We line-wrapped, so include the additional line in our running-count.
                //
                LineNumber++;
            }

            if (LineNumber > 18) {
                PutMore(&Stop);

                if (Stop) {
                    goto PrintTListInfoCleanup;
                }

                LineNumber = 0;

                if (GlobalPagingNeeded) {
                    SacPutSimpleMessage( SAC_TLIST_PSTAT_THREAD_HEADER );
                }

                LineNumber++;
            }


            ThreadInfo += 1;
            i += 1;

        }

        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart + TotalOffset);

        SacPutSimpleMessage(SAC_ENTER);
        LineNumber++;

        if (LineNumber > 18) {
            PutMore(&Stop);

            if (Stop) {
                goto PrintTListInfoCleanup;
            }

            LineNumber = 0;
        }

    } while( OffsetIncrement != 0 );

PrintTListInfoCleanup:

    SAFE_FREE_POOL(&OutputBuffer);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Exiting.\n")));
}


VOID
PutMore(
    OUT PBOOLEAN Stop
    )
{
#if 0
    PHEADLESS_RSP_GET_LINE Response;
    UCHAR Buffer[20];
    SIZE_T Length;
#endif    
    LARGE_INTEGER WaitTime;
    NTSTATUS Status;
    UCHAR   ch;

#if 0
    ASSERT(sizeof(HEADLESS_RSP_GET_LINE) <= (sizeof(UCHAR) * 20));
#endif

    //
    // Default: we will not stop paging
    //
    *Stop = FALSE;

    //
    // If paging is enabled,
    // then wait for user input
    //
    if (GlobalPagingNeeded) {
        
        WaitTime.QuadPart = Int32x32To64((LONG)100, -1000); // 100ms from now.
        
        //
        // Prompt for user input
        //
        SacPutSimpleMessage( SAC_MORE_MESSAGE );
        
        while (! *Stop) {

            //
            // Query the serial port buffer
            //
            Status = SerialBufferGetChar(&ch);

            //
            // wait if there are no characters
            //
            if (Status == STATUS_NO_DATA_DETECTED) {
                KeDelayExecutionThread(KernelMode, FALSE, &WaitTime);
                continue;
            }
            
            //
            // if the user input a ctrl-c, 
            // then stop paging
            //
            if (ch == 0x3) { // Control-C
                *Stop = TRUE;
            } 
            
            //
            // if we get a CR || LF, 
            // then continue to the next page
            //
            if (ch == 0x0D || ch == 0x0A) {
                break;
            }

        }
    
#if 0
        Response = (PHEADLESS_RSP_GET_LINE)&(Buffer[0]);
        Length = sizeof(UCHAR) * 20;

        Status = HeadlessDispatch(HeadlessCmdGetLine,
                                  NULL,
                                  0,
                                  Response,
                                  &Length
                                 );

        while (NT_SUCCESS(Status) && !Response->LineComplete) {

            KeDelayExecutionThread(KernelMode, FALSE, &WaitTime);
            
            Length = sizeof(UCHAR) * 20;
            Status = HeadlessDispatch(HeadlessCmdGetLine,
                                      NULL,
                                      0,
                                      Response,
                                      &Length
                                     );

        }

        if (Response->Buffer[0] == 0x3) { // Control-C
            *Stop = TRUE;
        } else {
            *Stop = FALSE;
        }

        // 
        // Drain any remaining buffered input
        //
        Length = sizeof(UCHAR) * 20;
        Status = HeadlessDispatch(HeadlessCmdGetLine,
                                  NULL,
                                  0,
                                  Response,
                                  &Length
                                 );

        while (NT_SUCCESS(Status) && Response->LineComplete) {

            Length = sizeof(UCHAR) * 20;
            Status = HeadlessDispatch(HeadlessCmdGetLine,
                                      NULL,
                                      0,
                                      Response,
                                      &Length
                                     );

        }
#endif

    } else {
        *Stop = FALSE;
    }

}


NTSTATUS 
CallQueryIPIOCTL(
    HANDLE IpDeviceHandle,
    PKEVENT Event,
    HANDLE EventHandle,
    IO_STATUS_BLOCK *IoStatusBlock,
    PVOID  InputBuffer,
    ULONG  InputBufferSize,
    PVOID  OutputBuffer,
    ULONG  OutputBufferSize,
    BOOLEAN PrintToTerminal,
    BOOLEAN *putPrompt
    )
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;

    //
    // Submit the IOCTL
    //
    Status = NtDeviceIoControlFile(IpDeviceHandle,
                                   EventHandle,
                                   NULL,
                                   NULL,
                                   IoStatusBlock,
                                   IOCTL_TCP_QUERY_INFORMATION_EX,
                                   InputBuffer,
                                   InputBufferSize,
                                   OutputBuffer,
                                   OutputBufferSize);

                                  
    if (Status == STATUS_PENDING) {

        //
        // Wait up to 30 seconds for it to finish
        //
        if (PrintToTerminal != FALSE) {
            SacPutSimpleMessage( SAC_ENTER );
            SacPutSimpleMessage( SAC_RETRIEVING_IPADDR );
            if (putPrompt) {
                *putPrompt= TRUE;
            }
        }
        
        TimeOut.QuadPart = Int32x32To64((LONG)30000, -1000);
        
        Status = KeWaitForSingleObject((PVOID)Event, Executive, KernelMode,  FALSE, &TimeOut);
        
        if (NT_SUCCESS(Status)) {
            Status = IoStatusBlock->Status;
        }

    }

    return(Status);


}


VOID
DoGetNetInfo(
    BOOLEAN PrintToTerminal
    )

/*++

Routine Description:

    This routine attempts to get and print every IP net number and its IP
    address.

Arguments:

    PrintToTerminal - Determines if the IP information is printed ( == TRUE )
           Or sent to the kernel ( == FALSE ) 

Return Value:

        None.

--*/

{
    NTSTATUS            Status;
    HANDLE              Handle;
    ULONG               i, j;
    IO_STATUS_BLOCK     IoStatusBlock;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    
    PTCP_REQUEST_QUERY_INFORMATION_EX TcpRequestQueryInformationEx;
    IPAddrEntry         *AddressEntry,*AddressArray;
    IPSNMPInfo          *IpsiInfo;

    IPRouteEntry        *RouteTable;
    ULONG               Gateway;

    PHEADLESS_CMD_SET_BLUE_SCREEN_DATA LocalPropBuffer = NULL;
    PVOID               LocalBuffer;

    PUCHAR              pch = NULL;
    ULONG               len;
    BOOLEAN             putPrompt=FALSE;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Entering.\n")));

    //
    // Alloc space for calling the IP driver
    //
    TcpRequestQueryInformationEx = ALLOCATE_POOL( 
                                        sizeof(TCP_REQUEST_QUERY_INFORMATION_EX), 
                                        GENERAL_POOL_TAG );
    if (TcpRequestQueryInformationEx == NULL) {
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (1).\n")));
        return;
    }

    IpsiInfo = ALLOCATE_POOL( sizeof(IPSNMPInfo), 
                              GENERAL_POOL_TAG );
    if (IpsiInfo == NULL) {
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (1).\n")));
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;
    }

    //
    // zero out the context information and preload with the info we're gonna
    // request (we want the count of interfaces)
    //
    TcpRequestQueryInformationEx->ID.toi_id = IP_MIB_STATS_ID;
    TcpRequestQueryInformationEx->ID.toi_type = INFO_TYPE_PROVIDER;
    TcpRequestQueryInformationEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_instance = 0;

    LocalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);
    if (LocalBuffer == NULL) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (6).\n")));            
        FREE_POOL(&TcpRequestQueryInformationEx);
        FREE_POOL(&IpsiInfo);
        return;        
    }

    
    //
    // Start by opening the TCP driver
    //
    RtlInitUnicodeString(&UnicodeString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                       );

    if (!NT_SUCCESS(Status)) {
        if (PrintToTerminal ) {   
            SacPutSimpleMessage(SAC_IPADDR_FAILED);
            SacPutSimpleMessage(SAC_ENTER);
        }
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (2).\n")));
        return;
    }
    
    if (SACEvent == NULL) {
        if (PrintToTerminal) {
            SacPutSimpleMessage(SAC_IPADDR_FAILED);
        }
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (14).\n")));
        return;
    }

    //
    // now call the ioctl
    //
    Status = CallQueryIPIOCTL(
                   Handle,
                   SACEvent,
                   SACEventHandle,
                   &IoStatusBlock,
                   TcpRequestQueryInformationEx,
                   sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                   IpsiInfo,
                   sizeof(IPSNMPInfo),
                   FALSE,
                   &putPrompt);
    

    if (!NT_SUCCESS(Status)) {
        if (PrintToTerminal){
            SacPutSimpleMessage(SAC_IPADDR_FAILED);
        }

        ZwClose(Handle);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;
    }

    if (IpsiInfo->ipsi_numaddr == 0) {
        if (PrintToTerminal) {
            SacPutSimpleMessage( SAC_IPADDR_NONE );
        }
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;

    }

    //
    // if it succeeded, then allocate space for the array of IP addresses
    //
    AddressArray = ALLOCATE_POOL(IpsiInfo->ipsi_numaddr*sizeof(IPAddrEntry), 
                                 GENERAL_POOL_TAG);
    if (AddressArray == NULL) {    
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (16).\n")));
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;
    
    }

    //
    // zero out the context information and preload with the info we're gonna
    // request (we want information on each of the interfaces on this machine)
    //
    RtlZeroMemory(TcpRequestQueryInformationEx, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
    TcpRequestQueryInformationEx->ID.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    TcpRequestQueryInformationEx->ID.toi_type = INFO_TYPE_PROVIDER;
    TcpRequestQueryInformationEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_instance = 0;

    Status = CallQueryIPIOCTL(
                   Handle,
                   SACEvent,
                   SACEventHandle,
                   &IoStatusBlock,
                   TcpRequestQueryInformationEx,
                   sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                   AddressArray,
                   IpsiInfo->ipsi_numaddr*sizeof(IPAddrEntry),
                   PrintToTerminal,
                   &putPrompt);

    if (!NT_SUCCESS(Status)) {
        if (PrintToTerminal){
            SacPutSimpleMessage(SAC_IPADDR_FAILED);
            SAC_PUT_ERROR_STRING(Status);
            
        }
        FREE_POOL(&TcpRequestQueryInformationEx);
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&AddressArray);
        FREE_POOL(&IpsiInfo);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));        
        return;
    }
    


    //
    // Load the route table information too so we can display the gateway for
    // each NIC.
    //
    RouteTable = ALLOCATE_POOL(IpsiInfo->ipsi_numroutes*sizeof(IPRouteEntry), 
                                 GENERAL_POOL_TAG);

    if (RouteTable == NULL) {    
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (14).\n")));
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        FREE_POOL(&AddressArray);
        return;    
    }

    //
    // zero out the context information and preload with the info we're gonna
    // request (we want routing information on each of the interfaces)
    //
    RtlZeroMemory(TcpRequestQueryInformationEx, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
    TcpRequestQueryInformationEx->ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
    TcpRequestQueryInformationEx->ID.toi_type = INFO_TYPE_PROVIDER;
    TcpRequestQueryInformationEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_instance = 0;

    Status = CallQueryIPIOCTL(
                   Handle,
                   SACEvent,
                   SACEventHandle,
                   &IoStatusBlock,
                   TcpRequestQueryInformationEx,
                   sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                   RouteTable,
                   IpsiInfo->ipsi_numroutes*sizeof(IPRouteEntry),
                   PrintToTerminal,
                   &putPrompt);

    if (!NT_SUCCESS(Status)) {
        if (PrintToTerminal){
            SacPutSimpleMessage(SAC_IPADDR_FAILED);
            SAC_PUT_ERROR_STRING(Status);
            
        }
        FREE_POOL(&TcpRequestQueryInformationEx);
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&AddressArray);
        FREE_POOL(&RouteTable);
        FREE_POOL(&IpsiInfo);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));        
        return;
    }
    


    //
    // Need to allocate a buffer for the XML data.
    //
    if(PrintToTerminal==FALSE) {
        LocalPropBuffer = (PHEADLESS_CMD_SET_BLUE_SCREEN_DATA) ALLOCATE_POOL(2*MEMORY_INCREMENT, GENERAL_POOL_TAG);
        if (LocalPropBuffer == NULL) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (6).\n")));            
            FREE_POOL(&AddressArray);
            FREE_POOL(&RouteTable);
            FREE_POOL(&LocalBuffer);
            FREE_POOL(&IpsiInfo);
            FREE_POOL(&TcpRequestQueryInformationEx);
            ZwClose(Handle);
            return;
        }
        pch = &(LocalPropBuffer->Data[0]);
        len = sprintf((LPSTR)pch,"IPADDRESS");
        LocalPropBuffer->ValueIndex = len+1;
        pch = pch+len+1;
        len = sprintf((LPSTR)pch,"\r\n<PROPERTY.ARRAY NAME=\"IPADDRESS\" TYPE=\"string\">\r\n");
        pch = pch + len;
        len = sprintf((LPSTR)pch,"<VALUE.ARRAY>\r\n");
        pch = pch + len;
    }
    
    //
    // walk the list of IP addresses and spit out the data
    //
    for (i = 0; i < IpsiInfo->ipsi_numaddr; i++) {
        AddressEntry = &AddressArray[i];

        if (IP_LOOPBACK(AddressEntry->iae_addr)) {
            continue;
        }

        //
        // We need to find which gateway pertains to this
        // interface.  The only way to do that is go dig
        // through the list of gateway addresses and see
        // if we can find one for this IP address and mask.
        //
        Gateway = 0;
        for( j = 0; j < IpsiInfo->ipsi_numroutes; j++ ) {

            //
            // See if we can match masks on the IP address
            // and the gateway.
            //
            if( (AddressEntry->iae_addr != 0) &&
                (AddressEntry->iae_mask != 0) &&
                ((AddressEntry->iae_addr & AddressEntry->iae_mask) ==
                 (RouteTable[j].ire_nexthop & AddressEntry->iae_mask)) ) {
                
                // We found a match.  Remember it and exit.
                Gateway = RouteTable[j].ire_nexthop;
                break;
            }

        }

        if( Gateway == 0 ) {
            //
            // We failed to find a gateway.  Look again, this time
            // see if we can get an exact match between the IP address
            // and the gateway.
            //
            for( j = 0; j < IpsiInfo->ipsi_numroutes; j++ ) {

                if( RouteTable[j].ire_nexthop == AddressEntry->iae_addr ) {
                    // We found a match.  Remember it and exit.
                    Gateway = RouteTable[j].ire_nexthop;
                    break;
                }
            }
        }
        
        if(PrintToTerminal){
           swprintf(LocalBuffer, 
                    GetMessage( SAC_IPADDR_DATA ),

                    //
                    // Interface number.
                    //
                    AddressEntry->iae_context,

                    //
                    // IP address.
                    //
                    AddressEntry->iae_addr & 0xFF,
                    (AddressEntry->iae_addr >> 8) & 0xFF,
                    (AddressEntry->iae_addr >> 16) & 0xFF,
                    (AddressEntry->iae_addr >> 24) & 0xFF,

                    //
                    // Subnet mask.
                    //
                    AddressEntry->iae_mask  & 0xFF,
                    (AddressEntry->iae_mask >> 8) & 0xFF,
                    (AddressEntry->iae_mask >> 16) & 0xFF,
                    (AddressEntry->iae_mask >> 24) & 0xFF,

                    //
                    // Gateway address.
                    //
                    Gateway & 0xFF,
                    (Gateway >> 8) & 0xFF,
                    (Gateway >> 16) & 0xFF,
                    (Gateway >> 24) & 0xFF
                   );
           SacPutString(LocalBuffer);

        } else {
           
            len=sprintf((LPSTR)LocalBuffer,"<VALUE>\"%d.%d.%d.%d\"</VALUE>\r\n",
                       AddressEntry->iae_addr & 0xFF,
                       (AddressEntry->iae_addr >> 8) & 0xFF,
                       (AddressEntry->iae_addr >> 16) & 0xFF,
                       (AddressEntry->iae_addr >> 24) & 0xFF
                       );
            if (pch + len < ((PUCHAR) LocalPropBuffer) + 2*MEMORY_INCREMENT - 80){
               // the 80 characters ensures that we can end this XML data
               // properly
               strcat((LPSTR)pch,LocalBuffer);
               pch = pch + len;
            }
        }
    }

  
    if(PrintToTerminal==FALSE) { 
        sprintf((LPSTR)pch, "</VALUE.ARRAY>\r\n</PROPERTY.ARRAY>");
    }

    FREE_POOL(&TcpRequestQueryInformationEx);
    ZwClose(Handle);        // handle to the TCP driver.
    
    FREE_POOL(&LocalBuffer);
    FREE_POOL(&AddressArray);
    FREE_POOL(&RouteTable);
    FREE_POOL(&IpsiInfo);

    if(!PrintToTerminal){
        
        
        HeadlessDispatch(HeadlessCmdSetBlueScreenData,
                         LocalPropBuffer,
                         2*MEMORY_INCREMENT,
                         NULL,
                         NULL
                         );
        FREE_POOL(&LocalPropBuffer);

        //
        // open up the IP driver so we know if the addresses change
        //
        RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        Status = ZwOpenFile(&Handle,
                            (ACCESS_MASK)FILE_GENERIC_READ,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0
                           );

        if (!NT_SUCCESS(Status)) {
            
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (2).\n")));
            return;
        }

        
        Status = ZwDeviceIoControlFile(Handle,
                                       NULL,
                                       NetAPCRoutine,
                                       NULL,
                                       &GlobalIoStatusBlock,
                                       IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST,
                                       NULL,
                                       0,
                                       NULL,
                                       0
                                      );
                                  
        if (Status == STATUS_PENDING) {
            IoctlSubmitted = TRUE;
        }
        if (putPrompt) {
            SacPutSimpleMessage(SAC_ENTER);
            SacPutSimpleMessage(SAC_PROMPT);            
        }
    
        ZwClose(Handle);
    
    }

    return;

}

VOID
NetAPCRoutine(IN PVOID ApcContext,
              IN PIO_STATUS_BLOCK IoStatusBlock,
              IN ULONG Reserved
              )
/*++

Routine Description:
    This is the APC routine called after IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST
    was completed
    
Arguments:
    
    APCContext    - UNUSED
    IoStatusBlock - Status about the Fate of the IRP
    Reserved      - UNUSED
    

Return Value:

        None.

--*/
{
    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(ApcContext);

    if (IoStatusBlock->Status == STATUS_CANCELLED) {
        // The SAC driver might be unloading
        // BUGBUG - If the IP driver is stopped and restarted 
        // then we are out of the loop. What to do ??
                
        return;

    }
    
    // Refresh the kernel information and resend the IRP

    DoGetNetInfo( FALSE );
    
    return;
}


VOID
SubmitIPIoRequest(
    )
/*++

Routine Description:
    Called the first time by the Processing Thread to actually
    submit the ADDR_CHANGE IOCTL to the IP Driver. Only the
    processing thread can call this and calls it only once successfully. 
    Then on the APC is reentered only through the NetAPCRoutine
    
Arguments:
    
    None.

Return Value:

        None.

--*/
{
    

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Submit IP Ioctl: Entering.\n")));

    DoGetNetInfo( FALSE );
    return;
    
}

VOID
CancelIPIoRequest(
    )
/*++

Routine Description:
    Called by the processing thread during unload of the driver
    to cancel the IOCTL sent to the IP driver
    
Arguments:
    
    None.

Return Value:

        None.

--*/
{

    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes; 
    NTSTATUS Status;
    HANDLE Handle;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Cancel IP Ioctl: Entering.\n")));

    RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                        );
    
    if (!NT_SUCCESS(Status)) {
        // Well, well IP Driver was probably never loaded.
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC Cancel IP IOCTL: Exiting (2).\n")));
        return;
    }
    ZwCancelIoFile(Handle,
                   &IoStatusBlock
                   );
    ZwClose(Handle);


}

VOID
DoMachineInformationCommand(
    VOID
    )
/*++

Routine Description:

    This function displays the contents of a buffer, which in turn contains
    a bunch of machine-specific information that can be used to help identify
    the machine.
    
Arguments:
    
    None.

Return Value:

    None.

--*/
{
    LARGE_INTEGER   TickCount;
    LARGE_INTEGER   ElapsedTime;
    ULONG           ElapsedHours = 0;
    ULONG           ElapsedMinutes = 0;
    ULONG           ElapsedSeconds = 0;
    ULONG           TmpBufferSize;
    PWSTR           TmpBuffer;
    PWSTR           MIBuffer;
    NTSTATUS        Status;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Display Machine Information: Entering.\n")));

    //
    // If the information buffer hasn't been filled in yet, there's not much we can do.
    //
    if( MachineInformation == NULL ) {

        //
        // He's empty.  This shouldn't have happened though because
        // he gets filled as soon as we're initialized.
        //

        IF_SAC_DEBUG( SAC_DEBUG_FUNC_TRACE_LOUD, 
                      KdPrint(("SAC Display Machine Information: MachineInformationBuffer hasn't been initialized yet.\n")));

        SacPutSimpleMessage(SAC_IDENTIFICATION_UNAVAILABLE);

        return;
    }

    //
    // Get machine information
    //
    Status = TranslateMachineInformationText(&MIBuffer);

    if (! NT_SUCCESS(Status)) {
        
        SacPutSimpleMessage(SAC_IDENTIFICATION_UNAVAILABLE);
    
        return;
    
    }
    
    //
    // Display the machine info portion
    //
    SacPutString(MIBuffer);

    FREE_POOL(&MIBuffer);

    //
    // Build and display Elapsed machine uptime.
    //

    // Elapsed TickCount
    KeQueryTickCount( &TickCount );

    // ElapsedTime in seconds.
//    ElapsedTime.QuadPart = (TickCount.QuadPart)/(10000000/KeQueryTimeIncrement());
    ElapsedTime.QuadPart = (TickCount.QuadPart * KeQueryTimeIncrement()) / 10000000;

    ElapsedHours = (ULONG)(ElapsedTime.QuadPart / 3600);
    ElapsedMinutes = (ULONG)(ElapsedTime.QuadPart % 3600) / 60;
    ElapsedSeconds = (ULONG)(ElapsedTime.QuadPart % 3600) % 60;

    TmpBufferSize = 0x100;
    TmpBuffer = (PWSTR)ALLOCATE_POOL( TmpBufferSize, GENERAL_POOL_TAG );

    if( TmpBuffer ) {
        
        SAFE_SWPRINTF(
            TmpBufferSize,
            ((PWSTR)TmpBuffer,
            GetMessage( SAC_HEARTBEAT_FORMAT ),
            ElapsedHours,
            ElapsedMinutes,
            ElapsedSeconds 
            ));
    
        //
        // Display machine uptime
        //
        SacPutString((PWSTR)TmpBuffer);
    
        FREE_POOL(&TmpBuffer);
    
    } 
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Display Machine Information: Exiting.\n")));


    return;
    
}

NTSTATUS
DoChannelListCommand(
    VOID
    )

/*++

Routine Description:

    This routine lists the channels.

Arguments:

    None.

Return Value:

    Status

--*/
{
    NTSTATUS            Status;
    PSAC_CHANNEL        Channel;
    ULONG               i;
    PWCHAR              Buffer;
    ULONG               BufferSize;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelListCommand: Entering.\n")));

    //
    // Allocate local memory
    //
    BufferSize = 8 * sizeof(WCHAR);
    Buffer = ALLOCATE_POOL(BufferSize, GENERAL_POOL_TAG);
    ASSERT_STATUS(Buffer, STATUS_NO_MEMORY);

    //
    // default: we listed the channels
    //
    Status = STATUS_SUCCESS;

    //
    // List all the channels
    //
    SacPutSimpleMessage(SAC_CHANNEL_PROMPT);

    //
    // Iterate through the channels and display the attributes
    // of the active channels
    //
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
        
        PWSTR               Name;
        SAC_CHANNEL_STATUS  ChannelStatus;

        //
        // Query the channel manager for a list of all currently active channels
        //
        Status = ChanMgrGetByIndex(
            i,
            &Channel
            );

        //
        // skip empty slots
        //
        if (Status == STATUS_NOT_FOUND) {
            continue;
        }

        if (! NT_SUCCESS(Status)) {
            break;
        }

        ASSERT(Channel != NULL);

        //
        // Get the channel's status
        //
        ChannelGetStatus(
            Channel,
            &ChannelStatus
            );

        //
        // construct channel attribute information
        //
        SAFE_SWPRINTF(
            BufferSize,
            (Buffer, L"%1d (%s%s)",
            ChannelGetIndex(Channel),
            (ChannelStatus == ChannelStatusInactive) ? L"I" : L"A",
            ((ChannelGetType(Channel) == ChannelTypeVTUTF8) ||
             (ChannelGetType(Channel) == ChannelTypeCmd)
             ) ? L"V" : L"R"
            ));
        
        SacPutString(Buffer);

        SacPutString(L"    ");

        ChannelGetName(
            Channel,
            &Name
            );
        SacPutString(Name);
        FREE_POOL(&Name);

        SacPutString(L"\r\n");

        //
        // We are done with the channel
        //
        Status = ChanMgrReleaseChannel(Channel);
    
        if (! NT_SUCCESS(Status)) {
            break;
        }

    }
    
    ASSERT(Buffer);
    FREE_POOL(&Buffer);

    return Status;
}

NTSTATUS
DoChannelCloseByNameCommand(
    PCSTR   ChannelName
    )

/*++

Routine Description:

    This routine closes the channel of the given name.

Arguments:

    ChannelName - the name of the channel to close

Return Value:

    Status

--*/
{
    NTSTATUS            Status;
    PSAC_CHANNEL        Channel;
    ULONG               Count;
    PWSTR               Name;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelCloseCommand: Entering.\n")));

    //
    // Allocate local memory
    //
    Name = ALLOCATE_POOL(SAC_MAX_CHANNEL_NAME_SIZE, GENERAL_POOL_TAG);
    ASSERT_STATUS(Name, STATUS_NO_MEMORY);
    
    //
    // Copy the ASCII to Unicode
    //
    Count = ConvertAnsiToUnicode(Name, (PSTR)ChannelName, SAC_MAX_CHANNEL_NAME_LENGTH+1);
    ASSERT_STATUS(Count > 0, STATUS_INVALID_PARAMETER);

    //
    // Attempt to find the specified channel
    //
    Status = ChanMgrGetChannelByName(
        Name,
        &Channel
        );

    if (NT_SUCCESS(Status)) {
        
        do {

            //
            // If the user is trying to close the SAC channel,
            // then report an error message to the user and fail
            //
            if (ConMgrIsSacChannel(Channel)) {

                //
                // tell the user they can't delete the SAC channel
                //
                SacPutSimpleMessage(SAC_CANNOT_REMOVE_SAC_CHANNEL);

                Status = STATUS_UNSUCCESSFUL;

                break;

            }

            //
            // we currently own the current channel lock.
            // hence, since closing a channel results in a call to the
            // channel IO Manager, we will get into a deadlock
            // over the current channel lock.  
            // so we can do this after we get out of the consumer loop
            //
            ExecutePostConsumerCommand      = CloseChannel;
            ExecutePostConsumerCommandData  = (PVOID)Channel;
        
        } while ( FALSE );
        
    } else {

        //
        // We couldn't find the channel to close
        //
        SacPutSimpleMessage(SAC_CHANNEL_NOT_FOUND);
    
    }

    SAFE_FREE_POOL(&Name);

    return Status;
    
}

NTSTATUS
DoChannelCloseByIndexCommand(
    ULONG   ChannelIndex
    )
/*++

Routine Description:

    This routine closes the channel with the specified index

Arguments:

    ChannelName - the name of the channel

Return Value:

    Status

--*/
{
    NTSTATUS            Status;
    PSAC_CHANNEL        Channel;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelSwitchByIndexCommand: Entering.\n")));

    ASSERT_STATUS(ChannelIndex < MAX_CHANNEL_COUNT, STATUS_INVALID_PARAMETER);

    do {

        //
        // Attempt to get the new current channel by index.
        // If we are successful, we need to keep a reference 
        // count on the new current channel since we hold
        // it until we switch away.
        //
        Status = ChanMgrGetByIndex(
            ChannelIndex,
            &Channel
            );

        if (! NT_SUCCESS(Status)) {
            
            //
            // We couldn't find the channel
            //
            SacPutSimpleMessage(SAC_CHANNEL_NOT_FOUND_AT_INDEX);
        
            break;

        }

        //
        // If the user is trying to close the SAC channel,
        // then report an error message to the user and fail
        //
        if (ConMgrIsSacChannel(Channel)) {
            
            //
            // tell the user they can't delete the SAC channel
            //
            SacPutSimpleMessage(SAC_CANNOT_REMOVE_SAC_CHANNEL);
        
            Status = STATUS_UNSUCCESSFUL;
            
            break;
        
        }

        //
        // we currently own the current channel lock.
        // hence, since closing a channel results in a call to the
        // channel IO Manager, we will get into a deadlock
        // over the current channel lock.  
        // so we can do this after we get out of the consumer loop
        //
        ExecutePostConsumerCommand      = CloseChannel;
        ExecutePostConsumerCommandData  = (PVOID)Channel;

    } while ( FALSE );

    return Status;
}

NTSTATUS
DoChannelSwitchByNameCommand(
    PCSTR   ChannelName
    )
/*++

Routine Description:

    This routine switchs to the channel with the specified name.

Arguments:

    ChannelName - the name of the channel

Return Value:

    Status

--*/
{
    NTSTATUS            Status;
    PSAC_CHANNEL        Channel;
    ULONG               Count;
    PWSTR               Name;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelSwitchByNameCommand: Entering.\n")));

    //
    // Allocate local memory
    //
    Name = ALLOCATE_POOL(SAC_MAX_CHANNEL_NAME_SIZE, GENERAL_POOL_TAG);
    ASSERT_STATUS(Name, STATUS_NO_MEMORY);
    
    //
    // Copy the ASCII to Unicode
    //
    Count = ConvertAnsiToUnicode(Name, (PSTR)ChannelName, SAC_MAX_CHANNEL_NAME_LENGTH+1);
    ASSERT_STATUS(Count > 0, STATUS_INVALID_PARAMETER);

    do {

        //
        // Attempt to get the specified channel
        //
        Status = ChanMgrGetChannelByName(
            Name,
            &Channel
            );

        if (! NT_SUCCESS(Status)) {
            
            //
            // We couldn't find the channel
            //
            SacPutSimpleMessage(SAC_CHANNEL_NOT_FOUND);
        
            break;

        }

        //
        // Change the current channel to the specified channel
        //
        // Go from the SAC --> specified channel
        //
        Status = ConMgrSetCurrentChannel(Channel);

        if (! NT_SUCCESS(Status)) {
            break;
        }
        
#if 0
        //
        // Flush the channel data to the screen
        //
        Status = ConMgrDisplayCurrentChannel();
#else
        //
        // Let the user know we switched via the Channel switching interface
        //
        Status = ConMgrDisplayFastChannelSwitchingInterface(Channel);
#endif

        if (! NT_SUCCESS(Status)) {
            break;        
        }
    
        //
        // Note: we DO NOT release the channel here because
        //       it is now the current channel
        //

    } while ( FALSE );

    SAFE_FREE_POOL(&Name);

    return Status;
}

NTSTATUS
DoChannelSwitchByIndexCommand(
    ULONG   ChannelIndex
    )
/*++

Routine Description:

    This routine switchs to the channel with the specified index

Arguments:

    ChannelName - the name of the channel

Return Value:

    Status

--*/
{
    NTSTATUS            Status;
    PSAC_CHANNEL        Channel;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelSwitchByIndexCommand: Entering.\n")));

    ASSERT_STATUS(ChannelIndex < MAX_CHANNEL_COUNT, STATUS_INVALID_PARAMETER);

    do {

        //
        // Attempt to get the new current channel by index.
        // If we are successful, we need to keep a reference 
        // count on the new current channel since we hold
        // it until we switch away.
        //
        Status = ChanMgrGetByIndex(
            ChannelIndex,
            &Channel
            );

        if (! NT_SUCCESS(Status)) {
            
            //
            // We couldn't find the channel
            //
            SacPutSimpleMessage(SAC_CHANNEL_NOT_FOUND_AT_INDEX);
        
            break;

        }

        //
        // Change the current channel to the specified channel
        //
        // Go from the SAC --> specified channel
        //
        Status = ConMgrSetCurrentChannel(Channel);

        if (! NT_SUCCESS(Status)) {
            break;
        }
        
#if 0
        //
        // Flush the channel data to the screen
        //
        Status = ConMgrDisplayCurrentChannel();
#else
        //
        // Let the user know we switched via the Channel switching interface
        //
        Status = ConMgrDisplayFastChannelSwitchingInterface(Channel);
#endif

        if (! NT_SUCCESS(Status)) {
            break;        
        }
    
        //
        // Note: we DO NOT release the channel here because
        //       it is now the current channel
        //
    
    } while ( FALSE );

    return Status;
}

VOID
DoChannelCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine lists the channels if a NULL name is given, otw it closes the channel
    of the given name.

Arguments:

    InputLine - The user's input line.

Return Value:

    None.

--*/
{
    NTSTATUS    Status;
    PUCHAR      pch;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelCommand: Exiting (1).\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }

    //
    // goto the sub-commmand
    //
    pch = InputLine;
    pch += (sizeof(CHANNEL_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    //
    // if we are at the end of the command, do a list
    // else, try to find a sub-command
    //
    if (*pch == '\0') {

        DoChannelListCommand();

    } else {

        //
        // determine which sub-command we have
        //
        if (!strncmp((LPSTR)pch, 
                     EXTENDED_HELP_SUBCOMMAND, 
                     strlen(EXTENDED_HELP_SUBCOMMAND))) {
        
                SacPutSimpleMessage(SAC_HELP_CH_CMD_EXT);
            
        } else if (!strncmp((LPSTR)pch, 
                     CHANNEL_CLOSE_NAME_COMMAND_STRING, 
                     strlen(CHANNEL_CLOSE_NAME_COMMAND_STRING))) {

            //
            // skip the sub-command and determine which channel to close
            //
            pch += (sizeof(CHANNEL_CLOSE_NAME_COMMAND_STRING) - sizeof(UCHAR));

            SKIP_WHITESPACE(pch);

            if (*pch == '\0') {
                SacPutSimpleMessage(SAC_INVALID_PARAMETER);
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelCommand: Exiting (2).\n")));
                return;
            }

            Status = DoChannelCloseByNameCommand((PCSTR)pch);

        } else if (!strncmp((LPSTR)pch, 
                     CHANNEL_CLOSE_INDEX_COMMAND_STRING, 
                     strlen(CHANNEL_CLOSE_INDEX_COMMAND_STRING))) {

            ULONG   ChannelIndex;

            //
            // Determine which channel to close
            //
            pch += (sizeof(CHANNEL_CLOSE_INDEX_COMMAND_STRING) - sizeof(UCHAR));

            SKIP_WHITESPACE(pch);

            if (*pch == '\0') {
                SacPutSimpleMessage(SAC_INVALID_PARAMETER);
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelCommand: Exiting (2).\n")));
                return;
            }
            
            if (!IS_NUMBER(*pch)) {
                SacPutSimpleMessage(SAC_INVALID_PARAMETER);
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelCommand: Exiting (3).\n")));
                return;
            }
            
            ChannelIndex = atoi((LPCSTR)pch);
            
            if (ChannelIndex < MAX_CHANNEL_COUNT) {
                Status = DoChannelCloseByIndexCommand(ChannelIndex);
            } else {
                SacPutSimpleMessage(SAC_INVALID_PARAMETER);
            }

        } else if (!strncmp((LPSTR)pch, 
                            CHANNEL_SWITCH_NAME_COMMAND_STRING, 
                            strlen(CHANNEL_SWITCH_NAME_COMMAND_STRING))) {
        
            //
            // Determine which channel to switch to
            //
            pch += (sizeof(CHANNEL_SWITCH_NAME_COMMAND_STRING) - sizeof(UCHAR));

            SKIP_WHITESPACE(pch);

            if (*pch == '\0') {
                SacPutSimpleMessage(SAC_INVALID_PARAMETER);
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelCommand: Exiting (2).\n")));
                return;
            }
        
            DoChannelSwitchByNameCommand((PCSTR)pch);

        } else if (!strncmp((LPSTR)pch, 
                            CHANNEL_SWITCH_INDEX_COMMAND_STRING, 
                            strlen(CHANNEL_SWITCH_INDEX_COMMAND_STRING))) {
        
            ULONG   ChannelIndex;

            //
            // Determine which channel to switch to
            //
            pch += (sizeof(CHANNEL_SWITCH_INDEX_COMMAND_STRING) - sizeof(UCHAR));

            SKIP_WHITESPACE(pch);

            if (*pch == '\0') {
                SacPutSimpleMessage(SAC_INVALID_PARAMETER);
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelCommand: Exiting (2).\n")));
                return;
            }
            
            if (!IS_NUMBER(*pch)) {
                SacPutSimpleMessage(SAC_INVALID_PARAMETER);
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelCommand: Exiting (3).\n")));
                return;
            }
            
            ChannelIndex = atoi((LPCSTR)pch);
            
            if (ChannelIndex < MAX_CHANNEL_COUNT) {
                DoChannelSwitchByIndexCommand(ChannelIndex);
            } else {
                SacPutSimpleMessage(SAC_INVALID_PARAMETER);
            }

        } else if (!strncmp((LPSTR)pch, 
                            CHANNEL_LIST_COMMAND_STRING, 
                            strlen(CHANNEL_LIST_COMMAND_STRING))) {
            
            DoChannelListCommand();
        
        } else {

            SacPutSimpleMessage(SAC_UNKNOWN_COMMAND);

        }

    }

    return;
    
}

VOID
DoCmdCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine launches a Command Console Channel

Arguments:

    InputLine - The user's input line.

Return Value:

    None.

--*/
{
    NTSTATUS    Status;
    BOOLEAN     IsFull;

    UNREFERENCED_PARAMETER(InputLine);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCmdCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCmdCommand: Exiting (1).\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }

    //
    // Ensure that it is possible to add another channel before
    // launching a cmd session.
    //
    Status = ChanMgrIsFull(&IsFull);
    
    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_CMD_SERVICE_FAILURE);
        SAC_PUT_ERROR_STRING(Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCmdCommand: Exiting (2).\n")));
        return;
    }

    if (IsFull) {

        //
        // Notify the user
        //
        SacPutSimpleMessage(SAC_CMD_CHAN_MGR_IS_FULL);

        return;

    }

    KeWaitForMutexObject(
        &SACCmdEventInfoMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    //
    // Before we do anything with the cmd operation, make sure
    // the user-mode service has registered itself with us. If not,
    // then there is no point in going further.
    //
    if (!UserModeServiceHasRegisteredCmdEvent()) {

        //
        // inform the user
        //
        SacPutSimpleMessage(SAC_CMD_SERVICE_NOT_REGISTERED);
    
        goto DoCmdCommandCleanup;
    
    }

    //
    // Fire the event in the user-mode app that is responsible for launching
    // the cmd console channel
    //
    Status = InvokeUserModeService();

    if (Status == STATUS_TIMEOUT) {
        //
        // Service didn't respond in Timeout period.  
        // Service may not be working properly or usermode is unresponsive
        //
        SacPutSimpleMessage(SAC_CMD_SERVICE_TIMED_OUT);

    } else if (NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_CMD_SERVICE_SUCCESS);

    } else {
        
        //
        // Error condition
        //
        SacPutSimpleMessage(SAC_CMD_SERVICE_FAILURE);
        SAC_PUT_ERROR_STRING(Status);
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCmdCommand: Error %X.\n", Status)));

    }

DoCmdCommandCleanup:

    KeReleaseMutex(&SACCmdEventInfoMutex, FALSE);

}

#if ENABLE_CHANNEL_LOCKING
VOID
DoLockCommand(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS            Status;
    PSAC_CHANNEL        Channel;
    ULONG               i;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelLockCommand: Entering.\n")));

    //
    // Iterate through the channels via the channel manager
    // and fire the lock events
    //
    
    //
    // default: we listed the channels
    //
    Status = STATUS_SUCCESS;

    //
    // Iterate through the channels and display the attributes
    // of the active channels
    //
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
        
        //
        // Query the channel manager for a list of all currently active channels
        //
        Status = ChanMgrGetByIndex(
            i,
            &Channel
            );

        //
        // skip empty slots
        //
        if (Status == STATUS_NOT_FOUND) {
            continue;
        }

        if (! NT_SUCCESS(Status)) {
            break;
        }

        ASSERT(Channel != NULL);

        //
        // If the channel has a lock event, 
        // then fire it
        //
        if (ChannelHasLockEvent(Channel)) {
            
            Status = ChannelSetLockEvent(Channel);

            if (! NT_SUCCESS(Status)) {
                break;
            }
        
        }

        //
        // We are done with the channel
        //
        Status = ChanMgrReleaseChannel(Channel);
    
        if (! NT_SUCCESS(Status)) {
            break;
        }

    }
    
    //
    // notify the SAC user that the lock 
    //
    SacPutSimpleMessage(SAC_CMD_CHANNELS_LOCKED);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\event.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    event.c

Abstract:

    This module contains the event handling routines for SAC.

Author:

    Sean Selitrennikoff (v-seans) - Jan 22, 1999
    Brian Guarraci (briangu)

Revision History:

--*/

#include "sac.h"

#if DBG
//
// A timer to show how many times we've hit the TimerDPC routine
//
// Note: use KD to view this value
//
ULONG   TimerDpcCount = 0;
#endif

//
// Serial Port Buffer globals
//
PUCHAR  SerialPortBuffer = NULL;
ULONG   SerialPortProducerIndex = 0;
ULONG   SerialPortConsumerIndex = 0;

VOID
WorkerProcessEvents(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

        This is the routine for the worker thread.  It blocks on an event, when
    the event is signalled, then that indicates a request is ready to be processed.    

Arguments:

    DeviceContext - A pointer to this device.

Return Value:

        None.

--*/
{
    //
    // Call the Worker handler
    //
    // Note: currently hardcoded to the console manager
    //
    IoMgrWorkerProcessEvents(DeviceContext);
}


VOID
TimerDpcRoutine(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

        This is a DPC routine that is queue'd by DriverEntry.  It is used to check for any
    user input and then processes them.

Arguments:

    DeferredContext - A pointer to the device context.
    
    All other parameters are unused.

Return Value:

        None.

--*/
{
    NTSTATUS    Status;
    SIZE_T      i;
    BOOLEAN     HaveNewData;
    HEADLESS_RSP_GET_BYTE Response;

    //
    // Keep track of how many times we've been here
    //
#if DBG
    InterlockedIncrement((volatile long *)&TimerDpcCount);
#endif

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    //
    // default: we didn't receive any new data
    //
    HaveNewData = FALSE;
    
    i = sizeof(HEADLESS_RSP_GET_BYTE);
    
    do {

        //
        // Check for user input
        //
        Status = HeadlessDispatch(
            HeadlessCmdGetByte,
            NULL,
            0,
            &Response,
            &i
            );

        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // If we received new data, add it to the buffer
        //
        if (Response.Value != 0) {
        
            //
            // we have new data
            //
            HaveNewData = TRUE;
            
            //
            // Assign the new value to the current producer index
            // 
            // Note: We overrun data in the buffer if the consumer hasn't caught up
            //
            SerialPortBuffer[SerialPortProducerIndex] = Response.Value;

            //
            // Compute the new producer index and store it atomically
            //
            InterlockedExchange(
                (volatile long *)&SerialPortProducerIndex, 
                (SerialPortProducerIndex + 1) % SERIAL_PORT_BUFFER_LENGTH
                );

        }
    
    } while ( Response.Value != 0 );                                      

    //
    // if we have new data, notify the worker thread to process the serial port buffer 
    //
    if (HaveNewData) {
        
        PSAC_DEVICE_CONTEXT DeviceContext;
        
        ProcessingType = SAC_PROCESS_SERIAL_PORT_BUFFER;
        DeviceContext = (PSAC_DEVICE_CONTEXT)DeferredContext;
        
        KeSetEvent(
            &(DeviceContext->ProcessEvent), 
            DeviceContext->PriorityBoost, 
            FALSE
            );
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\dispatch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the dispatch routines for SAC.

Author:

    Sean Selitrennikoff (v-seans) - Jan 13, 1999
    Brian Guarraci (briangu), 2001

Revision History:

--*/

#include <initguid.h>

#include "sac.h"
           
DEFINE_GUID(SAC_CMD_CHANNEL_APPLICATION_GUID,       0x63d02271, 0x8aa4, 0x11d5, 0xbc, 0xcf, 0x00, 0xb0, 0xd0, 0x14, 0xa2, 0xd0);

NTSTATUS
DispatchClose(
    IN PSAC_DEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    );

NTSTATUS
DispatchCreate(
    IN PSAC_DEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    );


NTSTATUS
Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for SAC.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

Security:

    interface:
    
    external --> internal
        exposed to anything that can get a handle device object
    
--*/

{
    PSAC_DEVICE_CONTEXT DeviceContext = (PSAC_DEVICE_CONTEXT)DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    //
    //
    //
    Status = STATUS_UNSUCCESSFUL;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC Dispatch: Entering.\n")));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MajorFunction) {
    
    case IRP_MJ_CREATE:
        
        Status = DispatchCreate(DeviceContext, Irp);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC Dispatch: Exiting with status 0x%x\n", Status)));

        break;

    case IRP_MJ_CLEANUP:

#if ENABLE_SERVICE_FILE_OBJECT_CHECKING

        //
        // Determine if the process that is closing
        // their driver handle owns any channels or
        // is the process that registered the cmd event info.
        // If it is any of these, close the respective
        // resource.
        //
        
        //
        // Compare the FileObject against 
        //
        //  the service fileobject
        //  the existing channel fileobjects
        //
        //
                
        if (IsCmdEventRegistrationProcess(IrpSp->FileObject)) {
        
            Status = UnregisterSacCmdEvent(IrpSp->FileObject);

            if (NT_SUCCESS(Status)) {

                //
                // Notify the Console Manager that the service has unregistered
                //
                Status = IoMgrHandleEvent(
                    IO_MGR_EVENT_UNREGISTER_SAC_CMD_EVENT,
                    NULL,
                    NULL
                    );
            
            }

        } 

#endif
        else {

            //
            // Find all channels that have the same File object
            // and notify the Io Mgr that they should be closed
            //
            Status = ChanMgrCloseChannelsWithFileObject(IrpSp->FileObject);
        
        }

        //
        // we return SUCCESS regardless of our attempts to clean up 
        // the service or channels.  
        // 
        Status = STATUS_SUCCESS;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC Dispatch: Exiting cleanup status 0x%x\n", Status)));

        break;

    case IRP_MJ_CLOSE:

        Status = DispatchClose(DeviceContext, Irp);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC Dispatch: Exiting close status 0x%x\n", Status)));

        break;

    case IRP_MJ_DEVICE_CONTROL:

        ASSERT(0);
        Status = DispatchDeviceControl(DeviceObject, Irp);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC Dispatch: Exiting with status 0x%x\n", Status)));

        break;

    default:
        IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                          KdPrint(( "SAC Dispatch: Invalid major function %lx\n", IrpSp->MajorFunction )));
        Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
        IoCompleteRequest(Irp, DeviceContext->PriorityBoost);

        Status = STATUS_NOT_IMPLEMENTED;
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC Dispatch: Exiting with status 0x%x\n", Status)));

        break;
    }

    return Status;

} // Dispatch


NTSTATUS
DispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for SAC IOCTLs.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

Security:

    interface:
    
    external -> internal
    internal -> external

--*/

{
    NTSTATUS                Status;
    PSAC_DEVICE_CONTEXT     DeviceContext;
    PIO_STACK_LOCATION      IrpSp;
    ULONG                   i;
    ULONG                   ResponseLength;
    ULONG                   IoControlCode;

    ResponseLength = 0;

    DeviceContext = (PSAC_DEVICE_CONTEXT)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DispatchDeviceControl: Entering.\n")));

    //
    // Get the IOCTL code
    //
    IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    switch (IoControlCode) {
    case IOCTL_SAC_OPEN_CHANNEL: {
        
        PSAC_CHANNEL                    Channel;
        PSAC_CMD_OPEN_CHANNEL           OpenChannelCmd;
        PSAC_RSP_OPEN_CHANNEL           OpenChannelRsp;
        PSAC_CHANNEL_OPEN_ATTRIBUTES    Attributes;

        //
        //
        //
        Channel = NULL;

        //
        // Verify the parameters of the IRP
        //
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(SAC_CMD_OPEN_CHANNEL)) {
            Status = STATUS_INVALID_BUFFER_SIZE;
            break;
        }
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != sizeof(SAC_RSP_OPEN_CHANNEL)) {
            Status = STATUS_INVALID_BUFFER_SIZE;
            break;
        }

        //
        // Get the IRP buffers
        //
        OpenChannelCmd = (PSAC_CMD_OPEN_CHANNEL)Irp->AssociatedIrp.SystemBuffer;
        OpenChannelRsp = (PSAC_RSP_OPEN_CHANNEL)Irp->AssociatedIrp.SystemBuffer;
        
        //
        // Get the attributes from the command structure
        //
        Attributes = &OpenChannelCmd->Attributes;

        //
        // Verify that the Channel Type is valid
        //
        if (! ChannelIsValidType(Attributes->Type)) {
            Status = STATUS_INVALID_PARAMETER_1;
            break;
        }

        //
        // Verify that if the user wants to use the CLOSE_EVENT, we received on to use
        //
        if (Attributes->Flags & SAC_CHANNEL_FLAG_CLOSE_EVENT) {
#if DEBUG_DISPATCH
            ASSERT(Attributes->CloseEvent != NULL);
#endif            
            if (Attributes->CloseEvent == NULL) {
                Status = STATUS_INVALID_PARAMETER_5;
                break;
            }
        } else {
#if DEBUG_DISPATCH
            ASSERT(Attributes->CloseEvent == NULL);
#endif            
            if (Attributes->CloseEvent !=  NULL) {
                Status = STATUS_INVALID_PARAMETER_5;
                break;
            }
        }
        
        //
        // Verify that if the user wants to use the HAS_NEW_DATA_EVENT, we received one to use
        //
        if (Attributes->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) {
#if DEBUG_DISPATCH
            ASSERT(Attributes->HasNewDataEvent);
#endif            
            if (! Attributes->HasNewDataEvent) {
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }
        } else {
#if DEBUG_DISPATCH
            ASSERT(Attributes->HasNewDataEvent == NULL);
#endif            
            if (Attributes->HasNewDataEvent !=  NULL) {
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }
        }
        
#if ENABLE_CHANNEL_LOCKING
        //
        // Verify that if the user wants to use the LOCK_EVENT, we received one to use
        //
        if (Attributes->Flags & SAC_CHANNEL_FLAG_LOCK_EVENT) {
#if DEBUG_DISPATCH
            ASSERT(Attributes->LockEvent);
#endif            
            if (! Attributes->LockEvent) {
                Status = STATUS_INVALID_PARAMETER_7;
                break;
            }
        } else {
#if DEBUG_DISPATCH
            ASSERT(Attributes->LockEvent == NULL);
#endif            
            if (Attributes->LockEvent !=  NULL) {
                Status = STATUS_INVALID_PARAMETER_7;
                break;
            }
        }
#endif
        
        //
        // Verify that if the user wants to use the REDRAW_EVENT, we received one to use
        //
        if (Attributes->Flags & SAC_CHANNEL_FLAG_REDRAW_EVENT) {
#if DEBUG_DISPATCH
            ASSERT(Attributes->RedrawEvent);
#endif            
            if (! Attributes->RedrawEvent) {
                Status = STATUS_INVALID_PARAMETER_8;
                break;
            }
        } else {
#if DEBUG_DISPATCH
            ASSERT(Attributes->RedrawEvent == NULL);
#endif            
            if (Attributes->RedrawEvent !=  NULL) {
                Status = STATUS_INVALID_PARAMETER_8;
                break;
            }
        }
        
        //
        // SECURITY:
        //
        //  at this point we have at least a properly formed set of flags
        //  and event handles.  The events still need to be validated, however.
        //  this is done via ChanMgrCreateChannel.
        //

        //
        // Create the channel based on type
        //
        if (Attributes->Type == ChannelTypeCmd) {
        
            PSAC_CHANNEL_OPEN_ATTRIBUTES tmpAttributes;
            PWCHAR                       Name;
            PCWSTR                       Description;

            //
            //
            //
            tmpAttributes   = NULL;
            Name            = NULL;
            Description     = NULL;

            //
            // Create a channel for this IRP
            //
            do {

                //
                // the cmd channel requires all of the events
                // hence, ensure we have them
                //
                if (!(Attributes->Flags & SAC_CHANNEL_FLAG_CLOSE_EVENT) ||
                    !(Attributes->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) ||
                    !(Attributes->Flags & SAC_CHANNEL_FLAG_LOCK_EVENT) ||
                    !(Attributes->Flags & SAC_CHANNEL_FLAG_REDRAW_EVENT)) {
                
                    Status = STATUS_INVALID_PARAMETER_7;
                    break;

                }

                //
                // Allocate a temporary attributes structure that
                // we'll populate with attributes appropriate for
                // creating a cmd type channel
                //
                tmpAttributes = ALLOCATE_POOL(sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES), GENERAL_POOL_TAG);
                if (! tmpAttributes) {
                    Status = STATUS_NO_MEMORY;
                    break;
                }

                //
                // Allocate a buffer for the channel's name
                //
                Name = ALLOCATE_POOL(SAC_MAX_CHANNEL_NAME_SIZE, GENERAL_POOL_TAG);
                if (! Name) {
                    Status = STATUS_NO_MEMORY;
                    break;
                }

                //
                // Generate a name for the command console channel
                //
                Status = ChanMgrGenerateUniqueCmdName(Name);
                if (! NT_SUCCESS(Status)) {
                    break;
                }

                //
                // Initialize the Command Console attributes
                //
                RtlZeroMemory(tmpAttributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

                tmpAttributes->Type             = Attributes->Type;
                
                // attempt to copy the name
                wcsncpy(tmpAttributes->Name, Name, SAC_MAX_CHANNEL_NAME_LENGTH);
                tmpAttributes->Name[SAC_MAX_CHANNEL_NAME_LENGTH] = UNICODE_NULL;
                
                // attempt to copy the channel description
                Description = GetMessage(CMD_CHANNEL_DESCRIPTION);
                ASSERT(Description);
                if (!Description) {
                    Status = STATUS_NO_MEMORY;
                    break;
                }
                wcsncpy(tmpAttributes->Description, Description, SAC_MAX_CHANNEL_DESCRIPTION_LENGTH);
                tmpAttributes->Description[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH] = UNICODE_NULL;
                
                tmpAttributes->Flags            = Attributes->Flags | 
                                                  SAC_CHANNEL_FLAG_APPLICATION_TYPE;
                tmpAttributes->CloseEvent       = Attributes->CloseEvent;
                tmpAttributes->HasNewDataEvent  = Attributes->HasNewDataEvent;
#if ENABLE_CHANNEL_LOCKING
                tmpAttributes->LockEvent        = Attributes->LockEvent;
#endif            
                tmpAttributes->RedrawEvent      = Attributes->RedrawEvent;
                tmpAttributes->ApplicationType  = SAC_CMD_CHANNEL_APPLICATION_GUID;

                //
                // attempt to create the new channel
                //
                Status = ChanMgrCreateChannel(
                    &Channel, 
                    tmpAttributes
                    );

            } while (FALSE);
        
            //
            // Cleanup
            //
            SAFE_FREE_POOL(&Name);
            SAFE_FREE_POOL(&tmpAttributes);
        
        } else {
            
            //
            // Validate the Name & Description strings
            //

            //
            // Verify name string is NULL terminated.
            //
            i = 0;
            while (i < SAC_MAX_CHANNEL_NAME_LENGTH) {
                if (Attributes->Name[i] == UNICODE_NULL) {
                    break;
                }

                i++;
            }

            //
            // fail if string is not NULL terminated or if string is empty
            //
            if ((i == SAC_MAX_CHANNEL_NAME_LENGTH) || (i == 0)) {
                Status = STATUS_INVALID_PARAMETER_2;
                break;
            }

            //
            // Verify description string is NULL terminated.
            // Note: the Description is allowed to have zero length, so we don't check it.
            //
            i = 0;
            while (i < SAC_MAX_CHANNEL_DESCRIPTION_LENGTH) {
                if (Attributes->Description[i] == UNICODE_NULL) {
                    break;
                }

                i++;
            }

            if (i == SAC_MAX_CHANNEL_DESCRIPTION_LENGTH) {
                Status = STATUS_INVALID_PARAMETER_3;
                break;
            }

            //
            // attempt to create the new channel
            //
            Status = ChanMgrCreateChannel(
                &Channel, 
                Attributes
                );

        }
        
        if (NT_SUCCESS(Status)) {

            //
            // Keep track of the File Object used to reference the driver
            //
            ChannelSetFileObject(Channel, IrpSp->FileObject);

            //
            // Populate the response message with the new channel handle
            //
            OpenChannelRsp->Handle = ChannelGetHandle(Channel);
            ResponseLength = sizeof(SAC_RSP_OPEN_CHANNEL);

            //
            // Notify the Console Manager that a new channel has been created
            //
            IoMgrHandleEvent(
                IO_MGR_EVENT_CHANNEL_CREATE,
                Channel,
                NULL
                );
            
        }

        break;

    }
    
    case IOCTL_SAC_CLOSE_CHANNEL: {

        PSAC_CMD_CLOSE_CHANNEL  ChannelCloseCmd;
        PSAC_CHANNEL            Channel;
        
        //
        // Verify the parameters of the IRP
        //
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(SAC_CMD_CLOSE_CHANNEL)) {
            Status = STATUS_INVALID_BUFFER_SIZE;
            break;
        }

        //
        // Close the given channel.
        //
        ChannelCloseCmd = (PSAC_CMD_CLOSE_CHANNEL)Irp->AssociatedIrp.SystemBuffer;

        //
        // Get the referred channel by it's handle while making
        // sure the driver handle is the same one as the one
        // that created the channel - the same process
        //
        Status = ChanMgrGetByHandleAndFileObject(
            ChannelCloseCmd->Handle, 
            IrpSp->FileObject,
            &Channel
            );

        if (NT_SUCCESS(Status)) {

            //
            // close the channel
            //
            Status = ChanMgrCloseChannel(Channel);

            //
            // We are done with the channel
            //
            ChanMgrReleaseChannel(Channel);

        }

        break;

    }

    case IOCTL_SAC_WRITE_CHANNEL: {

        PSAC_CMD_WRITE_CHANNEL  ChannelWriteCmd;
        PSAC_CHANNEL            Channel;

        //
        // Verify the parameters of the IRP
        //
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SAC_CMD_WRITE_CHANNEL)) {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Get the Write cmd structure
        //
        ChannelWriteCmd = (PSAC_CMD_WRITE_CHANNEL)Irp->AssociatedIrp.SystemBuffer;

        //
        // Verify that the specified write bufferSize is reasonable
        //
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
            (sizeof(SAC_CMD_WRITE_CHANNEL) + ChannelWriteCmd->Size)) {
            
            //
            // if the buffer sizes dont match, 
            // then the specified the wrong size
            //
            Status = STATUS_INVALID_PARAMETER_2;
            
            break;
        
        }

        //
        // Get the referred channel by it's handle while making
        // sure the driver handle is the same one as the one
        // that created the channel - the same process
        //
        Status = ChanMgrGetByHandleAndFileObject(
            ChannelWriteCmd->Handle, 
            IrpSp->FileObject,
            &Channel
            );

        if (NT_SUCCESS(Status)) {

            //
            // Call the I/O Manager's OWrite method
            //
            Status = IoMgrHandleEvent(
                IO_MGR_EVENT_CHANNEL_WRITE,
                Channel,
                ChannelWriteCmd
                );

            //
            // We are done with the channel
            //
            ChanMgrReleaseChannel(Channel);

        }
        
#if DEBUG_DISPATCH
        ASSERT(NT_SUCCESS(Status) || Status == STATUS_NOT_FOUND);
#endif

        break;

    }
    
    case IOCTL_SAC_READ_CHANNEL: {

        PSAC_CHANNEL            Channel;
        PSAC_CMD_READ_CHANNEL   ChannelReadCmd;
        PSAC_RSP_READ_CHANNEL   ChannelReadRsp;

        //
        //
        //
        Channel = NULL;

        //
        // Verify the parameters of the IRP
        //
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(SAC_CMD_READ_CHANNEL)) {
            Status = STATUS_INVALID_BUFFER_SIZE;
            break;
        }
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SAC_RSP_READ_CHANNEL)) {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Read from the given channel.
        //
        ChannelReadCmd = (PSAC_CMD_READ_CHANNEL)Irp->AssociatedIrp.SystemBuffer;

        //
        // Get the referred channel by it's handle while making
        // sure the driver handle is the same one as the one
        // that created the channel - the same process
        //
        Status = ChanMgrGetByHandleAndFileObject(
            ChannelReadCmd->Handle, 
            IrpSp->FileObject,
            &Channel
            );

        if (NT_SUCCESS(Status)) {

            ChannelReadRsp = (PSAC_RSP_READ_CHANNEL)Irp->AssociatedIrp.SystemBuffer;

            //
            // SECURITY:
            //
            //      it is safe to use the OutputBufferLength since we know the buffer
            //      is large enough to hold at least one byte.
            //      the response structure is essentially a byte array of bytes
            //      read, we read the # of bytes specified by OutputBufferLength 
            //
            Status = ChannelIRead(
                Channel,
                &(ChannelReadRsp->Buffer[0]),
                IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                &ResponseLength
                );

            //
            // We are done with the channel
            //
            ChanMgrReleaseChannel(Channel);

        }
        
#if DEBUG_DISPATCH
        ASSERT(NT_SUCCESS(Status) || Status == STATUS_NOT_FOUND);
#endif        

        break;

    }
    
    case IOCTL_SAC_POLL_CHANNEL: {

        PSAC_CHANNEL            Channel;
        PSAC_CMD_POLL_CHANNEL   PollChannelCmd;
        PSAC_RSP_POLL_CHANNEL   PollChannelRsp;

        //
        //
        //
        Channel = NULL;

        //
        // Verify the parameters of the IRP
        //
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(SAC_CMD_POLL_CHANNEL)) {
            Status = STATUS_INVALID_BUFFER_SIZE;
            break;
        }
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != sizeof(SAC_RSP_POLL_CHANNEL)) {
            Status = STATUS_INVALID_BUFFER_SIZE;
            break;
        }

        //
        // get the channel specified by the incoming channel handle
        //
        PollChannelCmd = (PSAC_CMD_POLL_CHANNEL)Irp->AssociatedIrp.SystemBuffer;        
        PollChannelRsp = (PSAC_RSP_POLL_CHANNEL)Irp->AssociatedIrp.SystemBuffer;        

        //
        // Get the referred channel by it's handle while making
        // sure the driver handle is the same one as the one
        // that created the channel - the same process
        //
        Status = ChanMgrGetByHandleAndFileObject(
            PollChannelCmd->Handle, 
            IrpSp->FileObject,
            &Channel
            );

        if (NT_SUCCESS(Status)) {

            //
            // see if there is data waiting
            //
            // SECURITY:
            //
            //      the InputWaiting variable is guaranteed to be safe since
            //      we validated the OutputBufferLength
            //
            PollChannelRsp->InputWaiting = ChannelHasNewIBufferData(Channel);

            ResponseLength = sizeof(SAC_RSP_POLL_CHANNEL);

            //
            // We are done with the channel
            //
            Status = ChanMgrReleaseChannel(Channel);

        }

#if DEBUG_DISPATCH
        ASSERT(NT_SUCCESS(Status) || Status == STATUS_NOT_FOUND);
#endif        

        break;

    }

    case IOCTL_SAC_REGISTER_CMD_EVENT: {

        PSAC_CMD_SETUP_CMD_EVENT    SetupCmdEvent;

        //
        // Verify the parameters of the IRP
        //
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(SAC_CMD_SETUP_CMD_EVENT)) {
            Status = STATUS_INVALID_BUFFER_SIZE;
            break;
        }

        //
        // get the event info
        //
        SetupCmdEvent = (PSAC_CMD_SETUP_CMD_EVENT)Irp->AssociatedIrp.SystemBuffer;        
        
#if ENABLE_CMD_SESSION_PERMISSION_CHECKING

        //
        // If we are not able to launch cmd sessions,
        // then notify that we cannot peform this action
        //
        if (! IsCommandConsoleLaunchingEnabled()) {
            
            Status = STATUS_UNSUCCESSFUL;

            break;
        
        }
            
#endif

        //
        // Attempt to register the callers cmd event info
        //
        // SECURITY:
        //
        //      the SAC_CMD_SETUP_CMD_EVENT has events handles that must be 
        //      validated as part of the registration process
        //
        Status = RegisterSacCmdEvent(
            IrpSp->FileObject,
            SetupCmdEvent
            );

        if (NT_SUCCESS(Status)) {
            
            //
            // Notify the Console Manager that the Command Prompt 
            // service has REGISTERED
            //
            Status = IoMgrHandleEvent(
                IO_MGR_EVENT_REGISTER_SAC_CMD_EVENT,
                NULL,
                NULL
                );
        
        }

#if DEBUG_DISPATCH
        ASSERT(NT_SUCCESS(Status));
#endif
        break;
        
    }

    case IOCTL_SAC_UNREGISTER_CMD_EVENT: {

        Status = STATUS_UNSUCCESSFUL;

#if ENABLE_CMD_SESSION_PERMISSION_CHECKING

        //
        // If we are not able to launch cmd sessions,
        // then notify that we cannot peform this action
        //
        if (! IsCommandConsoleLaunchingEnabled()) {
            break;
        }
            
#endif
        
#if ENABLE_SERVICE_FILE_OBJECT_CHECKING
        
        //
        // If the current process is the one that registered
        // the cmd event info,
        // then unregister
        //
        if (! IsCmdEventRegistrationProcess(IrpSp->FileObject)) {
            break;
        }

#endif
        
        Status = UnregisterSacCmdEvent(IrpSp->FileObject);

        if (NT_SUCCESS(Status)) {

            //
            // Notify the Console Manager that the Command Prompt 
            // service has UNREGISTERED
            //
            Status = IoMgrHandleEvent(
                IO_MGR_EVENT_UNREGISTER_SAC_CMD_EVENT,
                NULL,
                NULL
                );

        }

#if DEBUG_DISPATCH
        ASSERT(NT_SUCCESS(Status));
#endif        

        break;
    
    }

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = ResponseLength;

    if (Status != STATUS_PENDING) {
        IoCompleteRequest(Irp, DeviceContext->PriorityBoost);
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC DispatchDeviceControl: Exiting with status 0x%x\n", Status)));

    return Status;

} // DispatchDeviceControl


NTSTATUS
DispatchShutdownControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine which receives the shutdown IRP.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    UNREFERENCED_PARAMETER(DeviceObject);
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DispatchShutdownControl: Entering.\n")));

    //
    // Notify any user.
    //
    IoMgrHandleEvent(
        IO_MGR_EVENT_SHUTDOWN,
        NULL,
        NULL
        );
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DispatchShutdownControl: Exiting.\n")));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;

} // DispatchShutdownControl


NTSTATUS
DispatchCreate(
    IN PSAC_DEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for SAC IOCTL Create

Arguments:

    DeviceContext - Pointer to device context for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DispatchCreate: Entering.\n")));

    //
    // Check to see if we are done initializing.
    //
    if (!GlobalDataInitialized || !DeviceContext->InitializedAndReady) {

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest(Irp, DeviceContext->PriorityBoost);

        Status = STATUS_INVALID_DEVICE_STATE;

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC DispatchCreate: Exiting with status 0x%x\n", Status)));

        //
        // We need to catch this state
        //
        ASSERT(0);

        return Status;
    }

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //
    switch (IrpSp->MajorFunction) {
    
    //
    // The Create function opens a connection to this device.
    //
    case IRP_MJ_CREATE:

        Status = STATUS_SUCCESS;
        break;

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;

    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, DeviceContext->PriorityBoost);

    //
    // Return the immediate status code to the caller.
    //

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC DispatchCreate: Exiting with status 0x%x\n", Status)));

    //
    // We need to catch this state
    //
    ASSERT(NT_SUCCESS(Status));

    return Status;

}


NTSTATUS
DispatchClose(
    IN PSAC_DEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for SAC IOCTL Close

Arguments:

    DeviceContext - Pointer to device context for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS Status;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DispatchClose: Entering.\n")));

    //
    // Check to see if we are done initializing.
    //
    if (!GlobalDataInitialized || !DeviceContext->InitializedAndReady) {

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest(Irp, DeviceContext->PriorityBoost);

        Status = STATUS_INVALID_DEVICE_STATE;

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC DispatchClose: Exiting with status 0x%x\n", Status)));

        return Status;
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, DeviceContext->PriorityBoost);

    Status = STATUS_SUCCESS;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\iomgr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cmd.c

Abstract:

    This module contains the routines for handling each command.

Author:

    Sean Selitrennikoff (v-seans) - Dec 2, 1999
    Brian Guarraci (briangu)

Revision History:

--*/

#include "sac.h"
#include <ntddip.h>
#include <ntddtcp.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <stdlib.h>

BOOLEAN GlobalPagingNeeded = TRUE;
BOOLEAN GlobalDoThreads = FALSE;

// For the APC routines, a global value is better :-)
IO_STATUS_BLOCK GlobalIoStatusBlock;

//
// Global buffer
//
ULONG GlobalBufferSize = 0;
char *GlobalBuffer = NULL;

//
// build a string table to express the reason enums
// provided to use by the kernel.
//
// table is based on ntos\inc\ke.h _KTHREAD_STATE
//
// this table must be kept in sync with the _KTHREAD_STATE
// enum table.  Currently, there is no API that we can use
// to obtain these strings, so we build our own table.  
// 

WCHAR *StateTable[] = {
    L"Initialized",
    L"Ready",
    L"Running",
    L"Standby",
    L"Terminated",
    L"Wait:",
    L"Transition",
    L"Unknown",
    L"Unknown",
    L"Unknown",
    L"Unknown",
    L"Unknown"
};

// 
// build a string table to express the reason enums
// provided to use by the kernel.
//
// table is based on ntos\inc\ke.h _KWAIT_REASON 
//
// NOTE/WARNING:
//
// this table must be kept in sync with the _KWAIT_REASON
// enum table.  Currently, there is no API that we can use
// to obtain these strings, so we build our own table.  
// 

WCHAR *WaitTable[] = {
    L"Executive",
    L"FreePage",
    L"PageIn",
    L"PoolAllocation",
    L"DelayExecution",
    L"Suspended",
    L"UserRequest",
    L"WrExecutive",
    L"WrFreePage",
    L"WrPageIn",
    L"WrPoolAllocation",
    L"WrDelayExecution",
    L"WrSuspended",
    L"WrUserRequest",
    L"WrEventPair",
    L"WrQueue",
    L"WrLpcReceive",
    L"WrLpcReply",
    L"WrVirtualMemory",
    L"WrPageOut",
    L"WrRendezvous",
    L"Spare2",
    L"Spare3",
    L"Spare4",
    L"Spare5",
    L"Spare6",
    L"WrKernel",
    L"WrResource",
    L"WrPushLock",
    L"WrMutex",
    L"WrQuantumEnd",
    L"WrDispatchInt",
    L"WrPreempted",
    L"WrYieldExecution",
    L"MaximumWaitReason"
    };

WCHAR *Empty = L" ";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module performs initialization for the SAC device driver.

Author:

    Sean Selitrennikoff (v-seans) - Jan 11, 1999

Revision History:

--*/

#include "sac.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#endif


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the SAC device driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING DeviceName;
    CLONG i;
    BOOLEAN Success;
    PDEVICE_OBJECT DeviceObject;
    PSAC_DEVICE_CONTEXT DeviceContext;
    HEADLESS_RSP_QUERY_INFO Response;
    SIZE_T Length;

    PAGED_CODE( );

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DriverEntry: Entering.\n")));


    //
    // If the system is not setup to use a terminal, then just exit now.
    //
    Length = sizeof(HEADLESS_RSP_QUERY_INFO);
    HeadlessDispatch(HeadlessCmdQueryInformation, 
                     NULL,
                     0,
                     &Response,
                     &Length
                    );

    if ((Response.PortType == HeadlessUndefinedPortType) ||
        ((Response.PortType == HeadlessSerialPort) && !Response.Serial.TerminalAttached)) {
        return STATUS_PORT_DISCONNECTED;
    }

    //
    // Create the device object.  (IoCreateDevice zeroes the memory
    // occupied by the object.)
    //
    // An ACL to the device object in InitializeDeviceData().
    //

    RtlInitUnicodeString(&DeviceName,  SAC_DEVICE_NAME);

    Status = IoCreateDevice(DriverObject,            // DriverObject
                            sizeof(SAC_DEVICE_CONTEXT), // DeviceExtension
                            &DeviceName,             // DeviceName
                            FILE_DEVICE_UNKNOWN,     // DeviceType
                            FILE_DEVICE_SECURE_OPEN, // DeviceCharacteristics
                            FALSE,                   // Exclusive
                            &DeviceObject            // DeviceObject
                           );


    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                          KdPrint(( "SAC DriverEntry: unable to create device object: %X\n", Status )));
        goto ErrorExit;
    }

    DeviceContext = (PSAC_DEVICE_CONTEXT)DeviceObject->DeviceExtension;
    DeviceContext->InitializedAndReady = FALSE;

    //
    // Initialize the driver object for this file system driver.
    //
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = Dispatch;
    }
    //
    // Special case for IRP_MJ_DEVICE_CONTROL since it is
    // the most often used function in SAC.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = DispatchShutdownControl;
    DriverObject->FastIoDispatch = NULL;
    DriverObject->DriverUnload = UnloadHandler;    

    //
    // Initialize global data.
    //
    Success = InitializeGlobalData(RegistryPath, DriverObject);
    if (!Success) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // Initialize our device object.
    //
    Success = InitializeDeviceData(DeviceObject);
    if (!Success) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // Register that we want shutdown notification.  If this fails, no big deal, as
    // we only lose telling the user of this development.
    //
    IoRegisterShutdownNotification(DeviceObject);

    return (Status);

ErrorExit:
    
    FreeGlobalData();

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DriverEntry: Exiting with status 0x%x\n", Status)));    

    return Status;

} // DriverEntry


VOID
UnloadHandler(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the routine for handling unloading of the driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT DeviceContext;
    PDEVICE_OBJECT NextDeviceContext;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC UnloadHandler: Entering.\n")));

    //
    // Walk down each device, disconnecting it and freeing it.
    //
    DeviceContext = DriverObject->DeviceObject;

    while (DeviceContext != NULL) {

        NextDeviceContext = (PDEVICE_OBJECT)DeviceContext->NextDevice;

        FreeDeviceData(DeviceContext);

        IoDeleteDevice(DeviceContext);

        DeviceContext = NextDeviceContext;

    }

    //
    // Free global data
    //
    FreeGlobalData();

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC UnloadHandler: Exiting.\n")));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\memory.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module contains routines for handling memory management within the SAC.
    
    Currently the SAC allocates a chunk of memory up front and then does all local allocations
    from this, growing it as necessary.

Author:

    Sean Selitrennikoff (v-seans) - Jan 11, 1999

Revision History:

--*/

#include "sac.h"

      
//
// These are useful for finding memory leaks.
//
LONG TotalAllocations = 0;
LONG TotalFrees = 0;
LARGE_INTEGER TotalBytesAllocated;
LARGE_INTEGER TotalBytesFreed;


#define GLOBAL_MEMORY_SIGNATURE   0x44414548
#define LOCAL_MEMORY_SIGNATURE    0x5353454C
//
// Structure for holding all allocations from the system
//
typedef struct _GLOBAL_MEMORY_DESCRIPTOR {
#if DBG
    ULONG Signature;
#endif
    PVOID Memory;
    ULONG Size;
    struct _GLOBAL_MEMORY_DESCRIPTOR *NextDescriptor;
} GLOBAL_MEMORY_DESCRIPTOR, *PGLOBAL_MEMORY_DESCRIPTOR;

typedef struct _LOCAL_MEMORY_DESCRIPTOR {
#if DBG
#if defined (_IA64_)
    //
    // We must make sure that allocated memory falls on mod-8 boundaries.
    // To do this, we must make sure that this structure is of size mod-8.
    //
    ULONG Filler;
#endif
    ULONG Signature;
#endif
    ULONG Tag;
    ULONG Size;
} LOCAL_MEMORY_DESCRIPTOR, *PLOCAL_MEMORY_DESCRIPTOR;


//
// Variable for holding our memory together.
//
PGLOBAL_MEMORY_DESCRIPTOR GlobalMemoryList;
KSPIN_LOCK MemoryLock;


//
// Constants used to manipulate  size growth
//
#define MEMORY_ALLOCATION_SIZE    PAGE_SIZE
#define INITIAL_MEMORY_BLOCK_SIZE 0x100000


//
// Functions
//
BOOLEAN
InitializeMemoryManagement(
    VOID
    )

/*++

Routine Description:

    This routine initializes the internal memory management system.

Arguments:

    None.

Return Value:

    TRUE if successful, else FALSE

--*/

{
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMem: Entering\n")));

    GlobalMemoryList = (PGLOBAL_MEMORY_DESCRIPTOR)ExAllocatePoolWithTagPriority(NonPagedPool,
                                                                                INITIAL_MEMORY_BLOCK_SIZE,
                                                                                INITIAL_POOL_TAG,
                                                                                HighPoolPriority
                                                                               );

    if (GlobalMemoryList == NULL) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC InitializeMem: Exiting with FALSE. No pool.\n")));
        return FALSE;
    }

    KeInitializeSpinLock(&MemoryLock);

#if DBG
    GlobalMemoryList->Signature = GLOBAL_MEMORY_SIGNATURE;
#endif
    GlobalMemoryList->Memory = (PVOID)(GlobalMemoryList + 1);
    GlobalMemoryList->Size = INITIAL_MEMORY_BLOCK_SIZE - sizeof(GLOBAL_MEMORY_DESCRIPTOR);
    GlobalMemoryList->NextDescriptor = NULL;

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(GlobalMemoryList->Memory);
#if DBG
    LocalDescriptor->Signature = LOCAL_MEMORY_SIGNATURE;
#endif    
    LocalDescriptor->Tag = FREE_POOL_TAG;
    LocalDescriptor->Size = GlobalMemoryList->Size - sizeof(LOCAL_MEMORY_DESCRIPTOR);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMem: Exiting with TRUE.\n")));
    return TRUE;

} // InitializeMemoryManagement


VOID
FreeMemoryManagement(
    VOID
    )

/*++

Routine Description:

    This routine frees the internal memory management system.

Arguments:

    None.

Return Value:

    TRUE if successful, else FALSE

--*/

{
    KIRQL OldIrql;
    PGLOBAL_MEMORY_DESCRIPTOR NextDescriptor;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeMem: Entering\n")));

    KeAcquireSpinLock(&MemoryLock, &OldIrql);

    //
    // Check if the memory allocation fits in a current block anywhere
    //
    while (GlobalMemoryList != NULL) {
#if DBG
        ASSERT( GlobalMemoryList->Signature == GLOBAL_MEMORY_SIGNATURE );
#endif
        NextDescriptor = GlobalMemoryList->NextDescriptor;

        KeReleaseSpinLock(&MemoryLock, OldIrql);

        ExFreePool(GlobalMemoryList);

        KeAcquireSpinLock(&MemoryLock, &OldIrql);

        GlobalMemoryList = NextDescriptor;

    }

    KeReleaseSpinLock(&MemoryLock, OldIrql);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeMem: Exiting\n")));

}


PVOID
MyAllocatePool(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PCHAR FileName,
    IN ULONG LineNumber
    )

/*++

Routine Description:

    This routine allocates memory from our internal structures, and if needed, gets more pool.

Arguments:

    NumberOfBytes - Number of bytes the client wants.
    
    Tag - A tag to place on the memory.
    
    FileName - The file name this request is coming from.
    
    LineNumber - Line number within the file that is making this request.

Return Value:

    A pointer to the allocated block if successful, else NULL

--*/

{
    KIRQL OldIrql;
    PGLOBAL_MEMORY_DESCRIPTOR GlobalDescriptor;
    PGLOBAL_MEMORY_DESCRIPTOR NewDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR NextDescriptor;
    ULONG ThisBlockSize;
    ULONG BytesToAllocate;

    

    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(LineNumber);

    ASSERT(Tag != FREE_POOL_TAG);

    IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyAllocPool: Entering.\n")));

    KeAcquireSpinLock(&MemoryLock, &OldIrql);

    //
    // Always allocate on mod-8 boundaries
    //
    if( NumberOfBytes & 0x7 ) {
        NumberOfBytes += 8 - (NumberOfBytes & 0x7);
    }

    //
    // Check if the memory allocation fits in a current block anywhere
    //
    GlobalDescriptor = GlobalMemoryList;

    while (GlobalDescriptor != NULL) {
#if DBG
        ASSERT( GlobalDescriptor->Signature == GLOBAL_MEMORY_SIGNATURE );
#endif        
        LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(GlobalDescriptor->Memory);
        ThisBlockSize = GlobalDescriptor->Size;

        while (ThisBlockSize != 0) {
#if DBG
            ASSERT( LocalDescriptor->Signature == LOCAL_MEMORY_SIGNATURE );
#endif
            if ((LocalDescriptor->Tag == FREE_POOL_TAG) && 
                (LocalDescriptor->Size >= NumberOfBytes)) {
                
                IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyAllocPool: Found a good sized block.\n")));

                goto FoundBlock;
            }

            ThisBlockSize -= (LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR));
            LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                         LocalDescriptor->Size +
                                                         sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                        );
        }

        GlobalDescriptor = GlobalDescriptor->NextDescriptor;

    }

    KeReleaseSpinLock(&MemoryLock, OldIrql);

    //
    // There is no memory block big enough to hold the request.
    //
    
    //
    // Now check if the request is larger than the normal allocation unit we use.
    //
    if (NumberOfBytes > 
        (MEMORY_ALLOCATION_SIZE - sizeof(GLOBAL_MEMORY_DESCRIPTOR) - sizeof(LOCAL_MEMORY_DESCRIPTOR))) {

        BytesToAllocate = (ULONG)(NumberOfBytes + sizeof(GLOBAL_MEMORY_DESCRIPTOR) + sizeof(LOCAL_MEMORY_DESCRIPTOR));

    } else {

        BytesToAllocate = MEMORY_ALLOCATION_SIZE;

    }

    IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyAllocPool: Allocating new space.\n")));

    NewDescriptor = (PGLOBAL_MEMORY_DESCRIPTOR)ExAllocatePoolWithTagPriority(NonPagedPool,
                                                                             BytesToAllocate,
                                                                             ALLOC_POOL_TAG,
                                                                             HighPoolPriority
                                                                            );
    if (NewDescriptor == NULL) {
        
        IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyAllocPool: No more memory, returning NULL.\n")));

        return NULL;
    }

    KeAcquireSpinLock(&MemoryLock, &OldIrql);
#if DBG
    NewDescriptor->Signature = GLOBAL_MEMORY_SIGNATURE;
#endif
    NewDescriptor->Memory = (PVOID)(NewDescriptor + 1);
    NewDescriptor->Size = BytesToAllocate - sizeof(GLOBAL_MEMORY_DESCRIPTOR);
    NewDescriptor->NextDescriptor = GlobalMemoryList;

    GlobalMemoryList = NewDescriptor;

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(GlobalMemoryList->Memory);
#if DBG
    LocalDescriptor->Signature = LOCAL_MEMORY_SIGNATURE;
#endif
    LocalDescriptor->Tag = FREE_POOL_TAG;
    LocalDescriptor->Size = GlobalMemoryList->Size - sizeof(LOCAL_MEMORY_DESCRIPTOR);


FoundBlock:

    //
    // Jump to here when a memory descriptor of the right size has been found.  It is expected that
    // LocalDescriptor points to the correct block.
    //
    ASSERT(LocalDescriptor != NULL);
    ASSERT(LocalDescriptor->Tag == FREE_POOL_TAG);
#if DBG
    ASSERT(LocalDescriptor->Signature == LOCAL_MEMORY_SIGNATURE );
#endif

    if (LocalDescriptor->Size > NumberOfBytes + sizeof(LOCAL_MEMORY_DESCRIPTOR)) {

        //
        // Make a descriptor of the left over parts of this block.
        //
        NextDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                    sizeof(LOCAL_MEMORY_DESCRIPTOR) +
                                                    NumberOfBytes
                                                   );

#if DBG
        NextDescriptor->Signature = LOCAL_MEMORY_SIGNATURE;
#endif
        NextDescriptor->Tag = FREE_POOL_TAG;
        NextDescriptor->Size = (ULONG)(LocalDescriptor->Size - NumberOfBytes - sizeof(LOCAL_MEMORY_DESCRIPTOR));
        LocalDescriptor->Size = (ULONG)NumberOfBytes;

    }

    LocalDescriptor->Tag = Tag;
    
    KeReleaseSpinLock(&MemoryLock, OldIrql);

    InterlockedIncrement(
        &TotalAllocations
        );

    ExInterlockedAddLargeStatistic(
        &TotalBytesAllocated,
        (CLONG)LocalDescriptor->Size     // Sundown - FIX
        );

    IF_SAC_DEBUG(SAC_DEBUG_MEM, 
                      KdPrint(("SAC MyAllocPool: Returning block 0x%X.\n", LocalDescriptor)));

    RtlZeroMemory( (LocalDescriptor+1), NumberOfBytes );

    return (PVOID)(LocalDescriptor + 1);

} // MyAllocatePool


VOID
MyFreePool(
    IN PVOID *Pointer
    )

/*++

Routine Description:

    This routine frees a block previously allocated from the internal memory management system.

Arguments:

    Pointer - A pointer to the pointer to free.

Return Value:

    Pointer is set to NULL if successful, else it is left alone.

--*/

{
    KIRQL OldIrql;
    ULONG ThisBlockSize;
    PGLOBAL_MEMORY_DESCRIPTOR GlobalDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR PrevDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR ThisDescriptor;

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)(*Pointer)) - sizeof(LOCAL_MEMORY_DESCRIPTOR));

    IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyFreePool: Entering with block 0x%X.\n", LocalDescriptor)));

    ASSERT (LocalDescriptor->Size > 0);
#if DBG
    ASSERT (LocalDescriptor->Signature == LOCAL_MEMORY_SIGNATURE);
#endif

    InterlockedIncrement(
        &TotalFrees
        );

    ExInterlockedAddLargeStatistic(
        &TotalBytesFreed,
        (CLONG)LocalDescriptor->Size
        );


    //
    // Find the memory block in the global list
    //
    KeAcquireSpinLock(&MemoryLock, &OldIrql);

    GlobalDescriptor = GlobalMemoryList;

    while (GlobalDescriptor != NULL) {
#if DBG
        ASSERT(GlobalDescriptor->Signature == GLOBAL_MEMORY_SIGNATURE);
#endif
        PrevDescriptor = NULL;
        ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(GlobalDescriptor->Memory);
        ThisBlockSize = GlobalDescriptor->Size;

        while (ThisBlockSize != 0) {
#if DBG
            ASSERT (ThisDescriptor->Signature == LOCAL_MEMORY_SIGNATURE);
#endif
            
            if (ThisDescriptor == LocalDescriptor) {
                goto FoundBlock;
            }

            ThisBlockSize -= (ThisDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR));
            
            PrevDescriptor = ThisDescriptor;
            ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)ThisDescriptor) + 
                                                        ThisDescriptor->Size +
                                                        sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                       );
        }

        GlobalDescriptor = GlobalDescriptor->NextDescriptor;

    }

    KeReleaseSpinLock(&MemoryLock, OldIrql);

    IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyFreePool: Could not find block.\n")));

    ASSERT(FALSE);

    return;

FoundBlock:

    //
    // Jump to here when the proper memory descriptor has been found.
    //
#if DBG
    ASSERT (ThisDescriptor->Signature == LOCAL_MEMORY_SIGNATURE);
#endif

    
    if (LocalDescriptor->Tag == FREE_POOL_TAG) {
        //
        // Ouch! We tried to free something twice, skip it before bad things happen.
        //
        KeReleaseSpinLock(&MemoryLock, OldIrql);
        IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyFreePool: Attempted to free something twice.\n")));
        ASSERT(FALSE);
        return;
    }

    LocalDescriptor->Tag = FREE_POOL_TAG;

    //
    // If possible, merge this memory block with the next one.
    //
    if (ThisBlockSize > (LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR))) {
        ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                    LocalDescriptor->Size +
                                                    sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                   );
        if (ThisDescriptor->Tag == FREE_POOL_TAG) {
            ThisDescriptor->Tag = 0;
#if DBG
            ThisDescriptor->Signature = 0;
#endif
            LocalDescriptor->Size += ThisDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR);
        }

    }

    //
    // Now see if we can merge this block with a previous block.
    //
    if ((PrevDescriptor != NULL) && (PrevDescriptor->Tag == FREE_POOL_TAG)) {
#if DBG
        LocalDescriptor->Signature = 0;
#endif
        LocalDescriptor->Tag = 0;
        PrevDescriptor->Size += LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR);
    }

    KeReleaseSpinLock(&MemoryLock, OldIrql);
    
    *Pointer = NULL;
    
    IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyFreePool: exiting.\n")));

} // MyFreePool
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\data.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This module contains global data for SAC.

Author:

    Sean Selitrennikoff (v-seans) - Jan 11, 1999

Revision History:

--*/

#include "sac.h"

NTSTATUS
CreateDeviceSecurityDescriptor(
    IN PVOID    DeviceOrDriverObject
    );

NTSTATUS
BuildDeviceAcl(
    OUT PACL *DeviceAcl
    );

VOID
WorkerThreadStartUp(
    IN PVOID StartContext
    );

VOID
InitializeCmdEventInfo(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, InitializeGlobalData)
#pragma alloc_text( INIT, CreateDeviceSecurityDescriptor )
#pragma alloc_text( INIT, BuildDeviceAcl )
#endif

//
// Globally defined variables are here.
//

//
// Define the I/O Manager methods.
//
// The I/O manager is responsible for the behavior layer between 
// the channels and the serial port.
//
// Note: currently, the cmd routines are not-multithreadable.
//
#if 0
IO_MGR_HANDLE_EVENT         IoMgrHandleEvent            = XmlMgrHandleEvent;
IO_MGR_INITITIALIZE         IoMgrInitialize             = XmlMgrInitialize;
IO_MGR_SHUTDOWN             IoMgrShutdown               = XmlMgrShutdown;
IO_MGR_WORKER               IoMgrWorkerProcessEvents    = XmlMgrWorkerProcessEvents;
IO_MGR_IS_CURRENT_CHANNEL   IoMgrIsCurrentChannel       = XmlMgrIsCurrentChannel;
#else
IO_MGR_HANDLE_EVENT         IoMgrHandleEvent            = ConMgrHandleEvent;
IO_MGR_INITITIALIZE         IoMgrInitialize             = ConMgrInitialize;
IO_MGR_SHUTDOWN             IoMgrShutdown               = ConMgrShutdown;
IO_MGR_WORKER               IoMgrWorkerProcessEvents    = ConMgrWorkerProcessEvents;
IO_MGR_IS_WRITE_ENABLED     IoMgrIsWriteEnabled         = ConMgrIsWriteEnabled;
IO_MGR_WRITE_DATA           IoMgrWriteData              = ConMgrWriteData;
IO_MGR_FLUSH_DATA           IoMgrFlushData              = ConMgrFlushData;
#endif

PMACHINE_INFORMATION    MachineInformation = NULL;
BOOLEAN                 GlobalDataInitialized = FALSE;
UCHAR                   TmpBuffer[sizeof(PROCESS_PRIORITY_CLASS)];
BOOLEAN                 IoctlSubmitted;
LONG                    ProcessingType = SAC_NO_OP;
HANDLE                  SACEventHandle;
PKEVENT                 SACEvent=NULL;

#if ENABLE_CMD_SESSION_PERMISSION_CHECKING
BOOLEAN  CommandConsoleLaunchingEnabled;
#endif

//
// Globals for communicating with the user process responsible
// for launching CMD consoles
//
PVOID       RequestSacCmdEventObjectBody = NULL;
PVOID       RequestSacCmdEventWaitObjectBody = NULL;
PVOID       RequestSacCmdSuccessEventObjectBody = NULL;
PVOID       RequestSacCmdSuccessEventWaitObjectBody = NULL;
PVOID       RequestSacCmdFailureEventObjectBody = NULL;
PVOID       RequestSacCmdFailureEventWaitObjectBody = NULL;
BOOLEAN     HaveUserModeServiceCmdEventInfo = FALSE;
KMUTEX      SACCmdEventInfoMutex;

#if ENABLE_SERVICE_FILE_OBJECT_CHECKING
//
// In order to prevent a rogue process from unregistering the
// cmd event info from underneath the service, we only allow
// the process that registered to unregister.
//
PFILE_OBJECT    ServiceProcessFileObject = NULL;
#endif

//
// Globals for managing incremental UTF8 encoding for VTUTF8 channels
//
WCHAR IncomingUnicodeValue;
UCHAR IncomingUtf8ConversionBuffer[3];


#if DBG
ULONG SACDebug = 0x0;
#endif


BOOLEAN
InitializeGlobalData(
    IN PUNICODE_STRING RegistryPath,
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine initializes all the driver components that are shared across devices.

Arguments:

    RegistryPath - A pointer to the location in the registry to read values from.
    DriverObject - pointer to DriverObject

Return Value:

    TRUE if successful, else FALSE

--*/

{
    NTSTATUS                Status;
    UNICODE_STRING          DosName;
    UNICODE_STRING          NtName;
    UNICODE_STRING          UnicodeString;

    UNREFERENCED_PARAMETER(RegistryPath);

    PAGED_CODE();

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InitializeGlobalData: Entering.\n")));

    if (!GlobalDataInitialized) {
        
        //
        // Create a symbolic link from a DosDevice to this device so that a user-mode app can open us.
        //
        RtlInitUnicodeString(&DosName, SAC_DOSDEVICE_NAME);
        RtlInitUnicodeString(&NtName, SAC_DEVICE_NAME);
        Status = IoCreateSymbolicLink(&DosName, &NtName);

        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        //
        // Initialize internal memory system
        //
        if (!InitializeMemoryManagement()) {

            IoDeleteSymbolicLink(&DosName);

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeGlobalData: Exiting with status FALSE\n")));

            return FALSE;
        }

        Status = PreloadGlobalMessageTable(DriverObject->DriverStart);
        if (!NT_SUCCESS(Status)) {

            IoDeleteSymbolicLink(&DosName);

            IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                      KdPrint(( "SAC DriverEntry: unable to pre-load message table: %X\n", Status )));
            return FALSE;
        
        }


#if ENABLE_CMD_SESSION_PERMISSION_CHECKING
        //
        // determine if the SAC driver has permission to launch cmd sessions
        //
        Status = GetCommandConsoleLaunchingPermission(&CommandConsoleLaunchingEnabled);

        if (!NT_SUCCESS(Status)) {
            
            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(( "SAC DriverEntry: failed GetCommandConsoleLaunchingPermission: %X\n", Status))
                );
            
            //
            // We don't want to fail on this operation
            //
            NOTHING;
        }

#if ENABLE_SACSVR_START_TYPE_OVERRIDE

        else {
            
            //
            // Here we execute the command console service 
            // start type policy.  The goal is to provide
            // a means for the service to automatically start
            // when the cmd session feature is not explicitly
            // turned off.
            //
            // Here is the state table:
            //
            // Command Console Feature Enabled:
            //
            //  service start type:
            //
            //      automatic   --> NOP
            //      manual      --> automatic
            //      disabled    --> NOP
            //
            // Command Console Feature Disabled:
            //
            //  service start type:
            //
            //      automatic   --> NOP
            //      manual      --> NOP
            //      disabled    --> NOP
            //
            //      service (sacsvr) fails registration
            //
            if (IsCommandConsoleLaunchingEnabled()) {

                //
                // Modify the service start type if appropriate
                //
                Status = ImposeSacCmdServiceStartTypePolicy();
                
                if (!NT_SUCCESS(Status)) {
                    
                    IF_SAC_DEBUG(
                        SAC_DEBUG_FAILS, 
                        KdPrint(( "SAC DriverEntry: failed ImposeSacCmdServiceStartTypePolicy: %X\n", Status ))
                        );
                    
                    // We don't want to fail on this operation
                    //
                    NOTHING;
                }

            } else {

                //
                // We do nothing here
                //
                NOTHING;

            }
        
        }

#endif

#endif

        //
        //
        //
        Utf8ConversionBuffer = (PUCHAR)ALLOCATE_POOL(
            Utf8ConversionBufferSize, 
            GENERAL_POOL_TAG
            );
        if (!Utf8ConversionBuffer) {

            TearDownGlobalMessageTable();

            IoDeleteSymbolicLink(&DosName);

            IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                      KdPrint(( "SAC DriverEntry: unable to allocate memory for UTF8 translation." )));

            return FALSE;
        }

        //
        // initialize the channel manager
        //
        Status = ChanMgrInitialize();

        if (!NT_SUCCESS(Status)) {
        
            FREE_POOL(&Utf8ConversionBuffer);
        
            TearDownGlobalMessageTable();
        
            IoDeleteSymbolicLink(&DosName);
        
            IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                      KdPrint(( "SAC DriverEntry: Failed to create SAC Channel" )));
        
            return FALSE;
        }
        
        //
        // Initialize the serial port buffer
        //
        SerialPortBuffer = ALLOCATE_POOL(SERIAL_PORT_BUFFER_SIZE, GENERAL_POOL_TAG);

        if (! SerialPortBuffer) {
        
            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC InitializeDeviceData: Failed to allocate Serial Port Buffer\n"))
                );
        
            return FALSE;

        }

        RtlZeroMemory(SerialPortBuffer, SERIAL_PORT_BUFFER_SIZE);

        //
        // Initialize the Cmd Console Event information
        //
        KeInitializeMutex(&SACCmdEventInfoMutex, 0);

        InitializeCmdEventInfo();
        
        //
        // Globals are initialized
        //
        GlobalDataInitialized = TRUE;

        ProcessingType = SAC_NO_OP;
        IoctlSubmitted = FALSE;

        //
        // Setup notification event
        //
        RtlInitUnicodeString(&UnicodeString, L"\\SACEvent");
        SACEvent = IoCreateSynchronizationEvent(&UnicodeString, &SACEventHandle);
        
        if (SACEvent == NULL) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeGlobalData: Exiting with Event NULL\n")));

            return FALSE;
        }

        //
        // Retrieve all the machine-specific identification information.
        //
        InitializeMachineInformation();
        
        //
        // Populate the HeadlessDispatch structure with the Machine info
        //
        Status = RegisterBlueScreenMachineInformation();

        if (! NT_SUCCESS(Status)) {
            
            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC InitializeGlobalData: Failed to register blue screen machine info\n"))
                );
        
            return FALSE;
            
        }

    }
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InitializeGlobalData: Exiting with status TRUE\n")));

    return TRUE;
} // InitializeGlobalData


VOID
FreeGlobalData(
    VOID
    )

/*++

Routine Description:

    This routine frees all shared components.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UNICODE_STRING DosName;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeGlobalData: Entering.\n")));

    if (GlobalDataInitialized) {
        
        //
        //
        //
        if(SACEvent != NULL){
            ZwClose(SACEventHandle);
            SACEvent = NULL;
        }
        
        //
        //
        //
        TearDownGlobalMessageTable();

        //
        //
        //
        RtlInitUnicodeString(&DosName, SAC_DOSDEVICE_NAME);
        IoDeleteSymbolicLink(&DosName);

        //
        // Shutdown the console manager
        //
        // Note: this should be done before shutting down
        //       the channel manager to give the IO manager
        //       a chance to cleanly shut itself down.
        //
        IoMgrShutdown();
        
        //
        // Shutdown the channel manager
        //
        ChanMgrShutdown();

        //
        // Release the serial port buffer
        // 
        SAFE_FREE_POOL(&SerialPortBuffer);

        //
        // Release the machine information gathered at driver entry
        //
        FreeMachineInformation();

        //
        // Free the internal memory management system
        //
        FreeMemoryManagement();
        
        //
        // Global data is no longer present
        //
        GlobalDataInitialized = FALSE;
    
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeGlobalData: Exiting.\n")));

} // FreeGlobalData


BOOLEAN
InitializeDeviceData(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine initializes all the parts specific for each device.

Arguments:

    DeviceObject - pointer to device object to be initialized.

Return Value:

    TRUE if successful, else FALSE

--*/

{
    NTSTATUS                        Status;
    LARGE_INTEGER                   Time;
    LONG                            Priority;
    HEADLESS_CMD_ENABLE_TERMINAL    Command;
    PSAC_DEVICE_CONTEXT             DeviceContext;
    PWSTR                           XMLBuffer;

    PAGED_CODE();

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InitializeDeviceData: Entering.\n")));

    DeviceContext = (PSAC_DEVICE_CONTEXT)DeviceObject->DeviceExtension;

    if (!DeviceContext->InitializedAndReady) {
        
        DeviceObject->StackSize = DEFAULT_IRP_STACK_SIZE;
        DeviceObject->Flags |= DO_DIRECT_IO;

        DeviceContext->DeviceObject = DeviceObject;
        DeviceContext->PriorityBoost = DEFAULT_PRIORITY_BOOST;
        DeviceContext->ExitThread = FALSE;
        DeviceContext->Processing = FALSE;
                
        //
        //
        //

        KeInitializeTimer(&(DeviceContext->Timer));

        KeInitializeDpc(&(DeviceContext->Dpc), &TimerDpcRoutine, DeviceContext);

        KeInitializeSpinLock(&(DeviceContext->SpinLock));
        
        KeInitializeEvent(&(DeviceContext->ProcessEvent), SynchronizationEvent, FALSE);

        InitializeListHead(&(DeviceContext->IrpQueue));

        //
        // Enable the terminal
        //
        Command.Enable = TRUE;
        Status = HeadlessDispatch(HeadlessCmdEnableTerminal, 
                                  &Command, 
                                  sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                                  NULL,
                                  NULL
                                 );
        if (!NT_SUCCESS(Status)) {

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeDeviceData: Exiting (1) with status FALSE\n")));
            return FALSE;
        }
        
        //
        // Remember a pointer to the system process.  We'll use this pointer
        // for KeAttachProcess() calls so that we can open handles in the
        // context of the system process.
        //
        DeviceContext->SystemProcess = (PKPROCESS)IoGetCurrentProcess();

        //
        // Create the security descriptor used for raw access checks.
        //
        Status = CreateDeviceSecurityDescriptor(DeviceContext);

        if (!NT_SUCCESS(Status)) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeDeviceData: Exiting (2) with status FALSE\n")));
            Command.Enable = FALSE;
            
            Status = HeadlessDispatch(
                HeadlessCmdEnableTerminal, 
                &Command, 
                sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                NULL,
                NULL
                );
            
            if (! NT_SUCCESS(Status)) {
                
                IF_SAC_DEBUG(
                    SAC_DEBUG_FAILS, 
                    KdPrint(("SAC InitializeDeviceData: Failed dispatch\n")));
            
            }
            
            return FALSE;
        }

        //
        // Start a thread to handle requests
        //
        Status = PsCreateSystemThread(&(DeviceContext->ThreadHandle),
                                      PROCESS_ALL_ACCESS,
                                      NULL,
                                      NULL,
                                      NULL,
                                      WorkerThreadStartUp,
                                      DeviceContext
                                     );
                                      
        if (!NT_SUCCESS(Status)) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeDeviceData: Exiting (3) with status FALSE\n")));
            Command.Enable = FALSE;
            Status = HeadlessDispatch(
                HeadlessCmdEnableTerminal, 
                &Command, 
                sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                NULL,
                NULL
                );
            
            if (! NT_SUCCESS(Status)) {
                
                IF_SAC_DEBUG(
                    SAC_DEBUG_FAILS, 
                    KdPrint(("SAC InitializeDeviceData: Failed dispatch\n")));
            
            }
            
            return FALSE;
        }

        //
        // Set this thread to the real-time highest priority so that it will be
        // responsive.
        //
        Priority = HIGH_PRIORITY;
        Status = NtSetInformationThread(DeviceContext->ThreadHandle,
                                        ThreadPriority,
                                        &Priority,
                                        sizeof(Priority)
                                       );

        if (!NT_SUCCESS(Status)) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeDeviceData: Exiting (6) with status FALSE\n")));
                              
            //
            // Tell thread to exit.
            //
            DeviceContext->ExitThread = TRUE;
            KeInitializeEvent(&(DeviceContext->ThreadExitEvent), SynchronizationEvent, FALSE);
            KeSetEvent(&(DeviceContext->ProcessEvent), DeviceContext->PriorityBoost, FALSE);    
            Status = KeWaitForSingleObject((PVOID)&(DeviceContext->ThreadExitEvent), Executive, KernelMode,  FALSE, NULL);
            ASSERT(Status == STATUS_SUCCESS);

            Command.Enable = FALSE;
            Status = HeadlessDispatch(
                HeadlessCmdEnableTerminal, 
                &Command, 
                sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                NULL,
                NULL
                );
                        
            if (! NT_SUCCESS(Status)) {
                
                IF_SAC_DEBUG(
                    SAC_DEBUG_FAILS, 
                    KdPrint(("SAC InitializeDeviceData: Failed dispatch\n")));
            
            }
            
            return FALSE;
        }

        //
        // Send XML machine information to management application
        //
        Status = TranslateMachineInformationXML(
            &XMLBuffer, 
            NULL
            );

        if (NT_SUCCESS(Status)) {
            UTF8EncodeAndSend(XML_VERSION_HEADER);
            UTF8EncodeAndSend(XMLBuffer);
            FREE_POOL(&XMLBuffer);
        }

        //
        // Initialize the console manager
        //
        Status = IoMgrInitialize();
        if (! NT_SUCCESS(Status)) {
            return FALSE;
        }

        //
        // Start our timer
        //
        Time.QuadPart = Int32x32To64((LONG)4, -1000); 
        KeSetTimerEx(&(DeviceContext->Timer), Time, (LONG)4, &(DeviceContext->Dpc)); 

        DeviceContext->InitializedAndReady = TRUE;


    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InitializeDeviceData: Exiting with status TRUE\n")));

    return TRUE;
} // InitializeDeviceData


VOID
FreeDeviceData(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine frees all components specific to a device..

Arguments:

    DeviceContext - The device to work on.

Return Value:

    It will stop and wait, if necessary, for any processing to complete.

--*/

{
    KIRQL OldIrql;
    NTSTATUS Status;
    PSAC_DEVICE_CONTEXT DeviceContext;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeDeviceData: Entering.\n")));

    DeviceContext = (PSAC_DEVICE_CONTEXT)DeviceObject->DeviceExtension;

    if (!GlobalDataInitialized || !DeviceContext->InitializedAndReady) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeDeviceData: Exiting.\n")));
        return;
    }

    //
    // Wait for all processing to complete
    //
    KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);
    
    while (DeviceContext->Processing) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeDeviceData: Waiting....\n")));

        KeInitializeEvent(&(DeviceContext->UnloadEvent), SynchronizationEvent, FALSE);

        KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);
        
        Status = KeWaitForSingleObject((PVOID)&(DeviceContext->UnloadEvent), Executive, KernelMode,  FALSE, NULL);

        ASSERT(Status == STATUS_SUCCESS);

        KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);

    }

    DeviceContext->Processing = TRUE;

    KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);
    
    KeCancelTimer(&(DeviceContext->Timer));
    
    KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);
    
    DeviceContext->Processing = FALSE;

    //
    // Signal the thread to exit
    //
    KeInitializeEvent(&(DeviceContext->UnloadEvent), SynchronizationEvent, FALSE);
    KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);
    KeSetEvent(&(DeviceContext->ProcessEvent), DeviceContext->PriorityBoost, FALSE);    
    
    Status = KeWaitForSingleObject((PVOID)&(DeviceContext->UnloadEvent), Executive, KernelMode,  FALSE, NULL);
    ASSERT(Status == STATUS_SUCCESS);

    //
    // Finish up cleaning up.
    //
    IoUnregisterShutdownNotification(DeviceObject);

    KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);
    
    DeviceContext->InitializedAndReady = FALSE;

    KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeDeviceData: Exiting.\n")));
} // FreeDeviceData


VOID
WorkerThreadStartUp(
    IN PVOID StartContext
    )

/*++

Routine Description:

    This routine is the start up routine for the worker thread.  It justn
    sends the worker thread to the processing routine.

Arguments:

    StartContext - A pointer to the device to work on.

Return Value:

    None.

--*/

{
    WorkerProcessEvents((PSAC_DEVICE_CONTEXT)StartContext);
}


NTSTATUS
BuildDeviceAcl(
    OUT PACL *pDAcl
    )

/*++

Routine Description:

    This routine builds an ACL which gives System READ/WRITE access.
    All other principals have no access.

Arguments:

    pDAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    NTSTATUS status;
    PACL dacl;
    SECURITY_DESCRIPTOR securityDescriptor;
    ULONG length;

    //
    // Default:
    //
    if( !pDAcl ) {
        return STATUS_INVALID_PARAMETER;
    }
    *pDAcl = NULL;

    //
    // Build an appropriate discretionary ACL.
    //
    length = (ULONG) sizeof( ACL ) +
             (ULONG)( 1 * sizeof( ACCESS_ALLOWED_ACE )) +
             RtlLengthSid( SeExports->SeLocalSystemSid );

    dacl = (PACL) ALLOCATE_POOL( length, GENERAL_POOL_TAG );
    
    if (!dacl) {
        return STATUS_NO_MEMORY;
    }

    status = RtlCreateAcl( dacl, length, ACL_REVISION2 );
    
    if (NT_SUCCESS( status )) {

        status = RtlAddAccessAllowedAce( 
            dacl,
            ACL_REVISION2,
            GENERIC_READ | GENERIC_WRITE,
            SeExports->SeLocalSystemSid 
            );
    
    }
    
    if (NT_SUCCESS( status )) {

        //
        // Put it in a security descriptor so that it may be applied to
        // the system partition device.
        //

        status = RtlCreateSecurityDescriptor( 
            &securityDescriptor,
            SECURITY_DESCRIPTOR_REVISION 
            );
    
    }
                
    if (NT_SUCCESS( status )) {

        status = RtlSetDaclSecurityDescriptor( 
            &securityDescriptor,
            TRUE,
            dacl,
            FALSE 
            );
    
    }

    if (!NT_SUCCESS( status )) {
        FREE_POOL( &dacl );
    }

    //
    // Send back the dacl
    //
    *pDAcl = dacl;

    return status;
}

NTSTATUS
CreateDeviceSecurityDescriptor(
    PSAC_DEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine creates a security descriptor which controls access to
    the SAC device.  

Arguments:

    DeviceContext - A pointer to the device to work on.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

Security:

    Currently, only the System user has access (READ/WRITE) to this device.

--*/
{
    PACL                  RawAcl = NULL;
    NTSTATUS              Status;
    BOOLEAN               MemoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR  SecurityDescriptor;
    ULONG                 SecurityDescriptorLength;
    CHAR                  Buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR  LocalSecurityDescriptor = (PSECURITY_DESCRIPTOR) Buffer;
    PSECURITY_DESCRIPTOR  DeviceSecurityDescriptor = NULL;
    SECURITY_INFORMATION  SecurityInformation = DACL_SECURITY_INFORMATION;

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC CreateDeviceSecurityDescriptor: Entering.\n"))
        );

    //
    // Get a pointer to the security descriptor from the device object.
    //
    Status = ObGetObjectSecurity(
        DeviceContext->DeviceObject,
        &SecurityDescriptor,
        &MemoryAllocated
        );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC: Unable to get security descriptor, error: %x\n", Status))
            );
        ASSERT(MemoryAllocated == FALSE);
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC CreateDeviceSecurityDescriptor: Exiting with status 0x%x\n", Status))
            );
        return(Status);
    }

    //
    // Build a local security descriptor
    //
    Status = BuildDeviceAcl(&RawAcl);

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC CreateDeviceSecurityDescriptor: Unable to create Raw ACL, error: %x\n", Status))
            );
        goto ErrorExit;
    }

    (VOID)RtlCreateSecurityDescriptor(
        LocalSecurityDescriptor,
        SECURITY_DESCRIPTOR_REVISION
        );

    (VOID)RtlSetDaclSecurityDescriptor(
        LocalSecurityDescriptor,
        TRUE,
        RawAcl,
        FALSE
        );

    //
    // Make a copy of the security descriptor. This copy will be the raw descriptor.
    //
    SecurityDescriptorLength = RtlLengthSecurityDescriptor(SecurityDescriptor);

    DeviceSecurityDescriptor = ExAllocatePoolWithTag(
        PagedPool,
        SecurityDescriptorLength,
        SECURITY_POOL_TAG
        );

    if (DeviceSecurityDescriptor == NULL) {
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC CreateDeviceSecurityDescriptor: couldn't allocate security descriptor\n"))
            );
        goto ErrorExit;
    }

    RtlMoveMemory(
        DeviceSecurityDescriptor,
        SecurityDescriptor,
        SecurityDescriptorLength
        );

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    Status = SeSetSecurityDescriptorInfo(
        NULL,
        &SecurityInformation,
        LocalSecurityDescriptor,
        &DeviceSecurityDescriptor,
        NonPagedPool,
        IoGetFileObjectGenericMapping()
        );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC CreateDeviceSecurityDescriptor: SeSetSecurity failed, %lx\n", Status))
            );
        goto ErrorExit;
    }

    //
    // Update the driver DACL
    //
    Status = ObSetSecurityObjectByPointer(
        DeviceContext->DeviceObject, 
        SecurityInformation, 
        DeviceSecurityDescriptor
        );
    
ErrorExit:

    ObReleaseObjectSecurity(SecurityDescriptor, MemoryAllocated);

    if (DeviceSecurityDescriptor) {
        ExFreePool(DeviceSecurityDescriptor);
    }
    
    SAFE_FREE_POOL(&RawAcl);

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC CreateDeviceSecurityDescriptor: Exiting with status 0x%x\n", Status))
        );

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\iomgr.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    iomgr.h

Abstract:

    This is the common header for all io managers.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#ifndef IO_MGR_H
#define IO_MGR_H

#include <initguid.h>

DEFINE_GUID(
    PRIMARY_SAC_CHANNEL_APPLICATION_GUID,   
    0x63d02270, 0x8aa4, 0x11d5, 0xbc, 0xcf, 0x80, 0x6d, 0x61, 0x72, 0x69, 0x6f
    );

extern PSAC_CHANNEL SacChannel;

extern BOOLEAN GlobalPagingNeeded;
extern BOOLEAN GlobalDoThreads;

// For the APC routines, a global value is better :-)
extern IO_STATUS_BLOCK GlobalIoStatusBlock;

//
// Global buffer
//
extern ULONG GlobalBufferSize;
extern char *GlobalBuffer;

extern WCHAR *StateTable[];

extern WCHAR *WaitTable[];

extern WCHAR *Empty;

#define IP_LOOPBACK(x)  (((x) & 0x000000ff) == 0x7f)

#define IS_WHITESPACE(_ch) ((_ch == ' ') || (_ch == '\t'))
#define IS_NUMBER(_ch) ((_ch >= '0') && (_ch <= '9'))

#define SKIP_WHITESPACE(_pch) \
     while (IS_WHITESPACE(*_pch) && (*_pch != '\0')) { \
        _pch++; \
     }

#define SKIP_NUMBERS(_pch) \
     while (IS_NUMBER(*_pch) && (*_pch != '\0')) { \
        _pch++; \
     }

typedef struct _SAC_RSP_TLIST {
            
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDayInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;

    ULONG PagefileInfoOffset;
    ULONG ProcessInfoOffset;

} SAC_RSP_TLIST, *PSAC_RSP_TLIST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\rawchan.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    rawchan.c

Abstract:

    Routines for managing channels in the sac.

Author:

    Sean Selitrennikoff (v-seans) Sept, 2000.
    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#include "sac.h"

VOID
RawChannelSetIBufferIndex(
    IN PSAC_CHANNEL     Channel,
    IN ULONG            IBufferIndex
    );

ULONG
RawChannelGetIBufferIndex(
    IN  PSAC_CHANNEL    Channel
    );

NTSTATUS
RawChannelCreate(
    IN OUT PSAC_CHANNEL     Channel
    )
/*++

Routine Description:

    This routine allocates a channel and returns a pointer to it.
    
Arguments:

    Channel         - The resulting channel.
    
    OpenChannelCmd  - All the parameters for the new channel
    
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);
    
    Channel->OBuffer = (PUCHAR)ALLOCATE_POOL(SAC_RAW_OBUFFER_SIZE, GENERAL_POOL_TAG);
    ASSERT_STATUS(Channel->OBuffer, STATUS_NO_MEMORY);

    Channel->IBuffer = (PUCHAR)ALLOCATE_POOL(SAC_RAW_IBUFFER_SIZE, GENERAL_POOL_TAG);
    ASSERT_STATUS(Channel->IBuffer, STATUS_NO_MEMORY);
    
    Channel->OBufferIndex = 0;
    Channel->OBufferFirstGoodIndex = 0;
    
    ChannelSetIBufferHasNewData(Channel, FALSE);
    ChannelSetOBufferHasNewData(Channel, FALSE);

    return STATUS_SUCCESS;
}

NTSTATUS
RawChannelDestroy(
    IN OUT PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine closes a channel.
    
Arguments:

    Channel - The channel to be closed
    
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    //
    // Free the dynamically allocated memory
    //

    if (Channel->OBuffer) {
        FREE_POOL(&(Channel->OBuffer));
        Channel->OBuffer = NULL;
    }

    if (Channel->IBuffer) {
        FREE_POOL(&(Channel->IBuffer));
        Channel->IBuffer = NULL;
    }
    
    //
    // Now that we've done our channel specific destroy, 
    // Call the general channel destroy
    //
    Status = ChannelDestroy(Channel);

    return Status;
}

NTSTATUS
RawChannelORead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount
    )
/*++

Routine Description:

    This routine attempts to read BufferSize characters from the output buffer.  
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - Outgoing buffer   
    BufferSize  - Outgoing buffer size
    ByteCount   - The number of bytes actually read
    
    
    Note: if the buffered data stored in the channel has now been sent.
          If Channel is also in the Inactive state, the channel will
          now be qualified for removal.
    
Return Value:

    Status

--*/
{
    NTSTATUS        Status;
    PUCHAR          RawBuffer;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(Buffer,  STATUS_INVALID_PARAMETER_2);
    ASSERT_STATUS(BufferSize > 0,  STATUS_INVALID_PARAMETER_3);
    ASSERT_STATUS(ByteCount,  STATUS_INVALID_PARAMETER_4);
    
    do {

        //
        // We read 0 characters
        //
        *ByteCount = 0;

        //
        // if there is no data to read,
        // then report this to the caller
        // else read as much data as we can
        //
        if (! ChannelHasNewOBufferData(Channel)) {
            
            //
            // We are out of data
            //
            Status = STATUS_NO_DATA_DETECTED;

            break;

        }

        //
        // Get the raw channel obuffer
        //
        RawBuffer = (PUCHAR)Channel->OBuffer;

        //
        // default: we succeded to copy data
        //
        Status = STATUS_SUCCESS;

        //
        // Attempt to read the buffer
        //
        do {

            //
            // Do a byte-wise copy of the OBuffer to the destination buffer
            // 
            // Note: doing a byte-wise copy rather than an RtlCopyMemory is
            //       ok here since in general, this routine is called with 
            //       a small buffer size.  Naturally, if the use of Raw Channels
            //       changes and becomes dependent on a faster ORead, this
            //       will have to change.
            //

            //
            // copy the char
            //
            Buffer[*ByteCount] = RawBuffer[Channel->OBufferFirstGoodIndex];

            //
            // increment the byte count to what we actually read
            //
            *ByteCount += 1;

            //
            // advance the pointer to the next good index
            //
            Channel->OBufferFirstGoodIndex = (Channel->OBufferFirstGoodIndex + 1) % SAC_RAW_OBUFFER_SIZE;

            //
            // Make sure we don't pass the end of the buffer
            //
            if (Channel->OBufferFirstGoodIndex == Channel->OBufferIndex) {

                //
                // we have no new data
                //
                ChannelSetOBufferHasNewData(Channel, FALSE);

                break;

            }

            //
            // confirm the obvious
            //
            ASSERT(*ByteCount > 0);

        } while(*ByteCount < BufferSize);

    } while ( FALSE );

#if DBG
    //
    // More sanity checking
    //

    if (Channel->OBufferFirstGoodIndex == Channel->OBufferIndex) {
        ASSERT(ChannelHasNewOBufferData(Channel) == FALSE);
    }

    if (ChannelHasNewOBufferData(Channel) == FALSE) {
        ASSERT(Channel->OBufferFirstGoodIndex == Channel->OBufferIndex);
    }
#endif
    
    return Status;
}

NTSTATUS
RawChannelOEcho(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      String,
    IN ULONG        Size
    )
/*++

Routine Description:

    This routine puts the string out the headless port.
    
Arguments:

    Channel - Previously created channel.
    String  - Output string.
    Length  - The # of String bytes to process
    
Return Value:

    STATUS_SUCCESS if successful, otherwise status

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(String, STATUS_INVALID_PARAMETER_2);

    ASSERT(FIELD_OFFSET(HEADLESS_CMD_PUT_STRING, String) == 0);  // ASSERT if anyone changes this structure.
    
    //
    // Default: we succeeded
    //
    Status = STATUS_SUCCESS;
    
    //
    // Only echo if the buffer has something to send
    //
    if (Size > 0) {
        
        //
        // Send the bytes
        //
        Status = IoMgrWriteData(
            Channel,
            String,
            Size
            );
    
        //
        // If we were successful, flush the channel's data in the iomgr 
        //
        if (NT_SUCCESS(Status)) {
            Status = IoMgrFlushData(Channel);
        } 

    }

    return Status;
}


NTSTATUS
RawChannelOWrite(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      String,
    IN ULONG        Size
    )
/*++

Routine Description:

    This routine takes a string and prints it to the specified channel.  If the channel
    is the currently active channel, it puts the string out the headless port as well.
    
    Note: Current Channel lock must be held by caller            

Arguments:

    Channel - Previously created channel.
    String  - Output string.
    Length  - The # of String bytes to process
    
Return Value:

    STATUS_SUCCESS if successful, otherwise status

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(String, STATUS_INVALID_PARAMETER_2);
    
    ASSERT(FIELD_OFFSET(HEADLESS_CMD_PUT_STRING, String) == 0);  // ASSERT if anyone changes this structure.
    
    do {
        //
        // if the current channel is the active channel and the user has selected
        // to display this channel, relay the output directly to the user
        //
        if (IoMgrIsWriteEnabled(Channel) && ChannelSentToScreen(Channel)){

            Status = RawChannelOEcho(
                Channel, 
                String,
                Size
                );

            if (! NT_SUCCESS(Status)) {
                break;
            }
        
        } else {

            //
            // Write the data to the channel's obuffer
            //
            Status = RawChannelOWrite2(
                Channel,
                String, 
                Size
                ); 

            if (! NT_SUCCESS(Status)) {
                break;
            }

        }

    } while ( FALSE );

    return Status;
}

NTSTATUS
RawChannelOWrite2(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      String,
    IN ULONG        Size
    )
/*++

Routine Description:

    This routine takes a string and prints it into directly into the
    screen buffer with NO translation.
    
Arguments:

    Channel - Previously created channel.
    
    String  - String to print.

    Size    - the # of bytes to write.  
    
        Note:   If String is a character string, the Size = strlen(String),
                otherwise, Size = the # of bytes to process.
      
Return Value:

    STATUS_SUCCESS if successful, otherwise status

--*/
{
    ULONG   i;
    BOOLEAN TrackIndex;
    PUCHAR  RawBuffer;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(String, STATUS_INVALID_PARAMETER_2);

    //
    // If size == 0, then we are done
    //
    if (Size == 0) {
        return STATUS_SUCCESS;
    }

    //
    // Get the raw channel obuffer
    //
    RawBuffer = (PUCHAR)Channel->OBuffer;

    //
    // We are not in direct IO mode, so we need to buffer the string
    //

    TrackIndex = FALSE;

    for (i = 0; i < Size; i++) {

        //
        // Did we span over Good Data?  If so, then we need to 
        // move the First Good pointer.  The new First Good pointer position
        // is immediately after the newest data entry in the buffer.
        //
        // Note: Since both indices start at the same position, 
        //       we need to skip the case when RawBufferIndex == RawBufferFirstGoodIndex
        //       and there is no data in the buffer ((i == 0) && RawBufferHasNewData == FALSE),
        //       otherwise the RawBufferFirstGoodIndex will always track the RawBufferIndex.
        //       We need to let RawBufferIndex go around the ring buffer once before we enable
        //       tracking.
        //
        if ((Channel->OBufferIndex == Channel->OBufferFirstGoodIndex) &&
            ((i > 0) || (ChannelHasNewOBufferData(Channel) == TRUE))
            ) {

            TrackIndex = TRUE;

        }
        
        ASSERT(Channel->OBufferIndex < SAC_RAW_OBUFFER_SIZE);

        RawBuffer[Channel->OBufferIndex] = String[i];

        Channel->OBufferIndex = (Channel->OBufferIndex + 1) % SAC_RAW_OBUFFER_SIZE;

        if (TrackIndex) {

            Channel->OBufferFirstGoodIndex = Channel->OBufferIndex;

        }

    }

    ChannelSetOBufferHasNewData(Channel, TRUE);

    return STATUS_SUCCESS;
}


NTSTATUS
RawChannelOFlush(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

     Send all the data in the raw buffer since the channel was last active
     (or since the channel was created)
    
Arguments:

    Channel - Previously created channel.
    
Return Value:

    STATUS_SUCCESS if successful, otherwise status

--*/
{
    NTSTATUS    Status;
    PUCHAR      RawBuffer;    
    UCHAR       ch;
    ULONG       ByteCount;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    
    //
    // Get the raw channel obuffer
    //
    RawBuffer = (PUCHAR)Channel->OBuffer;

    //
    // default: we succeeded
    //
    Status = STATUS_SUCCESS;
    
    //
    // Send the Obuffer out to the headless port
    //
    while ( ChannelHasNewOBufferData(Channel) == TRUE ) {

        //
        // get a byte from the OBuffer
        // 
        Status = RawChannelORead(
            Channel,
            &ch,
            sizeof(ch),
            &ByteCount
            );

        if (! NT_SUCCESS(Status)) {
            break;
        }

        ASSERT(ByteCount == 1);
        if (ByteCount != 1) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // Send the byte
        // 
        Status = IoMgrWriteData(
            Channel,
            &ch,
            sizeof(ch)
            );

        if (! NT_SUCCESS(Status)) {
            break;
        }

    }

    //
    // If we were successful, flush the channel's data in the iomgr 
    //
    if (NT_SUCCESS(Status)) {
        Status = IoMgrFlushData(Channel);
    }

    return Status;
}

NTSTATUS
RawChannelIWrite(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    )
/*++

Routine Description:

    This routine takes a single character and adds it to the buffered input for this channel.
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - Incoming buffer of UCHARs   
    BufferSize  - Incoming buffer size

Return Value:

    STATUS_SUCCESS if successful, otherwise status

--*/
{
    NTSTATUS    Status;
    BOOLEAN     IBufferStatus;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(Buffer, STATUS_INVALID_PARAMETER_2);
    ASSERT_STATUS(BufferSize > 0, STATUS_INVALID_BUFFER_SIZE);

    //
    // Make sure we aren't full
    //
    Status = RawChannelIBufferIsFull(
        Channel,
        &IBufferStatus
        );

    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // If there is no more room, then fail
    //
    if (IBufferStatus == TRUE) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // make sure there is enough room for the buffer
    //
    // Note: this prevents us from writing a portion of the buffer
    //       and then failing, leaving the caller in the state where
    //       it doesn't know how much of the buffer was written.
    //
    if ((SAC_RAW_IBUFFER_SIZE - RawChannelGetIBufferIndex(Channel)) < BufferSize) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // default: we succeeded
    //
    Status = STATUS_SUCCESS;

    //
    // Copy the new data to the ibuffer
    //
    RtlCopyMemory(
        &Channel->IBuffer[RawChannelGetIBufferIndex(Channel)],
        Buffer,
        BufferSize
        );

    //
    // Account for the newly appended data
    //
    RawChannelSetIBufferIndex(
        Channel,
        RawChannelGetIBufferIndex(Channel) + BufferSize
        );
    
    
    //
    // Fire the HasNewData event if specified
    //
    if (Channel->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) {

        ASSERT(Channel->HasNewDataEvent);
        ASSERT(Channel->HasNewDataEventObjectBody);
        ASSERT(Channel->HasNewDataEventWaitObjectBody);

        KeSetEvent(
            Channel->HasNewDataEventWaitObjectBody,
            EVENT_INCREMENT,
            FALSE
            );

    }

    return Status;
}

NTSTATUS
RawChannelIRead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount   
    )

/*++

Routine Description:

    This routine takes the first character in the input buffer, removes and returns it.  If 
    there is none, it returns 0x0.
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - The buffer to read into
    BufferSize  - The size of the buffer 
    ByteCount   - The # of bytes read
          
Return Value:

    Status

--*/
{
    ULONG   CopyChars;
    ULONG   CopySize;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(Buffer, STATUS_INVALID_PARAMETER_2);
    ASSERT_STATUS(BufferSize > 0, STATUS_INVALID_BUFFER_SIZE);
    
    //
    // initialize
    //
    CopyChars = 0;
    CopySize = 0;

    //
    // Default: no bytes were read
    //
    *ByteCount = 0;

    //
    // If there is nothing to send, 
    // then return that we read 0 bytes
    //
    if (Channel->IBufferLength(Channel) == 0) {
        
        ASSERT(ChannelHasNewIBufferData(Channel) == FALSE);
        
        return STATUS_SUCCESS;
    
    }

    //
    // Caclulate the largest buffer size we can use (and need), and then calculate
    // the number of characters this refers to.
    //
    CopySize    = Channel->IBufferLength(Channel) * sizeof(UCHAR);
    CopySize    = CopySize > BufferSize ? BufferSize : CopySize;
    CopyChars   = CopySize / sizeof(UCHAR);
    
    //
    // We need to recalc the CopySize in case there was a rounding down when
    // computing CopyChars
    //
    CopySize    = CopyChars * sizeof(UCHAR);
    
    ASSERT(CopyChars <= Channel->IBufferLength(Channel));
    
    //
    // Do a block copy of the ibuffer to the destination buffer
    //
    RtlCopyMemory(
        Buffer,
        Channel->IBuffer,
        CopySize
        );
    
    //
    // subtract the # of characters copied from the character counter
    //
    RawChannelSetIBufferIndex(
        Channel,
        RawChannelGetIBufferIndex(Channel) - CopyChars
        );
    
    //
    // If there is remaining data left in the Channel input buffer, 
    // shift it to the beginning
    //
    if (Channel->IBufferLength(Channel) > 0) {

        RtlMoveMemory(&(Channel->IBuffer[0]), 
                      &(Channel->IBuffer[CopyChars]),
                      Channel->IBufferLength(Channel) * sizeof(Channel->IBuffer[0])
                     );

    } 
    
    //
    // Send back the # of bytes read
    //
    *ByteCount = CopySize;

    return STATUS_SUCCESS;

}

NTSTATUS
RawChannelIBufferIsFull(
    IN  PSAC_CHANNEL    Channel,
    OUT BOOLEAN*        BufferStatus
    )
/*++

Routine Description:

    Determine if the IBuffer is full
    
Arguments:

    Channel         - Previously created channel.
    BufferStatus    - on exit, TRUE if the buffer is full, otherwise FALSE
    
Return Value:

    Status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(BufferStatus, STATUS_INVALID_PARAMETER_2);

    *BufferStatus = (BOOLEAN)(RawChannelGetIBufferIndex(Channel) >= (SAC_RAW_IBUFFER_SIZE-1));

    return STATUS_SUCCESS;
}

ULONG
RawChannelIBufferLength(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This routine determines the length of the input buffer, treating the input buffer
    contents as a string
    
Arguments:

    Channel     - Previously created channel.
    
Return Value:

    The length of the current input buffer

--*/
{
    ASSERT(Channel);

    return (RawChannelGetIBufferIndex(Channel) / sizeof(UCHAR));
}


WCHAR
RawChannelIReadLast(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This routine takes the last character in the input buffer, removes and returns it.  If 
    there is none, it returns 0x0.
    
Arguments:

    Channel - Previously created channel.
    
Return Value:

    Last character in the input buffer.

--*/
{
    WCHAR Char;

    ASSERT(Channel);
    
    //
    // default: no character was read
    //
    Char = UNICODE_NULL;

    if (Channel->IBufferLength(Channel) > 0) {
        
        RawChannelSetIBufferIndex(
            Channel,
            RawChannelGetIBufferIndex(Channel) - sizeof(UCHAR)
            );
        
        Char = Channel->IBuffer[RawChannelGetIBufferIndex(Channel)];
        
        Channel->IBuffer[RawChannelGetIBufferIndex(Channel)] = UNICODE_NULL;
    
    }

    return Char;
}

ULONG
RawChannelGetIBufferIndex(
    IN  PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    Get teh ibuffer index
    
Arguments:

    Channel - the channel to get the ibuffer index from

Environment:
    
    The ibuffer index

--*/
{
    ASSERT(Channel);
    
    //
    // Make sure the ibuffer index is atleast aligned to a WCHAR
    //
    ASSERT((Channel->IBufferIndex % sizeof(UCHAR)) == 0);
    
    //
    // Make sure the ibuffer index is in bounds
    //
    ASSERT(Channel->IBufferIndex < SAC_RAW_IBUFFER_SIZE);
    
    return Channel->IBufferIndex;
}

VOID
RawChannelSetIBufferIndex(
    IN PSAC_CHANNEL     Channel,
    IN ULONG            IBufferIndex
    )
/*++

Routine Description:

    Set the ibuffer index
    
Arguments:

    Channel         - the channel to get the ibuffer index from
    IBufferIndex    - the new inbuffer index
                 
Environment:
    
    None

--*/
{

    ASSERT(Channel);
    
    //
    // Make sure the ibuffer index is atleast aligned to a WCHAR
    //
    ASSERT((Channel->IBufferIndex % sizeof(UCHAR)) == 0);
    
    //
    // Make sure the ibuffer index is in bounds
    //
    ASSERT(Channel->IBufferIndex < SAC_RAW_IBUFFER_SIZE);

    //
    // Set the index
    //
    Channel->IBufferIndex = IBufferIndex;

    //
    // Set the has new data flag accordingly
    //
    ChannelSetIBufferHasNewData(
        Channel, 
        Channel->IBufferIndex == 0 ? FALSE : TRUE
        );
    
    //
    // Additional checking if the index == 0
    //
    if (Channel->IBufferIndex == 0) {
            
        //
        // Clear the Has New Data event if specified
        //
        if (Channel->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) {
    
            ASSERT(Channel->HasNewDataEvent);
            ASSERT(Channel->HasNewDataEventObjectBody);
            ASSERT(Channel->HasNewDataEventWaitObjectBody);
    
            KeClearEvent(Channel->HasNewDataEventWaitObjectBody);
    
        }
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=drivers
MINORCOMP=sac

TARGETNAME=sacdrv
TARGETPATH=obj
TARGETTYPE=DRIVER

TARGETLIBS=

INCLUDES=$(BASE_INC_PATH);$(NET_INC_PATH)

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_ -D_PNP_POWER_ -DBUFFER_OWNERSHIP=1

SOURCES=                \
        ..\chanmgr.c    \
        ..\channel.c    \
        ..\rawchan.c    \
        ..\cmdchan.c    \
        ..\vtutf8chan.c  \
        ..\iomgr.c      \
        ..\concmd.c     \
        ..\conmgr.c     \
        ..\data.c       \
        ..\dispatch.c   \
        ..\event.c      \
        ..\init.c       \
        ..\memory.c     \
        ..\sacmsg.mc    \
        ..\util.c       \
        ..\version.rc   \

UMRES=obj\*\sac.res

MSC_WARNING_LEVEL=/W4 /WX

SOURCES_USED=..\sources.inc

PASS0_PUBLISH=\
        {$(O)\sacmsg.h=$(PROJECT_INC_PATH)\sacmsg.h}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\sac.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sac.h

Abstract:

    This is the local header file for SAC.   It includes all other
    necessary header files for this driver.

Author:

    Sean Selitrennikoff (v-seans) - Jan 11, 1999

Revision History:

--*/

#ifndef _SACP_
#define _SACP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
//#pragma warning(disable:4206)   // translation unit empty
//#pragma warning(disable:4706)   // assignment within conditional
//#pragma warning(disable:4324)   // structure was padded
//#pragma warning(disable:4328)   // greater alignment than needed

#include <stdio.h>
#include <ntosp.h>
#include <zwapi.h>
#include <hdlsblk.h>
#include <hdlsterm.h>

#include "sacmsg.h"
#include <ntddsac.h>

//
// Debug spew control
//
#if DBG
extern ULONG SACDebug;
#define SAC_DEBUG_FUNC_TRACE           0x0001
#define SAC_DEBUG_FAILS                0x0004
#define SAC_DEBUG_RECEIVE              0x0008
#define SAC_DEBUG_FUNC_TRACE_LOUD      0x2000  // Warning! This could get loud!
#define SAC_DEBUG_MEM                  0x1000  // Warning! This could get loud!

#define IF_SAC_DEBUG(x, y) if ((x) & SACDebug) { y; }
#else
#define IF_SAC_DEBUG(x, y)
#endif

#define ASSERT_STATUS(_C, _S)\
    ASSERT((_C));\
    if (!(_C)) {\
        return(_S);\
    }

#if 0
//
// General lock (mutex) management macros
//
typedef struct _SAC_LOCK {
    
    ULONG   RefCount;
    KMUTEX  Mutex;

} SAC_LOCK, *PSAC_LOCK;

#define INITIALIZE_LOCK(_l)     \
    KeInitializeMutex(          \
        &(_l.Mutex),            \
        0                       \
        );                      \
    _l.RefCount = 0;

#define LOCK_IS_SIGNALED(_l)    \
    (KeReadStateMutex(&(_l.Mutex)) == 1 ? TRUE : FALSE)

#define LOCK_HAS_ZERO_REF_COUNT(_l) \
    (_l.RefCount == 0 ? TRUE : FALSE)

#define ACQUIRE_LOCK(_l)                    \
    KeWaitForMutexObject(                   \
        &(_l.Mutex),                        \
        Executive,                          \
        KernelMode,                         \
        FALSE,                              \
        NULL                                \
        );                                  \
    ASSERT(_l.RefCount == 0);               \
    InterlockedIncrement(&(_l.RefCount));

#define RELEASE_LOCK(_l)                    \
    ASSERT(_l.RefCount == 1);               \
    InterlockedDecrement(&(_l.RefCount));   \
    KeReleaseMutex(                         \
        &(_l.Mutex),                        \
        FALSE                               \
        );
#else
//
// General lock (mutex) management macros
//
typedef struct _SAC_LOCK {
    
    ULONG       RefCount;
    KSEMAPHORE  Lock;

} SAC_LOCK, *PSAC_LOCK;

#define INITIALIZE_LOCK(_l)     \
    KeInitializeSemaphore(      \
        &(_l.Lock),             \
        1,                      \
        1                       \
        );                      \
    _l.RefCount = 0;

#define LOCK_IS_SIGNALED(_l)    \
    (KeReadStateSemaphore(&(_l.Lock)) == 1 ? TRUE : FALSE)

#define LOCK_HAS_ZERO_REF_COUNT(_l) \
    (_l.RefCount == 0 ? TRUE : FALSE)

#define ACQUIRE_LOCK(_l)                    \
    KeWaitForSingleObject(                  \
        &(_l.Lock),                         \
        Executive,                          \
        KernelMode,                         \
        FALSE,                              \
        NULL                                \
        );                                  \
    ASSERT(_l.RefCount == 0);               \
    InterlockedIncrement((volatile long *)&(_l.RefCount));

#define RELEASE_LOCK(_l)                    \
    ASSERT(_l.RefCount == 1);               \
    InterlockedDecrement((volatile long *)&(_l.RefCount));   \
    KeReleaseSemaphore(                     \
        &(_l.Lock),                         \
        IO_NO_INCREMENT,                    \
        1,                                  \
        FALSE                               \
        );
#endif

//
// This really belongs in ntdef or someplace like that...
//
typedef CONST UCHAR *LPCUCHAR, *PCUCHAR;

#include "channel.h"

//
// this macro ensures that we assert if we buffer overrun during the swprintf
//
// NOTE: 1 is added to the length to acct for UNICODE_NULL
//
#define SAFE_SWPRINTF(_size, _p)\
    {                           \
        ULONG   l;              \
        l = swprintf _p;       \
        ASSERT(((l+1)*sizeof(WCHAR)) <= _size);      \
    }                           

//
// NOTE: 1 is added to the length to acct for UNICODE_NULL
//
#define SAFE_WCSCPY(_size, _d, _s)                  \
    {                                               \
        if (_size >= 2) {                           \
            ULONG   l;                                                  \
            l = (ULONG)wcslen(_s);                                      \
            ASSERT(((l+1)*sizeof(WCHAR)) <= _size);                     \
            wcsncpy(_d,_s,(_size / sizeof(WCHAR)));                     \
            (_d)[(_size / sizeof(WCHAR)) - 1] = UNICODE_NULL;           \
        } else {                                                        \
            ASSERT(0);                                                  \
        }                                                               \
    }                           

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

//
// Machine Information table and routines.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

//
// common xml header
//
#define XML_VERSION_HEADER  L"<?xml version=\"1.0\"?>\r\n"

//
// Device name
//
#define SAC_DEVICE_NAME L"\\Device\\SAC"
#define SAC_DOSDEVICE_NAME L"\\DosDevices\\SAC"

//
// Memory tags
//
#define ALLOC_POOL_TAG             ((ULONG)'ApcR')
#define INITIAL_POOL_TAG           ((ULONG)'IpcR')
//#define IRP_POOL_TAG               ((ULONG)'JpcR')
#define SECURITY_POOL_TAG          ((ULONG)'SpcR')

//
// SAC internal Memory tags
//
#define FREE_POOL_TAG              ((ULONG)'FpcR')
#define GENERAL_POOL_TAG           ((ULONG)'GpcR')
#define CHANNEL_POOL_TAG           ((ULONG)'CpcR')

//
// Other defines
//

#define MEMORY_INCREMENT 0x1000

#define DEFAULT_IRP_STACK_SIZE 16
#define DEFAULT_PRIORITY_BOOST 2
#define SAC_SUBMIT_IOCTL 1
#define SAC_PROCESS_INPUT 2
#define SAC_CHANGE_CHANNEL  3
#define SAC_DISPLAY_CHANNEL 4
#define SAC_NO_OP 0
#define SAC_RETRY_GAP 10
#define SAC_PROCESS_SERIAL_PORT_BUFFER 20

//
// Context for each device created
//
typedef struct _SAC_DEVICE_CONTEXT {

    PDEVICE_OBJECT DeviceObject;        // back pointer to the device object.

    BOOLEAN InitializedAndReady;        // Is this device ready to go?
    BOOLEAN Processing;                 // Is something being processed on this device?
    BOOLEAN ExitThread;                 // Should the worker thread exit?

    CCHAR PriorityBoost;                // boost to priority for completions.
    PKPROCESS SystemProcess;            // context for grabbing handles
    PSECURITY_DESCRIPTOR AdminSecurityDescriptor; 
    KSPIN_LOCK SpinLock;                // Used to lock this data structure for access.
    KEVENT UnloadEvent;                 // Used to signal the thread trying to unload to continue processing.
    KEVENT ProcessEvent;                // Used to signal worker thread to process the next request.

    HANDLE ThreadHandle;                // Handle for the worker thread.
    KEVENT ThreadExitEvent;             // Used to main thread the worker thread is exiting.
    
    KTIMER Timer;                       // Used to poll for user input.
    KDPC Dpc;                           // Used with the above timer.
    
    LIST_ENTRY IrpQueue;                // List of IRPs to be processed.

} SAC_DEVICE_CONTEXT, * PSAC_DEVICE_CONTEXT;

//
// Structure to hold general machine information
//
typedef struct _MACHINE_INFORMATION {

    PWSTR   MachineName;
    PWSTR   GUID;
    PWSTR   ProcessorArchitecture;
    PWSTR   OSVersion;
    PWSTR   OSBuildNumber;
    PWSTR   OSProductType;
    PWSTR   OSServicePack;

} MACHINE_INFORMATION, *PMACHINE_INFORMATION;

//
// IoMgrHandleEvent event types 
//
typedef enum _IO_MGR_EVENT {

    IO_MGR_EVENT_CHANNEL_CREATE = 0,
    IO_MGR_EVENT_CHANNEL_CLOSE,
    IO_MGR_EVENT_CHANNEL_WRITE,
    IO_MGR_EVENT_REGISTER_SAC_CMD_EVENT,
    IO_MGR_EVENT_UNREGISTER_SAC_CMD_EVENT,
    IO_MGR_EVENT_SHUTDOWN

} IO_MGR_EVENT;

//
// IO Manager function types
//
typedef NTSTATUS 
(*IO_MGR_HANDLE_EVENT)(
    IN IO_MGR_EVENT Event,
    IN PSAC_CHANNEL Channel,
    IN PVOID        Data
    );

typedef NTSTATUS 
(*IO_MGR_INITITIALIZE)(
    VOID
    );

typedef NTSTATUS 
(*IO_MGR_SHUTDOWN)(
    VOID
    );

typedef VOID
(*IO_MGR_WORKER)(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );

typedef BOOLEAN
(*IO_MGR_IS_WRITE_ENABLED)(
    IN PSAC_CHANNEL Channel
    );

typedef NTSTATUS
(*IO_MGR_WRITE_DATA)(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

typedef NTSTATUS
(*IO_MGR_FLUSH_DATA)(
    IN PSAC_CHANNEL Channel
    );

//
// Global data 
//

//
// Function pointers to the routines that implement the I/O Manager behavior
//
extern IO_MGR_HANDLE_EVENT          IoMgrHandleEvent;
extern IO_MGR_INITITIALIZE          IoMgrInitialize;
extern IO_MGR_SHUTDOWN              IoMgrShutdown;
extern IO_MGR_WORKER                IoMgrWorkerProcessEvents;
extern IO_MGR_IS_WRITE_ENABLED      IoMgrIsWriteEnabled;
extern IO_MGR_WRITE_DATA            IoMgrWriteData;
extern IO_MGR_FLUSH_DATA            IoMgrFlushData;

extern PMACHINE_INFORMATION     MachineInformation;
extern BOOLEAN                  GlobalDataInitialized;
extern BOOLEAN                  GlobalPagingNeeded;
extern BOOLEAN                  IoctlSubmitted;
extern LONG                     ProcessingType;
extern HANDLE                   SACEventHandle;
extern PKEVENT                  SACEvent;

//
// Enable the ability to check that the process/service that
// registered is the one that is unregistering
//
#define ENABLE_SERVICE_FILE_OBJECT_CHECKING 1

//
// Enable user-specified feature control for cmd sessions
//
#define ENABLE_CMD_SESSION_PERMISSION_CHECKING 1

//
// Enable the ability to override the service start type
// based on the cmd session permissions
//
// Note: ENABLE_CMD_SESSION_PERMISSION_CHECKING must be 1
//       for this feature to work
//
#define ENABLE_SACSVR_START_TYPE_OVERRIDE 1

//
// Globals controlling if command console channels may be launched
//
#if ENABLE_CMD_SESSION_PERMISSION_CHECKING

extern BOOLEAN  CommandConsoleLaunchingEnabled;

#define IsCommandConsoleLaunchingEnabled()  (CommandConsoleLaunchingEnabled)

#endif

//
// The UTF8 encoding buffer
//
// Note: this buffer used during driver initialization,
//       the Console Manager and VTUTF8 channels.
//       It is safe to do this because the writes of these
//       modules never overlap.
//       The console manager uses the CURRENT CHANNEL LOCK
//       to ensure that no two modules write out at the same
//       time.
//
extern PUCHAR   Utf8ConversionBuffer;
extern ULONG    Utf8ConversionBufferSize;

//
// Define the max # of Unicode chars that can be translated with the
// given size of the utf8 translation buffer
//
#define MAX_UTF8_ENCODE_BLOCK_LENGTH ((Utf8ConversionBufferSize / 3) - 1)

//
// Globals for managing incremental UTF8 encoding for VTUTF8 channels
//
// Note: it is safe to use this as a global because only
//       one channel ever has the focus.  Hence, no two threads
//       should ever be decoding UFT8 at the same time.
//
extern WCHAR IncomingUnicodeValue;
extern UCHAR IncomingUtf8ConversionBuffer[3];

//
// Command console event info:
//
// Pointers to the event handles for the Command Console event service
//
extern PVOID            RequestSacCmdEventObjectBody;
extern PVOID            RequestSacCmdEventWaitObjectBody;
extern PVOID            RequestSacCmdSuccessEventObjectBody;
extern PVOID            RequestSacCmdSuccessEventWaitObjectBody;
extern PVOID            RequestSacCmdFailureEventObjectBody;
extern PVOID            RequestSacCmdFailureEventWaitObjectBody;
extern BOOLEAN          HaveUserModeServiceCmdEventInfo;
extern KMUTEX           SACCmdEventInfoMutex;
#if ENABLE_SERVICE_FILE_OBJECT_CHECKING
extern PFILE_OBJECT     ServiceProcessFileObject;
#endif

//
// Has the user-mode service registered?
//
#define UserModeServiceHasRegisteredCmdEvent() (HaveUserModeServiceCmdEventInfo)

//
// Serial Port Buffer globals
//

//
// Size of the serial port buffer
//
#define SERIAL_PORT_BUFFER_LENGTH 1024
#define SERIAL_PORT_BUFFER_SIZE  (SERIAL_PORT_BUFFER_LENGTH * sizeof(UCHAR))

//
// Serial port buffer and producer/consumer indices
//
// Note: there can be only one consumer
//
extern PUCHAR  SerialPortBuffer;
extern ULONG   SerialPortProducerIndex;
extern ULONG   SerialPortConsumerIndex;

//
// Memory management routines
//
#define ALLOCATE_POOL(b,t) MyAllocatePool( b, t, __FILE__, __LINE__ )
#define SAFE_FREE_POOL(_b)  \
    if (*_b) {               \
        FREE_POOL(_b);      \
    }
#define FREE_POOL(b) MyFreePool( b )

//
// 
//

BOOLEAN
InitializeMemoryManagement(
    VOID
    );

VOID
FreeMemoryManagement(
    VOID
    );

PVOID
MyAllocatePool(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PCHAR FileName,
    IN ULONG LineNumber
    );

VOID
MyFreePool(
    IN PVOID Pointer
    );

//
// Initialization routines.
//
BOOLEAN
InitializeGlobalData(
    IN PUNICODE_STRING RegistryPath,
    IN PDRIVER_OBJECT DriverObject
    );

VOID
FreeGlobalData(
    VOID
    );

BOOLEAN
InitializeDeviceData(
    PDEVICE_OBJECT DeviceObject
    );

VOID
FreeDeviceData(
    PDEVICE_OBJECT DeviceContext
    );

VOID
InitializeCmdEventInfo(
    VOID
    );

//
// Dispatch routines
//
NTSTATUS
Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DispatchShutdownControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UnloadHandler(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DispatchSend(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );

VOID
DoDeferred(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );

//
// Worker thread routines.
//

VOID
TimerDpcRoutine(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
WorkerProcessEvents(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );

#include "util.h"

//
// Channel routines
//

#include "xmlmgr.h"
#include "conmgr.h"
#include "chanmgr.h"
#include "vtutf8chan.h"
#include "rawchan.h"
#include "cmdchan.h"

#endif // ndef _SACP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\rawchan.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    rawchan.h

Abstract:

    Routines for managing Raw channels.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#ifndef RAW_CHAN_H
#define RAW_CHAN_H

//
// The size of the I/O Buffers for raw channels
//
#define SAC_RAW_OBUFFER_SIZE ((MEMORY_INCREMENT*2) / sizeof(UCHAR))
#define SAC_RAW_IBUFFER_SIZE ((MEMORY_INCREMENT*2) / sizeof(UCHAR))

//
// prototypes
//
NTSTATUS
RawChannelCreate(
    IN OUT PSAC_CHANNEL     Channel
    );

NTSTATUS
RawChannelDestroy(
    IN OUT PSAC_CHANNEL     Channel
    );


NTSTATUS
RawChannelORead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount
    );

NTSTATUS
RawChannelOEcho(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
RawChannelOWrite(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
RawChannelOWrite2(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );


NTSTATUS
RawChannelOFlush(
    IN PSAC_CHANNEL Channel
    );

NTSTATUS
RawChannelIWrite(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
RawChannelIRead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount   
    );

NTSTATUS
RawChannelEcho(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
RawChannelIBufferIsFull(
    IN  PSAC_CHANNEL    Channel,
    OUT BOOLEAN*        BufferStatus
    );

ULONG
RawChannelIBufferLength(
    IN PSAC_CHANNEL Channel
    );

WCHAR
RawChannelIReadLast(
    IN PSAC_CHANNEL Channel
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\util.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Utility routines for sac driver

Author:

    Andrew Ritz (andrewr) - 15 June, 2000

Revision History:

    added new utils: Brian Guarraci (briangu) - 2001

--*/

#include "sac.h"
#include <guiddef.h>
      
VOID
AppendMessage(
    PWSTR       OutPutBuffer,
    ULONG       MessageId,
    PWSTR       ValueBuffer OPTIONAL
    );

NTSTATUS
InsertRegistrySzIntoMachineInfoBuffer(
    PWSTR       KeyName,
    PWSTR       ValueName,
    ULONG       MessageId
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, PreloadGlobalMessageTable )
#pragma alloc_text( INIT, AppendMessage )
#pragma alloc_text( INIT, InsertRegistrySzIntoMachineInfoBuffer )
#pragma alloc_text( INIT, InitializeMachineInformation )
#endif

//
// (see comments in sac.h)
//
PUCHAR  Utf8ConversionBuffer;
ULONG   Utf8ConversionBufferSize = MEMORY_INCREMENT;
WCHAR   IncomingUnicodeValue;
UCHAR   IncomingUtf8ConversionBuffer[3];

//
// Message Table routines.  We load all of our message table entries into a 
// global non-paged structure so that we can send text to HeadlessDispatch at
// any time.
//

typedef struct _MESSAGE_TABLE_ENTRY {
    ULONG             MessageId;
    PCWSTR             MessageText;
} MESSAGE_TABLE_ENTRY, *PMESSAGE_TABLE_ENTRY;

PMESSAGE_TABLE_ENTRY GlobalMessageTable;
ULONG          GlobalMessageTableCount;

#define MESSAGE_INITIAL 1
#define MESSAGE_FINAL 200

//
// Prototypes
//
extern
BOOLEAN
ExVerifySuite(
    SUITE_TYPE SuiteType
    );

ULONG
ConvertAnsiToUnicode(
    OUT PWSTR   pwch,
    IN  PSTR    pch,
    IN  ULONG   cchMax
    )
/*++

Routine Description:

    Convert an ansi character string into unicode.
    
Arguments:

    pwch    - the unicode string
    pch     - the ansi string
    cchMax  - the max length to copy (including null termination)      

Return Value:

    # of characters converted (not including null termination)

--*/
{
    ULONG   Count;

    ASSERT_STATUS(pch, 0);
    ASSERT_STATUS(pwch, 0);

    Count = 0;

    while ((*pch != '\0') && (Count < (cchMax-1))) {
    
        *pwch = (WCHAR)(*pch);
        pwch++;
        pch++;

        Count++;
    }

    *pwch = UNICODE_NULL;

    return Count;
}
            
NTSTATUS
RegisterSacCmdEvent(
    IN PFILE_OBJECT             FileObject,
    IN PSAC_CMD_SETUP_CMD_EVENT SetupCmdEvent
    )
/*++

Routine Description:

    This routine populates the sac cmd event info specified by
    the user-mode service responsible for responding to requests
    to launch a command console session.
    
Arguments:

    FileObject      - the FileObject ptr for the driver handle object
                      used by the registering process
    SetupCmdEvent   - the event info                
                    
Return Value:

    Status       

Security:

    Interface:
    
        external --> internal
    
    this routine does not prevent reregistration of the cmd event info
    this behavior should be handled by the caller
           
--*/
{
    NTSTATUS    Status;
    BOOLEAN     b;

    ASSERT_STATUS(SetupCmdEvent, STATUS_INVALID_PARAMETER_1);

    //
    // Protect the SAC Cmd Event Info
    //
    KeWaitForMutexObject(
        &SACCmdEventInfoMutex, 
        Executive,
        KernelMode,
        FALSE,
        NULL
        );
    
    do {

        //
        // make sure there isn't a service already regiseterd
        //
        if (UserModeServiceHasRegisteredCmdEvent()) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // Reset our info to the initial condition
        //
        // Note: this cleans up the cmd event info if present
        //
        InitializeCmdEventInfo();
        

#if ENABLE_SERVICE_FILE_OBJECT_CHECKING
        //
        // get a reference to the registering process's driver handle
        // file object so we can make sure that an unregister IOCTL
        // comes from the same process.
        //
        Status = ObReferenceObjectByPointer(
            FileObject,
            GENERIC_READ,
            *IoFileObjectType,
            KernelMode
            );

        if (!NT_SUCCESS(Status)) {
            break;
        }
        
        ServiceProcessFileObject = FileObject;
#else
        UNREFERENCED_PARAMETER(FileObject);
#endif
        
        //
        // test and aqcuire the RequestSacCmdEvent event handle
        //
        b = VerifyEventWaitable(
            SetupCmdEvent->RequestSacCmdEvent,
            &RequestSacCmdEventObjectBody,
            &RequestSacCmdEventWaitObjectBody
            );

        if(!b) {
            Status = STATUS_INVALID_HANDLE;
            break;
        }

        //
        // test and aqcuire the RequestSacCmdSuccessEvent event handle
        //
        b = VerifyEventWaitable(
            SetupCmdEvent->RequestSacCmdSuccessEvent,
            &RequestSacCmdSuccessEventObjectBody,
            &RequestSacCmdSuccessEventWaitObjectBody
            );

        if(!b) {
            Status = STATUS_INVALID_HANDLE;
            ObDereferenceObject(RequestSacCmdEventObjectBody);
            break;
        }

        //
        // test and aqcuire the RequestSacCmdFailureEvent event handle
        //
        b = VerifyEventWaitable(
            SetupCmdEvent->RequestSacCmdFailureEvent,
            &RequestSacCmdFailureEventObjectBody,
            &RequestSacCmdFailureEventWaitObjectBody
            );

        if(!b) {
            Status = STATUS_INVALID_HANDLE;
            ObDereferenceObject(RequestSacCmdEventObjectBody);
            ObDereferenceObject(RequestSacCmdSuccessEventWaitObjectBody);
            break;
        }

        //
        // declare that we indeed have the user-mode service info
        //
        HaveUserModeServiceCmdEventInfo = TRUE;

        //
        // We have successfully registered teh SAC Cmd Event Info
        //
        Status = STATUS_SUCCESS;
    
    } while (FALSE);

    KeReleaseMutex(&SACCmdEventInfoMutex, FALSE);

    return Status;
}

#if ENABLE_SERVICE_FILE_OBJECT_CHECKING

BOOLEAN
IsCmdEventRegistrationProcess(
    IN PFILE_OBJECT     FileObject
    )
/*++

Routine Description:

    This routine purges the previously registered sac cmd event info.
    
    Note: This should be called when the user-mode service shuts down.

Arguments:

    FileObject      - the FileObject ptr for the driver handle object
                      used by the registering process
    
Return Value:

    Status    
        
--*/
{
    BOOLEAN bIsRegistrationProcess;
    
    //
    // Default
    //
    bIsRegistrationProcess = FALSE;

    //
    // Protect the SAC Cmd Event Info
    //
    KeWaitForMutexObject(
        &SACCmdEventInfoMutex, 
        Executive,
        KernelMode,
        FALSE,
        NULL
        );
    
    do {
        
        //
        // exit if there is no service registered
        //
        if (! UserModeServiceHasRegisteredCmdEvent()) {
            break;
        }

        //
        // make sure the calling process is the same
        // that registered
        //
        if (FileObject == ServiceProcessFileObject) {
            bIsRegistrationProcess = TRUE;
            break;
        }

    } while (FALSE);

    KeReleaseMutex(&SACCmdEventInfoMutex, FALSE);

    return bIsRegistrationProcess;
}

#endif

NTSTATUS
UnregisterSacCmdEvent(
    IN PFILE_OBJECT     FileObject
    )
/*++

Routine Description:

    This routine purges the previously registered sac cmd event info.
    
    Note: This should be called when the user-mode service shuts down.

Arguments:
    
    FileObject      - the FileObject ptr for the driver handle object
                      used by the registering process

Return Value:

    Status    
        
--*/
{
    NTSTATUS    Status;

    //
    // Protect the SAC Cmd Event Info
    //
    KeWaitForMutexObject(
        &SACCmdEventInfoMutex, 
        Executive,
        KernelMode,
        FALSE,
        NULL
        );
    
    do {
        
        //
        // exit if there is no service registered
        //
        if (! UserModeServiceHasRegisteredCmdEvent()) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

#if ENABLE_SERVICE_FILE_OBJECT_CHECKING

        //
        // make sure the calling process is the same
        // that registered
        //
        if (FileObject != ServiceProcessFileObject) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // since we are unregistering, 
        // we no longer need to hold a reference to 
        // the driver handle object
        //
        ObDereferenceObject(FileObject);

#else
        UNREFERENCED_PARAMETER(FileObject);
#endif
        
        //
        // Reset our info to the initial condition
        //
        InitializeCmdEventInfo();

        Status = STATUS_SUCCESS;
        
    } while (FALSE);

    KeReleaseMutex(&SACCmdEventInfoMutex, FALSE);

    return Status;
}

VOID
InitializeCmdEventInfo(
    VOID
    )
/*++

Routine Description:

    Initialize the Cmd Console Event Information.  
    
Arguments:

    NONE

Return Value:

    NONE

--*/
{
    
    //
    // Dereference the wait objects if we have them
    //
    if (HaveUserModeServiceCmdEventInfo) {
        
        ASSERT(RequestSacCmdEventObjectBody);
        ASSERT(RequestSacCmdSuccessEventObjectBody);
        ASSERT(RequestSacCmdFailureEventObjectBody);

        if (RequestSacCmdEventObjectBody) {
            ObDereferenceObject(RequestSacCmdEventObjectBody);
        }
        
        if (RequestSacCmdSuccessEventObjectBody) {
            ObDereferenceObject(RequestSacCmdSuccessEventObjectBody);
        }
        
        if (RequestSacCmdFailureEventObjectBody) {
            ObDereferenceObject(RequestSacCmdFailureEventObjectBody);
        }
    }
    
    //
    // reset the cmd console event information
    //
    RequestSacCmdEventObjectBody = NULL;
    RequestSacCmdEventWaitObjectBody = NULL;
    RequestSacCmdSuccessEventObjectBody = NULL;
    RequestSacCmdSuccessEventWaitObjectBody = NULL;
    RequestSacCmdFailureEventObjectBody = NULL;
    RequestSacCmdFailureEventWaitObjectBody = NULL;
    
#if ENABLE_SERVICE_FILE_OBJECT_CHECKING
    //
    // reset the process file object ptr
    //
    ServiceProcessFileObject = NULL;
#endif

    //
    // declare that we do NOT have the user-mode service info
    //
    HaveUserModeServiceCmdEventInfo = FALSE;
}

BOOLEAN
VerifyEventWaitable(
    IN  HANDLE  hEvent,
    OUT PVOID  *EventObjectBody,
    OUT PVOID  *EventWaitObjectBody
    )
/*++

Routine Description:

    This routine extracts the waitable object from the 
    specified event object.  It also verifies that there
    is a waitable object present.
    
    Note: if successful, this routine returns with the
          reference count incremented on the event object.
          The caller is responsible for releasing this
          object.                                              
                                              
Arguments:

    hEvent              - The handle to the event object
    EventObjectBody     - The event object
    EventWaitObjectBody - The waitiable object
    
Return Value:

    TRUE    - event is waitable
    FALSE   - otherwise

Security:

    This routine operates on event objects referred by event handles from
    usermode.

--*/
{
    POBJECT_HEADER ObjectHeader;
    NTSTATUS Status;

    //
    // Reference the event and verify that it is waitable.
    //
    Status = ObReferenceObjectByHandle(
                hEvent,
                EVENT_ALL_ACCESS,
                NULL,
                KernelMode,
                EventObjectBody,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC VerifyEventWaitable: Unable to reference event object (%lx)\n",Status))
            );
        return(FALSE);
    }

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(*EventObjectBody);
    if(!ObjectHeader->Type->TypeInfo.UseDefaultObject) {

        *EventWaitObjectBody = (PVOID)((PCHAR)(*EventObjectBody) +
                              (ULONG_PTR)ObjectHeader->Type->DefaultObject);

    } else {
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC VerifyEventWaitable: event object not waitable!\n"))
            );
        ObDereferenceObject(*EventObjectBody);
        return(FALSE);
    }

    return(TRUE);
}

NTSTATUS
InvokeUserModeService(
    VOID
    )
/*++

Routine Description:

    This routine manages the interaction with the user-mode service responsible
    for launching the cmd console channel.
    
Arguments:

    None

Return Value:

    STATUS_SUCCESS  - if cmd console was successfully launched by user-mode service
    
    otherwise, error status

--*/
{
    NTSTATUS        Status;
    LARGE_INTEGER   TimeOut;
    HANDLE          EventArray[ 2 ];

    //
    // setup the event array
    //
    enum { 
        SAC_CMD_LAUNCH_SUCCESS = 0,
        SAC_CMD_LAUNCH_FAILURE
        };
    
    ASSERT_STATUS(RequestSacCmdEventObjectBody != NULL, STATUS_INVALID_HANDLE);
    ASSERT_STATUS(RequestSacCmdSuccessEventWaitObjectBody != NULL, STATUS_INVALID_HANDLE);
    ASSERT_STATUS(RequestSacCmdFailureEventWaitObjectBody != NULL, STATUS_INVALID_HANDLE);

#if ENABLE_CMD_SESSION_PERMISSION_CHECKING

    //
    // If we are not able to launch cmd sessions,
    // then return status unsuccessful.
    //
    if (! IsCommandConsoleLaunchingEnabled()) {
        return STATUS_UNSUCCESSFUL;
    }
    
#endif

    //
    // Since we don't know if the user-mode app will serice our request properly
    // we have to timeout on the Serviced event.
    //
    TimeOut.QuadPart = Int32x32To64((LONG)90000, -1000);

    //
    // Populate the event array with events we want to catch from user-mode
    //
    EventArray[ 0 ] = RequestSacCmdSuccessEventWaitObjectBody;
    EventArray[ 1 ] = RequestSacCmdFailureEventWaitObjectBody;

    //
    // Set the event indicating that the communication buffer is
    // ready for the user-mode process. Because this is a synchronization
    // event, it automatically resets after releasing the waiting
    // user-mode thread.  Note that we specify WaitNext to prevent the
    // race condition between setting this synchronization event and
    // waiting on the next one.
    //
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InvokeUserModeService: Sending Notification Event\n")));
    
    KeSetEvent(RequestSacCmdEventObjectBody,EVENT_INCREMENT,TRUE);

    //
    // Wait for the user-mode process to indicate that it is done
    // processing the request.  We wait in user mode so that we can be 
    // interrupted if necessary -- say, by an exit APC.
    //
    
    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC InvokeUserModeService: Waiting for Serviced Event.\n"))
        );
    
    Status = KeWaitForMultipleObjects ( 
        sizeof(EventArray)/sizeof(HANDLE), 
        EventArray,
        WaitAny,
        Executive,
        UserMode,
        FALSE, 
        &TimeOut,
        NULL
        );
    
    switch (Status)
    {
    case SAC_CMD_LAUNCH_SUCCESS:
        Status = STATUS_SUCCESS;
        break;
    
    case SAC_CMD_LAUNCH_FAILURE:
        Status = STATUS_UNSUCCESSFUL;
        break;
    
    case STATUS_TIMEOUT:
        
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC InvokeUserModeService: KeWaitForMultipleObject timed-out %lx\n",Status))
            );
        
        //
        // We don't want to "reset" the cmd console event info
        // if the service times out for the following reason:
        //
        //    The service may still be functional, but just unable
        //    to respond because of machine load.  We don't want
        //    to remove it's registration and have it think it's
        //    still registered, making the service useless.
        //
        NOTHING;

        break;
    
    default:
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC InvokeUserModeService: KeWaitForMultipleObject returns %lx\n",Status))
            );
        
        Status = STATUS_UNSUCCESSFUL;

        break;
    }

    //
    // Return the status
    //
    return(Status);
}

VOID
SacFormatMessage(
    PWSTR       OutputString,
    PWSTR       InputString,
    ULONG       InputStringLength
    )
/*++

Routine Description:

    This routine parses the InputString for any control characters in the
    message, then converts those control characters.
    
Arguments:

    OutputString      - holds formatted string.

    InputString       - original unformatted string.

    InputStringLength - length of unformatted string.


Return Value:

    NONE

--*/
{

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC SacFormatMessage: Entering.\n")));


    if( (InputString == NULL) ||
        (OutputString == NULL) ||
        (InputStringLength == 0) ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC SacFormatMessage: Exiting with invalid parameters.\n")));

        return;
    }



    while( (*InputString != L'\0') &&
           (InputStringLength) ) {
        if( *InputString == L'%' ) {
            
            //
            // Possibly a control sequence.
            //
            if( *(InputString+1) == L'0' ) {

                *OutputString = L'\0';
                OutputString++;
                goto SacFormatMessage_Done;

            } else if( *(InputString+1) == L'%' ) {

                *OutputString = L'%';
                OutputString++;
                InputString += 2;

            } else if( *(InputString+1) == L'\\' ) {

                *OutputString = L'\r';
                OutputString++;
                *OutputString = L'\n';
                OutputString++;
                InputString += 2;

            } else if( *(InputString+1) == L'r' ) {

                *OutputString = L'\r';
                InputString += 2;
                OutputString++;

            } else if( *(InputString+1) == L'b' ) {

                *OutputString = L' ';
                InputString += 2;
                OutputString++;

            } else if( *(InputString+1) == L'.' ) {

                *OutputString = L'.';
                InputString += 2;
                OutputString++;

            } else if( *(InputString+1) == L'!' ) {

                *OutputString = L'!';
                InputString += 2;
                OutputString++;

            } else {

                //
                // Don't know what this is.  eat the '%' character.
                //
                InputString += 1;
            }
    
        } else {

            *OutputString++ = *InputString++;
        }

        InputStringLength--;

    }


    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC SacFormatMessage: Exiting.\n")));

SacFormatMessage_Done:

    return;
}


NTSTATUS
PreloadGlobalMessageTable(
    PVOID ImageBase
    )
/*++

Routine Description:

    This routine loads all of our message table entries into a global
    structure and 
    
Arguments:

    ImageBase - pointer to image base for locating resources

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    ULONG Count,EntryCount;
    SIZE_T TotalSizeInBytes = 0;
    NTSTATUS Status;
    PMESSAGE_RESOURCE_ENTRY messageEntry;
    PWSTR pStringBuffer;
    
    PAGED_CODE( );

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PreloadGlobalMessageTable: Entering.\n")));


    // 
    // if it already exists, then just return success
    //
    if (GlobalMessageTable != NULL) {
        Status = STATUS_SUCCESS;
        goto exit;
    }

    ASSERT( MESSAGE_FINAL > MESSAGE_INITIAL );

    //
    // get the total required size for the table.
    //
    for (Count = MESSAGE_INITIAL; Count != MESSAGE_FINAL ; Count++) {
        
        Status = RtlFindMessage(ImageBase,
                                11, // RT_MESSAGETABLE
                                LANG_NEUTRAL,
                                Count,
                                &messageEntry
                               );

        if (NT_SUCCESS(Status)) {
            //
            // add it on to our total size.
            //
            // the messageEntry size contains the structure size + the size of the text.
            //
            ASSERT(messageEntry->Flags & MESSAGE_RESOURCE_UNICODE);
            TotalSizeInBytes += sizeof(MESSAGE_TABLE_ENTRY) + 
                                (messageEntry->Length - FIELD_OFFSET(MESSAGE_RESOURCE_ENTRY, Text));
            GlobalMessageTableCount +=1;        
        }
            
    }


    if (TotalSizeInBytes == 0) {
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS,
            KdPrint(("SAC PreloadGlobalMessageTable: No Messages.\n")));
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Allocate space for the table.
    //
    GlobalMessageTable = (PMESSAGE_TABLE_ENTRY) ALLOCATE_POOL( TotalSizeInBytes, GENERAL_POOL_TAG);
    if (!GlobalMessageTable) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }

    //
    // go through again, this time filling out the table with actual data
    //
    pStringBuffer = (PWSTR)((ULONG_PTR)GlobalMessageTable + 
                        (ULONG_PTR)(sizeof(MESSAGE_TABLE_ENTRY)*GlobalMessageTableCount));
    EntryCount = 0;
    for (Count = MESSAGE_INITIAL ; Count != MESSAGE_FINAL ; Count++) {
        Status = RtlFindMessage(ImageBase,
                                11, // RT_MESSAGETABLE
                                LANG_NEUTRAL,
                                Count,
                                &messageEntry
                               );

        if (NT_SUCCESS(Status)) {
            ULONG TextSize = messageEntry->Length - FIELD_OFFSET(MESSAGE_RESOURCE_ENTRY, Text);
            GlobalMessageTable[EntryCount].MessageId = Count;
            GlobalMessageTable[EntryCount].MessageText = pStringBuffer;

            //
            // Send the message through our Formatting filter as it passes
            // into our global message structure.
            //
            SacFormatMessage( pStringBuffer, (PWSTR)messageEntry->Text, TextSize );

            ASSERT( (ULONG)(wcslen(pStringBuffer)*sizeof(WCHAR)) <= TextSize );

            pStringBuffer = (PWSTR)((ULONG_PTR)pStringBuffer + (ULONG_PTR)(TextSize));
            EntryCount += 1;
        }
    }

    Status = STATUS_SUCCESS;
                    
exit:
    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC PreloadGlobalMessageTable: Exiting with status 0x%0x.\n",
                Status)));

    return(Status);

}

NTSTATUS
TearDownGlobalMessageTable(
    VOID
    ) 
{
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PreloadGlobalMessageTable: Entering.\n")));
    
    SAFE_FREE_POOL( &GlobalMessageTable );

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC TearDownGlobalMessageTable: Exiting\n")));

    return(STATUS_SUCCESS);
}

PCWSTR
GetMessage(
    ULONG MessageId
    )
{
    PMESSAGE_TABLE_ENTRY pMessageTable;
    ULONG Count;
    
    if (!GlobalMessageTable) {
        return(NULL);
    }

    for (Count = 0; Count < GlobalMessageTableCount; Count++) {
        pMessageTable = &GlobalMessageTable[Count];
        if (pMessageTable->MessageId == MessageId) {
            return(pMessageTable->MessageText);
        }
    }

    ASSERT( FALSE );
    return(NULL);

}

NTSTATUS
UTF8EncodeAndSend(
    PCWSTR  OutputBuffer
    )
/*++

Routine Description:

    This is a convenience routine to simplify
    UFT8 encoding and sending a Unicode string.

Arguments:

    OutputBuffer    - the string to send

Return Value:

    Status

--*/
{
    NTSTATUS    Status;
    BOOLEAN     bStatus;
    ULONG       i;
    ULONG       TranslatedCount;
    ULONG       UTF8TranslationSize;

    Status = STATUS_SUCCESS;

    do {

        //
        // Display the output buffer
        //
        bStatus = SacTranslateUnicodeToUtf8(
            OutputBuffer,
            (ULONG)wcslen(OutputBuffer),
            (PUCHAR)Utf8ConversionBuffer,
            Utf8ConversionBufferSize,
            &UTF8TranslationSize,
            &TranslatedCount
            );
        
        if (! bStatus) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // Iterate through the uft8 buffer since
        // we can't be sure headless dispatch can
        // handle our entire string.
        //
        for (i = 0; i < UTF8TranslationSize; i ++) {

            Status = HeadlessDispatch(
                HeadlessCmdPutData,
                (PUCHAR)&(Utf8ConversionBuffer[i]),
                sizeof(UCHAR),
                NULL,
                NULL
                );
            if (! NT_SUCCESS(Status)) {
                break;
            }

        }
    
    } while ( FALSE );

    return Status;
}

BOOLEAN
SacTranslateUtf8ToUnicode(
    UCHAR  IncomingByte,
    UCHAR  *ExistingUtf8Buffer,
    WCHAR  *DestinationUnicodeVal
    )
/*++

Routine Description:

    Takes IncomingByte and concatenates it onto ExistingUtf8Buffer.
    Then attempts to decode the new contents of ExistingUtf8Buffer.

Arguments:

    IncomingByte -          New character to be appended onto
                            ExistingUtf8Buffer.


    ExistingUtf8Buffer -    running buffer containing incomplete UTF8
                            encoded unicode value.  When it gets full,
                            we'll decode the value and return the
                            corresponding Unicode value.

                            Note that if we *do* detect a completed UTF8
                            buffer and actually do a decode and return a
                            Unicode value, then we will zero-fill the
                            contents of ExistingUtf8Buffer.


    DestinationUnicodeVal - receives Unicode version of the UTF8 buffer.

                            Note that if we do *not* detect a completed
                            UTF8 buffer and thus can not return any data
                            in DestinationUnicodeValue, then we will
                            zero-fill the contents of DestinationUnicodeVal.


Return Value:

    TRUE - We received a terminating character for our UTF8 buffer and will
           return a decoded Unicode value in DestinationUnicode.

    FALSE - We haven't yet received a terminating character for our UTF8
            buffer.

--*/

{
//    ULONG Count = 0;
    ULONG i = 0;
    BOOLEAN ReturnValue = FALSE;



    //
    // Insert our byte into ExistingUtf8Buffer.
    //
    i = 0;
    do {
        if( ExistingUtf8Buffer[i] == 0 ) {
            ExistingUtf8Buffer[i] = IncomingByte;
            break;
        }

        i++;
    } while( i < 3 );

    //
    // If we didn't get to actually insert our IncomingByte,
    // then someone sent us a fully-qualified UTF8 buffer.
    // This means we're about to drop IncomingByte.
    //
    // Drop the zero-th byte, shift everything over by one
    // and insert our new character.
    //
    // This implies that we should *never* need to zero out
    // the contents of ExistingUtf8Buffer unless we detect
    // a completed UTF8 packet.  Otherwise, assume one of
    // these cases:
    // 1. We started listening mid-stream, so we caught the
    //    last half of a UTF8 packet.  In this case, we'll
    //    end up shifting the contents of ExistingUtf8Buffer
    //    until we detect a proper UTF8 start byte in the zero-th
    //    position.
    // 2. We got some garbage character, which would invalidate
    //    a UTF8 packet.  By using the logic below, we would
    //    end up disregarding that packet and waiting for
    //    the next UTF8 packet to come in.
    if( i >= 3 ) {
        ExistingUtf8Buffer[0] = ExistingUtf8Buffer[1];
        ExistingUtf8Buffer[1] = ExistingUtf8Buffer[2];
        ExistingUtf8Buffer[2] = IncomingByte;
    }

    //
    // Attempt to convert the UTF8 buffer
    //
    // UTF8 decodes to Unicode in the following fashion:
    // If the high-order bit is 0 in the first byte:
    //      0xxxxxxx yyyyyyyy zzzzzzzz decodes to a Unicode value of 00000000 0xxxxxxx
    //
    // If the high-order 3 bits in the first byte == 6:
    //      110xxxxx 10yyyyyy zzzzzzzz decodes to a Unicode value of 00000xxx xxyyyyyy
    //
    // If the high-order 3 bits in the first byte == 7:
    //      1110xxxx 10yyyyyy 10zzzzzz decodes to a Unicode value of xxxxyyyy yyzzzzzz
    //
    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SACDRV: SacTranslateUtf8ToUnicode - About to decode the UTF8 buffer.\n" ))
        );

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("                                  UTF8[0]: 0x%02lx UTF8[1]: 0x%02lx UTF8[2]: 0x%02lx\n",
            ExistingUtf8Buffer[0],
            ExistingUtf8Buffer[1],
            ExistingUtf8Buffer[2] ))
        );
    

    if( (ExistingUtf8Buffer[0] & 0x80) == 0 ) {

        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SACDRV: SacTranslateUtf8ToUnicode - Case1\n" ))
            );

        //
        // First case described above.  Just return the first byte
        // of our UTF8 buffer.
        //
        *DestinationUnicodeVal = (WCHAR)(ExistingUtf8Buffer[0]);


        //
        // We used 1 byte.  Discard that byte and shift everything
        // in our buffer over by 1.
        //
        ExistingUtf8Buffer[0] = ExistingUtf8Buffer[1];
        ExistingUtf8Buffer[1] = ExistingUtf8Buffer[2];
        ExistingUtf8Buffer[2] = 0;

        ReturnValue = TRUE;

    } else if( (ExistingUtf8Buffer[0] & 0xE0) == 0xC0 ) {

        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SACDRV: SacTranslateUtf8ToUnicode - 1st byte of UTF8 buffer says Case2\n"))
            );

        //
        // Second case described above.  Decode the first 2 bytes of
        // of our UTF8 buffer.
        //
        if( (ExistingUtf8Buffer[1] & 0xC0) == 0x80 ) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SACDRV: SacTranslateUtf8ToUnicode - 2nd byte of UTF8 buffer says Case2.\n"))
                );

            // upper byte: 00000xxx
            *DestinationUnicodeVal = ((ExistingUtf8Buffer[0] >> 2) & 0x07);
            *DestinationUnicodeVal = *DestinationUnicodeVal << 8;

            // high bits of lower byte: xx000000
            *DestinationUnicodeVal |= ((ExistingUtf8Buffer[0] & 0x03) << 6);

            // low bits of lower byte: 00yyyyyy
            *DestinationUnicodeVal |= (ExistingUtf8Buffer[1] & 0x3F);


            //
            // We used 2 bytes.  Discard those bytes and shift everything
            // in our buffer over by 2.
            //
            ExistingUtf8Buffer[0] = ExistingUtf8Buffer[2];
            ExistingUtf8Buffer[1] = 0;
            ExistingUtf8Buffer[2] = 0;

            ReturnValue = TRUE;

        }
    } else if( (ExistingUtf8Buffer[0] & 0xF0) == 0xE0 ) {

        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SACDRV: SacTranslateUtf8ToUnicode - 1st byte of UTF8 buffer says Case3\n" ))
            );

        //
        // Third case described above.  Decode the all 3 bytes of
        // of our UTF8 buffer.
        //

        if( (ExistingUtf8Buffer[1] & 0xC0) == 0x80 ) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SACDRV: SacTranslateUtf8ToUnicode - 2nd byte of UTF8 buffer says Case3\n" ))
                );

            if( (ExistingUtf8Buffer[2] & 0xC0) == 0x80 ) {

                IF_SAC_DEBUG(
                    SAC_DEBUG_FUNC_TRACE, 
                    KdPrint(("SACDRV: SacTranslateUtf8ToUnicode - 3rd byte of UTF8 buffer says Case3\n" ))
                    );

                // upper byte: xxxx0000
                *DestinationUnicodeVal = ((ExistingUtf8Buffer[0] << 4) & 0xF0);

                // upper byte: 0000yyyy
                *DestinationUnicodeVal |= ((ExistingUtf8Buffer[1] >> 2) & 0x0F);

                *DestinationUnicodeVal = *DestinationUnicodeVal << 8;

                // lower byte: yy000000
                *DestinationUnicodeVal |= ((ExistingUtf8Buffer[1] << 6) & 0xC0);

                // lower byte: 00zzzzzz
                *DestinationUnicodeVal |= (ExistingUtf8Buffer[2] & 0x3F);

                //
                // We used all 3 bytes.  Zero out the buffer.
                //
                ExistingUtf8Buffer[0] = 0;
                ExistingUtf8Buffer[1] = 0;
                ExistingUtf8Buffer[2] = 0;

                ReturnValue = TRUE;

            }
        }
    }

    return ReturnValue;
}

BOOLEAN
SacTranslateUnicodeToUtf8(
    IN  PCWSTR   SourceBuffer,
    IN  ULONG    SourceBufferLength,
    IN  PUCHAR   DestinationBuffer,
    IN  ULONG    DestinationBufferSize,
    OUT PULONG   UTF8Count,
    OUT PULONG   ProcessedCount
    )
/*++

Routine Description:

    This routine translates a Unicode string into a UFT8
    encoded string.

    Note: if the destination buffer is not large enough to hold
          the entire encoded UFT8 string, then it will contain
          as much as can fit.
          
    TODO: this routine should return some notification if
          the entire Unicode string was not encoded.       
              
Arguments:

    SourceBuffer            - the source Unicode string
    SourceBufferLength      - the # of characters the caller wants to translate
                              note: a NULL termination overrides this 
    DestinationBuffer       - the destination for the UTF8 string
    DestinationBufferSize   - the size of the destination buffer                 
    UTF8Count               - on exit, contains the # of resulting UTF8 characters
    ProcessedCount          - on exit, contains the # of processed Unicode characters
                   
Return Value:

    Status

--*/
{
    
    //
    // Init
    //
    *UTF8Count = 0;
    *ProcessedCount = 0;

    //
    // convert into UTF8 for actual transmission
    //
    // UTF-8 encodes 2-byte Unicode characters as follows:
    // If the first nine bits are zero (00000000 0xxxxxxx), encode it as one byte 0xxxxxxx
    // If the first five bits are zero (00000yyy yyxxxxxx), encode it as two bytes 110yyyyy 10xxxxxx
    // Otherwise (zzzzyyyy yyxxxxxx), encode it as three bytes 1110zzzz 10yyyyyy 10xxxxxx
    //
    
    //
    // Process until one of the specified conditions is met
    //
    while (*SourceBuffer && 
           (*UTF8Count < DestinationBufferSize) &&
           (*ProcessedCount < SourceBufferLength)
           ) {

        if( (*SourceBuffer & 0xFF80) == 0 ) {
            
            //
            // if the top 9 bits are zero, then just
            // encode as 1 byte.  (ASCII passes through unchanged).
            //
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)(*SourceBuffer & 0x7F);
        
        } else if( (*SourceBuffer & 0xF800) == 0 ) {
            
            //
            // see if we pass the end of the buffer
            //
            if ((*UTF8Count + 2) >= DestinationBufferSize) {
                break;
            }

            //
            // if the top 5 bits are zero, then encode as 2 bytes
            //
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)((*SourceBuffer >> 6) & 0x1F) | 0xC0;
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)(*SourceBuffer & 0xBF) | 0x80;
        
        } else {
            
            //
            // see if we pass the end of the buffer
            //
            if ((*UTF8Count + 3) >= DestinationBufferSize) {
                break;
            }
            
            //
            // encode as 3 bytes
            //
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)((*SourceBuffer >> 12) & 0xF) | 0xE0;
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)((*SourceBuffer >> 6) & 0x3F) | 0x80;
            DestinationBuffer[(*UTF8Count)++] = (UCHAR)(*SourceBuffer & 0xBF) | 0x80;
        
        }
        
        //
        // Advance the # of characters processed
        //
        (*ProcessedCount)++;
        
        //
        // Advanced to the next character to process
        //
        SourceBuffer += 1;
    
    }

    //
    // Sanity checks
    //
    ASSERT(*ProcessedCount <= SourceBufferLength);
    ASSERT(*UTF8Count <= DestinationBufferSize);

    return(TRUE);

}

VOID
AppendMessage(
    PWSTR       OutPutBuffer,
    ULONG       MessageId,
    PWSTR       ValueBuffer OPTIONAL
    )
/*++

Routine Description:

    This function will insert the valuestring into the specified message, then
    concatenate the resulting string onto the OutPutBuffer.

Arguments:
    
    OutPutBuffer    The resulting String.

    MessageId       ID of the formatting message to use.

    ValueBUffer     Value string to be inserted into the message.

Return Value:

    NONE

--*/
{
    PWSTR       MyTemporaryBuffer = NULL;
    PCWSTR      p;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC AppendMessage: Entering.\n")));

    p = GetMessage(MessageId);

    if( p == NULL ) {
        return;
    }

    if( ValueBuffer == NULL ) {

        wcscat( OutPutBuffer, p );

    } else {

        MyTemporaryBuffer = (PWSTR)(wcschr(OutPutBuffer, L'\0'));
        if( MyTemporaryBuffer == NULL ) {
            MyTemporaryBuffer = OutPutBuffer;
        }

        swprintf( MyTemporaryBuffer, p, ValueBuffer );
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC AppendMessage: Entering.\n")));

    return;
}


NTSTATUS
GetRegistryValueBuffer(
    PWSTR       KeyName,
    PWSTR       ValueName,
    PKEY_VALUE_PARTIAL_INFORMATION* ValueBuffer
    )
/*++

Routine Description:

    This function will go query the registry and pull the specified Value.

Arguments:
    
    KeyName         Name of the registry key we'll be querying.

    ValueName       Name of the registry value we'll be querying.

    ValueBuffer     On success, contains value 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               KeyValueLength;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeString;
    HANDLE              KeyHandle;

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC GetRegistryValueBuffer: Entering.\n"))
        );

    ASSERT_STATUS(KeyName, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(ValueName, STATUS_INVALID_PARAMETER_2);
    
    do {

        //
        // Get the reg key handle
        //
        INIT_OBJA( &Obja, &UnicodeString, KeyName );

        Status = ZwOpenKey( 
            &KeyHandle,
            KEY_READ,
            &Obja 
            );

        if( !NT_SUCCESS(Status) ) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SAC GetRegistryValueBuffer: failed ZwOpenKey: %X\n", Status))
                );

            return Status;

        }

        //
        // Get the value buffer size
        //
        RtlInitUnicodeString( &UnicodeString, ValueName );
        
        KeyValueLength = 0;
        
        Status = ZwQueryValueKey( 
            KeyHandle,
            &UnicodeString,
            KeyValuePartialInformation,
            (PVOID)NULL,
            0,
            &KeyValueLength 
            );

        if( KeyValueLength == 0 ) {
            
            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SAC GetRegistryValueBuffer: failed ZwQueryValueKey: %X\n", Status))
                );
            
            break;
        }

        //
        // Allocate the value buffer
        //
        KeyValueLength += 4;

        *ValueBuffer = (PKEY_VALUE_PARTIAL_INFORMATION)ALLOCATE_POOL( KeyValueLength, GENERAL_POOL_TAG );

        if( *ValueBuffer == NULL ) {
            
            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SAC GetRegistryValueBuffer: failed allocation\n"))
                );
            
            break;
        }

        //
        // Get the value
        //
        Status = ZwQueryValueKey( 
            KeyHandle,
            &UnicodeString,
            KeyValuePartialInformation,
            *ValueBuffer,
            KeyValueLength,
            &KeyValueLength 
            );

        if( !NT_SUCCESS(Status) ) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SAC GetRegistryValueBuffer: failed ZwQueryValueKey: %X\n", Status))
                );

            FREE_POOL( ValueBuffer );
            
            break;
        
        }
    
    } while ( FALSE );

    //
    // We are done with the reg key
    //
    NtClose(KeyHandle);

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC GetRegistryValueBuffer: Exiting.\n"))
        );

    return Status;

}

NTSTATUS
SetRegistryValue(
    IN PWSTR    KeyName,
    IN PWSTR    ValueName,
    IN ULONG    Type,
    IN PVOID    Data,
    IN ULONG    DataSize
    )
/*++

Routine Description:

    This function will set the specified registry key value.

Arguments:
    
    KeyName         Name of the registry key we'll be querying.
    ValueName       Name of the registry value we'll be querying.
    Type            Registry value type
    Data            New value data
    DataSize        Size of the new value data

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeString;
    HANDLE              KeyHandle;

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC SetRegistryValue: Entering.\n"))
        );

    ASSERT_STATUS(KeyName, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(ValueName, STATUS_INVALID_PARAMETER_2);
    ASSERT_STATUS(Data, STATUS_INVALID_PARAMETER_4);

    do {

        //
        // Get the reg key handle
        //
        INIT_OBJA( &Obja, &UnicodeString, KeyName );

        Status = ZwOpenKey( 
            &KeyHandle,
            KEY_WRITE,
            &Obja 
            );

        if( !NT_SUCCESS(Status) ) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SAC SetRegistryValue: failed ZwOpenKey: %X.\n", Status))
                );
                
            return Status;

        }

        //
        // Set the value 
        //
        RtlInitUnicodeString( &UnicodeString, ValueName );

        Status = ZwSetValueKey( 
            KeyHandle,
            &UnicodeString,
            0,
            Type,
            Data,
            DataSize
            );

        if( !NT_SUCCESS(Status) ) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SAC SetRegistryValue: failed ZwSetValueKey: %X\n", Status))
                );

            break;
        
        }
    
    } while ( FALSE );

    //
    // We are done with the reg key
    //
    NtClose(KeyHandle);
    
    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC SetRegistryValue: Exiting.\n"))
        );

    return Status;

}

NTSTATUS
CopyRegistryValueData(
    PVOID*                          Dest,
    PKEY_VALUE_PARTIAL_INFORMATION  ValueBuffer
    )
/*++

Routine Description:

    This routine allocates and copies the specified registry value data 

Arguments:

    Dest        - on success, contains the value data copy
    ValueBuffer - contains the value data    
    
Return Value:

    Status                                         
                                         
--*/
{
    NTSTATUS    Status;

    Status = STATUS_SUCCESS;

    ASSERT_STATUS(Dest, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(ValueBuffer, STATUS_INVALID_PARAMETER_2);
    
    do {

        *Dest = (PVOID)ALLOCATE_POOL(ValueBuffer->DataLength, GENERAL_POOL_TAG);

        if (*Dest == NULL) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC CopyRegistryValueBuffer: Failed ALLOCATE.\n")));
            Status = STATUS_NO_MEMORY;
            break;
        }

        RtlCopyMemory(*Dest, ValueBuffer->Data, ValueBuffer->DataLength);
    
    } while (FALSE);

    return Status;

}

NTSTATUS
TranslateMachineInformationText(
    PWSTR*  Buffer
    )
/*++

Routine Description:

    This routine creates a formated text string representing 
    the current machine info
    
Arguments:
    
    Buffer          - Contains the machine info string

Return Value:

    Status

--*/
{
    NTSTATUS    Status;
    PCWSTR      pwStr;
    PWSTR       pBuffer;
    ULONG       len;
    ULONG       Size;

#define MITEXT_SPRINTF(_s,_t)               \
    pwStr = GetMessage(_s);                 \
    if (pwStr && MachineInformation->_t) {  \
        len = swprintf(                     \
            pBuffer,                        \
            pwStr,                          \
            MachineInformation->_t          \
            );                              \
        pBuffer += len;                     \
    }                                       

#define MITEXT_LENGTH(_s,_t)                \
    pwStr = GetMessage(_s);                 \
    if (pwStr && MachineInformation->_t) {  \
        len += (ULONG)wcslen(MachineInformation->_t) + (ULONG)wcslen(pwStr);  \
    }                                       

    ASSERT_STATUS(Buffer, STATUS_INVALID_PARAMETER_1);

    //
    // default: we succeeded
    //
    Status = STATUS_SUCCESS;

    //
    // Assemble the machine info
    //
    do {

        //
        // compute the length of the final string so
        // we know how much memory to allocate
        //
        {
            len = 0;

            MITEXT_LENGTH(SAC_MACHINEINFO_COMPUTERNAME,            MachineName);
            MITEXT_LENGTH(SAC_MACHINEINFO_GUID,                    GUID);
            MITEXT_LENGTH(SAC_MACHINEINFO_PROCESSOR_ARCHITECTURE,  ProcessorArchitecture);
            MITEXT_LENGTH(SAC_MACHINEINFO_OS_VERSION,              OSVersion);
            MITEXT_LENGTH(SAC_MACHINEINFO_OS_BUILD,                OSBuildNumber);
            MITEXT_LENGTH(SAC_MACHINEINFO_OS_PRODUCTTYPE,          OSProductType);
            MITEXT_LENGTH(SAC_MACHINEINFO_SERVICE_PACK,            OSServicePack);

            //
            // compute the size; include NULL termination
            //
            Size = (len + 1) * sizeof(WCHAR);
        }
        
        *Buffer = ALLOCATE_POOL(Size, GENERAL_POOL_TAG);
        if( *Buffer == NULL ) {
            Status = STATUS_NO_MEMORY;
            break;
        }

        pBuffer = *Buffer;

        MITEXT_SPRINTF(SAC_MACHINEINFO_COMPUTERNAME,            MachineName);
        MITEXT_SPRINTF(SAC_MACHINEINFO_GUID,                    GUID);
        MITEXT_SPRINTF(SAC_MACHINEINFO_PROCESSOR_ARCHITECTURE,  ProcessorArchitecture);
        MITEXT_SPRINTF(SAC_MACHINEINFO_OS_VERSION,              OSVersion);
        MITEXT_SPRINTF(SAC_MACHINEINFO_OS_BUILD,                OSBuildNumber);
        MITEXT_SPRINTF(SAC_MACHINEINFO_OS_PRODUCTTYPE,          OSProductType);
        MITEXT_SPRINTF(SAC_MACHINEINFO_SERVICE_PACK,            OSServicePack);

        ASSERT((ULONG)((wcslen(*Buffer) + 1) * sizeof(WCHAR)) <= Size);

    } while ( FALSE );
    
    if (!NT_SUCCESS(Status) && *Buffer != NULL) {
        FREE_POOL(Buffer);
        *Buffer = NULL;
    } 

    return Status;
}


NTSTATUS
TranslateMachineInformationXML(
    OUT PWSTR*  Buffer,
    IN  PWSTR   AdditionalInfo
    )
/*++

Routine Description:

    This routine creates an XML string representing the current machine info
    
Arguments:
    
    Buffer          - Contains the machine info string
    AdditionalInfo  - Additional Machine Info wanted to be included by caller   
                      Note: additional info should be a well-formed xml string:
                            e.g. <uptime>01:01:01</uptime>

Return Value:

    Status

--*/
{
    NTSTATUS    Status;
    PCWSTR      pwStr;
    PWSTR       pBuffer;
    ULONG       len;
    ULONG       Size;

#define MIXML_SPRINTF(_s,_t)                \
    pwStr = _s;                             \
    if (pwStr && MachineInformation->_t) {  \
        len = swprintf(                     \
            pBuffer,                        \
            pwStr,                          \
            MachineInformation->_t          \
            );                              \
        pBuffer += len;                     \
    }                                       

#define XML_MACHINEINFO_HEADER                      L"<machine-info>\r\n"
#define XML_MACHINEINFO_NAME                        L"<name>%s</name>\r\n"
#define XML_MACHINEINFO_GUID                        L"<guid>%s</guid>\r\n"        
#define XML_MACHINEINFO_PROCESSOR_ARCHITECTURE      L"<processor-architecture>%s</processor-architecture>\r\n"
#define XML_MACHINEINFO_OS_VERSION                  L"<os-version>%s</os-version>\r\n"
#define XML_MACHINEINFO_OS_BUILD                    L"<os-build-number>%s</os-build-number>\r\n"
#define XML_MACHINEINFO_OS_PRODUCTTYPE              L"<os-product>%s</os-product>\r\n"
#define XML_MACHINEINFO_SERVICE_PACK                L"<os-service-pack>%s</os-service-pack>\r\n"
#define XML_MACHINEINFO_FOOTER                      L"</machine-info>\r\n"

    ASSERT_STATUS(Buffer, STATUS_INVALID_PARAMETER_1);
    
    //
    // default: we succeeded
    //
    Status = STATUS_SUCCESS;

    //
    // Assemble the machine info
    //
    do {

        //
        // compute the length of the final string so
        // we know how much memory to allocate
        //
        {
            len = (ULONG)wcslen(XML_MACHINEINFO_HEADER);

            if (MachineInformation->MachineName) {
                len += (ULONG)wcslen(MachineInformation->MachineName);
                len += (ULONG)wcslen(XML_MACHINEINFO_NAME);
            }
            if (MachineInformation->GUID) {
                len += (ULONG)wcslen(MachineInformation->GUID);
                len += (ULONG)wcslen(XML_MACHINEINFO_GUID);
            }
            if (MachineInformation->ProcessorArchitecture) {
                len += (ULONG)wcslen(MachineInformation->ProcessorArchitecture);
                len += (ULONG)wcslen(XML_MACHINEINFO_PROCESSOR_ARCHITECTURE);
            }
            if (MachineInformation->OSVersion) {
                len += (ULONG)wcslen(MachineInformation->OSVersion);
                len += (ULONG)wcslen(XML_MACHINEINFO_OS_VERSION);
            }
            if (MachineInformation->OSBuildNumber) {
                len += (ULONG)wcslen(MachineInformation->OSBuildNumber);
                len += (ULONG)wcslen(XML_MACHINEINFO_OS_BUILD);
            }
            if (MachineInformation->OSProductType) {
                len += (ULONG)wcslen(MachineInformation->OSProductType);
                len += (ULONG)wcslen(XML_MACHINEINFO_OS_PRODUCTTYPE);
            }
            if (MachineInformation->OSServicePack) {
                len += (ULONG)wcslen(MachineInformation->OSServicePack);
                len += (ULONG)wcslen(XML_MACHINEINFO_SERVICE_PACK);
            }

            //
            // If the caller passed additional machine info, 
            // then account for the additional len
            //
            if (AdditionalInfo) {
                len += (ULONG)wcslen(AdditionalInfo);
            }

            len += (ULONG)wcslen(XML_MACHINEINFO_FOOTER);

            //
            // compute the size; include NULL termination
            //
            Size = (len + 1) * sizeof(WCHAR);
        }

        //
        // Allocate the machine info buffer
        //
        *Buffer = ALLOCATE_POOL(Size, GENERAL_POOL_TAG);
        if( *Buffer == NULL ) {
            Status = STATUS_NO_MEMORY;
            break;
        }

        pBuffer = *Buffer;

        len = (ULONG)wcslen(XML_MACHINEINFO_HEADER);
        wcscpy(pBuffer, XML_MACHINEINFO_HEADER);
        pBuffer += len;

        MIXML_SPRINTF(XML_MACHINEINFO_NAME,                    MachineName);
        MIXML_SPRINTF(XML_MACHINEINFO_GUID,                    GUID);
        MIXML_SPRINTF(XML_MACHINEINFO_PROCESSOR_ARCHITECTURE,  ProcessorArchitecture);
        MIXML_SPRINTF(XML_MACHINEINFO_OS_VERSION,              OSVersion);
        MIXML_SPRINTF(XML_MACHINEINFO_OS_BUILD,                OSBuildNumber);
        MIXML_SPRINTF(XML_MACHINEINFO_OS_PRODUCTTYPE,          OSProductType);
        MIXML_SPRINTF(XML_MACHINEINFO_SERVICE_PACK,            OSServicePack);

        //
        // If present, include the additional info
        //
        if (AdditionalInfo) {
            
            len = (ULONG)wcslen(AdditionalInfo);
            wcscpy(pBuffer, AdditionalInfo);
            pBuffer += len;                     
        
        }

        wcscpy(pBuffer, XML_MACHINEINFO_FOOTER);

        ASSERT((((ULONG)wcslen(*Buffer) + 1) * sizeof(WCHAR)) <= Size);

    } while ( FALSE );
    
    if (!NT_SUCCESS(Status) && *Buffer != NULL) {
        FREE_POOL(Buffer);
        *Buffer = NULL;
    }

    return Status;
}

NTSTATUS
RegisterBlueScreenMachineInformation(
    VOID
    )
/*++

Routine Description:

    This routine populates Headless Dispatch Blue Screen handler
    with the XML representation machine information
    
Arguments:
    
    None.

Return Value:

    Status

--*/
{
    
    PHEADLESS_CMD_SET_BLUE_SCREEN_DATA BSBuffer;
    PWSTR       XMLBuffer;
    ULONG       XMLBufferLength;
    NTSTATUS    Status;
    ULONG       Size;
    PSTR        XML_TAG = "MACHINEINFO";
    ULONG       XML_TAG_LENGTH;

    //
    // Get the XML representation of the machine info
    //

    Status = TranslateMachineInformationXML(&XMLBuffer, NULL);

    ASSERT_STATUS(NT_SUCCESS(Status), Status);
    ASSERT_STATUS(XMLBuffer, STATUS_UNSUCCESSFUL);

    //
    // Determine the lengths of the strings we'll use
    //
    XMLBufferLength = (ULONG)wcslen(XMLBuffer);
    XML_TAG_LENGTH  = (ULONG)strlen(XML_TAG);

    //
    // Allocate the BS Buffer
    //
    // Need to accomodate:
    //
    // HEADLESS_CMD_SET_BLUE_SCREEN_DATA + XML_TAG\0XMLBuffer\0
    //
    Size = sizeof(HEADLESS_CMD_SET_BLUE_SCREEN_DATA) + 
        (XML_TAG_LENGTH*sizeof(UCHAR)) + sizeof(UCHAR) + 
        (XMLBufferLength*sizeof(UCHAR)) + sizeof(UCHAR);

    BSBuffer = (PHEADLESS_CMD_SET_BLUE_SCREEN_DATA)ALLOCATE_POOL( 
        Size,
        GENERAL_POOL_TAG 
        );

    if (!BSBuffer) {
        FREE_POOL(&XMLBuffer);
    }

    ASSERT_STATUS(BSBuffer, STATUS_NO_MEMORY);

    //
    // Copy the XML Buffer into the BS Buffer as an ANSI string
    //
    
    {
        PUCHAR      pch;
        ULONG       i;

        //
        // Get the BScreen buffer
        //
        pch = &(BSBuffer->Data[0]);

        //
        // Insert the XML Tag (required for HeadlessDispatch)
        //
        strcpy((char *)pch, XML_TAG);

        //
        // Move to the beginning of the XML buffer region
        //
        BSBuffer->ValueIndex = XML_TAG_LENGTH+1;
        pch += XML_TAG_LENGTH+1;

        //
        // Write the WCHAR XMLBuffer as ANSI into the BSBuffer
        // 
        for (i = 0; i < XMLBufferLength; i++) {
            pch[i] = (UCHAR)XMLBuffer[i];
        }
        pch[i] = '\0';
    
    }

    //
    // ========
    // Insert it all into the BLUESCREEN data.
    // ========
    //
    Status = HeadlessDispatch( 
        HeadlessCmdSetBlueScreenData,
        BSBuffer,
        Size,
        NULL,
        0
        );

    //
    // clean up
    //
    FREE_POOL( &BSBuffer );
    FREE_POOL( &XMLBuffer);

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC Initialize Machine Information: Exiting.\n"))
        );
    
    return Status;

}

VOID
FreeMachineInformation(
    VOID
    )
/*++

Routine Description:

    This routine releases the machine information collected at driver startup

Arguments:

    None

Return Value:
    
    None

--*/
{
    
    //
    // The information should be present
    //
    ASSERT(MachineInformation);
    if (!MachineInformation) {
        return;
    }

    SAFE_FREE_POOL(&MachineInformation->MachineName);
    SAFE_FREE_POOL(&MachineInformation->GUID);
    SAFE_FREE_POOL(&MachineInformation->ProcessorArchitecture);
    SAFE_FREE_POOL(&MachineInformation->OSVersion);
    SAFE_FREE_POOL(&MachineInformation->OSBuildNumber);
    SAFE_FREE_POOL(&MachineInformation->OSProductType);
    SAFE_FREE_POOL(&MachineInformation->OSServicePack);

}

VOID
InitializeMachineInformation(
    VOID
    )
/*++

Routine Description:

    This function initializes the global variable MachineInformationBuffer.

    We'll gather a whole bunch of information about the machine and fill
    in the buffer.

Arguments:
    
    None.

Return Value:

    None.

--*/
{
    PWSTR   COMPUTERNAME_KEY_NAME  = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName";
    PWSTR   COMPUTERNAME_VALUE_NAME  = L"ComputerName";
    PWSTR   PROCESSOR_ARCHITECTURE_KEY_NAME  = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\Environment";
    PWSTR   PROCESSOR_ARCHITECTURE_VALUE_NAME  = L"PROCESSOR_ARCHITECTURE";
    PWSTR   SETUP_KEY_NAME = L"\\Registry\\Machine\\System\\Setup";
    PWSTR   SETUPINPROGRESS_VALUE_NAME = L"SystemSetupInProgress";


    RTL_OSVERSIONINFOEXW            VersionInfo;
    PKEY_VALUE_PARTIAL_INFORMATION  ValueBuffer;
    NTSTATUS                        Status = STATUS_SUCCESS;
    SIZE_T                          i;
    PWSTR                           MyTemporaryBufferW = NULL;
    GUID                            MyGUID;
    PCWSTR                          pwStr;
    BOOLEAN                         InGuiModeSetup = FALSE;

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC Initialize Machine Information: Entering.\n"))
        );

    if( MachineInformation != NULL ) {

        //
        // someone called us again!
        //
        IF_SAC_DEBUG( 
            SAC_DEBUG_FUNC_TRACE_LOUD, 
            KdPrint(("SAC Initialize Machine Information:: MachineInformationBuffer already initialzied.\n"))
            );

        return;
    
    } else {

        MachineInformation = (PMACHINE_INFORMATION)ALLOCATE_POOL( sizeof(MACHINE_INFORMATION), GENERAL_POOL_TAG );

        if( MachineInformation == NULL ) {

            goto InitializeMachineInformation_Failure;
        
        }
    
    }

    RtlZeroMemory( MachineInformation, sizeof(MACHINE_INFORMATION) );

    //
    // We're real early in the boot process, so we're going to take for granted that the machine hasn't
    // bugchecked.  This means that we can safely call some kernel functions to go figure out what
    // platform we're running on.
    //
    RtlZeroMemory( &VersionInfo, sizeof(VersionInfo));
    
    Status = RtlGetVersion( (POSVERSIONINFOW)&VersionInfo );

    if( !NT_SUCCESS(Status) ) {

        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC InitializeMachineInformation: Exiting (2).\n"))
            );
        
        goto InitializeMachineInformation_Failure;
    
    }



    //
    // See if we're in gui-mode setup.  We may need this info later.
    //
    Status = GetRegistryValueBuffer(
        SETUP_KEY_NAME,
        SETUPINPROGRESS_VALUE_NAME,
        &ValueBuffer
        );
    if( NT_SUCCESS(Status) ) {

        //
        // See if it's 0 (we're not in Setup) or non-zero (we're in Setup)
        //
        if( *((PULONG)(ValueBuffer->Data)) != 0 ) {
            InGuiModeSetup = TRUE;
        }

        FREE_POOL(&ValueBuffer);
    }



    //
    // ========
    // Machine name.
    // ========
    //

    if( InGuiModeSetup ) {
        //
        // The machine name hasn't been initialized by the Setup process,
        // so use some predefined string for the manchine name.
        //
        MachineInformation->MachineName = ALLOCATE_POOL(((ULONG)wcslen((PWSTR)GetMessage(SAC_DEFAULT_MACHINENAME))+1) * sizeof(WCHAR), GENERAL_POOL_TAG);
        if( MachineInformation->MachineName ) {
            wcscpy( MachineInformation->MachineName, GetMessage(SAC_DEFAULT_MACHINENAME) );
        }
    } else {
        //
        // We are not in Guimode setup, so go dig the machinename
        // out of the registry.
        //
        Status = GetRegistryValueBuffer(
            COMPUTERNAME_KEY_NAME,
            COMPUTERNAME_VALUE_NAME,
            &ValueBuffer
            );
            
        if( NT_SUCCESS(Status) ) {
    
            //
            // we successfully retrieved the machine name
            //
    
            Status = CopyRegistryValueData(
                &(MachineInformation->MachineName),
                ValueBuffer
                );
    
            FREE_POOL(&ValueBuffer);
    
            if( !NT_SUCCESS(Status) ) {
    
                IF_SAC_DEBUG(
                    SAC_DEBUG_FUNC_TRACE, 
                    KdPrint(("SAC InitializeMachineInformation: Exiting (20).\n"))
                    );
    
                goto InitializeMachineInformation_Failure;
    
            }
        
        } else {
    
            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SAC InitializeMachineInformation: Failed to get machine name.\n"))
                );
    
        }
    }


    //
    // ========
    // Machine GUID.
    // ========
    //

    // make sure.
    RtlZeroMemory( &MyGUID, sizeof(GUID) );
    i = sizeof(GUID);
    Status = HeadlessDispatch( HeadlessCmdQueryGUID,
                               NULL,
                               0,
                               &MyGUID,
                               &i );
    
    if( NT_SUCCESS(Status) ) {

        MyTemporaryBufferW = (PWSTR)ALLOCATE_POOL( ((sizeof(GUID)*2) + 8) * sizeof(WCHAR) , GENERAL_POOL_TAG );

        if( MyTemporaryBufferW == NULL ) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SAC InitializeMachineInformation: Exiting (31).\n"))
                );

            goto InitializeMachineInformation_Failure;

        }

        swprintf( MyTemporaryBufferW,
                  L"%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                  MyGUID.Data1,
                  MyGUID.Data2,
                  MyGUID.Data3,
                  MyGUID.Data4[0],
                  MyGUID.Data4[1],
                  MyGUID.Data4[2],
                  MyGUID.Data4[3],
                  MyGUID.Data4[4],
                  MyGUID.Data4[5],
                  MyGUID.Data4[6],
                  MyGUID.Data4[7] );

        MachineInformation->GUID = MyTemporaryBufferW;
    
    } else {
        
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC InitializeMachineInformation: Failed to get Machine GUID.\n"))
            );
        
    }

    //
    // ========
    // Processor Architecture.
    // ========
    //
    
    Status = GetRegistryValueBuffer(
        PROCESSOR_ARCHITECTURE_KEY_NAME,
        PROCESSOR_ARCHITECTURE_VALUE_NAME,
        &ValueBuffer
        );
    
    if( NT_SUCCESS(Status) ) {
    
        Status = CopyRegistryValueData(
            &(MachineInformation->ProcessorArchitecture),
            ValueBuffer
            );

        FREE_POOL(&ValueBuffer);

        if( !NT_SUCCESS(Status) ) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FUNC_TRACE, 
                KdPrint(("SAC InitializeMachineInformation: Exiting (30).\n"))
                );

            goto InitializeMachineInformation_Failure;

        }

    } else {
        
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC InitializeMachineInformation: Exiting (30).\n"))
            );
    
    }
    
    //
    // ========
    // OS Name.
    // ========
    //

    //
    // Allocate enough memory for the formatting message, plus the size of 2 digits.
    // Currently, our versioning info is of the type "5.1", so we don't need much space
    // here, but let's be conservative and assume both major and minor version numbers
    // are 5 digits in size.  That's 11 characters.
    //
    // allow xxxxx.xxxxx
    //
    MyTemporaryBufferW = (PWSTR)ALLOCATE_POOL( (5 + 1 + 5 + 1) * sizeof(WCHAR), GENERAL_POOL_TAG );
    
    if( MyTemporaryBufferW == NULL ) {

        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC InitializeMachineInformation: Exiting (50).\n"))
            );
        
        goto InitializeMachineInformation_Failure;
    
    }

    swprintf( MyTemporaryBufferW,
              L"%d.%d",
              VersionInfo.dwMajorVersion,
              VersionInfo.dwMinorVersion );

    MachineInformation->OSVersion = MyTemporaryBufferW;

    //
    // ========
    // Build Number.
    // ========
    //

    //
    // Allocate enough memory for the formatting message, plus the size of our build number.
    // Currently that's well below the 5-digit mark, but let's build some headroom here for
    // build numbers up to 99000 (5-digits).
    //
    MyTemporaryBufferW = (PWSTR)ALLOCATE_POOL( ( 5 + 1 ) * sizeof(WCHAR), GENERAL_POOL_TAG );
    
    if( MyTemporaryBufferW == NULL ) {

        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC InitializeMachineInformation: Exiting (60).\n"))
            );
        
        goto InitializeMachineInformation_Failure;
    
    }

    swprintf( MyTemporaryBufferW,
              L"%d",
              VersionInfo.dwBuildNumber );

    MachineInformation->OSBuildNumber = MyTemporaryBufferW;

    //
    // ========
    // Product Type (and Suite).
    // ========
    //
    if( ExVerifySuite(DataCenter) ) {

        pwStr = (PWSTR)GetMessage(SAC_MACHINEINFO_DATACENTER);

    } else if( ExVerifySuite(EmbeddedNT) ) {

        pwStr = GetMessage(SAC_MACHINEINFO_EMBEDDED);

    } else if( ExVerifySuite(Enterprise) ) {

        pwStr = (PWSTR)GetMessage(SAC_MACHINEINFO_ADVSERVER);

    } else {

        //
        // We found no product suite that we recognized or cared about.
        // Assume we're running on a generic server.
        //
        pwStr = (PWSTR)GetMessage(SAC_MACHINEINFO_SERVER);

    }

    //
    // If we got a product type string message, then use this as our product type
    //
    if (pwStr) {

        ULONG   Size;

        Size = (ULONG)((wcslen(pwStr) + 1) * sizeof(WCHAR));

        ASSERT(Size > 0);

        MachineInformation->OSProductType = (PWSTR)ALLOCATE_POOL(Size, GENERAL_POOL_TAG);

        if (MachineInformation->OSProductType == NULL) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC InitializeMachineInformation: Failed product type memory allocation.\n"))
                );
            
            goto InitializeMachineInformation_Failure;

        }

        RtlCopyMemory(MachineInformation->OSProductType, pwStr, Size);

    } else {
        
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC InitializeMachineInformation: Failed to get product type.\n"))
            );
    
    }

    //
    // ========
    // Service Pack Information.
    // ========
    //
    if( VersionInfo.wServicePackMajor != 0 ) {

        //
        // There's been a service pack applied.  Better tell the user.
        //

        //
        // Allocate enough memory for the formatting message, plus the size of our servicepack number.
        // Currently that's well below the 5-digit mark, but let's build some headroom here for
        // service pack numbers up to 99000 (5-digits).
        //
        //  allow for xxxxx.xxxxx
        //
        MyTemporaryBufferW = (PWSTR)ALLOCATE_POOL( (5 + 1 + 5 + 1) * sizeof(WCHAR), GENERAL_POOL_TAG );
        
        if( MyTemporaryBufferW == NULL ) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC InitializeMachineInformation: Failed service pack memory allocation.\n"))
                );
            
            goto InitializeMachineInformation_Failure;
        
        }

        swprintf( MyTemporaryBufferW,
                  L"%d.%d",
                  VersionInfo.wServicePackMajor,
                  VersionInfo.wServicePackMinor );
        
        MachineInformation->OSServicePack = MyTemporaryBufferW;
    
    } else {

        ULONG   Size;

        pwStr = (PWSTR)GetMessage(SAC_MACHINEINFO_NO_SERVICE_PACK);

        Size = (ULONG)((wcslen(pwStr) + 1) * sizeof(WCHAR));

        ASSERT(Size > 0);

        MachineInformation->OSServicePack = (PWSTR)ALLOCATE_POOL(Size, GENERAL_POOL_TAG);

        if (MachineInformation->OSServicePack == NULL) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC InitializeMachineInformation: Failed service pack memory allocation.\n"))
                );
            
            goto InitializeMachineInformation_Failure;

        }

        RtlCopyMemory(MachineInformation->OSServicePack, pwStr, Size);
    
    }

    return;

InitializeMachineInformation_Failure:
    
    if( MachineInformation != NULL ) {
        FREE_POOL(&MachineInformation);
        MachineInformation = NULL;
    }

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC Initialize Machine Information: Exiting with error.\n"))
        );
    
    return;

}

NTSTATUS
SerialBufferGetChar(
    IN PUCHAR   ch
    )
/*++

Routine Description:

    This routine reads a character from the serial port buffer
    which is populated by the TimerDPC function.  The character
    is read from the Consumer index position in the buffer.  After
    the character is read, the buffer position is nulled.

Arguments:

    ch  - on success, contains the character at the consumer index
    
Return Value:

    Status                                                                  
                                                                  
--*/
{
    NTSTATUS    Status;

    Status = STATUS_SUCCESS;

    do {
        
        //
        // Bail if there are no new characters to read
        //
        if (SerialPortConsumerIndex == SerialPortProducerIndex) {

            Status = STATUS_NO_DATA_DETECTED;

            break;

        }

        //
        // Note: the following block is not done with an interlocked
        //       exchange because we don't need to.  The design
        //       of the serialport ring buffer is such that the 
        //       producer index is allowed to pass the consumer.
        //       This should not happen, however, because the
        //       consumer is notified whenever we get new data
        //       and the buffer should be large enough to allow 
        //       for reasonable consumer delays.
        //
        {
            //
            // get the current character at the current consumer index.  
            //
            *ch = SerialPortBuffer[SerialPortConsumerIndex];

            //
            // Null the value at the index we just read.  This prevents 
            // information being present in the buffer after we've already 
            // read it.
            //
            SerialPortBuffer[SerialPortConsumerIndex] = 0;        
        }

        //
        // Compute the new producer index and store it atomically
        //
        InterlockedExchange(
            (volatile long *)&SerialPortConsumerIndex, 
            (SerialPortConsumerIndex + 1) % SERIAL_PORT_BUFFER_LENGTH
            );

    } while ( FALSE );

    return Status;
}

#if ENABLE_CMD_SESSION_PERMISSION_CHECKING

NTSTATUS
GetCommandConsoleLaunchingPermission(
    OUT PBOOLEAN    Permission
    )
/*++

Routine Description:

    This routine determines if command console sessions are allowed
    to be launched.

Arguments:

    Permission  - on success, contains TRUE if sessions are allowed
                  to be launched

Return Value:

    Status

--*/
{
    NTSTATUS    Status;
    
    PWSTR   KEY_NAME    = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\sacdrv";
    PWSTR   VALUE_NAME  = L"DisableCmdSessions";
    
    PKEY_VALUE_PARTIAL_INFORMATION  ValueBuffer;

    //
    // default: permission is granted unless we specifically find
    //          the key/value stating that it is not
    //
    *Permission = TRUE;
    
    do {

        //
        // Attempt to find the registry key/value 
        //
        Status = GetRegistryValueBuffer(
            KEY_NAME,
            VALUE_NAME,
            &ValueBuffer
            );

        if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            
            //
            // The reg key was not found, so the feature is enabled.
            //
            Status = STATUS_SUCCESS;
            
            break;
        
        }
        
        if(! NT_SUCCESS(Status) ) {
            break;
        }
        
        //
        // We found the key/value, so notify the caller
        // that permission has been denied.
        //
        *Permission = FALSE;

    } while ( FALSE );

    return Status;

}

#if ENABLE_SACSVR_START_TYPE_OVERRIDE

NTSTATUS
ImposeSacCmdServiceStartTypePolicy(
    VOID
    )
/*++

Routine Description:
    
    This routine implement the service start type policy
    that is imposed when the cmd console session feature
    is ENABLED.
            
    Here is the state table:
            
    Command Console Feature Enabled:
            
    service start type:
            
        automatic   --> NOP
        manual      --> automatic
        disabled    --> NOP

Arguments:

    None

Return Value:

    Status    
        
--*/
{
    NTSTATUS    Status;
    
    PWSTR       KEY_NAME    = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\sacsvr";
    PWSTR       VALUE_NAME  = L"Start";
    
    PULONG                          ValueData;
    PKEY_VALUE_PARTIAL_INFORMATION  ValueBuffer;
    
    do {

        //
        // init
        //
        ValueBuffer = NULL;
        
        //
        // Attempt to find the registry key/value 
        //
        Status = GetRegistryValueBuffer(
            KEY_NAME,
            VALUE_NAME,
            &ValueBuffer
            );

        if(! NT_SUCCESS(Status)) {
            break;
        }
        if(ValueBuffer == NULL) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }
        
        //
        // Get the current start type value
        //
        Status = CopyRegistryValueData(
            &ValueData,
            ValueBuffer
            );

        FREE_POOL(&ValueBuffer);

        if( !NT_SUCCESS(Status) ) {
            break;
        }

        //
        // Examine the current start type and assign
        // a new type if appropriate.
        //
        switch (*ValueData) {
        case 2: // automatic
        case 4: // disabled
            break;

        case 3: // manual
            
            //
            // Set the start type --> Automatic
            //
            *ValueData = 2;

            //
            // Set the start type value in the service key.
            //
            Status = SetRegistryValue(
                KEY_NAME,
                VALUE_NAME,
                REG_DWORD,
                ValueData,
                sizeof(ULONG)
                );

            if(!NT_SUCCESS(Status)) {
                
                IF_SAC_DEBUG(
                    SAC_DEBUG_FAILS, 
                    KdPrint(("SAC ImposeSacCmdServiceStartTypePolicy: Failed SetRegistryValue: %X\n", Status))
                    );
            
            }
            
            break;

        default:
            ASSERT(0);
            break;
        }

    } while ( FALSE );

    return Status;

}
#endif

#endif

NTSTATUS
CopyAndInsertStringAtInterval(
    IN  PWCHAR   SourceStr,
    IN  ULONG    Interval,
    IN  PWCHAR   InsertStr,
    OUT PWCHAR   *pDestStr
    )
/*++

Routine Description:

    This routine takes a source string and inserts an 
    "interval string" at interval characters in the new
    destination string.
    
    Note: caller is responsible for releasing DestStr if successful      
          
    ex:
    
    src "aaabbbccc"
    interval string = "XYZ"
    interval = 3
                       
    ==> dest string == "aaaXYZbbbXYZccc"

Arguments:
    
    SourceStr   - the source string
    Interval    - spanning interval
    InsertStr   - the insert string
    DestStr     - the destination string    

Return Value:

    Status

--*/
{
    ULONG   SrcLength;
    ULONG   DestLength;
    ULONG   DestSize;
    ULONG   InsertLength;
    ULONG   k;
    ULONG   l;
    ULONG   i;
    PWCHAR  DestStr;
    ULONG   IntervalCnt;

    ASSERT_STATUS(SourceStr, STATUS_INVALID_PARAMETER_1); 
    ASSERT_STATUS(Interval > 0, STATUS_INVALID_PARAMETER_2); 
    ASSERT_STATUS(InsertStr, STATUS_INVALID_PARAMETER_3); 
    ASSERT_STATUS(pDestStr > 0, STATUS_INVALID_PARAMETER_4); 

    //
    // the length of the insert string
    //
    InsertLength = (ULONG)wcslen(InsertStr);
    
    //
    // Compute how large the destination string needs to be,
    // including the source string and the interval strings.
    //
    SrcLength = (ULONG)wcslen(SourceStr);
    IntervalCnt = SrcLength / Interval;
    if (SrcLength % Interval == 0) {
        IntervalCnt = IntervalCnt > 0 ? IntervalCnt - 1 : IntervalCnt;
    }
    DestLength = SrcLength + (IntervalCnt * (ULONG)wcslen(InsertStr));
    DestSize = (ULONG)((DestLength + 1) * sizeof(WCHAR));

    //
    // Allocate the new destination string
    //
    DestStr = ALLOCATE_POOL(DestSize, GENERAL_POOL_TAG);
    ASSERT_STATUS(DestStr, STATUS_NO_MEMORY);
    RtlZeroMemory(DestStr, DestSize);

    //
    // Initialize the pointers into the source and destination strings
    //
    l = 0;
    i = 0;

    do {

        //
        // k = # of characters to copy
        //
        // if Interval > # of characters left to copy,
        // then k = # of characters left to copy
        // else k = interval
        // 
        k = Interval > (SrcLength - i) ? (SrcLength - i) : Interval;
        
        //
        // Copy k charactars to the destination buffer
        //
        wcsncpy(
            &DestStr[l],
            &SourceStr[i],
            k
            );

        //
        // Account for how many characters we just copied
        //
        l += k;
        i += k;

        //
        // If there are any characters left to copy, 
        // then we need to insert the InsertString 
        // That is, we are at an interval.
        //
        if (i < SrcLength) {
            
            //
            // Insert the specified string at the interval
            //
            wcscpy(
                &DestStr[l],
                InsertStr
                );

            //
            // Account for how many characters we just copied
            //
            l += InsertLength;
        
        }

    } while ( i < SrcLength);

    //
    //
    //
    ASSERT(i == SrcLength);
    ASSERT(l == DestLength);
    ASSERT((l + 1) * sizeof(WCHAR) == DestSize);

    //
    // Send back the destination string
    //
    *pDestStr = DestStr;

    return STATUS_SUCCESS;
}

ULONG
GetMessageLineCount(
    ULONG MessageId
    )
/*++

Routine Description:

    This routine retrieves a message resource and counts the # of lines in it
    
Arguments:

    MessageId   - The message id of the resource to send

Return Value:

    LineCount

--*/
{
    PCWSTR  p;
    ULONG   c;

    //
    // we start at 0 
    // 1. if the message is found, 
    //    then we know resource messages always have at least 1 CRLF
    // 2. if the message is not found,
    //    then the line count is 0
    //
    c = 0;

    p = GetMessage(MessageId);
       
    if (p) {
        
        while(*p) {
            if (*p == L'\n') {
                c++;
            }
            p++;
        }

    }
    
    return(c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\vtutf8chan.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    vtutf8chan.h

Abstract:

    Routines for managing VTUTF8 channels.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#ifndef VTUTF8_CHAN_H
#define VTUTF8_CHAN_H

//
// Size of a VTUTF8 channel input buffer
// 
#define SAC_VTUTF8_IBUFFER_SIZE ((MEMORY_INCREMENT*sizeof(WCHAR)) / sizeof(UCHAR))
                   
//
// The VTUTF8 Channel's internal emulator screen dimensions
//
#define SAC_VTUTF8_ROW_HEIGHT    24
#define SAC_VTUTF8_COL_WIDTH     80

//
// This struct is all the information necessary for a single character on 
// a terminal.
//
typedef struct _SAC_SCREEN_ELEMENT {
    UCHAR FgColor;
    UCHAR BgColor;
    UCHAR Attr;
    WCHAR Value;
} SAC_SCREEN_ELEMENT, *PSAC_SCREEN_ELEMENT;

//
// This struct is the screen buffer used by VTUTF8 channels
//
typedef struct _SAC_SCREEN_BUFFER {

    SAC_SCREEN_ELEMENT Element[SAC_VTUTF8_ROW_HEIGHT][SAC_VTUTF8_COL_WIDTH];

} SAC_SCREEN_BUFFER, *PSAC_SCREEN_BUFFER;

//
// Prototypes
//
NTSTATUS
VTUTF8ChannelOInit(
    PSAC_CHANNEL    Channel
    );

NTSTATUS
VTUTF8ChannelCreate(
    IN OUT PSAC_CHANNEL     Channel
    );

NTSTATUS
VTUTF8ChannelDestroy(
    IN OUT PSAC_CHANNEL     Channel
    );

NTSTATUS
VTUTF8ChannelORead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount
    );

NTSTATUS
VTUTF8ChannelOEcho(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
VTUTF8ChannelOWrite(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
VTUTF8ChannelOWrite2(
    IN PSAC_CHANNEL Channel,
    IN PCWSTR       Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
VTUTF8ChannelOFlush(
    IN PSAC_CHANNEL Channel
    );

NTSTATUS
VTUTF8ChannelIWrite(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
VTUTF8ChannelIRead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount   
    );

ULONG
VTUTF8ChannelConsumeEscapeSequence(
    IN PSAC_CHANNEL Channel,
    IN PCWSTR       String
    );

BOOLEAN
VTUTF8ChannelScanForNumber(
    IN  PCWSTR pch,
    OUT PULONG Number
    );

NTSTATUS
VTUTF8ChannelEcho(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    );

NTSTATUS
VTUTF8ChannelIBufferIsFull(
    IN  PSAC_CHANNEL    Channel,
    OUT BOOLEAN*        BufferStatus
    );

WCHAR
VTUTF8ChannelIReadLast(
    IN PSAC_CHANNEL Channel
    );

ULONG
VTUTF8ChannelIBufferLength(
    IN PSAC_CHANNEL Channel
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\util.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    util.h

Abstract:

    This is the local header file for SAC utilities.

Author:

    Brian Guarraci (briangu)

Revision History:

--*/

#ifndef _SAC_UTIL_H_
#define _SAC_UTIL_H_


NTSTATUS
CommunicationBufferWrite(
    IN PUCHAR   buffer,
    IN ULONG    bufferSize
    );

ULONG
ConvertAnsiToUnicode(
    OUT PWSTR   pwch,
    IN  PSTR    pch,
    IN  ULONG   cchMax
    );

NTSTATUS
RegisterSacCmdEvent(
    IN PFILE_OBJECT                 FileObject,
    IN PSAC_CMD_SETUP_CMD_EVENT     SetupCmdEvent
    );

NTSTATUS
UnregisterSacCmdEvent(
    IN PFILE_OBJECT     FileObject
    );

BOOLEAN
IsCmdEventRegistrationProcess(
    IN PFILE_OBJECT     FileObject
    );

BOOLEAN
VerifyEventWaitable(
    IN  HANDLE  hEvent,
    OUT PVOID  *EventObjectBody,
    OUT PVOID  *EventWaitObjectBody
    );

NTSTATUS
InvokeUserModeService(
    VOID
    );

NTSTATUS
PreloadGlobalMessageTable(
    PVOID ImageHandle
    );

NTSTATUS
TearDownGlobalMessageTable(
    VOID
    );

PCWSTR
GetMessage(
    ULONG MessageId
    );

VOID
InitializeMachineInformation(
    VOID
    );

VOID
FreeMachineInformation(
    VOID
    );

NTSTATUS
TranslateMachineInformationText(
    PWSTR*                  Buffer
    );

NTSTATUS
TranslateMachineInformationXML(
    PWSTR*  Buffer,
    PWSTR   AdditionalInfo            
    );

NTSTATUS
RegisterBlueScreenMachineInformation(
    VOID
    );

NTSTATUS
UTF8EncodeAndSend(
    PCWSTR  OutputBuffer
    );

BOOLEAN
SacTranslateUtf8ToUnicode(
    UCHAR  IncomingByte,
    UCHAR  *ExistingUtf8Buffer,
    WCHAR  *DestinationUnicodeVal
    );

BOOLEAN
SacTranslateUnicodeToUtf8(
    IN  PCWSTR   SourceBuffer,
    IN  ULONG    SourceBufferLength,
    IN  PUCHAR   DestinationBuffer,
    IN  ULONG    DestinationBufferSize,
    OUT PULONG   UTF8Count,
    OUT PULONG   ProcessedCount
    );

NTSTATUS
SerialBufferGetChar(
    IN PUCHAR   ch
    );

NTSTATUS
VerifyChannelLogin(
    VOID
    );

NTSTATUS
ChannelLoginWorker(
    IN PWCHAR   UserName,
    IN PWCHAR   UserPassword
    );

NTSTATUS
CopyAndInsertStringAtInterval(
    IN  PWCHAR   SourceStr,
    IN  ULONG    Interval,
    IN  PWCHAR   InsertStr,
    OUT PWCHAR   *DestStr
    );

#if ENABLE_CMD_SESSION_PERMISSION_CHECKING

NTSTATUS
GetCommandConsoleLaunchingPermission(
    OUT PBOOLEAN    Permission
    );

#if ENABLE_SACSVR_START_TYPE_OVERRIDE

NTSTATUS
ImposeSacCmdServiceStartTypePolicy(
    VOID
    );

#endif

#endif

ULONG
GetMessageLineCount(
    ULONG MessageId
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\vtutf8chan.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    vtutf8chan.c

Abstract:

    Routines for managing channels in the sac.

Author:

    Sean Selitrennikoff (v-seans) Sept, 2000.
    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#include "sac.h"

//
// Macro to validate the VTUTF8 Screen matrix coordinates 
//
#define ASSERT_CHANNEL_ROW_COL(_Channel)            \
    ASSERT(_Channel->CursorRow >= 0);               \
    ASSERT(_Channel->CursorRow < SAC_VTUTF8_ROW_HEIGHT);  \
    ASSERT(_Channel->CursorCol >= 0);               \
    ASSERT(_Channel->CursorCol < SAC_VTUTF8_COL_WIDTH);  

//
// VTUTF8 Attribute flags
//
// Note: We use bit flags in the UCHAR
//       that containts the attributes.
//       Hence, there can be up to 8 attributes.
//
//#define VTUTF8_ATTRIBUTES_OFF    0x1
#define VTUTF8_ATTRIBUTE_BLINK   0x1
#define VTUTF8_ATTRIBUTE_BOLD    0x2
#define VTUTF8_ATTRIBUTE_INVERSE 0x4

//
// Internal VTUTF8 emulator command codes
//
typedef enum _SAC_ESCAPE_CODE {
    CursorUp,
    CursorDown,
    CursorRight,
    CursorLeft,
    AttributesOff,
    BlinkOn,
    BlinkOff,
    BoldOn,
    BoldOff,
    InverseOn,
    InverseOff,
    BackTab,
    ClearToEol,
    ClearToBol,
    ClearLine,
    ClearToEos,
    ClearToBos,
    ClearScreen,
    SetCursorPosition,
    SetScrollRegion,
    SetColor,
    SetBackgroundColor,
    SetForegroundColor,
    SetColorAndAttribute
} SAC_ESCAPE_CODE, *PSAC_ESCAPE_CODE;

//
// Structure for assembling well-defined 
// command sequences.
//
typedef struct _SAC_STATIC_ESCAPE_STRING {
    WCHAR String[10];
    ULONG StringLength;
    SAC_ESCAPE_CODE Code;
} SAC_STATIC_ESCAPE_STRING, *PSAC_STATIC_ESCAPE_STRING;

//
// The well-defined escape sequences.
// 
// Note: add <esc>[YYYm sequences below (in consume escape sequences)
//       rather than here 
// Note: try to keep this list small since it gets iterated through
//       for every escape sequence consumed.
// Note: it would be interesting to order these by hit frequency
//
SAC_STATIC_ESCAPE_STRING SacStaticEscapeStrings[] = {
    {L"[A",  sizeof(L"[A")/sizeof(WCHAR)-1,  CursorUp},
    {L"[B",  sizeof(L"[B")/sizeof(WCHAR)-1,  CursorDown},
    {L"[C",  sizeof(L"[C")/sizeof(WCHAR)-1,  CursorRight},
    {L"[D",  sizeof(L"[D")/sizeof(WCHAR)-1,  CursorLeft},
    {L"[0Z", sizeof(L"[0Z")/sizeof(WCHAR)-1, BackTab},
    {L"[K",  sizeof(L"[K")/sizeof(WCHAR)-1,  ClearToEol},
    {L"[1K", sizeof(L"[1K")/sizeof(WCHAR)-1, ClearToBol},
    {L"[2K", sizeof(L"[2K")/sizeof(WCHAR)-1, ClearLine},
    {L"[J",  sizeof(L"[J")/sizeof(WCHAR)-1,  ClearToEos},
    {L"[1J", sizeof(L"[1J")/sizeof(WCHAR)-1, ClearToBos},
    {L"[2J", sizeof(L"[2J")/sizeof(WCHAR)-1, ClearScreen}
    };

//
// Global defines for a default vtutf8 terminal.  May be used by clients to size the 
// local monitor to match the headless monitor.
//
#define ANSI_TERM_DEFAULT_ATTRIBUTES 0
#define ANSI_TERM_DEFAULT_BKGD_COLOR 40
#define ANSI_TERM_DEFAULT_TEXT_COLOR 37

//
// Enumerated ANSI escape sequences
// 
typedef enum _ANSI_CMD {
    ANSICmdClearDisplay,
    ANSICmdClearToEndOfDisplay,
    ANSICmdClearToEndOfLine,
    ANSICmdSetColor,
    ANSICmdPositionCursor,
    ANSICmdDisplayAttributesOff,
    ANSICmdDisplayInverseVideoOn,
    ANSICmdDisplayInverseVideoOff,
    ANSICmdDisplayBlinkOn,
    ANSICmdDisplayBlinkOff,
    ANSICmdDisplayBoldOn,
    ANSICmdDisplayBoldOff
} ANSI_CMD, *PANSI_CMD;

//
// HeadlessCmdSetColor:
//   Input structure: FgColor, BkgColor: Both colors set according to ANSI terminal 
//                       definitons. 
//
typedef struct _ANSI_CMD_SET_COLOR {
    ULONG FgColor;
    ULONG BkgColor;
} ANSI_CMD_SET_COLOR, *PANSI_CMD_SET_COLOR;

//
// ANSICmdPositionCursor:
//   Input structure: Row, Column: Both values are zero base, with upper left being (1, 1).
//
typedef struct _ANSI_CMD_POSITION_CURSOR {
    ULONG X;
    ULONG Y;
} ANSI_CMD_POSITION_CURSOR, *PANSI_CMD_POSITION_CURSOR;

NTSTATUS
VTUTF8ChannelProcessAttributes(
    IN PSAC_CHANNEL Channel,
    IN UCHAR        Attributes
    );

NTSTATUS
VTUTF8ChannelAnsiDispatch(
    IN  PSAC_CHANNEL    Channel,
    IN  ANSI_CMD        Command,
    IN  PVOID           InputBuffer         OPTIONAL,
    IN  SIZE_T          InputBufferSize     OPTIONAL
    );

VOID
VTUTF8ChannelSetIBufferIndex(
    IN PSAC_CHANNEL     Channel,
    IN ULONG            IBufferIndex
    );

ULONG
VTUTF8ChannelGetIBufferIndex(
    IN  PSAC_CHANNEL    Channel
    );

NTSTATUS
VTUTF8ChannelOInit(
    PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    Initialize the Output buffer

Arguments:
    
    Channel - the channel to initialize

Return Value:

    Status

--*/
{
    ULONG   R;
    ULONG   C;
    PSAC_SCREEN_BUFFER  ScreenBuffer;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    //
    // initialize the screen buffer
    //
    Channel->CurrentAttr    = ANSI_TERM_DEFAULT_ATTRIBUTES;
    Channel->CurrentBg      = ANSI_TERM_DEFAULT_BKGD_COLOR;
    Channel->CurrentFg      = ANSI_TERM_DEFAULT_TEXT_COLOR;

    //
    // Get the output buffer
    //
    ScreenBuffer = (PSAC_SCREEN_BUFFER)Channel->OBuffer;

    //
    // Initialize all the vtutf8 elements to the default state
    //
    for (R = 0; R < SAC_VTUTF8_ROW_HEIGHT; R++) {

        for (C = 0; C < SAC_VTUTF8_COL_WIDTH; C++) {

            ScreenBuffer->Element[R][C].Value = ' ';
            ScreenBuffer->Element[R][C].BgColor = ANSI_TERM_DEFAULT_BKGD_COLOR;
            ScreenBuffer->Element[R][C].FgColor = ANSI_TERM_DEFAULT_TEXT_COLOR;

        }

    }

    return STATUS_SUCCESS;
}

NTSTATUS
VTUTF8ChannelCreate(
    OUT PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine allocates a channel and returns a pointer to it.
    
Arguments:

    Channel         - The resulting channel.
    
    OpenChannelCmd  - All the parameters for the new channel
    
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);
        
    do {

        //
        // Allocate our output buffer
        //
        Channel->OBuffer = ALLOCATE_POOL(sizeof(SAC_SCREEN_BUFFER), GENERAL_POOL_TAG);
        ASSERT(Channel->OBuffer);
        if (!Channel->OBuffer) {
            Status = STATUS_NO_MEMORY;
            break;
        }

        //
        // Allocate our input buffer
        //
        Channel->IBuffer = (PUCHAR)ALLOCATE_POOL(SAC_RAW_OBUFFER_SIZE, GENERAL_POOL_TAG);
        ASSERT(Channel->IBuffer);
        if (!Channel->IBuffer) {
            Status = STATUS_NO_MEMORY;
            break;
        }

        //
        // Initialize the output buffer
        //
        Status = VTUTF8ChannelOInit(Channel);
        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Neither buffer has any new data
        //
        ChannelSetIBufferHasNewData(Channel, FALSE);
        ChannelSetOBufferHasNewData(Channel, FALSE);

    } while ( FALSE );

    //
    // Cleanup if necessary
    //
    if (!NT_SUCCESS(Status)) {
        if (Channel->OBuffer) {
            FREE_POOL(&Channel->OBuffer);
        }
        if (Channel->IBuffer) {
            FREE_POOL(&Channel->IBuffer);
        }
    }

    return Status;
}

NTSTATUS
VTUTF8ChannelDestroy(
    IN OUT PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine closes a channel.
    
Arguments:

    Channel - The channel to be closed
    
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    NTSTATUS    Status;
    
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    //
    // Free the dynamically allocated memory
    //

    if (Channel->OBuffer) {
        FREE_POOL(&(Channel->OBuffer));
        Channel->OBuffer = NULL;
    }

    if (Channel->IBuffer) {
        FREE_POOL(&(Channel->IBuffer));
        Channel->IBuffer = NULL;
    }

    //
    // Now that we've done our channel specific destroy, 
    // Call the general channel destroy
    //
    Status = ChannelDestroy(Channel);

    return  STATUS_SUCCESS;
}

NTSTATUS
VTUTF8ChannelORead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount
    )
{

    UNREFERENCED_PARAMETER(Channel);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(ByteCount);
    UNREFERENCED_PARAMETER(BufferSize);

    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
VTUTF8ChannelOEcho(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      String,
    IN ULONG        Size
    )
/*++

Routine Description:

    This routine puts the string out the ansi port.
    
Arguments:

    Channel - Previously created channel.
    String  - Output string.
    Length  - The # of String bytes to process
    
Return Value:

    STATUS_SUCCESS if successful, otherwise status

--*/
{
    NTSTATUS    Status;
    BOOLEAN     bStatus;
    ULONG       Length;
    ULONG       i;
    ULONG       k;
    ULONG       j;
    ULONG       TranslatedCount;
    ULONG       UTF8TranslationSize;
    PCWSTR      pwch;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(String, STATUS_INVALID_PARAMETER_2);
    
    //
    // Note: Simply echoing out the String buffer will ONLY work
    //       reliably if our VTUTF8 emulation does EXACTLY the same emulation
    //       as the remote client.  If our interpretation of the incoming stream
    //       differs, there will be a discrepency between the two screen images.
    //       For instance, if we do line wrapping (col becomes 0, and row++) and 
    //       the remote client does not, echoing of String will fail to reflect 
    //       the line wrapping end users (client) will only see the correct (our) 
    //       representation of our VTUTF8 screen when the switch away and come back, 
    //       thereby causing a screen redraw
    //
    //       One possible way around this problem would be to put 'dirty' bits into our vtutf8 screen
    //       buffer for each cell.  At this point, we could scan the buffer for changes
    //       and send the appropriate updates rather than just blindly echoing String.
    //

    //
    // Determine the total # of WCHARs to process
    //
    Length = Size / sizeof(WCHAR);

    //
    // Do nothing if there is nothing to do
    //
    if (Length == 0) {
        return STATUS_SUCCESS;
    }

    //
    // Point to the beginning of the string
    //
    pwch = (PCWSTR)String;

    //
    // Default: we were successful
    //
    Status = STATUS_SUCCESS;

    //
    // Divide the incoming buffer into blocks of length
    // MAX_UTF8_ENCODE_BLOCK_LENGTH.  
    //
    do {

        //
        // Determine the remainder 
        //
        k = Length % MAX_UTF8_ENCODE_BLOCK_LENGTH;

        if (k > 0) {
            
            //
            // Translate the first k characters
            //
            bStatus = SacTranslateUnicodeToUtf8(
                pwch,
                k,
                Utf8ConversionBuffer,
                Utf8ConversionBufferSize,
                &UTF8TranslationSize,
                &TranslatedCount
                );

            //
            // If this assert hits, it is probably caused by
            // a premature NULL termination in the incoming string
            //
            ASSERT(k == TranslatedCount);

            if (!bStatus) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Send the UTF8 encoded characters
            //
            Status = IoMgrWriteData(
                Channel,
                (PUCHAR)Utf8ConversionBuffer,
                UTF8TranslationSize
                );

            if (!NT_SUCCESS(Status)) {
                break;
            }

            //
            // Adjust the pwch to account for the sent length
            //
            pwch += k;

        }
        
        //
        // Determine the # of blocks we can process
        //
        j = Length / MAX_UTF8_ENCODE_BLOCK_LENGTH;

        //
        // Translate each WCHAR to UTF8 individually.  This way,
        // no matter how big the String is, we don't run into
        // buffer size problems (it just might take a while).
        //
        for (i = 0; i < j; i++) {

            //
            // Encode the next block
            //
            bStatus = SacTranslateUnicodeToUtf8(
                pwch,
                MAX_UTF8_ENCODE_BLOCK_LENGTH,
                Utf8ConversionBuffer,
                Utf8ConversionBufferSize,
                &UTF8TranslationSize,
                &TranslatedCount
                );

            //
            // If this assert hits, it is probably caused by
            // a premature NULL termination in the incoming string
            //
            ASSERT(MAX_UTF8_ENCODE_BLOCK_LENGTH == TranslatedCount);
            ASSERT(UTF8TranslationSize > 0);

            if (! bStatus) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Adjust the pwch to account for the sent length
            //
            pwch += MAX_UTF8_ENCODE_BLOCK_LENGTH;

            //
            // Send the UTF8 encoded characters
            //
            Status = IoMgrWriteData(
                Channel,
                (PUCHAR)Utf8ConversionBuffer,
                UTF8TranslationSize
                );

            if (! NT_SUCCESS(Status)) {
                break;
            }

        }

    } while ( FALSE );
    
    //
    // Validate that the pwch pointer stopped at the end of the buffer
    //
    ASSERT(pwch == (PWSTR)(String + Size));
    
    //
    // If we were successful, flush the channel's data in the iomgr 
    //
    if (NT_SUCCESS(Status)) {
        Status = IoMgrFlushData(Channel);
    }
    
    return Status;
}


NTSTATUS
VTUTF8ChannelOWrite(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      String,
    IN ULONG        Size
    )
/*++

Routine Description:

    This routine takes a string and prints it to the specified channel.  If the channel
    is the currently active channel, it puts the string out the ansi port as well.
    
    Note: Current Channel lock must be held by caller            
                
Arguments:

    Channel - Previously created channel.
    String  - Output string.
    Length  - The # of String bytes to process
    
Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    NTSTATUS    Status;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(String, STATUS_INVALID_PARAMETER_2);

    do {
        
        //
        // call the appropriate "printscreen" depending on the channel type
        // 
        // Note: this may be done more cleanly with function pointers and using
        //       a common function prototype.  The ChannelPrintStringIntoScreenBuffer
        //       function could translate the uchar buffer into a wchar buffer internally
        //
        Status = VTUTF8ChannelOWrite2(
            Channel,
            (PCWSTR)String, 
            Size / sizeof(WCHAR)
            ); 

        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // if the current channel is the active channel and the user has selected
        // to display this channel, relay the output directly to the user
        //
        if (IoMgrIsWriteEnabled(Channel) && ChannelSentToScreen(Channel)){

            Status = VTUTF8ChannelOEcho(
                Channel, 
                String,
                Size
                );

        } else {
                    
            //
            // this is not the current channel, 
            // hence, this channel has new data
            //
            ChannelSetOBufferHasNewData(Channel, TRUE);

        }

    } while ( FALSE );
    
    return Status;
}

NTSTATUS
VTUTF8ChannelOWrite2(
    IN PSAC_CHANNEL Channel,
    IN PCWSTR       String,
    IN ULONG        Length
    )
/*++

Routine Description:

    This routine takes a string and prints it into the screen buffer.  This makes this
    routine, essentially, a VTUTF8 emulator.
    
Arguments:

    Channel - Previously created channel.
    
    String - String to print.

    Length - Length of the string to write

Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    ULONG       i;
    ULONG       Consumed;
    ULONG       R, C;
    PCWSTR      pwch;
    PSAC_SCREEN_BUFFER  ScreenBuffer;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(String, STATUS_INVALID_PARAMETER_2);
    
    ASSERT_CHANNEL_ROW_COL(Channel);
    
    //
    // Get the VTUTF8 Screen Buffer
    //
    ScreenBuffer = (PSAC_SCREEN_BUFFER)Channel->OBuffer;
    
    //
    // Iterate through the string and do an internal vtutf8 emulation,
    // storing the "screen" in the Screen Buffer
    //
    for (i = 0; i < Length; i++) {
    
        //
        // Get the next character to process
        //
        pwch = &(String[i]);

        if (*pwch == '\033') { // escape char
            
            //
            // Note: if the String doesn't contain a complete escape sequence
            //       then when we consume the escape sequence, we'll fail to
            //       recognize the sequence and drop it.  Then, when the rest
            //       of the sequence follows, it will appear as text.
            //
            // FIX: this requires a better overall parsing engine that preserves state...
            //

            Consumed = VTUTF8ChannelConsumeEscapeSequence(Channel, pwch);

            if (Consumed != 0) {

                //
                // Adding Consumed moves us to just after the escape sequence
                // just consumed.  However, we need to subract 1 because we 
                // are about to add one due to the for loop
                //
                i += Consumed - 1;

                continue;

            } else {
                
                //
                // Ignore the escape
                //
                i++;
                
                continue;
            }

        } else {

            //
            // First, if this is a special character, process it.
            //

            
            //
            // Return
            //
            if (*pwch == '\n') {
                Channel->CursorCol = 0;
                continue;
            }

            //
            // Linefeed
            //
            if (*pwch == '\r') {
                
                Channel->CursorRow++;

                //
                // If we scrolled off the bottom, move everything up one line and clear
                // the bottom line.
                //
                if (Channel->CursorRow >= SAC_VTUTF8_ROW_HEIGHT) {

                    for (R = 0; R < SAC_VTUTF8_ROW_HEIGHT - 1; R++) {

                        ASSERT(R+1 < SAC_VTUTF8_ROW_HEIGHT);

                        for (C = 0; C < SAC_VTUTF8_COL_WIDTH; C++) {

                            ScreenBuffer->Element[R][C] = ScreenBuffer->Element[R+1][C];

                        }

                    }

                    ASSERT(R == SAC_VTUTF8_ROW_HEIGHT-1); 

                    for (C = 0; C < SAC_VTUTF8_COL_WIDTH; C++) {
                        RtlZeroMemory(&(ScreenBuffer->Element[R][C]), sizeof(SAC_SCREEN_ELEMENT));
                    }

                    Channel->CursorRow--;
                    
                }

                ASSERT_CHANNEL_ROW_COL(Channel);

                continue;

            }

            //
            // Tab
            //
            if (*pwch == '\t') {

                ASSERT_CHANNEL_ROW_COL(Channel);
                
                C = 4 - Channel->CursorCol % 4;
                for (; C != 0 ; C--) {
                    
                    ASSERT_CHANNEL_ROW_COL(Channel);

                    ScreenBuffer->Element[Channel->CursorRow][Channel->CursorCol].Attr = Channel->CurrentAttr;
                    ScreenBuffer->Element[Channel->CursorRow][Channel->CursorCol].BgColor = Channel->CurrentBg;
                    ScreenBuffer->Element[Channel->CursorRow][Channel->CursorCol].FgColor = Channel->CurrentFg;
                    ScreenBuffer->Element[Channel->CursorRow][Channel->CursorCol].Value = ' ';
                    
                    Channel->CursorCol++;

                    if (Channel->CursorCol >= SAC_VTUTF8_COL_WIDTH) { // no line wrap.
                        Channel->CursorCol = SAC_VTUTF8_COL_WIDTH - 1;
                    }

                }

                ASSERT_CHANNEL_ROW_COL(Channel);
                
                continue;

            }

            //
            // Backspace or delete character
            //
            if ((*pwch == 0x8) || (*pwch == 0x7F)) {
                
                if (Channel->CursorCol > 0) {
                    Channel->CursorCol--;
                }
                
                ASSERT_CHANNEL_ROW_COL(Channel);
                
                continue;
            }

            //
            // We just consume all the rest of non-printable characters.
            //
            if (*pwch < ' ') {
                continue;
            }

            //
            // All normal characters end up here.
            //

            ASSERT_CHANNEL_ROW_COL(Channel);

            ScreenBuffer->Element[Channel->CursorRow][Channel->CursorCol].Attr = Channel->CurrentAttr;
            ScreenBuffer->Element[Channel->CursorRow][Channel->CursorCol].BgColor = Channel->CurrentBg;
            ScreenBuffer->Element[Channel->CursorRow][Channel->CursorCol].FgColor = Channel->CurrentFg;
            ScreenBuffer->Element[Channel->CursorRow][Channel->CursorCol].Value = *pwch;

            Channel->CursorCol++;

            if (Channel->CursorCol == SAC_VTUTF8_COL_WIDTH) { // no line wrap.
                Channel->CursorCol = SAC_VTUTF8_COL_WIDTH - 1;
            }

            ASSERT_CHANNEL_ROW_COL(Channel);
        
        }

    }

    ASSERT_CHANNEL_ROW_COL(Channel);

    return STATUS_SUCCESS;
}

//
// This macro calculates the # of escape sequence characters
//
// Note: the compiler accounts for the fact
//       that _p and _s are PWCHARs, so we don't need to 
//       divide by sizeof(WCHAR).
//
#define CALC_CONSUMED(_p,_s)\
    ((ULONG)((_p) - (_s)) + 1)

ULONG
VTUTF8ChannelConsumeEscapeSequence(
    IN PSAC_CHANNEL Channel,
    IN PCWSTR       String
    )
/*++

Routine Description:

    This routine takes an escape sequence and process it, returning the number of
    character it consumed from the string.  If the escape sequence is not a valid
    vtutf8 sequence, it returns 0.
    
    Note: if the String doesn't contain a complete escape sequence
           then when we consume the escape sequence, we'll fail to
           recognize the sequence and drop it.  Then, when the rest
           of the sequence follows, it will appear as text.
    
    FIX: this requires a better overall parsing engine that preserves state...

Arguments:

    Channel - Previously created channel.
    
    String - Escape sequence.

Return Value:

    Number of characters consumed

--*/
{
    ULONG               i;
    SAC_ESCAPE_CODE     Code;
    PCWSTR              pch;
    ULONG               Consumed;
    ULONG               Param1 = 0;
    ULONG               Param2 = 0;
    ULONG               Param3 = 0;
    PSAC_SCREEN_BUFFER  ScreenBuffer;

    ASSERT(String[0] == '\033');

    //
    // Get the VTUTF8 Screen Buffer
    //
    ScreenBuffer = (PSAC_SCREEN_BUFFER)Channel->OBuffer;
    
    //
    // Check for one of the easy strings first.
    //
    for (i = 0; i < sizeof(SacStaticEscapeStrings)/sizeof(SAC_STATIC_ESCAPE_STRING); i++) {
        
        if (wcsncmp(&(String[1]), 
                    SacStaticEscapeStrings[i].String, 
                    SacStaticEscapeStrings[i].StringLength) == 0) {
            
            //
            // Populate the arguments for the function to process this code
            //
            Code = SacStaticEscapeStrings[i].Code;
            Param1 = 1;
            Param2 = 1;
            Param3 = 1;
            
            //
            // # chars consumed = length of escape string + <esc>
            //
            Consumed = SacStaticEscapeStrings[i].StringLength + 1;
            
            goto ProcessCode;
        }
    
    }

    //
    // Check for escape sequences with parameters.
    //

    if (String[1] != '[') {
        return 0;
    }

    pch = &(String[2]);

    //
    // look for '<esc>[X' codes
    //
    switch (*pch) {
    case 'A':
        Code = CursorUp;
        Consumed = CALC_CONSUMED(pch, String);
        goto ProcessCode;

    case 'B':
        Code = CursorDown;
        Consumed = CALC_CONSUMED(pch, String);
        goto ProcessCode;

    case 'C':
        Code = CursorLeft;
        Consumed = CALC_CONSUMED(pch, String);
        goto ProcessCode;

    case 'D':
        Code = CursorRight;
        Consumed = CALC_CONSUMED(pch, String);
        goto ProcessCode;
    case 'K':
        Code = ClearToEol;
        Consumed = CALC_CONSUMED(pch, String);
        goto ProcessCode;
    }

    //
    // if we made it here, there should be a # next
    //
    if (!VTUTF8ChannelScanForNumber(pch, &Param1)) {
        return 0;
    }

    //
    // Skip past the numbers
    //
    while ((*pch >= '0') && (*pch <= '9')) {
        pch++;
    }

    //
    // Check for set color
    //
    if (*pch == 'm') {
        
        switch (Param1) {
        case 0: 
            Code = AttributesOff;
            break;
        case 1:
            Code = BoldOn;
            break;
        case 5:
            Code = BlinkOn;
            break;
        case 7:
            Code = InverseOn;
            break;
        case 22:
            Code = BoldOff;
            break;
        case 25:
            Code = BlinkOff;
            break;
        case 27:
            Code = InverseOff;
            break;
            
        default:
            
            if (Param1 >= 40 && Param1 <= 47) {
                Code = SetBackgroundColor;
            } else if (Param1 >= 30 && Param1 <= 39) {
                Code = SetForegroundColor;
            } else {

                //
                // This allows us to catch unhandled codes,
                // so we know they need to be supported
                //
                ASSERT(0);
            
                return 0;

            }
        
            break;
        }

        Consumed = CALC_CONSUMED(pch, String);
        
        goto ProcessCode;
    }
    
    if (*pch != ';') {
        return 0;
    }

    pch++;

    if (!VTUTF8ChannelScanForNumber(pch, &Param2)) {
        return 0;
    }

    //
    // Skip past the numbers
    //
    while ((*pch >= '0') && (*pch <= '9')) {
        pch++;
    }
    
    //
    // Check for set color
    //
    if (*pch == 'm') {
        Code = SetColor;
        Consumed = CALC_CONSUMED(pch, String);
        goto ProcessCode;
    }

    //
    // Check for set cursor position
    //
    if (*pch == 'H') {
        Code = SetCursorPosition;
        Consumed = CALC_CONSUMED(pch, String);
        goto ProcessCode;
    }

    if (*pch != ';') {
        return 0;
    }

    pch++;

    switch (*pch) {
    case 'H':
    case 'f':
        Code = SetCursorPosition;
        Consumed = CALC_CONSUMED(pch, String);
        goto ProcessCode;

    case 'r':
        Code = SetScrollRegion;
        Consumed = CALC_CONSUMED(pch, String);
        goto ProcessCode;

    }

    if (!VTUTF8ChannelScanForNumber(pch, &Param3)) {
        return 0;
    }

    //
    // Skip past the numbers
    //
    while ((*pch >= '0') && (*pch <= '9')) {
        pch++;
    }

    //
    // Check for set color and attribute
    //
    if (*pch == 'm') {
        Code = SetColorAndAttribute;
        Consumed = CALC_CONSUMED(pch, String);
        goto ProcessCode;
    }
    
    return 0;

ProcessCode:

    ASSERT_CHANNEL_ROW_COL(Channel);
    
    switch (Code) {
    case CursorUp:
        if (Channel->CursorRow >= Param1) {
            Channel->CursorRow = (UCHAR)(Channel->CursorRow - (UCHAR)Param1);
        } else {
            Channel->CursorRow = 0;
        }
        ASSERT_CHANNEL_ROW_COL(Channel);
        break;

    case CursorDown:
        if ((Channel->CursorRow + Param1) < SAC_VTUTF8_ROW_HEIGHT) {
            Channel->CursorRow = (UCHAR)(Channel->CursorRow + (UCHAR)Param1);
        } else {
            Channel->CursorRow = SAC_VTUTF8_ROW_HEIGHT - 1;
        }
        ASSERT_CHANNEL_ROW_COL(Channel);
        break;

    case CursorLeft:
        if (Channel->CursorCol >= Param1) {
            Channel->CursorCol = (UCHAR)(Channel->CursorCol - (UCHAR)Param1);
        } else {
            Channel->CursorCol = 0;
        }
        ASSERT_CHANNEL_ROW_COL(Channel);
        break;

    case CursorRight:
        if ((Channel->CursorCol + Param1) < SAC_VTUTF8_COL_WIDTH) {
            Channel->CursorCol = (UCHAR)(Channel->CursorCol + (UCHAR)Param1);
        } else {
            Channel->CursorCol = SAC_VTUTF8_COL_WIDTH - 1;
        }
        ASSERT_CHANNEL_ROW_COL(Channel);
        break;

    case AttributesOff:
        //
        // Reset to default attributes and colors
        //
        Channel->CurrentAttr    = ANSI_TERM_DEFAULT_ATTRIBUTES;
        Channel->CurrentBg      = ANSI_TERM_DEFAULT_BKGD_COLOR;
        Channel->CurrentFg      = ANSI_TERM_DEFAULT_TEXT_COLOR;
        break;

    case BlinkOn:
        Channel->CurrentAttr |= VTUTF8_ATTRIBUTE_BLINK;
        break;
    case BlinkOff:
        Channel->CurrentAttr &= ~VTUTF8_ATTRIBUTE_BLINK;
        break;
    
    case BoldOn:
        Channel->CurrentAttr |= VTUTF8_ATTRIBUTE_BOLD;
        break;
    case BoldOff:
        Channel->CurrentAttr &= ~VTUTF8_ATTRIBUTE_BOLD;
        break;
    
    case InverseOn:
        Channel->CurrentAttr |= VTUTF8_ATTRIBUTE_INVERSE;
        break;
    case InverseOff:
        Channel->CurrentAttr &= ~VTUTF8_ATTRIBUTE_INVERSE;
        break;
    
    case BackTab:
        break;
        
    case ClearToEol:
        Param1 = Channel->CursorCol;
        Param2 = SAC_VTUTF8_COL_WIDTH;
        goto DoClearLine;

    case ClearToBol:
        Param1 = 0;
        Param2 = Channel->CursorCol + 1;
        goto DoClearLine;

    case ClearLine:
        Param1 = 0;
        Param2 = SAC_VTUTF8_COL_WIDTH;

DoClearLine:
        
        for (i = Param1; i < Param2; i++) {
            ScreenBuffer->Element[Channel->CursorRow][i].Attr = Channel->CurrentAttr;
            ScreenBuffer->Element[Channel->CursorRow][i].FgColor = Channel->CurrentFg;
            ScreenBuffer->Element[Channel->CursorRow][i].BgColor = Channel->CurrentBg;
            ScreenBuffer->Element[Channel->CursorRow][i].Value = ' ';
        }
        break;

    case ClearToEos:

        //
        // Start with clearing this line from the current cursor position
        //
        Param3 = Channel->CursorCol;
        
        for (i = Channel->CursorRow; i < SAC_VTUTF8_ROW_HEIGHT; i++) {

            for (Param1 = Param3; Param1 < SAC_VTUTF8_COL_WIDTH; Param1++) {
                
                ScreenBuffer->Element[i][Param1].Attr = Channel->CurrentAttr;
                ScreenBuffer->Element[i][Param1].FgColor = Channel->CurrentFg;
                ScreenBuffer->Element[i][Param1].BgColor = Channel->CurrentBg;
                ScreenBuffer->Element[i][Param1].Value = ' ';
            
            }

            //
            // Then clear the entire line for all other lines
            //
            Param3 = 0;

        }
        break;

    case ClearToBos:

        //
        // Start by clearing all of the line
        //
        Param3 = SAC_VTUTF8_COL_WIDTH;
        
        for (i = 0; i <= Channel->CursorRow; i++) {

            if (i == Channel->CursorRow) {
                Param3 = Channel->CursorCol;
            }

            for (Param1 = 0; Param1 < Param3; Param1++) {
                ScreenBuffer->Element[i][Param1].Attr = Channel->CurrentAttr;
                ScreenBuffer->Element[i][Param1].FgColor = Channel->CurrentFg;
                ScreenBuffer->Element[i][Param1].BgColor = Channel->CurrentBg;
                ScreenBuffer->Element[i][Param1].Value = ' ';
            }
        }
        break;

    case ClearScreen:

        for (i = 0; i < SAC_VTUTF8_ROW_HEIGHT; i++) {
            for (Param1 = 0; Param1 < SAC_VTUTF8_COL_WIDTH; Param1++) {
                ScreenBuffer->Element[i][Param1].Attr = Channel->CurrentAttr;
                ScreenBuffer->Element[i][Param1].FgColor = Channel->CurrentFg;
                ScreenBuffer->Element[i][Param1].BgColor = Channel->CurrentBg;
                ScreenBuffer->Element[i][Param1].Value = ' ';
            }
        }
        break;

    case SetCursorPosition:

        Channel->CursorRow = (UCHAR)Param1;  // I adjust below for 0-based array - don't subtract 1 here.
        Channel->CursorCol = (UCHAR)Param2;  // I adjust below for 0-based array - don't subtract 1 here.

        if (Channel->CursorRow > SAC_VTUTF8_ROW_HEIGHT) {
            Channel->CursorRow = SAC_VTUTF8_ROW_HEIGHT;
        }

        if (Channel->CursorRow >= 1) {
            Channel->CursorRow--;
        }
        
        if (Channel->CursorCol > SAC_VTUTF8_COL_WIDTH) {
            Channel->CursorCol = SAC_VTUTF8_COL_WIDTH;
        }

        if (Channel->CursorCol >= 1) {
            Channel->CursorCol--;
        }

        ASSERT_CHANNEL_ROW_COL(Channel);

        break;

    case SetColor:
        Channel->CurrentFg = (UCHAR)Param1;
        Channel->CurrentBg = (UCHAR)Param2;
        break;

    case SetBackgroundColor:
        Channel->CurrentBg = (UCHAR)Param1;
        break;
    
    case SetForegroundColor:
        Channel->CurrentFg = (UCHAR)Param1;
        break;
    
    case SetColorAndAttribute:
        Channel->CurrentAttr = (UCHAR)Param1;
        Channel->CurrentFg = (UCHAR)Param2;
        Channel->CurrentBg = (UCHAR)Param3;
        break;
    }

    return Consumed;
}

NTSTATUS
VTUTF8ChannelOFlush(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    Send the contents of the screen buffer to the remote terminal.  This 
    is done by sending VTUTF8 codes to recreate the screen buffer on the
    remote terminal.    
    
Arguments:

    Channel - Previously created channel.

Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    NTSTATUS    Status;
    BOOLEAN     bStatus;
    PWCHAR      LocalBuffer;
    UCHAR       CurrentAttr;
    UCHAR       CurrentFg;
    UCHAR       CurrentBg;
    ULONG       R, C;
    BOOLEAN     RepositionCursor;
    ANSI_CMD_SET_COLOR          SetColor;
    ANSI_CMD_POSITION_CURSOR    SetCursor;
    PSAC_SCREEN_BUFFER  ScreenBuffer;
    ULONG       TranslatedCount;
    ULONG       UTF8TranslationSize;

    ASSERT_STATUS(Channel,  STATUS_INVALID_PARAMETER);

    //
    // Get the VTUTF8 Screen Buffer
    //
    ScreenBuffer = (PSAC_SCREEN_BUFFER)Channel->OBuffer;

//
// Cursor offset on the screen
//
#define CURSOR_ROW_OFFSET   0
#define CURSOR_COL_OFFSET   0

    //
    // Allocate the local buffer
    //
    LocalBuffer = ALLOCATE_POOL(20*sizeof(WCHAR), GENERAL_POOL_TAG);
    if (!LocalBuffer) {
        Status = STATUS_NO_MEMORY;
        goto VTUTF8ChannelOFlushCleanup;
    }

    //
    // Clear the terminal screen.
    //
    Status = VTUTF8ChannelAnsiDispatch(
        Channel,
        ANSICmdClearDisplay,
        NULL,
        0
        );
    if (! NT_SUCCESS(Status)) {
        goto VTUTF8ChannelOFlushCleanup;
    }

    //
    // Set the cursor to the top left
    //
    SetCursor.Y = CURSOR_ROW_OFFSET;
    SetCursor.X = CURSOR_COL_OFFSET;
    
    Status = VTUTF8ChannelAnsiDispatch(
        Channel,
        ANSICmdPositionCursor,
        &SetCursor,
        sizeof(ANSI_CMD_POSITION_CURSOR)
        );
    if (! NT_SUCCESS(Status)) {
        goto VTUTF8ChannelOFlushCleanup;
    }

    //
    // Reset the terminal attributes to defaults
    //
    Status = VTUTF8ChannelAnsiDispatch(
        Channel,
        ANSICmdDisplayAttributesOff,
        NULL,
        0
        );
    
    if (! NT_SUCCESS(Status)) {
        goto VTUTF8ChannelOFlushCleanup;
    }

    //
    // Send starting attributes
    //
    CurrentAttr = Channel->CurrentAttr;
    Status = VTUTF8ChannelProcessAttributes(
        Channel,
        CurrentAttr
        );
    if (! NT_SUCCESS(Status)) {
        goto VTUTF8ChannelOFlushCleanup;
    }

    //
    // Send starting colors.
    //
    CurrentBg = Channel->CurrentBg;
    CurrentFg = Channel->CurrentFg;
    SetColor.BkgColor = CurrentBg;
    SetColor.FgColor = CurrentFg;
    
    Status = VTUTF8ChannelAnsiDispatch(
        Channel,
        ANSICmdSetColor,
        &SetColor,
        sizeof(ANSI_CMD_SET_COLOR)
        );
    if (! NT_SUCCESS(Status)) {
        goto VTUTF8ChannelOFlushCleanup;
    }

    //
    // default: we don't need to reposition the cursor
    //
    RepositionCursor = FALSE;

    //
    // Send each character
    //
    for (R = 0; R < SAC_VTUTF8_ROW_HEIGHT; R++) {

        for (C = 0; C < SAC_VTUTF8_COL_WIDTH; C++) {

            if ((ScreenBuffer->Element[R][C].BgColor != CurrentBg) ||
                (ScreenBuffer->Element[R][C].FgColor != CurrentFg)) {

                //
                // Change screen colors as necessary
                //
                if (RepositionCursor) {

                    SetCursor.Y = R + CURSOR_ROW_OFFSET;
                    SetCursor.X = C + CURSOR_COL_OFFSET;
                    
                    Status = VTUTF8ChannelAnsiDispatch(
                        Channel,
                        ANSICmdPositionCursor,
                        &SetCursor,
                        sizeof(ANSI_CMD_POSITION_CURSOR)
                        );
                    if (! NT_SUCCESS(Status)) {
                        goto VTUTF8ChannelOFlushCleanup;
                    }

                    RepositionCursor = FALSE;

                }
                
                CurrentBg = ScreenBuffer->Element[R][C].BgColor;
                CurrentFg = ScreenBuffer->Element[R][C].FgColor;
                SetColor.BkgColor = CurrentBg;
                SetColor.FgColor = CurrentFg;
                
                Status = VTUTF8ChannelAnsiDispatch(
                    Channel,
                    ANSICmdSetColor,
                    &SetColor,
                    sizeof(ANSI_CMD_SET_COLOR)
                    );
                if (! NT_SUCCESS(Status)) {
                    goto VTUTF8ChannelOFlushCleanup;
                }
            }

            if (ScreenBuffer->Element[R][C].Attr != CurrentAttr) {

                //
                // Change attribute as necessary
                //
                if (RepositionCursor) {

                    SetCursor.Y = R + CURSOR_ROW_OFFSET;
                    SetCursor.X = C + CURSOR_COL_OFFSET;
                    
                    Status = VTUTF8ChannelAnsiDispatch(
                        Channel,
                        ANSICmdPositionCursor,
                        &SetCursor,
                        sizeof(ANSI_CMD_POSITION_CURSOR)
                        );
                    if (! NT_SUCCESS(Status)) {
                        goto VTUTF8ChannelOFlushCleanup;
                    }

                    RepositionCursor = FALSE;

                }
                
                CurrentAttr = ScreenBuffer->Element[R][C].Attr;
                
                Status = VTUTF8ChannelProcessAttributes(
                    Channel,
                    CurrentAttr
                    );
                
                if (! NT_SUCCESS(Status)) {
                    goto VTUTF8ChannelOFlushCleanup;
                }
            
            }

            //
            // Send the character.  Note: we can optimize the not-sending of 
            // space characters, if the clear screen was in the same 
            // color as the current color.
            //

#if 0
            if ((ScreenBuffer->Element[R][C].Value != ' ') ||
                (CurrentAttr != 0) ||
                (CurrentBg != ANSI_TERM_DEFAULT_BKGD_COLOR) ||
                (CurrentFg != ANSI_TERM_DEFAULT_TEXT_COLOR)) {
#endif
                {
                    if (RepositionCursor) {

                        SetCursor.Y = R + CURSOR_ROW_OFFSET;
                        SetCursor.X = C + CURSOR_COL_OFFSET;

                        Status = VTUTF8ChannelAnsiDispatch(
                            Channel,
                            ANSICmdPositionCursor,
                            &SetCursor,
                            sizeof(ANSI_CMD_POSITION_CURSOR)
                            );
                        if (! NT_SUCCESS(Status)) {
                            goto VTUTF8ChannelOFlushCleanup;
                        }

                        RepositionCursor = FALSE;

                    }

                    LocalBuffer[0] = ScreenBuffer->Element[R][C].Value;
                    LocalBuffer[1] = UNICODE_NULL;

                    bStatus = SacTranslateUnicodeToUtf8(
                        LocalBuffer,
                        1,
                        Utf8ConversionBuffer,
                        Utf8ConversionBufferSize,
                        &UTF8TranslationSize,
                        &TranslatedCount
                        );
                    if (! bStatus) {
                        Status = STATUS_UNSUCCESSFUL;
                        goto VTUTF8ChannelOFlushCleanup;
                    }

                    //
                    // If the UTF8 encoded string is non-empty, send it
                    //
                    if (UTF8TranslationSize > 0) {

                        Status = IoMgrWriteData(
                            Channel,
                            (PUCHAR)Utf8ConversionBuffer,
                            UTF8TranslationSize
                            );

                        if (! NT_SUCCESS(Status)) {
                            goto VTUTF8ChannelOFlushCleanup;
                        }
                    }
                }

#if 0
            } else {

                RepositionCursor = TRUE;

            }
#endif
        }

        //
        // Position the cursor on the new row
        //
        RepositionCursor = TRUE;

    }

    //
    // Position cursor
    //
    SetCursor.Y = Channel->CursorRow + CURSOR_ROW_OFFSET;
    SetCursor.X = Channel->CursorCol + CURSOR_COL_OFFSET;
    
    Status = VTUTF8ChannelAnsiDispatch(
        Channel,
        ANSICmdPositionCursor,
        &SetCursor,
        sizeof(ANSI_CMD_POSITION_CURSOR)
        );
    if (! NT_SUCCESS(Status)) {
        goto VTUTF8ChannelOFlushCleanup;
    }

    //
    // Send current attributes
    //
    Status = VTUTF8ChannelProcessAttributes(
        Channel,
        Channel->CurrentAttr
        );
    if (! NT_SUCCESS(Status)) {
        goto VTUTF8ChannelOFlushCleanup;
    }
    
    //
    // Send current colors.
    //
    SetColor.BkgColor = Channel->CurrentBg;
    SetColor.FgColor = Channel->CurrentFg;
    
    Status = VTUTF8ChannelAnsiDispatch(
        Channel,
        ANSICmdSetColor,
        &SetColor,
        sizeof(ANSI_CMD_SET_COLOR)
        );
    if (! NT_SUCCESS(Status)) {
        goto VTUTF8ChannelOFlushCleanup;
    }

VTUTF8ChannelOFlushCleanup:

    //
    // If we were successful, flush the channel's data in the iomgr 
    //
    if (NT_SUCCESS(Status)) {
        Status = IoMgrFlushData(Channel);
    }

    //
    // Free local resources
    //
    if (LocalBuffer) {
        FREE_POOL(&LocalBuffer);
    }

    //
    // If we have successfully flushed the obuffer,
    // then we no longer have any new data
    //
    if (NT_SUCCESS(Status)) {
                
        ChannelSetOBufferHasNewData(Channel, FALSE);

    }
    
    return Status;
}

NTSTATUS
VTUTF8ChannelIWrite(
    IN PSAC_CHANNEL Channel,
    IN PCUCHAR      Buffer,
    IN ULONG        BufferSize
    )
/*++

Routine Description:

    This routine takes a single character and adds it to the buffered input for this channel.
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - Incoming buffer of UCHARs   
    BufferSize  - Incoming buffer size

Return Value:

    STATUS_SUCCESS if successful, else the appropriate error code.

--*/
{
    NTSTATUS    Status;
    BOOLEAN     haveNewChar;
    ULONG       i;
    BOOLEAN     IBufferStatus;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    ASSERT_STATUS(Buffer, STATUS_INVALID_PARAMETER_2);
    ASSERT_STATUS(BufferSize > 0, STATUS_INVALID_BUFFER_SIZE);

    //
    // Make sure we aren't full
    //
    Status = VTUTF8ChannelIBufferIsFull(
        Channel,
        &IBufferStatus
        );

    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // If there is no more room, then fail
    //
    if (IBufferStatus == TRUE) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // make sure there is enough room for the buffer
    //
    // Note: this prevents us from writing a portion of the buffer
    //       and then failing, leaving the caller in the state where
    //       it doesn't know how much of the buffer was written.
    //
    if ((SAC_VTUTF8_IBUFFER_SIZE - VTUTF8ChannelGetIBufferIndex(Channel)) < BufferSize) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // default: we succeeded
    //
    Status = STATUS_SUCCESS;

    for (i = 0; i < BufferSize; i++) {
    
        //
        // VTUTF8 channels receive UTF8 encoded Unicode, so
        // translate the UTF8 byte by byte into Unicode
        // as it's received.  Only delcare that we have a new
        // Unicode character if the a complete tranlsation
        // from UTF8 --> Unicode took place.
        //
    
        haveNewChar = SacTranslateUtf8ToUnicode(
            Buffer[i],
            IncomingUtf8ConversionBuffer,
            &IncomingUnicodeValue
            );
        
        //
        // if a completed Unicode value was assembled, then we have a new character
        //
        if (haveNewChar) {
            
            PWCHAR  pwch;

            pwch = (PWCHAR)&(Channel->IBuffer[VTUTF8ChannelGetIBufferIndex(Channel)]);
            *pwch = IncomingUnicodeValue;
        
            //
            // update the buffer index
            //
            VTUTF8ChannelSetIBufferIndex(
                Channel,
                VTUTF8ChannelGetIBufferIndex(Channel) + sizeof(WCHAR)/sizeof(UCHAR)
                );
        
        }
        
    }

    //
    // Fire the Has New Data event if specified
    //
    if (Channel->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) {

        ASSERT(Channel->HasNewDataEvent);
        ASSERT(Channel->HasNewDataEventObjectBody);
        ASSERT(Channel->HasNewDataEventWaitObjectBody);

        KeSetEvent(
            Channel->HasNewDataEventWaitObjectBody,
            EVENT_INCREMENT,
            FALSE
            );

    }

    return STATUS_SUCCESS;
}

NTSTATUS
VTUTF8ChannelIRead(
    IN  PSAC_CHANNEL Channel,
    IN  PUCHAR       Buffer,
    IN  ULONG        BufferSize,
    OUT PULONG       ByteCount   
    )
/*++

Routine Description:

    This routine takes the first character in the input buffer, removes and returns it.  If 
    there is none, it returns 0x0.
    
Arguments:

    Channel     - Previously created channel.
    Buffer      - The buffer to read into
    BufferSize  - The size of the buffer 
    ByteCount   - The # of bytes read
    
Return Value:

    Status

--*/
{
    ULONG   CopyChars;
    ULONG   CopySize;

    //
    // initialize
    //
    CopyChars = 0;
    CopySize = 0;

    //
    // Default: no bytes were read
    //
    *ByteCount = 0;

    //
    // Bail if there is no new data
    //
    if (Channel->IBufferLength(Channel) == 0) {
        
        ASSERT(ChannelHasNewIBufferData(Channel) == FALSE);

        return STATUS_SUCCESS;

    }

    //
    // Caclulate the largest buffer size we can use (and need), and then calculate
    // the number of characters this refers to.
    //
    CopySize    = Channel->IBufferLength(Channel) * sizeof(WCHAR);
    CopySize    = CopySize > BufferSize ? BufferSize : CopySize;
    CopyChars   = CopySize / sizeof(WCHAR);
    
    //
    // recalc size in case there was rounding when calculating CopyChars
    //
    CopySize    = CopyChars * sizeof(WCHAR); 

    //
    // sanity check the copy size
    //
    ASSERT(CopyChars <= Channel->IBufferLength(Channel));

    //
    // Copy as much as we can from the ibuffer to the out-going buffer
    //
    RtlCopyMemory(Buffer, Channel->IBuffer, CopySize);
    
    //
    // Update the buffer index to account for the size we just copied
    //
    VTUTF8ChannelSetIBufferIndex(
        Channel, 
        VTUTF8ChannelGetIBufferIndex(Channel) - CopySize
        );
    
    //
    // If there is remaining data left in the Channel input buffer, 
    // shift it to the beginning
    //
    if (Channel->IBufferLength(Channel) > 0) {

        RtlMoveMemory(&(Channel->IBuffer[0]), 
                      &(Channel->IBuffer[CopySize]),
                      Channel->IBufferLength(Channel) * sizeof(WCHAR)
                     );

    } 

    //
    // Send back the # of bytes read
    //
    *ByteCount = CopySize;

    return STATUS_SUCCESS;

}


BOOLEAN
VTUTF8ChannelScanForNumber(
    IN  PCWSTR pch,
    OUT PULONG Number
    )
/*++

Routine Description:

    This routine takes a character stream and converts it into an integer.
    
Arguments:

    pch - The character stream.
    
    Number - The equivalent integer.
    
Return Value:

    TRUE, if successful, else FALSE.

--*/
{
    if ((*pch < '0') || (*pch > '9')) {
        return FALSE;
    }

    *Number = 0;
    while ((*pch >= '0') && (*pch <= '9')) {
        *Number = *Number * 10;
        *Number = *Number + (ULONG)(*pch - '0');
        pch++;
    }

    return TRUE;
}

NTSTATUS
VTUTF8ChannelIBufferIsFull(
    IN  PSAC_CHANNEL    Channel,
    OUT BOOLEAN*        BufferStatus
    )
/*++

Routine Description:

    Determine if the IBuffer is full
    
Arguments:

    Channel         - Previously created channel.
    BufferStatus    - on exit, TRUE if the buffer is full, otherwise FALSE
    
Return Value:

    Status

--*/
{
    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    *BufferStatus = (BOOLEAN)(VTUTF8ChannelGetIBufferIndex(Channel) >= (SAC_VTUTF8_IBUFFER_SIZE-1));

    return STATUS_SUCCESS;
}

WCHAR
VTUTF8ChannelIReadLast(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This routine takes the last character in the input buffer, removes and returns it.  If 
    there is none, it returns 0x0.
    
Arguments:

    Channel - Previously created channel.
    
Return Value:

    Last character in the input buffer.

--*/
{
    WCHAR Char;
    PWCHAR pwch;

    ASSERT(Channel);
    
    Char = UNICODE_NULL;

    if (Channel->IBufferLength(Channel) > 0) {
        
        VTUTF8ChannelSetIBufferIndex(
            Channel,
            VTUTF8ChannelGetIBufferIndex(Channel) - sizeof(WCHAR)/sizeof(UCHAR)
            );
        
        pwch = (PWCHAR)&Channel->IBuffer[VTUTF8ChannelGetIBufferIndex(Channel)];
        
        Char = *pwch;
        
        *pwch = UNICODE_NULL;
    
    }

    return Char;
}

ULONG
VTUTF8ChannelIBufferLength(
    IN PSAC_CHANNEL Channel
    )
/*++

Routine Description:

    This routine determines the length of the input buffer, treating the input buffer
    contents as a string
    
Arguments:

    Channel     - Previously created channel.
    
Return Value:

    The length of the current input buffer

--*/
{
    ASSERT(Channel);

    return (VTUTF8ChannelGetIBufferIndex(Channel) / sizeof(WCHAR));
}

NTSTATUS
VTUTF8ChannelAnsiDispatch(
    IN  PSAC_CHANNEL    Channel,
    IN  ANSI_CMD        Command,
    IN  PVOID           InputBuffer         OPTIONAL,
    IN  SIZE_T          InputBufferSize     OPTIONAL
    )
/*++

Routine Description:

    
Arguments:

    Channel - The channel sending this escape sequence    
    Command - The command to execute.
    
Environment:
    
    Status

--*/
{
    NTSTATUS    Status;
    PUCHAR      Tmp;
    PUCHAR      LocalBuffer;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_1);
    
    //
    // default: not using local buffer
    //
    LocalBuffer = NULL;
    Tmp = NULL;

    //
    // Default: we succeeded
    //
    Status = STATUS_SUCCESS;
    
    //
    // Various output commands
    //
    switch (Command) {

    case ANSICmdClearDisplay:
        Tmp = (PUCHAR)"\033[2J";
        break;

    case ANSICmdClearToEndOfDisplay:
        Tmp = (PUCHAR)"\033[0J";
        break;

    case ANSICmdClearToEndOfLine:
        Tmp = (PUCHAR)"\033[0K";
        break;

    case ANSICmdDisplayAttributesOff:
        Tmp = (PUCHAR)"\033[0m";
        break;

    case ANSICmdDisplayInverseVideoOn:
        Tmp = (PUCHAR)"\033[7m";
        break;
    
    case ANSICmdDisplayInverseVideoOff:
        Tmp = (PUCHAR)"\033[27m";
        break;
    
    case ANSICmdDisplayBlinkOn:
        Tmp = (PUCHAR)"\033[5m";
        break;

    case ANSICmdDisplayBlinkOff:
        Tmp = (PUCHAR)"\033[25m";
        break;
    
    case ANSICmdDisplayBoldOn:
        Tmp = (PUCHAR)"\033[1m";
        break;

    case ANSICmdDisplayBoldOff:
        Tmp = (PUCHAR)"\033[22m";
        break;
    
    case ANSICmdSetColor:
    case ANSICmdPositionCursor: {
        
        ULONG   l;

        //
        // allocate tmp buffer
        //
        LocalBuffer = ALLOCATE_POOL(80*sizeof(UCHAR), GENERAL_POOL_TAG);
        ASSERT_STATUS(LocalBuffer, STATUS_NO_MEMORY);
        
        switch (Command) {
        case ANSICmdSetColor:
            
            if ((InputBuffer == NULL) || 
                (InputBufferSize != sizeof(ANSI_CMD_SET_COLOR))) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Assemble set color command
            //
#if 0
            l = sprintf((LPSTR)LocalBuffer, 
                    "\033[%d;%dm", 
                    ((PANSI_CMD_SET_COLOR)InputBuffer)->BkgColor, 
                    ((PANSI_CMD_SET_COLOR)InputBuffer)->FgColor
                   );
#else
            //
            // Break the color commands into to two commands.
            // 
            // Note: we do this because this is much more likely
            //       to be implemented than the compound command.
            //
            l = sprintf((LPSTR)LocalBuffer, 
                    "\033[%dm\033[%dm",
                    ((PANSI_CMD_SET_COLOR)InputBuffer)->BkgColor, 
                    ((PANSI_CMD_SET_COLOR)InputBuffer)->FgColor
                    );
#endif
            ASSERT((l+1)*sizeof(UCHAR) < 80);

            Tmp = &(LocalBuffer[0]);
            break;

        case ANSICmdPositionCursor:

            if ((InputBuffer == NULL) || 
                (InputBufferSize != sizeof(ANSI_CMD_POSITION_CURSOR))) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Assemble position cursor command
            //
            l = sprintf((LPSTR)LocalBuffer, 
                    "\033[%d;%dH", 
                    ((PANSI_CMD_POSITION_CURSOR)InputBuffer)->Y + 1, 
                    ((PANSI_CMD_POSITION_CURSOR)InputBuffer)->X + 1
                   );
            ASSERT((l+1)*sizeof(UCHAR) < 80);

            Tmp = &(LocalBuffer[0]);
            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            ASSERT(0);
            break;
        }

        break;
    }
            
    default:
        
        Status = STATUS_INVALID_PARAMETER;
        
        break;
    
    }

    //
    // Send the data if we were successful
    //
    if (NT_SUCCESS(Status)) {
        
        ASSERT(Tmp);

        if (Tmp) {
            
            Status = IoMgrWriteData(
                Channel,
                Tmp,
                (ULONG)(strlen((const char *)Tmp)*sizeof(UCHAR))
                );
        
        }
        
        //
        // If we were successful, flush the channel's data in the iomgr 
        //
        if (NT_SUCCESS(Status)) {
            Status = IoMgrFlushData(Channel);
        }

    }

    if (LocalBuffer) {
        FREE_POOL(&LocalBuffer);
    }
    
    return Status;
}

NTSTATUS
VTUTF8ChannelProcessAttributes(
    IN PSAC_CHANNEL Channel,
    IN UCHAR        Attributes
    )
/*++

Routine Description:

    
Arguments:

Returns:

--*/
{
    NTSTATUS    Status;
    ANSI_CMD    Cmd;

    ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER);

    do {
        
#if 0
        //
        // Send the attributes off command
        //
        // Note: if this attribute is set,
        //       then we ignore the rest of the
        //       attributes
        //
        if (Attributes == VTUTF8_ATTRIBUTES_OFF) {

            Status = VTUTF8ChannelAnsiDispatch(
                Channel,
                ANSICmdDisplayAttributesOff,
                NULL,
                0
                );

            if (! NT_SUCCESS(Status)) {
                break;
            }

            //
            // There are no more attributes to check
            //
            break;

        }
#endif
        
        //
        // Bold
        //
        Cmd = Attributes & VTUTF8_ATTRIBUTE_BOLD ?
            ANSICmdDisplayBoldOn : 
            ANSICmdDisplayBoldOff;
            
        Status = VTUTF8ChannelAnsiDispatch(
            Channel,
            Cmd,
            NULL,
            0
            );

        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // Blink
        //
        Cmd = Attributes & VTUTF8_ATTRIBUTE_BLINK ?
            ANSICmdDisplayBlinkOn : 
            ANSICmdDisplayBlinkOff;
            
        Status = VTUTF8ChannelAnsiDispatch(
            Channel,
            Cmd,
            NULL,
            0
            );

        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // Inverse video
        //
        Cmd = Attributes & VTUTF8_ATTRIBUTE_INVERSE ?
            ANSICmdDisplayInverseVideoOn : 
            ANSICmdDisplayInverseVideoOff;
            
        Status = VTUTF8ChannelAnsiDispatch(
            Channel,
            Cmd,
            NULL,
            0
            );

        if (! NT_SUCCESS(Status)) {
            break;
        }
        
    } while ( FALSE );

    return Status;

}

ULONG
VTUTF8ChannelGetIBufferIndex(
    IN  PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    Get teh ibuffer index
    
Arguments:

    Channel - the channel to get the ibuffer index from

Environment:
    
    The ibuffer index

--*/
{
    ASSERT(Channel);
    
    //
    // Make sure the ibuffer index is atleast aligned to a WCHAR
    //
    ASSERT((Channel->IBufferIndex % sizeof(WCHAR)) == 0);
    
    //
    // Make sure the ibuffer index is in bounds
    //
    ASSERT(Channel->IBufferIndex < SAC_VTUTF8_IBUFFER_SIZE);
    
    return Channel->IBufferIndex;
}

VOID
VTUTF8ChannelSetIBufferIndex(
    IN PSAC_CHANNEL     Channel,
    IN ULONG            IBufferIndex
    )
/*++

Routine Description:

    Set the ibuffer index
    
Arguments:

    Channel         - the channel to get the ibuffer index from
    IBufferIndex    - the new inbuffer index
                 
Environment:
    
    None

--*/
{

    ASSERT(Channel);
    
    //
    // Make sure the ibuffer index is atleast aligned to a WCHAR
    //
    ASSERT((Channel->IBufferIndex % sizeof(WCHAR)) == 0);
    
    //
    // Make sure the ibuffer index is in bounds
    //
    ASSERT(Channel->IBufferIndex < SAC_VTUTF8_IBUFFER_SIZE);

    //
    // Set the index
    //
    Channel->IBufferIndex = IBufferIndex;

    //
    // Set the has new data flag accordingly
    //
    ChannelSetIBufferHasNewData(
        Channel, 
        Channel->IBufferIndex == 0 ? FALSE : TRUE
        );

    //
    // Additional checking if the index == 0
    //
    if (Channel->IBufferIndex == 0) {
            
        //
        // Clear the Has New Data event if specified
        //
        if (Channel->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) {
    
            ASSERT(Channel->HasNewDataEvent);
            ASSERT(Channel->HasNewDataEventObjectBody);
            ASSERT(Channel->HasNewDataEventWaitObjectBody);
    
            KeClearEvent(Channel->HasNewDataEventWaitObjectBody);
    
        }
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\xmlcmd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cmd.c

Abstract:

    This module contains the routines for handling each command.

Author:

    Sean Selitrennikoff (v-seans) - Dec 2, 1999
    Brian Guarraci (briangu)

Revision History:

--*/

#include "sac.h"
#include <ntddip.h>
#include <ntddtcp.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <stdlib.h>

#include "iomgr.h"

//
// a convenience macro for simplifying the use of the global buffer 
// in a swprintf & xmlmgrsacputstring operations
//
#define GB_SPRINTF(_f,_d)               \
    swprintf(                           \
        (PWSTR)GlobalBuffer,            \
        _f,                             \
        _d                              \
        );                              \
    XmlMgrSacPutString((PWSTR)GlobalBuffer);  \

//
// Forward declarations.
//
NTSTATUS
XmlCmdGetTListInfo(
    OUT PSAC_RSP_TLIST ResponseBuffer,
    IN  LONG ResponseBufferSize,
    OUT PULONG ResponseDataSize
    );

VOID
XmlCmdPrintTListInfo(
    IN PSAC_RSP_TLIST Buffer
    );

VOID
XmlCmdDoGetNetInfo(
    IN BOOLEAN PrintToTerminal
    );
    
VOID
XmlCmdNetAPCRoutine(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
XmlCmdDoHelpCommand(
    VOID
    )

/*++

Routine Description:

    This routine displays the help text on the terminal.

Arguments:

    None.

Return Value:

        None.

--*/
{
    XmlMgrSacPutString(L"<help topic='ALL'>\r\n");
}

VOID
XmlCmdDoKernelLogCommand(
    VOID
    )
{
    HEADLESS_CMD_DISPLAY_LOG Command;
    NTSTATUS    Status;

    Command.Paging = GlobalPagingNeeded;
    
    XmlMgrSacPutString(L"<kernel-log>\r\n");
    
    Status = HeadlessDispatch(
        HeadlessCmdDisplayLog,
        &Command,
        sizeof(HEADLESS_CMD_DISPLAY_LOG),
        NULL,
        NULL
        );
    
    XmlMgrSacPutString(L"</kernel-log>\r\n");
    
    if (! NT_SUCCESS(Status)) {
    
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC TimerDpcRoutine: Exiting.\n"))
            );
    
    }

}


VOID
XmlCmdDoFullInfoCommand(
    VOID
    )

/*++

Routine Description:

    This routine toggles on and off full thread information on tlist.

Arguments:

    None.

Return Value:

        None.

--*/
{
    GlobalDoThreads = (BOOLEAN)!GlobalDoThreads;

    GB_SPRINTF(
        L"<tlist-thread-info status='%s'/>\r\n",
        GlobalDoThreads ? L"on" : L"off"
        );

}

VOID
XmlCmdDoPagingCommand(
    VOID
    )

/*++

Routine Description:

    This routine toggles on and off paging information on tlist.

Arguments:

    None.

Return Value:

        None.

--*/
{
    GlobalPagingNeeded = (BOOLEAN)!GlobalPagingNeeded;
    
    GB_SPRINTF(    
        L"<paging status='%s'/>\r\n",
        GlobalPagingNeeded ? L"on" : L"off"
        );

}

VOID
XmlMgrSacPutSystemTime(
    TIME_FIELDS TimeFields
    )
{
    //
    // Assemble the system time 
    //
    XmlMgrSacPutString(L"<system-time>\r\n");

    GB_SPRINTF( L"<month>%d</month>\r\n", TimeFields.Month );
    GB_SPRINTF( L"<day>%d</day>\r\n", TimeFields.Day );
    GB_SPRINTF( L"<year>%d</year>\r\n", TimeFields.Year );
    GB_SPRINTF( L"<hour>%d</hour>\r\n", TimeFields.Hour );
    GB_SPRINTF( L"<minute>%d</minute>\r\n", TimeFields.Minute );
    GB_SPRINTF( L"<second>%d</second>\r\n", TimeFields.Second );
    GB_SPRINTF( L"<milliseconds>%d</milliseconds>\r\n", TimeFields.Milliseconds );

    XmlMgrSacPutString(L"</system-time>\r\n");

}



VOID
XmlCmdDoSetTimeCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine sets the current system time.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    TIME_FIELDS TimeFields;
    LARGE_INTEGER Time;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Entering.\n")));

    RtlZeroMemory(&TimeFields, sizeof(TIME_FIELDS));

    //
    // Skip the command.
    //
    pch += (sizeof(TIME_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (*pch == '\0') {

        //
        // This is a display time request.
        //
        Status = ZwQuerySystemInformation(SystemTimeOfDayInformation,
                                          &TimeOfDay,
                                          sizeof(TimeOfDay),
                                          NULL
                                         );

        if (!NT_SUCCESS(Status)) {
            GB_SPRINTF(GetMessage( SAC_FAILURE_WITH_ERROR ) , Status);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (2).\n")));
            return;
        }

        RtlTimeToTimeFields(&(TimeOfDay.CurrentTime), &TimeFields);

        XmlMgrSacPutSystemTime(TimeFields);
        
        return;
    }

    pchTmp = pch;
    
    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (3).\n")));
        return;
    }

    //
    // Skip all the numbers.
    //
    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);


    //
    // If there is something other than the divider, it is a mal-formed line.
    //
    if (*pchTmp != '/') {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (4).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Month = (USHORT)(atoi((LPCSTR)pch));

    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (4b).\n")));
        return;
    }

    //
    // Skip all the numbers.
    //
    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    //
    // If there is something other than the divider, it is a mal-formed line.
    //
    if (*pchTmp != '/') {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (5).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Day = (USHORT)(atoi((LPCSTR)pch));

    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (5b).\n")));
        return;
    }

    //
    // Skip all the numbers.
    //
    SKIP_NUMBERS(pchTmp);

    //
    // If there is something other than whitespace, it is a mal-formed line.
    //
    if (!IS_WHITESPACE(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (6).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Year = (USHORT)(atoi((LPCSTR)pch));

    if ((TimeFields.Year < 1980) || (TimeFields.Year > 2099)) {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_DATETIME_LIMITS");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (6b).\n")));
        return;
    }

    pch = pchTmp;

    //
    // Skip to the hours
    //
    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (7).\n")));
        return;
    }

    pch = pchTmp;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != ':') {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (8).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Hour = (USHORT)(atoi((LPCSTR)pch));

    pch = pchTmp;

    //
    // Verify nothing else on the line but numbers
    //
    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (8a).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (8b).\n")));
        return;
    }

    //
    // Get the minutes.
    //
    TimeFields.Minute = (USHORT)(atoi((LPCSTR)pch));

    if (!RtlTimeFieldsToTime(&TimeFields, &Time)) {
        XmlMgrSacPutErrorMessage(L"set-time", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (9).\n")));
        return;
    }

    Status = ZwSetSystemTime(&Time, NULL);

    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessageWithStatus(L"set-time", L"SAC_INVALID_PARAMETER", Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (10).\n")));
        return;
    }

    XmlMgrSacPutSystemTime(TimeFields);
    
    return;
}

VOID
XmlCmdDoSetIpAddressCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine sets the IP address and subnet mask.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    HANDLE Handle;
    HANDLE EventHandle;
    PKEVENT Event;
    ULONG IpAddress;
    ULONG SubIpAddress;
    ULONG SubnetMask;
    ULONG NetworkNumber;
    LARGE_INTEGER TimeOut;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PIP_SET_ADDRESS_REQUEST IpRequest;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Entering.\n")));

    //
    // Skip the command.
    //
    pch += (sizeof(SETIP_COMMAND_STRING) - sizeof(UCHAR));
    
    SKIP_WHITESPACE(pch);

    if (*pch == '\0') {       
        //
        // No other parameters, get the network numbers and their IP addresses.
        //
        XmlCmdDoGetNetInfo( TRUE );
        return;
    }

    pchTmp = pch;

    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (1b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    
    if (!IS_WHITESPACE(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (1c).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    NetworkNumber = atoi((LPCSTR)pch);

    pch = pchTmp;

    //
    // Parse out the IP address.
    //

    //
    // Skip ahead to the divider and make it a \0.
    //
    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (2).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (4).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (4a).\n")));
        return;
    }
    IpAddress = SubIpAddress;

    //
    // Get 2nd part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (4b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (5).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    
    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (5a).\n")));
        return;
    }
    IpAddress |= (SubIpAddress << 8);

    //
    // Get 3rd part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (5b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (6).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    
    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (6a).\n")));
        return;
    }
    IpAddress |= (SubIpAddress << 16);

    //
    // Get 4th part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (6b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);

    if (!IS_WHITESPACE(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (7).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    
    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (7a).\n")));
        return;
    }
    IpAddress |= (SubIpAddress << 24);

    //
    //
    // Now onto the subnet mask.
    //
    //
    //
    // Skip ahead to the divider and make it a \0.
    //

    SKIP_WHITESPACE(pchTmp);

    pch = pchTmp;
    
    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (8).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (9).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (9a).\n")));
        return;
    }
    SubnetMask = SubIpAddress;
    
    //
    // Get 2nd part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (9b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (10).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (10a).\n")));
        return;
    }
    SubnetMask |= (SubIpAddress << 8);

    //
    // Get 3rd part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (10b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (11).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (11a).\n")));
        return;
    }
    SubnetMask |= (SubIpAddress << 16);

    //
    // Get 4th part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (12).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (13).\n")));
        return;
    }

    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (13a).\n")));
        return;
    }    
    SubnetMask |= (SubIpAddress << 24);

    //
    //
    // Now that that is done, we move onto actually doing the command.
    //
    //


    //
    // Start by opening the driver
    //
    RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                       );

    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessageWithStatus(L"set-ip-addr", L"SAC_IPADDRESS_SET_FAILURE", Status);
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: failed to open TCP device, ec = 0x%X\n",
                     Status)));
        return;
    }

    //
    // Setup notification event
    //
    RtlInitUnicodeString(&UnicodeString, L"\\BaseNamedObjects\\SACEvent");

    Event = IoCreateSynchronizationEvent(&UnicodeString, &EventHandle);

    if (Event == NULL) {
        XmlMgrSacPutErrorMessage(L"set-ip-addr", L"SAC_IPADDRESS_RETRIEVE_FAILURE");
        ZwClose(Handle);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Event is NULL.\n")));
        return;
    }

    //
    // Setup the IOCTL buffer to delete the old address.
    //
    IpRequest = (PIP_SET_ADDRESS_REQUEST)GlobalBuffer;
    IpRequest->Address = 0;
    IpRequest->SubnetMask = 0;
    IpRequest->Context = (USHORT)NetworkNumber;

    //
    // Submit the IOCTL
    //
    Status = NtDeviceIoControlFile(Handle,
                                   EventHandle,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_IP_SET_ADDRESS,
                                   IpRequest,
                                   sizeof(IP_SET_ADDRESS_REQUEST),
                                   NULL,
                                   0
                                  );
                                  
    if (Status == STATUS_PENDING) {

        //
        // Wait up to 30 seconds for it to finish
        //
        TimeOut.QuadPart = Int32x32To64((LONG)30000, -1000);
        
        Status = KeWaitForSingleObject((PVOID)Event, Executive, KernelMode,  FALSE, &TimeOut);
        
        if (Status == STATUS_SUCCESS) {
            Status = IoStatusBlock.Status;
        }

    }

    if (Status != STATUS_SUCCESS) {
        XmlMgrSacPutErrorMessageWithStatus(L"set-ip-addr", L"SAC_IPADDRESS_CLEAR_FAILURE", Status);
        ZwClose(EventHandle);
        ZwClose(Handle);
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: Exiting because it couldn't clear existing IP Address (0x%X).\n",
                     Status)));
        return;
    }

    //
    // Now add our address.
    //
    IpRequest = (PIP_SET_ADDRESS_REQUEST)GlobalBuffer;
    IpRequest->Address = IpAddress;
    IpRequest->SubnetMask = SubnetMask;
    IpRequest->Context = (USHORT)NetworkNumber;

    //
    // Submit the IOCTL
    //
    Status = NtDeviceIoControlFile(Handle,
                                   EventHandle,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_IP_SET_ADDRESS,
                                   IpRequest,
                                   sizeof(IP_SET_ADDRESS_REQUEST),
                                   NULL,
                                   0
                                  );
                                  
    if (Status == STATUS_PENDING) {

        //
        // Wait up to 30 seconds for it to finish
        //
        TimeOut.QuadPart = Int32x32To64((LONG)30000, -1000);
        
        Status = KeWaitForSingleObject((PVOID)Event, Executive, KernelMode,  FALSE, &TimeOut);
        
        if (NT_SUCCESS(Status)) {
            Status = IoStatusBlock.Status;
        }

    }

    ZwClose(EventHandle);
    ZwClose(Handle);
    
    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessageWithStatus(L"set-ip-addr", L"SAC_IPADDRESS_SET_FAILURE", Status);
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: Exiting because it couldn't set existing IP Address (0x%X).\n",
                     Status)));
        return;
    }
    
    XmlMgrSacPutString(L"<set-ip-addr status='success'>\r\n");
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting.\n")));
    return;
}

VOID
XmlCmdDoKillCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine kill a process.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    NTSTATUS StatusOfJobObject;
    HANDLE Handle = NULL;
    HANDLE JobHandle = NULL;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    CLIENT_ID ClientId;
    BOOLEAN TerminateJobObject;
    BOOLEAN TerminateProcessObject;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Entering.\n")));

    //
    // Skip to next argument (process id)
    //
    pch += (sizeof(KILL_COMMAND_STRING) - sizeof(UCHAR));
    
    SKIP_WHITESPACE(pch);

    if (*pch == '\0') {
        XmlMgrSacPutErrorMessage(L"kill-process", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (2).\n")));
        return;
    }

    pchTmp = pch;

    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"kill-process", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (2b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        XmlMgrSacPutErrorMessage(L"kill-process", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (3).\n")));
        return;
    }

    ProcessId = atoi((LPCSTR)pch);

    //
    // Try and open an existing job object
    //
    swprintf((PWCHAR)GlobalBuffer, L"\\BaseNamedObjects\\SAC%d", ProcessId);
    RtlInitUnicodeString(&UnicodeString, (PWCHAR)GlobalBuffer);
    InitializeObjectAttributes(&ObjectAttributes,                
                               &UnicodeString,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    StatusOfJobObject = ZwOpenJobObject(&JobHandle, MAXIMUM_ALLOWED, &ObjectAttributes);

    //
    // Also open a handle to the process itself.
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&Handle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );

    if (!NT_SUCCESS(Status) && !NT_SUCCESS(StatusOfJobObject)) {
        XmlMgrSacPutErrorMessageWithStatus(L"kill-process", L"SAC_KILL_FAILURE",Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (4).\n")));
        return;
    }

    //
    // To make the logic here more understandable, I use two booleans.  We have to use
    // ZwIsProcessInJob because there may be a previous JobObject for a process that we 
    // have killed, but has not yet been fully cleaned up by the system to determine if
    // the process we are trying to kill is, in fact, in the JobObject we have opened.
    //
    TerminateJobObject = (BOOLEAN)(NT_SUCCESS(StatusOfJobObject) &&
                          (BOOLEAN)NT_SUCCESS(Status) &&
                          (BOOLEAN)(ZwIsProcessInJob(Handle, JobHandle) == STATUS_PROCESS_IN_JOB)
                         );

    TerminateProcessObject = !TerminateJobObject && (BOOLEAN)NT_SUCCESS(Status);
         
    if (TerminateJobObject) {

        Status = ZwTerminateJobObject(JobHandle, 1); 

        //
        // Make the job object temporary so that when we do our close it
        // will remove it.
        //
        ZwMakeTemporaryObject(JobHandle);

    } else if (TerminateProcessObject) {

        Status = ZwTerminateProcess(Handle, 1);

    }

    if (JobHandle != NULL) {
        ZwClose(JobHandle);
    }

    if (Handle != NULL) {
        ZwClose(Handle);
    }

    if (!TerminateProcessObject && !TerminateJobObject) {
        XmlMgrSacPutErrorMessage(L"kill-process", L"SAC_PROCESS_STALE");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (5).\n")));
        return;

    } else if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessage(L"kill-process", L"SAC_KILL_FAILURE");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (6).\n")));
        return;
    }

    //
    // All done
    //
    XmlMgrSacPutString(L"<kill-process status='success'>\r\n");
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting.\n")));
    
    return;
}

VOID
XmlCmdDoLowerPriorityCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine slams the priority of a process down to the lowest possible, IDLE.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ProcessHandle = NULL;
    PROCESS_BASIC_INFORMATION BasicInfo;
    ULONG LoopCounter;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Entering.\n")));

    //
    // Skip to next argument (process id)
    //
    pch += (sizeof(LOWER_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (!IS_NUMBER(*pch)) {
        XmlMgrSacPutErrorMessage(L"lower-priority", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (2).\n")));
        goto Exit;
    }

    pchTmp = pch;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        XmlMgrSacPutErrorMessage(L"lower-priority", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (3).\n")));
        return;
    }

    ProcessId = atoi((LPCSTR)pch);

    //
    // Try to open the process
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&ProcessHandle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );

    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessageWithStatus(L"lower-priority", L"SAC_LOWERPRI_FAILURE", Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (4).\n")));
        goto Exit;
    }

    //
    // Query information on the process.
    //
    Status = ZwQueryInformationProcess( ProcessHandle,
                                        ProcessBasicInformation,
                                        &BasicInfo,
                                        sizeof(PROCESS_BASIC_INFORMATION),
                                        NULL );

    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessageWithStatus(L"lower-priority", L"SAC_LOWERPRI_FAILURE", Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (5).\n")));
        goto Exit;
    }

    //
    // Lower the priority and set.  Keep lowering it until we fail.  Remember
    // that we're supposed to lower it as far as it will go.
    //
    Status = STATUS_SUCCESS;
    LoopCounter = 0;
    while( (Status == STATUS_SUCCESS) &&
           (BasicInfo.BasePriority > 0) ) {

        BasicInfo.BasePriority--;
        Status = ZwSetInformationProcess( ProcessHandle,
                                          ProcessBasePriority,
                                          &BasicInfo.BasePriority,
                                          sizeof(BasicInfo.BasePriority) );

        //
        // Only treat a failure on the first time through.
        //
        if( (!NT_SUCCESS(Status)) && (LoopCounter == 0) ) {
            XmlMgrSacPutErrorMessageWithStatus(L"lower-priority", L"SAC_LOWERPRI_FAILURE", Status);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (6).\n")));
            goto Exit;
        }

        LoopCounter++;
    }


    //
    // All done.
    //
    XmlMgrSacPutString(L"<lower-priority status='success'/>\r\n");

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting.\n")));

Exit:

    if (ProcessHandle != NULL) {
        ZwClose(ProcessHandle);    
    }

    return;
}

VOID
XmlCmdDoRaisePriorityCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine raises the priority of a process up one increment.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ProcessHandle = NULL;
    PROCESS_BASIC_INFORMATION BasicInfo;


    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Entering.\n")));

    //
    // Skip to next argument (process id)
    //
    pch += (sizeof(RAISE_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (!IS_NUMBER(*pch)) {
        XmlMgrSacPutErrorMessage(L"raise-priority", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (2).\n")));
        goto Exit;
    }

    pchTmp = pch;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        XmlMgrSacPutErrorMessage(L"raise-priority", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (3).\n")));
        return;
    }

    ProcessId = atoi((LPCSTR)pch);

    //
    // See if the process even exists.
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&ProcessHandle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );

    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessageWithStatus(L"raise-priority", L"SAC_RAISEPRI_FAILURE", Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (4).\n")));
        goto Exit;
    }

    //
    // Query information on the process.
    //
    Status = ZwQueryInformationProcess( ProcessHandle,
                                        ProcessBasicInformation,
                                        &BasicInfo,
                                        sizeof(PROCESS_BASIC_INFORMATION),
                                        NULL );

    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessageWithStatus(L"raise-priority", L"SAC_RAISEPRI_FAILURE", Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (5).\n")));
        goto Exit;
    }

    //
    // Raise the priority and set.  Keep raising it until we fail.  Remember
    // that we're supposed to raise it as far as it will go.
    //
    BasicInfo.BasePriority++;
    Status = ZwSetInformationProcess( ProcessHandle,
                                      ProcessBasePriority,
                                      &BasicInfo.BasePriority,
                                      sizeof(BasicInfo.BasePriority) );

    //
    // Only treat a failure on the first time through.
    //
    if( !NT_SUCCESS(Status) ) {
        XmlMgrSacPutErrorMessageWithStatus(L"raise-priority", L"SAC_RAISEPRI_FAILURE", Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (6).\n")));
        goto Exit;
    }

    //
    // All done.
    //
    XmlMgrSacPutString(L"<raise-priority status='success'/>\r\n");

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting.\n")));

Exit:

    if (ProcessHandle != NULL) {
        ZwClose(ProcessHandle);    
    }

    return;
}

VOID
XmlCmdDoLimitMemoryCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine reduces the memory working set of a process to the values in
    the input line given.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    NTSTATUS StatusOfJobObject;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    ULONG MemoryLimit;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE JobHandle = NULL;
    HANDLE ProcessHandle = NULL;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ProposedLimits;
    ULONG ReturnedLength;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Entering.\n")));

    //
    // Get process id
    //
    pch += (sizeof(LIMIT_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (!IS_NUMBER(*pch)) {
        XmlMgrSacPutErrorMessage(L"limit-memory", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (2).\n")));
        goto Exit;
    }

    pchTmp = pch;

    SKIP_NUMBERS(pchTmp);

    if (!IS_WHITESPACE(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"limit-memory", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (3).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    ProcessId = atoi((LPCSTR)pch);

    //
    // Now get memory limit
    //
    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        XmlMgrSacPutErrorMessage(L"limit-memory", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (4).\n")));
        return;
    }

    pch = pchTmp;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        XmlMgrSacPutErrorMessage(L"limit-memory", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (5).\n")));
        return;
    }

    MemoryLimit = atoi((LPCSTR)pch);

    if (MemoryLimit == 0) {
        XmlMgrSacPutErrorMessage(L"limit-memory", L"SAC_INVALID_PARAMETER");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (6).\n")));
        goto Exit;
    }

    //
    // Create the name for the job object
    //
    swprintf((PWCHAR)GlobalBuffer, L"\\BaseNamedObjects\\SAC%d", ProcessId);

    //
    // Try and open the existing job object
    //
    RtlInitUnicodeString(&UnicodeString, (PWCHAR)GlobalBuffer);
    InitializeObjectAttributes(&ObjectAttributes,                
                               &UnicodeString,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    StatusOfJobObject = ZwOpenJobObject(&JobHandle, MAXIMUM_ALLOWED, &ObjectAttributes);

    //
    // Try to open the process
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&ProcessHandle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );


    if (!NT_SUCCESS(Status) && !NT_SUCCESS(StatusOfJobObject)) {
        XmlMgrSacPutErrorMessageWithStatus(L"limit-memory", L"SAC_LOWERMEM_FAILURE", Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (7).\n")));
        goto Exit;
    }

    if (NT_SUCCESS(Status) && 
        NT_SUCCESS(StatusOfJobObject) &&
        (ZwIsProcessInJob(ProcessHandle, JobHandle) != STATUS_PROCESS_IN_JOB)) {

        XmlMgrSacPutErrorMessageWithStatus(L"limit-memory", L"SAC_DUPLICATE_PROCESS", Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (8).\n")));
        goto Exit;
    }

    if (!NT_SUCCESS(StatusOfJobObject)) {
        
        //
        // Now try and create a job object to wrap around this process.
        //
        InitializeObjectAttributes(&ObjectAttributes,                
                                   &UnicodeString,       
                                   OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,  
                                   NULL,                  
                                   NULL                   
                                  );

        Status = ZwCreateJobObject(&JobHandle, MAXIMUM_ALLOWED, &ObjectAttributes);

        if (!NT_SUCCESS(Status)) {
            XmlMgrSacPutErrorMessageWithStatus(L"limit-memory", L"SAC_LOWERMEM_FAILURE", Status);
            ZwClose(ProcessHandle);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (8b).\n")));
            goto Exit;
        }

        //
        // Assign the process to this new job object.
        //
        Status = ZwAssignProcessToJobObject(JobHandle, ProcessHandle);

        ZwClose(ProcessHandle);

        if (!NT_SUCCESS(Status)) {
            XmlMgrSacPutErrorMessageWithStatus(L"limit-memory", L"SAC_LOWERMEM_FAILURE", Status);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (9).\n")));
            goto Exit;        
        }

    }

    //
    // Get the current set of limits
    //
    Status = ZwQueryInformationJobObject(JobHandle, 
                                         JobObjectExtendedLimitInformation, 
                                         &ProposedLimits, 
                                         sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
                                         &ReturnedLength
                                        );
    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessageWithStatus(L"limit-memory", L"SAC_LOWERMEM_FAILURE", Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (10).\n")));
        goto Exit;
    }

    //
    // Change the memory limits
    //
    ProposedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;
    ProposedLimits.ProcessMemoryLimit = MemoryLimit * 1024 * 1024;
    ProposedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_JOB_MEMORY;
    ProposedLimits.JobMemoryLimit = MemoryLimit * 1024 * 1024;

    Status = ZwSetInformationJobObject(JobHandle, 
                                       JobObjectExtendedLimitInformation, 
                                       &ProposedLimits, 
                                       sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
                                      );
    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessageWithStatus(L"limit-memory", L"SAC_LOWERMEM_FAILURE", Status);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (11).\n")));\
        goto Exit;
    }

    //
    // All done.
    //

    XmlMgrSacPutString(L"<limit-memory status='success'>\r\n");

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting.\n")));

Exit:
    if (JobHandle != NULL) {
        ZwClose(JobHandle);
    }

    if (ProcessHandle != NULL) {
        ZwClose(ProcessHandle);
    }

    return;
}

VOID
XmlCmdDoRebootCommand(
    BOOLEAN Reboot
    )

/*++

Routine Description:

    This routine does a shutdown and an optional reboot.

Arguments:

    Reboot - To Reboot or not to reboot, that is the question answered here.

Return Value:

        None.

--*/
{
    #define         RESTART_DELAY_TIME (60)
    NTSTATUS        Status;
    LARGE_INTEGER   TickCount;
    LARGE_INTEGER   ElapsedTime;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRebootCommand: Entering.\n")));

    //
    // If we attempt to shutdown the system before smss.exe has initialized
    // properly, and if there's no debugger, the machine may bugcheck.  Figuring
    // out exactly what's going on is difficult because if we put a debugger on
    // the machine, he won't repro the problem.  To work around this, we're going
    // to make sure the machine has had time to initialize before we tell it to
    // restart/shutdown.
    //

    // Elapsed TickCount
    KeQueryTickCount( &TickCount );

    // ElapsedTime in seconds.
    ElapsedTime.QuadPart = (TickCount.QuadPart)/(10000000/KeQueryTimeIncrement());

    if( ElapsedTime.QuadPart < RESTART_DELAY_TIME ) {

        KEVENT Event;

        XmlMgrSacPutString(L"<reboot status='");
        XmlMgrSacPutString(Reboot ? L"SAC_PREPARE_RESTART" : L"SAC_PREPARE_SHUTDOWN");
        XmlMgrSacPutString(L"<'/>");
                
        // wait until the machine has been up for at least RESTART_DELAY_TIME seconds.
        KeInitializeEvent( &Event,
                           SynchronizationEvent,
                           FALSE );

        ElapsedTime.QuadPart = Int32x32To64((LONG)((RESTART_DELAY_TIME-ElapsedTime.LowPart)*10000), // milliseconds until we reach RESTART_DELAY_TIME
                                            -1000);
        KeWaitForSingleObject((PVOID)&Event, Executive, KernelMode,  FALSE, &ElapsedTime);

    }

    Status = NtShutdownSystem(Reboot ? ShutdownReboot : ShutdownNoReboot);

    XmlMgrSacPutErrorMessageWithStatus(
        L"reboot", 
        Reboot ? L"SAC_RESTART_FAILURE" : L"SAC_SHUTDOWN_FAILURE", 
        Status
        );
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRebootCommand: Exiting.\n")));
}

VOID
XmlCmdDoCrashCommand(
    VOID
    )

/*++

Routine Description:

    This routine does a shutdown and bugcheck.

Arguments:

    None.

Return Value:

    None.

--*/
{
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCrashCommand: Entering.\n")));

    //
    // this call does not return
    //
    KeBugCheckEx(MANUALLY_INITIATED_CRASH, 0, 0, 0, 0);

    // XmlMgrSacPutSimpleMessage( SAC_CRASHDUMP_FAILURE );
    // IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCrashCommand: Exiting.\n")));
}

VOID
XmlCmdDoTlistCommand(
    VOID
    )

/*++

Routine Description:

    This routine gets a Tlist and displays it.

Arguments:

    None.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    ULONG DataLength;
    PVOID NewBuffer;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Entering.\n")));

RetryTList:

    Status = XmlCmdGetTListInfo(
        (PSAC_RSP_TLIST)GlobalBuffer, 
        (LONG)GlobalBufferSize, 
        &DataLength
        );

    if ((Status == STATUS_NO_MEMORY) ||
        (Status == STATUS_INFO_LENGTH_MISMATCH)) {
        //
        // Try to get more memory, if not available, then just fail without out of memory error.
        //
        NewBuffer = ALLOCATE_POOL(GlobalBufferSize + MEMORY_INCREMENT, GENERAL_POOL_TAG);
                                         
        if (NewBuffer != NULL) {

            FREE_POOL(&GlobalBuffer);
            GlobalBuffer = NewBuffer;
            GlobalBufferSize += MEMORY_INCREMENT;
            goto RetryTList;                            
        }
                    
        XmlMgrSacPutErrorMessage(L"tlist", L"SAC_NO_MEMORY");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Exiting.\n")));
        return;

    }

    if (NT_SUCCESS(Status)) {
        XmlCmdPrintTListInfo((PSAC_RSP_TLIST)GlobalBuffer);
    } else {
        XmlMgrSacPutErrorMessageWithStatus(L"tlist", L"SAC_TLIST_FAILURE", Status);
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Exiting.\n")));
}


NTSTATUS
XmlCmdGetTListInfo(
    OUT PSAC_RSP_TLIST ResponseBuffer,
    IN  LONG ResponseBufferSize,
    OUT PULONG ResponseDataSize
    )

/*++

Routine Description:

    This routine gets all the information necessary for the TList command.

Arguments:

    ResponseBuffer - The buffer to put the results into.
    
    ResponseBufferSize - The length of the above buffer.
    
    ResponseDataSize - The length of the resulting buffer.

Return Value:

        None.

--*/

{
    NTSTATUS Status;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;

    PUCHAR DataBuffer;
    PUCHAR StartProcessInfo;
    LONG CurrentBufferSize;
    ULONG ReturnLength;
    ULONG TotalOffset;
    ULONG OffsetIncrement = 0;
        
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Entering.\n")));
    
    *ResponseDataSize = 0;

    if (ResponseBufferSize < sizeof(ResponseBuffer)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory.\n")));
        return(STATUS_NO_MEMORY);
    }
    
    DataBuffer = (PUCHAR)(ResponseBuffer + 1);
    CurrentBufferSize = ResponseBufferSize - sizeof(SAC_RSP_TLIST);
    
    if (CurrentBufferSize < 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory (2).\n")));
        return STATUS_NO_MEMORY;
    }

    //
    // Get system-wide information
    //
    Status = ZwQuerySystemInformation(SystemTimeOfDayInformation,
                                      &(ResponseBuffer->TimeOfDayInfo),
                                      sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error.\n")));
        return(Status);
    }

    Status = ZwQuerySystemInformation(SystemBasicInformation,
                                      &(ResponseBuffer->BasicInfo),
                                      sizeof(SYSTEM_BASIC_INFORMATION),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(2).\n")));
        return(Status);
    }

    //
    // Get pagefile information
    //
    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)DataBuffer;
    Status = ZwQuerySystemInformation(SystemPageFileInformation,
                                      PageFileInfo,
                                      CurrentBufferSize,
                                      &ReturnLength
                                     );

    if (NT_SUCCESS(Status) && (ReturnLength != 0)) {

        ResponseBuffer->PagefileInfoOffset = ResponseBufferSize - CurrentBufferSize;
        CurrentBufferSize -= ReturnLength;
        DataBuffer += ReturnLength;
    
        if (CurrentBufferSize < 0) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(3).\n")));
            return STATUS_NO_MEMORY;
        }

        //
        // Go thru each pagefile and fixup the names...
        //
        for (; ; ) {

            if (PageFileInfo->PageFileName.Length > CurrentBufferSize) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(3).\n")));
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            RtlCopyMemory(DataBuffer, 
                          (PUCHAR)(PageFileInfo->PageFileName.Buffer), 
                          PageFileInfo->PageFileName.Length
                         );

            PageFileInfo->PageFileName.Buffer = (PWSTR)DataBuffer;
            DataBuffer += PageFileInfo->PageFileName.Length;
            CurrentBufferSize -= PageFileInfo->PageFileName.Length;

            if (CurrentBufferSize < 0) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory (4).\n")));
                return STATUS_NO_MEMORY;
            }

            if (PageFileInfo->NextEntryOffset == 0) {
                break;
            }

            PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);
        }

    } else if (((ULONG)CurrentBufferSize) < ReturnLength) {
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(5).\n")));
        return(STATUS_NO_MEMORY);
     
    } else {

        //
        // Either failure or no paging file present.
        //
        ResponseBuffer->PagefileInfoOffset = 0;

    }

    //
    // Get process information
    //
    Status = ZwQuerySystemInformation(SystemFileCacheInformation,
                                      &(ResponseBuffer->FileCache),
                                      sizeof(ResponseBuffer->FileCache),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(4).\n")));
        return(Status);
    }


    Status = ZwQuerySystemInformation(SystemPerformanceInformation,
                                      &(ResponseBuffer->PerfInfo),
                                      sizeof(ResponseBuffer->PerfInfo),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {     
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(5).\n")));
        return(Status);
    }

    //
    // Realign DataBuffer for the next query
    //
    DataBuffer = ALIGN_UP_POINTER(DataBuffer, SYSTEM_PROCESS_INFORMATION);
    CurrentBufferSize = (ULONG)(ResponseBufferSize - (((ULONG_PTR)DataBuffer) - ((ULONG_PTR)ResponseBuffer)));
        
    if (CurrentBufferSize < 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory (6).\n")));
        return STATUS_NO_MEMORY;
    }


    Status = ZwQuerySystemInformation(SystemProcessInformation,
                                      DataBuffer,
                                      CurrentBufferSize,
                                      &ReturnLength
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(6).\n")));
        return(Status);
    }


    StartProcessInfo = DataBuffer;

    ResponseBuffer->ProcessInfoOffset = ResponseBufferSize - CurrentBufferSize;
    DataBuffer += ReturnLength;
    CurrentBufferSize -= ReturnLength;

    if (CurrentBufferSize < 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(7).\n")));
        return STATUS_NO_MEMORY;
    }

    OffsetIncrement = 0;
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)StartProcessInfo;

    do {

        //
        // We have to take the name of each process and pack the UNICODE_STRING
        // buffer in our buffer so it doesn't collide with the subsequent data
        //
        if (ProcessInfo->ImageName.Buffer) {
                
            if (CurrentBufferSize < ProcessInfo->ImageName.Length ) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(7).\n")));
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            RtlCopyMemory(DataBuffer, (PUCHAR)(ProcessInfo->ImageName.Buffer), ProcessInfo->ImageName.Length);                        

            ProcessInfo->ImageName.Buffer = (PWSTR)DataBuffer;

            DataBuffer += ProcessInfo->ImageName.Length;
            CurrentBufferSize -= ProcessInfo->ImageName.Length;
            
            if (CurrentBufferSize < 0) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(8).\n")));
                return STATUS_NO_MEMORY;
            }

        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&(StartProcessInfo[TotalOffset]);

    } while( OffsetIncrement != 0 );

    *ResponseDataSize = (ULONG)(ResponseBufferSize - CurrentBufferSize);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting.\n")));
    return STATUS_SUCCESS;
}

VOID
XmlCmdPrintTListInfo(
    IN PSAC_RSP_TLIST Buffer
    )

/*++

Routine Description:

    This routine prints TList info to the headless terminal.

Arguments:

    Buffer - The buffer with the results.

Return Value:

        None.

--*/

{
    LARGE_INTEGER Time;
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS UpTime;
    ULONG TotalOffset;
    ULONG OffsetIncrement = 0;
    SIZE_T SumCommit;
    SIZE_T SumWorkingSet;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;
    ULONG i;
    PUCHAR ProcessInfoStart;
    PUCHAR BufferStart = (PUCHAR)Buffer;
    UNICODE_STRING Process;
    BOOLEAN Stop;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Entering.\n")));

    Time.QuadPart = Buffer->TimeOfDayInfo.CurrentTime.QuadPart - Buffer->TimeOfDayInfo.BootTime.QuadPart;

    RtlTimeToElapsedTimeFields(&Time, &UpTime);

    //
    //
    //
    XmlMgrSacPutString(L"<tlist>\r\n");

    XmlMgrSacPutString(L"<uptime>\r\n");

    GB_SPRINTF(
        L"<day>%d</day>\r\n",
        UpTime.Day
        );

    GB_SPRINTF(
        L"<hour>%d</hour>\r\n",
        UpTime.Hour
        );
    
    GB_SPRINTF(
        L"<minute>%d</minute>\r\n",
        UpTime.Minute
        );
    
    GB_SPRINTF(
        L"<second>%d</second>\r\n",
        UpTime.Second
        );
    
    GB_SPRINTF(
        L"<milliseconds>%d</milliseconds>\r\n",
        UpTime.Milliseconds
        );

    XmlMgrSacPutString(L"</uptime>\r\n");
    
    //
    // Print out the page file information.
    //
    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)(BufferStart + Buffer->PagefileInfoOffset);

    if (Buffer->PagefileInfoOffset == 0) {
    
        XmlMgrSacPutString(L"<pagefile status='none'/>\r\n");
        
    } else {
    
        for (; ; ) {

            GB_SPRINTF(
                L"<pagefile name='%wZ'>\r\n",
                &PageFileInfo->PageFileName
                );

            GB_SPRINTF(
                L"<current-size>%ld</current-size>\r\n",
                PageFileInfo->TotalSize * (Buffer->BasicInfo.PageSize/1024),
                );

            GB_SPRINTF(
                L"<total-size>%ld</total-size>\r\n",
                PageFileInfo->TotalInUse * (Buffer->BasicInfo.PageSize/1024),
                );
                
            GB_SPRINTF(
                L"<total-size>%ld</total-size>\r\n",
                PageFileInfo->PeakUsage * (Buffer->BasicInfo.PageSize/1024)
                );

            XmlMgrSacPutString(L"</pagefile>\r\n");

            if (PageFileInfo->NextEntryOffset == 0) {
                break;
            }

            PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);

        }

    }

    //
    // display pmon style process output, then detailed output that includes
    // per thread stuff
    //
    if (Buffer->ProcessInfoOffset == 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Exiting (1).\n")));
        return;
    }

    OffsetIncrement = 0;
    TotalOffset = 0;
    SumCommit = 0;
    SumWorkingSet = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);
    ProcessInfoStart = (PUCHAR)ProcessInfo;
    
    do {
        SumCommit += ProcessInfo->PrivatePageCount / 1024;
        SumWorkingSet += ProcessInfo->WorkingSetSize / 1024;
        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart +TotalOffset);
    } while( OffsetIncrement != 0 );

    SumWorkingSet += Buffer->FileCache.CurrentSize/1024;

    //
    //
    //
    XmlMgrSacPutString(L"<memory-info>\r\n");
    
    GB_SPRINTF(
        L"<memory-total>%ld</memory-total>\r\n",
        Buffer->BasicInfo.NumberOfPhysicalPages * (Buffer->BasicInfo.PageSize/1024),
        );
    
    GB_SPRINTF(
        L"<memory-avail>%ld</memory-avail>\r\n",
        Buffer->PerfInfo.AvailablePages * (Buffer->BasicInfo.PageSize/1024),
        );
    
    GB_SPRINTF(
        L"<working-set-total>%ld</working-set-total>\r\n",
        SumWorkingSet,
        );
    
    GB_SPRINTF(
        L"<resident-kernel>%ld</resident-kernel>\r\n",
        (Buffer->PerfInfo.ResidentSystemCodePage + Buffer->PerfInfo.ResidentSystemDriverPage) * (Buffer->BasicInfo.PageSize/1024)
        );
    
    GB_SPRINTF(
        L"<resident-page-size>%ld</resident-page-size>\r\n",
        (Buffer->PerfInfo.ResidentPagedPoolPage) * (Buffer->BasicInfo.PageSize/1024)
        );

    GB_SPRINTF(
        L"<commit-current>%ld</commit-current>\r\n",
        Buffer->PerfInfo.CommittedPages * (Buffer->BasicInfo.PageSize/1024),
        );
    
    GB_SPRINTF(
        L"<commit-total>%ld</commit-total>\r\n",
        SumCommit,
        );
    
    GB_SPRINTF(
        L"<commit-limit>%ld</commit-limit>\r\n",
        Buffer->PerfInfo.CommitLimit * (Buffer->BasicInfo.PageSize/1024),
        );
    
    GB_SPRINTF(
        L"<commit-peak>%ld</commit-peak>\r\n",
        Buffer->PerfInfo.PeakCommitment * (Buffer->BasicInfo.PageSize/1024),
        );

    GB_SPRINTF(
        L"<commit-peak>%ld</commit-peak>\r\n",
        Buffer->PerfInfo.PeakCommitment * (Buffer->BasicInfo.PageSize/1024),
        );
    
    GB_SPRINTF(
        L"<non-paged-pool>%ld</non-paged-pool>\r\n",
        Buffer->PerfInfo.NonPagedPoolPages * (Buffer->BasicInfo.PageSize/1024),
        );
    
    GB_SPRINTF(
        L"<paged-pool>%ld</paged-pool>\r\n",
        Buffer->PerfInfo.PagedPoolPages * (Buffer->BasicInfo.PageSize/1024)
        );

    XmlMgrSacPutString(L"</memory-info>\r\n");

    //
    //
    //
    XmlMgrSacPutString(L"<file-cache>\r\n");
    GB_SPRINTF(
        L"<current-size>%ld</current-size>\r\n",
        Buffer->FileCache.CurrentSize/1024
        );

    GB_SPRINTF(
        L"<page-fault-count>%ld</page-fault-count>\r\n",
        Buffer->FileCache.PageFaultCount
        );
    XmlMgrSacPutString(L"</file-cache>\r\n");

    //
    //
    //
    XmlMgrSacPutString(L"<processes>\r\n");

    OffsetIncrement = 0;
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);

    do {
        
        RtlTimeToElapsedTimeFields(&ProcessInfo->UserTime, &UserTime);
        RtlTimeToElapsedTimeFields(&ProcessInfo->KernelTime, &KernelTime);

        Process.Buffer = NULL;
        if (ProcessInfo->UniqueProcessId == 0) {
            RtlInitUnicodeString( &Process, L"Idle Process" );
        } else if (!ProcessInfo->ImageName.Buffer) {
            RtlInitUnicodeString( &Process, L"System" );
        }

        XmlMgrSacPutString(L"<process>\r\n");

        XmlMgrSacPutString(L"<user-time>\r\n");
        
        GB_SPRINTF(
            L"<hour>%ld</hour>\r\n",
            UserTime.Hour
            );

        GB_SPRINTF(
            L"<minute>%02ld</minute>\r\n",
            UserTime.Hour
            );
            
        GB_SPRINTF(
            L"<second>%02ld</second>\r\n",
            UserTime.Second
            );

        GB_SPRINTF(
            L"<milliseconds>%03ld</milliseconds>\r\n",
            UserTime.Milliseconds
            );
        
        XmlMgrSacPutString(L"</user-time>\r\n");

        XmlMgrSacPutString(L"<kernel-time>\r\n");
        
        GB_SPRINTF(
            L"<hour>%ld</hour>\r\n",
            KernelTime.Hour
            );

        GB_SPRINTF(
            L"<minute>%02ld</minute>\r\n",
            KernelTime.Hour
            );
            
        GB_SPRINTF(
            L"<second>%02ld</second>\r\n",
            KernelTime.Second
            );

        GB_SPRINTF(
            L"<milliseconds>%03ld</milliseconds>\r\n",
            KernelTime.Milliseconds
            );
        
        XmlMgrSacPutString(L"</kernel-time>\r\n");
        
        XmlMgrSacPutString(L"<process-info>\r\n");
        
        GB_SPRINTF(
            L"<working-set-size>%ld</working-set-size>\r\n",
            ProcessInfo->WorkingSetSize / 1024
            );     
        GB_SPRINTF(
            L"<page-fault-count>%ld</page-fault-count>\r\n",
            ProcessInfo->PageFaultCount
            );     
        GB_SPRINTF(
            L"<private-page-count>%ld</private-page-count>\r\n",
            ProcessInfo->PrivatePageCount
            );     
        GB_SPRINTF(
            L"<base-priority>%ld</base-priority>\r\n",
            ProcessInfo->BasePriority
            );     
        GB_SPRINTF(
            L"<handle-count>%ld</handle-count>\r\n",
            ProcessInfo->HandleCount
            );     
        GB_SPRINTF(
            L"<number-of-threads>%ld</number-of-threads>\r\n",
            ProcessInfo->NumberOfThreads
            );     
        GB_SPRINTF(
            L"<pid>%ld</pid>\r\n",
            HandleToUlong(ProcessInfo->UniqueProcessId)
            );     
        GB_SPRINTF(
            L"<process-name>%wZ</process-name>\r\n",
            Process.Buffer ? &Process : &ProcessInfo->ImageName 
            );     
        
        XmlMgrSacPutString(L"</process-info>\r\n");
        XmlMgrSacPutString(L"</process>\r\n");

        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart + TotalOffset);
    
    } while( OffsetIncrement != 0 );

    XmlMgrSacPutString(L"</processes>\r\n");
    
#if 0
    if (!GlobalDoThreads) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Exiting (2).\n")));
        return;
    }
#endif

    //
    // Beginning of normal old style pstat output
    //

    TotalOffset = 0;
    OffsetIncrement = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);

    XmlMgrSacPutString(L"<pstat>\r\n");

    do {

        Process.Buffer = NULL;
        if (ProcessInfo->UniqueProcessId == 0) {
            RtlInitUnicodeString( &Process, L"Idle Process" );
        } else if (!ProcessInfo->ImageName.Buffer) {
            RtlInitUnicodeString( &Process, L"System" );
        }

        XmlMgrSacPutString(L"<process>\r\n");

        GB_SPRINTF(
            L"<pid>%lx</pid>\r\n",
            HandleToUlong(ProcessInfo->UniqueProcessId)
            );
        GB_SPRINTF(
            L"<priority>%ld</priority>\r\n",
            ProcessInfo->BasePriority
            );
        GB_SPRINTF(
            L"<handle-count>%ld</handle-count>\r\n",
            ProcessInfo->HandleCount
            );
        GB_SPRINTF(
            L"<page-fault-count>%ld</page-fault-count>\r\n",
            ProcessInfo->PageFaultCount
            );
        GB_SPRINTF(
            L"<working-set-size>%ld</working-set-size>\r\n",
            ProcessInfo->WorkingSetSize / 1024
            );
        GB_SPRINTF(
            L"<image-name>%wZ</image-name>\r\n",
            Process.Buffer ? &Process : &ProcessInfo->ImageName
            );

        XmlMgrSacPutString(L"<thread-info>\r\n");

        i = 0;
        
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        
        while (i < ProcessInfo->NumberOfThreads) {
            RtlTimeToElapsedTimeFields ( &ThreadInfo->UserTime, &UserTime);

            RtlTimeToElapsedTimeFields ( &ThreadInfo->KernelTime, &KernelTime);
            
            GB_SPRINTF(
                L"<pid>%lx</pid>\r\n",
                ProcessInfo->UniqueProcessId == 0 ? 0 : HandleToUlong(ThreadInfo->ClientId.UniqueThread)
            );
            GB_SPRINTF(
                L"<priority>%lx</priority>\r\n",
                ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->Priority
            );
            GB_SPRINTF(
                L"<context-switches>%lx</context-switches>\r\n",
                ThreadInfo->ContextSwitches
            );
            GB_SPRINTF(
                L"<start-address>%lx</start-address>\r\n",
                ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->StartAddress
            );
            
            XmlMgrSacPutString(L"<user-time>\r\n");
            GB_SPRINTF(
                L"<hour>%ld</hour>\r\n",
                UserTime.Hour
                );
            GB_SPRINTF(
                L"<minute>%02ld</minute>\r\n",
                UserTime.Hour
                );
            GB_SPRINTF(
                L"<second>%02ld</second>\r\n",
                UserTime.Second
                );
            GB_SPRINTF(
                L"<milliseconds>%03ld</milliseconds>\r\n",
                UserTime.Milliseconds
                );
            XmlMgrSacPutString(L"</user-time>\r\n");

            XmlMgrSacPutString(L"<kernel-time>\r\n");
            GB_SPRINTF(
                L"<hour>%ld</hour>\r\n",
                KernelTime.Hour
                );
            GB_SPRINTF(
                L"<minute>%02ld</minute>\r\n",
                KernelTime.Hour
                );
            GB_SPRINTF(
                L"<second>%02ld</second>\r\n",
                KernelTime.Second
                );
            GB_SPRINTF(
                L"<milliseconds>%03ld</milliseconds>\r\n",
                KernelTime.Milliseconds
                );
            XmlMgrSacPutString(L"</kernel-time>\r\n");
            
            GB_SPRINTF(
                L"<state>%s</state>\r\n",
                StateTable[ThreadInfo->ThreadState]
                );
            
            GB_SPRINTF(
                L"<wait-reason>%s</wait-reason>\r\n",
                (ThreadInfo->ThreadState == 5) ? WaitTable[ThreadInfo->WaitReason] : Empty
                );
            
            ThreadInfo += 1;
            i += 1;

        }

        XmlMgrSacPutString(L"</thread-info>\r\n");
        XmlMgrSacPutString(L"</process>\r\n");

        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart + TotalOffset);

    } while( OffsetIncrement != 0 );

    XmlMgrSacPutString(L"</pstat>\r\n");
    
    XmlMgrSacPutString(L"</tlist>\r\n");

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Exiting.\n")));
}


NTSTATUS 
XmlCmdCallQueryIPIOCTL(
    HANDLE IpDeviceHandle,
    PKEVENT Event,
    HANDLE EventHandle,
    IO_STATUS_BLOCK *IoStatusBlock,
    PVOID  InputBuffer,
    ULONG  InputBufferSize,
    PVOID  OutputBuffer,
    ULONG  OutputBufferSize,
    BOOLEAN PrintToTerminal,
    BOOLEAN *putPrompt
    )
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;

    //
    // Submit the IOCTL
    //
    Status = NtDeviceIoControlFile(IpDeviceHandle,
                                   EventHandle,
                                   NULL,
                                   NULL,
                                   IoStatusBlock,
                                   IOCTL_TCP_QUERY_INFORMATION_EX,
                                   InputBuffer,
                                   InputBufferSize,
                                   OutputBuffer,
                                   OutputBufferSize);

                                  
    if (Status == STATUS_PENDING) {

        //
        // Wait up to 30 seconds for it to finish
        //
        XmlMgrSacPutString(L"<get-net-info state='SAC_RETRIEVING_IPADDR'>\r\n");
        
        TimeOut.QuadPart = Int32x32To64((LONG)30000, -1000);
        
        Status = KeWaitForSingleObject((PVOID)Event, Executive, KernelMode,  FALSE, &TimeOut);
        
        if (NT_SUCCESS(Status)) {
            Status = IoStatusBlock->Status;
        }

    }

    return(Status);

}


VOID
XmlCmdDoGetNetInfo(
    BOOLEAN PrintToTerminal
    )

/*++

Routine Description:

    This routine attempts to get and print every IP net number and its IP
    address.

Arguments:

    PrintToTerminal - Determines if the IP information is printed ( == TRUE )
           Or sent to the kernel ( == FALSE ) 

Return Value:

        None.

--*/

{
    NTSTATUS Status;
    HANDLE Handle;
    ULONG i;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    
    PTCP_REQUEST_QUERY_INFORMATION_EX TcpRequestQueryInformationEx;
    IPAddrEntry *AddressEntry,*AddressArray;
    IPSNMPInfo *IpsiInfo;
        
    PHEADLESS_CMD_SET_BLUE_SCREEN_DATA LocalPropBuffer = NULL;
    PVOID LocalBuffer;

    PUCHAR pch = NULL;
    ULONG len;
    BOOLEAN putPrompt=FALSE;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Entering.\n")));

    //
    // Alloc space for calling the IP driver
    //
    TcpRequestQueryInformationEx = ALLOCATE_POOL( 
                                        sizeof(TCP_REQUEST_QUERY_INFORMATION_EX), 
                                        GENERAL_POOL_TAG );
    if (TcpRequestQueryInformationEx == NULL) {
        XmlMgrSacPutErrorMessage(L"get-net-info", L"SAC_NO_MEMORY");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (1).\n")));
        return;
    }

    IpsiInfo = ALLOCATE_POOL( sizeof(IPSNMPInfo), 
                              GENERAL_POOL_TAG );
    if (IpsiInfo == NULL) {
        XmlMgrSacPutErrorMessage(L"get-net-info", L"SAC_NO_MEMORY");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (1).\n")));
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;
    }

    //
    // zero out the context information and preload with the info we're gonna
    // request (we want the count of interfaces)
    //
    RtlZeroMemory(TcpRequestQueryInformationEx, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
    TcpRequestQueryInformationEx->ID.toi_id = IP_MIB_STATS_ID;
    TcpRequestQueryInformationEx->ID.toi_type = INFO_TYPE_PROVIDER;
    TcpRequestQueryInformationEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_instance = 0;

    LocalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);
    if (LocalBuffer == NULL) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (6).\n")));            
        FREE_POOL(&TcpRequestQueryInformationEx);
        FREE_POOL(&IpsiInfo);
        return;        
    }

    
    //
    // Start by opening the TCP driver
    //
    RtlInitUnicodeString(&UnicodeString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                       );

    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessage(L"get-net-info", L"SAC_IPADDR_FAILED");
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (2).\n")));
        return;
    }
    
    if (SACEvent == NULL) {
        XmlMgrSacPutErrorMessage(L"get-net-info", L"SAC_IPADDR_FAILED");
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (14).\n")));
        return;
    }

    //
    // now call the ioctl
    //
    Status = XmlCmdCallQueryIPIOCTL(
        Handle,
        SACEvent,
        SACEventHandle,
        &IoStatusBlock,
        TcpRequestQueryInformationEx,
        sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
        IpsiInfo,
        sizeof(IPSNMPInfo),
        FALSE,
        &putPrompt);
    

    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessage(L"get-net-info", L"SAC_IPADDR_FAILED");
        ZwClose(Handle);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;
    }

    if (IpsiInfo->ipsi_numaddr == 0) {
        XmlMgrSacPutErrorMessage(L"get-net-info", L"SAC_IPADDR_NONE");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;
    }

    //
    // if it succeeded, then allocate space for the array of IP addresses
    //
    AddressArray = ALLOCATE_POOL(IpsiInfo->ipsi_numaddr*sizeof(IPAddrEntry), 
                                 GENERAL_POOL_TAG);
    if (AddressArray == NULL) {    
        XmlMgrSacPutErrorMessage(L"get-net-info", L"SAC_NO_MEMORY");
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (16).\n")));
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;
    }

    //
    // zero out the context information and preload with the info we're gonna
    // request (we want the count of interfaces)
    //
    RtlZeroMemory(TcpRequestQueryInformationEx, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
    TcpRequestQueryInformationEx->ID.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    TcpRequestQueryInformationEx->ID.toi_type = INFO_TYPE_PROVIDER;
    TcpRequestQueryInformationEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_instance = 0;

    Status = XmlCmdCallQueryIPIOCTL(
        Handle,
        SACEvent,
        SACEventHandle,
        &IoStatusBlock,
        TcpRequestQueryInformationEx,
        sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
        AddressArray,
        IpsiInfo->ipsi_numaddr*sizeof(IPAddrEntry),
        PrintToTerminal,
        &putPrompt);

    //
    // don't need this anymore
    //
    FREE_POOL(&TcpRequestQueryInformationEx);
    ZwClose(Handle);

    if (!NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessageWithStatus(L"net-info", L"SAC_IPADDR_FAILED", Status);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&AddressArray);
        FREE_POOL(&IpsiInfo);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));        
        return;
    }
    

    //
    // Need to allocate a buffer for the XML data.
    //
#if 0
    if(PrintToTerminal==FALSE) {
        LocalPropBuffer = (PHEADLESS_CMD_SET_BLUE_SCREEN_DATA) ALLOCATE_POOL(2*MEMORY_INCREMENT, GENERAL_POOL_TAG);
        if (LocalPropBuffer == NULL) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (6).\n")));            
            FREE_POOL(&AddressArray);
            FREE_POOL(&IpsiInfo);
            return;
        }
        pch = &(LocalPropBuffer->Data[0]);
        len = sprintf((LPSTR)pch,"IPADDRESS");
        LocalPropBuffer->ValueIndex = len+1;
        pch = pch+len+1;
        len = sprintf((LPSTR)pch,"\r\n<PROPERTY.ARRAY NAME=\"IPADDRESS\" TYPE=\"string\">\r\n");
        pch = pch + len;
        len = sprintf((LPSTR)pch,"<VALUE.ARRAY>\r\n");
        pch = pch + len;
    }
#endif
    
    //
    // walk the list of IP addresses and spit out the data
    //
    for (i = 0; i < IpsiInfo->ipsi_numaddr; i++) {

        AddressEntry = &AddressArray[i];

        if (IP_LOOPBACK(AddressEntry->iae_addr)) {
            continue;
        }        
        
#if 0
        if(PrintToTerminal){
           
            //  Net: %%d, Ip=%%d.%%d.%%d.%%d  Subnet=%%d.%%d.%%d.%%d
#endif

        XmlMgrSacPutString(L"<net-info>\r\n");
        
        GB_SPRINTF(
            L"<net>%d</net>\r\n",
            AddressEntry->iae_context
            );

        swprintf(
            LocalBuffer,
            L"%d.%d.%d.%d",
            AddressEntry->iae_addr & 0xFF,
            (AddressEntry->iae_addr >> 8) & 0xFF,
            (AddressEntry->iae_addr >> 16) & 0xFF,
            (AddressEntry->iae_addr >> 24) & 0xFF
            );
        GB_SPRINTF(
            L"<ip>%s</ip>\r\n",
            LocalBuffer
            );
        
        swprintf(
            LocalBuffer,
            L"%d.%d.%d.%d",
            AddressEntry->iae_mask  & 0xFF,
            (AddressEntry->iae_mask >> 8) & 0xFF,
            (AddressEntry->iae_mask >> 16) & 0xFF,
            (AddressEntry->iae_mask >> 24) & 0xFF
            );
        GB_SPRINTF(
            L"<sub-net>%s</sub-net>\r\n",
            LocalBuffer
            );

        XmlMgrSacPutString(L"</net-info>\r\n");
    
#if 0
        } else {
           
            len=sprintf((LPSTR)LocalBuffer,"<VALUE>\"%d.%d.%d.%d\"</VALUE>\r\n",
                       AddressEntry->iae_addr & 0xFF,
                       (AddressEntry->iae_addr >> 8) & 0xFF,
                       (AddressEntry->iae_addr >> 16) & 0xFF,
                       (AddressEntry->iae_addr >> 24) & 0xFF
                       );
            if (pch + len < ((PUCHAR) LocalPropBuffer) + 2*MEMORY_INCREMENT - 80){
               // the 80 characters ensures that we can end this XML data
               // properly
               strcat((LPSTR)pch,LocalBuffer);
               pch = pch + len;
            }
        }
#endif    
    }

#if 0
    if(PrintToTerminal==FALSE) { 
        sprintf((LPSTR)pch, "</VALUE.ARRAY>\r\n</PROPERTY.ARRAY>");
    }
#endif

    FREE_POOL(&AddressArray);
    FREE_POOL(&IpsiInfo);

    if(!PrintToTerminal){
        
        Status = HeadlessDispatch(
            HeadlessCmdSetBlueScreenData,
            LocalPropBuffer,
            2*MEMORY_INCREMENT,
            NULL,
            NULL
            );
        FREE_POOL(&LocalPropBuffer);
        
        if (! NT_SUCCESS(Status)) {
            
            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC DoGetNetInfo: Failed dispatch.\n"))
                );            
        
        }

        //
        // open up the IP driver so we know if the addresses change
        //
        RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        Status = ZwOpenFile(&Handle,
                            (ACCESS_MASK)FILE_GENERIC_READ,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0
                           );

        if (!NT_SUCCESS(Status)) {
            
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (2).\n")));
            return;
        }

        
        Status = ZwDeviceIoControlFile(Handle,
                                       NULL,
                                       XmlCmdNetAPCRoutine,
                                       NULL,
                                       &GlobalIoStatusBlock,
                                       IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST,
                                       NULL,
                                       0,
                                       NULL,
                                       0
                                      );
                                  
        if (Status == STATUS_PENDING) {
            IoctlSubmitted = TRUE;
        }
    
    }

    ZwClose(Handle);
    return;

}

VOID
XmlCmdNetAPCRoutine(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
/*++

Routine Description:
    This is the APC routine called after IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST
    was completed
    
Arguments:
    
    APCContext    - UNUSED
    IoStatusBlock - Status about the Fate of the IRP
    Reserved      - UNUSED
    

Return Value:

        None.

--*/
{
    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(ApcContext);

    if (IoStatusBlock->Status == STATUS_CANCELLED) {
        // The SAC driver might be unloading
        // BUGBUG - If the IP driver is stopped and restarted 
        // then we are out of the loop. What to do ??
                
        return;

    }
    
    // Refresh the kernel information and resend the IRP

    XmlCmdDoGetNetInfo( FALSE );
    
    return;
}


VOID
XmlCmdSubmitIPIoRequest(
    )
/*++

Routine Description:
    Called the first time by the Processing Thread to actually
    submit the ADDR_CHANGE IOCTL to the IP Driver. Only the
    processing thread can call this and calls it only once successfully. 
    Then on the APC is reentered only through the NetAPCRoutine
    
Arguments:
    
    None.

Return Value:

        None.

--*/
{
    

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Submit IP Ioctl: Entering.\n")));

    XmlCmdDoGetNetInfo( FALSE );
    return;
    
}

VOID
XmlCmdCancelIPIoRequest(
    )
/*++

Routine Description:
    Called by the processing thread during unload of the driver
    to cancel the IOCTL sent to the IP driver
    
Arguments:
    
    None.

Return Value:

        None.

--*/
{

    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes; 
    NTSTATUS Status;
    HANDLE Handle;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Cancel IP Ioctl: Entering.\n")));

    RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                        );
    
    if (!NT_SUCCESS(Status)) {
        // Well, well IP Driver was probably never loaded.
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC Cancel IP IOCTL: Exiting (2).\n")));
        return;
    }
    ZwCancelIoFile(Handle,
                   &IoStatusBlock
                   );
    ZwClose(Handle);


}

VOID
XmlCmdDoMachineInformationCommand(
    VOID
    )
/*++

Routine Description:

    This function displays the contents of a buffer, which in turn contains
    a bunch of machine-specific information that can be used to help identify
    the machine.
    
Arguments:
    
    None.

Return Value:

    None.

--*/
{
    LARGE_INTEGER   TickCount;
    LARGE_INTEGER   ElapsedTime;
    ULONG           ElapsedHours = 0;
    ULONG           ElapsedMinutes = 0;
    ULONG           ElapsedSeconds = 0;
    PWSTR           TmpBuffer;
    PWSTR           MIBuffer;
    NTSTATUS        Status;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Display Machine Information: Entering.\n")));

    //
    // If the information buffer hasn't been filled in yet, there's not much we can do.
    //
    if( MachineInformation == NULL ) {

        //
        // He's empty.  This shouldn't have happened though because
        // he gets filled as soon as we're initialized.
        //

        IF_SAC_DEBUG( SAC_DEBUG_FUNC_TRACE_LOUD, 
                      KdPrint(("SAC Display Machine Information: MachineInformationBuffer hasn't been initialized yet.\n")));

        XmlMgrSacPutErrorMessage(L"get-machine-info", L"SAC_IDENTIFICATION_UNAVAILABLE");
        
        return;
    }

    //
    // Build and display Elapsed machine uptime.
    //

    // Elapsed TickCount
    KeQueryTickCount( &TickCount );

    // ElapsedTime in seconds.
    ElapsedTime.QuadPart = (TickCount.QuadPart)/(10000000/KeQueryTimeIncrement());

    ElapsedHours = (ULONG)(ElapsedTime.QuadPart / 3600);
    ElapsedMinutes = (ULONG)(ElapsedTime.QuadPart % 3600) / 60;
    ElapsedSeconds = (ULONG)(ElapsedTime.QuadPart % 3600) % 60;

    TmpBuffer = (PWSTR)ALLOCATE_POOL( 0x100, GENERAL_POOL_TAG );

    if(! TmpBuffer ) {
        return;
    }
        
    //
    // Construct the <uptime>...</uptime> element
    //
    swprintf( 
        TmpBuffer,
        L"<uptime>\r\n<hours>%d</hours>\r\n<minutes>%02d</minutes>\r\n<seconds>%02d</seconds>\r\n</uptime>\r\n",
        ElapsedHours,
        ElapsedMinutes,
        ElapsedSeconds
        );

    //
    // Get machine information
    //
    Status = TranslateMachineInformationXML(
        &MIBuffer, 
        TmpBuffer
        );

    if (! NT_SUCCESS(Status)) {
        XmlMgrSacPutErrorMessage(L"get-machine-info", L"SAC_IDENTIFICATION_UNAVAILABLE");
        FREE_POOL(&TmpBuffer);
        return;
    }
    
    //
    // Display the machine info portion
    //
    XmlMgrSacPutString(MIBuffer);

    FREE_POOL(&TmpBuffer);
    FREE_POOL(&MIBuffer);

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC Display Machine Information: Exiting.\n"))
        );

    return;
    
}

VOID
XmlCmdDoChannelCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine lists the channels if a NULL name is given, otw it closes the channel
    of the given name.

Arguments:

    InputLine - The user's input line.

Return Value:

    None.

--*/
{
    PUCHAR pch;
    WCHAR Name[SAC_MAX_CHANNEL_NAME_LENGTH+1];
    PSAC_CHANNEL Channel;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoChannelCommand: Entering.\n")));

    //
    // Get channel name
    //
    pch = InputLine;
    pch += (sizeof(CHANNEL_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (*pch == '\0') {

        NTSTATUS    Status;
        ULONG       i;

        //
        // List all the channels
        //
        XmlMgrSacPutString(L"<channel-list>\r\n");

        //
        // Iterate through the channels and display the attributes
        // of the active channels
        //
        for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
            
            //
            // Query the channel manager for a list of all currently active channels
            //
            Status = ChanMgrGetByIndex(
                i,
                &Channel
                );

            if (! NT_SUCCESS(Status)) {
                goto DoChannelCommandCleanup;
            }

            if (Channel == NULL) {
                ChanMgrReleaseChannelByIndex(i);
                continue;
            }
            
            //
            // construct channel attribute information
            //
            XmlMgrSacPutString(L"<channel>\r\n");
            
            swprintf(
                (PWSTR)GlobalBuffer,
                L"<hasnewdata>%s</hasnewdata>\r\n",
                ChannelHasNewOBufferData(Channel) ? L"true" : L"false"
                );
            XmlMgrSacPutString((PWSTR)GlobalBuffer);

            swprintf(
                (PWSTR)GlobalBuffer,
                L"<status>%s</status>\r\n",
                ChannelGetStatus(Channel) ? L"active" : L"inactive"
                );
            XmlMgrSacPutString((PWSTR)GlobalBuffer);
            
            swprintf(
                (PWSTR)GlobalBuffer,
                L"<type>%s</type>\r\n",
                ChannelGetType(Channel) == ChannelTypeVT100 ? L"VT100" : L"RAW"
                );
            XmlMgrSacPutString((PWSTR)GlobalBuffer);

            swprintf(
                (PWSTR)GlobalBuffer,
                L"<name>%s</name>\r\n",
                ChannelGetName(Channel)
                );
            XmlMgrSacPutString((PWSTR)GlobalBuffer);

            XmlMgrSacPutString(L"</channel>\r\n");

            //
            // We are done with the channel
            //
            Status = ChanMgrReleaseChannel(Channel);
        
            if (! NT_SUCCESS(Status)) {
                break;
            }

        }

        XmlMgrSacPutString(L"</channel-list>\r\n");
    
    } else {

        ULONG       Count;
        
        //
        // Copy the ASCII to Unicode
        //
        Count = ConvertAnsiToUnicode(Name, pch, SAC_MAX_CHANNEL_NAME_LENGTH+1);

        ASSERT(Count > 0);
        if (Count == 0) {
            goto DoChannelCommandCleanup;
        }

        //
        // make sure the user isn't trying to delete the SAC channel
        //
        if (_wcsicmp(Name, PRIMARY_SAC_CHANNEL_NAME) == 0) {

            XmlMgrSacPutErrorMessage(L"channel-close", L"SAC_CANNOT_REMOVE_SAC_CHANNEL");

        } else {

            NTSTATUS    Status;

            Status = ChanMgrGetChannelByName(Name, &Channel);

            if (NT_SUCCESS(Status)) {
                
                SAC_CHANNEL_HANDLE  Handle;

                //
                // Get the channel handle
                //
                Handle = Channel->Handle;

                //
                // We are done with the channel
                //
                ChanMgrReleaseChannel(Channel);
            
                //
                // Notify the Console Manager that the 
                //
                // Note: we can't own the channel when we call
                //       this function since it acquires the lock also
                //
                Status = XmlMgrHandleEvent(
                    IO_MGR_EVENT_CHANNEL_CLOSE,
                    &Handle              
                    );
            
                if (NT_SUCCESS(Status)) {
                    XmlMgrSacPutString(L"<channel-close status='success'/>\r\n");
                } else {
                    XmlMgrSacPutString(L"<channel-close status='failure'/>\r\n");
                }

            } else {

                XmlMgrSacPutErrorMessage(L"channel-close", L"SAC_CHANNEL_NOT_FOUND");
            
            }

        }

    }

DoChannelCommandCleanup:

    return;
    
}

VOID
XmlCmdDoCmdCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine launches a Command Console Channel

Arguments:

    InputLine - The user's input line.

Return Value:

    None.

--*/
{
    PUCHAR pch;
    WCHAR Name[SAC_MAX_CHANNEL_NAME_LENGTH+1];
    PLIST_ENTRY ListEntry;
    PSAC_CHANNEL Channel;
    NTSTATUS    Status;
    BOOLEAN     IsUniqueName;
    KIRQL       OldIrql;
    KIRQL       OldIrql2;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCmdCommand: Entering.\n")));

    KeWaitForMutexObject(
        &SACCmdEventInfoMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    //
    // Before we do anything with the cmd operation, make sure
    // the user-mode service has registered itself with us. If not,
    // then there is no point in going further.
    //
    if (!UserModeServiceHasRegisteredCmdEvent()) {

        //
        // inform the user
        //

        XmlMgrSacPutErrorMessage(L"cmd-channel", L"SAC_CMD_SERVICE_NOT_REGISTERED");
    
        goto DoCmdCommandCleanup;
    }

    //
    // Fire the event in the user-mode app that is responsible for launching
    // the cmd console channel
    //
    Status = InvokeUserModeService();

    if (Status == STATUS_TIMEOUT) {
        //
        // Service didn't respond in Timeout period.  
        // Service may not be working properly or usermode is unresponsive
        //
        XmlMgrSacPutString(L"<cmd-channel status='timed-out'>\r\n");

    } else if (NT_SUCCESS(Status)) {

        XmlMgrSacPutString(L"<cmd-channel status='success'>\r\n");

    }