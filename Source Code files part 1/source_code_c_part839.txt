ID of object generating event
                LONG idChild   - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
	Notes:		Maybe change this to only take combo-boxes?
*************************************************************************/
BOOL OnSelectChangedEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                          DWORD dwmsTimeStamp)
{
    HRESULT         hr;
    IAccessible*    pIAcc;
    OBJINFO         objCurrent;
	VARIANT         varRole;
    VARIANT         varChild;

    // if we've not had a cursor style movement then sack this as it could be 
    // scroll bar chaging or slider moving etc to reflect rapidy moving events

    hr = AccessibleObjectFromEvent (hwnd, idObject, idChild, &pIAcc, &varChild);
    if (SUCCEEDED(hr))
    {
        objCurrent.hwnd = hwnd;
        objCurrent.plObj = (long*)pIAcc;
	    objCurrent.varChild = varChild;
	    
	    VariantInit(&varRole); // heuristic!
	    hr = pIAcc->get_accRole(varChild, &varRole);
	    if ( FAILED(hr) )
	    {
            pIAcc->Release();
            return FALSE;
	    }

	    if (varRole.vt == VT_I4 &&
		    varRole.lVal == ROLE_SYSTEM_LISTITEM) 
        {
			TCHAR buffer[100];
			GetClassName(hwnd,buffer,100); // Is it sysListView32

            // "Don't mute here ... we lose the previous speech message which will
			// have spoken the list item IF we were cursoring to list item.
			// SpeakMute(0);
		    // don't speak unless it's a listitem
		    // e.g. Current Selection for Joystick from Joystick setup.
		    // this does mean that some list items get spoken twice!:AK
			// if ( lstrcmpi(buffer, CLASS_LISTVIEW) != 0)
			if ( !g_pGlobalData->fListFocus )
				SpeakObjectInfo(&objCurrent,FALSE);

			g_pGlobalData->fListFocus = FALSE;
	    }
        pIAcc->Release();
    }
	
    return(TRUE);
}

/*************************************************************************
    Function:   OnFocusChangedEvent
    Purpose:    Receives focus events
    Inputs:     DWORD event    - What event are we processing
                HWND hwnd      - HWND of window generating event
                LONG idObject  - ID of object generating event
                LONG idChild   - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
*************************************************************************/
BOOL OnFocusChangedEvent(DWORD event, HWND hwnd, LONG idObject, 
                         LONG idChild, DWORD dwmsTimeStamp)
{
    HRESULT         hr;
    TCHAR           szName[256];
	TCHAR           buffer[100];
    IAccessible*    pIAcc;
    VARIANT         varChild;
	VARIANT         varRole;
	VARIANT         varState;
	BOOL			switchWnd = FALSE;

	hr = AccessibleObjectFromEvent (hwnd, idObject, idChild, &pIAcc, &varChild);
    if (FAILED(hr))
		return FALSE;

	// Check for Bogus events...
	if( !IsFocussedItem(hwnd, pIAcc, varChild) )
	{
		pIAcc->Release();
		return FALSE;
	}

	// Ignore the first Start pressed events...
	if ( g_pGlobalData->fStartPressed )
	{
		g_pGlobalData->fStartPressed = FALSE;
		pIAcc->Release();
		return FALSE;
	}

	g_pGlobalData->fDoingPassword = FALSE;
	
	// Have we got a password char in this one
	// if so then tell them and get out
	VariantInit(&varState); 
	hr = pIAcc->get_accState(varChild, &varState);
    if ( FAILED(hr) )
    {
        pIAcc->Release();
        return FALSE;
    }

    if ( varState.vt == VT_EMPTY )
        varState.lVal = 0;
    
	g_pGlobalData->fDoingPassword = (varState.lVal & STATE_SYSTEM_PROTECTED);

	GetClassName(hwnd,buffer,100); // is it Internet Explorer in any of its many forms?
    DBPRINTF(TEXT("OnFocusChangedEvent:  class name = %s\r\n"), buffer);
	g_pGlobalData->fInternetExplorer = IsTridentWindow(buffer);
    g_pGlobalData->fHTML_Help = FALSE;

	if (lstrcmpi(buffer, CLASS_WINSWITCH) == 0)
		switchWnd = TRUE;

	GetClassName(GetForegroundWindow(),buffer,100);
	if ((lstrcmpi(buffer, CLASS_HTMLHELP) == 0)|| (lstrcmpi(buffer, CLASS_IE_FRAME) == 0) ) { // have we got HTML Help?
		g_pGlobalData->fInternetExplorer = TRUE;
		g_pGlobalData->fHTML_Help = TRUE;
	}

    // Check to see if we are getting rapid focus changes
    // Consider using the Time stamp and saving away the last object
    
	VariantInit(&varRole); 

    // If the focus is being set to a list, a combo, or a dialog, 
    // don't say anything. We'll say something when the focus gets
    // set to one of the children.

	hr = pIAcc->get_accRole(varChild, &varRole); // heuristic!
	if ( FAILED(hr) )
	{
        pIAcc->Release();
        return FALSE;
	}

	// Special casing stuff.. Avoid repeatation for list items...
	// Required to correctly process Auto suggest list boxes.
	// As list items also send SelectionChange : AK
	if (varRole.vt == VT_I4 )
    {
		switch ( varRole.lVal )
		{
			case ROLE_SYSTEM_DIALOG:
				pIAcc->Release();
				return FALSE; 
				break;

			case ROLE_SYSTEM_TITLEBAR:
				g_pGlobalData->fMouseUp = FALSE;
				break;

			case ROLE_SYSTEM_LISTITEM:
				g_pGlobalData->fListFocus = TRUE;
				break;

			default:
				break;
		}
	}


	if (idObject == OBJID_WINDOW) 
    {
		SpeakMute(0);
		SpeakStringId(IDS_WINDOW);
		GetWindowText(hwnd, szName, sizeof(szName)/sizeof(TCHAR));	// raid #113789
		SpeakString(szName);
	}

	RECT rcCursor;
	
	if ( pIAcc->accLocation(&rcCursor.left, &rcCursor.top, &rcCursor.right, &rcCursor.bottom, varChild) == S_OK )
	{
        const POINT ptLoc = { rcCursor.left + (rcCursor.right/2), rcCursor.top + (rcCursor.bottom/2) };
  
    	if (g_pGlobalData->fTrackInputFocus && g_pGlobalData->fMouseUp) 
        {
            
            POINT CursorPosition;		
            GetCursorPos(&CursorPosition);
            // mouse to follow if it's not already in rectangle 
            // (e.g manually moving mouse in menu) and mouse button up
    		if (CursorPosition.x < rcCursor.left 
    			|| CursorPosition.x > (rcCursor.left+rcCursor.right)
    			|| CursorPosition.y < rcCursor.top
    			|| CursorPosition.y > (rcCursor.top+rcCursor.bottom))
    		{
            	g_ptMoveCursor.x = ptLoc.x;
            	g_ptMoveCursor.y =  ptLoc.y;

            	// If we set the cursor immediately extraneous events the 
            	// hovering on menu items causes feed back which results 
            	// in the cursor going back and forth between menu items.  
            	// This code sets a timer so that the cursor is set after things settle down
                if ( g_uTimer == 0 )
                    g_uTimer = SetTimer( NULL, 0, 100, TrackCursor );

                // If the focus events are from cursor movement this will ignore the extra
                // event that cause the feed back
                if ( g_pGlobalData->nMsrDoNext != MSR_DONOWT )
                    g_pGlobalData->fMouseUp = FALSE;
    		}
    	}
    	else
    	{
    	    SetSecondary(ptLoc.x, ptLoc.y, FALSE);
    	}
	}
	OBJINFO objCurrent;

	objCurrent.hwnd = hwnd;
	objCurrent.plObj = (long*)pIAcc;
	objCurrent.varChild = varChild;
	
	// If the event is from the switch window, 
	// Then mute the current speech before proceeding...AK
	if ( switchWnd && g_pGlobalData->fListFocus )
		SpeakMute(0);

    DBPRINTF(TEXT("OnFocusChangedEvent:  Calling SpeakObjectInfo...\r\n"));
	SpeakObjectInfo(&objCurrent,TRUE);
	
	if (g_pGlobalData->fDoingPassword)
	{
		pIAcc->Release();
		return FALSE;
	}

	if (g_pGlobalData->nSpeakWindowSoon) 
    {   
        DBPRINTF(TEXT("OnFocusChangedEvent:  Calling SpeakWindow\r\n"));
		SpeakWindow(0);
		g_pGlobalData->nSpeakWindowSoon = FALSE;
	}
    pIAcc->Release();

    return TRUE;
}


/*************************************************************************
    Function:   OnStateChangedEvent
    Purpose:    Receives focus events
    Inputs:     DWORD event    - What event are we processing
                HWND hwnd      - HWND of window generating event
                LONG idObject  - ID of object generating event
                LONG idChild   - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
*************************************************************************/
BOOL OnStateChangedEvent(DWORD event, HWND hwnd, LONG idObject, 
                         LONG idChild, DWORD dwmsTimeStamp)
{
    HRESULT         hr;
    IAccessible*    pIAcc;
    VARIANT         varChild;
	VARIANT         varRole;

	hr = AccessibleObjectFromEvent (hwnd, idObject, idChild, &pIAcc, &varChild);
    if (FAILED(hr))
        return (FALSE);

	// Check for Bogus events...
	if( !IsFocussedItem(hwnd, pIAcc, varChild) )
	{
		pIAcc->Release();
		return (FALSE);
	}

	VariantInit(&varRole); 

	hr = pIAcc->get_accRole(varChild, &varRole); 
    if ( FAILED(hr) )
    {
        pIAcc->Release();
        return FALSE;
    }
	    
	// Special casing stuff.. Handle State change for 
	// Outline items only for now
	if (varRole.vt == VT_I4 )
    {
		switch ( varRole.lVal )
		{
			case ROLE_SYSTEM_OUTLINEITEM:
				{
					OBJINFO objCurrent;

					objCurrent.hwnd = hwnd;
					objCurrent.plObj = (long*)pIAcc;
					objCurrent.varChild = varChild;
					
					SpeakObjectInfo(&objCurrent,TRUE);
				}
				break;

			default:
				break;
		}
	}

    pIAcc->Release();
    return(TRUE);
}

/*************************************************************************
    Function:   OnLocationChangedEvent
    Purpose:    Receives location change events - for the caret
    Inputs:     DWORD event    - What event are we processing
                HWND hwnd      - HWND of window generating event
                LONG idObject  - ID of object generating event
                LONG idChild   - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
*************************************************************************/
BOOL OnLocationChangedEvent(DWORD event, HWND hwnd, LONG idObject, 
                            LONG idChild, DWORD dwmsTimeStamp)
{
	//
	// Get the caret position and save it.
	//
	
	// flag set by key down code - here do appropriate action after 
	// caret has moved

	if (g_pGlobalData->nMsrDoNext) 
	{ // read char, word etc.
		WORD    wLineNumber;
		WORD    wLineIndex;
		WORD    wLineLength;
		DWORD   dwGetSel;
		DWORD    wStart;
		DWORD    wEnd;
		WORD    wColNumber;
		WORD    wEndWord;
        LPTSTR  pszTextShared;
        HANDLE  hProcess;
        int     nSomeInt;
		int *p; // PB 22 Nov 1998 Use this to get the size of the buffer in to array
		DWORD   LineStart;
		// Send the EM_GETSEL message to the edit control.
		// The low-order word of the return value is the character
		// position of the caret relative to the first character in the
		// edit control.
		dwGetSel = (WORD)SendMessage(hwnd, EM_GETSEL, (WPARAM)(LPDWORD) &wStart, (LPARAM)(LPDWORD) &wEnd);
		if (dwGetSel == -1) 
		{
			return FALSE;
		}
		
		LineStart = wStart;

		// New: Check for the selected text: AK
		if ( g_pGlobalData->nMsrDoNext == MSR_DOCHARR ) 
			LineStart = wEnd;
		else if ( g_pGlobalData->nMsrDoNext == MSR_DOLINED )
			LineStart = wEnd - 1;
		else if ( g_pGlobalData->nMsrDoNext == MSR_DOWORDR )
			LineStart = wEnd;

        // SteveDon: get the line for the start of the selection 
		wLineNumber = (WORD)SendMessage(hwnd,EM_LINEFROMCHAR, LineStart, 0L);
        
        // get the first character on that line that we're on.
		wLineIndex = (WORD)SendMessage(hwnd,EM_LINEINDEX, wLineNumber, 0L);
		
        // get the length of the line we're on
		wLineLength = (WORD)SendMessage(hwnd,EM_LINELENGTH, LineStart, 0L);
		
		// Subtract the LineIndex from the start of the selection,
		// This result is the column number of the caret position.
		wColNumber = LineStart - wLineIndex;

        // if we can't hold the text we want, say nothing.
		if (wLineLength > MAX_TEXT) 
		{
			return FALSE;
		}
		
        // To get the text of a line, send the EM_GETLINE message. When 
        // the message is sent, wParam is the line number to get and lParam
        // is a pointer to the buffer that will hold the text. When the message
        // is sent, the first word of the buffer specifies the maximum number 
        // of characters that can be copied to the buffer. 
        // We'll allocate the memory for the buffer in "shared" space so 
        // we can all see it. 
        // Allocate a buffer to hold it

		
		// PB 22 Nov 1998  Make it work!!! next 6 lines new.  Use global shared memory to do this!!!
        nSomeInt = wLineLength+1;
		if (nSomeInt >= 2000)
				nSomeInt = 1999;
		p = (int *) g_pGlobalData->pszTextLocal;
		*p = nSomeInt;
        SendMessage(hwnd, EM_GETLINE, (WPARAM)wLineNumber, (LPARAM)g_pGlobalData->pszTextLocal);
		g_pGlobalData->pszTextLocal[nSomeInt] = 0;

		// At this stage, pszTextLocal points to a (possibly) empty string.
		// We deal with that later...

		switch (g_pGlobalData->nMsrDoNext) 
		{
			case MSR_DOWORDR:
			case MSR_DOWORD:
				if (wColNumber >= wLineLength) 
				{
					SpeakMute(0);
					SpeakStringId(IDS_LINEEND);
					break;
				}
				else 
				{
					for (wEndWord = wColNumber; wEndWord < wLineLength; wEndWord++) 
					{
						if (g_pGlobalData->pszTextLocal[wEndWord] <= ' ') 
						{
							break;
						}
					} 
					wEndWord++;
					if (wEndWord-wColNumber < ARRAYSIZE(g_pGlobalData->pszTextLocal))
					{
					    lstrcpyn(g_pGlobalData->pszTextLocal,g_pGlobalData->pszTextLocal+wColNumber,wEndWord-wColNumber);
					    g_pGlobalData->pszTextLocal[wEndWord-wColNumber] = TEXT('\0');
					}
					SpeakMute(0);
					SpeakStringAll(g_pGlobalData->pszTextLocal);
				}
				break;
			
			case MSR_DOCHARR:
					wColNumber = LineStart - wLineIndex - 1;
					// Fall Through
			case MSR_DOCHAR: // OK now read character to left and right

				if (wColNumber >= wLineLength)
				{
					SpeakMute(0);
					SpeakStringId(IDS_LINEEND);
				}
				else if (g_pGlobalData->pszTextLocal[wColNumber] == TEXT(' '))
				{
					SpeakMute(0);
					SpeakStringId(IDS_SPACE);
				}
				else 
				{
					g_pGlobalData->pszTextLocal[0] = g_pGlobalData->pszTextLocal[wColNumber];
					g_pGlobalData->pszTextLocal[1] = 0;
					SpeakMute(0);
					SpeakStringAll(g_pGlobalData->pszTextLocal);
				}
				break;

			case MSR_DOLINED:
					// Fall through
			case MSR_DOLINE:
				g_pGlobalData->pszTextLocal[wLineLength] = 0; // add null
				SpeakMute(0);
				SpeakStringAll(g_pGlobalData->pszTextLocal);
				break;
		} // end switch (g_pGlobalData->nMsrDoNext)
	} // end if (g_pGlobalData->nMsrDoNext)

    RECT            rcCursor;
    IAccessible*    pIAcc;
    HRESULT         hr;
    VARIANT         varChild;

   	SetRectEmpty(&rcCursor); // now sort out mouse position as apprpropriate

    
    hr = AccessibleObjectFromEvent (hwnd, idObject, idChild, &pIAcc, &varChild);
    if (SUCCEEDED(hr))
    {
    	hr = pIAcc->accLocation(&rcCursor.left, &rcCursor.top, 
	    						&rcCursor.right, &rcCursor.bottom, 
		    					varChild);
		// Move mouse cursor, Only when Track mouse option is selcted: AK
        if (SUCCEEDED(hr) && g_pGlobalData->fTrackInputFocus && g_pGlobalData->fTrackCaret && g_pGlobalData->fMouseUp )
        {
            const POINT ptLoc = { rcCursor.left + (rcCursor.right/2), rcCursor.top + (rcCursor.bottom/2) };
        	g_ptMoveCursor.x = ptLoc.x;
        	g_ptMoveCursor.y = ptLoc.y;
            if ( g_uTimer == 0 )
                g_uTimer = SetTimer( NULL, 0, 100, TrackCursor );
            else
                SetSecondary( ptLoc.x, ptLoc.y, FALSE );
        }
        pIAcc->Release();
    }
    
    return TRUE;
}

/*************************************************************************
    Function:   OnObjectShowEvent
    Purpose:    Receives object show events - This is used for balloon tips
    Inputs:     DWORD event    - What event are we processing
                HWND hwnd      - HWND of window generating event
                LONG idObject  - ID of object generating event
                LONG idChild   - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
*************************************************************************/
BOOL OnObjectShowEvent(DWORD event, HWND hwnd, LONG idObject, 
                            LONG idChild, DWORD dwmsTimeStamp)
{
    IAccessible* pAcc = NULL;
    HRESULT hr;
    VARIANT varChild;
    varChild.vt = VT_EMPTY;

    IAccessible* pAccTemp = NULL;
    VARIANT varChildTemp;
    varChildTemp.vt = VT_I4;
    varChildTemp.lVal = CHILDID_SELF;
    if( idObject == OBJID_WINDOW )
    {
        // Most common case - get the client object, check if role is balloon tip...
        hr = AccessibleObjectFromWindow( hwnd, OBJID_CLIENT, IID_IAccessible, (void **) &pAccTemp );
        if( hr == S_OK && pAccTemp )
        {
            if( !CheckIsBalloonTipElseRelease( pAccTemp, varChild, &pAcc, &varChild ) )
                return FALSE;
        }
    }
    // if we didn't find a balloon tip try and get it from the event instead
    if ( !pAcc && varChild.vt != VT_I4 )
    {
        hr = AccessibleObjectFromEvent( hwnd, idObject, idChild, &pAccTemp, &varChildTemp );
        if( hr == S_OK && pAccTemp )
        {
            if( !CheckIsBalloonTipElseRelease( pAccTemp, varChildTemp, &pAcc, &varChild ) )
                return FALSE;
        }
        else
        {
            return FALSE;
        }
    }
    
    TCHAR szRole[ 128 ] = TEXT("");
    VARIANT varRole;
    hr = pAcc->get_accRole( varChild, & varRole );
    if( hr == S_OK && varRole.vt == VT_I4 )
        GetRoleText( varRole.lVal, szRole, ARRAYSIZE( szRole ) );

    BSTR bstrName = NULL;

    TCHAR szName [ 1025 ] = TEXT("");
    TCHAR * pszName;
    hr = pAcc->get_accName( varChild, & bstrName );
    if( hr == S_OK && bstrName != NULL && bstrName[ 0 ] != '\0' )
    {
#ifdef UNICODE
        pszName = bstrName;
#else
        WideCharToMultiByte( CP_ACP, 0, bstrName, -1, szName, ARRAYSIZE( szName ), NULL, NULL );
        pszName = szName;
#endif
    }

    TCHAR szText[ 1025 ];
    lstrcpyn(szText, szRole, ARRAYSIZE(szText));
    lstrcatn(szText, TEXT(": "), ARRAYSIZE(szText));
    lstrcatn(szText, pszName, ARRAYSIZE(szText));
    szText[ARRAYSIZE(szText)-1] = TEXT('\0');
	SpeakString(szText);

	SysFreeString(bstrName);
	
    return TRUE;
}


/*************************************************************************
    Function:   InitMSAA
    Purpose:    Initalize the Active Accessibility subsystem, including
				initializing the helper thread, installing the WinEvent
				hook, and registering custom messages.
    Inputs:     none
    Returns:    BOOL - TRUE if successful
    History:    
*************************************************************************/
BOOL InitMSAA(void)
{
	CScopeMutex csMutex;
	if (!csMutex.Create(g_szMutexNarrator, c_nMutexWait))
		return FALSE;

    // Call this FIRST to initialize the helper thread
    InitHelperThread();

    // Set up event call back
    g_hEventHook = SetWinEventHook(EVENT_MIN,            // We want all events
                                 EVENT_MAX,            
                                 GetModuleHandle(TEXT("NarrHook.dll")), // Use our own module
                                 WinEventProc,         // Our callback function
                                 0,                    // All processes
                                 0,                    // All threads
                                 WINEVENT_OUTOFCONTEXT /* WINEVENT_INCONTEXT */);
// Receive async events
// JMC: For Safety, lets always be 'out of context'.  Who cares if there is a 
// performance penalty.
// By being out of context, we guarantee the we won't bring down other apps if 
// there is a bug in our  event hook.


    // Did we install correctly? 
    if (g_hEventHook) 
	{
        //
        // register own own message for giving the cursor position
        //
		g_pGlobalData->uMSG_MSR_Cursor = RegisterWindowMessage(TEXT("MSR cursor")); 
        return TRUE;
	}

    // Did not install properly - clean up and fail
    UnInitHelperThread();
    return FALSE;
}   



/*************************************************************************
    Function:   UnInitMSAA
    Purpose:    Shuts down the Active Accessibility subsystem
    Inputs:     none
    Returns:    BOOL - TRUE if successful
    History:    
*************************************************************************/
BOOL UnInitMSAA(void)
{
	CScopeMutex csMutex;
	if (csMutex.Create(g_szMutexNarrator, c_nMutexWait))
    {
        // Remove the WinEvent hook
	    UnhookWinEvent(g_hEventHook);

        // Call this LAST so that the helper thread can finish up. 
        UnInitHelperThread();
    }
    
    // return true; we're exiting and there's not much that can be done
    return TRUE;
}

// --------------------------------------------------------------------------
//
//  GetObjectAtCursor()
//
//  Gets the object the cursor is over.
//
// --------------------------------------------------------------------------
IAccessible * GetObjectAtCursor(VARIANT * pvarChild,HRESULT* pResult)
{
    POINT   pt;
    IAccessible * pIAcc;
    HRESULT hr;

    //
    // Get cursor object & position
    //
    if (g_pGlobalData->ptCurrentMouse.x < 0)
		GetCursorPos(&pt);
	else
		pt = g_pGlobalData->ptCurrentMouse;
	
    //
    // Get object here.
    //
    VariantInit(pvarChild);
    hr = AccessibleObjectFromPoint(pt, &pIAcc, pvarChild);

    *pResult = hr;
    if (!SUCCEEDED(hr)) {
        return NULL;
	}
    
    return pIAcc;
}


/*************************************************************************
    Function:   SpeakItem
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpeakItem(int nOption)
{
    TCHAR tszDesc[256];
    VARIANT varChild;
    IAccessible* pIAcc;
    HRESULT hr;
    POINT ptMouse;
    BSTR bstr;

	SpeakString(TEXT(" ")); // reset last utterence
    // Important to init variants
    VariantInit(&varChild);

    //
    // Get cursor object & position
    //
    if (g_pGlobalData->ptCurrentMouse.x < 0)
		GetCursorPos(&ptMouse);
	else
		ptMouse = g_pGlobalData->ptCurrentMouse;

    hr = AccessibleObjectFromPoint(ptMouse, &pIAcc, &varChild);
    
    // Check to see if we got a valid pointer
    if (SUCCEEDED(hr))
    {
        hr = pIAcc->get_accDescription(varChild, &bstr);
	    if ( FAILED(hr) )
            bstr = NULL;
	    
	    if (bstr)
		{
#ifdef UNICODE
			lstrcpyn(tszDesc,bstr,ARRAYSIZE(tszDesc));
            tszDesc[ARRAYSIZE(tszDesc)-1] = TEXT('\0');
#else
			// If we got back a string, use that instead.
			WideCharToMultiByte(CP_ACP, 0, bstr, -1, tszDesc, sizeof(tszDesc), NULL, NULL);
#endif
	        SysFreeString(bstr);
            SpeakStringAll(tszDesc);
		}
        if (pIAcc)
            pIAcc->Release();
        
    }
    return;
}



/*************************************************************************
    Function:   SpeakMute
    Purpose:    causes the system to shut up.
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpeakMute(int nOption)
{
	SendMessage(g_pGlobalData->hwndMSR, WM_MUTE, 0, 0);
}


/*************************************************************************
    Function:   SpeakObjectInfo
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpeakObjectInfo(LPOBJINFO poiObj, BOOL ReadExtra)
{
    BSTR            bstrName;
    IAccessible*    pIAcc;
    long*           pl;
    HRESULT         hr;
    CAutoArray<TCHAR> aaName( new TCHAR[MAX_TEXT] );
    TCHAR *         szName = aaName.Get();
    CAutoArray<TCHAR> aaSpeak( new TCHAR[MAX_TEXT] );
    TCHAR *         szSpeak = aaSpeak.Get();
    if ( !szName || !szSpeak )
        return;     // no memory
    
    
    TCHAR           szRole[MAX_TEXT_ROLE];  
    TCHAR           szState[MAX_TEXT_ROLE];
    TCHAR           szValue[MAX_TEXT_ROLE];
	VARIANT         varRole;
    VARIANT         varState;
	BOOL            bSayValue = TRUE;
	BOOL			bReadHTMLEdit = FALSE;
	DWORD			Role = 0;

    bstrName = NULL;
    
    // Truncate them 
    szName[0] = TEXT('\0');
    szSpeak[0] = TEXT('\0');
    szRole[0] = TEXT('\0');
    szState[0] = TEXT('\0');
    szValue[0] = TEXT('\0');

    // Get the object out of the struct
    pl = poiObj->plObj;
    pIAcc =(IAccessible*)pl;

	GetObjectProperty(pIAcc, poiObj->varChild.lVal, ID_NAME, szName, MAX_NAME);
	if (szName[0] == -1) // name going to be garbage
	{
		LoadString(g_Hinst, IDS_NAMELESS, szSpeak, MAX_TEXT); // For now change "IDS_NAMELESS" in Resources to be just space!
	}
	else
	{
		lstrcpyn(szSpeak, szName, MAX_TEXT);
		szSpeak[MAX_TEXT-1] = TEXT('\0');
	}

	szName[0] = TEXT('\0');

	VariantInit(&varRole);
	hr = pIAcc->get_accRole(poiObj->varChild, &varRole);

	if (FAILED(hr)) 
    {
		DBPRINTF (TEXT("Failed role!\r\n"));
		MessageBeep(MB_OK);
		return;
	}

	if (varRole.vt == VT_I4) 
    {
		Role = varRole.lVal; // save for use below (if ReadExtra)

    	GetRoleText(varRole.lVal,szRole, ARRAYSIZE(szRole));

		// Special casing stuff: 
		// Outline Items give out their level No. in the tree in the Value
		// field, So Don't speak it. 
		switch(varRole.lVal)
		{
			case ROLE_SYSTEM_STATICTEXT:
			case ROLE_SYSTEM_OUTLINEITEM:
			{
				bSayValue = FALSE; // don't speak value for text - it may be HTML link
			}
				break;

			// If the text is from combo -box then speak up 
			case ROLE_SYSTEM_TEXT:
				bReadHTMLEdit = TRUE;
				bSayValue = TRUE; // Speak text in combo box
				break;

			case ROLE_SYSTEM_LISTITEM:
			{
				FilterGUID(szSpeak); 
			}
			break;

            case ROLE_SYSTEM_SPINBUTTON:
				// Remove the Wizard97 spin box utterances....AK
				{
					HWND hWnd, hWndP;
					WindowFromAccessibleObject(pIAcc, &hWnd);
					if ( hWnd != NULL)
					{
						hWndP = GetParent(hWnd);

						LONG_PTR style = GetWindowLongPtr(hWndP, GWL_STYLE);
						if ( style & WS_DISABLED)
							return;
					}
				
				}
				break;

			default:
				break;
		}
	}
	
	if (g_pGlobalData->fDoingPassword)
        LoadString(g_Hinst, IDS_PASSWORD, szRole, 128);

    // This will free a BSTR, etc.
    VariantClear(&varRole);

	if ( (lstrlen(szRole) > 0) && 
		(varRole.lVal != ROLE_SYSTEM_CLIENT) ) 
    {
	    lstrcatn(szSpeak, TEXT(", "),MAX_TEXT);
	    lstrcatn(szSpeak, szRole, MAX_TEXT);
		szRole[0] = TEXT('\0');
	}

    //
    // add value string if there is one
    //
    hr = pIAcc->get_accValue(poiObj->varChild, &bstrName);
    if ( FAILED(hr) )
        bstrName = NULL;

    if (bstrName)
    {
#ifdef UNICODE
		lstrcpyn(szName, bstrName, MAX_TEXT);
        szName[MAX_TEXT-1] = TEXT('\0');
#else
		// If we got back a string, use that instead.
        WideCharToMultiByte(CP_ACP, 0, bstrName,-1, szName, MAX_TEXT, NULL, NULL);
#endif
        SysFreeString(bstrName);
    }

// ROBSI: 10-10-99, Bug?
// We are not properly testing bSayValue here. Therefore, outline items are
// speaking their indentation level -- their accValue. According to comments
// above, this should be skipped. However, below we are explicitly loading
// IDS_TREELEVEL and using this level. Which is correct?
	// If not IE, read values for combo box, Edit etc.., For IE, read only for edit boxes

	if ( ((!g_pGlobalData->fInternetExplorer && bSayValue ) 
		|| ( g_pGlobalData->fInternetExplorer && bReadHTMLEdit ) )
		&& lstrlen(szName) > 0)  
	{       // i.e. got a value
			lstrcatn(szSpeak,TEXT(", "),MAX_TEXT);
			lstrcatn(szSpeak,szName,MAX_TEXT);
			szName[0] = TEXT('\0');
	}

	hr = pIAcc->get_accState(poiObj->varChild, &varState);

	if (FAILED(hr)) 
    {
		MessageBeep(MB_OK);
		return;
	}

    if (varState.vt == VT_I4)
    {
        GetStateString(varState.lVal, STATE_MASK, szState, ARRAYSIZE(szState) );
    }

	if (lstrlen(szState) > 0) 
    {
	    lstrcatn(szSpeak, TEXT(", "), MAX_TEXT);
	    lstrcatn(szSpeak, szState, MAX_TEXT);
        szState[0] = TEXT('\0');
	}

	if (ReadExtra && ( // Speak extra information if just got focus on this item
		Role == ROLE_SYSTEM_CHECKBUTTON || 
		Role == ROLE_SYSTEM_PUSHBUTTON || 
		Role == ROLE_SYSTEM_RADIOBUTTON ||
        Role == ROLE_SYSTEM_MENUITEM || 
		Role == ROLE_SYSTEM_OUTLINEITEM || 
		Role == ROLE_SYSTEM_LISTITEM ||
		Role == ROLE_SYSTEM_OUTLINEBUTTON)
	   ) {
		switch (Role) {
			case ROLE_SYSTEM_CHECKBUTTON:
				{
					// Change due to localization issues:a-anilk
					TCHAR szTemp[MAX_TEXT_ROLE];
					
					if (varState.lVal & STATE_SYSTEM_CHECKED)
						LoadString(g_Hinst, IDS_TO_UNCHECK, szTemp, MAX_TEXT_ROLE);
					else
						LoadString(g_Hinst, IDS_TO_CHECK, szTemp, MAX_TEXT_ROLE);
					// GetObjectProperty(pIAcc, poiObj->varChild.lVal, ID_DEFAULT, szName, 256);
					// wsprintf(szTemp, szTempLate, szName);
					lstrcatn(szSpeak, szTemp, MAX_TEXT);
				}
				break;

			case ROLE_SYSTEM_PUSHBUTTON:
				{
					if ( !(varState.lVal & STATE_SYSTEM_UNAVAILABLE) )
					{
						LoadString(g_Hinst, IDS_TOPRESS, szName, 256);
						lstrcatn(szSpeak, szName, MAX_TEXT);
					}
				}
				break;

			case ROLE_SYSTEM_RADIOBUTTON:
	            LoadString(g_Hinst, IDS_TOSELECT, szName, 256);
				lstrcatn(szSpeak, szName, MAX_TEXT);
                break;

                // To distinguish between menu items with sub-menu and without one.
                // For submenus, It speaks - ', Has a sub-menu': a-anilk
            case ROLE_SYSTEM_MENUITEM:
                {
                    long count = 0;
                    pIAcc->get_accChildCount(&count);
                    
                    // count = 1 for all menu items with sub menus
                    if ( count == 1 || varState.lVal & STATE_SYSTEM_HASPOPUP )
                    {
                        LoadString(g_Hinst, IDS_SUBMENU, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
                    }
                }
				
				break;

			case ROLE_SYSTEM_OUTLINEITEM:
				{
					// Read out the level in the tree....
					// And also the status as Expanded or Collapsed....:AK
					TCHAR buffer[64];

					if ( varState.lVal & STATE_SYSTEM_COLLAPSED )
					{
						LoadString(g_Hinst, IDS_TEXPAND, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
					}
					else if ( varState.lVal & STATE_SYSTEM_EXPANDED )
					{
						LoadString(g_Hinst, IDS_TCOLLAP, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
					}
					
					hr = pIAcc->get_accValue(poiObj->varChild, &bstrName);

					LoadString(g_Hinst, IDS_TREELEVEL, szName, 256);
                    wsprintf(buffer, szName, bstrName);
					lstrcatn(szSpeak, buffer, MAX_TEXT);
					
					SysFreeString(bstrName);
				}
				break;

			case ROLE_SYSTEM_LISTITEM:
				{
					// The list item is selectable, But not selected...:a-anilk
					if ( (varState.lVal & STATE_SYSTEM_SELECTABLE ) &&
							(!(varState.lVal & STATE_SYSTEM_SELECTED)) )
					{
						LoadString(g_Hinst, IDS_NOTSEL, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
					}
				}
				break;
            case ROLE_SYSTEM_OUTLINEBUTTON:
                {
					if ( varState.lVal & STATE_SYSTEM_COLLAPSED )
					{
						LoadString(g_Hinst, IDS_OB_EXPAND, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
					}
					else if ( varState.lVal & STATE_SYSTEM_EXPANDED )
					{
						LoadString(g_Hinst, IDS_OB_COLLAPSE, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
					}
                }
		}
	}

    SpeakString(szSpeak);

    return;
}

/*************************************************************************
    Function:   SpeakMainItems
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpeakMainItems(int nOption)
{
    VARIANT varChild;
    IAccessible* pIAcc=NULL;
    HRESULT hr;
    POINT ptMouse;
 
	SpeakString(TEXT(" "));

    //
    // Get cursor object & position
    //
    if (g_pGlobalData->ptCurrentMouse.x < 0)
		GetCursorPos(&ptMouse);
	else
		ptMouse = g_pGlobalData->ptCurrentMouse;

    // Important to init variants
    VariantInit(&varChild);

    hr = AccessibleObjectFromPoint(ptMouse, &pIAcc, &varChild);
   // Check to see if we got a valid pointer
    if (SUCCEEDED(hr))
    {
	        OBJINFO objCurrent;

	        objCurrent.hwnd = WindowFromPoint(ptMouse);
		    objCurrent.plObj = (long*)pIAcc;
			objCurrent.varChild = varChild;
			SpeakObjectInfo(&objCurrent,FALSE);
            pIAcc->Release();
	}
	return;
}


/*************************************************************************
    Function:   SpeakKeyboard
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpeakKeyboard(int nOption)
{
    TCHAR szName[128];
    VARIANT varChild;
    IAccessible* pIAcc;
    HRESULT hr;
    POINT ptMouse;

    //
    // Get cursor object & position
    //
    if (g_pGlobalData->ptCurrentMouse.x < 0)
		GetCursorPos(&ptMouse);
	else
		ptMouse = g_pGlobalData->ptCurrentMouse;

   // Important to init variants
   VariantInit(&varChild);
   hr = AccessibleObjectFromPoint(ptMouse, &pIAcc, &varChild);
    
    // Check to see if we got a valid pointer
    if (SUCCEEDED(hr))
    {
		SpeakStringId(IDS_KEYBOARD);

		GetObjectProperty(pIAcc, varChild.lVal, ID_SHORTCUT, szName, ARRAYSIZE(szName));
        SpeakString(szName);

        if (pIAcc)
            pIAcc->Release();
        
    }
    return;
}

/*************************************************************************
    Function:   Home
    Purpose:    
    Inputs:     
    Returns:    
    History:
    
      ALT_HOME to take secondary cursor to top of this window
*************************************************************************/
void Home(int x)
{
    RECT rect;
    GetWindowRect(GetForegroundWindow(),&rect);

	// Set it to show the title bar 48, max system icon size
    SetSecondary(rect.left + 48/*(rect.right - rect.left)/2*/, rect.top + 5,g_pGlobalData->fTrackSecondary);
    SpeakMainItems(0);
}


/*************************************************************************
    Function:   MoveToEnd
    Purpose:    
    Inputs:     
    Returns:    
    History:
    
        ALT_END to take secondary cursor to top of this window
*************************************************************************/
void MoveToEnd(int x)
{
    RECT rect;
    GetWindowRect(GetForegroundWindow(),&rect);

    SetSecondary(rect.left+ 48 /*(rect.right - rect.left)/2*/,rect.bottom - 8,g_pGlobalData->fTrackSecondary);
    SpeakMainItems(0);
}

#define LEFT_ID		0
#define RIGHT_ID	1
#define TOP_ID		2
#define BOTTOM_ID	3
#define SPOKEN_ID	4
#define SPATIAL_SIZE 2500
long ObjLocation[5][SPATIAL_SIZE];
int ObjIndex;

#define MAX_SPEAK 8192
/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpatialRead(RECT rc)
{
    int left_min, top_min, width_min, height_min, index_min; // current minimum object
    int i, j; // loop vars

    for (i = 0; i < ObjIndex; i++) 
    {
        left_min = 20000;
        top_min = 20000;
        index_min = -1;
        
        if (g_pGlobalData->fInternetExplorer)
        {
            for (j = 0; j < ObjIndex; j++) 
            {
                // Skip items that have been spoken before...
                if (ObjLocation[SPOKEN_ID][j] != 0)
                    continue;

                // if this is the first non-spoken object, just use it
                if( index_min == -1 )
                {
                    index_min = j;
                    top_min = ObjLocation[TOP_ID][j];
                    left_min = ObjLocation[LEFT_ID][j];
                    width_min = ObjLocation[RIGHT_ID][j];
                    height_min = ObjLocation[BOTTOM_ID][j];
                }
                else
                {
                    // If same top, different heights, and overlapping widths, then give smaller one priority
                    if( ObjLocation[TOP_ID][j] == top_min
                     && ObjLocation[BOTTOM_ID][j] != height_min
                     && ObjLocation[LEFT_ID][j] < left_min + width_min
                     && ObjLocation[LEFT_ID][j] + ObjLocation[RIGHT_ID][j] > left_min )
                    {
                        if( ObjLocation[BOTTOM_ID][j] < height_min )
                        {
                            index_min = j;
                            top_min = ObjLocation[TOP_ID][j];
                            left_min = ObjLocation[LEFT_ID][j];
                            width_min = ObjLocation[RIGHT_ID][j];
                            height_min = ObjLocation[BOTTOM_ID][j];
                        }
                    }
                    else if ( (ObjLocation[TOP_ID][j] < top_min  || // check if more top-left than previous ones - give or take on height (i.e. 5 pixels)
                              (ObjLocation[TOP_ID][j] == top_min && ObjLocation[LEFT_ID][j] < left_min ) ) ) // more left on this line
                    {
                        // OK got a candidate
                        index_min = j;
                        top_min = ObjLocation[TOP_ID][j];
                        left_min = ObjLocation[LEFT_ID][j];
                        width_min = ObjLocation[RIGHT_ID][j];
                        height_min = ObjLocation[BOTTOM_ID][j];
                    }
                }
            } // for j
        } // end if Internet Explorer
        else 
        {
            for (j = 0; j < ObjIndex; j++) 
            { 
                if (ObjLocation[SPOKEN_ID][j] == 0 && // not been spoken before
                    // check if enclosed by current rectangle (semi-hierarcical - with recursion!)
                    (ObjLocation[LEFT_ID][j] >= rc.left && ObjLocation[LEFT_ID][j] <= rc.left + rc.right &&
                     ObjLocation[TOP_ID][j] >= rc.top && ObjLocation[TOP_ID][j] <= rc.top + rc.bottom
                    ) &&
                    
                    // also check if more top-left than previous ones - give or take on height (i.e. 10 pixels)
                    ( (ObjLocation[TOP_ID][j] < top_min + 10 && ObjLocation[LEFT_ID][j] < left_min)
                    //      or just higher up
                    || (ObjLocation[TOP_ID][j] < top_min)
                    )
                   ) 
                { // OK got a candidate
                    index_min = j;
                    top_min = ObjLocation[TOP_ID][j];
                    left_min = ObjLocation[LEFT_ID][j];
                }
            } // for j
        } // end not Internet Explorer

        if (index_min >= 0) 
        { // got one!
            HWND hwndList; 
            CAutoArray<TCHAR> aaText( new  TCHAR[MAX_SPEAK] );
            TCHAR * szText = aaText.Get();
            RECT rect;
            ObjLocation[SPOKEN_ID][index_min] = 1; // don't do this one again
            hwndList = GetDlgItem(g_pGlobalData->hwndMSR, IDC_WINDOWINFO);
            // if the data does not fit don't say anything. 
            if (SendMessage(hwndList, LB_GETTEXTLEN, index_min, NULL) <= MAX_SPEAK)
            {
                SendMessage(hwndList, LB_GETTEXT, index_min, (LPARAM) szText);
                SpeakString(szText);
            }
            if (g_pGlobalData->fInternetExplorer) // no recursion for IE
                continue;
            rect.left = ObjLocation[LEFT_ID][index_min];
            rect.right = ObjLocation[RIGHT_ID][index_min];
            rect.top = ObjLocation[TOP_ID][index_min];
            rect.bottom = ObjLocation[BOTTOM_ID][index_min];
            SpatialRead(rect);
        }
    } // for i
}

//--------------------------------------------------------------------------
//
//  SpeakWindow()
//
//  Fills in a tree view with the descendants of the given top level window.
//  If hwnd is 0, use the previously saved hwnd to build the tree.
//
//--------------------------------------------------------------------------
void SpeakWindow(int nOption)
{
    IAccessible*  pacc;
    RECT rect;
    TCHAR szName[128];
    VARIANT varT;
    HWND ForeWnd;
    TCHAR buffer[100];

    szName[0] = NULL;
    buffer[0] = NULL;
    g_pGlobalData->nAutoRead = nOption; // set global flag to tell code in AddItem if we're to read edit box contents (don't do it if just got focus as the edit box has probably been spoken already
    
    ForeWnd = GetForegroundWindow();		// Check if we're in HTML Help
    GetClassName(ForeWnd,buffer,100); 
    g_pGlobalData->fHTML_Help = 0;
	if ((lstrcmpi(buffer, CLASS_HTMLHELP) == 0) ) 
    {
        g_pGlobalData->fInternetExplorer = TRUE;
        g_pGlobalData->fHTML_Help = TRUE;
        GetWindowRect(ForeWnd, &rect); // get the left hand side of our window to use later
        g_pGlobalData->nLeftHandSide = rect.left;
    }
    
	else if ( IsTridentWindow(buffer) )
	{
        g_pGlobalData->fInternetExplorer = TRUE;
        g_pGlobalData->fHTML_Help = FALSE;
        GetWindowRect(ForeWnd, &rect); // get the left hand side of our window to use later
        g_pGlobalData->nLeftHandSide = rect.left;
	}

    // Inititalise stack for tree information
    ObjIndex = 0; 
    //
    // Get the object for the root.
    //
    pacc = NULL;
    AccessibleObjectFromWindow(GetForegroundWindow(), OBJID_WINDOW, IID_IAccessible, (void**)&pacc);
    
    if (nOption == 1) 
    { // if it was a keyboard press then speak the window's name
        SpeakStringId(IDS_WINDOW);
        GetWindowText(GetForegroundWindow(), szName, sizeof(szName)/sizeof(TCHAR));	// raid #113789
        SpeakString(szName);
    }
    
    if (pacc)
    {
        HWND hwndList; // first clear the list box used to store the window info
        hwndList = GetDlgItem(g_pGlobalData->hwndMSR, IDC_WINDOWINFO);
        SendMessage(hwndList, LB_RESETCONTENT, 0, 0); 

        // AddAccessibleObjects changes this - so need to save and restore it
        // so that it is correct when we call SpatialRead...
        BOOL fIsInternetExplorer = g_pGlobalData->fInternetExplorer;

        InitChildSelf(&varT);
        AddAccessibleObjects(pacc, varT); // recursively go off and get the information
        pacc->Release();
        GetWindowRect(GetForegroundWindow(),&rect);

        if (g_pGlobalData->fReviewStyle) 
        {
            g_pGlobalData->fInternetExplorer = fIsInternetExplorer;

            SpatialRead(rect);
        }
    }
}

//--------------------------------------------------------------------------
//
//  AddItem()
//
//  Parameters:     pacc - the IAccessible object to [maybe] add
//                  varChild - if pacc is parent, the child id
//  Return Values:  Returns TRUE if caller should continue to navigate the
//                  UI tree or FALSE if it should stop.
//
//--------------------------------------------------------------------------
BOOL AddItem(IAccessible* pacc, const VARIANT &varChild)
{
    TCHAR           szName[MAX_NAME] = TEXT(" ");
    TCHAR           szRole[128] = TEXT(" ");
    TCHAR           szState[128] = TEXT(" ");
	TCHAR			szValue[MAX_VALUE] = TEXT(" ");
	TCHAR			szLink[32];
    VARIANT         varT;
    BSTR            bszT;
	BOOL			DoMore = TRUE;
	BOOL			GotStaticText = FALSE;
	BOOL			GotGraphic = FALSE;
	BOOL			GotText = FALSE;
	BOOL			GotNameless = FALSE;
	BOOL			GotInvisible = FALSE;
	BOOL			GotOffScreen = FALSE;
	BOOL			GotLink = FALSE;
	int				lastRole = 0;
	static TCHAR	szLastName[MAX_NAME] = TEXT(" ");

	BOOL fInternetExplorer = g_pGlobalData->fInternetExplorer;
	int nAutoRead = g_pGlobalData->nAutoRead;
	BOOL fHTMLHelp = g_pGlobalData->fHTML_Help;
	int nLeftHandSide = g_pGlobalData->nLeftHandSide;
	HWND hwndMSR = g_pGlobalData->hwndMSR;
	HRESULT hr;

    //
    // Get object state first.  If we are skipping invisible dudes, we want
    // to bail out now.
    //
    VariantInit(&varT);
    hr = pacc->get_accState(varChild, &varT);
    if ( FAILED(hr) )
    {
        DBPRINTF( TEXT("AddItem get_accState returned 0x%x\r\n"), hr ); 
        return FALSE;
    }
    
    DWORD dwState = 0;
    
    if (varT.vt == VT_I4)
    {
        LONG lStateMask = STATE_SYSTEM_UNAVAILABLE | STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_CHECKED;
        GetStateString(varT.lVal, lStateMask, szState, ARRAYSIZE(szState) );

        dwState = varT.lVal;

		GotInvisible = varT.lVal & STATE_SYSTEM_INVISIBLE;
		GotOffScreen = varT.lVal & STATE_SYSTEM_OFFSCREEN;

        // Bail out if not shown. If it's not IE, ignore both invisible and scrolled-off...
        if (!fInternetExplorer && GotInvisible) 
            return FALSE;

        // ...but if it's IE, only ignore 'really' invisible (display:none), and allow
        // scrolled-off (which has the offscreen bit set) to be read...
        if (fInternetExplorer && GotInvisible && ! GotOffScreen )
            return FALSE;
    }

    VariantClear(&varT);
    //
    // Get object role.
    //
    VariantInit(&varT);
    hr = pacc->get_accRole(varChild, &varT);
    if ( FAILED(hr) )
    {
        DBPRINTF( TEXT("AddItem get_accRole returned 0x%x\r\n"), hr ); 
        return FALSE;
    }

    LONG lRole = varT.lVal;
    
    if (varT.vt == VT_I4) 
    {
		switch (varT.lVal) 
        {
            case ROLE_SYSTEM_WINDOW: 
            case ROLE_SYSTEM_TABLE : 
            case ROLE_SYSTEM_DOCUMENT:
            {
                // it's a window - don't read it - read its kids
				return TRUE; // but carry on searching down
            }

            case ROLE_SYSTEM_LIST:       
            case ROLE_SYSTEM_SLIDER:     
            case ROLE_SYSTEM_STATUSBAR:
            case ROLE_SYSTEM_BUTTONMENU: 
            case ROLE_SYSTEM_COMBOBOX: 
            case ROLE_SYSTEM_DROPLIST:   
            case ROLE_SYSTEM_OUTLINE:    
            case ROLE_SYSTEM_TOOLBAR:
                DoMore = FALSE;    // i.e. speak it but no more children
                break;

            case ROLE_SYSTEM_GROUPING:
                if (fInternetExplorer)
                {
                    return TRUE;
                }
                else
                {
                    DoMore = FALSE;    // speak it but no more children
                }
                break;
                
            // Some of the CLIENT fields in office2000 are not spoken because 
            // we don't add. We may need to specail case for office :a-anilk
            // Micw:  Special case for IE and let the rest thru (Whistler raid #28777)
            case ROLE_SYSTEM_CLIENT : // for now work with this for IE ...???
                if (fInternetExplorer)
                {
                    return TRUE;
                }
                break;

            case ROLE_SYSTEM_PANE :
                if ( fInternetExplorer )
                {
                    LONG lLeft = 0, lTop = 0, lHeight = 0, lWidth = 0;
                    HRESULT hr = pacc->accLocation( &lLeft, &lTop, &lHeight, &lWidth, varChild );
                    
                    // If they don't know where they are don't speak them 
                    // We do not want to read zero width or height and the elements like in
                    // Remote Assistance or location of 0,0,0,0 like in oobe 
                    if ( hr != S_OK || lHeight == 0 || lWidth == 0 )
                    {
                        return FALSE;
                    }
                }

				return TRUE;

			case ROLE_SYSTEM_CELL: // New - works for HTML Help!
				return TRUE;

            case ROLE_SYSTEM_SEPARATOR:  
            case ROLE_SYSTEM_TITLEBAR: 
            case ROLE_SYSTEM_GRIP: 
            case ROLE_SYSTEM_MENUBAR:    
            case ROLE_SYSTEM_SCROLLBAR:
                return FALSE; // don't speak it or it's children

            case ROLE_SYSTEM_GRAPHIC: // this works for doing icons!
                GotGraphic = TRUE;
                break;

			case ROLE_SYSTEM_LINK:
				GotLink = TRUE;
				break;

            case ROLE_SYSTEM_TEXT:
                GotText = TRUE;
                break;
            case ROLE_SYSTEM_SPINBUTTON:
				// Remove the Wizard97 spin box utterances....
				{
					HWND hWnd, hWndP;
					WindowFromAccessibleObject(pacc, &hWnd);
					if ( hWnd != NULL)
					{
						hWndP = GetParent(hWnd);

						LONG_PTR style = GetWindowLongPtr(hWndP, GWL_STYLE);
						if ( style & WS_DISABLED)
                        {
							return FALSE;
                        }
					}
				
					DoMore = FALSE;    // i.e. speak it but no more children
				}

			case ROLE_SYSTEM_PAGETAB:
				// Hack to not read them if they are disabled...
				// Needed for WIZARD97 style :AK
				{
					HWND hWnd;
					WindowFromAccessibleObject(pacc, &hWnd);
					if ( hWnd != NULL)
					{
						LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
						if ( style & WS_DISABLED)
                        {
							return FALSE;
                        }
					}
				}
				break;
		} // switch

		
		GetRoleText(varT.lVal, szRole, 128);

// ROBSI: 10-10-99, BUG? Why (Role == Static) or (IE)??
		if (varT.lVal == ROLE_SYSTEM_STATICTEXT || fInternetExplorer) 
        {
            // don't speak role for this 
            // speech is better without
			szRole[0] = 0;                  
			GotStaticText = TRUE;
		}
	}
    else
    {
        szRole[0] = 0;	// lstrcpy(szRole, TEXT("UNKNOWN"));
    }

	VariantClear(&varT);

    //
    // Get object name.
    //
    bszT = NULL;
    hr = pacc->get_accName(varChild, &bszT);
    if ( FAILED(hr) )
        bszT = NULL;
       
    if (bszT)
    {
#ifdef UNICODE
		lstrcpyn(szName, bszT, MAX_NAME);
        szName[MAX_NAME-1] = TEXT('\0');
#else
        WideCharToMultiByte(CP_ACP, 0, bszT, -1, szName, MAX_NAME, NULL, NULL);
#endif
        SysFreeString(bszT);
		if (szName[0] == -1) 
        { // name going to be garbage
			LoadString(g_Hinst, IDS_NAMELESS, szName, 256);
			GotNameless = TRUE;
		}
    }
    else 
    {
		LoadString(g_Hinst, IDS_NAMELESS, szName, 256);
		GotNameless = TRUE;
	}

    bszT = NULL;
    hr = pacc->get_accValue(varChild, &bszT); // get value string if there is one
    if ( FAILED(hr) )
        bszT = NULL;
    
	szValue[0] = 0;
    if (bszT)
    {
#ifdef UNICODE
		lstrcpyn(szValue, bszT, MAX_VALUE);
        szValue[MAX_VALUE-1] = TEXT('\0');
#else
        WideCharToMultiByte(CP_ACP, 0, bszT, -1, szValue, MAX_VALUE, NULL, NULL);
#endif
        SysFreeString(bszT);
    }

    // There is no reason for us to speak client client client all time
    if ( GotNameless && lRole & ROLE_SYSTEM_CLIENT && szValue[0] == NULL )
        return TRUE;
    
    //
    // make sure these are terminated for the compare
    //
    szLastName[MAX_NAME - 1]=TEXT('\0');
    szName[MAX_NAME - 1]=TEXT('\0');

    //
    // don't want to repeat name that OLEACC got from static text
    // so if this name is the same as the previous name - don't speak it.
    //
	if (lstrcmp(szName,szLastName) == 0)
		szName[0] = 0; 

	if (GotStaticText)
	{
		lstrcpyn(szLastName, szName, MAX_NAME);
        szLastName[MAX_NAME-1] = TEXT('\0');
	}
	else
	{
		szLastName[0] = 0;
	}

    CAutoArray<TCHAR> aaItemString( new  TCHAR[MAX_TEXT] );
    TCHAR *         szItemString = aaItemString.Get();
    if ( !szItemString )
        return FALSE;       // no memory
        
	lstrcpyn(szItemString, szName, MAX_TEXT);
	szItemString[MAX_TEXT-1] = TEXT('\0');


    if (fInternetExplorer) 
    {
        if (GotText && szName[0] == 0)      // no real text
        {
            return FALSE;
        }
        
        if (GotNameless && szValue[0] == 0) // nameless with no link
        {
            return FALSE;
        }
        
        if (GotLink/*szValue[0]*/)  
        {
            // got a link
            // GotLink = TRUE;
            LoadString(g_Hinst, IDS_LINK, szLink, 32);
            lstrcatn(szItemString,szLink,MAX_TEXT);
        }
    }
    else
    {
        // the focused item has already been read so if the item does not have
        // focus it should be read in this case edit controls. 
        if (GotText && ( nAutoRead || !(dwState & STATE_SYSTEM_FOCUSED) ) )
            lstrcatn(szItemString,szValue,MAX_TEXT);
    }
    
    if (!GotText && !GotLink && !GotGraphic) 
    {
        
        if (lstrlen(szName) && lstrlen(szRole))
            lstrcatn(szItemString,TEXT(", "),MAX_TEXT);
        
        if (lstrlen(szRole)) 
        {
            lstrcatn(szItemString,szRole,MAX_TEXT);
            if (lstrlen(szValue) || lstrlen(szState))
                lstrcatn(szItemString, TEXT(", "),MAX_TEXT);
        }
        if (lstrlen(szValue)) 
        {
            lstrcatn(szItemString,szValue,MAX_TEXT);
            
            if (lstrlen(szState))
                lstrcatn(szItemString,TEXT(", "),MAX_TEXT);
        }
        if (lstrlen(szState))
            lstrcatn(szItemString,szState,MAX_TEXT);
        
		// Too much speech of period/comma. Just a space is fine...
        lstrcatn(szItemString, TEXT(" "),MAX_TEXT);
    }

    if (g_pGlobalData->fReviewStyle)  
    {
        HWND hwndList; 
        
        if (ObjIndex >= SPATIAL_SIZE) // only store so many
        {
            return DoMore;
        }
        
        pacc->accLocation(&ObjLocation[LEFT_ID][ObjIndex], 
                          &ObjLocation[TOP_ID][ObjIndex],
                          &ObjLocation[RIGHT_ID][ObjIndex], 
                          &ObjLocation[BOTTOM_ID][ObjIndex], 
                          varChild);
        
        // Dreadfull Hack/heuristic!
        // bin information as it's the left hand side of the HTML help window
        if (fHTMLHelp && (ObjLocation[LEFT_ID][ObjIndex] < nLeftHandSide + 220))
        {
            return DoMore;
        }
        
        hwndList = GetDlgItem(hwndMSR, IDC_WINDOWINFO);
        SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) szItemString); 
        ObjLocation[SPOKEN_ID][ObjIndex] = 0;
        ObjIndex++;
    }
    else
        SpeakString(szItemString);

    return DoMore;
}
        

// --------------------------------------------------------------------------
//
//  AddAccessibleObjects()
//    
//  This is a recursive function.  It adds an item for the parent, then 
//  adds items for its children if it has any.
//
//	Parameters:
//	IAccessible* pacc       Pointer to an IAccessible interface for the
//                          object being added. Start with the 'root' object.
//	VARIANT		 varChild	Variant that contains the ID of the child object
//                          to retrieve.
//
//	The first call, pIAcc points to the top level window object,
//					varChild is a variant that is VT_I4, CHILDID_SELF
// 
//  ISSUE:  The calling code isn't prepared to deal with errors so I'm making
//  the return void.  A re-engineered version should do better error handling.
//
void AddAccessibleObjects(IAccessible* pIAcc, const VARIANT &varChild)
{
	if (varChild.vt != VT_I4)
    {
        DBPRINTF(TEXT("BUG??: Got child ID other than VT_I4 (%d)\r\n"), varChild.vt);
		return;
    }

    // Find the window class so we can find embedded trdent windows
    HWND hwndCurrentObj;
    TCHAR szClassName[64];
    if ( WindowFromAccessibleObject( pIAcc, &hwndCurrentObj ) == S_OK )
    {
        if ( GetClassName( hwndCurrentObj, szClassName, ARRAYSIZE(szClassName) ) )
        {
            // is it Internet Explorer in any of its many forms?
            g_pGlobalData->fInternetExplorer = IsTridentWindow(szClassName);
        }
    }
    // Add the object itself and, if AddItem determines it wants children, do those

    if (AddItem(pIAcc, varChild))
    {
        // Traverse the children to see if any of them should be added

	    if (varChild.lVal != CHILDID_SELF)
		    return;	// only do this for container objects

        // Loop through pIAcc's children.

        long cChildren = 0;
        pIAcc->get_accChildCount(&cChildren);

	    if (!cChildren)
		    return;	// no children

	    // Allocate memory for the array of child variants
        CAutoArray<VARIANT> aaChildren( new VARIANT [cChildren] );
	    VARIANT * pavarChildren = aaChildren.Get();
	    if( ! pavarChildren )
	    {
            DBPRINTF(TEXT("Error: E_OUTOFMEMORY allocating pavarChildren\r\n"));
		    return;
	    }

	    long cObtained = 0;
	    HRESULT hr = AccessibleChildren( pIAcc, 0L, cChildren, pavarChildren, & cObtained );
	    if( hr != S_OK )
	    {
            DBPRINTF(TEXT("Error: AccessibleChildren returns 0x%x\r\n"), hr);
		    return;
	    }
	    else if( cObtained != cChildren)
	    {
            DBPRINTF(TEXT("Error: get_accChildCount returned %d but AccessibleChildren returned %d\r\n"), cChildren, cObtained);
		    return;
	    }
	    else 
	    {
		    // Loop through VARIANTs in ARRAY.  Object_Normalize returns a proper
            // pAccChild and varAccChild pair regardless of whether the array
            // element is VT_DISPATCH or VT_I4.

		    for( int i = 0 ; i < cChildren ; i++ )
		    {
			    IAccessible * pAccChild = NULL;
			    VARIANT       varAccChild;

			    // Object_Normalize consumes the variant, so no VariantClear() needed.

			    if( Object_Normalize( pIAcc, & pavarChildren[ i ], & pAccChild, & varAccChild ) )
			    {
				    AddAccessibleObjects(pAccChild, varAccChild);
				    pAccChild->Release();
			    }
		    }
	    }
    }
}

// --------------------------------------------------------------------------
// Helper method to filter out bogus focus events...
// Returns FALSE if the focus event is bogus, Otherwise returns TRUE
// a-anilk: 05-28-99
// --------------------------------------------------------------------------
BOOL IsFocussedItem( HWND hWnd, IAccessible * pAcc, VARIANT varChild )
{
	TCHAR buffer[100];

	GetClassName(hWnd,buffer,100); 
	// Is it toolbar, We cannot determine who had focus!!!
	if ((lstrcmpi(buffer, CLASS_TOOLBAR) == 0) ||
		(lstrcmpi(buffer, CLASS_IE_MAINWND) == 0))
			return TRUE;

	VARIANT varState;
	HRESULT hr;
	
	VariantInit(&varState); 
	hr = pAcc->get_accState(varChild, &varState);

	
	if ( hr == S_OK)
	{
		if ( ! (varState.lVal & STATE_SYSTEM_FOCUSED) )
			return FALSE;
	}
	else if (FAILED(hr)) // ROBSI: 10-11-99. If OLEACC returns an error, assume no focus.
	{
		return FALSE;
	}

	return TRUE;
}

#define TAB_KEY 0x09
#define CURLY_KEY 0x7B
// Helper method Filters GUID's that can appear in names: AK
void FilterGUID(TCHAR* szSpeak)
{
	// the GUID's have a Tab followed by a {0087....
	// If you find this pattern. Then donot speak that:AK
	
    TCHAR *szSpeakBegin = szSpeak;
	
	//  make sure the we don't go over MAX_TEXT.
	while(*szSpeak != NULL && (szSpeak-szSpeakBegin < MAX_TEXT-1))
	{
		if ( (*szSpeak == TAB_KEY) &&
			  (*(++szSpeak) == CURLY_KEY) )
		{
			*(--szSpeak) = NULL;
			return;
		}

		szSpeak++;
	}
}

///////////////////////////////////////////////////////////////////////////
// Helper functions 

// Convert an IDispatch to an IAccessible/varChild pair (Releases the IDispatch)

BOOL Object_IDispatchToIAccessible( IDispatch *     pdisp,
                                    IAccessible **  ppAccOut,
                                    VARIANT *       pvarChildOut)
{
    IAccessible * pAccTemp = NULL;
    HRESULT hr = pdisp->QueryInterface( IID_IAccessible, (void**) & pAccTemp );
    pdisp->Release();

    if( hr != S_OK || ! pAccTemp )
    {
        return FALSE;
    }

    *ppAccOut = pAccTemp;
    if( pvarChildOut )
    {
        InitChildSelf(pvarChildOut);
    }
    return TRUE;
}

// Given an IAccessible and a variant (may be I4 or DISP), returns a 'canonical'
// IAccessible/varChild, using getChild, etc.
// The variant is consumed.
BOOL Object_Normalize( IAccessible *    pAcc,
                       VARIANT *        pvarChild,
                       IAccessible **   ppAccOut,
                       VARIANT *        pvarChildOut)
{
	BOOL fRv = FALSE;

    if( pvarChild->vt == VT_DISPATCH )
    {
        fRv = Object_IDispatchToIAccessible( pvarChild->pdispVal, ppAccOut, pvarChildOut );
    }
    else if( pvarChild->vt == VT_I4 )
    {
        if( pvarChild->lVal == CHILDID_SELF )
        {
            // No normalization necessary...
            pAcc->AddRef();
            *ppAccOut = pAcc;
            pvarChildOut->vt = VT_I4;
            pvarChildOut->lVal = pvarChild->lVal;
            fRv = TRUE;
        } else
		{
			// Might still be a full object - try get_accChild...
			IDispatch * pdisp = NULL;
			HRESULT hr = pAcc->get_accChild( *pvarChild, & pdisp );

			if( hr == S_OK && pdisp )
			{
				// It's a full object...
				fRv = Object_IDispatchToIAccessible( pdisp, ppAccOut, pvarChildOut );
			}
			else
			{
				// Just a regular leaf node...
				pAcc->AddRef();
				*ppAccOut = pAcc;
				pvarChildOut->vt = VT_I4;
				pvarChildOut->lVal = pvarChild->lVal;
				fRv = TRUE;
			}	
		}
    }
    else
    {
        DBPRINTF( TEXT("Object_Normalize unexpected error") );
        *ppAccOut = NULL;    // unexpected error...
        VariantClear( pvarChild );
        fRv = FALSE;
    }

	return fRv;
}

/*************************************************************************
    THE INFORMATION AND CODE PROVIDED HEREUNDER (COLLECTIVELY REFERRED TO
    AS "SOFTWARE") IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN
    NO EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
    ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
    MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGES. SOME STATES DO NOT ALLOW THE EXCLUSION OR
    LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES SO THE
    FOREGOING LIMITATION MAY NOT APPLY.
*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\other.cpp ===
#include <windows.h>

#include "keys.h"

//--------------------------------------------------------------------------
// Description:
//   This implements lstrcat except that we always only cat up to the
//   passed on maxDest length.  This prevents cases where we cat past
//   the end of the destination buffer.
//
// Arguments:
//   pDest   - destination string to append to
//   pSrc    - src string to append 
//   maxDest - the maxuium number of characters of the destination buffer
//
// Returns: the destination buffer or NULL on error.  
//          GetLastError() will return the reason for the failure.
// 
//--------------------------------------------------------------------------
LPTSTR
lstrcatn(LPTSTR pDest, LPTSTR pSrc, int maxDest)
{
    int destLen;

    destLen=lstrlen(pDest);

    if (destLen < maxDest)
    {
        lstrcpyn(pDest+destLen,pSrc,maxDest-destLen);
        pDest[maxDest-1] = TEXT('\0');
        return pDest;
    }

    //
    // if the buffer is the exact length and we have nothing to append
    // then this is ok, just return the destination buffer.
    //
    if ((destLen == maxDest) && ((NULL == pSrc) || (*pSrc == TEXT('\0'))))
        return pDest;

    //
    // the destination buffer is too small, so return an error.
    //
    SetLastError(ERROR_INSUFFICIENT_BUFFER);

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\sources.inc ===
C_DEFINES=$(C_DEFINES)  -DUNICODE

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0500

TARGETNAME=NarrHook
TARGETPATH=obj
TARGETTYPE=DYNLINK
USE_MSVCRT=1
USE_NATIVE_EH=1
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\uuid.lib \
           $(SDK_LIB_PATH)\ole32.lib    \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\oleacc.lib

NOT_LEAN_AND_MEAN=1

DLLENTRY=_DllMainCRTStartup

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..\..\..\inc

SOURCES= ..\other.cpp   \
         ..\list.cpp    \
         ..\helpthd.cpp \
         ..\getprop.cpp \
         ..\keys.cpp    \
         ..\NarrHook.rc

UMTYPE=windows
UMRES=$(O)\main.res
DLLDEF=..\NarrHook.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\version.h ===
// NARRHOOK.DLL version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Microsoft Narrator Keyboard and WinEvent hook"
#define VER_INTERNALNAME_STR        "NARRHOOK"
#define VER_ORIGINALFILENAME_STR    "NARRHOOK.DLL"
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NarrHook.rc
//
#define IDD_DIALOG1                     103
#define TXT_NOMORE                      196
#define IDS_MENUEND                     197
#define IDS_MENU                        198
#define IDS_POPUP                       199
#define IDS_DIALOGEND                   200
#define IDS_WINDOW                      201
#define IDS_LINEEND                     202
#define IDS_KEYBOARD                    203
#define IDS_SPACE                       204
#define IDS_DELETE                      205
#define IDS_BACKSPACE                   206
#define IDS_TAB                         207
#define IDS_CONTROL                     208
#define IDS_ALT                         209
#define IDS_SHIFT                       210
#define IDS_RETURN                      211
#define IDS_POPUPEND                    212
#define IDS_NAMELESS                    213
#define IDS_SHOW                        214
#define IDS_VALUE                       216
#define IDS_FOREGROUND                  217
#define IDS_TOOLTIP                     218
#define IDS_LINESTART                   219
#define IDS_DIALOG                      220
#define IDS_LINK                        221
#define IDS_PASSWORD                    222
#define IDS_TOPRESS                     223
#define IDS_TOSELECT                    224
#define IDS_TO_CHECK                    225
#define IDS_PRESSSPACE                  226
#define IDS_SUBMENU                     227
#define IDS_TO_UNCHECK                  228
#define IDS_DRIVE                       230
#define IDS_TREELEVEL                   231
#define IDS_TEXPAND                     232
#define IDS_TCOLLAP                     233
#define IDS_LEAF                        234
#define IDS_ROOT                        235
#define IDS_NOTSEL                      236
#define IDS_WINKEY                      237
#define IDS_PASS                        238
#define IDS_INSERT                      239
#define IDS_HOME                        240
#define IDS_END                         241
#define IDS_PAGEUP                      242
#define IDS_PAGEDOWN                    243
#define IDS_CAPS_ON                     244
#define IDS_NUM_ON                      245
#define IDS_PRINT                       246
#define IDS_NUM_OFF                     247
#define IDS_CAPS_OFF                    248
#define IDS_ESC                         249
#define IDS_OB_EXPAND					250
#define IDS_OB_COLLAPSE					251


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\dgadvsca.h ===
INT_PTR AdvScanDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK AdvScanDlgProc(HWND hDlg, UINT message,
                                WPARAM wParam, LPARAM lParam);

void ConfigSwitchKey(UINT vk, BOOL bSet);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\credits.h ===
/* Modal dialog box procedure */

INT_PTR CALLBACK CreditsDlgProc(HWND hDlg, UINT message, 
                                WPARAM wParam, LPARAM lParam); 

 /* Startup procedure for modal dialog box */

INT_PTR CreditsDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL CreditsDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\about.h ===
// about.h


//**********************************************************************
// About dialog management
//**********************************************************************

//
// Modal dialog box procedure 
//
INT_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT message, 
                              WPARAM wParam, LPARAM lParam);

//
// Startup procedure for modal dialog box 
//

INT_PTR AboutDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam); 

BOOL AboutDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);




//**********************************************************************
// Initial Warning Message dialog management
//**********************************************************************
//
// Modal dialog box procedure 
//
INT_PTR CALLBACK WarningMsgDlgProc(HWND hDlg, UINT message, 
                              WPARAM wParam, LPARAM lParam);

//
// Startup procedure for modal dialog box 
//

INT_PTR WarningMsgDlgFunc(HWND hWnd); 

BOOL WarningMsgDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\door.h ===
/*****************************************************************************/
/*  Data structure for DEFAULT AND PREFERENCES SETTING                       */
/*****************************************************************************/

#ifndef _DOOR_H		//v_mjgran: To avoid data redefinitions
#define _DOOR_H

typedef struct tagKBPREFINFO
{
	//keyboard preference
	int 			g_margin;         	// Margin between rows and columns
	BOOL			smallKb;			// TRUE when working with Small Keyboard
	COLORREF		PrefTextKeyColor;  		// Prefered Color for text in keys
	COLORREF 		PrefCharKeyColor; 		// normal key
	COLORREF 		PrefModifierKeyColor;	// modifier key
	COLORREF 	    PrefDeadKeyColor; 		// dead key
	COLORREF		PrefBackgroundColor; 	// ditto Keyboard backgraund
	int			    PrefDeltakeysize;		// Preference increment in key size
	BOOL			PrefshowActivekey;		// Show cap letters in keys
    int				KBLayout;				// 101, 102, 106, KB layout
	BOOL			Pref3dkey;              // Use 3d keys
	BOOL			Prefusesound;			// Use click sound
	BOOL			PrefAlwaysontop;		// windows always on top control
	BOOL			Prefhilitekey;			// True for hilite eky under cursor
	BOOL			PrefDwellinkey;			// use dwelling system
	UINT			PrefDwellTime;	  		// Dwell time preference
	LOGFONTA	    lf;						// default font


	//import Dlg
	BOOL			DICT_LRNNEXT;
	BOOL			DICT_LRNNUM;
	BOOL			bReadLonger;
	BOOL			bWordToKeep;
	int			    minLength;
	long			maxWords;

	//Predict Dlg
	BOOL			typeFast;      //use clipboard ?
	BOOL			WListVisib;    //Word list visible
	BOOL			PredictNext;   //Predict next words
	BOOL    		Cap;           //Cap after period
	int    		    ShortestWord;  //Shorest Word
	int             space;         //how many space AFTER SENTENCE
	BOOL    		VorH;          //v = vertical h = horizontal word list
                                   //  (TRUE is V)
	int             WordShown;     //how many predict keys to create
	int			    WordFound;	   //how many words to find
	LOGFONTA        PredLF;        //store the font for predict window
	COLORREF		PredTextColor; //prefer color for predict text
    COLORREF        PredKeyColor;  //prefer color for predict key
    BOOL            AddSpace;      //Add space after , : ; or not

    //Scanning Option
    UINT            uKBKey;         // vk of scan key
    BOOL            bKBKey;         // use scan key
    BOOL            bPort;         // open the serial, parallel, game port 

	//Option Dlg
	BOOL			DICT_LRNNEW;
	BOOL			DICT_LRNFREQ;
	BOOL			DICT_PURGAUTO;
	BOOL			DICT_AUTOINCREASE;
	BOOL            WAIT_DLG_SHOWWORDS;

	//size and position of KB and Predictor
	RECT            KB_Rect;
	RECT            Pred_Rect;
    RECT            Pred_Crect;
	float           Pred_Width;
    float           Pred_Height;

	//HotKeys Dlg
	UINT            HotKeyList[30];    //array to store HotKeys
	BOOL            HK_F11;            //disable / enable the f11 hot key
	BOOL            HK_Show;
	UINT            Choice;            //choices for Func, numbers, keypad, all
	BOOL			HK_Enable;         //diasable / enable hotkey
	BOOL            HK_Front;
	BOOL			FastSel;

	BOOL            PrefScanning;      //use scanning
	UINT            PrefScanTime;
	
	BOOL			Actual;            // T - Actual or F - Block KB

	//Application preference
	BOOL			fShowWarningAgain;		// Show the initial warning dialog again


} KBPREFINFO;

typedef KBPREFINFO*  LPKBPREFINFO;

//
// Pointer to keyboard preference and other dialog option
// and the buffer we use to save and read from file
//
extern KBPREFINFO   *kbPref;   

#endif   //_DOOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\dgsett.h ===
//  dgSetting.h


/****************************************************************************/
/*    FUNCTIONS IN THIS FILE			*/
/****************************************************************************/
INT_PTR Type_ModeDlgFunc(HWND hWnd, UINT message,WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK Type_ModeDlgProc(HWND hDlg, UINT message, 
                                  WPARAM wParam, LPARAM lParam);

BOOL Type_ModeDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


void ChangeDwellTime(HWND hDlg, UINT message, WPARAM wParam);
void ChangeScanTime(HWND hDlg, UINT message, WPARAM wParam);
void SwitchToBlockKB(void);
void SwitchToActualKB(void);
void SwitchToJapaneseKB(void);
void SwitchToEuropeanKB(void);
void BlockKB(void);
void ActualKB(void);
void JapaneseKB(void);
void EuropeanKB(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\fileutil.h ===
/****************************************************************************/
/*    FUNCTIONS IN THIS FILE						    				    */
/****************************************************************************/
PSID GetCurrentUserInfo(void);
BOOL RunningAsAdministrator(void);
BOOL OpenUserSetting(void);
BOOL SaveUserSetting(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\init_end.h ===
/* Global vars */
extern HINSTANCE hInst;
extern HWND MainhWnd;
extern BOOL settingChanged;
extern DWORD platform;

/**************************************************************/
//			Functions in this file
/**************************************************************/
void Create_The_Rest(LPSTR lpCmdLine, HINSTANCE hInstance);
void ReadIn_OldDict(HINSTANCE hInstance);
BOOL BLDExitApplication(HWND hWnd);
void ConfigSwitchKey(UINT vk, BOOL bSet);
void ConfigPort(BOOL bSet);
BOOL BLDMenuCommand(HWND, unsigned , WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\kbmain.h ===
// KBMAIN.H      KEYBOARD MAIN HEADER FILE


/**************************************************************************/
/* GLOBAL DEFINES  */
/**************************************************************************/
// WINDOW TYPES
#define KB_MAIN_WND    	1
#define KB_KEY_WND	  	2
#define KB_MODIFIER_WND 3
#define KB_DEAD_WND		4
#define KB_NUMBASE_WND 	5
#define KB_NUMKEY_WND  	6
#define DESKTOP_ACCESSDENIED 0
#define DESKTOP_DEFAULT      1
#define DESKTOP_SCREENSAVER  2
#define DESKTOP_WINLOGON     3
#define DESKTOP_TESTDISPLAY  4
#define DESKTOP_OTHER        5

// KEYBOARD MARGINS
//The smallest width (pixel) you can get for KB
//#define KB_SMALLRMARGIN  152//137     //for width(smallKB).  152 - Block, 137 - Actual  (Moved to kbmain, WM_SIZE) 
#define KB_LARGERMARGIN  202     //for width
#define KB_CHARBMARGIN   57        //for height


#define KB_NUMRMARGIN
#define KB_NUMBMARGIN

// KEYBOARD NUMBERKEY
#define KB_HOWMANYKEY	 130    // IT HAS TO INCLUDE THE NUMERIC KEYBOARD 

// SOUND TYPES
#define SND_UP 		1
#define SND_DOWN 		2

// TIMERS
#define TIMER_HELPTOOLTIP 1014

#include "door.h"

LRESULT WINAPI kbMainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI kbKeyWndProc(HWND hwndKey, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK KeybdInputProc(WPARAM  wParam, LPARAM  lParam);
void RelocateDialog(HWND hDlg);

#define CAPLOCK_SCANCODE 0x3A
#define LSHIFT_SCANCODE  0x2A
#define RSHIFT_SCANCODE  0x36
#define TAB_SCANCODE     0x0f
#define BREAK_SCANCODE   0xE1
#define LMENU_SCANCODE   0x38
#define RMENU_SCANCODE   0x38 // extended 0xE0
#define CONTROL_SCANCODE 0x1D

#define RGB_KEYBGHIGHLIGHT COLOR_HIGHLIGHT /*RGB(0,0,0)*/

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x) sizeof(x)/sizeof(x[0])
#endif

/**************************************************************************/
/* GLOBAL VARIABLES  */
/**************************************************************************/

extern LPKBPREFINFO lpkbPref;				// Pointer to KB structure
extern LPKBPREFINFO lpkbDefault;			// ditto Default
extern HINSTANCE 	hInst;					// iinstance of keyboard process
extern HWND   	   *lpkeyhwnd;				// ptr to array of HWND
extern HWND 		numBasehwnd;			// HWND to the num base window
extern HWND			g_hwndOSK;				// HWND to the kbmain window
extern int 			lenKBkey;				// How Many Keys?
extern int          scrCY;					// Screen Height
extern int 			scrCX;					// Screen Width
extern int 			captionCY;				// Caption Bar Height
extern HHOOK		hkJRec;					// HHOOK to the Journal Record
extern int 			g_margin;         		// Margin between rows and columns
extern BOOL			smallKb;				// TRUE when working with Small Keyboard
extern COLORREF	PrefTextKeyColor;   		// Prefered Color for text in keys
extern COLORREF 	PrefCharKeyColor; 		// ditto normal key
extern COLORREF 	PrefModifierKeyColor;	// ditto modifier key
extern COLORREF 	PrefDeadKeyColor;       // ditto dead key
extern COLORREF	PrefBackgroundColor;        // ditto Keyboard backgraund
extern BOOL			PrefAlwaysontop;			// Always on Top control
extern int			PrefDeltakeysize;			// Preference increment in key size
extern BOOL			PrefshowActivekey;		// Show cap letters in keys
extern int			KBLayout;				// 101, 102, 106, KB layout
extern BOOL			Prefusesound;				// Use click sound
extern BOOL			newFont;						// Font is changed
extern LOGFONT		*plf;            			// pointer to the actual char font
extern HGDIOBJ 	oldFontHdle;     			// Old object handle
extern COLORREF	InvertTextColor; 			//Font color on inversion
extern COLORREF	InvertBKGColor;			//BKG color on inversion
extern BOOL			Prefhilitekey;				// True for hilite eky under cursor

// Dwelling time control variables
extern BOOL			PrefDwellinkey;			// use dwelling system
extern UINT			PrefDwellTime;		    // Dwell time preference

extern BOOL         PrefScanning;           //use scanning
extern UINT         PrefScanTime;           //Prefer scan time

extern BOOL		    g_fShowWarningAgain;		// Show initial warning dialog again

extern HWND			Dwellwindow;	  		// dwelling window

extern int	 		stopPaint;				// stop the bucket paint
extern 				UINT_PTR timerK1;       // timer id for keyboard
extern 				UINT_PTR timerK2;		// timer for print line on key
/*****************************************************************************/

extern BOOL g_fDrawCapital;
extern BOOL g_fCapsLockOn;
extern BOOL g_fShiftKeyDn;
extern BOOL g_fRAltKey;			// TRUE if the RALT key is down
extern BOOL	g_fLAltKey;			// TRUE if the left ALT key is down
extern BOOL g_fLCtlKey;         // TRUE if the left CTRL key is donw
extern BOOL g_fKanaKey;         // TRUE if the kana key is down

extern HWND g_hwndInputFocus;   // the window we are inputting to


//
// These are the different 'modified' states a key can have. Note that shifted,
// caps-lock, and shifted-caps-lock are all different states, since alphabetic
// numbers and symbols behave differently in these states.
//
typedef enum {
    KEYMOD_NORMAL,
    KEYMOD_SHIFTED,
    KEYMOD_CAPSLOCK,
    KEYMOD_SHIFTEDCAPSLOCK,
    KEYMOD_ALTGR,
    KEYMOD_STATES
} KEYMODSTATE;



__inline BOOL AltGrKeyPressed()	
{ 
    // this check is relaxed because the OS sets LCTRL toggled when LALT key is pressed
    return (g_fRAltKey || (g_fLAltKey && g_fLCtlKey))? TRUE:FALSE; 
}

__inline BOOL CapsLockIsOn() 
{ 
	return (g_fCapsLockOn)?TRUE:FALSE; 
}

__inline KEYMODSTATE GetModifierState()
{
	// The order of keyboard state checking is important; ALTGR takes
	// precedence over the shift/capslock variants, which takes precedence
    // over normal.
    if( AltGrKeyPressed() )
        return KEYMOD_ALTGR;

    if( g_fCapsLockOn && g_fShiftKeyDn )
        return KEYMOD_SHIFTEDCAPSLOCK;

    if( g_fCapsLockOn )
        return KEYMOD_CAPSLOCK;

    if( g_fShiftKeyDn )
        return KEYMOD_SHIFTED;

    return KEYMOD_NORMAL;
}


__inline HWND OurInputTarget() 
{ 
	if (!IsWindow(g_hwndInputFocus))
	{
		g_hwndInputFocus = NULL;
	}
	return g_hwndInputFocus; 
}

__inline HKL GetCurrentHKL()
{
    DWORD dwProcessId;
    HWND hwnd = OurInputTarget();
	return GetKeyboardLayout(GetWindowThreadProcessId((hwnd)?hwnd:g_hwndOSK, &dwProcessId));
}

__inline void SetBackgroundColor(HWND hwnd, unsigned long ulColor)
{
    SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)(ulColor+1));
}

BOOL OSKRunSecure();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\kbfunc.h ===
/****************************************************************************/
/* FUNCTIONS IN THIS FILE */
/****************************************************************************/
BOOL InitProc(void);
BOOL RegisterWndClass(HINSTANCE hInst);
HWND CreateMainWindow(BOOL re_size);
void mlGetSystemParam(void);
BOOL SetZOrder(void);
void FinishProcess(void);
void udfDraw3D(HDC hdc, RECT brect);
void udfDraw3Dpush(HDC hdc, RECT brect);

void UpdateKey(HWND hwndKey, HDC hdc, RECT brect, int index, int iKeyVal);

BOOL ChooseNewFont(HWND hWnd);
void ChangeTextKeyColor(void);
BOOL RDrawIcon(HDC hDC, TCHAR *pIconName, RECT rect);
BOOL RDrawBitMap(HDC hDC, TCHAR *pIconName, RECT rect, BOOL transform);
BOOL SavePreferences(void);
BOOL OpenPreferences(void);
void DeleteChildBackground(void);
HFONT	ReSizeFont(int index, LOGFONT *plf, int outsize);
BOOL NumLockLight(void);
void RedrawKeys(void);
void DrawIcon_KeyLight(HDC hDC, int which, RECT rect);
void SetKeyRegion(HWND hwnd, int w, int h);
void CapShift_Redraw(void);
int GetKeyText(UINT vk, UINT sc, BYTE *kbuf, TCHAR *cbuf, HKL hkl);
BOOL RedrawNumLock(void);
BOOL RedrawScrollLock(void);
void ChangeBitmapColorDC (HDC hdcBM, LPBITMAP lpBM, COLORREF rgbOld, COLORREF rgbNew);
void ChangeBitmapColor (HBITMAP hbmSrc, COLORREF rgbOld, COLORREF rgbNew, HPALETTE hPal);
BOOL RegisterKeyClasses(HINSTANCE hInst);

// Handy defines
#define GWLP_USERDATA_TEXTCOLOR GWLP_USERDATA

void InitKeys();
void UninitKeys();
void UpdateKeyLabels(HKL hkl);

extern int g_cAltGrKeys;
__inline BOOL CanDisplayAltGr() { return (g_cAltGrKeys)?TRUE:FALSE; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\kbkeydef.h ===
// KBKEYDEF.H        KEY DEFINITIONS

#define ECOLNUMB     21   // NUMBER OF COLUMNS IN ENHANCED KEYBOARD
#define EROWNUMB	  7   // DITO ROWS
#define ETOTALKEY	125   // ENHANCED KEYBOARD only main keys. 
                          // included separators

// KEY NAMES
#define KB_LSHIFT   	0
#define KB_RSHIFT	 	1
#define KB_CAPLOCK		2
#define KB_SPACE		3
#define KB_LCTR			4
#define KB_RCTR			5
#define KB_LALT			6
#define KB_RALT			7
#define KB_NUMLOCK      8
#define KB_PSC          9
#define NO_NAME			10
#define LED_NUMLOCK     11
#define LED_CAPSLOCK    12
#define LED_SCROLLLOCK  13
#define ICON            14
#define KB_SCROLL       15
#define BITMAP			16

// KEY TYPES
#define KNORMAL_TYPE	     1
#define KMODIFIER_TYPE       2
#define KDEAD_TYPE           3
#define LED_NUMLOCK_TYPE     4
#define LED_CAPSLOCK_TYPE    5
#define LED_SCROLLLOCK_TYPE  6
#define NUMLOCK_TYPE         7
#define SCROLLOCK_TYPE       8


// TYPE OF KEYBOARD
#define LARGE    1
#define SMALL	 2
#define BOTH	 3
#define NOTSHOW  4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\keyrc.h ===
/*Filename: KEYRC.H                                         */

/* Give access to handles in all code modules */
extern HINSTANCE hInst;
extern HWND MainhWnd;
 



/***************************************************************/ 
/* Variables, types and constants for controls in main window. */ 
/***************************************************************/ 
 
extern HWND hClient;     /* Handle to window in client area.   */
extern FARPROC lpClient; /* Function for window in client area.*/
 
#define CLIENTSTRIP WS_MINIMIZE|WS_MAXIMIZE|WS_CAPTION|WS_BORDER|WS_DLGFRAME|WS_SYSMENU|WS_POPUP|WS_THICKFRAME|DS_MODALFRAME
 
typedef struct 
  {
  unsigned long dtStyle;
  BYTE dtItemCount;
  int dtX;
  int dtY;
  int dtCX;
  int dtCY;
  } BLD_DLGTEMPLATE;
 
typedef BLD_DLGTEMPLATE  *LPBLD_DLGTEMPLATE;
 

    
/* User Defined ID Values               */
    
#define IDOK							  1
#define IDCANCEL						  2
#define COLORKBBACKGROUND			 10
#define COLORKBCHARACTERKEYS	  	 11
#define COLORKBTEXT				  	 12
#define COLORKBMODIFIERKEYS	  	 13
#define COLORKBDEFAULTSETTING		 14
#define COLORKBDEADKEYS				 15

#define SETDEFAULTSETTINGS			108
#define KBLANGUAGECOMBO				110
#define ALWAYSONTOP					111
#define KEYSIZE_0						112
#define KEYSIZE_1						113
#define KEYSIZE_2						114
#define KEYSIZE_3						115
#define KEYSIZE_4						116
#define DWELLONKEYS					118
#define DWELLMS					   119
#define HILITEKEY						120
#define DWELLTIMESCROLL				121
#define KBSHOWACTIVEKEYSCK			122
#define KBKEEPPROPORTIONSCK	 	123
#define KBUSE3DKEYSCK			  	124
#define KBUSECLICKSOUNDCK		 	125
#define KBSIZEBUT						126
#define KBFONTBUT						127
#define KBCOLORSBUT					128
#define IDC_LTEXT1					129
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\msswch.h ===
/***** Normal use, default configuration *****/

// global keyboard hook entry

#define WM_GLOBAL_KBDHOOK WM_USER+3

BOOL APIENTRY RegisterHookSendWindow(HWND hwnd, UINT uiMsg);

// hidden switch window information

#define SWITCH_TIMER 1015

void SwitchOnCreate(HWND hWnd);
void SwitchOnEndSession(HWND hWnd);
void SwitchOnTimer(HWND hWnd);
void SwitchOnPollMsg(HWND hWnd);
BOOL SwitchOnCopyData(WPARAM wParam, LPARAM lParam);

// msswch.dll header information

typedef HANDLE HSWITCHPORT;

HSWITCHPORT APIENTRY swchOpenSwitchPort(
	HWND				hWnd,
	DWORD				dwPortStyle );

#define PS_POLLING	1
#define PS_EVENTS		2

BOOL APIENTRY swchCloseSwitchPort(
	HSWITCHPORT		hSwitchPort );

#define NUM_SWITCHES		6
#define BIT_SWITCHES		0x003F

#define SWITCH_NONE 		0x0000
#define SWITCH_1			0x0001
#define SWITCH_2			0x0002
#define SWITCH_3			0x0004
#define SWITCH_4			0x0008
#define SWITCH_5			0x0010
#define SWITCH_6			0x0020

// These messages need to be reserved with Microsoft
#define SW_SWITCHDOWNBASE	0x00E0
#define SW_SWITCH1DOWN		(SW_SWITCHDOWNBASE + 1)
#define SW_SWITCH2DOWN		(SW_SWITCHDOWNBASE + 2)
#define SW_SWITCH3DOWN		(SW_SWITCHDOWNBASE + 3)
#define SW_SWITCH4DOWN		(SW_SWITCHDOWNBASE + 4)
#define SW_SWITCH5DOWN		(SW_SWITCHDOWNBASE + 5)
#define SW_SWITCH6DOWN		(SW_SWITCHDOWNBASE + 6)

// These messages need to be reserved with Microsoft
#define SW_SWITCHUPBASE		0x00F0
#define SW_SWITCH1UP			(SW_SWITCHUPBASE + 1)
#define SW_SWITCH2UP			(SW_SWITCHUPBASE + 2)
#define SW_SWITCH3UP			(SW_SWITCHUPBASE + 3)
#define SW_SWITCH4UP			(SW_SWITCHUPBASE + 4)
#define SW_SWITCH5UP			(SW_SWITCHUPBASE + 5)
#define SW_SWITCH6UP			(SW_SWITCHUPBASE + 6)

/***** Configuration *****/

typedef HANDLE HSWITCHDEVICE;

// make this a dword rather then a handle this is to make this 64 bit portable
typedef DWORD  HJOYDEVICE;

// This message needs to be reserved with Microsoft
#define SW_SWITCHCONFIGCHANGED	0x00D0

#define SC_TYPE_COM				1
#define SC_TYPE_LPT				2
#define SC_TYPE_JOYSTICK		3
#define SC_TYPE_KEYS				4

// Not defined yet
#define SC_TYPE_USB				5
#define SC_TYPE_1394				6

typedef struct _SWITCHLIST {
 DWORD dwSwitchCount;
 HSWITCHDEVICE hsd[ANYSIZE_ARRAY];
} SWITCHLIST, *PSWITCHLIST;

typedef struct _SWITCHCONFIG_LPT {
 DWORD dwReserved1;	// possible future Status register preset
 DWORD dwReserved2;	// possible future Data register preset
} SWITCHCONFIG_LPT, *PSWITCHCONFIG_LPT;

typedef struct _SWITCHCONFIG_JOYSTICK {
 DWORD dwJoySubType;
 DWORD dwJoyThresholdMinX;
 DWORD dwJoyThresholdMaxX;
 DWORD dwJoyThresholdMinY;
 DWORD dwJoyThresholdMaxY;
 DWORD dwJoyHysteresis;
} SWITCHCONFIG_JOYSTICK, *PSWITCHCONFIG_JOYSTICK;

typedef struct _SWITCHCONFIG_KEYS {
 DWORD dwKeySwitch1;
 DWORD dwKeySwitch2;
} SWITCHCONFIG_KEYS, *PSWITCHCONFIG_KEYS;

typedef struct _SWITCHCONFIG_USB {
 // *** NOT DEFINED YET ***
 DWORD dwReserved;
} SWITCHCONFIG_USB, *PSWITCHCONFIG_USB;

typedef struct _SWITCHCONFIG_IEEE1394 {
 // *** NOT DEFINED YET ***
 DWORD dwReserved;
} SWITCHCONFIG_IEEE1394, *PSWITCHCONFIG_IEEE1394;

typedef struct _SWITCHCONFIG_COM {
 DWORD dwComStatus;
} SWITCHCONFIG_COM, *PSWITCHCONFIG_COM;

typedef struct _SWITCHCONFIG {
 DWORD cbSize;
 UINT uiDeviceType;
 UINT uiDeviceNumber;
 DWORD dwFlags;
 DWORD dwSwitches;
 DWORD dwErrorCode;
 union {
   SWITCHCONFIG_COM  Com;
   SWITCHCONFIG_LPT  Lpt;
   SWITCHCONFIG_JOYSTICK   Joystick;
   SWITCHCONFIG_KEYS Keys;
   SWITCHCONFIG_USB  USB;
   SWITCHCONFIG_IEEE1394 IEEE1394;
 } u;
} SWITCHCONFIG, *PSWITCHCONFIG;

HSWITCHDEVICE swchGetSwitchDevice(
	HSWITCHPORT		hSwitchPort,
	UINT				uiDeviceType,
	UINT				uiDeviceNumber	);

UINT swchGetDeviceType( 
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd );

UINT swchGetPortNumber(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd	);

BOOL swchGetSwitchConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );

BOOL swchSetSwitchConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );

//v-mjgran: API to modify return value in keyboard hook. Avoid to send the scan char.
void APIENTRY swchCheckForScanChar (BOOL fCheckForScanKey);
LRESULT CALLBACK swcKeyboardHookProc( int nCode, WPARAM wParam, LPARAM lParam );

// bitflags
#define SC_FLAG_ACTIVE			0x00000001
#define SC_FLAG_DEFAULT			0x00000002
#define SC_FLAG_ERROR			0x00000004
#define SC_FLAG_UNAVAILABLE	0x00000080

// bitflags
#define SC_COM_DTR		0x00000010
#define SC_COM_RTS		0x00000020
#define SC_COM_DEFAULT	SC_COM_RTS

// bitflags
#define SC_LPT_STROBE	0x00000100
#define SC_LPT_AF			0x00000200
#define SC_LPT_INIT		0x00000400
#define SC_LPT_SLCTIN	0x00000800
#define SC_LPT_DEFAULT	0

#define SC_LPTDATA_DEFAULT  0x000000FF

#define SC_JOY_BUTTONS	0
#define SC_JOY_XYSWITCH	1
#define SC_JOY_XYANALOG	2
#define SC_JOY_DEFAULT	SC_JOY_BUTTONS

#define SC_JOYVALUE_DEFAULT	0

#define KANA_MODE_ON 0x00000002
#define KANA_MODE_OFF 0x00000004


// Error return values
#define SWCHERR_NO_ERROR				0
#define SWCHERR_ERROR					1
#define SWCHERR_INVALID_PARAMETER	2
#define SWCHERR_MAXIMUM_USERS			3
#define SWCHERR_ALREADY_OPEN			4
#define SWCHERR_NULL_POINTER			5
#define SWCHERR_INVALID_BUFFER_SIZE	6
#define SWCHERR_ALLOCATING_MEMORY	7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\osk.h ===
#define IDH_OSK_CLICK_MODE 70500 //options dialog
#define IDH_OSK_DWELL_MODE 70505//options dialog
#define IDH_OSK_DWELL_TIME 70510//options dialog
#define IDH_OSK_SCAN_MODE 70515//options dialog
#define IDH_OSK_SCAN_TIME 70520//options dialog
#define IDH_OSK_OK		70525//OK button
#define IDH_OSK_CANCEL	70530//Cancel button
#define IDH_ADVANCED	70535//Advanced button
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\kbus.h ===
//  KB_US.H     KEY DEFINITIONS FOR US EXTENDED KEYBOARD (101 KEYS)


#include "KBKEYDEF.H"

	/* the position of the key is given in relative units to the
		comence of the drawing.  That means that an X or Y position of
		350 means that the x or y edge is drawing begining in the position
		p + 350. In this case the 'p' value is the offset from the edge.*/

typedef	struct KBkeyRec
		{
		LPTSTR  textL;       // text in key lower
		LPTSTR  textC;       // text in key capital
		LPTSTR	skLow;       // What has to be printed low letter
		LPTSTR  skCap;   	 // What has to be printed cap letter
		int 	name;		 // BITMAP, LSHIFT, RSHIF...
		short	posY;		 // See explanation above
		short	posX;		 // same as above
		short	ksizeY;		 // key size in conventional units
		short	ksizeX;		 // same as above
		BOOL 	smallF;		 // TRUE = text has to be written in smaller font
		int  	ktype;		 // 1 - normal, 2 - modifier, 3 - dead
		int		smallKb;	 // SMALL, LARGE, BOTH, NOTSHOW
        BOOL    Caps_Redraw; // Redraw the window for shift, caps
		int 	print;	     //1 - print use ToAscii(), 2 - print the text provided by the header file   
		UINT	scancode[4]; // key scan-code
        LPTSTR  apszKeyStr[KEYMOD_STATES];// key labels for each keyboard layout (0=no modifiers 1=SHIFTED 2=ALTGR)
		BYTE    abKeyType[KEYMOD_STATES];// "ktype" for each keyboard layout
		}KBkeyRec;

extern struct KBkeyRec KBkey[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\ms32dll.h ===
/***************************************************************************/
/*     Functions Declaration      */
/***************************************************************************/

void RedrawKeysOnLanguageChange();
BOOL IsOneOfOurKey(HWND hwnd);
void DoAllUp (HWND hwnd, BOOL sendchr);
void DoButtonDOWN(HWND hwnd);
void SendWord(LPCSTR lpszKeys);
BOOL udfKeyUpProc(HWND khwnd, int keyname);
void MakeClick(int what);
void InvertColors(HWND hwnd, BOOL fForceUpdate);
void ReturnColors(HWND hwnd, BOOL inval);
void CALLBACK YourTimeIsOver(HWND hwnd, UINT uMsg, 
                             UINT_PTR idEvent, DWORD dwTime);
void killtime(void);
void Cursorover(void);
void SetTimeControl(HWND hwnd);
void PaintBucket(HWND hwnd);
void CALLBACK Painttime(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
void SendChar(HWND hwndKey);

int CharTrans(int index, BOOL *SkipSendkey);

void ReDrawModifierKey(void);

void Extra_Key(HWND hwnd, int index);

void PaintLine(HWND hwnd, HDC hdc, RECT rect);
void ReleaseAltCtrlKeys(void);
BOOL IsModifierPressed(HWND hwndKey);

#define MENUKEY_NONE  0
#define MENUKEY_LEFT  1
#define MENUKEY_RIGHT 2
extern int g_nMenu;				// holds menu key state
extern BOOL g_fControlPressed;	// TRUE if the CTRL key is down
extern BOOL g_fDoingAltTab;		// TRUE if LALT is down and TAB is being pressed

static __inline BOOL LAltKeyPressed()		{ return g_nMenu == MENUKEY_LEFT; }
static __inline BOOL LCtrlKeyPressed()	    { return g_fControlPressed; }
static __inline BOOL DoingAltTab()          { return g_fDoingAltTab; }
void SetCapsLock(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\sdgutil.h ===
/*************************************************************/
//Functions in this file
/*************************************************************/
void SendErrorMessage(UINT ids_string);
void GetPreferences(void);
DWORD WhatPlatform(void);
BOOL IsOutOfScreen(int scrCX, int scrCY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\scan.h ===
/***********************************************/
//			Functions in this file
/***********************************************/
void Scanning(int from);
void CALLBACK LineScanProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void CALLBACK KeyScanProc_Actual_101(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void CALLBACK KeyScanProc_Actual_106(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void CALLBACK KeyScanProc_Actual_102(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void RestoreRowColor(int Row);
void RestoreKeyColor(int i);
void KillScanTimer(BOOL reset);

void Scanning_Actual(int from);
void Scanning_Block(int from);
void CALLBACK KeyScanProc_Block(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void CALLBACK BlockScanProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void RestoreBlockColor(int ColStart, int ColEnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\pd32002.h ===
/*Filename: PD32002.H                                       */


/* Global vars */
extern HINSTANCE hInst;
extern HWND MainhWnd;
extern BOOL settingChanged;
extern HWND hClient;     /* Handle to window in client area.   */
extern FARPROC lpClient; /* Function for window in client area.*/

extern DWORD platform;




#define BLD_CannotRun          5000
#define BLD_CannotCreate       5001
#define BLD_CannotLoadMenu     5002
#define BLD_CannotLoadIcon     5003
#define BLD_CannotLoadBitmap   5004

#if !defined(THISISBLDRC)


/***************************************************************/
/* Variables, types and constants for controls in main window. */
/***************************************************************/

#define CLIENTSTRIP WS_MINIMIZE|WS_MAXIMIZE|WS_CAPTION|WS_BORDER|WS_DLGFRAME|WS_SYSMENU|WS_POPUP|WS_THICKFRAME|DS_MODALFRAME

typedef struct
  {
  unsigned long dtStyle;
  BYTE dtItemCount;
  int dtX;
  int dtY;
  int dtCX;
  int dtCY;
  } BLD_DLGTEMPLATE;

typedef BLD_DLGTEMPLATE            *LPBLD_DLGTEMPLATE;

#endif


//DIALOG DEFINES

#define CHECK     1
#define UNCHECK   0

/* User Defined ID Values               */
#define DLG_OK			 1
#define DLG_CANCEL  	 2

//About Dlg
#define About_Credits_but	101
#define shade	102



/**************************************************************/
//          Functions in this file
/**************************************************************/
void Create_The_Rest(LPSTR lpCmdLine, HINSTANCE hInstance);
void ReadIn_OldDict(HINSTANCE hInstance);


/****************************************************************/
//      Functions in pd32f2.c  and pd32002.c
/****************************************************************/
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine
, int nCmdShow);
LRESULT WINAPI MainWndProc(HWND,unsigned,WPARAM, LPARAM);
BOOL BLDKeyTranslation(HWND, HACCEL, MSG *);
BOOL BLDInitApplication(HINSTANCE,HINSTANCE,int *,LPSTR);
BOOL BLDExitApplication(HWND hWnd);      /* Called just before exit of applicati
on  */
BOOL BLDMenuCommand(HWND, unsigned , WPARAM, LPARAM);
int SaveChangesMessage(HWND hwnd, char *msg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\sendkeys.h ===
/****************************************************************************
Module name  : SendKeys.H
Description  : Include File for SendKeys utility functions.
*****************************************************************************/

#ifndef _INC_SENDKEYS
#define _INC_SENDKEYS		/* #defined if SendKeys.h has been included */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define ARRAY_LEN(Array)			(sizeof(Array) / sizeof(Array[0]))
#define INRANGE(low, val, high) ((low <= val) && (val <= high))
#define TOUPPER(Char)		((BYTE) (DWORD) AnsiUpper((LPSTR) MAKEINTRESOURCE(Char)))



// ************************ Function Prototypes ******************************
typedef enum {
	SK_NOERROR, SK_MISSINGCLOSEBRACE, SK_INVALIDKEY,
	SK_MISSINGCLOSEPAREN, SK_INVALIDCOUNT, SK_STRINGTOOLONG,
	SK_CANTINSTALLHOOK
} SENDKEYSERR;

SENDKEYSERR WINAPI _export SendKeys (LPCSTR szKeys);
SENDKEYSERR WINAPI VMSendKeys (LPCSTR szKeys);
void WINAPI PostVirtualKeyEvent (BYTE bVirtKey, BOOL fUp);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */
#endif  /* _INC_SENDKEYS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\tpoption.h ===
//#pragma once
#include <time.h>
#define MAX_HISTORY	10
#define STATVERSION 249 

/*typedef struct Statistics	{
	short	version;
	short	index;
	time_t	begTime[MAX_HISTORY];
	time_t	endTime[MAX_HISTORY];
	short	realKeys[MAX_HISTORY];
	short	postKeys[MAX_HISTORY];
	short	newDicts[MAX_HISTORY];
	short	newWords[MAX_HISTORY];
	short	newNexts[MAX_HISTORY];
	short	hitWords[MAX_HISTORY];
	short	hitAbbrs[MAX_HISTORY];
	short	mouseDowns[MAX_HISTORY];
	short	switches[MAX_HISTORY];
	} Statistics;
*/

typedef struct TSDict {
//	short	version;	
// structure version
	char	name[32];	 // name of this topic 

    //flags
//	unsigned DICT_LRNNEW  : 1;	// learn new words
//	unsigned DICT_LRNNEXT : 1;	// learn next words
//	unsigned DICT_LRNFREQ : 1;	// adjust word freq
//	unsigned DICT_SYMBOL  : 1;	// Symbolic dictionary (ie: Minspeak)
//	unsigned DICT_2BYTE   : 1;	// Two byte symbols (ie: Kanji)
//	unsigned DICT_REVERSE : 1;	// Runs right to left (ie: Hebrew)
//	unsigned DICT_PREDICT : 1;	// Use for predictions
//	unsigned DICT_PURGAUTO: 1;	// Autopurge if too full?
//	unsigned DICT_PURGASK : 1;	// Ask before purging
//	unsigned DICT_CURRENT : 1;	// current option item
//	unsigned DICT_LRNNUM  : 1;  // learn number
//	unsigned CAP		  : 1;  // capitialize new sentence

//	short	maxWords;	// words per topic
//	short	minLength;	// minimum word length
//	short	weight;		// how much to weight the probs
//	short   space;      //how many space after sentence

	short	tnmbr[256];	// how many in chain
	struct TSFreq *atops[256];	// first word in alpha chain
	struct TSFreq *ftops[256];	// first word in freq chain

//	struct TSFreq *dtops[256];	// first word in disamb chain
//	short	indx;		        // TSFreq Group selected
//	short	nmbr;		        // how many in chain?
	struct TSFreq  *last;	    // last word seen
//	struct TSFreq  *nearest;	// word nearest to word to insert
	}	TSDict;

extern struct TSDict *dp;

typedef struct TSFreq
	{
	// flags
//	unsigned WORD_SLCT   	:1;	// this word was selected in last match
	unsigned WORD_LOCK   	:1; // never delete word
//	unsigned WORD_CASE   	:1;	// word is case sensitive
	unsigned WORD_ABBR   	:1;	// word is an abbreviation
//	unsigned WORD_IGNR   	:1;	// ignore this word
//	unsigned WORD_SAY    	:1;	// say this word
	unsigned WORD_TYPE   	:1;	// type this word
//	unsigned WORD_NNXT   	:1;	// don't learn next words
//	unsigned WORD_SCRIPT 	:1;	// word data is a script
//	unsigned WORD_FPROB		:1;	// don't change freq
//	unsigned WORD_PREV		:1;	// this word was previously shown
//	unsigned WORD_HELD		:1;	// this word was held over for next
//	unsigned WORD_DELETED 	:1;	// this word was deleted
//	unsigned WORD_BIAS		:1;	// this is a preferred word in this session
//	unsigned WORD_VOICE		:1;	// the word/abbr special pronounciation

	short	 freq;	//	freq for this word

	struct TSNext	*nhead;	//	head of next word list for this word
	struct TSFreq	*anext;	//	next entry alphabetical
	struct TSFreq	*fnext;	//	next entry frequency
//	struct TSFreq	*dnext;	//	next entry disambiguation
	char 	 	*word;	//	actual data
	char		*abbr;	//	actual data
	} TSFreq;

extern struct TSFreq  *wordCur,  *abbrCur;

typedef struct TSNext
	{
	short	freq;	// this word pair's freq
	struct TSFreq	*nword;	// next word
	struct TSNext	*nnext;	// next word pair in chain
	} TSNext;

//extern void *MemPool;
//extern BYTE *MemPoolPtr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\inc\osksetti.h ===
//-----------------------------------------------------------------
//
//  Copyright (c) 1998 Microsoft Corporation
//
//  This H file was generated by the perl script regtoh.pl.
//
//  This file was last generated on: 7/7/100 at: 10:53:2.
//
//  Be sure to bump up the CURRENT_STEPPING when the structure changes.
//  Changing the stepping will force an update to the registry.
//
//  Please do not edit this file directly.
//
//-----------------------------------------------------------------

#define CURRENT_STEPPING 3

BYTE g_DefaultSettings[] = {

 0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xc0,0xc0,0x00,0xff,0x80,0xc0,0x00,0x00, 
  0xff,0x40,0x00,0x80,0x80,0xff,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe8,0x03,0x00,0x00,0xf5,0xff,0xff,0xff,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xbc,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x02,0x01,0x22,0x4d,0x53,0x20,0x53, 
  0x68,0x65,0x6c,0x6c,0x20,0x44,0x6c,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x98,0x3a, 
  0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00, 
  0x00,0x01,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x00,0xbc,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x22,0x53,0x79,0x73,0x74,0x65,0x6d,0x00,0x10,0x68, 
  0x8a,0xf7,0x0c,0xac,0x00,0x01,0x00,0x94,0x33,0x02,0x00,0x00,0x00,0x57,0x01,0x00,0x00,0x09,0x00,0x8b,0x01,0xa4,0x01,0x00,0x00, 
  0x00,0x00,0x80,0xff,0x80,0x00,0x01,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00, 
  0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xb8,0x00,0x00,0x00,0x9d,0x01,0x00,0x00,0x20,0x03,0x00,0x00, 
  0x01,0x04,0x00,0x00,0xe3,0x03,0x00,0x00,0x6d,0x01,0x00,0x00,0xee,0x02,0x00,0x00,0x39,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x72,0x00,0x00,0x00,0xb1,0x00,0x00,0x00,0x00,0x00,0xbc,0x42,0x00,0x00,0xc8,0x41,0x71,0x00,0x00,0x00,0x72,0x00, 
  0x00,0x00,0x73,0x00,0x00,0x00,0x74,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x76,0x00,0x00,0x00,0x77,0x00,0x00,0x00,0x78,0x00,0x00, 
  0x00,0x79,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00, 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf4,0x01,0x00,0x00, 
  0x01,0x00,0x00,0x00,0x01,0x3b,0x2e,0x4a
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\kbdhook.c ===
//
// KbdHook.c - contains the functions for global keyboard hooking in OSK
//
#include <windows.h>
#include <msswch.h>
#include <msswchh.h>
#include "mappedfile.h"
#include "w95trace.h"

#define THIS_DLL TEXT("MSSWCH.DLL")

//
//  Function Prototypes.
//
LRESULT CALLBACK OSKHookProc(int nCode, WPARAM wParam, LPARAM lParam);

////////////////////////////////////////////////////////////////////////////
//  DllMain
////////////////////////////////////////////////////////////////////////////
BOOL WINAPI MSSwchDll_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            DBPRINTF(TEXT("MSSwchDll_DllMain:  DLL_PROCESS_ATTACH\r\n"));
			swchOpenSharedMemFile();
            break;
        }

        case ( DLL_PROCESS_DETACH ) :
        {
            DBPRINTF(TEXT("MSSwchDll_DllMain:  DLL_PROCESS_DETACH\r\n"));
            swchCloseSharedMemFile();
            break;
        }
    }
    return (TRUE);

    UNREFERENCED_PARAMETER(lpvReserved);
}

////////////////////////////////////////////////////////////////////////////
//
//  RegisterHookSendWindow
//
//  The hwnd can be zero to indicate the app is closing down.
//
////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY RegisterHookSendWindow(HWND hwnd, UINT uiMsg)
{
    if (!g_pGlobalData)
    {
        swchOpenSharedMemFile();
        if (!g_pGlobalData)
        {
            DBPRINTF(TEXT("RegisterHookSendWindow: ERROR !g_pGlobalData\r\n"));
            return TRUE;    // internal error! ignore we'll see it later.
        }
    }

    if (hwnd)
    {
        g_pGlobalData->hwndOSK = hwnd;
        g_pGlobalData->uiMsg = uiMsg;
		g_pGlobalData->fSyncKbd = TRUE;

		if (!g_pGlobalData->hKbdHook)
		{
			g_pGlobalData->hKbdHook = SetWindowsHookEx(
										WH_KEYBOARD,
										OSKHookProc,
										GetModuleHandle(THIS_DLL),
										0);
		}
    }
    else
    {
		g_pGlobalData->fSyncKbd;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  OSKHookProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK OSKHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
	HANDLE hMutex;

    if (ScopeAccessMemory(&hMutex, SZMUTEXSWITCHKEY, 5000))
    {
		HHOOK hhook;

		if (!g_pGlobalData)
		{
			ScopeUnaccessMemory(hMutex);
			return 1;
		}

        if (nCode == HC_ACTION)
        {
		    // Check if this key is the key that causes scanning to begin.  When this is 
		    // the scan key, scan mode gets detected in the msswch dll timer (it see's
		    // the "key up" on the scan key) and sends out the "do scanning" message.

		    if (swcKeyboardHookProc(nCode, wParam, lParam))
		    {
			    ScopeUnaccessMemory(hMutex);
			    return 1;
		    }

		    // If this is a Japanese keyboard the OSK need to know if it is in Kana mode
		    // Because we are now in the same process we can reliably get this in formation
		    // So this sets some extra bits that are not use by the Kana key.  This will be used
		    // by OSK to keep track of the Kana state.
                   if ((LOBYTE(LOWORD(GetKeyboardLayout(0)))) == LANG_JAPANESE)
                    {
                        DWORD fKanaMode;

                        if (GetKeyState(VK_KANA) & 0x01)
                        {
                            DBPRINTF(TEXT("OSKHookProc: Kana mode is on\r\n"));
                            fKanaMode = 0x80000000 | KANA_MODE_ON;
                        }
                        else
                        {
                            fKanaMode = 0x80000000 | KANA_MODE_OFF;
                        }
                        PostMessage(g_pGlobalData->hwndOSK, // hwnd to receive the messagae
                                            g_pGlobalData->uiMsg,   // the message
                                            VK_KANA,                 // the virtual key code
                                            fKanaMode);               // keystroke message flags
                    } 

		    // if sync'ing with physical keyboard then pass
		    // this keystroke on to the OSK window

		    if (g_pGlobalData->fSyncKbd)
		    {
			    if (nCode >= 0)
			    {
				    PostMessage(g_pGlobalData->hwndOSK, // hwnd to receive the messagae
							    g_pGlobalData->uiMsg,   // the message
							    wParam,                 // the virtual key code
							    lParam );               // keystroke message flags
			    }
		    }
        }

		hhook = g_pGlobalData->hKbdHook;
		ScopeUnaccessMemory(hMutex);

		return CallNextHookEx(hhook, nCode, wParam, lParam);
    }
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\mappedfile.c ===
//Copyright (c) 1997-2000 Microsoft Corporation

// Memory mapped file routines

#include <windows.h>
#include <assert.h>
#include "msswch.h"
#include "mappedfile.h"
#include <malloc.h>
#include "w95trace.h"

HANDLE      g_hMapFile = NULL;     // handle to memory mapped file
PGLOBALDATA g_pGlobalData = NULL;  // pointer into memory mapped file

/****************************************************************************
   FUNCTION: ScopeAccessMemory() and ScopeUnaccessMemory()

	DESCRIPTION:
	Scoping functions protecting access to this DLL's shared memory file.

****************************************************************************/
BOOL ScopeAccessMemory(HANDLE *phMutex, LPCTSTR szMutex, unsigned long ulWait)
{
    assert(phMutex);
    if (phMutex)
    {
	    *phMutex = CreateMutex( NULL, FALSE, szMutex );
        if (*phMutex)
        {
    	    WaitForSingleObject( *phMutex, ulWait );
			return TRUE;
        }
    }
	DBPRINTF(TEXT("ScopeAccessMemory FAILED\r\n"));
    
    return FALSE;
}

void ScopeUnaccessMemory(HANDLE hMutex)
{
    if (hMutex)
    {
	    ReleaseMutex( hMutex );
	    CloseHandle( hMutex );
    }
}

/****************************************************************************

   FUNCTION: AccessSharedMemFile()

	DESCRIPTION:
		Create a shared memory file from system pagefile or open it if it
        already exists.  Returns TRUE if pvMapAddress is valid otherwise 
        returns FALSE.
    NOTE:
        pvMapAddress should be set to NULL before calling this function; 
       it allows calling multiple times, ignoring all but
        the first call.
				
****************************************************************************/

BOOL AccessSharedMemFile(
    LPCTSTR szName,         // name of the mapped file
    unsigned long ulMemSize,// size of the mapped file
    void **ppvMapAddress    // returned pointer to mapped file memory
    )
{
    assert(ppvMapAddress);
    if (!ppvMapAddress)
        return FALSE;

    if (!(*ppvMapAddress) && !g_hMapFile)
    {
        // Concatenate the passed in name with SHAREDMEMFILE

        LPTSTR pszName = (LPTSTR)malloc((lstrlen(szName) + lstrlen(SHAREDMEMFILE) + 1) *sizeof(TCHAR));
        if (!pszName)
            return FALSE;

        lstrcpy(pszName, szName);
        lstrcat(pszName, SHAREDMEMFILE);

        // Create the mapped file from system page file.  If it has been created
        // previously, then CreateFileMapping acts like OpenFileMapping.

        g_hMapFile = CreateFileMapping(
            INVALID_HANDLE_VALUE,    // Current file handle. 
            NULL,                    // Default security. 
            PAGE_READWRITE,          // Read/write permission. 
            0,                       // Hi-order DWORD of file size
            ulMemSize,               // Lo-order DWORD of file size
            pszName);                // Name of mapping object. 
 
        if (NULL == g_hMapFile) 
        {
            DBPRINTF(TEXT("CreateFileMapping for %s FAILED 0x%x\r\n"), pszName, GetLastError());
            free(pszName);
            return FALSE;
        }

        // Get a pointer to the mapped memory

        *ppvMapAddress = MapViewOfFile(
            g_hMapFile,              // Handle to mapping object. 
            FILE_MAP_ALL_ACCESS,     // Read/write permission 
            0,                       // Max. object size. 
            0,                       // Size of hFile. 
            0);                      // Map entire file. 
 
        if (NULL == *ppvMapAddress) 
        {
            DBPRINTF(TEXT("MapViewOfFile FAILED 0x%x\r\n"), GetLastError());
            free(pszName);
            return FALSE;
        }
        DBPRINTF(TEXT("CreateFileMapping for %s Succeeded\r\n"), pszName);
        free(pszName);
    }

    return TRUE;
}

/****************************************************************************

   FUNCTION: UnaccessSharedMemFile()

	DESCRIPTION:
		Clean up the shared memory file.
				
****************************************************************************/
void UnaccessSharedMemFile()
{
    if (g_pGlobalData)
    {
        UnmapViewOfFile(g_pGlobalData);
    }

    if (g_hMapFile)
    {
        CloseHandle(g_hMapFile);
        g_hMapFile = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\msswcher.h ===
/***** Internal Error codes *****/

#define SWCHERROR_SUCCESS					ERROR_SUCCESS
#define SWCHERROR_INVALID_HWND			ERROR_INVALID_WINDOW_HANDLE
#define SWCHERROR_INVALID_HSWITCHPORT	ERROR_INVALID_HANDLE
#define SWCHERROR_INVALID_HSD				ERROR_INVALID_HANDLE
#define SWCHERROR_MAXIMUM_PORTS			ERROR_ACCESS_DENIED
#define SWCHERROR_HWND_ALREADY_USED		ERROR_ACCESS_DENIED
#define SWCHERROR_INVALID_PARAMETER		ERROR_INVALID_PARAMETER
#define SWCHERROR_INVALID_DEVICETYPE	ERROR_INVALID_PARAMETER
#define SWCHERROR_INVALID_DEVICENUMBER	ERROR_INVALID_PARAMETER
#define SWCHERROR_INSUFFICIENT_BUFFER	ERROR_INSUFFICIENT_BUFFER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\msswchh.h ===
// MSSWCHH.H
// Functions and defines global to MSSWCH but not exported 
// to the rest of the world

// Functions with an X prefix must be called within the context
// of the helper window.

#ifndef _INC_TCHAR
	#include <tchar.h>
#endif
#define SZ_DLLMODULENAME	_TEXT("MSSWCH")

// MSSWCH is the main module and communicates with the outside world

BOOL swchPostSwitches(
	HSWITCHDEVICE	hsd,
	DWORD				dwSwitch );
BOOL swchPostConfigChanged( void );
void XswchStoreLastError(
	HSWITCHPORT		hSwitchPort,
	DWORD				dwError );
BOOL swchOpenSharedMemFile();
void swchCloseSharedMemFile();

// The List module distributes calls to the rest of the modules

BOOL XswcListInit( void );
BOOL XswcListEnd( void );
BOOL swcListGetList(
	HSWITCHPORT		hSwitchPort,
	PSWITCHLIST		pSL,
	DWORD				dwSize,
	PDWORD			pdwReturnSize );
HSWITCHDEVICE swcListGetSwitchDevice(
	HSWITCHPORT		hSwitchPort,
	UINT				uiDeviceType,
	UINT				uiDeviceNumber );
UINT swcListGetDeviceType(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd );
UINT swcListGetDeviceNumber(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd	);
BOOL swcListGetConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
BOOL XswcListSetConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
DWORD XswcListPollSwitches( void );


// Here are the rest of the modules

void swchComInit();
void swchJoyInit();
void swchKeyInit();
void swchListInit();

BOOL XswcComInit( HSWITCHDEVICE	hsd );
BOOL XswcComEnd( HSWITCHDEVICE	hsd );
BOOL swcComGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
BOOL XswcComSetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
DWORD XswcComPollStatus( HSWITCHDEVICE	hsd );

BOOL XswcJoyInit( HSWITCHDEVICE	hsd );
BOOL XswcJoyEnd( HSWITCHDEVICE	hsd );
BOOL swcJoyGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
BOOL XswcJoySetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
DWORD XswcJoyPollStatus( HSWITCHDEVICE	hsd );

BOOL XswcKeyInit( HSWITCHDEVICE	hsd );
BOOL XswcKeyEnd( HSWITCHDEVICE	hsd );
BOOL swcKeyGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
BOOL XswcKeySetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
DWORD XswcKeyPollStatus( HSWITCHDEVICE	hsd );

BOOL XswcLptInit( HSWITCHDEVICE	hsd );
BOOL XswcLptEnd( HSWITCHDEVICE	hsd );
BOOL swcLptGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
BOOL XswcLptSetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
DWORD XswcLptPollStatus( HSWITCHDEVICE	hsd );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msswch.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\mappedfile.h ===
//Copyright (c) 1997-2000 Microsoft Corporation

// This header contains the defines, typedefs and prototypes
// for managing the memory mapped file for this DLL.
//
#define SHAREDMEMFILE TEXT("_msswch")
#define SHAREDMEMFILE_MUTEX _T("MutexMSSwch")
#define SZMUTEXCONFIG _T("MutexMSSwchConfig")
#define SZMUTEXWNDLIST _T("MutexMSSwchWnd")
#define SZMUTEXSWITCHSTATUS _T("MutexMSSwchStatus")
#define SZMUTEXSWITCHKEY _T("MutexSwchKey")
#define SZMUTEXSWITCHLIST _T("MutexMSSwchList")

#define MAXWNDS	64
#define BIOS_SIZE 16
#define MAX_COM	4
#define MAX_JOYSTICKS	2
#define NUM_KEYS  2
#define MAX_LPT	3
// For now the list is static, since number of possible devices is known.
// 4 Com + 3 Lpt + 2 Joystick + 1 Key = 10 devices.
#define MAX_SWITCHDEVICES  10

typedef struct _USEWNDLIST
{
	HWND		hWnd;
	DWORD		dwPortStyle;
	DWORD		dwLastError;
} USEWNDLIST, *PUSEWNDLIST;

typedef struct _JOYSETTINGS
{
	DWORD		XMaxOn;
	DWORD		XMaxOff;
	DWORD		XMinOn;
	DWORD		XMinOff;
	DWORD		YMaxOn;
	DWORD		YMaxOff;
	DWORD		YMinOn;
	DWORD		YMinOff;
} JOYSETTINGS;

typedef struct _HOTKEY
{
	UINT mod;
	UINT vkey;
	UINT dwSwitch;
} HOTKEY;

typedef struct _INTERNALSWITCHLIST {
    DWORD dwSwitchCount;
    HSWITCHDEVICE hsd[MAX_SWITCHDEVICES];
} INTERNALSWITCHLIST, *PINTERNALSWITCHLIST;

typedef struct _GLOBALDATA
{
    // main global data

    HWND       hwndHelper;			      // The helper windows which owns shared resources
    DWORD      dwLastError;		          // The last error caused within this library
    USEWNDLIST rgUseWndList[MAXWNDS+1];   // list of using apps
    int	       cUseWndList;               // Count of using apps
    DWORD      dwSwitchStatus;		      // Bit field of status of switches
    BYTE       rgbBiosDataArea[BIOS_SIZE];// common bios status area

    // com port switch data

    SWITCHCONFIG_COM scDefaultCom;
    SWITCHCONFIG     rgscCom[MAX_COM];

    // joy stick switch data

    SWITCHCONFIG_JOYSTICK scDefaultJoy;
    SWITCHCONFIG          rgscJoy[MAX_JOYSTICKS];
    JOYSETTINGS	          rgJoySet[MAX_JOYSTICKS];

    // keyboard hook data for key press scan mode

    BOOL              fCheckForScanKey;	    // Check if sent key is a scan key
    HHOOK             hKbdHook;
    SWITCHCONFIG_KEYS scDefaultKeys;
    SWITCHCONFIG      scKeys;
    HOTKEY            rgHotKey[NUM_KEYS];
	BOOL              fScanKeys;            // TRUE if scanning based on key press

    // keyboard hook data for sync'ing soft keyboard with physical keyboard

    HWND			  hwndOSK;			// where to send key press information
    UINT			  uiMsg;			// the message expected by hwndOSK
	BOOL              fSyncKbd;         // TRUE if want to sync with physical keyboard

    // printer port switch data

    OSVERSIONINFO    osv;
    WORD             wPrtStatus;		// Printer status byte
    WORD             wCtrlStatus;		// Printer control byte
    WORD             wCurrByteData;		// Current data byte
    SWITCHCONFIG_LPT scDefaultLpt;
    SWITCHCONFIG     rgscLpt[MAX_LPT];

    // data for common handling of any switch device

    INTERNALSWITCHLIST SwitchList;
    DWORD              dwCurrentCount;
    DWORD              dwCurrentSize;
    DWORD              rgSwitches[NUM_SWITCHES]; // Array of bit field constants
    DWORD              rgSwDown[NUM_SWITCHES];   // Array of DOWN messages
    DWORD              rgSwUp[NUM_SWITCHES];     // Array of UP messages

} GLOBALDATA, *PGLOBALDATA;

extern PGLOBALDATA g_pGlobalData;  // pointer into memory mapped file

BOOL ScopeAccessMemory(HANDLE *phMutex, LPCTSTR szMutex, unsigned long ulWait);
void ScopeUnaccessMemory(HANDLE hMutex);
BOOL AccessSharedMemFile(LPCTSTR szName, unsigned long ulMemSize, void **ppvMapAddress);
void UnaccessSharedMemFile();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\ntddpar.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    ntddpar.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Parallel device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_PAR_BASE                  FILE_DEVICE_PARALLEL_PORT
#define IOCTL_PAR_QUERY_INFORMATION     CTL_CODE(FILE_DEVICE_PARALLEL_PORT,1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_PAR_SET_INFORMATION       CTL_CODE(FILE_DEVICE_PARALLEL_PORT,2,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_PAR_QUERY_DEVICE_ID       CTL_CODE(FILE_DEVICE_PARALLEL_PORT,3,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_PAR_QUERY_DEVICE_ID_SIZE  CTL_CODE(FILE_DEVICE_PARALLEL_PORT,4,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

typedef struct _PAR_QUERY_INFORMATION{
       UCHAR Status;
} PAR_QUERY_INFORMATION, *PPAR_QUERY_INFORMATION;

typedef struct _PAR_SET_INFORMATION{
       UCHAR Init;
} PAR_SET_INFORMATION, *PPAR_SET_INFORMATION;

#define PARALLEL_INIT            0x1
#define PARALLEL_AUTOFEED        0x2
#define PARALLEL_PAPER_EMPTY     0x4
#define PARALLEL_OFF_LINE        0x8
#define PARALLEL_POWER_OFF       0x10
#define PARALLEL_NOT_CONNECTED   0x20
#define PARALLEL_BUSY            0x40
#define PARALLEL_SELECTED        0x80

//
// This is the structure returned by IOCTL_PAR_QUERY_DEVICE_ID_SIZE.
//

typedef struct _PAR_DEVICE_ID_SIZE_INFORMATION {
    ULONG   DeviceIdSize;
} PAR_DEVICE_ID_SIZE_INFORMATION, *PPAR_DEVICE_ID_SIZE_INFORMATION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\swchcom.c ===
/****************************************************************************
   Switch Input Library DLL - Serial port routines

   Copyright (c) 1992-1997 Bloorview MacMillan Centre

  Currently this uses polling of the serial ports.
  To move to an interrupt-based system, our helper window
  would need to be the target for notifications.

*******************************************************************************/

#include <windows.h>
#include <tchar.h>
#include <conio.h>
#include <stdio.h>
#include <msswch.h>
#include "msswchh.h"
#include "mappedfile.h"

/***** Internal Prototypes *****/

HANDLE XswcComOpen( DWORD uiPort );
BOOL XswcComSet(HANDLE hCom, PSWITCHCONFIG_COM pC );

// Handles cannot be shared across processes
// These are port/file handles
HANDLE hCom[MAX_COM] = {0,0,0,0};

/****************************************************************************

   FUNCTION: swchComInit()

	DESCRIPTION:
		Called once per DLL load to initialize the com port specific 
        data in the memory mapped file.  We are w/in an open mutex.

****************************************************************************/

void swchComInit()
{
    int i;
    long lSize = sizeof(SWITCHCONFIG);
    for (i=0;i<MAX_COM;i++)
    {
        g_pGlobalData->rgscCom[i].cbSize = lSize;
        g_pGlobalData->rgscCom[i].uiDeviceType = SC_TYPE_COM;
        g_pGlobalData->rgscCom[i].uiDeviceNumber = i+1;
        g_pGlobalData->rgscCom[i].dwFlags = SC_FLAG_DEFAULT;
    }
    g_pGlobalData->scDefaultCom.dwComStatus = SC_COM_DEFAULT;
}

/****************************************************************************

   FUNCTION: XswcComInit()

	DESCRIPTION:
		Initialize the particular hardware device structures and variables.
		Any global initialization of resources will have to be done based
		on some version of a reference counter.  We are w/in an open mutex.

****************************************************************************/

BOOL XswcComInit( HSWITCHDEVICE hsd )
{
    UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

    g_pGlobalData->rgscCom[uiDeviceNumber-1].u.Com = g_pGlobalData->scDefaultCom;
    hCom[uiDeviceNumber-1] = (HANDLE) 0;
	
    return TRUE;
}


/****************************************************************************

   FUNCTION: XswcComEnd()

	DESCRIPTION:
		Free the resources for the given hardware port.
		We assume that if CloseHandle fails, the handle is
		invalid and/or already closed, so we zero it out anyways,
		and return TRUE for success.
		Global releases will need to be based on a reference counter.

****************************************************************************/

BOOL XswcComEnd( HSWITCHDEVICE hsd )
{
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

	if (hCom[uiDeviceNumber-1])
	{
		CloseHandle( hCom[uiDeviceNumber-1] );
		hCom[uiDeviceNumber-1] = 0;
	}
	g_pGlobalData->rgscCom[uiDeviceNumber-1].dwSwitches = 0;

	return TRUE;
}


/****************************************************************************

   FUNCTION: swcComGetConfig()

	DESCRIPTION:

****************************************************************************/

BOOL swcComGetConfig(HSWITCHDEVICE hsd, PSWITCHCONFIG psc)
{
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
   *psc = g_pGlobalData->rgscCom[uiDeviceNumber-1];
	return TRUE;
}


/****************************************************************************

   FUNCTION: XswcComSetConfig()

	DESCRIPTION:
		Activate/Deactivate the device.
		
		Four cases: 
		1) hCom = 0 and active = 0		- do nothing
		2)	hCom = x and active = 1		- just set the configuration
		3) hCom = 0 and active = 1		- activate and set the configuration
		4) hCom = x and active = 0		- deactivate

		If there are no errors, TRUE is returned and ListSetConfig
		will write the configuration to the registry.
		If there is any error, FALSE is returned so the registry
		entry remains unchanged.

		Plug and Play can check the registry for SC_FLAG_ACTIVE and
		start up the device if it is set. This all probably needs some work.

****************************************************************************/

BOOL XswcComSetConfig(HSWITCHDEVICE hsd, PSWITCHCONFIG psc)
{
	BOOL		bSuccess;
	BOOL		bJustOpened;
	UINT		uiDeviceNumber;
	HANDLE	*phCom;
	PSWITCHCONFIG prgscCom;

	bSuccess = FALSE;
	bJustOpened = FALSE;

	// Simplify our code
	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	phCom = &hCom[uiDeviceNumber-1];
	prgscCom = &g_pGlobalData->rgscCom[uiDeviceNumber-1];
	
	// Should we activate?
	if (	(0==*phCom)
		&&	(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{ // Yes
		*phCom = XswcComOpen( uiDeviceNumber );
		if (*phCom)
			{ //OK
			bSuccess = TRUE;
			bJustOpened = TRUE;
			prgscCom->dwFlags |= SC_FLAG_ACTIVE;
			prgscCom->dwFlags &= ~SC_FLAG_UNAVAILABLE;
			}
		else
			{ // Not OK
			bSuccess = FALSE;
			prgscCom->dwFlags &= ~SC_FLAG_ACTIVE;
			prgscCom->dwFlags |= SC_FLAG_UNAVAILABLE;
			}
		}

	// Should we deactivate?
	else if (	(0!=*phCom)
		&&	!(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{
		XswcComEnd( hsd ); // This will also zero out *phCom
		bSuccess = TRUE;
		prgscCom->dwFlags &= ~SC_FLAG_ACTIVE;
		}
	
	// If the above steps leave a valid hCom, let's try setting the config
	if ( 0!=*phCom )
		{
		if (psc->dwFlags & SC_FLAG_DEFAULT)
			{
			bSuccess = XswcComSet( *phCom, &g_pGlobalData->scDefaultCom );
			if (bSuccess)
				{
				prgscCom->dwFlags |= SC_FLAG_DEFAULT;
				prgscCom->u.Com = g_pGlobalData->scDefaultCom;
				}
			}
		else
			{
			bSuccess = XswcComSet( *phCom, &(psc->u.Com) );
			if (bSuccess)
				{
            prgscCom->u.Com = psc->u.Com;
				}
			}

		// If we can't set config and we just opened the port, better close it up.
		if (bJustOpened && !bSuccess)
			{
			XswcComEnd( hsd );
			prgscCom->dwFlags &= ~SC_FLAG_ACTIVE;
			}
		}

	return bSuccess;
}


/****************************************************************************

   FUNCTION: XswcComPollStatus()

	DESCRIPTION:
		Must be called in the context of the helper window.
		TODO: tell List which switch caused the last change?
****************************************************************************/

DWORD XswcComPollStatus( HSWITCHDEVICE	hsd )
{
	UINT uiDeviceNumber;
	HANDLE *phCom;
	DWORD dwStatus;
	DWORD dwModem;
	BOOL	bResult;

	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	phCom = &hCom[uiDeviceNumber-1];
	dwStatus = 0;
	if (*phCom)
		{
		bResult = GetCommModemStatus( *phCom, &dwModem );
		dwStatus |= (dwModem & MS_CTS_ON ) ? SWITCH_1 : 0;
		dwStatus |= (dwModem & MS_DSR_ON ) ? SWITCH_2 : 0;
		dwStatus |= (dwModem & MS_RLSD_ON) ? SWITCH_3 : 0;
		dwStatus |= (dwModem & MS_RING_ON) ? SWITCH_4 : 0;
		}
	g_pGlobalData->rgscCom[uiDeviceNumber-1].dwSwitches = dwStatus;
	return dwStatus;
}


/****************************************************************************

   FUNCTION: XswcComOpen()

	DESCRIPTION:
		Opens a file handle to the particular com port, based on
		the 1-based uiPort.
		
		If uiPort is invalid, this will automatically set up GetLastError().
		This is currently unlikely to happen since we make sure uiPort is valid in
		order to have a valid index into the array of device configs.
****************************************************************************/

HANDLE XswcComOpen( DWORD uiPort )
{
	HANDLE hComPort;
	TCHAR szComPort[20];

	hComPort = 0;
	wsprintf( szComPort, _TEXT("COM%1.1d"), uiPort );
	hComPort = CreateFile( szComPort, GENERIC_READ | GENERIC_WRITE, 0, NULL,
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

	if (INVALID_HANDLE_VALUE == hComPort) 
	{
		hComPort = 0;
	}

	return hComPort;
}


/****************************************************************************

   FUNCTION: XswcComSet()

	DESCRIPTION:
		Sets the configuration of the particular Port.
		Return FALSE (0) if an error occurs.
		GetLastError is automatically set up for us.
		
****************************************************************************/

BOOL XswcComSet(
	HANDLE hCom,
	PSWITCHCONFIG_COM pC )
{
	DCB dcb;
	BOOL bSuccess;

	dcb.DCBlength = sizeof( DCB );
	GetCommState( hCom, &dcb );
	// ENABLE = set low (+10V)
	// DISABLE = set high (-10V)
	dcb.fDtrControl = pC->dwComStatus & SC_COM_DTR ? 
		DTR_CONTROL_DISABLE : DTR_CONTROL_ENABLE;
	dcb.fRtsControl = pC->dwComStatus & SC_COM_RTS ? 
		RTS_CONTROL_DISABLE : RTS_CONTROL_ENABLE;
	bSuccess = SetCommState( hCom, &dcb );
	return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\swchjoy.c ===
/****************************************************************************
   Switch Input Library DLL - Joystick routines

   Copyright (c) 1992-1997 Bloorview MacMillan Centre

	Link with winmm.lib
*******************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include <msswch.h>
#include "msswchh.h"
#include "mappedfile.h"

HJOYDEVICE XswcJoyOpen( DWORD uiPort );
BOOL XswcJoySet(HJOYDEVICE hJoy, PSWITCHCONFIG_JOYSTICK pJ );

// Handles cannot be shared across processes
// These are faked handles, to keep the module logic similar to the serial port.
HJOYDEVICE ghJoy[MAX_JOYSTICKS] = {0,0};

void swchJoyInit()
{
    int i;
    long lSize = sizeof(SWITCHCONFIG);
    for (i=0;i<MAX_JOYSTICKS;i++)
    {
        g_pGlobalData->rgscJoy[i].cbSize = lSize;
        g_pGlobalData->rgscJoy[i].uiDeviceType = SC_TYPE_JOYSTICK;
        g_pGlobalData->rgscJoy[i].uiDeviceNumber = i+1;
        g_pGlobalData->rgscJoy[i].dwFlags = SC_FLAG_DEFAULT;
    }

    memset(&g_pGlobalData->rgJoySet, 0, MAX_JOYSTICKS * sizeof(JOYSETTINGS));

    g_pGlobalData->scDefaultJoy.dwJoySubType = SC_JOY_DEFAULT;
    g_pGlobalData->scDefaultJoy.dwJoyThresholdMinX = SC_JOYVALUE_DEFAULT;
    g_pGlobalData->scDefaultJoy.dwJoyThresholdMaxX = SC_JOYVALUE_DEFAULT;
    g_pGlobalData->scDefaultJoy.dwJoyThresholdMinY = SC_JOYVALUE_DEFAULT;
    g_pGlobalData->scDefaultJoy.dwJoyThresholdMaxY = SC_JOYVALUE_DEFAULT;
    g_pGlobalData->scDefaultJoy.dwJoyHysteresis = SC_JOYVALUE_DEFAULT;
}

/****************************************************************************

   FUNCTION: XswcJoyInit()

	DESCRIPTION:

****************************************************************************/

BOOL XswcJoyInit( HSWITCHDEVICE hsd )
	{
    UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

    g_pGlobalData->rgscJoy[uiDeviceNumber-1].u.Joystick = g_pGlobalData->scDefaultJoy;
	ghJoy[uiDeviceNumber-1] = 0;
	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcJoyEnd()

	DESCRIPTION:

****************************************************************************/

BOOL XswcJoyEnd( HSWITCHDEVICE hsd )
	{
	BOOL bSuccess = TRUE;
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

	ghJoy[uiDeviceNumber-1] = 0;
	g_pGlobalData->rgscJoy[uiDeviceNumber-1].dwSwitches = 0;

	// ignore bSuccess since we can't do anything anyways.
	return TRUE;
	}


/****************************************************************************

   FUNCTION: swcJoyGetConfig()

	DESCRIPTION:

****************************************************************************/

BOOL swcJoyGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	*psc = g_pGlobalData->rgscJoy[uiDeviceNumber-1];
	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcJoySetConfig()

	DESCRIPTION:
		Activate/Deactivate the device.
		
		Four cases: 
		1) hJoy = 0 and active = 0		- do nothing
		2)	hJoy = x and active = 1		- just set the configuration
		3) hJoy = 0 and active = 1		- activate and set the configuration
		4) hJoy = x and active = 0		- deactivate

		If there are no errors, TRUE is returned and ListSetConfig
		will write the configuration to the registry.
		If there is any error, FALSE is returned so the registry
		entry remains unchanged.

		Plug and Play can check the registry for SC_FLAG_ACTIVE and
		start up the device if it is set. This all probably needs some work.

****************************************************************************/

BOOL XswcJoySetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	BOOL		bSuccess;
	BOOL		bJustOpened;
	UINT		uiDeviceNumber;
    HJOYDEVICE  *pghJoy;
	PSWITCHCONFIG pgscJoy;

	bSuccess = FALSE;
	bJustOpened = FALSE;

	// Simplify our code
	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	pghJoy = &ghJoy[uiDeviceNumber-1];
	pgscJoy = &g_pGlobalData->rgscJoy[uiDeviceNumber-1];
	
	// Should we activate?
	if (	(0==*pghJoy)
		&&	(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{ // Yes
		*pghJoy = XswcJoyOpen( uiDeviceNumber );
		if (*pghJoy)
			{ //OK
			bSuccess = TRUE;
			bJustOpened = TRUE;
			pgscJoy->dwFlags |= SC_FLAG_ACTIVE;
			pgscJoy->dwFlags &= ~SC_FLAG_UNAVAILABLE;
			}
		else
			{ // Not OK
			bSuccess = FALSE;
			pgscJoy->dwFlags &= ~SC_FLAG_ACTIVE;
			pgscJoy->dwFlags |= SC_FLAG_UNAVAILABLE;
			}
		}

	// Should we deactivate?
	else if (	(0!=*pghJoy)
		&&	!(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{
		XswcJoyEnd( hsd ); // This will also zero out *pghJoy
		bSuccess = TRUE;
		pgscJoy->dwFlags &= ~SC_FLAG_ACTIVE;
		}
	
	// If the above steps leave a valid hJoy, let's try setting the config
	if ( 0!=*pghJoy )
		{
		if (psc->dwFlags & SC_FLAG_DEFAULT)
			{
			bSuccess = XswcJoySet( *pghJoy, &g_pGlobalData->scDefaultJoy );
			if (bSuccess)
				{
				pgscJoy->dwFlags |= SC_FLAG_DEFAULT;
				pgscJoy->u.Joystick = g_pGlobalData->scDefaultJoy;
				}
			}
		else
			{
			bSuccess = XswcJoySet( *pghJoy, &(psc->u.Joystick) );
			if (bSuccess)
				{
            pgscJoy->u.Joystick = psc->u.Joystick;
				}
			}

		// If we can't set config and we just opened the port, better close it up.
		if (bJustOpened && !bSuccess)
			{
			XswcJoyEnd( hsd );
			pgscJoy->dwFlags &= ~SC_FLAG_ACTIVE;
			}
		}

	return bSuccess;
	}


/****************************************************************************

   FUNCTION: XswcJoyPollStatus()

	DESCRIPTION:
		Must be called in the context of the helper window.
		(Actually it's not strictly necessary for the joystick,
		but we say so in order to be consistent with the other ports.)
****************************************************************************/

DWORD XswcJoyPollStatus( HSWITCHDEVICE	hsd )
	{
	JOYINFOEX	joyinfoex;
	MMRESULT		mmr;
	DWORD			dwStatus = 0;	// PREFIX 133793 init to default value
	UINT			uiDeviceNumber;
	UINT			uiJoyID;

	joyinfoex.dwSize = sizeof( JOYINFOEX );
	uiDeviceNumber = swcListGetDeviceNumber( NULL, hsd );

	assert( JOYSTICKID1 == 0 );	// assume JOYSTICKIDx is zero based
	uiJoyID = uiDeviceNumber -1;

	if (SC_FLAG_ACTIVE & g_pGlobalData->rgscJoy[uiDeviceNumber-1].dwFlags)
		{
		switch (g_pGlobalData->rgscJoy[uiDeviceNumber-1].u.Joystick.dwJoySubType)
			{
			case SC_JOY_BUTTONS:
				{
				dwStatus = 0;
				joyinfoex.dwFlags = JOY_RETURNBUTTONS;
				mmr = joyGetPosEx( uiJoyID, &joyinfoex );

				if (JOYERR_NOERROR == mmr)
					{
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON1) ? SWITCH_1 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON2) ? SWITCH_2 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON3) ? SWITCH_3 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON4) ? SWITCH_4 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON5) ? SWITCH_5 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON6) ? SWITCH_6 : 0;
					}
				}
				break;

			case SC_JOY_XYSWITCH:
				{
				dwStatus = 0;
				joyinfoex.dwFlags = JOY_RETURNBUTTONS | JOY_RETURNX | JOY_RETURNY;
				mmr = joyGetPosEx( uiJoyID, &joyinfoex );
				if (JOYERR_NOERROR == mmr)
					{
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON1) ? SWITCH_1 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON2) ? SWITCH_2 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON3) ? SWITCH_3 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON4) ? SWITCH_4 : 0;
					// No hysteresis needed, since it should be a switch
					if (joyinfoex.dwXpos < g_pGlobalData->rgJoySet[uiJoyID].XMinOn)
						dwStatus |=  SWITCH_5;
					if (joyinfoex.dwYpos < g_pGlobalData->rgJoySet[uiJoyID].YMinOn)
						dwStatus |=  SWITCH_6;
					}
				}
				break;

			case SC_JOY_XYANALOG:
				{
				// Hysteresis is necessary because of the "noisiness" of the joystick
				dwStatus = 0;
				joyinfoex.dwFlags = JOY_RETURNBUTTONS | JOY_RETURNX | JOY_RETURNY;
				mmr = joyGetPosEx( uiJoyID, &joyinfoex );

				if (JOYERR_NOERROR == mmr)
					{
					// In order to deal with the hysteresis,
					// we must explicity turn on or off each switch bit.
					dwStatus = g_pGlobalData->rgscJoy[uiDeviceNumber-1].dwSwitches;

					// left and right
					if (joyinfoex.dwXpos < g_pGlobalData->rgJoySet[uiJoyID].XMinOn)
						dwStatus |=  SWITCH_4;
					if (joyinfoex.dwXpos > g_pGlobalData->rgJoySet[uiJoyID].XMinOff)
						dwStatus &= ~SWITCH_4;

					if (joyinfoex.dwXpos > g_pGlobalData->rgJoySet[uiJoyID].XMaxOn)
						dwStatus |=  SWITCH_1;
					if (joyinfoex.dwXpos < g_pGlobalData->rgJoySet[uiJoyID].XMaxOff)
						dwStatus &= ~SWITCH_1;

					// top and bottom
					if (joyinfoex.dwYpos < g_pGlobalData->rgJoySet[uiJoyID].YMinOn)
						dwStatus |=  SWITCH_1;
					if (joyinfoex.dwYpos > g_pGlobalData->rgJoySet[uiJoyID].YMinOff)
						dwStatus &= ~SWITCH_1;

					if (joyinfoex.dwYpos > g_pGlobalData->rgJoySet[uiJoyID].YMaxOn)
						dwStatus |=  SWITCH_3;
					if (joyinfoex.dwYpos < g_pGlobalData->rgJoySet[uiJoyID].YMaxOff)
						dwStatus &= ~SWITCH_3;

					// 2 buttons
					if (joyinfoex.dwButtons & JOY_BUTTON1)
						dwStatus |=  SWITCH_5;
					else
						dwStatus &= ~SWITCH_5;

					if (joyinfoex.dwButtons & JOY_BUTTON2)
						dwStatus |=  SWITCH_6;
					else
						dwStatus &= ~SWITCH_6;
					}
				}
				break;

			default:
				dwStatus = 0;
				break;
			}
		g_pGlobalData->rgscJoy[uiDeviceNumber-1].dwSwitches = dwStatus;
		}

	return dwStatus;
	}

/****************************************************************************

   FUNCTION: XswcJoyOpen()

	DESCRIPTION:
	 uiPort is 1 based.
	 Return a non-zero value if the port is useable.
	 The joystick driver doesn't have a port to open, so
	 we fake the handle by using the PortNumber.

****************************************************************************/

HJOYDEVICE XswcJoyOpen( DWORD uiPort )
	{
	JOYINFOEX   joyinfoex;
	MMRESULT    mmr;
	UINT        uiJoyID;
    HJOYDEVICE  hJoy;	//faked, for success it must be non-zero

	assert( JOYSTICKID1 == 0 );	// assume JOYSTICKIDx is zero based

	joyinfoex.dwSize = sizeof( JOYINFOEX );

	// To check if a joystick is attached, set RETURNX and RETURNY as well.
	// If no joystick is attached, we will be OK just calling RETURNBUTTONS,
	// but a user will not be able to use the Windows calibration in 
    // Control Panel.

	joyinfoex.dwFlags = JOY_RETURNBUTTONS;
	uiJoyID = uiPort - 1;

	mmr = joyGetPosEx( uiJoyID, &joyinfoex );

	if (JOYERR_NOERROR == mmr)
		{
		hJoy = (HJOYDEVICE)uiPort;
		}
	else
		{
		hJoy = 0;
		}

	return hJoy;
	}


/****************************************************************************

   FUNCTION: XswcJoySet()

	DESCRIPTION:
		Sets the configuration of the particular Port.
		Remember that hJoy is actually the joystick port number.
		Return FALSE (0) if an error occurs.
		
****************************************************************************/

BOOL XswcJoySet(
	HJOYDEVICE hJoy,
	PSWITCHCONFIG_JOYSTICK pJ )
	{
	UINT uiJoyID = hJoy -1;
	BOOL bSuccess = TRUE;

	switch (pJ->dwJoySubType)
		{
		case SC_JOY_BUTTONS:
			bSuccess = TRUE;	//nothing to do
			break;

		case SC_JOY_XYSWITCH:
			// XY Switch only uses XMin and YMin
		case SC_JOY_XYANALOG:
			{
			DWORD	dwHy;
			// Set X values
			if (pJ->dwJoyThresholdMinX)
				g_pGlobalData->rgJoySet[uiJoyID].XMinOn = pJ->dwJoyThresholdMinX;
			else
				g_pGlobalData->rgJoySet[uiJoyID].XMinOn = 0x4000;
			g_pGlobalData->rgJoySet[uiJoyID].XMinOff = g_pGlobalData->rgJoySet[uiJoyID].XMinOn;
			if (pJ->dwJoyThresholdMaxX)
				g_pGlobalData->rgJoySet[uiJoyID].XMaxOn = pJ->dwJoyThresholdMaxX;
			else
				g_pGlobalData->rgJoySet[uiJoyID].XMaxOn = 0xC000;
			g_pGlobalData->rgJoySet[uiJoyID].XMaxOff = g_pGlobalData->rgJoySet[uiJoyID].XMaxOn;

			// Set Y values
			if (pJ->dwJoyThresholdMinY)
				g_pGlobalData->rgJoySet[uiJoyID].YMinOn = pJ->dwJoyThresholdMinY;
			else
				g_pGlobalData->rgJoySet[uiJoyID].YMinOn = 0x4000;
			g_pGlobalData->rgJoySet[uiJoyID].YMinOff = g_pGlobalData->rgJoySet[uiJoyID].YMinOn;
			if (pJ->dwJoyThresholdMaxY)
				g_pGlobalData->rgJoySet[uiJoyID].YMaxOn = pJ->dwJoyThresholdMaxY;
			else
				g_pGlobalData->rgJoySet[uiJoyID].YMaxOn = 0xC000;
			g_pGlobalData->rgJoySet[uiJoyID].YMaxOff = g_pGlobalData->rgJoySet[uiJoyID].YMaxOn;

			// Set hysteresis
			if (pJ->dwJoyHysteresis)
				dwHy = pJ->dwJoyHysteresis/2; // +/- half the value
			else
				dwHy = 0xFFFF/20;		// +/- 5%

			// Adjust for hysteresis
			g_pGlobalData->rgJoySet[uiJoyID].XMinOn -= dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].XMinOff += dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].XMaxOn += dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].XMaxOff -= dwHy;

			g_pGlobalData->rgJoySet[uiJoyID].YMinOn -= dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].YMinOff += dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].YMaxOn += dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].YMaxOff -= dwHy;
			bSuccess = TRUE;
			break;
			}

		default:
			bSuccess = FALSE;
			break;
		}

	return bSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\msswch.c ===
/****************************************************************************
   Switch Input Library DLL

   Copyright (c) 1992-1997 Bloorview MacMillan Centre

  MSSWCH.C - Global and external communication

		This module handles the list of calling windows, starts up the
		hidden helper window, and communicates with the helper window.

		The first user window that opens a port causes this DLL to start.
		The DLL executes the hidden helper window, which registers itself
		to the DLL through XswchRegHelpeWnd. When the last user window 
		closes a port, the  helper window is asked to shut down.
		The helper window calls down to to XswchEndAll to close down all
		global resources.

		For polling the switches, the helper window has started a timer, 
		which causes XswchTimerProc to be called continuously. This causes
		the switch devices to be polled, and swchPostSwitches to be
		called for each switch on each device that has changed status.

		When a user window tries to change the configuration, the request
		is posted up to the hidden window which calls down to
		XswchSetConfig on behalf of the user window in order to manipulate
		the global switch devices.

		Ideally all of this should be written as interrupt driven
		device drivers.

		IPC is handled in several ways:
		1) Communication between the 16-bit and 32-bit helper apps is via DDE
		2) The SetConfig call uses the WM_COPYDATA message to get the information
			transferred from the using app to the helper app.
		3) Currently all other information is in a global static, shared memory 
			area. Much of it could be in a memory-mapped file area which would allow
			more dynamic allocation of memory, but the static model is simpler to 
			implement for now, and provides faster performance with less overhead.
			When USB is added	it may be worthwhile moving to a memory-mapped file.

  18-Jul-97	GEH	First Microsoft version

  Notes:
	Clock resolution is 55 ms but clock time is 54.9 ms.

	Boundary condition 55 ms:
		0-54 = 1 tick, 56-109 = 2 ticks, 55 = 1 or 2 ticks
	
	*** AVOID THE BOUNDARY CONDITION ***

	SetTimer() experience:
		0 -54 	steady 55ms ticks
		55			55 ms ticks, misses (every tenth?)
		56-109 	steady 110ms ticks
		110		110 ms ticks, misses some
		111-		steady 165 ms ticks

	54.9 ms intervals:

		 55, 110, 165, 220, 275, 330, 385, 440, 495, 549,
		604, 659, 714, 769, 824

	We check the time because WM_TIMER messages may be combined

*******************************************************************************/

#include <windows.h>
#include <assert.h>
#include <mmsystem.h>
#include <msswch.h>
#include "msswchh.h"
#include "msswcher.h"
#include "mappedfile.h"
#include "w95trace.c"

// Helper Window / Timer related procs

BOOL APIENTRY XswchRegHelperWnd( HWND, PBYTE );
BOOL APIENTRY XswchEndAll( void );
LRESULT APIENTRY XswchSetSwitchConfig(WPARAM wParam, PCOPYDATASTRUCT pCopyData);
void APIENTRY XswchPollSwitches( HWND );
void APIENTRY XswchTimerProc( HWND );

// Internal functions

BOOL swchInitSharedMemFile();

__inline swchSetLastError(DWORD err)
{
	SetLastError(err);
}

/****************************************************************************

   FUNCTION: XswchRegHelperWnd()

	DESCRIPTION:
		Called by the helper window (SWCHX) to register itself for
		shutdown later on. 

****************************************************************************/

BOOL APIENTRY XswchRegHelperWnd(HWND hWndApp, PBYTE pbda)
{
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SZMUTEXCONFIG, INFINITE))
    {
		if (g_pGlobalData)
		{
			g_pGlobalData->hwndHelper = hWndApp;
			memcpy( g_pGlobalData->rgbBiosDataArea, pbda, BIOS_SIZE );

			XswcListInit();
		}

        ScopeUnaccessMemory(hMutex);
    }
	return TRUE;
}


/****************************************************************************

   FUNCTION: XswchEndAll()

	DESCRIPTION:
		Called by the helper window.
		Frees all the switch resources

****************************************************************************/

BOOL APIENTRY XswchEndAll( void )
{
    BOOL fRv = FALSE;
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, 5000))
    {
        fRv = XswcListEnd();
        ScopeUnaccessMemory(hMutex);
    }
	return fRv;
}


/****************************************************************************

    FUNCTION: swchOpenSwitchPort()

    DESCRIPTION:
		All applications using the DLL whether in event or in polling
		mode must call swchOpenSwitchPort() with their window handle.
		On exit they must call swchCloseSwitchPort().

		Perform any initialization needed when someone loads the DLL.
		Also keeps track of how many windows are using this DLL.

		In the future this should be a dynamically allocated list, not limited
		to a compile time array.

		Also, we assume that window handles are unique and therefore simply
		turn around and use the passed in windows handle as the HSWITCHPORTs.
****************************************************************************/

HSWITCHPORT APIENTRY swchOpenSwitchPort(HWND hWnd, DWORD dwPortStyle)
{
	HANDLE      hMutex;

	if (NULL == hWnd)
	{
		swchSetLastError( SWCHERROR_INVALID_HWND );
		return NULL;
	}

	if (!IsWindow( hWnd ))
	{
		swchSetLastError( SWCHERROR_INVALID_HWND );
		return NULL;
	}

    if (ScopeAccessMemory(&hMutex, SZMUTEXWNDLIST, INFINITE))
    {
	    int i;

        // setup to use the shared memory file w/in calling process
		if (!swchInitSharedMemFile())
		    goto Exit_OpenSwitchPort;

        // hit max using windows?
	    if (g_pGlobalData->cUseWndList >= MAXWNDS)
		{
		    swchSetLastError( SWCHERROR_MAXIMUM_PORTS );
		    goto Exit_OpenSwitchPort;
		}

        // hWnd must be unique; only 1 switch device per hwnd
	    for (i=0; i<g_pGlobalData->cUseWndList; i++)
		{
		    if (hWnd == g_pGlobalData->rgUseWndList[i].hWnd)
		    {
		        swchSetLastError( SWCHERROR_HWND_ALREADY_USED );
		        goto Exit_OpenSwitchPort;
		    }
		}

        // got unique window
	    g_pGlobalData->rgUseWndList[g_pGlobalData->cUseWndList].hWnd = hWnd;
	    g_pGlobalData->rgUseWndList[g_pGlobalData->cUseWndList].dwPortStyle = dwPortStyle;
	    i = ++g_pGlobalData->cUseWndList;

		// release mutex before starting helper window to avoid deadlock
        ScopeUnaccessMemory(hMutex);

	    if (1 == i)	// first caller starts port resource owner exe
           {
                STARTUPINFOA si;
                PROCESS_INFORMATION pi;
                CHAR szArg[] = "MSSWCHX.EXE SWCH";

                memset(&si,0,sizeof(si));
                si.cb = sizeof(si);
                si.dwFlags = STARTF_USESHOWWINDOW;
                si.wShowWindow = SW_HIDE;
                memset(&pi,0,sizeof(PROCESS_INFORMATION));

                CreateProcessA(NULL, szArg, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);        	
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
           }
	    
	    // Return a handle to the switch port
	    swchSetLastError( SWCHERROR_SUCCESS );
		return (HSWITCHPORT) hWnd;
    }

Exit_OpenSwitchPort:
    ScopeUnaccessMemory(hMutex);
	return NULL;
}


/****************************************************************************

    FUNCTION: swchCloseSwitchPort()

	 DESCRIPTION:

		Perform any deallocation/cleanup when the DLL is no longer needed.
		
		Note that the passed in HSWITCHPORT handle is simply a window handle,
		but the user doesn't know that.

****************************************************************************/

BOOL APIENTRY swchCloseSwitchPort(HSWITCHPORT hSwitchPort )
{
	HWND hWndRemove = (HWND)hSwitchPort;
	HANDLE hMutex;

	if (NULL == hWndRemove) 
        return FALSE;

    if (ScopeAccessMemory(&hMutex, SZMUTEXWNDLIST, INFINITE))
    {
	    short  i,j;
    	int cUseWndList = g_pGlobalData->cUseWndList;
    	if (cUseWndList > MAXWNDS+1)
    		cUseWndList = MAXWNDS+1;
    	
        // find the one caller wants to remove
	    for (i=0; i<cUseWndList; i++)
	    {
		    if (hWndRemove == g_pGlobalData->rgUseWndList[i].hWnd)
			    break;
	    }
		
	    if (i < g_pGlobalData->cUseWndList)
	    {
            // move items in list down one
	        for (j=i; j<cUseWndList; j++)
	        {
		        g_pGlobalData->rgUseWndList[j] = g_pGlobalData->rgUseWndList[j+1];
	        }

            // reduce count of users
	        g_pGlobalData->cUseWndList--;

            // if no more users then close port watcher
	        if (0 == g_pGlobalData->cUseWndList)
	        {
                // unhook the keyboard

                if (g_pGlobalData->hKbdHook)
                {
                    g_pGlobalData->fSyncKbd = FALSE;
                    UnhookWindowsHookEx(g_pGlobalData->hKbdHook);
                    g_pGlobalData->hKbdHook = NULL;
                }

				if (g_pGlobalData->hwndHelper && IsWindow( g_pGlobalData->hwndHelper ))
				{
					PostMessage( g_pGlobalData->hwndHelper, WM_CLOSE, 0, 0L );
				}
				g_pGlobalData->hwndHelper = NULL;
	        }
	    } // Else if not found, ignore it

        ScopeUnaccessMemory(hMutex);
    }

	return TRUE;
}


/****************************************************************************

    FUNCTION: swchGetSwitchDevice()

	 DESCRIPTION:
	   Return a handle to a switch device, given the PortType and PortNumber.
****************************************************************************/

HSWITCHDEVICE swchGetSwitchDevice(
    HSWITCHPORT hSwitchPort, 
    UINT uiDeviceType, 
    UINT uiDeviceNumber)
{
	HSWITCHDEVICE hsd = NULL;
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, INFINITE))
    {
	    hsd = swcListGetSwitchDevice( hSwitchPort, uiDeviceType, uiDeviceNumber );
        ScopeUnaccessMemory(hMutex);
    }
    return hsd;
}


/****************************************************************************

    FUNCTION: swchGetDeviceType()

	 DESCRIPTION:
		Return the Device Type value given the handle to the switch device.
****************************************************************************/

UINT swchGetDeviceType(HSWITCHPORT hSwitchPort, HSWITCHDEVICE hsd)
{
    BOOL fRv = FALSE;
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, INFINITE))
    {
    	fRv = swcListGetDeviceType( hSwitchPort, hsd );
        ScopeUnaccessMemory(hMutex);
    }
    return fRv;
}


/****************************************************************************

    FUNCTION: swchGetSwitchConfig()

	 DESCRIPTION:
		Returns with the buffer filled in with the configuration information
		for the given switch device.
****************************************************************************/

BOOL swchGetSwitchConfig(HSWITCHPORT hSwitchPort, HSWITCHDEVICE hsd, PSWITCHCONFIG psc)
{
	BOOL fRv = FALSE;
	HANDLE hMutex;

    if (ScopeAccessMemory(&hMutex, SZMUTEXCONFIG, INFINITE))
    {
	    fRv = swcListGetConfig( hSwitchPort, hsd, psc );
        ScopeUnaccessMemory(hMutex);
    }
	return fRv;
}


/****************************************************************************

    FUNCTION: swchSetSwitchConfig()

	 DESCRIPTION: Called by user applications that wish to change the configuration
		of a switch device.  Since all devices must be owned by the helper
		window, the parameters are copied to shared address space and a message
		posted to the helper window which will call down to XswchSetSwitchConfig.

	 Currently we send a WM_COPYDATA message for cheap IPC.
	 In the memory block we simply include the SWITCHCONFIG information.
****************************************************************************/

BOOL swchSetSwitchConfig(HSWITCHPORT hSwitchPort, HSWITCHDEVICE hsd, PSWITCHCONFIG psc)
{
	DWORD dwAllocSize;
	COPYDATASTRUCT CopyData;
	PBYTE pData;
	LRESULT lRes = SWCHERR_ERROR;
    HANDLE hMutex;

	if (!psc)
	{
		swchSetLastError( SWCHERROR_INVALID_PARAMETER );
		return FALSE;
	}

	dwAllocSize = sizeof(SWITCHCONFIG);
    if (!(psc->cbSize) || (dwAllocSize < psc->cbSize))
	{
        swchSetLastError( SWCHERROR_INSUFFICIENT_BUFFER );
		return FALSE;
	}

	assert( sizeof(HSWITCHDEVICE) == sizeof(DWORD_PTR) );
	assert( sizeof(HSWITCHPORT) == sizeof(WPARAM) );

	pData = (PBYTE) LocalAlloc( LPTR, dwAllocSize );
    if (!pData)
        return FALSE;   // LocalAlloc called swchSetLastError

	CopyData.dwData = (DWORD_PTR)hsd;
	CopyData.lpData = pData;
	CopyData.cbData = dwAllocSize;
	memcpy( pData, psc, sizeof(SWITCHCONFIG));

    // send config data to owner (it will call back with it)
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, INFINITE))
    {
		HWND hWnd = g_pGlobalData->hwndHelper;
        // avoid problems with callback into DLL while mutex is open
        ScopeUnaccessMemory(hMutex);
	    lRes = SendMessage(hWnd, WM_COPYDATA, (WPARAM) hSwitchPort, (LPARAM) &CopyData);
    }

	LocalFree( pData );
    return (lRes == SWCHERR_NO_ERROR)?FALSE:TRUE;
}


/****************************************************************************

    FUNCTION: XswchSetSwitchConfig()

	 DESCRIPTION:
		Gets called by the helper window to set the configuration.
		Note: we are in SendMessage() above.

****************************************************************************/

LRESULT APIENTRY XswchSetSwitchConfig(WPARAM wParam, PCOPYDATASTRUCT pCopyData)
{
	HSWITCHPORT   hSwitchPort = (HSWITCHPORT) wParam;
	HSWITCHDEVICE hsd;
	SWITCHCONFIG  scConfig;
	BOOL          bReturn = FALSE;
    HANDLE        hMutex;

	memcpy( &scConfig, pCopyData->lpData, sizeof(SWITCHCONFIG));
	hsd = (HSWITCHDEVICE) pCopyData->dwData;

    if (ScopeAccessMemory(&hMutex, SZMUTEXCONFIG, INFINITE))
    {
	    bReturn = XswcListSetConfig( hSwitchPort, hsd, &scConfig );
        ScopeUnaccessMemory(hMutex);
    }
		
    return (bReturn) ? SWCHERR_NO_ERROR : SWCHERR_ERROR;
}

/****************************************************************************

    FUNCTION: XswchPollSwitches()

    DESCRIPTION:
		The helper windows calls this.
		XswcListPollSwitches() ultimately calls swchPostSwitches() for each switch
		on each device that has changed state.
****************************************************************************/

void APIENTRY XswchPollSwitches( HWND hWnd )
{
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, 5000))
    {
    	g_pGlobalData->dwSwitchStatus = XswcListPollSwitches();
        ScopeUnaccessMemory(hMutex);
    }
}
	
	
/****************************************************************************

    FUNCTION: XswchTimerProc()

    DESCRIPTION:
		Timer call-back function for the regularly scheduled timer.
		The helper app calls this proc everytime it receives a timer message.
		XswcListPollSwitches() ultimately calls swchPostSwitches() for each switch
		on each device that has changed state.

		Currently we use the timer whether or not any application has requested
		events. In the future we could check and see if any applications are
		requesting events and only then start up the timer for non-interrupt
		driven devices.
****************************************************************************/

void APIENTRY XswchTimerProc( HWND hWnd )
{
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SZMUTEXSWITCHSTATUS, 5000))
    {
	    g_pGlobalData->dwSwitchStatus = XswcListPollSwitches();
        ScopeUnaccessMemory(hMutex);
    }
}

/****************************************************************************

   FUNCTION: swchCheckForScanChar (BOOL fCheckForScanKey)

	DESCRIPTION:
      Called just before the key designated as the scan mode key is sent
	  out to allow the keyboard filter to treat that key as a regular key
	  (send it to the target app) vs treating it as the scan key.
****************************************************************************/

void APIENTRY swchCheckForScanChar (BOOL fCheckForScanKey)
{
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, INFINITE))
    {
		g_pGlobalData->fCheckForScanKey = fCheckForScanKey;
        ScopeUnaccessMemory(hMutex);
    }
}


/****************************************************************************

   FUNCTION: swchPostSwitches()

	DESCRIPTION:
		Post the given switch up or down message to all applications
		which have requested posted messages.

		We would like to use timeGetTime() instead of GetTickCount, but
		it is unclear under what circumstances the multimedia timer is
		working at a more precise level. On my old PS/2 Model 95 with
		a 16-bit Microchannel Sound Blaster Pro, there does not seem
		to be a multimedia timer.

****************************************************************************/

BOOL swchPostSwitches(HSWITCHDEVICE hsd, DWORD dwSwitch)
{
	DWORD dwMsec = timeGetTime();
	int i;
	int cUseWndList = g_pGlobalData->cUseWndList;
	if (cUseWndList > MAXWNDS+1)
		cUseWndList = MAXWNDS+1;
	
	assert( sizeof(WPARAM) >= sizeof(HSWITCHDEVICE) );

	for (i=0; i<cUseWndList; i++)
	{
        HWND hWnd = g_pGlobalData->rgUseWndList[i].hWnd;
        if (!IsWindow(hWnd))
            continue;   // skip over dead windows

		if (PS_EVENTS == g_pGlobalData->rgUseWndList[i].dwPortStyle)
		{
			PostMessage(hWnd, dwSwitch, (WPARAM)hsd, dwMsec);
		}
	}

	return TRUE;
}


/****************************************************************************

   FUNCTION: swchPostConfigChanged()

	DESCRIPTION:
		Post the CONFIGCHANGED message to all apps which have registered
		with this DLL.
				
****************************************************************************/

BOOL swchPostConfigChanged( void )
{
	int i;
	for (i=0; i<g_pGlobalData->cUseWndList; i++)
	{
        HWND hWnd = g_pGlobalData->rgUseWndList[i].hWnd;
		if (IsWindow(hWnd))
		{
			PostMessage(hWnd, SW_SWITCHCONFIGCHANGED, 0, 0);
		}
	}
	return TRUE;
}

/****************************************************************************

   FUNCTION: GetDesktopName()

	DESCRIPTION:
		Internal function retrieve the name of the input desktop
				
****************************************************************************/
BOOL GetDesktopName(LPTSTR szDeskName, int cchDeskName)
{
    HDESK hdesk;
    DWORD nl;

	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    DBPRINTF(TEXT("GetDesktopName:  OpenInputDesktop returns hdesk=0x%x error=%d\r\n"), hdesk, GetLastError());
    if (!hdesk)
    {
        TCHAR szWinlogon[] = TEXT("Winlogon");
		hdesk = OpenDesktop(szWinlogon, 0, FALSE, MAXIMUM_ALLOWED);
        DBPRINTF(TEXT("GetDesktopName:  OpenDesktop returns hdesk=0x%x error=%d\r\n"), hdesk, GetLastError());
		if (!hdesk)
		{
            DBPRINTF(TEXT("GetDesktopName:  FAILING\r\n"));
		    return FALSE;
        }
    }
    
	GetUserObjectInformation(hdesk, UOI_NAME, szDeskName, cchDeskName, &nl);
    
    CloseDesktop(hdesk);
    DBPRINTF(TEXT("GetDesktopName:  desktop name is %s\r\n"), szDeskName);
	return TRUE;
}

/****************************************************************************

   FUNCTION: swchInitSharedMemFile()

	DESCRIPTION:
		Internal function to open the shared memory file and initialize it.
				
****************************************************************************/

BOOL swchInitSharedMemFile()
{
    // Init memory on first open if DLL_Attach didn't do it
    if (!g_pGlobalData)
    {
        swchOpenSharedMemFile();
        if (!g_pGlobalData)
        {
            DBPRINTF(TEXT("swchInitSharedMemFile: ERROR !g_pGlobalData\r\n"));
            return FALSE;    // internal error! ignore we'll see it later.
        }
    }

    memset((void *)g_pGlobalData, 0, sizeof(GLOBALDATA));
    swchComInit();
    swchJoyInit();
    swchKeyInit();
    swchListInit();

	return TRUE;
}

/****************************************************************************

   FUNCTION: swchOpenSharedMemFile()

	DESCRIPTION:
		Internal function to open the shared memory file.
				
****************************************************************************/

BOOL swchOpenSharedMemFile()
{
    if (!g_pGlobalData)
    {
        TCHAR szName[256];

        // Fail quietly on GetDesktopName; it can fail when OSK attaches
        // to msswch.dll because we've not assigned ourselves to a desktop
        // yet.  OSK will go thru this code when it explicitly registers.

        if (GetDesktopName(szName, 256))
        {
            if (!AccessSharedMemFile(
                      szName
                    , sizeof(GLOBALDATA)
                    , &g_pGlobalData))
            {
                swchSetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return FALSE;
            }
        }
    }
	return TRUE;
}

/****************************************************************************

   FUNCTION: swchCloseSharedMemFile()

	DESCRIPTION:
		Internal function to close the shared memory file.
				
****************************************************************************/

void swchCloseSharedMemFile()
{
    if (g_pGlobalData)
    {
        UnaccessSharedMemFile();
        g_pGlobalData = 0;
    }
}

/****************************************************************************

   FUNCTION: XswchStoreLastError()

	DESCRIPTION:

	Internal function to store the last error code for the process specific
	switch port, which is also the window handle at this point.
	If no switch port handle is passed, store the error code in
	a global variable.
	
	The Windows swchSetLastError call can be made
	just before the process specific call which caused the error
	returns to the application.
	
****************************************************************************/

void XswchStoreLastError(HSWITCHPORT hSwitchPort, DWORD dwError)
{
	if (NULL == hSwitchPort)
	{
		g_pGlobalData->dwLastError = dwError;
	}
	else
	{
	    int i;
		int cUseWndList = g_pGlobalData->cUseWndList;
		if (cUseWndList > MAXWNDS+1)
			cUseWndList = MAXWNDS+1;
		
		for (i=0; i<cUseWndList; i++)
		{
			if (hSwitchPort == g_pGlobalData->rgUseWndList[i].hWnd)
            {
    			g_pGlobalData->rgUseWndList[i].dwLastError = dwError;
                return;
            }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\swchkey.c ===
/****************************************************************************
   Switch Input Library DLL - Keyboard hook routines

   Copyright (c) 1992-1997 Bloorview MacMillan Centre


*******************************************************************************/

#include <windows.h>
#include <msswch.h>
#include "msswchh.h"
#include "mappedfile.h"
#include "w95trace.h"

// Hook proc
BOOL XswcKeyOpen( void );
BOOL XswcKeySet( PSWITCHCONFIG_KEYS pK );
BOOL swcKeyModKeysDown( UINT dwMod );

void swchKeyInit()
{
    g_pGlobalData->fCheckForScanKey = TRUE;
	g_pGlobalData->fScanKeys = FALSE;
    g_pGlobalData->scKeys.cbSize = sizeof(SWITCHCONFIG);
    g_pGlobalData->scKeys.uiDeviceType = SC_TYPE_KEYS;
    g_pGlobalData->scKeys.uiDeviceNumber = 1;
    g_pGlobalData->rgHotKey[0].dwSwitch = SWITCH_1;
    g_pGlobalData->rgHotKey[1].dwSwitch = SWITCH_2;

	g_pGlobalData->fSyncKbd = FALSE;
	g_pGlobalData->hwndOSK = 0;
	g_pGlobalData->uiMsg = 0;
}



/****************************************************************************

   FUNCTION: swcKeyboardHookProc()

	DESCRIPTION:
      When the hook is set set, this blocks the specified keys from
		being processed by anyone else.

		We could use this to set the switch status as well, but for 
		consistency we do it in the PollStatus routine.

      This must be released before unloading the DLL.

****************************************************************************/

LRESULT CALLBACK swcKeyboardHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    // Only check for the scanning key if we are in scan mode and not blocked
	// from checking for the key.  We are blocked when the key is sent out from
	// scan mode (eg. the user wants to "type" that key).

    if (nCode >= 0 && g_pGlobalData->fScanKeys && g_pGlobalData->fCheckForScanKey)
    {
		int i;
		for (i=0; i<NUM_KEYS; i++ )
		{
			// is this the scan hot key?
			if (g_pGlobalData->rgHotKey[i].vkey && (wParam == g_pGlobalData->rgHotKey[i].vkey))
			{
				// and are any requested modifier keys down?
				if (swcKeyModKeysDown(g_pGlobalData->rgHotKey[i].mod))
				{
					return 1;  // don't send out scan hotkey
				}
			}
		}
	}

	swchCheckForScanChar(TRUE);	// check next key
	
    // not in scan mode pass it on
    return 0;
}



/****************************************************************************

   FUNCTION: XswcKeyInit()

	DESCRIPTION:

****************************************************************************/

BOOL XswcKeyInit( HSWITCHDEVICE hsd )
	{
	BOOL bSuccess = TRUE;

	g_pGlobalData->scKeys.u.Keys = g_pGlobalData->scDefaultKeys;

	return bSuccess;
	}


/****************************************************************************

   FUNCTION: XswcKeyEnd()

	DESCRIPTION:

****************************************************************************/

BOOL XswcKeyEnd( HSWITCHDEVICE hsd )
{
	// clear the keyboard hook
	if (g_pGlobalData->fScanKeys)
	{
        g_pGlobalData->fScanKeys = FALSE;
	}
	g_pGlobalData->scKeys.dwSwitches = 0;
	return TRUE;
}


/****************************************************************************

   FUNCTION: swcKeyGetConfig()

	DESCRIPTION:

****************************************************************************/

BOOL swcKeyGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	*psc = g_pGlobalData->scKeys;
	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcKeySetConfig()

	DESCRIPTION:
		Activate/Deactivate the hook.
		
		Four cases: 
		1) g_pGlobalData->fScanKeys = 0 and active = 0		- do nothing
		2) g_pGlobalData->fScanKeys = 1 and active = 1		- just set the configuration
		3) g_pGlobalData->fScanKeys = 0 and active = 1		- activate and set the configuration
		4) g_pGlobalData->fScanKeys = 1 and active = 0		- deactivate

		If there are no errors, TRUE is returned and ListSetConfig
		will write the configuration to the registry.
		If there is any error, FALSE is returned so the registry
		entry remains unchanged.

		Plug and Play can check the registry for SC_FLAG_ACTIVE and
		start up the device if it is set. This all probably needs some work.

****************************************************************************/

BOOL XswcKeySetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
{	
	BOOL bSuccess = FALSE;
	BOOL bJustOpened = FALSE;

	// Should we activate?
	if (!g_pGlobalData->fScanKeys && (psc->dwFlags & SC_FLAG_ACTIVE))
	{ // Yes
		g_pGlobalData->fScanKeys = XswcKeyOpen();
		if (g_pGlobalData->fScanKeys)
		{ //OK
			bSuccess = TRUE;
			bJustOpened = TRUE;
			g_pGlobalData->scKeys.dwFlags |= SC_FLAG_ACTIVE;
			g_pGlobalData->scKeys.dwFlags &= ~SC_FLAG_UNAVAILABLE;
		}
		else
		{ // Not OK
			bSuccess = FALSE;
			g_pGlobalData->scKeys.dwFlags &= ~SC_FLAG_ACTIVE;
			g_pGlobalData->scKeys.dwFlags |= SC_FLAG_UNAVAILABLE;
		}
	}
	// Should we deactivate?
	else if (g_pGlobalData->fScanKeys && !(psc->dwFlags & SC_FLAG_ACTIVE))
	{
		XswcKeyEnd( hsd ); // This will set fScanKeys FALSE 
		bSuccess = TRUE;
		g_pGlobalData->scKeys.dwFlags &= ~SC_FLAG_ACTIVE;
	}

	// If the above steps leave a valid g_pGlobalData->hKbdHook, let's try setting the config
	// currently we don't do any error checking, so anything goes.
	if (g_pGlobalData->fScanKeys)
	{
		if (psc->dwFlags & SC_FLAG_DEFAULT)
		{
			bSuccess = XswcKeySet( &g_pGlobalData->scDefaultKeys );
			if (bSuccess)
			{
				g_pGlobalData->scKeys.dwFlags |= SC_FLAG_DEFAULT;
				g_pGlobalData->scKeys.u.Keys = g_pGlobalData->scDefaultKeys;
			}
		}
		else
		{
			bSuccess = XswcKeySet( &(psc->u.Keys) );
			if (bSuccess)
			{
				g_pGlobalData->scKeys.u.Keys = psc->u.Keys;
			}
		}

		// If we can't set config and we just opened the port, better close it up.
		if (bJustOpened && !bSuccess)
		{
			XswcKeyEnd( hsd );
			g_pGlobalData->scKeys.dwFlags &= ~SC_FLAG_ACTIVE;
		}
	}

	return bSuccess;
}


/****************************************************************************

   FUNCTION: XswcKeyPollStatus()

	DESCRIPTION:

  Assumes that if there is no keyboard hook, then this "device" is not active.

****************************************************************************/

DWORD XswcKeyPollStatus( HSWITCHDEVICE	hsd )
{
	int i;
	DWORD dwStatus;

	dwStatus = 0;
	if (g_pGlobalData->fScanKeys)
	{
		for (i=0; i<NUM_KEYS; i++)
		{
			if ((GetAsyncKeyState( g_pGlobalData->rgHotKey[i].vkey ) & 0x8000)
				&& swcKeyModKeysDown( g_pGlobalData->rgHotKey[i].mod ) )
            {
				dwStatus |= g_pGlobalData->rgHotKey[i].dwSwitch;
            }
		}
	}
	g_pGlobalData->scKeys.dwSwitches = dwStatus;

	return dwStatus;
}


/****************************************************************************

   FUNCTION: XswcKeyOpen()

	DESCRIPTION:
	Set the Windows keyboard hook.

****************************************************************************/

BOOL XswcKeyOpen( void )
{
	extern HOOKPROC OSKHookProc(int nCode, WPARAM wParam, LPARAM lParam);

	if (g_pGlobalData && !g_pGlobalData->hKbdHook)
	{
		g_pGlobalData->hKbdHook = SetWindowsHookEx(
									  WH_KEYBOARD
									, (HOOKPROC) OSKHookProc
									, GetModuleHandle(SZ_DLLMODULENAME)
									, 0);
	}

	return (g_pGlobalData && g_pGlobalData->hKbdHook) ? TRUE : FALSE;
}


/****************************************************************************

   FUNCTION: XswcKeySet()

	DESCRIPTION:

  Sets the configuration of the keys, storing the virtual key number and
  modifier states.

  In the future this routine can be used to limit the valid virtual keys.
		
****************************************************************************/

BOOL XswcKeySet( PSWITCHCONFIG_KEYS pK )
	{
	BOOL bSuccess;

	g_pGlobalData->rgHotKey[0].mod = HIWORD( pK->dwKeySwitch1 );
	g_pGlobalData->rgHotKey[0].vkey = LOWORD( pK->dwKeySwitch1 );
	g_pGlobalData->rgHotKey[1].mod = HIWORD( pK->dwKeySwitch2 );
	g_pGlobalData->rgHotKey[1].vkey = LOWORD( pK->dwKeySwitch2 );

	bSuccess = TRUE;
	return bSuccess;
	}


/****************************************************************************

   FUNCTION: swcKeyModKeysDown()

	DESCRIPTION:
	
	Are all the requested modifier keys down?
	If any requested key is not down, return FALSE.
	If any key is down but not requested, return FALSE.

****************************************************************************/

BOOL swcKeyModKeysDown( UINT dwMod )
	{
	DWORD		dwTest = 0;

	if (dwMod ^ dwTest)
		return FALSE;
	else
		return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\version.h ===
s// MAGNIFY.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "msswch\0"
#define VER_INTERNALNAME_STR        "msswch\0"
#define VER_ORIGINALFILENAME_STR    "msswch.dll\0"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswchx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msswchx.rc
//

#define IDS_NOT_USER_PROG         2
#define IDS_PROC_NOT_FOUND        3
#define IDS_MSSWCH_DLL_NOT_FOUND  4

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswchx\msswchx.c ===
/****************************************************************************
   Hidden 32-bit window for
   Switch Input Library DLL

   Copyright (c) 1992-1997 Bloorview MacMillan Centre
   
   This application performs several helper tasks:

   1) It owns any global resources (hooks, hardware devices) that are
      opened on behalf of applications using switch input

   2) It catches timer messages to keep polling the hardware devices

   3) In Windows 95 it receives the 16-bit bios table address information
      from the 16-bit hidden application and forwards it into the 
      32-bit world of the Switch Input Library

   If the window is not hidden on startup, it is in debug mode.
****************************************************************************/

/**************************************************************** Headers */

#include <windows.h>
#include <tchar.h>
#include "w95trace.c"
#include "msswch.h"
#include "resource.h"


// Types and pointer decls to DLL entry points

typedef BOOL (APIENTRY *LPFNXSWCHREGHELPERWND)( HWND hWnd, PBYTE bda );
typedef void (APIENTRY *LPFNXSWCHPOLLSWITCHES)( HWND hWnd );
typedef void (APIENTRY *LPFNXSWCHTIMERPROC)( HWND hWnd );
typedef LRESULT (APIENTRY *LPFNXSWCHSETSWITCHCONFIG)( WPARAM wParam, PCOPYDATASTRUCT pcd );
typedef BOOL (APIENTRY *LPFNXSWCHENDALL)( void );

LPFNXSWCHREGHELPERWND lpfnXswchRegHelperWnd;
LPFNXSWCHPOLLSWITCHES lpfnXswchPollSwitches;
LPFNXSWCHTIMERPROC lpfnXswchTimerProc;
LPFNXSWCHSETSWITCHCONFIG lpfnXswchSetSwitchConfig;
LPFNXSWCHENDALL lpfnXswchEndAll;

// Helper macro to get pointers to DLL entry points

#define GET_FUNC_PTR(name, ordinal, hlib, type, fUseDLL) \
{ \
	lpfn ## name = (type)GetProcAddress(hlib, LongToPtr(MAKELONG(ordinal, 0))); \
	if (!lpfn ## name) { \
		fUseDLL = FALSE; \
		ErrMessage(TEXT( #name ), IDS_PROC_NOT_FOUND, 0 ); \
	} \
}

static TCHAR x_szSwitchDll[] = TEXT("msswch.dll");
#define MAX_MSGLEN    256
#define SW_APPNAME    TEXT("msswchx")
#define SWITCH_TIMER_POLL_INTERVAL 0
#define MAJIC_CMDOPT  "SWCH"

// g_bios_data_area[] is a hold-over from Win9x code, unused in NT or W2K
#define BIOS_SIZE 16
BYTE g_bios_data_area[BIOS_SIZE];

INT_PTR APIENTRY SwchWndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
INT_PTR APIENTRY WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
void SwitchOnCreate(HWND hWnd);
BOOL SwitchOnCopyData(WPARAM wParam, LPARAM lParam);
BOOL SwitchOnCopyData(WPARAM wParam, LPARAM lParam);
void SwitchOnTimer(HWND hWnd);
void SwitchOnPoll(HWND hWnd);
void SwitchOnEndSession(HWND hWnd);
void ErrMessage(LPCTSTR szTitle, UINT uMsg, UINT uFlags);

static BOOL AssignDesktop();
static BOOL InitMyProcessDesktopAccess(VOID);
static VOID ExitMyProcessDesktopAccess(VOID);

HINSTANCE  g_hInst = NULL;
HANDLE g_hLibrary = 0;
BOOL g_WinlogonDesktop = FALSE;
// IsSystem - Returns TRUE if our process is running as SYSTEM
//
BOOL IsSystem()
{
    BOOL fStatus = FALSE;
    BOOL fIsLocalSystem = FALSE;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
    PSID psidSystem;
    if (!AllocateAndInitializeSid(&siaLocalSystem, 
                                            1,
                                            SECURITY_LOCAL_SYSTEM_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &psidSystem))
    {			
    	return FALSE;
    }

    if (psidSystem) 
    {
    	fStatus = CheckTokenMembership(NULL, psidSystem, &fIsLocalSystem);
    }

    return (fStatus && fIsLocalSystem);
}

/********************************************************\
 Windows initialization
\********************************************************/

int PASCAL WinMain(
	HINSTANCE	hInstance,
	HINSTANCE   hPrevInstance,
	LPSTR	    lpszCmdLine,
	int		    nCmdShow )
{
	HWND		hWnd;
	MSG         msg;
	WNDCLASS	wndclass;

	// Look for magic word

	if (strcmp(lpszCmdLine, MAJIC_CMDOPT))
	{
		TCHAR szErrBuf[MAX_MSGLEN];
		if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpszCmdLine, -1, szErrBuf, MAX_MSGLEN))
			ErrMessage( szErrBuf, IDS_NOT_USER_PROG, MB_OK | MB_ICONHAND );
		return FALSE;
	}

    //************************************************************************
    // 
    // The following two calls initialize the desktop so that, if we are on
    // the Winlogon desktop (secure desktop) our keyboard hook will be
    // associated with the correct window station. 
    //
    // Do not cause any windows to be created (eg. CoInitialize) prior to calling
    // these functions.  Doing so will cause them to fail and the application
    // will not appear on the Winlogon desktop.
    //
    InitMyProcessDesktopAccess();
    AssignDesktop();

    //  the only place it is ok to run as system is on the DESKTOP_WINLOGON desktop.  If that is
    //  not where we are than get out before we cause any security problems
    if (!g_WinlogonDesktop && IsSystem())
    {
	ExitMyProcessDesktopAccess();
	return FALSE;
    }

    //************************************************************************

	if(!hPrevInstance) 
	{
		wndclass.style		= CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
		wndclass.lpfnWndProc	= WndProc;
		wndclass.cbClsExtra	= 0;
		wndclass.cbWndExtra	= 0;
		wndclass.hInstance	= hInstance;
		wndclass.hIcon		= NULL;
		wndclass.hCursor		= NULL;
		wndclass.hbrBackground	= GetStockObject(WHITE_BRUSH);
		wndclass.lpszMenuName	= NULL;
		wndclass.lpszClassName	= SW_APPNAME;

		if(!RegisterClass(&wndclass))
        {
            ExitMyProcessDesktopAccess();
			return FALSE;
        }
	}

    g_hInst=hInstance;

	hWnd = CreateWindow(SW_APPNAME, SW_APPNAME,
					WS_OVERLAPPEDWINDOW,
					0,0,10,10,
					NULL, NULL, hInstance, NULL);

	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);

	while(GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
    ExitMyProcessDesktopAccess();

	return (int)msg.wParam;
}

/********************************************************\
 Main window procedure
\********************************************************/

INT_PTR APIENTRY WndProc(
	HWND	hWnd,
	UINT	uMsg,
	WPARAM	wParam,
	LPARAM	lParam)
{
	switch(uMsg)
    {
		case WM_TIMER:
		SwitchOnTimer( hWnd );
		break;

		case WM_COPYDATA:
		return SwitchOnCopyData( wParam, lParam );
		break;
		
		case WM_CREATE:
        SwitchOnCreate( hWnd );
		break;
		
		case WM_CLOSE:
		DestroyWindow( hWnd );
		break;

		case WM_QUERYENDSESSION:
		return 1L;
        break;

		case WM_DESTROY:
		PostQuitMessage(0);
        // intentional fall-thru to hit clean-up code

		case WM_ENDSESSION:
        SwitchOnEndSession( hWnd );
		break;

		default:
		return DefWindowProc(hWnd, uMsg, wParam, lParam);
        break;
	}
    return 0L;
}

void SwitchOnCreate(HWND hWnd)
{
	SetErrorMode(SEM_FAILCRITICALERRORS);	/* Bypass Windows error message */
	g_hLibrary = LoadLibrary( x_szSwitchDll );
	SetErrorMode(0);

	if (g_hLibrary)
	{
		BOOL fUseDLL = TRUE;

		GET_FUNC_PTR(XswchRegHelperWnd, 4, g_hLibrary, LPFNXSWCHREGHELPERWND, fUseDLL)
		GET_FUNC_PTR(XswchPollSwitches, 3, g_hLibrary, LPFNXSWCHPOLLSWITCHES, fUseDLL)
		GET_FUNC_PTR(XswchTimerProc, 6, g_hLibrary, LPFNXSWCHTIMERPROC, fUseDLL)
		GET_FUNC_PTR(XswchSetSwitchConfig, 5, g_hLibrary, LPFNXSWCHSETSWITCHCONFIG, fUseDLL)
		GET_FUNC_PTR(XswchEndAll, 2, g_hLibrary, LPFNXSWCHENDALL, fUseDLL)

		if (fUseDLL)
		{
            // register OSK's hWnd as switch resource owner
			(*lpfnXswchRegHelperWnd)( hWnd, g_bios_data_area );
            // send WM_TIMER messages to poll for switch activity
			SetTimer( hWnd, SWITCH_TIMER, SWITCH_TIMER_POLL_INTERVAL, NULL );
		}
	}
	else
	{
		FreeLibrary( g_hLibrary );
        g_hLibrary = 0;
		ErrMessage(NULL, IDS_MSSWCH_DLL_NOT_FOUND, 0 );
	}
}

void SwitchOnEndSession(HWND hWnd)
{
	if (g_hLibrary)
	{
		KillTimer( hWnd, SWITCH_TIMER );
		(*lpfnXswchEndAll)( );
		FreeLibrary( g_hLibrary );
        g_hLibrary = 0;
	}
}

void SwitchOnTimer(HWND hWnd)
{
	if (g_hLibrary)
	{
        (*lpfnXswchTimerProc)( hWnd );
    }
}

void SwitchOnPoll(HWND hWnd)
{
	if (g_hLibrary)
	{
		(*lpfnXswchPollSwitches)( hWnd );
    }
}

BOOL SwitchOnCopyData(WPARAM wParam, LPARAM lParam)
{
	if (g_hLibrary)
	{
        LRESULT rv = (*lpfnXswchSetSwitchConfig)( wParam, (PCOPYDATASTRUCT)lParam );
        return (rv == SWCHERR_NO_ERROR)?TRUE:FALSE;
    }
    return FALSE;
}

void ErrMessage(LPCTSTR szTitle, UINT uMsg, UINT uFlags)
{
    TCHAR szMessage[MAX_MSGLEN];
    TCHAR szTitle2[MAX_MSGLEN];
    LPCTSTR psz = szTitle;

    if (!psz)
        psz = x_szSwitchDll;
    
    LoadString(g_hInst, uMsg, szMessage, MAX_MSGLEN);

    MessageBox(GetFocus(), szMessage, psz, uFlags);
}

static HWINSTA g_origWinStation = NULL;
static HWINSTA g_userWinStation = NULL;
static BOOL  AssignDesktop()
{
    HDESK hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return FALSE;
        g_WinlogonDesktop = TRUE;
    }

    CloseDesktop(GetThreadDesktop(GetCurrentThreadId()));
    SetThreadDesktop(hdesk);
    return TRUE;
}

static BOOL InitMyProcessDesktopAccess(VOID)
{
  g_origWinStation = GetProcessWindowStation();
  g_userWinStation = OpenWindowStation(__TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
  if (!g_userWinStation)
      return FALSE;

  SetProcessWindowStation(g_userWinStation);
  return TRUE;
}

static VOID ExitMyProcessDesktopAccess(VOID)
{
  if (g_origWinStation)
    SetProcessWindowStation(g_origWinStation);

  if (g_userWinStation)
  {
    CloseWindowStation(g_userWinStation);
    g_userWinStation = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\swchlpt.c ===
/****************************************************************************
   Switch Input Library DLL - Parallel port routines

   Copyright (c) 1992-1997 Bloorview MacMillan Centre


*******************************************************************************/

#include <windows.h>
#include <tchar.h>
#include <conio.h>
#include <stdio.h>
#include <winioctl.h>
#include <msswch.h>
#include "msswchh.h"
#include "ntddpar.h"
#include "mappedfile.h"

// Internal functions
HANDLE XswcLptOpen( DWORD uiPort );
BOOL XswcLptSet(HANDLE hCom, PSWITCHCONFIG_LPT pC );

HANDLE swcLptOpen_Win( DWORD uiPort );
BOOL swcLptEnd_Win( HANDLE hsd );
DWORD swcLptStatus_Win( HANDLE hsd );
BOOL swcLptSet_Win(	HANDLE hLpt, PSWITCHCONFIG_LPT pC );

HANDLE swcLptOpen_NT( DWORD uiPort );
BOOL swcLptEnd_NT( HANDLE hsd );
DWORD swcLptStatus_NT( HANDLE hsd );
BOOL swcLptSet_NT(HANDLE hLpt, PSWITCHCONFIG_LPT pC );

void swchLptInit()
{
    int i;
    long lSize = sizeof(SWITCHCONFIG_LPT);

    g_pGlobalData->scDefaultLpt.dwReserved1 = SC_LPT_DEFAULT;
    g_pGlobalData->scDefaultLpt.dwReserved2 = SC_LPTDATA_DEFAULT;

    for (i=0;i<MAX_LPT;i++)
    {
        g_pGlobalData->rgscLpt[i].cbSize = lSize;
        g_pGlobalData->rgscLpt[i].uiDeviceType = SC_TYPE_LPT;
        g_pGlobalData->rgscLpt[i].uiDeviceNumber = i+1;
        g_pGlobalData->rgscLpt[i].dwFlags = SC_FLAG_DEFAULT;
    }
}

// Handles cannot be shared across processes.
// For NT, these are port/file handles, for '95 these are port addresses
HANDLE hLpt[MAX_LPT] = {0,0,0};


// Printer Ports
#define PRT_DATA		0x00
#define PRT_STAT		0x01
#define PRT_CTRL		0x02

// Printer Status Port
//			- inputs are straight in, switch pulls pin low = bit low
//			ERR, SEL, ACK are active low
//			PE is active high
//			NB is inverted state of BUSY line, BUSY is active high
//				- therefore, NB is sort of active low

#define PRT_TO		0x01
#define PRT_Resv1	0x02
#define PRT_IRQS	0x04	// IRQ pending
#define PRT_ERR	0x08	// pin 15 - MSI switch 3 - PRC sw2/5
#define PRT_SEL	0x10	// pin 13 - MSI switch 1 - PRC sw1/4
#define PRT_PE		0x20	// pin 12 - MSI switch 2
#define PRT_ACK	0x40	// pin 10 - switch 4 -		PRC sw3/6
#define PRT_NB		0x80	// pin 11 - switch 5 	*inverted*

// Printer Control Port

#define PRT_STRB	0x01	// pin 1
#define PRT_AUTO	0x02	// pin 14 *inverted*
#define PRT_INIT	0x04	// pin 16
#define PRT_SELI	0x08	// pin 17 *inverted*
#define PRT_IRQ	0x10	// IRQ enable - is this writable?

#define PRT_CTRL_IO 0x20	// input enable for parallel port - not possible

/****************************************************************************

   FUNCTION: XswcLptInit()

	DESCRIPTION:
		Initialize the particular hardware device structures and variables.
		Any global initialization of resources will have to be done based
		on some version of a reference counter

****************************************************************************/

BOOL XswcLptInit( HSWITCHDEVICE hsd )
	{
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );		

	g_pGlobalData->osv.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	GetVersionEx( &g_pGlobalData->osv );

   g_pGlobalData->rgscLpt[uiDeviceNumber-1].u.Lpt = g_pGlobalData->scDefaultLpt;
	hLpt[uiDeviceNumber-1] = (HANDLE) 0;
	
	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcLptEnd

	DESCRIPTION:
		Free the resources for the given hardware port.
		We assume that if CloseHandle fails, the handle is
		invalid and/or already closed, so we zero it out anyways,
		and return TRUE for success.
		Global releases will need to be based on a reference counter.

****************************************************************************/

BOOL XswcLptEnd( HANDLE hsd )
	{
	BOOL bSuccess;

	if (VER_PLATFORM_WIN32_WINDOWS == g_pGlobalData->osv.dwPlatformId) // Windows 95
		{
		bSuccess = swcLptEnd_Win( hsd );
		}
	else	// Windows NT
		{	
		bSuccess = swcLptEnd_NT( hsd );
		}

	return bSuccess;
	}


/****************************************************************************

   FUNCTION: swcLptGetConfig()

	DESCRIPTION:

****************************************************************************/

BOOL swcLptGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	
	*psc = g_pGlobalData->rgscLpt[uiDeviceNumber-1];
 	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcLptSetConfig

	DESCRIPTION:
		Activate/Deactivate the device.
		
		Four cases:
		1) hLpt = 0 and active = 0		- do nothing
		2)	hLpt = x and active = 1		- just set the configuration
		3) hLpt = 0 and active = 1		- activate and set the configuration
		4) hLpt = x and active = 0		- deactivate

		If there are no errors, TRUE is returned and ListSetConfig
		will write the configuration to the registry.
		If there is any error, FALSE is returned so the registry
		entry remains unchanged.

		Plug and Play can check the registry for SC_FLAG_ACTIVE and
		start up the device if it is set.

****************************************************************************/

BOOL XswcLptSetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	BOOL		bSuccess;
	BOOL		bJustOpened;
	UINT		uiDeviceNumber;
	HANDLE	*phLpt;
	PSWITCHCONFIG pscLpt;

	bSuccess = FALSE;
	bJustOpened = FALSE;

	// Simplify our code
	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	phLpt = &hLpt[uiDeviceNumber-1];
	pscLpt = &g_pGlobalData->rgscLpt[uiDeviceNumber-1];
	
	// Should we activate?
	if (	(0==*phLpt)
		&&	(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{ // Yes
		*phLpt = XswcLptOpen( uiDeviceNumber );
		if (*phLpt)
			{ //OK
			bSuccess = TRUE;
			bJustOpened = TRUE;
			pscLpt->dwFlags |= SC_FLAG_ACTIVE;
			pscLpt->dwFlags &= ~SC_FLAG_UNAVAILABLE;
			}
		else
			{ // Not OK
			bSuccess = FALSE;
			pscLpt->dwFlags &= ~SC_FLAG_ACTIVE;
			pscLpt->dwFlags |= SC_FLAG_UNAVAILABLE;
			}
		}

	// Should we deactivate?
	else if (	(0!=*phLpt)
		&&	!(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{
		XswcLptEnd( hsd ); // This will also zero out *phLpt
		bSuccess = TRUE;
		pscLpt->dwFlags &= ~SC_FLAG_ACTIVE;
		}
	
	// If the above steps leave a valid hLpt, let's try setting the config
	if ( 0!=*phLpt )
		{
		if (psc->dwFlags & SC_FLAG_DEFAULT)
			{
			bSuccess = XswcLptSet( *phLpt, &g_pGlobalData->scDefaultLpt );
			if (bSuccess)
				{
				pscLpt->dwFlags |= SC_FLAG_DEFAULT;
            pscLpt->u.Lpt = g_pGlobalData->scDefaultLpt;
				}
			}
		else
			{
			bSuccess = XswcLptSet( *phLpt, &(psc->u.Lpt) );
			if (bSuccess)
				{
            pscLpt->u.Lpt = psc->u.Lpt;
				}
			}
		// If we can't set config and we just opened the port, better close it up.
		if (bJustOpened && !bSuccess)
			{
			XswcLptEnd( *phLpt );
			pscLpt->dwFlags &= ~SC_FLAG_ACTIVE;
			}
		}

	return bSuccess;
	}


/****************************************************************************

   FUNCTION: XswcLptPollStatus

	DESCRIPTION:
		Must be called in the context of the helper window.
****************************************************************************/

DWORD XswcLptPollStatus( HSWITCHDEVICE	hsd )
	{
	DWORD		dwNewStatus;
	UINT		uiDeviceNumber;

	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

	if (VER_PLATFORM_WIN32_WINDOWS == g_pGlobalData->osv.dwPlatformId)
		{
		dwNewStatus = swcLptStatus_Win( hsd );
		}
	else
		{
		dwNewStatus = swcLptStatus_NT( hsd );
		}

	g_pGlobalData->rgscLpt[uiDeviceNumber-1].dwSwitches = dwNewStatus;
	return dwNewStatus;
	}


/****************************************************************************

   FUNCTION: XswcLptOpen()

	DESCRIPTION:
		Opens a file handle to the particular lpt port, based on
		the 1-based nPort.
		
		If nPort is valid, this will automatically set up GetLastError().
****************************************************************************/

HANDLE XswcLptOpen( DWORD uiPort )
{
	HANDLE hLptPort;

	hLptPort = 0;
	if (VER_PLATFORM_WIN32_WINDOWS == g_pGlobalData->osv.dwPlatformId) // Windows 95
	{
		hLptPort = swcLptOpen_Win( uiPort );
	}
	else	// Windows NT
	{
		hLptPort = swcLptOpen_NT( uiPort );
	}

	return hLptPort;
}


/****************************************************************************

   FUNCTION: XswcLptSet()

	DESCRIPTION:
		Sets the configuration of the particular nPort.
		Return FALSE (0) if an error occurs.
		GetLastError is automatically set up for us.
		
****************************************************************************/

BOOL XswcLptSet(
	HANDLE hLpt,
	PSWITCHCONFIG_LPT pC )
	{
	BOOL bSuccess;;
	if (VER_PLATFORM_WIN32_WINDOWS == g_pGlobalData->osv.dwPlatformId) // Windows 95
		{
		bSuccess = swcLptSet_Win( hLpt, pC );
		}
	else	// Windows NT
		{
		bSuccess = swcLptSet_NT( hLpt, pC );
		}
	return bSuccess;
	}


/***** Internal functions for Windows95 *****/

/****************************************************************************

   FUNCTION: swcLptOpen_Win()

	DESCRIPTION:
		Gets the base wInPort address for the given device, and
		increments by one to get the address for the "status in" port.
		
		This is cast into a HANDLE value for convenience.

		g_pGlobalData->rgbBiosDataArea has 7 entries of 2 bytes each.
		The first 4 are the com ports.
		The next 3 are the lpt ports.
****************************************************************************/

HANDLE swcLptOpen_Win( DWORD uiPort )
	{
	WORD wInPort = 0;

	switch (uiPort)
		{
		case 1:
		 	wInPort = (g_pGlobalData->rgbBiosDataArea[0x09] << 8)
				| (g_pGlobalData->rgbBiosDataArea[0x08] & 0x00FF);
			break;

		case 2:
		 	wInPort = (g_pGlobalData->rgbBiosDataArea[0x0B] << 8)
				| (g_pGlobalData->rgbBiosDataArea[0x0A] & 0x00FF);
			break;

		case 3:
		 	wInPort = (g_pGlobalData->rgbBiosDataArea[0x0D] << 8)
				| (g_pGlobalData->rgbBiosDataArea[0x0C] & 0x00FF);
			break;

		default:
			wInPort = 0;
			break;
		}

	if (wInPort)
		{
		wInPort += 1;	// Status In is base + 1;
		}
	return (HANDLE) wInPort;
	}


/****************************************************************************

   FUNCTION: swcLptEnd_Win()

	DESCRIPTION:
		Close the given lpt port.
		For Windows95, there is nothing to close, so just zero the port "handle"
		which is actually the wInPort address.
****************************************************************************/

BOOL swcLptEnd_Win( HANDLE hsd )
	{	
	BOOL bSuccess = TRUE;
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

	if (hLpt[uiDeviceNumber-1])
		{
		hLpt[uiDeviceNumber-1] = 0;
		}
	g_pGlobalData->rgscLpt[uiDeviceNumber-1].dwSwitches = 0;

	// ignore bSuccess since we can't do anything anyways.
	return TRUE;
	}


/****************************************************************************

   FUNCTION: swcLptStatus_Win()

	DESCRIPTION:

****************************************************************************/

DWORD swcLptStatus_Win( HSWITCHDEVICE hsd )
	{
	UINT		uiDeviceNumber;
	DWORD		dwStatus;
	DWORD		dwLptStatus;
	WORD		wInPort;

	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	dwStatus = 0;

    // on a risc platform _inp() will not be defined, but since we should
    // not enter this code anyways, just #ifdef it so it will compile on
    // risc.

#if defined(_M_IX86) || defined(_X86_)

	wInPort = (WORD) hLpt[uiDeviceNumber-1];
	if (wInPort)
		{
		dwLptStatus = _inp( wInPort );	

		g_pGlobalData->wCurrByteData = (WORD)_inp( (USHORT)(wInPort-1) );	// save data for dbg
		g_pGlobalData->wPrtStatus = (WORD)dwLptStatus;
		g_pGlobalData->wCtrlStatus = (WORD)_inp( (USHORT)(wInPort+1) );

		dwStatus |= (dwLptStatus & PRT_SEL) ? 0 : SWITCH_1;
		dwStatus |= (dwLptStatus & PRT_PE ) ? 0 : SWITCH_2;
		dwStatus |= (dwLptStatus & PRT_ERR) ? 0 : SWITCH_3;
		dwStatus |= (dwLptStatus & PRT_ACK) ? 0 : SWITCH_4;
		dwStatus |= (dwLptStatus & PRT_NB ) ? SWITCH_5 : 0;
		}
#endif

	return dwStatus;
	}


/****************************************************************************

   FUNCTION: swcLptSet_Win()

	DESCRIPTION:

  The original intent was to activate the data lines to use as pullups,
  and whatever control lines were requested.
  Since we have so little control over this on the NT side, we are leaving
  this for future improvement if there is demand for it.

****************************************************************************/

BOOL swcLptSet_Win(
	HANDLE hLpt,
	PSWITCHCONFIG_LPT pC )
	{
	//WORD wInPort;
	BOOL bSuccess = TRUE;

	//	wInPort = (WORD) hLpt;
	//	_outp( (USHORT)(wInPort - 1), 0xFF );				// activate pull ups

	return bSuccess;
	}


/*****	Internal functions for WindowsNT *****/

/****************************************************************************

   FUNCTION: swcLptOpen_NT()

	DESCRIPTION:
	Open a file handle to the port.

	CreateFile will return no error for non-existant, valid ports,
	so we need to check the return from a DeviceIoControl to see if the device
	is available.

 ****************************************************************************/

HANDLE swcLptOpen_NT( DWORD uiPort )
	{
	BOOL		bSuccess;
	TCHAR		szLptPort[40];
	PAR_QUERY_INFORMATION ParQueryInfo;
	DWORD		dwBytesRet;
	HANDLE		hLptPort;

	wsprintf( szLptPort, _TEXT("\\\\.\\lpt%1.1d"), uiPort );
	
	// Use overlapped i/o in order for the Write operation to be asynchronous?
	hLptPort = CreateFile(
		szLptPort,
		GENERIC_WRITE,
		0, NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL //| FILE_FLAG_OVERLAPPED,
		,NULL );

	if (INVALID_HANDLE_VALUE != hLptPort)
		{
		bSuccess = DeviceIoControl(
				hLptPort,
				IOCTL_PAR_QUERY_INFORMATION,
				NULL, 0,
				&ParQueryInfo, sizeof(PAR_QUERY_INFORMATION),
				&dwBytesRet, NULL);

		if (!bSuccess)
			{
			CloseHandle( hLptPort );
			hLptPort = 0;
			}
		}
	else
		{
		hLptPort = 0;
		}

	return hLptPort;
	}


/****************************************************************************

   FUNCTION: swcLptEnd_NT()

	DESCRIPTION:
		Close the given lpt port.
****************************************************************************/

BOOL swcLptEnd_NT( HANDLE hsd )
	{
	BOOL bSuccess = TRUE;
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

	if (hLpt[uiDeviceNumber-1])
		{
		bSuccess = CloseHandle( hLpt[uiDeviceNumber-1] );
		hLpt[uiDeviceNumber-1] = 0;
		}
	g_pGlobalData->rgscLpt[uiDeviceNumber-1].dwSwitches = 0;

	// ignore bSuccess since we can't do anything anyways.
	return TRUE;
	}


/******************************************************************************
	FUNCTION: swcLptStatus_NT()

   DESCRIPTION:

  Under construction.

  For the "standard" passive box, we can read information on four of
  the five status lines, although two of them look the same.

  To read these more explicitly we will need to write a parallel port
  "class driver".
******************************************************************************/

DWORD swcLptStatus_NT( HSWITCHDEVICE hsd )
	{
	PAR_QUERY_INFORMATION Pqi;
	DWORD		dwNewStatus = 0;	// PREFIX 113794 init to default
	BOOL		bResult;
	DWORD		dwBytesRet;
	UINT		uiDeviceNumber;
	HANDLE		*phLpt;

	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	phLpt = &hLpt[uiDeviceNumber-1];

	if (*phLpt)
		{
		bResult = DeviceIoControl( *phLpt,
						  IOCTL_PAR_QUERY_INFORMATION,
						  NULL, 0,
						  &Pqi, sizeof(PAR_QUERY_INFORMATION),
						  &dwBytesRet, NULL);

		g_pGlobalData->wPrtStatus = Pqi.Status;
		dwNewStatus = 0;

		dwNewStatus |= (Pqi.Status & PARALLEL_SELECTED) ? 0 : SWITCH_1;

		// When nothing is pulled low, NT says the power is off
		// AND sets PAPER_EMPTY to zero (active).
		// So we need to check for PAPER_EMPTY active and no power off
		if (    !(Pqi.Status & PARALLEL_PAPER_EMPTY)
			  && !(Pqi.Status & PARALLEL_POWER_OFF )
			)
			dwNewStatus |= SWITCH_2;

		dwNewStatus |= (Pqi.Status & PARALLEL_BUSY ) ? 0 : SWITCH_3;

		// These don't work because they cannot be disambiguated
		//dwNewStatus |= (Pqi.Status & PRT_ERR) ? 0 : 0;//SWITCH_3;
		//dwNewStatus |= (Pqi.Status & PRT_ACK) ? 0 : 0;//SWITCH_4;
		//dwNewStatus |= (Pqi.Status & PARALLEL_BUSY ) ? 0 : SWITCH_5;
		}

	return dwNewStatus;
	}


/* This code is unused. It is here as sample code.
void set( HSWITCHDEVICE hsd )
	{
	PAR_SET_INFORMATION Psi;
	DWORD		dwBytesRet;
	UINT		uiDeviceNumber;
	HANDLE		*phLpt;
	BOOL		bResult;
	
	uiDeviceNumber  = swcListGetDeviceNumber( hsd );
	phLpt = &hLpt[uiDeviceNumber-1];

	// Set SelectIn high and AF high

	//Psi.Init = PARALLEL_INIT;
	//Psi.Init = PARALLEL_AUTOFEED;
	//Psi.Init = PARALLEL_OFF_LINE;
	//Psi.Init = PARALLEL_NOT_CONNECTED;
	//Psi.Init = Pqi.Status;
	// For output does this set SelectIn high or just the SLCT input?
	//Psi.Init = Psi.Init & ~PARALLEL_SELECTED;
	//Psi.Init = Psi.Init & ~PARALLEL_AUTOFEED;
	bResult = DeviceIoControl( *phLpt,
               IOCTL_PAR_SET_INFORMATION,
               &Psi, sizeof(PAR_SET_INFORMATION),
               NULL, 0,
               &dwBytesRet, NULL);
	}
*/
	
/****************************************************************************

	FUNCTION: swcLptSet_NT()

	DESCRIPTION:

	The intent is to write data to the port to use the data lines as
	pullups.

	We cannot write to the port if there is no printer attached, since
	the NT driver times out waiting for a valid printer status.
	We only have access to the INIT and AF lines for setting the
	control bits.

	So for now, ignore setup. We will have to depend on the "floating"
	property of TTL outputs to keep the status lines up.

    In the future, we may try to use a parallel port "class driver" to
	make this work.

****************************************************************************/

BOOL swcLptSet_NT(
	HANDLE hLpt,
	PSWITCHCONFIG_LPT pC )
	{
	//DWORD		dwBytesWritten;
	BOOL		bSuccess = TRUE;

	/*
	if (!WriteFile( hLpt, &PullUpBuff, 2, &dwBytesWritten,
		//&Overlapped
		NULL
		))
		{
		DBGERR( TEXT("lpt> WriteFile Error"), TRUE );
		}
	else
		{
		DBGMSG( TEXT("lpt> WriteFile Success bytes:%d\n"), dwBytesWritten );
		}
	*/
	return bSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswch\swchlist.c ===
/****************************************************************************
   Switch Input Library DLL

   Copyright (c) 1992-1997 Bloorview MacMillan Centre

   SWCHLIST.C -  Dynamic List of switch devices

  Think of the specific switch device modules as objects. Then
  this module performs the "method overloading" by distributing
  the general calls to the respective specific device objects.
  Who needs C++ objects when you can just add another case to each of a
  dozen switch() statements? :-)
  We could solve this by adding a list of function pointers to the
  data structure of each object, but that adds another layer of
  complexity to create, debug, and maintain.

  In addition this module keeps the list of devices and manipulates the registry
  entries for each device.

  Assumptions:

  For now the Switch List is a static shared memory location. In the future
  it will become a dynamic shared memory mapped file, probably as a linked list.

  The registry entries are contiguously numbered, one for each switch device.
  While we are running, the position of a device in the Switch List is the
  same as its position in the Registry List.

  TODO:
  Some of the swcList functions are called by each other, but there is
  some overhead in testing for valid parameters each time. This
  should be eliminated, by creating "Unchecked" functions.
*******************************************************************************/

#include <windows.h>
#include <assert.h>
#include <tchar.h>
#include <conio.h>
#include <stdio.h>
#include <msswch.h>
#include "msswchh.h"
#include "msswcher.h"
#include "mappedfile.h"
#include "w95trace.h"

/***** Internal Prototypes *****/
BOOL swcListIsValidHsd(HSWITCHDEVICE hsd);
BOOL swcListIsValidDevice(UINT uiDeviceType, UINT uiDeviceNumber);
BOOL XswcListInitSwitchDevice(HSWITCHDEVICE hsd);
swcListRegSetValue(DWORD dwPos, PSWITCHCONFIG psc);
HKEY swcListRegCreateKey(void);
DWORD swcListFindInList(HSWITCHDEVICE	hsd);
BOOL swcListHsdInUse(HSWITCHDEVICE hsd);
DWORD swcListAddToList(HSWITCHDEVICE hsd);
BOOL swcListPostSwitches(HSWITCHDEVICE hsd, DWORD dwPrevStatus,	DWORD dwNewStatus);

void swchListInit()
{
    g_pGlobalData->rgSwitches[0] = SWITCH_1;
    g_pGlobalData->rgSwitches[1] = SWITCH_2;
    g_pGlobalData->rgSwitches[2] = SWITCH_3;
    g_pGlobalData->rgSwitches[3] = SWITCH_4;
    g_pGlobalData->rgSwitches[4] = SWITCH_5;
    g_pGlobalData->rgSwitches[5] = SWITCH_6;

    g_pGlobalData->rgSwDown[0] = SW_SWITCH1DOWN;
    g_pGlobalData->rgSwDown[1] = SW_SWITCH2DOWN;
    g_pGlobalData->rgSwDown[2] = SW_SWITCH3DOWN;
    g_pGlobalData->rgSwDown[3] = SW_SWITCH4DOWN;
    g_pGlobalData->rgSwDown[4] = SW_SWITCH5DOWN;
    g_pGlobalData->rgSwDown[5] = SW_SWITCH6DOWN;

    g_pGlobalData->rgSwUp[0] = SW_SWITCH1UP;
    g_pGlobalData->rgSwUp[1] = SW_SWITCH2UP;
    g_pGlobalData->rgSwUp[2] = SW_SWITCH3UP;
    g_pGlobalData->rgSwUp[3] = SW_SWITCH4UP;
    g_pGlobalData->rgSwUp[4] = SW_SWITCH5UP;
    g_pGlobalData->rgSwUp[5] = SW_SWITCH6UP;
}

/****************************************************************************

   FUNCTION: XswcListInit()

	DESCRIPTION:

   Called in the context of the helper window
   
   Individual devices are initialized during GetSwitchDevice,
   and are added to the switch list during SetConfig.

   Protected by "MutexConfig" when called from msswch.c.

****************************************************************************/

BOOL XswcListInit( void )
	{
	HKEY		hKey;
	DWORD		dwAllocSize;
	PBYTE		pData;
	LONG		lError;
	TCHAR		szName[20];
	DWORD		dwNameSize = 20;
	DWORD		dwDataSize;
	DWORD		ui;

	HSWITCHDEVICE	hsd;
	SWITCHCONFIG	sc;

	// When we go dynamic, use something like this:
	//g_pGlobalData->dwCurrentSize = sizeof( DWORD ) + MAX_SWITCHDEVICES * sizeof( HSWITCHDEVICE );
	// For now we are cheating:
	g_pGlobalData->dwCurrentSize = sizeof( INTERNALSWITCHLIST );

	hKey = swcListRegCreateKey();
	// In future, get maximum list size from registry.
	// For now, assume it is MAX_SWITCHDEVICES
	//RegQueryKeyInfo();

	dwAllocSize = sizeof(SWITCHCONFIG);
	pData = (PBYTE) LocalAlloc( LPTR, dwAllocSize );

	// Enumerate through the registry, configuring appropriate switches and 
	// adding them to the switch list.
	if (pData)
		{
		for (ui=0; ui<MAX_SWITCHDEVICES; ui++ )
			{
			dwDataSize = dwAllocSize;
			lError = RegEnumValue( hKey, ui,
				szName,
				&dwNameSize,
				NULL,
				NULL,
				pData,
				&dwDataSize );
			if (	(ERROR_SUCCESS == lError)
				||	(ERROR_MORE_DATA == lError)
				)
				{
				memcpy( &sc, pData, sizeof(SWITCHCONFIG) );
				// Note that this depends on the correctness of the stored
				// uiDeviceType and uiDeviceNumber. We can handle a variable
				// uiDeviceNumber, but the uiDeviceType cannot vary.
				// GetSwitchDevice also calls InitSwitchDevice
				hsd = swcListGetSwitchDevice( NULL, sc.uiDeviceType, sc.uiDeviceNumber );
				XswcListSetConfig( NULL, hsd, &sc );
				}
			else
				{
				break;
				}
			}

		LocalFree( pData );
		}

	RegCloseKey( hKey );
	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcListEnd()

	DESCRIPTION:
		Iterate through the list of switches and release all resources
		for each switch.

  Called in the context of the helper window

****************************************************************************/

BOOL XswcListEnd()
{
	PINTERNALSWITCHLIST pSwitchList;
	HSWITCHDEVICE hsd;
	BOOL		bRtn = FALSE;
	UINT		ui;

	pSwitchList = &g_pGlobalData->SwitchList;

	for (ui=0; ui<pSwitchList->dwSwitchCount; ui++ )
	{
		hsd = pSwitchList->hsd[ui];
		switch (swcListGetDeviceType( NULL, hsd ))
		{
			case SC_TYPE_COM:
				bRtn = XswcComEnd( hsd );
				break;

			case SC_TYPE_LPT:
				bRtn = XswcLptEnd( hsd );
				break;

			case SC_TYPE_JOYSTICK:
				bRtn = XswcJoyEnd( hsd );
				break;

			case SC_TYPE_KEYS:
				bRtn = XswcKeyEnd( hsd );
				break;

			default:
				bRtn = FALSE;
				break;
		}
	}

	return bRtn;
}


/****************************************************************************

   FUNCTION: swcListGetList()

	DESCRIPTION:

   Returns the list of switch device handles (hsd's).  Currently this is
	a static list with a count of the active elements in it.

   Protected by "MutexConfig" when called from msswch.c.

****************************************************************************/

BOOL swcListGetList(
	HSWITCHPORT		hSwitchPort,
	PSWITCHLIST		pSL,
	DWORD				dwSize,
	PDWORD			pdwReturnSize )
	{
	PINTERNALSWITCHLIST pSwitchList;

	pSwitchList = &g_pGlobalData->SwitchList;
	*pdwReturnSize = g_pGlobalData->dwCurrentSize;
	if (!pSL || !pSwitchList)
		return FALSE;
	if (dwSize < *pdwReturnSize)
		return FALSE;

	memcpy( pSL, pSwitchList, *pdwReturnSize );
	return TRUE;
	}


/****************************************************************************

   FUNCTION: swcListGetSwitchDevice()

	DESCRIPTION:
	   Return a handle to a switch device, given the PortType and PortNumber.
	   If the device is not in use yet, initialize it.

		The current way to create the handle is to put the PortType in the HIWORD
		and the PortNumber in the LOWORD, but that is not a documented part of the
		specification.
		In the future it may become a real handle and we will need to search
		for it or create it. Creation will require allocation of config buffers
		for each device. and will probably occur as part of the initialization.
		This dynamic hsd will have to be created and kept in a "created"
		list, separate from the "active" list, until it gets added to the active list.

****************************************************************************/

HSWITCHDEVICE swcListGetSwitchDevice(
	HSWITCHPORT		hSwitchPort,
	UINT				uiDeviceType,
	UINT				uiDeviceNumber	)
	{
	HSWITCHDEVICE	hsd;

	if (swcListIsValidDevice( uiDeviceType, uiDeviceNumber ))
		{
		hsd = (HSWITCHDEVICE)
			( MAKELPARAM( (WORD)uiDeviceNumber, (WORD)uiDeviceType ) );
		if (!swcListHsdInUse( hsd )) // It's a new one
			XswcListInitSwitchDevice( hsd );
		}
   else
      {
      hsd = 0;
		// SetLastError has been called by swcListIsValidDevice
      }

	return hsd;
	}


/****************************************************************************

   FUNCTION: swcListIsValidHsd()

	DESCRIPTION:
		Check if the hsd is valid.

		This routine is currently only for non-dynamically allocated
		devices COM, LPT, KEYS, and JOYSTICK.

		For dynamic Hsd's the validity of the Hsd will have to be checked
		from the lists of active or created hsd's.

		Sets LastError.

****************************************************************************/

BOOL swcListIsValidHsd( HSWITCHDEVICE hsd )
	{
	if (!swcListIsValidDevice( 
			(UINT)(HIWORD( (DWORD)((DWORD_PTR)hsd) )),	// type
			(UINT)(LOWORD( (DWORD)((DWORD_PTR)hsd) ))	// number
		))
		{
		XswchStoreLastError( NULL, SWCHERROR_INVALID_HSD );
		return FALSE;
		}

	return TRUE;
	}


/****************************************************************************

   FUNCTION: swcListIsValidDevice()

	DESCRIPTION:
		Check if the uiDeviceType and uiDeviceNumber are valid.
		This routine is currently only for non-dynamically allocated
		devices COM, LPT, KEYS, and JOYSTICK.

		For dynamic Hsd's the validity of the Hsd will have to be checked
		from the lists of active or created hsd's.

		Sets LastError.

****************************************************************************/

BOOL swcListIsValidDevice(
	UINT		uiDeviceType,
	UINT		uiDeviceNumber	)
	{
	BOOL		bTypeOK;
	BOOL		bNumberOK = FALSE;

	// Need to add better error checking for valid parameters here.
	switch (uiDeviceType)
		{
		case SC_TYPE_COM:
			bTypeOK = TRUE;
			if (uiDeviceNumber >= 1 && uiDeviceNumber <= 4)
				bNumberOK = TRUE;
			break;

		case SC_TYPE_LPT:
			bTypeOK = TRUE;
			if (uiDeviceNumber >= 1 && uiDeviceNumber <= 3)
				bNumberOK = TRUE;
			break;

		case SC_TYPE_JOYSTICK:
			bTypeOK = TRUE;
			if (uiDeviceNumber >= 1 && uiDeviceNumber <= 2)
				bNumberOK = TRUE;
			break;

		case SC_TYPE_KEYS:
			bTypeOK = TRUE;
         if (1 == uiDeviceNumber)
				bNumberOK = TRUE;
			break;

      default:
         bTypeOK = FALSE;
         bNumberOK = FALSE;
		}

	if (!bTypeOK)
		{
		XswchStoreLastError( NULL, SWCHERROR_INVALID_DEVICETYPE );
		return FALSE;
		}

	if (!bNumberOK)
		{
		XswchStoreLastError( NULL, SWCHERROR_INVALID_DEVICENUMBER );
		return FALSE;
		}

	return TRUE;
	}


/****************************************************************************

   FUNCTION: swcListGetDeviceType()

	DESCRIPTION:
		Return the PortType value given the handle to the switch device.
		Currently the handle is implemented with the HIWORD as the Type.
		In the future we may wish to access the SWITCHCONFIG information
		instead.
****************************************************************************/

UINT swcListGetDeviceType(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd )
	{
	if (!swcListIsValidHsd( hsd ))
		return 0;
	else
		return (UINT)(HIWORD( (DWORD)((UINT_PTR)hsd) ));
	}


/****************************************************************************

   FUNCTION: swcListGetDeviceNumber()

	DESCRIPTION:
		Return the PortNumber value, given the handle to the switch device.
		Currently the handle is implemented with the LOWORD as the Number.
		In the future we may wish to access the SWITCHCONFIG information
		instead.
****************************************************************************/

UINT swcListGetDeviceNumber(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd	)
	{
	if (!swcListIsValidHsd( hsd ))
		return 0;
	else
		return (UINT)(LOWORD( hsd ));
	}


/****************************************************************************

   FUNCTION: swcListGetConfig()

	DESCRIPTION:
		Return the configuration information for the specified device.

     Protected by "MutexConfig" when called from msswch.c.

****************************************************************************/

BOOL swcListGetConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	BOOL bRtn;

	switch (swcListGetDeviceType( hSwitchPort, hsd ))
		{
		case SC_TYPE_COM:
			bRtn = swcComGetConfig( hsd, psc );
			break;

		case SC_TYPE_LPT:
			bRtn = swcLptGetConfig( hsd, psc );
			break;

		case SC_TYPE_JOYSTICK:
			bRtn = swcJoyGetConfig( hsd, psc );
			break;

		case SC_TYPE_KEYS:
			bRtn = swcKeyGetConfig( hsd, psc );
			break;

		default:
			bRtn = FALSE;
		}
	return bRtn;
	}


/****************************************************************************

   FUNCTION: XswcListSetConfig()

	DESCRIPTION:
		Called in the context of the helper window
		Set the device configuration.
		If successful:
			If not in list, add to list
			Set registry value

		For a device to be in the registry, it must have had
		at least one successful config.

		This is also the "gatekeeper" for the uiDeviceType and uiDeviceNumber
		fields. These fields are "readonly" and cannot be changed by the user.
			
   Protected by "MutexConfig" when called from msswch.c.

****************************************************************************/

BOOL XswcListSetConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{	
	BOOL	bRtn;
	DWORD	dwRegPosition;

   // assume cbSize error checking has been done in swchSetConfig in msswch.c
   // we'll be doing "lazy copies" later, so make sure the user doesn't overwrite
   // this.
   psc->cbSize = sizeof(SWITCHCONFIG);

   // make sure the user doesn't overwrite these
	psc->uiDeviceType = swcListGetDeviceType( hSwitchPort, hsd );
	psc->uiDeviceNumber = swcListGetDeviceNumber( hSwitchPort, hsd );

	switch (	psc->uiDeviceType )
		{
		case SC_TYPE_COM:
			bRtn = XswcComSetConfig( hsd, psc );
			break;

		case SC_TYPE_LPT:
			bRtn = XswcLptSetConfig( hsd, psc );
			break;

		case SC_TYPE_JOYSTICK:
			bRtn = XswcJoySetConfig( hsd, psc );
			break;

		case SC_TYPE_KEYS:
			bRtn = XswcKeySetConfig( hsd, psc );
			break;

		default:
			bRtn = FALSE;
			break;
		}

	if (bRtn)
		{
		if (swcListHsdInUse( hsd ))
			{
			dwRegPosition = swcListFindInList( hsd );
			}
		else	 // It's a new one
			{
			dwRegPosition = swcListAddToList( hsd );
			}
		swcListRegSetValue( dwRegPosition, psc );
		swchPostConfigChanged();
		}

	return bRtn;
	}


/****************************************************************************

   FUNCTION: XswcListPollSwitches()

	DESCRIPTION:
		Polls the status of all possible switches and returns the
		bitwise OR combined status of the polled switch devices.
		Causes messages to be posted for any changed switches of 
		any device.
		Currently, we check the previous switch status of each device 
		before it is polled and changed. When any devices go
		to an interrupt driven mechanism, this will need to
		be changed.

		Must be called in the context of the helper window.

****************************************************************************/

DWORD XswcListPollSwitches( void )
	{
	PINTERNALSWITCHLIST	pSwitchList;
	SWITCHCONFIG		SwitchConfig;
	HSWITCHDEVICE		hsd;
	DWORD				dwPrevStatus;
	DWORD				dwNewStatus;
	DWORD				dwAllPolledStatus = 0;
	HANDLE				hMutex;
	UINT				ui;

    if (ScopeAccessMemory(&hMutex, SZMUTEXSWITCHLIST, INFINITE))
    {
		pSwitchList = &g_pGlobalData->SwitchList;
		memset(&SwitchConfig, 0, sizeof(SWITCHCONFIG));	// PREFIX 113795 init struct

		for (ui=0; ui<pSwitchList->dwSwitchCount; ui++ )
		{
			// For each switch device, get the old status before we poll it and
			// it changes to its new status.
			hsd = pSwitchList->hsd[ui];
			swcListGetConfig( NULL, hsd, &SwitchConfig );
			if (SC_FLAG_ACTIVE & SwitchConfig.dwFlags)
			{
				dwPrevStatus = SwitchConfig.dwSwitches;
				switch (swcListGetDeviceType( NULL, hsd ))
				{
					case SC_TYPE_COM:
					dwNewStatus = XswcComPollStatus( hsd );
					break;

					case SC_TYPE_LPT:
					dwNewStatus = XswcLptPollStatus( hsd );
					break;

					case SC_TYPE_JOYSTICK:
					dwNewStatus = XswcJoyPollStatus( hsd );
					break;

					case SC_TYPE_KEYS:
					dwNewStatus = XswcKeyPollStatus( hsd );
					break;

					default:
					dwNewStatus = 0;
					break;
				}
				swcListPostSwitches( hsd, dwPrevStatus, dwNewStatus );
				dwAllPolledStatus |= dwNewStatus;
			}
		}
        ScopeUnaccessMemory(hMutex);
    }

	return dwAllPolledStatus;
	}


/****************************************************************************

	FUNCTION: XswcListInitSwitchDevice()

	DESCRIPTION:

	Called in GetSwitchDevice to initialize a new hsd.

	Called in the context of the helper window

****************************************************************************/

BOOL XswcListInitSwitchDevice( HSWITCHDEVICE hsd )
	{
	BOOL bRtn;

	switch (swcListGetDeviceType( NULL, hsd ))
		{
		case SC_TYPE_COM:
			bRtn = XswcComInit( hsd );
			break;

		case SC_TYPE_LPT:
			bRtn = XswcLptInit( hsd );
			break;

		case SC_TYPE_JOYSTICK:
			bRtn = XswcJoyInit( hsd );
			break;

		case SC_TYPE_KEYS:
			bRtn = XswcKeyInit( hsd );
			break;

		default:
			bRtn = FALSE;
		}
	return bRtn;
	}

	
/****************************************************************************

   FUNCTION: swcListRegSetValue()

	DESCRIPTION:
		Stores the given config structure in the registry.
		Note that the structure is actually two structures,
		with a pointer from the base structure to the More Info structure.
		We simply copy both structures to the registry, concatenating them.

		The position in the registry and the position in the switch list
		are kept in sync.

  *** Note ***
		The correctness of this information is dependent on a side effect
		of the XswcListSetConfig function, which verifies the correctness
		of the read-only uiDeviceType and uiDeviceNumber fields of the config
		structure.

****************************************************************************/

swcListRegSetValue(
	DWORD		dwPos,
	PSWITCHCONFIG	psc)
	{
	HKEY		hKey;
	DWORD		dwAllocSize;
	PBYTE		pData;
	TCHAR		szValue[10];

	// Sanity checks for developers and testers
	assert( sizeof(HSWITCHDEVICE) == sizeof(DWORD) );

	dwAllocSize = sizeof(SWITCHCONFIG);
	pData = (PBYTE) LocalAlloc( LPTR, dwAllocSize );
	if (pData)
		{
		memcpy( pData, psc, sizeof(SWITCHCONFIG));		
		hKey = swcListRegCreateKey();
		// Create incrementing value names: "0000", "0001", "0002", etc.
		wsprintf( szValue, TEXT("%4.4d"), dwPos );
		if (hKey)
		{	// PREFIX 113792 dereference of NULL pointer
			RegSetValueEx( hKey, szValue, 0, REG_BINARY, pData, dwAllocSize );
			RegCloseKey( hKey );
		}
		}

	if (pData)
		LocalFree( pData );
	
	return 0;
	}


/****************************************************************************

   FUNCTION: swcListRegCreateKey()

	DESCRIPTION:
		Creates/Opens the registry key associated with the MSSWITCH entries.
		Temporary keys used to traverse the tree are closed again.
		The open key returned from this function must be closed by the
		caller.

		Currently the key opened is:
		HKEY_CURRENT_USER/Software/Microsoft/MS Switch

****************************************************************************/

HKEY swcListRegCreateKey( void )
	{
	LONG		lResult;
	DWORD		dwDisposition;
	HKEY		hKey1, hKey2, hKey3;
	
	lResult = RegCreateKeyEx( HKEY_CURRENT_USER,
		_TEXT("Software"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,
		NULL,	// security
		&hKey1,
		&dwDisposition );

	lResult = RegCreateKeyEx( hKey1,
		_TEXT("Microsoft"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,
		NULL,	// security
		&hKey2,
		&dwDisposition );

	lResult = RegCreateKeyEx( hKey2,
		_TEXT("MS Switch"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,
		NULL,	// security
		&hKey3,
		&dwDisposition );

	RegCloseKey( hKey1 );
	RegCloseKey( hKey2 );
	return hKey3;
	}


/****************************************************************************

   FUNCTION: swcListFindInList()

	DESCRIPTION:
		Find the list position of the given switchdevice.
		We assume the list position is the same in the g_pGlobalData->SwitchList
		and in the Registry List.

		Returns the zero based position or -1 if there is an error.
		If this changes, synchronize with ListHsdInList.

		Should we mutex this to synchronize with swcAddToList()?
****************************************************************************/

DWORD swcListFindInList( HSWITCHDEVICE	hsd )
	{
	PINTERNALSWITCHLIST	pSwitchList;
	DWORD		ui;

	pSwitchList = &g_pGlobalData->SwitchList;
	for (ui=0; ui < pSwitchList->dwSwitchCount; ui++)
		{
		if (hsd == pSwitchList->hsd[ui])
			break;
		}
	
	// if not found, return error
	if (ui == pSwitchList->dwSwitchCount)
		{
		ui = (DWORD)-1;
		}

	return ui;
	}


/****************************************************************************

	FUNCTION: swcListHsdInUse()

	DESCRIPTION:
	Return TRUE if the Hsd is one of the devices that is already initialized
	and in use.
****************************************************************************/

BOOL swcListHsdInUse( HSWITCHDEVICE hsd )
	{
	return (DWORD)-1 != swcListFindInList( hsd );
	}


/****************************************************************************

   FUNCTION: swcListAddToList()

	DESCRIPTION:
		Adds the switch device to our list,
		returning its new position in the list.
		This assumes that swcListFindInList has been called first
		or some other check has been made to make sure the device is not
		already there.		

****************************************************************************/

DWORD swcListAddToList( HSWITCHDEVICE hsd )
{
	PINTERNALSWITCHLIST  pSwitchList;
	HANDLE	hMutex;
    DWORD dwRv = 0;

    if (ScopeAccessMemory(&hMutex, SZMUTEXSWITCHLIST, INFINITE))
    {
		// When we go dynamic:
		// pSwitchList = MapViewOfFileEx();
		// For now, cheat:
		pSwitchList = &g_pGlobalData->SwitchList;

		pSwitchList->hsd[pSwitchList->dwSwitchCount] = hsd;
		pSwitchList->dwSwitchCount++;
        dwRv = pSwitchList->dwSwitchCount - 1;

        ScopeUnaccessMemory(hMutex);
    }

	return dwRv; 
}


/****************************************************************************

   FUNCTION: swcListPostSwitches()

	DESCRIPTION:

		For each switch up or down that has occured, request that a message
		gets posted to all apps which requested messages.

****************************************************************************/

BOOL swcListPostSwitches(HSWITCHDEVICE hsd, DWORD dwPrevStatus, DWORD dwNewStatus)
{
	int		i;
	DWORD	dwBit;                              // look at one bit at a time
	DWORD	dwChg = dwPrevStatus ^ dwNewStatus; // Isolate changes

	for (i=0; i<NUM_SWITCHES; i++)		// For each bit, check for a change
	{
		dwBit = dwChg & g_pGlobalData->rgSwitches[i];
		if (dwBit)                       // This switch has changed
		{
			if (!(dwBit & dwNewStatus))	// ... to "up"
			{
				swchPostSwitches( hsd, g_pGlobalData->rgSwUp[i] );
			}
		}
	}

	for (i=0; i<NUM_SWITCHES; i++)	// For each bit, check for a change
	{
		dwBit = dwChg & g_pGlobalData->rgSwitches[i];
		if (dwBit)                    // This switch has changed
		{
			if (dwBit & dwNewStatus)	// ... to "down"
			{
				swchPostSwitches( hsd, g_pGlobalData->rgSwDown[i] );
			}
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswchx\version.h ===
s// MAGNIFY.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "msswchx\0"
#define VER_INTERNALNAME_STR        "msswchx\0"
#define VER_ORIGINALFILENAME_STR    "msswch.exe\0"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\msswch\msswchy\msswchy.c ===
/****************************************************************************
   Hidden 16-bit window for
   Switch Input Library DLL

   Copyright (c) 1992-1997 Bloorview MacMillan Centre
   
   This mini-application reports the 16-bit bios table address information
   back to the 32-bit world of the Switch Input Library
****************************************************************************/

//#define DEBUGMSG
/**************************************************************** Headers */

#include <windows.h>
#include <dde.h>
#include <memory.h>

#define APIENTRY FAR PASCAL

long APIENTRY WndProc( HWND hWnd, UINT uMsg, WPARAM uParam, LPARAM lParam );
   
char  szAppName[]       = "MSSWCHY";

int   nShow;      // if Debug this will be SHOW
BYTE  bios_data_area[16];
HANDLE   hData;
DDEDATA FAR *pdata;

extern WORD _0040h;

#ifdef DEBUGMSG
char  szDbgMsg[80];
#endif

/********************************************* Windows Callback Functions */

   /********************************************************\
    Windows initialization
   \********************************************************/

int PASCAL WinMain(hInstance, hPrevInstance, lpszCmdLine, nCmdShow)
   HANDLE   hInstance, hPrevInstance;
   LPSTR    lpszCmdLine;
   int      nCmdShow;
   {
   HWND     hWnd;
   MSG      msg;
   WNDCLASS wndclass;


   // Look for magic word

   if (
         ( lpszCmdLine[0] != 'S' )
      || ( lpszCmdLine[1] != 'W' )
      || ( lpszCmdLine[2] != 'C' )
      || ( lpszCmdLine[3] != 'H' )
      )
      {
      MessageBox( GetFocus(), "This is not a user program", "MSSWCHY",
         MB_OK | MB_ICONHAND );
      return FALSE;
      }

   if(!hPrevInstance) 
      {
      wndclass.style    = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
      wndclass.lpfnWndProc = WndProc;
      wndclass.cbClsExtra  = 0;
      wndclass.cbWndExtra  = 0;
      wndclass.hInstance   = hInstance;
      wndclass.hIcon    = NULL;
      wndclass.hCursor     = NULL;
      wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
      wndclass.lpszMenuName   = NULL;
      wndclass.lpszClassName  = szAppName;

      if(!RegisterClass(&wndclass))
         return FALSE;
      }

   hWnd = CreateWindow(szAppName, szAppName,
               WS_OVERLAPPEDWINDOW,
               0,0,10,10,
               NULL, NULL, hInstance, NULL);

   nShow = nCmdShow;
   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   while(GetMessage(&msg, NULL, 0, 0))
      {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
      }

   return msg.wParam;
   }

   /********************************************************\
    Main window procedure
   \********************************************************/

long APIENTRY WndProc(HWND hWnd, UINT uMsg, WPARAM uParam, LPARAM lParam)
   {
   #ifdef xDEBUGMSG
   sprintf( szDbgMsg, "MP Msg: %X %X %lX\r\n", iMessage, wParam, lParam );
   OutputDebugString( szDbgMsg );
   #endif

   switch(uMsg)
      {
      case WM_CREATE:
         {
         HWND hSwchx;
         
         hSwchx = FindWindow( "MSSWCHX", NULL );
         _fmemcpy( bios_data_area,
          (LPSTR)(MAKELONG(0,&_0040h)),
           sizeof( bios_data_area ) );
         
         hData = GlobalAlloc( GMEM_DDESHARE, sizeof( DDEDATA ) + sizeof( bios_data_area ));
         if (hData)
            {
            pdata = (DDEDATA FAR *) GlobalLock( hData );
            pdata->fResponse =  TRUE;
            pdata->fRelease = FALSE;
            pdata->fAckReq = FALSE;
            pdata->cfFormat = CF_OWNERDISPLAY;
            _fmemcpy( pdata->Value, bios_data_area, sizeof( bios_data_area ) );
            GlobalUnlock( hData );
            
            PostMessage( hSwchx, WM_DDE_DATA, hWnd, MAKELONG( hData, 0 ));
            }
         }
         break;
         
      case WM_DDE_ACK:
         {
         if (hData)
            GlobalFree( hData );
         if (nShow != SW_SHOW)
            PostMessage( hWnd, WM_CLOSE, 0, 0L );
         }
            break;
            
      case WM_PAINT: // should only happen in debug mode
         {
         PAINTSTRUCT ps;
         char  szOutBuff[100];
         int i;

         BeginPaint( hWnd, &ps );
         i = 0;
         wsprintf( szOutBuff, "Bios Data Area" );
         TextOut( ps.hdc,0,10 * i,szOutBuff,lstrlen(szOutBuff));
      
         for ( i=0;i<8;i++ )
            {// note reversed pairs
            wsprintf( szOutBuff, "Port%d: %02X %02X", i,
             bios_data_area[2*i+1], bios_data_area[2*i] );
            TextOut( ps.hdc,0,30 + 30 * i,szOutBuff,lstrlen(szOutBuff));
            }
         EndPaint( hWnd, &ps );
         }
         break;
      
      case WM_CLOSE:
      case WM_QUERYENDSESSION:

         if (uMsg == WM_QUERYENDSESSION)
            return 1L;
         else
            DestroyWindow( hWnd );

         break;

      /* Window has just been closed   */
      case WM_DESTROY:

         PostQuitMessage(0);

      case WM_ENDSESSION:
         if (!uParam && (uMsg == WM_ENDSESSION))      /* Windows is not terminating */
            break;
         /* else continue */

         break;

      default:
         return DefWindowProc(hWnd, uMsg, uParam, lParam);
      }
   return 0L;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\credits.c ===
// Credit.c
#define STRICT

#include <windows.h>
#include "Init_End.h"
#include "resource.h"

#include "credits.h"


/***************************************************/
/* Startup procedure for modal dialog box */
/***************************************************/

INT_PTR CreditsDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) 
{
    INT_PTR  ReturnValue;
    TCHAR    str[256]=TEXT("");
    TCHAR    title[256]=TEXT("");

    ReturnValue = DialogBox(hInst,  MAKEINTRESOURCE(IDD_CREDITS), 
                            hWnd, CreditsDlgProc);

    if (ReturnValue==-1)
    {
        LoadString(hInst, IDS_CANNOTCREATEDLG, &str[0], 256);
        LoadString(hInst, IDS_CREDITSBOX, &title[0], 256);
        MessageBox(hWnd, str, title, MB_OK|MB_ICONHAND);
    }
    return ReturnValue;
}


/*****************************************************************************/
/* Modal dialog box procedure */
/*****************************************************************************/

INT_PTR CALLBACK CreditsDlgProc(HWND hDlg, UINT message, 
                                WPARAM wParam, LPARAM lParam)
{	
    switch(message)
    {
        case WM_INITDIALOG:
            return CreditsDlgDefault(hDlg,message,wParam,lParam);
            break;


        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                    if (!CreditsDlgDefault(hDlg,message,wParam,lParam))
                    { 	
                        EndDialog(hDlg,IDOK);
				    }
					  
                    break;

				case IDCANCEL:
						EndDialog(hDlg,IDCANCEL);
					 break; 


				default:
					  return CreditsDlgDefault(hDlg,message,wParam,lParam);
					  break;
					 }
		  default:
		  return CreditsDlgDefault(hDlg,message,wParam,lParam);
		  break;
		}
	 return TRUE;/* Did process the message */
}


/***************************************************************/

BOOL CreditsDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{	
		
	 switch(message)
		  {
		  case WM_INITDIALOG:

		  return TRUE;       /* TRUE means Windows will process WM_INITDIALOG */
		  break;

		  case WM_COMMAND:
				switch(wParam)
					 {

				default:
					  return FALSE; /* Didn't process the message */
					  break;
					 }
				break;

		  case WM_DRAWITEM:      /* Draw graphic button(s)     */
				{
				LPDRAWITEMSTRUCT lpDrawItem;

				lpDrawItem = (LPDRAWITEMSTRUCT)lParam;
				if (lpDrawItem->CtlType!=ODT_BUTTON)
					 return FALSE;
				if (lpDrawItem->itemAction!=ODA_DRAWENTIRE)
					 return FALSE;
				switch(lpDrawItem->CtlID)
					 {

				default:
					  return FALSE; /* Didn't process the message */
					  break;
					 }
				}
				break;

		  default:
				return FALSE; /* Didn't process the message */
				break;
		  }
	 return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\about.c ===
// about.c
#define STRICT

#include <windows.h>
#include <shellapi.h>
#include <commctrl.h>

#include "Init_End.h"
#include "resource.h"

#include "scan.h"
#include "credits.h"
#include "about.h"
#include "door.h"
#include "kbmain.h"

extern DWORD GetDesktop();
extern BOOL g_fShowWarningAgain;

extern KBPREFINFO  *kbPref;

/**************************************************************************/

/* Startup procedure for modal dialog box */

INT_PTR AboutDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	INT_PTR ReturnValue;
	TCHAR   str[256];
	TCHAR   title[256];

    ReturnValue = DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUT), NULL,
                            AboutDlgProc);

	 if (ReturnValue==-1)
	 {	
        LoadString(hInst, IDS_CANNOTCREATEDLG, &str[0], 256);
        LoadString(hInst, IDS_ABOUTBOX, &title[0], 256);
		MessageBox(hWnd, str, title, MB_OK|MB_ICONHAND);
	 }
	 return ReturnValue;
}


/*****************************************************************************/

/* Modal dialog box procedure */

INT_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT message, 
                              WPARAM wParam, LPARAM lParam) 
{	
    switch(message)
    {
        case WM_INITDIALOG:
        {
			RelocateDialog(hDlg);
            KillScanTimer(TRUE);  //kill scanning
            EnableWindow(GetDlgItem(hDlg, IDC_ENABLEWEB2), (OSKRunSecure())?FALSE:TRUE);
        }
        return AboutDlgDefault(hDlg,message,wParam,lParam);
        break;

		case WM_NOTIFY:
		{
			// Web address linked: Anil
			INT idCtl		= (INT)wParam;
			LPNMHDR pnmh	= (LPNMHDR)lParam;
			switch ( pnmh->code)
			{
				case NM_RETURN:
				case NM_CLICK:
				if ( (idCtl == IDC_ENABLEWEB2) && !OSKRunSecure())
				{
					TCHAR webAddr[256];
					LoadString(hInst, IDS_ENABLEWEB, webAddr, 256);
					ShellExecute(hDlg, NULL, webAddr, NULL, NULL, SW_SHOW); 
				}
				break;
			}
		}
		break;

        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                    if (!AboutDlgDefault(hDlg,message,wParam,lParam))
                    {
                         EndDialog(hDlg,IDOK);
                    }
					  
                break;

				case IDCANCEL:
						EndDialog(hDlg,IDCANCEL);
					 break; 

				default:
					  return AboutDlgDefault(hDlg,message,wParam,lParam);
					  break;
					 }
		  default:
		  return AboutDlgDefault(hDlg,message,wParam,lParam);
		  break;
		}
	 return TRUE;/* Did process the message */
}


/***************************************************************/

BOOL AboutDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{	
		
	 switch(message)
		  {
		  case WM_INITDIALOG:

		  return TRUE;       /* TRUE means Windows will process WM_INITDIALOG */
		  break;

		  default:
				return FALSE; /* Didn't process the message */
				break;
		  }
	 return TRUE;
}


/*****************************************************************************/


/**************************************************************************/
// Initial Warning Message Management
/**************************************************************************/

/* Startup procedure for modal dialog box */

INT_PTR WarningMsgDlgFunc(HWND hWnd)
{
	INT_PTR ReturnValue;
	TCHAR   str[256];
	TCHAR   title[256];

    ReturnValue = DialogBox(hInst, MAKEINTRESOURCE(IDD_WARNING_MSG), NULL,
                            WarningMsgDlgProc);

	 if (ReturnValue==-1)
	 {	
        LoadString(hInst, IDS_CANNOTCREATEDLG, &str[0], 256);
        LoadString(hInst, IDS_WARNING_MSG, &title[0], 256);
		MessageBox(hWnd, str, title, MB_OK|MB_ICONHAND);
	 }

//	 hWarningIcon = LoadIcon(NULL, IDI_WARNING);
	 return ReturnValue;
}


/*****************************************************************************/

/* Modal dialog box procedure */

INT_PTR CALLBACK WarningMsgDlgProc(HWND hDlg, UINT message, 
                              WPARAM wParam, LPARAM lParam) 
{	
    switch(message)
    {
		case WM_INITDIALOG:
			RelocateDialog(hDlg);
			KillScanTimer(TRUE);  //kill scanning
            EnableWindow(GetDlgItem(hDlg, IDC_ENABLEWEB), (OSKRunSecure())?FALSE:TRUE);
			return WarningMsgDlgDefault(hDlg,message,wParam,lParam);
			break;
			
		case WM_NOTIFY:
		{
			INT idCtl		= (INT)wParam;
			LPNMHDR pnmh	= (LPNMHDR)lParam;
			switch ( pnmh->code)
			{
				case NM_RETURN:
				case NM_CLICK:
				if ( (idCtl == IDC_ENABLEWEB) && !OSKRunSecure())
				{
					TCHAR webAddr[256];
					LoadString(hInst, IDS_ENABLEWEB, webAddr, 256);
					ShellExecute(hDlg, NULL, webAddr, NULL, NULL, SW_SHOW); 
				}
				break;
			}
		}
		break;

		case WM_CLOSE:
			EndDialog(hDlg,IDOK);
			break;
			
		case WM_COMMAND:
			switch(wParam)
			{
				case IDOK:
					if (!WarningMsgDlgDefault(hDlg,message,wParam,lParam))
					{
						EndDialog(hDlg,IDOK);
					}
					break;
				default:
					return WarningMsgDlgDefault(hDlg,message,wParam,lParam);
					break;
			}
		default:
			return WarningMsgDlgDefault(hDlg,message,wParam,lParam);
			break;
	}
	return TRUE;/* Did process the message */
}


/***************************************************************/
BOOL WarningMsgDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{	
		
	 switch(message)
		  {
		  case WM_INITDIALOG:

		  return TRUE;       /* TRUE means Windows will process WM_INITDIALOG */
		  break;

		  case WM_COMMAND:
				switch(wParam)
				{
					case IDOK:
					{
						LRESULT lRes = SendMessage(GetDlgItem(hDlg, IDC_SHOW_AGAIN), BM_GETCHECK, 0, 0);

						if (lRes == BST_CHECKED)
						{
							g_fShowWarningAgain = FALSE;
						}
						else
						{
							g_fShowWarningAgain = TRUE;
						}

						kbPref->fShowWarningAgain = g_fShowWarningAgain;

						return FALSE;
					}
					break;
				
					case IDCANCEL:
						EndDialog(hDlg,IDCANCEL);
					 break; 

					default:
					  return FALSE; /* Didn't process the message */
					  break;
				}
				break;

		  default:
				return FALSE; /* Didn't process the message */
				break;
		  }
	 return TRUE;
}


/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\dgadvsca.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// KBMAIN.C 
// Additions, Bug Fixes 1999 Anil Kumar
//  

#define STRICT


#include <windows.h>
#include <malloc.h>

#include "kbmain.h"
#include "Init_End.h"
#include "door.h"
#include "resource.h"


//*****************************************************************************
//    Functions prototype
//*****************************************************************************
#include "sdgutil.h"
#include "dgadvsca.h"
#include "Init_End.h"

#define MAX_KEY_TEXT		8

extern DWORD GetDesktop();

DWORD	g_rgHelpIds[] ={
		IDOK,	        70525,
		IDCANCEL,	    70530,
		CHK_KEY,        70545,
        COMBO_KB_KEY,   70545,
        CHK_PORT,       70540
    };

/*****************************************************************************/

INT_PTR AdvScanDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	INT_PTR ReturnValue;

    ReturnValue = DialogBox(hInst,  MAKEINTRESOURCE(IDD_ADVANCE_SCANNING), 
                            hWnd, AdvScanDlgProc);

    if (ReturnValue==-1)
	{	
        SendErrorMessage(IDS_CANNOTCREATEDLG);
	}
	return ReturnValue;
}

/*****************************************************************************/
INT_PTR CALLBACK AdvScanDlgProc(HWND hDlg, UINT message, 
                                WPARAM wParam, LPARAM lParam) 
{	
	HWND	hComboBox;
	int		nSel;
	static  BOOL bKBKey;
	static  UINT uKBKey;
	static  BOOL bPort;
    // F1 key is always for help and F10 for menu , So donot 
    // use these for scanning. a-anilk
/*	TCHAR	sKBKey[11][6]={ TEXT("Space"), TEXT("Enter"), 
                            TEXT("F2"),  TEXT("F3"), TEXT("F4"),
                            TEXT("F5"),    TEXT("F6"),  TEXT("F7"), TEXT("F8"),
                            TEXT("F9"),  TEXT("F12") };
*/
	LPTSTR sKBKey[11];
	UINT    ary_KBKey[11]={VK_SPACE, VK_RETURN, 
                           VK_F2, VK_F3, VK_F4, VK_F5, VK_F6, 
		                   VK_F7, VK_F8, VK_F9, VK_F12};
	int i;
	
	int nCopiedChars, nTextSpace, nOldCopied;

	BOOL bRetValue = TRUE;


	//v-mjgran: Init sKBKey;
	for (i=0; i<11; i++)
	{
		nTextSpace = MAX_KEY_TEXT;

		sKBKey[i] = (LPTSTR) malloc (nTextSpace*sizeof(TCHAR));

		nCopiedChars = LoadString(hInst, IDS_SPACE_KEY+i, sKBKey[i], nTextSpace);
		nOldCopied = 0;
		while (nCopiedChars == (nTextSpace-1) && nOldCopied != nCopiedChars)
		{
			// To allow more space in diferent languages
			free(sKBKey[i]);
			nTextSpace = nTextSpace << 1;		//duplicate the available space
			sKBKey[i] = (LPTSTR) malloc (nTextSpace*sizeof(TCHAR));
			nOldCopied = nCopiedChars;
			nCopiedChars = LoadString(hInst, IDS_SPACE_KEY+i, sKBKey[i], nTextSpace);
		}
	}


	switch(message)
		{
		case WM_INITDIALOG:

			CheckDlgButton(hDlg, CHK_PORT,
							((bPort = kbPref->bPort) ? BST_CHECKED : \
													   BST_UNCHECKED));
			
			CheckDlgButton(hDlg, CHK_KEY,
                           ((bKBKey = kbPref->bKBKey) ? BST_CHECKED : \
                                                        BST_UNCHECKED));

			EnableWindow(GetDlgItem(hDlg, COMBO_KB_KEY), bKBKey ? TRUE : FALSE);
			
			//Set the Switch key from the setting
			uKBKey = kbPref->uKBKey;

			//Combo box
			hComboBox = GetDlgItem(hDlg, COMBO_KB_KEY);

            // Number of choices = 11 :a-anilk
			for(i=0; i < 11; i++)
            {
				SendMessage(hComboBox, CB_ADDSTRING, 0, (LPARAM)sKBKey[i]);
            }
			
			for(i=0; i < 11; i++)
            {
				if(uKBKey == ary_KBKey[i])
				{	
                    //set which choice be in the combo box at starting
                    SendMessage(hComboBox, CB_SETCURSEL, i, 0L);     
					break;
				}
            }

			//return TRUE;
			bRetValue = TRUE;
		break;

		case WM_COMMAND:
				switch(LOWORD(wParam))
					{
				case IDOK:
					
					//Switch Key
					if((bKBKey != kbPref->bKBKey) || (uKBKey != kbPref->uKBKey))
					{	
						//Save it to the setting record
						kbPref->bKBKey = bKBKey;
						kbPref->uKBKey = uKBKey;
						
						if(bKBKey)   //Config the scan key
							ConfigSwitchKey(kbPref->uKBKey, TRUE);
						else         //disable the scan key
							ConfigSwitchKey(0, FALSE);
					}

					//Switch Port
					if(bPort != kbPref->bPort)
					{
						kbPref->bPort = bPort;
						
						//Config the port (On or OFF)
						ConfigPort(bPort);
					}


					EndDialog(hDlg,IDOK);
				break;

				case IDCANCEL:
					EndDialog(hDlg,IDCANCEL);
				break;

				case CHK_PORT:
					bPort = !bPort;
				break;

				case CHK_KEY:
					bKBKey = !bKBKey;

					EnableWindow(GetDlgItem(hDlg, COMBO_KB_KEY), 
                                 (bKBKey ? TRUE : FALSE));
	
				break;

				case COMBO_KB_KEY:
					nSel= (int)SendMessage(GetDlgItem(hDlg, COMBO_KB_KEY), 
                                           CB_GETCURSEL, 0, 0L);
					
					uKBKey = ary_KBKey[nSel];

				break;

				default:
					//return FALSE;
					bRetValue = FALSE;
				break;
					}
		break;
		
        case WM_HELP:
			if ( OSKRunSecure() )
			{
				return FALSE;
			}

            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, __TEXT("osk.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_rgHelpIds);
            //return(TRUE);
			bRetValue = TRUE;
        
        case WM_CONTEXTMENU:  // right mouse click
			if ( OSKRunSecure() )
			{
				return FALSE;
			}

            WinHelp((HWND) wParam, __TEXT("osk.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_rgHelpIds);
            break;

		default:
			//return FALSE;
			bRetValue = FALSE;
		break;
		}		


	for (i=0; i<11; i++)
		free(sKBKey[i]);

	//return TRUE;
	return bRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\kbfunc.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// KBFUNC.C    // Function library to KBMAIN.C
// File modified to paint bitmaps instead of icons : a-anilk :02-16-99
// Last updated Maria Jose and Anil Kumar
// 
#define STRICT

#include <windows.h>
#include <commdlg.h>
#include "kbmain.h"
#include "kbus.h"
#include "kbfunc.h"
#include "ms32dll.h"
#include "resource.h"
#include "dgsett.h"
#include <malloc.h>
#include <stdlib.h>
#include "w95trace.h"


// local functions
int GetKeyLabel(UINT vk, UINT sc, LPBYTE achKbdState, LPTSTR pszBuf, int cchBuf, HKL hkl);
LPTSTR SetKeyText(UINT vk, UINT sc, LPBYTE achKbdState, HKL hkl, LPTSTR pszDefLabel, int *piType);
LPTSTR CopyDefKey(LPTSTR pszDefLabel);

#define RGBBLACK     RGB(0,0,0)
#define RGBWHITE     RGB(255,255,255)
#define RGBBACK     RGB(107,107,107)
#define DSPDxax   0x00E20746L

#define REDRAW			1
#define NREDRAW			2

static BOOL s_fLastDown = FALSE;
int g_cAltGrKeys = 0;	// non-zero if there are ALTGR keys to show

extern KBkeyRec	KBkey[] =
	{
	//0
    {TEXT(""),TEXT(""),	TEXT(""),TEXT(""),
     NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,BOTH},  //DUMMY

//1
	{TEXT("esc"),TEXT("esc"),TEXT("{esc}"),TEXT("{esc}"),
     NO_NAME, 1,1,8,8, TRUE,  KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x01,0x00,0x00,0x00}},

//2
    {TEXT("F1"), TEXT("F1"), TEXT("{f1}"), TEXT("{f1}"),
     NO_NAME, 1,19, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3B,0x00,0x00,0x00}},

//3
    {TEXT("F2"), TEXT("F2"), TEXT("{f2}"), TEXT("{f2}"),
     NO_NAME, 1,28, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3C,0x00,0x00,0x00}},

//4
    {TEXT("F3"), TEXT("F3"), TEXT("{f3}"), TEXT("{f3}"),
     NO_NAME, 1,37, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3D,0x00,0x00,0x00}},

//5
    {TEXT("F4"), TEXT("F4"), TEXT("{f4}"), TEXT("{f4}"),
     NO_NAME, 1,46, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3E,0x00,0x00,0x00}},

//6
    {TEXT("F5"), TEXT("F5"), TEXT("{f5}"), TEXT("{f5}"),
     NO_NAME, 1,60, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3F,0x00,0x00,0x00}},

//7
    {TEXT("F6"), TEXT("F6"), TEXT("{f6}"), TEXT("{f6}"),
     NO_NAME, 1,69, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x40,0x00,0x00,0x00}},

//8
    {TEXT("F7"), TEXT("F7"), TEXT("{f7}"), TEXT("{f7}"),
     NO_NAME, 1,78, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x41,0x00,0x00,0x00}},

//9
    {TEXT("F8"), TEXT("F8"), TEXT("{f8}"), TEXT("{f8}"),
     NO_NAME, 1,87, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x42,0x00,0x00,0x00}},

//10
    {TEXT("F9"), TEXT("F9"), TEXT("{f9}"), TEXT("{f9}"),
     NO_NAME, 1,101, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x43,0x00,0x00,0x00}},

//11
    {TEXT("F10"),TEXT("F10"), TEXT("{f10}"),TEXT("{f10}"),
     NO_NAME,  1,110, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x44,0x00,0x00,0x00}},

//12
    {TEXT("F11"),TEXT("F11"), TEXT("{f11}"),TEXT("{f11}"),
     NO_NAME,  1,119, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x57,0x00,0x00,0x00}},

//13
    {TEXT("F12"),TEXT("F12"), TEXT("{f12}"),TEXT("{f12}"),
     NO_NAME,1,128,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x58,0x00,0x00,0x00}},

//14
    {TEXT("psc"), TEXT("psc"),TEXT("{PRTSC}"),TEXT("{PRTSC}"),
     KB_PSC, 1,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x2A,0xE0,0x37}},

//15
    {TEXT("slk"), TEXT("slk"),TEXT("{SCROLLOCK}"),TEXT("{SCROLLOCK}"),
     KB_SCROLL,1,147,8, 8, TRUE, SCROLLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x46,0x00,0x00,0x00}},

//16
	{TEXT("brk"), TEXT("pau"), TEXT("{BREAK}"), TEXT("{^s}"),
     NO_NAME,1,156,8,8, TRUE, KNORMAL_TYPE, LARGE, REDRAW, 2,
     {0xE1,0x1D,0x45,0x00}},

//17
    {TEXT("`"), TEXT("~"), TEXT("`"), TEXT("{~}"),
     NO_NAME, 12,1,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x29,0x00,0x00,0x00}},

//18
    {TEXT("1"), TEXT("!"), TEXT("1"), TEXT("!"),
     NO_NAME, 12,10,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x02,0x00,0x00,0x00}},

//19
	{TEXT("2"),	TEXT("@"), TEXT("2"), TEXT("@"),
     NO_NAME, 12,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x03,0x00,0x00,0x00}},

//20
    {TEXT("3"), TEXT("#"), TEXT("3"), TEXT("#"),
     NO_NAME,12,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x04,0x00,0x00,0x00}},

//21
	{TEXT("4"),		TEXT("$"),		TEXT("4"),		TEXT("$"),		NO_NAME,	 12,	  37,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x05,0x00,0x00,0x00}},
	
//22	
	{TEXT("5"), 	TEXT("%"), 		TEXT("5"),		TEXT("{%}"),	NO_NAME,	 12,	  46,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x06,0x00,0x00,0x00}},
	
//23	
	{TEXT("6"),		TEXT("^"),		TEXT("6"),		TEXT("{^}"),	NO_NAME,	 12,	  55,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x07,0x00,0x00,0x00}},
	
//24
	{TEXT("7"),		TEXT("&"),		TEXT("7"),		TEXT("&"),		NO_NAME,	 12,	  64,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x08,0x00,0x00,0x00}},
	
//25
	{TEXT("8"), 	TEXT("*"), 		TEXT("8"),		TEXT("*"),		NO_NAME,	 12,	  73,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x09,0x00,0x00,0x00}},
	
//26
	{TEXT("9"),		TEXT("("),		TEXT("9"),		TEXT("("),		NO_NAME,	 12,	  82,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0A,0x00,0x00,0x00}},
	
//27
	{TEXT("0"),		TEXT(")"),		TEXT("0"),		TEXT(")"),		NO_NAME,	 12,	  91,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0B,0x00,0x00,0x00}},
	
//28
	{TEXT("-"), 	TEXT("_"), 		TEXT("-"),		TEXT("_"),		NO_NAME,	 12,	 100,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0C,0x00,0x00,0x00}},
	
//29
	{TEXT("="),		TEXT("+"),		TEXT("="),		TEXT("{+}"),	NO_NAME,	 12,	 109,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0D,0x00,0x00,0x00}},

//30
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW},  //DUMMY

//31
	{TEXT("bksp"),TEXT("bksp"),TEXT("{BS}"),TEXT("{BS}"),
     NO_NAME,12, 118,8,18,  TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0E,0x00,0x00,0x00}},

//32
	{TEXT("ins"),TEXT("ins"),TEXT("{INSERT}"),TEXT("{INSERT}"), NO_NAME, 12,138, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x52,0x00,0x00}},
	
//33	
	{TEXT("hm"), TEXT("hm"), TEXT("{HOME}"), TEXT("{HOME}"), 	NO_NAME, 12,147, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x47,0x00,0x00}},

//34
	{TEXT("pup"),TEXT("pup"),TEXT("{PGUP}"),TEXT("{PGUP}"),		NO_NAME, 12,156, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x49,0x00,0x00}},

//35
	{TEXT("nlk"),TEXT("nlk"),TEXT("{NUMLOCK}"),TEXT("{NUMLOCK}"),
    KB_NUMLOCK, 12,166,8,8, FALSE, NUMLOCK_TYPE, LARGE, NREDRAW, 2, 
    {0x45,0x00,0x00,0x00}},
	
//36
	{TEXT("/"),	TEXT("/"),	TEXT("/"),	TEXT("/"),	NO_NAME, 12, 175,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x35,0x00,0x00}},
	
//37
	{TEXT("*"),	TEXT("*"),	TEXT("*"),	TEXT("*"),	NO_NAME, 12, 184,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x37,0x00,0x00}},
	
//38	
	{TEXT("-"),	TEXT("-"),	TEXT("-"),	TEXT("-"),	NO_NAME, 12, 193,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1, {0x4A,0x00,0x00,0x00}},

//39
	{TEXT("tab"),	TEXT("tab"),	TEXT("{TAB}"),TEXT("{TAB}"),NO_NAME, 21,   1,  8,	13, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2, {0x0F,0x00,0x00,0x00}},

//40
	{TEXT("q"),	TEXT("Q"),	TEXT("q"),	TEXT("+q"),	NO_NAME, 21,  15,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x10,0x00,0x00,0x00}},
	
//41
	{TEXT("w"),	TEXT("W"),	TEXT("w"),	TEXT("+w"),	NO_NAME, 21,  24,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x11,0x00,0x00,0x00}},
	
//42
	{TEXT("e"),	TEXT("E"),	TEXT("e"),	TEXT("+e"),	NO_NAME, 21,  33,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x12,0x00,0x00,0x00}},
	
//43
	{TEXT("r"),	TEXT("R"),	TEXT("r"),	TEXT("+r"),	NO_NAME, 21,  42,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x13,0x00,0x00,0x00}},

//44
    {TEXT("t"),	TEXT("T"),	TEXT("t"),	TEXT("+t"),	
     NO_NAME, 21,51,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x14,0x00,0x00,0x00}},

//45
	{TEXT("y"),	TEXT("Y"),	TEXT("y"),	TEXT("+y"),	NO_NAME, 21,  60,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x15,0x00,0x00,0x00}},
	
//46	
	{TEXT("u"),	TEXT("U"),	TEXT("u"),	TEXT("+u"),	NO_NAME, 21,  69,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x16,0x00,0x00,0x00}},
	
//47	
	{TEXT("i"),	TEXT("I"),	TEXT("i"),	TEXT("+i"),	NO_NAME, 21,  78,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x17,0x00,0x00,0x00}},
	
//48
	{TEXT("o"),	TEXT("O"),	TEXT("o"),	TEXT("+o"),	NO_NAME, 21,  87,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x18,0x00,0x00,0x00}},
	
//49	
	{TEXT("p"),	TEXT("P"),	TEXT("p"),	TEXT("+p"),	NO_NAME, 21,  96,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x19,0x00,0x00,0x00}},
	
//50
	{TEXT("["),	TEXT("{"),	TEXT("["),	TEXT("{{}"),	NO_NAME, 21, 105,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1A,0x00,0x00,0x00}},
	
//51	
	{TEXT("]"),	TEXT("}"),	TEXT("]"),	TEXT("{}}"),	NO_NAME, 21, 114,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1B,0x00,0x00,0x00}},
	
//52	
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 123,  8,	13, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x2B,0x00,0x00,0x00}},

//53
	{TEXT("del"), TEXT("del"), 	TEXT("{DEL}"),TEXT("{DEL}"),NO_NAME, 21,   138,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x53,0x00,0x00}},

//54	
	{TEXT("end"),	TEXT("end"), 	TEXT("{END}"),TEXT("{END}"),NO_NAME, 21,   147,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x4F,0x00,0x00}},

//55	
	{TEXT("pdn"), TEXT("pdn"), 	TEXT("{PGDN}"),TEXT("{PGDN}"),NO_NAME, 21, 156,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x51,0x00,0x00}},

//56
	{TEXT("7"),		TEXT("7"),		TEXT("hm"),		TEXT("7"),		NO_NAME,	 21,	 166,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x47,0x00,0x00,0x00}},

//57	
	{TEXT("8"),		TEXT("8"),		TEXT("8"),		TEXT("8"),		NO_NAME,	 21,	 175,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x48,0x00,0x00,0x00}},

//58	
	{TEXT("9"),		TEXT("9"),		TEXT("pup"),		TEXT("9"),		NO_NAME,	 21,	 184,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x49,0x00,0x00,0x00}},
	
//59
	{TEXT("+"),		TEXT("+"),		TEXT("{+}"),  	TEXT("{+}"),	NO_NAME,	 21,	 193,	 17,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x4E,0x00,0x00,0x00}},


//60
    {TEXT("lock"),TEXT("lock"),TEXT("{caplock}"),TEXT("{caplock}"),
     KB_CAPLOCK, 30,1,8,17, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x3A,0x00,0x00,0x00}},

//61
	{TEXT("a"),	TEXT("A"), TEXT("a"), TEXT("+a"),
     NO_NAME, 30,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1E,0x00,0x00,0x00}},

//62
	{TEXT("s"),		TEXT("S"),		TEXT("s"),		TEXT("+s"),		NO_NAME,	  30,	  28,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1F,0x00,0x00,0x00}},
	
//63
	{TEXT("d"),		TEXT("D"),		TEXT("d"),		TEXT("+d"),		NO_NAME,	  30,	  37,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x20,0x00,0x00,0x00}},
	
//64
	{TEXT("f"),		TEXT("F"),		TEXT("f"),		TEXT("+f"),		NO_NAME,	  30,	  46,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x21,0x00,0x00,0x00}},
	
//65
	{TEXT("g"),		TEXT("G"),		TEXT("g"),		TEXT("+g"),		NO_NAME,	  30,	  55,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x22,0x00,0x00,0x00}},
	
//66
	{TEXT("h"),		TEXT("H"),		TEXT("h"),		TEXT("+h"),		NO_NAME,	  30,	  64,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x23,0x00,0x00,0x00}},

//67
	{TEXT("j"),	TEXT("J"), TEXT("j"), TEXT("+j"),
     NO_NAME, 30,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x24,0x00,0x00,0x00}},

//68
	{TEXT("k"),		TEXT("K"),		TEXT("k"),		TEXT("+k"),		NO_NAME,	  30,	  82,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x25,0x00,0x00,0x00}},
	
//69
	{TEXT("l"),		TEXT("L"),		TEXT("l"),		TEXT("+l"),		NO_NAME,	  30,	  91,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x26,0x00,0x00,0x00}},
	
//70	
	{TEXT(";"), TEXT(":"), TEXT(";"), TEXT("+;"),
     NO_NAME, 30,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x27,0x00,0x00,0x00}},

//71
	{TEXT("'"),		TEXT("''"),		TEXT("'"),		TEXT("''"),		NO_NAME,	  30,	 109,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x28,0x00,0x00,0x00}},
	
//72
//Japanese KB extra key
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 118,  8,	8, FALSE, KNORMAL_TYPE, NOTSHOW, REDRAW, 1, {0x2B,0x00,0x00,0x00}},
	
//73	
	{TEXT("ent"),TEXT("ent"),TEXT("{enter}"),TEXT("{enter}"),	NO_NAME,  30,	 118,	  8,  18, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 2, {0x1C,0x00,0x00,0x00}},


//74
    {TEXT("4"), TEXT("4"), TEXT("4"), TEXT("4"),
     NO_NAME, 30,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4B,0x00,0x00,0x00}},

//75
    {TEXT("5"),	TEXT("5"), TEXT("5"), TEXT("5"),
     NO_NAME, 30,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4C,0x00,0x00,0x00}},

//76
    {TEXT("6"),	TEXT("6"), TEXT("6"), TEXT("6"),
     NO_NAME, 30,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4D,0x00,0x00,0x00}},


//77
	{TEXT("shft"),TEXT("shft"),	TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,21, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},

//78
    {TEXT("z"), TEXT("Z"),  TEXT("z"),  TEXT("+z"),
     NO_NAME,39,23,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2C,0x00,0x00,0x00}},

//79
    {TEXT("x"),	TEXT("X"), TEXT("x"), TEXT("+x"),
     NO_NAME, 39,32,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2D,0x00,0x00,0x00}},

//80
    {TEXT("c"), TEXT("C"), TEXT("c"), TEXT("+c"),
     NO_NAME, 39,41,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2E,0x00,0x00,0x00}},

//81
    {TEXT("v"), TEXT("V"), TEXT("v"), TEXT("+v"),
     NO_NAME, 39,50,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2F,0x00,0x00,0x00}},

//82
    {TEXT("b"),TEXT("B"),TEXT("b"),TEXT("+b"),
     NO_NAME,39,59,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x30,0x00,0x00,0x00}},

//83
    {TEXT("n"),	TEXT("N"), TEXT("n"), TEXT("+n"),
     NO_NAME,39,68,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x31,0x00,0x00,0x00}},

//84
    {TEXT("m"), TEXT("M"), TEXT("m"), TEXT("+m"),
     NO_NAME, 39,77,8,8,FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x32,0x00,0x00,0x00}},

//85
    {TEXT(","),	TEXT("<"), TEXT(","), TEXT("+<"),
     NO_NAME, 39,86,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x33,0x00,0x00,0x00}},

//86
    {TEXT("."), TEXT(">"), TEXT("."), TEXT("+>"),
     NO_NAME, 39,95,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
    {0x34,0x00,0x00,0x00}},

//87
    {TEXT("/"),	TEXT("?"), TEXT("/"), TEXT("+/"),
     NO_NAME, 39,104,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x35,0x00,0x00,0x00}},


//88
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW},  //DUMMY
	
//89
	{TEXT("shft"),TEXT("shft"),TEXT(""),TEXT(""),
     KB_RSHIFT,39,113,8,23,TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},


//90
    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP,39,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//91
	{TEXT("1"), TEXT("1"),TEXT("end"),TEXT("1"),
     NO_NAME,39,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4F,0x00,0x00,0x00}},

//92
	{TEXT("2"), TEXT("2"),TEXT("2"),TEXT("2"),
     NO_NAME,39,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x50,0x00,0x00,0x00}},

//93
	{TEXT("3"),TEXT("3"),TEXT("pdn"),TEXT("3"),
     NO_NAME,39,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x51,0x00,0x00,0x00}},

//94
	{TEXT("ent"),TEXT("ent"),TEXT("ent"),TEXT("ent"),
     NO_NAME, 39,193,17,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x1C,0x00,0x00}},


//95
	{TEXT("ctrl"), TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_LCTR,48,1,8,13,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x1D,0x00,0x00,0x00}},

//96
    {TEXT("winlogoUp"), TEXT("winlogoDn"),TEXT("I_winlogo"),TEXT("lwin"),
     ICON, 48, 15 ,8,8,TRUE, KMODIFIER_TYPE,BOTH, REDRAW},

//97
    {TEXT("alt"),TEXT("alt"),TEXT(""),TEXT(""),
	 KB_LALT,48,24,8,13,TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x38,0x00,0x00,0x00}},

//98
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW},  //DUMMY

//99
    {TEXT(""),TEXT(""),TEXT(" "),TEXT(" "),
     KB_SPACE,48,38,8,52, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//100
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW},  //DUMMY

//101
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW},  //DUMMY


//102
    {TEXT("alt"),TEXT("alt"),TEXT(""),TEXT(""),
     KB_RALT,48,91,8,13, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//103
	{TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"),TEXT("rwin"),
     ICON, 48,105,8,8,TRUE, KMODIFIER_TYPE,LARGE, REDRAW},

//104
	{TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"),TEXT("App"),
     ICON, 48,114,8,8, TRUE, KMODIFIER_TYPE,LARGE, REDRAW},

//105
    {TEXT("ctrl"),TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_RCTR,48,123,8,13,TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x10,0x00,0x00}},


//106
	{TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,138,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

//107
	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//108
	{TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,156,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},


//109
    {TEXT("0"),	TEXT("0"),	TEXT("ins"),	TEXT("0"),
     NO_NAME, 48,166,8,17, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x52,0x00,0x00,0x00}},

//110
    {TEXT("."),	TEXT("."),	TEXT("del"),	TEXT("."),
     NO_NAME, 48,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x53,0x00,0x00,0x00}},

//End of large KB

//111
	{TEXT(""), TEXT(""), TEXT(" "), TEXT(" "),
     KB_SPACE,  48,38,8,38, FALSE, KNORMAL_TYPE, SMALL, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},


//112
	{TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT,  48,77,8,13, TRUE, KMODIFIER_TYPE, SMALL, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//113
	{TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48,91,8,8, TRUE, KMODIFIER_TYPE, SMALL, REDRAW},


//114
	{TEXT("IDB_UPUPARW"),TEXT("IDB_UPUPARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 48,100,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//115
	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,109,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//116
	{TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,118,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

//117
    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP,48,127, 8,9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

	};

/**************************************************************************/
// FUNCTIONS in Other FILEs
/**************************************************************************/
LRESULT WINAPI kbMainWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI kbKeyWndProc (HWND hwndKey, UINT message, WPARAM wParam, LPARAM lParam);
void SendErrorMessage(UINT id_string);

/****************************************************************************/
/* Global Vars */
/****************************************************************************/
TCHAR szKbMainClass[] = TEXT("OSKMainClass") ;
extern BOOL settingChanged;

/****************************************************************************/
/* BOOL InitProc(void) */
/****************************************************************************/
BOOL InitProc(void)
{	
	// How many keys we have.
	lenKBkey = sizeof(KBkey)/sizeof(KBkey[0]);
    return TRUE;
}

/****************************************************************************/
/* BOOL RegisterWndClass(void) */
/****************************************************************************/
BOOL RegisterWndClass(HINSTANCE hInst)
{
	WNDCLASS wndclass;

	// Keyboard frame class
	wndclass.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
	wndclass.lpfnWndProc   = kbMainWndProc ;
	wndclass.cbClsExtra    = 0 ;
	wndclass.cbWndExtra    = 0 ;
	wndclass.hInstance     = hInst;
	wndclass.hIcon         = LoadIcon (hInst, TEXT("APP_OSK"));
	wndclass.hbrBackground = (HBRUSH)(COLOR_MENUHILIGHT+1);
	wndclass.lpszMenuName  = TEXT("IDR_MENU");
	wndclass.lpszClassName = szKbMainClass ;

	// Load the system hand cursor or use our own if not available

	wndclass.hCursor = LoadCursor (NULL, IDC_HAND);
	if (!wndclass.hCursor)
	{
		wndclass.hCursor = LoadCursor (hInst, MAKEINTRESOURCE(IDC_CURHAND1));
	}

	RegisterClass(&wndclass);

	return RegisterKeyClasses(hInst);
} 

BOOL RegisterKeyClasses(HINSTANCE hInst)
{
	WNDCLASS    wndclass, wndclassT;
	TCHAR		Wclass[10];
	int			i;
	COLORREF    color;

	// Key class
	wndclass.cbClsExtra    = 0 ;
	wndclass.hInstance     = hInst;
	wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
	wndclass.lpfnWndProc   = kbKeyWndProc ;
	wndclass.cbWndExtra    = sizeof (long);
    wndclass.hIcon         = NULL;
	wndclass.hbrBackground = (HBRUSH)COLOR_INACTIVECAPTION;
	wndclass.lpszMenuName  = NULL;

	// Load the system hand cursor or use our own if not available

	wndclass.hCursor = LoadCursor (NULL, IDC_HAND);
	if (!wndclass.hCursor)
	{
		wndclass.hCursor = LoadCursor (hInst, MAKEINTRESOURCE(IDC_CURHAND1));
	}

	// Register class types for each type of key.  The reason for so many classes
	// is that the background color for each key is stored in the extra class
	// memory.  This is a hack and really should be handled differently. 
	
	for (i = 1; i < lenKBkey; i++)
	{
		BOOL fSkip = FALSE;
		switch (KBkey[i].ktype)
		{
			case KNORMAL_TYPE:		 wsprintf(Wclass, TEXT("N%d"), i); color = COLOR_MENU;   break;
			case KMODIFIER_TYPE:	 wsprintf(Wclass, TEXT("M%d"), i); color = COLOR_INACTIVECAPTION; break;
			case KDEAD_TYPE:		 wsprintf(Wclass, TEXT("D%d"), i); color = COLOR_INACTIVECAPTION; break;
			case NUMLOCK_TYPE:		 wsprintf(Wclass, TEXT("NL%d"),i); color = COLOR_INACTIVECAPTION; break;
			case SCROLLOCK_TYPE:	 wsprintf(Wclass, TEXT("SL%d"),i); color = COLOR_INACTIVECAPTION; break;
			case LED_NUMLOCK_TYPE:	 wsprintf(Wclass, TEXT("LN%d"),i); color = COLOR_BTNSHADOW; break;
			case LED_CAPSLOCK_TYPE:	 wsprintf(Wclass, TEXT("LC%d"),i); color = COLOR_BTNSHADOW; break;
			case LED_SCROLLLOCK_TYPE:wsprintf(Wclass, TEXT("LS%d"),i); color = COLOR_BTNSHADOW; break;
			default: fSkip = TRUE; break;	// internal error!
		}

		// only call RegisterClass if there's one to do and it isn't already registered

		if (!fSkip && !GetClassInfo(hInst, Wclass, &wndclassT))
		{
			wndclass.hbrBackground = (HBRUSH)IntToPtr(color + 1);
			wndclass.lpszClassName = Wclass ;
			RegisterClass (&wndclass);
		}
	}

	return TRUE;
}

extern BOOL  Setting_ReadSuccess;      //read the setting file success ?

/****************************************************************************/
/*  HWND CreateMainWindow(void) */
/****************************************************************************/
HWND CreateMainWindow(BOOL re_size)
{
	int x, y, cx, cy, temp;
	TCHAR  szTitle[256]=TEXT("");
	int KB_SMALLRMARGIN= 137;

	// SmallMargin for Actual / Block layout
	if(kbPref->Actual)
		KB_SMALLRMARGIN = 137;  //Actual
	else
		KB_SMALLRMARGIN = 152;  //Block


	if(!Setting_ReadSuccess)       //if can't read the setting file
	{	
        g_margin = scrCX / KB_LARGERMARGIN;

		if(g_margin < 4)
		{
			g_margin = 4;
			smallKb = TRUE;
			cx = KB_SMALLRMARGIN * g_margin;
		}
		else
        {
			cx = KB_LARGERMARGIN * g_margin;
        }

		temp = scrCY - 5;          // 5 units from the bottom
		y = temp - (g_margin * KB_CHARBMARGIN) - captionCY; //- menuCY;
		x = 5;                     // 5 units from the left
		cy = temp - y;
    } 
    else
    {
        x  = kbPref->KB_Rect.left;
        y  = kbPref->KB_Rect.right;
        cx = kbPref->KB_Rect.right - kbPref->KB_Rect.left;
        cy = kbPref->KB_Rect.bottom - kbPref->KB_Rect.top;
    }

    //*********************************
    //Create the main window (Keyboard)
    //*********************************
	
    LoadString(hInst, IDS_TITLE1, &szTitle[0], 256);

    return CreateWindowEx(WS_EX_NOACTIVATE|WS_EX_APPWINDOW/*WS_EX_LTRREADING*/, 
						szKbMainClass, 
                        szTitle,
                        WS_CAPTION|WS_BORDER|WS_MINIMIZEBOX|WS_SYSMENU,
                        x, y, 
                        cx, cy,
                        NULL, NULL, 
                        hInst, NULL);
}

/*****************************************************************************
* void mlGetSystemParam( void)
*
* GET SYSTEM PARAMETERS
*****************************************************************************/
void mlGetSystemParam(void)
{
	scrCX 		= GetSystemMetrics(SM_CXSCREEN);       // Screen Width
	scrCY 		= GetSystemMetrics(SM_CYSCREEN);       // Screen Height
	captionCY 	= GetSystemMetrics(SM_CYCAPTION);		// Caption Bar Height
} 

/****************************************************************************/
/* BOOL SetZOrder - Place the main window always on top / non top most
/****************************************************************************/
BOOL SetZOrder(void)
{
	HWND hwnd = (PrefAlwaysontop == TRUE)?HWND_TOPMOST:HWND_NOTOPMOST;
	SetWindowPos(g_hwndOSK, hwnd, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
	return TRUE;
}

/********************************************************************
* udfDraw3Dpush(HDC hdc, RECT rect)
*
* 3d effect when pushing buttons
********************************************************************/

void udfDraw3Dpush(HDC hdc, RECT brect)
{
	POINT bPoint[3];
	HPEN oldhpen;
	LOGPEN lpPen = { PS_SOLID, 2, 2, RGB(255,0,0) };
	HPEN hPen = CreatePenIndirect(&lpPen);

	if (!hPen)
		return;	// PREFIX #113804 NULL pointer reference 

	oldhpen = SelectObject(hdc, hPen);

	bPoint[0].x = brect.right - 1 ;
	bPoint[0].y =  +2;
	bPoint[1].x = brect.right - 1;
	bPoint[1].y = brect.bottom - 1;
	bPoint[2].x =  0;
	bPoint[2].y = brect.bottom - 1;
	Polyline(hdc, bPoint,3);

	bPoint[0].x =  1 ;
	bPoint[0].y =  brect.bottom;
	bPoint[1].x = 0;
	bPoint[1].y = 0;
	bPoint[2].x =  brect.right;
	bPoint[2].y = 1;
	Polyline(hdc, bPoint,3);

	SelectObject(hdc, oldhpen);
	DeleteObject(hPen);
}

/********************************************************************
/* UpdateKey - update a key's text and background
/********************************************************************/

void UpdateKey(HWND hwndKey, HDC hdc, RECT brect, int iKey, int iKeyVal)
{
    LPTSTR     pszText;
    KBkeyRec   *pKey = KBkey + iKey;
	HFONT      hFont = NULL;
	int        iCharWidth, iCharHeight, cchText;
	int        px, py, iPrevBkMode;
    TEXTMETRIC tm;

    pszText = pKey->apszKeyStr[ GetModifierState() ];

	if (!pszText)
	{
		DBPRINTF(TEXT("UpdateKey:  key %d has null text!\r\n"), iKey);
		return;	// internal error!
	}

    // Set a font

	cchText = lstrlen(pszText);

	hFont = ReSizeFont(iKey, plf, cchText);
    if (NULL != hFont)
    {
    	oldFontHdle = SelectObject(hdc, hFont);
    }

	iPrevBkMode = SetBkMode(hdc, TRANSPARENT);

	// Set a text color

	if (iKeyVal == 4)
	{
        // color of most keys
        SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT)); // always white
		iKeyVal = 0;
	}
    else if (  pKey->ktype == KMODIFIER_TYPE 
            || pKey->ktype == NUMLOCK_TYPE 
            || pKey->ktype == SCROLLOCK_TYPE
			|| pKey->ktype == KDEAD_TYPE)
	{
        // color of keys text that can be latched or are modifiers
		BOOL clr = (BOOL)GetWindowLongPtr(hwndKey, GWLP_USERDATA_TEXTCOLOR);
		SetTextColor(hdc, clr? GetSysColor(COLOR_INACTIVECAPTION) : GetSysColor(COLOR_INACTIVECAPTIONTEXT));
	}
    else
    {
        // all other keys text color
		SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
    }

    // More font stuff based on the key char

	GetTextMetrics(hdc, &tm);
	iCharHeight = tm.tmHeight + tm.tmExternalLeading;
	iCharWidth = tm.tmAveCharWidth * cchText;

	px =(int) (((float)((brect.right -brect.left) - iCharWidth + 0) / 2.0) +
               ((float)(tm.tmAveCharWidth * iKeyVal)/3.0));

	py =(int) (((float)((brect.bottom -brect.top) - iCharHeight) / 1.5));

    // Special case, these letters are fatter

    switch (*pszText)
    {
        case 'W': px -= 2; break;
        case 'M': px -= 1; break;
        case 'm': px -= 1; break;
        case '%': px -= 3; break;
    }

	// put the text on the key

	TextOut(hdc, px, py, pszText, cchText);
	SetBkMode(hdc, iPrevBkMode);

    // some state that needs to be saved

	if((Prefusesound == TRUE) && (iKeyVal != 4))
    {
		if(iKeyVal != 0)
        {
			s_fLastDown = TRUE;
        }
		else if((iKeyVal == 0) && (s_fLastDown == TRUE))
        {
			s_fLastDown = FALSE;
        }
    }

	SelectObject(hdc, oldFontHdle);
	if (hFont)	// PREFIX #113808 NULL pointer reference
    {
		DeleteObject(hFont);
    }

    return;
}

/****************************************************************************/
//Redraw the num lock key.
//Toggole it stay hilite or off
/****************************************************************************/
BOOL RedrawNumLock(void)
{	
	int i;
	int bRet = FALSE;

	for(i=1; i<lenKBkey; i++)
	{	
		if(KBkey[i].ktype == NUMLOCK_TYPE)
		{
			if(LOBYTE(GetKeyState(VK_NUMLOCK)) &0x01)   //Toggled (ON)
			{
				SetWindowLong(lpkeyhwnd[i], 0, 4);	
				SetBackgroundColor(lpkeyhwnd[i], COLOR_HOTLIGHT);
    			SetWindowLongPtr(lpkeyhwnd[i],  GWLP_USERDATA_TEXTCOLOR, 1);
				bRet = TRUE;
			}
			else
			{	SetWindowLong(lpkeyhwnd[i], 0, 0);
                SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);	
    			SetWindowLongPtr(lpkeyhwnd[i],  GWLP_USERDATA_TEXTCOLOR, 0);
				bRet = FALSE;
			}
			
			InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
			
			break;
		}
	}
	return bRet;
}
/****************************************************************************/
//Redraw the scroll lock key.
//Toggole it stay hilite or off
/****************************************************************************/
BOOL RedrawScrollLock(void)
{	
	int i;
	int bRet = FALSE;

	for(i=1; i<lenKBkey; i++)
	{	if(KBkey[i].ktype == SCROLLOCK_TYPE)
		{
			if(LOBYTE(GetKeyState(VK_SCROLL)) &0x01)   //Toggled (ON)
			{
				SetWindowLong(lpkeyhwnd[i], 0, 4);	
				SetBackgroundColor(lpkeyhwnd[i], COLOR_HOTLIGHT);
    			SetWindowLongPtr(lpkeyhwnd[i],  GWLP_USERDATA_TEXTCOLOR, 1);
				bRet = TRUE;
			}
			else
			{	SetWindowLong(lpkeyhwnd[i], 0, 0);
                SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);	
    			SetWindowLongPtr(lpkeyhwnd[i],  GWLP_USERDATA_TEXTCOLOR, 0);
				bRet = FALSE;
			}
			
			InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
			
			break;
		}
	}
	return bRet;
}
/****************************************************************************/

HFONT	ReSizeFont(int iKey, LOGFONT *plf, int cchText)
{
	static int    FontHeight=-12;
	static float  Scale=1.0;
	static float  UpRatio=0.0, DnRatio=0.0;

    HFONT    hFont=NULL;        // Handle of the selected font
	LOGFONT  smallLF;
	float    Scale1=0.0;
	int      delta=0;
	RECT     rect;

	//use smaller font
	if(cchText >= 2 && KBkey[iKey].ktype != KMODIFIER_TYPE && iKey !=30 && iKey != 38 && iKey !=71 )
	{
		GetClientRect(g_hwndOSK, &rect);
		Scale1= (float)(rect.right - rect.left);

		if(Scale1/Scale >= UpRatio)
			delta= -2;
		else if(Scale1/Scale <= DnRatio)
			delta= +2;

		smallLF.lfHeight= FontHeight +2;       // + delta;
		smallLF.lfWidth= 0;
		smallLF.lfEscapement= 0;
		smallLF.lfOrientation= 0;
		smallLF.lfWeight= 700;
		smallLF.lfItalic= '\0';
		smallLF.lfUnderline= '\0';
		smallLF.lfStrikeOut= '\0';
		smallLF.lfCharSet= plf->lfCharSet;  // '\0'
		smallLF.lfOutPrecision= '\x01';
		smallLF.lfClipPrecision= '\x02';
		smallLF.lfQuality= '\x01';
		smallLF.lfPitchAndFamily= DEFAULT_PITCH || FF_DONTCARE;  //'"';

        lstrcpy(smallLF.lfFaceName, plf->lfFaceName);

		hFont = CreateFontIndirect(&smallLF);

		return hFont;
	}
	else if(newFont == TRUE)
	{	
        hFont = CreateFontIndirect(plf);
		return hFont;
	}
    return hFont;
}


/**********************************************************************/
/*  BOOL ChooseNewFont( HWND hWnd )*/
/**********************************************************************/
BOOL ChooseNewFont(HWND hWnd)
{
	CHOOSEFONT   chf;

	chf.hDC = NULL;
	chf.lStructSize = sizeof(CHOOSEFONT);
	chf.hwndOwner = NULL;    
	chf.lpLogFont = plf;
	chf.Flags = CF_SCREENFONTS | CF_FORCEFONTEXIST | CF_INITTOLOGFONTSTRUCT;
	chf.rgbColors = 0;
	chf.lCustData = 0;
	chf.hInstance = (HANDLE)hInst;
	chf.lpszStyle = (LPTSTR)NULL;
	chf.nFontType = SCREEN_FONTTYPE;
	chf.nSizeMin = 0;
	chf.nSizeMax = 14;
	chf.lpfnHook = (LPCFHOOKPROC)(FARPROC)NULL;
	chf.lpTemplateName = (LPTSTR)NULL;

	if( ChooseFont(&chf) == FALSE )
    {
		return FALSE;
    }

	newFont = TRUE;

    kbPref->lf.lfHeight      = plf->lfHeight;
    kbPref->lf.lfWidth       = plf->lfWidth;
    kbPref->lf.lfEscapement  = plf->lfEscapement;
    kbPref->lf.lfOrientation = plf->lfOrientation;
    kbPref->lf.lfWeight      = plf->lfWeight;
    kbPref->lf.lfItalic      = plf->lfItalic;
    kbPref->lf.lfUnderline   = plf->lfUnderline;
    kbPref->lf.lfStrikeOut   = plf->lfStrikeOut;
    kbPref->lf.lfCharSet     = plf->lfCharSet;
    kbPref->lf.lfOutPrecision  = plf->lfOutPrecision;
    kbPref->lf.lfClipPrecision = plf->lfClipPrecision;
    kbPref->lf.lfQuality       = plf->lfQuality;
    kbPref->lf.lfPitchAndFamily= plf->lfPitchAndFamily;

#ifdef UNICODE
    wsprintfA(kbPref->lf.lfFaceName, "%ls", plf->lfFaceName);
#else
    wsprintfA(kbPref->lf.lfFaceName, "%hs", plf->lfFaceName);
#endif

	return (TRUE);
}

/**********************************************************************/
/*  BOOL RDrawIcon
/**********************************************************************/
BOOL RDrawIcon(HDC hDC, TCHAR *pIconName, RECT rect)
{
	HICON hIcon;
	BOOL iret;
    int rx, ry, Ox, Oy;

    rx = rect.right - rect.left;
    ry = rect.bottom - rect.top;

    hIcon = LoadImage(hInst, pIconName, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE|LR_SHARED);

	if(hIcon == NULL)
	{
		SendErrorMessage(IDS_CANNOT_LOAD_ICON);
		return FALSE;
	}

	SetMapMode(hDC,MM_TEXT);

    //Find out where is the top left corner to place the icon

    Ox = (int)(rx/2) - 16;
    Oy = (int)(ry/2) - 16;

    //Draw the icon (Draw in center)
    iret = DrawIconEx(hDC, Ox, Oy, hIcon, 0,0,0, NULL, DI_NORMAL);

	return iret;
}

/**********************************************************************/
/*  BOOL RDrawBitMap
/**********************************************************************/
BOOL RDrawBitMap(HDC hDC, TCHAR *pIconName, RECT rect, BOOL transform)
{
	HBITMAP hBitMap;
	BOOL iret;
    SIZE sz;
	HDC hDC1;
    int rx, ry, ix, iy;
	DWORD err;
	COLORREF clrIn, clrTx;

    ix = 0;
    iy = 0;
    rx = rect.right - rect.left;
    ry = rect.bottom - rect.top;
    if (!PrefScanning)
    {
        ix  = 2;
        iy  = 2;
        rx -= 4;
        ry -= 4;
    }
	
	SetMapMode(hDC,MM_TEXT);

	clrIn = GetSysColor(COLOR_INACTIVECAPTION);
	clrTx = GetSysColor(COLOR_INACTIVECAPTIONTEXT);

	iret = FALSE;
	hBitMap = LoadImage(hInst, pIconName, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE );
    if (hBitMap)
    {
	    if ( transform )
	    {
		    // convert the background and text to match inactive title
		    // and inactive text color

		    // Take care not to overwrite each other and also skip if you don't need any transformation.

		    if ( clrIn == RGBWHITE )
		    {
			    // Then reverse the process
			    ChangeBitmapColor (hBitMap, RGBWHITE, clrTx, NULL);
			    ChangeBitmapColor (hBitMap, RGBBACK, clrIn, NULL);
		    }
		    else
		    {
			    if ( RGBBACK != clrIn)
				    ChangeBitmapColor (hBitMap, RGBBACK, clrIn, NULL);

			    if ( RGBWHITE != clrTx)
				    ChangeBitmapColor (hBitMap, RGBWHITE, clrTx, NULL);
		    }
	    }

	    hDC1 = CreateCompatibleDC(hDC);
	    if (hDC1)	// PREFIX #113799 null pointer reference
	    {
		    HBITMAP hBitMapOld = SelectObject(hDC1, hBitMap);

		    iret = StretchBlt(hDC, ix, iy, rx, ry, hDC1, 0, 0, rx, ry, SRCCOPY);

            SelectObject(hDC1, hBitMapOld);
		    DeleteDC(hDC1);
	    }

        DeleteObject(hBitMap);
    }

	return iret;
}

/**************************************************************************/
/* void DeleteChildBackground(void)                                           */
/**************************************************************************/
void DeleteChildBackground(void)
{
	register int i;

	for (i = 1; i < lenKBkey; i++)
	{
		switch (KBkey[i].ktype)
		{
			case KNORMAL_TYPE:
				SetBackgroundColor(lpkeyhwnd[i], COLOR_MENU);
				break;
			
			case NUMLOCK_TYPE:
			case KMODIFIER_TYPE:
			case SCROLLOCK_TYPE:
			case KDEAD_TYPE:
				SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);
				break;
			
			case LED_NUMLOCK_TYPE:
			case LED_CAPSLOCK_TYPE:
			case LED_SCROLLLOCK_TYPE:
				SetBackgroundColor(lpkeyhwnd[i], COLOR_BTNSHADOW);
				break;
		}
	}
}

/*****************************************************************************/
//Redraw the keys when Shift/Cap being pressed or released
/*****************************************************************************/
void RedrawKeys(void)
{
	KBkeyRec *pKey;
	int  i, nKeyState;

	// Depending on modifier key states, show one of three keyboards.

    nKeyState = GetModifierState();

	for (i = 1, pKey = KBkey+i; i < lenKBkey; i++, pKey++)
	{
		if (pKey->Caps_Redraw != REDRAW)
			continue;	// skip keys that don't redraw

		// Restore dead key type and background

		if (pKey->ktype == KDEAD_TYPE)
		{
			SetBackgroundColor(lpkeyhwnd[i], COLOR_MENU);
			pKey->ktype = KNORMAL_TYPE;
		}

		// Set a new key type based on the current keyboard state

        pKey->ktype = pKey->abKeyType[ nKeyState ];


		// update dead key background

		if (pKey->ktype == KDEAD_TYPE)
		{
			SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);
		}

		// Do the redraw

        InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
    }
}

/*****************************************************************************/
//Redraw the Num Pad Keys
/*****************************************************************************/
void RedrawNumPadKeys(void)
{	
	register int i;

	for (i = 1; i < lenKBkey; i++)
	{
		if(KBkey[i].print==3)
		{
			InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
		}
	}
}

/*****************************************************************************/
//Round the coner of each key
/*****************************************************************************/
void SetKeyRegion(HWND hwnd, int w, int h)
{	
	HRGN hRgn = CreateRoundRectRgn(1, 1, w, h, 5, 2);
	SetWindowRgn(hwnd, hRgn, TRUE);
}

// Bitmap transformation
void ChangeBitmapColor(HBITMAP hbmSrc, COLORREF rgbOld, COLORREF rgbNew, HPALETTE hPal)
{
	HDC hDC;
	HDC hdcMem;
	PBITMAP bmBits;
    HBITMAP hbmOld;
	DWORD err;
	bmBits = (LPBITMAP)LocalAlloc(LMEM_FIXED, sizeof(*bmBits));

	if (hDC = GetDC(NULL))
	{
		if (hdcMem = CreateCompatibleDC(hDC))
		{
			//
			// Get the bitmap struct needed by ChangeBitmapColorDC()
			//
			GetObject(hbmSrc, sizeof(*bmBits), (LPBITMAP)bmBits);

			err = GetLastError();
			//
			// Select our bitmap into the memory DC
			//
			hbmOld = (HBITMAP) SelectObject(hdcMem, hbmSrc);

			// Select in our palette so our RGB references will come
			// out correctly

			if (hPal) 
			{
				SelectPalette(hdcMem, hPal, FALSE);
				RealizePalette(hdcMem);
			}

			ChangeBitmapColorDC(hdcMem, bmBits, rgbOld, rgbNew);

			//
			// Unselect our bitmap before deleting the DC
			//
			hbmSrc = (HBITMAP) SelectObject(hdcMem, hbmOld);

			DeleteDC(hdcMem);
		}

		ReleaseDC(NULL, hDC);
	}
	LocalFree(bmBits);
}

void ChangeBitmapColorDC (HDC hdcBM, LPBITMAP lpBM, COLORREF rgbOld, COLORREF rgbNew)
{
	HDC hdcMask;
	HBITMAP hbmMask, hbmOld;
	HBRUSH hbrOld, hbrNew;

	if (!lpBM)
		return;

	//
	// if the bitmap is mono we have nothing to do
	//

	if (lpBM->bmPlanes == 1 && lpBM->bmBitsPixel == 1)
		return;

   //
   // To perform the color switching, we need to create a monochrome
   // "mask" which is the same size as our color bitmap, but has all
   // pixels which match the old color (rgbOld) in the bitmap set to 1.
   //
   // We then use the ROP code "DSPDxax" to Blt our monochrome
   // bitmap to the color bitmap.  "D" is the Destination color
   // bitmap, "S" is the source monochrome bitmap, and "P" is the
   // selected brush (which is set to the replacement color (rgbNew)).
   // "x" and "a" represent the XOR and AND operators, respectively.
   //
   // The DSPDxax ROP code can be explained as having the following
   // effect:
   //
   // "Every place the Source bitmap is 1, we want to replace the
   // same location in our color bitmap with the new color.  All
   // other colors we leave as is."
   //
   // The truth table for DSPDxax is as follows:
   //
   //       D S P Result
   //       - - - ------
   //       0 0 0   0
   //       0 0 1   0
   //       0 1 0   0
   //       0 1 1   1
   //       1 0 0   1
   //       1 0 1   1
   //       1 1 0   0
   //       1 1 1   1
   //
   // (Even though the table is assuming monochrome D (Destination color),
   // S (Source color), & P's (Pattern color), the results apply to color
   // bitmaps also).
   //
   // By examining the table, every place that the Source is 1
   // (source bitmap contains a 1), the result is equal to the
   // Pattern at that location.  Where S is zero, the result equals
   // the Destination.
   //
   // See Section 11.2 (page 11-4) of the "Reference -- Volume 2" for more
   // information on the Termary Raster Operation codes.
   //


   // bit maps are actually 32 by 32 pixels.  The height and width here were coming from the font which does not
   // apply to a bitmap key.  The keys in question here are the arrow keys.
   lpBM->bmWidth = 32;
   lpBM->bmHeight = 32;
   
   if (hbmMask = CreateBitmap(lpBM->bmWidth, lpBM->bmHeight, 1, 1, NULL))
   {
   
      if (hdcMask = CreateCompatibleDC(hdcBM))
      {
		 //
		 // Select th mask bitmap into the mono DC
		 //
         hbmOld = (HBITMAP) SelectObject(hdcMask, hbmMask);

         //
         // Create the brush and select it into the source color DC --
         // this is our "Pattern" or "P" color in our DSPDxax ROP.
         //

         hbrNew = CreateSolidBrush(rgbNew);
         hbrOld = (HBRUSH) SelectObject(hdcBM, hbrNew);
         //
         // To create the mask, we will use a feature of BitBlt -- when
         // converting from Color to Mono bitmaps, all Pixels of the
         // background colors are set to WHITE (1), and all other pixels
         // are set to BLACK (0).  So all pixels in our bitmap that are
         // rgbOld color, we set to 1.
         //

         SetBkColor(hdcBM, rgbOld);
         BitBlt(hdcMask, 0, 0, lpBM->bmWidth, lpBM->bmHeight, hdcBM, 0, 0, SRCCOPY);

         //
         // Where the mask is 1, lay down the brush, where it is 0, leave
         // the destination.
         //

         SetBkColor(hdcBM, RGBWHITE);
         SetTextColor(hdcBM, RGBBLACK);

         BitBlt(hdcBM, 0, 0, lpBM->bmWidth, lpBM->bmHeight, hdcMask, 0, 0, DSPDxax);

         SelectObject(hdcMask, hbmOld); // select old bitmaps and brushes 
         SelectObject(hdcBM, hbrOld);   // back into device contexts.

         if (hbrNew)
             DeleteObject(hbrNew);	// PREFIX #113798 dereference NULL pointer

         DeleteDC(hdcMask);
      }

      DeleteObject(hbmMask);
   }
}

//
// New routines added to refresh key labels when the keyboard layout changes 
// for the active window rather than trying to do that on-the-fly.  The old
// way caused lots of issues with dead key processing.
//

//
// InitKeys - initialize the key label fields in the keyboard array
//
void InitKeys()
{
    int i;
	KBkeyRec *pKey;

    for (i=1, pKey = &KBkey[1];i<lenKBkey;i++, pKey++)
    {
        int j;
        for (j=0;j<3;j++)
        {
            pKey->apszKeyStr[j] = NULL;
        }
    }
}

//
// UninitKeys - reset/free the key label fields in the keyboard array
//
void UninitKeys()
{
    int i, j;
	KBkeyRec *pKey;

	for (i = 1, pKey = KBkey+i; i < lenKBkey; i++, pKey++)
    {
		// reset the dead key types and restore the background to normal

		if (pKey->ktype == KDEAD_TYPE)
		{
			SetBackgroundColor(lpkeyhwnd[i], COLOR_MENU);
			pKey->ktype = KNORMAL_TYPE;
		}

        for (j=0;j<3;j++)
        {
            if (pKey->apszKeyStr[j])
            {
                free(pKey->apszKeyStr[j]);
                pKey->apszKeyStr[j] = NULL;
            }
        }
    }
}

//
// UpdateKeyLabels - Call to refresh all the key labels for normal, SHIFTED and
//                   ALTGR based on the specified hardware keyboard layout.
//
// Notes:  Just a bit kludgy, but we capture all the dead keys into abKeyType[]
//         and when the keyboard state changes we'll update the ktype member
//
void UpdateKeyLabels(HKL hkl)
{
    int i;
    KBkeyRec *pKey;
    BYTE achKbdState[256] = {0};
	LPTSTR pszDefLabel;

    // is this a Japanese keyboard?  then check if we are in kana mode
   if ((LOBYTE(LOWORD(hkl))) == LANG_JAPANESE)
    {
        if (g_fKanaKey)
        {
            DBPRINTF(TEXT("UpdateKeyLabels: Kana mode is on\r\n"));
            achKbdState[VK_KANA]= 0x80;
        }
    } 

    g_cAltGrKeys = 0;
    for (pKey=&KBkey[1], i=1;i<lenKBkey;pKey++, i++)
    {
        int  iRv;
        UINT vk;

        if (pKey->Caps_Redraw != REDRAW)
		{
			pKey->abKeyType[KEYMOD_NORMAL]   = (BYTE)pKey->ktype;
			pKey->apszKeyStr[KEYMOD_NORMAL]  = CopyDefKey(pKey->textL);

			pKey->abKeyType[KEYMOD_SHIFTED]  = (BYTE)pKey->ktype;
			pKey->apszKeyStr[KEYMOD_SHIFTED] = CopyDefKey(pKey->textC);

			pKey->abKeyType[KEYMOD_CAPSLOCK]  = (BYTE)pKey->ktype;
			pKey->apszKeyStr[KEYMOD_CAPSLOCK] = CopyDefKey(pKey->textC);

			pKey->abKeyType[KEYMOD_SHIFTEDCAPSLOCK]  = (BYTE)pKey->ktype;
			pKey->apszKeyStr[KEYMOD_SHIFTEDCAPSLOCK] = CopyDefKey(pKey->textC);

			pKey->abKeyType[KEYMOD_ALTGR]    = (BYTE)pKey->ktype;
			pKey->apszKeyStr[KEYMOD_ALTGR]   = CopyDefKey(pKey->textL);
			continue;
		}

        // if not flagged to use default label get virtual key code

        vk = (pKey->print == 2)? 0 : MapVirtualKeyEx(pKey->scancode[0], 3, hkl);

        // Get normal state (no modifiers down)

        achKbdState[VK_CAPITAL] = 0;
        achKbdState[VK_SHIFT]   = 0;
        achKbdState[VK_MENU]    = 0;
        achKbdState[VK_CONTROL] = 0;

        pKey->apszKeyStr[KEYMOD_NORMAL] = SetKeyText(vk, pKey->scancode[0], achKbdState, hkl, pKey->textL, &iRv);
        if (iRv < 0)
        {
			pKey->abKeyType[KEYMOD_NORMAL] = KDEAD_TYPE;
            pKey->ktype = KDEAD_TYPE;
        }
		else
		{
			pKey->abKeyType[KEYMOD_NORMAL] = (BYTE)pKey->ktype;
		}

        // Get SHIFTED state (SHIFT down)

        achKbdState[VK_CAPITAL] = 0;
        achKbdState[VK_SHIFT]   = 0x80;
        achKbdState[VK_MENU]    = 0;
        achKbdState[VK_CONTROL] = 0;

        pKey->apszKeyStr[KEYMOD_SHIFTED] = SetKeyText(vk, pKey->scancode[0], achKbdState, hkl, pKey->textC, &iRv);
		pKey->abKeyType[KEYMOD_SHIFTED] = (iRv < 0)?KDEAD_TYPE:pKey->abKeyType[KEYMOD_NORMAL];

        // Get CAPSLOCK state (CAPSLOCK active)

        achKbdState[VK_CAPITAL] = 0x01;
        achKbdState[VK_SHIFT]   = 0;
        achKbdState[VK_MENU]    = 0;
        achKbdState[VK_CONTROL] = 0;

        pKey->apszKeyStr[KEYMOD_CAPSLOCK] = SetKeyText(vk, pKey->scancode[0], achKbdState, hkl, pKey->textC, &iRv);
		pKey->abKeyType[KEYMOD_CAPSLOCK] = (iRv < 0)?KDEAD_TYPE:pKey->abKeyType[KEYMOD_NORMAL];

        // Get SHIFTED-CAPSLOCK state (CAPSLOCK active, SHIFT down)

        achKbdState[VK_CAPITAL] = 0x01;
        achKbdState[VK_SHIFT]   = 0x80;
        achKbdState[VK_MENU]    = 0;
        achKbdState[VK_CONTROL] = 0;

        pKey->apszKeyStr[KEYMOD_SHIFTEDCAPSLOCK] = SetKeyText(vk, pKey->scancode[0], achKbdState, hkl, pKey->textC, &iRv);
		pKey->abKeyType[KEYMOD_SHIFTEDCAPSLOCK] = (iRv < 0)?KDEAD_TYPE:pKey->abKeyType[KEYMOD_NORMAL];

        // Get ALTGR state (right ALT down same as LALT+CTRL)

        achKbdState[VK_CAPITAL] = 0;
        achKbdState[VK_SHIFT]   = 0;
        achKbdState[VK_MENU]    = 0x80;
        achKbdState[VK_CONTROL] = 0x80;

		// special-case showing the RALT key when in ALTGR keyboard state
		pszDefLabel = (pKey->name == KB_RALT)?pKey->textL:NULL;

        pKey->apszKeyStr[KEYMOD_ALTGR] = SetKeyText(vk, pKey->scancode[0], achKbdState, hkl, pszDefLabel, &iRv);
		pKey->abKeyType[KEYMOD_ALTGR] = (iRv < 0)?KDEAD_TYPE:pKey->abKeyType[KEYMOD_NORMAL];

		// count the ALTGR keys so we know whether to show this state or not

		if (iRv != 0)
		{
			g_cAltGrKeys++;
		}
    }
}

// 
// The following are called w/in this source file
//

//
// SetKeyText - set a key label for a key using the default label if GetKeyLabel doesn't set one. 
//
LPTSTR SetKeyText(UINT vk, UINT sc, LPBYTE achKbdState, HKL hkl, LPTSTR pszDefLabel, int *piType)
{
    TCHAR szBuf[30];
    LPTSTR psz;
    LPTSTR pszRet = 0;
    int iRet = GetKeyLabel(vk, sc, achKbdState, szBuf, ARRAY_SIZE(szBuf), hkl);

    if (!piType)
        return 0;

    // szBuf is set if there is text or for a dead key else if a 
    // default label was supplied use that else the key is blank

    if (iRet || iRet < 0)
    {
        psz = szBuf;
    }
    else 
    {
        if (pszDefLabel && *pszDefLabel)
        {
            psz = pszDefLabel;
        }
        else
        {
            psz = szBuf;
        }
    }

    pszRet = (LPTSTR)malloc((lstrlen(psz)+1)*sizeof(TCHAR));
    if (pszRet)
    {
        lstrcpy(pszRet, psz);
    }

    *piType = iRet;
    return pszRet;
}

//
// CopyDefKey - set a key label for a key using the default label
//              or space if there isn't one.
//
LPTSTR CopyDefKey(LPTSTR pszDefLabel)
{
    LPTSTR pszRet = 0;
	LPTSTR pszSpace = TEXT(" ");
	LPTSTR psz = pszSpace;

    if (pszDefLabel && *pszDefLabel)
    {
		psz = pszDefLabel;
    } 

    pszRet = (LPTSTR)malloc((lstrlen(psz)+1) * sizeof(TCHAR));
    if (pszRet)
    {
        lstrcpy(pszRet, psz);
    }

    return pszRet;
}

//
// GetKeyLabel - set a label for a key based on hardware keyboard layout, 
//               the virtual key code, and scan code
//
int GetKeyLabel(UINT vk, UINT sc, LPBYTE achKbdState, LPTSTR pszBuf, int cchBuf, HKL hkl)
{
    int iRet, cch;

#ifdef UNICODE

    iRet = ToUnicodeEx(vk, sc | 0x80, achKbdState, pszBuf, cchBuf, 0, hkl);
    if (iRet < 0)
    {
        // it is possible to have previous dead key, flush again.
        ToUnicodeEx(vk, sc | 0x80, achKbdState, pszBuf, cchBuf, 0, hkl);
    }

    cch = iRet;
#else
       // TODO ansi stuff but only if we had to backport to Win9x
#endif

    if (iRet <= 0 )
    {
        cch = 1;
        if (iRet == 0)
        {
            // no translation for this key at this shift state; set empty label.
            pszBuf[0] = TEXT(' ');
        }
    }

    pszBuf[cch] = TEXT('\0');
    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\init_end.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// Additions, Bug Fixes 1999 Anil

#define STRICT

#include <windows.h>
#include <winable.h>
#include "kbmain.h"
#include "Msswch.h"
#include "resource.h"
#include "htmlhelp.h"
#include "Init_End.h"
#include "kbus.h"
#include "dgsett.h"
#include "ms32dll.h"
#include "sdgutil.h"
#include "fileutil.h"
#include "kbfunc.h"
#include "about.h"
#include "w95trace.h"

/**************************************************************/
//      Global Vars
/**************************************************************/
HLOCAL				HkbPref  = NULL;
BOOL				KillTime = FALSE;
HSWITCHPORT	        g_hSwitchPort = NULL;
extern HWND			OpeningHwnd;
extern HINSTANCE	hInst;
extern float        g_KBC_length;
extern BOOL	        g_startUM;
extern KBkeyRec	    KBkey[];

extern DWORD GetDesktop();

/******************************************************************************/
void Create_The_Rest(LPSTR lpCmdLine, HINSTANCE hInstance)
{	
	// Opening the switch port initializes the msswch dll memory
	// mapped file so call it before calling RegisterHookSendWindow
	
	g_hSwitchPort = swchOpenSwitchPort( g_hwndOSK, PS_EVENTS );

	if(g_hSwitchPort == NULL)
    {
		SendErrorMessage(IDS_CANNOT_OPEN_SWPORT);
        return;
    }

	// RegisterHookSendWindow is new in Whistler and takes part of
	// the place of the old WH_JOURNALRECORD hook

    if (!RegisterHookSendWindow(g_hwndOSK, WM_GLOBAL_KBDHOOK))
	{	
		SendErrorMessage(IDS_JOURNAL_HOOK);
		SendMessage(g_hwndOSK, WM_DESTROY,0L,0L);  //destroy myself
		return;
	}

	//Config the scan key and port if the user has choosen these options
	if (kbPref->PrefScanning && kbPref->bKBKey)   //want switch key
		ConfigSwitchKey(kbPref->uKBKey, TRUE);
	else if (kbPref->PrefScanning)    //don't want switch key
		ConfigSwitchKey(0, FALSE);
    else if (kbPref->bPort)
        ConfigPort(TRUE);

}
/****************************************************************************/
/* void FinishProcess(void) */
/****************************************************************************/
void FinishProcess(void)
{	
	INPUT	rgInput[6];

    // Stop keyboard processing
    RegisterHookSendWindow(0, 0);

	// Close the Switch Port
	swchCloseSwitchPort(g_hSwitchPort);     

	KillTimer(g_hwndOSK, timerK1);           	// timer id
	KillTimer(g_hwndOSK,timerK2);				// timer for bucket

	// Send the shift, alt, ctrl key up message in case they still down
	//LSHIFT
	rgInput[0].type = INPUT_KEYBOARD;
	rgInput[0].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[0].ki.dwExtraInfo = 0;
	rgInput[0].ki.wVk = VK_LSHIFT;
	rgInput[0].ki.wScan = 0x2A;

	//RSHIFT
	rgInput[1].type = INPUT_KEYBOARD;
	rgInput[1].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[1].ki.dwExtraInfo = 0;
	rgInput[1].ki.wVk = VK_RSHIFT;
	rgInput[1].ki.wScan = 0x36;

	//LMENU
	rgInput[2].type = INPUT_KEYBOARD;
	rgInput[2].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[2].ki.dwExtraInfo = 0;
	rgInput[2].ki.wVk = VK_LMENU;
	rgInput[2].ki.wScan = 0x38;

	//RMENU
	rgInput[3].type = INPUT_KEYBOARD;
	rgInput[3].ki.dwFlags = KEYEVENTF_KEYUP|KEYEVENTF_EXTENDEDKEY;
	rgInput[3].ki.dwExtraInfo = 0;
	rgInput[3].ki.wVk = VK_RMENU;
	rgInput[3].ki.wScan = 0x38;

	//LCONTROL
	rgInput[4].type = INPUT_KEYBOARD;
	rgInput[4].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[4].ki.dwExtraInfo = 0;
	rgInput[4].ki.wVk = VK_LCONTROL;
	rgInput[4].ki.wScan = 0x1D;

	//RCONTROL
	rgInput[5].type = INPUT_KEYBOARD;
	rgInput[5].ki.dwFlags = KEYEVENTF_KEYUP|KEYEVENTF_EXTENDEDKEY;
	rgInput[5].ki.dwExtraInfo = 0;
	rgInput[5].ki.wVk = VK_RCONTROL;
	rgInput[5].ki.wScan = 0x1D;

	SendInput(6, rgInput, sizeof(INPUT));

} // FinishProcess
/******************************************************************************/
//  Explaination how Large and Small KB switching:
//  All the keys are sizing according to the size of the KB window. So change 
//  from Large KB to Small KB and make the KB to (2/3) of the original but 
//  same key size. We need to set the KB size to (2/3) first. But use the original
//  KB client window length to calculate "colMargin" to get the same key size.									                                         
/******************************************************************************/
BOOL BLDMenuCommand(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	HMENU	hMenu=NULL;
	RECT KBW_rect;
	RECT KBC_rect;
	static BOOL isTypeDlg = FALSE;
	static BOOL isFontDlg = FALSE;
	static BOOL isAboutDlg = FALSE;

	hMenu= GetMenu(hWnd);

	switch(wParam)
	{
	
	case IDM_Exit:
		return(BLDExitApplication(hWnd));      // Clean up if necessary
		break;

	case IDM_ALWAYS_ON_TOP:
		PrefAlwaysontop = kbPref->PrefAlwaysontop = !kbPref->PrefAlwaysontop;
		SetZOrder();
		break;

	case IDM_CLICK_SOUND:
		Prefusesound = kbPref->Prefusesound = !kbPref->Prefusesound;
		break;

	case IDM_LARGE_KB:
		if ( !smallKb )
			break;
		smallKb = kbPref->smallKb = FALSE;

		//For the 106 KB, we need to fix the position for the two extra Japanese keys
		if(kbPref->KBLayout == 106)
		{
			KBkey[100].posX = 78;
			KBkey[101].posX = 87;
		}

		//see explaination
		GetWindowRect(g_hwndOSK, &KBW_rect);
		MoveWindow(g_hwndOSK, KBW_rect.left, KBW_rect.top, (KBW_rect.right - KBW_rect.left) * 3 / 2, KBW_rect.bottom - KBW_rect.top, TRUE);
		break;

	case IDM_SMALL_KB:
		if ( smallKb )
			break;
		smallKb = kbPref->smallKb = TRUE;

		//For the 106 KB, we need to fix the position for the two extra Japanese keys
		if(kbPref->KBLayout == 106)
		{
			KBkey[100].posX = 64;
			KBkey[101].posX = 73;
		}

		//see explaination
		GetWindowRect(g_hwndOSK, &KBW_rect);
		GetClientRect(g_hwndOSK, &KBC_rect);
		
		g_KBC_length = (float)KBC_rect.right;

		g_KBC_length -= 12;

		MoveWindow(g_hwndOSK, KBW_rect.left, KBW_rect.top, (KBW_rect.right - KBW_rect.left) * 2 /3, KBW_rect.bottom - KBW_rect.top, TRUE);
		break;

	case IDM_REGULAR_LAYOUT:
		kbPref->Actual = TRUE;
		SwitchToActualKB();
		kbPref->KBLayout = 101;
		break;

	case IDM_BLOCK_LAYOUT:
		kbPref->Actual = FALSE;
		SwitchToBlockKB();
		kbPref->KBLayout = 101;
		break;

	case IDM_101_LAYOUT:
		kbPref->Actual ? SwitchToActualKB(): SwitchToBlockKB();
		kbPref->KBLayout = 101;
		break;

	case IDM_102_LAYOUT:
		SwitchToEuropeanKB();
		kbPref->KBLayout = 102;
		break;

	case IDM_106_LAYOUT:
		SwitchToJapaneseKB();
		kbPref->KBLayout = 106;
		break;

	case IDM_TYPE_MODE:
		if ( !isTypeDlg )
		{
			isTypeDlg = TRUE;

			Type_ModeDlgFunc(hWnd, message, wParam, lParam);

			isTypeDlg = FALSE;
		}
		break;

    case IDM_SET_FONT:
		if ( OSKRunSecure() )
			return FALSE;

		if ( !isFontDlg )
		{
			isFontDlg = TRUE;
			ChooseNewFont(hWnd);
			isFontDlg = FALSE;
			InvalidateRect(hWnd, NULL, TRUE);
		}
		break;

	case CM_HELPABOUT:
		if ( !isAboutDlg )
		{
			isAboutDlg = TRUE;
			AboutDlgFunc(hWnd, message, wParam, lParam);
			isAboutDlg = FALSE;
		}
		break;

	case CM_HELPTOPICS:
        if ( !OSKRunSecure() )
        {
            HtmlHelp(NULL, TEXT("osk.chm"), HH_DISPLAY_TOPIC, 0);
        }
		break;

	default:
		return FALSE;   
	}
	
	return TRUE;     
}
/******************************************************************************/
/* Called just before exit of application  */
/******************************************************************************/
BOOL BLDExitApplication(HWND hWnd)
{  
	//Automatic save setting when quit
	SaveUserSetting();  

	SendMessage(hWnd, WM_DESTROY, (WPARAM) NULL, (LPARAM) NULL);
	return TRUE;
}
/***********************************************************************/
// Set the Serial, LPT, Game ports to ON or OFF
// according to bSet
/***********************************************************************/
void ConfigPort(BOOL bSet)
{
	SWITCHCONFIG	Config;
	HSWITCHDEVICE	hsd;
	BOOL            fRv;

	//Set the Com port
	Config.cbSize = sizeof( SWITCHCONFIG );
	hsd = swchGetSwitchDevice( g_hSwitchPort, SC_TYPE_COM, 1 );
	swchGetSwitchConfig( g_hSwitchPort, hsd, &Config );

	if (SC_TYPE_COM == swchGetDeviceType( g_hSwitchPort, hsd ))
	{
		//Clear all the bits
		Config.dwFlags &= 0x00000000; 

		if(bSet)   //set it to active
			Config.dwFlags |= 0x00000001 ;
	}

	swchSetSwitchConfig( g_hSwitchPort, hsd, &Config );

	//Set the LPT port
	Config.cbSize = sizeof( SWITCHCONFIG );	
	hsd = swchGetSwitchDevice( g_hSwitchPort, SC_TYPE_LPT, 1 );

	// POSSIBLE ISSUE 03/26/01 micw There is a bug here.  swchGetSwitchConfig changes
	// Config.cbSize to 0.  This is happening in swchlpt.c in swcLptGetConfig() when it
	// copies static data from g_pGlobalData.  Is this area of shared memory getting trashed? 
    // It doesn't cause any apparent problem for the user so I didn't look at it more closely.
    
	fRv = swchGetSwitchConfig( g_hSwitchPort, hsd, &Config );

	if (SC_TYPE_LPT == swchGetDeviceType( g_hSwitchPort, hsd ))
	{
		
		//Clear all the bits
		Config.dwFlags &= 0x00000000; 

		if(bSet)   //set it to active
			Config.dwFlags |= 0x00000001 ;
	}

	swchSetSwitchConfig( g_hSwitchPort, hsd, &Config );

	//Set the Game port
	Config.cbSize = sizeof( SWITCHCONFIG );
	hsd = swchGetSwitchDevice( g_hSwitchPort, SC_TYPE_JOYSTICK, 1 );
	swchGetSwitchConfig( g_hSwitchPort, hsd, &Config );

	if (SC_TYPE_JOYSTICK == swchGetDeviceType( g_hSwitchPort, hsd ))
	{
		//Clear all the bits
		Config.dwFlags &= 0x00000000; 
		
		if(bSet)   //set it to active
			Config.dwFlags |= 0x00000001 ;

		Config.u.Joystick.dwJoySubType = SC_JOY_XYSWITCH;
		Config.u.Joystick.dwJoyThresholdMinX = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMaxX = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMinY = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMaxY = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyHysteresis = SC_JOYVALUE_DEFAULT;
	}

	swchSetSwitchConfig( g_hSwitchPort, hsd, &Config );
}
/***********************************************************************/
// Set the Switch key to active
// Given the vk, set the switch key to the given vk
/***********************************************************************/
void ConfigSwitchKey(UINT vk, BOOL bSet)
{
	SWITCHCONFIG	Config;
	HSWITCHDEVICE	hsd;

	Config.cbSize = sizeof( SWITCHCONFIG );
	hsd = swchGetSwitchDevice( g_hSwitchPort, SC_TYPE_KEYS, 1 );
	swchGetSwitchConfig( g_hSwitchPort, hsd, &Config );

	//Set the Switch Key active and Set the Switch Key as 'vk' pass in as one param
	if (SC_TYPE_KEYS == swchGetDeviceType( g_hSwitchPort, hsd ))
	{
		//Clear all the bits
		Config.dwFlags &= 0x00000000; 

		if(bSet)   //set it to active
			Config.dwFlags |= 0x00000001 ;

		Config.u.Keys.dwKeySwitch1 = MAKELONG( vk, 0 );
	}

	if (SC_TYPE_JOYSTICK == swchGetDeviceType( g_hSwitchPort, hsd ))
	{
		//Clear all the bits
		Config.dwFlags &= 0x00000000; 
		
		//set it to active
		Config.dwFlags |= 0x00000001 ;

		Config.u.Joystick.dwJoySubType = SC_JOY_XYSWITCH;
		Config.u.Joystick.dwJoyThresholdMinX = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMaxX = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMinY = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMaxY = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyHysteresis = SC_JOYVALUE_DEFAULT;
	}

	swchSetSwitchConfig( g_hSwitchPort, hsd, &Config );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\kbmain.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// KBMAIN.C 
// Additions, Bug Fixes 1999
// a-anilk, v-mjgran
//  
#define STRICT

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include <crtdbg.h>
#include "kbmain.h"
#include "Init_End.h"     // all the functions, buttons control for dialogs
#include "kbus.h"
#include "resource.h"
#include "htmlhelp.h"
#include "Msswch.h"
#include "About.h"
#include "door.h"
#include "w95trace.c"
#include "DeskSwitch.c"
#include <objbase.h>
#include "wtsapi32.h"   // for terminal services

/**************************************************************************/
// FUNCTIONS IN THIS FILE
/**************************************************************************/
static BOOL  AssignDesktop(LPDWORD desktopID, LPTSTR pname);
static BOOL InitMyProcessDesktopAccess(VOID);
static VOID ExitMyProcessDesktopAccess(VOID);
void DoButtonUp(HWND hwndKey);

/**************************************************************************/
// FUNCTIONS CALLED FROM THIS FILE
/**************************************************************************/
#include "sdgutil.h"
#include "kbfunc.h"
#include "scan.h"
#include "ms32dll.h"
#include "fileutil.h"

/**************************************************************************/
// global initial (YUK!)
/**************************************************************************/
extern LPKBPREFINFO  lpkbPref = NULL;                    // Pointer to Preferences KB structure
extern LPKBPREFINFO  lpkbDefault = NULL;                 // ditto Default
extern HWND          *lpkeyhwnd = NULL;                  // ptr to array of HWND
extern HWND          numBasehwnd = NULL;                 // HWND to the num base window
extern HWND          g_hwndOSK = NULL;                   // HWND to the kbmain window
extern int           lenKBkey = 0;                       // How Many Keys?
extern int           scrCY = 0;                          // Screen Height
extern int           scrCX = 0;                          // Screen Width
extern int           captionCY = 0;                      // Caption Bar Height
extern int           g_margin = 0;                       // Margin between rows and columns
extern BOOL          smallKb = FALSE;                    // TRUE when working with Small Keyboard
extern BOOL          PrefAlwaysontop = TRUE;             // Always on Top control
extern int           PrefDeltakeysize = 2;               // Preference increment in key size
extern BOOL          PrefshowActivekey = TRUE;           // Show cap letters in keys
extern int           KBLayout = 101;                     // 101, 102, 106, KB layout
extern BOOL          Prefusesound = FALSE;               // Use click sound
extern BOOL          newFont = FALSE;                    // Font is changed
extern HGDIOBJ       oldFontHdle = NULL;                 // Old object handle
extern LOGFONT       *plf = NULL;                        // pointer to the actual char font
extern COLORREF      InvertTextColor = 0xFFFFFFFF;       // Font color on inversion
extern COLORREF      InvertBKGColor = 0x00000000;        // BKG color on inversion
extern BOOL          Prefhilitekey = TRUE;               // True for hilite key under cursor
// Dwelling time control variables
extern BOOL          PrefDwellinkey = FALSE;             // use dwelling system
extern UINT          PrefDwellTime = 1000;               // Dwell time preference  (ms)

extern BOOL          PrefScanning = FALSE;               // use scanning
extern UINT          PrefScanTime = 1000;                // Prefer scan time

extern BOOL          g_fShowWarningAgain = 1;            // Show initial warning dialog again

extern HWND          Dwellwindow = NULL;                 // dwelling window HANDLE
                                                         
extern int           stopPaint = FALSE;                  // stop the bucket paint on keys
                                                         
extern UINT_PTR      timerK1 = 0;                        // timer id
extern UINT_PTR      timerK2 = 0;                        // timer for bucket

BOOL                 g_fShiftKeyDn = FALSE;              // TRUE if the SHIFT key is down
BOOL                 g_fCapsLockOn = FALSE;				 // TRUE if the CAPSLOCK is on
BOOL				 g_fRAltKey    = FALSE;			     // TRUE if the right ALT key is down
BOOL				 g_fLAltKey    = FALSE;			     // TRUE if the left ALT key is down
BOOL                 g_fLCtlKey    = FALSE;              // TRUE if the left CTRL key is donw
BOOL                 g_fKanaKey    = FALSE;              // TRUE if Kana key is down
extern HWND          g_hBitmapLockHwnd;

extern HINSTANCE     hInst = NULL;
extern KBPREFINFO    *kbPref = NULL;
extern HWND			 g_hwndDwellKey;
HANDLE               g_hMutexOSKRunning;
DWORD				 platform = 1;

// Global variable to indicate if it was started from UM
extern BOOL			g_startUM = FALSE;
UINT taskBarStart;

static HWINSTA origWinStation = NULL;
static HWINSTA userWinStation = NULL;

// For Link Window
EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
DWORD GetDesktop();

BOOL OSKRunSecure()
{
	return RunSecure(GetDesktop());
}

// stuff to keep our window inactive while using the soft keyboard
void SetFocusToInputWindow();
void TrackActiveWindow();
HWND g_hwndInputFocus = NULL;   // the window we are inputting to

// stuff for the message ballontip
#define  MAX_TOOLTIP_SIZE  256
TOOLINFO ti;
HWND     g_hToolTip;

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))
#endif

__inline void HighlightKey(HWND hwnd)
{
    if (Prefhilitekey)
    {
        InvertColors(hwnd, TRUE);
    }
    if (PrefDwellinkey)
    {
        killtime();
        SetTimeControl(hwnd);
    }
}

// IsSystem - Returns TRUE if our process is running as SYSTEM
//
BOOL IsSystem()
{
    BOOL fStatus = FALSE;
    BOOL fIsLocalSystem = FALSE;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
    PSID psidSystem;
    if (!AllocateAndInitializeSid(&siaLocalSystem, 
                                            1,
                                            SECURITY_LOCAL_SYSTEM_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &psidSystem))
    {			
    	return FALSE;
    }

    if (psidSystem) 
    {
    	fStatus = CheckTokenMembership(NULL, psidSystem, &fIsLocalSystem);
    }

    return (fStatus && fIsLocalSystem);
}


/****************************************************************************/
/* LRESULT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,     */
/*                   LPSTR lpCmdLine, int nCmdShow)                    */
/****************************************************************************/
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	MSG  msg;
	TCHAR szToolTipText[MAX_TOOLTIP_SIZE];
	LPTSTR lpCmdLineW = GetCommandLine();
	DWORD desktopID;  // For utilman
	TCHAR name[300];

	if (NULL != lpCmdLineW && lstrlen(lpCmdLineW))
	{
		g_startUM = (lstrcmpi(lpCmdLineW, TEXT("/UM")) == 0)?TRUE:FALSE;
	}

	SetLastError(0);

	// Allow only ONE instance of the program running.

	g_hMutexOSKRunning = CreateMutex(NULL, TRUE, TEXT("OSKRunning"));
	if ((g_hMutexOSKRunning == NULL) || (GetLastError() == ERROR_ALREADY_EXISTS))
	{
		return 0;  // Exit without starting
	}

	taskBarStart = RegisterWindowMessage(TEXT("TaskbarCreated"));

	platform = WhatPlatform();	// note the OS

	hInst = hInstance;

	GetPreferences();	// load the setting file and init setting

   //************************************************************************
   // 
   // The following two calls initialize the desktop so that, if we are on
   // the Winlogon desktop (secure desktop) our UI will display.  Do not
   // cause any windows to be created (eg. CoInitialize) prior to calling
   // these functions.  Doing so will cause them to fail and the application
   // will not appear on the Winlogon desktop.
   //
   InitMyProcessDesktopAccess();
   AssignDesktop(&desktopID, name);

    //  the only place it is ok to run as system is on the DESKTOP_WINLOGON desktop.  If that is
    //  not where we are than get out before we cause any security problems
    if (DESKTOP_WINLOGON !=  desktopID && IsSystem())
    {
        if ( g_hMutexOSKRunning ) 
        	ReleaseMutex(g_hMutexOSKRunning);
	ExitMyProcessDesktopAccess();
	return 0;
    }
    
   //************************************************************************

   // for the Link Window in about dialog (requires COM initialization)...
   CoInitialize(NULL);
   LinkWindow_RegisterClass();

   if (!InitProc())
      return 0;

   InitKeys();
   UpdateKeyLabels(GetCurrentHKL());

   RegisterWndClass(hInst);

   mlGetSystemParam();              // Get system parameters

   g_hwndOSK = CreateMainWindow(FALSE);

   if (g_hwndOSK == NULL)
   {
      SendErrorMessage(IDS_CANNOT_CREATE_KB);
      return 0;
   }

   SetZOrder();                     // Set the main window position (topmost/non-topmost)
 
   DeleteChildBackground();         // Init all the keys color before showing them

   // Show the window but don't activate

   ShowWindow(g_hwndOSK, SW_SHOWNOACTIVATE);
   UpdateWindow (g_hwndOSK);
   TrackActiveWindow();

   InitCommonControls();
     
   //Create the help balloon
   g_hToolTip = CreateWindowEx(
					WS_EX_TOPMOST,
					TOOLTIPS_CLASS, 
					NULL, 
					WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
                    0, 0, 
					0, 0, 
					NULL, NULL, 
					hInstance, NULL);

   if (g_hToolTip)
   {
      ti.cbSize = sizeof(ti);
      ti.uFlags = TTF_TRANSPARENT | TTF_CENTERTIP | TTF_TRACK;
      ti.hwnd = g_hwndOSK;
      ti.uId = 0;
      ti.hinst = hInstance;
      
      LoadString(hInstance, IDS_TOOLTIP, szToolTipText, MAX_TOOLTIP_SIZE);
      ti.lpszText = szToolTipText;
      
      SendMessage(g_hToolTip, TTM_ADDTOOL, 0, (LPARAM) &ti );
   }

   Create_The_Rest(lpCmdLine, hInstance);

   // check if there is necessary to show the initial warning msg
   if (g_fShowWarningAgain && !OSKRunSecure())
   {
      WarningMsgDlgFunc(g_hwndOSK);
   }

    // main message loop
   while (GetMessage(&msg, 0, 0, 0))
   {
        TranslateMessage(&msg); /* Translates character keys             */
        DispatchMessage(&msg);  /* Dispatches message to window          */
   }

   ExitMyProcessDesktopAccess();   // utilman

   UninitKeys();
   CoUninitialize();

// check for leaks
#ifdef _DEBUG
   _CrtDumpMemoryLeaks();
#endif

   return((int)msg.wParam);
}

/****************************************************************************/
extern BOOL  Setting_ReadSuccess;    //read the setting file success ?

BOOL ForStartUp1=TRUE;
BOOL ForStartUp2=TRUE;

float g_KBC_length = 0;









/*****************************************************************************/
//
//  kbMainWndProc
//  Explain how Large and Small KB switching:
//  All the keys are sizing according to the size of the KB window. So change
//  from Large KB to Small KB and make the KB to (2/3) of the original but
//  same key size. We need to set the KB size to (2/3) first. But use the 
//  original KB client window length to calculate "colMargin" to get the same
//  key size.
/*****************************************************************************/
LRESULT WINAPI kbMainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int  i;
	static   int  oldWidth  = 0;
	static   int  oldHeight = 0;
	TCHAR    Wclass[50]=TEXT("");
	BOOL     isvisible;
	RECT     rect, rectC;
	int      rmargin, bmargin;          //will set to smallest width and height
	LONG_PTR dwExStyle;
	HWND     hwndMouseOver;
	POINT    pt;
	static  BOOL  s_fGotMouseDown = FALSE;    // TRUE if there's been a button down on a key
	static  HWND  s_hwndLastMouseOver = NULL; // handle to last key hwnd under mouse or NULL
	static  BOOL s_fIgnoreSizeMsg=FALSE;      // avoid looping because of sizing
	//
	// rowMargin is the ratio to the smallest height(KB_CHARBMARGIN)
	// e.g. rowMargin=4 means the current KB height is 4 * KB_CHARBMARGIN
	//
    float rowMargin, colMargin; 

   switch (message)
   {
      case WM_CREATE:
         if (lpkeyhwnd==NULL)
		 {
            lpkeyhwnd = LocalAlloc(LPTR, sizeof(HWND) * lenKBkey);
		 }

         if (!lpkeyhwnd)
         {
             SendErrorMessage(IDS_MEMORY_LIMITED);
             break;
         }
         
         // set the CapsLock flag On or Off

		 g_fCapsLockOn = (LOBYTE(GetKeyState(VK_CAPITAL)) & 0x01)?TRUE:FALSE;

         // Turn off mirroring while creating the keyboard keys

         dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
         SetWindowLongPtr(hwnd, GWL_EXSTYLE, dwExStyle & ~WS_EX_LAYOUTRTL); 

         for (i = 1; i < lenKBkey; i++)
         {
            switch (KBkey[i].ktype)
            {
                case KNORMAL_TYPE:      wsprintf(Wclass, TEXT("N%d"), i);  break;
                case KMODIFIER_TYPE:    wsprintf(Wclass, TEXT("M%d"), i);  break;
                case KDEAD_TYPE:        wsprintf(Wclass, TEXT("D%d"), i);  break;
                case NUMLOCK_TYPE:      wsprintf(Wclass, TEXT("NL%d"), i); break;
                case SCROLLOCK_TYPE:    wsprintf(Wclass, TEXT("SL%d"), i); break;
            }
            
            // Show only the keys that are supposed to show for this keyboard type

            if (((smallKb == TRUE) && (KBkey[i].smallKb == SMALL)) ||
                ((smallKb == FALSE) && (KBkey[i].smallKb == LARGE)) ||
                 (KBkey[i].smallKb == BOTH))
            {
               isvisible = TRUE;   //Show this key
            }
            else
            {
               isvisible = FALSE;  //Hide this key
            }

            lpkeyhwnd[i] = CreateWindow(
                                    Wclass, 
                                    KBkey[i].textC,
                                    WS_CHILD|(WS_VISIBLE * isvisible)|BS_PUSHBUTTON|WS_CLIPSIBLINGS|WS_BORDER,
                                    KBkey[i].posX * g_margin,
                                    KBkey[i].posY * g_margin,
                                    KBkey[i].ksizeX * g_margin + PrefDeltakeysize,
                                    KBkey[i].ksizeY * g_margin + PrefDeltakeysize,
                                    hwnd, 
                                    (HMENU)IntToPtr(i), 
                                    hInst, NULL);

            if (lpkeyhwnd[i] == NULL)
            {
               DBPRINTF(TEXT("WM_CREATE:  Error %d creating key %s\r\n"), GetLastError(), KBkey[i].apszKeyStr[0]);
               SendErrorMessage(IDS_CANNOT_CREATE_KEY);
               break;
            }
         }

         // Restore mirroring to main window
         SetWindowLongPtr(hwnd, GWL_EXSTYLE, dwExStyle);

         // Watch for desktop switches (eg user hits Ctrl+Alt+Del).
         // Note:  even with FUS we get desktop switch notification
         // and we get the notification before we get the disconnect
         // notification from TS.

         InitWatchDeskSwitch(hwnd, WM_USER + 2);
         return 0;
         break;

      case WM_USER + 2:
         // When the desktop changes, if UtilMan is running exit.  
         // UtilMan will start us up again if necessary.
         if (IsUtilManRunning() /*&& CanLockDesktopWithoutDisconnect()*/)
         {
             BLDExitApplication(hwnd);  // this sends WM_DESTROY
         } 
         return 0;
         break;

      // This is a message from the global keyboard hook
      case WM_GLOBAL_KBDHOOK:
         KeybdInputProc(wParam, lParam);
		 return 0;
         break;


      // The WS_EX_NOACTIVATE style bit only stops us from being activated when the
      // focus belongs to a window of another thread. We have to use this message to
      // stop the OSK window from taking focus from other windows on our thread - ie.
      // the Font and Typing Mode dialogs.
      // Don't allow this window to be activated if it's a click over the client area.
      // non-Client - menus, caption bar, etc - is ok.
      case WM_MOUSEACTIVATE:
      {
         if( LOWORD( lParam ) == HTCLIENT )
             return MA_NOACTIVATE;
         else
             return MA_ACTIVATE;
      }

         
      //
	  // WM_SETCURSOR is sent whether we are activated or not.  We use it to determine
	  // if the mouse is over the keyboard (client area) of OSK.  If so, we force the
	  // the foreground window to be the target input window.  If the mouse is over
	  // the caption or menu area then we activate the OSK window so menus and dragging
	  // work.
	  //

	  case WM_SETCURSOR:
		  {
			  WORD  wHitTestValue;
			  // Get hit test and button state information

			  wHitTestValue = LOWORD(lParam);
			  s_fGotMouseDown = (HIWORD(lParam) == WM_LBUTTONDOWN);

			  // Keep track of the active window (the one we're inputting to)

			  TrackActiveWindow();

			  // If the cursor is not in the client area, reset the button colors.
              // If it's a click, activate the OSK window so that the click (which is
              // probably for the menu, caption, etc.) will work. We need to do
              // this since the window has the WS_EX_NOACTIVATE style, so we have
              // to explicitly activate the window ourselves when we need to.

			  if( ! ( wHitTestValue == HTCLIENT ) )
			  {
				  ReturnColors(s_hwndLastMouseOver, TRUE); 
                  s_hwndLastMouseOver = NULL;

                  if( s_fGotMouseDown )
                  {
                      SetForegroundWindow( hwnd );
                  }

				  return DefWindowProc(hwnd, message, wParam, lParam);
			  } 

              SetFocusToInputWindow();

			  // if the input language changes this fn changes the keyboard

			  RedrawKeysOnLanguageChange();

			  // cursor is over the main window client area; see if we are on one of the keys

			  GetCursorPos(&pt);
			  ScreenToClient(hwnd, &pt);
			  hwndMouseOver = ChildWindowFromPointEx(hwnd, pt, CWP_SKIPINVISIBLE);

              // at this point if:
              //
              // hwndMouseOver == NULL then cursor is nowhere of interest
              // hwndMouseOver == hwnd then cursor is on main window
              // hwndMouseOver != hwnd then cursor is on a key

              if (hwndMouseOver && hwndMouseOver != hwnd)
              {
                  SetCursor(LoadCursor(NULL, IDC_HAND));

				  // if the mouse button is down on a key capture the
				  // mouse so we know if it goes up w/in the same key

				  if (s_fGotMouseDown)
				  {
					  SetCapture(hwnd);
				  }

                  // if cursor is in a new key then update highlighting

			      if (s_hwndLastMouseOver != hwndMouseOver)
			      {
					  ReturnColors(s_hwndLastMouseOver, TRUE); 
				   
				      g_hwndDwellKey = Dwellwindow = hwndMouseOver;

                      HighlightKey(hwndMouseOver);		   // highlight this key based on user settings

		              s_hwndLastMouseOver = hwndMouseOver; // save this key hwnd
			      }
              } 
              else if (hwndMouseOver == hwnd)
              {
                  SetCursor(LoadCursor(NULL, IDC_ARROW));
              }
		  }
		  return 0;
		  break;

      case WM_LBUTTONUP:
		  if (s_fGotMouseDown)
		  {
			  ReleaseCapture();	         // Release the mouse if we've captured it
			  s_fGotMouseDown = FALSE;
		  }

		  pt.x = GET_X_LPARAM(lParam);   // lParam has cursor coordinates
          pt.y = GET_Y_LPARAM(lParam);   // relative to client area 

		  hwndMouseOver = ChildWindowFromPointEx(hwnd, pt, CWP_SKIPINVISIBLE);

		  // if the button down was w/in this key window send the
          // char else restore the last key to normal

		  if (hwndMouseOver && s_hwndLastMouseOver == hwndMouseOver)
		  {
              SendChar(hwndMouseOver);
              s_hwndLastMouseOver = NULL;
		  }
          else
          {
			  ReturnColors(s_hwndLastMouseOver, TRUE); 
              s_hwndLastMouseOver = hwndMouseOver;
          }
		  return 0;
		  break;

      case WM_RBUTTONDOWN:
          KillScanTimer(TRUE); // stop scanning
		  return 0;
          break;

      case WM_SIZE:

		  if (!s_fIgnoreSizeMsg)
		  {  
			 int KB_SMALLRMARGIN= 137;

			 GetClientRect(g_hwndOSK, &rectC);
			 GetWindowRect(g_hwndOSK, &rect);

			 if ((oldWidth == rect.right) && (oldHeight == rect.bottom))
				return 0;

			 bmargin  = KB_CHARBMARGIN;      //smallest height

			 // SmallMargin for Actual / Block layout
			 KB_SMALLRMARGIN = (kbPref->Actual) ? KB_LARGERMARGIN:224; // actual:block

			 rmargin = (smallKb == TRUE) ? KB_SMALLRMARGIN:KB_LARGERMARGIN;

			 if (smallKb && ForStartUp1)   //Start up with Small KB
			 {
				 //why - 10? -> The number doesnt really match the origianl size, so - 10
				 colMargin = ((float)rectC.right * 3 / 2 - 10) / (float)rmargin;
			 }
			 else if (smallKb)			   //Small KB but NOT at start up
			 {
				 colMargin = g_KBC_length / (float)rmargin;
			 }
			 else						   //Large KB
			 {
				 //rmargin is smallest width; colMargin is the ratio; see explain
				 colMargin = (float)rectC.right / (float)rmargin; 
			 }

			 //bmargin is smallest height; rowMargin is the ratio; see explain
			 rowMargin = (float)rectC.bottom  / (float)bmargin;  

			 // place to the right place on screen at STARTUP TIME

			 if (ForStartUp1 && !Setting_ReadSuccess)    
			 {
				// At StartUp and CANNOT read setting file position at lower left
				ForStartUp1= FALSE;
				s_fIgnoreSizeMsg= TRUE;

				rect.bottom = rect.bottom - (rectC.bottom - ((int)rowMargin * bmargin));
				rect.right = rect.right - (rectC.right - ((int)colMargin * rmargin));

				MoveWindow(
					g_hwndOSK, 
					rect.left, 
					scrCY-30-(rect.bottom - rect.top),
					rect.right - rect.left,
					rect.bottom - rect.top,  
					TRUE);
			 }
			 else if (ForStartUp1 && Setting_ReadSuccess)
			 {  
				// At StartUp and can read setting file position at last position
				ForStartUp1= FALSE;
				s_fIgnoreSizeMsg= TRUE;           

				// Check to see the KB is  not out of screen with the current resolution

				if (IsOutOfScreen(scrCX, scrCY))
				{
				   MoveWindow(
					   g_hwndOSK, 
					   scrCX/2 - (kbPref->KB_Rect.right - kbPref->KB_Rect.left)/2,
					   scrCY - 30 - (kbPref->KB_Rect.bottom - kbPref->KB_Rect.top),
					   kbPref->KB_Rect.right - kbPref->KB_Rect.left,
					   kbPref->KB_Rect.bottom - kbPref->KB_Rect.top, 
					   TRUE);
				}
				else
				{
				   MoveWindow(g_hwndOSK, 
					   kbPref->KB_Rect.left,
					   kbPref->KB_Rect.top,
					   kbPref->KB_Rect.right - kbPref->KB_Rect.left,
					   kbPref->KB_Rect.bottom - kbPref->KB_Rect.top,
					   TRUE);
				}
			 }

			 s_fIgnoreSizeMsg = FALSE;

			 oldWidth = rect.right;
			 oldHeight = rect.top;

			 // Turn off mirroring while positioning the buttons

			 dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
			 SetWindowLongPtr(hwnd, GWL_EXSTYLE, dwExStyle & ~WS_EX_LAYOUTRTL); 

			 // Positon the keys
			 for (i = 1 ; i < lenKBkey ; i++)
			 {
				int w, h;   //width and height of each window key
            
				// *** show / not show the keys between small/large keyboard
				if (((smallKb == TRUE) && (KBkey[i].smallKb == SMALL)) ||
				   ((smallKb == FALSE) && (KBkey[i].smallKb == LARGE)) ||
					(KBkey[i].smallKb == BOTH))
				{
				   ShowWindow(lpkeyhwnd[i], SW_SHOW);
				}
				else
				{
				   ShowWindow(lpkeyhwnd[i], SW_HIDE);
				}

				if (ForStartUp2 && !Setting_ReadSuccess)
				{
					// At StartUp and cant read setting file move keys based on defaults
					MoveWindow(lpkeyhwnd[i],   
							KBkey[i].posX * (int)colMargin,
							KBkey[i].posY * (int)rowMargin,
							KBkey[i].ksizeX * (int)colMargin + PrefDeltakeysize,
							KBkey[i].ksizeY * (int)rowMargin + PrefDeltakeysize,
							TRUE);
				}
				else
				{  
					// At not startup / at startup and can read setting file use save position
					MoveWindow(lpkeyhwnd[i],
							(int)((float)KBkey[i].posX * colMargin),
							(int)((float)KBkey[i].posY * rowMargin),
							(int)((float)KBkey[i].ksizeX * colMargin) + PrefDeltakeysize,
							(int)((float)KBkey[i].ksizeY * rowMargin) + PrefDeltakeysize,
							TRUE);
				}

				w = (int) ((KBkey[i].ksizeX * colMargin) + PrefDeltakeysize);
				h = (int) ((KBkey[i].ksizeY * rowMargin) + PrefDeltakeysize);

				SetKeyRegion(lpkeyhwnd[i], w, h);  //set the region we want for each key

			 }   //end for each key loop

			 // restore mirroring on main window
			 SetWindowLongPtr(hwnd, GWL_EXSTYLE, dwExStyle); 

			 ForStartUp2= FALSE;
		  }  // s_fIgnoreSizeMsg

		  if (!IsIconic(g_hwndOSK))
		  {
			 GetWindowRect(g_hwndOSK, &kbPref->KB_Rect);
		  }

		  return 0;

      case WM_SHOWWINDOW:
         RedrawNumLock();   //Hilit the NUMLOCK key if it is on
         RedrawScrollLock();//hilite the Scroll Key if it is on
		 return 0;

      case WM_MOVE:
         if (!IsIconic(g_hwndOSK))
		 {
            GetWindowRect(g_hwndOSK, &kbPref->KB_Rect);   //Save the KB position
		 }
         return 0;

      //When user drags the keyboard or re-size
      case WM_ENTERSIZEMOVE:
         return 0;

      //When user finishes dragging or re-sizing
      case WM_EXITSIZEMOVE:
		 SetFocusToInputWindow();
         return 0;

      case WM_COMMAND:
         BLDMenuCommand(hwnd, message, wParam, lParam);
         break;

      case WM_CLOSE:
         return BLDExitApplication(hwnd);

      case WM_QUERYENDSESSION:
         return TRUE;

      case WM_ENDSESSION:
      {
          // forced to end; make osk start up again next time user logs on
          HKEY hKey;
          DWORD dwPosition;
          const TCHAR szSubKey[] =  __TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
          const TCHAR szImageName[] = __TEXT("OSK.exe");

          BLDExitApplication(hwnd);

          if ( ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szSubKey, 0, NULL,
             REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKey, &dwPosition))
          {
             RegSetValueEx(hKey, NULL, 0, REG_SZ, (CONST BYTE*)szImageName, (lstrlen(szImageName)+1)*sizeof(TCHAR) );
             RegCloseKey(hKey);
          }
      }
      return 0;
      
      case WM_TIMER:
		 KillTimer(hwnd, TIMER_HELPTOOLTIP);
		 SendMessage(g_hToolTip,TTM_TRACKACTIVATE,(WPARAM)FALSE,(LPARAM)&ti);
	     break;

      case WM_DESTROY:            /* window being destroyed                   */
         TermWatchDeskSwitch();
         FinishProcess();
         PostQuitMessage(0);
         return TRUE;

      case WM_USER + 1:
         Scanning(1);  // Start scanning again
         return TRUE;

      case WM_INITMENUPOPUP:
      {
         HMENU hMenu = (HMENU) wParam;

         CheckMenuItem(hMenu, IDM_ALWAYS_ON_TOP, (PrefAlwaysontop ? MF_CHECKED : MF_UNCHECKED));
         CheckMenuItem(hMenu, IDM_CLICK_SOUND, (Prefusesound ? MF_CHECKED : MF_UNCHECKED));

         //Small or Large KB
         if (kbPref->smallKb)
         {        
            CheckMenuRadioItem(hMenu, IDM_LARGE_KB, IDM_SMALL_KB, IDM_SMALL_KB, MF_BYCOMMAND);
         }
         else
         {
            CheckMenuRadioItem(hMenu, IDM_LARGE_KB, IDM_SMALL_KB, IDM_LARGE_KB, MF_BYCOMMAND);
         }

         //Regular or Block Layout
         if (kbPref->Actual)
         {
            CheckMenuRadioItem(hMenu, IDM_REGULAR_LAYOUT, IDM_BLOCK_LAYOUT, IDM_REGULAR_LAYOUT, MF_BYCOMMAND);

            // enable the 102, 106 menu 
            EnableMenuItem(hMenu, IDM_102_LAYOUT, MF_ENABLED);
            EnableMenuItem(hMenu, IDM_106_LAYOUT, MF_ENABLED);
         }
         else   //Block layout 
         {
            CheckMenuRadioItem(hMenu, IDM_REGULAR_LAYOUT, IDM_BLOCK_LAYOUT, IDM_BLOCK_LAYOUT, MF_BYCOMMAND);

            //Disable the 102, 106 menu
            EnableMenuItem(hMenu, IDM_102_LAYOUT, MF_GRAYED);
            EnableMenuItem(hMenu, IDM_106_LAYOUT, MF_GRAYED);
         }

         switch (kbPref->KBLayout)
         {
             case 101:
                CheckMenuRadioItem(hMenu,IDM_101_LAYOUT, IDM_106_LAYOUT, IDM_101_LAYOUT, MF_BYCOMMAND);
      
                //disable these two menus
                EnableMenuItem(hMenu, IDM_REGULAR_LAYOUT, MF_ENABLED);
                EnableMenuItem(hMenu, IDM_BLOCK_LAYOUT, MF_ENABLED);
                break;

             case 102:
                CheckMenuRadioItem(hMenu,IDM_101_LAYOUT, IDM_106_LAYOUT, IDM_102_LAYOUT, MF_BYCOMMAND);
      
                //disable these two menus
                EnableMenuItem(hMenu, IDM_REGULAR_LAYOUT, MF_GRAYED);
                EnableMenuItem(hMenu, IDM_BLOCK_LAYOUT, MF_GRAYED);
                break;

             case 106:
                CheckMenuRadioItem(hMenu,IDM_101_LAYOUT, IDM_106_LAYOUT, IDM_106_LAYOUT, MF_BYCOMMAND);
      
                //disable these two menus
                EnableMenuItem(hMenu, IDM_REGULAR_LAYOUT, MF_GRAYED);
                EnableMenuItem(hMenu, IDM_BLOCK_LAYOUT, MF_GRAYED);
                break;
         }

		 // Disable help menus on all but default desktop
		 if ( OSKRunSecure() )
		 {
              EnableMenuItem(hMenu, CM_HELPABOUT, MF_GRAYED);
              EnableMenuItem(hMenu, CM_HELPTOPICS, MF_GRAYED);
		 }
		  return 0;
      }


      case WM_HELP:
          if ( !OSKRunSecure() )
          {
              HtmlHelp(NULL, TEXT("osk.chm"), HH_DISPLAY_TOPIC, 0);
          }
          return TRUE;

		// SW_SWITCH1DOWN is posted from msswch by swchPostSwitches()
		// when the key to start scanning is pressed
        case SW_SWITCH1DOWN:
            if (PrefScanning)
            {
                // Keep track of the active window (the one we're inputting
                // to) and redraw keys if the input language changes
                TrackActiveWindow();
                RedrawKeysOnLanguageChange();

                Scanning(1);
            }
            break;

		default:
			break;
   }
   return DefWindowProc (hwnd, message, wParam, lParam) ;
}


/*****************************************************************************/
/* LRESULT WINAPI kbKeyWndProc (HWND hwndKey, UINT message, WPARAM wParam, */
/*                       LPARAM lParam)                              */
/* BitMap Additions : a-anilk: 02-16-99                               */
/*****************************************************************************/
LRESULT WINAPI kbKeyWndProc (HWND hwndKey, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC         hdc ;
    PAINTSTRUCT ps ;
    RECT        rect;
    int         iKey, iKeyCookie;
	KBkeyRec    *pKey;

    iKey = GetWindowLong(hwndKey, GWL_ID);  //order of the key in the array
	pKey = KBkey + iKey;
    switch (message)
    {
        case WM_CREATE:
            SetWindowLong(hwndKey, 0, 0) ;       // on/off flag
            return 0 ;

        case WM_PAINT:
            hdc = BeginPaint(hwndKey, &ps);
            GetClientRect(hwndKey, &rect);
            iKeyCookie = GetWindowLong(hwndKey,0);

            switch(iKeyCookie)
            {
                case 0:           //*** Normal Button ***
                if (pKey->name == BITMAP)
                {
                    // Draw bitmaps
                    if (CapsLockIsOn() && pKey->scancode[0] == CAPLOCK_SCANCODE)
                    {
                            SetWindowLong(hwndKey, 0, 1);
                            SetClassLongPtr(hwndKey, GCLP_HBRBACKGROUND, 
                                         (LONG_PTR)CreateSolidBrush(RGB(0,0,0)));

                            InvalidateRect(hwndKey, NULL, TRUE);

                            RDrawBitMap(hdc, pKey->skLow, rect, FALSE);
                            g_hBitmapLockHwnd = hwndKey;
                    }
                    else
                    {
                        RDrawBitMap(hdc, pKey->textL, rect, TRUE);
                    }
                }

                if (pKey->name == ICON)
                {
                    RDrawIcon(hdc, pKey->textL, rect);
                }
                break;

                case 1:          //*** Button down ***
                if (pKey->name == BITMAP)
                {
                    RDrawBitMap(hdc, pKey->skLow, rect, TRUE);
                }

                if (pKey->name == ICON)
                {
                    RDrawIcon(hdc, pKey->textC, rect);
                }
                break;

                case 4:         //*** highlight key while moving around  
                if (!PrefScanning)
                {
                    udfDraw3Dpush(hdc, rect);
                }

                if (pKey->name == ICON)
                {
                    RDrawIcon(hdc, pKey->skLow, rect);
                }
                else if (pKey->name == BITMAP)
                {
                    RDrawBitMap(hdc, pKey->skLow, rect, FALSE);
                }
                break;

                case 5:          //*** Dwell (scan mode) ***
                PaintLine(hwndKey, hdc, rect);
                EndPaint(hwndKey, &ps);

                if (pKey->name != BITMAP)
                {
                    SetWindowLong(Dwellwindow, 0, 1);
                }
                else
                {
                    SetWindowLong(Dwellwindow, 0, 4);
                }

                return 0;
            }

            if (iKeyCookie != 4)
            {
                iKeyCookie = 0;
            }

            // Print the text on each button ignoring icons and bitmaps

            if(pKey->name != ICON && pKey->name != BITMAP)
            {
                UpdateKey(hwndKey, hdc, rect, iKey, iKeyCookie);
            }
            EndPaint(hwndKey, &ps);
            return 0;

        default:
            break;
    }
    return DefWindowProc (hwndKey, message, wParam, lParam) ;
}

/**************************************************************************/


// AssignDeskTop() For UM
// a-anilk. 1-12-98
static BOOL  AssignDesktop(LPDWORD desktopID, LPTSTR pname)
{
    HDESK hdesk;
    wchar_t name[300];
    DWORD nl;
    // Beep(1000,1000);

    *desktopID = DESKTOP_ACCESSDENIED;
    hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return FALSE;
    }
    GetUserObjectInformation(hdesk,UOI_NAME,name,300,&nl);
    if (pname)
	{
        wcscpy(pname, name);
	}

    if (!_wcsicmp(name, __TEXT("Default")))
	{
        *desktopID = DESKTOP_DEFAULT;
	}
    else if (!_wcsicmp(name, __TEXT("Winlogon")))
    {
        *desktopID = DESKTOP_WINLOGON;
    }
    else if (!_wcsicmp(name, __TEXT("screen-saver")))
	{
        *desktopID = DESKTOP_SCREENSAVER;
	}
    else if (!_wcsicmp(name, __TEXT("Display.Cpl Desktop")))
	{
        *desktopID = DESKTOP_TESTDISPLAY;
	}
    else
	{
        *desktopID = DESKTOP_OTHER;
	}

    CloseDesktop(GetThreadDesktop(GetCurrentThreadId()));
    SetThreadDesktop(hdesk);

    return TRUE;
}

// InitMyProcessDesktopAccess
// a-anilk: 1-12-98
static BOOL InitMyProcessDesktopAccess(VOID)
{
  origWinStation = GetProcessWindowStation();
  userWinStation = OpenWindowStation(__TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
  if (!userWinStation)
  {
      return FALSE;
  }

  SetProcessWindowStation(userWinStation);
  return TRUE;
}

// ExitMyProcessDesktopAccess
// a-anilk: 1-12-98
static VOID ExitMyProcessDesktopAccess(VOID)
{
  if (origWinStation)
  {
    SetProcessWindowStation(origWinStation);
  }

  if (userWinStation)
  {
    CloseWindowStation(userWinStation);
    userWinStation = NULL;
  }
}

// a-anilk added
// Returns the current desktop-ID
DWORD GetDesktop()
{
    HDESK hdesk;
    TCHAR name[300];
    DWORD value, nl, desktopID = DESKTOP_ACCESSDENIED;

	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return DESKTOP_WINLOGON;
    }
    
	GetUserObjectInformation(hdesk, UOI_NAME, name, 300, &nl);
    CloseDesktop(hdesk);
    
	if (!_wcsicmp(name, __TEXT("Default")))
	{
        desktopID = DESKTOP_DEFAULT;
	}
    else if (!_wcsicmp(name, __TEXT("Winlogon")))
	{
        desktopID = DESKTOP_WINLOGON;
	}
    else if (!_wcsicmp(name, __TEXT("screen-saver")))
	{
        desktopID = DESKTOP_SCREENSAVER;
	}
    else if (!_wcsicmp(name, __TEXT("Display.Cpl Desktop")))
	{
        desktopID = DESKTOP_TESTDISPLAY;
	}
    else
	{
        desktopID = DESKTOP_OTHER;
	}
    
	return desktopID;
}

// Moves the dialog outside of the OSK screen area, Either on top if
// space permits or on the bottom edge of OSK: 
void RelocateDialog(HWND hDlg)
{
   RECT rKbMainRect, rDialogRect, Rect;
   int x, y, width, height;
   
   GetWindowRect(g_hwndOSK, &rKbMainRect);
   GetWindowRect(hDlg, &rDialogRect);
   
   width = rDialogRect.right - rDialogRect.left;
   height = rDialogRect.bottom - rDialogRect.top;
   
   GetWindowRect(GetDesktopWindow(),&Rect);
   if ((rKbMainRect.top - height) > Rect.top)
   {
      // There is enough space over OSK window, place the dialog on the top of the osk window
      y = rKbMainRect.top - height;
      x = rKbMainRect.left + (rKbMainRect.right - rKbMainRect.left)/2 - \
         (rDialogRect.right - rDialogRect.left)/2 ;
   }
   else if ((rKbMainRect.bottom + height) < Rect.bottom)
   {
      // There is enough space under OSK window, place the dialog on the bottom of the osk window
      y = rKbMainRect.bottom;
      x = rKbMainRect.left + (rKbMainRect.right - rKbMainRect.left)/2 - \
         (rDialogRect.right - rDialogRect.left)/2 ;
   }
   else
   {
      // It is not possible to see the entire dialog, dont move it.
      return;
   }
   
   MoveWindow(hDlg, x, y, width, height, 1);
}

/************************************************************************/
/* DoButtonUp
/************************************************************************/
void DoButtonUp(HWND hwndKey)
{
	// don't need to change the bitmap color. It will be change with WM_PAINT message
	if (g_hBitmapLockHwnd != hwndKey)
    {
	    SetWindowLong (hwndKey, 0, 0);

		InvalidateRect (hwndKey, NULL, TRUE);

	    if (Prefusesound == TRUE)
	    {
		    MakeClick(SND_DOWN);
	    }
    }
}

/**************************************************************************/
/* SetFocusToInputWindow - set input focus on input window
/**************************************************************************/
void SetFocusToInputWindow()
{
	if (g_hwndInputFocus)
	{
	    SetForegroundWindow(g_hwndInputFocus);
		AllowSetForegroundWindow(ASFW_ANY);
	} 
}

/************************************************************************/
/* TrackActiveWindow - keep track of the window with input focus
/************************************************************************/
void TrackActiveWindow()
{
	HWND hwndT = GetForegroundWindow();

	// When the user is doing ALT+TAB thru top-level windows then GetForegroundWindow
	// may return NULL.  We need to detect this here and set the input focus variable
	// to NULL so that when the keyup on ALT happens we won't force the input back to
	// the previous window.  However, if we aren't doing ALT+TAB then we need to ignore
	// NULL from GetForegroundWindow because when clicking quickly with the mouse
	// (where we are getting activated then forcing the target window to be activated)
	// GetForegroundWindow can return NULL between [I assume] us being deactivated
	// and the target window being activated.

	// ISSUE:  If we ALT+TAB to a CMD window then we aren't able to ALT+TAB
	//         back out.  What is it about cmd windows?  Other windows work.

	if (DoingAltTab() && !hwndT)
	{
		g_hwndInputFocus = NULL;
		return;
	}
	if (hwndT && hwndT != g_hwndOSK)
	{
		g_hwndInputFocus = hwndT;
	}

	// Detect when the window we've been working with gets destroyed

	if (g_hwndInputFocus && !IsWindow(g_hwndInputFocus))
	{
		g_hwndInputFocus = NULL;
	}
}

/************************************************************************/
/* FindKey - return index to key with specified scan code
/************************************************************************/
__inline int FindKey(UINT sc, BOOL fExt)
{
	int i;
	KBkeyRec *pKey;

	for (i=1, pKey=&KBkey[i]; i<lenKBkey; i++, pKey++)
    {
        if ((!fExt && pKey->scancode[0] == sc) || (fExt && pKey->scancode[1] == sc))
        {
            break;
        }
    }
	return (i < lenKBkey)?i:-1;
}

/************************************************************************/
/* KeybdInputProc
/*
/* Notes:  If the soft keyboard appearance needs to change based on both
/* physical and osk key presses then the logic for that needs to go in
/* KeybdInputProc because that is the only place both are detected. 
/* Otherwise, the logic can go in UpdateKey.  Don't put the logic
/* in both places or you'll end up doing everything twice.
/*
/************************************************************************/
LRESULT CALLBACK KeybdInputProc(
   WPARAM  wParam,    // virtual-key code
   LPARAM  lParam     // keystroke-message information
   )
{
    UINT sc;
    UINT vk = (UINT)wParam;
    UINT uiMsg = (lParam & 0x80000000) ? WM_KEYUP : WM_KEYDOWN;
    int i;
    #define GET_KEY_INDEX(sc, i, fext) \
    { \
	    i = FindKey(sc, fext); \
	    if (i < 0) \
		    break;	/* internal error! */ \
    }

	if (uiMsg == WM_KEYDOWN)
	{
		switch(vk)
		{
			case VK_SHIFT:
				// When using the physical keyboard we get many of these as the user presses and holds
				// the shift (before they enter the real key and release shift) so avoid all the redrawing...
				if (!g_fShiftKeyDn)
				{
					g_fShiftKeyDn = TRUE;

                    // Make both shift keys work in sync
                    GET_KEY_INDEX(LSHIFT_SCANCODE, i, FALSE);
					SetWindowLong(lpkeyhwnd[i], 0, 4);
                    SetBackgroundColor(lpkeyhwnd[i], COLOR_HOTLIGHT);

                    GET_KEY_INDEX(RSHIFT_SCANCODE, i, FALSE);
					SetWindowLong(lpkeyhwnd[i], 0, 4);
                    SetBackgroundColor(lpkeyhwnd[i], COLOR_HOTLIGHT);

					RedrawKeys();
				}
				break;

			case VK_MENU:
				// When using the physical keyboard we get many of these as the user presses and holds
				// the RALT (before they enter the real key and release shift) so avoid all the redrawing.
				// Only check for ALTGR if there are ALTGR keys to display.
				if (CanDisplayAltGr() && !g_fRAltKey)
				{
					g_fRAltKey = HIBYTE(GetKeyState(VK_RMENU)) & 0x01;
					if (g_fRAltKey)
					{
						RedrawKeys();
					}
				}
				if (CanDisplayAltGr() && !g_fLAltKey)
				{
                    // When LALT is pressed the system toggles (and we see) VK_CONTROL
					g_fLAltKey = HIBYTE(GetKeyState(VK_MENU)) & 0x01;
					if (g_fLAltKey && g_fLCtlKey)
					{
						RedrawKeys();
					}
				}
				break;

            case VK_CONTROL:
				// When using the physical keyboard we get many of these as the user presses and holds
				// the LCTRL (before they enter the real key and release shift) so avoid all the redrawing.
				// Only check for ALTGR if there are ALTGR keys to display.
				if (CanDisplayAltGr() && !g_fLCtlKey)
				{
                    g_fLCtlKey = HIBYTE(GetKeyState(VK_CONTROL)) & 0x01;
					if (g_fLAltKey && g_fLCtlKey)
					{
						RedrawKeys();
					}
				}
                break;
		}
	}
	else if (uiMsg == WM_KEYUP)
	{
		switch(vk)
		{
            //
            // F11 minimizes and restores the keyboard
            //
			case VK_F11:
			   if(IsIconic(g_hwndOSK)) 
			   {
				  ShowWindow(g_hwndOSK, SW_RESTORE);
			   }
			   else
			   {
				  ShowWindow(g_hwndOSK, SW_SHOWMINIMIZED);
			   }
			   break;
			
            //
            // Show CAPSLOCK toggled and change the keyboard to upper or
			// lower case.  Do this here so the keyboard changes on physical 
			// key press as well as soft keyboard key press.
            //
			case VK_CAPITAL:
				g_fCapsLockOn = (LOBYTE(GetKeyState(VK_CAPITAL)) & 0x01); //Update CapLock drawn flag

                // find the CAPSLOCK scancode to get the hwnd to modify

				GET_KEY_INDEX(CAPLOCK_SCANCODE, i, FALSE);

				if (g_fCapsLockOn)   // CapsLock On
				{	
                    SetCapsLock(lpkeyhwnd[i]);

				    //Hilite Cap key
                    SetWindowLong(lpkeyhwnd[i], 0, 4);
                    SetBackgroundColor(lpkeyhwnd[i], COLOR_HOTLIGHT);

                    if (KBkey[i].name == BITMAP)     //Updates japanese CapLock
					{
                        g_hBitmapLockHwnd = lpkeyhwnd[i];
					}
				}
				else                  // CapsLock off
				{
                    SetCapsLock(NULL);

					SetWindowLong(lpkeyhwnd[i], 0, 0);
					SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);

					if (KBkey[i].name == BITMAP)     //Updates japanese CapLock
					{
						g_hBitmapLockHwnd = NULL;
					}
				}
				RedrawKeys();
    			break;

			case VK_SHIFT:
				g_fShiftKeyDn = FALSE;

                // Make both shift keys work in sync
				GET_KEY_INDEX(LSHIFT_SCANCODE, i, FALSE);
				SetWindowLong(lpkeyhwnd[i], 0, 0);
				SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);

				GET_KEY_INDEX(RSHIFT_SCANCODE, i, FALSE);
				SetWindowLong(lpkeyhwnd[i], 0, 0);
				SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);

				RedrawKeys();
				break;

			case VK_MENU:
				if (g_fRAltKey)
				{
					g_fRAltKey = FALSE;
					RedrawKeys();
				}
				if (g_fLAltKey)
				{
					g_fLAltKey = FALSE;
					RedrawKeys();
				}
				g_fDoingAltTab = FALSE;
				break;

            case VK_CONTROL:
				if (g_fLCtlKey)
				{
					g_fLCtlKey = FALSE;
				}
                // I think we always need to redraw keys on VK_CONTROL
                // because that is a special key on the JPN 106 keyboard.
				RedrawKeys();
				break;

            //
            // Redraw NUMLOCK, SCROLL, etc... based on toggle state
            //
			case VK_NUMLOCK:
				RedrawNumLock();
    			break;

			case VK_SCROLL:
				RedrawScrollLock();
			    break;

			case VK_KANA:
			    {
			        BOOL fLastKanaState = g_fKanaKey;

			        //  These bits in the lParam are private bit that are set in the keyboard hook
			        //  to let OSK know the Kana state.  The only way to reliably tell this is to be in proc
			        if (lParam & KANA_MODE_ON)
			        {
			            g_fKanaKey = TRUE;
			        }
			        else if  (lParam & KANA_MODE_OFF)
			        {
			            g_fKanaKey = FALSE;
			        }

			        if (fLastKanaState != g_fKanaKey)
			        {
                                UninitKeys();
                                UpdateKeyLabels(GetCurrentHKL());
                                RedrawKeys();   
			        }
			    }
			    break;

            default:
			    break;
		}
    }
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\dgsett.c ===
// dgSetting.c
// Copyright (c) 1997-1999 Microsoft Corporation
// KBMAIN.C 
// Additions, Bug Fixes 1999 Anil Kumar

#define STRICT

#include <windows.h>
#include <winnt.h>
#include <stdio.h>
#include <tchar.h>

#include "kbmain.h"
#include "resource.h"
#include "kbus.h"
#include "osk.h"
#include "commctrl.h"
#include "w95trace.h"

#define  REDRAW     TRUE
#define  NREDRAW    FALSE

/****************************************************************************/
/*    FUNCTIONS IN THIS FILE			                                    */
/****************************************************************************/
#include "dgsett.h"

/******************************************/
//    Functions in other file
/******************************************/
#include "kbfunc.h"
#include "scan.h"
#include "sdgutil.h"
#include "dgadvsca.h"
#include "Init_End.h"

/******************************************************************************/

__inline int SendMessageInt(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return (int)SendMessage(hWnd, uMsg, wParam, lParam);
}

BOOL DwellSel=0;
BOOL ScanSel=0;

int GetComboItemData(HWND hwnd);
void FillAndSetCombo(HWND hwnd, int iMinVal, int iMaxVal, int iIncr, int iSelVal, LPTSTR pszLabel);
void SelNearestComboItem(HWND hwnd, int iFindVal);

extern float g_KBC_length;
extern DWORD GetDesktop();

LPTSTR CvtToDblString(int iVal)
{
    static TCHAR szbuf2[30];
    TCHAR szbuf[30];

    // first create non-localized string
    wsprintf(szbuf, TEXT("%d.%d"), iVal/1000, (iVal%1000)/100);

    // convert to localized the number
    if (!GetNumberFormat(LOCALE_USER_DEFAULT, 0, szbuf, NULL, szbuf2, ARRAY_SIZE(szbuf2)))
        lstrcpy(szbuf2, szbuf); // do the best we can

    return szbuf2;
}

void EnableDwellCtrls(HWND hDlg, BOOL fEnable)
{
    CheckDlgButton(hDlg, chk_Dwell, (fEnable)?BST_CHECKED:BST_UNCHECKED);
    EnableWindow(GetDlgItem(hDlg, IDC_HOVER_DESC), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CMB_DWELL), fEnable);
    if (!fEnable)
        SendMessage(GetDlgItem(hDlg, IDC_CMB_DWELL), CB_SETCURSEL, -1, 0);
}

void EnableScanCtrls(HWND hDlg, BOOL fEnable)
{
    CheckDlgButton(hDlg, chk_Scan, (fEnable)?BST_CHECKED:BST_UNCHECKED);
    EnableWindow(GetDlgItem(hDlg, IDC_SCAN_DESC), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CMB_SCAN), fEnable);
    if (!fEnable)
        SendMessage(GetDlgItem(hDlg, IDC_CMB_SCAN), CB_SETCURSEL, -1, 0);
	EnableWindow(GetDlgItem(hDlg, BUT_ADVANCED), fEnable);
}

/******************************************************************************/
/* Typing Mode
/******************************************************************************/
INT_PTR Type_ModeDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT_PTR ReturnValue;

    ReturnValue = DialogBox(hInst, MAKEINTRESOURCE(DLG_TYPE_MODE),
                            NULL, Type_ModeDlgProc);

    if (ReturnValue==-1)
    {
        SendErrorMessage(IDS_CANNOTCREATEDLG);
    }
    return ReturnValue;
}

/******************************************************************************/
INT_PTR CALLBACK Type_ModeDlgProc(HWND hDlg, UINT message,
                                  WPARAM wParam, LPARAM lParam)
{	
    TCHAR		buf[50];
    int         cch;
	TCHAR		filename[MAX_PATH]=TEXT("");
	LPHELPINFO	lphi;
	DWORD		m_dwHelpMap[] ={
		chk_Click,	        IDH_OSK_CLICK_MODE,
		chk_Dwell,	        IDH_OSK_DWELL_MODE,
		IDC_HOVER_DESC,     IDH_OSK_DWELL_TIME,
        IDC_CMB_DWELL,      IDH_OSK_DWELL_TIME,
		chk_Scan,	        IDH_OSK_SCAN_MODE,
		IDC_SCAN_DESC,      IDH_OSK_SCAN_TIME,
        IDC_CMB_SCAN,       IDH_OSK_SCAN_TIME,
        IDOK,               IDH_OSK_OK,
        IDCANCEL,           IDH_OSK_CANCEL,
		BUT_ADVANCED,       IDH_ADVANCED,
	};


	switch(message)
    {
        case WM_INITDIALOG:
			RelocateDialog(hDlg);

			KillScanTimer(TRUE);  //kill scanning

            // set up the combo box info

            cch = LoadString(hInst, IDS_SECONDS, buf, ARRAY_SIZE(buf));
            if (!cch) lstrcpy(buf, TEXT("Error!"));
            FillAndSetCombo(GetDlgItem(hDlg, IDC_CMB_DWELL), 500, 3000, 500, PrefDwellTime, buf);
            FillAndSetCombo(GetDlgItem(hDlg, IDC_CMB_SCAN), 500, 3000, 500, PrefScanTime, buf);

			// enable dwell info?

            DwellSel = PrefDwellinkey;
			if(DwellSel)
            {
                EnableDwellCtrls(hDlg, TRUE);
                EnableScanCtrls(hDlg, FALSE);
            }

			// enable scan info?
			
            ScanSel = PrefScanning;
			if (ScanSel)
            {
                EnableDwellCtrls(hDlg, FALSE);
                EnableScanCtrls(hDlg, TRUE);
            }

			//Check the Click check box?

			if (!DwellSel && !ScanSel)
            {
				CheckDlgButton(hDlg, chk_Click, BST_CHECKED);
                EnableDwellCtrls(hDlg, FALSE);
                EnableScanCtrls(hDlg, FALSE);
            } else
            {
				CheckDlgButton(hDlg, chk_Click, BST_UNCHECKED);
            }
    		return TRUE;
		break;


		case WM_HELP:
			if ( !OSKRunSecure() )
            {
			    lphi = (LPHELPINFO) lParam;

			    if(lphi->iContextType == HELPINFO_WINDOW)
                {
				    WinHelp((HWND)lphi->hItemHandle, TEXT("osk.hlp"),  HELP_WM_HELP
                                , (DWORD_PTR)m_dwHelpMap);
                }
		        return TRUE;
            }
			return FALSE;
		break;

		case WM_CONTEXTMENU:
			if ( !OSKRunSecure() )
            {
                WinHelp((HWND)wParam, TEXT("osk.hlp"),  HELP_CONTEXTMENU,
                        (DWORD_PTR)m_dwHelpMap);

		        return TRUE;
            }
			return FALSE;
		break;

		case WM_COMMAND:
            switch LOWORD(wParam)
            {
            case IDOK:
			    kbPref->PrefDwellinkey = PrefDwellinkey = DwellSel;
                kbPref->PrefScanning = PrefScanning = ScanSel;
				if (DwellSel)
				{
                    kbPref->PrefDwellTime = PrefDwellTime 
                        = GetComboItemData(GetDlgItem(hDlg, IDC_CMB_DWELL));
                }

                if (ScanSel)
				{
				    kbPref->PrefScanning = PrefScanning = TRUE;
				 	kbPref->PrefScanTime = PrefScanTime 
                        = GetComboItemData(GetDlgItem(hDlg, IDC_CMB_SCAN));

					Prefhilitekey = FALSE;   // stop hilighting when the mouse moves

					// If we have Switch key check, then config the Switch key
					if(kbPref->bKBKey)
						ConfigSwitchKey(kbPref->uKBKey, TRUE);  //Turn on the key

					// If we have Switch port check, then config the Switch port
					if(kbPref->bPort)
						ConfigPort(TRUE);  //Turn on the port
                } else
                {
				    kbPref->PrefScanning = PrefScanning = FALSE;

                    Prefhilitekey = TRUE;   // start hilighting when the mouse moves

					// Disable scan key, in case it is set
					ConfigSwitchKey(0, FALSE);

					// Disable serial, lpt, game port from scanning
					ConfigPort(FALSE);
                }

				EndDialog(hDlg,IDOK);
			break;

			case IDCANCEL:
				EndDialog(hDlg,IDCANCEL);
			break;

			case chk_Click:    // Using click mode. Disable both Dwell and Scanning
				CheckDlgButton(hDlg, chk_Click, BST_CHECKED);

				//Disable Dwelling
				DwellSel = FALSE;
                EnableDwellCtrls(hDlg, FALSE);

				//Disable Scanning
				ScanSel = FALSE;
                EnableScanCtrls(hDlg, FALSE);
			break;

			case chk_Dwell:
				DwellSel = !DwellSel;

				CheckDlgButton(hDlg, chk_Click, BST_UNCHECKED);

				if (DwellSel)
				{
                    SelNearestComboItem(GetDlgItem(hDlg, IDC_CMB_DWELL), PrefDwellTime);
                    EnableDwellCtrls(hDlg, TRUE);

					// Disable Scanning
					ScanSel = FALSE;
                    EnableScanCtrls(hDlg, FALSE);
				}
			break;

			case chk_Scan:
				ScanSel = !ScanSel;
				
				CheckDlgButton(hDlg, chk_Click, BST_UNCHECKED);
				
				if (ScanSel)
				{
                    SelNearestComboItem(GetDlgItem(hDlg, IDC_CMB_SCAN), PrefScanTime);
                    EnableScanCtrls(hDlg, TRUE);

					// Disable Dwelling			
					DwellSel = FALSE;
                    EnableDwellCtrls(hDlg, FALSE);
				}
			break;

			case BUT_ADVANCED:
				AdvScanDlgFunc(hDlg, 0, (WPARAM)NULL, (LPARAM)NULL);
			break;

			default:
			    return FALSE;
            break;
			}   // switch LOWORD(wParam)

		    return TRUE;
	    break;

	default:
		return FALSE;
	}

	return TRUE;

}

void SwitchToNewLayout()
{
    int i;
	RECT KBC_rect;

    // destroy the current key windows

	InvalidateRect(g_hwndOSK, NULL, TRUE);

	for (i = 1; i < lenKBkey; i++)
    {
		DestroyWindow(lpkeyhwnd[i]);
    }

	// RegisterWndClass depends on the key types so update them before

	InitKeys();
	UpdateKeyLabels(GetCurrentHKL());

	RegisterWndClass(hInst);

    // tell the main window to recreate the key windows

	SendMessage(g_hwndOSK, WM_CREATE, 0L, 0L);

	//Since we want the same key size, but smaller (2/3) of the KB.
	//We need to increase the KB size by 3/2. -12 because we need little bit bigger than 3/2

	GetClientRect(g_hwndOSK, &KBC_rect);
	g_KBC_length = (float)KBC_rect.right * 3 / 2 - 12;

    // tell the main window to resize

	SendMessage(g_hwndOSK, WM_SIZE, 0L, 0L);

	RedrawNumLock();	// highlight the NUMLOCK key if it is on
	RedrawScrollLock();	// highlight the Scroll Key if it is on
}

/******************************************************************************/
void SwitchToBlockKB(void)
{	
    UninitKeys();
	BlockKB();
    SwitchToNewLayout();
}
/****************************************************************************/
void SwitchToActualKB(void)
{	
    UninitKeys();
	ActualKB();
    SwitchToNewLayout();
}

/**************************************************************************/
void SwitchToJapaneseKB(void)
{	
    UninitKeys();
	JapaneseKB();
    SwitchToNewLayout();
}
/**************************************************************************/
void SwitchToEuropeanKB(void)
{	
    UninitKeys();
	EuropeanKB();
    SwitchToNewLayout();
}

/**************************************************************************/
//Construct the Block layout structure
/**************************************************************************/
void BlockKB(void)
{
    KBkeyRec KBkey2[]= {
	

//0
    {TEXT(""),      TEXT(""),       TEXT(""),       TEXT(""),
     NO_NAME, 0,0,0,0,TRUE,KNORMAL_TYPE,BOTH},    //DUMMY

//1
    {TEXT("esc"),   TEXT("esc"),    TEXT("{esc}"),  TEXT("{esc}"),
     NO_NAME, 1,1,8,9, TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x01,0x00,0x00,0x00}},

//2
    {TEXT("F1"),    TEXT("F1"),     TEXT("{f1}"),   TEXT("{f1}"),
     NO_NAME, 1,11,8,9,FALSE,KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3B,0x00,0x00,0x00}},	

//3
    {TEXT("F2"),    TEXT("F2"),     TEXT("{f2}"),   TEXT("{f2}"),
     NO_NAME, 1,21,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3C,0x00,0x00,0x00}},

//4
    {TEXT("F3"),    TEXT("F3"),     TEXT("{f3}"),   TEXT("{f3}"),
     NO_NAME, 1,31,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3D,0x00,0x00,0x00}},

//5
    {TEXT("F4"),    TEXT("F4"),     TEXT("{f4}"),   TEXT("{f4}"),
     NO_NAME, 1,41,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3E,0x00,0x00,0x00}},


//6
    {TEXT("F5"),    TEXT("F5"),     TEXT("{f5}"),   TEXT("{f5}"),
     NO_NAME, 1,52,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3F,0x00,0x00,0x00}},

//7
    {TEXT("F6"),    TEXT("F6"),     TEXT("{f6}"),   TEXT("{f6}"),
     NO_NAME, 1,62,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x40,0x00,0x00,0x00}},

//8
    {TEXT("F7"),    TEXT("F7"),     TEXT("{f7}"),   TEXT("{f7}"),
     NO_NAME, 1,72,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x41,0x00,0x00,0x00}},

//9
    {TEXT("F8"),    TEXT("F8"),     TEXT("{f8}"),   TEXT("{f8}"),
     NO_NAME, 1,82,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x42,0x00,0x00,0x00}},

//10
    {TEXT("F9"),    TEXT("F9"), 	TEXT("{f9}"),	TEXT("{f9}"),
     NO_NAME,1,103,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x43,0x00,0x00,0x00}},

//11
    {TEXT("F10"),	TEXT("F10"),   TEXT("{f10}"),	TEXT("{f10}"),
     KB_LALT,1,113,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x44,0x00,0x00,0x00}},

//12
    {TEXT("F11"),	TEXT("F11"),   TEXT("{f11}"),	TEXT("{f11}"),
     NO_NAME,1,123,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x57,0x00,0x00,0x00}},

//13
    {TEXT("F12"),	TEXT("F12"),   TEXT("{f12}"),	TEXT("{f12}"),
     NO_NAME,1,133,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x58,0x00,0x00,0x00}},


//14
    {TEXT("psc"),   TEXT("psc"),   TEXT("{PRTSC}"), TEXT("{PRTSC}"),
     KB_PSC,1,153,8,9, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x2A,0xE0,0x37}},

//15
    {TEXT("slk"), TEXT("slk"),TEXT("{SCROLLOCK}"),TEXT("{SCROLLOCK}"),
     KB_SCROLL, 1,163,8,9, TRUE, SCROLLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x46,0x00,0x00,0x00}},

//16
    {TEXT("brk"), TEXT("pau"), TEXT("{BREAK}"), TEXT("{^s}"),
     NO_NAME, 1,173,8,9, TRUE, KNORMAL_TYPE, LARGE, REDRAW, 2,
     {0xE1,0x10,0x45,0x00}},

//17
    {TEXT("pup"), TEXT("pup"), TEXT("{PGUP}"), TEXT("{PGUP}"),
     NO_NAME, 1,183,8,9, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x49,0x00,0x00}},

//18
    {TEXT("pdn"), TEXT("pdn"), TEXT("{PGDN}"), TEXT("{PGDN}"),
     NO_NAME, 1,193,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x51,0x00,0x00}},


//19
	{TEXT("`"), TEXT("~"), TEXT("`"), TEXT("{~}"),
     NO_NAME, 12,1,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x29,0x00,0x00,0x00}},

//20
    {TEXT("1"),	TEXT("!"), TEXT("1"), TEXT("!"),
     NO_NAME, 12,11,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x02,0x00,0x00,0x00}},

//21
    {TEXT("2"), TEXT("@"), TEXT("2"), TEXT("@"),
     NO_NAME, 12,21,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x03,0x00,0x00,0x00}},

//22
    {TEXT("3"), TEXT("#"), TEXT("3"), TEXT("#"),
     NO_NAME, 12,31,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x04,0x00,0x00,0x00}},

//23
    {TEXT("4"),	TEXT("$"), TEXT("4"), TEXT("$"),
     NO_NAME, 12,41,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x05,0x00,0x00,0x00}},

//24	
    {TEXT("5"),	TEXT("%"), TEXT("5"), TEXT("{%}"),
     NO_NAME, 12,52,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x06,0x00,0x00,0x00}},

//25
    {TEXT("6"),	TEXT("^"), TEXT("6"), TEXT("{^}"),
     NO_NAME, 12,62,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x07,0x00,0x00,0x00}},

//26
	{TEXT("7"),	TEXT("&"), TEXT("7"), TEXT("&"),
     NO_NAME, 12,72,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x08,0x00,0x00,0x00}},

//27
    {TEXT("8"), TEXT("*"), TEXT("8"), TEXT("*"),
     NO_NAME, 12,82,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x09,0x00,0x00,0x00}},

//28
    {TEXT("9"),	TEXT("("), TEXT("9"), TEXT("("),
     NO_NAME, 12,92,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0A,0x00,0x00,0x00}},
	
//29
    {TEXT("0"),	TEXT(")"), TEXT("0"), TEXT(")"),
     NO_NAME, 12,103,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0B,0x00,0x00,0x00}},

//30
    {TEXT("-"), TEXT("_"), TEXT("-"), TEXT("_"),
     NO_NAME, 12,113,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0C,0x00,0x00,0x00}},

//31
    {TEXT("="),	TEXT("+"), TEXT("="), TEXT("{+}"),
     NO_NAME, 12,123,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0D,0x00,0x00,0x00}},

//32
     //Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

//33
    {TEXT("bksp"),TEXT("bksp"),TEXT("{BS}"),TEXT("{BS}"),
     NO_NAME, 12,133,8,18, TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0E,0x00,0x00,0x00}},

//34
    {TEXT("nlk"), TEXT("nlk"), TEXT("{NUMLOCK}"),TEXT("{NUMLOCK}"),	
     KB_NUMLOCK, 12,153,8,9, FALSE, NUMLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x45,0x00,0x00,0x00}},

//35
	{TEXT("/"),		TEXT("/"),		TEXT("/"),		TEXT("/"),	
	NO_NAME,	 12,	 163,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, 
	 {0xE0,0x35,0x00,0x00}},
	
//36	
	{TEXT("*"),		TEXT("*"),		TEXT("*"),		TEXT("*"),	
	NO_NAME,	 12,	 173,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, 
	 {0xE0,0x37,0x00,0x00}},

//37	
	{TEXT("-"),		TEXT("-"),		TEXT("-"),		TEXT("-"),	
	NO_NAME,	 12,	 183,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1, 
	 {0x4A,0x00,0x00,0x00}},

//38
    {TEXT("ins"),TEXT("ins"),TEXT("{INSERT}"),TEXT("{INSERT}"),
     NO_NAME, 12,193,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x52,0x00,0x00}},




//39
	{TEXT("tab"),	TEXT("tab"),	TEXT("{TAB}"),	TEXT("{TAB}"),			
	NO_NAME,	 21,	   1,	  8,	19, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2, 
	{0x0F,0x00,0x00,0x00}},
	
//40	
	{TEXT("q"),		TEXT("Q"),		TEXT("q"),		TEXT("+q"),		
	NO_NAME,	 21,	  21,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x10,0x00,0x00,0x00}},
	
//41
	{TEXT("w"),		TEXT("W"),		TEXT("w"),		TEXT("+w"),		
	NO_NAME,	 21,	  31,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x11,0x00,0x00,0x00}},
	
//42	
	{TEXT("e"),		TEXT("E"),		TEXT("e"),		TEXT("+e"),		
	NO_NAME,	 21,	  41,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, 
	REDRAW, 1, {0x12,0x00,0x00,0x00}},

//43
	{TEXT("r"),		TEXT("R"),		TEXT("r"),		TEXT("+r"),		
	NO_NAME,	 21,	  52,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, 
	REDRAW, 1, {0x13,0x00,0x00,0x00}},
	
//44
	{TEXT("t"),		TEXT("T"),		TEXT("t"),		TEXT("+t"),		
	NO_NAME,	 21,	  62,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x14,0x00,0x00,0x00}},
	
//45
	{TEXT("y"),		TEXT("Y"),		TEXT("y"),		TEXT("+y"),		
	NO_NAME,	 21,	  72,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x15,0x00,0x00,0x00}},

//46	
	{TEXT("u"),		TEXT("U"),		TEXT("u"),		TEXT("+u"),		
	NO_NAME,	 21,	  82,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x16,0x00,0x00,0x00}},

//47
	{TEXT("i"),		TEXT("I"),		TEXT("i"),		TEXT("+i"),		
	NO_NAME,	 21,	  92,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x17,0x00,0x00,0x00}},
	
//48
	{TEXT("o"),		TEXT("O"),		TEXT("o"),		TEXT("+o"),		
	NO_NAME,	 21,	 103,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x18,0x00,0x00,0x00}},
	
//49
	{TEXT("p"),		TEXT("P"),		TEXT("p"),		TEXT("+p"),		
	NO_NAME,	 21,	 113,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x19,0x00,0x00,0x00}},

//50
	{TEXT("["),		TEXT("{"),		TEXT("["),		TEXT("{{}"),		
	NO_NAME,	 21,	 123,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x1A,0x00,0x00,0x00}},

//51
	{TEXT("]"),		TEXT("}"),		TEXT("]"),		TEXT("{}}"),		NO_NAME,	 21,	 133,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1B,0x00,0x00,0x00}},

//52
	{TEXT("\\"),	TEXT("|"),		TEXT("\\"),		TEXT("|"),			NO_NAME,	 21,	 143,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x2B,0x00,0x00,0x00}},

//53
	{TEXT("7"),		TEXT("7"),		TEXT("7"),		TEXT("7"),		NO_NAME,	 21,	 153,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x47,0x00,0x00,0x00}},

//54	
	{TEXT("8"),		TEXT("8"),		TEXT("8"),		TEXT("8"),		NO_NAME,	 21,	 163,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x48,0x00,0x00,0x00}},

//55
	{TEXT("9"),		TEXT("9"),		TEXT("9"),		TEXT("9"),		NO_NAME,	 21,	 173,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x49,0x00,0x00,0x00}},

//56	
	{TEXT("+"),		TEXT("+"),		TEXT("{+}"),  	TEXT("{+}"),		NO_NAME,	 21,	 183,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x4E,0x00,0x00,0x00}},

//57	
	{TEXT("hm"), TEXT("hm"), TEXT("{HOME}"), TEXT("{HOME}"), 				NO_NAME,	 21,	 193,	  8,	 8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x47,0x00,0x00}},




//58
	{TEXT("lock"),TEXT("lock"),TEXT("{caplock}"),TEXT("{caplock}"),		KB_CAPLOCK,	  30,	   1,	  8,	19,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2, {0x3A,0x00,0x00,0x00}},

//59
	{TEXT("a"),		TEXT("A"),		TEXT("a"),		TEXT("+a"),	NO_NAME,	  30,	  21,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1E,0x00,0x00,0x00}},

//60
	{TEXT("s"),		TEXT("S"),		TEXT("s"),		TEXT("+s"),	NO_NAME,	  30,	  31,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1F,0x00,0x00,0x00}},

//61	
	{TEXT("d"),		TEXT("D"),		TEXT("d"),		TEXT("+d"),	NO_NAME,	  30,	  41,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x20,0x00,0x00,0x00}},

//62
	{TEXT("f"),		TEXT("F"),		TEXT("f"),		TEXT("+f"),	NO_NAME,	  30,	  52,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x21,0x00,0x00,0x00}},

//63
	{TEXT("g"),		TEXT("G"),		TEXT("g"),		TEXT("+g"),	NO_NAME,	  30,	  62,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x22,0x00,0x00,0x00}},

//64	
	{TEXT("h"),		TEXT("H"),		TEXT("h"),		TEXT("+h"),	NO_NAME,	  30,	  72,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x23,0x00,0x00,0x00}},

//65
	{TEXT("j"),		TEXT("J"),		TEXT("j"),		TEXT("+j"),	NO_NAME,	  30,	  82,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x24,0x00,0x00,0x00}},

//66	
	{TEXT("k"),		TEXT("K"),		TEXT("k"),		TEXT("+k"),	NO_NAME,	  30,	  92,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x25,0x00,0x00,0x00}},

//67
	{TEXT("l"),		TEXT("L"),		TEXT("l"),		TEXT("+l"),	NO_NAME,	  30,	 103,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x26,0x00,0x00,0x00}},

//68
	{TEXT(";"),		TEXT(":"),		TEXT(";"),		TEXT("+;"),	NO_NAME,	  30,	 113,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x27,0x00,0x00,0x00}},

//69	
	{TEXT("'"),		TEXT("''"),		TEXT("'"),		TEXT("''"),	NO_NAME,	  30,	 123,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x28,0x00,0x00,0x00}},

//70
//Japanese KB extra key
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 123,  8,	13, FALSE, KNORMAL_TYPE, NOTSHOW, REDRAW, 1, {0x2B,0x00,0x00,0x00}},	

//71
	{TEXT("ent"),	   TEXT("ent"), TEXT("{enter}"),   TEXT("{enter}"),	NO_NAME,	  30,	 133,	  8,     18, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2, {0x1C,0x00,0x00,0x00}},


//72
    {TEXT("4"),	TEXT("4"), TEXT("4"), TEXT("4"),
     NO_NAME, 30,153,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4B,0x00,0x00,0x00}},

//73
    {TEXT("5"),	TEXT("5"), TEXT("5"), TEXT("5"),
     NO_NAME, 30,163,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4C,0x00,0x00,0x00}},

//74
    {TEXT("6"), TEXT("6"), TEXT("6"), TEXT("6"),
     NO_NAME, 30,173,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4D,0x00,0x00,0x00}},

//75
    {TEXT("del"), TEXT("del"), TEXT("{DEL}"), TEXT("{DEL}"),
     NO_NAME, 30,183,8,9,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x53,0x00,0x00}},

//76
    {TEXT("end"), TEXT("end"), TEXT("{END}"), TEXT("{END}"),
     NO_NAME, 30,193,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x4F,0x00,0x00}},


//77
    {TEXT("shft"), TEXT("shft"), TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,19, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},

//78
    {TEXT("z"),	TEXT("Z"), TEXT("z"), TEXT("+z"),
     NO_NAME, 39,21,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2C,0x00,0x00,0x00}},

//79
    {TEXT("x"), TEXT("X"), TEXT("x"), TEXT("+x"),
     NO_NAME, 39,31,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2D,0x00,0x00,0x00}},

//80
    {TEXT("c"), TEXT("C"), TEXT("c"), TEXT("+c"),
     NO_NAME, 39,41,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2E,0x00,0x00,0x00}},


//81
    {TEXT("v"), TEXT("V"), TEXT("v"), TEXT("+v"),
     NO_NAME, 39,52,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2F,0x00,0x00,0x00}},

//82
    {TEXT("b"),	TEXT("B"), TEXT("b"), TEXT("+b"),
     NO_NAME, 39,62,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x30,0x00,0x00,0x00}},

//83
    {TEXT("n"),	TEXT("N"), TEXT("n"), TEXT("+n"),
     NO_NAME, 39,72,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x31,0x00,0x00,0x00}},

//84
    {TEXT("m"), TEXT("M"), TEXT("m"), TEXT("+m"),
     NO_NAME, 39,82,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x32,0x00,0x00,0x00}},

//85
    {TEXT(","), TEXT("<"), TEXT(","), TEXT("+<"),
     NO_NAME, 39,92,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x33,0x00,0x00,0x00}},


//86
    {TEXT("."),	TEXT(">"), TEXT("."), TEXT("+>"),
     NO_NAME, 39,103,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x34,0x00,0x00,0x00}},

//87
    {TEXT("/"),	TEXT("?"), TEXT("/"), TEXT("+/"),
     NO_NAME, 39,113,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x35,0x00,0x00,0x00}},

//88
     //Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


//89
    {TEXT("shft"), TEXT("shft"), TEXT(""), TEXT(""),
     KB_RSHIFT, 39,123,8,28, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},


//90
    {TEXT("1"),	TEXT("1"), TEXT("1"), TEXT("1"),
     NO_NAME, 39,153,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4F,0x00,0x00,0x00}},

//91
    {TEXT("2"),	TEXT("2"), TEXT("2"), TEXT("2"),
     NO_NAME, 39,163,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x50,0x00,0x00,0x00}},

//92
	{TEXT("3"),	TEXT("3"), TEXT("3"), TEXT("3"),
     NO_NAME, 39,173,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x51,0x00,0x00,0x00}},

//93
    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 39,183,8,9, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//94
    {TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 39,193,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},


//95
    {TEXT("ctrl"), TEXT("ctrl"), TEXT(""), TEXT(""),
     KB_LCTR, 48,1,8,19,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x1D,0x00,0x00,0x00}},

//96
    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("lwin"),	
     ICON, 48,21,8,9,TRUE, KMODIFIER_TYPE, BOTH, NREDRAW},

//97
	{TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_LALT, 48,31,8,19,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x38,0x00,0x00,0x00}},

//98
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,52,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


//99
    {TEXT(""),  TEXT(""),   TEXT(" "),  TEXT(" "),
     KB_SPACE, 48,52,8,49, FALSE, KNORMAL_TYPE, LARGE, NREDRAW,  1,
     {0x39,0x00,0x00,0x00}},

	
//100	
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


//101
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


//102
    {TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT, 48,103,8,9, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//103
    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("rwin"),
     ICON, 48,113,8,9,	TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

//104
    {TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48,123,8,9,	TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

//105
    {TEXT("ctrl"), TEXT("ctrl"), TEXT(""), TEXT(""),
     KB_RCTR, 48,133,8,18, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x10,0x00,0x00}},


//106
    {TEXT("0"),	TEXT("0"), TEXT("0"), TEXT("0"),
     NO_NAME, 48,153,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x52,0x00,0x00,0x00}},

//107
    {TEXT("."),	TEXT("."), TEXT("."), TEXT("."),
     NO_NAME, 48,163,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x53,0x00,0x00,0x00}},

//108
    {TEXT("ent"),TEXT("ent"),TEXT("ent"),TEXT("ent"),
     NO_NAME, 48,173,8,9,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x1C,0x00,0x00}},

//109
    {TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,183,8,9, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//110
    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,193,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},


//111
	{TEXT(""), TEXT(""), TEXT(" "), TEXT(" "),
     KB_SPACE, 48,52,8,39, FALSE, KNORMAL_TYPE, SMALL, REDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//112
	{TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT, 48,92,8,9, TRUE, KMODIFIER_TYPE, SMALL, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//113
	{TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48,103,8,9, TRUE, KMODIFIER_TYPE, SMALL, REDRAW},

//114
	{TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 48,113,8,9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//115
	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,123,8,9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//116
	{TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,133,8,9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

//117
	{TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,143,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

	};

	CopyMemory(KBkey, KBkey2, sizeof(KBkey2));
}

/**************************************************************************/
//Contract the Actual KB layout structure
/**************************************************************************/
void ActualKB(void)
{
	KBkeyRec	KBkey2[]=
	{
	//0
    {TEXT(""), TEXT(""), TEXT(""), TEXT(""),
     NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,BOTH},  //to be investigated??????

    {TEXT("esc"), TEXT("esc"), TEXT("{esc}"), TEXT("{esc}"),
     NO_NAME, 1,1,8,8, TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x01,0x00,0x00,0x00}},

    {TEXT("F1"), TEXT("F1"), TEXT("{f1}"), TEXT("{f1}"),
     NO_NAME, 1,19,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3B,0x00,0x00,0x00}},

    {TEXT("F2"), TEXT("F2"), TEXT("{f2}"), TEXT("{f2}"),
     NO_NAME, 1,28,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3C,0x00,0x00,0x00}},

    {TEXT("F3"), TEXT("F3"), TEXT("{f3}"), TEXT("{f3}"),
     NO_NAME, 1,37,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3D,0x00,0x00,0x00}},

    {TEXT("F4"), TEXT("F4"), TEXT("{f4}"), TEXT("{f4}"),
     NO_NAME, 1,46,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3E,0x00,0x00,0x00}},


    {TEXT("F5"), TEXT("F5"), TEXT("{f5}"), TEXT("{f5}"),
     NO_NAME, 1,60,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3F,0x00,0x00,0x00}},

    {TEXT("F6"), TEXT("F6"), TEXT("{f6}"), TEXT("{f6}"),
     NO_NAME, 1,69,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x40,0x00,0x00,0x00}},

    {TEXT("F7"), TEXT("F7"), TEXT("{f7}"), TEXT("{f7}"),
     NO_NAME, 1,78,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x41,0x00,0x00,0x00}},

    {TEXT("F8"), TEXT("F8"), TEXT("{f8}"), TEXT("{f8}"),
     NO_NAME, 1,87,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x42,0x00,0x00,0x00}},


    {TEXT("F9"), TEXT("F9"), TEXT("{f9}"), TEXT("{f9}"),
     NO_NAME, 1,101,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x43,0x00,0x00,0x00}},

    {TEXT("F10"), TEXT("F10"), TEXT("{f10}"), TEXT("{f10}"),
     KB_LALT, 1,110,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x44,0x00,0x00,0x00}},

    {TEXT("F11"), TEXT("F11"), TEXT("{f11}"), TEXT("{f11}"),
     NO_NAME, 1,119,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x57,0x00,0x00,0x00}},

    {TEXT("F12"), TEXT("F12"), TEXT("{f12}"), TEXT("{f12}"),
     NO_NAME, 1,128,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x58,0x00,0x00,0x00}},


    {TEXT("psc"), TEXT("psc"), TEXT("{PRTSC}"), TEXT("{PRTSC}"),
     KB_PSC, 1,138,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x2A,0xE0,0x37}},

    {TEXT("slk"), TEXT("slk"), TEXT("{SCROLLOCK}"), TEXT("{SCROLLOCK}"),
     KB_SCROLL, 1,147,8, 8,  TRUE, SCROLLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x46,0x00,0x00,0x00}},

    {TEXT("brk"), TEXT("pau"), TEXT("{BREAK}"), TEXT("{^s}"),
     NO_NAME, 1,156,8,8, TRUE, KNORMAL_TYPE, LARGE, REDRAW, 2,
     {0xE1,0x10,0x45,0x00}},


    //17
    {TEXT("`"),	TEXT("~"), TEXT("`"), TEXT("{~}"),
     NO_NAME, 12,1,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x29,0x00,0x00,0x00}},

    {TEXT("1"), TEXT("!"), TEXT("1"), TEXT("!"),
     NO_NAME, 12,10,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x02,0x00,0x00,0x00}},

    {TEXT("2"),	TEXT("@"), TEXT("2"), TEXT("@"),
     NO_NAME, 12,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x03,0x00,0x00,0x00}},

    {TEXT("3"), TEXT("#"), TEXT("3"), TEXT("#"),
     NO_NAME, 12,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x04,0x00,0x00,0x00}},

    {TEXT("4"),	TEXT("$"), TEXT("4"), TEXT("$"),
     NO_NAME, 12,37,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x05,0x00,0x00,0x00}},

    {TEXT("5"), TEXT("%"), TEXT("5"), TEXT("{%}"),
     NO_NAME, 12,46,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x06,0x00,0x00,0x00}},

    {TEXT("6"), TEXT("^"), TEXT("6"), TEXT("{^}"),
     NO_NAME, 12,55,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x07,0x00,0x00,0x00}},

    {TEXT("7"), TEXT("&"), TEXT("7"), TEXT("&"),
     NO_NAME, 12,64,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x08,0x00,0x00,0x00}},

    {TEXT("8"),	TEXT("*"), TEXT("8"), TEXT("*"),
     NO_NAME, 12,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x09,0x00,0x00,0x00}},

    {TEXT("9"),	TEXT("("), TEXT("9"), TEXT("("),
     NO_NAME, 12,82,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0A,0x00,0x00,0x00}},

    {TEXT("0"),	TEXT(")"), TEXT("0"), TEXT(")"),
     NO_NAME, 12,91,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0B,0x00,0x00,0x00}},

    {TEXT("-"), TEXT("_"), TEXT("-"), TEXT("_"),
     NO_NAME, 12,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0C,0x00,0x00,0x00}},

    {TEXT("="),	TEXT("+"), TEXT("="), TEXT("{+}"),
     NO_NAME, 12,109,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0D,0x00,0x00,0x00}},


//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


    {TEXT("bksp"),TEXT("bksp"),TEXT("{BS}"),TEXT("{BS}"),
     NO_NAME, 12,118,8,18,  TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0E,0x00,0x00,0x00}},


    {TEXT("ins"),TEXT("ins"),TEXT("{INSERT}"),TEXT("{INSERT}"),
     NO_NAME, 12,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x52,0x00,0x00}},

    {TEXT("hm"), TEXT("hm"), TEXT("{HOME}"), TEXT("{HOME}"),
     NO_NAME, 12,147,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x47,0x00,0x00}},

    {TEXT("pup"),TEXT("pup"),TEXT("{PGUP}"),TEXT("{PGUP}"),
     NO_NAME, 12,156,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x49,0x00,0x00}},


    {TEXT("nlk"),TEXT("nlk"),TEXT("{NUMLOCK}"),TEXT("{NUMLOCK}"),
     KB_NUMLOCK, 12,166,8,8, FALSE, NUMLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x45,0x00,0x00,0x00}},

    {TEXT("/"),	TEXT("/"), TEXT("/"), TEXT("/"),
     NO_NAME, 12,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x35,0x00,0x00}},

    {TEXT("*"),	TEXT("*"), TEXT("*"), TEXT("*"),
     NO_NAME, 12,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x37,0x00,0x00}},

    {TEXT("-"),	TEXT("-"), TEXT("-"), TEXT("-"),
     NO_NAME, 12,193,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
    {0x4A,0x00,0x00,0x00}},


	//38
    {TEXT("tab"), TEXT("tab"), TEXT("{TAB}"), TEXT("{TAB}"),
     NO_NAME, 21,1,8,13, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0F,0x00,0x00,0x00}},

    {TEXT("q"),	TEXT("Q"), TEXT("q"), TEXT("+q"),
     NO_NAME, 21,15,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x10,0x00,0x00,0x00}},

    {TEXT("w"),	TEXT("W"), TEXT("w"), TEXT("+w"),
     NO_NAME, 21,24,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x11,0x00,0x00,0x00}},

    {TEXT("e"),	TEXT("E"), TEXT("e"), TEXT("+e"),
     NO_NAME, 21,33,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x12,0x00,0x00,0x00}},

    {TEXT("r"),	TEXT("R"), TEXT("r"), TEXT("+r"),
     NO_NAME, 21,42,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x13,0x00,0x00,0x00}},

    {TEXT("t"),	TEXT("T"), TEXT("t"), TEXT("+t"),
     NO_NAME, 21,51,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x14,0x00,0x00,0x00}},

    {TEXT("y"),	TEXT("Y"), TEXT("y"), TEXT("+y"),
     NO_NAME, 21,60,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x15,0x00,0x00,0x00}},

    {TEXT("u"),	TEXT("U"), TEXT("u"), TEXT("+u"),
     NO_NAME, 21,69,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x16,0x00,0x00,0x00}},

    {TEXT("i"),	TEXT("I"), TEXT("i"), TEXT("+i"),
     NO_NAME, 21,78,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x17,0x00,0x00,0x00}},

    {TEXT("o"),	TEXT("O"), TEXT("o"), TEXT("+o"),
     NO_NAME, 21,87,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x18,0x00,0x00,0x00}},

    {TEXT("p"),	TEXT("P"), TEXT("p"), TEXT("+p"),
     NO_NAME, 21,96,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x19,0x00,0x00,0x00}},

    {TEXT("["),	TEXT("{"), TEXT("["), TEXT("{{}"),
     NO_NAME, 21,105,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1A,0x00,0x00,0x00}},

    {TEXT("]"),	TEXT("}"), TEXT("]"), TEXT("{}}"),
     NO_NAME, 21,114,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1B,0x00,0x00,0x00}},

    {TEXT("\\"), TEXT("|"),	TEXT("\\"),	TEXT("|"),
     NO_NAME, 21,123,8,13, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2B,0x00,0x00,0x00}},


    {TEXT("del"), TEXT("del"), TEXT("{DEL}"), TEXT("{DEL}"),
     NO_NAME, 21,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x53,0x00,0x00}},

    {TEXT("end"), TEXT("end"), TEXT("{END}"), TEXT("{END}"),
     NO_NAME, 21,147,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x4F,0x00,0x00}},

    {TEXT("pdn"), TEXT("pdn"), TEXT("{PGDN}"),TEXT("{PGDN}"),
     NO_NAME, 21,156,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x51,0x00,0x00}},


    {TEXT("7"),	TEXT("7"), TEXT("7"), TEXT("7"),
     NO_NAME, 21,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x47,0x00,0x00,0x00}},

    {TEXT("8"),	TEXT("8"), TEXT("8"), TEXT("8"),
     NO_NAME, 21,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x48,0x00,0x00,0x00}},

    {TEXT("9"),	TEXT("9"), TEXT("9"), TEXT("9"),
     NO_NAME, 21,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x49,0x00,0x00,0x00}},

    {TEXT("+"),	TEXT("+"), TEXT("{+}"), TEXT("{+}"),
     NO_NAME, 21,193,17,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4E,0x00,0x00,0x00}},


	//59
    {TEXT("lock"),TEXT("lock"),TEXT("{caplock}"),TEXT("{caplock}"),
     KB_CAPLOCK, 30,1,8,17, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x3A,0x00,0x00,0x00}},

    {TEXT("a"),	TEXT("A"), TEXT("a"), TEXT("+a"),
     NO_NAME, 30,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1E,0x00,0x00,0x00}},

    {TEXT("s"),	TEXT("S"), TEXT("s"), TEXT("+s"),
     NO_NAME, 30,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1F,0x00,0x00,0x00}},

    {TEXT("d"),	TEXT("D"), TEXT("d"), TEXT("+d"),
     NO_NAME, 30,37,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x20,0x00,0x00,0x00}},

    {TEXT("f"), TEXT("F"), TEXT("f"), TEXT("+f"),
     NO_NAME, 30,46,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x21,0x00,0x00,0x00}},

    {TEXT("g"),	TEXT("G"), TEXT("g"), TEXT("+g"),
     NO_NAME, 30,55,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x22,0x00,0x00,0x00}},

    {TEXT("h"), TEXT("H"), TEXT("h"), TEXT("+h"),
     NO_NAME, 30,64,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x23,0x00,0x00,0x00}},

    {TEXT("j"),	TEXT("J"), TEXT("j"), TEXT("+j"),
     NO_NAME, 30,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x24,0x00,0x00,0x00}},

    {TEXT("k"),	TEXT("K"), TEXT("k"), TEXT("+k"),
     NO_NAME, 30,82,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x25,0x00,0x00,0x00}},

    {TEXT("l"),	TEXT("L"), TEXT("l"), TEXT("+l"),
     NO_NAME, 30,91,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x26,0x00,0x00,0x00}},

    {TEXT(";"),	TEXT(":"), TEXT(";"), TEXT("+;"),
     NO_NAME, 30,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x27,0x00,0x00,0x00}},

    {TEXT("'"),	TEXT("''"),	TEXT("'"), TEXT("''"),
     NO_NAME, 30,109,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x28,0x00,0x00,0x00}},


//Japanese KB extra key
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 123,  8,	13, FALSE, KNORMAL_TYPE, NOTSHOW, REDRAW, 1, {0x2B,0x00,0x00,0x00}},

    {TEXT("ent"),TEXT("ent"),TEXT("{enter}"),TEXT("{enter}"),
     NO_NAME, 30,118,8,18, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x1C,0x00,0x00,0x00}},


    {TEXT("4"),	TEXT("4"), TEXT("4"), TEXT("4"),
     NO_NAME, 30,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4B,0x00,0x00,0x00}},

    {TEXT("5"), TEXT("5"), TEXT("5"), TEXT("5"),
     NO_NAME, 30,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4C,0x00,0x00,0x00}},

    {TEXT("6"), TEXT("6"), TEXT("6"), TEXT("6"),
     NO_NAME, 30,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4D,0x00,0x00,0x00}},

	//75
	{TEXT("shft"), TEXT("shft"), TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,21, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},

    {TEXT("z"), TEXT("Z"), TEXT("z"), TEXT("+z"),
     NO_NAME, 39,23,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
    {0x2C,0x00,0x00,0x00}},

    {TEXT("x"), TEXT("X"), TEXT("x"), TEXT("+x"),
     NO_NAME, 39,32,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2D,0x00,0x00,0x00}},

    {TEXT("c"),	TEXT("C"), TEXT("c"), TEXT("+c"),
     NO_NAME, 39,41,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2E,0x00,0x00,0x00}},

    {TEXT("v"),	TEXT("V"), TEXT("v"), TEXT("+v"),
     NO_NAME, 39,50,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2F,0x00,0x00,0x00}},

    {TEXT("b"), TEXT("B"), TEXT("b"), TEXT("+b"),
     NO_NAME, 39,59,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x30,0x00,0x00,0x00}},

    {TEXT("n"),	TEXT("N"), TEXT("n"), TEXT("+n"),
     NO_NAME, 39,68,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x31,0x00,0x00,0x00}},

    {TEXT("m"),	TEXT("M"), TEXT("m"), TEXT("+m"),
     NO_NAME, 39,77,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x32,0x00,0x00,0x00}},

    {TEXT(","),	TEXT("<"), TEXT(","), TEXT("+<"),
     NO_NAME, 39,86,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x33,0x00,0x00,0x00}},

    {TEXT("."),	TEXT(">"), TEXT("."), TEXT("+>"),
     NO_NAME, 39,95,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x34,0x00,0x00,0x00}},

    {TEXT("/"),	TEXT("?"), TEXT("/"), TEXT("+/"),
     NO_NAME, 39,104,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x35,0x00,0x00,0x00}},

     //Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

	{TEXT("shft"),  TEXT("shft"),   TEXT(""),   TEXT(""),
     KB_RSHIFT, 39,113,8,23, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},


    // 87
    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 39,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},


    {TEXT("1"), TEXT("1"), TEXT("1"), TEXT("1"),
     NO_NAME, 39,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4F,0x00,0x00,0x00}},

    {TEXT("2"),	TEXT("2"), TEXT("2"), TEXT("2"),
     NO_NAME, 39,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x50,0x00,0x00,0x00}},

    {TEXT("3"),	TEXT("3"), TEXT("3"), TEXT("3"),
     NO_NAME, 39,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x51,0x00,0x00,0x00}},

    {TEXT("ent"),TEXT("ent"),TEXT("ent"),TEXT("ent"),
     NO_NAME, 39,193,17,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x1C,0x00,0x00}},


	//92
    {TEXT("ctrl"), TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_LCTR,48,1,8,13,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x1D,0x00,0x00,0x00}},

    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("lwin"),
     ICON, 48, 15 ,8,8,TRUE, KMODIFIER_TYPE,BOTH, REDRAW},

    {TEXT("alt"), TEXT("alt"),	TEXT(""), TEXT(""),
     KB_LALT, 48,24,8,13, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x38,0x00,0x00,0x00}},

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

    //95
    {TEXT(""), TEXT(""), TEXT(" "), TEXT(" "),
     KB_SPACE,48,38,8,52, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

    {TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT, 48,91,8,13, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("rwin"),
     ICON, 48, 105 ,8,8,TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

    {TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48, 114 ,8,8,TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

    {TEXT("ctrl"), TEXT("ctrl"), TEXT(""), TEXT(""),
     KB_RCTR, 48,123,8,13, TRUE, KMODIFIER_TYPE,LARGE, REDRAW, 2,
     {0xE0,0x10,0x00,0x00}},


    {TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,138,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,147,8, 8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,156,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},


    {TEXT("0"), TEXT("0"), TEXT("0"), TEXT("0"),
     NO_NAME, 48,166,8,17, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x52,0x00,0x00,0x00}},

    {TEXT("."),	TEXT("."), TEXT("."), TEXT("."),
     NO_NAME, 48,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x53,0x00,0x00,0x00}},


    //105
    {TEXT(""),      TEXT(""),       TEXT(" "),  TEXT(" "),
     KB_SPACE, 48,38,8,38, FALSE, KNORMAL_TYPE, SMALL, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},


	{TEXT("alt"),   TEXT("alt"),    TEXT(""),   TEXT(""),
     KB_RALT, 48,77,8,13, TRUE, KMODIFIER_TYPE, SMALL, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

	{TEXT("MenuKeyUp"),TEXT("MenuKeyDn"),TEXT("I_MenuKey"),TEXT("App"),
     ICON, 48,91,8,8, TRUE, KMODIFIER_TYPE, SMALL, REDRAW},


    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 48,100,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

    {TEXT("IDB_DNUPARW"),TEXT("DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,109,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

    {TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,118,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,127,8, 9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

	};
	
	CopyMemory(KBkey, KBkey2, sizeof(KBkey2));
}


/***************************************************************************/
//Contract the Japanese KB layout structure
//Japanese KB the Enter is in different position then English KB
/***************************************************************************/
void JapaneseKB(void)
{
	KBkeyRec KBkey2[] = {
	
//0
    {TEXT(""),TEXT(""),	TEXT(""),TEXT(""),
     NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,BOTH},  //DUMMY

//1
    {TEXT("esc"),TEXT("esc"),TEXT("{esc}"),TEXT("{esc}"),
     NO_NAME, 1,1,8,8, TRUE,  KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x01,0x00,0x00,0x00}},

//2
    {TEXT("F1"), TEXT("F1"), TEXT("{f1}"), TEXT("{f1}"),
     NO_NAME, 1,19, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3B,0x00,0x00,0x00}},

//3
    {TEXT("F2"), TEXT("F2"), TEXT("{f2}"), TEXT("{f2}"),
     NO_NAME, 1,28, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3C,0x00,0x00,0x00}},

//4
    {TEXT("F3"), TEXT("F3"), TEXT("{f3}"), TEXT("{f3}"),
     NO_NAME, 1,37, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3D,0x00,0x00,0x00}},

//5
    {TEXT("F4"), TEXT("F4"), TEXT("{f4}"), TEXT("{f4}"),
     NO_NAME, 1,46, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3E,0x00,0x00,0x00}},

//6
    {TEXT("F5"), TEXT("F5"), TEXT("{f5}"), TEXT("{f5}"),
     NO_NAME, 1,60, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3F,0x00,0x00,0x00}},

//7
    {TEXT("F6"), TEXT("F6"), TEXT("{f6}"), TEXT("{f6}"),
     NO_NAME, 1,69, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x40,0x00,0x00,0x00}},

//8
    {TEXT("F7"), TEXT("F7"), TEXT("{f7}"), TEXT("{f7}"),
     NO_NAME, 1,78, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x41,0x00,0x00,0x00}},

//9
    {TEXT("F8"), TEXT("F8"), TEXT("{f8}"), TEXT("{f8}"),
     NO_NAME, 1,87, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x42,0x00,0x00,0x00}},


//10
    {TEXT("F9"), TEXT("F9"), TEXT("{f9}"), TEXT("{f9}"),
     NO_NAME, 1,101, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x43,0x00,0x00,0x00}},

//11
    {TEXT("F10"),TEXT("F10"), TEXT("{f10}"),TEXT("{f10}"),
     KB_LALT,  1,110, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x44,0x00,0x00,0x00}},

//12
    {TEXT("F11"),TEXT("F11"), TEXT("{f11}"),TEXT("{f11}"),
     NO_NAME,  1,119, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x57,0x00,0x00,0x00}},

//13
    {TEXT("F12"),TEXT("F12"), TEXT("{f12}"),TEXT("{f12}"),
     NO_NAME,1,128,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x58,0x00,0x00,0x00}},

//14
    {TEXT("psc"), TEXT("psc"),TEXT("{PRTSC}"),TEXT("{PRTSC}"),
     KB_PSC, 1,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x2A,0xE0,0x37}},

//15
    {TEXT("slk"), TEXT("slk"),TEXT("{SCROLLOCK}"),TEXT("{SCROLLOCK}"),
     KB_SCROLL,1,147,8, 8, TRUE, SCROLLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x46,0x00,0x00,0x00}},

//16
	{TEXT("brk"), TEXT("pau"), TEXT("{BREAK}"), TEXT("{^s}"),
     NO_NAME,1,156,8,8, TRUE, KNORMAL_TYPE, LARGE, REDRAW, 2,
     {0xE1,0x10,0x45,0x00}},

//17
    {TEXT("IDB_KANJI"), TEXT("IDB_KANJI"), TEXT("IDB_KANJIB"), TEXT("{~}"),
     BITMAP, 12,1,8,8, FALSE, KMODIFIER_TYPE, BOTH, REDRAW, 1,
     {0x29,0x00,0x00,0x00}},

//18
    {TEXT("1"), TEXT("!"), TEXT("1"), TEXT("!"),
     NO_NAME, 12,10,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x02,0x00,0x00,0x00}},

//19
	{TEXT("2"),	TEXT("@"), TEXT("2"), TEXT("@"),
     NO_NAME, 12,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x03,0x00,0x00,0x00}},

//20
    {TEXT("3"), TEXT("#"), TEXT("3"), TEXT("#"),
     NO_NAME,12,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x04,0x00,0x00,0x00}},

//21
	{TEXT("4"),		TEXT("$"),		TEXT("4"),		TEXT("$"),		NO_NAME,	 12,	  37,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x05,0x00,0x00,0x00}},
	
//22
	{TEXT("5"), 	TEXT("%"), 		TEXT("5"),		TEXT("{%}"),	NO_NAME,	 12,	  46,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x06,0x00,0x00,0x00}},
	
//23	
	{TEXT("6"),		TEXT("^"),		TEXT("6"),		TEXT("{^}"),	NO_NAME,	 12,	  55,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x07,0x00,0x00,0x00}},
	
//24	
	{TEXT("7"),		TEXT("&"),		TEXT("7"),		TEXT("&"),		NO_NAME,	 12,	  64,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x08,0x00,0x00,0x00}},
	
//25	
	{TEXT("8"), 	TEXT("*"), 		TEXT("8"),		TEXT("*"),		NO_NAME,	 12,	  73,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x09,0x00,0x00,0x00}},
	
//26	
	{TEXT("9"),		TEXT("("),		TEXT("9"),		TEXT("("),		NO_NAME,	 12,	  82,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0A,0x00,0x00,0x00}},
	
//27
	{TEXT("0"),		TEXT(")"),		TEXT("0"),		TEXT(")"),		NO_NAME,	 12,	  91,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0B,0x00,0x00,0x00}},
	
//28	
	{TEXT("-"), 	TEXT("_"), 		TEXT("-"),		TEXT("_"),		NO_NAME,	 12,	 100,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0C,0x00,0x00,0x00}},
	
//29	
	{TEXT("="),		TEXT("+"),		TEXT("="),		TEXT("{+}"),	NO_NAME,	 12,	 109,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0D,0x00,0x00,0x00}},

//30
//Japanese KB extra key
	{TEXT("jp"),		TEXT("jp"),		TEXT("jp"),		TEXT("{jp}"),	NO_NAME,	 12,	 118,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x7D,0x00,0x00,0x00}},


//31
	{TEXT("bksp"),TEXT("bksp"),TEXT("{BS}"),TEXT("{BS}"),
     NO_NAME,12, 127,8,9,  TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0E,0x00,0x00,0x00}},

//32
	{TEXT("ins"),TEXT("ins"),TEXT("{INSERT}"),TEXT("{INSERT}"), NO_NAME, 12,138, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x52,0x00,0x00}},
	
//33	
	{TEXT("hm"), TEXT("hm"), TEXT("{HOME}"), TEXT("{HOME}"), 	NO_NAME, 12,147, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x47,0x00,0x00}},
	
//34	
	{TEXT("pup"),TEXT("pup"),TEXT("{PGUP}"),TEXT("{PGUP}"),		NO_NAME, 12,156, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x49,0x00,0x00}},

//35
	{TEXT("nlk"),TEXT("nlk"),	TEXT("{NUMLOCK}"),TEXT("{NUMLOCK}"),KB_NUMLOCK,12,166,  8,	 8, FALSE, NUMLOCK_TYPE, LARGE, NREDRAW, 2, {0x45,0x00,0x00,0x00}},
	
//36
	{TEXT("/"),	TEXT("/"),	TEXT("/"),	TEXT("/"),	NO_NAME, 12, 175,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x35,0x00,0x00}},
	
//37
	{TEXT("*"),	TEXT("*"),	TEXT("*"),	TEXT("*"),	NO_NAME, 12, 184,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x37,0x00,0x00}},
	
//38	
	{TEXT("-"),	TEXT("-"),	TEXT("-"),	TEXT("-"),	NO_NAME, 12, 193,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1, {0x4A,0x00,0x00,0x00}},


//39
	{TEXT("tab"),	TEXT("tab"),	TEXT("{TAB}"),TEXT("{TAB}"),NO_NAME, 21,   1,  8,	13, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2, {0x0F,0x00,0x00,0x00}},

//40
	{TEXT("q"),	TEXT("Q"),	TEXT("q"),	TEXT("+q"),	NO_NAME, 21,  15,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x10,0x00,0x00,0x00}},

//41	
	{TEXT("w"),	TEXT("W"),	TEXT("w"),	TEXT("+w"),	NO_NAME, 21,  24,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x11,0x00,0x00,0x00}},
	
//42	
	{TEXT("e"),	TEXT("E"),	TEXT("e"),	TEXT("+e"),	NO_NAME, 21,  33,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x12,0x00,0x00,0x00}},
	
//43	
	 {TEXT("r"),	TEXT("R"),	TEXT("r"),	TEXT("+r"),	NO_NAME, 21,  42,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x13,0x00,0x00,0x00}},


//44
    {TEXT("t"),	TEXT("T"),	TEXT("t"),	TEXT("+t"),	
     NO_NAME, 21,51,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x14,0x00,0x00,0x00}},

//45
	{TEXT("y"),	TEXT("Y"),	TEXT("y"),	TEXT("+y"),	NO_NAME, 21,  60,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x15,0x00,0x00,0x00}},

//46
	{TEXT("u"),	TEXT("U"),	TEXT("u"),	TEXT("+u"),	NO_NAME, 21,  69,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x16,0x00,0x00,0x00}},
	
//47	
	{TEXT("i"),	TEXT("I"),	TEXT("i"),	TEXT("+i"),	NO_NAME, 21,  78,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x17,0x00,0x00,0x00}},
	
//48	
	{TEXT("o"),	TEXT("O"),	TEXT("o"),	TEXT("+o"),	NO_NAME, 21,  87,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x18,0x00,0x00,0x00}},
	
//49	
	{TEXT("p"),	TEXT("P"),	TEXT("p"),	TEXT("+p"),	NO_NAME, 21,  96,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x19,0x00,0x00,0x00}},

//50	
	{TEXT("["),	TEXT("{"),	TEXT("["),	TEXT("{{}"),	NO_NAME, 21, 105,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1A,0x00,0x00,0x00}},

//51
	{TEXT("]"),	TEXT("}"),	TEXT("]"),	TEXT("{}}"),	NO_NAME, 21, 114,  8,	 12, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1B,0x00,0x00,0x00}},

//52	
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 123,  8,	13, FALSE, KNORMAL_TYPE, NOTSHOW, REDRAW, 1, {0x2B,0x00,0x00,0x00}},

//53	
// ***Japanese KB the ENTER key is in here whcih is different from English KB***
	{TEXT("ent"),TEXT("ent"),TEXT("{enter}"),TEXT("{enter}"),	NO_NAME,  21,	 127,	  17,  9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 2, {0x1C,0x00,0x00,0x00}},

//54
	{TEXT("del"), TEXT("del"), 	TEXT("{DEL}"),TEXT("{DEL}"),NO_NAME, 21,   138,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x53,0x00,0x00}},

//55
	{TEXT("end"),	TEXT("end"), 	TEXT("{END}"),TEXT("{END}"),NO_NAME, 21,   147,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x4F,0x00,0x00}},

//56
	{TEXT("pdn"), TEXT("pdn"), 	TEXT("{PGDN}"),TEXT("{PGDN}"),NO_NAME, 21, 156,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x51,0x00,0x00}},


//57
	{TEXT("7"),		TEXT("7"),		TEXT("7"),		TEXT("7"),		NO_NAME,	 21,	 166,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x47,0x00,0x00,0x00}},

//58
	{TEXT("8"),		TEXT("8"),		TEXT("8"),		TEXT("8"),		NO_NAME,	 21,	 175,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x48,0x00,0x00,0x00}},

//59
	{TEXT("9"),		TEXT("9"),		TEXT("9"),		TEXT("9"),		NO_NAME,	 21,	 184,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x49,0x00,0x00,0x00}},

//60	
	{TEXT("+"),		TEXT("+"),		TEXT("{+}"),  	TEXT("{+}"),	NO_NAME,	 21,	 193,	 17,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x4E,0x00,0x00,0x00}},

//61
    {TEXT("IDB_BITMAP7"),TEXT("IDB_BITMAP7"),TEXT("IDB_BITMAP9"),TEXT("CAPS"),
     BITMAP, 30,1,8,17, FALSE, KMODIFIER_TYPE, BOTH, REDRAW, 1,
     {0x3A,0x00,0x00,0x00}},

//62
	{TEXT("a"),	TEXT("A"), TEXT("a"), TEXT("+a"),
     NO_NAME, 30,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1E,0x00,0x00,0x00}},

//63
	{TEXT("s"),		TEXT("S"),		TEXT("s"),		TEXT("+s"),		NO_NAME,	  30,	  28,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1F,0x00,0x00,0x00}},

//64	
	{TEXT("d"),		TEXT("D"),		TEXT("d"),		TEXT("+d"),		NO_NAME,	  30,	  37,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x20,0x00,0x00,0x00}},

//65
	{TEXT("f"),		TEXT("F"),		TEXT("f"),		TEXT("+f"),		NO_NAME,	  30,	  46,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x21,0x00,0x00,0x00}},

//66
	{TEXT("g"),		TEXT("G"),		TEXT("g"),		TEXT("+g"),		NO_NAME,	  30,	  55,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x22,0x00,0x00,0x00}},

//67	
	{TEXT("h"),		TEXT("H"),		TEXT("h"),		TEXT("+h"),		NO_NAME,	  30,	  64,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x23,0x00,0x00,0x00}},

//68
    {TEXT("j"),	TEXT("J"), TEXT("j"), TEXT("+j"),
     NO_NAME, 30,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x24,0x00,0x00,0x00}},

//69
	{TEXT("k"),		TEXT("K"),		TEXT("k"),		TEXT("+k"),		NO_NAME,	  30,	  82,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x25,0x00,0x00,0x00}},

//70
	{TEXT("l"),		TEXT("L"),		TEXT("l"),		TEXT("+l"),		NO_NAME,	  30,	  91,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x26,0x00,0x00,0x00}},

//71
	{TEXT(";"), TEXT(":"), TEXT(";"), TEXT("+;"),
     NO_NAME, 30,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x27,0x00,0x00,0x00}},

//72
	{TEXT("'"),		TEXT("''"),		TEXT("'"),		TEXT("''"),		NO_NAME,	  30,	 109,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x28,0x00,0x00,0x00}},
	
//73
//Japanese KB extra key
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 30, 118,  8,	8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x2B,0x00,0x00,0x00}},


//74
    {TEXT("4"), TEXT("4"), TEXT("4"), TEXT("4"),
     NO_NAME, 30,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4B,0x00,0x00,0x00}},

//75
    {TEXT("5"),	TEXT("5"), TEXT("5"), TEXT("5"),
     NO_NAME, 30,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4C,0x00,0x00,0x00}},

//76
    {TEXT("6"),	TEXT("6"), TEXT("6"), TEXT("6"),
     NO_NAME, 30,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4D,0x00,0x00,0x00}},


//77
	{TEXT("shft"),TEXT("shft"),	TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,21, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},

//78
    {TEXT("z"), TEXT("Z"),  TEXT("z"),  TEXT("+z"),
     NO_NAME,39,23,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2C,0x00,0x00,0x00}},

//79
    {TEXT("x"),	TEXT("X"), TEXT("x"), TEXT("+x"),
     NO_NAME, 39,32,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2D,0x00,0x00,0x00}},

//80
    {TEXT("c"), TEXT("C"), TEXT("c"), TEXT("+c"),
     NO_NAME, 39,41,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2E,0x00,0x00,0x00}},

//81
    {TEXT("v"), TEXT("V"), TEXT("v"), TEXT("+v"),
     NO_NAME, 39,50,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2F,0x00,0x00,0x00}},

//82
    {TEXT("b"),TEXT("B"),TEXT("b"),TEXT("+b"),
     NO_NAME,39,59,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x30,0x00,0x00,0x00}},

//83
    {TEXT("n"),	TEXT("N"), TEXT("n"), TEXT("+n"),
     NO_NAME,39,68,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x31,0x00,0x00,0x00}},

//84
    {TEXT("m"), TEXT("M"), TEXT("m"), TEXT("+m"),
     NO_NAME, 39,77,8,8,FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x32,0x00,0x00,0x00}},

//85
    {TEXT(","),	TEXT("<"), TEXT(","), TEXT("+<"),
     NO_NAME, 39,86,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x33,0x00,0x00,0x00}},

//86
    {TEXT("."), TEXT(">"), TEXT("."), TEXT("+>"),
     NO_NAME, 39,95,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
    {0x34,0x00,0x00,0x00}},

//87
    {TEXT("/"),	TEXT("?"), TEXT("/"), TEXT("+/"),
     NO_NAME, 39,104,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x35,0x00,0x00,0x00}},

//88
//Japanese KB extra key
    {TEXT("jp"),	TEXT("jp"), TEXT("jp"), TEXT("jp"),
     NO_NAME, 39,113,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x73,0x00,0x00,0x00}},

//89	
	{TEXT("shft"),TEXT("shft"),TEXT(""),TEXT(""),
     KB_RSHIFT,39,122,8,14,TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},


//90
    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP,39,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//91
	{TEXT("1"), TEXT("1"),TEXT("1"),TEXT("1"),
     NO_NAME,39,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4F,0x00,0x00,0x00}},

//92
	{TEXT("2"), TEXT("2"),TEXT("2"),TEXT("2"),
     NO_NAME,39,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x50,0x00,0x00,0x00}},

//93
	{TEXT("3"),TEXT("3"),TEXT("3"),TEXT("3"),
     NO_NAME,39,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x51,0x00,0x00,0x00}},

//94
	{TEXT("ent"),TEXT("ent"),TEXT("ent"),TEXT("ent"),
     NO_NAME, 39,193,17,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x1C,0x00,0x00}},


//95
	{TEXT("ctrl"), TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_LCTR,48,1,8,13,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x1D,0x00,0x00,0x00}},

//96
    {TEXT("winlogoUp"), TEXT("winlogoDn"),TEXT("I_winlogo"),TEXT("lwin"),
     ICON, 48, 15 ,8,8,TRUE, KMODIFIER_TYPE,BOTH, REDRAW},

//97
    {TEXT("alt"),TEXT("alt"),TEXT(""),TEXT(""),
	 KB_LALT,48,24,8,8,TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x38,0x00,0x00,0x00}},

//98
//Japanese KB extra key  NO COVERT
    {TEXT("IDB_MHENKAN"),TEXT("IDB_MHENKAN"),TEXT("IDB_MHENKANB"),TEXT("jp"),
	 BITMAP,48,33,8,8,TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 1,
     {0x7B,0x00,0x00,0x00}},

//99
    {TEXT(""),TEXT(""),TEXT(" "),TEXT(" "),
     KB_SPACE,48,42,8,35, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//100
//Japanese KB extra key   CONVERT
    {TEXT("IDB_HENKAN"),TEXT("IDB_HENKAN"),TEXT("IDB_HENKANB"),TEXT(""),
     BITMAP,48,78,8,8, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 1,
     {0x79,0x00,0x00,0x00}},

//101
//Japanese KB extra key
    {TEXT("IDB_KANA"),TEXT("IDB_KANA"),TEXT("IDB_KANAB"),TEXT(""),
     BITMAP,48,87,8,8, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 1,
     {0x70,0x00,0x00,0x00}},

//102
    {TEXT("alt"),TEXT("alt"),TEXT(""),TEXT(""),
     KB_RALT,48,96,8,8, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//103
	{TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"),TEXT("rwin"),
     ICON, 48,105,8,8,TRUE, KMODIFIER_TYPE,LARGE, REDRAW},

//104
	{TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"),TEXT("App"),
     ICON, 48,114,8,8, TRUE, KMODIFIER_TYPE,LARGE, REDRAW},

//105
    {TEXT("ctrl"),TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_RCTR,48,123,8,13,TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x10,0x00,0x00}},

//106
	{TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,138,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

//107
	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//108
	{TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,156,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

//109
    {TEXT("0"),	TEXT("0"),	TEXT("0"),	TEXT("0"),
     NO_NAME, 48,166,8,17, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x52,0x00,0x00,0x00}},

//110
    {TEXT("."),	TEXT("."),	TEXT("."),	TEXT("."),
     NO_NAME, 48,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x53,0x00,0x00,0x00}},


//111
	{TEXT(""), TEXT(""), TEXT(" "), TEXT(" "),
     KB_SPACE,  48,42,8,21, FALSE, KNORMAL_TYPE, SMALL, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//112
	{TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT,  48,82,8,8, TRUE, KMODIFIER_TYPE, SMALL, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//113
	{TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48,91,8,8, TRUE, KMODIFIER_TYPE, SMALL, REDRAW},


//114
	{TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 48,100,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//115
	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,109,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//116
	{TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,118,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

//117
    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP,48,127, 8,9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

	};

	CopyMemory(KBkey, KBkey2, sizeof(KBkey2));

	if(kbPref->smallKb)
	{	KBkey[100].posX = 64;
		KBkey[101].posX = 73;
	}
}
/**********************************************************************/
//Contract the EuropeanKB KB laout structure
/**********************************************************************/
void EuropeanKB(void)
{
	KBkeyRec	KBkey2[]=
	{
	//0
    {TEXT(""), TEXT(""), TEXT(""), TEXT(""),
     NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,BOTH},  //to be investigated??????

    {TEXT("esc"), TEXT("esc"), TEXT("{esc}"), TEXT("{esc}"),
     NO_NAME, 1,1,8,8, TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x01,0x00,0x00,0x00}},

    {TEXT("F1"), TEXT("F1"), TEXT("{f1}"), TEXT("{f1}"),
     NO_NAME, 1,19,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3B,0x00,0x00,0x00}},

    {TEXT("F2"), TEXT("F2"), TEXT("{f2}"), TEXT("{f2}"),
     NO_NAME, 1,28,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3C,0x00,0x00,0x00}},

    {TEXT("F3"), TEXT("F3"), TEXT("{f3}"), TEXT("{f3}"),
     NO_NAME, 1,37,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3D,0x00,0x00,0x00}},

    {TEXT("F4"), TEXT("F4"), TEXT("{f4}"), TEXT("{f4}"),
     NO_NAME, 1,46,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3E,0x00,0x00,0x00}},


    {TEXT("F5"), TEXT("F5"), TEXT("{f5}"), TEXT("{f5}"),
     NO_NAME, 1,60,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3F,0x00,0x00,0x00}},

    {TEXT("F6"), TEXT("F6"), TEXT("{f6}"), TEXT("{f6}"),
     NO_NAME, 1,69,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x40,0x00,0x00,0x00}},

    {TEXT("F7"), TEXT("F7"), TEXT("{f7}"), TEXT("{f7}"),
     NO_NAME, 1,78,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x41,0x00,0x00,0x00}},

    {TEXT("F8"), TEXT("F8"), TEXT("{f8}"), TEXT("{f8}"),
     NO_NAME, 1,87,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x42,0x00,0x00,0x00}},


    {TEXT("F9"), TEXT("F9"), TEXT("{f9}"), TEXT("{f9}"),
     NO_NAME, 1,101,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x43,0x00,0x00,0x00}},

    {TEXT("F10"), TEXT("F10"), TEXT("{f10}"), TEXT("{f10}"),
     KB_LALT, 1,110,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x44,0x00,0x00,0x00}},

    {TEXT("F11"), TEXT("F11"), TEXT("{f11}"), TEXT("{f11}"),
     NO_NAME, 1,119,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x57,0x00,0x00,0x00}},

    {TEXT("F12"), TEXT("F12"), TEXT("{f12}"), TEXT("{f12}"),
     NO_NAME, 1,128,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x58,0x00,0x00,0x00}},


    {TEXT("psc"), TEXT("psc"), TEXT("{PRTSC}"), TEXT("{PRTSC}"),
     KB_PSC, 1,138,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x2A,0xE0,0x37}},

    {TEXT("slk"), TEXT("slk"), TEXT("{SCROLLOCK}"), TEXT("{SCROLLOCK}"),
     KB_SCROLL, 1,147,8, 8,  TRUE, SCROLLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x46,0x00,0x00,0x00}},

    {TEXT("brk"), TEXT("pau"), TEXT("{BREAK}"), TEXT("{^s}"),
     NO_NAME, 1,156,8,8, TRUE, KNORMAL_TYPE, LARGE, REDRAW, 2,
     {0xE1,0x10,0x45,0x00}},


    //17
    {TEXT("`"),	TEXT("~"), TEXT("`"), TEXT("{~}"),
     NO_NAME, 12,1,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x29,0x00,0x00,0x00}},

    {TEXT("1"), TEXT("!"), TEXT("1"), TEXT("!"),
     NO_NAME, 12,10,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x02,0x00,0x00,0x00}},

    {TEXT("2"),	TEXT("@"), TEXT("2"), TEXT("@"),
     NO_NAME, 12,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x03,0x00,0x00,0x00}},

    {TEXT("3"), TEXT("#"), TEXT("3"), TEXT("#"),
     NO_NAME, 12,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x04,0x00,0x00,0x00}},

    {TEXT("4"),	TEXT("$"), TEXT("4"), TEXT("$"),
     NO_NAME, 12,37,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x05,0x00,0x00,0x00}},

    {TEXT("5"), TEXT("%"), TEXT("5"), TEXT("{%}"),
     NO_NAME, 12,46,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x06,0x00,0x00,0x00}},

    {TEXT("6"), TEXT("^"), TEXT("6"), TEXT("{^}"),
     NO_NAME, 12,55,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x07,0x00,0x00,0x00}},

    {TEXT("7"), TEXT("&"), TEXT("7"), TEXT("&"),
     NO_NAME, 12,64,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x08,0x00,0x00,0x00}},

    {TEXT("8"),	TEXT("*"), TEXT("8"), TEXT("*"),
     NO_NAME, 12,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x09,0x00,0x00,0x00}},

    {TEXT("9"),	TEXT("("), TEXT("9"), TEXT("("),
     NO_NAME, 12,82,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0A,0x00,0x00,0x00}},

    {TEXT("0"),	TEXT(")"), TEXT("0"), TEXT(")"),
     NO_NAME, 12,91,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0B,0x00,0x00,0x00}},

    {TEXT("-"), TEXT("_"), TEXT("-"), TEXT("_"),
     NO_NAME, 12,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0C,0x00,0x00,0x00}},

    {TEXT("="),	TEXT("+"), TEXT("="), TEXT("{+}"),
     NO_NAME, 12,109,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0D,0x00,0x00,0x00}},


//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


    {TEXT("bksp"),TEXT("bksp"),TEXT("{BS}"),TEXT("{BS}"),
     NO_NAME, 12,118,8,18,  TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0E,0x00,0x00,0x00}},


    {TEXT("ins"),TEXT("ins"),TEXT("{INSERT}"),TEXT("{INSERT}"),
     NO_NAME, 12,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x52,0x00,0x00}},

    {TEXT("hm"), TEXT("hm"), TEXT("{HOME}"), TEXT("{HOME}"),
     NO_NAME, 12,147,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x47,0x00,0x00}},

    {TEXT("pup"),TEXT("pup"),TEXT("{PGUP}"),TEXT("{PGUP}"),
     NO_NAME, 12,156,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x49,0x00,0x00}},


    {TEXT("nlk"),TEXT("nlk"),TEXT("{NUMLOCK}"),TEXT("{NUMLOCK}"),
     KB_NUMLOCK, 12,166,8,8, FALSE, NUMLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x45,0x00,0x00,0x00}},

    {TEXT("/"),	TEXT("/"), TEXT("/"), TEXT("/"),
     NO_NAME, 12,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x35,0x00,0x00}},

    {TEXT("*"),	TEXT("*"), TEXT("*"), TEXT("*"),
     NO_NAME, 12,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x37,0x00,0x00}},

    {TEXT("-"),	TEXT("-"), TEXT("-"), TEXT("-"),
     NO_NAME, 12,193,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
    {0x4A,0x00,0x00,0x00}},


	//38
    {TEXT("tab"), TEXT("tab"), TEXT("{TAB}"), TEXT("{TAB}"),
     NO_NAME, 21,1,8,13, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0F,0x00,0x00,0x00}},

    {TEXT("q"),	TEXT("Q"), TEXT("q"), TEXT("+q"),
     NO_NAME, 21,15,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x10,0x00,0x00,0x00}},

    {TEXT("w"),	TEXT("W"), TEXT("w"), TEXT("+w"),
     NO_NAME, 21,24,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x11,0x00,0x00,0x00}},

    {TEXT("e"),	TEXT("E"), TEXT("e"), TEXT("+e"),
     NO_NAME, 21,33,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x12,0x00,0x00,0x00}},

    {TEXT("r"),	TEXT("R"), TEXT("r"), TEXT("+r"),
     NO_NAME, 21,42,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x13,0x00,0x00,0x00}},

    {TEXT("t"),	TEXT("T"), TEXT("t"), TEXT("+t"),
     NO_NAME, 21,51,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x14,0x00,0x00,0x00}},

    {TEXT("y"),	TEXT("Y"), TEXT("y"), TEXT("+y"),
     NO_NAME, 21,60,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x15,0x00,0x00,0x00}},

    {TEXT("u"),	TEXT("U"), TEXT("u"), TEXT("+u"),
     NO_NAME, 21,69,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x16,0x00,0x00,0x00}},

    {TEXT("i"),	TEXT("I"), TEXT("i"), TEXT("+i"),
     NO_NAME, 21,78,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x17,0x00,0x00,0x00}},

    {TEXT("o"),	TEXT("O"), TEXT("o"), TEXT("+o"),
     NO_NAME, 21,87,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x18,0x00,0x00,0x00}},

    {TEXT("p"),	TEXT("P"), TEXT("p"), TEXT("+p"),
     NO_NAME, 21,96,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x19,0x00,0x00,0x00}},

    {TEXT("["),	TEXT("{"), TEXT("["), TEXT("{{}"),
     NO_NAME, 21,105,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1A,0x00,0x00,0x00}},

    {TEXT("]"),	TEXT("}"), TEXT("]"), TEXT("{}}"),
     NO_NAME, 21,114,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1B,0x00,0x00,0x00}},

    {TEXT("\\"), TEXT("|"),	TEXT("\\"),	TEXT("|"),
     NO_NAME, 21,123,8,13, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2B,0x00,0x00,0x00}},


    {TEXT("del"), TEXT("del"), TEXT("{DEL}"), TEXT("{DEL}"),
     NO_NAME, 21,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x53,0x00,0x00}},

    {TEXT("end"), TEXT("end"), TEXT("{END}"), TEXT("{END}"),
     NO_NAME, 21,147,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x4F,0x00,0x00}},

    {TEXT("pdn"), TEXT("pdn"), TEXT("{PGDN}"),TEXT("{PGDN}"),
     NO_NAME, 21,156,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x51,0x00,0x00}},


    {TEXT("7"),	TEXT("7"), TEXT("7"), TEXT("7"),
     NO_NAME, 21,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x47,0x00,0x00,0x00}},

    {TEXT("8"),	TEXT("8"), TEXT("8"), TEXT("8"),
     NO_NAME, 21,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x48,0x00,0x00,0x00}},

    {TEXT("9"),	TEXT("9"), TEXT("9"), TEXT("9"),
     NO_NAME, 21,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x49,0x00,0x00,0x00}},

    {TEXT("+"),	TEXT("+"), TEXT("{+}"), TEXT("{+}"),
     NO_NAME, 21,193,17,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4E,0x00,0x00,0x00}},


	//59
    {TEXT("lock"),TEXT("lock"),TEXT("{caplock}"),TEXT("{caplock}"),
     KB_CAPLOCK, 30,1,8,17, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x3A,0x00,0x00,0x00}},

    {TEXT("a"),	TEXT("A"), TEXT("a"), TEXT("+a"),
     NO_NAME, 30,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1E,0x00,0x00,0x00}},

    {TEXT("s"),	TEXT("S"), TEXT("s"), TEXT("+s"),
     NO_NAME, 30,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1F,0x00,0x00,0x00}},

    {TEXT("d"),	TEXT("D"), TEXT("d"), TEXT("+d"),
     NO_NAME, 30,37,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x20,0x00,0x00,0x00}},

    {TEXT("f"), TEXT("F"), TEXT("f"), TEXT("+f"),
     NO_NAME, 30,46,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x21,0x00,0x00,0x00}},

    {TEXT("g"),	TEXT("G"), TEXT("g"), TEXT("+g"),
     NO_NAME, 30,55,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x22,0x00,0x00,0x00}},

    {TEXT("h"), TEXT("H"), TEXT("h"), TEXT("+h"),
     NO_NAME, 30,64,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x23,0x00,0x00,0x00}},

    {TEXT("j"),	TEXT("J"), TEXT("j"), TEXT("+j"),
     NO_NAME, 30,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x24,0x00,0x00,0x00}},

    {TEXT("k"),	TEXT("K"), TEXT("k"), TEXT("+k"),
     NO_NAME, 30,82,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x25,0x00,0x00,0x00}},

    {TEXT("l"),	TEXT("L"), TEXT("l"), TEXT("+l"),
     NO_NAME, 30,91,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x26,0x00,0x00,0x00}},

    {TEXT(";"),	TEXT(":"), TEXT(";"), TEXT("+;"),
     NO_NAME, 30,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x27,0x00,0x00,0x00}},

    {TEXT("'"),	TEXT("''"),	TEXT("'"), TEXT("''"),
     NO_NAME, 30,109,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x28,0x00,0x00,0x00}},


//Japanese KB extra key      //DUMMY
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 123,  8,	13, FALSE, KNORMAL_TYPE, NOTSHOW, REDRAW, 1, {0x2B,0x00,0x00,0x00}},

    {TEXT("ent"),TEXT("ent"),TEXT("{enter}"),TEXT("{enter}"),
     NO_NAME, 30,118,8,18, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x1C,0x00,0x00,0x00}},


    {TEXT("4"),	TEXT("4"), TEXT("4"), TEXT("4"),
     NO_NAME, 30,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4B,0x00,0x00,0x00}},

    {TEXT("5"), TEXT("5"), TEXT("5"), TEXT("5"),
     NO_NAME, 30,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4C,0x00,0x00,0x00}},

    {TEXT("6"), TEXT("6"), TEXT("6"), TEXT("6"),
     NO_NAME, 30,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4D,0x00,0x00,0x00}},
/*
	//75
	{TEXT("shft"), TEXT("shft"), TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,21, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},
*/

	//75
	{TEXT("shft"), TEXT("shft"), TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,12, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},

     //Japanese KB extra key and also
	 //European KB extra key
    {TEXT("jp"),	TEXT("jp"), TEXT("jp"), TEXT("jp"),
     NO_NAME, 39,14,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x56,0x00,0x00,0x00}},

    {TEXT("z"), TEXT("Z"), TEXT("z"), TEXT("+z"),
     NO_NAME, 39,23,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
    {0x2C,0x00,0x00,0x00}},

    {TEXT("x"), TEXT("X"), TEXT("x"), TEXT("+x"),
     NO_NAME, 39,32,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2D,0x00,0x00,0x00}},

    {TEXT("c"),	TEXT("C"), TEXT("c"), TEXT("+c"),
     NO_NAME, 39,41,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2E,0x00,0x00,0x00}},

    {TEXT("v"),	TEXT("V"), TEXT("v"), TEXT("+v"),
     NO_NAME, 39,50,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2F,0x00,0x00,0x00}},

    {TEXT("b"), TEXT("B"), TEXT("b"), TEXT("+b"),
     NO_NAME, 39,59,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x30,0x00,0x00,0x00}},

    {TEXT("n"),	TEXT("N"), TEXT("n"), TEXT("+n"),
     NO_NAME, 39,68,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x31,0x00,0x00,0x00}},

    {TEXT("m"),	TEXT("M"), TEXT("m"), TEXT("+m"),
     NO_NAME, 39,77,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x32,0x00,0x00,0x00}},

    {TEXT(","),	TEXT("<"), TEXT(","), TEXT("+<"),
     NO_NAME, 39,86,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x33,0x00,0x00,0x00}},

    {TEXT("."),	TEXT(">"), TEXT("."), TEXT("+>"),
     NO_NAME, 39,95,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x34,0x00,0x00,0x00}},

    {TEXT("/"),	TEXT("?"), TEXT("/"), TEXT("+/"),
     NO_NAME, 39,104,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x35,0x00,0x00,0x00}},
/*
     //Japanese KB extra key and also
	 //European KB extra key
    {TEXT("jp"),	TEXT("jp"), TEXT("jp"), TEXT("jp"),
     NO_NAME, 39,113,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x56,0x00,0x00,0x00}},

	{TEXT("shft"),  TEXT("shft"),   TEXT(""),   TEXT(""),
     KB_RSHIFT, 39,122,8,14, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},
*/
	{TEXT("shft"),  TEXT("shft"),   TEXT(""),   TEXT(""),
     KB_RSHIFT, 39,113,8,23, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},

    // 87
    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 39,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},


    {TEXT("1"), TEXT("1"), TEXT("1"), TEXT("1"),
     NO_NAME, 39,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4F,0x00,0x00,0x00}},

    {TEXT("2"),	TEXT("2"), TEXT("2"), TEXT("2"),
     NO_NAME, 39,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x50,0x00,0x00,0x00}},

    {TEXT("3"),	TEXT("3"), TEXT("3"), TEXT("3"),
     NO_NAME, 39,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x51,0x00,0x00,0x00}},

    {TEXT("ent"),TEXT("ent"),TEXT("ent"),TEXT("ent"),
     NO_NAME, 39,193,17,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x1C,0x00,0x00}},


	//92
    {TEXT("ctrl"), TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_LCTR,48,1,8,13,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x1D,0x00,0x00,0x00}},

    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("lwin"),
     ICON, 48, 15 ,8,8,TRUE, KMODIFIER_TYPE,BOTH, REDRAW},

    {TEXT("alt"), TEXT("alt"),	TEXT(""), TEXT(""),
     KB_LALT, 48,24,8,13, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x38,0x00,0x00,0x00}},

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

    //95
    {TEXT(""), TEXT(""), TEXT(" "), TEXT(" "),
     KB_SPACE,48,38,8,52, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

    {TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT, 48,91,8,13, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("rwin"),
     ICON, 48, 105 ,8,8,TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

    {TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48, 114 ,8,8,TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

    {TEXT("ctrl"), TEXT("ctrl"), TEXT(""), TEXT(""),
     KB_RCTR, 48,123,8,13, TRUE, KMODIFIER_TYPE,LARGE, REDRAW, 2,
     {0xE0,0x10,0x00,0x00}},


    {TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,138,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,147,8, 8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,156,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},


    {TEXT("0"), TEXT("0"), TEXT("0"), TEXT("0"),
     NO_NAME, 48,166,8,17, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x52,0x00,0x00,0x00}},

    {TEXT("."),	TEXT("."), TEXT("."), TEXT("."),
     NO_NAME, 48,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x53,0x00,0x00,0x00}},


    //105
    {TEXT(""),      TEXT(""),       TEXT(" "),  TEXT(" "),
     KB_SPACE, 48,38,8,38, FALSE, KNORMAL_TYPE, SMALL, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},


	{TEXT("alt"),   TEXT("alt"),    TEXT(""),   TEXT(""),
     KB_RALT, 48,77,8,13, TRUE, KMODIFIER_TYPE, SMALL, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

	{TEXT("MenuKeyUp"),TEXT("MenuKeyDn"),TEXT("I_MenuKey"),TEXT("App"),
     ICON, 48,91,8,8, TRUE, KMODIFIER_TYPE, SMALL, REDRAW},


    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 48,100,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

    {TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,109,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

    {TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,118,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,127,8, 9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

	};
	
	CopyMemory(KBkey, KBkey2, sizeof(KBkey2));

}

// Helper functions for combo boxes

int GetComboItemData(HWND hwnd)
{
    int iValue = CB_ERR;
    LRESULT iCurSel = SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iCurSel != CB_ERR)
        iValue = SendMessageInt(hwnd, CB_GETITEMDATA, iCurSel, 0);

    return iValue;
}

void FillAndSetCombo(HWND hwnd, int iMinVal, int iMaxVal, int iIncr, int iSelVal, LPTSTR pszLabel)
{
    int i;
    int iSelPos = -1;

    SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

    for (i=0;iMaxVal >= iMinVal;i++)
    {
        TCHAR pszItem[100];
        int iPos;

        wsprintf(pszItem, TEXT("%s %s"), CvtToDblString(iMaxVal), pszLabel);
        iPos = SendMessageInt(hwnd, CB_ADDSTRING, 0, (LPARAM)pszItem);
        if (iPos != CB_ERR)
        {
            SendMessage(hwnd, CB_SETITEMDATA, iPos, iMaxVal);

            // This used to be finer granularity so 
            // iSelVal may be between two items
            if (iSelPos < 0 && iSelVal >= iMaxVal)
                iSelPos = iPos; // note the current selection
        }
        iMaxVal-=iIncr;
    }

    // show the current value
    SendMessage(hwnd, CB_SETCURSEL, iSelPos, 0);
}

void SelNearestComboItem(HWND hwnd, int iFindVal)
{
    int i;
    int iSelPos = -1;
    int cItems = SendMessageInt(hwnd, CB_GETCOUNT, 0, 0);
    // search thru item data of combo box for iFindVal
    // (allow finding values between items)
    for (i=0;i<cItems;i++)
    {
        int iItemData = SendMessageInt(hwnd, CB_GETITEMDATA, i, 0);
        if (iItemData != CB_ERR)
        {
            if (iFindVal >= iItemData)
            {
                iSelPos = i;
                break;
            }
        }
    }

    // show the current value
    SendMessage(hwnd, CB_SETCURSEL, iSelPos, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\fileutil.c ===
//FILEUTIL.C    file utilities

#define STRICT

#include <windows.h>
#include <malloc.h>

#include "kbmain.h"
#include "resource.h"

//
// This header contains the default settings in a global variable.
// This file was generated from the osksetti.reg file using a perl
// script.  If the:
//   Software\\Microsoft\\Osk  key is missing or the 
//   Settings value is empty then we will create this value from this varable.
//
#include "osksetti.h"


#define ACL_BUFFER_SIZE     1024
#define REG_INSTALLED       TEXT("Installed")      // Last value written during
                                                   // application installation.
/****************************************************************************/
extern BOOL settingChanged;
extern DWORD platform;

/****************************************************************************/
/*    FUNCTIONS IN THIS FILE											    */
/****************************************************************************/

PSID GetCurrentUserInfo(void);
BOOL RunningAsAdministrator(void);
BOOL OpenUserSetting(void);
BOOL SaveUserSetting(void);

/**************************************************************/


PSID GetCurrentUserInfo(void)
{
   // This function returns security information about the person who owns
   // this thread.

   HANDLE htkThread;

   TOKEN_USER *ptu;
   DWORD      cbtu;

   TOKEN_GROUPS *ptg = NULL;
   SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;

   // First we must open a handle to the access token for this thread.

   if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &htkThread))
      if (GetLastError() == ERROR_NO_TOKEN)
      {
         // If the thread does not have an access token, we'll examine the
         // access token associated with the process.

         if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &htkThread))
         return NULL;
      }
      else return NULL;


   if (GetTokenInformation(htkThread, TokenUser, NULL, 0, &cbtu))
      return NULL;

   // Here we verify that GetTokenInformation failed for lack of a large
   // enough buffer.

   if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
      return NULL;

   // Now we allocate a buffer for the group information.
   // Since _alloca allocates on the stack, we don't have
   // to explicitly deallocate it. That happens automatically
   // when we exit this function.

   if (!(ptu= LocalAlloc(LPTR, cbtu))) return NULL;

   // Now we ask for the user information again.
   // This may fail if an administrator has changed SID information
   // for this user.

   if (!GetTokenInformation(htkThread, TokenUser, ptu, cbtu, &cbtu))
   {
       LocalFree(ptu);
       return NULL;
   }

   return ptu;
}
/***************************************************************************/

typedef HRESULT (*CHECKTOKENMEMBERSHIP)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

// CheckToken Returns TRUE if we were able to GetProcAddress on NT5's CheckTokenMembership,
// returns FALSE otherwise.
BOOL CheckToken(HANDLE hAccessToken, BOOL *pfIsAdmin)
{
    BOOL bNewNT5check = FALSE;
    HINSTANCE hAdvapi32 = NULL;
    CHECKTOKENMEMBERSHIP pf;
    PSID AdministratorsGroup;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    hAdvapi32 = LoadLibrary(TEXT("advapi32.dll"));
    if (hAdvapi32)
    {
        pf = (CHECKTOKENMEMBERSHIP)GetProcAddress(hAdvapi32, "CheckTokenMembership");
        if (pf)
        {
            bNewNT5check = TRUE;

            if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
            {
                pf(hAccessToken, AdministratorsGroup, pfIsAdmin);
                FreeSid(AdministratorsGroup);
            }
        }
        FreeLibrary(hAdvapi32);
    }
    return bNewNT5check;
}

// Returns true if our process has admin priviliges.
// Returns false otherwise.
// We need to know this in order to start UtilMan as an app when we
// do it from menu under non-admin account
// We also return FALSE when any allocation or other error is encountered
BOOL RunningAsAdministrator()
{
   BOOL  fAdmin = FALSE;
   HANDLE htkThread;
   TOKEN_GROUPS *ptg = NULL;
   DWORD cbTokenGroups;
   DWORD iGroup;
   SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
   PSID psidAdmin = 0;

   // This function returns TRUE if the user identifier associated with this
   // process is a member of the the Administrators group.

   // First we must open a handle to the access token for this thread.

   if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &htkThread))
   {
      if (GetLastError() == ERROR_NO_TOKEN)
      {
         // If the thread does not have an access token, we'll examine the
         // access token associated with the process.

         if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &htkThread))
         {
             return FALSE;
         }
      }
      else
      {
          return FALSE;
      }
   }

   // early out by calling NT5's new CheckTokenMembership function
   if (CheckToken(htkThread, &fAdmin))
   {
       goto bail;
   }
   // Then we must query the size of the group information associated with
   // the token. Note that we expect a FALSE result from GetTokenInformation
   // because we've given it a NULL buffer. On exit cbTokenGroups will tell
   // the size of the group information.

   if (GetTokenInformation(htkThread, TokenGroups, NULL, 0, &cbTokenGroups))
   {
       goto bail;
   }

   // Here we verify that GetTokenInformation failed for lack of a large
   // enough buffer.

   if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
      goto bail;

   // Now we allocate a buffer for the group information.
   // Since _alloca allocates on the stack, we don't have
   // to explicitly deallocate it. That happens automatically
   // when we exit this function.

   if (!(ptg= LocalAlloc(LPTR, cbTokenGroups))) return FALSE;

   // Now we ask for the group information again.
   // This may fail if an administrator has added this account
   // to an additional group between our first call to
   // GetTokenInformation and this one.

    if (!GetTokenInformation(htkThread, TokenGroups, ptg, cbTokenGroups, 
                            &cbTokenGroups))
    {
        goto bail;
    }

   // Now we must create a System Identifier for the Admin group.

   if (!AllocateAndInitializeSid
          (&SystemSidAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &psidAdmin
          )
      )
   {
      goto bail;
   }

   // Finally we'll iterate through the list of groups for this access
   // token looking for a match against the SID we created above.


   for (iGroup= 0; iGroup < ptg->GroupCount; iGroup++)
   {
      if (EqualSid(ptg->Groups[iGroup].Sid, psidAdmin))
      {
         fAdmin = TRUE;
         break;
      }
   }

bail:
   CloseHandle(htkThread);

   if (psidAdmin)
      FreeSid(psidAdmin);

   if (ptg)
       LocalFree(ptg);

   return fAdmin;
}

/****************************************************************************/
BOOL OpenUserSetting(void)
{  
//   HKEY hkGlobal;
   TCHAR pathbuff[50]=TEXT("Software\\Microsoft\\Osk");
   
   HKEY hkPerUser  = NULL;
   LONG lResult;
   DWORD dwType, cbData, dwStepping;
   DWORD dwDisposition;
   TOKEN_USER *ptu = NULL;
   PSID psidUser   = NULL,
        psidAdmins = NULL;
   PACL  paclKey = NULL;
   SID_IDENTIFIER_AUTHORITY		SystemSidAuthority= SECURITY_NT_AUTHORITY;
   SECURITY_ATTRIBUTES sa;
   SECURITY_DESCRIPTOR sdPermissions;

   TCHAR errstr[256]=TEXT("");
   TCHAR title[256]=TEXT("");
    //a-anilk
   int actualKeybdType;
   // First we'll setup the security attributes we're going to
   // use with the application's global key.

   sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
   sa.bInheritHandle       = FALSE;
   sa.lpSecurityDescriptor = &sdPermissions;

	// ***  Do extra checking if we are in NT  ***
	if(platform == VER_PLATFORM_WIN32_NT)   
	{	
		// Here we're creating a System Identifier (SID) to represent
		// the Admin group.
		if (!AllocateAndInitializeSid
			  (&SystemSidAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &psidAdmins))
        {
			goto security_failure;
        }

		// We also need a SID for the current user.

		if (!(ptu= GetCurrentUserInfo()) || !(psidUser= ptu->User.Sid)) 
			goto security_failure;

		if (!InitializeSecurityDescriptor(&sdPermissions, 
                                          SECURITY_DESCRIPTOR_REVISION1))
        {
			goto security_failure;
        }

		// We want the current user to own this key.

		if (!SetSecurityDescriptorOwner(&sdPermissions, psidUser, 0))
			goto security_failure;

		// Finally we must allocate and construct the discretionary
		// access control list (DACL) for the key.

		// Note that _alloca allocates memory on the stack frame
		// which will automatically be deallocated when this routine
		// exits.

		if (!(paclKey= (PACL) LocalAlloc(LPTR, ACL_BUFFER_SIZE)))
			goto memory_limited;

		if (!InitializeAcl(paclKey, ACL_BUFFER_SIZE, ACL_REVISION2))
			goto security_failure;

		// Our DACL will two access control entries (ACEs). The first ACE
		// provides full access to the current user. The second ACE gives
		// the Admin group full access. By default all other users will have
		// no access to the key.

		// The reason for admin access is to allow an administrator to
		// run special utilties to cleanup inconsistencies and disasters
		// in the per-user data area.

		if (!AddAccessAllowedAce(paclKey, ACL_REVISION2, KEY_ALL_ACCESS, psidUser))
			goto security_failure;

		if (!AddAccessAllowedAce(paclKey, ACL_REVISION2, KEY_ALL_ACCESS, psidAdmins))
			goto security_failure;

		// We must bind this DACL to the security descriptor...

		if (!SetSecurityDescriptorDacl(&sdPermissions, TRUE, paclKey, FALSE))
			goto security_failure;

	}   //end of extra checking for NT
    
	// Now we'll attempt to create the key with the security attributes...

	lResult= RegCreateKeyEx(HKEY_CURRENT_USER, 
                            &pathbuff[0], 
                            0,
                            TEXT("Application Per-User Data"), 
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            &sa, 
                            &hkPerUser, 
                            &dwDisposition);

	if (lResult != ERROR_SUCCESS) 
    {
        goto registry_access_error;
    }

   // Usually the disposition value will indicate that we've created a
   // new key. Sometimes it may instead state that we've opened an existing
   // key. This can happen when installation is incomplete and interrupted,
   // say by loss of electrical power.

	if ((dwDisposition != REG_CREATED_NEW_KEY) && 
        (dwDisposition != REG_OPENED_EXISTING_KEY)) 
    {
		goto registry_access_error;
    }

	
	kbPref = (KBPREFINFO *)malloc(sizeof(KBPREFINFO));   

    if (kbPref == NULL)
        goto memory_limited;

    dwType=REG_DWORD;
    cbData=sizeof(DWORD);
    lstrcpy(pathbuff,TEXT("Stepping"));
	lResult=RegQueryValueEx(hkPerUser, &pathbuff[0], NULL, &dwType, 
                            (LPBYTE)&dwStepping, &cbData); 

    if (lResult != ERROR_SUCCESS)
        dwStepping=0;

	dwType= REG_BINARY;
	cbData= sizeof(KBPREFINFO);
	lstrcpy(pathbuff, TEXT("Setting"));
	lResult=RegQueryValueEx(hkPerUser, &pathbuff[0], NULL, &dwType, 
                            (LPBYTE)kbPref, &cbData); 

	if((lResult != ERROR_SUCCESS) || (dwStepping < CURRENT_STEPPING)) 
    {
        //
        // if it is not there then create the default Settings value
        //
        RegSetValueEx(hkPerUser, pathbuff, 0, REG_BINARY,  
                      g_DefaultSettings, sizeof(g_DefaultSettings));
        
    	cbData= sizeof(KBPREFINFO);
	    lResult=RegQueryValueEx(hkPerUser, &pathbuff[0], NULL, &dwType, 
                                (LPBYTE)kbPref, &cbData); 

        // HACK by a-anilk
        // This is the place where the Default values are taken by OSK. 
        // Just change the keyboard layout based on the keyboard type used
        actualKeybdType = GetKeyboardType(0);
        switch(actualKeybdType)
        {
            case 1:
            case 3:
            case 4:
            case 5:
            case 6:
                // 101 keyboard
                kbPref->KBLayout = 101;
                break;

            case 2:
                // 102 keyboard
                kbPref->KBLayout = 102;
                break;

            case 7:
                // Japanese Keyboard
                kbPref->KBLayout = 106;
                break;

            default:
                // 101 keyboard
                kbPref->KBLayout = 101;
                break;
        }

        if (lResult != ERROR_SUCCESS)
    		goto registry_access_error;

        //
        // update the stepping
        //
        dwType=REG_DWORD;
	    cbData=sizeof(DWORD);
        lstrcpy(pathbuff,TEXT("Stepping"));
        dwStepping=CURRENT_STEPPING;

        RegSetValueEx(hkPerUser, pathbuff, 0, REG_DWORD,  
                      (LPBYTE)&dwStepping, sizeof(DWORD));
    }

	RegCloseKey(hkPerUser);
	FreeSid(psidAdmins);
	LocalFree(ptu);
    if (paclKey)
    {
        LocalFree(paclKey);
        paclKey = NULL;
    }

	return(TRUE);

//**************
//Error handler
//**************

registry_access_error:

	LoadString(hInst, IDS_REGISTRY_ACCESS_ERROR, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
	MessageBox(0, errstr, title, MB_OK|MB_ICONHAND);
    goto clean_up_after_failure;

memory_limited:

	LoadString(hInst, IDS_MEMORY_LIMITED, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
	MessageBox(0, errstr, title, MB_OK|MB_ICONHAND);
    goto clean_up_after_failure;

security_failure:

	LoadString(hInst, IDS_SECURITY_FAILURE, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
	MessageBox(0, errstr, title, MB_OK|MB_ICONHAND);

clean_up_after_failure:

    if (psidAdmins) 
        FreeSid(psidAdmins);
    if (ptu) 
	    LocalFree(ptu);
    if (paclKey)
    {
        LocalFree(paclKey);
        paclKey = NULL;
    }

   return FALSE;
}
/****************************************************************************/
BOOL SaveUserSetting(void)
{  
//    HKEY hkGlobal;
    TCHAR pathbuff[50]=TEXT("Software\\Microsoft\\Osk");
    TCHAR errstr[256];
    TCHAR title[256];
   
    HKEY hkPerUser  = NULL;
    LONG lResult;
    DWORD dwDisposition;

    TOKEN_USER *ptu = NULL;

    PSID psidUser   = NULL;
    PSID psidAdmins = NULL;

    PACL  paclKey = NULL;

    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;

    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sdPermissions;

	

   // First we'll see whether this user has admin privileges...
//   if (RunningAsAdministrator())
//		MessageBox(0, TEXT("Running as administrator"), TEXT("Admin"), MB_OK);




   // First we'll setup the security attributes we're going to
   // use with the application's global key.

   sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
   sa.bInheritHandle       = FALSE;
   sa.lpSecurityDescriptor = &sdPermissions;

	// ***  Do extra checking if we are in NT  ***
	if(platform == VER_PLATFORM_WIN32_NT)   
	{
   
		// Here we're creating a System Identifier (SID) to represent
		// the Admin group.

		if (!AllocateAndInitializeSid
			  (&SystemSidAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
				                       DOMAIN_ALIAS_RID_ADMINS,
					                   0, 0, 0, 0, 0, 0,
						               &psidAdmins))
        {
			goto security_failure;
        }

		// We also need a SID for the current user.

		if (!(ptu= GetCurrentUserInfo()) || !(psidUser= ptu->User.Sid)) 
			goto security_failure;

        if (!InitializeSecurityDescriptor(&sdPermissions, 
                                          SECURITY_DESCRIPTOR_REVISION1))
        {
			goto security_failure;
        }

		// We want the current user to own this key.

		if (!SetSecurityDescriptorOwner(&sdPermissions, psidUser, 0))
			goto security_failure;

		// Finally we must allocate and construct the discretionary
		// access control list (DACL) for the key.

		// Note that _alloca allocates memory on the stack frame
		// which will automatically be deallocated when this routine
		// exits.

		if (!(paclKey= (PACL) LocalAlloc(LPTR, ACL_BUFFER_SIZE)))
			goto memory_limited;

		if (!InitializeAcl(paclKey, ACL_BUFFER_SIZE, ACL_REVISION2))
			goto security_failure;

		// Our DACL will two access control entries (ACEs). The first ACE
		// provides full access to the current user. The second ACE gives
		// the Admin group full access. By default all other users will have
		// no access to the key.

		// The reason for admin access is to allow an administrator to
		// run special utilties to cleanup inconsistencies and disasters
		// in the per-user data area.

		if (!AddAccessAllowedAce(paclKey, ACL_REVISION2, KEY_ALL_ACCESS, 
                                 psidUser))
        {
            goto security_failure;
        }

        if (!AddAccessAllowedAce(paclKey, ACL_REVISION2, KEY_ALL_ACCESS, 
                                 psidAdmins))
        {
            goto security_failure;
        }

		// We must bind this DACL to the security descriptor...

		if (!SetSecurityDescriptorDacl(&sdPermissions, TRUE, paclKey, FALSE))
			goto security_failure;

	}	//end of extra checking for NT

   
   // Now we'll attempt to create the key with the security attributes...

   lResult= RegCreateKeyEx(HKEY_CURRENT_USER, &pathbuff[0], 0,
                           TEXT("Application Per-User Data"), 
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           &sa, &hkPerUser, &dwDisposition
                          );

   if (lResult != ERROR_SUCCESS) goto registry_access_error;

   // Usually the disposition value will indicate that we've created a
   // new key. Sometimes it may instead state that we've opened an existing
   // key. This can happen when installation is incomplete and interrupted,
   // say by loss of electrical power.

    if (dwDisposition != REG_CREATED_NEW_KEY  &&
        dwDisposition != REG_OPENED_EXISTING_KEY) 
    {
        goto registry_access_error;
    }


	//Save the whole setting
	lstrcpy(pathbuff, TEXT("Setting"));
	lResult= RegSetValueEx(hkPerUser, &pathbuff[0], 0, REG_BINARY,
                           (LPBYTE) kbPref, sizeof(KBPREFINFO));

	if (lResult != ERROR_SUCCESS) 
		goto registry_access_error;

   RegCloseKey(hkPerUser);
   FreeSid(psidAdmins);
   LocalFree(ptu);

   free(kbPref);		//v-mjgran: Memory Leak fixed

   if (paclKey)
   {
       LocalFree(paclKey);
       paclKey = NULL;
   }

   return(TRUE);

//Error handling

registry_access_error:

    LoadString(hInst, IDS_REGISTRY_ACCESS_ERROR, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
    MessageBox(0, errstr, title, MB_OK|MB_ICONHAND);
    goto clean_up_after_failure;

memory_limited:

    LoadString(hInst, IDS_MEMORY_LIMITED, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
    MessageBox(0, errstr,title, MB_OK|MB_ICONHAND);
    goto clean_up_after_failure;

security_failure:

    LoadString(hInst, IDS_SECURITY_FAILURE, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
    MessageBox(0, errstr, title, MB_OK|MB_ICONHAND);

clean_up_after_failure:

   if (psidAdmins) 
	   FreeSid(psidAdmins);
   if (ptu) 
	   LocalFree(ptu);
   if (paclKey)
   {
       LocalFree(paclKey);
       paclKey = NULL;
   }

   return FALSE;
}



/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OSK.rc
//
#define IDS_TITLE1                      1
#define IDS_TITLE2                      2
#define IDS_TITLE3                      3
#define IDS_CANNOTCREATEDLG             4
#define IDS_REGISTRY_DAMAGE             5
#define IDS_REGISTRY_ACCESS_ERROR       6
#define IDS_MEMORY_LIMITED              7
#define IDS_SECURITY_FAILURE            8
#define IDS_CANNOT_REGISTER             9
#define chk_AlwaysOnTop                 10
#define radio_LargeKB                   11
#define IDS_CANNOT_SWITCH_LANG          11
#define radio_SmallKB                   12
#define IDS_CANNOT_CREATE_KB            12
#define chk_ClickSound                  13
#define IDS_CANNOT_CREATE_KEY           13
#define chk_Dwell                       14
#define IDS_CANNOT_LOAD_ICON            14
#define chk_Scan                        15
#define radio_Actual                    16
#define IDS_MAIL                        16
#define radio_Block                     17
#define IDS_CANNOT_OPEN_SWPORT          17
#define IDS_SETTING_DAMAGE              18
#define IDS_MOUSE_HOOK                  19
#define IDS_JOURNAL_HOOK                20
#define IDS_ABOUTBOX                    21
#define IDS_CREDITSBOX                  22
#define IDS_THANKYOU                    23
#define IDS_MOUSE_UNHOOK                24
#define IDS_JOURNAL_UNHOOK              25
#define IDS_ADDTOUM                     26
#define IDS_REMUM                       27
#define IDS_WARNING_MSG                 28
#define IDS_SPACE_KEY                   29
#define IDS_ENTER_KEY                   30
#define IDS_F2_KEY                      31
#define IDS_F3_KEY                      32
#define IDS_F4_KEY                      33
#define IDS_F5_KEY                      34
#define IDS_F6_KEY                      35
#define IDS_F7_KEY                      36
#define IDS_F8_KEY                      37
#define IDS_F9_KEY                      38
#define IDS_F12_KEY                     39
#define IDS_ENABLEWEB                   40
#define IDS_TSERROR                     41
#define IDS_TOOLTIP                     42
#define IDS_SECONDS                     43
#define IDC_CURHAND                     105
#define IDD_ABOUT                       148
#define IDC_CURHAND1                    156
#define IDD_SPLASH                      159
#define IDD_CREDITS                     166
#define WAV_CLICKDN                     179
#define WAV_CLICKUP                     180
#define WAV_SWITCH_CLICK                182
#define DLG_TYPE_MODE                   184
#define IDD_ADVANCE_SCANNING            185
#define IDB_BITMAP1                     188
#define IDB_BITMAP5                     232
#define IDD_WARNING_MSG                 266
#define chk_Click                       1005
#define IDC_TXT4                        1030
#define IDC_TXT7                        1034
#define BUT_ADVANCED                    1040
#define CHK_PORT                        1041
#define CHK_KEY                         1042
#define COMBO_KB_KEY                    1043
#define IDC_CHECK1                      1058
#define IDC_SHOW_AGAIN                  1058
#define IDC_HOVER_DESC                  1062
#define IDC_SCAN_DESC                   1063
#define IDC_WARNING_TEXT1               1064
#define IDC_ABOUTDISCLAIMER             1065
#define IDC_WARNING_TEXT2               1065
#define IDC_ABOUTWEBSITE                1066
#define IDC_ENABLEWEB2                  1067
#define IDC_CMB_DWELL                   1068
#define IDC_CMB_SCAN                    1069
#define IDC_ENABLEWEB                   1086
#define IDC_WARND3                      1087
#define IDM_Open                        4001
#define IDM_Save                        4003
#define IDM_SaveAs                      4004
#define IDM_Exit                        4005
#define IDM_SettoDefault                4015
#define IDM_Setting                     4019
#define IDM_ALWAYS_ON_TOP               4019
#define CM_HELPABOUT                    4027
#define CM_HELPTOPICS                   4028
#define IDC_WARNING_ICON                32515
#define IDM_LARGE_KB                    40001
#define IDM_SMALL_KB                    40002
#define IDM_CLICK_SOUND                 40003
#define IDM_REGULAR_LAYOUT              40004
#define IDM_BLOCK_LAYOUT                40005
#define IDM_TYPE_MODE                   40006
#define IDM_SET_FONT                    40007
#define IDM_JAPAN_LAYOUT                40008
#define IDM_101_LAYOUT                  40008
#define IDM_102_LAYOUT                  40009
#define IDM_106_LAYOUT                  40010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        267
#define _APS_NEXT_COMMAND_VALUE         40012
#define _APS_NEXT_CONTROL_VALUE         1069
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\scan.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// Updated :1999 Anil Kumar and Maria Jose
// 

#include <windows.h>
#include <mmsystem.h>
#include "kbmain.h"
#include "kbus.h"
#include "resource.h"
#include "msswch.h"
#include "w95trace.h"

#define SCANTIMER	123    //timer identifier
#define NUMOFTIME   2      //after scan this many time of each key, 
                           //back to scan row : a-anilk

#define ROW1	1
#define ROW2	12
#define ROW3	21
#define ROW4	30
#define ROW5	39
#define ROW6	48
static int aiRows[] = {-1/*dummy*/, ROW1, ROW2, ROW3, ROW4, ROW5, ROW6};

#define COL1	  1
#define COL2	  52
#define COL3	  103
#define COL4	  153
#define COL4_END  202
#define COL4S     103   //Small KB
#define COL4S_END 143   //Small KB

int count=0;

UINT_PTR TimerS1;       //Timer for scanning
int g_iCurRowYPos = 1;  //current row which is scanning
int CurKey=0;       //current key which is scanning
int LastKey=0;      //Last scanned key in Small keyboard
int ScanState=0;    //State : Row scan / Key scan
int CurCol= COL1;

extern HWND g_hBitmapLockHwnd;

__inline ChangeBGColor(HWND hwnd)
{
    SetWindowLong(hwnd, 0, 4);
    SetBackgroundColor(hwnd, COLOR_HOTLIGHT);
    InvalidateRect(hwnd, NULL, TRUE);
}

/***********************************************/
//			Functions in this file
/***********************************************/

#include "scan.h"

void ScanningSound(int what);


/***********************************************/
//			Functions in other file
/***********************************************/
#include "ms32dll.h"
extern BOOL RedrawNumLock();
extern BOOL RedrawScrollLock();

/***************************************************************/
void Scanning(int from)
{	
	count = 0;   //reset this counter of key scan

	//Play some sound
	ScanningSound(3);

	if(kbPref->Actual)
		Scanning_Actual(from);
	else
		Scanning_Block(from);
}

/***************************************************************/
// Actual layout
/***************************************************************/
void Scanning_Actual(int from)
{	
	ScanState = ScanState + from;
	
	count = 0;   //reset this counter of key scan

	switch (ScanState)
	{
		case 0:
			KillScanTimer(TRUE);
			break;
	
		case 1:		//Row scanning
			KillScanTimer(FALSE);
			CurKey = 0;  //reset to 0 anyway
			TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)LineScanProc);
			break;
	
		case 2:		//key scanning
			KillScanTimer(FALSE);
			switch (kbPref->KBLayout)
			{
				case 101:
					TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)KeyScanProc_Actual_101);
					break;
				case 106:
					TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)KeyScanProc_Actual_106);
					break;
				case 102:
					TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)KeyScanProc_Actual_102);
					break;
				default:
					break;	// internal error!
			}
			break;
	
		default:     //stop scanning and send char
			KillScanTimer(FALSE);
			swchCheckForScanChar(FALSE); // flag msswch dll to not check for scan char

			if (smallKb && (LastKey != 0))
			{
				SendChar(lpkeyhwnd[LastKey]);
			}
			else
			{
				SendChar(lpkeyhwnd[CurKey-1]);
			}
			
			ScanState = 0;
			CurKey = 0;

			//Post a message to call Scanning again to avoid recursive call
			PostMessage(g_hwndOSK, WM_USER + 1, 0L, 0L);
			break;
	}
}

/****************************************************************/
// Scan each row. Both Actual and Block
/****************************************************************/
void CALLBACK LineScanProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
    int i, iPrevRowIndex;
    static int s_iRowIndex = 1;

    // quit scanning if we've cycled NUMOFTIME times w/no scan key

	if (count == NUMOFTIME)
	{	
		Scanning(-1);
		return;
	}

    // get the previous row to be restored and restore it

    iPrevRowIndex = s_iRowIndex - 1;
    if (iPrevRowIndex < 1)
        iPrevRowIndex = 6;

    RestoreRowColor(aiRows[iPrevRowIndex]);
    g_iCurRowYPos = aiRows[s_iRowIndex];

    // change the background of each key in the current row

    for (i=1; i < lenKBkey; i++)
    {	
        if (KBkey[i].posY == g_iCurRowYPos)
        {
            ChangeBGColor(lpkeyhwnd[i]);
        }
    }
	
	ScanningSound(1);	// play sound?
	
	s_iRowIndex++;        // update the current row index

	if (s_iRowIndex == 7) // last row, reset to first row 
	{	
        s_iRowIndex = 1;
		count++;
	}
}

/******************************************************************************/
// Scan each key in Actual 101 kb
/******************************************************************************/
void CALLBACK KeyScanProc_Actual_101(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
    register int j=0;

	if(CurKey == 0)
	{	
		//move to the correct row
		while ((KBkey[j].posY != g_iCurRowYPos) && (j < lenKBkey))
			j++;
		CurKey = j;
	}

	//Skip all the dummy key
	for(CurKey;KBkey[CurKey].smallKb == NOTSHOW;CurKey++);

	//Scan each key
	if (KBkey[CurKey].posY == g_iCurRowYPos)
	{	
		//Just reach the end last time (For Small KB only)
		if(LastKey != 0)
		{	
			RestoreKeyColor(LastKey);
			
		    //	
            //if 97 (LALT) just pass the space in SMALL KB, so don't increment the counter
            //
			if(LastKey != 97)  
            {
				count++;   //else increment the counter
            }
			
			LastKey = 0;
			
			if (count == NUMOFTIME)
			{	count = 0;
				Scanning_Actual(-1);
				return;
			}
		}
		else
		{
			RestoreKeyColor(CurKey - 1);
		}

        //Change the key color to black
		ChangeBGColor(lpkeyhwnd[CurKey]);
		CurKey++;   //jump to next key

		//Reach at the VERY END in Large KB
		//Note: It should be 111, but I let it to scan one more so I don't need to write extra code to redraw the last key 
		if(!smallKb && CurKey == 112)  
		{	
			count++;		//increment the counter
			CurKey = 95;	//set it back to first key (LCTRL) in last row of the kb
		}

		//reach at the VERY END in Small KB (KB has 117 keys)
		else if(smallKb && CurKey == 118)
		{			
			CurKey = 95;  // first key (LCTRL) in last row
			LastKey = 117;
		}

		//After left Alt, jump to 111 (Space) for Small KB
		else if(smallKb && CurKey == 98)
		{	
            CurKey = 111;   //Space in small KB
			LastKey = 97;   //LALT
		}
			
		//reach at the end of each row
		else if(smallKb) 
		{	
  			// the number is one advance than the actual key 
			// because it increment one after it scan the key
			switch(CurKey)
			{
				case 14:		//f12
				CurKey = 1;
				LastKey = 13;
				break;

				case 32:		//BS
				CurKey = 17;	// ~
				LastKey = 31;	//BS
				break;

				case 53:		// |
				CurKey = 39;	//TAB
				LastKey = 52;	// |
				break;

				case 74:		//enter
				CurKey = 60;	// Cap
				LastKey = 73;	//ENTER
				break;

				case 90:		//right shift
				CurKey = 77;   //LSHIFT
				LastKey = 89;  //RSHIFT
				break;
			}
		}
	}
	//End of the row (Large KB).  Reset to beginning of the row
	else if (KBkey[CurKey].posY > g_iCurRowYPos && !smallKb)
	{	
		RestoreKeyColor(CurKey - 1);
		
		count++;   //increment the counter

		switch (g_iCurRowYPos)
		{
			case ROW1:
			CurKey = 1;  //esc
			break;

			case ROW2:
			CurKey = 17;  // ~
			break;

			case ROW3:
			CurKey = 39;  //TAB
			break;

			case ROW4:
			CurKey = 60;  // CAP
			break;

			case ROW5:
			CurKey = 77;  // LSHIFT
			break;

			case ROW6:
			CurKey = 95;  //LCRL
			break;
		}
	}

	//Play some sound
	ScanningSound(1);
	
	// We have scan NUMOFTIME for each key in this row, and 
	// the user hasn't made a choice. Now go back to scan ROW
	if (count == NUMOFTIME)
	{	
		count = 0;
		Scanning_Actual(-1);
	}
}

/******************************************************************************/
// Scan each key in Actual 102 kb
/******************************************************************************/
void CALLBACK KeyScanProc_Actual_102(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
    register int j=0;

	if(CurKey == 0)
	{	//move to the correct row
		while ((KBkey[j].posY != g_iCurRowYPos) && (j < lenKBkey))
			j++;
		CurKey = j;
	}

	//Skip all the dummy key
	for(CurKey;KBkey[CurKey].smallKb == NOTSHOW;CurKey++);

	//Scan each key
	if (KBkey[CurKey].posY == g_iCurRowYPos)
	{	
		//Just reach the end last time (For Small KB only)
		if(LastKey != 0)
		{	
			RestoreKeyColor(LastKey);
			
		    //	
            //if 97 (LALT) just pass the space in SMALL KB, so don't increment the counter
            //
			if(LastKey != 97)  
            {
				count++;   //else increment the counter
            }
			
			LastKey = 0;
			
			if (count == NUMOFTIME)
			{	count = 0;
				Scanning_Actual(-1);
				return;
			}
		}
		else
		{
			RestoreKeyColor(CurKey - 1);
		}

        //Change the key color to black
		ChangeBGColor(lpkeyhwnd[CurKey]);
		CurKey++;   //jump to next key

		//Reach at the VERY END in Large KB
		//Note: It should be 111, but I let it to scan one more so I don't need to write extra code to redraw the last key 
		if(!smallKb && CurKey == 112)  
		{	
			count++;   //increment the counter
			CurKey = 95;  //set it back to first key (LCTRL) in last row of the kb
		}
		//reach at the VERY END in Small KB (KB has 117 keys)
		else if(smallKb && CurKey == 118)
		{			
			CurKey = 95;  // first key (LCTRL) in last row
			LastKey = 117;
		}
		//After left Alt, jump to 111 (Space) for Small KB
		else if(smallKb && CurKey == 98)
		{	
            CurKey = 111;   //Space in small KB
			LastKey = 97;   //LALT
		}
		//reach at the end of each row
		else if(smallKb) 
		{	
  			// the number is one advance than the actual key 
			// because it increment one after it scan the key
			switch(CurKey)
			{
				case 14:  //f12
				CurKey = 1;
				LastKey = 13;
				break;

				case 32:   //BS
				CurKey = 17;  // ~
				LastKey = 31;  //BS
				break;

				case 53:    // |
				CurKey = 39;  //TAB
				LastKey = 52;  // |
				break;

				case 74:   //enter
				CurKey = 60;    // Cap
				LastKey = 73;   //ENTER
				break;

				case 90:   //right shift
				CurKey = 77;   //LSHIFT
				LastKey = 89;  //RSHIFT
				break;
			}
		}
	}
	//End of the row (Large KB).  Reset to beginning of the row
	else if (KBkey[CurKey].posY > g_iCurRowYPos && !smallKb)
	{	
		RestoreKeyColor(CurKey - 1);
		
		count++;   //increment the counter

		switch (g_iCurRowYPos)
		{
			case ROW1:
			CurKey = 1;  //esc
			break;

			case ROW2:
			CurKey = 17;  // ~
			break;

			case ROW3:
			CurKey = 39;  //TAB
			break;

			case ROW4:
			CurKey = 60;  // CAP
			break;

			case ROW5:
			CurKey = 77;  // LSHIFT
			break;

			case ROW6:
			CurKey = 95;  //LCRL
			break;
		}
	}

	//Play some sound
	ScanningSound(1);
	
	// We have scan NUMOFTIME for each key in this row, and the 
	// user hasn't made a choice. Now go back to scan ROW
	if (count == NUMOFTIME)
	{	
		count = 0;
		Scanning_Actual(-1);
	}
}

/******************************************************************************/
// Scan each key in Actual 106 kb
/******************************************************************************/
void CALLBACK KeyScanProc_Actual_106(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
    register int j=0;

	if(CurKey == 0)
	{	//move to the correct row
		while ((KBkey[j].posY != g_iCurRowYPos) && (j < lenKBkey))
			j++;
		CurKey = j;
	}

	//Skip all the dummy key
	for(CurKey;KBkey[CurKey].smallKb == NOTSHOW;CurKey++);

	//Scan each key 
	if(KBkey[CurKey].posY == g_iCurRowYPos)
	{	
		//Just reach the end last time (For Small KB only)
		if(LastKey != 0)
		{	
			RestoreKeyColor(LastKey);
			
		    //	
            //These are the keys as exception in SMALL KB.
			//They are not reach the end of the road, 
		    //so don't increment the counter
            //
			if(LastKey != 98 && LastKey != 101 && LastKey != 111)  
            {
				count++;   //else increment the counter
            }
			
			LastKey = 0;
			
			if (count == NUMOFTIME)
			{	count = 0;
				Scanning_Actual(-1);
				return;
			}
		}
		else
		{
			RestoreKeyColor(CurKey - 1);
		}

        //Change the key color to black
		ChangeBGColor(lpkeyhwnd[CurKey]);
		CurKey++;   //jump to next key

		//Reach at the VERY END in Large KB
		//Note: It should be 111, but I let it to scan one more so I don't need to write extra code to redraw the last key 
		if(!smallKb && CurKey == 112)  
		{	
			count++;   //increment the counter
			
			CurKey = 95;  //set it back to first key (LCTRL) in last row of the kb
		}
		//reach at the VERY END in Small KB (KB has 117 keys)
		else if(smallKb && CurKey == 118)
		{			
			CurKey = 95;  // first key (LCTRL) in last row
			LastKey = 117;
		}
		//After the NO CONVERT Key, skip the Space in Large KB
		else if(smallKb && CurKey == 99)
		{	
            CurKey = 111;   //CONVERT key
			LastKey = 98;   //Japanses
		}
		//After Space jump back to CONVERT key
		else if(smallKb && CurKey == 112)
		{	
            CurKey = 100;   //CONVERT
			LastKey = 111;   // SPACE
		}
		//After THE Japanese key, jump to 102 (RALT) for Small KB
		else if(smallKb && CurKey == 102)
		{	
            CurKey = 112;   //RALT in small KB
			LastKey = 101;   //Japanese Key
		}
		//reach at the end of each row
		else if(smallKb) 
		{	
  			// the number is one advance than the actual key 
			// because it increment one after it scan the key
			switch(CurKey)
			{
				case 14:  //f12
				CurKey = 1;
				LastKey = 13;
				break;

				case 32:   //BS
				CurKey = 17;  // ~
				LastKey = 31;  //BS
				break;

				case 54:    // Enter
				CurKey = 39;  //TAB
				LastKey = 53;  // |
				break;

				case 74:   // '\'
				CurKey = 61;    // Cap
				LastKey = 73;   //ENTER
				break;

				case 90:   //right shift
				CurKey = 77;   //LSHIFT
				LastKey = 89;  //RSHIFT
				break;
			}
		}
	}
	//End of the row (Large KB).  Reset to beginning of the row
	else if (KBkey[CurKey].posY > g_iCurRowYPos && !smallKb)
	{	
		RestoreKeyColor(CurKey - 1);
		
		count++;   //increment the counter

		switch (g_iCurRowYPos)
		{
			case ROW1:
			CurKey = 1;  //esc
			break;

			case ROW2:
			CurKey = 17;  // ~
			break;

			case ROW3:
			CurKey = 39;  //TAB
			break;

			case ROW4:
			CurKey = 61;  // CAP
			break;

			case ROW5:
			CurKey = 77;  // LSHIFT
			break;

			case ROW6:
			CurKey = 95;  //LCRL
			break;
		}
	}

	//Play some sound
	ScanningSound(1);

	// We have scan NUMOFTIME for each key in this row, and the
	// user hasn't made  a choice. Now go back to scan ROW
	if (count == NUMOFTIME)
	{	
		count = 0;
		Scanning_Actual(-1);
	}
}

/******************************************************************************/
// Restore the whole row's color
/******************************************************************************/
void RestoreRowColor(int Row)
{	
    register int i;

    //Reset previous row color
    for(i=1; i < lenKBkey; i++)
    {
        if(KBkey[i].posY == Row)
        {
            RestoreKeyColor(i);
        }
	}
}

/****************************************************************************/
// Restore one key color
/****************************************************************************/
void RestoreKeyColor(int i)
{
	// index > 0
	if(i<=0)
		return;
	
	//Skip all the dummy key
	for(i; KBkey[i].smallKb == NOTSHOW; i--);

	if (lpkeyhwnd[i] != g_hBitmapLockHwnd)
	{
		// Do not change the key color if Caplock bitmap
		SetWindowLong(lpkeyhwnd[i], 0, 0);	
	}

	switch (KBkey[i].ktype)
	{
		case KNORMAL_TYPE:
		SetBackgroundColor(lpkeyhwnd[i], COLOR_MENU);
	    break;

		case SCROLLOCK_TYPE:
        RedrawScrollLock();
        break;

		case NUMLOCK_TYPE:
        RedrawNumLock();
	    break;
			
		case KMODIFIER_TYPE:
		case KDEAD_TYPE:
        {
            int iColor = (IsModifierPressed(lpkeyhwnd[i]))?COLOR_HOTLIGHT:COLOR_INACTIVECAPTION;
            SetBackgroundColor(lpkeyhwnd[i], iColor);
        }
	    break;

        case LED_NUMLOCK_TYPE:
		case LED_SCROLLLOCK_TYPE:
		case LED_CAPSLOCK_TYPE:
		SetBackgroundColor(lpkeyhwnd[i], COLOR_BTNSHADOW);
	    break;	
	}

	InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
}

/****************************************************************/
// Pass FALSE - Pause
// Pass TRUE  - Reset (start scanning from row 1) 
/****************************************************************/
void KillScanTimer(BOOL reset)
{
	KillTimer(g_hwndOSK, SCANTIMER);
	RestoreRowColor(g_iCurRowYPos);

	//if calling from dialog init, reset these vars to start at the beginning 
	if (reset)
	{	
		ScanState = 0;
		CurKey = 0;
		g_iCurRowYPos = ROW1;
	}
}

/**********************************************************************/
// Scan in block kb
/**********************************************************************/
void Scanning_Block(int from)
{	

	ScanState = ScanState + from;
	
	count = 0;   //reset this counter of key scan


	switch (ScanState)
	{
		case 0:
			KillScanTimer(TRUE);
			break;
	
		case 1:   //Row scanning
			KillScanTimer(FALSE);
			CurCol = COL1;    //reset Col to COL1 for next round
			TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)LineScanProc);
			break;

		case 2:
			KillScanTimer(FALSE);
			TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)BlockScanProc);
			break;

		case 3:    //key scanning
			KillScanTimer(FALSE);

			//Set the coloum back 1 because in Block scan I set it 1 advance
			switch(CurCol)
			{
				case COL1: CurCol = COL4; break;
				case COL2: CurCol = COL1; break;
				case COL3: CurCol = COL2; break;
				case COL4: CurCol = COL3; break;
			}

			//Small KB doesn't has Col4, Set to Col3
			if(smallKb && (CurCol == COL4))
				CurCol = COL3;

			TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)KeyScanProc_Block);
			break;
	
		default:     //stop scanning and send char
			KillScanTimer(FALSE);

			//a special for SPACE in Large KB and Block layout
			if((!kbPref->Actual) && (!smallKb) && (CurKey == 99))
				CurKey++;

			// tell msswch dll to not check this char to see if it is the scanning char

			swchCheckForScanChar(FALSE);

			SendChar(lpkeyhwnd[CurKey-1]);
			
			//re-set some vars
			ScanState = 0;
			CurKey = 0;

			//Post a message to call Scanning again to avoid recursive call
			PostMessage(g_hwndOSK, WM_USER + 1, 0L, 0L);
			break;
	}
}

/*********************************************************************/
// Restore the whole block color in block kb
/*********************************************************************/
void RestoreBlockColor(int ColStart, int ColEnd)
{	register int i;

	//Find the first key in current row and current col
	for(i=1; i < lenKBkey; i++)
		if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == ColStart))
			break;

	while(((KBkey[i].posX < ColEnd) && (KBkey[i].posY == g_iCurRowYPos)) || (KBkey[i].smallKb == NOTSHOW))
	{
		if(KBkey[i].smallKb == NOTSHOW)
		{	
			i++;
			continue;
		}

		if (lpkeyhwnd[i] != g_hBitmapLockHwnd)
		{
			// Do no change the color key if Caplock bitmap
			SetWindowLong(lpkeyhwnd[i], 0, 0);	
		}

		switch (KBkey[i].ktype)
		{
			case KNORMAL_TYPE:
			SetBackgroundColor(lpkeyhwnd[i], COLOR_MENU);
			break;

			case SCROLLOCK_TYPE:
            RedrawScrollLock();
            break;

			case NUMLOCK_TYPE:
            RedrawNumLock();
            break;
		
			case KMODIFIER_TYPE:
			case KDEAD_TYPE:
			SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);
			break;
		
		
			case LED_NUMLOCK_TYPE:
			case LED_CAPSLOCK_TYPE:
			case LED_SCROLLLOCK_TYPE:
			SetBackgroundColor(lpkeyhwnd[i], COLOR_BTNSHADOW);
			break;
		}
		InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
		i++;
	}
}


/*********************************************************************/
// Scan each block in block kb
/*********************************************************************/
void CALLBACK BlockScanProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
	register int i;

	//We have scan NUMOFTIME for each block in this row, and the user hasn't make 
	//any choice. Now go back to scan ROW
	if (count == NUMOFTIME)
	{	
		count = 0;    //reset the counter
		Scanning_Block(-1);
		return;
	}

	//Find the first key in current row and current col
	for(i=1; i < lenKBkey; i++)
		if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == CurCol))
			break;

        switch (CurCol)
		{
			case COL1:
				CurKey = i;    //set the CurKey to the beginning of this block 
				if (smallKb)	//Small KB
				{
					int j;
					RestoreBlockColor(COL3,COL4);
					for(j=113; j <= 117; j++)  //Hardcoded it!
						RestoreKeyColor(j); 
				}
				else   // Large KB
				{
					RestoreBlockColor(COL4, COL4_END);
				}

				//Paint all keys within the Block
				while(((KBkey[i].posX < COL2) && (KBkey[i].posY == g_iCurRowYPos)) || (KBkey[i].smallKb == NOTSHOW))		
				{	
					if(KBkey[i].smallKb == NOTSHOW)
					{	i++;
						continue;
					}

					ChangeBGColor(lpkeyhwnd[i]);	
					i++;
				}
				CurCol = COL2;  //Jump to next col
				break;

			case COL2:
				CurKey = i;    //set the CurKey to the beginning of this block
				RestoreBlockColor(COL1, COL2);

				//In Small KB, skip all the large kb keys
				if (smallKb)
				{
					while((KBkey[i].smallKb == LARGE) || (KBkey[i].smallKb == NOTSHOW))
						i++;
				}

				//Paint all keys within the Block
				while(((KBkey[i].posX < COL3) && (KBkey[i].posY == g_iCurRowYPos)) || (KBkey[i].smallKb == NOTSHOW))		
				{	
					if(KBkey[i].smallKb == NOTSHOW)
					{	i++;
						continue;
					}
									
					ChangeBGColor(lpkeyhwnd[i]);	
					i++;
				}
				CurCol = COL3;   //Jump to next col
				break;

			case COL3:
				//For small KB, skip all the keys only for LARGE kb
				if(smallKb)
				{
					while(KBkey[i].smallKb == LARGE || KBkey[i].smallKb == NOTSHOW)
						i++;
				}

				CurKey = i;    //set the CurKey to the beginning of this block

				//Small kb
				if (smallKb && CurKey == 111)   // CurKey == SPACE
				{
					RestoreKeyColor(111);   // SPACE
					RestoreKeyColor(112);   // RALT

					CurKey = i = 113;   //APP KEY
				}
				//Large KB
				else
				{
					RestoreBlockColor(COL2, COL3);
				}

				//Paint all keys within the Block
				while(((KBkey[i].posX < COL4) && (KBkey[i].posY == g_iCurRowYPos)) || (KBkey[i].smallKb == NOTSHOW))		
				{	
					if(KBkey[i].smallKb == NOTSHOW)
					{	i++;
						continue;
					}
					
					ChangeBGColor(lpkeyhwnd[i]);	
					i++;
				}

				if (smallKb)   //Small KB only has 3 columns
				{
					CurCol = COL1;
					count++;        // increment the counter
				}
				else    //Large KB
				{
					CurCol = COL4;  //Jump to next col
				}
				break;

			case COL4:
				CurKey = i;    //set the CurKey to the beginning of this block
				RestoreBlockColor(COL3, COL4);

				//Paint all keys within the Block
				while(((KBkey[i].posX < COL4_END) && (KBkey[i].posY == g_iCurRowYPos)) || (KBkey[i].smallKb == NOTSHOW))
				{	
					if(KBkey[i].smallKb == NOTSHOW)
					{	i++;
						continue;
					}
					
					ChangeBGColor(lpkeyhwnd[i]);	
					i++;
				}

				CurCol = COL1;   //Jump to next col
				count++;   //increment the counter
				break;
		}

	//Play some sound
	ScanningSound(1);
}

/*********************************************************************/
// Scan each key in a block in block kb
/*********************************************************************/
void CALLBACK KeyScanProc_Block(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
	static int last=0;	
	register int i;

	switch (CurCol)
	{
		case COL1:   //This is actually COL1
			//Scanning each key in the Block
			if((KBkey[CurKey].posY == g_iCurRowYPos) && (KBkey[CurKey].posX < COL2))
			{	
				if(last != 0)
				{	RestoreKeyColor(last);
					last = 0;
				}
				else if(CurKey > 1)
				{
					RestoreKeyColor(CurKey - 1);
				}
				
				ChangeBGColor(lpkeyhwnd[CurKey]);
				CurKey++;   //jump to next key
			}
				//Reach last key, reset to first key in the col
			else if(KBkey[CurKey].posX >= COL2)
			{	for(i=1; i < lenKBkey; i++)
				{
					if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == COL1))
					{	last = CurKey -1;   //save the last key for next restore color
						CurKey = i;
						break;
					}
				}
				count++;
			}
			break;

		case COL2:   //Actually COL2
			//In small KB, skip all the Large KB keys
			if (smallKb)
			{
				while(KBkey[CurKey].smallKb == LARGE || KBkey[CurKey].smallKb == NOTSHOW)
					CurKey++;
			}

			//Only for the last row (both Small and Large KB)
			if(KBkey[CurKey].name == KB_SPACE)
			{	
				if (smallKb)    //Small KB
					RestoreKeyColor(112);   //106

				ChangeBGColor(lpkeyhwnd[CurKey]);
				CurKey++;

				if (!smallKb)   //Large KB
				{				
					count++;

					if(count < NUMOFTIME)
						CurKey--;
				}
				else    //Small Kb
				{
					last = 111;      //SPACE (small)
				}
				break;
			}

			//Scanning each key in the Column
			if((KBkey[CurKey].posY == g_iCurRowYPos) && (KBkey[CurKey].posX < COL3))
			{
				if(last != 0)
				{	
					RestoreKeyColor(last);
					last = 0;
				}
				else
				{
					RestoreKeyColor(CurKey - 1);
				}

				ChangeBGColor(lpkeyhwnd[CurKey]);
			
				CurKey++;   //jump to next key
			}
			//Reach last key, reset to first key in the col
			else if(KBkey[CurKey].posX >= COL3)
			{	
				if (smallKb && CurKey == 113)    //App Key (small)
				{
					CurKey = 111;       //SPACE (small)
					last = 112;         //RALT (small)
				}
				else
				{
					for(i=1; i < lenKBkey; i++)
					{
						if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == COL2))
						{	
							//save the last key for next restore color
							last = CurKey - 1;
							CurKey = i;
							break;
						}
					}
				}
				count++;
			}
			break;

		case COL3:  //Actually COL3
			//Last Col for SMALL KB
			//Special case!!  Last scan reach the very end in Samll KB (118)
			if (CurKey == 118)  
			{   
				CurKey = 113;   //Reset to the first one in this col
				count++;
			}

			//Skip all Dummy key
			while(KBkey[CurKey].smallKb == NOTSHOW)
				CurKey++;

			//Scanning each key in the Block
			if((KBkey[CurKey].posY == g_iCurRowYPos) && (KBkey[CurKey].posX < COL4) && 
			   (CurKey <= 117))
			{
				//In small KB, skip all the Large KB keys
				if(smallKb)
				{
					while(KBkey[CurKey].smallKb == LARGE || KBkey[CurKey].smallKb == NOTSHOW)
						CurKey++;
				}

				if(last != 0)
				{	
					RestoreKeyColor(last);

					//Special case, reach the end of the small KB
					if (last == 118)    //The end in Small KB
						CurKey = 113;   //reset to first one in this col

					last = 0;
				}
				else
				{
					RestoreKeyColor(CurKey - 1);
				}

				//Set the key to black
				ChangeBGColor(lpkeyhwnd[CurKey]);
			
				CurKey++;   //jump to next key
			}
			//Reach last key, reset to first key in the col
			else if( (KBkey[CurKey].posX >= COL4 || CurKey > 109)  && (CurKey <= 117) )  
			{	
				//reach the very end

				for(i=1; i < lenKBkey; i++)
				{
					if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == COL3))
					{	last = CurKey - 1;   //save the last key for next restore color
						CurKey = i;
						break;
					}
				}
				count++;
			}

			//Small KB reach the last key (117)
			if (smallKb && (CurKey == 118))
				last = CurKey -1;
			break;

		case COL4:   //Actual COL4
			//Only LARGE KB has COL4
			//Scanning each key in the Block
																					   //large KB and not reach the end
			if((KBkey[CurKey].posY == g_iCurRowYPos) && (KBkey[CurKey].posX < COL4_END) && !smallKb && (CurKey <= 110))
			{
				if(last != 0)
				{	RestoreKeyColor(last);
					last = 0;
				}
				else
					RestoreKeyColor(CurKey - 1);


				ChangeBGColor(lpkeyhwnd[CurKey]);
			
				CurKey++;   //jump to next key
							
			}
			//Reach last key, reset to first key in the col
			else // if(KBkey[CurKey - 1].posX >= COL4_END)
			{	
				for(i=1; i < lenKBkey; i++)
				{
					if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == COL4))
					{	last = CurKey - 1;   //save the last key for next restore color
						CurKey = i;
						break;
					}
				}
				count++;
			}
			break;
	}

	//Play some sound
	ScanningSound(1);
		
	// We have scan NUMOFTIME for each key in this Block, and the 
	// user hasn't made a choice. Now go back to scan BLOCK
	if (count == NUMOFTIME)
	{	
		count = 0;    //reset the counter
		Scanning_Block(-1);
	}
}
/*****************************************************************************/
void ScanningSound(int what)
{	
	// don't want sound, then exit
	if(!Prefusesound)
		return;

	switch(what)
	{
		case 2:     // scanning
		PlaySound(MAKEINTRESOURCE(WAV_CLICKDN), hInst, SND_ASYNC|SND_RESOURCE);
		break;

		case 1:      //one level up
		PlaySound(MAKEINTRESOURCE(WAV_CLICKUP), hInst, SND_ASYNC|SND_RESOURCE);
		break;

		case 3:      //switch click
		PlaySound(MAKEINTRESOURCE(WAV_SWITCH_CLICK), hInst, SND_ASYNC|SND_RESOURCE);
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\version.h ===
// MAGNIFY.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "On-Screen Keyboard\0"
#define VER_INTERNALNAME_STR        "osk\0"
#define VER_ORIGINALFILENAME_STR    "osk.exe\0"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\ms32dll.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// File: ms32dll.c
// Additions, Bug Fixes 1999 
// a-anilk and v-mjgran
//

#define STRICT

#include <windows.h>
#include <mmsystem.h>
#include <commctrl.h>
#include <winable.h>
#include "kbmain.h"
#include "resource.h"
#include "kbus.h"
#include "keyrc.h"
#include "ms32dll.h"
#include "w95trace.h"

/***************************************************************************/
/*   functions not in this file              */
/***************************************************************************/
#include "scan.h"
#include "kbfunc.h"
#include "sdgutil.h"

#define DWELLTIMER 267
#define PAINTTIMER 101

int   paintlineNo = 0;
HWND  g_hwndLastMouseOver = NULL;      // handle to window under mouse
HWND  g_hwndDwellKey=NULL;            // a copy of Dwellwindow handle

HWND s_hwndCtrl=NULL;
HWND s_hwndAlt=NULL;
HWND s_hwndCaplock=NULL;
HWND s_hwndShift=NULL;
HWND s_hwndWinLogo=NULL;
BOOL SendSAS();

BOOL g_fWinKeyDown= FALSE;
BOOL g_fCtrlAltDel = FALSE;        // Ctr+Alt+Del down
BOOL g_fControlPressed = FALSE;    // Control is down
BOOL g_fDoingAltTab = FALSE;	   // LAlt+Tab 

// External variables
extern TOOLINFO		ti;
extern HWND	g_hToolTip;

int g_nMenu  = MENUKEY_NONE;  // holds menu key state
HWND g_hBitmapLockHwnd = NULL;		// CapLock when japaneese keyboard is bitmap type
HKL g_hklLast = 0;                  // the keyboard layout currently being worked with

// Functions
void SendExtendedKey(HWND hwndKey, UINT vk, UINT scanCode);
void SendFullKeyPress(UINT vk, UINT scanCode);
void SendHalfKeyPress(UINT vk, UINT scanCode, DWORD dwFlags);

__inline void ToggleAppearance(HWND hwnd, BOOL fForceUpdate)
{
	SetWindowLongPtr(hwnd, GWLP_USERDATA_TEXTCOLOR, 1);
    InvertColors(hwnd, fForceUpdate);
}

__inline void RestoreAppearance(HWND *phwnd, BOOL fForceUpdate)
{
	HWND hwndTmp = *phwnd;
	*phwnd = NULL;

	SetWindowLongPtr(hwndTmp, GWLP_USERDATA_TEXTCOLOR, 0);
    ReturnColors(hwndTmp, fForceUpdate);
}

/***************************************************************************/
/*     Functions Declaration      */
/***************************************************************************/

void DoButtonUp(HWND hwnd);
void SendAltCtrlDel();

/***************************************************************************
   IsModifierPressed - returns TRUE if hwndKey is toggled (down)
 ***************************************************************************/
BOOL IsModifierPressed(HWND hwndKey)
{
    if (!hwndKey)
        return FALSE;   // paranoia

    // return TRUE if the specified key is pressed (toggled)
	if (hwndKey == s_hwndCtrl  || hwndKey == s_hwndAlt || hwndKey == s_hwndCaplock)
        return TRUE;

    // Special case - both SHIFT keys are down if either one is pressed
    if (g_fShiftKeyDn)
    {
	    int iKey = GetWindowLong(hwndKey, GWL_ID);
        if (KBkey[iKey].name == KB_LSHIFT || KBkey[iKey].name == KB_RSHIFT)
            return TRUE;
    }

    return FALSE;
}

/***************************************************************************
   SetCapsLock - sets the caps lock hwnd
 ***************************************************************************/
void SetCapsLock(HWND hwnd) 
{ 
    s_hwndCaplock = hwnd; 
}

/***************************************************************************
   DoMenuKey - function to handle left and right alt keys
 ***************************************************************************/
void DoMenuKey(DWORD dwFlag, int nWhichMenu)
{
	INPUT	rgInput[1];

    switch (nWhichMenu)
    {
        // LMENU (aka LALT)
        case MENUKEY_LEFT:
        {
		    rgInput[0].type = INPUT_KEYBOARD;
		    rgInput[0].ki.dwExtraInfo = 0;
		    rgInput[0].ki.wVk = VK_MENU;
		    rgInput[0].ki.wScan = 0x38;
		    rgInput[0].ki.dwFlags = dwFlag;
		    SendInput(1, rgInput, sizeof(INPUT));
        }
        break;

        // RMENU (aka RALT)
        case MENUKEY_RIGHT:
        {
		    rgInput[0].type = INPUT_KEYBOARD;
		    rgInput[0].ki.dwExtraInfo = 0;
		    rgInput[0].ki.wVk = VK_RMENU;
		    rgInput[0].ki.wScan = 0x38;
		    rgInput[0].ki.dwFlags = dwFlag;
		    SendInput(1, rgInput, sizeof(INPUT));
       }
        break;

        default:
        // do nothing
        break;
    }
}

/**************************************************************************/
/* RedrawKeysOnLanguageChange - change the keyboard based on input language
/**************************************************************************/
void RedrawKeysOnLanguageChange()
{
	KBkeyRec *pKey;
    HKL hkl;

    hkl = GetCurrentHKL();
	if (g_hklLast != hkl)
	{       
		if (!ActivateKeyboardLayout(hkl, 0))
        {
			SendErrorMessage(IDS_CANNOT_SWITCH_LANG);
        }

		g_hklLast = hkl;

        // update the key labels for this new keyboard layout

		UninitKeys();
        UpdateKeyLabels(hkl);
        RedrawKeys();
	}
}

/**************************************************************************/
/* void MakeClick(int what)                                               */
/**************************************************************************/
void MakeClick(int what)
{	
	switch (what)
	{
		case SND_UP:
            PlaySound(MAKEINTRESOURCE(WAV_CLICKUP), hInst, SND_ASYNC|SND_RESOURCE);	
		    break;

		case SND_DOWN:
            PlaySound(MAKEINTRESOURCE(WAV_CLICKDN), hInst, SND_ASYNC|SND_RESOURCE);
		    break;
	}
	return;
}

/**************************************************************************/
/* void InvertColors(HWND hwnd)                                           */
/**************************************************************************/
void InvertColors(HWND hwnd, BOOL fForceUpdate)
{
	SetWindowLong(hwnd, 0, 4);
	SetBackgroundColor(hwnd, COLOR_HOTLIGHT);

    if (fForceUpdate)
    {
	    InvalidateRect(hwnd, NULL, TRUE);
    }
} 

/**************************************************************************/
/* void ReturnColors(HWND hwnd, BOOL fForceUpdate)                        */
// Repaint the key
/**************************************************************************/
void ReturnColors(HWND hwnd, BOOL fForceUpdate)
{
	int iKey;
	COLORREF selcolor;
	BOOL fReplaceColor=FALSE;       //Do some check before do redraw, save some time! :-)

	stopPaint = TRUE;

    if (!hwnd)
        return; // ignore if no hwnd

	iKey = GetWindowLong(hwnd, GWL_ID);  //order of the key in the array

	if (iKey < lenKBkey && iKey >= 0)
	{
        // Special case - don't redraw either SHIFT key if one is down
        if (g_fShiftKeyDn && (KBkey[iKey].name == KB_LSHIFT || KBkey[iKey].name == KB_RSHIFT))
        {
            return;
        }

		switch (KBkey[iKey].ktype)
		{
			case KNORMAL_TYPE:
				selcolor = COLOR_MENU;
				fReplaceColor= TRUE;
				SetWindowLong(hwnd, 0, 0);
			    break;

			case KMODIFIER_TYPE:

				if (hwnd!=s_hwndCtrl    && hwnd!=s_hwndAlt &&
					hwnd!=s_hwndCaplock && hwnd!=s_hwndWinLogo)
				{
					if (hwnd != g_hBitmapLockHwnd)
                    {
						SetWindowLong(hwnd, 0, 0);
                    }

					selcolor = COLOR_INACTIVECAPTION;
					fReplaceColor= TRUE;
				}
			    break;

			case KDEAD_TYPE:
				selcolor = COLOR_INACTIVECAPTION;
				fReplaceColor= TRUE;
				SetWindowLong(hwnd, 0, 0);
			    break;

			case NUMLOCK_TYPE:
				if (RedrawNumLock()==0)         //RedrawNumLock return 0 if NumLock is OFF
				{	
					selcolor = COLOR_INACTIVECAPTION;
					fReplaceColor= TRUE;
					SetWindowLong(hwnd, 0, 0);
				}
			    break;

			case SCROLLOCK_TYPE:
				if (RedrawScrollLock()==0)       //RedrawNumLock returns 0 if NumLock is OFF
				{	
                    selcolor = COLOR_INACTIVECAPTION;
					fReplaceColor= TRUE;
					SetWindowLong(hwnd, 0, 0);
				}
			    break;

		}
	}
	if (fReplaceColor)     //fReplaceColor TRUE = we are on KEYS or PREDICT KEYS , if true then redraw it!!
	{
		SetBackgroundColor(hwnd, selcolor);

		if (fForceUpdate == TRUE)
		{
			InvalidateRect(hwnd,NULL, TRUE);
			UpdateWindow(hwnd);
		}
	}
}

/*******************************************************************************/
/*void CALLBACK YourTimeIsOver(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)*/
/*******************************************************************************/
void CALLBACK YourTimeIsOver(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
	static int lastF = -1;
	POINT pt;
	HWND temphwnd;
	int x=0;

	//Stop all the Dwell timers

	killtime();

	if (PrefDwellinkey != TRUE)
		return;

	SetWindowLong(g_hwndDwellKey,0, 0);

	// check if the mouse is over our dwellwindow

	GetCursorPos(&pt);                		// check if it is a dwelling window
	ScreenToClient(g_hwndOSK, &pt);
	temphwnd = ChildWindowFromPointEx(g_hwndOSK, pt, CWP_SKIPINVISIBLE);
	
	//If not the Dwell window, do nothing.

	if (g_hwndDwellKey != temphwnd)
	{
		if (g_hwndDwellKey != NULL)
        {
			InvalidateRect(g_hwndDwellKey, NULL, TRUE);
        }
		return;
	}

	// Repeated 'Function keys' (f1 - f12) clicking can make a mess in the
	// "host" program.  Then.... Don't let stay over that key.

	x = GetWindowLong(g_hwndDwellKey, GWL_ID);
	if (x < 13)
	{
		if (lastF != x)
			lastF = x;
		else
			return;
	}
	else
		lastF = -1;


	//Send out the char
	SendChar(g_hwndDwellKey);

	//Redraw the key to original color
	ReturnColors(g_hwndDwellKey, FALSE);

	//Redraw the key as button up
	DoButtonUp(g_hwndDwellKey);	
	
	g_hwndDwellKey=NULL;
}

/**************************************************************************/
/* void killtime(void)                                                 	  */
/**************************************************************************/
void killtime(void)
{
    stopPaint = TRUE;

    KillTimer(g_hwndOSK, timerK1);
    timerK1 = 0;
    KillTimer(g_hwndOSK, timerK2);

    if ((Dwellwindow!= NULL) && (Dwellwindow != g_hwndOSK))
    {
	    InvalidateRect(Dwellwindow, NULL, TRUE);
    }
}

/**************************************************************************/
/* void SetTimeControl(void)                                           	  */
/**************************************************************************/
void SetTimeControl(HWND  hwnd)
{
	if (PrefDwellinkey)
    {
        int iMSec;

	    if (!Prefhilitekey)           //if not hilite key make the key black for Dwell
        {
		    InvertColors(hwnd, TRUE);
        }

        iMSec=(int)((float)PrefDwellTime * (float)1);   //1.5

	    timerK1 = SetTimer(g_hwndOSK, DWELLTIMER, iMSec, YourTimeIsOver);
	    stopPaint = FALSE;
	    PaintBucket(hwnd);
    }
}

/**************************************************************************/
/* void CALLBACK PaintTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)*/
/**************************************************************************/
void CALLBACK PaintTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
	POINT pt;
    HWND hwndMouseOver;

    GetCursorPos(&pt);
    ScreenToClient(hwnd, &pt);
    hwndMouseOver = ChildWindowFromPointEx(hwnd, pt, CWP_SKIPINVISIBLE);

	if (!hwndMouseOver || hwndMouseOver == hwnd)
	{
		killtime();
		ReturnColors(Dwellwindow, TRUE);
	}

	if (stopPaint == TRUE)
		return;

	SetWindowLong(Dwellwindow, 0, 5);
	InvalidateRect(Dwellwindow, NULL, FALSE);
}

/**************************************************************************/
/* void PaintBucket(void)                                             	  */
/**************************************************************************/
void PaintBucket(HWND  hwnd)
{	
    int iMSec;					// time between bucket's line

	paintlineNo = 0;

	iMSec = (int)((float)PrefDwellTime * (float)0.07);

	timerK2 = SetTimer(g_hwndOSK, PAINTTIMER, iMSec, PaintTimerProc);
}

/********************************************************************
* void PaintLine(HWND hwnd, HDC hdc, RECT rect, int Wline)
*
* Paint the bucket
********************************************************************/
void PaintLine(HWND hwnd, HDC hdc, RECT rect)
{
	POINT bPoint[3];
	HPEN oldhpen;
	HPEN hPenWhite;

	LOGPEN lpWhite = { PS_SOLID, 1, 1, RGB (255, 255, 255) };

	hPenWhite = CreatePenIndirect(&lpWhite);
	if (hPenWhite) // PREFIX #113796 don't use resource if call fails
	{
		oldhpen = SelectObject(hdc, hPenWhite);

		bPoint[0].x = 0;
		bPoint[0].y = rect.bottom -(1 * paintlineNo);
		bPoint[1].x = rect.right;
		bPoint[1].y = bPoint[0].y;
		bPoint[2].x = 0;
		bPoint[2].y = rect.bottom -(1 * paintlineNo);

		if (stopPaint != TRUE)
			Polyline(hdc, bPoint, 3);

		SelectObject(hdc, oldhpen);
		DeleteObject(hPenWhite);
	}

	paintlineNo++;
	paintlineNo++;
}

/**************************************************************************/
//Handle the Window Keys and App Key. Send out keystroke or key combination
//using SendInput.
/**************************************************************************/
void Extra_Key(HWND hwnd, int iKey)
{	UINT  scancode;
	UINT  vk;
	INPUT rgInput[3];
	static UINT s_vkWinKey;
	static UINT s_scWinKey;

	//Previous Window Key Down. Now user press char key, or Window key again
	if (g_fWinKeyDown)
	{
		g_fWinKeyDown = FALSE;

		// Re-Draw the window key
		RestoreAppearance(&s_hwndWinLogo, TRUE);
		
		// WinKey previously down; release it.
		// TODO Doesn't handle LWINKEY then RWINKEY properly.  Is there a difference between Left and Right WinKey?
		// if you key down on one and key up on the other is one key still down?

		vk = 0;
		if (!lstrcmp(KBkey[iKey].skCap,TEXT("lwin")))
		{	
			vk = VK_LWIN;
		}
		else if (!lstrcmp(KBkey[iKey].skCap,TEXT("rwin")))
		{	
			vk = VK_RWIN;
		}

		if (vk)
		{
			rgInput[0].type = INPUT_KEYBOARD;
            rgInput[0].ki.dwFlags = KEYEVENTF_KEYUP|KEYEVENTF_EXTENDEDKEY;
            rgInput[0].ki.dwExtraInfo = 0;
            rgInput[0].ki.wVk = (WORD)vk;
            rgInput[0].ki.wScan = (WORD)MapVirtualKey(vk, 0);

			SendInput(1, rgInput,sizeof(INPUT));
		}
		else  // Window key conbination. Send (letter + Win key up)
		{
			vk = MapVirtualKey(KBkey[iKey].scancode[0],1);

			// key down
			rgInput[0].type = INPUT_KEYBOARD;
            rgInput[0].ki.dwFlags = 0;
            rgInput[0].ki.dwExtraInfo = 0;
            rgInput[0].ki.wVk = (WORD) vk;
            rgInput[0].ki.wScan = (WORD) KBkey[iKey].scancode[0];

			// key up
			rgInput[1].type = INPUT_KEYBOARD;
            rgInput[1].ki.dwFlags = KEYEVENTF_KEYUP;
            rgInput[1].ki.dwExtraInfo = 0;
            rgInput[1].ki.wVk = (WORD) vk;
            rgInput[1].ki.wScan = (WORD) KBkey[iKey].scancode[0];

			// Win key up (the last one down)
			rgInput[2].type = INPUT_KEYBOARD;
            rgInput[2].ki.dwFlags = KEYEVENTF_KEYUP|KEYEVENTF_EXTENDEDKEY;
            rgInput[2].ki.dwExtraInfo = 0;
            rgInput[2].ki.wVk = (WORD) s_vkWinKey;
            rgInput[2].ki.wScan = (WORD) s_scWinKey;

			SendInput(3, rgInput,sizeof(INPUT));
		}

		return;
	}

	// App Key down?

	if (lstrcmp(KBkey[iKey].textL,TEXT("MenuKeyUp"))==0)
	{
        SetWindowLong(hwnd,0,0);
		InvalidateRect(hwnd, NULL, TRUE);
		scancode = MapVirtualKey(VK_APPS, 0);

		//App key down
		rgInput[0].type = INPUT_KEYBOARD;
        rgInput[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY;
        rgInput[0].ki.dwExtraInfo = 0;
        rgInput[0].ki.wVk = VK_APPS;
        rgInput[0].ki.wScan = (WORD) scancode;

		//App key up
		rgInput[1].type = INPUT_KEYBOARD;
        rgInput[1].ki.dwFlags = KEYEVENTF_KEYUP|KEYEVENTF_EXTENDEDKEY;
        rgInput[1].ki.dwExtraInfo = 0;
        rgInput[1].ki.wVk = VK_APPS;
        rgInput[1].ki.wScan = (WORD) scancode;

		SendInput(2, rgInput,sizeof(INPUT));
	
		if (Prefusesound)
		{
			MakeClick(SND_DOWN);
		}

		return;
	}

	// Left or Right WinKey down

	if (!lstrcmp(KBkey[iKey].skCap, TEXT("lwin")))
	{
		s_scWinKey= MapVirtualKey(VK_LWIN, 0);
		s_vkWinKey = VK_LWIN;
	}
	else
	{
		s_scWinKey= MapVirtualKey(VK_RWIN, 0);
		s_vkWinKey= VK_RWIN;
	}

	rgInput[0].type = INPUT_KEYBOARD;
    rgInput[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY;
    rgInput[0].ki.dwExtraInfo = 0;
    rgInput[0].ki.wVk = (WORD)s_vkWinKey;
    rgInput[0].ki.wScan = (WORD) s_scWinKey;

	SendInput(1, rgInput,sizeof(INPUT));

	g_fWinKeyDown = TRUE;
    s_hwndWinLogo = hwnd;
	InvertColors(s_hwndWinLogo, TRUE);	//Change the Win key appearance
	
	if (Prefusesound)
	{
		MakeClick(SND_DOWN);
	}
}

/**************************************************************************/
void NumPad(UINT sc, HWND hwnd)
{	
	BOOL fNumLockOn = (LOBYTE(GetKeyState(VK_NUMLOCK)) & 0x01)?TRUE:FALSE;
	switch (sc)
	{
		case 0x47:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD7:VK_HOME, sc);   break; // 7
		case 0x48:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD8:VK_UP, sc);     break; // 8
		case 0x49:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD9:VK_PRIOR, sc);  break; // 9
		case 0x4A:  SendFullKeyPress(VK_SUBTRACT, sc);                       break; // -
		case 0x4E:  SendFullKeyPress(VK_ADD, sc);                            break; // +
		case 0x4B:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD4:VK_LEFT, sc);   break; // 4
		case 0x4C:  if (fNumLockOn) { SendFullKeyPress(VK_NUMPAD5, sc); }    break; // 5
		case 0x4D:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD6:VK_RIGHT, sc);  break; // 6
		case 0x4F:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD1:VK_END, sc);    break; // 1
		case 0x50:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD2:VK_DOWN, sc);   break; // 2
		case 0x51:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD3:VK_NEXT, sc);   break; // 3
		case 0x52:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD0:VK_INSERT, sc); break; // 0

		case 0x53:	// (decimal pt)
			if (fNumLockOn)
			{
				SendFullKeyPress(VK_DECIMAL, sc);
			}
			else
			{
				// User pressed Ctrl+Alt+Del?
				if (LCtrlKeyPressed() && LAltKeyPressed())
				{	
					//change back to its normal state (key up)
					RestoreAppearance(&s_hwndAlt, TRUE);
					
					//change back to its normal state (key up)
					RestoreAppearance(&s_hwndCtrl, TRUE);
					
					g_fCtrlAltDel = TRUE;
					
					SendSAS();
				}

				SendFullKeyPress(VK_DELETE, sc);
			}		
			break;
	}
	
	if (PrefDwellinkey)
	{
		InvalidateRect(hwnd, NULL, TRUE);
	}

	//Make click sound
	if (Prefusesound)
	{
		MakeClick(SND_UP);
	}
}

/**************************************************************************/
/* void SendChar - send out the char associated with hwndKey              */
/**************************************************************************/
void SendChar(HWND hwndKey)
{	
	UINT vk;
	int iKey;
	BOOL fIsExtendedKey=FALSE;
	KBkeyRec *pKey;

	static int s_cBalloonTips = 0;

	if (g_fCtrlAltDel)  //if previously press Ctrl+Alt+Del, release Alt and Ctrl keys
	{
		ReleaseAltCtrlKeys();
	}

	// If OSK has the focus and the user presses a key then
	// tell them up to three times they need to put focus on
	// some other window.

	if ((GetForegroundWindow() == g_hwndOSK) && s_cBalloonTips < 3)
	{
		POINT pt;
		GetCursorPos(&pt);   
		s_cBalloonTips++;

		SendMessage(g_hToolTip,TTM_TRACKACTIVATE,(WPARAM)TRUE,(LPARAM)&ti);
        SendMessage(g_hToolTip, TTM_TRACKPOSITION,0, (LPARAM)MAKELPARAM(pt.x+10, pt.y+10));

		SetTimer(g_hwndOSK, TIMER_HELPTOOLTIP, 4000, NULL);
	}
	else if (s_cBalloonTips)
	{
		s_cBalloonTips = 0;
		SendMessage(g_hToolTip,TTM_TRACKACTIVATE,(WPARAM)FALSE,(LPARAM)&ti);
	}

	// Get the key index from the window data

	iKey = GetWindowLong(hwndKey, GWL_ID);
	if (iKey < 0 || iKey > lenKBkey)
	{
		return;	// internal error; not in range of valid keys
	}
	pKey = &KBkey[iKey];

	// Extra Keys (Window Keys, App Key)

	if ((lstrcmp(pKey->textL,TEXT("winlogoUp"))==0) ||
        (lstrcmp(pKey->textL,TEXT("MenuKeyUp"))==0) || g_fWinKeyDown)
	{	
		Extra_Key(hwndKey, iKey);
		return;
	}

    // extended key
	if (pKey->scancode[0] == 0xE0)
	{
		// WinSE #9381 (Whistler #120346): Check for divide ext. key as well here
		if (((pKey->scancode[1] >= 0x47) &&
             (pKey->scancode[1] <= 0x53) ) ||
             (pKey->scancode[1] == 0x35) )
		{
			// Arrow keys/ Home/ End keys do special processing.

			switch (pKey->scancode[1])
			{
				case 0x35: vk = VK_DIVIDE;	break;  // Divide
				case 0x47: vk = VK_HOME;	break;  // Home
				case 0x48: vk = VK_UP;		break;  // UP
				case 0x49: vk = VK_PRIOR;	break;  // PGUP
				case 0x4B: vk = VK_LEFT;	break;  // LEFT
				case 0x4D: vk = VK_RIGHT;	break;  // RIGHT
				case 0x4F: vk = VK_END;		break;  // END
				case 0x50: vk = VK_DOWN;	break;  // DOWN
				case 0x51: vk = VK_NEXT;	break;  // PGDOWN
				case 0x52: vk = VK_INSERT;	break;  // INS

				case 0x53:    //DEL
					vk = VK_DELETE;
					if (LCtrlKeyPressed() && LAltKeyPressed())
					{	
						g_fCtrlAltDel = TRUE;
						SendSAS();
					}
					break;
                default: return; break; // internal error!
			}

			// Do the processing here itself
			SendExtendedKey(hwndKey, vk, pKey->scancode[1]);
			return;
		}

		vk = MapVirtualKey(pKey->scancode[1], 1);
		
		fIsExtendedKey=TRUE;
	}
	else if ((pKey->scancode[0] >= 0x47) && (pKey->scancode[0] <= 0x53))
	{
		// NumPad processing
        NumPad(pKey->scancode[0], hwndKey);
		return;
	}
	else
	{	
		// other keys
		vk = MapVirtualKey(pKey->scancode[0], 1);
	}

	switch (pKey->name)
	{
		case KB_PSC:  //Print screen
			SendFullKeyPress(VK_SNAPSHOT, 0);
			break;

		case KB_LCTR:	//case VK_CONTROL:
		case KB_RCTR:
			g_fControlPressed = !g_fControlPressed;

			if (g_fControlPressed)    // CTRL down
			{	
				// VK from MapVirtualKey doesn't return correct
				// VK for VK_RCONTROL so always use VK_CONTROL
				SendHalfKeyPress(VK_CONTROL, pKey->scancode[0], 0);
				
				//Change the ctrl color to show toggled
				s_hwndCtrl = hwndKey;
				InvertColors(hwndKey, TRUE);
			}
			else					// CTRL up
			{				
				SendHalfKeyPress(VK_CONTROL, pKey->scancode[0], KEYEVENTF_KEYUP);

				//change back to its normal state (key up)
				RestoreAppearance(&s_hwndCtrl, TRUE);
			}
			break;

		case KB_CAPLOCK:
			// Capslock state is maintained in the keyboard input handler.
			// The keyboard will be redrawn when the keyboard input
			// handler see's the caps lock key
			SendFullKeyPress(vk, pKey->scancode[0]);
			break;

		case KB_LSHIFT:
		case KB_RSHIFT:	
			// Shift state is maintained in the keyboard input handler. The keyboard
			// will be redrawn when the keyboard input handler see's the shift key.
			if (g_fShiftKeyDn)
			{	
				// Shift is currently down; send key up and restore key color
				SendHalfKeyPress(VK_SHIFT, pKey->scancode[0], 
						KEYEVENTF_KEYUP | 
						    ( (pKey->name == KB_RSHIFT)? KEYEVENTF_EXTENDEDKEY : 0)
					);
			}
			else
			{	
				// Shift is currently up; send key down and show key toggled
				SendHalfKeyPress(VK_SHIFT, pKey->scancode[0], 
						    ( (pKey->name == KB_RSHIFT)? KEYEVENTF_EXTENDEDKEY : 0)
						);
				// MARKWO: Remember the HWND for Shift, so we can toggle it
				// after a single normal key is pressed
				s_hwndShift = hwndKey;
			}
			break;

		case KB_LALT:
			// User hit left menu key.  If the right menu key was previously hit
			// then release it before continuing...
			if (g_nMenu == MENUKEY_RIGHT)
			{
				// send keyup on right menu and restore its color
				DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_RIGHT);
				g_nMenu = MENUKEY_NONE;
				RestoreAppearance(&s_hwndAlt, TRUE);
			}

			g_nMenu = (g_nMenu == MENUKEY_NONE)?MENUKEY_LEFT:MENUKEY_NONE;

			if (g_nMenu != MENUKEY_NONE)         // user pressed once
			{	
				// send the keydown and show the key toggled
				DoMenuKey(0, MENUKEY_LEFT);
				s_hwndAlt = hwndKey;
				InvertColors(hwndKey, TRUE);
			}
			else                                // user pressed again
			{	
				// send the keyup and return the key color to normal
				DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_LEFT);
				RestoreAppearance(&s_hwndAlt, TRUE);
			}
			break;

		case KB_RALT:
			// User hit right menu key.  If the left menu key was previously hit
			// then release it before continuing...
			if (g_nMenu == MENUKEY_LEFT)
			{
				// send keyup on left menu and restore its color
				DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_LEFT);
				g_nMenu = MENUKEY_NONE;
				RestoreAppearance(&s_hwndAlt, TRUE);
			}

			g_nMenu = (g_nMenu == MENUKEY_NONE)?MENUKEY_RIGHT:MENUKEY_NONE;

			// If there are ALTGR keys to show then send out RALT

			if (CanDisplayAltGr())
			{
				if (g_nMenu != MENUKEY_NONE)
				{
					// send keydown and toggle key color
					DoMenuKey(0, MENUKEY_RIGHT);
					s_hwndAlt = hwndKey;
					InvertColors(hwndKey, TRUE);
				} 
				else
				{	
					// send keyup and restore key color
					DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_RIGHT);
					RestoreAppearance(&s_hwndAlt, TRUE);
				}
			}
			else	// no ALTGR so RALT is the same as LALT key
			{	
				if (g_nMenu != MENUKEY_NONE)
				{	
					// send keydown on *left* menu and toggle key color
					DoMenuKey(0, MENUKEY_LEFT);
					s_hwndAlt = hwndKey;
					InvertColors(hwndKey, TRUE);
				}
				else 
				{	
					// send keyup on *left* menu and toggle key color
					DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_LEFT);
					RestoreAppearance(&s_hwndAlt, TRUE);
				}
			}

			fIsExtendedKey = FALSE;
			break;

		case KB_NUMLOCK:
			SendFullKeyPress(VK_NUMLOCK, 0x45);
			RedrawNumLock();
			break;

		case KB_SCROLL:
			SendFullKeyPress(VK_SCROLL, 0x46);
			RedrawScrollLock();
			break;

	   case BITMAP:
			// manage the CapLock japanese key
			if (!g_hBitmapLockHwnd)
			{
				SetWindowLong(lpkeyhwnd[iKey], 0, 4);
				g_hBitmapLockHwnd = hwndKey;
			}
			else
			{
				SetWindowLong(lpkeyhwnd[iKey], 0, 1);
				g_hBitmapLockHwnd = NULL;
			}

			InvalidateRect(hwndKey, NULL, TRUE);     //Redraw the key (in case it is in Dwell)

		   // Intentional fall through to send the key input...

		default:
        {
			if (fIsExtendedKey)      //extended key
			{	
				// extend key down
				SendExtendedKey(hwndKey, vk, pKey->scancode[1]);
				
				if (pKey->scancode[1] == 0x53 && LCtrlKeyPressed() && LAltKeyPressed())
				{
					g_fCtrlAltDel = TRUE;
				}
			}
			else             // a normal (non-extended) key
			{
				//APPCOMPAT: MapVirtualKey returns 0 for 'Break' key. Special case for 'Break'.
				if (!vk && pKey->scancode[0] == BREAK_SCANCODE)
				{
					if (GetAsyncKeyState(VK_CONTROL) & 0x8000)
					{
						SendFullKeyPress(3, pKey->scancode[2]);
					}
					else
					{
						SendFullKeyPress(19, pKey->scancode[0]);
					}
				}
                else
				{
					SendFullKeyPress(vk, pKey->scancode[0]);
				}

                // restore the key appearance
				InvalidateRect(hwndKey, NULL, TRUE);

				if (Prefusesound)
				{
					MakeClick(SND_UP);	//Make click sound
				}
			}

			if (g_fShiftKeyDn)				// if SHIFT is down release it
			{	
				// If we did shift down, release it and restore key color
				// MARKWO: This is broken since pKey is not SHIFT at this point
				// SendHalfKeyPress(VK_SHIFT, pKey->scancode[0], KEYEVENTF_KEYUP);
				// This is better :	
		
                        	iKey = GetWindowLong(s_hwndShift, GWL_ID);
                        	if (iKey < 0 || iKey > lenKBkey)
                        	{
                        		return;	// internal error; not in range of valid keys
                        	}
                        	pKey = &KBkey[iKey];
				SendHalfKeyPress(VK_SHIFT, pKey->scancode[0], KEYEVENTF_KEYUP | ( (pKey->name == KB_RSHIFT)? KEYEVENTF_EXTENDEDKEY : 0));
			}

            // ISSUE:  Navigating menus using LALT+menu key doesn't work when the user
            // is clicking on the soft keyboard.  When menus are being accessed the
            // keyboard processing sets the KF_MENUMODE bit in HIWORD(lParam) on the
            // KEYUP event of the key following the LALT (keyboard filters see this).  
            // However, when the user clicks the mouse on the soft keyboard to do the 
            // char following the LALT the system detects that focus is no longer on
            // the thread that started the menu processing and clears the KF_MENUMODE
            // bit.  OSK never sees the KF_MENUMODE bit and can't detect when menus 
            // are active (even in the keyboard filter proc).  Menus work in hover
            // mode or scan mode.  

			if (g_nMenu == MENUKEY_LEFT)
			{
				// If in middle of doing ALT+TAB... don't release the
				// LMENU key; the user must explicitly do the key up.
				if ((WORD) pKey->scancode[0] != TAB_SCANCODE)
				{
					DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_LEFT);
					RestoreAppearance(&s_hwndAlt, TRUE);
					g_nMenu = MENUKEY_NONE;
				}
				else
				{
					g_fDoingAltTab = TRUE;  // Flag we're in ALT+TAB... so we won't try to set the focus
				}                           // back to the last input target in the WM_SETCURSOR event
			}

			if (g_nMenu == MENUKEY_RIGHT)   // if RMENU is down, release it
			{	
				DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_RIGHT);
				RestoreAppearance(&s_hwndAlt, FALSE);
				g_nMenu = MENUKEY_NONE;
			}
		
			if (g_fControlPressed)			// if CTRL is down, release it.
			{
				SendHalfKeyPress(VK_CONTROL, pKey->scancode[0], KEYEVENTF_KEYUP);
				g_fControlPressed = FALSE;
				RestoreAppearance(&s_hwndCtrl, FALSE);
			}
			break;
        }
	}  //end switch
}

/**************************************************************************/
//Send key up for Alt and Ctrl after user press Ctrl+Alt+Del
//For some reason, after user press Ctrl+Alt+Del from osk, the Alt and Ctrl
//keys still down.
/**************************************************************************/
void ReleaseAltCtrlKeys(void)
{	
	INPUT	rgInput[2];
				
	//Menu UP
	rgInput[0].type = INPUT_KEYBOARD;
	rgInput[0].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[0].ki.dwExtraInfo = 0;
	rgInput[0].ki.wVk = VK_MENU;
	rgInput[0].ki.wScan = 0x38;

	rgInput[1].type = INPUT_KEYBOARD;
	rgInput[1].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[1].ki.dwExtraInfo = 0;
	rgInput[1].ki.wVk = VK_CONTROL;
	rgInput[1].ki.wScan = 0x1D;

	SendInput(2, rgInput, sizeof(INPUT));

	g_fCtrlAltDel = FALSE;
}
/**************************************************************************/

void SendExtendedKey(HWND hwndKey, UINT vk, UINT scanCode)
{
	INPUT rgInput[2];

	// extend key down
	rgInput[0].type = INPUT_KEYBOARD;
	rgInput[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY;
	rgInput[0].ki.dwExtraInfo = 0;
	rgInput[0].ki.wVk = (WORD) vk;
	rgInput[0].ki.wScan = (WORD) scanCode;
		
	// extend key up
	rgInput[1].type = INPUT_KEYBOARD;
	rgInput[1].ki.dwFlags = KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP;
	rgInput[1].ki.dwExtraInfo = 0;
	rgInput[1].ki.wVk = (WORD) vk;
	rgInput[1].ki.wScan = (WORD) scanCode;

	SendInput(2, rgInput, sizeof(INPUT));

	InvalidateRect(hwndKey, NULL, TRUE);     //Redraw the key (in case it is in Dwell)

	//Make click sound
	if (Prefusesound)
	{
		MakeClick(SND_UP);
	}
}

void SendFullKeyPress(UINT vk, UINT scanCode)
{
	INPUT rgInput[2];

	// key down
	rgInput[0].type = INPUT_KEYBOARD;
	rgInput[0].ki.dwFlags = 0;
	rgInput[0].ki.dwExtraInfo = 0;
	rgInput[0].ki.wVk = (WORD) vk;
	rgInput[0].ki.wScan = (WORD) scanCode;
		
	// key up
	rgInput[1].type = INPUT_KEYBOARD;
	rgInput[1].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[1].ki.dwExtraInfo = 0;
	rgInput[1].ki.wVk = (WORD) vk;
	rgInput[1].ki.wScan = (WORD) scanCode;

	SendInput(2, rgInput, sizeof(INPUT));
}

void SendHalfKeyPress(UINT vk, UINT scanCode, DWORD dwFlags)
{
	INPUT rgInput[1];

	rgInput[0].type = INPUT_KEYBOARD;
	rgInput[0].ki.dwFlags = dwFlags;
	rgInput[0].ki.dwExtraInfo = 0;
	rgInput[0].ki.wVk = (WORD) vk;
	rgInput[0].ki.wScan = (WORD) scanCode;

	SendInput(1, rgInput, sizeof(INPUT));
}

// Sending SAS...

BOOL SendSAS()
{
	HWND hWnd = NULL;
	
	// SAS window will only be found on logon desktop
	hWnd = FindWindow(NULL, TEXT("SAS window"));
	if ( hWnd )
	{
		PostMessage(hWnd, WM_HOTKEY, 0, (LPARAM) 2e0003);
		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\osk\src\sdgutil.c ===
/*  Screen Doors*/

#define STRICT
#include <windows.h>
#include "Init_End.h"
#include "kbmain.h"     //keyboard header file from 3keyboar

#include "resource.h"

/*************************************************************/
//Functions in this file
/*************************************************************/
#include "sdgutil.h"

/************************************************************/
//Functions in other files
/************************************************************/
#include "fileutil.h"
#include "dgsett.h"

/*************************************************************/
//Global vars
/*************************************************************/
LOGFONT   lf;
extern BOOL  Setting_ReadSuccess=FALSE;

/**************************************************************************/
/* SendInitErrorMessage  - error msg                                          */
/**************************************************************************/
void SendErrorMessage(UINT ids_string)
{
    TCHAR str[256]=TEXT("");
    TCHAR title[256]=TEXT("");

	LoadString(hInst, ids_string, &str[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
	MessageBox(g_hwndOSK, str, title,MB_ICONHAND | MB_OK);
}

/******************************************************************************/
//initially set all the preferences (except some keyboard preference which 
// set at kbmain.c)
/******************************************************************************/
void GetPreferences(void)
{
	 // use the setting read from Registry
	 if(Setting_ReadSuccess=OpenUserSetting())
	 {
		g_margin			= kbPref->g_margin;			   	// Margin between rows and columns
		smallKb 			= kbPref->smallKb;				// TRUE when working with Small Keyboard
		PrefDeltakeysize 	= kbPref->PrefDeltakeysize;		// Preference increment in key size
		PrefshowActivekey 	= kbPref->PrefshowActivekey;	// Show cap letters in keys
		KBLayout			= kbPref->KBLayout;				// 101, 102, 106, KB layout
		Prefusesound 		= kbPref->Prefusesound;			// Use click sound
		PrefAlwaysontop     = kbPref->PrefAlwaysontop;      // windows always on top
		
		//if Scanning on, we don't want hilite key
		if(kbPref->PrefScanning)
			Prefhilitekey        = FALSE;          
		else
			Prefhilitekey = kbPref->Prefhilitekey  = TRUE;    //hilite key under cursor

		PrefDwellinkey       = kbPref->PrefDwellinkey;    // TRUE for dwelling
		PrefDwellTime        = kbPref->PrefDwellTime;     // How long to dwell

		PrefScanning         = kbPref->PrefScanning;
		PrefScanTime         = kbPref->PrefScanTime;

		g_fShowWarningAgain	= kbPref->fShowWarningAgain;   // Show initial warning message again

		// font
		plf = &lf; 				// pointer to the actual font

		plf->lfHeight	 		= kbPref->lf.lfHeight;
		plf->lfWidth 			= kbPref->lf.lfWidth;
		plf->lfEscapement 		= kbPref->lf.lfEscapement;
		plf->lfOrientation 		= kbPref->lf.lfOrientation;
		plf->lfWeight 			= kbPref->lf.lfWeight;
		plf->lfItalic 			= kbPref->lf.lfItalic ;
		plf->lfUnderline 		= kbPref->lf.lfUnderline;
		plf->lfStrikeOut 		= kbPref->lf.lfStrikeOut;
		plf->lfCharSet 			= kbPref->lf.lfCharSet;
		plf->lfOutPrecision 	= kbPref->lf.lfOutPrecision;
		plf->lfClipPrecision 	= kbPref->lf.lfClipPrecision;
		plf->lfQuality 			= kbPref->lf.lfQuality ;
		plf->lfPitchAndFamily 	= kbPref->lf.lfPitchAndFamily;

        wsprintf(plf->lfFaceName, TEXT("%hs"), kbPref->lf.lfFaceName);

//"MS SHELL DLG" is the alias to default font 
//wsprintf(plf->lfFaceName, TEXT("%hs"), "MS SHELL DLG");

		newFont = TRUE;


		//Use 101 keyboard layout   (default is 101 and Actual layout)
		if(KBLayout == 101)
		{
			//The setting say use Block layout, so switch to Block structure
			if(!kbPref->Actual)
				BlockKB();
		}

		// Use 102 keyboard layout
		else if(KBLayout == 102)
			EuropeanKB();

		//Use 106 keyboard layout
		else
			JapaneseKB();
	 }

    else
    {
        SendErrorMessage(IDS_SETTING_DAMAGE);
   		ExitProcess(0);
    }
}

/**************************************************************/
DWORD WhatPlatform(void)
{	OSVERSIONINFO	osverinfo;

	osverinfo.dwOSVersionInfoSize = (DWORD)sizeof(OSVERSIONINFO);
	GetVersionEx(&osverinfo);
	return osverinfo.dwPlatformId;

}
/**************************************************************/
// Check to see the keyboard is out of screen or not with the given
// Screen resoultion (scrCX, scrCY)
/**************************************************************/
BOOL IsOutOfScreen(int scrCX, int scrCY)
{	
	//Check left and top
	if(kbPref->KB_Rect.left < 0 || kbPref->KB_Rect.top < 0)
		return TRUE;

	//Check right and bottom
	if(kbPref->KB_Rect.right > scrCX || kbPref->KB_Rect.bottom > scrCY)
		return TRUE;

	return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\event.c ===
// ----------------------------------------------------------------------------
//
// Event.c
//
//
// Author: Jost Eckhardt
// 
// This code was written for ECO Kommunikation Insight
// (c) 1997-99 ECO Kommunikation
// ----------------------------------------------------------------------------
#include <windows.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"
// -----------------------
HANDLE BuildEvent(LPTSTR name,BOOL manualRest,BOOL initialState,BOOL inherit)
{
HANDLE ev;
LPSECURITY_ATTRIBUTES psa = NULL;
obj_sec_attr_ts sa;
  if (!name)
		return CreateEvent(NULL, manualRest, initialState, NULL);
  if (inherit)
	{
		psa = &sa.sa;
    InitSecurityAttributes(&sa);
	}
  ev = CreateEvent(psa, manualRest, initialState, name);
  if (inherit)
  	ClearSecurityAttributes(&sa);
	return ev;
}//BuildEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\desktop.c ===
// ----------------------------------------------------------------------------
//
// Desktop.c
//
//
// Author: Jost Eckhardt
// 
// This code was written for ECO Kommunikation Insight
// Copyright (c) 1997-1999 Microsoft Corporation
//
// ----------------------------------------------------------------------------
#include <windows.h>
#include <TCHAR.h>
#include <WinSvc.h>

#include "_UMTool.h"
#include "UtilMan.h"
#include "LmErr.h"
#include "LmAccess.h"
#include "LmApiBuf.h"

#ifndef ONLY_DSWITCH

// ----------------------------------------------------
BOOL InitDesktopAccess(desktop_access_tsp dAccess)
{
	memset(dAccess,0,sizeof(desktop_access_ts));
	dAccess->orgStation = GetProcessWindowStation();

	dAccess->userStation= OpenWindowStation(_TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
	if (!dAccess->userStation)
  		return FALSE;

	SetProcessWindowStation((HWINSTA)dAccess->userStation);
	return TRUE;
}

// ----------------------------------------------------
VOID ExitDesktopAccess(desktop_access_tsp dAccess)
{
	if (dAccess->orgStation)
	SetProcessWindowStation((HWINSTA)dAccess->orgStation);

	if (dAccess->userStation)
	CloseWindowStation((HWINSTA)dAccess->userStation);

	memset(dAccess,0,sizeof(desktop_access_ts));
}


// ----------------------------------------------------
BOOL  QueryCurrentDesktop(desktop_tsp desktop,BOOL onlyType)
{
	USER_INFO_11 *ui11;//LanManager without Administrator for own account!
	LPBYTE buf;
	HDESK hdesk;
	DWORD nl;
	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);

	if (!hdesk)
	{
		hdesk = OpenDesktop(_TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
		if (!hdesk)
		{
			desktop->userName[0] = 0;
			desktop->name[0] = 0;
			desktop->type = DESKTOP_ACCESSDENIED;
			desktop->user = USER_GUEST;
			return FALSE;
		}
	}

	GetUserObjectInformation(hdesk,UOI_NAME,desktop->name,NAME_LEN,&nl);
	CloseDesktop(hdesk);

	if (!_tcsicmp(desktop->name, _TEXT("Default")))
		desktop->type = DESKTOP_DEFAULT;
	else if (!_tcsicmp(desktop->name, _TEXT("Winlogon")))
		desktop->type = DESKTOP_WINLOGON;
	else if (!_tcsicmp(desktop->name, _TEXT("screen-saver")))
		desktop->type = DESKTOP_SCREENSAVER;
	else if (!_tcsicmp(desktop->name, _TEXT("Display.Cpl Desktop")))
		desktop->type = DESKTOP_TESTDISPLAY;
	else
		desktop->type = DESKTOP_OTHER;
	
	if (onlyType)
	{
		desktop->userName[0] = 0;
		desktop->user = USER_GUEST;
		return TRUE;
	}

	nl = NAME_LEN;
	GetUserName(desktop->userName, &nl);
	
	if (!_tcsicmp(desktop->userName,_TEXT("SYSTEM")))
	{
		desktop->user = USER_SUPERVISOR;
		return TRUE;
	}

	desktop->user = USER_GUEST;
	//mDEBUGOUT((1,(uchar_tp)L"%s User: %s", desktop->name,userName));
	if (NetUserGetInfo(NULL,//local computer
						desktop->userName, 11, &buf) == NERR_Success)
	{
		ui11 = (USER_INFO_11 *)buf;
		switch (ui11->usri11_priv)
		{
			case USER_PRIV_GUEST:
				desktop->user = USER_GUEST;
				break;

			case USER_PRIV_USER:
				desktop->user = USER_USER;
				break;

			case USER_PRIV_ADMIN:
			default:
				desktop->user = USER_SUPERVISOR;
		}
		//if (ui11->usri11_name)
		  //Vstrncpy(desktop->userName,ui11->usri11_name,PUBLICNAME_LEN);
		NetApiBufferFree(buf);
	}

	return TRUE;
}

#endif //ndef ONLY_DSWITCH


// ----------------------------------------------------
BOOL  SwitchToCurrentDesktop(void)
{
	HDESK hdesk;
	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
	
	if (!hdesk)
	{
		hdesk = OpenDesktop(_TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
		if (!hdesk)
		  return FALSE;
	}

	CloseDesktop(GetThreadDesktop(GetCurrentThreadId()));
	
	SetThreadDesktop(hdesk);
	return TRUE;
}
#ifndef ONLY_DSWITCH


// ----------------------------------------------------
VOID WaitDesktopChanged(desktop_tsp desktop)
{
	HDESK hdesk;
	DWORD i;

	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
	
	for (i = 0; i < 50; i++)
	{
	  if (hdesk)
			break;
		Sleep(120);
		hdesk = OpenDesktop(_TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
	}

	if (hdesk)
	    CloseDesktop(hdesk);

	QueryCurrentDesktop(desktop,TRUE);
	
	SwitchToCurrentDesktop();

}
#endif //ndef ONLY_DSWITCH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\manageshelllinks.cpp ===
// StartupLinks.cpp: implementation of the CManageShellLinks class
//                   to manage Shell Folder links.
//
// Note:  Multiple calls using the same class instance don't assume any
//        information about previous calls.  The only stuff in common
//        is the IShellLink object and the specific shell folder. 
//////////////////////////////////////////////////////////////////////

#include "stdio.h"
#include "ManageShellLinks.h"
#include "_umclnt.h"

#define SHELL_FOLDERS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define LINK_EXT TEXT(".lnk")

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CManageShellLinks::CManageShellLinks(
    LPCTSTR pszDestFolder   // [in] Which shell folder to operate on
    )
    : m_pIShLink(0)
    , m_pszShellFolder(0)
{
	// Get a pointer to the IShellLink interface
    HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                            IID_IShellLink, (void **)&m_pIShLink);

    if (FAILED(hr) || !m_pIShLink)
        DBPRINTF(TEXT("CManageShellLinks::CManageShellLinks:  CoCreateInstance failed 0x%x\r\n"), hr);

    m_pszShellFolder = new TCHAR[lstrlen(pszDestFolder)+1];
    if (m_pszShellFolder)
        lstrcpy(m_pszShellFolder, pszDestFolder);
}

CManageShellLinks::~CManageShellLinks()
{
	if (m_pIShLink)
	{
		m_pIShLink->Release();
		m_pIShLink = 0;
	}
    if (m_pszShellFolder)
	{
        delete [] m_pszShellFolder;
        m_pszShellFolder = 0;
	}
}

//*****************************************************************************
// GetFolderPath - returns shell folder path
//
// pszFolderPath [out]    - pointer to location for shell folder
// pulSize       [in out] - pointer to size of pszFolderPath
//
// Returns TRUE if it found the folder name else FALSE
//
long CManageShellLinks::GetFolderPath(LPTSTR pszFolderPath, unsigned long *pulSize)
{
    *pszFolderPath = 0;

    if (!m_pszShellFolder)
        return ERROR_NOT_ENOUGH_MEMORY;

    HKEY hkeyFolders;
    HKEY hkeyUser;

    // Open current user's hive and retrieve shell folder path

    long lRv = RegOpenCurrentUser(KEY_QUERY_VALUE, &hkeyUser);

    if (lRv == ERROR_SUCCESS)
    {
        lRv = RegOpenKeyEx(
                      hkeyUser
                    , SHELL_FOLDERS
                    , 0,KEY_QUERY_VALUE
                    , &hkeyFolders);
        RegCloseKey(hkeyUser);
    }

    if (lRv == ERROR_SUCCESS)
    {
    	DWORD dwType;
	    lRv = RegQueryValueEx( 
                      hkeyFolders
                    , m_pszShellFolder
                    , NULL
                    , &dwType
                    , (LPBYTE)pszFolderPath
                    , pulSize);
	    if (lRv != ERROR_SUCCESS || dwType != REG_SZ)
	    	pszFolderPath[0] = TEXT('\0');

        pszFolderPath[*pulSize-1] = TEXT('\0');
        
	    RegCloseKey(hkeyFolders);
    }

    return lRv;
}

//*****************************************************************************
// GetUsersFolderPath - returns the location of the current user's shell folder
//
// pszFolderPath [out]    - pointer to location for shell folder
// pulSize       [in out] - pointer to size of pszFolderPath
//
// Returns TRUE if it found the folder name else FALSE
//
BOOL CManageShellLinks::GetUsersFolderPath(LPTSTR pszFolderPath, unsigned long *pulSize)
{
    long lRv = ERROR_ACCESS_DENIED;
    unsigned long ulSize = 0;
    *pszFolderPath = 0;

    if (m_pszShellFolder)
    {
        ulSize = *pulSize;
        BOOL fError;

        // At this point, if UtilMan was started in the system context (WinKey+U),
        // HKCU points to "Default User".  We need it to point to the logged on
        // user's hive so we can get the correct path for the logged on user.
        // Note:  GetUserAccessToken() will fail if we are not started by SYSTEM
        // and in that case just get the logged on user's folder path.

        HANDLE hMyToken = GetUserAccessToken(TRUE, &fError);
        if (hMyToken)
        {
            if (ImpersonateLoggedOnUser(hMyToken))
            {
                lRv = GetFolderPath(pszFolderPath, &ulSize);
                RevertToSelf();
            }
            CloseHandle(hMyToken);
        }
        else
        {
            lRv = GetFolderPath(pszFolderPath, &ulSize);
        }
    }

    *pulSize = ulSize;
    return (lRv == ERROR_SUCCESS)?TRUE:FALSE;
}

//*****************************************************************************
// CreateLinkPath - returns the complete path and name of the link.  Caller
//                  free's the memory.
//
// pszLink [in] - the base name of the link itself
//
LPTSTR CManageShellLinks::CreateLinkPath(LPCTSTR pszLink)
{
    // allocate enough space for folder path + '\' + filename + NULL

    unsigned long ccbStartPath = MAX_PATH;
    LPTSTR pszLinkPath = new TCHAR [ccbStartPath + 1 + lstrlen(pszLink) + sizeof(LINK_EXT) + 1];
    if (!pszLinkPath)
        return NULL;

    // get the user's shell folder name

    if (!GetUsersFolderPath(pszLinkPath, &ccbStartPath) || !ccbStartPath)
    {
        delete [] pszLinkPath;
        return NULL;
    }

    // append the link name and extension

    lstrcat(pszLinkPath, TEXT("\\"));
    lstrcat(pszLinkPath, pszLink);
    lstrcat(pszLinkPath, LINK_EXT);

	return pszLinkPath;
}

//*****************************************************************************
// LinkExists - returns TRUE if pszLink exists in the shell folder else FALSE
//
// pszLink [in] - the base name of the link itself
//
BOOL CManageShellLinks::LinkExists(LPCTSTR pszLink)
{
    LPTSTR pszLinkPath = CreateLinkPath(pszLink);
    if (!pszLinkPath)
        return FALSE;

	DWORD dwAttr = GetFileAttributes(pszLinkPath);
	delete [] pszLinkPath;
	return (dwAttr == -1)?FALSE:TRUE;
}

//*****************************************************************************
// RemoveLink - removes a link from the user's shell folder
//
// pszLink     [in] - the base name of the link itself
//
// Returns S_OK on success or a standard HRESULT
//
HRESULT CManageShellLinks::RemoveLink(LPCTSTR pszLink)
{
	if (!m_pIShLink)
		return E_FAIL;

    LPTSTR pszLinkPath = CreateLinkPath(pszLink);
    if (!pszLinkPath)
        return E_FAIL;

	int iRemoveFailed = _wremove(pszLinkPath);
	delete [] pszLinkPath;
	return (iRemoveFailed)?S_FALSE:S_OK;
}

//*****************************************************************************
// CreateLink - creates a link in the user's shell folder
//
// pszLinkFile [in] - the fully qualified name of the file the link refers to
// pszLink     [in] - the base name of the link itself
// pszStartIn  [in] - working directory (may be NULL)
// pszDesc     [in] - the tooltip for the link (may be NULL)
// pszArgs     [in] - command line arguments (may be NULL)
//
// Returns S_OK on success or a standard HRESULT
//
HRESULT CManageShellLinks::CreateLink(
    LPCTSTR pszLink, 
    LPCTSTR pszLinkFile, 
    LPCTSTR pszStartIn, 
    LPCTSTR pszDesc,
    LPCTSTR pszArgs
    )
{
	if (!m_pIShLink)
    {
        DBPRINTF(TEXT("CManageShellLinks::CreateLink:  !m_pIShLink\r\n"));
		return E_FAIL;
    }

    LPTSTR pszLinkPath = CreateLinkPath(pszLink);
    if (!pszLinkPath)
    {
        DBPRINTF(TEXT("CManageShellLinks::CreateLink:  !pszLinkPath\r\n"));
		return E_FAIL;
    }

    IPersistFile *pIPersistFile;

    // Get the IPersistFile interface to save the shortcut

    HRESULT hr = m_pIShLink->QueryInterface(IID_IPersistFile, (void **)&pIPersistFile);
    if (SUCCEEDED(hr))
    {
        // Set the path to and description of the link

		// The shortcut
        if (FAILED(m_pIShLink->SetPath(pszLinkFile)))
	        DBPRINTF(TEXT("SetPath failed!\r\n"));

		// ToolTip description
        if (pszDesc && FAILED(m_pIShLink->SetDescription(pszDesc)))
	        DBPRINTF(TEXT("SetDescription failed!\r\n"));

		// Working directory
		if (pszStartIn && FAILED(m_pIShLink->SetWorkingDirectory(pszStartIn)))
			DBPRINTF(TEXT("SetWorkingDirectory failed!\r\n"));

        // Command line args
        if (pszArgs && FAILED(m_pIShLink->SetArguments(pszArgs)))
            DBPRINTF(TEXT("SetArguments failed!\r\n"));

        // Save it

        if (FAILED(pIPersistFile->Save(pszLinkPath, TRUE)))
	        DBPRINTF(TEXT("Save failed!\r\n"));

        pIPersistFile->Release();
    }

    delete [] pszLinkPath;

    return hr;
}

#ifdef __cplusplus
extern "C" {
#endif

//*****************************************************************************
// LinkExists - helper function called from C returns TRUE if pszLink exists 
//              in the shell folder else FALSE
//
// pszLink [in] - the base name of the link itself
//
BOOL LinkExists(LPCTSTR pszLink)
{
    CManageShellLinks CMngShellLinks(STARTUP_FOLDER);

    return CMngShellLinks.LinkExists(pszLink);
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\manageshelllinks.h ===
// StartupLinks.h: interface for the CManageShellLinks class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STARTUPLINKS_H__9F81721C_405C_4A8C_BE66_E5A6D1CDF1D5__INCLUDED_)
#define AFX_STARTUPLINKS_H__9F81721C_405C_4A8C_BE66_E5A6D1CDF1D5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STARTUP_FOLDER      TEXT("Startup")
#define STARTMENU_FOLDER    TEXT("Start Menu")
#define DESKTOP_FOLDER      TEXT("Desktop")

#include <shlobj.h>     // for IShellLink defines and prototypes
#include <oleguid.h>    // for IID_IPersistFile
#include "w95trace.h"

#ifdef __cplusplus
class CManageShellLinks  
{
public:
	CManageShellLinks(LPCTSTR pszDestFolder);
	virtual ~CManageShellLinks();
	HRESULT CreateLink(LPCTSTR pszLink, LPCTSTR pszLinkFile
                     , LPCTSTR pszStartIn, LPCTSTR pszDesc, LPCTSTR pszArgs);
	HRESULT RemoveLink(LPCTSTR pszLink);
	BOOL LinkExists(LPCTSTR pszLink);

private:
	LPTSTR CreateLinkPath(LPCTSTR pszLink);
	BOOL GetUsersFolderPath(LPTSTR pszFolderPath, unsigned long *pulSize);
    long GetFolderPath(LPTSTR pszFolderPath, unsigned long *pulSize);

	IShellLink *m_pIShLink;     // IShellLink interface pointer
    LPTSTR m_pszShellFolder;    // The specific shell folder 
};
#endif

#ifdef __cplusplus
extern "C" {
#endif
// LinkExists - helper function called from C returns TRUE if pszLink exists 
BOOL LinkExists(LPCTSTR pszLink);
#ifdef __cplusplus
}
#endif

#endif // !defined(AFX_STARTUPLINKS_H__9F81721C_405C_4A8C_BE66_E5A6D1CDF1D5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\memfile.c ===
// ----------------------------------------------------------------------------
//
// MemFile.c
//
// Memory handling module
//
// Build: May-12-97
//
// Author: J. Eckhardt
// This code was written for ECO Kommunikation Insight
// Copyright (c) 1997-1999 Microsoft Corporation
// ----------------------------------------------------------------------------
#include <windows.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"

// -------------------------------------------------------------------
// task independent memory
// -------------------------------------------------------------------
HANDLE CreateIndependentMemory(LPTSTR name, DWORD size, BOOL inherit)
{
	LPSECURITY_ATTRIBUTES psa = NULL;
	obj_sec_attr_ts sa;
	HANDLE hFileMap;

	if (inherit)
	{
		psa = &sa.sa;
		InitSecurityAttributesEx(&sa, GENERIC_ALL, GENERIC_READ|GENERIC_WRITE);
	}

	hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE, psa, PAGE_READWRITE, 0, size,name);

    DBPRINTF(TEXT("CreateIndependentMemory:  CreateFileMapping(%s) returns %d\r\n"), name, GetLastError());

	if (inherit)
		ClearSecurityAttributes(&sa);

	if (hFileMap == INVALID_HANDLE_VALUE)
	{
		return NULL;
	}
	return hFileMap;
}

// ---------------------------
LPVOID AccessIndependentMemory(LPTSTR name, DWORD size, DWORD dwDesiredAccess, PDWORD_PTR accessID)
{
	HANDLE hMap;
	LPVOID n;
	*accessID = 0;

	hMap = OpenFileMapping(dwDesiredAccess, FALSE, name);
	
	if (!hMap)
	{
		return NULL;
	}

	n = MapViewOfFile(hMap, dwDesiredAccess, 0, 0, size);
	
	if (!n)
	{
		CloseHandle(hMap);
		return NULL;
	}

	*accessID = (DWORD_PTR)hMap;
	return n;
}

// ---------------------------
void UnAccessIndependentMemory(LPVOID data, DWORD_PTR accessID)
{
	if (data)
		UnmapViewOfFile(data);

	if (accessID)
		CloseHandle((HANDLE)accessID);
}

// ---------------------------
void DeleteIndependentMemory(HANDLE id)
{
	if (id)
	  CloseHandle(id);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\secdescr.c ===
// ----------------------------------------------------------------------------
//
// SecDescr.c
//
//
// Author: Jost Eckhardt
// 
// This code was written for ECO Kommunikation Insight
// Copyright (c) 1997-1999 Microsoft Corporation
// ----------------------------------------------------------------------------
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"

static PSECURITY_DESCRIPTOR GetObjectSecurityDescr(
						obj_sec_descr_tsp obj, 
					    DWORD dwAccessMaskOwner, 
						DWORD dwAccessMaskLoggedOnUser);
static BOOL GetUserSidFromToken(HANDLE hToken, PSID *ppSid);
static BOOL GetGroupSidFromToken(HANDLE hToken, PSID *ppSid);

// ---------------------------
// InitSecurityAttributes - initialize the security descriptor in the
//                          obj_sec_attr_tsp struct using a null DACL.
//
// Caller must call ClearSecurityAttributes when done with the struct.
//
void InitSecurityAttributes(obj_sec_attr_tsp  psa)
{
	memset(psa,0,sizeof(obj_sec_attr_ts));
	psa->sa.nLength = sizeof(SECURITY_ATTRIBUTES);

	psa->sa.bInheritHandle = TRUE;
	psa->sa.lpSecurityDescriptor = GetObjectSecurityDescr(&psa->objsd, 0, 0);
}

// ---------------------------
// InitSecurityAttributesEx - initialize the security descriptor in the
//                            obj_sec_attr_tsp struct using a non-null DACL
//
// dwAccessMaskOwner		- If non-zero specifies the access allowed to the creator
// dwAccessMaskLoggedOnUser	- If non-zero specifies the access allowed to the current user 
//
// If dwAccessMaskOwner and dwAccessMaskLoggedOnUser are zero the security descriptor
// will have a NULL DACL.  Caller must call ClearSecurityAttributes when done 
// with the struct.
//
void InitSecurityAttributesEx(obj_sec_attr_tsp  psa, DWORD dwAccessMaskOwner, DWORD dwAccessMaskLoggedOnUser)
{
	memset(psa,0,sizeof(obj_sec_attr_ts));
	psa->sa.nLength = sizeof(SECURITY_ATTRIBUTES);

	psa->sa.bInheritHandle = TRUE;
	psa->sa.lpSecurityDescriptor = GetObjectSecurityDescr(&psa->objsd, dwAccessMaskOwner, dwAccessMaskLoggedOnUser);
}

// ---------------------------
// ClearSecurityAttributes - free memory from the security descriptor
//
void ClearSecurityAttributes(obj_sec_attr_tsp  psa)
{
	if (psa->sa.lpSecurityDescriptor)
		free(psa->sa.lpSecurityDescriptor);

	if (psa->objsd.psidUser)
		free(psa->objsd.psidUser);

	if (psa->objsd.psidGroup)
		free(psa->objsd.psidGroup);

	memset(psa,0,sizeof(obj_sec_attr_ts));
}

// ---------------------------
static PSECURITY_DESCRIPTOR GetObjectSecurityDescr(
								obj_sec_descr_tsp obj, 
								DWORD dwAccessMaskOwner, 
								DWORD dwAccessMaskLoggedOnUser)
{
	PSECURITY_DESCRIPTOR psd = NULL;
	HANDLE hToken;
	GENERIC_MAPPING gm =  {1, 2, 4, 8};
	DWORD dwDesired = 1;
	BOOL fAccess = FALSE;
	DWORD dwGranted;
	PRIVILEGE_SET ps;
	DWORD cbPriv = sizeof (ps);
    PACL  pAcl;
    ULONG cbAcl;
	PSID  psidCurUser;

    obj->psidUser = obj->psidGroup = NULL;
    
    // Get the user's SID
	
	if (!ImpersonateSelf(SecurityImpersonation))
		return NULL;
	
	if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
		goto GSSD_ERROR;
	
	if (!GetUserSidFromToken(hToken, &obj->psidUser))
		goto GSSD_ERROR;
	
	// assumption:  if either access masks are given
	// then the owner access mask must be given

	if (dwAccessMaskLoggedOnUser && !dwAccessMaskOwner)
		goto GSSD_ERROR;

    // Figure the size of an access-allowed ACL (if an
    // access mask is supplied there will be one ACE)

    cbAcl = 0;
    if (dwAccessMaskOwner)
    {
        cbAcl = sizeof(ACL)
		      + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)
			  + GetLengthSid(obj->psidUser);
    }

	psidCurUser = 0;
    if (dwAccessMaskLoggedOnUser)
    {
		psidCurUser = InteractiveUserSid(TRUE);
		if (psidCurUser)
		{
			cbAcl += sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)
				  + GetLengthSid(psidCurUser);
		}
	}
	
    // Allocate space for the SD and the ACL
	
	psd = malloc(SECURITY_DESCRIPTOR_MIN_LENGTH + cbAcl);
	
	if (!psd)
		goto GSSD_ERROR;
	
    // Add ACEs to the ACL if specified
	
	pAcl = NULL;
    if (dwAccessMaskOwner)
    {
        // Point to the ACL in the security descriptor
		
		pAcl = (ACL *)((BYTE *)psd + SECURITY_DESCRIPTOR_MIN_LENGTH);
		
		if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) 
			goto GSSD_ERROR;
		
        // Set access allowed for creator
		
		if (!AddAccessAllowedAce(pAcl, 
								 ACL_REVISION, 
								 dwAccessMaskOwner,
								 obj->psidUser)) 
			goto GSSD_ERROR;
		
        // Set access allowed for everyone else
		
		if (psidCurUser)
		{
			if (!AddAccessAllowedAce(pAcl, 
									 ACL_REVISION, 
									 dwAccessMaskLoggedOnUser,
									 psidCurUser)) 
				goto GSSD_ERROR;
		}
    }
	
    // Initialize the security descriptor etc...
	
	if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
		goto GSSD_ERROR;
    if (!SetSecurityDescriptorDacl(psd, TRUE, (dwAccessMaskOwner)?pAcl:NULL, FALSE))
		goto GSSD_ERROR;
    if (!SetSecurityDescriptorOwner(psd, obj->psidUser, FALSE))
		goto GSSD_ERROR;
	if (!GetGroupSidFromToken(hToken, &obj->psidGroup))
		goto GSSD_ERROR;
	if (!SetSecurityDescriptorGroup(psd, obj->psidGroup, FALSE))
		goto GSSD_ERROR;
	if (!AccessCheck(psd, hToken, dwDesired, &gm, &ps, &cbPriv,&dwGranted, &fAccess))
		goto GSSD_ERROR;
	
	RevertToSelf();
	
	return psd;
	
GSSD_ERROR:
	
	if (psd)
		free(psd);
	if (obj->psidUser)
		free(obj->psidUser);
	if (obj->psidGroup)
		free(obj->psidGroup);
	
	RevertToSelf();
	return NULL;
}

// ----------------------------------------
static BOOL GetGroupSidFromToken(HANDLE hToken, PSID *ppSid)
{
	TOKEN_PRIMARY_GROUP *pGroup = NULL;
	PSID psidGroup = NULL;
	DWORD cbSid;
	DWORD cbRequired;

	if (GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &cbRequired))
		return FALSE;

	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		return FALSE;

	pGroup = malloc(cbRequired);

	if (!pGroup)
		return FALSE;

	if (!GetTokenInformation(hToken, TokenPrimaryGroup, pGroup,cbRequired, &cbRequired))
		goto GGSFT_ERROR;

	cbSid = GetLengthSid(pGroup->PrimaryGroup);
	psidGroup = malloc(cbSid);

	if (!psidGroup)
		goto GGSFT_ERROR;

	if (!CopySid(cbSid, psidGroup, pGroup->PrimaryGroup))
		goto GGSFT_ERROR;

	*ppSid = psidGroup;
	psidGroup = NULL;

	return TRUE;

GGSFT_ERROR:
	
	if (psidGroup)
		free(psidGroup);

	free(pGroup);

	return FALSE;
}

// ----------------------------------------
static BOOL GetUserSidFromToken(HANDLE hToken, PSID *ppSid)
{
	TOKEN_USER *pUser = NULL;
	PSID psidUser = NULL;
	DWORD cbSid;
	DWORD cbRequired;

	if (GetTokenInformation(hToken, TokenUser, NULL, 0, &cbRequired))
		return FALSE;

	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER )
		return FALSE;

	pUser = malloc(cbRequired);

	if (!pUser)
		return FALSE;

	if (!GetTokenInformation(hToken, TokenUser, pUser, cbRequired,&cbRequired))
		goto GUSFT_ERROR;

	cbSid = GetLengthSid(pUser->User.Sid);
	psidUser = malloc(cbSid);

	if (!psidUser)
		goto GUSFT_ERROR;
	if (!CopySid(cbSid, psidUser, pUser->User.Sid))
		goto GUSFT_ERROR;
	
	*ppSid = psidUser;
	psidUser = NULL;
	return TRUE;

GUSFT_ERROR:
	if (psidUser)
		free(psidUser);

	free(pUser);
	return FALSE;
}

PSID EveryoneSid(BOOL fFetch)
{
    static PSID psidEverybody = 0;
    SID_IDENTIFIER_AUTHORITY siaEverybody = SECURITY_WORLD_SID_AUTHORITY;
	BOOL fRv = FALSE;

	if (!fFetch)
	{
		if (psidEverybody)
		{
			FreeSid(psidEverybody);
			psidEverybody = 0;
		}
		return 0;
	}

	if (!psidEverybody)
	{
		if (!AllocateAndInitializeSid(
						&siaEverybody, 
						1,
						SECURITY_WORLD_RID,
						0, 0, 0, 0, 0, 0, 0,
						&psidEverybody
						))
		{			
			psidEverybody = 0;
		}
	}

    return psidEverybody;
}

PSID AdminSid(BOOL fFetch)
{
    static PSID psidAdmin = 0;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
	BOOL fRv = FALSE;

	if (!fFetch)
	{
		if (psidAdmin)
		{
			FreeSid(psidAdmin);
			psidAdmin = 0;
		}
		return 0;
	}

	if (!psidAdmin)
	{
		if (!AllocateAndInitializeSid(&siaNtAuthority,
                                       2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_ADMINS,
                                       0, 0, 0, 0, 0, 0,
                                       &psidAdmin))
		{			
			psidAdmin = 0;
		}
	}

    return psidAdmin;
}

PSID InteractiveUserSid(BOOL fFetch)
{
    static PSID psidInteractiveUser = 0;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
	BOOL fRv = FALSE;

	if (!fFetch)
	{
		if (psidInteractiveUser)
		{
			FreeSid(psidInteractiveUser);
			psidInteractiveUser = 0;
		}
		return 0;
	}

	if (!psidInteractiveUser)
	{
		if (!AllocateAndInitializeSid(&siaLocalSystem, 
									1,
									SECURITY_INTERACTIVE_RID,
									0, 0, 0, 0, 0, 0, 0,
									&psidInteractiveUser))
		{			
			psidInteractiveUser = 0;
		}
	}

    return psidInteractiveUser;
}

PSID SystemSid(BOOL fFetch)
{
    static PSID psidSystem = 0;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
	BOOL fRv = FALSE;

	if (!fFetch)
	{
		if (psidSystem)
		{
			FreeSid(psidSystem);
			psidSystem = 0;
		}
		return 0;
	}

	if (!psidSystem)
	{
		if (!AllocateAndInitializeSid(&siaLocalSystem, 
									1,
									SECURITY_LOCAL_SYSTEM_RID,
									0, 0, 0, 0, 0, 0, 0,
									&psidSystem))
		{			
			psidSystem = 0;
		}
	}

    return psidSystem;
}

void InitWellknownSids()
{
	EveryoneSid(TRUE);
	AdminSid(TRUE);
    InteractiveUserSid(TRUE);
	SystemSid(TRUE);
}

void UninitWellknownSids()
{
	EveryoneSid(FALSE);
	AdminSid(FALSE);
    InteractiveUserSid(FALSE);
	SystemSid(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\ums_ctrl.h ===
// -------------------------------------------------------
// UMS_Ctrl.h
// definition of the UtilityManager service control codes
//
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//
// History: created nov-15-98 by JE
// -------------------------------------------------------
#ifndef _UMS_CTRL_H_
#define _UMS_CTRL_H_
// --------------------
#define UTILMAN_SERVICE_NAME            _TEXT("UtilMan")
#define UTILMAN_START_BYHOTKEY          _TEXT("/Hotkey") 
// show the UtilityManager dialog code
 #define UM_SERVICE_CONTROL_SHOWDIALOG   128
// internal to UM:
 // UtilityManager dialog has closed code
 #define UM_SERVICE_CONTROL_DIALOGCLOSED 129
 // UtilityManager internal reserved
 #define UM_SERVICE_CONTROL_RESERVED     130
// reserved for Microsoft
 #define UM_SERVICE_CONTROL_MIN_RESERVED 131
 #define UM_SERVICE_CONTROL_MAX_RESERVED 141
// codes to launch a specific client
 #define UM_SERVICE_CONTROL_FIRSTCLIENT  142
 #define UM_SERVICE_CONTROL_LASTCLIENT   255

#endif _UMS_CTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\umanclnt.c ===
// ----------------------------------------------------------------------------
//
// UManClnt.c
//
// Utility Manager client depending code (used by UtilMan and UManDlg)
//
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
//
// History: created oct-98 by JE
//          JE nov-15-98: removed any code related to key hook
//          YX may-27-99: functions to start apps under current user account
//			YX may-29-99: apps start under user account even from LogOn desktop,
//						  if possible
//			YX jun-04-99: code to report the app processes status even if they
//						  have been started outside Utilman
//			YX jun-23-99: IsAdmin function added (used in the dialog)
//			Bug Fixes and Changes Anil Kumar 1999
// ----------------------------------------------------------------------------
#include <windows.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"
#include "w95trace.c"
#include "UtilMan.h"
#include "_UMClnt.h"
#include "ums_ctrl.h"
#include "w95trace.h"

// Handle to the utilman instance that is showing UI
HANDLE g_hUIProcess = 0;
// From Terminal services
extern BOOL GetWinStationUserToken(ULONG, PHANDLE);
// Private User function that returns user token for session 0 only
HANDLE GetCurrentUserTokenW( WCHAR WinSta[], DWORD desiredAccess);

#include <psapi.h>
#define MAX_NUMBER_OF_PROCESSES 2048

//
// RunningInMySession - returns TRUE if the specified process ID is 
// running in the same session as UtilMan.  In Whistler, with terminal
// services integrated, UtilMan is able to get information about 
// processes that are not running in the same session.  We must
// avoid impacting these processes.
//
BOOL RunningInMySession(DWORD dwProcessId)
{
    DWORD dwSessionId = -1;
    static DWORD dwMySessionId = -1;

    if (-1 == dwMySessionId)
    {
        ProcessIdToSessionId(GetCurrentProcessId(), &dwMySessionId);
    }

    ProcessIdToSessionId(dwProcessId, &dwSessionId);

    return (dwSessionId == dwMySessionId)?TRUE:FALSE;
}

// These are for compiling with irnotig.lib
// To be REMOVED once that becomes an API of advapi.lib
PVOID MIDL_user_allocate(IN size_t BufferSize)
{
    return( LocalAlloc(0, BufferSize));
}

VOID MIDL_user_free(IN PVOID Buffer)
{
    LocalFree( Buffer );
}

BOOL StartAppAsUser( LPCTSTR appPath, 
					 LPTSTR cmdLine,
					 LPSTARTUPINFO lpStartupInfo,
					 LPPROCESS_INFORMATION lpProcessInformation);

BOOL GetApplicationProcessInfo(umclient_tsp tspClient, BOOL fCloseHandle);
BOOL CloseAllWindowsByProcessID(DWORD procID);



// ---------------------------------
BOOL StartClient(HWND hParent,umclient_tsp client)
{
	if (client->runCount >= client->machine.MaxRunCount || client->runCount >= MAX_APP_RUNCOUNT)
	{
		DBPRINTF(_TEXT("StartClient run count >= max run count\r\n"));
		return FALSE;
	}

	switch (client->machine.ApplicationType)
	{
		case APPLICATION_TYPE_APPLICATION:
		{
			BOOL fStarted;
			TCHAR ApplicationPath[MAX_APPLICATION_PATH_LEN+100];

			if (!GetClientApplicationPath(
				  client->machine.ApplicationName
				, ApplicationPath
				, MAX_APPLICATION_PATH_LEN))
            {
				return FALSE;
            }
            
            fStarted = StartApplication(ApplicationPath 
                                      , UTILMAN_STARTCLIENT_ARG 
                                      ,  client->user.fCanRunSecure
                                      ,  &client->processID[client->runCount]
                                      ,  &client->hProcess[client->runCount]
                                      ,  &client->mainThreadID[client->runCount]);

			if (!fStarted)
			{
				return FALSE;
			}

			client->runCount++;
			client->state = UM_CLIENT_RUNNING;
			break;
		}

		case APPLICATION_TYPE_SERVICE:
		{
			DWORD i = 0;
			SERVICE_STATUS  ssStatus;
			SC_HANDLE hService;
			TCHAR arg2[200];
			LPTSTR args[2];
			SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
			if (!hSCM)
				return FALSE;

			hService = OpenService(hSCM, client->machine.ApplicationName, SERVICE_ALL_ACCESS);
			CloseServiceHandle(hSCM);
			if (!hService)
			{
				return FALSE;
			}
  			arg2[0] = 0;
  			args[0] = UTILMAN_STARTCLIENT_ARG;
	  		args[1] = arg2;
    		if (!StartService(hService,1,args))
			{ 
				CloseServiceHandle(hService);
				return FALSE;
			} 

			Sleep(1000);
			while(QueryServiceStatus(hService, &ssStatus))
			{ 
				if (ssStatus.dwCurrentState == SERVICE_RUNNING)
			    break;

				Sleep(1000);
				i++;
				if (i >= 60)
					break;
			} 

			if (ssStatus.dwCurrentState != SERVICE_RUNNING)
			{ 
				CloseServiceHandle(hService);
  				return FALSE;
			} 

			CloseServiceHandle(hService);

			client->runCount++;
			client->processID[0] = 0;
			client->mainThreadID[0] = 0;
			client->hProcess[0] = NULL;
			client->state = UM_CLIENT_RUNNING;

			break;
		}

		default:
			return FALSE;
	}
	return TRUE;
}
// ---------------------------------

// The hParent window is used to signal whether the stop is interactive
// (and thus WM_COLSE could be used) or is a reaction to the desktop
// change
BOOL StopClient(umclient_tsp client)
{
	if (!client->runCount || client->runCount > MAX_APP_RUNCOUNT)
		return FALSE;

	switch (client->machine.ApplicationType)
	{
		case APPLICATION_TYPE_APPLICATION:
		{
			DWORD j, runCount = client->runCount;
			for (j = 0; j < runCount; j++)
			{
                // If client was started outside UtilMan then try to get its process ID
				if (client->mainThreadID[j] == 0)
				{
					if (!GetApplicationProcessInfo(client, FALSE))
					{
					    // could not find the client, so prevent attempts to stop it
						client->hProcess[j] = NULL;
					}
				}
				if (client->hProcess[j])
				{ 
				    // Try to close the application by sending a WM_CLOSE message to 
				    // all the windows in opened by the process.  Then just kill it.

					BOOL sent = CloseAllWindowsByProcessID(client->processID[j]);
					if (!sent)
					{
						TerminateProcess(client->hProcess[j],1);
					}

					client->processID[j] = 0;
                    CloseHandle(client->hProcess[j]);
	  				client->hProcess[j] = NULL;
		  			client->mainThreadID[j] = 0;
					client->runCount--;
					if (!client->runCount)
					    client->state = UM_CLIENT_NOT_RUNNING;
				}
			}
			if (runCount != client->runCount)
			{
		        for (j = 0; j < (runCount-1); j++)
                { 
			        if (!client->hProcess[j])
                    {
					    memmove(&client->processID[j], &client->processID[j+1],sizeof(DWORD)*(runCount-j-1));
					    memmove(&client->hProcess[j], &client->hProcess[j+1],sizeof(HANDLE)*(runCount-j-1));
					    memmove(&client->mainThreadID[j], &client->mainThreadID[j+1],sizeof(DWORD)*(runCount-j-1));
                    } 
				}
			}
			break;
		}

		case APPLICATION_TYPE_SERVICE:
		{
			SERVICE_STATUS  ssStatus;
			SC_HANDLE hService;
			SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
			if (!hSCM)
				return FALSE;
			hService = OpenService(hSCM, client->machine.ApplicationName, SERVICE_ALL_ACCESS);
			CloseServiceHandle(hSCM);
			if (!hService)
				 return FALSE;
			if (ControlService(hService, SERVICE_CONTROL_STOP, &ssStatus))
			{ 
				DWORD i = 0;
				Sleep(1000);
				while(QueryServiceStatus(hService, &ssStatus))
				{ 
					if (ssStatus.dwCurrentState == SERVICE_STOPPED)
				    break;
					Sleep(1000);
					i++;
					if (i >= 60)
					break;
				} 

				if (ssStatus.dwCurrentState != SERVICE_STOPPED)
				{ 
					CloseServiceHandle(hService);
	  				return FALSE;
				} 
			} 

			CloseServiceHandle(hService);
			client->runCount--;
 			client->processID[0] = 0;
  			client->hProcess[0] = NULL;
	  		client->mainThreadID[0] = 0;
			if (!client->runCount)
  				client->state = UM_CLIENT_NOT_RUNNING;
			break;
		}

		default:
			return FALSE;
	}

	return TRUE;
}//StopClient

// ---------------------------------
BOOL  GetClientApplicationPath(LPTSTR ApplicationName, LPTSTR ApplicationPath,DWORD len)
{
	HKEY hKey, sKey;
	DWORD ec, slen,type;

	ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE, UM_REGISTRY_KEY,0,KEY_READ,&hKey);
	
	if (ec != ERROR_SUCCESS)
		return FALSE;
	ec = RegOpenKeyEx(hKey,ApplicationName,0,KEY_READ,&sKey);
	
	if (ec != ERROR_SUCCESS)
	{
		RegCloseKey(hKey);
		return FALSE;
	}
	
	slen = sizeof(TCHAR)*len;
	ec = RegQueryValueEx(sKey,UMR_VALUE_PATH,NULL,&type,(LPBYTE)ApplicationPath,&slen);
	
	if ((ec != ERROR_SUCCESS) || (type != REG_SZ))
	{
		ApplicationPath[0] = TEXT('\0');
		RegCloseKey(sKey);
		RegCloseKey(hKey);
		return FALSE;
	}
	
	ApplicationPath[slen-1] = TEXT('\0');
	
	RegCloseKey(sKey);
	RegCloseKey(hKey);
    return (slen)?TRUE:FALSE;
}//GetClientApplicationPath

BOOL TestServiceClientRuns(umclient_tsp client,SERVICE_STATUS  *ssStatus)
{
	SC_HANDLE hService;
	SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
	
	if (!hSCM)
		return FALSE;
	
	hService = OpenService(hSCM, client->machine.ApplicationName, SERVICE_ALL_ACCESS);
	CloseServiceHandle(hSCM);
	
	if (!hService)
		return FALSE;
	
	if (!QueryServiceStatus(hService, ssStatus) ||
		 (ssStatus->dwCurrentState == SERVICE_STOPPED))
	{
		CloseServiceHandle(hService);
		return FALSE;
	}

	CloseServiceHandle(hService);
	return TRUE;
}

// 
// CheckStatus - Called from utilman's main timer and the dialog's timer 
//               to detect the state of running applications and pick up
//               any that are started outside of utilman. 
//
// Returns:  TRUE if the state of any application has changed else FALSE
//
BOOL CheckStatus(umclient_tsp c, DWORD cClients)
{
	DWORD i;
    BOOL  fAnyChanges = FALSE;

	for (i = 0; i < cClients && cClients < MAX_NUMBER_OF_CLIENTS; i++)
	{
	    // detect the client process started outside UMan
		if ( (!c[i].runCount))
		{
			if (GetApplicationProcessInfo(&c[i], TRUE))
            {
                fAnyChanges = TRUE;
            }
		}
		// detect clients not running anymore or not responding
  		switch (c[i].machine.ApplicationType)
		{
			case APPLICATION_TYPE_APPLICATION:
			{
				DWORD j, dwRunCount = c[i].runCount;
 				for (j = 0; j < dwRunCount && j < MAX_APP_RUNCOUNT; j++)
				{
				    // step 1: test if terminated
					if (!GetProcessVersion(c[i].processID[j]))
					{
						c[i].runCount--;
						c[i].hProcess[j] = NULL;
						c[i].processID[j] = 0;
  						c[i].mainThreadID[j] = 0;
	  					c[i].state = UM_CLIENT_NOT_RUNNING;
                        c[i].user.fRestartOnDefaultDesk = FALSE;
                        fAnyChanges = TRUE;
						continue;   // its not running anymore
					}

	  			    // step 2: test if responding (only processes started by utilman - mainThreadID != 0)
					if (c[i].mainThreadID[j] != 0)
					{
						if (!PostThreadMessage(c[i].mainThreadID[j],WM_QUERYENDSESSION,0,ENDSESSION_LOGOFF))
						{
							c[i].state = UM_CLIENT_NOT_RESPONDING;
                            fAnyChanges = TRUE;
							continue;   // its not responding
						}
					}

					if (c[i].state != UM_CLIENT_RUNNING)
					{
						fAnyChanges = TRUE;
					}
					c[i].state = UM_CLIENT_RUNNING;
				}

				if (dwRunCount != c[i].runCount)
				{
  					for (j = 0; j < (dwRunCount-1) && j < (MAX_APP_RUNCOUNT-1); j++)
					{
						if (!c[i].processID[j])
						{
							memmove(&c[i].processID[j], &c[i].processID[j+1],sizeof(DWORD)*(dwRunCount-j-1));
							memmove(&c[i].hProcess[j], &c[i].hProcess[j+1],sizeof(HANDLE)*(dwRunCount-j-1));
							memmove(&c[i].mainThreadID[j], &c[i].mainThreadID[j+1],sizeof(DWORD)*(dwRunCount-j-1));
						}
					}
				}
				break;
			}
  			case APPLICATION_TYPE_SERVICE:
			{
				SERVICE_STATUS  ssStatus;
				if (!TestServiceClientRuns(&c[i],&ssStatus))
				{
 					c[i].runCount--;
	  				c[i].processID[0] = 0;
 		  			c[i].mainThreadID[0] = 0;
  					c[i].state = UM_CLIENT_NOT_RUNNING;
                    fAnyChanges = TRUE;
				}
	  			break;
			}
		}
	}

    return fAnyChanges;
}

__inline DWORD GetCurrentSession()
{
    static DWORD dwSessionId = -1;
    if (-1 == dwSessionId)
    {
        ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId);
    }
    return dwSessionId;
}

// GetUserAccessToken - return the logged on user's access token
//
// If fNeedImpersonationToken is true the token will be an
// impersonation token otherwise it will be a primary token.
// The returned token will be 0 if security calls fail.
//
// Notes:  Caller must call CloseHandle on the returned handle.
//

HANDLE GetUserAccessToken(BOOL fNeedImpersonationToken, BOOL *fError)
{
    HANDLE hUserToken = 0;
    HANDLE hImpersonationToken = 0;
    *fError = FALSE;

    if (!GetWinStationUserToken(GetCurrentSession(), &hImpersonationToken))
    {
		// Call private API in the case where terminal services aren't running
        
        HANDLE hPrimaryToken = 0;
        DWORD dwFlags = TOKEN_QUERY | TOKEN_DUPLICATE;
        
        dwFlags |= (fNeedImpersonationToken)? TOKEN_IMPERSONATE : TOKEN_ASSIGN_PRIMARY;
        
        hPrimaryToken = GetCurrentUserTokenW (L"WinSta0", dwFlags);
        
        // GetCurrentUserTokenW returns a primary token; turn
        // it into an impersonation token if needed
        
        if (hPrimaryToken && fNeedImpersonationToken)
        {
            if (!DuplicateToken(hPrimaryToken, SecurityImpersonation, &hUserToken))
            {
                *fError = TRUE;
                DBPRINTF(TEXT("GetUserAccessToken:  DuplicateToken returned %d\r\n"), GetLastError());
            }
            
            CloseHandle(hPrimaryToken);
            
        } else
        {
            // otherwise, give out the primary token even if NULL
            hUserToken = hPrimaryToken;
        }
    }
    else
    {
        // Terminal services are running see if we need primary token

        if (hImpersonationToken && !fNeedImpersonationToken)
        {
            if (!DuplicateTokenEx(hImpersonationToken, 0, NULL
                            , SecurityImpersonation, TokenPrimary, &hUserToken))
            {
                *fError = TRUE;
                DBPRINTF(TEXT("GetUserAccessToken:  DuplicateTokenEx returned %d\r\n"), GetLastError());
            }

            CloseHandle(hImpersonationToken);

        } else
        {
            // otherwise, give out the impersonation token even if NULL
            hUserToken = hImpersonationToken;
        }
    }

    return hUserToken;
}

// StartAppAsUser - start the app in the context of the logged on user
//
BOOL StartAppAsUser( LPCTSTR appPath, LPTSTR cmdLine,
					LPSTARTUPINFO lpStartupInfo,
					LPPROCESS_INFORMATION lpProcessInformation)
{
    HANDLE hNewToken = 0;
	BOOL fStarted = FALSE;
    BOOL fError;
	
    // Get the our process's primary token (only succeeds if we are SYSTEM)
    hNewToken = GetUserAccessToken(FALSE, &fError);
	if (hNewToken)
	{
		// running in system context so impersonate the logged on user

		fStarted = CreateProcessAsUser( hNewToken, appPath,
				                 cmdLine, 0, 0, FALSE,
								 NORMAL_PRIORITY_CLASS , 0, 0,
								 lpStartupInfo, lpProcessInformation );

		CloseHandle( hNewToken );
        DBPRINTF(TEXT("StartAppAsUser:  CreateProcessAsUser(%s, %s) returns %d\r\n"), appPath, cmdLine, fStarted);
    } 
    else if (IsInteractiveUser())
    {
        TCHAR szArg[] = UTILMAN_STARTCLIENT_ARG;
        // Running in interactive user's context, just do normal create.  Since
        // we are the interactive user default security descriptors will do.
		fStarted = CreateProcess(appPath, szArg
				, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE
				, NULL, NULL, lpStartupInfo, lpProcessInformation);
        DBPRINTF(TEXT("StartAppAsUser:  CreateProcess(%s, %s) returns %d\r\n"), appPath, UTILMAN_STARTCLIENT_ARG, fStarted);
    }

    // caller is going to close handles

	return fStarted;
}

// Functions to detect running copies of Accessibility utilities

// FindProcess - Searches the running processes by application name.  If found,
//               returns the process id.  Else returns zero.  If the process
//               id is returned then phProcess is the process handle.  The
//               caller must close the process handle.
//
// pszApplicationName [in]  - application as base.ext
// phProcess          [out] - pointer to memory to receive process handle
//
// returns the process Id.
//
DWORD FindProcess(LPCTSTR pszApplicationName, HANDLE *phProcess)
{
    DWORD dwProcId = 0;
	DWORD adwProcess[MAX_NUMBER_OF_PROCESSES];  // array to receive the process identifiers
	DWORD cProcesses;
    DWORD dwThisProcess = GetCurrentProcessId();
    unsigned int i;

    *phProcess = 0;

    // Get IDs of all running processes

	if (!EnumProcesses(adwProcess, sizeof(adwProcess), &cProcesses))
		return 0;

    // cProcesses is returned as bytes; convert to number of processes

    cProcesses = cProcesses/sizeof(DWORD);
    if (cProcesses > MAX_NUMBER_OF_PROCESSES)
    	cProcesses = MAX_NUMBER_OF_PROCESSES;
	
    // open each process and test against pszApplicationName

	for (i = 0; i < cProcesses; i++)
	{
		HANDLE hProcess;
        //
        // EnumProcesses returns process IDs across all sessions but
        // we are only interested in processes in our session
        //
        if (!RunningInMySession(adwProcess[i]))
            continue;

        // Skip this process

        if (dwThisProcess == adwProcess[i])
            continue;

        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ
                                , FALSE, adwProcess[i]);

		if (hProcess != NULL)
		{
			HMODULE hMod;
	        TCHAR szProcessName[MAX_PATH];
	        DWORD ccbProcess;

            // find the module handle of exe of this process then it's base name (name.ext)

			if ( EnumProcessModules( hProcess, &hMod, sizeof(hMod), &ccbProcess) )
			{
				DWORD ctch = GetModuleBaseName(hProcess, hMod, szProcessName, MAX_PATH);
				if (ctch && _wcsicmp(szProcessName, pszApplicationName) == 0)
				{
                    *phProcess = hProcess;    // found it
                    dwProcId = adwProcess[i];
                    break;
				}
			}	
			CloseHandle(hProcess);
		}
	}
    return dwProcId;
}

// GetApplicationProcessInfo - Tries to find the process running for this application
BOOL GetApplicationProcessInfo(umclient_tsp tspClient, BOOL fCloseHandle)
{
    DWORD dwProcId;
	HANDLE hProcess;
	TCHAR ApplicationPath[MAX_PATH];
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szPath[_MAX_PATH];
	TCHAR szName[_MAX_FNAME+_MAX_EXT];
	TCHAR szExt[_MAX_EXT];

	if (GetClientApplicationPath(tspClient->machine.ApplicationName, ApplicationPath, MAX_PATH))
    {
        // ApplicationPath may include path information but we need just the base name

	    _wsplitpath(ApplicationPath, szDrive, szPath, szName, szExt);
        lstrcat(szName, szExt);

        dwProcId = FindProcess(szName, &hProcess);
        if (dwProcId)
        {
		    tspClient->processID[0] = dwProcId;
				    
		    // I do not know how to get main thread ID
		    tspClient->mainThreadID[0] = 0;
		    tspClient->runCount = 1;
		    tspClient->state = UM_CLIENT_RUNNING;
        
		    // In order to keep the HANDLE usable, we may have to keep it open.
		    // So, we do not close it here, but I consider it relatively safe,
		    // since we cannot execute this code more than once without
		    // terminating the process first (and thus closing the handle)

		    if (fCloseHandle)
		    {
			    CloseHandle(hProcess);
			    tspClient->hProcess[0] = NULL;
            } else
            {
		        tspClient->hProcess[0] = hProcess;
            }
            return TRUE;    // the application is running
	    }
    }

	return FALSE;           // the application is not running
}

// YX 06-15-99 [
// Code to finid the window by its Process ID

static BOOL SentClose;

BOOL CALLBACK FindWindowByID(HWND hWnd, LPARAM lParam)
{
	DWORD procID;
	
	if  (GetWindowThreadProcessId(hWnd, &procID) != 0) 
	{
		if (procID == (DWORD)lParam)
		{
			// The process, We are looking for 
			// Send a message to close this window
			// CAUTION: A SendMessage is Synchronous, So It will freeze UM if the
			// message doenot return so PostMessage is safer or a SendMessageTimeout()
			// PostMessage is sufficient....
			PostMessage(hWnd, WM_CLOSE, 0, 0);
			SentClose = TRUE;
		}
	}
	return TRUE;  
}


BOOL CloseAllWindowsByProcessID(DWORD procID)
{
	BOOL rc = FALSE;
	SentClose = FALSE;

	rc = EnumWindows(FindWindowByID, (LPARAM)procID);

	return SentClose;
}

// IsAdmin - Returns TRUE if our process has admin priviliges else FALSE
//
BOOL IsAdmin()
{
    BOOL fStatus = FALSE;
	BOOL fIsAdmin = FALSE;
    PSID AdministratorsSid = AdminSid(TRUE);

    if (AdministratorsSid)
    {
        fStatus = CheckTokenMembership(NULL, AdministratorsSid, &fIsAdmin);
    }
    
    return (fStatus && fIsAdmin);
}

// IsInteractiveUser - Returns TRUE if our process has an Interactive User SID
//
BOOL IsInteractiveUser()
{
    BOOL fStatus = FALSE;
	BOOL fIsInteractiveUser = FALSE;
    PSID psidInteractive = InteractiveUserSid(TRUE);

    if (psidInteractive) 
	{
        fStatus = CheckTokenMembership(NULL, psidInteractive, &fIsInteractiveUser);
    }

    return (fStatus && fIsInteractiveUser);
}

// IsSystem - Returns TRUE if our process is running as SYSTEM
//
BOOL IsSystem()
{
    BOOL fStatus = FALSE;
	BOOL fIsLocalSystem = FALSE;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
    PSID psidSystem = SystemSid(TRUE);

    if (psidSystem) 
	{
        fStatus = CheckTokenMembership(NULL, psidSystem, &fIsLocalSystem);
    }

    return (fStatus && fIsLocalSystem);
}

BOOL StartApplication(
    LPTSTR  pszPath,        // IN  path + filename of application to start
    LPTSTR  pszArg,         // IN  command line argument(s)
    BOOL    fIsTrusted,     // IN  TRUE if app can run on secure desktop
    DWORD   *pdwProcessId,  // OUT if not NULL, returned process Id
    HANDLE  *phProcess,     // OUT if not NULL, returned process handle (caller must close)
    DWORD   *pdwThreadId    // OUT if not NULL, returned thread Id
    )
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	desktop_ts desktop;
	BOOL fStarted;

	memset(&si,0,sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	memset(&pi,0,sizeof(PROCESS_INFORMATION));

	QueryCurrentDesktop(&desktop, TRUE);

    DBPRINTF(TEXT("StartApplication:  pszPath=%s pszArg=%s fIsTrusted=%d Utilman is SYSTEM=%d\r\n"), pszPath, pszArg, fIsTrusted, IsSystem());

    // If not on the winlogon desktop, first try starting the app as the interactive
    // user.  If that fails (eg. the case when OOBE runs after setup when there is
    // no interactive user) then, if its the winlogon desktop or utilman is running 
    // SYSTEM and the app is trusted then use CreateProcess (the app will be running
    // as SYSTEM).  The latter case (running SYSTEM and the app is trusted allows
    // applets to run when OOBE is running.

	fStarted = FALSE;

	if (desktop.type != DESKTOP_WINLOGON)
    {
		si.lpDesktop = desktop.name;
		fStarted = StartAppAsUser(pszPath, pszArg, &si,&pi);
    }

    if (!fStarted && (desktop.type == DESKTOP_WINLOGON || (IsSystem() && fIsTrusted)))
    {
		if (fIsTrusted)
		{
		    si.lpDesktop = 0;
            // Since we only run trusted apps we can run with default security descriptor
			fStarted = CreateProcess(pszPath, pszArg, NULL, NULL, FALSE, 
                                     CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &si, &pi);
            DBPRINTF(TEXT("StartApplication:  trusted CreateProcess(%s, %s) returns %d\r\n"), pszPath, pszArg, fStarted);
        }
    }

	if (fStarted)
	{
        if (pdwProcessId)
        {
            *pdwProcessId = pi.dwProcessId;
        }
        if (phProcess)
        {
            *phProcess = pi.hProcess;
        }
        else
        {
            CloseHandle(pi.hProcess);
        }
        if (pdwThreadId)
        {
            *pdwThreadId = pi.dwThreadId;
        }
        CloseHandle(pi.hThread);
	}

    return fStarted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\utilman.h ===
// ----------------------------------------------------------------------------
//
// UtilMan.h
//
// Header for Utility Manager
//
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//
// History: created oct-98 by JE
//          JE nov-15 98: added "ClientControlCode"
//			YX jun-01 99: added const for localized name subkey
// ----------------------------------------------------------------------------
#ifndef _UTILMAN_H_
#define _UTILMAN_H_

#include <stdlib.h>
// ------------------------------
#define UTILMAN_STARTCLIENT_ARG  _TEXT("/UM")
// ------------------------------
#define UTILMAN_DESKTOP_CHANGED_MESSAGE   _TEXT("UtilityManagerDesktopChanged")
// wParam:
 #define DESKTOP_ACCESSDENIED 0
 #define DESKTOP_DEFAULT      1
 #define DESKTOP_SCREENSAVER  2
 #define DESKTOP_WINLOGON     3
 #define DESKTOP_TESTDISPLAY  4
 #define DESKTOP_OTHER        5
// lParam: 0
// --------------------------------------------
// registry
#define UM_HKCU_REGISTRY_KEY _TEXT("Software\\Microsoft\\Utility Manager")
#define UM_REGISTRY_KEY _TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Accessibility\\Utility Manager")
#define MAX_APPLICATION_NAME_LEN 300
// --------------------------------------------
#define UMR_VALUE_DISPLAY _TEXT("Display name") // YX: Reg key to store localized names
#define UMR_VALUE_PATH _TEXT("Application path")
#define MAX_APPLICATION_PATH_LEN _MAX_PATH
 // REG_SZ
#define UMR_VALUE_TYPE _TEXT("Application type")
#define APPLICATION_TYPE_APPLICATION 1
#define APPLICATION_TYPE_SERVICE     2
 //MAX_APPLICATION_PATH_LEN
 // REG_SZ
 // optional (default: NULL)
#define UMR_VALUE_WRA  _TEXT("WontRespondAction")
 //MAX_APPLICATION_PATH_LEN
 // REG_SZ
 // optional (default: NULL)
#define UMR_VALUE_WRTO _TEXT("WontRespondTimeout")
 #define NO_WONTRESPONDTIMEOUT  0
 #define MAX_WONTRESPONDTIMEOUT 600
 // REG_DWORD
#define UMR_VALUE_MRC  _TEXT("MaxRunCount")
 #define MAX_APP_RUNCOUNT  255
 #define MAX_SERV_RUNCOUNT 1
  // 1 to MAX_xxx_RUNCOUNT (1 BYTE)
  // REG_BINARY 
  // optional (default = 1)
//          JE nov-15 98
#define UMR_VALUE_CCC  _TEXT("ClientControlCode")
 // REG_DWORD
 // for valid values see "UMS_Ctrl.h"
// --------------------------------------------
#define UMR_VALUE_STARTUM  _TEXT("Start with Utility Manager")
#define UMR_VALUE_STARTLOCK _TEXT("Start on locked desktop")
#define UMR_VALUE_SHOWWARNING _TEXT("ShowWarning")
 // BOOL
 // REG_DWORD
// CONSIDER cleaning up the "Start with Windows" key
#define UMR_VALUE_ATATLOGON _TEXT("Start at Logon")
 // BOOL
 // REG_DWORD
#endif //_UTILMAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\_umdlg.h ===
// ----------------------------------------------------------------------------
//
// _UMDlg.h
//
// Internal header for Utility Manager
//
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
// ----------------------------------------------------------------------------
#ifndef __UMDLG_H_
#define __UMDLG_H_
// ----------------------------------------
#define UMANDLG_DLL _TEXT("UManDlg.dll")
#define UMANDLG_VERSION                2
// ----------------------------------------
#define UMANDLG_FCT "UManDlg"
typedef BOOL (*umandlg_f)(BOOL fShow, BOOL fWaitForDlgClose, DWORD dwVersion);
#endif __UMDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\_umclnt.h ===
// ----------------------------------------------------------------------------
//
// _UMClnt.h
//
// Client definition for Utility Manager
//
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//
// History: created oct-98 by JE
//          JE nov-15-98: removed any code related to key hook
//          JE nov-15-98: changed UMDialog message to be a service control message
//          JE nov-15 98: changed "umc_machine_ts" to save memory
//          JE nov-15 98: changed "umc_machine_ts" to support launch specific client
//          JE nov-15 98: changed "umclient_ts" for multiple instances support
//			YX jun-01 99: added DisplayName member to the umc_machine_ts
//			YX jun-23 99: added IsAdmin function
// ----------------------------------------------------------------------------
#ifndef __UMCLNT_H_
#define __UMCLNT_H_
#include "UtilMan.h"
// ---------------------------------
// HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\Utility Manager\[Application Name]
// ---------------------------------
#define ACC_KEY_NONE -1
typedef struct
{
	WCHAR ApplicationName[MAX_APPLICATION_NAME_LEN];
	WCHAR DisplayName[MAX_APPLICATION_NAME_LEN]; // YX: added for localization purposes
	DWORD ApplicationType;//APPLICATION_TYPE_xxx
	DWORD WontRespondTimeout;//NO_WONTRESPONDTIMEOUT or up to MAX_WONTRESPONDTIMEOUT (sec)
	DWORD MaxRunCount;// instances (only a byte in registry)
	DWORD ClientControlCode;//JE nov-15 98
	WPARAM AcceleratorKey;	// micw - the accelerator key for this applet
} umc_machine_ts,*umc_machine_tsp;
// ---------------------------------
// HKCU\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\Utility Manager\[Application Name]
typedef struct
{
    BOOL fCanRunSecure;
	BOOL fStartWithUtilityManager;
	BOOL fStartAtLogon;
    BOOL fStartOnLockDesktop;
    BOOL fRestartOnDefaultDesk;
} umc_user_ts, *umc_user_tsp;
// ---------------------------------
// internal client struct (for each instance)
#define UM_CLIENT_NOT_RUNNING     0
#define UM_CLIENT_RUNNING         1
#define UM_CLIENT_NOT_RESPONDING  2
typedef struct
{
	umc_machine_ts machine;
	umc_user_ts    user;
	DWORD          runCount;// number of instance
	DWORD          state;
	DWORD          processID[MAX_APP_RUNCOUNT];
	HANDLE         hProcess[MAX_APP_RUNCOUNT];
	DWORD          mainThreadID[MAX_APP_RUNCOUNT];
	DWORD          lastResponseTime[MAX_APP_RUNCOUNT];
} umclient_ts, *umclient_tsp;
// ---------------------------------
// header structure
#define START_BY_OTHER  0x0
#define START_BY_HOTKEY 0x1
#define START_BY_MENU   0x2

#define MAX_NUMBER_OF_CLIENTS 16
typedef struct
{
	DWORD    numberOfClients;   // number of applets being managed
    DWORD    dwStartMode;       // one of START_BY_HOTKEY, START_BY_MENU, or START_BY_OTHER
    BOOL     fShowWarningAgain; // flag for showing warning dlg when started via Start menu
} umc_header_ts, *umc_header_tsp;
// ---------------------------------
// memory mapped files
#define UMC_HEADER_FILE _TEXT("UtilityManagerClientHeaderFile")
// sizeof(umc_header_ts)
#define UMC_CLIENT_FILE _TEXT("UtilityManagerClientDataFile")
// sizeof(umclient_ts) * (umc_header_tsp)->numberOfClients
// ---------------------------------
#ifdef __cplusplus
extern "C" {
#endif
	BOOL  StartClient(HWND hParent,umclient_tsp client);
	BOOL  StopClient(umclient_tsp client);
    BOOL  StartApplication(LPTSTR pszPath, LPTSTR pszArg, BOOL fIsTrusted, 
                           DWORD *pdwProcessId, HANDLE *phProcess, DWORD *pdwThreadId);
	BOOL  GetClientApplicationPath(LPTSTR ApplicationName, LPTSTR ApplicationPath,DWORD len);
    BOOL  CheckStatus(umclient_tsp c, DWORD cClients);
	BOOL  IsAdmin();
    BOOL  IsInteractiveUser();
    BOOL  IsSystem();
    HANDLE GetUserAccessToken(BOOL fNeedImpersonationToken, BOOL *fError);
    BOOL  TestServiceClientRuns(umclient_tsp client,SERVICE_STATUS  *ssStatus);

    // Helpers to start up the utilman instance that displays UI

    extern HANDLE g_hUIProcess;

    __inline void OpenUManDialogOutOfProc()
    {
	    TCHAR szUtilmanPath[_MAX_PATH+64] = {0};
	    if (GetModuleFileName(NULL, szUtilmanPath, _MAX_PATH+64))
	    {
			// This function is called (when there is an interactive user) to bring up
            // the utilman UI in the user's security context.  This avoids the problem
            // where a non-trusted application could send a message to utilman and cause
            // some process to start as SYSTEM.  In this context, utilman is not considered
			// trusted; it must start as the interactive user or not at all.
		    StartApplication(szUtilmanPath, TEXT("/start"), FALSE, NULL, &g_hUIProcess, NULL);
	    }
    }
    __inline HANDLE GetUIUtilman()
    {
        return g_hUIProcess;
    }
    __inline BOOL ResetUIUtilman()
    {
        // This process detected the switch and should quit on its own
        if (g_hUIProcess)
        {
			CloseHandle(g_hUIProcess);
			g_hUIProcess = 0;
            return TRUE;
        }
        return FALSE;
    }

    __inline void SetUIUtilman(HANDLE hProcess)
    {
        ResetUIUtilman();
        g_hUIProcess = hProcess;
    }

#ifdef __cplusplus
}
#endif
#endif __UMCLNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\_umrun.h ===
// ----------------------------------------------------------------------------
//
// _UMRun.h
//
// Run and watch Utility Manager clients
//
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//
// History: created oct-98 by JE
//          JE nov-15-98: changed UMDialog message to be a service control message
//          JE nov-15 98: changed to support launch specific client
// ----------------------------------------------------------------------------
#ifndef __UMANRUN_H_
#define __UMANRUN_H_

#define UTILMAN_MODULE      TEXT("UtilMan.exe")

// -----------------------
BOOL  InitUManRun(BOOL fFirstInstance, DWORD dwStartMode);
void  ExitUManRun(void);
BOOL IsDialogDisplayed();
// -----------------------
BOOL NotifyClientsBeforeDesktopChanged(DWORD dwType);
BOOL NotifyClientsOnDesktopChanged(DWORD type);
extern HANDLE g_evUtilManDeskswitch;
// -----------------------
VOID CALLBACK UMTimerProc(HWND hwnd,UINT uMsg,UINT_PTR idEvent,DWORD dwTime);
BOOL  OpenUManDialogInProc(BOOL fWaitForDlgClose);
UINT_PTR  UManRunSwitchDesktop(desktop_tsp desktop, UINT_PTR timerID);
// -----------------------
// UitlMan.c 
VOID TerminateUMService(VOID);

#endif __UMANRUN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\umandlg\umabout.cpp ===
// UMAbout.cpp : implementation file
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include "UManDlg.h"
#include "UMAbout.h"
#include "UtilMan.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HWND aboutWnd;
/////////////////////////////////////////////////////////////////////////////
// UMAbout dialog


UMAbout::UMAbout(CWnd* pParent /*=NULL*/)
	: CDialog(UMAbout::IDD, pParent)
{
	//{{AFX_DATA_INIT(UMAbout)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void UMAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(UMAbout)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(UMAbout, CDialog)
	//{{AFX_MSG_MAP(UMAbout)
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// UMAbout message handlers

BOOL UMAbout::OnInitDialog() 
{
	CDialog::OnInitDialog();
	aboutWnd = m_hWnd;	

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void UMAbout::OnClose() 
{
	CDialog::OnClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\umandlg\umabout.h ===
#if !defined(AFX_UMABOUT_H__6845734C_40A1_11D2_B602_0060977C295E__INCLUDED_)
#define AFX_UMABOUT_H__6845734C_40A1_11D2_B602_0060977C295E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// UMAbout.h : header file
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//

/////////////////////////////////////////////////////////////////////////////
// UMAbout dialog

class UMAbout : public CDialog
{
// Construction
public:
	UMAbout(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(UMAbout)
	enum { IDD = IDD_ABOUT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(UMAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(UMAbout)
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UMABOUT_H__6845734C_40A1_11D2_B602_0060977C295E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\_umtool.h ===
// ----------------------------------------------------------------------------
//
// _UMTool.h
//
// Header for Insight.lib
//
// Author: J. Eckhardt, ECO Kommunikation
//
// This code was written for ECO Kommunikation Insight
// (c) 1997-99 ECO Kommunikation
// ----------------------------------------------------------------------------
#ifndef __UMTOOL_H_
#define __UMTOOL_H_
// --------------------------------------------
// type definitions
typedef struct
{
	HANDLE  orgStation;
	HANDLE  userStation;
} desktop_access_ts, *desktop_access_tsp;
// ------------------------------
#define NAME_LEN 300
 #define USER_GUEST       0
 #define USER_USER        1
 #define USER_SUPERVISOR  2
 #define USER_DISTRIBUTOR 3
 #define USER_VENDOR      4
// YX 06-11-99 moved from utilman.c
#define STOP_UTILMAN_SERVICE_EVENT      _TEXT("StopUtilityManagerEvent")
typedef struct
{
	TCHAR userName[NAME_LEN];
	TCHAR name[NAME_LEN];
	DWORD type;
	DWORD user;
} desktop_ts, *desktop_tsp;
 #ifdef __cplusplus
  extern "C" {
 #endif
// --------------------------------------------
// macros
#include "w95trace.h"

// --------------------------------------------
// desktop prototypes
BOOL  InitDesktopAccess(desktop_access_tsp dAccess);
VOID  ExitDesktopAccess(desktop_access_tsp dAccess);
BOOL	QueryCurrentDesktop(desktop_tsp desktop,BOOL onlyType);
BOOL  SwitchToCurrentDesktop(void);
VOID	WaitDesktopChanged(desktop_tsp desktop);
// --------------------------------------------
// event prototypes
HANDLE BuildEvent(LPTSTR name,BOOL manualRest,BOOL initialState,BOOL inherit);
// --------------------------------------------
// memory mapped files
HANDLE CreateIndependentMemory(LPTSTR name, DWORD size, BOOL inherit);
LPVOID AccessIndependentMemory(LPTSTR name, DWORD size, DWORD dwDesiredAccess, PDWORD_PTR accessID);
void UnAccessIndependentMemory(LPVOID data, DWORD_PTR accessID);
void DeleteIndependentMemory(HANDLE id);
// --------------------------------------------
// security descriptor
typedef struct
{
	PSID psidUser;
	PSID psidGroup;
} obj_sec_descr_ts,*obj_sec_descr_tsp;
typedef struct
{
	obj_sec_descr_ts objsd;
	SECURITY_ATTRIBUTES sa;
} obj_sec_attr_ts, *obj_sec_attr_tsp;
void InitSecurityAttributes(obj_sec_attr_tsp psa);
void InitSecurityAttributesEx(obj_sec_attr_tsp psa, DWORD dwAccessMaskOwner, DWORD dwAccessMaskWorld);
void ClearSecurityAttributes(obj_sec_attr_tsp psa);
PSID EveryoneSid(BOOL fFetch);
PSID AdminSid(BOOL fFetch);
PSID InteractiveUserSid(BOOL fFetch);
PSID SystemSid(BOOL fFetch);
void InitWellknownSids();
void UninitWellknownSids();
 #ifdef __cplusplus
  }
 #endif
#endif //__UMTOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\umandlg\umandlg.h ===
// UMDlg.h : main header file for the UMDLG DLL
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//

#if !defined(AFX_UMDLG_H__6845733C_40A1_11D2_B602_0060977C295E__INCLUDED_)
#define AFX_UMDLG_H__6845733C_40A1_11D2_B602_0060977C295E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CUMDlgApp
// See UMDlg.cpp for the implementation of this class
//

class CUMDlgApp : public CWinApp
{
public:
	CUMDlgApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUMDlgApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CUMDlgApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UMDLG_H__6845733C_40A1_11D2_B602_0060977C295E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\umandlg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UManDlg.rc
//
#define IDS_ABOUT_STRING                1
#define IDS_NAME                        2
#define IDS_STATUS                      3
#define IDS_NOT_RUNNING                 4
#define IDS_RUNNING                     5
#define IDS_NOT_RESPONDING              6
#define IDS_OPTIONS                     7
#define IDS_ERRSTART                    9
#define IDS_UM                          10
#define IDS_ERRSTOP                     11
#define IDS_SECUREMODE                  13
#define IDD_UMAN                        101
#define IDI_UM                          102
#define IDD_ABOUT                       103
#define IDI_CLIENT1                     103
#define IDI_CLIENT2                     104
#define IDI_CLIENT3                     105
#define IDI_CLIENT4                     106
#define IDI_CLIENT5                     107
#define IDI_CLIENT6                     108
#define IDI_CLIENT7                     109
#define IDI_CLIENT8                     110
#define IDI_CLIENT9                     111
#define IDD_WARNING                     131
#define IDC_NAME_STATUS                 1000
#define IDC_START                       1001
#define IDC_STOP                        1002
#define IDC_START_AT_LOGON              1003
#define IDC_START_WITH_UM               1004
#define IDC_VERSION                     1007
#define IDC_OPTIONS                     1008
#define IDC_START_ON_LOCK               1009
#define IDC_CHK_WARN                    1010
#define IDS_DISPLAY_NAME_NARRATOR       502
#define IDS_DISPLAY_NAME_MAGNIFIER      503
#define IDS_DISPLAY_NAME_OSK			504

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\umandlg\version.h ===
// NARRATOR.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "UManDlg DLL"
#define VER_INTERNALNAME_STR        "UManDlg"
#define VER_ORIGINALFILENAME_STR    "UManDlg.dll"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\umandlg\umdialog.h ===
#if !defined(AFX_UMDIALOG_H__68457343_40A1_11D2_B602_0060977C295E__INCLUDED_)
#define AFX_UMDIALOG_H__68457343_40A1_11D2_B602_0060977C295E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// UMDialog.h : header file
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//

/////////////////////////////////////////////////////////////////////////////
// UMDialog dialog

class UMDialog : public CDialog
{
// Construction
public:
	UMDialog(CWnd* pParent = NULL);   // standard constructor
	~UMDialog();	// my destructor

// Dialog Data
	//{{AFX_DATA(UMDialog)
	enum { IDD = IDD_UMAN };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(UMDialog)
	public:
	virtual void OnSysCommand(UINT nID,LPARAM lParam);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(UMDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
	afx_msg void OnStart();
	afx_msg void OnStop();
	virtual void OnOK();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnHelp();
	afx_msg void OnSelchangeNameStatus();
	afx_msg void OnStartAtLogon();
	afx_msg void OnStartWithUm();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnStartOnLock();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	inline BOOL GetSelectedClient(int cClients, int &iSel)
	{
		iSel = m_lbClientList.GetCurSel();
		return (iSel < cClients && iSel != -1)?TRUE:FALSE;
	}
	void SetStateStr(int iClient);
	void ListClients();
	void UpdateClientState(int iSel);
	void EnableDlgItem(DWORD dwEnableMe, BOOL fEnable, DWORD dwFocusHere);
	void SaveCurrentState();

	CString  m_szStateStr;
	CString  m_szUMStr;
	CListBox m_lbClientList;
	BOOL     m_fRunningSecure; // TRUE if dialog shouldn't expose help or links
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

/////////////////////////////////////////////////////////////////////////////
// CWarningDlg dialog

class CWarningDlg : public CDialog
{
// Construction
public:
	CWarningDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWarningDlg)
	enum { IDD = IDD_WARNING };
	BOOL	m_fDontWarnAgain;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWarningDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWarningDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UMDIALOG_H__68457343_40A1_11D2_B602_0060977C295E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\umandlg\umandlg.cpp ===
// UMDlg.cpp : Defines the initialization routines for the DLL.
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include "UManDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CUMDlgApp

BEGIN_MESSAGE_MAP(CUMDlgApp, CWinApp)
	//{{AFX_MSG_MAP(CUMDlgApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	ON_COMMAND( ID_HELP, OnHelp ) 

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUMDlgApp construction

CUMDlgApp::CUMDlgApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CUMDlgApp object

CUMDlgApp theApp;

/*BOOL WINAPI DllMain(HINSTANCE hinst, DWORD fdwReason, LPVOID pvReserved)
{
    // Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\umandlg\umdialog.cpp ===
// UMDialog.cpp : implementation file
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
//
// History:
//		Changes 
//      Yuri Khramov
//      01-jun-99: DisplayName key used in the Dialog (Localization)
//		11-jun-99: DlgHasClosed code changed to work with app closure
//		15-jun-99: Timer delay increased 1000ms
//
//		Bug fixes and Changes Anil Kumar 1999
//---------------------------------------------------------------------
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include "UManDlg.h"
#include "UMDialog.h"
#include "UMAbout.h"
#include "_UMDlg.h"
#include "_UMClnt.h"
#include "_UMTool.h"
#include "UMS_Ctrl.h"
#include "w95trace.h"
#include <WinSvc.h>
#include <htmlhelp.h>
#include <initguid.h>
#include <ole2.h>
#include "deskswitch.c"
#include "ManageShellLinks.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// --------------------------------------------
// constants
#define IDC_ABOUT 10
#define UPDATE_CLIENT_LIST_TIMER 1
// --------------------------------------------
// variables
static DWORD g_cClients = 0;
static umclient_tsp g_rgClients = NULL;
static DWORD s_dwStartMode = START_BY_OTHER;
static BOOL s_fShowWarningAgain = TRUE;
extern CUMDlgApp theApp;
// --------------------------------------------
// C prototypes
static BOOL InitClientData(void);
static BOOL StartClientsOnShow();
static BOOL WriteClientData(BOOL fRunningSecure);
static BOOL IsStartAuto();
static BOOL CantStopClient(umclient_tsp client);
static int GetClientNameFromAccelerator(WPARAM wVK);

extern "C" BOOL StartAppAsUser( LPCTSTR appPath,
					 LPTSTR cmdLine,
					 LPSTARTUPINFO lpStartupInfo,
					 LPPROCESS_INFORMATION lpProcessInformation);


// Help ID's for context sensitive help
DWORD g_rgHelpIds[] = {	
	IDC_NAME_STATUS, 3,
	IDC_START, 1001,
	IDC_STOP, 1002,
	IDC_START_AT_LOGON, 1003,	// TODO UE needs to update CS help
	IDC_START_WITH_UM, 1004,
    IDC_START_ON_LOCK, 1005,    // TODO UE needs to add to CS help
	IDOK, 1100,
	IDCANCEL, 1200,
	ID_HELP, 1300,
};

// ---------------------------------------------------------------
extern "C"{
//--------------------------------
HWND g_hWndDlg = NULL;
HWND aboutWnd = NULL;
static HANDLE s_hDlgThread = NULL;

static HDESK s_hdeskSave = 0;
static HDESK s_hdeskInput = 0;

// UnassignDesktop gets called after the thread has exited to
// close desktop handles opened in AssignDesktop.
inline void UnassignDesktop()
{
    if (s_hdeskInput)
	{
        CloseDesktop(s_hdeskInput); 
        s_hdeskInput = 0;
	}
}

BOOL AssignDesktop(DWORD dwThreadId)
{
    s_hdeskSave = GetThreadDesktop(dwThreadId);
    s_hdeskInput = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!s_hdeskInput)
    {
        s_hdeskInput = OpenDesktop(_TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
    }
    
    if (s_hdeskInput)
    {
        BOOL fSet = SetThreadDesktop(s_hdeskInput);
    }
    return (s_hdeskInput)?TRUE:FALSE;
}

//--------------------------------
DWORD UManDlgThread(LPVOID /* UNUSED */ in)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	UMDialog dlg;

    // assign thread to the input desktop (have to do
    // this here so it works on the winlogon desktop)

    if (AssignDesktop(GetCurrentThreadId()))
    {
        // initialize COM *after* assign to input desktop
        // because CoInitialize creates a hidden window on
        // the current desktop.

        CoInitialize(NULL);
        InitCommonControls();

        if (InitClientData())
        {
            Sleep(10);
            dlg.DoModal();
            if (g_rgClients)
            {
                VirtualFree(g_rgClients,0,MEM_RELEASE);
                g_rgClients = NULL;
            }
            g_cClients = 0;
            g_hWndDlg = NULL;	
            s_hDlgThread = NULL;
        }

        CoUninitialize();   // uninitialize COM
    }

	return 1;
}

void StopDialog()
{
    if (aboutWnd)
    {
        EndDialog(aboutWnd,0);
        aboutWnd = NULL;
        Sleep(10);
    }
    if (g_hWndDlg)
    {
        ::PostMessage(g_hWndDlg, WM_CLOSE, 0, 0);
        g_hWndDlg = NULL;
        Sleep(10);
        UnassignDesktop();
    }
    if (g_rgClients)
    {
        VirtualFree(g_rgClients,0,MEM_RELEASE);
        g_rgClients = NULL;
    }
    g_cClients = 0;
}

//--------------------------------
#if defined(_X86_)
__declspec (dllexport)
#endif
// UManDlg - Opens or closes the utilman dialog.
//
// fShowDlg         - TRUE if dialog should be shown, FALSE if dialog should be closed
// fWaitForDlgClose - TRUE if the function should not return until the dialog
//                    is closed or a desktop switch happens else FALSE.
// dwVersion        - The utilman version
//
// returns TRUE if the dialog was opened or closed
// returns FALSE if the dialog could not be opened or it wasn't open
//
BOOL UManDlg(BOOL fShowDlg, BOOL fWaitForDlgClose, DWORD dwVersion)
{
	BOOL fRv = FALSE;
	if (dwVersion != UMANDLG_VERSION)
		return FALSE;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (fShowDlg)
	{
		if (!s_hDlgThread)
		{
			s_hDlgThread = CreateThread(NULL, 0, UManDlgThread, NULL, 0, NULL);
		} 
		else
		{
			SetForegroundWindow((aboutWnd)?aboutWnd:g_hWndDlg);
		}

		if (s_hDlgThread && fWaitForDlgClose)
        {
            // This code is executed on the default desktop for the following cases:
            //
            // 1. Utilman #1 run from the start menu
            // 2. Utilman #2 run from the start menu (utilman #1 is SYSTEM)
            // 3. Utilman #2 run by utilman #1 in user's context
            //
            // Wait for either the dialog to close or a desktop switch then return.
            // This will end this instance of utilman.  If there is a utilman
            // running as SYSTEM it will bring up the dialog on the other desktop.

            HANDLE rghEvents[2];

            rghEvents[0] = s_hDlgThread;
	        rghEvents[1] = OpenEvent(SYNCHRONIZE, FALSE, __TEXT("WinSta0_DesktopSwitch"));

	        while (TRUE)
            {
                DWORD dwObj = MsgWaitForMultipleObjects(2, rghEvents, FALSE, INFINITE, QS_ALLINPUT );
        
                switch (dwObj)
                {
                    case WAIT_OBJECT_0 + 1:    // the desktop is changing; close the dialog
                        StopDialog();
                        // intentional fall thru to cleanup code

                    case WAIT_OBJECT_0:        // the thread exited; clean up and return
                        CloseHandle(s_hDlgThread);
                        s_hDlgThread = 0;
                        CloseHandle(rghEvents[1]);
                        return TRUE;
                        break;

                    default:                 // process messages
                        {
                            MSG msg;
		                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                        break;
                }
            } 
        }
	}
	else
	{
        // This code is executed when utilman is running on the secure desktop.  In
        // that case, utilman brings up the dialog as a thread from its process. 
        // When the desktop switch is detected utilman calls this function to close 
        // the dialog.  It will be restarted again on the new desktop. 

		fRv = (g_hWndDlg && s_hDlgThread);

        StopDialog();
	}
	return fRv;
}

BOOL IsDialogUp()
{
    return (g_hWndDlg && s_hDlgThread)?TRUE:FALSE;
}

}//extern "C"


/////////////////////////////////////////////////////////////////////////////
// CWarningDlg dialog


CWarningDlg::CWarningDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWarningDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWarningDlg)
	m_fDontWarnAgain = TRUE;
	//}}AFX_DATA_INIT
}


void CWarningDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWarningDlg)
	DDX_Check(pDX, IDC_CHK_WARN, m_fDontWarnAgain);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWarningDlg, CDialog)
	//{{AFX_MSG_MAP(CWarningDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWarningDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// UMDialog dialog
// --------------------------------------------
UMDialog::UMDialog(CWnd* pParent /*=NULL*/)
	: CDialog(UMDialog::IDD, pParent)
	, m_fRunningSecure(FALSE)
{
	m_szUMStr.LoadString(IDS_UM);

	//{{AFX_DATA_INIT(UMDialog)
	// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

UMDialog::~UMDialog()
{
	m_lbClientList.Detach();
}
// --------------------------------------------
void UMDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(UMDialog)
	// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}
// --------------------------------------------
BEGIN_MESSAGE_MAP(UMDialog, CDialog)
//{{AFX_MSG_MAP(UMDialog)
	ON_WM_CLOSE()
	ON_BN_CLICKED(IDC_START, OnStart)
	ON_BN_CLICKED(IDC_STOP, OnStop)
	ON_WM_TIMER()
	ON_WM_HELPINFO()
	ON_COMMAND( ID_HELP, OnHelp )
	ON_LBN_SELCHANGE(IDC_NAME_STATUS, OnSelchangeNameStatus)
	ON_BN_CLICKED(IDC_START_AT_LOGON, OnStartAtLogon)
	ON_BN_CLICKED(IDC_START_WITH_UM, OnStartWithUm)
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_SYSCOMMAND,OnSysCommand)
	ON_BN_CLICKED(IDC_START_ON_LOCK, OnStartOnLock)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// UMDialog message handlers

BOOL UMDialog::PreTranslateMessage(MSG* pMsg) 
{
	// Override that allows use of function keys to launch applets when on
	// the logon desktop.  Only pay attention to key up to avoid dup calls.

	if (m_fRunningSecure && WM_KEYUP == pMsg->message) 
	{
		int iClient = GetClientNameFromAccelerator(pMsg->wParam);
		if (iClient >= 0)
		{
			m_lbClientList.SelectString(-1, g_rgClients[iClient].machine.DisplayName);
			OnStart();
			return TRUE;
		}
	}
	
	return CDialog::PreTranslateMessage(pMsg);
}

BOOL UMDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	// set the flag indicating if we are running in secure mode

	desktop_ts desktop;	
	QueryCurrentDesktop(&desktop, TRUE);
	m_fRunningSecure = RunSecure(desktop.type);

    if (s_fShowWarningAgain && s_dwStartMode == START_BY_MENU)
    {
        CWarningDlg dlgWarn;
        dlgWarn.m_fDontWarnAgain = !s_fShowWarningAgain;
        dlgWarn.DoModal();
        s_fShowWarningAgain = !dlgWarn.m_fDontWarnAgain;
    }

	g_hWndDlg = m_hWnd;	

	// change system menu

	CMenu *hSysMenu = GetSystemMenu(FALSE);
	if (hSysMenu)
	{
		CString str;
		hSysMenu->AppendMenu(MF_SEPARATOR);
		str.LoadString(IDS_ABOUT_STRING);
		hSysMenu->AppendMenu(MF_STRING,IDC_ABOUT,LPCTSTR(str));
	}

    // handle any "start when utility manager starts" applets

    StartClientsOnShow();

	// attach ListBox to member data and populate w/list of applications

	m_lbClientList.Attach(GetDlgItem(IDC_NAME_STATUS)->m_hWnd);
	ListClients();

	// Disable Help button if we are at WinLogon because the help 
	// dialog supports "Jump to URL..." exposing security risk.
	// The m_fRunningSecure variable is TRUE if UI shouldn't expose help.

	if (m_fRunningSecure)
	{
		EnableDlgItem(ID_HELP, FALSE, IDOK); 
	}

    // Disable "Start when UtilMan starts" unless user is an admin
    // and we are running in non-secure mode.

    if (s_dwStartMode != START_BY_MENU)
    {
        GetDlgItem(IDC_START_WITH_UM)->EnableWindow(IsAdmin() && !m_fRunningSecure);
    }

	// Bring dialog to top and center on desktop window

	RECT rectUmanDlg,rectDesktop;
	GetDesktopWindow()->GetWindowRect(&rectDesktop);
	GetWindowRect(&rectUmanDlg);

	long lDlgWidth = rectUmanDlg.right - rectUmanDlg.left;
	long lDlgHieght = rectUmanDlg.bottom - rectUmanDlg.top;
	if (!m_fRunningSecure)
	{
		rectUmanDlg.left = (rectDesktop.right - lDlgWidth)/2;
		rectUmanDlg.top = (rectDesktop.bottom - lDlgHieght)/2;
	} else
	{
		rectUmanDlg.left = rectDesktop.left + (long)(lDlgWidth/10);
		rectUmanDlg.top = rectDesktop.bottom - lDlgHieght - (long)(lDlgHieght/10);
	}

    // This looks a bit odd (SetForegroundWindow should also be activating 
    // the window) but if you don't call SetActiveWindow on the secure
    // desktop then the second, etc... WinKey+U will bring up UM hidden
    // behind the welcome "screen".

    SetActiveWindow();
    SetForegroundWindow();
	SetWindowPos(&wndTopMost,rectUmanDlg.left,rectUmanDlg.top,0,0,SWP_NOSIZE);
    
	if (!m_fRunningSecure)
    {
        // on default desktop the above SetWindowPos makes the dialog initially
        // on top and this call allows other apps to then be on top.
	    SetWindowPos(&wndNoTopMost,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE);
    }

    // start checking every so often to see if we need to update our display

	SetTimer(UPDATE_CLIENT_LIST_TIMER, 3000, NULL);

	return TRUE;  // return TRUE unless you set the focus to a control
}

// -----------------------------------------------------
void UMDialog::OnSysCommand(UINT nID,LPARAM lParam)
{
	if (nID == IDC_ABOUT)
	{
		UMAbout dlg;
		dlg.DoModal();
		aboutWnd = NULL;	
	}
	else
	{
		CDialog::OnSysCommand(nID,lParam);
	}
}//UMDialog::OnSysCommand
// ------------------------------------

// --------------------------------------------
// CanStartOnLockedDesktop - returns TRUE if applets can 
// be configured to be auto-started on the secure desktop
//
inline BOOL CanStartOnLockedDesktop(int iWhichClient, BOOL fRunningSecure)
{
    // user can ask for auto start on secure desktop if they are logged on, the
    // applet is OK'd to run on the secure desktop and the machine isn't using
    // fast user switching (FUS) (w/FUS Ctrl+Alt+Del disconnects the user session
    // rather than switching desktops).

    BOOL fCanStartOnLockedDesktop = 
        (
            !fRunningSecure && 
            g_rgClients[iWhichClient].user.fCanRunSecure &&
            CanLockDesktopWithoutDisconnect()
        )?TRUE:FALSE;

    return fCanStartOnLockedDesktop;
}

// --------------------------------------------
// OnSelchangeNameStatus is called when the user navigates the list
// box items by clicking with the mouse or using up/down arrows.
//
void UMDialog::OnSelchangeNameStatus() 
{
	// Get the currently selected item and update the controls for
	// the currently selected item.

	int iSel;
	if (GetSelectedClient((int)g_cClients, iSel))
	{
		// Group box label
		CString str(g_rgClients[iSel].machine.DisplayName);
		CString optStr;
		optStr.Format(IDS_OPTIONS, str);
		GetDlgItem(IDC_OPTIONS)->SetWindowText(optStr);

        // only enable options when started via WinKey+U 

        if (s_dwStartMode != START_BY_MENU)
        {
            // Disable "start at logon" at secure desktop to avoid mischief

            if (!m_fRunningSecure)
            {
                GetDlgItem(IDC_START_AT_LOGON)->EnableWindow(TRUE);
            } else
            {
                // this may be set in an upgrade situation; clear it
                g_rgClients[iSel].user.fStartAtLogon = FALSE;
                GetDlgItem(IDC_START_AT_LOGON)->EnableWindow(FALSE);
            }

            // Enable "start on locked desktop" if at default desktop and
            // when applet can run on secure desktop

            if (CanStartOnLockedDesktop(iSel, m_fRunningSecure))
            {
                GetDlgItem(IDC_START_ON_LOCK)->EnableWindow(TRUE);
            } else
            {
                // this may be set in an upgrade situation; clear it
                g_rgClients[iSel].user.fStartOnLockDesktop = FALSE;
                GetDlgItem(IDC_START_ON_LOCK)->EnableWindow(FALSE);
            }
		    
		    // Start option checkboxes

		    CheckDlgButton(IDC_START_AT_LOGON, (g_rgClients[iSel].user.fStartAtLogon)?TRUE:FALSE);
            CheckDlgButton(IDC_START_ON_LOCK, (g_rgClients[iSel].user.fStartOnLockDesktop)?TRUE:FALSE);
		    CheckDlgButton(IDC_START_WITH_UM, (g_rgClients[iSel].user.fStartWithUtilityManager)?TRUE:FALSE);
        } else
        {
            GetDlgItem(IDC_START_AT_LOGON)->EnableWindow(FALSE);
            GetDlgItem(IDC_START_ON_LOCK)->EnableWindow(FALSE);
            GetDlgItem(IDC_START_WITH_UM)->EnableWindow(FALSE);
		    CheckDlgButton(IDC_START_AT_LOGON, FALSE);
            CheckDlgButton(IDC_START_ON_LOCK, FALSE);
		    CheckDlgButton(IDC_START_WITH_UM, FALSE);
        }

		// Start and stop buttons
		DWORD dwState = g_rgClients[iSel].state;

		if ((dwState == UM_CLIENT_RUNNING) 
			&& (g_rgClients[iSel].runCount >= g_rgClients[iSel].machine.MaxRunCount))
			EnableDlgItem(IDC_START, FALSE, IDC_NAME_STATUS);
		else
			EnableDlgItem(IDC_START, TRUE, IDC_NAME_STATUS);

		if ((dwState == UM_CLIENT_NOT_RUNNING) || CantStopClient(&g_rgClients[iSel]))
			EnableDlgItem(IDC_STOP, FALSE, IDC_NAME_STATUS);
		else
			EnableDlgItem(IDC_STOP, TRUE, IDC_NAME_STATUS);

	}// else ignore selections not in a valid range
}

// --------------------------------------------
void UMDialog::OnClose()
{
	// behave like cancel
	CDialog::OnClose();
}//UMDialog::OnClose

// --------------------------------------------
// OnStart is called when the Start button is clicked.  It starts
// the client ap then lets the timer update saved state.
//
void UMDialog::OnStart()
{
    int iSel;
    if (GetSelectedClient((int)g_cClients, iSel))
    {
        if (StartClient(m_hWnd, &g_rgClients[iSel]))
        {
            KillTimer(UPDATE_CLIENT_LIST_TIMER);
            EnableDlgItem(IDC_STOP, TRUE, IDC_NAME_STATUS);
			ListClients();
            SetTimer(UPDATE_CLIENT_LIST_TIMER, 3000, NULL);
            
            if (g_rgClients[iSel].runCount+1 >= g_rgClients[iSel].machine.MaxRunCount)
                EnableDlgItem(IDC_START, FALSE, IDC_STOP);
        }
        else if (g_rgClients[iSel].runCount < g_rgClients[iSel].machine.MaxRunCount)
        {
            // Unable to start
            CString str;	
            str.LoadString((m_fRunningSecure)?IDS_SECUREMODE:IDS_ERRSTART);
            MessageBox(str, m_szUMStr, MB_OK);	
        }
    }
}

// --------------------------------------------
// OnStop is called when the Stop button is clicked.  It stops
// the client ap then lets the timer update saved state.
//
void UMDialog::OnStop()
{
	int iSel;
	if (GetSelectedClient((int)g_cClients, iSel))
	{
		if (StopClient(&g_rgClients[iSel]))
		{
            KillTimer(UPDATE_CLIENT_LIST_TIMER);
            GetDlgItem(IDC_START)->EnableWindow(TRUE);
			ListClients();
			EnableDlgItem(IDC_STOP, FALSE, IDOK);
            SetTimer(UPDATE_CLIENT_LIST_TIMER, 3000, NULL);
		}
		else
		{
			// Unable to stop
			CString str;
			str.LoadString(IDS_ERRSTOP);
			MessageBox(str, m_szUMStr, MB_OK);	
		}
	}
}

void UMDialog::SaveCurrentState()
{
	int iSel;
	if (GetSelectedClient((int)g_cClients, iSel))
	{
		g_rgClients[iSel].user.fStartAtLogon
			= (IsDlgButtonChecked(IDC_START_AT_LOGON))?TRUE:FALSE;
		g_rgClients[iSel].user.fStartWithUtilityManager
			= (IsDlgButtonChecked(IDC_START_WITH_UM))?TRUE:FALSE;
        g_rgClients[iSel].user.fStartOnLockDesktop
            = (IsDlgButtonChecked(IDC_START_ON_LOCK))?TRUE:FALSE;
	}
}

// --------------------------------------------
// OnOK is called when the user clicks the OK button to
// dismiss the UtilMan dialog.
//
void UMDialog::OnOK()
{
	SaveCurrentState();

	WriteClientData(m_fRunningSecure);

	CDialog::OnOK();
}//UMDialog::OnOK

// ----------------------------------------------------------------------------
// OnTimer is called to check the status of client apps that are displayed
// in the UI.  This keeps the UI consistent with the running client app's.
//
void UMDialog::OnTimer(UINT nIDEvent)
{
	if (nIDEvent == UPDATE_CLIENT_LIST_TIMER)
	{
		UINT uiElapsed = 3000; 
		KillTimer(UPDATE_CLIENT_LIST_TIMER);

        // get current status and pick up new apps
		if (CheckStatus(g_rgClients, g_cClients))
        {
		    ListClients();          // something has changed - update the UI
			uiElapsed = 500;
        }

		SetTimer(UPDATE_CLIENT_LIST_TIMER, uiElapsed, NULL);
	}
	CDialog::OnTimer(nIDEvent);
}

// --------------------------------------------
// OnHelpInfo provides context sensitive help.  It only does
// this if not on the WinLogon desktop.
//
BOOL UMDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
	if (m_fRunningSecure)	
		return FALSE;

	if ( pHelpInfo->iCtrlId == IDC_OPTIONS )
		return TRUE;

	::WinHelp((HWND)pHelpInfo->hItemHandle, __TEXT("utilmgr.hlp"), HELP_WM_HELP,
				(DWORD_PTR) (LPSTR) g_rgHelpIds);

	return TRUE;
}

// --------------------------------------------
// OnHelpInfo provides context sensitive help when the user
// right-clicks the dialog.  It only does this if not on the 
// WinLogon desktop.
//
void UMDialog::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	if (m_fRunningSecure)	
		return;

	::WinHelp(pWnd->m_hWnd, __TEXT("utilmgr.hlp"), HELP_CONTEXTMENU
		, (DWORD_PTR) (LPSTR) g_rgHelpIds);
}

// --------------------------------------------
// OnHelp provides standard help.  It only does this if not
// on the WinLogon desktop.
//
void UMDialog::OnHelp()
{
    if (m_fRunningSecure)	
        return;
    
    ::HtmlHelp(m_hWnd , TEXT("utilmgr.chm"), HH_DISPLAY_TOPIC, 0);
}

// ----------------------------------
void UMDialog::EnableDlgItem(DWORD dwEnableMe, BOOL fEnable, DWORD dwFocusHere)
{
	// when disabling a control that currently has focs switch it to dwFocusHere
	if (!fEnable && (GetFocus() == GetDlgItem(dwEnableMe)))
        GetDlgItem(dwFocusHere)->SetFocus();

    GetDlgItem(dwEnableMe)->EnableWindow(fEnable);
}

void UMDialog::SetStateStr(int iClient)
{
	switch (g_rgClients[iClient].state)
	{
		case UM_CLIENT_NOT_RUNNING:
		m_szStateStr.Format(IDS_NOT_RUNNING, g_rgClients[iClient].machine.DisplayName);
		break;

		case UM_CLIENT_RUNNING:
		m_szStateStr.Format(IDS_RUNNING, g_rgClients[iClient].machine.DisplayName);
		break;

		case UM_CLIENT_NOT_RESPONDING:
		m_szStateStr.Format(IDS_NOT_RESPONDING, g_rgClients[iClient].machine.DisplayName);
		break;

		default:
		m_szStateStr.Empty();
		break;
	}
}

// --------------------------------------------
void UMDialog::ListClients()
{
	// Re-do the client list box with latest state info

    int iCurSel = m_lbClientList.GetCurSel();
    if (iCurSel == LB_ERR)
        iCurSel = 0;

	m_lbClientList.ResetContent();
	
	for (DWORD i = 0; i < g_cClients; i++)
	{
		SetStateStr(i);

		if (!m_szStateStr.IsEmpty())
        {
            m_lbClientList.AddString(m_szStateStr);
        }
	}
	m_lbClientList.SetCurSel(iCurSel);

	// Refresh button states in case they've changed 
	// (this happens on desktop switch)

	OnSelchangeNameStatus();
}

// --------------------------------------------
// UpdateClientState updates the client list box with the current state
// of the application (running, not running, not responding)
//
void UMDialog::UpdateClientState(int iSel)
{
	SetStateStr(iSel);
	m_lbClientList.DeleteString(iSel);
	m_lbClientList.InsertString(iSel, m_szStateStr);
	m_lbClientList.SetCurSel(iSel);

}

// --------------------------------------------
// OnStartAtLogon updates the state of the client in memory when the
// Start with Windows checkbox is checked or unchecked.
//
void UMDialog::OnStartAtLogon() 
{
	SaveCurrentState();
}

// --------------------------------------------
// OnStartWithUm updates the state of the client in memory when the
// Start with Utility Manager checkbox is checked or unchecked.
//
void UMDialog::OnStartWithUm() 
{
	SaveCurrentState();
}

// --------------------------------------------
// OnStartOnLock updates the state of the client in memory when the
// Start when I lock my desktop checkbox is checked or unchecked.
//
void UMDialog::OnStartOnLock() 
{
	SaveCurrentState();
}

// --------------------------------------------
// OnShowWindow 
// This was added for a timing problem where utilman came up running in the system context on the users desktop
// this code here makes sure that that cannot happen by cheching right when the dialog is about to appear
//
void UMDialog::OnShowWindow(BOOL bShow, UINT nStatus) 
{
    HDESK hdesk;
    SID *desktopSID = NULL;
    
	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
	// this is expected to fail for the winlogon desktop and thats ok
	if (hdesk)     
	{
        TCHAR desktopName[NAME_LEN];
        DWORD nl, SIDLen = 0;
        
    	if (!GetUserObjectInformation(hdesk, UOI_NAME, desktopName, NAME_LEN, &nl))
    	    goto StopDialog;

    	if (!GetUserObjectInformation(hdesk, UOI_USER_SID, desktopSID, 0, &SIDLen))
    	{
        	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        	    goto StopDialog;
    	}
    	
    	if (SIDLen > 0 && !lstrcmpi(desktopName, TEXT("Default")))
    	{
    	    desktopSID = (SID*)new BYTE[SIDLen];
    	    if (!desktopSID)
    	        goto StopDialog;
    	    
        	if (!GetUserObjectInformation(hdesk, UOI_USER_SID, desktopSID, SIDLen, &SIDLen))
        	    goto StopDialog;

        	BOOL fError;
            HANDLE hUserToken = GetUserAccessToken(TRUE, &fError);
            if (fError)
                goto StopDialog;
            
            // We get a token only if there is a logged on user.  
            // If there is not then we can come up as system with no worries.
            if (!hUserToken)
                goto LetDialogComeup;

            BOOL fStatus = FALSE;
        	BOOL fIsInteractiveUser = FALSE;
            PSID psidInteractive = InteractiveUserSid(TRUE);

            if (!psidInteractive)
                goto StopDialog;

            fStatus = CheckTokenMembership(hUserToken, psidInteractive, &fIsInteractiveUser);

            //If the logged on user is the interactive user and we are running as system then it is a
            // security risk to show UI.  This can happen when rappidly switching desktops.
            if ( fStatus && fIsInteractiveUser && IsSystem()) 
                goto StopDialog;
            
        }
    	
	}

    LetDialogComeup:
        if (desktopSID)
            delete [] desktopSID;
        return;
    
	StopDialog:
        StopDialog();
        if (desktopSID)
            delete [] desktopSID;

}

/////////////////////////////////////////////////////////////////////////////
// C code
//-----------------------------------------------------------------

__inline void ReplaceDisplayName(LPTSTR szName, int iRID)
{
	TCHAR szBuf[MAX_APPLICATION_NAME_LEN];
	if (LoadString(AfxGetInstanceHandle(), iRID, szBuf, MAX_APPLICATION_NAME_LEN))
		lstrcpy(szName, szBuf);
}

void SetLocalizedDisplayName()
{
	// Make localization easier; don't require them to localize registry entries.
    // Instead, replace our copy with the localized version.  This appears to be
    // duplicate code to that in umanrun.c however, that part of the code always
    // runs as system and therefore the DisplayName is set to the default system
    // language.  This part of the code (the UI) runs as the logged on user when
    // there is one so these resources will be the user's language.  The resources
    // and associated code should be removed from utilman.exe and this code and
    // resources (from umandlg.dll) should be used.

    for (DWORD i=0;i<g_cClients;i++)
    {
	    if ( lstrcmp( g_rgClients[i].machine.ApplicationName, TEXT("Magnifier") ) == 0 )
	    {
		    ReplaceDisplayName(g_rgClients[i].machine.DisplayName, IDS_DISPLAY_NAME_MAGNIFIER);
	    }
	    else if ( lstrcmp( g_rgClients[i].machine.ApplicationName, TEXT("Narrator") ) == 0 ) 
	    {
		    ReplaceDisplayName(g_rgClients[i].machine.DisplayName, IDS_DISPLAY_NAME_NARRATOR);
	    }
	    else if ( lstrcmp( g_rgClients[i].machine.ApplicationName, TEXT("On-Screen Keyboard") ) == 0 ) 
	    {
		    ReplaceDisplayName(g_rgClients[i].machine.DisplayName, IDS_DISPLAY_NAME_OSK);
	    }
    }
}

static BOOL InitClientData(void)
{
    BOOL fRv = TRUE;

    // On initial run allocate and initialize client array
    
    if (!g_rgClients || !g_cClients)
    {
        umc_header_tsp pHdr = 0;
        umclient_tsp c = 0;
        DWORD_PTR accessID,accessID2;
        
        g_cClients = 0;
        g_rgClients = NULL;
        
        fRv = FALSE;

        pHdr = (umc_header_tsp)AccessIndependentMemory(
									UMC_HEADER_FILE, 
									sizeof(umc_header_ts), 
									FILE_MAP_READ,
									&accessID);
        if (!pHdr)
        {
            goto Cleanup;
        }
        
        s_dwStartMode = pHdr->dwStartMode;              // capture the Utilman start mode
        s_fShowWarningAgain = pHdr->fShowWarningAgain;  // and warning dialog flag
        
        if (!pHdr->numberOfClients)
        {
            goto Cleanup;
        }
        c = (umclient_tsp)AccessIndependentMemory(
								UMC_CLIENT_FILE, 
								sizeof(umclient_ts)*MAX_NUMBER_OF_CLIENTS, 
								FILE_MAP_READ,
								&accessID2);
        if (!c)
        {
            goto Cleanup;
        }
        g_rgClients = (umclient_tsp)VirtualAlloc(NULL, sizeof(umclient_ts)*pHdr->numberOfClients, MEM_RESERVE,PAGE_READWRITE);
        if (!g_rgClients)
        {
            goto Cleanup;
        }
        if (!VirtualAlloc(g_rgClients, sizeof(umclient_ts)*pHdr->numberOfClients, MEM_COMMIT, PAGE_READWRITE))
        {
            goto Cleanup;
        }

        fRv = TRUE;
        
        g_cClients = pHdr->numberOfClients;
        memcpy(g_rgClients,c,sizeof(umclient_ts)*pHdr->numberOfClients);

        SetLocalizedDisplayName();
        
Cleanup:
        if (pHdr)
        {
            UnAccessIndependentMemory(pHdr, accessID);
        }
        if (c)
        {
            UnAccessIndependentMemory(c, accessID2);
        }
        
        if (!fRv && g_rgClients)
        {
            VirtualFree(g_rgClients, 0, MEM_RELEASE);
            g_rgClients = NULL;
            g_cClients = 0;
        }

    }

    // "Start when I log on" is per-user setting so get that
    // each time the dialog is brought up

    CManageShellLinks CManageLinks(STARTUP_FOLDER);
    for (DWORD i=0;i<g_cClients;i++)
    {
        g_rgClients[i].user.fStartAtLogon 
            = CManageLinks.LinkExists(g_rgClients[i].machine.ApplicationName);
    }

	return fRv;
}

// RegSetUMDwordValue - helper function to set a DWORD string value creating it if necessary
//
BOOL RegSetUMDwordValue(HKEY hKey, LPCTSTR pszKey, LPCTSTR pszString, DWORD dwNewValue)
{
    HKEY hSubkey;
    int iRv;
    DWORD dwValue = dwNewValue;

    iRv = RegCreateKeyEx(
                  hKey
                , pszKey
                , 0, NULL
                , REG_OPTION_NON_VOLATILE
                , KEY_ALL_ACCESS
                , NULL, &hSubkey, NULL);

	if (iRv == ERROR_SUCCESS)
    {
		RegSetValueEx(
                  hSubkey
                , pszString
                , 0, REG_DWORD
                , (BYTE *)&dwValue
                , sizeof(DWORD));

		RegCloseKey(hSubkey);
    }

    return (iRv == ERROR_SUCCESS)?TRUE:FALSE;
}

void WriteUserRegData(HKEY hKeyCU, BOOL fDoAppletData)
{
    HKEY hkey;
    DWORD dwRv = RegCreateKeyEx(hKeyCU
                            , UM_HKCU_REGISTRY_KEY
                            , 0 , NULL
                            , REG_OPTION_NON_VOLATILE
                            , KEY_ALL_ACCESS, NULL
                            , &hkey, NULL);

    if (dwRv == ERROR_SUCCESS)
    {
        dwRv = RegSetValueEx(
              hkey
            , UMR_VALUE_SHOWWARNING
            , 0, REG_DWORD
            , (BYTE *)&s_fShowWarningAgain
            , sizeof(DWORD));

        if (fDoAppletData)
        {
	        for (DWORD i = 0; i < g_cClients; i++)
	        {
                RegSetUMDwordValue(
                      hkey
                    , g_rgClients[i].machine.ApplicationName
                    , UMR_VALUE_STARTLOCK
                    , g_rgClients[i].user.fStartOnLockDesktop);
	        }
        }

        RegCloseKey(hkey);
    }
}

// --------------------------------------------
static BOOL CopyClientData()
{
	umclient_tsp c;
	DWORD_PTR accessID;
	if (!g_cClients || !g_rgClients)
		return TRUE;
	c = (umclient_tsp)AccessIndependentMemory(
							UMC_CLIENT_FILE, 
							sizeof(umclient_ts)*MAX_NUMBER_OF_CLIENTS, 
							FILE_MAP_READ|FILE_MAP_WRITE,
							&accessID);
	if (!c)
		return FALSE;
	memcpy(c,g_rgClients,sizeof(umclient_ts)*g_cClients);
	UnAccessIndependentMemory(c, accessID);
	return TRUE;
}

static void CopyHeaderData()
{
	umc_header_tsp pHdr;
	DWORD_PTR accessID;

	pHdr = (umc_header_tsp)AccessIndependentMemory(
								UMC_HEADER_FILE, 
								sizeof(umc_header_ts), 
								FILE_MAP_READ|FILE_MAP_WRITE,
								&accessID);
	if (pHdr)
    {
        pHdr->fShowWarningAgain = s_fShowWarningAgain;
	    UnAccessIndependentMemory(pHdr, accessID);
    }
}

// ----------------------------------
// WriteClientData - save settings to the registry
//
static BOOL WriteClientData(BOOL fRunningSecure)
{
    // It only makes sense to do this if there are any applets being managed
    // (shouldn't get here) and if there is a logged on user (otherwise the
    // settings cannot be changed)

	if (!g_cClients || !g_rgClients || fRunningSecure)
		return TRUE;

	// The SYSTEM instance of utilman needs to be updated in case the user
	// changed any options.  This is so subsequent instances of the UI will
	// get the correct options without having to read the registry.

	CopyHeaderData();
	CopyClientData();

    //
    // Write utilman settings data.  Put "Start when UtilMan starts" in HKLM, 
    // "Start when I lock desktop" in HKCU, and "Start when I log on" into
    // a startup link in the logged on user's shell folder.
    //

    // "Start when UtilMan starts" settings... (only for admins)

	DWORD i;
    if (IsWindowEnabled(GetDlgItem(g_hWndDlg, IDC_START_WITH_UM)))
    {
	    HKEY hHKLM;
        DWORD dwRv = RegCreateKeyEx(HKEY_LOCAL_MACHINE
                                , UM_REGISTRY_KEY
                                , 0 , NULL
                                , REG_OPTION_NON_VOLATILE
                                , KEY_ALL_ACCESS, NULL
                                , &hHKLM, NULL);
        if (dwRv == ERROR_SUCCESS)
        {
	        for (i = 0; i < g_cClients; i++)
	        {
                RegSetUMDwordValue(
                      hHKLM
                    , g_rgClients[i].machine.ApplicationName
                    , UMR_VALUE_STARTUM
                    , g_rgClients[i].user.fStartWithUtilityManager);
	        }
	        RegCloseKey(hHKLM);
        }
    }

    //
    // "Start when I lock my desktop" settings... (any logged on user)
    // and Don't show me the warning anymore setting
    //
    WriteUserRegData(HKEY_CURRENT_USER, IsWindowEnabled(GetDlgItem(g_hWndDlg, IDC_START_ON_LOCK)));

    //
    // manage shell folder link updates (logged on user only)
    //

    if (IsWindowEnabled(GetDlgItem(g_hWndDlg, IDC_START_AT_LOGON)))
    {
        CManageShellLinks CManageLinks(STARTUP_FOLDER);

	    for (i = 0; i < g_cClients; i++)
	    {
            LPTSTR pszAppName = g_rgClients[i].machine.ApplicationName;
            BOOL fLinkExists = CManageLinks.LinkExists(pszAppName);

            // if should start at logon and there isn't a link then create one
            // and if shouldn't start at logon and there is a link then delete it

            if (g_rgClients[i].user.fStartAtLogon && !fLinkExists)
            {
                TCHAR pszAppPath[MAX_PATH];
                LPTSTR pszApp = 0;

                // Following is TRUE *only* if pszAppPath is non-null string value
                if (GetClientApplicationPath(pszAppName , pszAppPath , MAX_PATH))
                {
			        TCHAR pszFullPath[MAX_PATH*2+1]; // path + filename
				    TCHAR pszStartIn[MAX_PATH];
                    int ctch, ctchAppPath = lstrlen(pszAppPath);

				    // if pszAppPath is just base name and extension then prepend system path

				    if (wcscspn(pszAppPath, TEXT("\\")) != (size_t)ctchAppPath
                        || wcscspn(pszAppPath, TEXT(":")) != (size_t)ctchAppPath)
				    {
					    TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR];
					    _wsplitpath(pszAppPath, szDrive, szDir, NULL, NULL);
					    lstrcpy(pszStartIn, szDrive);
					    lstrcat(pszStartIn, szDir);

                        pszApp = pszAppPath;
				    } else
				    {
					    ctch = GetSystemDirectory(pszStartIn, MAX_PATH);

					    lstrcpy(pszFullPath, pszStartIn); // save path to build full path

					    if (ctch + ctchAppPath + 2 > MAX_PATH*2)
					    {
						    DBPRINTF(TEXT("WriteClientData:  Path is too short!\r\n"));
					    } else
					    {
						    if (*(pszFullPath + ctch - 1) != '\\')
							    lstrcat(pszFullPath, TEXT("\\"));

						    lstrcat(pszFullPath, pszAppPath);
                            pszApp = pszFullPath;
					    }
				    }

				    if (pszApp)
				    {
                        // remove ending '\' from StartIn path
                        ctch = lstrlen(pszStartIn) - 1;
				        if (*(pszStartIn + ctch) == '\\')
                            *(pszStartIn + ctch) = 0;

                        CManageLinks.CreateLink(
                                      pszAppName
                                    , pszApp
                                    , pszStartIn
                                    , g_rgClients[i].machine.DisplayName
                                    , TEXT("/UM"));
                    }
                }
            } else if (!g_rgClients[i].user.fStartAtLogon && fLinkExists)
            {
                CManageLinks.RemoveLink(pszAppName);
            }
	    }
    }

	return TRUE;
}
// --------------------------------------------
static BOOL CantStopClient(umclient_tsp client)
{
	switch (client->machine.ApplicationType)
	{
	case APPLICATION_TYPE_APPLICATION:
		break;
	case APPLICATION_TYPE_SERVICE:
		{
			SERVICE_STATUS  ssStatus;
			SC_HANDLE hService;
			SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
			if (!hSCM)
				return TRUE;
			hService = OpenService(hSCM, client->machine.ApplicationName, SERVICE_ALL_ACCESS);
			CloseServiceHandle(hSCM);
			if (!hService)
				return TRUE;
			if (!QueryServiceStatus(hService, &ssStatus) ||
				!(ssStatus.dwControlsAccepted  & SERVICE_ACCEPT_STOP))
			{
				CloseServiceHandle(hService);
				return TRUE;
			}
			CloseServiceHandle(hService);
			break;
		}
	}
	return FALSE;
}//CantStopClient

// We don't want UtilMan to startType to be Automatic
// It should only be made Automatic if it is required, When the user
// selects "Start when NT starts" through the GUI :a-anilk
static BOOL IsStartAuto()
{
#ifdef NEVER    // MICW Don't start service anymore at logon because of TS
    DWORD nClient;
	
	for(nClient = 0; nClient < g_cClients; nClient++)
	{
		if ( g_rgClients[nClient].user.fStartAtLogon == TRUE )
            return TRUE;
    }
#endif
    return FALSE;
}

static int GetClientNameFromAccelerator(WPARAM wVK)
{
	for (int i=0;i<(int)g_cClients;i++)
		if (g_rgClients[i].machine.AcceleratorKey == wVK)
			return i;
	return -1;
}

static BOOL StartClientsOnShow()
{
    BOOL fOK = TRUE;
	for (int i=0;i<(int)g_cClients;i++)
	{
		if ( g_rgClients[i].user.fStartWithUtilityManager
		  && !StartClient(g_hWndDlg, &g_rgClients[i]))
            fOK = FALSE;
	}
    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\utilman\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by utilman.rc
//
#define IDI_UM                          102
#define IDS_TSERROR                     500
#define IDS_NOACCESS                    501
#define IDS_DISPLAY_NAME_NARRATOR       502
#define IDS_DISPLAY_NAME_MAGNIFIER      503
#define IDS_DISPLAY_NAME_OSK			504
#define IDS_DISPLAY_NAME_UTILMAN        505

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\utilman\version.h ===
// NARRATOR.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "UtilMan EXE"
#define VER_INTERNALNAME_STR        "UtilMan"
#define VER_ORIGINALFILENAME_STR    "UtilMan.exe"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\utilman\utilman.c ===
// ----------------------------------------------------------------------------
//
// UtilMan.c
//
// Main file for Utility Manager
//
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// History: 
//          JE nov-15-98: changed UMDialog message to be a service control message
//			a-anilk: Add /Start, TS Exceptions, Errors, Fixes
// ----------------------------------------------------------------------------

// -----------------------------------------------------------------------
// Change in behavior - Whistler, with terminal server running, doesn't 
// allow running as a service.  Services can only run in session 0 and
// UtilMan needs to be able to run in any session.
// -----------------------------------------------------------------------

#define ALLOW_STOP_SERVICE

// Includes -----------------------------------
#include <windows.h>
#include <initguid.h>
#include <ole2.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"
#include "_UMRun.h"
#include "_UMClnt.h"
#include "UtilMan.h"
#include "UMS_Ctrl.h"
#include "resource.h"
#include <accctrl.h>
#include <aclapi.h>
#include "TSSessionNotify.c"   // for terminal services
#include "w95trace.h"
// --------------------------------------------
// constants
#define UTILMAN_IS_ACTIVE_EVENT         TEXT("UtilityManagerIsActiveEvent")
#define APP_TITLE                       TEXT("Utility Manager")
#define WTSNOTIFY_CLASS                 TEXT("UtilMan Notification Window")
#ifdef ALLOW_STOP_SERVICE
	#define NUM_EV 3
#else
	#define NUM_EV 2
#endif

// This is how often utilman will check for new applets started outside of utilman 
#define TIMER_INTERVAL 5000

// --------------------------------------------
// vars
static HANDLE evIsActive = NULL;
HINSTANCE hInstance = NULL;
static desktop_access_ts dAccess;

// --------------------------------------------
// prototypes
static long ExpFilter(LPEXCEPTION_POINTERS lpEP);
static BOOL CanRunUtilMan(LPTSTR cmdLine, DWORD *pdwRunCode, DWORD *pdwStartMode);
static void LoopService(DWORD dwStartMode);
LRESULT CALLBACK TSNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// These defines are used to construct a flag that describes
// how the current instance of utilman is being run.  The
// flag has RUNNING_, INSTANCE_ and DESKTOP_ bytes.
#define RUNNING_SYSTEM  0x1
#define RUNNING_USER    0x2
#define INSTANCE_1      0x4
#define INSTANCE_2      0x8
#define DESKTOP_SECURE  0x10
#define DESKTOP_LOGON   0x20

// Don't rely only on the command line flags; validate that if
// the flags indicate SYSTEM we are actually running system.
//
__inline BOOL RunningAsSystem(LPTSTR pszCmdLine)
{
	BOOL fIsSystem = (pszCmdLine && !_tcsicmp(pszCmdLine, TEXT("debug")))?TRUE:FALSE;
    if (fIsSystem)
    {
        fIsSystem = IsSystem();
    }
    return fIsSystem;
}

__inline BOOL RunningAsUser(LPTSTR pszCmdLine)
{
	BOOL fIsLocalUser = (!pszCmdLine || (pszCmdLine && !_tcsicmp(pszCmdLine, TEXT("start"))))?TRUE:FALSE;
	if (fIsLocalUser)
	{
		fIsLocalUser = IsInteractiveUser();
	}
    return fIsLocalUser;
}

//
// OObeRunning returns TRUE it can find the OOBE mutex.
//
__inline BOOL OObeRunning()
{
    HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, TEXT("OOBE is running"));
    BOOL fOobeRunning = (hMutex)?TRUE:FALSE;
    if (hMutex)
        CloseHandle(hMutex);

    return fOobeRunning;
}

int PASCAL WinMain(HINSTANCE hInst, 
                   HINSTANCE hPrevInst, 
                   LPSTR lpCmdLine, 
                   int nCmdShow)
{
	LPTSTR cmdLine = GetCommandLine();

	hInstance = hInst;

	__try
	{
        TCHAR  szDir[_MAX_PATH];
        DWORD  dwStartMode;
        BOOL   fKeepRunning;
        HANDLE hEvent    = OpenEvent(EVENT_MODIFY_STATE, FALSE, UTILMAN_IS_ACTIVE_EVENT);
        DWORD  dwRunCode = (hEvent)?INSTANCE_2:INSTANCE_1;

        // utilman needs to run in windows system directory 
        // so it can find MS trusted applets

        if (GetSystemDirectory(szDir, _MAX_PATH))
        {
            SetCurrentDirectory(szDir);
        }

        // assign to the correct desktop (will fail if any windows are open)

		InitDesktopAccess(&dAccess);

        CoInitialize(NULL);

        fKeepRunning = CanRunUtilMan(cmdLine, &dwRunCode, &dwStartMode);

        // initialize shared memory

	    if (!InitUManRun((dwRunCode & INSTANCE_1), dwStartMode))
	    {
            DBPRINTF(TEXT("WinMain:  InitUManRun FAILED\r\n"));
		    return 1;
	    }

        if (!hEvent)
        {
		    evIsActive = BuildEvent(UTILMAN_IS_ACTIVE_EVENT, FALSE, FALSE, TRUE);
        }

        switch(dwRunCode)
        {
            case RUNNING_SYSTEM|INSTANCE_1|DESKTOP_SECURE:
                OpenUManDialogInProc(FALSE);
                break;

            case RUNNING_SYSTEM|INSTANCE_2|DESKTOP_SECURE:
                SetEvent(hEvent);
                break;

            case RUNNING_SYSTEM|INSTANCE_1|DESKTOP_LOGON:
            case RUNNING_SYSTEM|INSTANCE_2|DESKTOP_LOGON:
                OpenUManDialogOutOfProc();
                break;

            case RUNNING_USER|INSTANCE_1|DESKTOP_LOGON:
            case RUNNING_USER|INSTANCE_2|DESKTOP_LOGON:
                OpenUManDialogInProc(TRUE);
                break;

            default:
                DBPRINTF(TEXT("WinMain:  Taking default switch path dwRunCode = 0x%x dwStartMode = %d\r\n"), dwRunCode, dwStartMode);
                break;
        }

	    if (hEvent)
	    {
		    CloseHandle(hEvent);
        }

        if (fKeepRunning)
        {
            LoopService(dwStartMode);
        }

        DBPRINTF(TEXT("WinMain:  Exiting...\r\n"));
		ExitUManRun();
		CloseHandle(evIsActive);
		ExitDesktopAccess(&dAccess);
        CoUninitialize();
	}
	__except(ExpFilter(GetExceptionInformation()))
	{
	}

	return 1;
}
// ---------------------------------

VOID TerminateUMService(VOID)
{
	HANDLE  ev = BuildEvent(STOP_UTILMAN_SERVICE_EVENT,FALSE,FALSE,TRUE);
    DBPRINTF(TEXT("TerminateUMService:  signaling STOP_UTILMAN_SERVICE_EVENT\r\n"));
	SetEvent(ev);
	CloseHandle(ev);
}

// -------------------------
static BOOL CanRunUtilMan(LPTSTR cmdLine, DWORD *pdwRunCode, DWORD *pdwStartMode)
{
	LPTSTR      pszCmdLine;
	desktop_ts  desktop;
    DWORD       dwRunCode = 0;
    DWORD       dwStartMode = START_BY_OTHER;
    BOOL        fKeepRunning = FALSE;
	TCHAR       szUMDisplayName[256];

    // Detect if there is a utilman dialog currently up.  See if we can find
    // the "Utility Manager" window.

	if (!LoadString(hInstance, IDS_DISPLAY_NAME_UTILMAN, szUMDisplayName, 256))
	{
		DBPRINTF(TEXT("IsDialogRunning:  Cannot find IDS_DISPLAY_NAME_UTILMAN resource\r\n"));
        return TRUE;    // cause a noticable error
	}

    if (FindWindowEx(NULL, NULL, TEXT("#32770"), szUMDisplayName))
	{
        goto ExitCanRunUtilman;
    }

    // Ours is the only instance of utilman running in this security context.
	// If we are running SYSTEM there may be another instance (in the user's 
	// context) but we can't detect that.  In that case, the SYSTEM instance
	// will launch an instance in the user's context and we'll detect the
	// window up then.

    dwRunCode = *pdwRunCode;

	pszCmdLine = _tcschr(cmdLine, TEXT('/'));
	if (!pszCmdLine)
    {
		pszCmdLine = _tcschr(cmdLine, TEXT('-'));
    }
	if (pszCmdLine)
    {
		pszCmdLine++;
    }

    // Determine if this instance is running as SYSTEM or the interactive user.
    // This is a kludge because of the way utilman gets started with certain
    // flags (/debug when started from winlogon and /start when started from
    // Start menu).  Better way would be to detect the SID(s) in this process's
    // token and decide from there what to do.  Consider for the next version.

	if (RunningAsSystem(pszCmdLine))
	{
		dwRunCode |= RUNNING_SYSTEM;
        dwStartMode = START_BY_HOTKEY;
	}
	if (RunningAsUser(pszCmdLine))
	{
		dwRunCode |= RUNNING_USER;
        dwStartMode = (dwRunCode & INSTANCE_1)?START_BY_MENU:START_BY_HOTKEY;
	}

    // Get the current desktop type and set the desktop flag

    QueryCurrentDesktop(&desktop, TRUE);

    // OOBE fix: Oobe runs on the interactive desktop as SYSTEM before any user
    // is logged on.  We break their accessibility if we determine how to run
    // based on which desktop we're on.  So special-case setting DESKTOP_SECURE
	// if OOBE is running.

    if (desktop.type == DESKTOP_WINLOGON || (IsSystem() && OObeRunning()))
    {
        dwRunCode |= DESKTOP_SECURE;
        dwStartMode = START_BY_HOTKEY; // paranoia
    }
    else
    {
        dwRunCode |= DESKTOP_LOGON;
    }

    // If this is the first time utilman is run for the session and it is running as
	// SYSTEM then this instance of utilman should continue running after the dialog
	// is dismissed.  This instance will handle monitoring applets and the UI instance
	// during desktop and session changes.

    fKeepRunning = ((dwRunCode & INSTANCE_1) && (dwRunCode & RUNNING_SYSTEM));

ExitCanRunUtilman:
    *pdwRunCode = dwRunCode;
    *pdwStartMode = dwStartMode;

	return fKeepRunning;
}

__inline void CloseEventHandles(HANDLE events[])
{
	CloseHandle(events[0]);
    CloseHandle(events[1]);
#ifdef ALLOW_STOP_SERVICE
	CloseHandle(events[2]);
#endif
}

// -------------------------
static void LoopService(DWORD dwStartMode)
{
    HWND hWndMessages;
	desktop_ts desktop;
	HANDLE events[NUM_EV];
	DWORD r;
	UINT_PTR  timerID = 0;

    // assign thread to the current desktop

	SwitchToCurrentDesktop();

    // set up the array of object handles for MsgWaitForMultipleObjects

	events[0] = OpenEvent(SYNCHRONIZE, FALSE, __TEXT("WinSta0_DesktopSwitch"));
    events[1] = evIsActive;
#ifdef ALLOW_STOP_SERVICE
	events[2] = BuildEvent(STOP_UTILMAN_SERVICE_EVENT,FALSE,FALSE,TRUE);
#endif

    // create a message-only window to handle terminal server 
    // session notification messages

    hWndMessages = CreateWTSNotifyWindow(hInstance, TSNotifyWndProc);

    // note the current desktop so we know where we came from 
    // and where we are going when the desktop changes

    QueryCurrentDesktop(&desktop, TRUE);

	// Change timer to 5 seconds.  This timer is helps detect client 
    // apps not started with utilman (so we can restart them if the
    // user switches away from this session) and the status of the
    // utilman process displaying UI.

    timerID = SetTimer(NULL, 1, TIMER_INTERVAL, UMTimerProc);
	for (;;)
    {
	    desktop_ts desktopT;
        // 
        // Sync the current desktop; if it has changed (eg we missed
        // a desktop switch notification) then bypass the MWFMO and
        // go into the desktop switch code.
        //
        QueryCurrentDesktop(&desktopT, TRUE);
        r = WAIT_OBJECT_0 + NUM_EV + 1; // signals we've got the current desktop

        if (desktopT.type == desktop.type)
        {
            // Nope, wait for objects...
		    r = MsgWaitForMultipleObjects(NUM_EV,events, FALSE, INFINITE, QS_ALLINPUT);
#ifdef ALLOW_STOP_SERVICE
		    if (r == (WAIT_OBJECT_0+NUM_EV-1))//stop event
			    break;
#endif
            if (r == (WAIT_OBJECT_0+1)) // Show dialog event
            {
                DBPRINTF(TEXT("LoopService:  Got UTILMAN_IS_ACTIVE_EVENT event\r\n"));
		        OpenUManDialogInProc(FALSE);
                continue;
            }
		    if (r == (WAIT_OBJECT_0+NUM_EV))
		    {
                // this message loop is just for the timer
			    MSG msg;
			    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
			    {
				    TranslateMessage(&msg);
				    DispatchMessage(&msg);
			    }
			    continue;
		    }
		    if (r != WAIT_OBJECT_0)// any kind of error
			    continue;

            // When this session is being disconnected the switch is a noop.
            // Get the new desktop and compare with the old; if we haven't
            // changed then just continue to wait...

            QueryCurrentDesktop(&desktopT, TRUE);
            if (desktopT.type == desktop.type)
                continue;
        }

        // desktop switch event - kill the timer and get clients to quit this desktop

        KillTimer(NULL, timerID);

		NotifyClientsBeforeDesktopChanged(desktop.type);

		WaitDesktopChanged(&desktop);
		UManRunSwitchDesktop(&desktop, timerID);

		NotifyClientsOnDesktopChanged(desktop.type);

        // start the timer up again to monitor client aps

        timerID = SetTimer(NULL, 1, TIMER_INTERVAL, UMTimerProc);
	}
	CloseEventHandles(events);

    // Clean up the terminal server message-only window
    DestroyWTSNotifyWindow(hWndMessages);
}

// -------------------------
static long ExpFilter(LPEXCEPTION_POINTERS lpEP)
{
	TCHAR message[500];
	_stprintf(message, TEXT("Exception: Code %8.8x Flags %8.8x Address %8.8x"),
		lpEP->ExceptionRecord->ExceptionCode,
		lpEP->ExceptionRecord->ExceptionFlags,
		lpEP->ExceptionRecord->ExceptionAddress);
	MessageBox(NULL, message, APP_TITLE, MB_OK | MB_ICONSTOP);
	return EXCEPTION_EXECUTE_HANDLER;
}

// TSNotifyWndProc - callback that receives window message notifications from terminal services
//
LRESULT CALLBACK TSNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fNarratorRunning = FALSE;
    // Could react to WTS_CONSOLE_DISCONNECT and WTS_REMOTE_DISCONNECT too however
    // both disconnect and the connect come after the desktop switch notification.
    // For the cases where TS isn't there (server and workstation in a domain) we
    // have to handle cleanup in desk switch.  For future, it would be nice to code
    // such that the cleanup handler could be exec'd at session change or desk
    // switch but not both.
	if (uMsg == WM_WTSSESSION_CHANGE && wParam == WTS_SESSION_LOGOFF)
	{
            umc_header_tsp d;
            DWORD_PTR accessID;
            desktop_ts desktop;
            
            WaitDesktopChanged(&desktop);
            d = (umc_header_tsp)AccessIndependentMemory(UMC_HEADER_FILE, sizeof(umc_header_ts), FILE_MAP_ALL_ACCESS, &accessID);
            if (d)
            {
                DWORD cClients = d->numberOfClients;
                if (cClients > MAX_NUMBER_OF_CLIENTS)
                	cClients = MAX_NUMBER_OF_CLIENTS;
                
                if (cClients)
                {
                    DWORD i, j;
                    DWORD_PTR accessID2;
                    umclient_tsp c = (umclient_tsp)AccessIndependentMemory(
            											UMC_CLIENT_FILE, 
            											sizeof(umclient_ts)*MAX_NUMBER_OF_CLIENTS, 
            											FILE_MAP_ALL_ACCESS, 
            											&accessID2);
                    if (c)
                    {
                        // When a user logs off they switch to the locked desktop before getting to the logged off desktop
                        // (both these desktops are WINLOGON). This means that the applets that have start me on the
                        // locked desktop will startup only to need to stopped when the user logs is finnished being
                        // logged off.  Because of a time issue this was broken.  So we need to detect the logoff and make
                        // sure the applets have shut down. If we don't they stay up and then when the user logs back
                        // in they won't  start up on the default desktop because they are still running on winlogon desktop. 
                        // the applets take a long time to come up and if we try to shut them down to fast then they miss
                        // the message and stay up.  So we will keep trying for a long enough time to make sure we get them.
                        
                        Sleep(4000);

                        for (i = 0; i < cClients; i++)
                        {
                            if (lstrcmp(c[i].machine.DisplayName, TEXT("Narrator")) == 0)
                                fNarratorRunning = TRUE;
                            else
                                StopClient(&c[i]);
                        }
                        UnAccessIndependentMemory(c, accessID2);
                    }
                }
            }
            UnAccessIndependentMemory(d, accessID);
            // Narrator does not respond to the close messages to keep utilman running to bring it back up when they login.
            if (!fNarratorRunning)
                TerminateUMService();
	}


	return DefWindowProc( hwnd, uMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\utilman\utilman\umanrun.c ===
// --------------------------------------------
// switch behaviour
// ----------------------------------------------------------------------------
//
// UManRun.c
//
// Run and watch Utility Manager clients
//
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
//
// History: created oct-98 by JE
//          JE nov-15-98: changed UMDialog message to be a service control message
//          JE nov-15 98: changed to support launch specific client
//			YX jun-01-99: client.machine.DisplayName retrieved from registry
//			YX jun-04-99: UMDlg notified after desktop change; changes in the 
//						  UTimeProc to react the process started outside the manager
//			Bug Fixes and changes Anil Kumar 1999				  
// ----------------------------------------------------------------------------
#include <windows.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"
#include "_UMRun.h"
#include "_UMDlg.h"
#include "UtilMan.h"
#include "_UMClnt.h"
#include "UMS_Ctrl.h"
#include "resource.h"
#include "manageshelllinks.h"

// --------------------------------------------
// vars
static desktop_ts s_CurrentDesktop;
extern HINSTANCE hInstance;
static HANDLE    s_hFile = NULL;
static HANDLE    hClientFile = NULL;
static HINSTANCE hDll = NULL;
static umandlg_f UManDlg = NULL;
typedef BOOL (* LPFNISDIALOGUP)(void);
static LPFNISDIALOGUP IsDialogUp = NULL;
// --------------------------------------------
// prototypes
static BOOL InitClientData(umc_header_tsp header);
static BOOL UpdateClientData(umc_header_tsp header,umclient_tsp client);
static BOOL CloseUManDialog(VOID);
static VOID	CorrectClientControlCode(umclient_tsp c, DWORD i);
static VOID	CorrectAllClientControlCodes(umclient_tsp c, DWORD max);
static VOID	ChangeClientControlCode(LPTSTR ApplicationName,DWORD ClientControlCode);

DWORD FindProcess(LPCTSTR pszApplicationName, HANDLE *phProcess);

__inline BOOL IsMSClient(unsigned long ulControlCode)
{
    return (ulControlCode >= UM_SERVICE_CONTROL_MIN_RESERVED 
         && ulControlCode <= UM_SERVICE_CONTROL_MAX_RESERVED)?TRUE:FALSE;
}

// ---------------------------------
// IsTrusted does an explicit name check on Microsoft applications.
// It returns TRUE if szAppPath is a trusted Microsoft applet else FALSE. 
// Applications must be:
//
// 1. osk.exe, magnify.exe, or narrator.exe
// 2. run from %WINDIR%
//
BOOL IsTrusted(LPTSTR szAppPath)
{
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szPath[_MAX_PATH];
	TCHAR szName[_MAX_FNAME];
	TCHAR szExt[_MAX_EXT];

	_wsplitpath(szAppPath, szDrive, szPath, szName, szExt);
	if (lstrlen(szPath) && !lstrlen(szDrive))
		return FALSE;	// if there's a path specifier then require drive
						// otherwise could have sys path on non-sys drive

	if ( lstrcmpi(szName, TEXT("osk")) 
	  && lstrcmpi(szName, TEXT("magnify")) 
#ifdef DBG
      && lstrcmpi(szName, TEXT("inspect"))
      && lstrcmpi(szName, TEXT("accevent"))
#endif
	  && lstrcmpi(szName, TEXT("narrator")) )
		return FALSE;	// it isn't a trusted MS application

	if (lstrcmpi(szExt, TEXT(".exe")))
		return FALSE;	// OK name but it isn't an executable

	// if there is a path on the application it must be in system
	// directory (else it defaults to system directory)

	if (lstrlen(szDrive))
	{
		TCHAR szSysDir[_MAX_PATH];
		int ctch = GetSystemDirectory(szSysDir, _MAX_PATH);
		if (!ctch)
			return FALSE;	// should never happen

		if (_wcsnicmp(szAppPath, szSysDir, ctch))
			return FALSE;	// path isn't system path
	}

	return TRUE;
}

// --------------------------------------------
BOOL InitUManRun(BOOL fFirstInstance, DWORD dwStartMode)
{
	QueryCurrentDesktop(&s_CurrentDesktop,TRUE);
	InitWellknownSids();

	// The first instance of utilman creates and initializes the memory 
	// mapped file regardless of what context it is running in.

	if (fFirstInstance)
	{
		umc_header_tsp d;
		DWORD_PTR accessID;

		s_hFile = CreateIndependentMemory(UMC_HEADER_FILE, sizeof(umc_header_ts), TRUE);
		
		if (!s_hFile)
			return FALSE;
		
		d = (umc_header_tsp)AccessIndependentMemory(
								UMC_HEADER_FILE, 
								sizeof(umc_header_ts), 
								FILE_MAP_ALL_ACCESS, 
								&accessID);
		if (!d)
		{
			DeleteIndependentMemory(s_hFile);
			s_hFile = NULL;
			return FALSE;
		}
		memset(d, 0, sizeof(umc_header_ts));

		InitClientData(d);

		d->dwStartMode = dwStartMode;
		
		UnAccessIndependentMemory(d, accessID);
	}

	return TRUE;
}

VOID ExitUManRun(VOID)
{
	if (s_hFile)
	{
		DeleteIndependentMemory(s_hFile);
		s_hFile = NULL;
	}
	if (hClientFile)
	{
		DeleteIndependentMemory(hClientFile);
		hClientFile = NULL;
	}
	UninitWellknownSids();
}//ExitUManRun
// -----------------------

//
// NotifyClientsBeforeDesktopChanged:  
// Called when the desktop switch object is signaled.  This function captures
// information about running clients, signals and waits for them to quit then
// resets its event object.
//
#define MAX_WAIT_RETRIES 500
BOOL NotifyClientsBeforeDesktopChanged(DWORD dwDesktop)
{
    umc_header_tsp d;
    DWORD_PTR accessID;
    DWORD cClients;

    d = (umc_header_tsp)AccessIndependentMemory(
							UMC_HEADER_FILE, 
							sizeof(umc_header_ts), 
							FILE_MAP_ALL_ACCESS, 
							&accessID);

    if (!d)
    {
        DBPRINTF(TEXT("NotifyClientsBeforeDesktopChanged: Can't AccessIndependentMemory\r\n"));
        return FALSE;
    }

    cClients = d->numberOfClients;
    if (cClients > MAX_NUMBER_OF_CLIENTS)
    	cClients = MAX_NUMBER_OF_CLIENTS;
    
    if (cClients)
    {
        DWORD i;
        DWORD_PTR accessID2;
        umclient_tsp c = (umclient_tsp)AccessIndependentMemory(
											UMC_CLIENT_FILE, 
											sizeof(umclient_ts)*MAX_NUMBER_OF_CLIENTS, 
											FILE_MAP_ALL_ACCESS, 
											&accessID2);
        if (c)
        {
            //
            // First capture state about running clients
            //

            if (dwDesktop == DESKTOP_DEFAULT)
            {
                // For now we only need to capture state on the default desktop
                for (i = 0; i < cClients; i++)
                {
                    // We only control restarting MS applications on the default desktop
                    if (IsMSClient(c[i].machine.ClientControlCode) && c[i].state == UM_CLIENT_RUNNING)
                    {
                        c[i].user.fRestartOnDefaultDesk = TRUE;
                    }
                }
            }

            //
            // Then wait for clients to shut down
            //

            for (i = 0; i < cClients; i++)
            {
                // We only control MS applications.  Other applications
                // shouldn't have to worry about desktop switches.
                if (IsMSClient(c[i].machine.ClientControlCode) && c[i].state == UM_CLIENT_RUNNING)
                {
			        DWORD j, dwRunCount = c[i].runCount;
			        for (j = 0; j < dwRunCount && j < MAX_APP_RUNCOUNT; j++)
			        {
                        // Wait for this one to quit...
                        BOOL fClientRunning;
                        int cTries = 0;
                        do
                        {
                            // This code won't work for services but there
                            // are no MS utilman clients that are services. GetExitCodeProcess
				            if (!GetProcessVersion(c[i].processID[j]))
                            {
					            c[i].processID[j] = 0;
                                if (c[i].hProcess[j])
                                {
	  				                CloseHandle(c[i].hProcess[j]);
                                    c[i].hProcess[j] = 0;
                                }
		  			            c[i].mainThreadID[j] = 0;
                                fClientRunning = FALSE;   // This one has quit
                            } else
                            {
                                fClientRunning = TRUE;    // This one hasn't quit yet
                                Sleep(100);
                            }
                            cTries++;
                        } while (fClientRunning && cTries < MAX_WAIT_RETRIES);
                    }
                    c[i].runCount = 0;
                    c[i].state = UM_CLIENT_NOT_RUNNING;
                }
            }

            UnAccessIndependentMemory(c, accessID2);
        }
    }

    UnAccessIndependentMemory(d, accessID);
    return TRUE;
}

//
// NotifyClientsOnDesktopChanged:  Called after a desktop change has occurred.
// This code restarts any clients on the new desktop.
//
BOOL NotifyClientsOnDesktopChanged(DWORD dwDesktop)
{
	umc_header_tsp d;
	DWORD_PTR accessID;

	d = (umc_header_tsp)AccessIndependentMemory(
							UMC_HEADER_FILE, 
							sizeof(umc_header_ts), 
							FILE_MAP_ALL_ACCESS, 
							&accessID);
	if (!d)
		return FALSE;

	if (d->numberOfClients)
	{
        DWORD i,j;
        DWORD_PTR accessID2;
        umclient_tsp c = (umclient_tsp)AccessIndependentMemory(
											UMC_CLIENT_FILE, 
											sizeof(umclient_ts)*MAX_NUMBER_OF_CLIENTS, 
											FILE_MAP_ALL_ACCESS, 
											&accessID2);
        DWORD cClients = d->numberOfClients;
	    if (cClients > MAX_NUMBER_OF_CLIENTS)
    		cClients = MAX_NUMBER_OF_CLIENTS;

        if (c)
        {
            for (i = 0; i < cClients; i++)
            {
                //
                // New         User must configure when to start MS applets on the
                // behavior:   locked desktop.  We'll restart any applets on the
                // (08/2000)   default desktop if they said to start them when they
                //             log in regardless of it's state on secure desktop.
                //             Also restart MS applets if they were running before.
                //
                if( IsMSClient(c[i].machine.ClientControlCode))
                {
                    if ( (dwDesktop == DESKTOP_WINLOGON && c[i].user.fStartOnLockDesktop)
                      || (dwDesktop == DESKTOP_DEFAULT  && c[i].user.fStartAtLogon)
                      || (dwDesktop == DESKTOP_DEFAULT  && c[i].user.fRestartOnDefaultDesk))
                    {
                        if (!StartClient(NULL, &c[i]))
                        {
                            Sleep(500);   // Starting the client failed! Try again
                            StartClient(NULL, &c[i]);
                        }
                    }
                }
                else if (dwDesktop == DESKTOP_DEFAULT &&  c[i].user.fStartAtLogon)
                {
                    UINT mess = RegisterWindowMessage(UTILMAN_DESKTOP_CHANGED_MESSAGE);
                    for (j = 0; j < c[i].runCount && j < MAX_APP_RUNCOUNT; j++)	
                    {
                        // Can only post message if UtilMan started it; we don't
                        // know the process id of externally started clients.
                        if (c[i].mainThreadID[j] != 0)
                            PostThreadMessage(c[i].mainThreadID[j],mess,dwDesktop,0);
                    }
                }
            }
            UnAccessIndependentMemory(c, accessID2);
        }
	}

	UnAccessIndependentMemory(d, accessID);
	return TRUE;
}

// ----------------------------------------
BOOL OpenUManDialogInProc(BOOL fWaitForDlgClose)
{
    if (!hDll)
    {
        hDll = LoadLibrary(UMANDLG_DLL);
        if (!hDll)
            return FALSE;
    }
    if (!UManDlg)
    {
        UManDlg = (umandlg_f)GetProcAddress(hDll, UMANDLG_FCT);
        if (!UManDlg)
        {
            FreeLibrary(hDll);
            return FALSE;
        }
    }
    return UManDlg(TRUE, fWaitForDlgClose, UMANDLG_VERSION);
}
// ----------------------------------------

static BOOL CloseUManDialog(VOID)
{
    BOOL fWasOpen = FALSE;
	if (UManDlg)
	{
		fWasOpen = UManDlg(FALSE, FALSE, UMANDLG_VERSION);
		UManDlg = NULL;
	}
	Sleep(10);

    if (IsDialogUp)
        IsDialogUp = NULL;

	if (hDll)
	{
  		FreeLibrary(hDll);
		hDll = NULL;
	}
	return fWasOpen;
}

// ----------------------------------------

UINT_PTR UManRunSwitchDesktop(desktop_tsp desktop, UINT_PTR timerID)
{
    BOOL fDlgWasUp = FALSE;
    KillTimer(NULL,timerID);

    if ((desktop->type != DESKTOP_ACCESSDENIED) &&
        (desktop->type != DESKTOP_SCREENSAVER)  &&
        (desktop->type != DESKTOP_TESTDISPLAY))
    {
        if (desktop->type != s_CurrentDesktop.type)
        {
            // if dialog is running in-proc ask it to close
            fDlgWasUp = CloseUManDialog();
            if (!fDlgWasUp)
            {
                // if dialog is running out-of-proc it will close itself
                fDlgWasUp = ResetUIUtilman();
            }
        }
    }

    memcpy(&s_CurrentDesktop, desktop, sizeof(desktop_ts));

    SwitchToCurrentDesktop();

    if ((desktop->type == DESKTOP_ACCESSDENIED) ||
        (desktop->type == DESKTOP_SCREENSAVER)  ||
        (desktop->type == DESKTOP_TESTDISPLAY))
    {
        return 0;
    }
    
    UpdateClientData(NULL, NULL);
    if (fDlgWasUp)
    {
        // Depending on which desktop we're on restart the dialog in-proc or out-of-proc

        if (desktop->type == DESKTOP_WINLOGON)
        {
            OpenUManDialogInProc(FALSE);
        }
        else
        {
            OpenUManDialogOutOfProc();
        }
    }
    return 0;
}
// ---------------------------------

static BOOL InitClientData(umc_header_tsp header)
{
	SERVICE_STATUS  ssStatus;
	DWORD dwRv;
	DWORD index,type,len,i, cchAppName;
	HKEY hKey, sKey;
	DWORD_PTR accessID;
	umclient_tsp c;
	WCHAR ApplicationName[MAX_APPLICATION_NAME_LEN];
	TCHAR ApplicationPath[MAX_APPLICATION_PATH_LEN];
	UINT em;
	HANDLE h;
    unsigned long ccb;
    DWORD dwNumberOfClients=0;

	// read the machine dependent data

	dwRv = RegOpenKeyEx(HKEY_LOCAL_MACHINE, UM_REGISTRY_KEY, 0, KEY_READ, &hKey);
	if (dwRv != ERROR_SUCCESS)
	{
		dwRv = RegCreateKeyEx(HKEY_LOCAL_MACHINE,UM_REGISTRY_KEY,0,NULL,REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,NULL,&hKey,NULL);
		if (dwRv != ERROR_SUCCESS)
		{	
  			DBPRINTF(_TEXT("Can't open HKLM\r\n"));
	  		return FALSE;   // error
		}
	}

	// count client applications based on what's in the registry

    cchAppName = MAX_APPLICATION_NAME_LEN;  // RegEnumKey takes count of TCHARs
    index = 0;
	while (RegEnumKey(hKey, index, ApplicationName, cchAppName) == ERROR_SUCCESS)
	{
		index++;
		dwNumberOfClients++;
	}
	
	// limit this to 16 this number is abitrary
	// This makes it so no one can overwrite memory when we go thru these elements
	// There is currently no one using this feature that we know of and having more than 16
	// aids on a system that you would manage with utilman seems stupid.
	if (dwNumberOfClients > MAX_NUMBER_OF_CLIENTS)
		dwNumberOfClients = MAX_NUMBER_OF_CLIENTS;	

	header->numberOfClients = dwNumberOfClients;

	if (!header->numberOfClients)
	{
		DBPRINTF(_TEXT("No clients\r\n"));
		RegCloseKey(hKey);
		return TRUE;   // no clients registered so nothing to do
	}

    // get a pointer to memory mapped file that contains applet data

    ccb = sizeof(umclient_ts)*MAX_NUMBER_OF_CLIENTS;
	hClientFile = CreateIndependentMemory(UMC_CLIENT_FILE, ccb, TRUE);
	if (!hClientFile)
	{
		DBPRINTF(_TEXT("Can't create client data\r\n"));
		header->numberOfClients = 0;
		RegCloseKey(hKey);
		return FALSE;   // error - unable to create memory mapped file
	}
 	c = (umclient_tsp)AccessIndependentMemory(
							UMC_CLIENT_FILE, 
							ccb, 
							FILE_MAP_ALL_ACCESS, 
							&accessID);
	if (!c)
	{
		DBPRINTF(_TEXT("Can't access client data\r\n"));
		DeleteIndependentMemory(hClientFile);
		hClientFile = NULL;
		header->numberOfClients = 0;
		RegCloseKey(hKey);
		return FALSE;   // error - unable to access pointer to memory mapped file
	}
    memset(c, 0, ccb);

    // read data from the registry into memory mapped file

	index = 0;  // index for RegEnumKey
	i = 0;      // index into memory mapped file structures

	em = SetErrorMode(SEM_FAILCRITICALERRORS);
	while (RegEnumKey(hKey, index, c[i].machine.ApplicationName, cchAppName) == ERROR_SUCCESS)
	{
		index++;
		dwRv = RegOpenKeyEx(hKey, c[i].machine.ApplicationName, 0, KEY_READ, &sKey);
		if (dwRv != ERROR_SUCCESS)
			continue;

        // get path to applet and verify the file exists

		len = sizeof(TCHAR)*MAX_APPLICATION_PATH_LEN;
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_PATH, NULL, &type, (LPBYTE)ApplicationPath, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_SZ))
		{
			RegCloseKey(sKey);
			continue;
		}
		
		ApplicationPath[len-1] = TEXT('\0');

        // CONSIDER This code is one reason why command line arguments aren't supported.
		h = CreateFile(ApplicationPath, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (h == INVALID_HANDLE_VALUE)
		{
   			DBPRINTF(_TEXT("Invalid client file\r\n"));
			RegCloseKey(sKey);
			continue;   // file doesn't exit -> skip it
		}

        // retrieve and store display name (it differs from the app name 
        // due to possible localization), if not - use app name

		len = sizeof(TCHAR)*MAX_APPLICATION_NAME_LEN;
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_DISPLAY, NULL, &type, (LPBYTE)&c[i].machine.DisplayName, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_SZ))
		{
			lstrcpy(c[i].machine.DisplayName, c[i].machine.ApplicationName);	
		}
		
		c[i].machine.DisplayName[len-1] = TEXT('\0');

        // get the type of applet - verify it is either executable or service

		len = sizeof(DWORD);
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_TYPE,NULL, &type, (LPBYTE)&c[i].machine.ApplicationType, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_DWORD))
		{
			RegCloseKey(sKey);
			continue;
		}

		if ((c[i].machine.ApplicationType != APPLICATION_TYPE_APPLICATION) &&
			  (c[i].machine.ApplicationType != APPLICATION_TYPE_SERVICE))
		{
			RegCloseKey(sKey);
			continue;
		}

        // get timeout and runcount and validate values

		len = sizeof(DWORD);
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_WRTO, NULL, &type, (LPBYTE)&c[i].machine.WontRespondTimeout, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_DWORD))
		{
			RegCloseKey(sKey);
			continue;
		}

		if (c[i].machine.WontRespondTimeout > MAX_WONTRESPONDTIMEOUT)
			c[i].machine.WontRespondTimeout = MAX_WONTRESPONDTIMEOUT;

		len = sizeof(BYTE);
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_MRC, NULL, &type, (LPBYTE)&c[i].machine.MaxRunCount, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_BINARY))
			c[i].machine.MaxRunCount = 1;

		if (!c[i].machine.MaxRunCount)
			c[i].machine.MaxRunCount = 1;

		if (c[i].machine.ApplicationType == APPLICATION_TYPE_SERVICE)
		{
		  if (c[i].machine.MaxRunCount > MAX_SERV_RUNCOUNT)
			  c[i].machine.MaxRunCount = MAX_SERV_RUNCOUNT;
		}
		else
		{
		  if (c[i].machine.MaxRunCount > MAX_APP_RUNCOUNT)
			  c[i].machine.MaxRunCount = MAX_APP_RUNCOUNT;
		}

        // get applet control code and validate

		len = sizeof(DWORD);
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_CCC, NULL, &type, (LPBYTE)&c[i].machine.ClientControlCode, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_DWORD))
			c[i].machine.ClientControlCode = 0;
		else
			CorrectClientControlCode(c, i);

		RegCloseKey(sKey);

        // update applet's running status (services get started here)

		if ((c[i].machine.ApplicationType == APPLICATION_TYPE_SERVICE) &&
		    TestServiceClientRuns(&c[i],&ssStatus))
		{
			c[i].state = UM_CLIENT_RUNNING;
			c[i].runCount = 1;
		}
		else
        {
			c[i].state = UM_CLIENT_NOT_RUNNING;
        }

        // capture whether this is a secure MS applet or not

        c[i].user.fCanRunSecure = IsTrusted(ApplicationPath);

		i++;
		if (i > MAX_NUMBER_OF_CLIENTS)
			break;

	}   //while 

	SetErrorMode(em);

	// set the number of clients based on what has just been read
	header->numberOfClients = i;

	// get user dependent data and correct errant control codes

	UpdateClientData(header, c);
	CorrectAllClientControlCodes(c, header->numberOfClients);
	UnAccessIndependentMemory(c, accessID);
	RegCloseKey(hKey);

	return TRUE;
}//InitClientData
// ---------------------------------

BOOL RegGetUMDwordValue(HKEY hHive, LPCTSTR pszKey, LPCTSTR pszString, DWORD *pdwValue)
{
    HKEY hKey;
	DWORD dwType = REG_BINARY;
	DWORD dwLen;

	DWORD dwRv = RegOpenKeyEx(hHive, pszKey, 0 , KEY_READ, &hKey);
    memset(pdwValue, 0, sizeof(DWORD));
	if (dwRv == ERROR_SUCCESS)
	{
		dwLen = sizeof(DWORD);
		dwRv = RegQueryValueEx(
                      hKey
                    , pszString
                    , NULL, &dwType
                    , (LPBYTE)pdwValue
                    , &dwLen);
		RegCloseKey(hKey);
    }
    return (dwRv == ERROR_SUCCESS && dwType == REG_DWORD)?TRUE:FALSE;
}

// UpdateClientData - updates the memory mapped data for each applet based on
//                    the user that is currently logged on (if any).
//
// header [in] - 
// client [in] - data for each applet managed by utilman
//
// header and client may be null in which case.
//
static BOOL UpdateClientData(umc_header_tsp header, umclient_tsp client)
{
	umc_header_tsp d = 0;
	umclient_tsp c = 0;
	DWORD_PTR accessID = 0, accessID2 = 0;
	DWORD dwRv;
	DWORD i;
	HKEY hHKLM, hHKCU;
    BOOL fRv = FALSE;
    HANDLE hImpersonateToken;
    BOOL fError;

    //
    // get valid header and client struct pointers
    //

	if (header)
    {
		d = header;
    }
	else
	{
		d = (umc_header_tsp)AccessIndependentMemory(
								UMC_HEADER_FILE, 
								sizeof(umc_header_ts), 
								FILE_MAP_ALL_ACCESS, 
								&accessID);
		if (!d)
            goto Cleanup;
	}

	if (!d->numberOfClients)
	{
        fRv = TRUE;    // no clients so nothing to do
        goto Cleanup;
	}

    // by default we warn when running in user context
    d->fShowWarningAgain = TRUE;

	if (client)
    {
		c = client;
    }
	else
	{
        c = (umclient_tsp)AccessIndependentMemory(
								UMC_CLIENT_FILE, 
								sizeof(umclient_ts)*MAX_NUMBER_OF_CLIENTS, 
								FILE_MAP_ALL_ACCESS, 
								&accessID2);
		if (!c)
            goto Cleanup;
	}

    //
    // Read utilman settings data.  Get "Start when UtilMan starts" from HKLM 
    // and "Start when I lock desktop" from HKCU
    //

	for (i = 0; i < d->numberOfClients; i++)
    {
        c[i].user.fStartWithUtilityManager = FALSE;
        c[i].user.fStartOnLockDesktop = FALSE;
    }

    // "Start when UtilMan starts" settings...

	dwRv = RegOpenKeyEx(HKEY_LOCAL_MACHINE
                , UM_REGISTRY_KEY
                , 0, KEY_READ
                , &hHKLM);

	if (dwRv == ERROR_SUCCESS)
	{
	    for (i = 0; i < d->numberOfClients; i++)
	    {
            RegGetUMDwordValue(hHKLM
                    , c[i].machine.ApplicationName
                    , UMR_VALUE_STARTUM
                    , &c[i].user.fStartWithUtilityManager);
	    }
	    RegCloseKey(hHKLM);
    }

    // "Start when I lock my desktop" and "Start when I log on" settings...

    // At this point, if UtilMan was started before a user logged on, HKCU points
    // to HKEY_USERS\.DEFAULT.  We need it to point to the logged on user's hive so
    // we can manage the registry for the logged on user.  Impersonate the logged on user
    // then use new W2K function RegOpenCurrentUser to get us to the correct registry hive.
    // Note:  GetUserAccessToken() will fail if UtilMan was started from the command
    // line (which is supported for DEBUG only).  In that case, we *are* the user and 
    // don't have to impersonte.

    hImpersonateToken = GetUserAccessToken(TRUE, &fError);
    if (hImpersonateToken)
    {
        if (ImpersonateLoggedOnUser(hImpersonateToken))
        {
            HKEY hkeyUser;
            dwRv = RegOpenCurrentUser(KEY_READ, &hkeyUser);

            if (dwRv == ERROR_SUCCESS)
            {
	            dwRv = RegOpenKeyEx(hkeyUser
                            , UM_HKCU_REGISTRY_KEY
                            , 0, KEY_READ
                            , &hHKCU);

	            if (dwRv == ERROR_SUCCESS)
	            {
	                for (i = 0; i < d->numberOfClients; i++)
	                {
                        RegGetUMDwordValue(hHKCU
                            , c[i].machine.ApplicationName
                            , UMR_VALUE_STARTLOCK
                            , &c[i].user.fStartOnLockDesktop);
	                }
                    RegCloseKey(hHKCU);
	            }
                RegCloseKey(hkeyUser);
            }
            RevertToSelf();
        }
        CloseHandle(hImpersonateToken);

        // Set the start at logon flag based on whether the user has a startup link
        // Note:  The could be done inside the client loop above but LinkExists will
        // also try to impersonate the logged on user.
	    for (i = 0; i < d->numberOfClients; i++)
	    {
            c[i].user.fStartAtLogon = LinkExists(c[i].machine.ApplicationName);
	    }
    } 
	else if (IsInteractiveUser())
    {
	    dwRv = RegOpenKeyEx(HKEY_CURRENT_USER
                    , UM_HKCU_REGISTRY_KEY
                    , 0, KEY_READ
                    , &hHKCU);

	    if (dwRv == ERROR_SUCCESS)
	    {
            // if we're in user context then update warning flag
		    DWORD dwLen = sizeof(DWORD);
            DWORD dwType;
		    dwRv = RegQueryValueEx(
                          hHKCU
                        , UMR_VALUE_SHOWWARNING
                        , NULL, &dwType
                        , (LPBYTE)&d->fShowWarningAgain
                        , &dwLen);

            if (dwRv != ERROR_SUCCESS)
                d->fShowWarningAgain = TRUE;

	        for (i = 0; i < d->numberOfClients; i++)
	        {
                RegGetUMDwordValue(hHKCU
                    , c[i].machine.ApplicationName
                    , UMR_VALUE_STARTLOCK
                    , &c[i].user.fStartOnLockDesktop);

                c[i].user.fStartAtLogon = LinkExists(c[i].machine.ApplicationName);
	        }
            RegCloseKey(hHKCU);
	    }
    }


    fRv = TRUE;

Cleanup:
	if (!header && d)
  		UnAccessIndependentMemory(d, accessID);
 	if (!client && c)
   		UnAccessIndependentMemory(c, accessID2);

	return fRv;
}

BOOL IsDialogDisplayed()
{
    if (GetUIUtilman())
    {
        // Check if the UI dialog process is still up
        DWORD dwExitCode;
        if (GetExitCodeProcess(GetUIUtilman(), &dwExitCode))
        {
            if (dwExitCode != STILL_ACTIVE)
            {
                ResetUIUtilman();
            }
        }
    }
    
    // Check both cases since user may dismiss one UI then quickly bring up another 

    if (!GetUIUtilman())
    {
        // Check if there is a new one running that we need to pick up
        HANDLE hProcess;
        FindProcess(UTILMAN_MODULE, &hProcess);
        SetUIUtilman(hProcess);
    }

    return (GetUIUtilman())?TRUE:FALSE;
}

// ----------------------------------------------------------------------------
// UMTimerProc - Timer procedure called from utilman's timer.  The main purpose
//               of this timer is to pick up any applications the are not started
//               from utilman.  We can restart these if the user switches sessions
//               (or locks) then comes back to this session.  We also detect if an
//               instance of the utilman UI is running.
//
VOID CALLBACK UMTimerProc(HWND hwnd,UINT uMsg,UINT_PTR idEvent,DWORD dwTime)
{
	umc_header_tsp d;
	umclient_tsp c;
	DWORD_PTR accessID,accessID2;

    //
    // check the applets we control 
    //

	d = (umc_header_tsp)AccessIndependentMemory(
							UMC_HEADER_FILE, 
							sizeof(umc_header_ts), 
							FILE_MAP_ALL_ACCESS, 
							&accessID);

	if (d && d->numberOfClients)
    {
	    c = (umclient_tsp)AccessIndependentMemory(
                                UMC_CLIENT_FILE, 
                                sizeof(umclient_ts)*MAX_NUMBER_OF_CLIENTS, 
								FILE_MAP_ALL_ACCESS, 
                                &accessID2);
	    if (c)
	    {
            CheckStatus(c, d->numberOfClients);
	        UnAccessIndependentMemory(c, accessID2);
	    }

    }

    if (d)
    {
	    UnAccessIndependentMemory(d, accessID);
    }

    // 
    // check the out-of-proc utilman that displays UI
    //

    IsDialogDisplayed();
}
// ---------------------------------

__inline void ReplaceDisplayName(LPTSTR szName, int iRID)
{
	TCHAR szBuf[MAX_APPLICATION_NAME_LEN];
	if (LoadString(hInstance, iRID, szBuf, MAX_APPLICATION_NAME_LEN))
		lstrcpy(szName, szBuf);
}

static VOID	CorrectClientControlCode(umclient_tsp c, DWORD i)
{
	DWORD j;

	// init accelerator key code to not defined
	c[i].machine.AcceleratorKey = ACC_KEY_NONE;

	if (c[i].machine.ClientControlCode < UM_SERVICE_CONTROL_MIN_RESERVED)
	{
		c[i].machine.ClientControlCode = 0;
		return;
	}

	if (IsMSClient(c[i].machine.ClientControlCode))
	{
		TCHAR szBuf[MAX_APPLICATION_NAME_LEN];

		// Microsoft Clients
		if ( lstrcmp( c[i].machine.ApplicationName, TEXT("Magnifier") ) == 0 )
		{
			// Make localization easier; don't require them to localize registry entries.
			// Non-MS applets will have to localize their entries.

			ReplaceDisplayName(c[i].machine.DisplayName, IDS_DISPLAY_NAME_MAGNIFIER);

			c[i].machine.AcceleratorKey = VK_F2;	// hard-wired accelerator keys
			return;									// only for WinLogon desktop
		}
		else if ( lstrcmp( c[i].machine.ApplicationName, TEXT("Narrator") ) == 0 ) 
		{
			// Make localization easier; don't require them to localize registry entries.
			// Non-MS applets will have to localize their entries.

			ReplaceDisplayName(c[i].machine.DisplayName, IDS_DISPLAY_NAME_NARRATOR);

			c[i].machine.AcceleratorKey = VK_F3;
			return;
		}
		else if ( lstrcmp( c[i].machine.ApplicationName, TEXT("On-Screen Keyboard") ) == 0 ) 
		{
			// Make localization easier; don't require them to localize registry entries.
			// Non-MS applets will have to localize their entries.

			ReplaceDisplayName(c[i].machine.DisplayName, IDS_DISPLAY_NAME_OSK);

			c[i].machine.AcceleratorKey = VK_F4;
			return;
		}
		// non-trusted
		else
		{
			c[i].machine.ClientControlCode = 0;
			return;
		}
	}

	if (c[i].machine.ClientControlCode > UM_SERVICE_CONTROL_LASTCLIENT)
	{
		c[i].machine.ClientControlCode = 0;
		return;
	}
	
	for (j = 0; j < i; j++)
	{
		if (c[j].machine.ClientControlCode == c[i].machine.ClientControlCode)
		{
			c[i].machine.ClientControlCode = 0;
			return;
		}
	}
}//CorrectClientControlCode
// ---------------------------------

static VOID	CorrectAllClientControlCodes(umclient_tsp c, DWORD max)
{
DWORD i, j;
DWORD ccc[UM_SERVICE_CONTROL_LASTCLIENT+1];
  memset(ccc,0,sizeof(DWORD)*(UM_SERVICE_CONTROL_LASTCLIENT+1));
	for (i = 0; i < max; i++)
	{
		if (c[i].machine.ClientControlCode)
			ccc[c[i].machine.ClientControlCode] = 1;
	}
	for (i = 0; i < max; i++)
	{
		if (!c[i].machine.ClientControlCode)
		{
			for (j = UM_SERVICE_CONTROL_FIRSTCLIENT; j <= UM_SERVICE_CONTROL_LASTCLIENT; j++)
			{
				if (!ccc[j])
				{
					c[i].machine.ClientControlCode = j;
					ChangeClientControlCode(c[i].machine.ApplicationName,j);
					ccc[j] = 1;
					break;
				}
			}
		}
	}
}//CorrectAllClientControlCodes
// ---------------------------------

static VOID	ChangeClientControlCode(LPTSTR ApplicationName,DWORD ClientControlCode)
{
	HKEY hKey, sKey;
	DWORD ec, val;
	ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE, UM_REGISTRY_KEY,0,KEY_ALL_ACCESS,&hKey);

	if (ec != ERROR_SUCCESS)
		return;
	
	ec = RegOpenKeyEx(hKey,ApplicationName,0,KEY_ALL_ACCESS,&sKey);
	
	if (ec != ERROR_SUCCESS)
	{
		RegCloseKey(hKey);
		return;
	}
	
	val = ClientControlCode;
	RegSetValueEx(sKey,UMR_VALUE_CCC,0,REG_DWORD,(BYTE *)&val,sizeof(DWORD));
	RegCloseKey(sKey);
	RegCloseKey(hKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\console.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    console.h

Abstract:

    This module contains the definitions for the console applet

Author:

    Jerry Shea (jerrysh) Feb-3-1992

Revision History:

--*/

#include "font.h"
#include "doshelp.h"


//
// Icon ID
//

#define IDI_CONSOLE                   1


//
// String table constants
//

#define IDS_NAME                      1
#define IDS_INFO                      2
#define IDS_TITLE                     3
#define IDS_RASTERFONT                4
#define IDS_FONTSIZE                  5
#define IDS_SELECTEDFONT              6
#define IDS_SAVE                      7
#define IDS_LINKERRCAP                8
#define IDS_LINKERROR                 9
#define IDS_WARNING                  10


//
// Global Variables
//

extern HINSTANCE  ghInstance;
extern PCONSOLE_STATE_INFO gpStateInfo;
extern PFONT_INFO FontInfo;
extern ULONG      NumberOfFonts;
extern ULONG      CurrentFontIndex;
extern ULONG      DefaultFontIndex;
extern TCHAR      DefaultFaceName[];
extern COORD      DefaultFontSize;
extern BYTE       DefaultFontFamily;
extern TCHAR      szPreviewText[];
extern PFACENODE  gpFaceNames;
extern BOOL       gbEnumerateFaces;
extern LONG       gcxScreen;
extern LONG       gcyScreen;

#if defined(FE_SB)
extern UINT OEMCP;
extern BOOL gfFESystem;
extern BOOL fChangeCodePage;


NTSTATUS
MakeAltRasterFont(
    UINT CodePage,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPTSTR AltFaceName
    );

NTSTATUS
InitializeDbcsMisc(
    VOID
    );

BYTE
CodePageToCharSet(
    UINT CodePage
    );

LPTTFONTLIST
SearchTTFont(
    LPTSTR ptszFace,
    BOOL   fCodePage,
    UINT   CodePage
    );

BOOL
IsAvailableTTFont(
    LPTSTR ptszFace
    );

BOOL
IsAvailableTTFontCP(
    LPWSTR pwszFace,
    UINT CodePage
    );

BOOL
IsDisableBoldTTFont(
    LPTSTR ptszFace
    );

LPTSTR
GetAltFaceName(
    LPTSTR ptszFace
    );

NTSTATUS
DestroyDbcsMisc(
    VOID
    );

int
LanguageListCreate(
    HWND hDlg,
    UINT CodePage
    );

int
LanguageDisplay(
    HWND hDlg,
    UINT CodePage
    ) ;

//
// registry.c
//
NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    );

NTSTATUS
MyRegEnumValue(
    IN HANDLE hKey,
    IN DWORD dwIndex,
    OUT DWORD dwValueLength,
    OUT LPWSTR lpValueName,
    OUT DWORD dwDataLength,
    OUT LPBYTE lpData
    );
#endif

//
// Function prototypes
//

INT_PTR ConsolePropertySheet(HWND hWnd);
BOOL    RegisterClasses(HANDLE hModule);
void    UnregisterClasses(HANDLE hModule);
INT_PTR FontDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
PCONSOLE_STATE_INFO InitRegistryValues(VOID);
DWORD   GetRegistryValues(PCONSOLE_STATE_INFO StateInfo);
VOID    SetRegistryValues(PCONSOLE_STATE_INFO StateInfo, DWORD dwPage);
PCONSOLE_STATE_INFO InitStateValues(HANDLE hMap);
PCONSOLE_STATE_INFO ReadStateValues(HANDLE hMap);
BOOL    WriteStateValues(PCONSOLE_STATE_INFO pStateInfo);
LRESULT ColorControlProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
LRESULT FontPreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
LRESULT PreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CommonDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
VOID    EndDlgPage(HWND hDlg);
BOOL    UpdateStateInfo(HWND hDlg, UINT Item, int Value);
BOOL    WereWeStartedFromALnk();
BOOL    SetLinkValues( PCONSOLE_STATE_INFO StateInfo );

//
// Macros
//

#define NELEM(array) (sizeof(array)/sizeof(array[0]))
#define AttrToRGB(Attr) (gpStateInfo->ColorTable[(Attr) & 0x0F])
#define ScreenTextColor(pStateInfo) \
            (AttrToRGB(LOBYTE(pStateInfo->ScreenAttributes) & 0x0F))
#define ScreenBkColor(pStateInfo) \
            (AttrToRGB(LOBYTE(pStateInfo->ScreenAttributes >> 4)))
#define PopupTextColor(pStateInfo) \
            (AttrToRGB(LOBYTE(pStateInfo->PopupAttributes) & 0x0F))
#define PopupBkColor(pStateInfo) \
            (AttrToRGB(LOBYTE(pStateInfo->PopupAttributes >> 4)))

#ifdef DEBUG_PRINT
  #define _DBGFONTS  0x00000001
  #define _DBGFONTS2 0x00000002
  #define _DBGCHARS  0x00000004
  #define _DBGOUTPUT 0x00000008
  #define _DBGALL    0xFFFFFFFF
  extern ULONG gDebugFlag;

  #define DBGFONTS(_params_)  {if (gDebugFlag & _DBGFONTS) DbgPrint _params_ ; }
  #define DBGFONTS2(_params_) {if (gDebugFlag & _DBGFONTS2)DbgPrint _params_ ; }
  #define DBGCHARS(_params_)  {if (gDebugFlag & _DBGCHARS) DbgPrint _params_ ; }
  #define DBGOUTPUT(_params_) {if (gDebugFlag & _DBGOUTPUT)DbgPrint _params_ ; }
  #define DBGPRINT(_params_)  DbgPrint _params_
#else
  #define DBGFONTS(_params_)
  #define DBGFONTS2(_params_)
  #define DBGCHARS(_params_)
  #define DBGOUTPUT(_params_)
  #define DBGPRINT(_params_)
#endif

#ifdef FE_SB
// Macro definitions that handle codepages
//
#define CP_US       (UINT)437
#define CP_JPN      (UINT)932
#define CP_WANSUNG  (UINT)949
#define CP_TC       (UINT)950
#define CP_SC       (UINT)936

#define IsBilingualCP(cp) ((cp)==CP_JPN || (cp)==CP_WANSUNG)
#define IsFarEastCP(cp) ((cp)==CP_JPN || (cp)==CP_WANSUNG || (cp)==CP_TC || (cp)==CP_SC)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\console.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    menu.c

Abstract:

        This file implements the system menu management.

Author:

    Therese Stowell (thereses) Jan-24-1992 (swiped from Win3.1)

--*/

#include "precomp.h"
#pragma hdrstop


BOOL InEM_UNDO=FALSE;

BYTE ColorArray[4];
int Index;

BOOL gbSaveToRegistry;
BOOL gbWriteToConsole;
BOOL gbStartedFromLink;
LONG gcxScreen;
LONG gcyScreen;
UINT gnCurrentPage;

PCONSOLE_STATE_INFO gpStateInfo;
BOOL g_fAutoComplete;
BOOL g_fSaveAutoCompleteState;


/*
 *  Context Help Ids.
 */
CONST DWORD gaConsoleHelpIds[] =
{
    IDD_WINDOWED,               IDH_DOS_SCREEN_USAGE_WINDOW,
    IDD_FULLSCREEN,             IDH_DOS_SCREEN_USAGE_FULL,
    IDD_DISPLAY_GROUPBOX,       -1,
    IDD_QUICKEDIT,              IDH_CONSOLE_OPTIONS_QUICK_EDIT,
    IDD_INSERT,                 IDH_CONSOLE_OPTIONS_INSERT,
    IDD_CURSOR_SMALL,           IDH_CONSOLE_OPTIONS_CURSOR,
    IDD_CURSOR_MEDIUM,          IDH_CONSOLE_OPTIONS_CURSOR,
    IDD_CURSOR_LARGE,           IDH_CONSOLE_OPTIONS_CURSOR,
    IDD_HISTORY_SIZE,           IDH_CONSOLE_OPTIONS_BUFF_SIZE,
    IDD_HISTORY_SIZESCROLL,     IDH_CONSOLE_OPTIONS_BUFF_SIZE,
    IDD_HISTORY_NUM,            IDH_CONSOLE_OPTIONS_BUFF_NUM,
    IDD_HISTORY_NUMSCROLL,      IDH_CONSOLE_OPTIONS_BUFF_NUM,
    IDD_HISTORY_NODUP,          IDH_CONSOLE_OPTIONS_DISCARD_DUPS,
#if defined(FE_SB)
    IDD_LANGUAGELIST,           IDH_CONSOLE_OPTIONS_LANGUAGE,
    IDD_LANGUAGE,               IDH_CONSOLE_OPTIONS_LANGUAGE,
#endif
    IDD_STATIC,                 IDH_CONSOLE_FONT_FONT,
    IDD_FACENAME,               IDH_CONSOLE_FONT_FONT,
    IDD_BOLDFONT,               IDH_CONSOLE_FONT_BOLD_FONTS,
    IDD_PREVIEWLABEL,           IDH_DOS_FONT_WINDOW_PREVIEW,
    IDD_PREVIEWWINDOW,          IDH_DOS_FONT_WINDOW_PREVIEW,
    IDD_GROUP,                  IDH_DOS_FONT_FONT_PREVIEW,
    IDD_STATIC2,                IDH_DOS_FONT_FONT_PREVIEW,
    IDD_STATIC3,                IDH_DOS_FONT_FONT_PREVIEW,
    IDD_STATIC4,                IDH_DOS_FONT_FONT_PREVIEW,
    IDD_FONTWIDTH,              IDH_DOS_FONT_FONT_PREVIEW,
    IDD_FONTHEIGHT,             IDH_DOS_FONT_FONT_PREVIEW,
    IDD_FONTWINDOW,             IDH_DOS_FONT_FONT_PREVIEW,
    IDD_FONTSIZE,               IDH_DOS_FONT_SIZE,
    IDD_POINTSLIST,             IDH_DOS_FONT_SIZE,
    IDD_PIXELSLIST,             IDH_DOS_FONT_SIZE,
    IDD_SCRBUF_WIDTH,           IDH_CONSOLE_SIZE_BUFF_WIDTH,
    IDD_SCRBUF_WIDTHSCROLL,     IDH_CONSOLE_SIZE_BUFF_WIDTH,
    IDD_SCRBUF_HEIGHT,          IDH_CONSOLE_SIZE_BUFF_HEIGHT,
    IDD_SCRBUF_HEIGHTSCROLL,    IDH_CONSOLE_SIZE_BUFF_HEIGHT,
    IDD_WINDOW_WIDTH,           IDH_CONSOLE_SIZE_WIN_WIDTH,
    IDD_WINDOW_WIDTHSCROLL,     IDH_CONSOLE_SIZE_WIN_WIDTH,
    IDD_WINDOW_HEIGHT,          IDH_CONSOLE_SIZE_WIN_HEIGHT,
    IDD_WINDOW_HEIGHTSCROLL,    IDH_CONSOLE_SIZE_WIN_HEIGHT,
    IDD_WINDOW_POSX,            IDH_CONSOLE_SIZE_POS_LEFT,
    IDD_WINDOW_POSXSCROLL,      IDH_CONSOLE_SIZE_POS_LEFT,
    IDD_WINDOW_POSY,            IDH_CONSOLE_SIZE_POS_TOP,
    IDD_WINDOW_POSYSCROLL,      IDH_CONSOLE_SIZE_POS_TOP,
    IDD_AUTO_POSITION,          IDH_CONSOLE_SIZE_LET_SYS,
    IDD_COLOR_SCREEN_TEXT,      IDH_CONSOLE_COLOR_SCR_TEXT,
    IDD_COLOR_SCREEN_BKGND,     IDH_CONSOLE_COLOR_SCR_BACK,
    IDD_COLOR_POPUP_TEXT,       IDH_CONSOLE_COLOR_POPUP_TEXT,
    IDD_COLOR_POPUP_BKGND,      IDH_CONSOLE_COLOR_POPUP_BACK,
    IDD_COLOR_1,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_2,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_3,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_4,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_5,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_6,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_7,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_8,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_9,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_10,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_11,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_12,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_13,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_14,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_15,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_16,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_SCREEN_COLORS,    IDH_CONSOLE_COLOR_SCR_COLORS,
    IDD_COLOR_POPUP_COLORS,     IDH_CONSOLE_COLOR_WIN_COLORS,
    IDD_COLOR_RED,              IDH_CONSOLE_COLOR_RED,
    IDD_COLOR_REDSCROLL,        IDH_CONSOLE_COLOR_RED,
    IDD_COLOR_GREEN,            IDH_CONSOLE_COLOR_RED,
    IDD_COLOR_GREENSCROLL,      IDH_CONSOLE_COLOR_RED,
    IDD_COLOR_BLUE,             IDH_CONSOLE_COLOR_RED,
    IDD_COLOR_BLUESCROLL,       IDH_CONSOLE_COLOR_RED,
    IDD_AUTOCOMPLETE,           IDH_CONSOLE_OPTIONS_AUTOCOMPLETE,
    0,                          0
};

VOID
UpdateItem(
    HWND hDlg,
    UINT item,
    UINT nNum
    )
{
    SetDlgItemInt(hDlg, item, nNum, TRUE);
    SendDlgItemMessage(hDlg, item, EM_SETSEL, 0, (DWORD)-1);
}


BOOL
CheckNum(
    HWND hDlg,
    UINT Item)
{
    int i;
    TCHAR szNum[5];
    BOOL fSigned;

    if (Item == IDD_WINDOW_POSX || Item == IDD_WINDOW_POSY) {
        fSigned = TRUE;
    } else {
        fSigned = FALSE;
    }

    GetDlgItemText(hDlg, Item, szNum, NELEM(szNum));
    for (i = 0; szNum[i]; i++) {
        if (!iswdigit(szNum[i]) && (!fSigned || i > 0 || szNum[i] != TEXT('-')))
            return FALSE;
    }
    return TRUE;
}


INT_PTR
CommonDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (wMsg) {
    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)gaConsoleHelpIds);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)gaConsoleHelpIds);
        break;

    default:
        break;
    }
    return FALSE;
}


INT_PTR
WINAPI
SaveQueryDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HFONT hFont;
    HWND  hChild;
    HWND  hCreator;

    switch (wMsg) {
    case WM_INITDIALOG:
        /*
         * Save the handle of the window that created us
         */
        hCreator = (HWND)lParam;
        SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

        /*
         * Get the font used in other controls
         */
        hChild = GetWindow(hCreator, GW_CHILD);
        hFont = GetWindowFont(hChild);

        /*
         * Now apply it to our controls
         */
        hChild = GetWindow(hDlg, GW_CHILD);
        while (hChild != NULL) {
            SetWindowFont(hChild, hFont, TRUE);
            hChild = GetWindow(hChild, GW_HWNDNEXT);
        }

        CheckRadioButton(hDlg, IDD_APPLY, IDD_SAVE, IDD_APPLY);
        gbSaveToRegistry = FALSE;
        gbWriteToConsole = FALSE;
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if (IsDlgButtonChecked(hDlg, IDD_SAVE)) {
                gbSaveToRegistry = TRUE;
            }
            gbWriteToConsole = TRUE;
            EndDialog(hDlg, PSNRET_NOERROR);
            return TRUE;
        case IDCANCEL:
            EndDialog(hDlg, PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }
        break;

    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
        /*
         * Let the window who created us decide what colors to use
         */
        hCreator = (HWND)GetWindowLongPtr(hDlg, GWLP_USERDATA);
        return SendMessage(hCreator, wMsg, wParam, lParam);
    }
    return FALSE;
}


UINT
ConsolePropSheetProc(
    HWND hDlg,
    UINT wMsg,
    LPARAM lParam
    )
{
    DWORD dwExStyle;

    switch (wMsg) {
    case PSCB_INITIALIZED:
        /*
         * If we're connected to the server, tell him we're starting
         */
        if (gpStateInfo->hWnd != NULL) {
            SendMessage(gpStateInfo->hWnd, CM_PROPERTIES_START, (WPARAM)hDlg, 0);
        }
        break;
    default:
        break;
    }

    return 0;
}


VOID
EndDlgPage(
    HWND hDlg
    )
{
    HWND hParent;
    HWND hTabCtrl;
    INT_PTR Result;

    /*
     * If we've already made a decision, we're done
     */
    if (gbWriteToConsole || gbSaveToRegistry) {
        SetDlgMsgResult(hDlg, PSN_APPLY, PSNRET_NOERROR);
        return;
    }

    /*
     * Get the current page number
     */
    hParent = GetParent(hDlg);
    hTabCtrl = PropSheet_GetTabControl(hParent);
    gnCurrentPage = TabCtrl_GetCurSel(hTabCtrl);

    /*
     * If we're not connected to the server, we're done
     */
    if (gpStateInfo->hWnd == NULL) {
        gbSaveToRegistry = TRUE;
        SetDlgMsgResult(hDlg, PSN_APPLY, PSNRET_NOERROR);
        return;
    }

    /*
     * Check to show the Apply/Save dialog box
     */
    if (gbStartedFromLink)
    {
        Result = DialogBoxParam(ghInstance, MAKEINTRESOURCE(DID_SAVE_QUERY_LINK),
                                GetParent(hDlg), SaveQueryDlgProc, (LPARAM)hDlg);

        SetDlgMsgResult(hDlg, PSN_APPLY, Result);
    }
    else
    {
        Result = DialogBoxParam(ghInstance, MAKEINTRESOURCE(DID_SAVE_QUERY),
                                GetParent(hDlg), SaveQueryDlgProc, (LPARAM)hDlg);

        SetDlgMsgResult(hDlg, PSN_APPLY, Result);
    }
    return;
}


LRESULT
ColorControlProc(
    HWND hColor,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Window proc for the color buttons

--*/

{
    PAINTSTRUCT ps;
    int ColorId;
    RECT rColor;
    RECT rTemp;
    HBRUSH hbr;
    HDC hdc;
    HWND hWnd;
    HWND hDlg;
    COLORREF rgbBrush;

    ColorId = GetWindowLong(hColor, GWL_ID);
    hDlg = GetParent(hColor);

    switch (wMsg) {
    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTTAB;
        break;
    case WM_SETFOCUS:
        if (ColorArray[Index] != (BYTE)(ColorId - IDD_COLOR_1)) {
            hWnd = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);
            SetFocus(hWnd);
        }
        // Fall through
    case WM_KILLFOCUS:
        hdc = GetDC(hDlg);
        hWnd = GetDlgItem(hDlg, IDD_COLOR_1);
        GetWindowRect(hWnd, &rColor);
        hWnd = GetDlgItem(hDlg, IDD_COLOR_16);
        GetWindowRect(hWnd, &rTemp);
        rColor.right = rTemp.right;
        ScreenToClient(hDlg, (LPPOINT)&rColor.left);
        ScreenToClient(hDlg, (LPPOINT)&rColor.right);
        InflateRect(&rColor, 2, 2);
        DrawFocusRect(hdc, &rColor);
        ReleaseDC(hDlg, hdc);
        break;
    case WM_KEYDOWN:
        switch (wParam) {
        case VK_UP:
        case VK_LEFT:
            if (ColorId > IDD_COLOR_1) {
                SendMessage(hDlg, CM_SETCOLOR,
                            ColorId - 1 - IDD_COLOR_1, (LPARAM)hColor);
            }
            break;
        case VK_DOWN:
        case VK_RIGHT:
            if (ColorId < IDD_COLOR_16) {
                SendMessage(hDlg, CM_SETCOLOR,
                            ColorId + 1 - IDD_COLOR_1, (LPARAM)hColor);
            }
            break;
        case VK_TAB:
            hWnd = GetDlgItem(hDlg, IDD_COLOR_1);
            hWnd = GetNextDlgTabItem(hDlg, hWnd, GetKeyState(VK_SHIFT) < 0);
            SetFocus(hWnd);
            break;
        default:
            return DefWindowProc(hColor, wMsg, wParam, lParam);
        }
        break;
    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
        SendMessage(hDlg, CM_SETCOLOR,
                    ColorId - IDD_COLOR_1, (LPARAM)hColor);
        break;
    case WM_PAINT:
        BeginPaint(hColor, &ps);
        GetClientRect(hColor, &rColor);
        rgbBrush = GetNearestColor(ps.hdc, AttrToRGB(ColorId-IDD_COLOR_1));
        if ((hbr = CreateSolidBrush(rgbBrush)) != NULL) {
            //
            // are we the selected color for the current object?
            //
            if (ColorArray[Index] == (BYTE)(ColorId - IDD_COLOR_1)) {

                //
                // put current values in dialog box
                //
                UpdateItem(hDlg, IDD_COLOR_RED,
                           GetRValue(AttrToRGB(ColorArray[Index])));
                UpdateItem(hDlg, IDD_COLOR_GREEN,
                           GetGValue(AttrToRGB(ColorArray[Index])));
                UpdateItem(hDlg, IDD_COLOR_BLUE,
                           GetBValue(AttrToRGB(ColorArray[Index])));

                //
                // highlight the selected color
                //
                FrameRect(ps.hdc, &rColor, GetStockObject(BLACK_BRUSH));
                InflateRect(&rColor, -1, -1);
                FrameRect(ps.hdc, &rColor, GetStockObject(BLACK_BRUSH));
            }
            InflateRect(&rColor, -1, -1);
            FillRect(ps.hdc, &rColor, hbr);
            DeleteObject(hbr);
        }
        EndPaint(hColor, &ps);
        break;
    default:
        return DefWindowProc(hColor, wMsg, wParam, lParam);
        break;
    }
    return TRUE;
}


INT_PTR
WINAPI
ColorDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the color selection dialog box.

--*/

{
    UINT Value;
    UINT Red;
    UINT Green;
    UINT Blue;
    UINT Item;
    HWND hWnd;
    HWND hWndOld;
    BOOL bOK;

    switch (wMsg) {
    case WM_INITDIALOG:
        ColorArray[IDD_COLOR_SCREEN_TEXT - IDD_COLOR_SCREEN_TEXT] =
                LOBYTE(gpStateInfo->ScreenAttributes) & 0x0F;
        ColorArray[IDD_COLOR_SCREEN_BKGND - IDD_COLOR_SCREEN_TEXT] =
                LOBYTE(gpStateInfo->ScreenAttributes >> 4);
        ColorArray[IDD_COLOR_POPUP_TEXT - IDD_COLOR_SCREEN_TEXT] =
                LOBYTE(gpStateInfo->PopupAttributes) & 0x0F;
        ColorArray[IDD_COLOR_POPUP_BKGND - IDD_COLOR_SCREEN_TEXT] =
                LOBYTE(gpStateInfo->PopupAttributes >> 4);
        CheckRadioButton(hDlg,IDD_COLOR_SCREEN_TEXT,IDD_COLOR_POPUP_BKGND,IDD_COLOR_SCREEN_BKGND);
        Index = IDD_COLOR_SCREEN_BKGND - IDD_COLOR_SCREEN_TEXT;

        // initialize size of edit controls

        SendDlgItemMessage(hDlg, IDD_COLOR_RED, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage(hDlg, IDD_COLOR_GREEN, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage(hDlg, IDD_COLOR_BLUE, EM_LIMITTEXT, 3, 0L);

        // initialize arrow controls

        SendDlgItemMessage(hDlg, IDD_COLOR_REDSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(255, 0));
        SendDlgItemMessage(hDlg, IDD_COLOR_REDSCROLL, UDM_SETPOS, 0,
                           MAKELONG(GetRValue(AttrToRGB(ColorArray[Index])), 0));
        SendDlgItemMessage(hDlg, IDD_COLOR_GREENSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(255, 0));
        SendDlgItemMessage(hDlg, IDD_COLOR_GREENSCROLL, UDM_SETPOS, 0,
                           MAKELONG(GetGValue(AttrToRGB(ColorArray[Index])), 0));
        SendDlgItemMessage(hDlg, IDD_COLOR_BLUESCROLL, UDM_SETRANGE, 0,
                           MAKELONG(255, 0));
        SendDlgItemMessage(hDlg, IDD_COLOR_BLUESCROLL, UDM_SETPOS, 0,
                           MAKELONG(GetBValue(AttrToRGB(ColorArray[Index])), 0));

        return TRUE;

    case WM_COMMAND:
        Item = LOWORD(wParam);
        switch (Item) {
        case IDD_COLOR_SCREEN_TEXT:
        case IDD_COLOR_SCREEN_BKGND:
        case IDD_COLOR_POPUP_TEXT:
        case IDD_COLOR_POPUP_BKGND:
            hWndOld = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);

            Index = Item - IDD_COLOR_SCREEN_TEXT;

            // repaint new color
            hWnd = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);
            InvalidateRect(hWnd, NULL, TRUE);

            // repaint old color
            if (hWndOld != hWnd) {
                InvalidateRect(hWndOld, NULL, TRUE);
            }

            return TRUE;

        case IDD_COLOR_RED:
        case IDD_COLOR_GREEN:
        case IDD_COLOR_BLUE:
            switch (HIWORD(wParam)) {
            case EN_UPDATE:
                if (!CheckNum (hDlg, Item)) {
                    if (!InEM_UNDO) {
                        InEM_UNDO = TRUE;
                        SendMessage((HWND)lParam, EM_UNDO, 0, 0L);
                        InEM_UNDO = FALSE;
                    }
                }
                break;
            case EN_KILLFOCUS:
                /*
                 * Update the state info structure
                 */
                Value = GetDlgItemInt(hDlg, Item, &bOK, TRUE);
                if (bOK) {
                    if (Value > 255) {
                        UpdateItem(hDlg, Item, 255);
                        Value = 255;
                    }
                    if (Item == IDD_COLOR_RED) {
                        Red = Value;
                    } else {
                        Red = GetRValue(AttrToRGB(ColorArray[Index]));
                    }
                    if (Item == IDD_COLOR_GREEN) {
                        Green = Value;
                    } else {
                        Green = GetGValue(AttrToRGB(ColorArray[Index]));
                    }
                    if (Item == IDD_COLOR_BLUE) {
                        Blue = Value;
                    } else {
                        Blue = GetBValue(AttrToRGB(ColorArray[Index]));
                    }
                    UpdateStateInfo(hDlg, ColorArray[Index] + IDD_COLOR_1,
                                    RGB(Red, Green, Blue));
                }

                /*
                 * Update the preview windows with the new value
                 */
                hWnd = GetDlgItem(hDlg, IDD_COLOR_SCREEN_COLORS);
                InvalidateRect(hWnd, NULL, FALSE);
                hWnd = GetDlgItem(hDlg, IDD_COLOR_POPUP_COLORS);
                InvalidateRect(hWnd, NULL, FALSE);
                hWnd = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);
                InvalidateRect(hWnd, NULL, FALSE);
                break;
            }
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            EndDlgPage(hDlg);
            return TRUE;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (Item = GetDlgCtrlID(GetFocus())) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;

    case WM_VSCROLL:
        /*
         * Fake the dialog proc into thinking the edit control just
         * lost focus so it'll update properly
         */
        Item = GetDlgCtrlID((HWND)lParam) - 1;
        SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
        return TRUE;

    case CM_SETCOLOR:
        UpdateStateInfo(hDlg, Index + IDD_COLOR_SCREEN_TEXT, (UINT)wParam);

        hWndOld = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);

        ColorArray[Index] = (BYTE)wParam;

        /* Force the preview window to repaint */

        if (Index < (IDD_COLOR_POPUP_TEXT - IDD_COLOR_SCREEN_TEXT)) {
            hWnd = GetDlgItem(hDlg, IDD_COLOR_SCREEN_COLORS);
        } else {
            hWnd = GetDlgItem(hDlg, IDD_COLOR_POPUP_COLORS);
        }
        InvalidateRect(hWnd, NULL, TRUE);

        // repaint new color
        hWnd = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);
        InvalidateRect(hWnd, NULL, TRUE);
        SetFocus(hWnd);

        // repaint old color
        if (hWndOld != hWnd) {
            InvalidateRect(hWndOld, NULL, TRUE);
        }
        return TRUE;

    default:
        break;
    }
    return CommonDlgProc(hDlg, wMsg, wParam, lParam);
}


int
GetStateInfo(
    HWND hDlg,
    UINT Item,
    BOOL *bOK
    )
{
    int Value = 0;

    *bOK = TRUE;
    switch (Item) {
    case IDD_SCRBUF_WIDTH:
        Value = gpStateInfo->ScreenBufferSize.X;
        break;
    case IDD_SCRBUF_HEIGHT:
        Value = gpStateInfo->ScreenBufferSize.Y;
        break;
    case IDD_WINDOW_WIDTH:
        Value = gpStateInfo->WindowSize.X;
        break;
    case IDD_WINDOW_HEIGHT:
        Value = gpStateInfo->WindowSize.Y;
        break;
    case IDD_WINDOW_POSX:
        Value = gpStateInfo->WindowPosX;
        break;
    case IDD_WINDOW_POSY:
        Value = gpStateInfo->WindowPosY;
        break;
    default:
        *bOK = FALSE;
        break;
    }
    return Value;
}


BOOL
UpdateStateInfo(
    HWND hDlg,
    UINT Item,
    int Value
    )
{
    switch (Item) {
    case IDD_SCRBUF_WIDTH:
        gpStateInfo->ScreenBufferSize.X = (SHORT)Value;
        if (gpStateInfo->WindowSize.X > Value) {
            gpStateInfo->WindowSize.X = (SHORT)Value;
            UpdateItem(hDlg, IDD_WINDOW_WIDTH, Value);
        }
        break;
    case IDD_SCRBUF_HEIGHT:
        gpStateInfo->ScreenBufferSize.Y = (SHORT)Value;
        if (gpStateInfo->WindowSize.Y > Value) {
            gpStateInfo->WindowSize.Y = (SHORT)Value;
            UpdateItem(hDlg, IDD_WINDOW_HEIGHT, Value);
        }
        break;
    case IDD_WINDOW_WIDTH:
        gpStateInfo->WindowSize.X = (SHORT)Value;
        if (gpStateInfo->ScreenBufferSize.X < Value) {
            gpStateInfo->ScreenBufferSize.X = (SHORT)Value;
            UpdateItem(hDlg, IDD_SCRBUF_WIDTH, Value);
        }
        break;
    case IDD_WINDOW_HEIGHT:
        gpStateInfo->WindowSize.Y = (SHORT)Value;
        if (gpStateInfo->ScreenBufferSize.Y < Value) {
            gpStateInfo->ScreenBufferSize.Y = (SHORT)Value;
            UpdateItem(hDlg, IDD_SCRBUF_HEIGHT, Value);
        }
        break;
    case IDD_WINDOW_POSX:
        gpStateInfo->WindowPosX = Value;
        break;
    case IDD_WINDOW_POSY:
        gpStateInfo->WindowPosY = Value;
        break;
    case IDD_AUTO_POSITION:
        gpStateInfo->AutoPosition = Value;
        break;
    case IDD_COLOR_SCREEN_TEXT:
        gpStateInfo->ScreenAttributes =
                    (gpStateInfo->ScreenAttributes & 0xF0) |
                    (Value & 0x0F);
        break;
    case IDD_COLOR_SCREEN_BKGND:
        gpStateInfo->ScreenAttributes =
                    (gpStateInfo->ScreenAttributes & 0x0F) |
                    (Value << 4);
        break;
    case IDD_COLOR_POPUP_TEXT:
        gpStateInfo->PopupAttributes =
                    (gpStateInfo->PopupAttributes & 0xF0) |
                    (Value & 0x0F);
        break;
    case IDD_COLOR_POPUP_BKGND:
        gpStateInfo->PopupAttributes =
                    (gpStateInfo->PopupAttributes & 0x0F) |
                    (Value << 4);
        break;
    case IDD_COLOR_1:
    case IDD_COLOR_2:
    case IDD_COLOR_3:
    case IDD_COLOR_4:
    case IDD_COLOR_5:
    case IDD_COLOR_6:
    case IDD_COLOR_7:
    case IDD_COLOR_8:
    case IDD_COLOR_9:
    case IDD_COLOR_10:
    case IDD_COLOR_11:
    case IDD_COLOR_12:
    case IDD_COLOR_13:
    case IDD_COLOR_14:
    case IDD_COLOR_15:
    case IDD_COLOR_16:
        gpStateInfo->ColorTable[Item - IDD_COLOR_1] = Value;
        break;
#ifdef i386
    case IDD_FULLSCREEN:
        gpStateInfo->FullScreen = TRUE;
        break;
    case IDD_WINDOWED:
        gpStateInfo->FullScreen = FALSE;
        break;
#endif
#if defined(FE_SB)
    case IDD_LANGUAGELIST:
        /*
         * Value is a code page
         */
        gpStateInfo->CodePage = Value;
        break;
#endif
    case IDD_QUICKEDIT:
        gpStateInfo->QuickEdit = Value;
        break;
    case IDD_AUTOCOMPLETE:
        g_fAutoComplete = Value;
        g_fSaveAutoCompleteState = TRUE;
        break;
    case IDD_INSERT:
        gpStateInfo->InsertMode = Value;
        break;
    case IDD_HISTORY_SIZE:
        gpStateInfo->HistoryBufferSize = max(Value, 1);
        break;
    case IDD_HISTORY_NUM:
        gpStateInfo->NumberOfHistoryBuffers = max(Value, 1);
        break;
    case IDD_HISTORY_NODUP:
        gpStateInfo->HistoryNoDup = Value;
        break;
    case IDD_CURSOR_SMALL:
        gpStateInfo->CursorSize = 25;
        break;
    case IDD_CURSOR_MEDIUM:
        gpStateInfo->CursorSize = 50;
        break;
    case IDD_CURSOR_LARGE:
        gpStateInfo->CursorSize = 100;
        break;
    default:
        return FALSE;
    }
    return TRUE;
}


VOID
UpdateWarningMessage(
    HWND hDlg,
    BOOL fLoadString
    )
{
    static WCHAR achFormat[256];
    WCHAR achText[NELEM(achFormat)+4];
    HWND hWnd;
    UINT Value;

    /*
     * Load the format string, if requested.
     */
    if (fLoadString) {
        LoadString(ghInstance, IDS_WARNING, achFormat, NELEM(achFormat));
    }

    /*
     * Put up the warning message if we're using more than 1 Meg
     * of memory per console window, otherwise hide it.
     */
    hWnd = GetDlgItem(hDlg, IDD_WARNING);
    Value = (gpStateInfo->ScreenBufferSize.X *
             gpStateInfo->ScreenBufferSize.Y) / 0x080000;
    if (Value) {
        wsprintf(achText, achFormat, Value);
        SetWindowText(hWnd, achText);
        ShowWindow(hWnd, SW_SHOW);
    } else {
        ShowWindow(hWnd, SW_HIDE);
    }
}


INT_PTR
WINAPI
ScreenSizeDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the screen size dialog box.

--*/

{
    UINT Value;
    UINT Item;
    HWND hWnd;
    BOOL bOK;
    LONG xScreen;
    LONG yScreen;
    LONG cxScreen;
    LONG cyScreen;
    LONG cxFrame;
    LONG cyFrame;

    switch (wMsg) {
    case WM_INITDIALOG:
        // initialize size of edit controls

        SendDlgItemMessage(hDlg, IDD_SCRBUF_WIDTH, EM_LIMITTEXT, 4, 0L);
        SendDlgItemMessage(hDlg, IDD_SCRBUF_HEIGHT, EM_LIMITTEXT, 4, 0L);
        SendDlgItemMessage(hDlg, IDD_WINDOW_WIDTH, EM_LIMITTEXT, 4, 0L);
        SendDlgItemMessage(hDlg, IDD_WINDOW_HEIGHT, EM_LIMITTEXT, 4, 0L);
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSX, EM_LIMITTEXT, 4, 0L);
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSY, EM_LIMITTEXT, 4, 0L);

        // Get some system parameters

        xScreen  = GetSystemMetrics(SM_XVIRTUALSCREEN);
        yScreen  = GetSystemMetrics(SM_YVIRTUALSCREEN);
        cxScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN);
        cyScreen = GetSystemMetrics(SM_CYVIRTUALSCREEN);
        cxFrame  = GetSystemMetrics(SM_CXFRAME);
        cyFrame  = GetSystemMetrics(SM_CYFRAME);

        // initialize arrow controls

        SendDlgItemMessage(hDlg, IDD_SCRBUF_WIDTHSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(9999, 1));
        SendDlgItemMessage(hDlg, IDD_SCRBUF_WIDTHSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->ScreenBufferSize.X, 0));
        SendDlgItemMessage(hDlg, IDD_SCRBUF_HEIGHTSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(9999, 1));
        SendDlgItemMessage(hDlg, IDD_SCRBUF_HEIGHTSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->ScreenBufferSize.Y, 0));
        SendDlgItemMessage(hDlg, IDD_WINDOW_WIDTHSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(9999, 1));
        SendDlgItemMessage(hDlg, IDD_WINDOW_WIDTHSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->WindowSize.X, 0));
        SendDlgItemMessage(hDlg, IDD_WINDOW_HEIGHTSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(9999, 1));
        SendDlgItemMessage(hDlg, IDD_WINDOW_HEIGHTSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->WindowSize.Y, 0));
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSXSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(xScreen + cxScreen - cxFrame, xScreen - cxFrame));
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSXSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->WindowPosX, 0));
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSYSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(yScreen + cyScreen - cyFrame, yScreen - cyFrame));
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSYSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->WindowPosY, 0));

        //
        // put current values in dialog box
        //

        CheckDlgButton(hDlg, IDD_AUTO_POSITION, gpStateInfo->AutoPosition);
        SendMessage(hDlg, WM_COMMAND, IDD_AUTO_POSITION, 0);

        // update the warning message

        UpdateWarningMessage(hDlg, TRUE);

        return TRUE;

    case WM_VSCROLL:
        /*
         * Fake the dialog proc into thinking the edit control just
         * lost focus so it'll update properly
         */
        Item = GetDlgCtrlID((HWND)lParam) - 1;
        SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
        return TRUE;

    case WM_COMMAND:
        Item = LOWORD(wParam);
        switch (Item) {
        case IDD_SCRBUF_WIDTH:
        case IDD_SCRBUF_HEIGHT:
        case IDD_WINDOW_WIDTH:
        case IDD_WINDOW_HEIGHT:
        case IDD_WINDOW_POSX:
        case IDD_WINDOW_POSY:
            switch (HIWORD(wParam)) {
            case EN_UPDATE:
                if (!CheckNum (hDlg, Item)) {
                    if (!InEM_UNDO) {
                        InEM_UNDO = TRUE;
                        SendMessage((HWND)lParam, EM_UNDO, 0, 0L);
                        InEM_UNDO = FALSE;
                    }
                }
                break;
            case EN_KILLFOCUS:
                /*
                 * Update the state info structure
                 */
                Value = (UINT)SendDlgItemMessage(hDlg, Item + 1, UDM_GETPOS, 0, 0);
                if (HIWORD(Value) == 0) {
                    UpdateStateInfo(hDlg, Item, (SHORT)LOWORD(Value));
                } else {
                    Value = GetStateInfo(hDlg, Item, &bOK);
                    if (bOK) {
                        UpdateItem(hDlg, Item, Value);
                    }
                }

                /*
                 * Update the warning message
                 */
                 UpdateWarningMessage(hDlg, FALSE);

                /*
                 * Update the preview window with the new value
                 */
                hWnd = GetDlgItem(hDlg, IDD_PREVIEWWINDOW);
                SendMessage(hWnd, CM_PREVIEW_UPDATE, 0, 0);
                break;
            }
            return TRUE;

        case IDD_AUTO_POSITION:
            Value = IsDlgButtonChecked(hDlg, IDD_AUTO_POSITION);
            UpdateStateInfo(hDlg, IDD_AUTO_POSITION, Value);
            for (Item = IDD_WINDOW_POSX; Item < IDD_AUTO_POSITION; Item++) {
                hWnd = GetDlgItem(hDlg, Item);
                EnableWindow(hWnd, (Value == FALSE));
            }
            break;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            EndDlgPage(hDlg);
            return TRUE;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (Item = GetDlgCtrlID(GetFocus())) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;

    default:
        break;
    }
    return CommonDlgProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR
WINAPI
SettingsDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the settings dialog box.

--*/

{
    UINT Value;
    UINT Item;
    BOOL bOK;
    SYSTEM_INFO SystemInfo;

    switch (wMsg) {
    case WM_INITDIALOG:
        GetSystemInfo(&SystemInfo);
        if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
            if (gpStateInfo->FullScreen) {
                CheckRadioButton(hDlg,IDD_WINDOWED,IDD_FULLSCREEN,IDD_FULLSCREEN);
            } else {
                CheckRadioButton(hDlg,IDD_WINDOWED,IDD_FULLSCREEN,IDD_WINDOWED);
            }
        } else {
            ShowWindow(GetDlgItem(hDlg, IDD_WINDOWED), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDD_FULLSCREEN), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDD_DISPLAY_GROUPBOX), SW_HIDE);
        }

        CheckDlgButton(hDlg, IDD_HISTORY_NODUP, gpStateInfo->HistoryNoDup);
        CheckDlgButton(hDlg, IDD_QUICKEDIT, gpStateInfo->QuickEdit);
        CheckDlgButton(hDlg, IDD_INSERT, gpStateInfo->InsertMode);

        g_fSaveAutoCompleteState = FALSE;
        if (IsWindow(GetDlgItem(hDlg, IDD_AUTOCOMPLETE)))
        {
            CheckDlgButton(hDlg, IDD_AUTOCOMPLETE, g_fAutoComplete);
        }

        // initialize cursor radio buttons

        if (gpStateInfo->CursorSize <= 25) {
            Item = IDD_CURSOR_SMALL;
        } else if (gpStateInfo->CursorSize <= 50) {
            Item = IDD_CURSOR_MEDIUM;
        } else {
            Item = IDD_CURSOR_LARGE;
        }
        CheckRadioButton(hDlg, IDD_CURSOR_SMALL, IDD_CURSOR_LARGE, Item);

        SetDlgItemInt(hDlg, IDD_HISTORY_SIZE, gpStateInfo->HistoryBufferSize,
                      FALSE);
        SendDlgItemMessage(hDlg, IDD_HISTORY_SIZE, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage(hDlg, IDD_HISTORY_SIZESCROLL, UDM_SETRANGE, 0,
                           MAKELONG(999, 1));

        SetDlgItemInt(hDlg, IDD_HISTORY_NUM, gpStateInfo->NumberOfHistoryBuffers,
                      FALSE);
        SendDlgItemMessage(hDlg, IDD_HISTORY_NUM, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage(hDlg, IDD_HISTORY_NUM, EM_SETSEL, 0, (DWORD)-1);
        SendDlgItemMessage(hDlg, IDD_HISTORY_NUMSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(999, 1));

        // FE_SB
        // Let users select Default CodePage.
        // Per request from PMs, this feature should be activated only for FE enabled NT.
        if (gfFESystem) {
            if (gpStateInfo->hWnd != NULL) {
                LanguageDisplay(hDlg, gpStateInfo->CodePage);
            }
            else{
                LanguageListCreate(hDlg, gpStateInfo->CodePage);
            }
        }
        else {
            // If the system is not FE enabled, just disable and hide them.
            HWND LangHwnd = GetDlgItem(hDlg, IDD_LANGUAGELIST);
            if (LangHwnd) {
                EnableWindow(LangHwnd, FALSE);
                ShowWindow(LangHwnd, SW_HIDE);
            }

            LangHwnd = GetDlgItem(hDlg, IDD_LANGUAGE_GROUPBOX);
            if (LangHwnd) {
                ShowWindow(LangHwnd, SW_HIDE);
            }
        }
        // end FE_SB
        return TRUE;

    case WM_COMMAND:
        Item = LOWORD(wParam);
        switch (Item) {
#ifdef i386
        case IDD_WINDOWED:
        case IDD_FULLSCREEN:
            UpdateStateInfo(hDlg, Item, 0);
            return TRUE;
#endif
        // FE_SB
        case IDD_LANGUAGELIST:
            switch (HIWORD(wParam)) {
            case CBN_KILLFOCUS: {
                HWND hWndLanguageCombo;
                LONG lListIndex;

                hWndLanguageCombo = GetDlgItem(hDlg, IDD_LANGUAGELIST);
                lListIndex = (LONG)SendMessage(hWndLanguageCombo, CB_GETCURSEL, 0, 0L);
                Value = (UINT)SendMessage(hWndLanguageCombo, CB_GETITEMDATA, lListIndex, 0L);
                if (Value != -1) {
                    fChangeCodePage = (Value != gpStateInfo->CodePage);
                    UpdateStateInfo(hDlg, Item, Value);
                }
                break;
            }

            default:
                DBGFONTS(("unhandled CBN_%x from POINTSLIST\n",HIWORD(wParam)));
                break;
            }
            return TRUE;
        // end FE_SB
        case IDD_CURSOR_SMALL:
        case IDD_CURSOR_MEDIUM:
        case IDD_CURSOR_LARGE:
            UpdateStateInfo(hDlg, Item, 0);
            return TRUE;

        case IDD_HISTORY_NODUP:
        case IDD_AUTOCOMPLETE:
        case IDD_QUICKEDIT:
        case IDD_INSERT:
            Value = IsDlgButtonChecked(hDlg, Item);
            UpdateStateInfo(hDlg, Item, Value);
            return TRUE;

        case IDD_HISTORY_SIZE:
        case IDD_HISTORY_NUM:
            switch (HIWORD(wParam)) {
            case EN_UPDATE:
                if (!CheckNum(hDlg, Item)) {
                    if (!InEM_UNDO) {
                        InEM_UNDO = TRUE;
                        SendMessage((HWND)lParam, EM_UNDO, 0, 0L);
                        InEM_UNDO = FALSE;
                    }
                }
                break;

            case EN_KILLFOCUS:
                /*
                 * Update the state info structure
                 */
                Value = GetDlgItemInt(hDlg, Item, &bOK, TRUE);
                if (bOK) {
                    UpdateStateInfo(hDlg, Item, Value);
                }
                break;
            }
            return TRUE;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            EndDlgPage(hDlg);
            return TRUE;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (Item = GetDlgCtrlID(GetFocus())) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;

    case WM_VSCROLL:
        /*
         * Fake the dialog proc into thinking the edit control just
         * lost focus so it'll update properly
         */
        Item = GetDlgCtrlID((HWND)lParam) - 1;
        SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
        return TRUE;

    default:
        break;
    }
    return CommonDlgProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR
ConsolePropertySheet(
    IN HWND hWnd
    )

/*++

    Creates the property sheet to change console settings.

--*/

{
    PROPSHEETPAGE psp[4];
    PROPSHEETHEADER psh;
    INT_PTR Result = IDCANCEL;
    WCHAR awchBuffer[MAX_PATH];

    //
    // Initialize the state information
    //

    gpStateInfo = InitStateValues((HANDLE)hWnd);
    if (gpStateInfo == NULL) {
        KdPrint(("CONSOLE: can't get state information\n"));
        return IDCANCEL;
    }

    //
    // Initialize the font cache and current font index
    //

    InitializeFonts();
    CurrentFontIndex = FindCreateFont(gpStateInfo->FontFamily,
                                      gpStateInfo->FaceName,
                                      gpStateInfo->FontSize,
                                      gpStateInfo->FontWeight,
                                      gpStateInfo->CodePage);

    //
    // Get the current page number
    //

    gnCurrentPage = GetRegistryValues(NULL);

    //
    // Initialize the property sheet structures
    //

    RtlZeroMemory(psp, sizeof(psp));

    psp[0].dwSize      = sizeof(PROPSHEETPAGE);
    psp[0].hInstance   = ghInstance;
#if defined(FE_SB) // v-HirShi Nov.20.1996
    if (gpStateInfo->hWnd != NULL) {
        psp[0].pszTemplate = MAKEINTRESOURCE(DID_SETTINGS2);
    }
    else{
        psp[0].pszTemplate = MAKEINTRESOURCE(DID_SETTINGS);
    }
#else
    psp[0].pszTemplate = MAKEINTRESOURCE(DID_SETTINGS);
#endif
    psp[0].pfnDlgProc  = SettingsDlgProc;
    psp[0].lParam      = 0;

    psp[1].dwSize      = sizeof(PROPSHEETPAGE);
    psp[1].hInstance   = ghInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(DID_FONTDLG);
    psp[1].pfnDlgProc  = FontDlgProc;
    psp[1].lParam      = 1;

    psp[2].dwSize      = sizeof(PROPSHEETPAGE);
    psp[2].hInstance   = ghInstance;
    psp[2].pszTemplate = MAKEINTRESOURCE(DID_SCRBUFSIZE);
    psp[2].pfnDlgProc  = ScreenSizeDlgProc;
    psp[2].lParam      = 2;

    psp[3].dwSize      = sizeof(PROPSHEETPAGE);
    psp[3].hInstance   = ghInstance;
    psp[3].pszTemplate = MAKEINTRESOURCE(DID_COLOR);
    psp[3].pfnDlgProc  = ColorDlgProc;
    psp[3].lParam      = 3;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPTITLE | PSH_USEICONID | PSH_PROPSHEETPAGE |
                  PSH_NOAPPLYNOW | PSH_USECALLBACK;
    if (gpStateInfo->hWnd) {
        psh.hwndParent = gpStateInfo->hWnd;
    } else {
        psh.hwndParent = hWnd;
    }
    psh.hInstance = ghInstance;
    psh.pszIcon = MAKEINTRESOURCE(IDI_CONSOLE);
    if (gpStateInfo->ConsoleTitle[0] != TEXT('\0')) {
        wcscpy(awchBuffer, TEXT("\""));
        ExpandEnvironmentStrings(gpStateInfo->ConsoleTitle, &awchBuffer[1], NELEM(awchBuffer) - 2);
        wcscat(awchBuffer, TEXT("\""));
        gbStartedFromLink = WereWeStartedFromALnk();
    } else {
        LoadString(ghInstance, IDS_TITLE, awchBuffer, NELEM(awchBuffer));
        gbStartedFromLink = FALSE;
    }
    psh.pszCaption = awchBuffer;
    psh.nPages = NELEM(psp);
    psh.nStartPage = min(gnCurrentPage, NELEM(psp));
    psh.ppsp = psp;
    psh.pfnCallback = ConsolePropSheetProc;

    //
    // Create the property sheet
    //

    Result = PropertySheet(&psh);

    //
    // Send the state values to the console server
    //

    if (gbWriteToConsole) {
        WriteStateValues(gpStateInfo);
    }

    //
    // Save our changes to the registry
    //

    if (gbSaveToRegistry) {

        //
        // If we're looking at the default font, clear the values
        // before we save them
        //

        if ((gpStateInfo->FontFamily == DefaultFontFamily) &&
            (gpStateInfo->FontSize.X == DefaultFontSize.X) &&
            (gpStateInfo->FontSize.Y == DefaultFontSize.Y) &&
            (gpStateInfo->FontWeight == FW_NORMAL) &&
            (wcscmp(gpStateInfo->FaceName, DefaultFaceName) == 0)) {

            gpStateInfo->FontFamily = 0;
            gpStateInfo->FontSize.X = 0;
            gpStateInfo->FontSize.Y = 0;
            gpStateInfo->FontWeight = 0;
            gpStateInfo->FaceName[0] = TEXT('\0');
        }
        if (gbStartedFromLink) {

            if (!SetLinkValues( gpStateInfo )) {

                WCHAR szMessage[ MAX_PATH + 100 ];
                STARTUPINFOW si;
                HWND hwndTemp;

                // An error occured try to save the link file,
                // display a message box to that effect...

                GetStartupInfoW( &si );
                LoadStringW(ghInstance, IDS_LINKERROR, awchBuffer, NELEM(awchBuffer));
                wsprintfW( szMessage,
                           awchBuffer,
                           si.lpTitle
                          );
                LoadStringW(ghInstance, IDS_LINKERRCAP, awchBuffer, NELEM(awchBuffer));
                if (gpStateInfo->hWnd) {
                    hwndTemp = gpStateInfo->hWnd;
                } else {
                    hwndTemp = hWnd;
                }
                MessageBoxW( hwndTemp,
                             szMessage,
                             awchBuffer,
                             MB_APPLMODAL | MB_OK | MB_ICONSTOP | MB_SETFOREGROUND
                            );

            }

        } else {
            SetRegistryValues(gpStateInfo, gnCurrentPage);
        }
    } else {
        SetRegistryValues(NULL, gnCurrentPage);
    }

    //
    // Tell the console server that we're done
    //

    if (gpStateInfo->hWnd) {
        SendMessage(gpStateInfo->hWnd, CM_PROPERTIES_END, 0, 0);
    }

    //
    // Free the state information
    //

    HeapFree(RtlProcessHeap(), 0, gpStateInfo);

    //
    // Destroy the font cache
    //

    DestroyFonts();

    return Result;
}


BOOL
RegisterClasses(HANDLE hModule)
{
    WNDCLASS wc;

    wc.lpszClassName = TEXT("cpColor");
    wc.hInstance     = hModule;
    wc.lpfnWndProc   = ColorControlProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    if (!RegisterClass(&wc)) {
        return FALSE;
    }

    wc.lpszClassName = TEXT("WOAWinPreview");
    wc.lpfnWndProc   = PreviewWndProc;
    wc.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    wc.style         = 0L;
    if (!RegisterClass(&wc)) {
        return FALSE;
    }

    wc.lpszClassName = TEXT("WOAFontPreview");
    wc.lpfnWndProc   = FontPreviewWndProc;
    wc.hbrBackground = GetStockObject(BLACK_BRUSH);
    wc.style         = 0L;
    if (!RegisterClass(&wc)) {
        return FALSE;
    }

    return TRUE;
}

void
UnregisterClasses(HANDLE hModule)
{
    UnregisterClass(TEXT("cpColor"),        hModule);
    UnregisterClass(TEXT("WOAWinPreview"),  hModule);
    UnregisterClass(TEXT("WOAFontPreview"), hModule);
}


PCONSOLE_STATE_INFO
ReadStateValues(HANDLE hMap)
{
    PCONSOLE_STATE_INFO pConsoleInfo;
    PCONSOLE_STATE_INFO pStateInfo;

    /*
     * Map the shared memory block into our address space.
     */
    pConsoleInfo = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (pConsoleInfo == NULL) {
        return NULL;
    }

    /*
     * Copy the data into a locally allocated buffer.
     */
    pStateInfo = HeapAlloc(RtlProcessHeap(), 0, pConsoleInfo->Length);
    if (pStateInfo) {
        RtlCopyMemory(pStateInfo, pConsoleInfo, pConsoleInfo->Length);
    }

    /*
     * Close any open handles.
     */
    UnmapViewOfFile(pConsoleInfo);
    CloseHandle(hMap);

    return pStateInfo;
}


BOOL
WriteStateValues(PCONSOLE_STATE_INFO pStateInfo)
{
    HANDLE hMap;
    PCONSOLE_STATE_INFO pConsoleInfo;

    /*
     * Make sure we have a console window to notify.
     */
    if (pStateInfo->hWnd == NULL) {
        return FALSE;
    }

    /*
     * Create the shared memory block which will contain the state info.
     */
    hMap = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0,
                             pStateInfo->Length, NULL);
    if (!hMap) {
        KdPrint(("CONSOLE: error %d creating file mapping\n", GetLastError()));
        return FALSE;
    }

    /*
     * Map the shared memory block into our address space and copy the
     * data into it.
     */
    pConsoleInfo = MapViewOfFile(hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
    if (!pConsoleInfo) {
        KdPrint(("CONSOLE: error %d mapping view of file\n", GetLastError()));
        CloseHandle(hMap);
        return FALSE;
    }

    RtlCopyMemory(pConsoleInfo, pStateInfo, pStateInfo->Length);
    UnmapViewOfFile(pConsoleInfo);

    /*
     * Send a message to the server window telling him to read the data
     * and then close any open handles.
     */
    SendMessage(pStateInfo->hWnd, CM_PROPERTIES_UPDATE, (WPARAM)hMap, 0);

    CloseHandle(hMap);

    return TRUE;
}


PCONSOLE_STATE_INFO
InitStateValues(HANDLE hMap)
{
    PCONSOLE_STATE_INFO pStateInfo;

    /*
     * Try to open the shared memory block and read the state info
     * into our address space.
     */
    pStateInfo = ReadStateValues(hMap);
    if (pStateInfo != NULL) {
        return pStateInfo;
    }

    /*
     * Couldn't read the shared memory block so allocate and fill
     * in default values in structure.
     */
    pStateInfo = InitRegistryValues();
    if (pStateInfo == NULL) {
        return NULL;
    }

    /*
     * Now overwrite default values with values from registry
     */
    GetRegistryValues(pStateInfo);

    return pStateInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\dialogs.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dialogs.h

Abstract:

    This module contains the definitions for the console dialog boxes

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#define DID_SETTINGS                100
#define IDD_WINDOWED                101
#define IDD_FULLSCREEN              102
#define IDD_QUICKEDIT               103
#define IDD_INSERT                  104
#define IDD_CURSOR_SMALL            105
#define IDD_CURSOR_MEDIUM           106
#define IDD_CURSOR_LARGE            107
#define IDD_HISTORY_SIZE            108
#define IDD_HISTORY_SIZESCROLL      109
#define IDD_HISTORY_NUM             110
#define IDD_HISTORY_NUMSCROLL       111
#define IDD_HISTORY_NODUP           112
#if defined(FE_SB)
#define IDD_LANGUAGELIST            113
// v-HirShi Nov.2.1996
#define DID_SETTINGS2               114
#define IDD_LANGUAGE                115
#define IDD_LANGUAGE_GROUPBOX       116
#endif
#define IDD_DISPLAY_GROUPBOX        117
#define IDD_AUTOCOMPLETE            118

#define DID_FONTDLG                 200
#define IDD_STATIC                  201
#define IDD_FACENAME                202
#define IDD_BOLDFONT                203
#define IDD_STATIC2                 204
#define IDD_PREVIEWLABEL            206
#define IDD_GROUP                   207
#define IDD_STATIC3                 208
#define IDD_STATIC4                 209
#define IDD_FONTWIDTH               210
#define IDD_FONTHEIGHT              211
#define IDD_FONTSIZE                212
#define IDD_POINTSLIST              213
#define IDD_PIXELSLIST              214
#define IDD_PREVIEWWINDOW           215
#define IDD_FONTWINDOW              216

#define DID_SCRBUFSIZE              300
#define IDD_SCRBUF_WIDTH            301
#define IDD_SCRBUF_WIDTHSCROLL      302
#define IDD_SCRBUF_HEIGHT           303
#define IDD_SCRBUF_HEIGHTSCROLL     304
#define IDD_WINDOW_WIDTH            305
#define IDD_WINDOW_WIDTHSCROLL      306
#define IDD_WINDOW_HEIGHT           307
#define IDD_WINDOW_HEIGHTSCROLL     308
#define IDD_WINDOW_POSX             309
#define IDD_WINDOW_POSXSCROLL       310
#define IDD_WINDOW_POSY             311
#define IDD_WINDOW_POSYSCROLL       312
#define IDD_AUTO_POSITION           313
#define IDD_WARNING                 314

#define DID_COLOR                   400
#define IDD_COLOR_SCREEN_TEXT       401
#define IDD_COLOR_SCREEN_BKGND      402
#define IDD_COLOR_POPUP_TEXT        403
#define IDD_COLOR_POPUP_BKGND       404
#define IDD_COLOR_1                 405
#define IDD_COLOR_2                 406
#define IDD_COLOR_3                 407
#define IDD_COLOR_4                 408
#define IDD_COLOR_5                 409
#define IDD_COLOR_6                 410
#define IDD_COLOR_7                 411
#define IDD_COLOR_8                 412
#define IDD_COLOR_9                 413
#define IDD_COLOR_10                414
#define IDD_COLOR_11                415
#define IDD_COLOR_12                416
#define IDD_COLOR_13                417
#define IDD_COLOR_14                418
#define IDD_COLOR_15                419
#define IDD_COLOR_16                420
#define IDD_COLOR_SCREEN_COLORS     421
#define IDD_COLOR_POPUP_COLORS      422
#define IDD_COLOR_RED               423
#define IDD_COLOR_REDSCROLL         424
#define IDD_COLOR_GREEN             425
#define IDD_COLOR_GREENSCROLL       426
#define IDD_COLOR_BLUE              427
#define IDD_COLOR_BLUESCROLL        428

#define DID_SAVE_QUERY              500
#define DID_SAVE_QUERY_LINK         501
#define IDD_APPLY                   502
#define IDD_SAVE                    503
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\font.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    font.h

Abstract:

    This module contains the data structures, data types,
    and procedures related to fonts.

Author:

    Therese Stowell (thereses) 15-Jan-1991

Revision History:

--*/

#ifndef FONT_H
#define FONT_H

#define INITIAL_FONTS 20
#define FONT_INCREMENT 3
#define CONSOLE_MAX_FONT_NAME_LENGTH 256

#define EF_NEW         0x0001 // a newly available face
#define EF_OLD         0x0002 // a previously available face
#define EF_ENUMERATED  0x0004 // all sizes have been enumerated
#define EF_OEMFONT     0x0008 // an OEM face
#define EF_TTFONT      0x0010 // a TT face
#define EF_DEFFACE     0x0020 // the default face
#if defined(FE_SB)
#define EF_DBCSFONT    0x0040 // the DBCS font
#endif

/*
 * FONT_INFO
 *
 * The distinction between the desired and actual font dimensions obtained
 * is important in the case of TrueType fonts, in which there is no guarantee
 * that what you ask for is what you will get.
 *
 * Note that the correspondence between "Desired" and "Actual" is broken
 * whenever the user changes his display driver, because GDI uses driver
 * parameters to control the font rasterization.
 *
 * The SizeDesired is {0, 0} if the font is a raster font.
 */
typedef struct _FONT_INFO {
    HFONT hFont;
    COORD Size;      // font size obtained
    COORD SizeWant;  // 0;0 if Raster font
    LONG  Weight;
    LPTSTR FaceName;
    BYTE  Family;
#if defined(FE_SB)
    BYTE  tmCharSet;
#endif
} FONT_INFO, *PFONT_INFO;

typedef struct tagFACENODE {
     struct tagFACENODE *pNext;
     DWORD  dwFlag;
     TCHAR  atch[];
} FACENODE, *PFACENODE;

#define TM_IS_TT_FONT(x)     (((x) & TMPF_TRUETYPE) == TMPF_TRUETYPE)
#define IS_BOLD(w)           ((w) >= FW_SEMIBOLD)
#define SIZE_EQUAL(s1, s2)   (((s1).X == (s2).X) && ((s1).Y == (s2).Y))
#define POINTS_PER_INCH 72
#define MIN_PIXEL_HEIGHT 5
#define MAX_PIXEL_HEIGHT 72


//
// Function prototypes
//

VOID
InitializeFonts(VOID);

VOID
DestroyFonts(VOID);

NTSTATUS
EnumerateFonts(DWORD Flags);

#if !defined(FE_SB)
int
FindCreateFont(
    DWORD Family,
    LPTSTR ptszFace,
    COORD Size,
    LONG Weight);
#else
int
FindCreateFont(
    DWORD Family,
    LPTSTR ptszFace,
    COORD Size,
    LONG Weight,
    UINT CodePage);
#endif

BOOL
DoFontEnum(
    HDC hDC,
    LPTSTR ptszFace,
    PSHORT pTTPoints,
    UINT nTTPoints);

#endif /* !FONT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\fontdlg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fontdlg.dlg

Abstract:

    This module contains the code for console font dialog

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "fontdlg.h"


/* ----- Prototypes ----- */

int FontListCreate(
    HWND hDlg,
    LPTSTR ptszTTFace,
    BOOL bNewFaceList
    );

BOOL PreviewUpdate(
    HWND hDlg,
    BOOL bLB
    );

int SelectCurrentSize(
    HWND hDlg,
    BOOL bLB,
    int FontIndex);

BOOL PreviewInit(
    HWND hDlg);

VOID DrawItemFontList(
    const LPDRAWITEMSTRUCT lpdis);

/* ----- Globals ----- */

const TCHAR g_szPreviewText[] = \
    TEXT("C:\\WINDOWS> dir                       \n") \
    TEXT("SYSTEM       <DIR>     10-01-99   5:00a\n") \
    TEXT("SYSTEM32     <DIR>     10-01-99   5:00a\n") \
    TEXT("README   TXT     26926 10-01-99   5:00a\n") \
    TEXT("WINDOWS  BMP     46080 10-01-99   5:00a\n") \
    TEXT("NOTEPAD  EXE    337232 10-01-99   5:00a\n") \
    TEXT("CLOCK    AVI     39594 10-01-99   5:00p\n") \
    TEXT("WIN      INI      7005 10-01-99   5:00a\n");

HBITMAP hbmTT = NULL; // handle of TT logo bitmap
BITMAP bmTT;          // attributes of TT source bitmap
int dyFacelistItem;   // height of Item in Facelist listbox

BOOL gbPointSizeError = FALSE;
BOOL gbBold = FALSE;
#if defined(FE_SB)
BOOL fChangeCodePage = FALSE;


BOOL
SelectCurrentFont(
    HWND hDlg,
    int FontIndex
    );
#endif

// Globals strings loaded from resource
TCHAR tszSelectedFont[CCH_SELECTEDFONT+1];
TCHAR tszRasterFonts[CCH_RASTERFONTS+1];


INT_PTR
APIENTRY
FontDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the font selection dialog box.
    Returns the near offset into the far table of LOGFONT structures.

--*/

{
    HWND hWndFocus;
    HWND hWndList;
    int FontIndex;
    BOOL bLB;
    TEXTMETRIC tm;
    HDC hDC;

    switch (wMsg) {
    case WM_INITDIALOG:
        /*
         * Load the font description strings
         */
        LoadString(ghInstance, IDS_RASTERFONT,
                   tszRasterFonts, NELEM(tszRasterFonts));
        DBGPRINT(("tszRasterFonts = \"%ls\"\n", tszRasterFonts));
        ASSERT(_tcslen(tszRasterFonts) < CCH_RASTERFONTS);

        LoadString(ghInstance, IDS_SELECTEDFONT,
                   tszSelectedFont, NELEM(tszSelectedFont));
        DBGPRINT(("tszSelectedFont = \"%ls\"\n", tszSelectedFont));
        ASSERT(_tcslen(tszSelectedFont) < CCH_SELECTEDFONT);

        /* Save current font size as dialog window's user data */
#if defined(FE_SB)
        ASSERT(OEMCP != 0);
        if (gfFESystem) {
            SetWindowLongPtr(hDlg, GWLP_USERDATA,
                          MAKELONG(FontInfo[CurrentFontIndex].tmCharSet,
                                   FontInfo[CurrentFontIndex].Size.Y));
        } else {
#endif
            SetWindowLongPtr(hDlg, GWLP_USERDATA,
                          MAKELONG(FontInfo[CurrentFontIndex].Size.X,
                                   FontInfo[CurrentFontIndex].Size.Y));
#if defined(FE_SB)
        }
#endif

        /* Create the list of suitable fonts */
        gbEnumerateFaces = TRUE;
        bLB = !TM_IS_TT_FONT(gpStateInfo->FontFamily);
        gbBold = IS_BOLD(gpStateInfo->FontWeight);
        CheckDlgButton(hDlg, IDD_BOLDFONT, gbBold);
        FontListCreate(hDlg, bLB ? NULL : gpStateInfo->FaceName, TRUE);

        /* Initialize the preview window - selects current face & size too */
        bLB = PreviewInit(hDlg);
        PreviewUpdate(hDlg, bLB);

        /* Make sure the list box has the focus */
        hWndList = GetDlgItem(hDlg, bLB ? IDD_PIXELSLIST : IDD_POINTSLIST);
        SetFocus(hWndList);
        break;

    case WM_FONTCHANGE:
        gbEnumerateFaces = TRUE;
        bLB = !TM_IS_TT_FONT(gpStateInfo->FontFamily);
        FontListCreate(hDlg, NULL, TRUE);
        FontIndex = FindCreateFont(gpStateInfo->FontFamily,
                                   gpStateInfo->FaceName,
                                   gpStateInfo->FontSize,
                                   gpStateInfo->FontWeight,
                                   gpStateInfo->CodePage);
        SelectCurrentSize(hDlg, bLB, FontIndex);
        return TRUE;

#if defined(FE_SB)
    case WM_PAINT:
        if (fChangeCodePage)
        {
            fChangeCodePage = FALSE;

            /* Create the list of suitable fonts */
            bLB = !TM_IS_TT_FONT(gpStateInfo->FontFamily);
            FontIndex = FontListCreate(hDlg, !bLB ? NULL : gpStateInfo->FaceName, TRUE);
            FontIndex = FontListCreate(hDlg, bLB ? NULL : gpStateInfo->FaceName, TRUE);
            CurrentFontIndex = FontIndex;

            FontIndex = SelectCurrentSize(hDlg, bLB, FontIndex);
            SelectCurrentFont(hDlg, FontIndex);

            PreviewUpdate(hDlg, bLB);
        }
        break;
#endif

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDD_BOLDFONT:
            DBGPRINT(("WM_COMMAND to Bold Font checkbox %x\n", HIWORD(wParam)));
            gbBold = IsDlgButtonChecked(hDlg, IDD_BOLDFONT);
            goto RedoFontListAndPreview;

        case IDD_FACENAME:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
RedoFontListAndPreview:
                {
                    TCHAR atchNewFace[LF_FACESIZE];
                    LONG l;

                    DBGFONTS(("LBN_SELCHANGE from FACENAME\n"));
                    l = (LONG)SendDlgItemMessage(hDlg, IDD_FACENAME, LB_GETCURSEL, 0, 0L);
                    bLB = (BOOL)SendDlgItemMessage(hDlg, IDD_FACENAME, LB_GETITEMDATA, l, 0L);
                    if (!bLB) {
                        SendDlgItemMessage(hDlg, IDD_FACENAME, LB_GETTEXT, l, (LPARAM)atchNewFace);
                        DBGFONTS(("LBN_EDITUPDATE, got TT face \"%ls\"\n", atchNewFace));
                    }
                    FontIndex = FontListCreate(hDlg, bLB ? NULL : atchNewFace, FALSE);
                    FontIndex = SelectCurrentSize(hDlg, bLB, FontIndex);
                    PreviewUpdate(hDlg, bLB);
                    return TRUE;
                }
            }
            break;

        case IDD_POINTSLIST:
            switch (HIWORD(wParam)) {
            case CBN_SELCHANGE:
                DBGFONTS(("CBN_SELCHANGE from POINTSLIST\n"));
                PreviewUpdate(hDlg, FALSE);
                return TRUE;

            case CBN_KILLFOCUS:
                DBGFONTS(("CBN_KILLFOCUS from POINTSLIST\n"));
                if (!gbPointSizeError) {
                    hWndFocus = GetFocus();
                    if (hWndFocus != NULL && IsChild(hDlg, hWndFocus) &&
                        hWndFocus != GetDlgItem(hDlg, IDCANCEL)) {
                        PreviewUpdate(hDlg, FALSE);
                    }
                }
                return TRUE;

            default:
                DBGFONTS(("unhandled CBN_%x from POINTSLIST\n",HIWORD(wParam)));
                break;
            }
            break;

        case IDD_PIXELSLIST:
            switch (HIWORD(wParam)) {
            case LBN_SELCHANGE:
                DBGFONTS(("LBN_SELCHANGE from PIXELSLIST\n"));
                PreviewUpdate(hDlg, TRUE);
                return TRUE;

            default:
                break;
            }
            break;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_KILLACTIVE:
            //
            // If the TT combo box is visible, update selection
            //
            hWndList = GetDlgItem(hDlg, IDD_POINTSLIST);
            if (hWndList != NULL && IsWindowVisible(hWndList)) {
                if (!PreviewUpdate(hDlg, FALSE)) {
                    SetDlgMsgResult(hDlg, PSN_KILLACTIVE, TRUE);
                    return TRUE;
                }
                SetDlgMsgResult(hDlg, PSN_KILLACTIVE, FALSE);
            }

            FontIndex = CurrentFontIndex;

            if (FontInfo[FontIndex].SizeWant.Y == 0) {
                // Raster Font, so save actual size
                gpStateInfo->FontSize = FontInfo[FontIndex].Size;
            } else {
                // TT Font, so save desired size
                gpStateInfo->FontSize = FontInfo[FontIndex].SizeWant;
            }

            gpStateInfo->FontWeight = FontInfo[FontIndex].Weight;
            gpStateInfo->FontFamily = FontInfo[FontIndex].Family;
            wcscpy(gpStateInfo->FaceName, FontInfo[FontIndex].FaceName);

            return TRUE;

        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            EndDlgPage(hDlg);
            return TRUE;
        }
        break;

    /*
     *  For WM_MEASUREITEM and WM_DRAWITEM, since there is only one
     *  owner-draw item (combobox) in the entire dialog box, we don't have
     *  to do a GetDlgItem to figure out who he is.
     */
    case WM_MEASUREITEM:
        /*
         * Load the TrueType logo bitmap
         */
        if (hbmTT == NULL) {
            hbmTT = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_TRUETYPE));
            GetObject(hbmTT, sizeof(BITMAP), &bmTT);
        }

        /*
         * Compute the height of face name listbox entries
         */
        if (dyFacelistItem == 0) {
            HFONT hFont;
            hDC = GetDC(hDlg);
            hFont = GetWindowFont(hDlg);
            if (hFont) {
                hFont = SelectObject(hDC, hFont);
            }
            GetTextMetrics(hDC, &tm);
            if (hFont) {
                SelectObject(hDC, hFont);
            }
            ReleaseDC(hDlg, hDC);
            dyFacelistItem = max(tm.tmHeight, bmTT.bmHeight);
        }
        ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = dyFacelistItem;
        return TRUE;

    case WM_DRAWITEM:
        DrawItemFontList((LPDRAWITEMSTRUCT)lParam);
        return TRUE;

    case WM_DESTROY:
        /*
         * Delete the TrueType logo bitmap
         */
        if (hbmTT != NULL) {
            DeleteObject(hbmTT);
            hbmTT = NULL;
        }
        return TRUE;

    default:
        break;
    }
    return CommonDlgProc(hDlg, wMsg, wParam, lParam);
}


int
FontListCreate(
    HWND hDlg,
    LPTSTR ptszTTFace,
    BOOL bNewFaceList
    )

/*++

    Initializes the font list by enumerating all fonts and picking the
    proper ones for our list.

    Returns
        FontIndex of selected font (LB_ERR if none)
--*/

{
    TCHAR tszText[80];
    LONG lListIndex;
    ULONG i;
    HWND hWndShow;      // List or Combo box
    HWND hWndHide;    // Combo or List box
    HWND hWndFaceCombo;
    HANDLE hStockFont;
    BOOL bLB;
    int LastShowX = 0;
    int LastShowY = 0;
    int nSameSize = 0;
    UINT  CodePage = gpStateInfo->CodePage;
    BOOL  fDbcsCharSet = IS_ANY_DBCS_CHARSET( CodePageToCharSet( CodePage ) );
    BOOL  fFindTTFont = FALSE;
    LPTSTR ptszAltTTFace = NULL;
    LONG_PTR dwExStyle = 0L;

    ASSERT(OEMCP != 0); // must be initialized

    bLB = ((ptszTTFace == NULL) || (ptszTTFace[0] == TEXT('\0')));
    if (! bLB) {
        if (IsAvailableTTFont(ptszTTFace)) {
            ptszAltTTFace = GetAltFaceName(ptszTTFace);
        }
        else {
            ptszAltTTFace = ptszTTFace;
        }
    }
    DBGFONTS(("FontListCreate %lx, %s, %s new FaceList\n", hDlg,
            bLB ? "Raster" : "TrueType",
            bNewFaceList ? "Make" : "No" ));

    /*
     * This only enumerates face names if necessary, and
     * it only enumerates font sizes if necessary
     */

    EnumerateFonts(bLB ? EF_OEMFONT : EF_TTFONT);

    /* init the TTFaceNames */

    DBGFONTS(("  Create %s fonts\n", bLB ? "Raster" : "TrueType"));

    if (bNewFaceList) {
        PFACENODE panFace;
        hWndFaceCombo = GetDlgItem(hDlg, IDD_FACENAME);

        SendMessage(hWndFaceCombo, LB_RESETCONTENT, 0, 0);

        lListIndex = (LONG)SendMessage(hWndFaceCombo, LB_ADDSTRING, 0, (LPARAM)tszRasterFonts);
        SendMessage(hWndFaceCombo, LB_SETITEMDATA, lListIndex, TRUE);
        DBGFONTS(("Added \"%ls\", set Item Data %d = TRUE\n", tszRasterFonts, lListIndex));
        for (panFace = gpFaceNames; panFace; panFace = panFace->pNext) {
            if ((panFace->dwFlag & (EF_TTFONT|EF_NEW)) != (EF_TTFONT|EF_NEW)) {
                continue;
            }
            if (!fDbcsCharSet && (panFace->dwFlag & EF_DBCSFONT)) {
                continue;
            }

            if ((fDbcsCharSet && IsAvailableTTFontCP(panFace->atch, CodePage)) ||
                (!fDbcsCharSet && IsAvailableTTFontCP(panFace->atch, 0)))
            {

                if ( !bLB &&
                     (_tcscmp(ptszTTFace, panFace->atch) == 0 ||
                      _tcscmp(ptszAltTTFace, panFace->atch) == 0)
                   ) {
                    fFindTTFont = TRUE;
                }
                lListIndex = (LONG)SendMessage(hWndFaceCombo, LB_ADDSTRING, 0,
                                         (LPARAM)panFace->atch);
                SendMessage(hWndFaceCombo, LB_SETITEMDATA, lListIndex, FALSE);
                DBGFONTS(("Added \"%ls\", set Item Data %d = FALSE\n",
                          panFace->atch, lListIndex));
            }
        }
        if (!bLB && !fFindTTFont) {

            for (panFace = gpFaceNames; panFace; panFace = panFace->pNext) {

                if ((panFace->dwFlag & (EF_TTFONT|EF_NEW)) != (EF_TTFONT|EF_NEW)) {
                    continue;
                }
                if (!fDbcsCharSet && (panFace->dwFlag & EF_DBCSFONT)) {
                    continue;
                }

                if (( fDbcsCharSet && IsAvailableTTFontCP(panFace->atch, CodePage)) ||
                    (!fDbcsCharSet && IsAvailableTTFontCP(panFace->atch, 0)))
                {

                    if (_tcscmp(ptszTTFace, panFace->atch) != 0) {
                        _tcscpy(ptszTTFace, panFace->atch);
                        break;
                    }
                }
            }
        }
    } // if(bNewFaceList)

    hWndShow = GetDlgItem(hDlg, IDD_BOLDFONT);
#if defined(FE_SB)
    /*
     * For JAPAN, We uses "MS Gothic" TT font.
     * So, Bold of this font is not 1:2 width between SBCS:DBCS.
     */
    if (fDbcsCharSet && IsDisableBoldTTFont(ptszTTFace)) {
        EnableWindow(hWndShow, FALSE);
        gbBold = FALSE;
        CheckDlgButton(hDlg, IDD_BOLDFONT, FALSE);
    } else {
#endif
        CheckDlgButton(hDlg, IDD_BOLDFONT, (bLB || !gbBold) ? FALSE : TRUE);
        EnableWindow(hWndShow, bLB ? FALSE : TRUE);
#if defined(FE_SB)
    }
#endif

    hWndHide = GetDlgItem(hDlg, bLB ? IDD_POINTSLIST : IDD_PIXELSLIST);
    ShowWindow(hWndHide, SW_HIDE);
    EnableWindow(hWndHide, FALSE);

    hWndShow = GetDlgItem(hDlg, bLB ? IDD_PIXELSLIST : IDD_POINTSLIST);
//    hStockFont = GetStockObject(SYSTEM_FIXED_FONT);
//    SendMessage(hWndShow, WM_SETFONT, (DWORD)hStockFont, FALSE);
    ShowWindow(hWndShow, SW_SHOW);
    EnableWindow(hWndShow, TRUE);

#if defined(FE_SB)
    if (bNewFaceList) {
        lcbRESETCONTENT(hWndShow, bLB);
    }
#endif

    dwExStyle = GetWindowLongPtr(hWndShow, GWL_EXSTYLE);
    if((dwExStyle & WS_EX_LAYOUTRTL) && !(dwExStyle & WS_EX_RTLREADING))
    {
        // if mirrored RTL Reading means LTR !!
        SetWindowLongPtr(hWndShow, GWL_EXSTYLE, dwExStyle | WS_EX_RTLREADING);
    }

    /* Initialize hWndShow list/combo box */

    for (i=0;i<NumberOfFonts;i++) {
        int ShowX, ShowY;

        if (!bLB == !TM_IS_TT_FONT(FontInfo[i].Family)) {
            DBGFONTS(("  Font %x not right type\n", i));
            continue;
        }
#if defined(FE_SB)
        if (fDbcsCharSet) {
            if (!IS_ANY_DBCS_CHARSET(FontInfo[i].tmCharSet)) {
                DBGFONTS(("  Font %x not right type for DBCS character set\n", i));
                continue;
            }
        }
        else {
            if (IS_ANY_DBCS_CHARSET(FontInfo[i].tmCharSet)) {
                DBGFONTS(("  Font %x not right type for SBCS character set\n", i));
                continue;
            }
        }
#endif

        if (!bLB) {
            if (_tcscmp(FontInfo[i].FaceName, ptszTTFace) != 0 &&
                _tcscmp(FontInfo[i].FaceName, ptszAltTTFace) != 0
               ) {
                /*
                 * A TrueType font, but not the one we're interested in,
                 * so don't add it to the list of point sizes.
                 */
                DBGFONTS(("  Font %x is TT, but not %ls\n", i, ptszTTFace));
                continue;
            }
            if (gbBold != IS_BOLD(FontInfo[i].Weight)) {
                DBGFONTS(("  Font %x has weight %d, but we wanted %sbold\n",
                        i, FontInfo[i].Weight, gbBold ? "" : "not "));
                continue;
            }
        }

        if (FontInfo[i].SizeWant.X > 0) {
            ShowX = FontInfo[i].SizeWant.X;
        } else {
            ShowX = FontInfo[i].Size.X;
        }
        if (FontInfo[i].SizeWant.Y > 0) {
            ShowY = FontInfo[i].SizeWant.Y;
        } else {
            ShowY = FontInfo[i].Size.Y;
        }
        /*
         * Add the size description string to the end of the right list
         */
        if (TM_IS_TT_FONT(FontInfo[i].Family)) {
            // point size
            wsprintf(tszText, TEXT("%2d"), FontInfo[i].SizeWant.Y);
        } else {
            // pixel size
            if ((LastShowX == ShowX) && (LastShowY == ShowY)) {
                nSameSize++;
            } else {
                LastShowX = ShowX;
                LastShowY = ShowY;
                nSameSize = 0;
            }
            /*
             * The number nSameSize is appended to the string to distinguish
             * between Raster fonts of the same size.  It is not intended to
             * be visible and exists off the edge of the list
             */
            if(((dwExStyle & WS_EX_RIGHT) && !(dwExStyle & WS_EX_LAYOUTRTL))
                || (!(dwExStyle & WS_EX_RIGHT) && (dwExStyle & WS_EX_LAYOUTRTL))) {
                // flip  it so that the hidden part be at the far left
                wsprintf(tszText, TEXT("#%d                %2d x %2d"),
                         nSameSize, ShowX, ShowY);
            } else {
                wsprintf(tszText, TEXT("%2d x %2d                #%d"),
                         ShowX, ShowY, nSameSize);
            }
        }
        lListIndex = lcbFINDSTRINGEXACT(hWndShow, bLB, tszText);
        if (lListIndex == LB_ERR) {
            lListIndex = lcbADDSTRING(hWndShow, bLB, tszText);
        }
        DBGFONTS(("  added %ls to %sSLIST(%lx) index %lx\n",
                tszText,
                bLB ? "PIXEL" : "POINT",
                hWndShow, lListIndex));
        lcbSETITEMDATA(hWndShow, bLB, (DWORD)lListIndex, i);
    }

    /*
     * Get the FontIndex from the currently selected item.
     * (i will be LB_ERR if no currently selected item).
     */
    lListIndex = lcbGETCURSEL(hWndShow, bLB);
    i = lcbGETITEMDATA(hWndShow, bLB, lListIndex);

    DBGFONTS(("FontListCreate returns 0x%x\n", i));
    return i;
}


/** DrawItemFontList
 *
 *  Answer the WM_DRAWITEM message sent from the font list box or
 *  facename list box.
 *
 *  Entry:
 *      lpdis     -> DRAWITEMSTRUCT describing object to be drawn
 *
 *  Returns:
 *      None.
 *
 *      The object is drawn.
 */
VOID WINAPI
DrawItemFontList(const LPDRAWITEMSTRUCT lpdis)
{
    HDC     hDC, hdcMem;
    DWORD   rgbBack, rgbText, rgbFill;
    TCHAR   tszFace[LF_FACESIZE];
    HBITMAP hOld;
    int     dy;
    HBRUSH  hbrFill;
    HWND    hWndItem;
    BOOL    bLB;
    int     dxttbmp;

    if ((int)lpdis->itemID < 0)
        return;

    hDC = lpdis->hDC;

    if (lpdis->itemAction & ODA_FOCUS) {
        if (lpdis->itemState & ODS_SELECTED) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    } else {
        if (lpdis->itemState & ODS_SELECTED) {
            rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            rgbBack = SetBkColor(hDC, rgbFill = GetSysColor(COLOR_HIGHLIGHT));
        } else {
            rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
            rgbBack = SetBkColor(hDC, rgbFill = GetSysColor(COLOR_WINDOW));
        }
        // draw selection background
        hbrFill = CreateSolidBrush(rgbFill);
        if (hbrFill) {
            FillRect(hDC, &lpdis->rcItem, hbrFill);
            DeleteObject(hbrFill);
        }

        // get the string
        if (IsWindow(hWndItem = lpdis->hwndItem) == FALSE) {
            return;
        }
        SendMessage(hWndItem, LB_GETTEXT, lpdis->itemID, (LPARAM)tszFace);
        bLB = (BOOL)SendMessage(hWndItem, LB_GETITEMDATA, lpdis->itemID, 0L);
        dxttbmp = bLB ? 0 : bmTT.bmWidth;

        DBGFONTS(("DrawItemFontList must redraw \"%ls\" %s\n", tszFace,
                bLB ? "Raster" : "TrueType"));

        // draw the text
        TabbedTextOut(hDC, lpdis->rcItem.left + dxttbmp,
                      lpdis->rcItem.top, tszFace,
                      _tcslen(tszFace), 0, NULL, dxttbmp);

        // and the TT bitmap if needed
        if (!bLB) {
            hdcMem = CreateCompatibleDC(hDC);
            if (hdcMem) {
                hOld = SelectObject(hdcMem, hbmTT);

                dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - bmTT.bmHeight) / 2;

                BitBlt(hDC, lpdis->rcItem.left, lpdis->rcItem.top + dy,
                       dxttbmp, dyFacelistItem, hdcMem,
                       0, 0, SRCINVERT);

                if (hOld)
                    SelectObject(hdcMem, hOld);
                DeleteDC(hdcMem);
            }
        }

        SetTextColor(hDC, rgbText);
        SetBkColor(hDC, rgbBack);

        if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    }
}


UINT
GetPointSizeInRange(
   HWND hDlg,
   INT Min,
   INT Max)
/*++

Routine Description:

   Get a size from the Point Size ComboBox edit field

Return Value:

   Point Size - of the edit field limited by Min/Max size
   0 - if the field is empty or invalid

--*/

{
    TCHAR szBuf[90];
    int nTmp = 0;
    BOOL bOK;

    if (GetDlgItemText(hDlg, IDD_POINTSLIST, szBuf, NELEM(szBuf))) {
        nTmp = GetDlgItemInt(hDlg, IDD_POINTSLIST, &bOK, TRUE);
        if (bOK && nTmp >= Min && nTmp <= Max) {
            return nTmp;
        }
    }

    return 0;
}


/* ----- Preview routines ----- */

LRESULT
FontPreviewWndProc(
    HWND hWnd,
    UINT wMessage,
    WPARAM wParam,
    LPARAM lParam
    )

/*  FontPreviewWndProc
 *      Handles the font preview window
 */

{
    PAINTSTRUCT ps;
    RECT rect;
    HFONT hfontOld;
    HBRUSH hbrNew;
    HBRUSH hbrOld;
    COLORREF rgbText;
    COLORREF rgbBk;

    switch (wMessage) {
    case WM_ERASEBKGND:
        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);

        /* Draw the font sample */
        if (GetWindowLong(hWnd, GWL_ID) == IDD_COLOR_POPUP_COLORS) {
            rgbText = GetNearestColor(ps.hdc, PopupTextColor(gpStateInfo));
            rgbBk = GetNearestColor(ps.hdc, PopupBkColor(gpStateInfo));
        } else {
            rgbText = GetNearestColor(ps.hdc, ScreenTextColor(gpStateInfo));
            rgbBk = GetNearestColor(ps.hdc, ScreenBkColor(gpStateInfo));
        }
        SetTextColor(ps.hdc, rgbText);
        SetBkColor(ps.hdc, rgbBk);
        GetClientRect(hWnd, &rect);
        hfontOld = SelectObject(ps.hdc, FontInfo[CurrentFontIndex].hFont);
        hbrNew = CreateSolidBrush(rgbBk);
        hbrOld = SelectObject(ps.hdc, hbrNew);
        PatBlt(ps.hdc, rect.left, rect.top,
                rect.right - rect.left, rect.bottom - rect.top,
                PATCOPY);
        InflateRect(&rect, -2, -2);
        DrawText(ps.hdc, g_szPreviewText, -1, &rect, 0);
        SelectObject(ps.hdc, hbrOld);
        DeleteObject(hbrNew);
        SelectObject(ps.hdc, hfontOld);

        EndPaint(hWnd, &ps);
        break;

    default:
        return DefWindowProc(hWnd, wMessage, wParam, lParam);
    }
    return 0L;
}


/*
 * Get the font index for a new font
 * If necessary, attempt to create the font.
 * Always return a valid FontIndex (even if not correct)
 * Family:   Find/Create a font with of this Family
 *           0    - don't care
 * ptszFace: Find/Create a font with this face name.
 *           NULL or TEXT("")  - use DefaultFaceName
 * Size:     Must match SizeWant or actual Size.
 */
int
FindCreateFont(
    DWORD Family,
    LPTSTR ptszFace,
    COORD Size,
    LONG Weight,
    UINT CodePage)
{
#define NOT_CREATED_NOR_FOUND -1
#define CREATED_BUT_NOT_FOUND -2

    int i;
    int FontIndex = NOT_CREATED_NOR_FOUND;
    BOOL bFontOK;
    TCHAR AltFaceName[LF_FACESIZE];
    COORD AltFontSize;
    BYTE  AltFontFamily;
    ULONG AltFontIndex = 0;
    LPTSTR ptszAltFace = NULL;

    BYTE CharSet = CodePageToCharSet(CodePage);

    ASSERT(OEMCP != 0);

    DBGFONTS(("FindCreateFont Family=%x %ls (%d,%d) %d %d %x\n",
            Family, ptszFace, Size.X, Size.Y, Weight, CodePage, CharSet));

    if (gfFESystem) {
        if (IS_ANY_DBCS_CHARSET(CharSet)) {
            if (ptszFace == NULL || *ptszFace == TEXT('\0')) {
                ptszFace = DefaultFaceName;
            }
            if (Size.Y == 0) {
                Size = DefaultFontSize;
            }
        }
        else {
            MakeAltRasterFont(CodePage, &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName);

            if (ptszFace == NULL || *ptszFace == TEXT('\0')) {
                ptszFace = AltFaceName;
            }
            if (Size.Y == 0) {
                Size.X = AltFontSize.X;
                Size.Y = AltFontSize.Y;
            }
        }
    }
    else {
        if (ptszFace == NULL || *ptszFace == TEXT('\0')) {
            ptszFace = DefaultFaceName;
        }
        if (Size.Y == 0) {
            Size = DefaultFontSize;
        }
    }


    if (IsAvailableTTFont(ptszFace)) {
        ptszAltFace = GetAltFaceName(ptszFace);
    }
    else {
        ptszAltFace = ptszFace;
    }

    /*
     * Try to find the exact font
     */
TryFindExactFont:
    for (i=0; i < (int)NumberOfFonts; i++) {
        /*
         * If looking for a particular Family, skip non-matches
         */
        if ((Family != 0) &&
                ((BYTE)Family != FontInfo[i].Family)) {
            continue;
        }

        /*
         * Skip non-matching sizes
         */
        if ((!SIZE_EQUAL(FontInfo[i].SizeWant, Size) &&
             !SIZE_EQUAL(FontInfo[i].Size, Size))) {
            continue;
        }

        /*
         * Skip non-matching weights
         */
        if ((Weight != 0) && (Weight != FontInfo[i].Weight)) {
            continue;
        }

#if defined(FE_SB)
        if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
                FontInfo[i].tmCharSet != CharSet) {
            continue;
        }
#endif

        /*
         * Size (and maybe Family) match.
         *  If we don't care about the name, or if it matches, use this font.
         *  Else if name doesn't match and it is a raster font, consider it.
         */
        if ((ptszFace == NULL) || (ptszFace[0] == TEXT('\0')) ||
                (_tcscmp(FontInfo[i].FaceName, ptszFace) == 0) ||
                (_tcscmp(FontInfo[i].FaceName, ptszAltFace) == 0)
           ) {
            FontIndex = i;
            goto FoundFont;
        } else if (!TM_IS_TT_FONT(FontInfo[i].Family)) {
            FontIndex = i;
        }
    }

    if (FontIndex == NOT_CREATED_NOR_FOUND) {
        /*
         * Didn't find the exact font, so try to create it
         */
        ULONG ulOldEnumFilter;
        ulOldEnumFilter = SetFontEnumeration(0);
        SetFontEnumeration(ulOldEnumFilter & ~FE_FILTER_TRUETYPE);
        if (Size.Y < 0) {
            Size.Y = -Size.Y;
        }
        bFontOK = DoFontEnum(NULL, ptszFace, &Size.Y, 1);
        SetFontEnumeration(ulOldEnumFilter);
        if (bFontOK) {
            DBGFONTS(("FindCreateFont created font!\n"));
            FontIndex = CREATED_BUT_NOT_FOUND;
            goto TryFindExactFont;
        } else {
            DBGFONTS(("FindCreateFont failed to create font!\n"));
        }
    } else if (FontIndex >= 0) {
        // a close Raster Font fit - only the name doesn't match.
        goto FoundFont;
    }

    /*
     * Failed to find exact match, even after enumeration, so now try
     * to find a font of same family and same size or bigger
     */
    for (i=0; i < (int)NumberOfFonts; i++) {
#if defined(FE_SB)
        if (gfFESystem) {
            if ((Family != 0) &&
                    ((BYTE)Family != FontInfo[i].Family)) {
                continue;
            }

            if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
                FontInfo[i].tmCharSet != CharSet) {
                continue;
            }
        }
        else {
#endif
        if ((BYTE)Family != FontInfo[i].Family) {
            continue;
        }
#if defined(FE_SB)
        }
#endif

        if (FontInfo[i].Size.Y >= Size.Y &&
                FontInfo[i].Size.X >= Size.X) {
            // Same family, size >= desired.
            FontIndex = i;
            break;
        }
    }

    if (FontIndex < 0) {
        DBGFONTS(("FindCreateFont defaults!\n"));
#if defined(FE_SB)
        if (gfFESystem) {
            if (CodePage == OEMCP) {
                FontIndex = DefaultFontIndex;
            }
            else {
                FontIndex = AltFontIndex;
            }
        }
        else {
#endif
        FontIndex = DefaultFontIndex;
#if defined(FE_SB)
        }
#endif
    }

FoundFont:
    DBGFONTS(("FindCreateFont returns %x : %ls (%d,%d)\n", FontIndex,
            FontInfo[FontIndex].FaceName,
            FontInfo[FontIndex].Size.X, FontInfo[FontIndex].Size.Y));
    return FontIndex;

#undef NOT_CREATED_NOR_FOUND
#undef CREATED_BUT_NOT_FOUND
}


/*
 * SelectCurrentSize - Select the right line of the Size listbox/combobox.
 *   bLB       : Size controls is a listbox (TRUE for RasterFonts)
 *   FontIndex : Index into FontInfo[] cache
 *               If < 0 then choose a good font.
 * Returns
 *   FontIndex : Index into FontInfo[] cache
 */
int
SelectCurrentSize(HWND hDlg, BOOL bLB, int FontIndex)
{
    int iCB;
    HWND hWndList;

    DBGFONTS(("SelectCurrentSize %lx %s %x\n",
            hDlg, bLB ? "Raster" : "TrueType", FontIndex));

    hWndList = GetDlgItem(hDlg, bLB ? IDD_PIXELSLIST : IDD_POINTSLIST);
    iCB = lcbGETCOUNT(hWndList, bLB);
    DBGFONTS(("  Count of items in %lx = %lx\n", hWndList, iCB));

    if (FontIndex >= 0) {
        /*
         * look for FontIndex
         */
        while (iCB > 0) {
            iCB--;
            if (lcbGETITEMDATA(hWndList, bLB, iCB) == FontIndex) {
                lcbSETCURSEL(hWndList, bLB, iCB);
                break;
            }
        }
    } else {
        /*
         * look for a reasonable default size: looking backwards, find
         * the first one same height or smaller.
         */
        DWORD Size;
        Size = GetWindowLong(hDlg, GWLP_USERDATA);
#if defined(FE_SB)
        ASSERT(OEMCP != 0);
        if (gfFESystem && bLB
            && (FontInfo[CurrentFontIndex].tmCharSet != LOBYTE(LOWORD(Size)))
           )
        {
            TCHAR AltFaceName[LF_FACESIZE];
            COORD AltFontSize;
            BYTE  AltFontFamily;
            ULONG AltFontIndex = 0;

            MakeAltRasterFont(gpStateInfo->CodePage, &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName);

            while (iCB > 0) {
                iCB--;
                if (lcbGETITEMDATA(hWndList, bLB, iCB) == (int)AltFontIndex) {
                    lcbSETCURSEL(hWndList, bLB, iCB);
                    break;
                }
            }
        }
        else
#endif
        while (iCB > 0) {
            iCB--;
            FontIndex = lcbGETITEMDATA(hWndList, bLB, iCB);
            if (FontInfo[FontIndex].Size.Y <= HIWORD(Size)) {
                lcbSETCURSEL(hWndList, bLB, iCB);
                break;
            }
        }
    }
    DBGFONTS(("SelectCurrentSize returns %x\n", FontIndex));
    return FontIndex;
}


BOOL
SelectCurrentFont(HWND hDlg, int FontIndex)
{
    BOOL bLB;

    DBGFONTS(("SelectCurrentFont hDlg=%lx, FontIndex=%x\n", hDlg, FontIndex));

    bLB = !TM_IS_TT_FONT(FontInfo[FontIndex].Family);

    SendDlgItemMessage(hDlg, IDD_FACENAME, LB_SELECTSTRING, (WPARAM)-1,
            bLB ? (LPARAM)tszRasterFonts : (LPARAM)FontInfo[FontIndex].FaceName);

    SelectCurrentSize(hDlg, bLB, FontIndex);
    return bLB;
}


BOOL
PreviewInit(
    HWND hDlg
    )

/*  PreviewInit
 *      Prepares the preview code, sizing the window and the dialog to
 *      make an attractive preview.
 *  Returns TRUE if Raster Fonts, FALSE if TT Font
 */

{
    int nFont;

    DBGFONTS(("PreviewInit hDlg=%lx\n", hDlg));

    /*
     * Set the current font
     */
    nFont = FindCreateFont(gpStateInfo->FontFamily,
                           gpStateInfo->FaceName,
                           gpStateInfo->FontSize,
                           gpStateInfo->FontWeight,
                           gpStateInfo->CodePage);

    DBGPRINT(("Changing Font Number from %d to %d\n",
              CurrentFontIndex, nFont));
    CurrentFontIndex = nFont;

    return SelectCurrentFont(hDlg, nFont);
}


BOOL
PreviewUpdate(
    HWND hDlg,
    BOOL bLB
    )

/*++

    Does the preview of the selected font.

--*/

{
    PFONT_INFO lpFont;
    int FontIndex;
    LONG lIndex;
    HWND hWnd;
    TCHAR tszText[60];
    TCHAR tszFace[LF_FACESIZE + CCH_SELECTEDFONT];
    HWND hWndList;

    DBGFONTS(("PreviewUpdate hDlg=%lx, %s\n", hDlg,
            bLB ? "Raster" : "TrueType"));

    hWndList = GetDlgItem(hDlg, bLB ? IDD_PIXELSLIST : IDD_POINTSLIST);

    /* When we select a font, we do the font preview by setting it into
     *  the appropriate list box
     */
    lIndex = lcbGETCURSEL(hWndList, bLB);
    DBGFONTS(("PreviewUpdate GETCURSEL gets %x\n", lIndex));
    if ((lIndex < 0) && !bLB) {
        COORD NewSize;

        lIndex = (LONG)SendDlgItemMessage(hDlg, IDD_FACENAME, LB_GETCURSEL, 0, 0L);
        SendDlgItemMessage(hDlg, IDD_FACENAME, LB_GETTEXT, lIndex, (LPARAM)tszFace);
        NewSize.X = 0;
        NewSize.Y = (SHORT)GetPointSizeInRange(hDlg, MIN_PIXEL_HEIGHT, MAX_PIXEL_HEIGHT);

        if (NewSize.Y == 0) {
            TCHAR tszBuf[60];
            /*
             * Use tszText, tszBuf to put up an error msg for bad point size
             */
            gbPointSizeError = TRUE;
            LoadString(ghInstance, IDS_FONTSIZE, tszBuf, NELEM(tszBuf));
            wsprintf(tszText, tszBuf, MIN_PIXEL_HEIGHT, MAX_PIXEL_HEIGHT);

            GetWindowText(hDlg, tszBuf, NELEM(tszBuf));
            MessageBoxEx(hDlg, tszText, tszBuf, MB_OK|MB_ICONINFORMATION, 0L);
            SetFocus(hWndList);
            gbPointSizeError = FALSE;
            return FALSE;
        }
        FontIndex = FindCreateFont(FF_MODERN|TMPF_VECTOR|TMPF_TRUETYPE,
                                   tszFace, NewSize, 0,
                                   gpStateInfo->CodePage);
    } else {
        FontIndex = lcbGETITEMDATA(hWndList, bLB, lIndex);
    }

    if (FontIndex < 0) {
        FontIndex = DefaultFontIndex;
    }

    /*
     * If we've selected a new font, tell the property sheet we've changed
     */
    if (CurrentFontIndex != (ULONG)FontIndex) {
        CurrentFontIndex = FontIndex;
    }

    lpFont = &FontInfo[FontIndex];

    /* Display the new font */

    _tcscpy(tszFace, tszSelectedFont);
    _tcscat(tszFace, lpFont->FaceName);
    SetDlgItemText(hDlg, IDD_GROUP, tszFace);

    /* Put the font size in the static boxes */
    wsprintf(tszText, TEXT("%u"), lpFont->Size.X);
    hWnd = GetDlgItem(hDlg, IDD_FONTWIDTH);
    SetWindowText(hWnd, tszText);
    InvalidateRect(hWnd, NULL, TRUE);
    wsprintf(tszText, TEXT("%u"), lpFont->Size.Y);
    hWnd = GetDlgItem(hDlg, IDD_FONTHEIGHT);
    SetWindowText(hWnd, tszText);
    InvalidateRect(hWnd, NULL, TRUE);

    /* Force the preview windows to repaint */
    hWnd = GetDlgItem(hDlg, IDD_PREVIEWWINDOW);
    SendMessage(hWnd, CM_PREVIEW_UPDATE, 0, 0);
    hWnd = GetDlgItem(hDlg, IDD_FONTWINDOW);
    InvalidateRect(hWnd, NULL, TRUE);

    DBGFONTS(("Font %x, (%d,%d) %ls\n", FontIndex,
            FontInfo[FontIndex].Size.X,
            FontInfo[FontIndex].Size.Y,
            FontInfo[FontIndex].FaceName));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\fontdlg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fontdlg.h

Abstract:

    This module contains the definitions for console font dialog

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#ifndef FONTDLG_H
#define FONTDLG_H

/* ----- Literals ----- */

#define MAXDIMENSTRING     40  // max text in combo box
#define DX_TTBITMAP        20
#define DY_TTBITMAP        12
#define CCH_RASTERFONTS    24
#define CCH_SELECTEDFONT   30


/* ----- Macros ----- */
/*
 *  High-level macros
 *
 *  These macros handle the SendMessages that go tofrom list boxes
 *  and combo boxes.
 *
 *  The "xxx_lcb" prefix stands for leaves CritSect & "list or combo box".
 *
 *  Basically, we're providing mnemonic names for what would otherwise
 *  look like a whole slew of confusing SendMessage's.
 *
 */
#define lcbRESETCONTENT(hWnd, bLB) \
        SendMessage(hWnd, bLB ? LB_RESETCONTENT : CB_RESETCONTENT, 0, 0L)

#define lcbGETTEXT(hWnd, bLB, w) \
        SendMessage(hWnd, bLB ? LB_GETTEXT : CB_GETLBTEXT, w, 0L)

#define lcbFINDSTRINGEXACT(hWnd, bLB, pwsz) \
        (LONG)SendMessage(hWnd, bLB ? LB_FINDSTRINGEXACT : CB_FINDSTRINGEXACT, \
                          (WPARAM)-1, (LPARAM)pwsz)

#define lcbADDSTRING(hWnd, bLB, pwsz) \
        (LONG)SendMessage(hWnd, bLB ? LB_ADDSTRING : CB_ADDSTRING, 0, (LPARAM)pwsz)

#define lcbSETITEMDATA(hWnd, bLB, w, nFont) \
        SendMessage(hWnd, bLB ? LB_SETITEMDATA : CB_SETITEMDATA, w, nFont)

#define lcbGETITEMDATA(hWnd, bLB, w) \
        (LONG)SendMessage(hWnd, bLB ? LB_GETITEMDATA : CB_GETITEMDATA, w, 0L)

#define lcbGETCOUNT(hWnd, bLB) \
        (LONG)SendMessage(hWnd, bLB ? LB_GETCOUNT : CB_GETCOUNT, 0, 0L)

#define lcbGETCURSEL(hWnd, bLB) \
        (LONG)SendMessage(hWnd, bLB ? LB_GETCURSEL : CB_GETCURSEL, 0, 0L)

#define lcbSETCURSEL(hWnd, bLB, w) \
        SendMessage(hWnd, bLB ? LB_SETCURSEL : CB_SETCURSEL, w, 0L)

#endif /* #ifndef FONTDLG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\dbcs.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dbcs.c

Abstract:

    This module contains the code for console DBCS font dialog

Author:

    kazum Feb-27-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#if defined(FE_SB)

SINGLE_LIST_ENTRY gTTFontList;    // This list contain TTFONTLIST data.


UINT OEMCP;
BOOL gfFESystem;


WORD
ConvertStringToDec(
    LPTSTR lpch,
    LPTSTR *endptr
    )
{
    TCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != TEXT('\0'))
    {
        if (TEXT('0') <= ch && ch <= TEXT('9'))
            val = (val * 10) + (ch - TEXT('0'));
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}

WORD
ConvertStringToHex(
    LPTSTR lpch,
    LPTSTR *endptr
    )
{
    TCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != TEXT('\0'))
    {
        if (TEXT('0') <= ch && ch <= TEXT('9'))
            val = (val << 4) + (ch - TEXT('0'));
        else if (TEXT('A') <= ch && ch <= TEXT('F'))
            val = (val << 4) + (ch - TEXT('A') + 10);
        else if (TEXT('a') <= ch && ch <= TEXT('f'))
            val = (val << 4) + (ch - TEXT('a') + 10);
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}


NTSTATUS
MakeAltRasterFont(
    UINT CodePage,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPTSTR AltFaceName
    )
{
    DWORD i;
    DWORD Find;
    ULONG FontIndex;
    COORD FontSize = FontInfo[DefaultFontIndex].Size;
    COORD FontDelta;
    BOOL  fDbcsCharSet = IS_ANY_DBCS_CHARSET( CodePageToCharSet( CodePage ) );

    FontIndex = 0;
    Find = (DWORD)-1;
    for (i=0; i < NumberOfFonts; i++)
    {
        if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
            IS_ANY_DBCS_CHARSET(FontInfo[i].tmCharSet) == fDbcsCharSet
           )
        {
            FontDelta.X = (SHORT)abs(FontSize.X - FontInfo[i].Size.X);
            FontDelta.Y = (SHORT)abs(FontSize.Y - FontInfo[i].Size.Y);
            if (Find > (DWORD)(FontDelta.X + FontDelta.Y))
            {
                Find = (DWORD)(FontDelta.X + FontDelta.Y);
                FontIndex = i;
            }
        }
    }

    *AltFontIndex = FontIndex;
    _tcscpy(AltFaceName, FontInfo[*AltFontIndex].FaceName);
    *AltFontSize = FontInfo[*AltFontIndex].Size;
    *AltFontFamily = FontInfo[*AltFontIndex].Family;

    DBGFONTS(("MakeAltRasterFont : AltFontIndex = %ld\n", *AltFontIndex));

    return STATUS_SUCCESS;
}

NTSTATUS
InitializeDbcsMisc(
    VOID
    )
{
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    DWORD dwIndex;
    LPWSTR pwsz;

    gTTFontList.Next = NULL;

    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_TTFONT,
                          &hkRegistry);
    if (!NT_SUCCESS( Status )) {
        DBGPRINT(("CONSRV: NtOpenKey failed %ws\n", MACHINE_REGISTRY_CONSOLE));
    }
    else {
        LPTTFONTLIST pTTFontList;

        for( dwIndex = 0; ; dwIndex++) {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status )) {
                break;
            }

            pTTFontList = LocalAlloc(LPTR, sizeof(TTFONTLIST));
            if (pTTFontList == NULL) {
                break;
            }

            pTTFontList->List.Next = NULL;
            pTTFontList->CodePage = ConvertStringToDec(awchValue, NULL);
            pwsz = awchData;
            if (*pwsz == BOLD_MARK) {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            else
                pTTFontList->fDisableBold = FALSE;
            _tcscpy(pTTFontList->FaceName1, pwsz);

            pwsz += _tcslen(pwsz) + 1;
            if (*pwsz == BOLD_MARK) {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            _tcscpy(pTTFontList->FaceName2, pwsz);

            PushEntryList(&gTTFontList, &(pTTFontList->List));
        }

        NtClose(hkRegistry);
    }

    ASSERT(OEMCP != 0); // OEMCP must be initialized so far by CPL_INIT
    ASSERT(IsFarEastCP(OEMCP) == gfFESystem);

    return STATUS_SUCCESS;
}

BYTE
CodePageToCharSet(
    UINT CodePage
    )
{
    CHARSETINFO csi;

    if (!TranslateCharsetInfo((DWORD *)IntToPtr(CodePage), &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = OEM_CHARSET;

    return (BYTE)csi.ciCharset;
}

LPTTFONTLIST
SearchTTFont(
    LPTSTR ptszFace,
    BOOL   fCodePage,
    UINT   CodePage
    )
{
    PSINGLE_LIST_ENTRY pTemp = gTTFontList.Next;

    if (ptszFace) {
        while (pTemp != NULL) {
            LPTTFONTLIST pTTFontList = (LPTTFONTLIST)pTemp;

            if (wcscmp(ptszFace, pTTFontList->FaceName1) == 0 ||
                wcscmp(ptszFace, pTTFontList->FaceName2) == 0    ) {
                if (fCodePage)
                    if (pTTFontList->CodePage == CodePage )
                        return pTTFontList;
                    else
                        return NULL;
                else
                    return pTTFontList;
            }

            pTemp = pTemp->Next;
        }
    }

    return NULL;
}

BOOL
IsAvailableTTFont(
    LPTSTR ptszFace
    )
{
    if (SearchTTFont(ptszFace, FALSE, 0))
        return TRUE;
    else
        return FALSE;
}

BOOL
IsAvailableTTFontCP(
    LPTSTR ptszFace,
    UINT CodePage
    )
{
    if (SearchTTFont(ptszFace, TRUE, CodePage))
        return TRUE;
    else
        return FALSE;
}

BOOL
IsDisableBoldTTFont(
    LPTSTR ptszFace
    )
{
    LPTTFONTLIST pTTFontList;

    pTTFontList = SearchTTFont(ptszFace, FALSE, 0);
    if (pTTFontList != NULL)
        return pTTFontList->fDisableBold;
    else
        return FALSE;
}

LPTSTR
GetAltFaceName(
    LPTSTR ptszFace
    )
{
    LPTTFONTLIST pTTFontList;

    pTTFontList = SearchTTFont(ptszFace, FALSE, 0);
    if (pTTFontList != NULL) {
        if (wcscmp(ptszFace, pTTFontList->FaceName1) == 0) {
            return pTTFontList->FaceName2;
        }
        if (wcscmp(ptszFace, pTTFontList->FaceName2) == 0) {
            return pTTFontList->FaceName1;
        }
        return NULL;
    }
    else
        return NULL;
}

NTSTATUS
DestroyDbcsMisc(
    VOID
    )
{
    while (gTTFontList.Next != NULL) {
        LPTTFONTLIST pTTFontList = (LPTTFONTLIST)PopEntryList(&gTTFontList);

        if (pTTFontList != NULL)
            LocalFree(pTTFontList);
    }

    return STATUS_SUCCESS;
}

typedef struct _LC_List {
    struct _LC_List* Next;
    BOOL   FindFlag;
    TCHAR  LC_String[9];
} LC_List, *PLC_List;

static PLC_List LocaleList = NULL;

BOOL CALLBACK
EnumProc(
    LPTSTR LC_String
    )
{
    PLC_List TmpList;

    if (_tcslen(LC_String) <= (sizeof(LocaleList->LC_String)/sizeof(TCHAR))-1)
    {
        TmpList = (PLC_List)&LocaleList;

        while(TmpList->Next != NULL)
            TmpList = TmpList->Next;

        TmpList->Next = LocalAlloc(LPTR, sizeof(LC_List));
        if (TmpList->Next != NULL)
        {
            TmpList = TmpList->Next;
            _tcscpy(TmpList->LC_String, LC_String);
        }
    }
    return TRUE;
}


int
LanguageListCreate(
    HWND hDlg,
    UINT CodePage
    )

/*++

    Initializes the Language list by enumerating all Locale Information.

    Returns
--*/

{
    HWND hWndLanguageCombo;
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    DWORD dwIndex;
    PLC_List TmpList;
    WORD LangID;
    LCID Locale;
    int  cchData;
    LONG lListIndex;
    UINT cp;
    BOOL fRet;
    CPINFOEX cpinfo;

    /*
     * Enumrate system locale information
     */
    EnumSystemLocales( EnumProc, CP_INSTALLED );

    /*
     * Enumrate registory key
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_NLS,
                          &hkRegistry);
    if (!NT_SUCCESS( Status )) {
        DBGPRINT(("CONSRV: NtOpenKey failed %ws\n", MACHINE_REGISTRY_CONSOLE));
    }
    else {
        for( dwIndex = 0; ; dwIndex++)
        {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status ))
            {
                break;
            }

            TmpList = (PLC_List)&LocaleList;
            while(TmpList->Next != NULL)
            {
                TmpList = TmpList->Next;
                if (_tcscmp(awchValue, TmpList->LC_String) == 0)
                {
                    TmpList->FindFlag = TRUE;
                    break;
                }
            }
        }

        NtClose(hkRegistry);

    }

    /*
     * Create ComboBox items
     */
    hWndLanguageCombo = GetDlgItem(hDlg, IDD_LANGUAGELIST);
    SendMessage(hWndLanguageCombo, CB_RESETCONTENT, 0, 0L);

    TmpList = (PLC_List)&LocaleList;
    while(TmpList->Next != NULL)
    {
        TmpList = TmpList->Next;

        if (TmpList->FindFlag)
        {
            LangID = ConvertStringToHex(TmpList->LC_String, NULL);
            Locale = MAKELCID( LangID, SORT_DEFAULT );

            cchData = GetLocaleInfo(Locale, LOCALE_IDEFAULTCODEPAGE,
                                    awchData, sizeof(awchData)/sizeof(TCHAR));
            if (cchData)
            {
                awchData[cchData] = TEXT('\0');
                cp = ConvertStringToDec(awchData, NULL);

                if ( (IS_ANY_DBCS_CHARSET(CodePageToCharSet(cp)) && GetOEMCP() == cp) ||
                     (!IS_ANY_DBCS_CHARSET(CodePageToCharSet(cp))) ) {

                    fRet = GetCPInfoEx(cp, 0, &cpinfo);
                    if (fRet) {
                        lListIndex = (LONG)SendMessage(hWndLanguageCombo, CB_ADDSTRING, 0, (LPARAM)cpinfo.CodePageName);
                        SendMessage(hWndLanguageCombo, CB_SETITEMDATA, (DWORD)lListIndex, cp);

                        if (CodePage == cp) {
                            SendMessage(hWndLanguageCombo, CB_SETCURSEL, lListIndex, 0L);
                        }
                    }
                }
            }
        }
    }

    {
        PLC_List Tmp;

        TmpList = (PLC_List)&LocaleList;
        while(TmpList->Next != NULL)
        {
            Tmp = TmpList;
            TmpList = TmpList->Next;

            if (Tmp != (PLC_List)&LocaleList)
                LocalFree(Tmp);
        }

        LocaleList = NULL;
    }


    /*
     * Get the LocaleIndex from the currently selected item.
     * (i will be LB_ERR if no currently selected item).
     */
    lListIndex = (LONG)SendMessage(hWndLanguageCombo, CB_GETCURSEL, 0, 0L);
    return (LONG)SendMessage(hWndLanguageCombo, CB_GETITEMDATA, lListIndex, 0L);
}


// v-HirShi Nov.20.1996
int
LanguageDisplay(
    HWND hDlg,
    UINT CodePage
    )

/*++

    Display the Language .

    Returns
--*/

{
    HWND hWndLanguageDisp;
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    DWORD dwIndex;
    PLC_List TmpList;
    WORD LangID;
    LCID Locale;
    int  cchData;
    LONG lListIndex;
    UINT cp;
    BOOL fRet;
    CPINFOEX cpinfo;

    /*
     * Enumrate system locale information
     */
    EnumSystemLocales( EnumProc, CP_INSTALLED );

    /*
     * Enumrate registory key
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_NLS,
                          &hkRegistry);
    if (!NT_SUCCESS( Status )) {
        DBGPRINT(("CONSRV: NtOpenKey failed %ws\n", MACHINE_REGISTRY_CONSOLE));
    }
    else {
        for( dwIndex = 0; ; dwIndex++)
        {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status ))
            {
                break;
            }

            TmpList = (PLC_List)&LocaleList;
            while(TmpList->Next != NULL)
            {
                TmpList = TmpList->Next;
                if (_tcscmp(awchValue, TmpList->LC_String) == 0)
                {
                    TmpList->FindFlag = TRUE;
                    break;
                }
            }
        }

        NtClose(hkRegistry);

    }

    /*
     * Display Language
     */

    TmpList = (PLC_List)&LocaleList;
    while(TmpList->Next != NULL)
    {
        TmpList = TmpList->Next;

        if (TmpList->FindFlag)
        {
            LangID = ConvertStringToHex(TmpList->LC_String, NULL);
            Locale = MAKELCID( LangID, SORT_DEFAULT );

            cchData = GetLocaleInfo(Locale, LOCALE_IDEFAULTCODEPAGE,
                                    awchData, sizeof(awchData)/sizeof(TCHAR));
            if (cchData)
            {
                awchData[cchData] = TEXT('\0');
                cp = ConvertStringToDec(awchData, NULL);

                fRet = GetCPInfoEx(cp, 0, &cpinfo);
                if (fRet) {
                    if (CodePage == cp) {
                        hWndLanguageDisp = GetDlgItem(hDlg, IDD_LANGUAGE);
                        SetWindowText(hWndLanguageDisp, cpinfo.CodePageName);
                    }
                }
            }
        }
    }

    {
        PLC_List Tmp;

        TmpList = (PLC_List)&LocaleList;
        while(TmpList->Next != NULL)
        {
            Tmp = TmpList;
            TmpList = TmpList->Next;

            if (Tmp != (PLC_List)&LocaleList)
                LocalFree(Tmp);
        }

        LocaleList = NULL;
    }

    return TRUE;
}


#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <tchar.h>
#include <winuserp.h>
#include <winbasep.h>
#include <winconp.h>
#include <wingdip.h>
#include <commctrl.h>
#include "menu.h"
#include "dialogs.h"
#include "console.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\link.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    link.c

Abstract:

        This file implements the code to save to a link file.

Author:

    Rick Turner (RickTu) Sep-12-1995

--*/

#include "precomp.h"
#pragma hdrstop

#include "shlobj.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "shlobjp.h"
#include "initguid.h"
#include "oleguid.h"
#include "shlguid.h"
#include "shlguidp.h"



BOOL PathIsLink(LPCTSTR szFile)
{
    BOOL fRet;

    LPCTSTR pszExt = PathFindExtension(szFile);

    if (pszExt)
    {
        fRet = (lstrcmpi(TEXT(".lnk"), pszExt) == 0);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}


BOOL
WereWeStartedFromALnk()
{
    STARTUPINFO si;

    GetStartupInfo( &si );

    // Check to make sure we were started from a link
    if (si.dwFlags & STARTF_TITLEISLINKNAME)
    {
        if (PathIsLink(si.lpTitle))
            return TRUE;
    }

    return FALSE;
}



BOOL
SetLinkValues(
    PCONSOLE_STATE_INFO pStateInfo
    )

/*++

Routine Description:

    This routine writes values to the link file that spawned this console
    window.  The link file name is still in the startinfo structure.

Arguments:

    pStateInfo - pointer to structure containing information

Return Value:

    none

--*/

{

    STARTUPINFO si;
    IShellLink * psl;
    IPersistFile * ppf;
    IShellLinkDataList * psldl;
    NT_CONSOLE_PROPS props;
#if defined(FE_SB)
    NT_FE_CONSOLE_PROPS fe_props;
#endif
    BOOL bRet;

    GetStartupInfo( &si );

    // Check to make sure we were started from a link
    if (!(si.dwFlags & STARTF_TITLEISLINKNAME) )
        return FALSE;

    // Make sure we are dealing w/a link file
    if (!PathIsLink(si.lpTitle))
        return FALSE;

    // Ok, load the link so we can modify it...
    if (FAILED(SHCoCreateInstance( NULL, &CLSID_ShellLink, NULL, &IID_IShellLink, &psl )))
        return FALSE;

    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf)))
    {
        WCHAR wszPath[ MAX_PATH ];

        StrToOleStr(wszPath, si.lpTitle );
        if (FAILED(ppf->lpVtbl->Load(ppf, wszPath, 0)))
        {
            ppf->lpVtbl->Release(ppf);
            psl->lpVtbl->Release(psl);
            return FALSE;
        }
    }

    // Now the link is loaded, generate new console settings section to replace
    // the one in the link.

    ((LPDBLIST)&props)->cbSize      = sizeof(props);
    ((LPDBLIST)&props)->dwSignature = NT_CONSOLE_PROPS_SIG;
    props.wFillAttribute            = pStateInfo->ScreenAttributes;
    props.wPopupFillAttribute       = pStateInfo->PopupAttributes;
    props.dwScreenBufferSize        = pStateInfo->ScreenBufferSize;
    props.dwWindowSize              = pStateInfo->WindowSize;
    props.dwWindowOrigin.X          = (SHORT)pStateInfo->WindowPosX;
    props.dwWindowOrigin.Y          = (SHORT)pStateInfo->WindowPosY;
    props.nFont                     = 0;
    props.nInputBufferSize          = 0;
    props.dwFontSize                = pStateInfo->FontSize;
    props.uFontFamily               = pStateInfo->FontFamily;
    props.uFontWeight               = pStateInfo->FontWeight;
    CopyMemory( props.FaceName, pStateInfo->FaceName, sizeof(props.FaceName) );
    props.uCursorSize               = pStateInfo->CursorSize;
    props.bFullScreen               = pStateInfo->FullScreen;
    props.bQuickEdit                = pStateInfo->QuickEdit;
    props.bInsertMode               = pStateInfo->InsertMode;
    props.bAutoPosition             = pStateInfo->AutoPosition;
    props.uHistoryBufferSize        = pStateInfo->HistoryBufferSize;
    props.uNumberOfHistoryBuffers   = pStateInfo->NumberOfHistoryBuffers;
    props.bHistoryNoDup             = pStateInfo->HistoryNoDup;
    CopyMemory( props.ColorTable, pStateInfo->ColorTable, sizeof(props.ColorTable) );

#if defined(FE_SB)
    ((LPDBLIST)&fe_props)->cbSize      = sizeof(fe_props);
    ((LPDBLIST)&fe_props)->dwSignature = NT_FE_CONSOLE_PROPS_SIG;
    fe_props.uCodePage                 = pStateInfo->CodePage;
#endif

    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IShellLinkDataList, &psldl)))
    {
        //
        // Store the changes back into the link...
        //
        psldl->lpVtbl->RemoveDataBlock( psldl, NT_CONSOLE_PROPS_SIG );
        psldl->lpVtbl->AddDataBlock( psldl, (LPVOID)&props );

#if defined(FE_SB)
        if (gfFESystem) {
            psldl->lpVtbl->RemoveDataBlock( psldl, NT_FE_CONSOLE_PROPS_SIG );
            psldl->lpVtbl->AddDataBlock( psldl, (LPVOID)&fe_props );
        }
#endif

        psldl->lpVtbl->Release( psldl );
    }



    bRet = SUCCEEDED(ppf->lpVtbl->Save( ppf, NULL, TRUE ));
    ppf->lpVtbl->Release(ppf);
    psl->lpVtbl->Release(psl);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\menu.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    menu.h

Abstract:

    This module contains the definitions for console system menu

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

/*
 * DIALOG IDs
 *
 */

#define CM_SETCOLOR       (WM_USER+1)
#define CM_PREVIEW_UPDATE (WM_USER+2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\misc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    misc.c

Abstract:

        This file implements the NT console server font routines.

Author:

    Therese Stowell (thereses) 22-Jan-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef DEBUG_PRINT
ULONG gDebugFlag = 0 ;
// ULONG gDebugFlag = _DBGOUTPUT | _DBGCHARS | _DBGFONTS | _DBGFONTS2 ;
#endif

PFONT_INFO FontInfo = NULL;
ULONG FontInfoLength;
ULONG NumberOfFonts;
BOOL gbEnumerateFaces = FALSE;


#define FE_ABANDONFONT 0
#define FE_SKIPFONT    1
#define FE_FONTOK      2

/*
 * Initial default fonts and face names
 */
PFACENODE gpFaceNames = NULL;

/*
 * TTPoints -- Initial font pixel heights for TT fonts
 */
SHORT TTPoints[] = {
    5, 6, 7, 8, 10, 12, 14, 16, 18, 20, 24, 28, 36, 72
};
#if defined(FE_SB)
/*
 * TTPointsDbcs -- Initial font pixel heights for TT fonts of DBCS.
 * So, This list except odd point size because font width is (SBCS:DBCS != 1:2).
 */
SHORT TTPointsDbcs[] = {
    6, 8, 10, 12, 14, 16, 18, 20, 24, 28, 36, 72
};
#endif


typedef struct _FONTENUMDATA {
    HDC hDC;
    BOOL bFindFaces;
    ULONG ulFE;
    PSHORT pTTPoints;
    UINT nTTPoints;
} FONTENUMDATA, *PFONTENUMDATA;


PFACENODE
AddFaceNode(PFACENODE *ppStart, LPTSTR ptsz) {
    PFACENODE pNew;
    PFACENODE *ppTmp;
    int cb;

    /*
     * Is it already here?
     */
    for (ppTmp = ppStart; *ppTmp; ppTmp = &((*ppTmp)->pNext)) {
        if (_tcscmp(((*ppTmp)->atch), ptsz) == 0) {
            // already there !
            return *ppTmp;
        }
    }

    cb = (_tcslen(ptsz) + 1) * sizeof(TCHAR);
    pNew = (PFACENODE)HeapAlloc(RtlProcessHeap(),0,sizeof(FACENODE) + cb);
    if (pNew == NULL) {
        return NULL;
    }

    pNew->pNext = NULL;
    pNew->dwFlag = 0;
    _tcscpy(pNew->atch, ptsz);
    *ppTmp = pNew;
    return pNew;
}


VOID
DestroyFaceNodes( VOID ) {
    PFACENODE pNext;
    PFACENODE pTmp;

    pTmp = gpFaceNames;
    while (pTmp != NULL) {
        pNext = pTmp->pNext;
        HeapFree(RtlProcessHeap(), 0, pTmp);
        pTmp = pNext;
    }
    gpFaceNames = NULL;
}


int
AddFont(
    ENUMLOGFONT *pelf,
    NEWTEXTMETRIC *pntm,
    int nFontType,
    HDC hDC,
    PFACENODE pFN
    )

/*++

    Add the font desribed by the LOGFONT structure to the font table if
    it's not already there.

--*/

{
    HFONT hFont;
    TEXTMETRIC tm;
    LONG nFont;
    COORD SizeToShow;
    COORD SizeActual;
    COORD SizeWant;
    BYTE tmFamily;
    SIZE Size;
    LPTSTR ptszFace = pelf->elfLogFont.lfFaceName;

    /* get font info */
    SizeWant.X = (SHORT)pelf->elfLogFont.lfWidth;
    SizeWant.Y = (SHORT)pelf->elfLogFont.lfHeight;

CreateBoldFont:
    pelf->elfLogFont.lfQuality = DEFAULT_QUALITY;
    hFont = CreateFontIndirect(&pelf->elfLogFont);
    if (!hFont) {
        DBGFONTS(("    REJECT  font (can't create)\n"));
        return FE_SKIPFONT;  // same font in other sizes may still be suitable
    }

    DBGFONTS2(("    hFont = %lx\n", hFont));

    SelectObject(hDC, hFont);
    GetTextMetrics(hDC, &tm);

    GetTextExtentPoint32(hDC, TEXT("0"), 1, &Size);
    SizeActual.X = (SHORT)Size.cx;
    SizeActual.Y = (SHORT)(tm.tmHeight + tm.tmExternalLeading);
    DBGFONTS2(("    actual size %d,%d\n", SizeActual.X, SizeActual.Y));
    tmFamily = tm.tmPitchAndFamily;
    if (TM_IS_TT_FONT(tmFamily) && (SizeWant.Y >= 0)) {
        SizeToShow = SizeWant;
        if (SizeWant.X == 0) {
            // Asking for zero width height gets a default aspect-ratio width.
            // It's better to show that width rather than 0.
            SizeToShow.X = SizeActual.X;
        }
    } else {
        SizeToShow = SizeActual;
    }

    //
    // The size shouldn't be zero. This is to help catch Windows Bug #332453.
    //
    ASSERT(SizeActual.X != 0 && SizeActual.Y != 0 && "If you hit this please e-mail jasonsch");

    DBGFONTS2(("    SizeToShow = (%d,%d), SizeActual = (%d,%d)\n",
            SizeToShow.X, SizeToShow.Y, SizeActual.X, SizeActual.Y));

    /*
     * NOW, determine whether this font entry has already been cached
     * LATER : it may be possible to do this before creating the font, if
     * we can trust the dimensions & other info from pntm.
     * Sort by size:
     *  1) By pixelheight (negative Y values)
     *  2) By height (as shown)
     *  3) By width (as shown)
     */
    for (nFont = 0; nFont < (LONG)NumberOfFonts; ++nFont) {
        COORD SizeShown;

        if (FontInfo[nFont].hFont == NULL) {
            DBGFONTS(("!   Font %x has a NULL hFont\n", nFont));
            continue;
        }

        if (FontInfo[nFont].SizeWant.X > 0) {
            SizeShown.X = FontInfo[nFont].SizeWant.X;
        } else {
            SizeShown.X = FontInfo[nFont].Size.X;
        }

        if (FontInfo[nFont].SizeWant.Y > 0) {
            // This is a font specified by cell height.
            SizeShown.Y = FontInfo[nFont].SizeWant.Y;
        } else {
            SizeShown.Y = FontInfo[nFont].Size.Y;
            if (FontInfo[nFont].SizeWant.Y < 0) {
                // This is a TT font specified by character height.
                if (SizeWant.Y < 0 && SizeWant.Y > FontInfo[nFont].SizeWant.Y) {
                    // Requested pixelheight is smaller than this one.
                    DBGFONTS(("INSERT %d pt at %x, before %d pt\n",
                            -SizeWant.Y, nFont, -FontInfo[nFont].SizeWant.Y));
                    break;
                }
            }
        }

        // DBGFONTS(("    SizeShown(%x) = (%d,%d)\n",nFont,SizeShown.X,SizeShown.Y));

        if (SIZE_EQUAL(SizeShown, SizeToShow) &&
                FontInfo[nFont].Family == tmFamily &&
                FontInfo[nFont].Weight == tm.tmWeight &&
                _tcscmp(FontInfo[nFont].FaceName, ptszFace) == 0) {
            /*
             * Already have this font
             */
            DBGFONTS2(("    Already have the font\n"));
            DeleteObject(hFont);
            return FE_FONTOK;
        }


        if ((SizeToShow.Y < SizeShown.Y) ||
                (SizeToShow.Y == SizeShown.Y && SizeToShow.X < SizeShown.X)) {
            /*
             * This new font is smaller than nFont
             */
            DBGFONTS(("INSERT at %x, SizeToShow = (%d,%d)\n", nFont,
                    SizeToShow.X,SizeToShow.Y));
            break;
        }
    }

    /*
     * If we have to grow our font table, do it
     */
    if (NumberOfFonts == FontInfoLength) {
        PFONT_INFO Temp;

        FontInfoLength += FONT_INCREMENT;
        Temp = (PFONT_INFO)HeapReAlloc(RtlProcessHeap(), 0, FontInfo,
                                       sizeof(FONT_INFO) * FontInfoLength);
        if (Temp == NULL) {
            FontInfoLength -= FONT_INCREMENT;
            return FE_ABANDONFONT;  // no point enumerating more - no memory!
        }
        FontInfo = Temp;
    }

    /*
     * The font we are adding should be inserted into the list,
     * if it is smaller than the last one.
     */
    if (nFont < (LONG)NumberOfFonts) {
        RtlMoveMemory(&FontInfo[nFont+1],
                      &FontInfo[nFont],
                      sizeof(FONT_INFO) * (NumberOfFonts - nFont));
    }

    /*
     * Store the font info
     */
    FontInfo[nFont].hFont = hFont;
    FontInfo[nFont].Family = tmFamily;
    FontInfo[nFont].Size = SizeActual;
    if (TM_IS_TT_FONT(tmFamily)) {
        FontInfo[nFont].SizeWant = SizeWant;
    } else {
        FontInfo[nFont].SizeWant.X = 0;
        FontInfo[nFont].SizeWant.Y = 0;
    }
    FontInfo[nFont].Weight = tm.tmWeight;
    FontInfo[nFont].FaceName = pFN->atch;
#if defined(FE_SB)
    FontInfo[nFont].tmCharSet = tm.tmCharSet;
#endif

    ++NumberOfFonts;

    /*
     * If this is a true type font, create a bold version too.
     */
    if (nFontType == TRUETYPE_FONTTYPE && !IS_BOLD(FontInfo[nFont].Weight)) {
          pelf->elfLogFont.lfWeight = FW_BOLD;
          goto CreateBoldFont;
    }

    return FE_FONTOK;  // and continue enumeration
}


VOID
InitializeFonts( VOID )
{
    EnumerateFonts(EF_DEFFACE);  // Just the Default font
}


VOID
DestroyFonts( VOID )
{
    ULONG FontIndex;

    if (FontInfo != NULL) {
        for (FontIndex = 0; FontIndex < NumberOfFonts; FontIndex++) {
            DeleteObject(FontInfo[FontIndex].hFont);
        }
        HeapFree(RtlProcessHeap(), 0, FontInfo);
        FontInfo = NULL;
        NumberOfFonts = 0;
    }

    DestroyFaceNodes();
}


/*
 * Returns bit combination
 *  FE_ABANDONFONT  - do not continue enumerating this font
 *  FE_SKIPFONT     - skip this font but keep enumerating
 *  FE_FONTOK       - font was created and added to cache or already there
 */
int
FontEnum(
    ENUMLOGFONT *pelf,
    NEWTEXTMETRIC *pntm,
    int nFontType,
    PFONTENUMDATA pfed
    )

/*++

    Is called exactly once by GDI for each font in the system.  This
    routine is used to store the FONT_INFO structure.

--*/

{
    UINT i;
    LPTSTR ptszFace = pelf->elfLogFont.lfFaceName;
    PFACENODE pFN;

    DBGFONTS(("  FontEnum \"%ls\" (%d,%d) weight 0x%lx(%d) %x -- %s\n",
            ptszFace,
            pelf->elfLogFont.lfWidth, pelf->elfLogFont.lfHeight,
            pelf->elfLogFont.lfWeight, pelf->elfLogFont.lfWeight,
            pelf->elfLogFont.lfCharSet,
            pfed->bFindFaces ? "Finding Faces" : "Creating Fonts"));

    //
    // reject variable width and italic fonts, also tt fonts with neg ac
    //


    if
    (
      !(pelf->elfLogFont.lfPitchAndFamily & FIXED_PITCH) ||
      (pelf->elfLogFont.lfItalic)                        ||
      !(pntm->ntmFlags & NTM_NONNEGATIVE_AC)
    )
    {
        if (! IsAvailableTTFont(ptszFace)) {
            DBGFONTS(("    REJECT  face (dbcs, variable pitch, italic, or neg a&c)\n"));
            return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
        }
    }

    /*
     * reject TT fonts for whoom family is not modern, that is do not use
     * FF_DONTCARE    // may be surprised unpleasantly
     * FF_DECORATIVE  // likely to be symbol fonts
     * FF_SCRIPT      // cursive, inappropriate for console
     * FF_SWISS OR FF_ROMAN // variable pitch
     */

    if ((nFontType == TRUETYPE_FONTTYPE) &&
            ((pelf->elfLogFont.lfPitchAndFamily & 0xf0) != FF_MODERN)) {
        DBGFONTS(("    REJECT  face (TT but not FF_MODERN)\n"));
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject non-TT fonts that aren't OEM
     */
    if ((nFontType != TRUETYPE_FONTTYPE) &&
#if defined(FE_SB)
            (!gfFESystem || !IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet)) &&
#endif
            (pelf->elfLogFont.lfCharSet != OEM_CHARSET)) {
        DBGFONTS(("    REJECT  face (not TT nor OEM)\n"));
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject non-TT fonts that are virtical font
     */
    if ((nFontType != TRUETYPE_FONTTYPE) &&
            (ptszFace[0] == TEXT('@'))) {
        DBGFONTS(("    REJECT  face (not TT and TATEGAKI)\n"));
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject non-TT fonts that aren't Terminal
     */
    if (gfFESystem && (nFontType != TRUETYPE_FONTTYPE) &&
            (_tcscmp(ptszFace, TEXT("Terminal")) != 0)) {
        DBGFONTS(("    REJECT  face (not TT nor Terminal)\n"));
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject Far East TT fonts that aren't Far East charset.
     */
    if (IsAvailableTTFont(ptszFace) &&
        !IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet) &&
        !IsAvailableTTFontCP(ptszFace,0)
       ) {
        DBGFONTS(("    REJECT  face (Far East TT and not Far East charset)\n"));
        return FE_SKIPFONT;    // should be enumerate next charset.
    }

    /*
     * Add or find the facename
     */
    pFN = AddFaceNode(&gpFaceNames, ptszFace);
    if (pFN == NULL) {
        return FE_ABANDONFONT;
    }

    if (pfed->bFindFaces) {
        DWORD dwFontType;
        if (nFontType == TRUETYPE_FONTTYPE) {
            DBGFONTS(("NEW TT FACE %ls\n", ptszFace));
            dwFontType = EF_TTFONT;
        } else if (nFontType == RASTER_FONTTYPE) {
            DBGFONTS(("NEW OEM FACE %ls\n",ptszFace));
            dwFontType = EF_OEMFONT;
        }
        pFN->dwFlag |= dwFontType | EF_NEW;
#if defined(FE_SB)
        if (IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet))
            pFN->dwFlag |= EF_DBCSFONT;
#endif
        return FE_SKIPFONT;
    }


    if (IS_BOLD(pelf->elfLogFont.lfWeight)) {
        DBGFONTS2(("    A bold font (weight %d)\n", pelf->elfLogFont.lfWeight));
        // return FE_SKIPFONT;
    }

    /*
     * Add the font to the table. If this is a true type font, add the
     * sizes from the array. Otherwise, just add the size we got.
     */
    if (nFontType & TRUETYPE_FONTTYPE) {
        for (i = 0; i < pfed->nTTPoints; i++) {
            pelf->elfLogFont.lfHeight = pfed->pTTPoints[i];
            pelf->elfLogFont.lfWidth  = 0;
            pelf->elfLogFont.lfWeight = 400;
            pfed->ulFE |= AddFont(pelf, pntm, nFontType, pfed->hDC, pFN);
            if (pfed->ulFE & FE_ABANDONFONT) {
                return FE_ABANDONFONT;
            }
        }
    } else {
            pfed->ulFE |= AddFont(pelf, pntm, nFontType, pfed->hDC, pFN);
            if (pfed->ulFE & FE_ABANDONFONT) {
                return FE_ABANDONFONT;
            }
    }

    return FE_FONTOK;  // and continue enumeration
}

BOOL
DoFontEnum(
    HDC hDC,
    LPTSTR ptszFace,
    PSHORT pTTPoints,
    UINT nTTPoints)
{
    BOOL bDeleteDC = FALSE;
    FONTENUMDATA fed;
    LOGFONT LogFont;

    DBGFONTS(("DoFontEnum \"%ls\"\n", ptszFace));
    if (hDC == NULL) {
        hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
        bDeleteDC = TRUE;
    }

    fed.hDC = hDC;
    fed.bFindFaces = (ptszFace == NULL);
    fed.ulFE = 0;
    fed.pTTPoints = pTTPoints;
    fed.nTTPoints = nTTPoints;
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));
    LogFont.lfCharSet = DEFAULT_CHARSET;
    if (ptszFace)
        _tcscpy(LogFont.lfFaceName, ptszFace);
    /*
     * EnumFontFamiliesEx function enumerates one font in every face in every character set. 
     */
    EnumFontFamiliesEx(hDC, &LogFont, (FONTENUMPROC)FontEnum, (LPARAM)&fed, 0);
    if (bDeleteDC) {
        DeleteDC(hDC);
    }
    return (fed.ulFE & FE_FONTOK) != 0;
}


VOID
RemoveFace(LPTSTR ptszFace)
{
    DWORD i;
    int nToRemove = 0;

    DBGFONTS(("RemoveFace %ls\n", ptszFace));
    //
    // Delete & Remove fonts with Face Name == ptszFace
    //
    for (i = 0; i < NumberOfFonts; i++) {
        if (_tcscmp(FontInfo[i].FaceName, ptszFace) == 0) {
            BOOL bDeleted = DeleteObject(FontInfo[i].hFont);
            DBGPRINT(("RemoveFace: hFont %lx was %sdeleted\n",
                    FontInfo[i].hFont, bDeleted ? "" : "NOT "));
            FontInfo[i].hFont = NULL;
            nToRemove++;
        } else if (nToRemove > 0) {
            /*
             * Shuffle from FontInfo[i] down nToRemove slots.
             */
            RtlMoveMemory(&FontInfo[i - nToRemove],
                    &FontInfo[i],
                    sizeof(FONT_INFO)*(NumberOfFonts - i));
            NumberOfFonts -= nToRemove;
            i -= nToRemove;
            nToRemove = 0;
        }
    }
    NumberOfFonts -= nToRemove;
}

TCHAR DefaultFaceName[LF_FACESIZE];
COORD DefaultFontSize;
BYTE  DefaultFontFamily;
ULONG DefaultFontIndex = 0;
ULONG CurrentFontIndex = 0;

NTSTATUS
EnumerateFonts(
    DWORD Flags)
{
    TEXTMETRIC tm;
    HDC hDC;
    PFACENODE pFN;
    ULONG ulOldEnumFilter;
    BOOL  bEnumOEMFace = TRUE;
    DWORD FontIndex;
    DWORD dwFontType = 0;

    DBGFONTS(("EnumerateFonts %lx\n", Flags));

    dwFontType = (EF_TTFONT|EF_OEMFONT|EF_DEFFACE) & Flags;

    if (FontInfo == NULL) {
        //
        // allocate memory for the font array
        //
        NumberOfFonts = 0;

        FontInfo = (PFONT_INFO)HeapAlloc(RtlProcessHeap(),0,sizeof(FONT_INFO) * INITIAL_FONTS);
        if (FontInfo == NULL)
            return STATUS_NO_MEMORY;
        FontInfoLength = INITIAL_FONTS;
    }

    hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);

    // Before enumeration, turn off font enumeration filters.
    ulOldEnumFilter = SetFontEnumeration(0);
    SetFontEnumeration(ulOldEnumFilter & ~FE_FILTER_TRUETYPE);

    if (Flags & EF_DEFFACE) {
        SelectObject(hDC, GetStockObject(OEM_FIXED_FONT));
        GetTextMetrics(hDC, &tm);
        GetTextFace(hDC, LF_FACESIZE, DefaultFaceName);

        DefaultFontSize.X = (SHORT)(tm.tmMaxCharWidth);
        DefaultFontSize.Y = (SHORT)(tm.tmHeight+tm.tmExternalLeading);
        DefaultFontFamily = tm.tmPitchAndFamily;
#if !defined(FE_SB)
        DBGFONTS(("Default (OEM) Font %ls (%d,%d)\n", DefaultFaceName,
                DefaultFontSize.X, DefaultFontSize.Y));
#else
        if (IS_ANY_DBCS_CHARSET(tm.tmCharSet))
            DefaultFontSize.X /= 2;
        DBGFONTS(("Default (OEM) Font %ls (%d,%d) CharSet 0x%02X\n", DefaultFaceName,
                DefaultFontSize.X, DefaultFontSize.Y,
                tm.tmCharSet));
#endif

        // Make sure we are going to enumerate the OEM face.
        pFN = AddFaceNode(&gpFaceNames, DefaultFaceName);
        if (pFN)
            pFN->dwFlag |= EF_DEFFACE | EF_OEMFONT;
    }

    if (gbEnumerateFaces) {
        /*
         * Set the EF_OLD bit and clear the EF_NEW bit
         * for all previously available faces
         */
        for (pFN = gpFaceNames; pFN; pFN = pFN->pNext) {
            pFN->dwFlag |= EF_OLD;
            pFN->dwFlag &= ~EF_NEW;
        }

        //
        // Use DoFontEnum to get the names of all the suitable Faces
        // All facenames found will be put in gpFaceNames with
        // the EF_NEW bit set.
        //
        DoFontEnum(hDC, NULL, TTPoints, 1);
        gbEnumerateFaces = FALSE;
    }

    // Use DoFontEnum to get all fonts from the system.  Our FontEnum
    // proc puts just the ones we want into an array
    //
    for (pFN = gpFaceNames; pFN; pFN = pFN->pNext) {
        DBGFONTS(("\"%ls\" is %s%s%s%s%s%s\n", pFN->atch,
            pFN->dwFlag & EF_NEW        ? "NEW "        : " ",
            pFN->dwFlag & EF_OLD        ? "OLD "        : " ",
            pFN->dwFlag & EF_ENUMERATED ? "ENUMERATED " : " ",
            pFN->dwFlag & EF_OEMFONT    ? "OEMFONT "    : " ",
            pFN->dwFlag & EF_TTFONT     ? "TTFONT "     : " ",
            pFN->dwFlag & EF_DEFFACE    ? "DEFFACE "    : " "));

        if ((pFN->dwFlag & (EF_OLD|EF_NEW)) == EF_OLD) {
            // The face is no longer available
            RemoveFace(pFN->atch);
            pFN->dwFlag &= ~EF_ENUMERATED;
            continue;
        }
        if ((pFN->dwFlag & dwFontType) == 0) {
            // not the kind of face we want
            continue;
        }
        if (pFN->dwFlag & EF_ENUMERATED) {
            // we already enumerated this face
            continue;
        }

        if (pFN->dwFlag & EF_TTFONT) {
#if defined(FE_SB)
            if (gfFESystem && !IsAvailableTTFontCP(pFN->atch,0))
                DoFontEnum(hDC, pFN->atch, TTPointsDbcs, NELEM(TTPointsDbcs));
            else
#endif
                DoFontEnum(hDC, pFN->atch, TTPoints, NELEM(TTPoints));
        } else {
            DoFontEnum(hDC, pFN->atch, NULL, 0);

            // If we find that the face just enumerated is the same as OEM,
            // reset flag so we don't try to enumerate it again.

            if (!_tcsncmp(pFN->atch, DefaultFaceName, LF_FACESIZE)) {
                bEnumOEMFace = FALSE;
            }
        }
        pFN->dwFlag |= EF_ENUMERATED;
    }


    // After enumerating fonts, restore the font enumeration filter.
    SetFontEnumeration(ulOldEnumFilter);

    DeleteDC(hDC);

#if defined(FE_SB)
    if (gfFESystem )
    {
        for (FontIndex = 0; FontIndex < NumberOfFonts; FontIndex++) {
            if (FontInfo[FontIndex].Size.X == DefaultFontSize.X &&
                FontInfo[FontIndex].Size.Y == DefaultFontSize.Y &&
                IS_ANY_DBCS_CHARSET(FontInfo[FontIndex].tmCharSet) &&
                FontInfo[FontIndex].Family == DefaultFontFamily) {
                break;
            }
        }
    }
    else
    {
#endif
    for (FontIndex = 0; FontIndex < NumberOfFonts; FontIndex++) {
        if (FontInfo[FontIndex].Size.X == DefaultFontSize.X &&
            FontInfo[FontIndex].Size.Y == DefaultFontSize.Y &&
            FontInfo[FontIndex].Family == DefaultFontFamily) {
            break;
        }
    }
#if defined(FE_SB)
    }
#endif
    ASSERT(FontIndex < NumberOfFonts);
    if (FontIndex < NumberOfFonts) {
        DefaultFontIndex = FontIndex;
    } else {
        DefaultFontIndex = 0;
    }
    DBGFONTS(("EnumerateFonts : DefaultFontIndex = %ld\n", DefaultFontIndex));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\registry.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This file contains functions to read and _rite values
    to the registry.

Author:

    Jerry Shea (JerrySh) 30-Sep-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <shlwapi.h>

#define CONSOLE_REGISTRY_CURRENTPAGE  (L"CurrentPage")
extern BOOL	g_fAutoComplete;
extern BOOL	g_fSaveAutoCompleteState;


NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    )
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    return NtOpenKey(
              phResult,
              KEY_READ,
              &Obja
              );
}

NTSTATUS
MyRegDeleteKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey
    )
{
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Delete the subkey
    //

    return NtDeleteValueKey(
              hKey,
              &SubKey
              );
}

NTSTATUS
MyRegCreateKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    )
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    return NtCreateKey(
                    phResult,
                    KEY_READ | KEY_WRITE,
                    &Obja,
                    0,
                    NULL,
                    0,
                    NULL
                    );
}

NTSTATUS
MyRegQueryValue(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + dwValueLength;
    KeyValueInformation = HeapAlloc(RtlProcessHeap(),0,BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtQueryValueKey(
                hKey,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->DataLength <= dwValueLength);
        RtlCopyMemory(lpData,
            KeyValueInformation->Data,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwValueLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    HeapFree(RtlProcessHeap(),0,KeyValueInformation);
    return Status;
}


#if defined(FE_SB)
NTSTATUS
MyRegEnumValue(
    IN HANDLE hKey,
    IN DWORD dwIndex,
    OUT DWORD dwValueLength,
    OUT LPWSTR lpValueName,
    OUT DWORD dwDataLength,
    OUT LPBYTE lpData
    )
{
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + dwValueLength + dwDataLength;
    KeyValueInformation = LocalAlloc(LPTR,BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtEnumerateValueKey(
                hKey,
                dwIndex,
                KeyValueFullInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->NameLength <= dwValueLength);
        RtlMoveMemory(lpValueName,
                      KeyValueInformation->Name,
                      KeyValueInformation->NameLength);
        lpValueName[ KeyValueInformation->NameLength >> 1 ] = UNICODE_NULL;


        ASSERT(KeyValueInformation->DataLength <= dwDataLength);
        RtlMoveMemory(lpData,
            (PBYTE)KeyValueInformation + KeyValueInformation->DataOffset,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ ||
            KeyValueInformation->Type ==REG_MULTI_SZ
           ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwDataLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    LocalFree(KeyValueInformation);
    return Status;
}
#endif

LPWSTR
TranslateConsoleTitle(
    LPWSTR ConsoleTitle
    )
/*++

    this routine translates path characters into '_' characters because
    the NT registry apis do not allow the creation of keys with
    names that contain path characters.  it allocates a buffer that
    must be freed.

--*/
{
    int ConsoleTitleLength, i;
    LPWSTR TranslatedTitle;

    ConsoleTitleLength = lstrlenW(ConsoleTitle) + 1;
    TranslatedTitle = HeapAlloc(RtlProcessHeap(), 0,
                                ConsoleTitleLength * sizeof(WCHAR));
    if (TranslatedTitle == NULL) {
        return NULL;
    }
    for (i = 0; i < ConsoleTitleLength; i++) {
        if (ConsoleTitle[i] == '\\') {
            TranslatedTitle[i] = (WCHAR)'_';
        } else {
            TranslatedTitle[i] = ConsoleTitle[i];
        }
    }
    return TranslatedTitle;
}


NTSTATUS
MyRegSetValue(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwType,
    IN LPVOID lpData,
    IN DWORD cbData
    )
{
    UNICODE_STRING ValueName;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    return NtSetValueKey(
                    hKey,
                    &ValueName,
                    0,
                    dwType,
                    lpData,
                    cbData
                    );
}


NTSTATUS
MyRegUpdateValue(
    IN HANDLE hConsoleKey,
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwType,
    IN LPVOID lpData,
    IN DWORD cbData
    )
{
    NTSTATUS Status;
    BYTE Data[MAX_PATH];

    //
    // If this is not the main console key but the value is the same,
    // delete it. Otherwise, set it.
    //

    if (hConsoleKey != hKey) {
        Status = MyRegQueryValue(hConsoleKey, lpValueName, sizeof(Data), Data);
        if (NT_SUCCESS(Status)) {
            if (RtlCompareMemory(lpData, Data, cbData) == cbData) {
                return MyRegDeleteKey(hKey, lpValueName);
            }
        }
    }

    return MyRegSetValue(hKey, lpValueName, dwType, lpData, cbData);
}


PCONSOLE_STATE_INFO
InitRegistryValues(VOID)

/*++

Routine Description:

    This routine allocates a state info structure and fill it in with
    default values.

Arguments:

    none

Return Value:

    pStateInfo - pointer to structure to receive information

--*/

{
    PCONSOLE_STATE_INFO pStateInfo;

    pStateInfo = HeapAlloc(RtlProcessHeap(), 0, sizeof(CONSOLE_STATE_INFO));
    if (pStateInfo == NULL) {
        return NULL;
    }

    pStateInfo->Length = sizeof(CONSOLE_STATE_INFO);
    pStateInfo->ScreenAttributes = 0x07;            // white on black
    pStateInfo->PopupAttributes = 0xf5;             // purple on white
    pStateInfo->InsertMode = FALSE;
    pStateInfo->QuickEdit = FALSE;
    pStateInfo->FullScreen = FALSE;
    pStateInfo->ScreenBufferSize.X = 80;
    pStateInfo->ScreenBufferSize.Y = 25;
    pStateInfo->WindowSize.X = 80;
    pStateInfo->WindowSize.Y = 25;
    pStateInfo->WindowPosX = 0;
    pStateInfo->WindowPosY = 0;
    pStateInfo->AutoPosition = TRUE;
    pStateInfo->FontSize.X = 0;
    pStateInfo->FontSize.Y = 0;
    pStateInfo->FontFamily = 0;
    pStateInfo->FontWeight = 0;
    pStateInfo->FaceName[0] = TEXT('\0');
    pStateInfo->CursorSize = 25;
    pStateInfo->HistoryBufferSize = 25;
    pStateInfo->NumberOfHistoryBuffers = 4;
    pStateInfo->HistoryNoDup = 0;
    pStateInfo->ColorTable[ 0] = RGB(0,   0,   0   );
    pStateInfo->ColorTable[ 1] = RGB(0,   0,   0x80);
    pStateInfo->ColorTable[ 2] = RGB(0,   0x80,0   );
    pStateInfo->ColorTable[ 3] = RGB(0,   0x80,0x80);
    pStateInfo->ColorTable[ 4] = RGB(0x80,0,   0   );
    pStateInfo->ColorTable[ 5] = RGB(0x80,0,   0x80);
    pStateInfo->ColorTable[ 6] = RGB(0x80,0x80,0   );
    pStateInfo->ColorTable[ 7] = RGB(0xC0,0xC0,0xC0);
    pStateInfo->ColorTable[ 8] = RGB(0x80,0x80,0x80);
    pStateInfo->ColorTable[ 9] = RGB(0,   0,   0xFF);
    pStateInfo->ColorTable[10] = RGB(0,   0xFF,0   );
    pStateInfo->ColorTable[11] = RGB(0,   0xFF,0xFF);
    pStateInfo->ColorTable[12] = RGB(0xFF,0,   0   );
    pStateInfo->ColorTable[13] = RGB(0xFF,0,   0xFF);
    pStateInfo->ColorTable[14] = RGB(0xFF,0xFF,0   );
    pStateInfo->ColorTable[15] = RGB(0xFF,0xFF,0xFF);
#if defined(FE_SB)
    pStateInfo->CodePage = OEMCP; // scotthsu
#endif
    pStateInfo->hWnd = NULL;
    pStateInfo->ConsoleTitle[0] = TEXT('\0');

    g_fAutoComplete = TRUE;

    return pStateInfo;
}




#define SZ_REGKEY_CMDAUTOCOMPLETE           TEXT("Software\\Microsoft\\Command Processor")
#define SZ_REGVALUE_CMDAUTOCOMPLETE         TEXT("CompletionChar")
#define DWORD_CMD_TAB_AUTOCOMPLETE_ON       0x00000009          // 9 is tab
#define DWORD_CMD_TAB_AUTOCOMPLETE_OFF      0x00000020          // 20 is space which turns it off.

BOOL
IsAutoCompleteOn(
    void
    )
{
    DWORD dwType;
    DWORD dwValue = DWORD_CMD_TAB_AUTOCOMPLETE_ON;
    DWORD cbSize = sizeof(dwValue);

    if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_CMDAUTOCOMPLETE, SZ_REGVALUE_CMDAUTOCOMPLETE, &dwType, (LPBYTE)&dwValue, &cbSize)) ||
        (REG_DWORD != dwType))
    {
        dwValue = DWORD_CMD_TAB_AUTOCOMPLETE_ON;    // Fall back to the default value.
    }

    return (DWORD_CMD_TAB_AUTOCOMPLETE_ON == dwValue);
}


void
SaveAutoCompleteSetting(
    IN BOOL fAutoComplete
    )
{
    // Only over write the registry value if someone has changed the value.
    if (g_fSaveAutoCompleteState)
    {
        DWORD dwValue = (fAutoComplete ? DWORD_CMD_TAB_AUTOCOMPLETE_ON : DWORD_CMD_TAB_AUTOCOMPLETE_OFF);

        SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_CMDAUTOCOMPLETE, SZ_REGVALUE_CMDAUTOCOMPLETE, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
    }
}


DWORD
GetRegistryValues(
    PCONSOLE_STATE_INFO pStateInfo
    )

/*++

Routine Description:

    This routine reads in values from the registry and places them
    in the supplied structure.

Arguments:

    pStateInfo - optional pointer to structure to receive information

Return Value:

    current page number

--*/

{
    HANDLE hCurrentUserKey;
    HANDLE hConsoleKey;
    HANDLE hTitleKey;
    NTSTATUS Status;
    LPWSTR TranslatedTitle;
    DWORD dwValue;
    DWORD dwRet = 0;
    DWORD i;
    WCHAR awchBuffer[LF_FACESIZE];

    //
    // Open the current user registry key
    //

    Status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hCurrentUserKey);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    //
    // Open the console registry key
    //

    Status = MyRegOpenKey(hCurrentUserKey,
                          CONSOLE_REGISTRY_STRING,
                          &hConsoleKey);
    if (!NT_SUCCESS(Status)) {
        NtClose(hCurrentUserKey);
        return 0;
    }

    //
    // If there is no structure to fill out, just get the current
    // page and bail out.
    //

    if (pStateInfo == NULL) {
        if (NT_SUCCESS(MyRegQueryValue(hConsoleKey,
                       CONSOLE_REGISTRY_CURRENTPAGE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
            dwRet = dwValue;
        }
        goto CloseKeys;
    }

    //
    // Open the console title subkey, if there is one
    //

    if (pStateInfo->ConsoleTitle[0] != TEXT('\0')) {
        TranslatedTitle = TranslateConsoleTitle(pStateInfo->ConsoleTitle);
        if (TranslatedTitle == NULL) {
            NtClose(hConsoleKey);
            NtClose(hCurrentUserKey);
            return 0;
        }
        Status = MyRegOpenKey(hConsoleKey,
                              TranslatedTitle,
                              &hTitleKey);
        HeapFree(RtlProcessHeap(),0,TranslatedTitle);
        if (!NT_SUCCESS(Status)) {
            NtClose(hConsoleKey);
            NtClose(hCurrentUserKey);
            return 0;
        }
    } else {
        hTitleKey = hConsoleKey;
    }

    //
    // Initial screen fill
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FILLATTR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->ScreenAttributes = (WORD)dwValue;
    }

    //
    // Initial popup fill
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_POPUPATTR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->PopupAttributes = (WORD)dwValue;
    }

    //
    // Initial color table
    //

    for (i = 0; i < 16; i++) {
        wsprintf(awchBuffer, CONSOLE_REGISTRY_COLORTABLE, i);
        if (NT_SUCCESS(MyRegQueryValue(hTitleKey, awchBuffer,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
            pStateInfo->ColorTable[i] = dwValue;
        }
    }

    //
    // Initial insert mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_INSERTMODE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->InsertMode = !!dwValue;
    }

    //
    // Initial quick edit mode
    //
    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_QUICKEDIT,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->QuickEdit = !!dwValue;
    }

    //
    // Initial autocomplete mode
    //
    g_fAutoComplete = IsAutoCompleteOn();

#ifdef i386
    //
    // Initial full screen mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FULLSCR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->FullScreen = !!dwValue;
    }
#endif
#if defined(FE_SB) // scotthsu
    //
    // Initial code page
    //

    ASSERT(OEMCP != 0);
    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_CODEPAGE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        if (IsValidCodePage(dwValue)) {
            pStateInfo->CodePage = (UINT) dwValue;
        }
    }
#endif

    //
    // Initial screen buffer size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_BUFFERSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->ScreenBufferSize.X = LOWORD(dwValue);
        pStateInfo->ScreenBufferSize.Y = HIWORD(dwValue);
    }

    //
    // Initial window size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_WINDOWSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->WindowSize.X = LOWORD(dwValue);
        pStateInfo->WindowSize.Y = HIWORD(dwValue);
    }

    //
    // Initial window position
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_WINDOWPOS,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->WindowPosX = (SHORT)LOWORD(dwValue);
        pStateInfo->WindowPosY = (SHORT)HIWORD(dwValue);
        pStateInfo->AutoPosition = FALSE;
    }

    //
    // Initial font size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->FontSize.X = LOWORD(dwValue);
        pStateInfo->FontSize.Y = HIWORD(dwValue);
    }

    //
    // Initial font family
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTFAMILY,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->FontFamily = dwValue;
    }

    //
    // Initial font weight
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTWEIGHT,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->FontWeight = dwValue;
    }

    //
    // Initial font face name
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FACENAME,
                       sizeof(awchBuffer), (PBYTE)awchBuffer))) {
        RtlCopyMemory(pStateInfo->FaceName, awchBuffer, sizeof(awchBuffer));
    }

    //
    // Initial cursor size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_CURSORSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->CursorSize = dwValue;
    }

    //
    // Initial history buffer size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->HistoryBufferSize = dwValue;
    }

    //
    // Initial number of history buffers
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYBUFS,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->NumberOfHistoryBuffers = dwValue;
    }

    //
    // Initial history duplication mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYNODUP,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->HistoryNoDup = dwValue;
    }

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        NtClose(hTitleKey);
    }

CloseKeys:
    NtClose(hConsoleKey);
    NtClose(hCurrentUserKey);

    return dwRet;
}


VOID
SetRegistryValues(
    PCONSOLE_STATE_INFO pStateInfo,
    DWORD dwPage
    )

/*++

Routine Description:

    This routine writes values to the registry from the supplied
    structure.

Arguments:

    pStateInfo - optional pointer to structure containing information
    dwPage     - current page number

Return Value:

    none

--*/

{
    HANDLE hCurrentUserKey;
    HANDLE hConsoleKey;
    HANDLE hTitleKey;
    NTSTATUS Status;
    LPWSTR TranslatedTitle;
    DWORD dwValue;
    DWORD i;
    WCHAR awchBuffer[LF_FACESIZE];

    //
    // Open the current user registry key
    //

    Status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hCurrentUserKey);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    //
    // Open the console registry key
    //

    Status = MyRegCreateKey(hCurrentUserKey,
                            CONSOLE_REGISTRY_STRING,
                            &hConsoleKey);
    if (!NT_SUCCESS(Status)) {
        NtClose(hCurrentUserKey);
        return;
    }

    //
    // Save the current page
    //

    MyRegSetValue(hConsoleKey,
                  CONSOLE_REGISTRY_CURRENTPAGE,
                  REG_DWORD, &dwPage, sizeof(dwPage));

    //
    // If we only want to save the current page, bail out
    //

    if (pStateInfo == NULL) {
        goto CloseKeys;
    }

    //
    // Open the console title subkey, if there is one
    //

    if (pStateInfo->ConsoleTitle[0] != TEXT('\0')) {
        TranslatedTitle = TranslateConsoleTitle(pStateInfo->ConsoleTitle);
        if (TranslatedTitle == NULL) {
            NtClose(hConsoleKey);
            NtClose(hCurrentUserKey);
            return;
        }
        Status = MyRegCreateKey(hConsoleKey,
                                TranslatedTitle,
                                &hTitleKey);
        HeapFree(RtlProcessHeap(),0,TranslatedTitle);
        if (!NT_SUCCESS(Status)) {
            NtClose(hConsoleKey);
            NtClose(hCurrentUserKey);
            return;
        }
    } else {
        hTitleKey = hConsoleKey;
    }

    //
    // Save screen and popup colors and color table
    //

    dwValue = pStateInfo->ScreenAttributes;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FILLATTR,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->PopupAttributes;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_POPUPATTR,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    for (i = 0; i < 16; i++) {
        dwValue = pStateInfo->ColorTable[i];
        wsprintf(awchBuffer, CONSOLE_REGISTRY_COLORTABLE, i);
        MyRegUpdateValue(hConsoleKey, hTitleKey, awchBuffer,
                         REG_DWORD, &dwValue, sizeof(dwValue));
    }

    //
    // Save insert, quickedit, and fullscreen mode settings
    //

    dwValue = pStateInfo->InsertMode;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_INSERTMODE,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->QuickEdit;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_QUICKEDIT,
                     REG_DWORD, &dwValue, sizeof(dwValue));

    SaveAutoCompleteSetting(g_fAutoComplete);

#ifdef i386
    dwValue = pStateInfo->FullScreen;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FULLSCR,
                     REG_DWORD, &dwValue, sizeof(dwValue));
#endif
#if defined(FE_SB) // scotthsu

    ASSERT(OEMCP != 0);
    if (gfFESystem) {
        dwValue = (DWORD) pStateInfo->CodePage;
        MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_CODEPAGE,
                         REG_DWORD, &dwValue, sizeof(dwValue));
    }
#endif

    //
    // Save screen buffer size
    //

    dwValue = MAKELONG(pStateInfo->ScreenBufferSize.X,
                       pStateInfo->ScreenBufferSize.Y);
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_BUFFERSIZE,
                     REG_DWORD, &dwValue, sizeof(dwValue));

    //
    // Save window size
    //

    dwValue = MAKELONG(pStateInfo->WindowSize.X,
                       pStateInfo->WindowSize.Y);
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_WINDOWSIZE,
                     REG_DWORD, &dwValue, sizeof(dwValue));

    //
    // Save window position
    //

    if (pStateInfo->AutoPosition) {
        MyRegDeleteKey(hTitleKey, CONSOLE_REGISTRY_WINDOWPOS);
    } else {
        dwValue = MAKELONG(pStateInfo->WindowPosX,
                           pStateInfo->WindowPosY);
        MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_WINDOWPOS,
                         REG_DWORD, &dwValue, sizeof(dwValue));
    }

    //
    // Save font size, family, weight, and face name
    //

    dwValue = MAKELONG(pStateInfo->FontSize.X,
                       pStateInfo->FontSize.Y);
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FONTSIZE,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->FontFamily;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FONTFAMILY,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->FontWeight;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FONTWEIGHT,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FACENAME,
                     REG_SZ, pStateInfo->FaceName,
                      (_tcslen(pStateInfo->FaceName) + 1) * sizeof(TCHAR));

    //
    // Save cursor size
    //

    dwValue = pStateInfo->CursorSize;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_CURSORSIZE,
                     REG_DWORD, &dwValue, sizeof(dwValue));

    //
    // Save history buffer size and number
    //

    dwValue = pStateInfo->HistoryBufferSize;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_HISTORYSIZE,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->NumberOfHistoryBuffers;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_HISTORYBUFS,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->HistoryNoDup;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_HISTORYNODUP,
                     REG_DWORD, &dwValue, sizeof(dwValue));

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        NtClose(hTitleKey);
    }

CloseKeys:
    NtClose(hConsoleKey);
    NtClose(hCurrentUserKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\init.c ===
/*************************************************************\
 *  File name:    INIT.C
 *
 *  Description:  Initialization code for Console control panel
 *                applet
 *
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1994
 *  All rights reserved
 *
\*************************************************************/
#include "precomp.h"
#include <cpl.h>


HINSTANCE ghInstance;


/*************************************************************\
 *
 *  DllInitialize()
 *
 *  Purpose:    Main entry point
 *
 *
 *  Parameters: HINSTANCE hInstDLL    - Instance handle of DLL
 *              DWORD     dwReason    - Reason DLL was called
 *              LPVOID    lpvReserved - NULL
 *
 *
 *  Return:     BOOL
 *
\*************************************************************/

BOOL DllInitialize(HINSTANCE hInstDLL, DWORD dwReason, LPVOID lpvReserved)
{
    if (dwReason != DLL_PROCESS_ATTACH) {
        return TRUE;
    }

    ghInstance = hInstDLL;

    DisableThreadLibraryCalls(hInstDLL);

    return TRUE;
}


/*************************************************************\
 *
 *  CPlApplet()
 *
 *  Purpose:    Control Panel entry point
 *
 *
 *  Parameters: HWND hwnd      - Window handle
 *              WORD wMsg      - Control Panel message
 *              LPARAM lParam1 - Long parameter
 *              LPARAM lParam2 - Long parameter
 *
 *
 *  Return:     LONG
 *
\*************************************************************/

LONG CPlApplet( HWND hwnd, WORD wMsg, LPARAM lParam1, LPARAM lParam2)
{
    LPCPLINFO lpOldCPlInfo;
    LPNEWCPLINFO lpCPlInfo;
    INITCOMMONCONTROLSEX iccex;

    switch (wMsg) {

    case CPL_INIT:

        iccex.dwSize = sizeof(iccex);
        iccex.dwICC  = ICC_WIN95_CLASSES;
        InitCommonControlsEx( &iccex );
        //InitCommonControls();

        if (!RegisterClasses(ghInstance)) {
            return FALSE;
        }
        OEMCP = GetOEMCP();
        gfFESystem = IsFarEastCP(OEMCP);
        if (!NT_SUCCESS(InitializeDbcsMisc())) {
            return FALSE;
        }
        return TRUE;

    case CPL_GETCOUNT:
        return 1;

    case CPL_INQUIRE:

        lpOldCPlInfo = (LPCPLINFO)lParam2;

        lpOldCPlInfo->idIcon = IDI_CONSOLE;
        lpOldCPlInfo->idName = IDS_NAME;
        lpOldCPlInfo->idInfo = IDS_INFO;
        lpOldCPlInfo->lData  = 0;
        return TRUE;

    case CPL_NEWINQUIRE:

        lpCPlInfo = (LPNEWCPLINFO)lParam2;

        lpCPlInfo->hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_CONSOLE));

        if (!LoadString(ghInstance, IDS_NAME, lpCPlInfo->szName,
                        NELEM(lpCPlInfo->szName))) {
            lpCPlInfo->szName[0] = TEXT('\0');
        }

        if (!LoadString(ghInstance, IDS_INFO, lpCPlInfo->szInfo,
                        NELEM(lpCPlInfo->szInfo))) {
            lpCPlInfo->szInfo[0] = TEXT('\0');
        }

        lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
        lpCPlInfo->dwHelpContext = 0;
        lpCPlInfo->szHelpFile[0] = TEXT('\0');

        return (LONG)TRUE;

    case CPL_DBLCLK:
        ConsolePropertySheet(hwnd);
        break;

    case CPL_EXIT:
        DestroyDbcsMisc();
        UnregisterClasses(ghInstance);
        break;
    }
    return (LONG)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\console\preview.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    preview.c

Abstract:

    This module contains the code for console preview window

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


/* ----- Equates ----- */
#define PREVIEW_HSCROLL  0x01
#define PREVIEW_VSCROLL  0x02


/* ----- Prototypes ----- */

void AspectPoint(
    RECT* rectPreview,
    POINT* pt);

LONG AspectScale(
    LONG n1,
    LONG n2,
    LONG m);


/* ----- Globals ----- */

POINT NonClientSize;
RECT WindowRect;
DWORD PreviewFlags;


VOID
UpdatePreviewRect(VOID)

/*++

    Update the global window size and dimensions

--*/

{
    POINT MinSize;
    POINT MaxSize;
    POINT WindowSize;
    PFONT_INFO lpFont;
    HMONITOR hMonitor;
    MONITORINFO mi;

    /*
     * Get the font pointer
     */
    lpFont = &FontInfo[CurrentFontIndex];

    /*
     * Get the window size
     */
    MinSize.x = (GetSystemMetrics(SM_CXMIN)-NonClientSize.x) / lpFont->Size.X;
    MinSize.y = (GetSystemMetrics(SM_CYMIN)-NonClientSize.y) / lpFont->Size.Y;
    MaxSize.x = GetSystemMetrics(SM_CXFULLSCREEN) / lpFont->Size.X;
    MaxSize.y = GetSystemMetrics(SM_CYFULLSCREEN) / lpFont->Size.Y;
    WindowSize.x = max(MinSize.x, min(MaxSize.x, gpStateInfo->WindowSize.X));
    WindowSize.y = max(MinSize.y, min(MaxSize.y, gpStateInfo->WindowSize.Y));

    /*
     * Get the window rectangle, making sure it's at least twice the
     * size of the non-client area.
     */
    WindowRect.left = gpStateInfo->WindowPosX;
    WindowRect.top = gpStateInfo->WindowPosY;
    WindowRect.right = WindowSize.x * lpFont->Size.X + NonClientSize.x;
    if (WindowRect.right < NonClientSize.x * 2) {
        WindowRect.right = NonClientSize.x * 2;
    }
    WindowRect.right += WindowRect.left;
    WindowRect.bottom = WindowSize.y * lpFont->Size.Y + NonClientSize.y;
    if (WindowRect.bottom < NonClientSize.y * 2) {
        WindowRect.bottom = NonClientSize.y * 2;
    }
    WindowRect.bottom += WindowRect.top;

    /*
     * Get information about the monitor we're on
     */
    hMonitor = MonitorFromRect(&WindowRect, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    gcxScreen = mi.rcWork.right - mi.rcWork.left;
    gcyScreen = mi.rcWork.bottom - mi.rcWork.top;

    /*
     * Convert window rectangle to monitor relative coordinates
     */
    WindowRect.right  -= WindowRect.left;
    WindowRect.left   -= mi.rcWork.left;
    WindowRect.bottom -= WindowRect.top;
    WindowRect.top    -= mi.rcWork.top;

    /*
     * Update the display flags
     */
    if (WindowSize.x < gpStateInfo->ScreenBufferSize.X) {
        PreviewFlags |= PREVIEW_HSCROLL;
    } else {
        PreviewFlags &= ~PREVIEW_HSCROLL;
    }
    if (WindowSize.y < gpStateInfo->ScreenBufferSize.Y) {
        PreviewFlags |= PREVIEW_VSCROLL;
    } else {
        PreviewFlags &= ~PREVIEW_VSCROLL;
    }
}


VOID
InvalidatePreviewRect(HWND hWnd)

/*++

    Invalidate the area covered by the preview "window"

--*/

{
    RECT rectWin;
    RECT rectPreview;

    /*
     * Get the size of the preview "screen"
     */
    GetClientRect(hWnd, &rectPreview);

    /*
     * Get the dimensions of the preview "window" and scale it to the
     * preview "screen"
     */
    rectWin.left   = WindowRect.left;
    rectWin.top    = WindowRect.top;
    rectWin.right  = WindowRect.left + WindowRect.right;
    rectWin.bottom = WindowRect.top + WindowRect.bottom;
    AspectPoint(&rectPreview, (POINT*)&rectWin.left);
    AspectPoint(&rectPreview, (POINT*)&rectWin.right);

    /*
     * Invalidate the area covered by the preview "window"
     */
    InvalidateRect(hWnd, &rectWin, FALSE);
}


VOID
PreviewPaint(
    PAINTSTRUCT* pPS,
    HWND hWnd
    )

/*++

    Paints the font preview.  This is called inside the paint message
    handler for the preview window

--*/

{
    RECT rectWin;
    RECT rectPreview;
    HBRUSH hbrFrame;
    HBRUSH hbrTitle;
    HBRUSH hbrOld;
    HBRUSH hbrClient;
    HBRUSH hbrBorder;
    HBRUSH hbrButton;
    HBRUSH hbrScroll;
    HBRUSH hbrDesktop;
    POINT ptButton;
    POINT ptScroll;
    HDC hDC;
    HBITMAP hBitmap;
    HBITMAP hBitmapOld;
    COLORREF rgbClient;

    /*
     * Get the size of the preview "screen"
     */
    GetClientRect(hWnd, &rectPreview);

    /*
     * Get the dimensions of the preview "window" and scale it to the
     * preview "screen"
     */
    rectWin = WindowRect;
    AspectPoint(&rectPreview, (POINT*)&rectWin.left);
    AspectPoint(&rectPreview, (POINT*)&rectWin.right);

    /*
     * Compute the dimensions of some other window components
     */
    ptButton.x = GetSystemMetrics(SM_CXSIZE);
    ptButton.y = GetSystemMetrics(SM_CYSIZE);
    AspectPoint(&rectPreview, &ptButton);
    ptButton.y *= 2;       /* Double the computed size for "looks" */
    ptScroll.x = GetSystemMetrics(SM_CXVSCROLL);
    ptScroll.y = GetSystemMetrics(SM_CYHSCROLL);
    AspectPoint(&rectPreview, &ptScroll);

    /*
     * Create the memory device context
     */
    hDC = CreateCompatibleDC(pPS->hdc);
    hBitmap = CreateCompatibleBitmap(pPS->hdc,
                                     rectPreview.right,
                                     rectPreview.bottom);
    hBitmapOld = SelectObject(hDC, hBitmap);

    /*
     * Create the brushes
     */
    hbrBorder  = CreateSolidBrush(GetSysColor(COLOR_ACTIVEBORDER));
    hbrTitle   = CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));
    hbrFrame   = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME));
    hbrButton  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    hbrScroll  = CreateSolidBrush(GetSysColor(COLOR_SCROLLBAR));
    hbrDesktop = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));
    rgbClient  = GetNearestColor(hDC, ScreenBkColor(gpStateInfo));
    hbrClient  = CreateSolidBrush(rgbClient);

    /*
     * Erase the clipping area
     */
    FillRect(hDC, &(pPS->rcPaint), hbrDesktop);

    /*
     * Fill in the whole window with the client brush
     */
    hbrOld = SelectObject(hDC, hbrClient);
    PatBlt(hDC, rectWin.left, rectWin.top,
           rectWin.right - 1, rectWin.bottom - 1, PATCOPY);

    /*
     * Fill in the caption bar
     */
    SelectObject(hDC, hbrTitle);
    PatBlt(hDC, rectWin.left + 3, rectWin.top + 3,
           rectWin.right - 7, ptButton.y - 2, PATCOPY);

    /*
     * Draw the "buttons"
     */
    SelectObject(hDC, hbrButton);
    PatBlt(hDC, rectWin.left + 3, rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptButton.x,
           rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - 2 * ptButton.x - 1,
           rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left + 3 + ptButton.x, rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptButton.x - 1,
           rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - 2 * ptButton.x - 2,
           rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);

    /*
     * Draw the scrollbars
     */
    SelectObject(hDC, hbrScroll);
    if (PreviewFlags & PREVIEW_HSCROLL) {
        PatBlt(hDC, rectWin.left + 3,
               rectWin.top + rectWin.bottom - 4 - ptScroll.y,
               rectWin.right - 7, ptScroll.y, PATCOPY);
    }
    if (PreviewFlags & PREVIEW_VSCROLL) {
        PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptScroll.x,
               rectWin.top + 1 + ptButton.y + 1,
               ptScroll.x, rectWin.bottom - 6 - ptButton.y, PATCOPY);
        if (PreviewFlags & PREVIEW_HSCROLL) {
            SelectObject(hDC, hbrFrame);
            PatBlt(hDC, rectWin.left + rectWin.right - 5 - ptScroll.x,
                   rectWin.top + rectWin.bottom - 4 - ptScroll.y,
                   1, ptScroll.y, PATCOPY);
            PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptScroll.x,
                   rectWin.top + rectWin.bottom - 5 - ptScroll.y,
                   ptScroll.x, 1, PATCOPY);
        }
    }

    /*
     * Draw the interior window frame and caption frame
     */
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 2,
           1, rectWin.bottom - 5, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 2,
           rectWin.right - 5, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + rectWin.bottom - 4,
           rectWin.right - 5, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4, rectWin.top + 2,
           1, rectWin.bottom - 5, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 1 + ptButton.y,
           rectWin.right - 5, 1, PATCOPY);

    /*
     * Draw the border
     */
    SelectObject(hDC, hbrBorder);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + 1,
           1, rectWin.bottom - 3, PATCOPY);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + 1,
           rectWin.right - 3, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + rectWin.bottom - 3,
           rectWin.right - 3, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 3, rectWin.top + 1,
           1, rectWin.bottom - 3, PATCOPY);

    /*
     * Draw the exterior window frame
     */
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left, rectWin.top,
           1, rectWin.bottom - 1, PATCOPY);
    PatBlt(hDC, rectWin.left, rectWin.top,
           rectWin.right - 1, 1, PATCOPY);
    PatBlt(hDC, rectWin.left, rectWin.top + rectWin.bottom - 2,
           rectWin.right - 1, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 2, rectWin.top,
           1, rectWin.bottom - 1, PATCOPY);

    /*
     * Copy the memory device context to the screen device context
     */
    BitBlt(pPS->hdc, 0, 0, rectPreview.right, rectPreview.bottom,
           hDC, 0, 0, SRCCOPY);

    /*
     * Clean up everything
     */
    SelectObject(hDC, hbrOld);
    SelectObject(hDC, hBitmapOld);
    DeleteObject(hbrBorder);
    DeleteObject(hbrFrame);
    DeleteObject(hbrTitle);
    DeleteObject(hbrClient);
    DeleteObject(hbrButton);
    DeleteObject(hbrScroll);
    DeleteObject(hbrDesktop);
    DeleteObject(hBitmap);
    DeleteDC(hDC);
}


LRESULT
PreviewWndProc(
    HWND hWnd,
    UINT wMessage,
    WPARAM wParam,
    LPARAM lParam
    )

/*
 * PreviewWndProc
 *      Handles the preview window
 */

{
    PAINTSTRUCT ps;
    LPCREATESTRUCT lpcs;
    RECT rcWindow;
    int cx;
    int cy;

    switch (wMessage) {
    case WM_CREATE:
        /*
         * Figure out space used by non-client area
         */
        SetRect(&rcWindow, 0, 0, 50, 50);
        AdjustWindowRect(&rcWindow, WS_OVERLAPPEDWINDOW, FALSE);
        NonClientSize.x = rcWindow.right - rcWindow.left - 50;
        NonClientSize.y = rcWindow.bottom - rcWindow.top - 50;

        /*
         * Compute the size of the preview "window"
         */
        UpdatePreviewRect();

        /*
         * Scale the window so it has the same aspect ratio as the screen
         */
        lpcs = (LPCREATESTRUCT)lParam;
        cx = lpcs->cx;
        cy = AspectScale(gcyScreen, gcxScreen, cx);
        if (cy > lpcs->cy) {
            cy = lpcs->cy;
            cx = AspectScale(gcxScreen, gcyScreen, cy);
        }
        MoveWindow(hWnd, lpcs->x, lpcs->y, cx, cy, TRUE);
        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        PreviewPaint(&ps, hWnd);
        EndPaint(hWnd, &ps);
        break;

    case CM_PREVIEW_UPDATE:
        InvalidatePreviewRect(hWnd);
        UpdatePreviewRect();

        /*
         * Make sure the preview "screen" has the correct aspect ratio
         */
        GetWindowRect(hWnd, &rcWindow);
        cx = rcWindow.right - rcWindow.left;
        cy = AspectScale(gcyScreen, gcxScreen, cx);
        if (cy != rcWindow.bottom - rcWindow.top) {
            SetWindowPos(hWnd, NULL, 0, 0, cx, cy, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
        }
    
        InvalidatePreviewRect(hWnd);
        break;

    default:
        return DefWindowProc(hWnd, wMessage, wParam, lParam);
    }
    return 0L;
}


/*  AspectScale
 *      Performs the following calculation in LONG arithmetic to avoid
 *      overflow:
 *          return = n1 * m / n2
 *      This can be used to make an aspect ration calculation where n1/n2
 *      is the aspect ratio and m is a known value.  The return value will
 *      be the value that corresponds to m with the correct apsect ratio.
 */

LONG AspectScale(
    LONG n1,
    LONG n2,
    LONG m)
{
    LONG Temp;

    Temp = n1 * m + (n2 >> 1);
    return Temp / n2;
}

/*  AspectPoint
 *      Scales a point to be preview-sized instead of screen-sized.
 */

void AspectPoint(
    RECT* rectPreview,
    POINT* pt)
{
    pt->x = AspectScale(rectPreview->right, gcxScreen, pt->x);
    pt->y = AspectScale(rectPreview->bottom, gcyScreen, pt->y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\advaudio.cpp ===
//--------------------------------------------------------------------------;
//
//  File: advaudio.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;


#include "mmcpl.h"
#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "utils.h"
#include "medhelp.h"
#include "gfxui.h"

#include <dsound.h>
#include "advaudio.h"
#include "speakers.h"
#include "perfpage.h"
#include "dslevel.h"
#include "drivers.h"

////////////
// Globals
////////////

AUDDATA         gAudData;
HINSTANCE       ghInst;
const TCHAR *    gszHelpFile;

////////////
// Functions
////////////
extern INT_PTR CALLBACK  SoundEffectsDlg(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

STDAPI_(void) ToggleApplyButton(HWND hWnd)
{
    BOOL fChanged = FALSE;
    HWND hwndSheet;

    if (memcmp(&gAudData.stored,&gAudData.current,sizeof(CPLDATA)))
    {
        fChanged = TRUE;
    }

    hwndSheet = GetParent(hWnd);

    if (fChanged)
    {
        PropSheet_Changed(hwndSheet,hWnd);
    }
    else
    {
        PropSheet_UnChanged(hwndSheet,hWnd);
    }
}


void VerifyRanges(LPCPLDATA pData)
{
    pData->dwHWLevel        = min(pData->dwHWLevel,MAX_HW_LEVEL);
    pData->dwSRCLevel       = min(pData->dwSRCLevel,MAX_SRC_LEVEL);
    pData->dwSpeakerType    = min(pData->dwSpeakerType,MAX_SPEAKER_TYPE);
}


void GetCurrentSettings(LPAUDDATA pAD, DWORD dwWaveId, LPTSTR szDeviceName, BOOL fRecord)
{
    HRESULT hr = E_FAIL;

    if (pAD)
    {
        CPLDATA cplData = { DEFAULT_HW_LEVEL, DEFAULT_SRC_LEVEL, SPEAKERS_DEFAULT_CONFIG, SPEAKERS_DEFAULT_TYPE };

        memset(pAD,0,sizeof(AUDDATA));
        pAD->dwDefaultHWLevel = MAX_HW_LEVEL;
        pAD->fRecord = fRecord;

        hr = DSGetGuidFromName(szDeviceName, fRecord, &pAD->devGuid);

        if (SUCCEEDED(hr))
        {
            hr = DSGetCplValues(pAD->devGuid, fRecord, &cplData);

            if (SUCCEEDED(hr))
            {
                VerifyRanges(&cplData);
                VerifySpeakerConfig(cplData.dwSpeakerConfig,&cplData.dwSpeakerType);
            }
        }

        pAD->waveId = dwWaveId;
        pAD->stored = cplData;
        pAD->current = cplData;
        pAD->fValid = SUCCEEDED(hr);
    }
}


STDAPI_(void) ApplyCurrentSettings(LPAUDDATA pAD)
{
    HRESULT hr = S_OK;

    if (pAD && pAD->fValid)        // Only apply changes if there are changes to be applied
    {
        if (memcmp(&pAD->stored,&pAD->current,sizeof(CPLDATA)))
        {
            hr = DSSetCplValues(pAD->devGuid, pAD->fRecord, &pAD->current);

            if (SUCCEEDED(hr))
            {
                pAD->stored = pAD->current;
            }
        }
    }
}

typedef BOOL (WINAPI* UPDATEDDDLG)(HWND,HINSTANCE,const TCHAR *,LPTSTR,BOOL);

STDAPI_(BOOL) RunUpgradedDialog(HWND hwnd, HINSTANCE hInst, const TCHAR *szHelpFile, LPTSTR szDeviceName, BOOL fRecord)
{
    BOOL            fUsedUpgradedDLG = FALSE;
    TCHAR            path[_MAX_PATH];
    UPDATEDDDLG        UpdatedDialog;
    HMODULE         hModule;

    GetSystemDirectory(path, sizeof(path)/sizeof(TCHAR));
    lstrcat(path, TEXT("\\DSNDDLG.DLL") );
    
    hModule = LoadLibrary(path);

    if (hModule)
    {
        UpdatedDialog = (UPDATEDDDLG) GetProcAddress( hModule,"DSAdvancedAudio");
    
        if (UpdatedDialog)
        {
            fUsedUpgradedDLG = UpdatedDialog(hwnd,hInst,szHelpFile,szDeviceName,fRecord);
        }

        FreeLibrary( hModule );
    }

    return fUsedUpgradedDLG;
}

HRESULT CheckDSAccelerationPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet)
{
    HRESULT hr;

    DWORD dwHWLevel = gAudData.dwDefaultHWLevel;
    hr = DSGetAcceleration(guidDevice, fRecord, &dwHWLevel);

    if (phrGet)
    {
        *phrGet = hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = DSSetAcceleration(guidDevice, fRecord, dwHWLevel);
    } //end if Get is OK

    return (hr);
}

HRESULT CheckDSSrcQualityPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet)
{
    HRESULT hr;

    DWORD dwSRCLevel = DEFAULT_SRC_LEVEL;
    hr = DSGetSrcQuality(guidDevice, fRecord, &dwSRCLevel);

    if (phrGet)
    {
        *phrGet = hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = DSSetSrcQuality(guidDevice, fRecord, dwSRCLevel);
    } //end if Get is OK

    return (hr);
}

HRESULT CheckDSSpeakerConfigPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet)
{
    HRESULT hr;

    DWORD dwSpeakerConfig = SPEAKERS_DEFAULT_CONFIG;
    DWORD dwSpeakerType = SPEAKERS_DEFAULT_TYPE;
    hr = DSGetSpeakerConfigType(guidDevice, fRecord, &dwSpeakerConfig, &dwSpeakerType);

    if (phrGet)
    {
        *phrGet = hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = DSSetSpeakerConfigType(guidDevice, fRecord, dwSpeakerConfig, dwSpeakerType);
    } //end if Get is OK

    return (hr);
}

STDAPI_(void) AdvancedAudio(HWND hwnd, HINSTANCE hInst, const TCHAR *szHelpFile, 
                            DWORD dwWaveId, LPTSTR szDeviceName, BOOL fRecord)
{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp[3];
    int page;
    TCHAR str[255];
    HMODULE hModDirectSound = NULL;
    HRESULT hrAccelGet = E_FAIL;
    HRESULT hrQualityGet = E_FAIL;
    HRESULT hrSpeakerConfigGet = E_FAIL;
    bool fDisplayGFXTab = false;

    if (!RunUpgradedDialog(hwnd,hInst,szHelpFile,szDeviceName,fRecord))
    {
        //load DirectSound
        hModDirectSound = LoadLibrary(TEXT("dsound.dll"));
        if (hModDirectSound)
        {
            // Initialize gAudData
            memset(&gAudData,0,sizeof(AUDDATA));
            gAudData.dwDefaultHWLevel = MAX_HW_LEVEL;
            gAudData.fRecord = fRecord;

            // If not a Capture device, check if we can read any of the DirectSound device settings
            if (!fRecord && SUCCEEDED(DSGetGuidFromName(szDeviceName, fRecord, &gAudData.devGuid)))
            {
                CheckDSAccelerationPriv(gAudData.devGuid, fRecord, &hrAccelGet);

                CheckDSSrcQualityPriv(gAudData.devGuid, fRecord, &hrQualityGet);

                CheckDSSpeakerConfigPriv(gAudData.devGuid, fRecord, &hrSpeakerConfigGet);
            }

            // Check if we should show the GFX tab
            UINT uMixId;
            if( !fRecord )
            {
                if (!mixerGetID(HMIXEROBJ_INDEX(dwWaveId), &uMixId, MIXER_OBJECTF_WAVEOUT) &&
                    GFXUI_CheckDevice(uMixId, GFXTYPE_RENDER))
                {
                    fDisplayGFXTab = true;
                }
            }
            else
            {
                if (!mixerGetID(HMIXEROBJ_INDEX(dwWaveId), &uMixId, MIXER_OBJECTF_WAVEIN) &&
                    GFXUI_CheckDevice(uMixId, GFXTYPE_CAPTURE))
                {
                    fDisplayGFXTab = true;
                }
            }
 
            // If there's anything to display
            if (fDisplayGFXTab || SUCCEEDED(hrAccelGet) || SUCCEEDED(hrQualityGet) ||
                SUCCEEDED(hrSpeakerConfigGet))
            {
                ghInst = hInst;
                gszHelpFile = szHelpFile;

                // Get the current settings
                GetCurrentSettings(&gAudData, dwWaveId, szDeviceName, fRecord);

                // Now, add the property sheets
                page = 0;

                // Only add speaker configuration if we're not in record mode
                if (!fRecord)
                {
                    if (SUCCEEDED(hrSpeakerConfigGet))
                    {
                        memset(&psp[page],0,sizeof(PROPSHEETPAGE));
                        psp[page].dwSize = sizeof(PROPSHEETPAGE);
                        psp[page].dwFlags = PSP_DEFAULT;
                        psp[page].hInstance = ghInst;
                        psp[page].pszTemplate = MAKEINTRESOURCE(IDD_SPEAKERS);
                        psp[page].pfnDlgProc = SpeakerHandler;
                        page++;
                    }
                }

                // Always check to add performance sheet
                if (SUCCEEDED(hrAccelGet) || SUCCEEDED(hrQualityGet))
                {
                    memset(&psp[page],0,sizeof(PROPSHEETPAGE));
                    psp[page].dwSize = sizeof(PROPSHEETPAGE);
                    psp[page].dwFlags = PSP_DEFAULT;
                    psp[page].hInstance = ghInst;
                    psp[page].pszTemplate = MAKEINTRESOURCE(IDD_PLAYBACKPERF);
                    psp[page].pfnDlgProc = PerformanceHandler;
                    page++;
                }

                // Always check to add GFX sheet
                if (fDisplayGFXTab)
                {
                    memset(&psp[page],0,sizeof(PROPSHEETPAGE));
                    psp[page].dwSize = sizeof(PROPSHEETPAGE);
                    psp[page].dwFlags = PSP_DEFAULT;
                    psp[page].hInstance = ghInst;
                    psp[page].pszTemplate = MAKEINTRESOURCE(EFFECTSDLG);
                    psp[page].pfnDlgProc = SoundEffectsDlg;
                    page++;
                }

                LoadString( hInst, IDS_ADVAUDIOTITLE, str, sizeof( str )/sizeof(TCHAR) );

                memset(&psh,0,sizeof(psh));
                psh.dwSize = sizeof(psh);
                psh.dwFlags = PSH_DEFAULT | PSH_PROPSHEETPAGE; 
                psh.hwndParent = hwnd;
                psh.hInstance = ghInst;
                psh.pszCaption = str;
                psh.nPages = page;
                psh.nStartPage = 0;
                psh.ppsp = psp;

                PropertySheet(&psh);
            }
            else
            {
                TCHAR szCaption[MAX_PATH];
                TCHAR szMessage[MAX_PATH];
                bool fAccessDenied;

                fAccessDenied = (hrAccelGet == DSERR_ACCESSDENIED) || (hrQualityGet == DSERR_ACCESSDENIED) ||
                    (hrSpeakerConfigGet == DSERR_ACCESSDENIED);

                LoadString(hInst,IDS_ERROR,szCaption,sizeof(szCaption)/sizeof(TCHAR));
                LoadString(hInst,fAccessDenied ? IDS_ERROR_DSPRIVS : IDS_ERROR_DSGENERAL,szMessage,sizeof(szMessage)/sizeof(TCHAR));
                MessageBox(hwnd,szMessage,szCaption,MB_OK|MB_ICONERROR);
            }

            FreeLibrary(hModDirectSound);
        } //end if DS loaded
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\h\cphelp.h ===
//
//  NOTE:  The NetUI group is responsible for a number of applets
//         that are shipped with the base system.  This includes the
//         Network Control Panel Applet (NCPA.CPL), the Server Manager
//         and Services Applets (SRVMGR.CPL), and the UPS Applet (UPS.CPL).
//
//         To prevent help context conflicts between the NetUI applets
//         and the "standard" system applets, the NetUI group hereby
//         reserves the help contexts in the range 40000 - 59999.  This
//         will provide plenty of breathing room for future NetUI applets.
//

#define IDH_NETUI_FIRST 40000
#define IDH_NETUI_LAST  59999

#define IDH_HELPFIRST        5000
#define IDH_SYSMENU     (IDH_HELPFIRST + 2000)
#define IDH_MBFIRST     (IDH_HELPFIRST + 2001)
#define IDH_DLG_FONT2   (IDH_HELPFIRST + 2002)
#define IDH_MBLAST      (IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST    (IDH_HELPFIRST + 3000)
#define IDH_SCRNSAVE    (IDH_HELPFIRST + 4000)


#define IDH_SPOOLER_OFFSET 5000
#define IDH_DISPLAY_OFFSET 6000

#define IDH_MENU_SCHHELP    (IDH_HELPFIRST + MENU_SCHHELP)
#define IDH_MENU_INDHELP    (IDH_HELPFIRST + MENU_INDHELP)
#define IDH_MENU_USEHELP    (IDH_HELPFIRST + MENU_USEHELP)
#define IDH_MENU_ABOUT      (IDH_HELPFIRST + MENU_ABOUT )
#define IDH_MENU_EXIT       (IDH_HELPFIRST + MENU_EXIT)
#define IDH_CHILD_COLOR     (IDH_HELPFIRST + CHILD_COLOR)
#define IDH_CHILD_PRINTER   (IDH_HELPFIRST + CHILD_PRINTER)
#define IDH_CHILD_FONT      (IDH_HELPFIRST + CHILD_FONT )
#define IDH_CHILD_INTL      (IDH_HELPFIRST + CHILD_INTL )
#define IDH_CHILD_PORTS     (IDH_HELPFIRST + CHILD_PORTS)
#define IDH_CHILD_KEYBOARD  (IDH_HELPFIRST + CHILD_KEYBOARD )
#define IDH_CHILD_MOUSE     (IDH_HELPFIRST + CHILD_MOUSE)
#define IDH_CHILD_DATETIME  (IDH_HELPFIRST + CHILD_DATETIME )
#define IDH_CHILD_DESKTOP   (IDH_HELPFIRST + CHILD_DESKTOP)
#define IDH_CHILD_SOUND     (IDH_HELPFIRST + CHILD_SOUND)
#define IDH_CHILD_NETWORK   (IDH_HELPFIRST + CHILD_NETWORK)
#define IDH_CHILD_SYSTEM    (IDH_HELPFIRST + CHILD_SYSTEM)
#define IDH_CHILD_MIDI      (IDH_HELPFIRST + 122)           // MM midi
#define IDH_CHILD_SND       (IDH_HELPFIRST + 121)           // MM sound
#define IDH_CHILD_DRIVERS   (IDH_HELPFIRST + 120)           // MM drivers
#define IDH_CHILD_CURSORS   (IDH_HELPFIRST + 119)
#define IDH_DLG_CURBROWSE   (IDH_HELPFIRST + 118)

#define IDH_DLG_CONFLICT    (IDH_DLGFIRST + DLG_CONFLICT)
#define IDH_DLG_ADDFILE     (IDH_DLGFIRST + DLG_ADDFILE)
#define IDH_DLG_INTLDATE    (IDH_DLGFIRST + DLG_INTLDATE)
#define IDH_DLG_INTLTIME    (IDH_DLGFIRST + DLG_INTLTIME)
#define IDH_DLG_INTLNUM     (IDH_DLGFIRST + DLG_INTLNUM)
#define IDH_DLG_INTLCUR     (IDH_DLGFIRST + DLG_INTLCUR)
#define IDH_DLG_NETPRINT    (IDH_DLGFIRST + DLG_NETPRN)

#define IDH_DLG_PATTERN     (IDH_DLGFIRST + DLG_PATTERN)
#define IDH_DLG_PORTS2      (IDH_DLGFIRST + DLG_PORTS2)
#define IDH_DLG_PORTS3      (IDH_DLGFIRST + DLG_PORTS3)
#define IDH_DLG_MOUSE       (IDH_DLGFIRST + DLG_MOUSE)

#define IDH_DLG_COLORSAVE   (IDH_DLGFIRST + DLG_COLORSAVE)
#define IDH_DLG_COLORDEFINE (IDH_DLGFIRST + DLG_COLORDEFINE)
#define IDH_DLG_CONFIGURE   (IDH_DLGFIRST + DLG_CONFIGURE)
#define IDH_DLG_INSTALL     (IDH_DLGFIRST + DLG_INSTALL)
#define IDH_DLG_UNLIST      (IDH_DLGFIRST + DLG_UNLIST)
#define IDH_DLG_REMOVEFONT  (IDH_DLGFIRST + DLG_REMOVEFONT)
#define IDH_DLG_TRUETYPE    (IDH_DLGFIRST + DLG_TRUETYPE)
#define IDH_DLG_BROWSE      (IDH_DLGFIRST + DLG_BROWSE)

#define IDH_DLG_INSTALL_PS     (IDH_DLGFIRST + DLG_INSTALL_PS)
#define IDH_DLG_REMOVEFONT_PS  (IDH_DLGFIRST + DLG_REMOVEFONT_PS)


#define IDH_DLG_SYSTEM      (IDH_DLGFIRST + DLG_SYSTEM)
#define IDH_DLG_ADDOS       (IDH_DLGFIRST + DLG_ADDOS)

#define IDH_DLG_VIRTUALMEM  (IDH_DLGFIRST + DLG_VIRTUALMEM)

#define IDH_DLG_PREVIOUSCON (IDH_DLGFIRST + DLG_PREVIOUSCON)
#define IDH_DLG_TASKING     (IDH_DLGFIRST + DLG_TASKING)

#define IDH_DLG_COREDUMP    (IDH_DLGFIRST + DLG_COREDUMP)

// pen win help constants

#define IDH_DLG_ROT              (IDH_DLGFIRST + 200)
#define IDH_DLG_CAL              (IDH_DLGFIRST + 201)
#define IDH_DLG_CAL_ACCEPT       (IDH_DLGFIRST + 202)


// MM midi  dialogs
#define IDH_DLG_MIDI_SETUPEDIT  (IDH_DLGFIRST + 404)
#define IDH_DLG_MIDI_PATCHEDIT  (IDH_DLGFIRST + 504)
#define IDH_DLG_MIDI_KEYEDIT    (IDH_DLGFIRST + 604)
#define IDH_DLG_MIDI_SETUPNEW   (IDH_DLGFIRST + 704)
#define IDH_DLG_MIDI_PATCHNEW   (IDH_DLGFIRST + 804)
#define IDH_DLG_MIDI_KEYNEW     (IDH_DLGFIRST + 904)

// MM sound dialogs
#define IDH_DLG_NEWSND          (IDH_DLGFIRST + 503)

// MM drivers dialogs
#define IDH_DLG_ADD_DRIVERS     (IDH_DLGFIRST + 403)
#define IDH_DLG_INSERT_DISK     (IDH_DLGFIRST + 703)
#define IDH_DLG_ADD_UNKNOWN     (IDH_DLGFIRST + 803)
#define IDH_DLG_FILE_ERROR      (IDH_DLGFIRST + 903)

// Screen Saver dialogs
#define IDH_DLG_CHANGEPASS      (IDH_SCRNSAVE)
#define IDH_DLG_MARQUE          (IDH_SCRNSAVE + 1)
#define IDH_DLG_MYSTIFY         (IDH_SCRNSAVE + 2)
#define IDH_DLG_STARSIM         (IDH_SCRNSAVE + 3)
#define IDH_DLG_MARQUEE_FONT    (IDH_SCRNSAVE + 4)
#define IDH_DLG_FLYWIN          (IDH_SCRNSAVE + 5)
#define IDH_DLG_BEZIER          (IDH_SCRNSAVE + 6)

#define IDH_DLG_PRINTER         (IDH_DLGFIRST + DLG_PRINTER)

// We need to change the help stuff when called by the spooler.
#define IDH_PRINTER               (IDH_DLG_PRINTER + IDH_SPOOLER_OFFSET)
#define IDH_DLG_CONNECT           (IDH_DLG_CONFIGURE + IDH_SPOOLER_OFFSET)
#define IDH_DLG_NETCONNECT        (IDH_DLG_NETPRINT + IDH_SPOOLER_OFFSET)
#define IDH_DLG_PREVCON           (IDH_DLG_PREVIOUSCON + IDH_SPOOLER_OFFSET)
#define IDH_DLG_UNLISTED_PRINTER  (IDH_DLG_UNLIST + IDH_SPOOLER_OFFSET)
// #define IDH_DLG_INSTALL_PRINTER   (IDH_DLG_INSTALL + IDH_SPOOLER_OFFSET)
#define IDH_DLG_COM_SET           (IDH_DLG_PORTS2 + IDH_SPOOLER_OFFSET)
#define IDH_DLG_ADVANCED_COMSET   (IDH_DLG_PORTS3 + IDH_SPOOLER_OFFSET)
#define IDH_DLG_PRINTER_BROWSE    (IDH_DLG_BROWSE + IDH_SPOOLER_OFFSET)
#define IDH_DLG_INS_PRINTER_DISK  (IDH_DLG_INSERT_DISK + IDH_SPOOLER_OFFSET)



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\h\cplib.h ===
/** FILE: cplib.h ********** Module Header ********************************
 *
 *  Control panel utility library routines for use by control panel applets.
 *  Common definitions, resource ids, typedefs, external declarations and
 *  library routine function prototypes.
 *
 * History:
 *  15:30 on Thur  25 Apr 1991  -by-    Steve Cathcart   [stevecat]
 *       Took base code from Win 3.1 source
 *  10:30 on Tues  04 Feb 1992	-by-	Steve Cathcart   [stevecat]
 *	    Updated code to latest Win 3.1 sources
 *
 *  Copyright (C) 1990-1992 Microsoft Corporation
 *
 *************************************************************************/
//==========================================================================
//                        Typedefs and Definitions
//==========================================================================
// NOTE: The following lines are used by applets to define items in their
//               resource files.  These are necessary to be compatible with some of
//               library routines.
//
// Resource String ids for Applets
#define INITS           16
#define CLASS           36
#define COPY            (CLASS + 4)

#define UTILS           64
#define INSTALLIT  196

#define FOO -1                  // for useless control ids

#define IDD_HELP        200             // Help control id

#define CP_ACCEL        100             // Keyboard Accelerator table

// End resource file definitions

#define PATHMAX         133         // path length max

#define MYNUL     (LPSTR) szNull

#define COLOR_SAVE        711

#define  NOSELECT -1        // indices for int Selected
#define  HOUR     0             // index into rDateTime, wDateTime, wRange
#define  MINUTE   1
#define  SECOND   2
#define  MONTH    3
#define  DAY      4
#define  YEAR     5
#define  WEEKDAY  6
#if 0
#define  UPTIME   6
#define  DOWNTIME 7
#define  UPDATE   8
#define  DOWNDATE 9
#endif

typedef BOOL (APIENTRY *BWNDPROC)(HWND, UINT, DWORD, LONG);

#ifndef NOARROWS
typedef struct
  {
    short lineup;             /* lineup/down, pageup/down are relative */
    short linedown;           /* changes.  top/bottom and the thumb    */
    short pageup;             /* elements are absolute locations, with */
    short pagedown;           /* top & bottom used as limits.          */
    short top;
    short bottom;
    short thumbpos;
    short thumbtrack;
    BYTE  flags;              /* flags set on return                   */
  } ARROWVSCROLL;
typedef ARROWVSCROLL NEAR     *NPARROWVSCROLL;
typedef ARROWVSCROLL FAR      *LPARROWVSCROLL;

#define UNKNOWNCOMMAND 1
#define OVERFLOW       2
#define UNDERFLOW      4

#endif

#define COPY_CANCEL        0
#define COPY_SELF         -1
#define COPY_NOCREATE     -2
#define COPY_DRIVEOPEN    -3
#define COPY_NODISKSPACE  -4
#define COPY_NOMEMORY     -5

//  AddStringToObject defines
#define ASO_GLOBAL  0x0001
#define ASO_FIXED   0x0002
#define ASO_EXACT   0x0004
#define ASO_COMPACT 0x0008

/* Help defines */
#define IDH_HELPFIRST                   5000
#define IDH_DLGFIRST      (IDH_HELPFIRST + 3000)
#define IDH_DLG_CONFLICT  (IDH_DLGFIRST + DLG_CONFLICT)
#define IDH_DLG_ADDFILE   (IDH_DLGFIRST + DLG_ADDFILE)

#define MENU_INDHELP     40

//==========================================================================
//                              Macros
//==========================================================================
#define GSM(SM) GetSystemMetrics(SM)
#define GDC(dc, index) GetDeviceCaps(dc, index)

#define LPMIS LPMEASUREITEMSTRUCT
#define LPDIS LPDRAWITEMSTRUCT
#define LPCIS LPCOMPAREITEMSTRUCT

#define LONG2POINT(l, pt)   (pt.y = (int) HIWORD(l),  pt.x = (int) LOWORD(l))

//==========================================================================
//                         External Declarations
//==========================================================================
/* exported from applets  */
extern HANDLE hModule;


/* exported from cplib  */
/* initapp.c  */
extern char szOnString[];               // separator printer/port in listboxes
extern char szSeparator[];              // separator filename printer desc
extern char szDefNullPort[];            // default null port name
									
extern char szCtlPanel[];
extern char szErrMem[];

extern char szBasePath[];               /* Path to WIN.INI directory */
extern char szWinIni[];                 /* Path to WIN.INI */
extern char szWinCom[];                 /* Path to WIN.COM directory */
extern char szSystemIniPath[];          /* Path to SYSTEM.INI */
extern char szCtlIni[];                 /* Path to CONTROL.INI */
extern char szControlHlp[];
extern char szSetupInfPath[];
extern char szSetupDir[];
extern char szSharedDir[];

extern char pszSysDir[];
extern char pszWinDir[];
extern char pszClose[];
extern char pszContinue[];

extern char szSYSTEMINI[];
extern char szSETUPINF[];
extern char szCONTROLINF[];

extern char BackSlash[];
extern char szFOT[];
extern char szDot[];

extern unsigned wMerge;                 /* MERGE SPEC FOR STRINGS */

/* utiltext.c */
extern char szGenErr[];
extern char szNull[];
extern char szComma[];
extern char szSpace[];

extern short wDateTime[];                   // values for first 7 date/time items
extern short wModulos[];                    // highest value for hour, minute, second
extern short wPrevDateTime[];               // only repaint fields if nec

/* Help stuff */
extern DWORD dwContext;
extern WORD  wHelpMessage;
extern WORD  wBrowseMessage;
extern WORD  wBrowseDoneMessage;


// Originally from cpprn.c
extern short nDisk;
extern char szDrv[];
extern char szDirOfSrc[];               	// Directory for File copy
extern WORD nConfID;                    	// For conflict dialog


//==========================================================================
//                          Function Prototypes
//==========================================================================
/* utiltext.c */

void GetDate (void);
void GetTime (void);
void SetDate (void);
void SetTime (void);

void SetDateTime (void);                // [stevecat] - new functions
void GetDateTime (void);

DWORD  AddStringToObject(DWORD dwStringObject, LPSTR lpszSrc, WORD wFlags);
LPSTR  BackslashTerm (LPSTR pszPath);
void   ErrMemDlg(HWND hParent);
HANDLE FindRHSIni (LPSTR pFile, LPSTR pSection, LPSTR pRHS);
int    GetSection (LPSTR lpFile, LPSTR lpSection, LPHANDLE hSection);
short  myatoi(LPSTR pszInt);
HANDLE StringToLocalHandle (LPSTR lpStr);

#ifdef LATER
void   ErrWinDlg(HWND hParent);
short  Copy(HWND hParent, char *szSrcFile, char *szDestFile);
#endif  //  LATER

/* util.c */

int    DoDialogBoxParam(int nDlg, HWND hParent, WNDPROC lpProc,
                                        DWORD dwHelpContext, DWORD dwParam);
void   HourGlass (BOOL bOn);
int    MyMessageBox(HWND hWnd, DWORD wText, DWORD wCaption, DWORD wType, ...);
void   SendWinIniChange(LPSTR szSection);
int    strpos(LPSTR,char);
char   *strscan(char *, char *);
void   StripBlanks( char * );

/* arrow.c */
short ArrowVScrollProc(short wScroll, short nCurrent, LPARROWVSCROLL lpAVS);
BOOL  OddArrowWindow(HWND);

// initapp.c (new)       (Originally from control.c)
BOOL AppletInit();

// addfile.c (new)   (Originally from cpprn.c)
BOOL AddFileDlg (HWND hDlg, UINT message, DWORD wParam, LONG lParam);

// conflict.c (new)   (Originally from cpprn.c)
BOOL ConflictDlg(HWND hDlg, UINT message, DWORD wParam, LONG lParam);

#if DBG
void  DbgPrint( char *, ... );
void  DbgBreakPoint( void );
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\advaudio.h ===
//--------------------------------------------------------------------------;
//
//  File: advaudio.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;

#ifndef ADVAUDIO_HEADER
#define ADVAUDIO_HEADER

typedef struct CPLDATA
{
	DWORD dwHWLevel;
	DWORD dwSRCLevel;
	DWORD dwSpeakerConfig;
	DWORD dwSpeakerType;
} CPLDATA, *LPCPLDATA;


typedef struct AUDDATA
{
	GUID		devGuid;
	BOOL		fValid;
    BOOL        fRecord;
    DWORD       waveId;
	CPLDATA		stored;
	CPLDATA		current;
    DWORD       dwDefaultHWLevel;     // Obtain the default acceleration from DSound
} AUDDATA, *LPAUDDATA;


STDAPI_(void) AdvancedAudio(HWND hWnd, HINSTANCE hInst, const TCHAR *szHelpFile, 
                            DWORD dwWaveId, LPTSTR szDeviceName, BOOL fRecord);
STDAPI_(void) ToggleApplyButton(HWND hWnd);
STDAPI_(void) ApplyCurrentSettings(LPAUDDATA pAD);
HRESULT CheckDSAccelerationPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet);
HRESULT CheckDSSrcQualityPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet);
HRESULT CheckDSSpeakerConfigPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet);

extern AUDDATA		gAudData;
extern HINSTANCE	ghInst;
extern const TCHAR*	gszHelpFile;

#endif // ADVAUDIO_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\add.c ===
/*  ADD.C
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**  Multimedia Control Panel Applet for removing
**  device drivers.  See the ispec doc DRIVERS.DOC for more information.
**
**  This file deals with the case where an OEM driver being installed.
**
**  History:
**
**      Thu Nov 1 1991 -by- Sanjaya
**      Created. Originally part of drivers.c
*/

#include <windows.h>
#include <mmsystem.h>
#include <memory.h>
#include <string.h>
#include <cpl.h>

#include "drivers.h"
#include <cphelp.h>
#include "sulib.h"
extern PINF       pinfOldDefault;
extern BOOL       bBadOemSetup;
TCHAR *szFilter[] = {TEXT("Inf Files(*.inf)"), TEXT("*.inf"), TEXT("Drv Files(*.drv)"), TEXT("*.drv"), TEXT("")};

BOOL GetDir          (HWND);
void BrowseDlg           (HWND, int);

/*  AddDriversDlg
 *
 * Returns 2 if dialog needs to be redrawn
 * Returns 1 if the oem file has been succesfully located
 * Returns 0 if Cancel has been pressed
 */

INT_PTR AddDriversDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:

            SetDlgItemText(hDlg, ID_TEXT, (LPTSTR)szUnlisted);
            SetDlgItemText(hDlg, ID_EDIT, (LPTSTR)szDirOfSrc);
            return(TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    if (GetDir(hDlg))
                    {
                        DialogBox(myInstance, MAKEINTRESOURCE(DLG_UPDATE),
                        GetParent(hDlg), AddUnlistedDlg);
                        break;
                    } else {
                        EndDialog(hDlg, 2);
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    return(TRUE);

                case IDS_BROWSE:
                    lstrcpy(szDrv, szOemInf);
                    BrowseDlg(hDlg, 1);
                    break;

                case IDH_DLG_INSERT_DISK:
                    goto DoHelp;
            }
            break;

        default:
            if (message == wHelpMessage) {
DoHelp:
                WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_DLG_INSERT_DISK);
                return TRUE;
            } else
                return FALSE;

    }
    return (FALSE);                         /* Didn't process a message    */
}


BOOL GetDir(HWND hDlg)
{
    LPTSTR    pstr;
    OFSTRUCT of;

    wsStartWait();

   /*
    * Test the edit box for a proper path
    * and look for the oemsetup.inf
    * file.  If we don't find it , highlight the
    * text in the edit box and bring up a dialog box
    */

    GetDlgItemText( hDlg, ID_EDIT, szDirOfSrc, MAX_PATH);
    RemoveSpaces(szFullPath, szDirOfSrc);
    lstrcpy(szDirOfSrc, szFullPath);
    for (pstr = szFullPath;*pstr;pstr++);
        if (*(pstr-1) != TEXT('\\'))
            *pstr++ = TEXT('\\');

    *pstr = TEXT('\0');

    lstrcpy(szDiskPath, szFullPath);

   /*
    * Look for an oemsetup.inf
    * If you can't find it return false
    *
    */

    lstrcpy(pstr, szOemInf);

    if ((HFILE)HandleToUlong(CreateFile(szFullPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == -1)
    {
       SendDlgItemMessage(hDlg, ID_EDIT, EM_SETSEL, 0, -1L);
       wsEndWait();
       return (FALSE);
    }

   /*
    * Change the default inf to this new oemsetup.inf
    * Discard the value of the previous .inf, since it might
    * just be another set of oem drivers.
    */

    if (bBadOemSetup)
       infSetDefault(infOpen(szFullPath));
    else
       pinfOldDefault = infSetDefault(infOpen(szFullPath));
    EndDialog(hDlg, 1);
    wsEndWait();
    return(TRUE);
}


/*
 * Hooks into common dialog to show only directories
 */

UINT_PTR CALLBACK AddFileHookProc(HWND hDlg, UINT iMessage,
                              WPARAM wParam, LPARAM lParam)
{
  TCHAR szTemp[200];
  HWND hTemp;

    switch (iMessage)
    {
        case WM_INITDIALOG:

            GetDlgItemText(((LPOPENFILENAME)lParam)->hwndOwner, ID_TEXT,
                  szTemp, sizeof(szTemp)/sizeof(TCHAR));
            SetDlgItemText(hDlg, ctlLast+1, szTemp);

            goto PostMyMessage;

        case WM_COMMAND:

            switch (LOWORD(wParam))
            {
                case lst2:
                case cmb2:
                case IDOK:

  PostMyMessage:
                  PostMessage(hDlg, WM_COMMAND, ctlLast+2, 0L);
                  break;

                case IDH_DLG_BROWSE:
                  goto DoHelp;

                case ctlLast+2:
                   if (bFindOEM)
                   {
                     if (SendMessage(hTemp=GetDlgItem(hDlg, lst1), LB_GETCOUNT,
                       0, 0L))
                       {
                         SendMessage(hTemp, LB_SETCURSEL, 0, 0L);
                         SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(lst1, LBN_SELCHANGE),
                                     (LONG_PTR)hTemp);
                         break;
                       }
                   }
                   SetDlgItemText(hDlg, edt1, szDrv);
                   break;
            }
            break;

        default:

            if (iMessage == wHelpMessage)
            {
DoHelp:
                WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_DLG_BROWSE);
                return(TRUE);
            }
    }

    return FALSE;  // commdlg, do your thing
}


/*
 * Function : BrowseDlg
 *
 *     Call the GetOpenFileName dialog to open a file
 *
 * Parameters :
 *
 *     hDlg : Parent Dialog box
 *
 *     iIndex : Index into szFilter to determine which filter(s) to use
 */


void BrowseDlg(HWND hDlg, int iIndex)
{
    OPENFILENAME OpenFileName;
    TCHAR szPath[MAX_PATH];
    TCHAR szFile[MAX_PATH];

    *szPath = TEXT('\0');
    *szFile = TEXT('\0');
    OpenFileName.lStructSize = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner = hDlg;
    OpenFileName.hInstance = myInstance;
    OpenFileName.lpstrFilter = szFilter[0];
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter = 0;
    OpenFileName.nFilterIndex = iIndex;
    OpenFileName.lpstrFile = (LPTSTR)szPath;
    OpenFileName.nMaxFile = sizeof(szPath) / sizeof(TCHAR);
    OpenFileName.lpstrFileTitle = szFile;
    OpenFileName.nMaxFileTitle = sizeof(szFile) / sizeof(TCHAR);
    OpenFileName.lpstrInitialDir = NULL;
    OpenFileName.lpstrTitle = NULL;
    OpenFileName.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK |
      /*  OFN_FILEMUSTEXIST | */ OFN_ENABLETEMPLATE | OFN_NOCHANGEDIR |
            OFN_SHOWHELP;
    OpenFileName.lCustData = (LONG_PTR)hDlg;
    OpenFileName.lpfnHook = AddFileHookProc;

    OpenFileName.lpTemplateName = (LPTSTR)MAKEINTRESOURCE(DLG_BROWSE);
    OpenFileName.nFileOffset = 0;
    OpenFileName.nFileExtension = 0;
    OpenFileName.lpstrDefExt = NULL;
    if (GetOpenFileName(&OpenFileName))
    {
        UpdateWindow(hDlg); // force buttons to repaint
        szPath[OpenFileName.nFileOffset] = TEXT('\0');
        SetDlgItemText(hDlg, ID_EDIT, szPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\copy.c ===
/*
 *  copy.c - Copy routine for WinDosSetup
 *  Todd Laney
 *
 *  Modification History:
 *
 *  6/03/91 Vlads        Change copy process to incorporate new Install API
 *
 *  3/24/89  Toddla      Wrote it
 *
 *
 *  notes:
 *   we now use the LZCopy stuff for compression
 *   we now set the crit error handler ourselves so CHECKFLOPPY is
 *   NOT defined
 */

#include <windows.h>

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <mmsystem.h>

#include "drivers.h"
#include "sulib.h"
//#include <ver.h>


#define MAX_COPY_ATTEMPTS  15

/*
 *  Maximum number of install disks we support
 */

#define MAX_DISKS 100

/*
 *  Flags for VerInstallFile
 */

#define FORCEABLE_FLAGS  (VIF_MISMATCH + VIF_SRCOLD + VIF_DIFFLANG + VIF_DIFFTYPE + VIF_DIFFCODEPG )

/**********************************************************************
 *
 * Local function prototypes.
 *
 **********************************************************************/

 // Retrieve disk path for logical disk

 LONG GetDiskPath(LPTSTR Disk, LPTSTR szPath, size_t cchPath);

 // Convert VIF_... to ERROR... return codes

 UINT ConvertFlagToValue(DWORD dwFlags);

 // Do the work of trying to copy a file

 LONG TryCopy(LPTSTR    szSrc,     // Full source file path
              LPTSTR    szLogSrc,  // Logical source name
              LPTSTR    szDestPath,// Destination path
              FPFNCOPY fpfnCopy); // Callback routine

 #ifdef CHECK_FLOPPY
 BOOL NEAR IsDiskInDrive(int iDisk);
 #endif

 // GLOBAL VARIABLES

 //  directory where windows will be setup to

 TCHAR szSetupPath[MAX_PATH];

 // directory where the root of the setup disks are!

 TCHAR szDiskPath[MAX_PATH];

 // Name of driver being copied (or oemsetup.inf)

 TCHAR szDrv[120];

/*
 *  global vars used by DosCopy
 */
 static LPTSTR    lpBuf = NULL;   // copy buffer
 static int      iBuf = 0;       // usage count
 static UINT     nBufSize;
 BOOL     bRetry = FALSE;
 BOOL     bQueryExist;

 extern BOOL bCopyEvenIfOlder;  // From DRIVERS.C


 BOOL DefCopyCallback(int msg, DWORD_PTR n, LPTSTR szFile)
 {
     return FC_IGNORE;
 }



/*  UINT FileCopy (szSource, szDir, fpfnCopy, UINT fCopy)
 *
 *  This function will copy a group of files to a single destination
 *
 *  ENTRY:
 *
 *  szSourc      : pointer to a SETUP.INF section
 *  szDir        : pointer to a string containing the target DIR
 *  fpfnCopy     : callback function used to notify called of copy status
 *  fCopy        : flags
 *
 *      FC_SECTION            - szSource is a section name
 *      FC_LIST               - szSource is a pointer to a char **foo;
 *      FC_LISTTYPE           - szSource is a pointer to a char *foo[];
 *      FC_FILE               - szSource is a file name.
 *      FC_QUALIFIED          - szSource is a fully qualified file name.
 *      FC_DEST_QUALIFIED     - szDir is fully qualified. Don't expand this.
 *      FC_CALLBACK_WITH_VER  - call back if file exists and report version information.
 *
 *  NOTES:
 *      if szSource points to a string of the form '#name' the section
 *      named by 'name' will be used as the source files
 *
 *      the first field of each line in the secion is used as the name of the
 *      source file.  A file name has the following form:
 *
 *          #:name
 *
 *          #       - Disk number containing file 1-9,A-Z
 *          name    - name of the file, may be a wild card expression
 *
 *  Format for copy status function
 *
 *  BOOL FAR PASCAL CopyStatus(int msg, int n, LPSTR szFile)
 *
 *      msg:
 *          COPY_ERROR          error occured while copying file(s)
 *                              n      is the DOS error number
 *                              szFile is the file that got the error
 *                              return: TRUE ok, FALSE abort copy
 *
 *          COPY_STATUS         Called each time a new file is copied
 *                              n      is the percent done
 *                              szFile is the file being copied
 *                              return: TRUE ok, FALSE abort copy
 *
 *          COPY_INSERTDISK     Please tell the user to insert a disk
 *                              n      is the disk needed ('1' - '9')
 *                              return: TRUE try again, FALSE abort copy
 *
 *          COPY_QUERYCOPY      Should this file be copied?
 *                              n      line index in SETUP.INF section (0 based)
 *                              szFile is the line from section
 *                              return: TRUE copy it, FALSE dont copy
 *
 *          COPY_START          Sent before any files are copied
 *
 *          COPY_END            Sent after all files have been copied
 *                              n   is dos error if copy failed
 *
 *          COPY_EXISTS         Sent if the FC_CALL_ON_EXIST bit was set
 *                              and the file exists at the destination
 *                              given for the filecopy.
 *
 *
 *  EXIT: returns TRUE if successful, FALSE if failure.
 *
 */

UINT FileCopy (LPTSTR szSource, LPTSTR szDir, FPFNCOPY fpfnCopy, UINT fCopy)
{
   int   err = ERROR_SUCCESS;     // Return code from this routine

   TCHAR  szPath[MAX_PATH];
   TCHAR  szLogSrc[MAX_PATH];
   TCHAR  szSrc[MAX_PATH];

   LPTSTR pFileBegin;              // First file

   LPTSTR * List;                  // Handle lists of files
   LPTSTR * ListHead;

   int   nDisk;                   // The disk we're on

   int   cntFiles = 0;            // How many files we've got to do

   if (fpfnCopy == NULL) {
      fpfnCopy = DefCopyCallback;
   }

   if (!szSource || !*szSource || !szDir || !*szDir) {
      return ERROR_FILE_NOT_FOUND;
   }


  /*
   *  fix up the drive in the destination
   */

   if ( fCopy & FC_DEST_QUALIFIED ) {
      lstrcpy(szPath, szDir);
      fCopy &= ~FC_DEST_QUALIFIED;
   } else {
      err = ExpandFileName(szDir, szPath);
      if (err != ERROR_SUCCESS)
	  {
		  (*fpfnCopy)(COPY_ERROR, err, szDir);
		  return err;
	  }
   }

   if (szSource[0] == TEXT('#') && fCopy == FC_FILE) {
       fCopy = FC_SECTION;
       ++szSource;
   }

   switch (fCopy) {
       case FC_SECTION:
       {
           szSource = infFindSection(NULL,szSource);

          /*
           * We are called even when the section doesn't exist
           */

           if (szSource == NULL) {
               return ERROR_SUCCESS;
           }

           fCopy = FC_LIST;
       }
       // fall through to FC_LIST

       case FC_LIST:
          pFileBegin = szSource;
          cntFiles = infLineCount(szSource);
          break;

       case FC_LISTTYPE:
          ListHead = List = (LPTSTR far *)szSource;
          pFileBegin = *ListHead;
          while ( *List++ )           // Count files to be copied.
             ++cntFiles;
          break;

       case FC_FILE:
       case FC_QUALIFIED:
       default:
          pFileBegin = szSource;
          cntFiles = 1;
    }

  /*
   *  walk all files in the list and call TryCopy ....
   *
   *  NOTES:
   *      we must walk file list sorted by disk number.
   *      we should use the disk that is currently inserted.
   *      we should do a find first/find next on the files????
   *      we need to check for errors.
   *      we need to ask the user to insert disk in drive.
   *
   */

   (*fpfnCopy)(COPY_START,0,NULL);

  /*
   *  Go through all possible disks: 1 to 100 and A to Z (26)
   */

   for (nDisk = 1;
        err == ERROR_SUCCESS && (cntFiles > 0) &&
            (nDisk <= MAX_DISKS + 'Z' - 'A' + 1);
        nDisk++)
   {
      TCHAR Disk[10];              // Maximum string is "100:"
      LPTSTR pFile;
      int FileNumber;             // Which file in the list we're on
                                  // (to pass to callback)

      pFile      = pFileBegin;    // Start at first file
      List       = ListHead;      // Handled chained lists
      FileNumber = 0;             // Informational for callback - gives
                                  // which file in list we're on
     /*
      *  Work out the string representing our disk letter
      */

      if (nDisk > MAX_DISKS) {
          Disk[0] = TEXT('A') + nDisk - MAX_DISKS - 1;
          Disk[1] = TEXT('\0');
      } else {
          _itow(nDisk, Disk, 10);
      }

      wcscat(Disk, TEXT(":"));

      for (;
           err == ERROR_SUCCESS && pFile;
           FileNumber++,
           pFile = fCopy == FC_LISTTYPE ? *(++List) :
                   fCopy == FC_LIST ? infNextLine(pFile) :
                   NULL)
      {
        /*
         *  We have to reset high bit of first byte because it could be set
         *  by translating service in OEM setup to show that file name was
         *  mapped
         */

         *pFile = toascii(*pFile);


        /*
         *  should we copy this file?
         *  copy the files in disk order.
         */

         if (_wcsnicmp(pFile, Disk, wcslen(Disk)) == 0 || // File has disk
                                                         // number and we're
                                                         // on that disk
             RemoveDiskId(pFile) == pFile &&
                nDisk == 1 && *pFile ||                  // First disk and
                                                         // no disk number

             fCopy == FC_QUALIFIED) {                    // Fully qualified


            /*
             * done with a file. decrement count.
             */

             cntFiles--;

             lstrcpy(szDrv, RemoveDiskId(pFile));

             switch ((*fpfnCopy)(COPY_QUERYCOPY, FileNumber, pFile))
             {
                 case CopyCurrent:                // Skip

                         continue;

                 case CopyNeither:

                         err = ERROR_FILE_EXISTS; // File already exists

                 case CopyNew:
                         break;

                 default:
                         break;

             }

            /*
             *  Pick up bad return code from switch
             */

             if (err != ERROR_SUCCESS) {
                 break;
             }

            /*
             *  now we convert logical dest into a physical
             *    (unless FC_QUALIFIED)
             */

             err = infParseField(pFile, 1, szLogSrc, SIZEOF(szLogSrc));    // logical source
			 if( INF_PARSE_FAILED(err) ) {
			     (*fpfnCopy)(COPY_ERROR, err, pFile);
				 break;
			 }

             if ( fCopy != FC_QUALIFIED )
			 {
                err = ExpandFileName(szLogSrc, szSrc); // full physical source
				if (err != ERROR_SUCCESS) {
				    (*fpfnCopy)(COPY_ERROR, err, szLogSrc);
					break;
				}
             } else {
                lstrcpy(szSrc,szLogSrc);
             }


            /*
             *  Attempt copy
             */

             err = TryCopy(szSrc,      // Qualified Source file
                           szLogSrc,   // Logical source file name (with disk #)
                           szPath,     // Path for directory to install in
                           fpfnCopy);  // Copy callback function

            /*
             *  If failed to find file try the windows directory
             */

             if (err != ERROR_SUCCESS) {
                 break;
             }

         } /* End if dor if DoCopy */
      }
   }

   (*fpfnCopy)(COPY_END,err,NULL);

   return err;
}

/**********************************************************************
 *
 *  TryCopy
 *
 *  Copy a single file from source to destination using the VerInstallFile
 *  API - interpreting the return code as :
 *
 *    ERROR_SUCCESS  - OK
 *    Other          - failure type
 *
 **********************************************************************/

LONG TryCopy(LPTSTR    szSrc,      // Full expanded source file path
             LPTSTR    szLogSrc,   // Logical source name
             LPTSTR    szDestPath, // Destination path
             FPFNCOPY fpfnCopy)   // Callback routine

{
    DWORD wTmpLen;
    DWORD dwRetFlags;
    TCHAR  szTempFile[MAX_PATH];
    TCHAR  szErrFile[MAX_PATH];
    TCHAR  DriversPath[MAX_PATH];
    BOOL  bRetVal;               // Return code from callback
    LPTSTR szFile;
    TCHAR  szSrcPath[MAX_PATH];
    int   iAttemptCount;
    WORD  wVerFlags;
    LONG  err;
	LONG  lResult;

   /*
    *  Fix up destination if file is a kernel driver
    */

    if (IsFileKernelDriver(szSrc) && szDestPath) 
    {
        wcscpy(DriversPath, szDestPath);
        wcscat(DriversPath, TEXT("\\drivers"));
        szDestPath = DriversPath;
    }

   /*
    *  Create file name from current string
    */

    szFile = FileName(szSrc);
    lstrcpy(szSrcPath, szSrc);
    StripPathName(szSrcPath);

    for(iAttemptCount = 0, wVerFlags = 0 ;
        iAttemptCount <= MAX_COPY_ATTEMPTS;
        iAttemptCount++) {

        HCURSOR  hcurPrev;             // Saved cursor state

        // Central operation - attempt to install file szFile in directory
        // pointed by szPath from directory pointed by szSrc
        // If operation will fail but with possibility to force install
        // in last parameter buffer we will have temporary file name ==>
        // therefore we can avoid excessive copying.
        // NOTE: now szFile consists of only file name and other buffers
        // only path names.

        wTmpLen = MAX_PATH;

        hcurPrev = SetCursor(LoadCursor(NULL,IDC_WAIT));
        dwRetFlags = VerInstallFile(wVerFlags,
                                    (LPTSTR) szFile,
                                    (LPTSTR) szFile,
                                    (LPTSTR) szSrcPath,
                                    (LPTSTR) szDestPath,
                                    (LPTSTR) szDestPath,
                                    (LPTSTR) szTempFile,
                                    (LPDWORD) &wTmpLen);
        SetCursor(hcurPrev);

       /*
        *  Operation failed if at least one bit of return flags is non-zero
        *  That is unusual but defined so in Version API.
        */

        if ( !dwRetFlags )
            return ERROR_SUCCESS;    // If no errors - goto next file


       /*
        *  If flag MISMATCH is set - install can be forced and we have
        *  temporary file in destination subdirectory
        */

        if ( dwRetFlags  &  VIF_MISMATCH ) {

            if ( (dwRetFlags & VIF_SRCOLD) && (!bCopyEvenIfOlder) ) {

              /*
               *  If we need not call back with question - automatically
               *  force install with same parameters.
               *  michaele, *only* if src file is *newer* than dst file
               */

               DeleteFile(szTempFile);

               return ERROR_SUCCESS;
            }

           /*
            *  If we need not call back with question - automatically
            *  force install with same parameters.
            */

            wVerFlags |= VIFF_FORCEINSTALL;
            iAttemptCount--;             // Make sure we get another go.
            continue;

        }   /* End if MISMATCH */

       /*
        *  If real error occured - call back with error file info
        *  In all dialogs we use our error codes - so I will convert
        *  flags returned from Ver API to ours.
        */

        err = ConvertFlagToValue(dwRetFlags);


       /*
        *  If source path or file is nor readable - try to change disk
        */

        if ( dwRetFlags & VIF_CANNOTREADSRC )
        {
          /*
           *  Now new path in szSrc so I deleted logic for creating it
           */

           if (RemoveDiskId(szLogSrc) == szLogSrc)

             /*
              *  if disk # not provided, default to 1
              */

              bRetVal = (*fpfnCopy)(COPY_INSERTDISK, (DWORD_PTR)"1", szSrcPath);
           else
              bRetVal = (*fpfnCopy)(COPY_INSERTDISK, (DWORD_PTR)szLogSrc, szSrcPath);


           switch (bRetVal)
              {
              case FC_RETRY:
                  continue;              // and try again...

              case FC_ABORT:
                  return ERROR_FILE_NOT_FOUND;

              case FC_IGNORE:
                  break;
              }
        }

        lResult = ExpandFileName(szLogSrc, szErrFile);
		if (lResult != ERROR_SUCCESS)
		{
			(*fpfnCopy)(COPY_ERROR, lResult, szLogSrc);
			return lResult;
		}

#if WINDOWSDIR

        if (!*bWindowsDir  &&
            err != FC_ERROR_LOADED_DRIVER &&
            err != ERROR_DISK_FULL)
        {
            GetWindowsDirectory(szPath, MAX_PATH);
            *bWindowsDir = TRUE;
            continue;
        }

#endif // WINDOWSDIR

        switch ((*fpfnCopy)(COPY_ERROR, err, szErrFile)) {

            case FC_IGNORE:
                return ERROR_SUCCESS;

            case FC_RETRY:
                break;

            case FC_ABORT:
                return ERROR_FILE_NOT_FOUND;
        }
    } // End of attempts

    return err;
}

/*  LONG GetDiskPath(Disk, szPath, cchPath)
 *
 *  This function will retrive the full path name for a logical disk
 *
 *  The code reads the [disks] section of SETUP.INF and looks for
 *  n = path where n is the disk char.  NOTE the disk '0' defaults to
 *  the root windows directory.
 *
 *  ENTRY:
 *
 *  cDisk        : what disk to find 0-9,A-Z
 *  szPath       : buffer to hold disk path
 *  cchPath      : size of destination buffer (szPath) in characters.
 *                 length must be large enough to hold all of the
 *                 text including the null terminator.
 *
 *  Returns :
 *     ERROR_SUCCESS if a disk path was found
 *     ERROR_INSUFFICIENT_BUFFER if szPath is too small to hold disk path
 *     ERROR_NOT_FOUND if there was no disk specified (ie no ':'
 *
 */

LONG GetDiskPath(LPTSTR Disk, LPTSTR szPath, size_t cchPath)
{
   TCHAR    ach[MAX_PATH];
   TCHAR    szBuf[MAX_PATH];
   LONG     lResult;
   int i;


  /*
   *  Check to see if there is actually a disk id.
   *  If not return ERROR_NOT_FOUND
   */

   if (RemoveDiskId(Disk) == Disk) {
       return ERROR_NOT_FOUND;
   }

  /*
   *  Create our copy of the disk id
   */

   for (i = 0; Disk[i] != TEXT(':'); i++) {
       ach[i] = Disk[i];
   }
   ach[i] = TEXT('\0');


  /*
   *  Zero disk letter means windows setup directory
   */

   if (_wcsicmp(ach, TEXT("0")) == 0) {

      /*
       * return the windows setup directory
       */

       lstrcpy(szPath,szSetupPath);
       return ERROR_SUCCESS;
   }

  /*
   *  now look in the [disks] section for a full path name
   *
   *  This is a pretty bogus concept and is not supported
   *  in win 32 style disks section [Source Media Descriptions]
   */

   lResult = infGetProfileString(NULL,DISK_SECT,ach,szPath,cchPath);
   if (ERROR_NOT_FOUND == lResult)
   {
	   lResult = infGetProfileString(NULL,OEMDISK_SECT,ach,szPath,cchPath);
   }

   if (ERROR_SUCCESS == lResult)
   {
       lResult = infParseField(szPath,1,szPath,cchPath);
	   if( INF_PARSE_SUCCESS(lResult) )
	   {
		  /*
		   *  is the path relative? is so prepend the szDiskPath
		   */

		   if (szPath[0] == TEXT('.') || szPath[0] == TEXT('\0')) {
			   lstrcpy(szBuf,szDiskPath);
			   catpath(szBuf,szPath);
			   lstrcpy(szPath,szBuf);
		   }
		   lResult = ERROR_SUCCESS;
	   }
   }
   else if (ERROR_NOT_FOUND == lResult)
   {
	   lstrcpy(szPath, szDiskPath);
	   lResult = ERROR_SUCCESS;
   }

   return lResult;
}


/*  LONG FAR PASCAL ExpandFileName(LPSTR szFile, LPTSTR szPath)
 *
 *  This function will retrive the full path name for a file
 *  it will expand, logical disk letters to pyshical ones
 *  will use current disk and directory if non specifed.
 *
 *  if the drive specifed is 0-9, it will expand the drive into a
 *  full pathname using GetDiskPath()
 *
 *  IE  0:system ==>  c:windows\system
 *      1:foo.txt     a:\foo.txt
 *
 *  ENTRY:
 *
 *  szFile       : File name to expand
 *  szPath       : buffer to hold full file name
 *
 */
LONG ExpandFileName(LPTSTR szFile, LPTSTR szPath)
{
   TCHAR    szBuf[MAX_PATH*2];
   LONG		lResult;

   lResult = GetDiskPath(szFile, szBuf, SIZEOF(szBuf));
   if (ERROR_SUCCESS == lResult)
   {
       lstrcpy(szPath,szBuf);
       if (szFile[2])
          catpath(szPath,szFile + 2);
   }
   else if (ERROR_NOT_FOUND == lResult)
   {
       lstrcpy(szPath,szFile);
	   lResult = ERROR_SUCCESS;
   }
   else
   {
	   szPath[0] = 0;
   }
   return lResult;
}




void catpath(LPTSTR path, LPTSTR sz)
{
   //
   // Remove any drive letters from the directory to append
   //
   sz = RemoveDiskId(sz);

   //
   // Remove any current directories ".\" from directory to append
   //
   while (sz[0] == TEXT('.') && SLASH(sz[1]))
      sz += 2;

   //
   // Dont append a NULL string or a single "."
   //
   if (*sz && ! (sz[0] == TEXT('.') && sz[1] == 0))
   {
      // Add a slash separator if necessary.
      if ((! SLASH(path[lstrlen(path) - 1])) &&    // slash at end of path
          ((path[lstrlen(path) - 1]) != TEXT(':')) &&    // colon at end of path
          (! SLASH(sz[0])))                        // slash at beginning of file
         lstrcat(path, CHSEPSTR);

      lstrcat(path, sz);
   }
}

/*
 *  Return a pointer to the file name part of a string
 */

LPTSTR FileName(LPTSTR szPath)
{
   LPTSTR   sz;

   for (sz=szPath; *sz; sz++)
      ;

   for (; sz>=szPath && !SLASH(*sz) && *sz!=TEXT(':'); sz--)
      ;

   return ++sz;
}

/*
 *  Return the portion of a file name following the disk (ie anything
 *  before the colon).
 *  If there is no colon just return a pointer to the original string
 */

LPTSTR RemoveDiskId(LPTSTR szPath)
{
   LPTSTR sz;

   for (sz = szPath; *sz; sz++) {
       if (*sz == TEXT(':')) {
           return sz + 1;
       }
   }

   return szPath;
}

LPTSTR StripPathName(LPTSTR szPath)
{
    LPTSTR   sz;

    sz = FileName(szPath);

    if (sz > szPath+1 && SLASH(sz[-1]) && sz[-2] != TEXT(':'))
       sz--;

    *sz = 0;
    return szPath;
}

/*
 *  See if a file is a kernel driver.  Unfortunately the VersionInfo APIs
 *  don't seem coded up to take care of this at the moment so we just check
 *  to see if the file extension is ".SYS"
 */

 BOOL IsFileKernelDriver(LPTSTR szPath)
 {
     TCHAR drive[MAX_PATH];
     TCHAR dir[MAX_PATH];
     TCHAR fname[MAX_PATH];
     TCHAR ext[MAX_PATH];

     lsplitpath(szPath, drive, dir, fname, ext);
     return !_wcsicmp(ext, TEXT(".sys"));
 }


/**************************************************************************
 *
 * This function converts returned flags from Ver API to the numerical
 * error codes used in SETUP.
 *
 ***************************************************************************/

UINT ConvertFlagToValue(DWORD dwFlags)
{
    if ( ! dwFlags  )
       return(NO_ERROR);
    if ( dwFlags & VIF_CANNOTREADSRC )
       return(ERROR_FILE_NOT_FOUND);
    if ( dwFlags & VIF_OUTOFMEMORY )
       return(ERROR_OUTOFMEMORY);
    if ( dwFlags & VIF_ACCESSVIOLATION )
       return(ERROR_ACCESS_DENIED);
    if ( dwFlags & VIF_SHARINGVIOLATION )
       return(ERROR_SHARING_VIOLATION);
    if ( dwFlags & VIF_FILEINUSE)
       return(FC_ERROR_LOADED_DRIVER);

    return(ERROR_CANNOT_COPY);    // General error
}



#ifdef CHECK_FLOPPY
/*--------------------------------------------------------------------------

  IsValidDiskette() -

--------------------------------------------------------------------------*/

#define CBSECTORSIZE   512
#define INT13_READ   2

BOOL IsValidDiskette(int iDrive)
{
   TCHAR       buf[CBSECTORSIZE];

   iDrive |= 0x0020;   // make lower case

   iDrive -= 'a';   // A = 0, B = 1, etc. for BIOS stuff

   return MyReadWriteSector(buf, INT13_READ, iDrive, 0, 0, 1);
}



/*  BOOL IsDiskInDrive(char cDisk)
 *
 *  Is the specifed disk in the drive
 *
 *  ENTRY:
 *
 *  cDisk        : what disk required to be in the drive (logical)
 *
 *  return TRUE if the specifed disk is in the drive
 *         FALSE if the wrong disk is in the drive or disk error
 *
 */
BOOL IsDiskInDrive(int iDisk)
{

   if ((iDisk  >= 'A' && iDisk <= 'Z') ||
      (iDisk  >= 'a' && iDisk <= 'z'))
      {
      if (DosRemoveable(iDisk))
         {
         if (!IsValidDiskette(iDisk))
            return FALSE;
         }
      return TRUE;
      }
   return TRUE;   // for non drive letters assume a path
                  // and thus always in.
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\cdaudio.c ===
/*
 ***************************************************************
 *  sprop.c
 *
 *  Copyright (C) Microsoft, 1990, All Rights Reserved.
 *
 *  Displays the Simple media properties
 *
 *  History:
 *
 *  July 1994 -by- VijR (Created)
 *        
 ***************************************************************
 */

#include "mmcpl.h"
#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <mmddk.h>
#include <mmreg.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "utils.h"
#include "medhelp.h"
#include "mmcpl.h"

#include <winerror.h>

//for digital cd audio
#include "devguid.h"
#include "setupapi.h"
#include "cfgmgr32.h"
#include "winioctl.h"
#include "tchar.h"

const TCHAR gszCreateCDFile[] = TEXT("\\\\.\\%c:");

#define MYREGSTR_PATH_MEDIA  TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources") 
const TCHAR gszRegstrCDAPath[] = MYREGSTR_PATH_MEDIA TEXT("\\mci\\cdaudio");
const TCHAR gszUnitEnum[] = TEXT("%s\\unit %d");
const TCHAR gszSettingsKey[] = TEXT("Volume Settings");
const TCHAR gszDefaultCDA[] = TEXT("Default Drive");

const TCHAR gszRegstrCDROMPath[] = TEXT("System\\CurrentControlSet\\Services\\Class\\CDROM\\");
const TCHAR gszDigitalPlay[] = TEXT("DigitalAudioPlay");

const TCHAR gszRegstrDrivePath[] = TEXT("Enum\\SCSI");

#define CDA_VT_UNSET 0
#define CDA_VT_AUX  1
#define CDA_VT_MIX  2


#define CDROM_DIGITAL_PLAY_ENABLED      0x01
#define CDROM_DIGITAL_PLAY_CAPABLE      0x02
#define CDROM_DIGITAL_DEVICE_KNOWN      0x04


typedef struct {                // This struct is used in other places DO NOT CHANGE
    DWORD   unit;
    DWORD   dwVol;
} CDAREG, *PCDAREG;

typedef struct {                // This is now the local version with addition data, this can change, but has to keep the
    CDAREG              cdar;
    BOOLEAN             fDigFlags;
    BOOLEAN             DigitalEnabled;
    BOOLEAN             DigitalKnownDevice;
    BOOLEAN             oldDigEnabled;
    DWORD               dwOldVol;
    TCHAR               chDrive;
    HDEVINFO            hDevInfo;
    PSP_DEVINFO_DATA    pDevInfoData;
} CDSTATE, *PCDSTATE;


BOOL g_fWDMEnabled = FALSE;
HMODULE g_hModStorProp = NULL;

typedef LONG (WINAPI *CDROMISDIGITALPLAYBACKENABLEDPROC)(HDEVINFO,PSP_DEVINFO_DATA,BOOLEAN*);
typedef BOOL (WINAPI *CDROMKNOWNGOODDIGITALPLAYBACKPROC)(HDEVINFO,PSP_DEVINFO_DATA);
typedef LONG (WINAPI *CDROMENABLEDIGITALPLAYBACKPROC)(HDEVINFO,PSP_DEVINFO_DATA,BOOLEAN);
typedef LONG (WINAPI *CDROMDISABLEDIGITALPLAYBACKPROC)(HDEVINFO,PSP_DEVINFO_DATA);

CDROMISDIGITALPLAYBACKENABLEDPROC   _gCdromIsDigitalPlaybackEnabled = NULL;
CDROMKNOWNGOODDIGITALPLAYBACKPROC   _gCdromKnownGoodDigitalPlayback = NULL;
CDROMENABLEDIGITALPLAYBACKPROC      _gCdromEnableDigitalPlayback = NULL;
CDROMDISABLEDIGITALPLAYBACKPROC     _gCdromDisableDigitalPlayback = NULL;

void GetPrefInfo(PAUDIODLGINFO pai, HWND hDlg );

HANDLE GetHandleForDevice(LPCTSTR DeviceName)
{
    int i = 0;
    TCHAR fakeDeviceName[MAX_PATH];
    HANDLE h = INVALID_HANDLE_VALUE;
    BOOL success = FALSE;
    TCHAR buf[MAX_PATH];
    
    while (!success && i < 10)
    {
        wsprintf(buf, TEXT("DISK_FAKE_DEVICE_%d_"), i++);
        success = DefineDosDevice(DDD_RAW_TARGET_PATH,
                                  buf, 
                                  DeviceName);
        if (success)
        {
            _tcscpy(fakeDeviceName, TEXT("\\\\.\\"));
            _tcscat(fakeDeviceName, buf);
            h = CreateFile(fakeDeviceName,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
            DefineDosDevice(DDD_REMOVE_DEFINITION,
                            buf,
                            NULL);
        }
    } //end while

    return h;
}

HANDLE GetHandleForDeviceInst(DEVINST DevInst)
{
    TCHAR DeviceName[MAX_PATH];
    CONFIGRET cr;
    DWORD len = MAX_PATH;

    cr = CM_Get_DevNode_Registry_Property(DevInst,
                                          CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                          NULL,
                                          DeviceName,
                                          &len,
                                          0);

    if (cr != CR_SUCCESS)
    {
        return 0;
    }
       
    return GetHandleForDevice(DeviceName);
} 

BOOL EnableCdromFunctions(HMODULE* pMod)
{
    BOOL fRet = FALSE;
    
    if (!*pMod)
    {
        *pMod = LoadLibrary(TEXT("STORPROP.DLL"));
    }

    if (*pMod)
    {
        _gCdromIsDigitalPlaybackEnabled = (CDROMISDIGITALPLAYBACKENABLEDPROC)GetProcAddress(*pMod,"CdromIsDigitalPlaybackEnabled");
        _gCdromKnownGoodDigitalPlayback = (CDROMKNOWNGOODDIGITALPLAYBACKPROC)GetProcAddress(*pMod,"CdromKnownGoodDigitalPlayback");
        _gCdromEnableDigitalPlayback = (CDROMENABLEDIGITALPLAYBACKPROC)GetProcAddress(*pMod,"CdromEnableDigitalPlayback");
        _gCdromDisableDigitalPlayback = (CDROMDISABLEDIGITALPLAYBACKPROC)GetProcAddress(*pMod,"CdromDisableDigitalPlayback");

        if (
            (_gCdromIsDigitalPlaybackEnabled)
            &&
            (_gCdromKnownGoodDigitalPlayback)
            &&
            (_gCdromEnableDigitalPlayback)
            &&
            (_gCdromDisableDigitalPlayback)
        )
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

BYTE CDAudio_GetSetDigitalFlags(PCDSTATE pcds, BYTE fSetFlags, BOOL fSet)
{
    BYTE bFlags = 0;
    BOOLEAN bEnabled = FALSE;

    if (EnableCdromFunctions(&g_hModStorProp))
    {
        bFlags = 0;

        if (fSet)
        {
            BOOLEAN bEnable = fSetFlags & CDROM_DIGITAL_PLAY_ENABLED;
            BOOLEAN bAlready = FALSE;
            _gCdromIsDigitalPlaybackEnabled(pcds->hDevInfo,pcds->pDevInfoData,&bAlready);

            if (bEnable != bAlready)
            {
                if (bEnable)
                {
                    _gCdromEnableDigitalPlayback(pcds->hDevInfo,pcds->pDevInfoData,FALSE);
                }
                else
                {
                    _gCdromDisableDigitalPlayback(pcds->hDevInfo,pcds->pDevInfoData);
                }
            }
        }

        //always do a get after a set
        _gCdromIsDigitalPlaybackEnabled(pcds->hDevInfo,pcds->pDevInfoData,&bEnabled);

        if (bEnabled)
        {
            bFlags |= CDROM_DIGITAL_PLAY_ENABLED;
        }

        if (_gCdromKnownGoodDigitalPlayback(pcds->hDevInfo,pcds->pDevInfoData))
        {
            bFlags |= CDROM_DIGITAL_DEVICE_KNOWN;
        }
    }

    return bFlags;
}

BYTE CDAudio_SetDigitalFlags(PCDSTATE pcds, BYTE fDigFlags)
{
    return CDAudio_GetSetDigitalFlags(pcds,fDigFlags,TRUE);
}

BYTE CDAudio_GetDigitalFlags(PCDSTATE pcds)
{
    return CDAudio_GetSetDigitalFlags(pcds,0,FALSE);
}


/*
 * */
void CDAudio_GetRegData(PCDSTATE pcds,ULONG uDrive)
{
    TCHAR    szRegstrCDAudio[_MAX_PATH];
    HKEY    hkTmp;
    
    if (!pcds)
    	return;
    
    wsprintf(szRegstrCDAudio, gszUnitEnum, gszRegstrCDAPath, uDrive);

    pcds->cdar.dwVol = 0xFF;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE
			     , szRegstrCDAudio
			     , 0
			     , KEY_READ
			     , &hkTmp ) == ERROR_SUCCESS)
    {
	    DWORD cbCDA = sizeof(CDAREG);
	    RegQueryValueEx(hkTmp
			    , gszSettingsKey
			    , NULL
			    , NULL
			    , (LPBYTE)&pcds->cdar
			    , &cbCDA);
	    RegCloseKey(hkTmp);
    }
    
    pcds->cdar.unit = uDrive;

    pcds->fDigFlags = CDAudio_GetDigitalFlags(pcds);

    pcds->DigitalEnabled = pcds->fDigFlags & CDROM_DIGITAL_PLAY_ENABLED;
    pcds->DigitalKnownDevice = pcds->fDigFlags & CDROM_DIGITAL_DEVICE_KNOWN;

    pcds->oldDigEnabled = pcds->DigitalEnabled;
    pcds->dwOldVol = pcds->cdar.dwVol;
}

/*
 * */
void CDAudio_SetRegData(
    PCDSTATE pcds, HWND hwnd)
{
    TCHAR        szRegstrCDAudio[_MAX_PATH];
    HKEY        hkTmp;
    BYTE        bFlags = 0;

    wsprintf(szRegstrCDAudio, gszUnitEnum, gszRegstrCDAPath, pcds->cdar.unit);
    
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE
		       , szRegstrCDAudio
		       , 0
		       , NULL
		       , 0
		       , KEY_WRITE
		       , NULL
		       , &hkTmp
		       , NULL ) == ERROR_SUCCESS)
    {
	RegSetValueEx(hkTmp
		      , gszSettingsKey
		      , 0L
		      , REG_BINARY
		      , (LPBYTE)&pcds->cdar
		      , sizeof(CDAREG));
	RegCloseKey(hkTmp);
    }

    if (pcds->DigitalEnabled)
    {
	    pcds->fDigFlags |= CDROM_DIGITAL_PLAY_ENABLED;
    }
    else
    {
	    pcds->fDigFlags &= ~CDROM_DIGITAL_PLAY_ENABLED;
    }

    bFlags = CDAudio_SetDigitalFlags(pcds,pcds->fDigFlags);

    //check for success
    if ((bFlags & CDROM_DIGITAL_PLAY_ENABLED) != (pcds->DigitalEnabled))
    {
        pcds->DigitalEnabled = bFlags & CDROM_DIGITAL_PLAY_ENABLED;
        Button_SetCheck(GetDlgItem(hwnd, IDC_CDEN_DIGAUDIO), pcds->DigitalEnabled);
    }
}

void ChangeCDVolume(PCDSTATE pcds)
{
    MCI_OPEN_PARMS  mciOpen;
    TCHAR           szElementName[4];
    TCHAR           szAliasName[32];
    DWORD           dwFlags;
    DWORD           dwAliasCount = GetCurrentTime();
    DWORD           dwRet;
    CDAREG          cdarCache;
    HKEY            hkTmp;
    TCHAR            szRegstrCDAudio[_MAX_PATH];
    
    ASSERT(pcds);

    if (pcds != NULL)
    { 
        wsprintf(szRegstrCDAudio, gszUnitEnum, gszRegstrCDAPath, pcds->cdar.unit);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE , szRegstrCDAudio , 0 , KEY_READ , &hkTmp ) == ERROR_SUCCESS)
        {
            DWORD cbCDA = sizeof(CDAREG);
            RegQueryValueEx(hkTmp , gszSettingsKey , NULL , NULL , (LPBYTE)&cdarCache , &cbCDA);
            RegCloseKey(hkTmp);
        }
        else
        {
            cdarCache = pcds->cdar;
        }

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegstrCDAudio, 0, NULL, 0, KEY_WRITE, NULL, &hkTmp, NULL ) == ERROR_SUCCESS)
        {
            CDAREG cdar;
        
            cdar = pcds->cdar;      
            RegSetValueEx(hkTmp , gszSettingsKey , 0L , REG_BINARY , (LPBYTE)&cdar , sizeof(CDAREG));
            RegCloseKey(hkTmp);
        }

        ZeroMemory( &mciOpen, sizeof(mciOpen) );

        mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
        wsprintf( szElementName, TEXT("%c:"), pcds->chDrive );
        wsprintf( szAliasName, TEXT("SJE%lu:"), dwAliasCount );

        mciOpen.lpstrElementName = szElementName;
        mciOpen.lpstrAlias = szAliasName;

        dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_ALIAS | MCI_OPEN_SHAREABLE | 
                  MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;

        dwRet = mciSendCommand(0, MCI_OPEN, dwFlags, (DWORD_PTR)(LPVOID)&mciOpen);

        if ( dwRet == MMSYSERR_NOERROR )
        {     
            mciSendCommand(mciOpen.wDeviceID, MCI_CLOSE, 0L, 0L );
        }

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE , szRegstrCDAudio , 0 , KEY_WRITE , &hkTmp ) == ERROR_SUCCESS)
        {
            RegSetValueEx(hkTmp , gszSettingsKey , 0L , REG_BINARY , (LPBYTE)&cdarCache , sizeof(CDAREG));
            RegCloseKey(hkTmp);
        }
    }
}

/*
 * */
void CDAudio_SaveState(
    HWND        hwnd)
{
    PCDSTATE pcds;
    pcds = (PCDSTATE)GetWindowLongPtr(hwnd,DWLP_USER);

    if (pcds)
    { 
        CDAudio_SetRegData(pcds,hwnd);
        pcds->oldDigEnabled = pcds->DigitalEnabled;
        pcds->dwOldVol = pcds->cdar.dwVol;

        ChangeCDVolume(pcds);
    }
}

void CDAudio_DigitalPlaybackEnable(HWND hDlg)
{
    PCDSTATE pcds;
    pcds = (PCDSTATE)GetWindowLongPtr(hDlg,DWLP_USER);   

    if (pcds)
    {
        pcds->DigitalEnabled = (BOOLEAN)Button_GetCheck(GetDlgItem(hDlg, IDC_CDEN_DIGAUDIO));
    }
}

ULONG MatchDriveToDevInst(DWORD DevInst)
{
    HANDLE hMatch = INVALID_HANDLE_VALUE;
    STORAGE_DEVICE_NUMBER sDevice, sMatch;
    DWORD bytesReturned;
    ULONG uRet = 0;

    if (INVALID_HANDLE_VALUE != (hMatch = 
                                 GetHandleForDeviceInst(DevInst)))
    {
        if (DeviceIoControl(hMatch,
                             IOCTL_STORAGE_GET_DEVICE_NUMBER,
                             NULL,
                             0,
                             &sMatch,
                             sizeof(STORAGE_DEVICE_NUMBER),
                             &bytesReturned,
                             NULL))
        {
            uRet = sMatch.DeviceNumber;
        }

        CloseHandle(hMatch);
    }

    return uRet;
}

/*
 * */
DWORD CDAudio_InitDrives(HWND hwnd, PCDSTATE pcds)
{
    DWORD cch;
    DWORD cCDs = 0;
    ULONG uDrive = 0;

    uDrive = MatchDriveToDevInst(pcds->pDevInfoData->DevInst);
    CDAudio_GetRegData(pcds,uDrive);

    if (cch = GetLogicalDriveStrings(0, NULL))
    {
	LPTSTR   lpDrives,lp;
	lp = lpDrives = GlobalAllocPtr(GHND, cch * sizeof(TCHAR));
	cch = GetLogicalDriveStrings(cch, lpDrives);
	if (lpDrives && cch)
	{
	    // upon the last drive enumerated, there will be a double
	    // null termination
	    while (*lpDrives)
	    {
		    if (GetDriveType(lpDrives) == DRIVE_CDROM)
		    {
			    int   i;
			    LPTSTR lp;
			    lp = CharUpper(lpDrives);
			    
			    while (*lp != TEXT('\\'))
			        lp = CharNext(lp);
			    
			    while (*lp)
			    {
			        *lp = TEXT(' ');
			        lp = CharNext(lp);
			    }
			        
			    if (cCDs == uDrive)
			    {
                   pcds->chDrive = lpDrives[0];
			    }

		        cCDs++;
		    }
		    for ( ; *lpDrives ; lpDrives++ );
		    lpDrives++;
	    }
	}
	
	if (lp)
	    GlobalFreePtr(lp);

    }
    return cCDs;
}

//
//  Determines what device is currently being used by the mapper to play audio
//
MMRESULT GetWaveID(UINT *puWaveID)

{
    PAUDIODLGINFO pInfo = (PAUDIODLGINFO)LocalAlloc(LPTR, sizeof(AUDIODLGINFO));;

	if (!pInfo) return MMSYSERR_NOMEM;

	GetPrefInfo(pInfo, NULL);
	if(-1 == pInfo->uPrefOut)
	{
		LocalFree((HLOCAL)pInfo);
		return MMSYSERR_BADDEVICEID;
	}

	*puWaveID = pInfo->uPrefOut;
	LocalFree((HLOCAL)pInfo);

	return MMSYSERR_NOERROR;
}


//
// Checks to see if the current output audio device is a WDM Device or not
//
BOOL WDMAudioEnabled(void)
{
    BOOL fResult = FALSE;

    UINT uWaveID;

    if (GetWaveID(&uWaveID) == MMSYSERR_NOERROR)
    {
        WAVEOUTCAPS woc;

        if (waveOutGetDevCaps(uWaveID, &woc, sizeof(WAVEOUTCAPS)) == MMSYSERR_NOERROR)
        {
            if ((woc.wMid == MM_MICROSOFT) && (woc.wPid == MM_MSFT_WDMAUDIO_WAVEOUT))
            {
                fResult = TRUE;
            }
        }
    }

    return(fResult);
}



BOOL CDAudio_OnInitDialog(
    HWND        hwnd,
    HWND        hwndFocus,
    LPARAM      lParam)
{
    HWND     hwndTB1 = GetDlgItem(hwnd, IDC_CD_TB_VOLUME);
    HWND     hwndCK3 = GetDlgItem(hwnd, IDC_CDEN_DIGAUDIO);
    HWND     hwndTX1 = GetDlgItem(hwnd, IDC_TEXT_24);
    UINT     uDrive;
    int      i;
    PCDSTATE pcds = NULL;
    PALLDEVINFO pDevInfo = NULL;

    pcds = (PCDSTATE)GlobalAllocPtr(GHND, sizeof(CDSTATE));

	if (!pcds) return FALSE;

    SetWindowLongPtr(hwnd,DWLP_USER,(LONG_PTR)pcds);

    pDevInfo = (ALLDEVINFO *) ((LPPROPSHEETPAGE) lParam)->lParam;

    if (pDevInfo)
    {
        pcds->hDevInfo = pDevInfo->hDevInfo;
        pcds->pDevInfoData = pDevInfo->pDevInfoData;
        GlobalFreePtr(pDevInfo);
        ((LPPROPSHEETPAGE) lParam)->lParam = (LPARAM) NULL;
    }

    SendMessage(hwndTB1, TBM_SETTICFREQ, 10, 0);
    SendMessage(hwndTB1, TBM_SETRANGE, FALSE, MAKELONG(0,100));

    i = CDAudio_InitDrives(hwnd,pcds);
    
    if (i)
    {
        if (pcds)
        {
            SendMessage(hwndTB1, TBM_SETPOS, TRUE, (pcds->cdar.dwVol * 100L)/255L );
            Button_SetCheck(hwndCK3, pcds->DigitalEnabled);
        }

        g_fWDMEnabled = WDMAudioEnabled();

//        if (!g_fWDMEnabled)             // Per bug 20964, never disable "Enable Digital CD" checkbox
//        {
//            EnableWindow(hwndCK3, FALSE);
//            EnableWindow(hwndTX1, FALSE);
//        }
    }
//    else
//    {
//        EnableWindow(hwndCK3, FALSE);
//        EnableWindow(hwndTB1, FALSE);
//        EnableWindow(hwndTX1, FALSE);
//    }

    return FALSE;
}

void CDToggleApply(HWND hDlg)
{
    PCDSTATE    pcds;
    BOOL        fChanged = FALSE;

    pcds = (PCDSTATE)GetWindowLongPtr(hDlg,DWLP_USER); 

    if (pcds)
    {
        if (pcds->DigitalEnabled != pcds->oldDigEnabled)
        {
            fChanged = TRUE;
        }

        if (pcds->dwOldVol != pcds->cdar.dwVol)
        {
            fChanged = TRUE;
        }
    }

    if (fChanged)
    {
        PropSheet_Changed(GetParent(hDlg),hDlg);
    }
    else
    {
        PropSheet_UnChanged(GetParent(hDlg),hDlg);
    }
}

void CDAudio_OnDestroy(
    HWND        hwnd)
{
    PCDSTATE lp = (PCDSTATE)GetWindowLongPtr(hwnd,DWLP_USER);
    if (lp)
        GlobalFreePtr(lp);

    if (g_hModStorProp)
    {
        FreeLibrary(g_hModStorProp);
        g_hModStorProp = NULL;
    }
}

void CDAudio_OnHScroll(
    HWND        hwnd,
    HWND        hwndCtl,
    UINT        code,
    int         pos)
{
    if (code == TB_ENDTRACK || code == SB_THUMBTRACK) 
    {
        HWND        hwndTB1 = GetDlgItem(hwnd, IDC_CD_TB_VOLUME);
        int         i; 
        PCDSTATE    pcds;
        DWORD       dwVol;

        pcds = (PCDSTATE)GetWindowLongPtr(hwnd,DWLP_USER);

        if (CB_ERR != (UINT_PTR) pcds && pcds)
        {
            dwVol = (((DWORD)SendMessage(hwndTB1, TBM_GETPOS, 0, 0)) * 255L) / 100L;

            if (dwVol != pcds->cdar.dwVol)
            {
                pcds->cdar.dwVol = dwVol;
                ChangeCDVolume(pcds);   
                CDToggleApply(hwnd);
            }
        }
    }
}
    
void CDAudio_OnCancel(
    HWND        hwnd)
{
    PCDSTATE    pcds;

    pcds = (PCDSTATE)GetWindowLongPtr(hwnd,DWLP_USER);
    pcds->cdar.dwVol = pcds->dwOldVol;
    ChangeCDVolume(pcds);
}

BOOL PASCAL CDAudio_OnCommand(
    HWND        hDlg,
    int         id,
    HWND        hwndCtl,
    UINT        codeNotify)
{
    BOOL fResult = FALSE;

    switch (id)
    {
	case ID_APPLY:
	{
	    CDAudio_SaveState(hDlg);
	    fResult = TRUE;
	}
	break;

	case IDCANCEL:
	{
	    CDAudio_OnCancel(hDlg);
	    fResult = TRUE;
	}
	break;

	case IDC_CDEN_DIGAUDIO:
	{
	    CDAudio_DigitalPlaybackEnable(hDlg);
	    CDToggleApply(hDlg);
	}
	break;
    }

    return fResult;
}


const static DWORD aCDHelpIds[] = {  // Context Help IDs

    IDI_CDAUDIO,         IDH_COMM_GROUPBOX,
    IDC_ICON_5,          IDH_COMM_GROUPBOX,
    IDC_TEXT_25,         IDH_COMM_GROUPBOX,
    IDC_GROUPBOX,        IDH_COMM_GROUPBOX,
    IDC_GROUPBOX_2,      IDH_COMM_GROUPBOX,
    IDC_TEXT_29,         IDH_CD_VOL_HEADPHONE,
    IDC_CD_TB_VOLUME,    IDH_CD_VOL_HEADPHONE,
    IDC_TEXT_30,         IDH_CD_VOL_HEADPHONE,
    IDC_TEXT_24,         IDH_CDROM_PROPERTIES_DIGITAL,
    IDC_CDEN_DIGAUDIO,   IDH_CDROM_PROPERTIES_DIGITAL,

    0, 0
};

BOOL CALLBACK CDDlg(
    HWND        hDlg,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    NMHDR FAR   *lpnm;

    switch (uMsg)
    {
	case WM_NOTIFY:
	    lpnm = (NMHDR FAR *)lParam;
	    switch(lpnm->code)
	    {
		case PSN_KILLACTIVE:
		    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);  
		    break;              

		case PSN_APPLY:
		    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);      
		    break;                                                      

		case PSN_SETACTIVE:
		    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
		    break;

		case PSN_RESET:
		    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
		    break;
	    }
	    break;

	case WM_INITDIALOG:
	    HANDLE_WM_INITDIALOG(hDlg, wParam, lParam, CDAudio_OnInitDialog);
	    break;

	case WM_DESTROY:
	    HANDLE_WM_DESTROY(hDlg, wParam, lParam, CDAudio_OnDestroy);
	    break;

	case WM_DROPFILES:
	    break;

	case WM_CONTEXTMENU:        
	    WinHelp((HWND)wParam, gszWindowsHlp, HELP_CONTEXTMENU, 
		  (UINT_PTR)(LPTSTR)aCDHelpIds);
	    break;

	case WM_HELP:        
	    WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszWindowsHlp,
		  HELP_WM_HELP, (UINT_PTR)(LPTSTR)aCDHelpIds);
	    break;

	case WM_COMMAND:
	    HANDLE_WM_COMMAND(hDlg, wParam, lParam, CDAudio_OnCommand);
	    break;

	case WM_HSCROLL:
	    HANDLE_WM_HSCROLL(hDlg, wParam, lParam, CDAudio_OnHScroll);
	    break;

#if 0        
	default:
	    if (uMsg == wHelpMessage) 
	    {
		WinHelp(hDlg, gszWindowsHlp, HELP_CONTEXT, ID_SND_HELP);
		return TRUE;
	    }
	    break;
#endif
	    
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\class.c ===
/*==========================================================================*/
//
//  class.c
//
//  Copyright (C) 1993-1994 Microsoft Corporation.  All Rights Reserved.
//  Mod Log:   Modified by Shawn Brown (10/95)
//                - Ported to NT (Unicode, etc.)
/*==========================================================================*/

#include "mmcpl.h"
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <cpl.h> 
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <string.h>
#include <memory.h>
#include <idf.h>
#include <regstr.h>
#include "utils.h"

#include "midi.h"
#include "mmdebug.h"
#if defined DEBUG || defined DEBUG_RETAIL
 extern TCHAR szNestLevel[];
#endif

#include "medhelp.h"

#ifndef TVIS_ALL
#define TVIS_ALL 0xFF7F
#endif


static CONST TCHAR cszIdfWildcard[]    = TEXT ("*.idf");
static CONST TCHAR cszIdf[]            = TEXT (".idf");
static CONST TCHAR cszSetupKey[]       = REGSTR_PATH_SETUP REGSTR_KEY_SETUP;
static CONST TCHAR cszMachineDir[]     = REGSTR_VAL_WINDIR;
static CONST TCHAR cszConfigDir[]      = TEXT ("config\\");

extern CONST TCHAR cszMidiSlash[];
extern CONST TCHAR cszFriendlyName[];
extern CONST TCHAR cszDescription[];
extern CONST TCHAR cszSlashInstruments[];
extern CONST TCHAR cszExternal[];
extern CONST TCHAR cszDefinition[];
extern CONST TCHAR cszPort[];
extern CONST TCHAR cszDriversRoot[];
extern CONST TCHAR cszSchemeRoot[];
extern CONST TCHAR cszMidiMapRoot[];
extern CONST TCHAR cszDriversRoot[];
extern CONST TCHAR csz02d[];
extern CONST TCHAR cszSlash[];
extern CONST TCHAR cszEmpty[];

extern int lstrnicmp (LPTSTR pszA, LPTSTR pszB, size_t cch);


typedef struct _midi_class {
    LPPROPSHEETPAGE ppsp;
    HKEY            hkMidi;
    BOOL            bDetails;
    BOOL            bRemote;  // device connected via midi cable
    UINT            bChanges;
    UINT            ixDevice; // registry enum index of driver key
    BYTE            nPort;
    BYTE            bFill[3];
    BOOL            bFillingList;
  #ifdef USE_IDF_ICONS
    HIMAGELIST      hIDFImageList;
  #endif
    LPTSTR          pszKey;
    TCHAR           szFullKey[MAX_PATH];
    TCHAR           szAlias[MAX_PATH];
    TCHAR           szFile[MAX_PATH*2];
    } MCLASS, FAR * PMCLASS;

#define MCL_ALIAS_CHANGED 1
#define MCL_TREE_CHANGED  2
#define MCL_IDF_CHANGED   4
#define MCL_PORT_CHANGED  8


/*+
 * Determines if a given string has a given prefix and if
 * the next character in the string is a given charater.
 *
 * if so, it returns a pointer to the first character in the
 * string after the prefix.
 *
 * this is useful for parsing off the file in  file<Instrument>
 * or parts of registry paths.
 *
 * note that we do NOT consider a string to be a prefix of itself.
 * psz MUST be longer than than pszPrefix or this function returns NULL.
 *
 *-=================================================================*/

STATICFN LPTSTR WINAPI IsPrefix (
    LPTSTR pszPrefix,
    LPTSTR psz,
    TCHAR  chTerm)
{
    UINT  cb  = lstrlen(pszPrefix);
    UINT  cb2 = lstrlen(psz);
    TCHAR ch;

    if (cb2 < cb)
        return NULL;

    ch = psz[cb];
    if (ch != chTerm)
        return NULL;

    psz[cb] = 0;
    if (lstrcmpi(pszPrefix, psz))
    {
        psz[cb] = ch;
        return NULL;
    }

    psz[cb] = ch;
    return psz + cb;
}


/*+ IsFullPath
 *
 * returns true if the filename passed in is a fully qualified
 * pathname. returns false if it is a relative path
 *
 * unc paths are treated as fully qualified always
 *
 *-=================================================================*/

BOOL IsFullPath (
    LPTSTR pszFile)
{
    // fully qualified paths either begin with a backslash
    // or with a drive letter, colon, then backslash
    //
    if ((pszFile[0] == TEXT('\\')) ||
        (pszFile[1] == TEXT(':') && pszFile[2] == TEXT('\\')))
        return TRUE;

    return FALSE;
}


/*+ GetIDFDirectory
 *
 *-=================================================================*/

BOOL GetIDFDirectory (
    LPTSTR pszDir,
    UINT   cchDir)
{
    HKEY  hKey;
    UINT  cbSize;

    *pszDir = 0;

#if(_WIN32_WINNT >= 0x0400)
    if (!GetSystemDirectory (pszDir, cchDir))
        return FALSE;
#else
    if (!RegOpenKey (HKEY_LOCAL_MACHINE, cszSetupKey, &hKey))
    {
        cbSize = cchDir * sizeof(TCHAR);
        RegQueryValueEx (hKey, 
                         cszMachineDir, 
                         NULL, 
                         NULL, 
                         (LPBYTE)pszDir, 
                         &cbSize);
        RegCloseKey (hKey);

        cchDir = cbSize/sizeof(TCHAR);

        if (!cchDir--)
            return FALSE;
    }
    else if (!GetWindowsDirectory (pszDir, cchDir))
        return FALSE;
#endif

    cchDir = lstrlen (pszDir);
    if (pszDir[cchDir -1] != TEXT('\\'))
        pszDir[cchDir++] = TEXT('\\');
    lstrcpy (pszDir + cchDir, cszConfigDir);

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT("IDFDir='%s'\r\n"), pszDir);
#endif
    return TRUE;
}


/*+ GetIDFFileName
 *
 *-=================================================================*/

BOOL GetIDFFileName (
    HWND    hWnd,
    LPTSTR  lpszFile,
    UINT    cchFile)
    {
    OPENFILENAME ofn;
    TCHAR        szFilter[MAX_PATH];
    UINT         cch;

    assert (hWnd);

    // load filter string from resource and convert '#' characters
    // into NULLs
    //
    LoadString (ghInstance, IDS_IDFFILES, szFilter, NUMELMS(szFilter));
    cch = lstrlen(szFilter);
    assert2 (cch, TEXT ("IDFFILES resource is empty!"));
    while (cch--)
    {
        if (TEXT('#') == szFilter[cch])
            szFilter[cch] = 0;
    }

    ZeroMemory (&ofn, sizeof(ofn));
    ofn.lStructSize  = sizeof(ofn);
    ofn.hwndOwner    = hWnd;
    ofn.hInstance    = ghInstance;
    ofn.lpstrFilter  = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile    = lpszFile;
    ofn.nMaxFile     = cchFile;
    ofn.Flags        = OFN_HIDEREADONLY | OFN_NOCHANGEDIR;
    ofn.lpstrDefExt  = cszIdf;

    return GetOpenFileName (&ofn);
    }


/*+ InstallNewIDF
 *
 *-=================================================================*/

BOOL WINAPI InstallNewIDF (
    HWND hWnd)
{
    TCHAR szWinPath[MAX_PATH];
    TCHAR szNewIDF[MAX_PATH];
    UINT  cch;
    UINT  oBasename;

    // prompt for an IDF file
    //
    szNewIDF[0] = 0;
    if ( ! GetIDFFileName (hWnd, szNewIDF, NUMELMS(szNewIDF)))
        return FALSE;

    // set oBasename to pointer to the first character of the
    // basename of the new idf file
    //
    oBasename = lstrlen (szNewIDF);
    if (!oBasename)
        return FALSE;
    while (oBasename && (TEXT('\\') != szNewIDF[oBasename-1]))
        --oBasename;

    // build the new filename from windows directory and idf basename
    //
    GetIDFDirectory (szWinPath, NUMELMS(szWinPath));
    cch = lstrlen (szWinPath);
    if (cch && szWinPath[cch-1] != TEXT('\\'))
        szWinPath[cch++] = TEXT('\\');
    lstrcpyn (szWinPath + cch, szNewIDF + oBasename, NUMELMS(szWinPath)-cch);
    oBasename = cch;

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT("install IDF to '%s'\r\n"), szWinPath);
#endif
    // now force .idf as the extension for new file
    //
    for (cch = lstrlen (szWinPath); cch && szWinPath[cch] != TEXT('.'); --cch)
        if (TEXT('\\') == szWinPath[cch])
        {
            cch = lstrlen(szWinPath);
            break;
        }
    lstrcpy (szWinPath + cch, cszIdf);

    // quit now if we are trying to copy a file to itself
    //
    if (IsSzEqual(szWinPath, szNewIDF))
        return FALSE;

    // copy the file, but fail if destination already exists
    //
#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT("Copying %s to %s\r\n"), szNewIDF, szWinPath);
#endif
    if (CopyFile (szNewIDF, szWinPath, TRUE))
        return TRUE;
    //
    // if copy fails, query to overwrite because destination
    // already exists.
    //
    else
    {
        TCHAR szQuery[255];
        TCHAR sz[255];

#ifdef DEBUG
        AuxDebugEx (1, DEBUGLINE TEXT ("InstallIDF -CopyFile failed w/ %d\r\n"),
                    GetLastError());
#endif

        LoadString (ghInstance, IDS_QUERY_OVERIDF, sz, NUMELMS(sz));
        wsprintf (szQuery, sz, szWinPath + oBasename);

        LoadString (ghInstance, IDS_IDF_CAPTION, sz, NUMELMS(sz));

        if (MessageBox (hWnd, szQuery, sz, MB_YESNO | MB_ICONQUESTION) == IDYES)
            return CopyFile (szNewIDF, szWinPath, FALSE);
    }
    return FALSE;
}

/*+
 *
 * FEATURE: Please remove the #ifdef UNICODE sections 
 *          when mmioOpen gets UNICODE enabled !!!
 *-=================================================================*/

typedef BOOL (WINAPI * FNIDFENUM)(LPVOID        pvArg,
                                  UINT          nEnum,
                                  LPIDFHEADER   pHdr,
                                  LPIDFINSTINFO pInst);

UINT WINAPI idfEnumInstruments (
    LPTSTR     lpszFile,
    FNIDFENUM  fnEnum,
    LPVOID     lpvArg)
{
    MMCKINFO    chkIDFX;         // Grandparent chunk
    MMCKINFO    chkMMAP;         // Parent chunk
    HMMIO       hmmio;           // Handle to the file.
    UINT        nInstruments;

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT("idfEnumInstruments('%s',%08X,%08X)\r\n"),
                lpszFile, fnEnum, lpvArg);
#endif

    // Open the file for reading.
    hmmio = mmioOpen(lpszFile, NULL, MMIO_READ);
    if ( ! hmmio)
    {
// What were they thinking??  You can't assert this.
//      assert3(0, TEXT("Cant open IDF file %s"), lpszFile ? lpszFile : TEXT("<null>"));
        return 0;
    }

    // the whole IDF instrument stuff is wrapped in an 'IDF ' RIFF chunk
    //
    chkIDFX.fccType = MAKEFOURCC('I','D','F',' ');
    if (mmioDescend(hmmio, &chkIDFX, NULL, MMIO_FINDRIFF))
    {
#ifdef DEBUG
        AuxDebugEx (0, DEBUGLINE TEXT ("idfEnum: '%s' is not a valid IDF File\r\n"), lpszFile);
#endif
        mmioClose(hmmio, 0);
        return 0;
    }

    // Count the number of instruments by counting
    // the number of "MMAP"'s in the file.
    //
    nInstruments = 0;
    chkMMAP.fccType = MAKEFOURCC('M','M','A','P');
    while ( ! mmioDescend(hmmio, &chkMMAP, &chkIDFX, MMIO_FINDLIST))
    {
        union {
            IDFHEADER idf;
            TCHAR      sz[MAX_ALIAS + sizeof(IDFHEADER)];
            } hdr;
        union {
            IDFINSTINFO iii;
            BYTE        ab[MAX_ALIAS * 8 + sizeof(IDFINSTINFO)];
            } inst;
        MMCKINFO chk;
        DWORD    cb;

#ifdef DEBUG
        AuxDebugEx (15, DEBUGLINE TEXT ("MMAP[%d] id=%08X siz=%08x\r\n"),
                    nInstruments, chkMMAP.ckid, chkMMAP.cksize);
#endif

        // read the hdr chunk
        //
        chk.ckid = MAKEFOURCC('h','d','r',' ');
        if (mmioDescend(hmmio, &chk, &chkMMAP, MMIO_FINDCHUNK))
            break;

#ifdef DEBUG
        AuxDebugEx (15, DEBUGLINE TEXT("  hdr.id=%08X hdr.siz=%08x\r\n"),
                    chk.ckid, chk.cksize);
#endif
        assert (chk.cksize > 0 && chk.cksize < 0x0080000);

        //AuxDebugDump (6, &chk, sizeof(chk));

        cb = min(chk.cksize, sizeof(hdr));
        if ((DWORD)mmioRead (hmmio, (LPVOID)&hdr, cb) != cb)
           break;

        //AuxDebugDump (6, &chk, sizeof(chk));

        hdr.sz[NUMELMS(hdr.sz)-1] = 0;
        mmioAscend (hmmio, &chk, 0);
#ifdef DEBUG
        AuxDebugEx (15, DEBUGLINE TEXT("hdr = '%s'\r\n"), hdr.idf.abInstID);
#endif

        //AuxDebugDump (6, &chk, sizeof(chk));

        // read the inst chunk and locate the product name
        // field.
        //
        chk.ckid = MAKEFOURCC('i','n','s','t');
        if (mmioDescend(hmmio, &chk, &chkMMAP, MMIO_FINDCHUNK))
        {
#ifdef DEBUG
            AuxDebug (TEXT ("mmioDescend failed for 'inst' chunk"));
#endif
        }

#ifdef DEBUG
        AuxDebugEx (15, DEBUGLINE TEXT("  inst.id=%08X inst.siz=%08x\r\n"),
                    chk.ckid, chk.cksize);
#endif
        assert (chk.cksize > 0 && chk.cksize < 0x0080000);
        cb = min(chk.cksize, sizeof(inst));
        if ((DWORD)mmioRead (hmmio, (LPVOID)&inst, cb) != cb)
        {
#ifdef DEBUG
            AuxDebug ( TEXT ("mmioRead failed for 'inst' chunk"));
#endif
        }

        inst.ab[NUMELMS(inst.ab)-1] = 0;
        mmioAscend (hmmio, &chk, 0);
#ifdef DEBUG
        AuxDebugEx (15, DEBUGLINE TEXT ("inst.mfg = '%s'\r\n"), inst.iii.abData);
        AuxDebugEx (15, TEXT ("\t.prod = '%s'\r\n"), inst.iii.abData
                                                   + inst.iii.cbManufactASCII
                                                   + inst.iii.cbManufactUNICODE);
#endif
        // call the enum callback for this instrument
        //
        if ( ! fnEnum (lpvArg, nInstruments, &hdr.idf, &inst.iii))
            break;

        ++nInstruments;
        assert (nInstruments < 20);

        // ascend and loop back to look for the next instrument
        //
        if (mmioAscend(hmmio, &chkMMAP, 0))
            break;
    }

    mmioClose(hmmio, 0);
    return nInstruments;
}


/*+ LoadTypesIntoTree
 *
 *-=================================================================*/

struct types_enum_data {
    HANDLE            hWndT;
    TV_INSERTSTRUCT * pti;
    LPTSTR            pszInstr;
    HTREEITEM         htiSel;
    };

STATICFN BOOL WINAPI fnTypesEnum (
    LPVOID        lpv,
    UINT          nEnum,
    LPIDFHEADER   pHdr,
    LPIDFINSTINFO pInst)
{
    struct types_enum_data * pted = lpv;
    HTREEITEM hti;

    assert (pted);

#ifdef DEBUG
    AuxDebugEx (7, DEBUGLINE TEXT ("enum[%d] '%s' instr=%x\r\n"),
                nEnum, pHdr->abInstID, pted->pszInstr);
#endif

    MultiByteToWideChar(GetACP(), 0,
                        pHdr->abInstID, -1,
                        pted->pti->item.pszText, ARRAYSIZE(pted->pti->item.pszText));

    hti = TreeView_InsertItem (pted->hWndT, pted->pti);

    // this item is the 'selected' one, if it is the first
    // item or if it matches the name
    //
    if ((nEnum == 0) ||
        (pted->pszInstr && pted->pszInstr[0] &&
         IsPrefix(pted->pti->item.pszText, pted->pszInstr + sizeof(TCHAR), TEXT('>'))))
    {
        pted->htiSel = hti;
#ifdef DEBUG
        AuxDebugEx (7, DEBUGLINE TEXT("\t'%s' hti %08X is select\r\n"),
                    pted->pszInstr ? pted->pszInstr : TEXT (""), hti);
#endif
    }

    // return true to continue enumeration
    //
    return TRUE;
}

STATICFN void SetTypesEdit (
    HWND    hWnd,
    UINT    uId,
    PMCLASS pmcl)
{
    SetDlgItemText (hWnd, uId, pmcl->szFile);
}

STATICFN void LoadTypesIntoTree (
    HWND     hWnd,
    UINT     uId,
    PMCLASS  pmcl)
{
    HWND  hWndT;
    UINT  cchBase;
    TCHAR szPath[MAX_PATH];
    TCHAR szDefaultIDF[MAX_PATH];
    int   ix;
    WIN32_FIND_DATA ffd;
    HANDLE          hFind;
   #ifdef USE_IDF_ICONS
    HIMAGELIST      hImageList;
   #endif
    HTREEITEM       htiSelect = NULL; // item to select

    hWndT = GetDlgItem (hWnd, uId);
    if (!hWndT)
        return;

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("LoadTypesIntoTree( ,%x, )\r\n"), uId);
#endif

    LoadString (ghInstance, IDS_GENERAL, szDefaultIDF, NUMELMS(szDefaultIDF));

   #ifdef USE_IDF_ICONS

    // if we have not already loaded an image list for the IDF types
    // do so now.
    //
    if (!(hImageList = pmcl->hIDFImageList))
    {
        static LPCTSTR aid[] = {
            MAKEINTRESOURCE(IDI_IDFICON),
            MAKEINTRESOURCE(IDI_BLANK),
            };

        int cx = GetSystemMetrics(SM_CXSMICON);
        int cy = GetSystemMetrics(SM_CYSMICON);
        DWORD dwLayout;

        UINT uFlags = ILC_MASK | ILC_COLOR32;
    
        if (GetProcessDefaultLayout(&dwLayout) &&
            (dwLayout & LAYOUT_RTL)) 
        {
            uFlags |= ILC_MIRROR;
        }

        pmcl->hIDFImageList =
        hImageList = ImageList_Create (cx, cy, uFlags, NUMELMS(aid), 2);

        if (hImageList)
        {
            UINT  ii;

            for (ii = 0; ii < NUMELMS(aid); ++ii)
            {
                HICON hIcon = LoadImage (ghInstance, aid[ii], IMAGE_ICON,
                                         cx, cy, LR_DEFAULTCOLOR);
                if (hIcon)
                    ImageList_AddIcon (hImageList, hIcon);
            }
        }
    }

   #endif

    pmcl->bFillingList = TRUE;

    //SetWindowRedraw (hWndT, FALSE);
#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("tv_deleteAllItems(%08X)\r\n"), hWndT);
#endif
    TreeView_DeleteAllItems(hWndT);
#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("tv_deleteAllItems(%08X) ends\r\n"), hWndT);
#endif
   #ifdef USE_IDF_ICONS
    TreeView_SetImageList (hWndT, hImageList, TVSIL_NORMAL);
   #endif
    htiSelect = NULL;

    pmcl->bFillingList = FALSE;

    GetIDFDirectory (szPath, NUMELMS(szPath));
    cchBase = lstrlen (szPath);
    if (cchBase && szPath[cchBase-1] != TEXT('\\'))
        szPath[cchBase++] = TEXT('\\');
    lstrcpyn (szPath + cchBase, cszIdfWildcard, NUMELMS(szPath)-cchBase);

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("scanning for idfs at '%s'\r\n"), szPath);
#endif

    ix = 0;

    hFind = FindFirstFile (szPath, &ffd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
       TV_INSERTSTRUCT ti;
       struct types_enum_data ted = {hWndT, &ti, NULL, NULL};
       ZeroMemory (&ti, sizeof(ti));

       do
       {
           UINT   nInstr;
           UINT   cch;

           // patch off the extension before we add
           // this name to the list
           //
           cch = lstrlen(ffd.cFileName);
           while (cch)
              if (ffd.cFileName[--cch] == TEXT('.'))
              {
                 ffd.cFileName[cch] = 0;
                 break;
              }

           ti.hParent      = TVI_ROOT;
           ti.hInsertAfter = TVI_SORT;
          #ifdef USE_IDF_ICONS
           ti.item.mask      = TVIF_TEXT | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
          #else
           ti.item.mask      = TVIF_TEXT | TVIF_STATE;
          #endif

           // the TV_ITEM structure may not be unicode enabled ?!?
           ti.item.pszText   = ffd.cFileName;
           ti.item.state     = 0;
           ti.item.stateMask = TVIS_ALL;

#ifdef DEBUG
           AuxDebugEx (7, DEBUGLINE TEXT ("adding '%s' to types tree\r\n"), ti.item.pszText);
#endif

           ti.hParent = TreeView_InsertItem (hWndT, &ti);
           if ( ! ti.hParent)
              break;
           ti.hInsertAfter = TVI_LAST;

           // put the extension back
           //
           if (cch > 0)
              ffd.cFileName[cch] = TEXT('.');

           // check to see if this file is a match for the
           // current definition file.
           //
#ifdef DEBUG
           AuxDebugEx (7, DEBUGLINE TEXT ("comparing '%s' with '%s'\r\n"),
                       ffd.cFileName, pmcl->szFile);
#endif
           ted.pszInstr = IsPrefix (ffd.cFileName, pmcl->szFile, TEXT('<'));
#ifdef DEBUG
           AuxDebugEx (7, DEBUGLINE TEXT ("\tpszInstr = '%s'\r\n"), ted.pszInstr ? ted.pszInstr : TEXT ("NULL"));
#endif

           // add instruments as subkeys to this file
           // this also has the side effect of setting ted.htiSel
           // when the instrument name matches
           //
           lstrcpy (szPath + cchBase, ffd.cFileName);
           nInstr = idfEnumInstruments (szPath, fnTypesEnum, &ted);

           // if this idf has no instruments. ignore it.
           // if it has more than one instrument, expand the list
           // so that instruments are visible
           //
           if (0 == nInstr)
               TreeView_DeleteItem (hWndT, ti.hParent);
           else if (nInstr > 1)
               TreeView_Expand (hWndT, ti.hParent, TVE_EXPAND);
           else
               ted.htiSel = ti.hParent;

           // if we have a match on filename, then we need to select
           // either the parent or one of the children
           //
           if (ted.pszInstr ||
               IsSzEqual(ffd.cFileName,pmcl->szFile) ||
               IsSzEqual(ffd.cFileName,szDefaultIDF))
           {
#ifdef DEBUG
               AuxDebugEx (7, DEBUGLINE TEXT ("will be selecting %08X '%s'\r\n"),
                           ted.htiSel, ffd.cFileName);
#endif
               htiSelect = ted.htiSel;
           }

        } while (FindNextFile (hFind, &ffd));

        FindClose (hFind);
    }

    if (htiSelect)
    {
        pmcl->bFillingList = TRUE;
#ifdef DEBUG
        AuxDebugEx (7, DEBUGLINE TEXT ("selecting %08X\r\n"), htiSelect);
#endif
        TreeView_SelectItem (hWndT, htiSelect);
#ifdef DEBUG
        AuxDebugEx (7, DEBUGLINE TEXT ("FirstVisible %08X\r\n"), htiSelect);
#endif
        TreeView_SelectSetFirstVisible (hWndT, htiSelect);
        pmcl->bFillingList = FALSE;
    }

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("LoadTypesIntoTree( ,%d, ) ends\r\n"), uId);
#endif
    //SetWindowRedraw (hWndT, TRUE);
}

/*+
 *
 *-=================================================================*/

STATICFN void WINAPI HandleTypesSelChange (
    PMCLASS pmcl,
    LPNMHDR lpnm)
{
    LPNM_TREEVIEW pntv = (LPVOID)lpnm;
    LPTV_ITEM     pti  = &pntv->itemNew;
    HTREEITEM     htiParent;
    TV_ITEM       ti;

    assert (pmcl->bDetails);

    // setup ti to get text & # of children
    // from the IDF filename entry.
    //
    ti.mask       = TVIF_TEXT;
    ti.pszText    = pmcl->szFile;
    ti.cchTextMax = NUMELMS(pmcl->szFile);
    ti.hItem      = pti->hItem;

#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("Type Change pti=%08X hItem=%08X\r\n"), pti, pti->hItem);
#endif

    // if this entry has a parent, it must be a IDF
    // instrument name.  if so, then we want to read
    // from its parent first.
    //
    htiParent = TreeView_GetParent (lpnm->hwndFrom, pti->hItem);
    if (htiParent)
        ti.hItem = htiParent;

    TreeView_GetItem (lpnm->hwndFrom, &ti);
    lstrcat (pmcl->szFile, cszIdf);

#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("mask=%08x htiParent=%08X %08x nChild=%d '%s'\r\n"),
                ti.mask, htiParent, ti.hItem, ti.cChildren, ti.pszText);
#endif

    // if the selection had a parent, and we are not it's first child
    // then we need to append child (delimited by <>) after parent
    //
    if (htiParent &&
        (TreeView_GetChild(lpnm->hwndFrom, htiParent) != pti->hItem))
    {
        static CONST TCHAR cszAngle[] = TEXT(">");
        UINT cch = lstrlen(pmcl->szFile);

        pmcl->szFile[cch++] = TEXT('<');

        ti.mask       = TVIF_TEXT;
        ti.pszText    = pmcl->szFile + cch;
        ti.cchTextMax = NUMELMS(pmcl->szFile) - cch;
        ti.hItem      = pti->hItem;

        TreeView_GetItem (lpnm->hwndFrom, &ti);
        lstrcat (pmcl->szFile, cszAngle);
#ifdef DEBUG
        AuxDebugEx (6, DEBUGLINE TEXT ("appending child %08X; '%s'\r\n"), pti->hItem, pmcl->szFile);
#endif
    }

    pmcl->bChanges |= MCL_IDF_CHANGED;
}


/*+
 *
 *-=================================================================*/

STATICFN void LoadDevicesIntoList (
    HWND     hWnd,
    UINT     uId,
    PMCLASS  pmcl,
    BOOL     bList)
{
    HWND   hWndT;
    TCHAR  sz[MAX_ALIAS];
    DWORD  cch = sizeof(sz) / sizeof(TCHAR);
    UINT   ii;
    BOOL   bAdded = FALSE;

    hWndT = GetDlgItem (hWnd, uId);
    if (!hWndT)
        return;

    SetWindowRedraw (hWndT, FALSE);
    if (bList)
        ListBox_ResetContent(hWndT);
    else
        ComboBox_ResetContent(hWndT);

    if (!pmcl->hkMidi &&
        RegCreateKey (HKEY_LOCAL_MACHINE, cszDriversRoot, &pmcl->hkMidi))
        return;

    for (cch = sizeof(sz)/sizeof(TCHAR), ii = 0; ! RegEnumKey (pmcl->hkMidi, ii, sz, cch); ++ii)
    {
        TCHAR  szAlias[MAX_ALIAS];
        int    ix;
        BOOL   bExtern;
        BOOL   bActive;

        // read in the friendly name for this driver
        //
        if (GetAlias (pmcl->hkMidi, sz, szAlias, sizeof(szAlias)/sizeof(TCHAR), &bExtern, &bActive))
            continue;

        if (IsPrefix (sz, pmcl->pszKey, TEXT('\\')))
            pmcl->ixDevice = ii;

        // ignore if this is not an external device or if it is disabled
        //
        if ( ! bExtern || ! bActive)
            continue;

        // otherwise, add the driver name to the combobox/list
        //
        if (bList)
        {
            ix = ListBox_AddString (hWndT, szAlias);
            if (ix >= 0)
            {
                ListBox_SetItemData (hWndT, ix, ii);
                bAdded = TRUE;
            }
        }
        else
        {
            ix = ComboBox_AddString (hWndT, szAlias);
            if (ix >= 0)
            {
                ComboBox_SetItemData (hWndT, ix, ii);
                bAdded = TRUE;
            }
        }
    }

    SetWindowRedraw (hWndT, TRUE);
    EnableWindow (hWndT, bAdded);
    if (ii > 0)
        InvalidateRect (hWndT, NULL, TRUE);

    // iterate back through the items and select the one
    // that has item data that corresponds to driver that
    // owns the current device
    //
    if (bList)
    {
        UINT jj;

        for (jj = 0; jj < ii; ++jj)
        {
            if ((UINT)ListBox_GetItemData (hWndT, jj) == pmcl->ixDevice)
            {
                ListBox_SetCurSel (hWndT, jj);
                break;
            }
        }
        if (jj >= ii)
            ListBox_SetCurSel (hWndT, 0);
    }
    else
    {
        UINT jj;

        for (jj = 0; jj < ii ; ++jj)
        {
            if ((UINT)ComboBox_GetItemData (hWndT, jj) == pmcl->ixDevice)
            {
                ComboBox_SetCurSel (hWndT, jj);
                break;
            }
        }
        if (jj >= ii)
            ComboBox_SetCurSel (hWndT, 0);
    }
}


/*+ LoadClass
 *
 *-=================================================================*/

STATICFN BOOL WINAPI LoadClass (
    HWND    hWnd,
    PMCLASS pmcl)
{
    HKEY  hKeyA = NULL;
    BOOL  bRet = FALSE;
    UINT  cbSize;
    UINT  cch;
    DWORD dw;

    if (!pmcl->hkMidi &&
        RegCreateKey (HKEY_LOCAL_MACHINE, cszDriversRoot, &pmcl->hkMidi))
        goto cleanup;

    if (RegOpenKey (pmcl->hkMidi, pmcl->pszKey, &hKeyA))
        goto cleanup;

    // read data from this key
    //
    cbSize = sizeof(pmcl->szFile);
    RegQueryValueEx (hKeyA, cszDefinition, NULL, &dw, (LPBYTE)pmcl->szFile, &cbSize);

    // strip off leading directory (if there is one).
    //
    cch = lstrlen(pmcl->szFile);
    while (cch && (pmcl->szFile[cch-1] != TEXT('\\')))
        --cch;
    if (cch)
    {
        TCHAR szFile[MAX_PATH];
        lstrcpy (szFile, pmcl->szFile + cch);
        lstrcpy (pmcl->szFile, szFile);
    }

    // get scheme alias
    //
    cbSize = sizeof(pmcl->szAlias);
    RegQueryValueEx (hKeyA, cszFriendlyName, NULL, &dw, (LPBYTE)pmcl->szAlias, &cbSize);

    //
    //
    pmcl->nPort = 0;
    cbSize = sizeof(pmcl->nPort);
    RegQueryValueEx (hKeyA, cszPort, NULL, &dw, (LPVOID)&pmcl->nPort, &cbSize);

    pmcl->bChanges = 0;
    bRet = TRUE;

  cleanup:
    if (hKeyA)
       RegCloseKey (hKeyA);

    return bRet;
}


/*+ RebuildSchemes
 *
 * correct key references in the midi schemes when an instrument
 * is moved from one external midi port to another
 *
 *-=================================================================*/

STATICFN BOOL WINAPI RebuildSchemes (
    LPTSTR pszOldKey,
    LPTSTR pszNewKey)
{
    HKEY  hkSchemes;
    UINT  ii;
    TCHAR sz[MAX_ALIAS];
    UINT  cchNew;

    cchNew = 0;
    if (pszNewKey)
        cchNew = lstrlen(pszNewKey) + 1;

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("RebuildSchemes('%s','%s')\r\n"),
                pszOldKey, pszNewKey ? pszNewKey : TEXT ("NULL"));
#endif

    if (RegCreateKey (HKEY_LOCAL_MACHINE, cszSchemeRoot, &hkSchemes))
        return FALSE;


    for (ii = 0; ! RegEnumKey (hkSchemes, ii, sz, sizeof(sz)/sizeof(TCHAR)); ++ii)
    {
        HKEY  hKeyA;
        UINT  jj;

        if (RegOpenKey (hkSchemes, sz, &hKeyA))
            continue;

        for (jj = 0; ! RegEnumKey (hKeyA, jj, sz, sizeof(sz)/sizeof(TCHAR)); ++jj)
        {
            UINT  cb;
            TCHAR szKey[MAX_PATH];

            cb = sizeof(szKey);
            if (RegQueryValue (hKeyA, sz, szKey, &cb))
                continue;

            if (IsSzEqual(pszOldKey, szKey))
            {
                if (cchNew)
                    RegSetValue (hKeyA, sz, REG_SZ, pszNewKey, cchNew);
                else
                    RegDeleteKey (hKeyA, sz);

#ifdef DEBUG
                AuxDebugEx (4, DEBUGLINE TEXT ("RebuildSchemes - fixing %d\\%d\r\n"), ii, jj);
#endif
            }
        }
    }

    return TRUE;
}


/*+ OpenInstrumentKey
 *
 *-=================================================================*/

STATICFN HKEY WINAPI OpenInstrumentKey (
    HWND    hWnd,
    PMCLASS pmcl,
    BOOL    bCreate)   // create an new key (do not remove or rebuild existing)
{
    TCHAR  szKey[MAX_ALIAS];
    HKEY   hkInst;
    HKEY   hKeyA = NULL;
    ZeroMemory (szKey, sizeof (szKey));

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("OpenInstrumentKey(%X,%08X,%d) szKey=%s\r\n"),
                hWnd, pmcl, bCreate, pmcl->pszKey ? pmcl->pszKey : TEXT ("NULL"));
#endif

    hkInst = NULL;

    if (!pmcl->hkMidi &&
        RegCreateKey (HKEY_LOCAL_MACHINE, cszDriversRoot, &pmcl->hkMidi))
        goto cleanup;

    if (RegEnumKey (pmcl->hkMidi, pmcl->ixDevice, szKey, sizeof(szKey)/sizeof(TCHAR)))
    {
        assert3(0, TEXT ("Failed to enum Midi device %d"), pmcl->ixDevice);
        goto cleanup;
    }
#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("ixDevice = %d, Key is %s\r\n"),
                pmcl->ixDevice, szKey);
#endif

    // if this is a driver key, or if we are not creating and
    // the instrument has not changed parentage, we can just
    // open the existing key and update its content
    //
    if (!pmcl->bRemote ||
        (!bCreate && IsPrefix (szKey, pmcl->pszKey, TEXT('\\'))))
    {
        if (RegOpenKey (pmcl->hkMidi, pmcl->pszKey, &hKeyA))
            goto cleanup;
#ifdef DEBUG
        AuxDebugEx (6, DEBUGLINE TEXT ("opened key %s\r\n"), pmcl->pszKey);
#endif
    }
    else
    {
        UINT  kk;
        TCHAR szEnum[10];

        pmcl->bChanges |= MCL_TREE_CHANGED;

        lstrcat (szKey, cszSlashInstruments);
        if (RegCreateKey (pmcl->hkMidi, szKey, &hkInst))
            goto cleanup;

        // find an unused keyname
        //
        for (kk = 0; kk < 128; ++kk)
        {
           wsprintf (szEnum, csz02d, kk);
           if (RegOpenKey (hkInst, szEnum, &hKeyA))
               break;
           RegCloseKey (hKeyA);
        }
        lstrcat (szKey, cszSlash);
        lstrcat (szKey, szEnum);

        // create a key with that name
        //
        if (RegCreateKey (hkInst, szEnum, &hKeyA))
            goto cleanup;

#ifdef DEBUG
        AuxDebugEx (6, DEBUGLINE TEXT ("created key %s\r\n"), szKey);
#endif

        // we are moving an instrument from one
        // external midi port to another
        //
        if (!bCreate)
        {
#ifdef DEBUG
            AuxDebugEx (3, DEBUGLINE TEXT ("Deleting key midi\\%s\r\n"), pmcl->pszKey);
#endif
            RegDeleteKey (pmcl->hkMidi, pmcl->pszKey);
            RebuildSchemes (pmcl->pszKey, szKey);
        }

        lstrcpy (pmcl->pszKey, szKey);
    }


  cleanup:
    if (hkInst)
       RegCloseKey (hkInst);

    return hKeyA;
}

/*+ SaveDetails
 *
 *-=================================================================*/

STATICFN UINT WINAPI SaveDetails (
    HWND    hWnd,
    PMCLASS pmcl,
    BOOL    bCreate)
{
    HWND   hWndT;
    HKEY   hKeyA;
    UINT   bChanges;
    UINT   cbSize;

    // this should only be called on shutdown
    // of details page (or on exit of wizard)
    //
    assert (pmcl->bDetails);

    hKeyA = OpenInstrumentKey (hWnd, pmcl, bCreate);
    if ( ! hKeyA)
        return FALSE;

    hWndT = GetDlgItem (hWnd, IDE_ALIAS);
    if (hWndT)
    {
        TCHAR sz[NUMELMS(pmcl->szAlias)];
        GetWindowText (hWndT, sz, NUMELMS(sz));
        if ( ! IsSzEqual(sz, pmcl->szAlias))
        {
            lstrcpy (pmcl->szAlias, sz);
            pmcl->bChanges |= MCL_ALIAS_CHANGED;
        }
    }

#ifdef DEBUG
    AuxDebugEx (2, DEBUGLINE TEXT ("--------SaveInstrument---------\r\n"));
    AuxDebugEx (2, TEXT ("\tChanges=%x\r\n"), pmcl->bChanges);
    AuxDebugEx (2, TEXT ("\tFriendly='%s'\r\n"), pmcl->szAlias);
    AuxDebugEx (2, TEXT ("\tDefinition='%s'\r\n"), pmcl->szFile);
#endif

    // save value data from this key
    //
    cbSize = (lstrlen(pmcl->szFile)+1) * sizeof(TCHAR);
    RegSetValueEx (hKeyA, cszDefinition, 0, REG_SZ, (LPBYTE)pmcl->szFile,
                   cbSize);

    cbSize = (lstrlen(pmcl->szAlias)+1) * sizeof(TCHAR);
    RegSetValueEx (hKeyA, cszFriendlyName, 0, REG_SZ,
                   (LPBYTE)pmcl->szAlias, cbSize);

    RegSetValueEx (hKeyA, cszPort, 0, REG_BINARY, (LPVOID)&pmcl->nPort, 1);

    RegCloseKey (hKeyA);

    bChanges = pmcl->bChanges;
    pmcl->bChanges = 0;

    // return 'changed' flag
    //
    return bChanges;
}


/*+ ParseAngleBrackets
 *
 *  replace '<>' delimiters with 0s and return a pointer
 *  to the delimited string. This function does nothing if
 *  the string does not end in a '>' delimiter
 *
 *-=================================================================*/

static LPTSTR __inline WINAPI ParseAngleBrackets (
    LPTSTR pszArg)
{
    LPTSTR psz = pszArg + lstrlen(pszArg);

    while (--psz > pszArg)
    {
        if (*psz == TEXT('>'))
        {
            *psz = 0;
            while (--psz >= pszArg)
            {
                if (*psz == TEXT('<'))
                {
                    *psz = 0;
                    return psz+1;
                }
            }
        }
    }

    return NULL;
}


/*+ fnFindDevice
 *
 *-=================================================================*/

struct _find_data {
    HWND   hWnd;
    UINT   idMfg;
    UINT   idProd;
    LPTSTR pszInstr;
    };

STATICFN BOOL WINAPI fnFindDevice (
    LPVOID        lpv,
    UINT          nEnum,
    LPIDFHEADER   pHdr,
    LPIDFINSTINFO pInst)
{
    struct _find_data * pfd = lpv;
    TCHAR szTemp[MAX_PATH];

    assert (pfd);

    MultiByteToWideChar(GetACP(), 0,
                        pHdr->abInstID, -1,
                        szTemp, sizeof(szTemp)/sizeof(TCHAR));

    if (!pfd->pszInstr ||
        IsSzEqual (pfd->pszInstr, szTemp))
    {
        if (SetDlgItemText (pfd->hWnd, pfd->idMfg, (TCHAR*)(pInst->abData+pInst->cbManufactASCII )))
            pfd->idMfg = 0;

        if (SetDlgItemText (pfd->hWnd, pfd->idProd,
                            (TCHAR*)(pInst->abData
                            + pInst->cbManufactASCII + pInst->cbManufactUNICODE)))
            pfd->idProd = 0;

        // we can stop enumerating now
        //
        return FALSE;
    }

    // return true to consider ennumeration
    //
    return TRUE;
}


/*+ ActivateInstrumentPage
 *
 *-=================================================================*/

STATICFN void WINAPI ActivateInstrumentPage (
    HWND    hWnd,
    PMCLASS pmcl)
{
    pmcl->bDetails = FALSE;
    if (GetDlgItem (hWnd, IDC_TYPES))
    {
        pmcl->bDetails = TRUE;
        LoadTypesIntoTree (hWnd, IDC_TYPES, pmcl);
        SetTypesEdit (hWnd, IDE_TYPES, pmcl);

        LoadDevicesIntoList (hWnd, IDC_DEVICES, pmcl, FALSE);

        if ( ! pmcl->bRemote)
        {
            HWND hWndT = GetDlgItem (hWnd, IDC_DEVICES);

            if (hWndT)
                EnableWindow (hWndT, FALSE);
        }
    }
    else
    {
        struct _find_data fd;
        TCHAR  szFile[NUMELMS(pmcl->szFile)];

        if ( ! IsFullPath (pmcl->szFile))
        {
           UINT  cch;

           GetIDFDirectory (szFile, NUMELMS(szFile));
           cch = lstrlen (szFile);
           if (cch && szFile[cch-1] != TEXT('\\'))
               szFile[cch++] = TEXT('\\');
           lstrcpyn (szFile + cch, pmcl->szFile, NUMELMS(szFile)-cch);
        }
        else
           lstrcpy (szFile, pmcl->szFile);

        fd.hWnd = hWnd;
        fd.idMfg = IDC_MANUFACTURER;
        fd.idProd = IDC_DEVICE_TYPE;
        fd.pszInstr = ParseAngleBrackets(szFile);

        idfEnumInstruments (szFile, fnFindDevice, &fd);

        if (fd.idMfg)
            SetDlgItemText (hWnd, fd.idMfg, cszEmpty);
        if (fd.idProd)
        {
            LoadString (ghInstance, IDS_UNSPECIFIED, szFile, NUMELMS(szFile));
            SetDlgItemText (hWnd, fd.idProd, szFile);
        }
    }
}


/*+ IsInstrumentKey
 *
 * return TRUE if the keyname passed refers to an instrument key
 * rather than a device key.  device keys usually end in '>',
 * while instrument keys will always be of the form
 * <dev>\Instruments\<enum>  where <dev> and <enum> can be arbitrary
 * strings.
 *
 *-=================================================================*/

STATICFN BOOL WINAPI IsInstrumentKey (
    LPTSTR pszKey)
{
    UINT cch = lstrlen(pszKey);
    if (!cch)
        return FALSE;

    if (pszKey[cch-1] == TEXT('>'))
        return FALSE;

    while (--cch)
        if (pszKey[cch] == TEXT('\\'))
            return TRUE;

    return FALSE;
}


/*+ InitInstrumentProps
 *
 *-=================================================================*/

STATICFN BOOL WINAPI InitInstrumentProps (
    HWND    hWnd,
    PMCLASS pmcl)
{
    LPPROPSHEETPAGE ppsp = pmcl->ppsp;
    PMPSARGS        pmpsa;

    assert (ppsp && ppsp->dwSize == sizeof(*ppsp));
    if (!ppsp)
        return FALSE; // EndDialog (hWnd, FALSE);

    pmcl->bRemote = FALSE;

    pmpsa = (LPVOID)ppsp->lParam;
    if (pmpsa && pmpsa->lpfnMMExtPSCallback)
    {
       pmpsa->lpfnMMExtPSCallback (MM_EPS_GETNODEDESC,
                                   (DWORD_PTR)pmcl->szAlias,
                                   sizeof(pmcl->szAlias),
                                   (DWORD_PTR)pmpsa->lParam);
#ifdef DEBUG
       AuxDebugEx (3, TEXT ("\tgot szAlias='%s'\r\n"), pmcl->szAlias);
#endif
       pmpsa->lpfnMMExtPSCallback (MM_EPS_GETNODEID,
                                   (DWORD_PTR)pmcl->szFullKey,
                                   sizeof(pmcl->szFullKey),
                                   (DWORD_PTR)pmpsa->lParam);
#ifdef DEBUG
       AuxDebugEx (3, TEXT ("\tgot szFullKey='%s'\r\n"), pmcl->szFullKey);
#endif
       // skip over the midi\ part of the key if we have been
       // passed that.  we want the driver name to be the first
       // part of the key
       //
       pmcl->pszKey = pmcl->szFullKey;
       if (!lstrnicmp (pmcl->pszKey,
                       (LPTSTR)cszMidiSlash,
                       lstrlen(cszMidiSlash)))
       {
           pmcl->pszKey += lstrlen(cszMidiSlash);
       }

       // If this is an instrument key, set bRemote to true
       //
       if (IsInstrumentKey(pmcl->pszKey))
          pmcl->bRemote = TRUE;
    }
    else
       LoadString (ghInstance, IDS_UNSPECIFIED,
                   pmcl->szAlias, NUMELMS(pmcl->szAlias));

    SetDlgItemText (hWnd, IDE_ALIAS, pmcl->szAlias);
    Static_SetIcon(GetDlgItem (hWnd, IDC_CLASS_ICON),
                   LoadIcon (ghInstance, MAKEINTRESOURCE(IDI_INSTRUMENT)));

    LoadClass (hWnd, pmcl);

    //ActivateInstrumentPage(hWnd, pmcl);

    return TRUE;
}


/*+ NotifyMapper
 *
 *-=================================================================*/

STATICFN void WINAPI NotifyMapper (
    PMCLASS pmcl,
    UINT    bChanges,
    HWND    hWnd)
{
    // tell midi mapper about tree changes, IDF changes and port changes
    //
    if (bChanges & (MCL_TREE_CHANGED | MCL_IDF_CHANGED | MCL_PORT_CHANGED))
    {
        KickMapper (hWnd);
    }
}


/*+
 *
 *-=================================================================*/

STATICFN BOOL WINAPI RemoveInstrument (
    HWND    hWnd,
    PMCLASS pmcl)
{
    RegDeleteKey (pmcl->hkMidi, pmcl->pszKey);
    RebuildSchemes (pmcl->pszKey, NULL);
    return TRUE;
}

BOOL WINAPI RemoveInstrumentByKeyName (
    LPCTSTR pszKey)
{
    MCLASS  mcl;
    BOOL    rc = FALSE;

    memset ((TCHAR *)&mcl, 0x00, sizeof(mcl));
    mcl.pszKey = (LPTSTR)pszKey;

    if (!lstrnicmp (mcl.pszKey,
                    (LPTSTR)cszMidiSlash,
                    lstrlen(cszMidiSlash)))
    {
        mcl.pszKey += lstrlen(cszMidiSlash);
    }

    if (LoadClass (NULL, &mcl))
    {
        rc = RemoveInstrument (NULL, &mcl);

        if (mcl.hkMidi)
            RegCloseKey (mcl.hkMidi);
    }

    return rc;
}


/*+ MidiInstrumentCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiInstrumentCommands (
    HWND        hWnd,
    UINT_PTR    uId,
    LPNMHDR     lpnm)
{
    PMCLASS pmcl = GetDlgData(hWnd);

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("InstrumentCommands(..%d..) %d(%xx)\r\n"),
                uId, lpnm->code, lpnm->code);
#endif

    if (!pmcl)
        return FALSE;
    
    switch (uId)
    {
        case IDE_ALIAS:
            if (lpnm->code == EN_CHANGE)
                PropSheet_Changed(GetParent(hWnd), hWnd);
            break;

        case IDB_REMOVE:
            if (RemoveInstrument (hWnd, pmcl))
            {
                PMPSARGS  pmpsa = (LPVOID)pmcl->ppsp->lParam;
                if (pmpsa && pmpsa->lpfnMMExtPSCallback)
                    pmpsa->lpfnMMExtPSCallback (MM_EPS_TREECHANGE, 0, 0, (DWORD_PTR)pmpsa->lParam);

                NotifyMapper (pmcl, MCL_TREE_CHANGED, hWnd);
                SetDlgData(hWnd, NULL);
                if (pmcl->hkMidi)
                    RegCloseKey (pmcl->hkMidi), pmcl->hkMidi = NULL;

                LocalFree ((HLOCAL)(UINT_PTR)(DWORD_PTR)pmcl);
                PropSheet_PressButton(GetParent(hWnd), PSBTN_CANCEL);
            }
            break;

        case IDB_NEWTYPE:
            InstallNewIDF (hWnd);
            LoadTypesIntoTree (hWnd, IDC_TYPES, pmcl);
            SetTypesEdit (hWnd, IDE_TYPES, pmcl);
            break;

        case IDC_TYPES:
            if ((lpnm->code == TVN_SELCHANGED) && !pmcl->bFillingList)
            {
                HandleTypesSelChange (pmcl, lpnm);
                SetTypesEdit (hWnd, IDE_TYPES, pmcl);
                PropSheet_Changed(GetParent(hWnd), hWnd);
#ifdef DEBUG
                AuxDebugEx (5, DEBUGLINE TEXT ("file='%s'\r\n"), pmcl->szFile);
#endif
            }
            break;

        case IDC_DEVICES:
            if (lpnm->code == CBN_SELCHANGE)
            {
                int ix = ComboBox_GetCurSel (lpnm->hwndFrom);
                pmcl->ixDevice = (UINT) ((ix >= 0) ? ComboBox_GetItemData (lpnm->hwndFrom, ix) : -1);
                PropSheet_Changed(GetParent(hWnd), hWnd);
#ifdef DEBUG
                AuxDebugEx (4, DEBUGLINE TEXT ("IDC_DEVICES.selChange(%d) %d\r\n"), ix, pmcl->ixDevice);
#endif
            }
            break;

        // we get these only if invoked as a dialog, not as a property
        // sheet
        //
        case IDOK:
            {
            UINT bChanges = SaveDetails (hWnd, pmcl, FALSE);
            NotifyMapper (pmcl, bChanges, hWnd);
            }
            // fall through
        case IDCANCEL:
            EndDialog (hWnd, uId);
            break;

        case 0:
        {
            LONG lRet = FALSE;

            switch (lpnm->code)
            {
                case PSN_APPLY:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("ID_APPLY\r\n"));
#endif
                    if (pmcl->bDetails)
                    {
                        UINT bChanges = SaveDetails (hWnd, pmcl, FALSE);

                        NotifyMapper (pmcl, bChanges, hWnd);

                        // tell mmsys.cpl about tree & alias changes
                        //
                        if (bChanges & (MCL_TREE_CHANGED | MCL_ALIAS_CHANGED))
                        {
                            PMPSARGS  pmpsa = (LPVOID)pmcl->ppsp->lParam;
                            if (pmpsa && pmpsa->lpfnMMExtPSCallback)
                                pmpsa->lpfnMMExtPSCallback (MM_EPS_TREECHANGE, 0, 0, (DWORD_PTR)pmpsa->lParam);
                        }

                        // we do this because the SysTreeView for IDF files
                        // forgets its selection when APPLY is pressed. go figure
                        //
#ifdef DEBUG
                        AuxDebugEx (7,  DEBUGLINE TEXT ("PSN_APPLY: re-doing selection '%s'\r\n"), pmcl->szFile);
                        //ActivateInstrumentPage (hWnd, pmcl);
                        AuxDebugEx (7,  DEBUGLINE TEXT ("PSN_APPLY: done re-doing selection '%s'\r\n"), pmcl->szFile);
#endif
                    }
                    break;

                case PSN_KILLACTIVE:
                    break;

                case PSN_SETACTIVE:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_SETACTIVE\r\n"));
#endif
                    ActivateInstrumentPage (hWnd, pmcl);
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_SETACTIVE ends\r\n"));
#endif
                    break;
            }
            SetWindowLongPtr (hWnd, DWLP_MSGRESULT, (LONG_PTR)lRet);
            break;
        }
    }

    return FALSE;
}

const static DWORD aKeyWordIds[] = {  // Context Help IDs
    IDC_CLASS_ICON, IDH_MMCPL_DEVPROP_DETAILS_INSTRUMENT,
    IDE_ALIAS,      IDH_MMCPL_DEVPROP_DETAILS_INSTRUMENT,
    IDC_DEVICES,    IDH_MMCPL_DEVPROP_DETAILS_MIDI_PORT,
    IDC_TYPES,      IDH_MMCPL_DEVPROP_DETAILS_INS_DEF,
    IDB_NEWTYPE,    IDH_MMCPL_DEVPROP_DETAILS_BROWSE,

    0, 0
};

/*+ MidiInstrumentDlgProc
 *
 *-=================================================================*/

INT_PTR CALLBACK MidiInstrumentDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
   #if defined DEBUG || defined DEBUG_RETAIL
    TCHAR chNest = szNestLevel[0]++;
   #endif

    switch (uMsg)
    {
        case WM_COMMAND:
            {
            NMHDR nmh;
            nmh.hwndFrom = GET_WM_COMMAND_HWND(wParam, lParam);
            nmh.idFrom   = GET_WM_COMMAND_ID(wParam, lParam);
            nmh.code     = GET_WM_COMMAND_CMD(wParam, lParam);

            MidiInstrumentCommands(hWnd, nmh.idFrom, &nmh);
            }
            break;
        
        case WM_NOTIFY:
#ifdef DEBUG
            AuxDebugEx (3, DEBUGLINE TEXT ("WM_NOTIFY(%x,%x,%x)\r\n"), hWnd, wParam, lParam);
#endif

           #if defined DEBUG || defined DEBUG_RETAIL
            ++szNestLevel[0];
           #endif

            MidiInstrumentCommands(hWnd, wParam, (LPVOID)lParam);

           #if defined DEBUG || defined DEBUG_RETAIL
            --szNestLevel[0];
           #endif
            break;
        
        case WM_INITDIALOG:
        {
            PMCLASS         pmcl;

            pmcl = (LPVOID)LocalAlloc(LPTR, sizeof(*pmcl));
            if (!pmcl)
			{
                EndDialog(hWnd, FALSE);
				break;
			}

            pmcl->ppsp = (LPVOID)lParam;
            SetDlgData (hWnd, pmcl);

#ifdef DEBUG
            AuxDebugEx (5, DEBUGLINE TEXT ("midiInstrument.WM_INITDLG ppsp=%08X\r\n"));
#endif
            //AuxDebugDump (8, pmcl->ppsp, sizeof(*(pmcl->ppsp)));

            InitInstrumentProps (hWnd, pmcl);
            break;
        }

        case WM_DESTROY:
        {
            PMCLASS pmcl = GetDlgData(hWnd);

            if (pmcl)
            {
                if (pmcl->hkMidi)
                    RegCloseKey (pmcl->hkMidi), pmcl->hkMidi = NULL;

               #ifdef USE_IDF_ICONS

                if (pmcl->hIDFImageList)
                {
                    HWND hWndT = GetDlgItem (hWnd, IDC_TYPES);
                    if (hWndT)
                        TreeView_SetImageList (hWndT, NULL, TVSIL_NORMAL);

                    ImageList_Destroy (pmcl->hIDFImageList);
                    pmcl->hIDFImageList = NULL;
                }

               #endif

                LocalFree ((HLOCAL)(UINT_PTR)(DWORD_PTR)pmcl);
            }

            break;
        }

        case WM_CONTEXTMENU:
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (UINT_PTR) (LPTSTR) aKeyWordIds);
            break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
                    (UINT_PTR) (LPTSTR) aKeyWordIds);
            break;
        }
    }

   #if defined DEBUG || defined DEBUG_RETAIL
    szNestLevel[0] = chNest;
   #endif
    return FALSE;
}


/// --------------------- Wizard stuff ----------------------

static LPTSTR aidWiz[] = {
    MAKEINTRESOURCE(IDD_MIDIWIZ02),
    MAKEINTRESOURCE(IDD_MIDIWIZ03),
    MAKEINTRESOURCE(IDD_MIDIWIZ04)
    };

#define WIZ_TEMPLATE_DEVICE  aidWiz[0]
#define WIZ_TEMPLATE_IDF     aidWiz[1]
#define WIZ_TEMPLATE_ALIAS   aidWiz[2]

typedef struct _wizdata {
    LPPROPSHEETPAGE ppspActive;
    HBITMAP         hBmp;
    MCLASS          mcl;
    PMCMIDI         pmcm;
    HPROPSHEETPAGE  ahpsp[NUMELMS(aidWiz)];
    } WIZDATA, * PWIZDATA;

/*+ FindInstrument
 *
 *-=================================================================*/

STATICFN PINSTRUM WINAPI FindInstrument (
    PMCMIDI  pmcm,
    LPTSTR   pszFriendly)
{
    UINT  ii;

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
        assert (pmcm->api[ii]);
        if (IsSzEqual(pszFriendly, pmcm->api[ii]->szFriendly))
            return pmcm->api[ii];
    }

    return NULL;
}

/*+ UniqueFriendlyName
 *
 *-=================================================================*/

STATICFN BOOL WINAPI fnFirstInstr (
    LPVOID        lpv,
    UINT          nEnum,
    LPIDFHEADER   pHdr,
    LPIDFINSTINFO pInst)
{
    LPTSTR pszInstr = lpv;

    assert (pszInstr);

    MultiByteToWideChar(GetACP(), 0,
                        pHdr->abInstID, -1,
                        pszInstr, MAX_ALIAS);

    return FALSE;
}

STATICFN BOOL WINAPI UniqueFriendlyName (
    PMCMIDI pmcm,
    PMCLASS pmcl,
    LPTSTR  pszAlias,
    UINT    cchAlias)
{
    TCHAR  szFile[MAX_PATH * 2];
    LPTSTR pszInstr;
    UINT   cch;
    UINT   ii;

    GetIDFDirectory (szFile, sizeof(szFile)/sizeof(TCHAR));
    cch = lstrlen(szFile);
    if (cch && szFile[cch-1] != TEXT('\\'))
        szFile[cch++] = TEXT('\\');
    lstrcpy (szFile + cch, pmcl->szFile);
    pszInstr = ParseAngleBrackets (szFile);
    if ( ! pszInstr)
    {
        pszInstr = szFile + lstrlen(szFile) + 1;
        idfEnumInstruments (szFile, fnFirstInstr, pszInstr);
    }

    // if no instrument name from the IDF file, get a default
    // from our resources
    //
    if ( ! lstrlen (pszInstr))
    {
        LoadString (ghInstance, IDS_DEF_INSTRNAME, pszInstr, MAX_ALIAS);
        return FALSE;
    }

    // make the instrument name the same as the alias, and prepare
    // to append a number if the alias turns out not to be unique
    //
    lstrcpyn (pszAlias, pszInstr, cchAlias);
    cch = lstrlen (pszAlias);
    cch = min (cch, (UINT)MAX_ALIAS-3);
    ii = 1;

    // loop while we are trying to use an instrument name
    // that has already been used
    //
    while (FindInstrument (pmcm, pszAlias))
    {
        static CONST TCHAR cszSpaceD[] = TEXT (" %d");

        wsprintf (pszAlias + cch, cszSpaceD, ++ii);
        if (ii > NUMELMS(pmcm->api))
        {
            assert2(0, TEXT ("infinite loop in UniqueFriendlyName!"));
            break;
        }
    }

    return TRUE;
}


/*+ MidiWizardCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiWizardCommands (
    HWND        hWnd,
    UINT_PTR    uId,
    LPNMHDR     lpnm)
{
    PWIZDATA         pwd;
    LPPROPSHEETPAGE  ppsp = GetDlgData(hWnd);
    LONG             lRet = TRUE;

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("WizardCmd ppsp=%08X code=%d(0x%X)\r\n"),
                ppsp, lpnm->code, lpnm->code);
#endif

    pwd = NULL;
    if (ppsp)
        pwd = (LPVOID)ppsp->lParam;
    assert (pwd);

    switch (uId)
    {
        case IDC_TYPES:
            if ((lpnm->code == TVN_SELCHANGED) && !pwd->mcl.bFillingList)
            {
                HandleTypesSelChange (&pwd->mcl, lpnm);
                UniqueFriendlyName (pwd->pmcm, &pwd->mcl, pwd->mcl.szAlias, NUMELMS(pwd->mcl.szAlias));
#ifdef DEBUG
                AuxDebugEx (5, DEBUGLINE TEXT ("file='%s'\r\n"), pwd->mcl.szFile);
#endif
            }
            break;

        case IDB_NEWTYPE:
            InstallNewIDF (hWnd);
            LoadTypesIntoTree (hWnd, IDC_TYPES, &pwd->mcl);
            break;

        //case IDC_DEVICES:
        //    break;
        //case IDE_ALIAS:
        //    break;

        case 0:
        {
            switch (lpnm->code)
            {
                case PSN_HELP:
                    break;

                case PSN_KILLACTIVE:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_KILLACTIVE\r\n"));
#endif
                    break;

                case PSN_SETACTIVE:
                {
                    DWORD dwWizBtn;

#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_SETACTIVE\r\n"));
#endif
                    if (pwd)
                        pwd->ppspActive = ppsp;

                    if (ppsp->pszTemplate == WIZ_TEMPLATE_DEVICE) // midi device
                        LoadDevicesIntoList (hWnd, IDC_DEVICES, &pwd->mcl, TRUE);
                    else if (ppsp->pszTemplate == WIZ_TEMPLATE_IDF) // idf file
                        LoadTypesIntoTree (hWnd, IDC_TYPES, &pwd->mcl);
                    else if (ppsp->pszTemplate == WIZ_TEMPLATE_ALIAS) // alias
                        SetDlgItemText (hWnd, IDE_ALIAS, pwd->mcl.szAlias);

                    dwWizBtn = PSWIZB_NEXT | PSWIZB_BACK;
                    if (ppsp->pszTemplate == aidWiz[NUMELMS(aidWiz)-1])
                        dwWizBtn = PSWIZB_FINISH | PSWIZB_BACK;
                    else if (ppsp->pszTemplate == aidWiz[0])
                        dwWizBtn = PSWIZB_NEXT;

                    PropSheet_SetWizButtons (GetParent(hWnd), dwWizBtn);
                }
                    break;

                case PSN_WIZNEXT:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_WIZNEXT\r\n"));
#endif

                    if (ppsp->pszTemplate == WIZ_TEMPLATE_DEVICE) // midi device
                    {
                        HWND   hWndT;
                        int    ix;

                        pwd->mcl.ixDevice = (UINT)-1;
                        pwd->mcl.nPort = 0;

                        hWndT = GetDlgItem (hWnd, IDC_DEVICES);
                        if (hWndT)
                        {
                            ix = ListBox_GetCurSel (hWndT);
                            if (ix >= 0)
                                pwd->mcl.ixDevice = (UINT) ListBox_GetItemData (hWndT, ix);
                        }

                        if (pwd->mcl.ixDevice == (UINT)-1)
                            SetWindowLongPtr (hWnd, DWLP_MSGRESULT, (LONG_PTR)-1);
                    }
                    else if (ppsp->pszTemplate == WIZ_TEMPLATE_IDF) // idf file
                    {
                        if ( ! pwd->mcl.szAlias[0])
                        {
                            LoadString (ghInstance, IDS_DEF_INSTRNAME,
                                        pwd->mcl.szAlias,
                                        NUMELMS(pwd->mcl.szAlias));
                        }
                    }
                    else if (ppsp->pszTemplate == WIZ_TEMPLATE_IDF) // alias
                    {
                        GetDlgItemText (hWnd, IDE_ALIAS, pwd->mcl.szAlias,
                                        NUMELMS(pwd->mcl.szAlias));
                    }
                    break;

                case PSN_WIZBACK:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_WIZBACK\r\n"));
#endif
                    break;

                case PSN_WIZFINISH:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_WIZFINISH\r\n"));
#endif
                    //if (!save success)
                       lRet = FALSE;
                    //SetWindowLong (hWnd, DWL_MSGRESULT, lRet);
                    SaveDetails (hWnd, &pwd->mcl, TRUE);
                    break;

                default:
                    lRet = FALSE;
            }
        }
            break;
    }

    return lRet;
}


/*+ MidiWizardDlgProc
 *
 *-=================================================================*/

INT_PTR CALLBACK MidiWizardDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL bRet = TRUE;
   #if defined DEBUG || defined DEBUG_RETAIL
    TCHAR chNest = szNestLevel[0]++;
   #endif

    switch (uMsg)
    {
        case WM_COMMAND:
            {
            NMHDR nmh;
            nmh.hwndFrom = GET_WM_COMMAND_HWND(wParam, lParam);
            nmh.idFrom   = GET_WM_COMMAND_ID(wParam, lParam);
            nmh.code     = GET_WM_COMMAND_CMD(wParam, lParam);

            bRet = MidiWizardCommands(hWnd, nmh.idFrom, &nmh);
            }
            break;
        
        case WM_NOTIFY:
#ifdef DEBUG
            AuxDebugEx (6, DEBUGLINE TEXT ("WM_NOTIFY(%x,%x,%x)\r\n"), hWnd, wParam, lParam);
#endif
            bRet = MidiWizardCommands(hWnd, wParam, (LPVOID)lParam);
            break;
        
        case WM_INITDIALOG:
        {
            PWIZDATA         pwd;
            LPPROPSHEETPAGE  ppsp = (LPVOID)lParam;

            SetDlgData (hWnd, lParam);

            pwd = (LPVOID)ppsp->lParam;

            SendDlgItemMessage(hWnd, IDC_WIZBMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)pwd->hBmp);

#ifdef DEBUG
            AuxDebugEx (5, DEBUGLINE TEXT ("MidiWizard.WM_INITDLG ppsp=%08X\r\n"), ppsp);
#endif
        }
            break;

        case WM_DESTROY:
        {
            PWIZDATA         pwd;
            LPPROPSHEETPAGE  ppsp = GetDlgData(hWnd);

            if (ppsp && (pwd = (LPVOID)ppsp->lParam) != NULL)
            {
                if (pwd->mcl.hkMidi)
                    RegCloseKey (pwd->mcl.hkMidi), pwd->mcl.hkMidi = NULL;

               #ifdef USE_IDF_ICONS

                if (pwd->mcl.hIDFImageList)
                {
                    HWND hWndT = GetDlgItem (hWnd, IDC_TYPES);
                    if (hWndT)
                        TreeView_SetImageList (hWndT, NULL, TVSIL_NORMAL);

                    ImageList_Destroy (pwd->mcl.hIDFImageList);
                    pwd->mcl.hIDFImageList = NULL;
                }

               #endif

            }
        }
            break;

        default:
            bRet = FALSE;
            break;
    }

   #if defined DEBUG || defined DEBUG_RETAIL
    szNestLevel[0] = chNest;
   #endif
    return bRet;
}


INT CALLBACK
iSetupDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{
    switch( uMsg )
    {
        case PSCB_INITIALIZED:
            break;

        case PSCB_PRECREATE:
            if( lParam ){
                DLGTEMPLATE *pDlgTemplate = (DLGTEMPLATE *)lParam;
                pDlgTemplate->style &= ~DS_CONTEXTHELP;
            }
            break;
    }

    return FALSE;
}

/*+ MidiInstrumentsWizard
 *
 *-=================================================================*/

INT_PTR MidiInstrumentsWizard (
    HWND    hWnd,
    PMCMIDI pmcm,       // optional
    LPTSTR  pszDriverKey) // optional
{
    WIZDATA         wd;
    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;
    UINT            ii;
    INT_PTR         iRet = -1;
    LPTSTR          psz;

    ZeroMemory (&wd, sizeof(wd));
    wd.mcl.bDetails = TRUE;
    wd.mcl.bRemote = TRUE;
    wd.mcl.ixDevice = 0;
    LoadString (ghInstance, IDS_DEF_DEFINITION, wd.mcl.szFile,
                NUMELMS(wd.mcl.szFile));

    // set the default driver key to what was passed.
    // If someone passed us a path, rather than a driver key
    // null out the '\\' characters so that we see only the
    // leading driver part of the key.
    //
    wd.mcl.pszKey = wd.mcl.szFullKey;
    if (pszDriverKey)
       lstrcpy (wd.mcl.szFullKey, pszDriverKey);
    if (!lstrnicmp (wd.mcl.pszKey, (LPTSTR)cszMidiSlash, lstrlen(cszMidiSlash)))
        wd.mcl.pszKey += lstrlen(cszMidiSlash);
    psz = wd.mcl.pszKey;
    while (*psz)
    {
        if (*psz == TEXT('\\'))
            *psz = 0;
        ++psz;
    }

    // load all current instrument names from the registry
    //
    if (!(wd.pmcm = pmcm))
    {
        wd.pmcm = (LPVOID) LocalAlloc (LPTR, sizeof(MCMIDI));
		if (!wd.pmcm) return -1;
        LoadInstruments (wd.pmcm, FALSE);
    }

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = ghInstance;
    psp.pfnDlgProc = MidiWizardDlgProc;
    psp.lParam = (LPARAM)&wd;

    for (psh.nPages = 0, ii = 0; ii < NUMELMS(aidWiz); ++ii)
    {
        HPROPSHEETPAGE hpsp;

        psp.pszTemplate = aidWiz[ii];
        wd.ahpsp[psh.nPages] = hpsp = CreatePropertySheetPage(&psp);
        if (hpsp)
            ++psh.nPages;
    }

    if ( ! psh.nPages)
        return -1;

    wd.hBmp = LoadBitmap(ghInstance, MAKEINTRESOURCE(IDB_WIZBMP));
#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("Wizard bitmap = %08X\r\n"));
#endif

    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPTITLE | PSH_WIZARD_LITE | PSH_USECALLBACK;
    psh.hwndParent = hWnd;
    psh.hInstance = ghInstance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_WIZNAME);
    psh.nPages = NUMELMS(aidWiz);
    psh.nStartPage = 0;
    psh.phpage = wd.ahpsp;
    psh.pfnCallback = iSetupDlgCallback;

    iRet = PropertySheet (&psh);

    // free dynamically allocated stuff.
    //
    if (wd.hBmp)
       DeleteObject (wd.hBmp);

    // if no MCMIDI was passed, we dynamically loaded one,
    // so now we need to free it.
    //
    if ( ! pmcm)
    {
        if (wd.pmcm->hkMidi)
            RegCloseKey (wd.pmcm->hkMidi);
        FreeInstruments (wd.pmcm);
        LocalFree ((HLOCAL)(UINT_PTR)(DWORD_PTR)wd.pmcm);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\debug.c ===
#include <windows.h>
#include <string.h>
#include <stdio.h>

void OutputDebugLog(PWSTR buf)
{
    ULONG Bytes;
    char str[2048];
    static HANDLE hFile = NULL;

    Bytes = wcslen( buf );

    WideCharToMultiByte(CP_ACP,
                        0,
                        buf,
                        -1,
                        str,
                        Bytes + 4,
                        NULL,
                        NULL
                       );

    if (hFile == NULL)
    {
        WCHAR LogFileName[MAX_PATH];

        if (!GetWindowsDirectory( LogFileName, sizeof(LogFileName)/sizeof(WCHAR))) LogFileName[0] = '\0';
        wcscat( LogFileName, L"\\mmsyslog.txt" );
        hFile = CreateFile(
                          LogFileName,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                          NULL
                          );
        SetFilePointer(hFile,0,NULL,FILE_END);
    }

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    WriteFile(
             hFile,
             str,
             Bytes,
             &Bytes,
             NULL
             );

    return;
}

void
    DebugLog(
            PWSTR FileName,
            ULONG LineNumber,
            PWSTR FormatStr,
            ...
            )
{
    WCHAR buf[2048];
    PWSTR s,p;
    SYSTEMTIME CurrTime;

    va_list arg_ptr;

    GetSystemTime( &CurrTime );

    _try
    {
        p = buf;
        *p = 0;
        swprintf( p, L"%02d:%02d:%02d.%03d ",
                  CurrTime.wHour,
                  CurrTime.wMinute,
                  CurrTime.wSecond,
                  CurrTime.wMilliseconds
                );
        p += wcslen(p);
        if (FileName && LineNumber)
        {
            s = wcsrchr( FileName, L'\\' );
            if (s)
            {
                wcscpy( p, s+1 );
                p += wcslen(p);
                swprintf( p, L" @ %d ", LineNumber );
                p += wcslen(p);
            }
        }
        va_start( arg_ptr, FormatStr );
        wvsprintf(p,FormatStr,arg_ptr);
        va_end( arg_ptr );
        p += wcslen(p);
        wcscat( p, L"\r\n" );
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        buf[0] = 0;
    }

    if (buf[0] == 0)
    {
        return;
    }

    OutputDebugLog(buf);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\debug.h ===
#ifndef _debug_h_
    #define _debug_h_

void OutputDebugLog(PWSTR buf);
void DebugLog(PWSTR FileName,ULONG LineNumber,PWSTR FormatStr,...);

    #ifdef DBG
        #define dlog(_fmt_)                            DebugLog(TEXT(__FILE__),__LINE__,TEXT(_fmt_))
        #define dlog1(_fmt_,_arg1_)                    DebugLog(TEXT(__FILE__),__LINE__,TEXT(_fmt_),_arg1_)
        #define dlog2(_fmt_,_arg1_,_arg2_)             DebugLog(TEXT(__FILE__),__LINE__,TEXT(_fmt_),_arg1_,_arg2_)
        #define dlog3(_fmt_,_arg1_,_arg2_,_arg3_)      DebugLog(TEXT(__FILE__),__LINE__,TEXT(_fmt_),_arg1_,_arg2_,_arg3_)

        #define dlogt(_fmt_)                           DebugLog(TEXT(__FILE__),__LINE__,_fmt_)
    #else
        #define dlog(_fmt_)
        #define dlog1(_fmt_,_arg1_)
        #define dlog2(_fmt_,_arg1_,_arg2_)
        #define dlog3(_fmt_,_arg1_,_arg2_,_arg3_)

        #define dlogt(_fmt_)
    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\draw.h ===
/*
 **************************************************************************
 *	 
 *	 draw.h header file
 *
 * 
 *
 ***************************************************************************
 */

#include <mmsystem.h>

// Function Prototypes

LRESULT PASCAL			dfDispFrameWndFn(HWND,UINT,WPARAM,LPARAM);
BOOL PASCAL			RegSndCntrlClass(LPCTSTR);
BOOL				dfDrawRect(HDC, RECT);
BOOL                DIBInfo(HANDLE hbi,LPBITMAPINFOHEADER lpbi);
HPALETTE            CreateBIPalette(LPBITMAPINFOHEADER lpbi);
WORD                PaletteSize(VOID FAR * pv);
WORD				NumDIBColors (VOID FAR * pv);
WORD        WINAPI  bmfGetNumDIBs(LPTSTR lpszFile);
WORD        WINAPI  bmfNumDIBColors(HANDLE hDib);
HPALETTE    WINAPI  bmfCreateDIBPalette(HANDLE hDib);
HANDLE      WINAPI  bmfDIBFromBitmap(HBITMAP hBmp, DWORD biStyle,
                                     WORD biBits,HPALETTE hPal);
HBITMAP     WINAPI  bmfBitmapFromDIB(HANDLE hDib, HPALETTE hPal);
HBITMAP     WINAPI  bmfBitmapFromIcon (HICON hIcon, DWORD dwColor);
BOOL        WINAPI  bmfDrawBitmap(HDC hdc, int xpos, int ypos,
                                  HBITMAP hBmp, DWORD rop);
DWORD       WINAPI  bmfDIBSize(HANDLE hDIB);
BOOL        WINAPI  bmfDrawBitmapSize (HDC hdc, int xpos, int ypos,
                    int xSize, int ySize, HBITMAP hBmp, DWORD rop);

// Defines

#define DF_DISP_EXTRA       8
#define DF_GET_BMPHANDLE    (HBITMAP)(GetWindowLongPtr(hWnd, 0))
#define DF_SET_BMPHANDLE(x) (SetWindowLongPtr(hWnd, 0, (LONG_PTR)(x)))
#ifndef _WIN64
#define DF_GET_BMPPAL       (HPALETTE)(GetWindowLong(hWnd, 4))
#define DF_SET_BMPPAL(x)    (SetWindowLong(hWnd, 4, (LONG)(x)))
#else
#define DF_GET_BMPPAL       (HPALETTE)(GetWindowLongPtr(hWnd, sizeof(UINT_PTR)))
#define DF_SET_BMPPAL(x)    (SetWindowLongPtr(hWnd, sizeof(UINT_PTR), (LONG_PTR)(x)))
#endif

/* Help Macros */
#define DF_MID(x,y)         (((x)+(y))/2)

#define DISPICONCLASS       TEXT("WSS_DispIcon")
#define DISPFRAMCLASS       TEXT("WSS_DispFrame")

/* Header signatutes for various resources */
#define BFT_ICON   0x4349   /* 'IC' */
#define BFT_BITMAP 0x4d42   /* 'BM' */
#define BFT_CURSOR 0x5450   /* 'PT' */

/* macro to determine if resource is a DIB */
#define ISDIB(bft) ((bft) == BFT_BITMAP)

/* Macro to align given value to the closest DWORD (unsigned long ) */
#define ALIGNULONG(i)   (((i)+3)/4*4)

/* Macro to determine to round off the given value to the closest byte */
#define WIDTHBYTES(i)   (((i)+31)/32*4)

#define PALVERSION      0x300
#define MAXPALETTE  256   /* max. # supported palette entries */


//******** DISPFRAM ********************************************************

// DispFrame Control messages.

#define DF_PM_SETBITMAP    (WM_USER+1)

/* Parent Window Message string */

#define  DF_WMDISPFRAME    TEXT("PM_DISPFRAME")

#define DISP_DIB_CHUNK  1
#define DISP_TEXT_CHUNK 2
#define LIST_INFO_CHUNK 4

#define MAXDESCSIZE         4095
#define MAXLABELSIZE        255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\dispfram.c ===
/*
 **************************************************************************
 *
 *  dispfram.c
 *
 *  DispFrame Control DLL defines a bitmap display control to be used
 *  by any windows application.
 *
 *  Copyright 1991-3, Microsoft Corporation
 *
 *  History:
 *
 *  In Sik Rhee - 7/15/91 (original slider.dll)
 *  Ben Mejia - 1/22/92 (made display.dll)	 
 **************************************************************************
 */
#pragma warning(disable:4704)
#include <windows.h>
#include <custcntl.h>
#include <commctrl.h>
#include "draw.h"

/*
 **************************************************************************
 * global static variables 
 **************************************************************************
 */
UINT				gwPm_DispFrame;
extern HINSTANCE	ghInstance;


/*
 **************************************************************************
 * prototypes 
 **************************************************************************
 */

LONG PASCAL dfPaint				(HWND hWnd);
LONG PASCAL dfSetBitmap			(HWND hWnd, HBITMAP hBmpNew, HPALETTE 
																hPalNew);
BOOL PASCAL RegSndCntrlClass	(LPCTSTR lpszSndCntrlClass);
LRESULT PASCAL dfDispFrameWndFn	(HWND hWnd, UINT wMessage, WPARAM wParam, 
																LPARAM lParam);
BOOL dfDrawRect					(HDC hdcRect, RECT rFrame);

/*
 **************************************************************************
 * RegSndCntrlClass
 *
 * Description: Registers the SndCntrlClass, must be called in LibMain
 *
 * Arguments:
 *   LPTSTR		lpszSndCntrlClass
 *
 *  Returns:	BOOL
 *      TRUE if RegisterClass succeeds, else FALSE
 *
 **************************************************************************
 */
BOOL PASCAL RegSndCntrlClass(LPCTSTR lpszSndCntrlClass)
{

    extern UINT     gwPm_DispFrame;

    /* local variables */
    WNDCLASS    ClassStruct;

    /* check to see if class already exists;  if so, simply return TRUE */
    if (GetClassInfo(ghInstance, lpszSndCntrlClass, &ClassStruct))
        return TRUE;

	/* define dispfram class attributes */
	ClassStruct.lpszClassName   = (LPTSTR)DISPFRAMCLASS;
	ClassStruct.hCursor         = LoadCursor( NULL, IDC_ARROW );
	ClassStruct.lpszMenuName    = (LPTSTR)NULL;
	ClassStruct.style           = CS_HREDRAW|CS_VREDRAW|CS_GLOBALCLASS;
	ClassStruct.lpfnWndProc     = dfDispFrameWndFn;
	ClassStruct.hInstance       = ghInstance;
	ClassStruct.hIcon           = NULL;
	ClassStruct.cbWndExtra      = DF_DISP_EXTRA;
	ClassStruct.cbClsExtra      = 0;
	ClassStruct.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1 );

	/* register display frame window class */
	if (!RegisterClass(&ClassStruct))
		return FALSE;
	gwPm_DispFrame = RegisterWindowMessage((LPTSTR) DF_WMDISPFRAME);

	if (!gwPm_DispFrame)    /* failed to create message */
		return FALSE;
	return TRUE;
}

/*
 **************************************************************************
 * dfDispFrameWndFn
 * 
 * Description:   Window function for display frame control.
 *
 * Arguments:     
 *	 HWND	hWnd - handle to control window.
 *   UINT	wMessage - the message
 *   WPARAM	wParam
 *   LPARAM	lParam
 * Returns: LONG
 *     result of message processing... depends on message sent.
 * 
 **************************************************************************
 */

LRESULT PASCAL dfDispFrameWndFn(HWND hWnd, UINT wMessage, WPARAM wParam, 
																LPARAM lParam)
{
	HBITMAP		hBmp;

    switch (wMessage)
    {
    case WM_CREATE:
        DF_SET_BMPHANDLE(0);
        DF_SET_BMPPAL(0);
        return 0;

    case WM_DESTROY:
		/* Free up stored bitmap and palette, if any.
		*/
		hBmp = (HBITMAP)DF_GET_BMPHANDLE;
		if (hBmp)
	        DeleteObject(hBmp);
        return 0;

	case WM_SYSCOLORCHANGE:
		InvalidateRect(hWnd, NULL, TRUE);
		return 0;

    case WM_PAINT:
		return dfPaint(hWnd);

    /* Custom Control Messages */
    case DF_PM_SETBITMAP:
		return dfSetBitmap(hWnd, (HBITMAP)wParam, (HPALETTE)lParam);
    }
    return DefWindowProc(hWnd, wMessage, wParam, lParam);
}

/*
 **************************************************************************
 * dfDrawRect
 *
 * Description:  Draws background of control window.
 *
 * Params:     
 *   HWND	hWnd - handle to control window.
 *   RECT	rFrame - bounding rectangle.
 *
 * Returns:    BOOL
 *	Pass/Fail indicator 0 indicates failure.
 **************************************************************************	 
 */
BOOL dfDrawRect(HDC hdcRect, RECT rFrame)
{
    HANDLE      hBrush;
    HANDLE      hOldBrush;
    HANDLE      hPen;
    HANDLE      hOldPen;
    HANDLE      hPen3DHILIGHT;
											    
    /* Get DC's pen and brush for frame redraw
    */
    hBrush = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
    if (!hBrush)
        return FALSE;
	hPen = CreatePen(PS_SOLID, 2, GetSysColor(COLOR_WINDOWFRAME));

	if (!hPen)
	{
		DeleteObject(hBrush);
		return FALSE;
	}

	hPen3DHILIGHT = CreatePen(PS_SOLID, 2, GetSysColor(COLOR_3DHILIGHT));

	if (!hPen3DHILIGHT)
	{
		DeleteObject(hBrush);
		DeleteObject(hPen);
		return FALSE;
	}
    hOldBrush = SelectObject(hdcRect, hBrush);
    //hOldPen = SelectObject(hdcRect, hPen);
	hOldPen = SelectObject(hdcRect, hPen3DHILIGHT);

	/* paint the window.
	*/
    //Rectangle(hdcRect, rFrame.left, rFrame.top, rFrame.right,
    //    rFrame.bottom);
	MoveToEx(hdcRect, rFrame.left,rFrame.bottom, NULL);
	LineTo(hdcRect, rFrame.right,rFrame.bottom);
	LineTo(hdcRect, rFrame.right,rFrame.top);
	SelectObject(hdcRect, hPen);
	LineTo(hdcRect, rFrame.left,rFrame.top);
	LineTo(hdcRect, rFrame.left,rFrame.bottom);
	SelectObject(hdcRect, hOldPen);
	SelectObject(hdcRect, hOldBrush);

    /*clean up brush and pen */
    //DeleteObject();
    DeleteObject(hBrush);
    DeleteObject(hPen3DHILIGHT);
    DeleteObject(hPen);
    return TRUE;
}

/*
 **************************************************************************
 * dfPaint
 *
 * Description:   Paints background and bitmap, if any.
 *
 * Params:     
 *    HWND	hWnd - handle to control window
 *		 
 * Returns: LONG   
 *			0 if OK, -1 otherwise. (for windproc return)
 * 
 **************************************************************************
 */
LONG PASCAL dfPaint(HWND hWnd)
{
	HBITMAP hBmp;
	HBITMAP hPrev;
	RECT rFrame;
	PAINTSTRUCT ps;
	HDC hdcMem;
	BITMAP bmp;
	int x, y, dx, dy;

	/* Setup to do the painting
	*/
 	if(!GetUpdateRect(hWnd,NULL,FALSE))
 		return 0L;
    BeginPaint(hWnd, &ps);
	GetClientRect(hWnd, &rFrame);
	hBmp = (HBITMAP)DF_GET_BMPHANDLE;
	if (hBmp)
	{
		hdcMem = CreateCompatibleDC(ps.hdc);
		if (!hdcMem)
		{
			EndPaint(hWnd, &ps);
			return -1L;
		}
		hPrev = SelectObject(hdcMem, hBmp);
	
		/* Get the size of the bitmap to center it in the frame.
		*/
		GetObject(hBmp, sizeof(BITMAP), (LPTSTR)&bmp);
		if (bmp.bmWidth > (rFrame.right-rFrame.left))
		{
			x = 0;
			dx = rFrame.right-rFrame.left;
		}
		else
		{
			x = ((rFrame.right-rFrame.left - bmp.bmWidth) >> 1);
			dx = bmp.bmWidth;
		}
		if (bmp.bmHeight > (rFrame.bottom-rFrame.top))
		{
			y = 0;
			dy = rFrame.bottom-rFrame.top;
		}
		else
		{
			y = ((rFrame.bottom-rFrame.top - bmp.bmHeight) >> 1);
			dy = bmp.bmHeight;
		}
	
		/* Draw the frame & background, then blt in the bitmap.
		*/
		dfDrawRect(ps.hdc, rFrame);
		BitBlt(ps.hdc, x, y, dx, dy, hdcMem, 0, 0, SRCCOPY);

		/* Cleanup and exit.
		*/
		SelectObject(hdcMem, hPrev);
		DeleteDC(hdcMem);
	}
	else
		/* if no bitmap, just repaint the background.
		*/
		dfDrawRect(ps.hdc, rFrame);
		
	EndPaint(hWnd, &ps);
	return 0L;
}


/*
 **************************************************************************
 * dfSetBitmap
 * 
 * Description:   Load a new bitmap into the control.
 *
 * Arguments:     
 *		HWND		hWnd - handle to control window.
 *		HBITMAP		hBmpNew - handle to new bitmap.
 *		HPALETTE	hPalNew - handle to new bitmap's palette (Optional).
 * Returns:			LONG
 *				0 for success; -1 if fails (for return by wndproc).
 * 
 **************************************************************************
 */
LONG PASCAL dfSetBitmap(HWND hWnd, HBITMAP hBmpNew, HPALETTE hPalNew)
{
	HBITMAP hBmp;
	HANDLE hPrev;
	HANDLE hPrevNew;
	HDC hdcMem;
	HDC hdcNew;
	HDC hDC;
	RECT rFrame;
	int dx, dy;
	BITMAP bmp;

	/* Cleanup any existing bitmap & palette
	*/
	hBmp = (HBITMAP)DF_GET_BMPHANDLE;
	if (hBmp)
		DeleteObject(hBmp);
    DF_SET_BMPHANDLE(0);
    DF_SET_BMPPAL(0);
	InvalidateRect(hWnd, NULL, TRUE);

	/* Copy the displayable portion of the bitmap into a private copy.
	*/
    if (hBmpNew)
    {
		/* get all the req'd DC's etc.
		*/
        hDC = GetDC(hWnd);
        hdcMem = CreateCompatibleDC(hDC);
        if (!hdcMem)
        {
            ReleaseDC(hWnd, hDC);
            return -1L;
        }
        hdcNew = CreateCompatibleDC(hDC);
        if (!hdcNew)
        {
            ReleaseDC(hWnd, hDC);
            return -1L;
        }
        GetObject(hBmpNew, sizeof(BITMAP), (LPTSTR)&bmp);
        hBmp = CreateCompatibleBitmap(hDC, bmp.bmWidth, bmp.bmHeight);
        if (!hBmp)
        {
            DeleteDC(hdcMem);
            DeleteDC(hdcNew);
            ReleaseDC(hWnd, hDC);
            return -1L;
        }
  	    hPrevNew = SelectObject(hdcNew, hBmpNew);
        hPrev = SelectObject(hdcMem, hBmp);

		/* figure out how much of the bitmap we need to copy.
		*/    
		GetClientRect(hWnd, &rFrame);
        if (bmp.bmWidth > (rFrame.right-rFrame.left))
            dx = rFrame.right-rFrame.left;
        else
            dx = bmp.bmWidth;
        if (bmp.bmHeight > (rFrame.bottom-rFrame.top))
            dy = rFrame.bottom-rFrame.top;
        else
            dy = bmp.bmHeight;

		/* copy the bitmap.
		*/
        BitBlt(hdcMem, 0, 0, dx, dy, hdcNew, 0 , 0, SRCCOPY);

		/* cleanup
		*/
		hBmp = SelectObject(hdcMem, hPrev);
        DF_SET_BMPHANDLE(hBmp);
		DeleteDC(hdcMem);
		SelectObject(hdcNew, hPrevNew);
		DeleteDC(hdcNew);
		ReleaseDC(hWnd, hDC);

		/* if a palette is handed in, store it too.
		*/
	    DF_SET_BMPPAL(hPalNew);
   }
   return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\dib.c ===
/****************************************************************************
 *
 *  MODULE  : DIB.C
 *
 *  DESCRIPTION : Routines for dealing with Device Independent Bitmaps.
 *
 *  FUNCTION   :bmfNumDIBColors(HANDLE hDib)
 *
 *  FUNCTION   :bmfCreateDIBPalette(HANDLE hDib)
 *
 *  FUNCTION   :bmfDIBSize(HANDLE hDIB)
 *
 *  FUNCTION   :bmfDIBFromBitmap(HBITMAP hBmp, DWORD biStyle, WORD biBits,
 *                               HPALETTE hPal)
 *
 *  FUNCTION   :bmfBitmapFromDIB(HANDLE hDib, HPALETTE hPal)
 *
 *  FUNCTION   :bmfBitmapFromIcon (HICON hIcon, DWORD dwColor)
 *
 *  FUNCTION   :bmfDrawBitmap(HDC hdc, int xpos, int ypos, HBITMAP hBmp,
 *                            DWORD rop)
 *
 *  FUNCTION   :bmfDrawBitmapSize(HDC hdc, int x, int y, int xSize,
 *                                int ySize, HBITMAP hBmp, DWORD rop)
 *
 *  FUNCTION   :DIBInfo(HANDLE hbi,LPBITMAPINFOHEADER lpbi)
 *
 *  FUNCTION   :CreateBIPalette(LPBITMAPINFOHEADER lpbi)
 *
 *  FUNCTION   :PaletteSize(VOID FAR * pv)
 *
 *  FUNCTION   :NumDIBColors(VOID FAR * pv)
 *
 *  FUNCTION   :LoadUIBitmap(HANDLE hInstance, LPCTSTR szName, 
 *							 COLORREF rgbText,
 *                           COLORREF rgbFace, COLORREF rgbShadow,
 *                           COLORREF rgbHighlight, COLORREF rgbWindow,
 *                           COLORREF rgbFrame)
 *
 ****************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <stdlib.h>
#include <shellapi.h>
#include "draw.h"

/* global variables */
extern      HANDLE        ghInstance;    //instance handle of DIB.DLL

/***************************************************************************
 *
 *  FUNCTION   :bmfNumDIBColors(HANDLE hDib)
 *
 *  PURPOSE    :Returns the number of colors required to display the DIB
 *              indicated by hDib.
 *
 *  RETURNS    :The number of colors in the DIB. Possibilities are
 *              2, 16, 256, and 0 (0 indicates a 24-bit DIB).  In
 *              the case of an error, -1 is returned.
 *
 ****************************************************************************/

WORD WINAPI bmfNumDIBColors (HANDLE hDib)
{
    WORD                bits;
    LPBITMAPINFOHEADER  lpbi;

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDib);
    if (!lpbi)
	return ((WORD)-1);

    /* The function NumDIBColors will return the number of colors in the
     * DIB by looking at the BitCount field in the info block
     */
    bits = NumDIBColors(lpbi);
    GlobalUnlock(hDib);
    return(bits);
}


/***************************************************************************
 *
 *  FUNCTION   :bmfCreateDIBPalette(HANDLE hDib)
 *
 *  PURPOSE    :Creates a palette suitable for displaying hDib.
 *
 *  RETURNS    :A handle to the palette if successful, NULL otherwise.
 *
 ****************************************************************************/

HPALETTE WINAPI bmfCreateDIBPalette (HANDLE hDib)
{
    HPALETTE            hPal;
    LPBITMAPINFOHEADER  lpbi;

    if (!hDib)
	return NULL;    //bail out if handle is invalid

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDib);
    if (!lpbi)
	return NULL;

    hPal = CreateBIPalette(lpbi);
    GlobalUnlock(hDib);
    return hPal;
}


/***************************************************************************
 *
 *  FUNCTION   :bmfDIBSize(HANDLE hDIB)
 *
 *  PURPOSE    :Return the size of a DIB.
 *
 *  RETURNS    :DWORD with size of DIB, include BITMAPINFOHEADER and
 *              palette.  Returns 0 if failed.
 *
 *  HISTORY:
 *  92/08/13 -  BUG 1642: (w-markd)
 *              Added this function so Quick Recorder could find out the
 *              size of a DIB.
 *  92/08/29 -  BUG 2123: (w-markd)
 *              If the biSizeImage field of the structure we get is zero,
 *              then we have to calculate the size of the image ourselves.
 *              Also, after size is calculated, we bail out if the 
 *              size we calculated is larger than the size of the global
 *              object, since this indicates that the structure data
 *              we used to calculate the size was invalid.
 *
 ****************************************************************************/

DWORD WINAPI bmfDIBSize(HANDLE hDIB)
{
    LPBITMAPINFOHEADER  lpbi;
    DWORD               dwSize;

    /* Lock down the handle, and cast to a LPBITMAPINFOHEADER
    ** so we can read the fields we need
    */
    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);
    if (!lpbi)
	return 0;

    /* BUG 2123: (w-markd)
    ** Since the biSizeImage could be zero, we may have to calculate
    ** the size ourselves.
    */
    dwSize = lpbi->biSizeImage;
    if (dwSize == 0)
	dwSize = WIDTHBYTES((WORD)(lpbi->biWidth) * lpbi->biBitCount) *
	    lpbi->biHeight;


    /* The size of the DIB is the size of the BITMAPINFOHEADER
    ** structure (lpbi->biSize) plus the size of our palette plus
    ** the size of the actual data (calculated above).
    */
    dwSize += lpbi->biSize + (DWORD)PaletteSize(lpbi);

    /* BUG 2123: (w-markd)
    ** Check to see if the size is greater than the size
    ** of the global object.  If it is, the hDIB is corrupt.
    */
    GlobalUnlock(hDIB);
    if (dwSize > GlobalSize(hDIB))
	return 0;
    else
	return(dwSize);
}


/***************************************************************************
 *
 *  FUNCTION   :bmfDIBFromBitmap(HBITMAP hBmp, DWORD biStyle, WORD biBits,
 *                               HPALETTE hPal)
 *
 *  PURPOSE    :Converts the device-dependent BITMAP indicated by hBmp into
 *              a DIB.  biStyle indicates whether the palette contains
 *              DIB_RGB_COLORS or DIB_PAL_COLORS.  biBits indicates the
 *              desired number of bits in the destination DIB.  If biBits
 *              is zero, the destination DIB will be created with the
 *              minimum required bits.  hPal is a handle to the palette to be
 *              stored with the DIB data.  If hPal is NULL, the default
 *              system palette is used.
 *
 *  RETURNS    :A global handle to a memory block containing the DIB
 *              information in CF_DIB format.  NULL is returned if errors
 *              are encountered.
 *
 *  HISTORY:
 *
 *  92/08/12 -  BUG 1642: (angeld)
 *              Check the return value from GetObject, it will tell us
 *              if the handle hBmp was valid. bail out right away if it isn't
 *  92/08/29 -  BUG 2123: (w-markd)
 *              Use temporary variable to store old palette, then
 *              reselect the old palette when we are done.
 *
 ****************************************************************************/

HANDLE WINAPI bmfDIBFromBitmap (HBITMAP hBmp, DWORD biStyle, WORD biBits,
				    HPALETTE hPal)
{
    BITMAP                  bm;
    BITMAPINFOHEADER        bi;
    BITMAPINFOHEADER FAR    *lpbi;
    DWORD                   dwLen;
    HANDLE                  hDib;
    HANDLE                  hMem;
    HDC                     hdc;
    HPALETTE                hOldPal;

    if (!hBmp || !(GetObject(hBmp,sizeof(bm),(LPSTR)&bm)))
	 {
#if DEBUG
	  OutputDebugString(TEXT("bmfDIBFromBitmap:   INVALID HBITMAP!!!\n\r"));
#endif          
	return NULL;    //bail out if handle is invalid
	 }

    /* get default system palette if hPal is invalid */
    if (hPal == NULL)
	hPal = GetStockObject(DEFAULT_PALETTE);

    if (biBits == 0)
	biBits =  bm.bmPlanes * bm.bmBitsPixel;

    /* set up BITMAPINFOHEADER structure */
    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = biStyle;
    bi.biSizeImage          = 0;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = 0;
    bi.biClrImportant       = 0;

    dwLen  = bi.biSize + PaletteSize(&bi);

    hdc = GetDC(NULL);
    /* BUG 2123: (w-markd)
    ** Store the previous palette in hOldPal, restore it on exit.
    */
    hOldPal = SelectPalette(hdc,hPal,FALSE);
    RealizePalette(hdc);

    /* get global memory for DIB */
    hDib = GlobalAlloc(GHND,dwLen);

    if (!hDib)
    {
	/* could not allocate memory; clean up and exit */
	SelectPalette(hdc,hOldPal,FALSE);
	ReleaseDC(NULL,hdc);
	return NULL;
    }

    lpbi = (VOID FAR *)GlobalLock(hDib);
    if (!lpbi)
    {
	/* could not lock memory; clean up and exit */
	SelectPalette(hdc,hOldPal,FALSE);
	ReleaseDC(NULL,hdc);
	GlobalFree(hDib);
	return NULL;
    }

    *lpbi = bi;

    /*  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */
    GetDIBits(hdc, hBmp, 0, (WORD)bi.biHeight,
	NULL, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    bi = *lpbi;
    GlobalUnlock(hDib);

    /* If the driver did not fill in the biSizeImage field, make one up */
    if (bi.biSizeImage == 0)
    {
	bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;

	if (biStyle != BI_RGB)
	    bi.biSizeImage = (bi.biSizeImage * 3) / 2;
    }

    /*  realloc the buffer big enough to hold all the bits */
    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;
    hMem = GlobalReAlloc(hDib,dwLen,GMEM_MOVEABLE);
    if (!hMem)
    {
	/* could not allocate memory; clean up and exit */
	GlobalFree(hDib);
	SelectPalette(hdc,hOldPal,FALSE);
	ReleaseDC(NULL,hdc);
	return NULL;
    }
    else
	hDib = hMem;

    /*  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */
    lpbi = (VOID FAR *)GlobalLock(hDib);
    if (!lpbi)
    {
	/* could not lock memory; clean up and exit */
	GlobalFree(hDib);
	SelectPalette(hdc,hOldPal,FALSE);
	ReleaseDC(NULL,hdc);
	return NULL;
    }

    if (GetDIBits( hdc, hBmp, 0, (WORD)bi.biHeight,
	   (LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize(lpbi),
	   (LPBITMAPINFO)lpbi, DIB_RGB_COLORS) == 0)
    {
	/* clean up and exit */
	GlobalUnlock(hDib);
	GlobalFree(hDib);
	SelectPalette(hdc,hOldPal,FALSE);
	ReleaseDC(NULL,hdc);
	return NULL;
    }

    bi = *lpbi;

    /* clean up and exit */
    GlobalUnlock(hDib);
    SelectPalette(hdc,hOldPal,FALSE);
    ReleaseDC(NULL,hdc);
    return hDib;
}


/***************************************************************************
 *
 *  FUNCTION   :bmfBitmapFromDIB(HANDLE hDib, HPALETTE hPal)
 *
 *  PURPOSE    :Converts DIB information into a device-dependent BITMAP
 *              suitable for display on the current display device.  hDib is
 *              a global handle to a memory block containing the DIB
 *              information in CF_DIB format.  hPal is a handle to a palette
 *              to be used for displaying the bitmap.  If hPal is NULL, the
 *              default system palette is used during the conversion.
 *
 *  RETURNS    :Returns a handle to a bitmap is successful, NULL otherwise.
 *
 *  HISTORY:
 *  92/08/29 -  BUG 2123: (w-markd)
 *              Check if DIB is has a valid size, and bail out if not.
 *              If no palette is passed in, try to create one.  If we
 *              create one, we must destroy it before we exit.
 *
 ****************************************************************************/

HBITMAP WINAPI bmfBitmapFromDIB(HANDLE hDib, HPALETTE hPal)
{
    LPBITMAPINFOHEADER  lpbi;
    HPALETTE            hPalT;
    HDC                 hdc;
    HBITMAP             hBmp;
    DWORD               dwSize;
    BOOL                bMadePalette = FALSE;

    if (!hDib)
	return NULL;    //bail out if handle is invalid
    
    /* BUG 2123: (w-markd)
    ** Check to see if we can get the size of the DIB.  If this call
    ** fails, bail out.
    */
    dwSize = bmfDIBSize(hDib);
    if (!dwSize)
	return NULL;

    lpbi = (VOID FAR *)GlobalLock(hDib);
    if (!lpbi)
	return NULL;

    /* prepare palette */
    /* BUG 2123: (w-markd)
    ** If the palette is NULL, we create one suitable for displaying
    ** the dib.
    */
    if (!hPal)
    {
	hPal = bmfCreateDIBPalette(hDib);
	if (!hPal)
	{
	    GlobalUnlock(hDib);
	    #ifdef V101
	    #else
	    bMadePalette = TRUE;
	    #endif
	    return NULL;
	}
	#ifdef V101
	/* BUGFIX: mikeroz 2123 - this flag was in the wrong place */
	bMadePalette = TRUE;
	#endif
    }
    hdc = GetDC(NULL);
    hPalT = SelectPalette(hdc,hPal,FALSE);
    RealizePalette(hdc);     // GDI Bug...????

    /* Create the bitmap.  Note that a return value of NULL is ok here */
    hBmp = CreateDIBitmap(hdc, (LPBITMAPINFOHEADER)lpbi, (LONG)CBM_INIT,
			  (LPSTR)lpbi + lpbi->biSize + PaletteSize(lpbi),
			  (LPBITMAPINFO)lpbi, DIB_RGB_COLORS );

    /* clean up and exit */
    /* BUG 2123: (w-markd)
    ** If we made the palette, we need to delete it.
    */
    if (bMadePalette)
	DeleteObject(SelectPalette(hdc,hPalT,FALSE));
    else
	SelectPalette(hdc,hPalT,FALSE);
    ReleaseDC(NULL,hdc);
    GlobalUnlock(hDib);
    return hBmp;
}


/***************************************************************************
 *
 *  FUNCTION   :bmfBitmapFromIcon (HICON hIcon, DWORD dwColor)
 *
 *  PURPOSE    :Converts an icon into a bitmap.  hIcon is a handle to a
 *              windows ICON object.  dwColor sets the background color for
 *              the bitmap.
 *
 *  RETURNS    :A handle to the bitmap is successful, NULL otherwise.
 *
 ****************************************************************************/


HBITMAP WINAPI bmfBitmapFromIcon (HICON hIcon, DWORD dwColor)
{
    HDC     hDC;
    HDC     hMemDC = 0;
    HBITMAP hBitmap = 0;
    HBITMAP hOldBitmap;
    HBRUSH  hBrush = 0;
    HBRUSH  hOldBrush;
    int     xIcon, yIcon;

    hDC = GetDC(NULL);
    hMemDC = CreateCompatibleDC( hDC );
    if (hMemDC)
    {
	/* get the size for the destination bitmap */
	xIcon = GetSystemMetrics(SM_CXICON);
	yIcon = GetSystemMetrics(SM_CYICON);
	hBitmap = CreateCompatibleBitmap(hDC, xIcon, yIcon);
	if (hBitmap)
	{
	    hBrush = CreateSolidBrush(dwColor);
	    if (hBrush)
	    {
		hOldBitmap = SelectObject (hMemDC, hBitmap);
		hOldBrush  = SelectObject (hMemDC, hBrush);

		/* draw the icon on the memory device context */
		PatBlt   (hMemDC, 0, 0, xIcon, yIcon, PATCOPY);
		DrawIcon (hMemDC, 0, 0, hIcon);

		/* clean up and exit */
		DeleteObject(SelectObject(hMemDC, hOldBrush));
		SelectObject(hMemDC, hOldBitmap);
		DeleteDC(hMemDC);
		ReleaseDC(NULL, hDC);
		return hBitmap;
	    }
	}
    }

    /* clean up resources and exit */
    if (hBitmap)
	DeleteObject(hBitmap);
    if (hMemDC)
	DeleteDC(hMemDC);
    ReleaseDC (NULL, hDC);
    return NULL;
}


/***************************************************************************
 *
 *  FUNCTION   :bmfDrawBitmap(HDC hdc, int xpos, int ypos, HBITMAP hBmp,
 *                            DWORD rop)
 *
 *  PURPOSE    :Draws bitmap hBmp at the specifed position in DC hdc
 *
 *  RETURNS    :Return value of BitBlt() or FALSE if in an error is
 *              encountered.  Note that BitBlt returns true if successful.
 *
 ****************************************************************************/

BOOL WINAPI bmfDrawBitmap (HDC hdc, int xpos, int ypos, HBITMAP hBmp,
			       DWORD rop)
{
    HDC       hdcBits;
    BITMAP    bm;
    BOOL      bResult;

    if (!hdc || !hBmp)
	return FALSE;

    hdcBits = CreateCompatibleDC(hdc);
    if (!hdcBits)
	return FALSE;
    GetObject(hBmp,sizeof(BITMAP),(LPSTR)&bm);
    SelectObject(hdcBits,hBmp);
    bResult = BitBlt(hdc,xpos,ypos,bm.bmWidth,bm.bmHeight,hdcBits,0,0,rop);
    DeleteDC(hdcBits);

    return bResult;
}


/***************************************************************************
 *
 *  FUNCTION   :DIBInfo(HANDLE hbi,LPBITMAPINFOHEADER lpbi)
 *
 *  PURPOSE    :Retrieves the DIB info associated with a CF_DIB
 *              format memory block.
 *
 *  RETURNS    :TRUE (non-zero) if successful;  FALSE (zero) otherwise.
 *
 ****************************************************************************/

BOOL DIBInfo (HANDLE hbi, LPBITMAPINFOHEADER lpbi)
{
    if (!hbi)
	return FALSE;

    *lpbi = *(LPBITMAPINFOHEADER)GlobalLock (hbi);
    if (!lpbi)
	return FALSE;
    /* fill in the default fields */
    if (lpbi->biSize != sizeof (BITMAPCOREHEADER))
    {
	if (lpbi->biSizeImage == 0L)
	    lpbi->biSizeImage =
	    WIDTHBYTES(lpbi->biWidth*lpbi->biBitCount) * lpbi->biHeight;
	if (lpbi->biClrUsed == 0L)
	    lpbi->biClrUsed = NumDIBColors (lpbi);
    }
    GlobalUnlock (hbi);
    return TRUE;
}

/***************************************************************************
 *
 *  FUNCTION   :CreateBIPalette(LPBITMAPINFOHEADER lpbi)
 *
 *  PURPOSE    :Given a Pointer to a BITMAPINFO struct will create a
 *              a GDI palette object from the color table.
 *
 *  RETURNS    :A handle to the palette if successful, NULL otherwise.
 *
 ****************************************************************************/

HPALETTE CreateBIPalette (LPBITMAPINFOHEADER lpbi)
{
    LPLOGPALETTE        pPal;
    HPALETTE            hPal = NULL;
    WORD                nNumColors;
    BYTE                red;
    BYTE                green;
    BYTE                blue;
    int                 i;
    RGBQUAD             FAR *pRgb;
    HANDLE hMem;

    if (!lpbi)
	return NULL;

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
	return NULL;

    /* Get a pointer to the color table and the number of colors in it */
    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->biSize);
    nNumColors = NumDIBColors(lpbi);

    if (nNumColors)
    {
	/* Allocate for the logical palette structure */
	hMem = GlobalAlloc(GMEM_MOVEABLE,
	sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));
	if (!hMem)
	    return NULL;
	pPal = (LPLOGPALETTE)GlobalLock(hMem);
	if (!pPal)
	{
	    GlobalFree(hMem);
	    return NULL;
	}

	pPal->palNumEntries = nNumColors;
	pPal->palVersion    = PALVERSION;

	/* Fill in the palette entries from the DIB color table and
	 * create a logical color palette.
	 */
	for (i = 0; (unsigned)i < nNumColors; i++)
	{
	    pPal->palPalEntry[i].peRed   = pRgb[i].rgbRed;
	    pPal->palPalEntry[i].peGreen = pRgb[i].rgbGreen;
	    pPal->palPalEntry[i].peBlue  = pRgb[i].rgbBlue;
	    pPal->palPalEntry[i].peFlags = (BYTE)0;
	}
	hPal = CreatePalette(pPal);
	/* note that a NULL return value for the above CreatePalette call
	 * is acceptable, since this value will be returned, and is not
	 * used again here
	 */
	GlobalUnlock(hMem);
	GlobalFree(hMem);
    }
    else if (lpbi->biBitCount == 24)
    {
	/* A 24 bitcount DIB has no color table entries so, set the number of
	 * to the maximum value (256).
	 */
	nNumColors = MAXPALETTE;
	hMem =GlobalAlloc(GMEM_MOVEABLE,
	sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));
	if (!hMem)
	    return NULL;
	pPal = (LPLOGPALETTE)GlobalLock(hMem);
	if (!pPal)
	{
	    GlobalFree(hMem);
	    return NULL;
	}

	pPal->palNumEntries = nNumColors;
	pPal->palVersion    = PALVERSION;

	red = green = blue = 0;

	/* Generate 256 (= 8*8*4) RGB combinations to fill the palette
	 * entries.
	 */
	for (i = 0; (unsigned)i < pPal->palNumEntries; i++)
	{
	    pPal->palPalEntry[i].peRed   = red;
	    pPal->palPalEntry[i].peGreen = green;
	    pPal->palPalEntry[i].peBlue  = blue;
	    pPal->palPalEntry[i].peFlags = (BYTE)0;

	    if (!(red += 32))
	    if (!(green += 32))
		blue += 64;
	}
	hPal = CreatePalette(pPal);
	/* note that a NULL return value for the above CreatePalette call
	 * is acceptable, since this value will be returned, and is not
	 * used again here
	 */
	GlobalUnlock(hMem);
	GlobalFree(hMem);
    }
    return hPal;
}
/***************************************************************************
 *
 *  FUNCTION   :PaletteSize(VOID FAR * pv)
 *
 *  PURPOSE    :Calculates the palette size in bytes. If the info. block
 *              is of the BITMAPCOREHEADER type, the number of colors is
 *              multiplied by 3 to give the palette size, otherwise the
 *              number of colors is multiplied by 4.
 *
 *  RETURNS    :Palette size in number of bytes.
 *
 ****************************************************************************/

WORD PaletteSize (VOID FAR *pv)
{
    LPBITMAPINFOHEADER  lpbi;
    WORD                NumColors;

    lpbi      = (LPBITMAPINFOHEADER)pv;
    NumColors = NumDIBColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	return (NumColors * sizeof(RGBTRIPLE));
    else
	return (NumColors * sizeof(RGBQUAD));
}


/***************************************************************************
 *
 *  FUNCTION   :NumDIBColors(VOID FAR * pv)
 *
 *  PURPOSE    :Determines the number of colors in the DIB by looking at
 *              the BitCount field in the info block.
 *              For use only internal to DLL.
 *
 *  RETURNS    :The number of colors in the DIB.
 *
 ****************************************************************************/

WORD NumDIBColors (VOID FAR * pv)
{
    int                 bits;
    LPBITMAPINFOHEADER  lpbi;
    LPBITMAPCOREHEADER  lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
	if (lpbi->biClrUsed != 0)
	    return (WORD)lpbi->biClrUsed;
	bits = lpbi->biBitCount;
    }
    else
	bits = lpbc->bcBitCount;

    switch (bits)
    {
    case 1:
	return 2;
    case 4:
	return 16;
    case 8:
	return 256;
    default:
	/* A 24 bitcount DIB has no color table */
	return 0;
    }
}


/***************************************************************************
 *
 *  FUNCTION   :bmfDrawBitmapSize(HDC hdc, int x, int y, int xSize,
 *              int ySize, HBITMAP hBmp, DWORD rop)
 *
 *  PURPOSE    :Draws bitmap <hBmp> at the specifed position in DC <hdc> with
 *              a specified size.
 *
 *  RETURNS    :Return value of BitBlt() or false in an error is
 *              encountered.  Note that BitBlt returns true if successful.
 *
 *  HISTORY:
 *  92/08/13 -  BUG 1642: (w-markd)
 *              Exported this function.
 *              Also stored object that was returned from SelectObject,
 *              and selected this back into the hdc before deleting.
 *
 ****************************************************************************/

BOOL WINAPI bmfDrawBitmapSize (HDC hdc, int xpos, int ypos, int xSize, int ySize, HBITMAP hBmp, DWORD rop)
{
    HDC         hdcBits;
    BOOL        bResult;
    HBITMAP     hOldBmp;

    if (!hdc || !hBmp)
	return FALSE;

    hdcBits = CreateCompatibleDC(hdc);
    if (!hdcBits)
	return FALSE;
    /* BUG 1642: (w-markd)
    ** Remeber old bmp and reselect into hdc before DeleteDC
    */
    hOldBmp = SelectObject(hdcBits,hBmp);
    bResult = BitBlt(hdc,xpos,ypos,xSize, ySize,hdcBits, 0,0,rop);
    SelectObject(hdcBits, hOldBmp);
    DeleteDC(hdcBits);

    return bResult;
}

//----------------------------------------------------------------------------
//  LoadUIBitmap() - load a bitmap resource
//
//      load a bitmap resource from a resource file, converting all
//      the standard UI colors to the current user specifed ones.
//
//      this code is designed to load bitmaps used in "gray ui" or
//      "toolbar" code.
//
//      the bitmap must be a 4bpp windows 3.0 DIB, with the standard
//      VGA 16 colors.
//
//      the bitmap must be authored with the following colors
//
//          Button Text        Black        (index 0)
//          Button Face        lt gray      (index 7)
//          Button Shadow      gray         (index 8)
//          Button Highlight   white        (index 15)
//          Window Color       yellow       (index 11)
//          Window Frame       green        (index 10)
//
//      Example:
//
//          hbm = LoadUIBitmap(hInstance, "TestBmp",
//              GetSysColor(COLOR_BTNTEXT),
//              GetSysColor(COLOR_BTNFACE),
//              GetSysColor(COLOR_BTNSHADOW),
//              GetSysColor(COLOR_BTNHIGHLIGHT),
//              GetSysColor(COLOR_WINDOW),
//              GetSysColor(COLOR_WINDOWFRAME));
//
//      Author:     JimBov, ToddLa
//      History:    5/13/92 - added to dib.c in sndcntrl.dll, t-chrism
//
//----------------------------------------------------------------------------
HBITMAP WINAPI LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
    LPCTSTR      szName,             // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame)           // color to use for "Window Frame"
{
    LPBYTE              lpb;
    HBITMAP             hbm;
    LPBITMAPINFOHEADER  lpbi = NULL;
    HANDLE              h;
    HDC                 hdc;
    LPDWORD             lprgb;
    HRSRC               hrsrc;

    // convert a RGB into a RGBQ
    #define RGBQ(dw) RGB(GetBValue(dw),GetGValue(dw),GetRValue(dw))

    hrsrc = FindResource(hInstance, szName, RT_BITMAP);
    if (hrsrc)
    {
        h = LoadResource(hInstance,hrsrc);
        if (h)
            lpbi = (LPBITMAPINFOHEADER)LockResource(h);
    }

    if (!lpbi)
	return(NULL);

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
	return NULL;

    if (lpbi->biBitCount != 4)
	return NULL;

    lprgb = (LPDWORD)((LPBYTE)lpbi + (int)lpbi->biSize);
    lpb   = (LPBYTE)(lprgb + 16);

    lprgb[0]  = RGBQ(rgbText);          // Black
    lprgb[7]  = RGBQ(rgbFace);          // lt gray
    lprgb[8]  = RGBQ(rgbShadow);        // gray
    lprgb[15] = RGBQ(rgbHighlight);     // white
    lprgb[11] = RGBQ(rgbWindow);        // yellow
    lprgb[10] = RGBQ(rgbFrame);         // green

    hdc = GetDC(NULL);

    hbm = CreateDIBitmap(hdc, lpbi, CBM_INIT, (LPVOID)lpb,
	(LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    ReleaseDC(NULL, hdc);
    UnlockResource(h);
    FreeResource(h);
    return(hbm);
}// LoadUIBitmap
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\drivers.h ===
/*  DRIVERS.H
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**
**  Multimedia Control Panel Drivers Applet.
**
**  Display a list of all installed drivers, allow user to configure
**  existing or install new ones.
**
*/
#include "dlgs.h"
#include "commdlg.h"
#include <commctrl.h>
#include "mmcpl.h"
#include <setupapi.h>

#define SECTION         512                   // Maximum size of section
#define MAXSTR          256
#define DLG_BROWSE      38
#define UNLIST_LINE     1
#define NO_UNLIST_LINE  0
#define WEC_RESTART     0x42
#define DESC_ERROR		4
#define DESC_SYS        3
#define DESC_INF        2
#define DESC_EXE        1
#define DESC_NOFILE     0
#define MAXDRVSTR       80 // Warning - Making this constant bigger could cause a buffer overflow

#define dwStatusHASSERVICE   0x00000001  // bit set if driver has service
#define dwStatusSvcENABLED   0x00000002  // bit set if has -enabled- service
#define dwStatusSvcSTARTED   0x00000004  // bit set if has now-running service
#define dwStatusDRIVEROK     0x00000008  // bit set if !svc and can open driver
#define dwStatusMAPPABLE     0x00000010  // bit set if doesn't have Mappable=0

#ifndef cchRESOURCE
#define cchRESOURCE     256
#endif

typedef struct _IDRIVER
{
    WCHAR   wszSection[MAXSTR];
    WCHAR   wszAlias[MAXSTR];
    WCHAR   wszFile[MAX_PATH];
    TCHAR    szSection[MAXSTR];
    TCHAR    szAlias[MAXSTR];
    TCHAR    szFile[MAX_PATH];
    TCHAR    szDesc[MAXSTR];
    struct  _IDRIVER *related;
    BOOL    bRelated;
    TCHAR    szRelated[MAXSTR];
    TCHAR    szRemove[MAXSTR];
    int     fQueryable;     // 0 -> can't, 1 -> can, -1 -> need to check
    BOOL    bInstall;       // 0 -> no,    1 -> yes
    BOOL    KernelDriver;   // If TRUE this is a kernel driver, not an
                            // 'installable' driver so it can't be opened,
                            // process messages etc.
#ifdef INFFILE
    BOOL    infFileProcessing;
#endif // INFFILE

    LPARAM  lp;
} IDRIVER, *PIDRIVER;

typedef enum    // DriverClass (in no particular order)
{
    dcINVALID = -1,
    dcAUX = 0,   // Aux devices
    dcMIDI,  // MIDi devices, MIDI mapper
    dcMIXER, // Mixer devices
    dcWAVE,  // Wave audio devices, Wave mapper
    dcACODEC,    // Audio codecs
    dcVCODEC,    // Video codecs
    dcMCI,   // MCI devices
    dcVIDCAP,    // Video capture devices
    dcJOY,   // Joystick devices
    dcLEGACY,    // Legacy Devices for wave, midi and mixer
    dcOTHER  // Any unknown device
} DriverClass;

typedef struct _DevTreeNode // legacy from win95 devpropsheet code
{
    HWND hwndTree;
    LPARAM lParam;
} DEVTREENODE, * PDEVTREENODE;

extern HANDLE         myInstance;
extern TCHAR           szNULL[];
extern TCHAR           szDrivers[];
extern TCHAR           szBoot[];
extern TCHAR           szDriversHlp[];
extern TCHAR           szAppName[];
extern TCHAR           szUnlisted[];
extern TCHAR           szFullPath[];
extern TCHAR           szOemInf[];
extern TCHAR           szDirOfSrc[];
extern TCHAR           szUserDrivers[];
extern TCHAR           szControlIni[];
extern TCHAR           szDriversDesc[];
extern TCHAR           szSetupInf[];
extern TCHAR           szSysIni[];
extern TCHAR           szMCI[];
extern TCHAR           szRestartDrv[MAXDRVSTR];
extern TCHAR           szRelated[];
extern TCHAR           szNULL[];
extern TCHAR           szBackslash[];
extern TCHAR           szOutOfRemoveSpace[];
extern TCHAR           szKnown[];
extern TCHAR           szRelatedDesc[];
extern TCHAR           szDrv[];
extern TCHAR           szRemove[];
extern TCHAR           szSystem[];
extern TCHAR           szSystemDrivers[];
extern int            iRestartMessage;
extern UINT           wHelpMessage;
extern DWORD          dwContext;
extern BOOL           bCopyVxD;
extern BOOL           bVxd;
extern BOOL           bInstallBootLine;
extern BOOL           bFindOEM;
extern BOOL           bRestart;
extern BOOL           bCopyingRelated;
extern BOOL           bRelated;
extern HWND           hAdvDlgTree;
extern BOOL           IniFileReadAllowed;
extern BOOL           IniFileWriteAllowed;

//------------------------------------------------------------------------
//
// Public routines
//
//------------------------------------------------------------------------
extern void RemoveDriverEntry   (LPTSTR, LPTSTR, LPTSTR, BOOL);
extern int  FileNameCmp         (TCHAR *, TCHAR *);
extern void OpenDriverError     (HWND, LPTSTR, LPTSTR);
extern void RemoveSpaces        (LPTSTR, LPTSTR);
extern INT_PTR RestartDlg          (HWND, unsigned, WPARAM, LPARAM);
extern INT_PTR AddDriversDlg       (HWND, unsigned, WPARAM, LPARAM);
extern INT_PTR AddUnlistedDlg      (HWND, unsigned, WPARAM, LPARAM);
extern BOOL mmAddNewDriver      (LPTSTR, LPTSTR, PIDRIVER);
extern LONG_PTR PostRemove          (PIDRIVER, BOOL);
extern BOOL RemoveService       (LPTSTR);
extern BOOL CopyToSysDir        (void);
extern BOOL InstallDrivers      (HWND, HWND, LPTSTR);
extern void InitDrvConfigInfo   (LPDRVCONFIGINFO, PIDRIVER);
extern BOOL AddIDriverToArray   (PIDRIVER);
extern BOOL FillTreeInAdvDlg    (HWND, PIDRIVER);
extern PIDRIVER FindIDriverByName (LPTSTR);
extern void RemoveIDriver       (HWND, PIDRIVER, BOOL);
extern BOOL IsConfigurable      (PIDRIVER, HWND);
extern void BrowseDlg           (HWND, int);
extern int  LoadDescFromFile    (PIDRIVER, LPTSTR, LPTSTR, size_t);
extern BOOL wsInfParseInit      (void);
extern void wsStartWait         (void);
extern void wsEndWait           (void);
extern UINT wsCopySingleStatus  (int, DWORD_PTR, LPTSTR);
extern BOOL QueryRemoveDrivers  (HWND, LPTSTR, LPTSTR);
#ifdef FIX_BUG_15451
extern void ConfigureDriver     (HWND, LPTSTR);
extern BOOL fDeviceHasMixers    (LPTSTR);
extern BOOL WaitForNewCPLWindow (HWND);
extern void GetTreeItemNodeDesc (LPTSTR, PIRESOURCE);
extern void GetTreeItemNodeID   (LPTSTR, PIRESOURCE);
#endif // FIX_BUG_15451
extern void RefreshAdvDlgTree   (void);

extern DWORD InstallDriversForPnPDevice (HWND, HDEVINFO, PSP_DEVINFO_DATA);

// From drivers.c
extern void        lsplitpath     (LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);

// From remove.c
LPTSTR mystrtok(LPTSTR SrcString, LPCTSTR Seps, LPTSTR FAR *State);
extern DWORD Media_RemoveDevice(IN HDEVINFO         DeviceInfoSet,
                                IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                               );
extern BOOL RemoveDriver (HDEVINFO, PSP_DEVINFO_DATA);
#ifdef _WIN64
extern void mmWOW64ThunkMediaClassInstaller(DWORD dwInstallationFlag, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
#endif //_WIN64

// From install.c
extern BOOL FilterOutNonNTInfs(IN HDEVINFO         DeviceInfoSet,
                               IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
                               IN DWORD DriverType
                              );
extern DWORD Media_SelectBestCompatDrv(IN HDEVINFO         DeviceInfoSet,
                                       IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                                      );
extern DWORD Media_AllowInstall(IN HDEVINFO         DeviceInfoSet,
                                IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                               );
extern DWORD Media_InstallDevice(IN HDEVINFO         DeviceInfoSet,
                                 IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                                );

// From legcyinf.c
extern DWORD Media_SelectDevice(IN HDEVINFO         DeviceInfoSet,
                                IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                               );


extern DWORD Media_MigrateLegacy(IN HDEVINFO         DeviceInfoSet,
                                 IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                                );

#define IS_MS_MMMCI 1
#define IS_MS_MMVID 2
#define IS_MS_MMACM 3
#define IS_MS_MMVCD 4
#define IS_MS_MMDRV 5
extern int IsSpecialDriver(IN HDEVINFO         DeviceInfoSet,
                           IN PSP_DEVINFO_DATA DeviceInfoData
                          );

extern BOOL IsPnPDriver(IN PTSTR szName);

void acmDeleteCodec (WORD, WORD);       // (from MSACMCPL.C)

#ifdef FIX_BUG_15451
extern TCHAR    szDriverWhichNeedsSettings[MAX_PATH]; // See MMCPL.C
#endif // FIX_BUG_15451

void                FreeIResource             (PIRESOURCE);
INT_PTR CALLBACK    DevPropDlg                (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL                DriverClassToClassNode    (PCLASSNODE, DriverClass);
int                 DriverClassToOldClassID   (DriverClass);
DWORD               GetDriverStatus           (PIDRIVER);
BOOL                InitInstalled             (HWND, LPTSTR);

/* Resource IDs */

#define IDOK                1
#define IDCANCEL            2
#define ID_IGNORE           3
#define ID_CURRENT          4
#define ID_RETRY            5
#define ID_NEW              6

#define ID_DISK             101
#define ID_ADV_ADD          102
#define ID_EDIT             105
#define ID_TEXT             106

#define ID_DIR              202
#define ID_FILE_LIST        203
#define ID_DIR_LIST         204
#define ID_TYPE             205

#define LB_AVAILABLE        301
#define ID_DRV              302
#define ID_LIST             303
#define ID_DRVSTRING        304
#define LB_UNLISTED         306
#define ID_ADV_PROP         307
#define ID_ADV_TSHOOT       308

#define ADVDLG              1001
#define DLG_UPDATE          1002
#define DLG_KNOWN           1003
#define DLG_RESTART         1004
#define DLG_EXISTS          1005
#define DLG_INSERTDISK      1006

#define DLG_COPYERR         1007
#define ID_STATUS2          1008
#define DLG_DM_ADVDLG       1009
#define DLG_DM_LEGACY_RESOURCES 1010

#define IDS_NOINF                       2003
#define IDS_DEFDRIVE                    2004
#define IDS_OUTOFDISK                   2005
#define IDS_DISKS                       2006
#define IDS_INSTALLDRIVERS              2007
#define IDS_INSTALLDRIVERS32            2067
#define IDS_DRIVERDESC                  2008
#define IDS_OUT_OF_REMOVE_SPACE         2009
#define IDS_AVAILABLE_DRIVERS_DEFAULT   2010
#define IDS_ERROR                       2011
#define IDS_INSTALLING_DRIVERS          2012
#define IDS_NO_DESCRIPTION              2013
#define IDS_ERRORBOX                    2014
#define IDS_RESTARTTEXT                 2015
#define IDS_CONFIGURE_DRIVER            2016
#define IDS_TOO_MANY_DRIVERS            2017
#define IDS_CANNOT_FIND                 2018
#define IDS_APPNAME                     2019
#define IDS_DRIVERS                     2020
#define IDS_SETUPINF                    2021
#define IDS_CONTROLINI                  2022
#define IDS_SYSINI                      2023
#define IDS_MCI                         2024
#define IDS_CONTROL_INI                 2025
#define IDS_WIN                         2027
#define IDS_DOS                         2028
#define IDS_BROWSE                      2029
#define IDS_UPDATED                     2031
#define IDS_CLOSE                       2032
#define IDS_REMOVEORNOT                 2033
#define IDS_UNLISTED                    2034
#define IDS_KNOWN                       2035
#define IDS_REMOVE                      2036
#define IDS_REMOVEORNOTSTRICT           2037
#define IDS_USERINSTALLDRIVERS          2038
#define IDS_OEMSETUP                    2044
#define IDS_SYSTEM                      2045
#define IDS_FILE_ERROR                  2046
#define IDS_INVALIDINF                  2048
#define IDS_UNABLE_TOINSTALL            2049
#define IDS_BOOT                        2050
#define IDS_RESTART_ADD                 2051
#define IDS_RESTART_REM                 2052
#define IDS_FILEINUSEADD                2053
#define IDS_OEMDISKS                    2054
#define IDS_FILEINUSEREM                2055
#define IDS_LASTQUERY                   2056
#define IDS_RELATEDDESC                 2057
#define IDS_DRIVER_EXISTS               2058
#define IDS_SYSTEM_DRIVERS              2060
#define IDS_INSUFFICIENT_PRIVILEGE      2061
#define IDS_CANNOT_RESTART_PRIVILEGE    2062
#define IDS_CANNOT_RESTART_UNKNOWN      2063
#define IDS_DRIVER_CONFIG_ERROR         2064
#define IDS_CANTADD                     2065
#define IDS_CONTROL_HLP_FILE            2066
#define IDS_TSHOOT                      2068
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\dmproppg.c ===
#pragma warning( disable: 4103)
#include "mmcpl.h"
#include <cpl.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <infstr.h>
#include <devguid.h>

#include "draw.h"
#include "utils.h"
#include "drivers.h"
#include "sulib.h"
#include "medhelp.h"
#include <tchar.h>

#define GetString(_psz,_id) LoadString(myInstance,(_id),(_psz),sizeof((_psz))/sizeof(TCHAR))

// Global info struct. One instance for the whole dialog
typedef struct _OUR_PROP_PARAMS
{
    HDEVINFO            DeviceInfoSet;
    PSP_DEVINFO_DATA    DeviceInfoData;
    HKEY                hkDrv;      // Key to classguid\0000
    HKEY                hkDrivers;  // Key to classguid\0000\Drivers
    BOOL                bClosing;   // Set to TRUE while dialog is closing
    TCHAR szSubClasses[256];         // Subclasses to process
} OUR_PROP_PARAMS, *POUR_PROP_PARAMS;

typedef enum
{
    NodeTypeRoot,
    NodeTypeClass,
    NodeTypeDriver
} NODETYPE;

// Tree node. One per node on tree.
typedef struct _DMTREE_NODE;
typedef BOOL (*PFNCONFIG)     (HWND ParentHwnd, struct _DMTREE_NODE *pTreeNode);
typedef BOOL (*PFNQUERYCONFIG)(HWND ParentHwnd, struct _DMTREE_NODE *pTreeNode);
typedef struct _DMTREE_NODE
{
    NODETYPE NodeType;              // Type of node
    PFNCONFIG pfnConfig;            // Ptr to config function
    PFNQUERYCONFIG pfnQueryConfig;  // Ptr to query config function
    int QueryConfigInfo;            // Data for config function
    TCHAR szDescription[MAXSTR];     // Node description
    TCHAR szDriver[MAXSTR];          // Driver name of this node
    WCHAR wszDriver[MAXSTR];        // Wide char driver name
    TCHAR szAlias[MAXSTR];          // Alias
    WCHAR wszAlias[MAXSTR];         // Wide char alias
    DriverClass dc;                 // Legacy-style driver class, if available
    HTREEITEM hti;                  // For use with MIDI prop sheet callback
} DMTREE_NODE, *PDMTREE_NODE;

INT_PTR APIENTRY DmAdvPropPageDlgProc(IN HWND   hDlg,
                                      IN UINT   uMessage,
                                      IN WPARAM wParam,
                                      IN LPARAM lParam
                                     );

UINT CALLBACK DmAdvPropPageDlgCallback(HWND hwnd,
                                       UINT uMsg,
                                       LPPROPSHEETPAGE ppsp
                                      );

BOOL DmAdvPropPage_OnCommand(
                            HWND ParentHwnd,
                            int  ControlId,
                            HWND ControlHwnd,
                            UINT NotifyCode
                            );

BOOL DmAdvPropPage_OnContextMenu(
                                HWND HwndControl,
                                WORD Xpos,
                                WORD Ypos
                                );

BOOL DmAdvPropPage_OnHelp(
                         HWND       ParentHwnd,
                         LPHELPINFO HelpInfo
                         );

BOOL DmAdvPropPage_OnInitDialog(
                               HWND    ParentHwnd,
                               HWND    FocusHwnd,
                               LPARAM  Lparam
                               );

BOOL DmAdvPropPage_OnNotify(
                           HWND    ParentHwnd,
                           LPNMHDR NmHdr
                           );

void DmAdvPropPage_OnPropertiesClicked(
                                      HWND             ParentHwnd,
                                      POUR_PROP_PARAMS Params
                                      );


BOOL DmOverrideResourcesPage(LPVOID        Info,
                             LPFNADDPROPSHEETPAGE AddFunc,
                             LPARAM               Lparam,
                             POUR_PROP_PARAMS     Params
                            );

BOOL AddCDROMPropertyPage( HDEVINFO             hDeviceInfoSet,
                           PSP_DEVINFO_DATA     pDeviceInfoData,
                           LPFNADDPROPSHEETPAGE AddFunc,
                           LPARAM               Lparam
                          );

BOOL AddSpecialPropertyPage( DWORD                SpecialDriverType,
                             LPFNADDPROPSHEETPAGE AddFunc,
                             LPARAM               Lparam
                            );

BOOL DmInitDeviceTree(HWND hwndTree, POUR_PROP_PARAMS Params);

BOOL DmAdvPropPage_OnDestroy(
                            HWND    ParentHwnd,
                            LPNMHDR NmHdr
                            );

void DoProperties(HWND ParentHwnd, HWND hWndI, HTREEITEM htiCur);

BOOL QueryConfigDriver(HWND ParentHwnd, PDMTREE_NODE pTreeNode)
{
    HANDLE       hDriver;

    if (pTreeNode->NodeType!=NodeTypeDriver)
    {
        return FALSE;
    }

    if (pTreeNode->QueryConfigInfo==0)  // if 0, the we haven't checked yet
    {
        INT_PTR IsConfigurable;

        //  open the driver
        hDriver = OpenDriver(pTreeNode->wszDriver, NULL, 0L);
        if (!hDriver)
        {
            return FALSE;
        }

        // Send the DRV_CONFIGURE message to the driver
        IsConfigurable = SendDriverMessage(hDriver,
                                           DRV_QUERYCONFIGURE,
                                           0L,
                                           0L);

        CloseDriver(hDriver, 0L, 0L);

        // 1->Is configurable, -1->Not configurable
        pTreeNode->QueryConfigInfo = IsConfigurable ? 1 : -1;
    }

    return (pTreeNode->QueryConfigInfo>0);
}

BOOL PNPDriverToIResource(PDMTREE_NODE pTreeNode, IRESOURCE* pir)
{
    IDRIVER tempIDriver;

    if ((pir->pcn = (PCLASSNODE)LocalAlloc (LPTR, sizeof(CLASSNODE))) == NULL)
    {
        return FALSE;
    }

    if (!DriverClassToClassNode(pir->pcn, pTreeNode->dc))
    {
        LocalFree ((HANDLE)pir->pcn);
        return FALSE;
    }

    pir->iNode = 2;   // 1=class, 2=device, 3=acm, 4=instmt

    lstrcpy (pir->szFriendlyName, pTreeNode->szDescription);
    lstrcpy (pir->szDesc,         pTreeNode->szDescription);
    lstrcpy (pir->szFile,         pTreeNode->szDriver);
    lstrcpy (pir->szDrvEntry,     pTreeNode->szAlias);
    lstrcpy (pir->szClass,        pir->pcn->szClass);

    pir->fQueryable = (short)QueryConfigDriver(NULL, pTreeNode);
    pir->iClassID = (short)DriverClassToOldClassID(pTreeNode->dc);
    pir->szParam[0] = 0;
    pir->dnDevNode = 0;
    pir->hDriver = NULL;

    // Find fStatus, which despite its name is really a series of
    // flags--in Win95 it's composed of DEV_* flags (from the old
    // mmcpl.h), but those are tied with PNP.  Here, we use the
    // dwStatus* flags:
    //
    ZeroMemory(&tempIDriver,sizeof(IDRIVER));

    lstrcpy(tempIDriver.wszAlias,pTreeNode->wszAlias);
    lstrcpy(tempIDriver.szAlias,pTreeNode->szAlias);
    lstrcpy(tempIDriver.wszFile,pTreeNode->wszDriver);
    lstrcpy(tempIDriver.szFile,pTreeNode->szDriver);
    lstrcpy(tempIDriver.szDesc,pTreeNode->szDescription);
    lstrcpy(tempIDriver.szSection,wcsstr(pTreeNode->szDescription, TEXT("MCI")) ? szMCI : szDrivers);
    lstrcpy(tempIDriver.wszSection,wcsstr(pTreeNode->szDescription, TEXT("MCI")) ? szMCI : szDrivers);

    pir->fStatus = (int)GetDriverStatus (&tempIDriver);

    return TRUE;
}

BOOL ConfigDriver(HWND ParentHwnd, PDMTREE_NODE pTreeNode)
{
    //need to pop up the legacy properties dialog
    IRESOURCE ir;
    DEVTREENODE dtn;
    TCHAR        szTab[ cchRESOURCE ];

    if ((pTreeNode->NodeType == NodeTypeDriver) && (pTreeNode->dc != dcINVALID))
    {
        if (PNPDriverToIResource(pTreeNode, &ir))
        {
            GetString (szTab, IDS_GENERAL);

            dtn.lParam = (LPARAM)&ir;
            dtn.hwndTree = ParentHwnd;

            //must call this function twice to fill in the array of PIDRIVERs in drivers.c
            //otherwise, many of the "settings" calls won't work
            InitInstalled (GetParent (ParentHwnd), szDrivers);
            InitInstalled (GetParent (ParentHwnd), szMCI);

            switch (pTreeNode->dc)
            {
                case dcMIDI :
                   ShowWithMidiDevPropSheet (szTab,
                                             DevPropDlg,
                                             DLG_DEV_PROP,
                                             ParentHwnd,
                                             pTreeNode->szDescription,
                                             pTreeNode->hti,
                                             (LPARAM)&dtn,
                                             (LPARAM)&ir,
                                             (LPARAM)ParentHwnd);
                break;

                case dcWAVE :
                    ShowPropSheet (szTab,
                              DevPropDlg,
                              DLG_WAVDEV_PROP,
                              ParentHwnd,
                              pTreeNode->szDescription,
                              (LPARAM)&dtn);
                break;

                default:
                   ShowPropSheet (szTab,
                                  DevPropDlg,
                                  DLG_DEV_PROP,
                                  ParentHwnd,
                                  pTreeNode->szDescription,
                                  (LPARAM)&dtn);
                break;
            } //end switch

            FreeIResource (&ir);
        }
    }

    return (FALSE);
}

const static DWORD aDMPropHelpIds[] = {  // Context Help IDs
    IDC_ADV_TREE,    IDH_GENERIC_DEVICES,
    ID_ADV_PROP,     IDH_ADV_PROPERTIES,
    0, 0
};

//******************************************************************************
//* Subtype code
//******************************************************************************
//
// Subtype info. Array of one per device class subtype
typedef struct _SUBTYPE_INFO
{
    TCHAR *szClass;
    DWORD DescId;
    DWORD IconId;
    PFNCONFIG pfnConfig;
    PFNQUERYCONFIG pfnQueryConfig;
    DriverClass dc;
    TCHAR  szDescription[64];
    DWORD IconIndex;
} SUBTYPE_INFO;

static SUBTYPE_INFO SubtypeInfo[] =
{
    { TEXT(""),            IDS_MM_HEADER,       IDI_MMICON,   ConfigDriver, QueryConfigDriver, dcOTHER},
    { TEXT("waveaudio"),   IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("wavemap"),     IDS_WAVE_HEADER,     IDI_WAVE,     ConfigDriver, QueryConfigDriver, dcWAVE},
    { TEXT("wave"),        IDS_WAVE_HEADER,     IDI_WAVE,     ConfigDriver, QueryConfigDriver, dcWAVE},
    { TEXT("vids"),        IDS_ICM_HEADER,      IDI_ICM,      ConfigDriver, QueryConfigDriver, dcVCODEC},
    { TEXT("vidc"),        IDS_ICM_HEADER,      IDI_ICM,      ConfigDriver, QueryConfigDriver, dcVCODEC},
    { TEXT("sequencer"),   IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("msvideo"),     IDS_VIDCAP_HEADER,   IDI_VIDEO,    ConfigDriver, QueryConfigDriver, dcVIDCAP},
    { TEXT("msacm"),       IDS_ACM_HEADER,      IDI_ACM,      ConfigDriver, QueryConfigDriver, dcACODEC},
    { TEXT("mpegvideo"),   IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("mixer"),       IDS_MIXER_HEADER,    IDI_MIXER,    ConfigDriver, QueryConfigDriver, dcMIXER},
    { TEXT("midimapper"),  IDS_MIDI_HEADER,     IDI_MIDI,     ConfigDriver, QueryConfigDriver, dcMIDI},
    { TEXT("midi"),        IDS_MIDI_HEADER,     IDI_MIDI,     ConfigDriver, QueryConfigDriver, dcMIDI},
    { TEXT("mci"),         IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("icm"),         IDS_ICM_HEADER,      IDI_ICM,      ConfigDriver, QueryConfigDriver, dcVCODEC},
    { TEXT("cdaudio"),     IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("avivideo"),    IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("aux"),         IDS_AUX_HEADER,      IDI_AUX,      ConfigDriver, QueryConfigDriver, dcAUX},
    { TEXT("acm"),         IDS_ACM_HEADER,      IDI_ACM,      ConfigDriver, QueryConfigDriver, dcACODEC},
    { TEXT("joy"),         IDS_JOYSTICK_HEADER, IDI_JOYSTICK, ConfigDriver, QueryConfigDriver, dcJOY}
};

#define SUBTYPE_INFO_SIZE (sizeof(SubtypeInfo)/sizeof(SUBTYPE_INFO))

BOOL LoadSubtypeInfo(HWND hwndTree)
{
    UINT i;
    UINT  uFlags;
    int cxMiniIcon;
    int cyMiniIcon;
    DWORD dwLayout;

    HIMAGELIST hImagelist;

    // Create the image list
    cxMiniIcon = (int)GetSystemMetrics(SM_CXSMICON);
    cyMiniIcon = (int)GetSystemMetrics(SM_CYSMICON);
    uFlags = ILC_MASK | ILC_COLOR32;
   
    if (GetProcessDefaultLayout(&dwLayout) &&
            (dwLayout & LAYOUT_RTL)) 
    {
        uFlags |= ILC_MIRROR;
    }

    hImagelist = ImageList_Create(cxMiniIcon, cyMiniIcon, uFlags, SUBTYPE_INFO_SIZE, 4);
    if (!hImagelist)
        return FALSE;

    for (i=0;i<SUBTYPE_INFO_SIZE;i++)
    {
        HICON hIcon;

        // Load the description
        LoadString(ghInstance, SubtypeInfo[i].DescId, SubtypeInfo[i].szDescription, 64);

        // Load the image into the image list
        hIcon = LoadImage (ghInstance,
                           MAKEINTRESOURCE( SubtypeInfo[i].IconId ),
                           IMAGE_ICON,
                           cxMiniIcon,
                           cyMiniIcon,
                           LR_DEFAULTCOLOR);

        if (hIcon)  // PREFIX 160723
        {
            SubtypeInfo[i].IconIndex = ImageList_AddIcon(hImagelist, hIcon);
            DestroyIcon(hIcon);
        }
        else
        {
            SubtypeInfo[i].IconIndex = -1;
        }
    }

    // Clean out and initialize tree control
    TreeView_SetImageList(hwndTree, hImagelist, TVSIL_NORMAL);

    return TRUE;
}

SUBTYPE_INFO *GetSubtypeInfo(TCHAR *pszClass)
{
    UINT iClass;
    if (pszClass)
    {
        for (iClass=0;iClass<SUBTYPE_INFO_SIZE;iClass++)
        {
            if (!lstrcmpi(pszClass,SubtypeInfo[iClass].szClass))
                return &SubtypeInfo[iClass];
        }
    }

    return &SubtypeInfo[0];
}

//******************************************************************************

/*

Routine Description: MediaPropPageProvider

    Entry-point for adding additional device manager property
    sheet pages.  Registry specifies this routine under
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96C-E325-11CE-BFC1-08002BE10318}
    EnumPropPage32="mmsys.cpl,thisproc"

    This entry-point gets called only when the DeviceManager asks for additional property pages.

Arguments:

    Info  - points to PROPSHEETPAGE_REQUEST, see setupapi.h
    AddFunc - function ptr to call to add sheet.
    Lparam - add sheet functions private data handle.

Return Value:

    BOOL: FALSE if pages could not be added, TRUE on success

*/
BOOL APIENTRY MediaPropPageProvider(LPVOID               Info,
                                    LPFNADDPROPSHEETPAGE AddFunc,
                                    LPARAM               Lparam
                                   )
{
    PSP_PROPSHEETPAGE_REQUEST pprPropPageRequest;
    PROPSHEETPAGE             psp;
    HPROPSHEETPAGE            hpsp;
    POUR_PROP_PARAMS          Params;
    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;
    DWORD SpecialDriverType;

    HKEY hkDrv;
    HKEY hkDrivers;
    DWORD cbLen;

    pprPropPageRequest = (PSP_PROPSHEETPAGE_REQUEST) Info;

    if (pprPropPageRequest->PageRequested != SPPSR_ENUM_ADV_DEVICE_PROPERTIES)
    {
        return TRUE;
    }

    DeviceInfoSet  = pprPropPageRequest->DeviceInfoSet;
    DeviceInfoData = pprPropPageRequest->DeviceInfoData;

    // This API is called for both devices and the class as a whole
    // (when someone right-clicks on the class and chooses properties).
    // In the class case the DeviceInfoData field of the propPageRequest structure is NULL.
    // We don't do anything in that case, so just return.
    if (!DeviceInfoData)
    {
        return TRUE;
    }

    SpecialDriverType = IsSpecialDriver(DeviceInfoSet, DeviceInfoData);
    if (SpecialDriverType)
    {
        SP_DEVINSTALL_PARAMS DeviceInstallParams;

        DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
        SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);
        DeviceInstallParams.Flags |= DI_RESOURCEPAGE_ADDED | DI_DRIVERPAGE_ADDED; // | DI_GENERALPAGE_ADDED;
        SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);
        AddSpecialPropertyPage(SpecialDriverType, AddFunc, Lparam);
        return TRUE;
    }

    if (AddCDROMPropertyPage(DeviceInfoSet,DeviceInfoData, AddFunc, Lparam))
    {
        return TRUE;
    }

    // Open device reg key to see if this is a WDM driver
    hkDrv = SetupDiOpenDevRegKey(DeviceInfoSet,
                                 DeviceInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DRV,
                                 KEY_ALL_ACCESS);
    if (!hkDrv)
        return FALSE;

    // Allocate and zero out memory for the struct that will contain page specific data
    Params = (POUR_PROP_PARAMS)LocalAlloc(LPTR, sizeof(OUR_PROP_PARAMS));
    if (!Params)
    {
        RegCloseKey(hkDrv);
        return FALSE;
    }

    // Initialize Params structure
    Params->DeviceInfoSet  = DeviceInfoSet;
    Params->DeviceInfoData = DeviceInfoData;
    Params->hkDrv          = hkDrv;

    // Override Resource page if this is not a WDM (PNP) driver
    DmOverrideResourcesPage(Info, AddFunc, Lparam, Params);

    // Try a couple of things to see if there are actually any drivers under this key
    // and cache the results

    // Try to open up the Drivers subkey
    if (RegOpenKey(Params->hkDrv, TEXT("Drivers"), &hkDrivers))
    {
        RegCloseKey(hkDrv);
        LocalFree(Params);
        return TRUE;
    }

    // Try to read the SubClasses key to determine which subclasses to process
    cbLen=sizeof(Params->szSubClasses);
    if (RegQueryValueEx(hkDrivers, TEXT("Subclasses"), NULL, NULL, (LPBYTE)Params->szSubClasses, &cbLen))
    {
        RegCloseKey(hkDrv);
        RegCloseKey(hkDrivers);
        LocalFree(Params);
        return TRUE;
    }

    Params->hkDrivers      = hkDrivers;

    // Initialize the property sheet page
    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    psp.hInstance   = ghInstance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_DM_ADVDLG);
    psp.pfnDlgProc  = DmAdvPropPageDlgProc;     // dlg window proc
    psp.lParam      = (LPARAM) Params;
    psp.pfnCallback = DmAdvPropPageDlgCallback; // control callback of the dlg window proc

    // Create the page & get back a handle
    hpsp = CreatePropertySheetPage(&psp);
    if (!hpsp)
    {
        RegCloseKey(hkDrv);
        LocalFree(Params);
        return FALSE;
    }

    // Add the property page
    if (!(*AddFunc)(hpsp, Lparam))
    {
        DestroyPropertySheetPage(hpsp);
        return FALSE;
    }

    return TRUE;
} /* DmAdvPropPageProvider */

UINT CALLBACK DmAdvPropPageDlgCallback(HWND hwnd,
                                       UINT uMsg,
                                       LPPROPSHEETPAGE ppsp)
{
    POUR_PROP_PARAMS Params;

    switch (uMsg)
    {
    case PSPCB_CREATE:  // This gets called when the page is created
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE: // This gets called when the page is destroyed
        Params = (POUR_PROP_PARAMS) ppsp->lParam;
        RegCloseKey(Params->hkDrv);
        RegCloseKey(Params->hkDrivers);
        LocalFree(Params);  // Free our local params

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

/*++

Routine Description: DmAdvPropPageDlgProc

    The windows control function for the Port Settings properties window

Arguments:

    hDlg, uMessage, wParam, lParam: standard windows DlgProc parameters

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
INT_PTR APIENTRY DmAdvPropPageDlgProc(IN HWND   hDlg,
                                      IN UINT   uMessage,
                                      IN WPARAM wParam,
                                      IN LPARAM lParam)
{
    switch (uMessage)
    {
    case WM_COMMAND:
        return DmAdvPropPage_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));

    case WM_CONTEXTMENU:
        return DmAdvPropPage_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        return DmAdvPropPage_OnHelp(hDlg, (LPHELPINFO) lParam);

    case WM_INITDIALOG:
        return DmAdvPropPage_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return DmAdvPropPage_OnNotify(hDlg,  (NMHDR *)lParam);

    case WM_DESTROY:
        return DmAdvPropPage_OnDestroy(hDlg, (NMHDR *)lParam);
    }

    return FALSE;
} /* DmAdvPropPageDlgProc */

BOOL DmAdvPropPage_OnCommand(
                            HWND ParentHwnd,
                            int  ControlId,
                            HWND ControlHwnd,
                            UINT NotifyCode
                            )
{
    POUR_PROP_PARAMS params =
        (POUR_PROP_PARAMS) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    switch (ControlId)
    {
    case ID_ADV_PROP:
        DmAdvPropPage_OnPropertiesClicked(ParentHwnd, params);
        break;
    }

    return FALSE;
}

BOOL DmAdvPropPage_OnContextMenu(
                                HWND HwndControl,
                                WORD Xpos,
                                WORD Ypos
                                )
{
    WinHelp(HwndControl,
            gszWindowsHlp,
            HELP_CONTEXTMENU,
            (ULONG_PTR) aDMPropHelpIds);
    return FALSE;
}

BOOL DmAdvPropPage_OnHelp(
                         HWND       ParentHwnd,
                         LPHELPINFO HelpInfo
                         )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW)
    {
        WinHelp((HWND) HelpInfo->hItemHandle,
                gszWindowsHlp,
                HELP_WM_HELP,
                (ULONG_PTR) aDMPropHelpIds);
    }
    return FALSE;
}

BOOL DmAdvPropPage_OnInitDialog(
                               HWND    ParentHwnd,
                               HWND    FocusHwnd,
                               LPARAM  Lparam
                               )
{
    HWND hwndTree;
    POUR_PROP_PARAMS Params;
    HCURSOR hCursor;
    BOOL bSuccess;

    // on WM_INITDIALOG call, lParam points to the property sheet page.
    //
    // The lParam field in the property sheet page struct is set by the
    // caller. When I created the property sheet, I passed in a pointer
    // to a struct containing information about the device. Save this in
    // the user window long so I can access it on later messages.
    Params = (POUR_PROP_PARAMS) ((LPPROPSHEETPAGE)Lparam)->lParam;
    SetWindowLongPtr(ParentHwnd, DWLP_USER, (ULONG_PTR) Params);

    // Put up the wait cursor
    hCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));

    //create the device tree.
    hwndTree = GetDlgItem(ParentHwnd, IDC_ADV_TREE);

    // Initialize the tree
    bSuccess = DmInitDeviceTree(hwndTree, Params);

    // Enable the adv properties button
    EnableWindow(GetDlgItem(ParentHwnd, ID_ADV_PROP), TRUE);

    // Tear down the wait cursor
    SetCursor(hCursor);

    return bSuccess;
}

BOOL DmAdvPropPage_OnNotify(
                           HWND    ParentHwnd,
                           LPNMHDR NmHdr
                           )
{
    POUR_PROP_PARAMS Params = (POUR_PROP_PARAMS) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    switch (NmHdr->code)
    {
    case PSN_APPLY:    // Sent when the user clicks on Apply OR OK !!
        SetWindowLongPtr(ParentHwnd, DWLP_MSGRESULT, (LONG_PTR)PSNRET_NOERROR);
        return TRUE;

    case TVN_SELCHANGED:
        //Don't bother if we are closing. This helps avoid irritating
        //redraw problems as destroy causes several of these messages to be sent.
        if (!Params->bClosing)
        {
            LPNM_TREEVIEW   lpnmtv;
            TV_ITEM         tvi;
            PDMTREE_NODE    pTreeNode;
            BOOL            fEnablePropButton;
            HWND            hwndProp;

            lpnmtv    = (LPNM_TREEVIEW)NmHdr;
            tvi       = lpnmtv->itemNew;
            pTreeNode = (PDMTREE_NODE)tvi.lParam;
            fEnablePropButton = pTreeNode->pfnQueryConfig(ParentHwnd, pTreeNode);

            //override the enabling for driver entries
            if ((pTreeNode->NodeType == NodeTypeDriver) && (pTreeNode->dc != dcINVALID))
            {
                fEnablePropButton = TRUE;
            }

            // Enable or disable the Properties button depending upon
            // whether this driver can be configured
            hwndProp  = GetDlgItem(ParentHwnd, ID_ADV_PROP);
            EnableWindow(hwndProp, fEnablePropButton);
        }
        break;

    case NM_DBLCLK:
        //show properties on a double-click
        if (NmHdr->idFrom == (DWORD)IDC_ADV_TREE)
        {
            HWND            hwndTree;
            TV_HITTESTINFO  tvht;

            hwndTree = GetDlgItem(ParentHwnd, IDC_ADV_TREE);

            // Find out which tree item the cursor is on and call properties on it
            GetCursorPos(&tvht.pt);
            ScreenToClient(hwndTree, &tvht.pt);
            TreeView_HitTest(hwndTree, &tvht);
            if (tvht.flags & TVHT_ONITEM)
            {
                DoProperties(ParentHwnd, hwndTree, tvht.hItem);
            }
        }
        break;

#if 0 // stolen from Win98, not integrated yet
    case PSN_KILLACTIVE:
        FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
        break;

    case PSN_APPLY:
        FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
        break;

    case PSN_SETACTIVE:
        FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
        break;

    case PSN_RESET:
        FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
        break;

    case TVN_ITEMEXPANDING:
        {
            TV_ITEM tvi;
            HWND hwndTree = GetDlgItem(hDlg,IDC_ADV_TREE);

            tvi = lpnmtv->itemNew;
            tvi.mask = TVIF_PARAM;
            if (!TreeView_GetItem(hwndTree, &tvi))
                break;

            if (!tvi.lParam || IsBadReadPtr((LPVOID)tvi.lParam, 2))
            {
                DPF("****TVN_ITEMEXPANDING: lParam = 0 || BadReadPtr***\r\n");
                break;
            }
            if (*((short *)(tvi.lParam)) == 1)
            {
                //re-enum ACM codecs on expand because their states could have been programmatically changed.
                PCLASSNODE     pcn = (PCLASSNODE)(tvi.lParam);

                if (lpnmtv->action == TVE_EXPAND && !lstrcmpi(pcn->szClass, ACM))
                {
                    if (gfLoadedACM)
                        ACMNodeChange(hDlg);
                }
            }
            else if (!tvi.lParam && lpnmtv->action == TVE_COLLAPSE)
            {
                //dont let the root collapse.
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)TRUE);
                return TRUE;
            }
            break;
        }


    case TVN_BEGINLABELEDIT:
        //we don't want to allow editing of label unless the user explicitly wants it by
        //clicking context menu item
        if (!gfEditLabel)
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)TRUE);
        return TRUE;

    case TVN_ENDLABELEDIT:
        {
            HWND hwndTree;
            LPSTR pszFriendlyName = ((TV_DISPINFO *) lpnm)->item.pszText;
            TV_ITEM item;
            HTREEITEM hti;
            PIRESOURCE pIResource;
            char szWarn[128];
            char ach[MAXSTR];

            //user has chosen a new friendly name. COnfirm with the user and put it in the
            //registry. ALso unhook KB hook which was used to track Esc and Return
            if (gfnKBHook)
            {
                UnhookWindowsHookEx(gfnKBHook);
                gfnKBHook = NULL;
            }
            if (!pszFriendlyName)
                return FALSE;
            hwndTree = GetDlgItem(hDlg, IDC_ADV_TREE);
            hti = TreeView_GetSelection(hwndTree);
            item.hItem =  hti;
            item.mask = TVIF_PARAM;
            TreeView_GetItem(hwndTree, &item);

            LoadString(ghInstance, IDS_FRIENDLYWARNING, szWarn, sizeof(szWarn));
            wsprintf(ach, szWarn, pszFriendlyName);
            LoadString(ghInstance, IDS_FRIENDLYNAME, szWarn, sizeof(szWarn));
            if (mmse_MessageBox(hDlg, ach, szWarn, MMSE_YESNO) == MMSE_NO)
            {
                SetFocus(hwndTree);
                return FALSE;
            }
            if (*((short *)(item.lParam)) == 2)
            {
                pIResource = (PIRESOURCE)item.lParam;
                lstrcpy(pIResource->szFriendlyName, pszFriendlyName);
                SaveDevFriendlyName(pIResource);
            }
            else
            {
                PINSTRUMENT pInstr = (PINSTRUMENT)item.lParam;
                lstrcpy(pInstr->szFriendlyName, pszFriendlyName);
                SaveInstrFriendlyName(pInstr);
            }
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)TRUE);
            return TRUE;
        }
    case NM_RCLICK:
        //popup context menu.
        TreeContextMenu(hDlg,  GetDlgItem(hDlg, IDC_ADV_TREE));
        return TRUE;

#endif
    default:
        return FALSE;
    }

    return FALSE;
}


void DoProperties(HWND ParentHwnd, HWND hWndI, HTREEITEM htiCur)
{
    TV_ITEM      tvi;
    PDMTREE_NODE pTreeNode;
    BOOL         bRestart;

    // Get item struct attached to selected node
    tvi.mask = TVIF_PARAM;
    tvi.hItem = htiCur;
    if (TreeView_GetItem (hWndI, &tvi))
    {
        // Get my private data structure from item struct
        pTreeNode = (PDMTREE_NODE)tvi.lParam;

        if (pTreeNode->NodeType != NodeTypeDriver)
        {
            if (!pTreeNode->pfnQueryConfig(ParentHwnd, pTreeNode))
            {
                return;
            }
        }

        // Call config and get back whether restart needed
        pTreeNode->hti = htiCur; //this allows us to work with the legacy MIDI setup code
        bRestart = pTreeNode->pfnConfig(ParentHwnd, pTreeNode);

        if (bRestart)
        {
            PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
        }
    }

    return;
}

void DmAdvPropPage_OnPropertiesClicked(
                                      HWND             ParentHwnd,
                                      POUR_PROP_PARAMS Params
                                      )
{
    HWND         hWndI;
    HTREEITEM    htiCur;

    // Get handle to treeview control
    hWndI  = GetDlgItem(ParentHwnd, IDC_ADV_TREE);

    // Get handle to currently selected node
    htiCur = TreeView_GetSelection (hWndI);

    if (htiCur != NULL)
    {
        DoProperties(ParentHwnd, hWndI, htiCur);
    }

    return;
}

INT_PTR APIENTRY DmResourcesPageDlgProc(IN HWND   hDlg,
                                        IN UINT   uMessage,
                                        IN WPARAM wParam,
                                        IN LPARAM lParam)
{
    return FALSE;
} /* DmAdvPropPageDlgProc */



INT_PTR CALLBACK CDDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


BOOL AddCDROMPropertyPage( HDEVINFO             hDeviceInfoSet,
                           PSP_DEVINFO_DATA     pDeviceInfoData,
                           LPFNADDPROPSHEETPAGE AddFunc,
                           LPARAM               Lparam
                          )
{
    BOOL fHandled = FALSE;

    if (IsEqualGUID(&pDeviceInfoData->ClassGuid,&GUID_DEVCLASS_CDROM))
    {
        PROPSHEETPAGE    psp;
        HPROPSHEETPAGE   hpsp;
        PALLDEVINFO      padi;

        padi = GlobalAllocPtr(GHND, sizeof(ALLDEVINFO));

		if (!padi) return FALSE;

        padi->hDevInfo = hDeviceInfoSet;
        padi->pDevInfoData = pDeviceInfoData;

        // Add our own page for DLG_DM_LEGACY_RESOURCES
        // Initialize the property sheet page
        psp.dwSize      = sizeof(PROPSHEETPAGE);
        psp.dwFlags     = 0;
        psp.hInstance   = ghInstance;
        psp.pszTemplate = MAKEINTRESOURCE(DM_CDDLG);
        psp.pfnDlgProc  = CDDlg;                       // dlg window proc
        psp.lParam      = (LPARAM) padi;
        psp.pfnCallback = 0;                          // control callback of the dlg window proc

        // Create the page & get back a handle
        hpsp = CreatePropertySheetPage(&psp);
        if (!hpsp)
        {
            fHandled = TRUE;
        }
        else if (!(*AddFunc)(hpsp, Lparam))
        {
            GlobalFreePtr(padi);
            DestroyPropertySheetPage(hpsp);
            fHandled = FALSE;
        }
    }

    return(fHandled);
}

INT_PTR CALLBACK AdvDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);



BOOL AddSpecialPropertyPage( DWORD                SpecialDriverType,
                             LPFNADDPROPSHEETPAGE AddFunc,
                             LPARAM               Lparam
                            )
{
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE   hpsp;

    // Add our own page for DLG_DM_LEGACY_RESOURCES
    // Initialize the property sheet page
    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = 0;
    psp.hInstance   = ghInstance;
    psp.pszTemplate = MAKEINTRESOURCE(DM_ADVDLG);
    psp.pfnDlgProc  = AdvDlg;                       // dlg window proc
    psp.lParam      = (LPARAM)SpecialDriverType;
    psp.pfnCallback = 0;                          // control callback of the dlg window proc

    // Create the page & get back a handle
    hpsp = CreatePropertySheetPage(&psp);
    if (!hpsp)
    {
        return FALSE;
    }

    // Add the property page
    if (!(*AddFunc)(hpsp, Lparam))
    {
        DestroyPropertySheetPage(hpsp);
        return FALSE;
    }

    return TRUE;
}



BOOL DmOverrideResourcesPage(LPVOID        Info,
                             LPFNADDPROPSHEETPAGE AddFunc,
                             LPARAM               Lparam,
                             POUR_PROP_PARAMS     Params
                            )
{
    HKEY             hkDrv;
    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE            hpsp;

    TCHAR szDriverType[16];
    DWORD cbLen;

    hkDrv          = Params->hkDrv;
    DeviceInfoSet  = Params->DeviceInfoSet;
    DeviceInfoData = Params->DeviceInfoData;

    // Query value of DriverType field to decide if this is a WDM driver
    cbLen = sizeof(szDriverType);
    if (!RegQueryValueEx(hkDrv, TEXT("DriverType"), NULL, NULL, (LPBYTE)szDriverType, &cbLen))
    {
        if ( lstrcmpi(szDriverType,TEXT("Legacy")) || lstrcmpi(szDriverType,TEXT("PNPISA")) )
        {
            // This is a PNPISA or Legacy device. Override resource page.
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);
            DeviceInstallParams.Flags |= DI_RESOURCEPAGE_ADDED;
            SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);

            // Add our own page for DLG_DM_LEGACY_RESOURCES
            // Initialize the property sheet page
            psp.dwSize      = sizeof(PROPSHEETPAGE);
            psp.dwFlags     = 0;
            psp.hInstance   = ghInstance;
            psp.pszTemplate = MAKEINTRESOURCE(DLG_DM_LEGACY_RESOURCES);
            psp.pfnDlgProc  = DmResourcesPageDlgProc;     // dlg window proc
            psp.lParam      = (LPARAM)0;
            psp.pfnCallback = 0;                          // control callback of the dlg window proc

            // Create the page & get back a handle
            hpsp = CreatePropertySheetPage(&psp);
            if (!hpsp)
            {
                return FALSE;
            }

            // Add the property page
            if (!(*AddFunc)(hpsp, Lparam))
            {
                DestroyPropertySheetPage(hpsp);
                return FALSE;
            }

        }
    }

    return TRUE;
}

/*
 ***************************************************************
 * BOOL DmInitDeviceTree
 *
 *      This function calls commctrl to create the image list and tree and
 *      the opens the registry, reads each class and loads all devices under
 *      the class by calling ReadNodes. For ACM however it uses ACM
 *      APIs (this enumeration code is in msacmcpl.c)
 ***************************************************************
 */
BOOL DmInitDeviceTree(HWND hwndTree, POUR_PROP_PARAMS Params)
{
    TV_INSERTSTRUCT ti;

    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;

    TCHAR *strtok_State;         // strtok state
    TCHAR *pszClass;             // Information about e.g. classguid\0000\Drivers\wave
    HKEY hkClass;

    DWORD idxR3DriverName;      // Information about e.g. classguid\0000\Drivers\wave\foo.drv
    HKEY hkR3DriverName;
    TCHAR szR3DriverName[64];

    DWORD cbLen;

    PDMTREE_NODE pTreeNode;

    SUBTYPE_INFO *pSubtypeInfo;

    HTREEITEM htiRoot;
    HTREEITEM htiClass;
    HTREEITEM htiDriver;

    // Load up all the class descriptions and icons
    LoadSubtypeInfo(hwndTree);

    // Clear out the tree
    SendMessage(hwndTree, WM_SETREDRAW, FALSE, 0L);

    // Allocate my private data structure for this class
    pTreeNode = (PDMTREE_NODE)LocalAlloc(LPTR, sizeof(DMTREE_NODE));
    if (!pTreeNode)
    {
        return FALSE;
    }

    pSubtypeInfo = GetSubtypeInfo(NULL);

    pTreeNode->NodeType = NodeTypeRoot;
    pTreeNode->pfnConfig = pSubtypeInfo->pfnConfig;
    pTreeNode->pfnQueryConfig = pSubtypeInfo->pfnQueryConfig;

    // Insert root entry
    ti.hParent = TVI_ROOT;
    ti.hInsertAfter = TVI_LAST;
    ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    ti.item.iImage = ti.item.iSelectedImage = pSubtypeInfo->IconIndex;
    ti.item.pszText = pSubtypeInfo->szDescription;
    ti.item.lParam = (LPARAM)pTreeNode;
    htiRoot = NULL; //TreeView_InsertItem(hwndTree, &ti);

    // Enumerate all the subclasses
    for (
        pszClass = mystrtok(Params->szSubClasses,NULL,&strtok_State);
        pszClass;
        pszClass = mystrtok(NULL,NULL,&strtok_State)
        )
    {

        // Get an ID for this class
        pSubtypeInfo = GetSubtypeInfo(pszClass);

        // Open up each subclass
        if (RegOpenKey(Params->hkDrivers, pszClass, &hkClass))
        {
            continue;
        }

        // Allocate my private data structure for this class
        pTreeNode = (PDMTREE_NODE)LocalAlloc(LPTR, sizeof(DMTREE_NODE));
        if (!pTreeNode)
        {
            RegCloseKey(hkClass);
            continue;
        }

        pTreeNode->NodeType = NodeTypeClass;
        pTreeNode->pfnConfig = pSubtypeInfo->pfnConfig;
        pTreeNode->pfnQueryConfig = pSubtypeInfo->pfnQueryConfig;

        // Initialize tree insert struct
        ti.hParent = htiRoot;
        ti.hInsertAfter = TVI_LAST;
        ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        ti.item.iImage = ti.item.iSelectedImage = pSubtypeInfo->IconIndex;
        ti.item.pszText = pSubtypeInfo->szDescription;
        ti.item.lParam = (LPARAM)pTreeNode;

        // Insert Class entry into tree
        htiClass = TreeView_InsertItem(hwndTree, &ti);

        // Under each class is a set of driver name subkeys.
        // For each driver (e.g. foo1.drv, foo2.drv, etc.)
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {

            // Open the key to the driver name
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Create the branch for this subclass
            pTreeNode = (PDMTREE_NODE)LocalAlloc(LPTR, sizeof(DMTREE_NODE));
            pTreeNode->NodeType = NodeTypeDriver;
            pTreeNode->pfnConfig = pSubtypeInfo->pfnConfig;
            pTreeNode->pfnQueryConfig = pSubtypeInfo->pfnQueryConfig;
            pTreeNode->dc = pSubtypeInfo->dc;

            // Get driver name
            cbLen = sizeof(pTreeNode->szDriver);
            RegQueryValueEx(hkR3DriverName, TEXT("Driver"), NULL, NULL, (LPBYTE)pTreeNode->szDriver, &cbLen);
            wcscpy(pTreeNode->wszDriver, pTreeNode->szDriver);

            // Get driver description
            cbLen = sizeof(pTreeNode->szDescription);
            RegQueryValueEx(hkR3DriverName, TEXT("Description"), NULL, NULL, (LPBYTE)pTreeNode->szDescription, &cbLen);

            // Get driver alias
            cbLen = sizeof(pTreeNode->szAlias);
            RegQueryValueEx(hkR3DriverName, TEXT("Alias"), NULL, NULL, (LPBYTE)pTreeNode->szAlias, &cbLen);
            wcscpy(pTreeNode->wszAlias, pTreeNode->szAlias);

            // Insert Class entry
            ti.hParent = htiClass;
            ti.hInsertAfter = TVI_LAST;
            ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            ti.item.iImage = ti.item.iSelectedImage = pSubtypeInfo->IconIndex;
            ti.item.pszText = pTreeNode->szDescription;
            ti.item.lParam = (LPARAM)pTreeNode;

            htiDriver = TreeView_InsertItem(hwndTree, &ti);

            // Close the Driver Name key
            RegCloseKey(hkR3DriverName);
        }
        // Close the class key
        RegCloseKey(hkClass);
    }

    // Open up the tree and display
    TreeView_Expand(hwndTree, htiRoot, TVE_EXPAND);
    SendMessage(hwndTree, WM_SETREDRAW, TRUE, 0L);

    return TRUE;
}


// Free up the tree
void DmFreeAdvDlgTree (HWND hTree, HTREEITEM hti)
{
    HTREEITEM htiChild;
    TV_ITEM tvi;

    // Delete all children by calling myself recursively
    while ((htiChild = TreeView_GetChild(hTree, hti)) != NULL)
    {
        DmFreeAdvDlgTree(hTree, htiChild);
    }

    if (hti!=TVI_ROOT)
    {
        // Delete my attached data structures
        tvi.mask = TVIF_PARAM;
        tvi.hItem = hti;
        tvi.lParam = 0;
        TreeView_GetItem(hTree, &tvi);
        if (tvi.lParam != 0)
            LocalFree ((HANDLE)tvi.lParam);

        // Delete myself
        TreeView_DeleteItem (hTree, hti);
    }

    return;
}

BOOL DmAdvPropPage_OnDestroy(
                            HWND    ParentHwnd,
                            LPNMHDR NmHdr
                            )
{
    HWND hTree;
    HIMAGELIST hImageList;
    POUR_PROP_PARAMS Params = (POUR_PROP_PARAMS) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    if (Params)
    {
        Params->bClosing = TRUE;    // Remember that we're now closing
    }

    // Get handle to treeview control
    hTree = GetDlgItem(ParentHwnd, IDC_ADV_TREE);

    // Free all the entries on the control
    DmFreeAdvDlgTree(hTree,TVI_ROOT);

    // Free up the image list attached to the control
    hImageList = TreeView_GetImageList(hTree, TVSIL_NORMAL);
    if (hImageList)
    {
        TreeView_SetImageList(hTree, NULL, TVSIL_NORMAL);
        ImageList_Destroy (hImageList);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\dslevel.h ===
//--------------------------------------------------------------------------;
//
//  File: dslevel.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;
#pragma once 

#include "advaudio.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

HRESULT DSGetGuidFromName(LPTSTR szName, BOOL fRecord, LPGUID pGuid);
HRESULT DSGetCplValues(GUID guid, BOOL fRecord, LPCPLDATA pData);
HRESULT DSSetCplValues(GUID guid, BOOL fRecord, const LPCPLDATA pData);
HRESULT DSGetAcceleration(GUID guid, BOOL fRecord, LPDWORD pdwHWLevel);
HRESULT DSGetSrcQuality(GUID guid, BOOL fRecord, LPDWORD pdwSRCLevel);
HRESULT DSGetSpeakerConfigType(GUID guid, BOOL fRecord, LPDWORD pdwSpeakerConfig, LPDWORD pdwSpeakerType);
HRESULT DSSetAcceleration(GUID guid, BOOL fRecord, DWORD dwHWLevel);
HRESULT DSSetSrcQuality(GUID guid, BOOL fRecord, DWORD dwSRCLevel);
HRESULT DSSetSpeakerConfigType(GUID guid, BOOL fRecord, DWORD dwSpeakerConfig, DWORD dwSpeakerType);

#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\drivers.c ===
/*  DRIVERS.C
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**  Multimedia Control Panel Applet for installing/configuring installable
**  device drivers.  See the ispec doc DRIVERS.DOC for more information.
**
**  History:
**
**      Tue Jul 31 1990 -by- MichaelE
**          Created.
**
**      Thu Oct 25 1990 -by- MichaelE
**          Added restart, horz. scroll, added SKIPDESC reading desc. strings.
**
**      Sat Oct 27 1990 -by- MichaelE
**          Added FileCopy.  Uses SULIB.LIB and LZCOPY.LIB. Finished stuff
**          for case of installing a driver with more than one type.
**
**      May 1991 -by- JohnYG
**          Added and replaced too many things to list.  Better management
**          of removed drivers, correct usage of DRV_INSTALL/DRV_REMOVE,
**          installing VxD's, replaced "Unknown" dialog with an OEMSETUP.INF
**          method, proper "Cancel" method, fixed many potential UAE's.
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <mmsystem.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <cpl.h>
#include <cphelp.h>
#include <commctrl.h>
#include <mmcpl.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <regstr.h>

#include "drivers.h"
#include "sulib.h"
#include "utils.h"
#include "medhelp.h"
#include "midi.h"
#ifdef FIX_BUG_15451
#include "trayvol.h"
#endif // FIX_BUG_15451

#ifndef cchLENGTH
#define cchLENGTH(_sz)  (sizeof(_sz) / sizeof((_sz)[0]))
#endif

#ifndef TreeView_GetGrandParent
#define TreeView_GetGrandParent(_htree,_hti) \
        TreeView_GetParent(_htree,TreeView_GetParent(_htree,_hti))
#endif

/*
 * Enable the definition below to cause MCI devices to be listed by their
 * internal descriptions in the tree, rather than their descriptions as
 * read from Drivers.Desc.
 *
 */
// #define GET_MCI_DEVICE_DESCRIPTIONS_FROM_THEIR_DEVICES

typedef struct
{
        int idIcon;
        int idName;
        int idInfo;
        BOOL bEnabled;
        DWORD dwContext;
        LPTSTR pszHelp;
} APPLET_INFO;

#define NUM_APPLETS     1
#define OBJECT_SIZE     1024

BOOL     bBadOemSetup;
BOOL     bRestart = FALSE;
int      iRestartMessage = 0;
BOOL     bInstallBootLine = FALSE;
BOOL     bCopyVxD;
BOOL     bFindOEM = FALSE;
BOOL     bRelated = FALSE;
BOOL     bCopyEvenIfOlder = FALSE;
BOOL     bDriversAppInUse;
BOOL     bCopyingRelated;
BOOL     bDescFileValid;
HANDLE   myInstance;
HWND     hAdvDlgTree;
UINT     wHelpMessage;
DWORD    dwContext;
PINF     pinfOldDefault = NULL;
TCHAR     szDriversHlp[24];
TCHAR     szLastQuery[20];
TCHAR     szSetupInf[18];
TCHAR     szKnown[250];
TCHAR     szRestartDrv[MAXDRVSTR];  // Warning - Making this string longer could cause a buffer overflow
TCHAR     szUnlisted[150];
TCHAR     szRelatedDesc[30];
TCHAR     szAppName[26];
TCHAR     szDrivers[12];
TCHAR     szRemove[12];
TCHAR     szControlIni[20];
TCHAR     szSysIni[20];
TCHAR     szMCI[6];
TCHAR     szOutOfRemoveSpace[54];
TCHAR     szDriversDesc[38];
TCHAR     szUserDrivers[38];

// Where the source of files to copy is - user updates

TCHAR     szDirOfSrc[MAX_PATH];
TCHAR     szAddDriver[36];
TCHAR     szNoDesc[36];
TCHAR     szError[20];
TCHAR     szRemoveOrNot[250];
TCHAR     szRemoveOrNotStrict[250];
TCHAR     szStringBuf[128];
TCHAR     szMDrivers[38];
TCHAR     szMDrivers32[38];
TCHAR     szFullPath[MAXFILESPECLEN];
TCHAR     szSystem[MAX_PATH];
TCHAR     szOemInf[MAX_PATH];
TCHAR     aszClose[16];
TCHAR     szFileError[50];

#ifdef FIX_BUG_15451
TCHAR    szDriverWhichNeedsSettings[MAX_PATH]; // See MMCPL.C
#endif // FIX_BUG_15451

static   HANDLE   hIList;
static   HANDLE   hWndMain;

/*
 *  Global flag telling us if we're allowed to write to ini files
 */

 BOOL IniFileReadAllowed;
 BOOL IniFileWriteAllowed;


/*
 *** Stuff for keeping track of the TreeView window
 *
 */

#define GetString(_psz,_id) LoadString(myInstance,(_id),(_psz),sizeof((_psz))/sizeof(TCHAR))

static struct   // aDriverKeyword
   {
   LPTSTR       psz;    // text found as alias for driver
   DriverClass  dc; // DriverClass inferred from keyword
   }
aDriverKeyword[] =  // (used by GuessDriverClass())
   {
      { TEXT("waveaudio"),   dcMCI      },    // (sort in inverse alphabetical;
      { TEXT("wavemap"),     dcWAVE     },    //  in particular, longer names first)
      { TEXT("wave"),        dcWAVE     },
      { TEXT("vids"),        dcVCODEC   },
      { TEXT("vidc"),        dcVCODEC   },
      { TEXT("sequencer"),   dcMCI      },
      { TEXT("msvideo"),     dcVIDCAP   },
      { TEXT("msacm"),       dcACODEC   },
      { TEXT("mpegvideo"),   dcMCI      },
      { TEXT("mixer"),       dcMIXER    },
      { TEXT("midimapper"),  dcMIDI     },
      { TEXT("midi"),        dcMIDI     },
      { TEXT("mci"),         dcMCI      },
      { TEXT("icm"),         dcVCODEC   },
      { TEXT("cdaudio"),     dcMCI      },
      { TEXT("avivideo"),    dcMCI      },
      { TEXT("aux"),         dcAUX      },
      { TEXT("acm"),         dcACODEC   },
      { TEXT("joy"),         dcJOY      }
   };

#define nDriverKEYWORDS ((int)(sizeof(aDriverKeyword) / \
                               sizeof(aDriverKeyword[0])))

static struct   // aKeywordDesc
   {
   DriverClass  dc; // DriverClass
   LPTSTR       psz;    // alias which best describes class
   }
aKeywordDesc[] =    // (used by DriverClassToClassNode())
   {
      { dcWAVE,    TEXT("wave")     },
      { dcMIXER,   TEXT("mixer")    },
      { dcVIDCAP,  TEXT("msvideo")  },
      { dcVCODEC,  TEXT("icm")      },
      { dcAUX,     TEXT("aux")      },
      { dcACODEC,  TEXT("acm")      },
      { dcMIDI,    TEXT("midi")     },
      { dcJOY,     TEXT("joystick") }
   };

#define nKeywordDESCS   ((int)(sizeof(aKeywordDesc) / \
                               sizeof(aKeywordDesc[0])))

static struct   // aDriverRoot
   {
   DriverClass  dc; // corresponding driver classification
   BOOL         fAlwaysMake;    // TRUE if should exist even w/o child
   int          idIcon; // icon for items under this tree
   int          idDesc; // description string for parent
   int          idEnable;   // string to describe enabling action
   int          idDisable;  // string to describe disabling action
   HTREEITEM    hti;    // item within tree
   DWORD        dwBit;  // bit mask representing this node
   }
aDriverRoot[] = // (order will define order in display)
   {
      { dcINVALID, TRUE,  IDI_MMICON, IDS_MM_HEADER,
                                      0,
                                      0 },
      { dcWAVE,    TRUE,  IDI_WAVE,   IDS_WAVE_HEADER,
                                      IDS_ENABLEAUDIO,
                                      IDS_DISABLEAUDIO },
      { dcMIDI,    TRUE,  IDI_MIDI,   IDS_MIDI_HEADER,
                                      IDS_ENABLEMIDI,
                                      IDS_DISABLEMIDI },
      { dcMIXER,   TRUE,  IDI_MIXER,  IDS_MIXER_HEADER,
                                      IDS_ENABLEMIXER,
                                      IDS_DISABLEMIXER },
      { dcAUX,     TRUE,  IDI_AUX,    IDS_AUX_HEADER,
                                      IDS_ENABLEAUX,
                                      IDS_DISABLEAUX },
      { dcMCI,     TRUE,  IDI_MCI,    IDS_MCI_HEADER,
                                      IDS_ENABLEMCI,
                                      IDS_DISABLEMCI },
      { dcVCODEC,  TRUE,  IDI_ICM,    IDS_ICM_HEADER,
                                      IDS_ENABLEICM,
                                      IDS_DISABLEICM },
      { dcACODEC,  TRUE,  IDI_ACM,    IDS_ACM_HEADER,
                                      IDS_ENABLEACM,
                                      IDS_DISABLEACM },
      { dcVIDCAP,  TRUE,  IDI_VIDEO,  IDS_VIDCAP_HEADER,
                                      IDS_ENABLECAP,
                                      IDS_DISABLECAP },
      { dcJOY,     TRUE, IDI_JOYSTICK,IDS_JOYSTICK_HEADER,
                                      IDS_ENABLEJOY,
                                      IDS_DISABLEJOY },
      { dcOTHER,   FALSE, IDI_MMICON, IDS_OTHER_HEADER,
                                      IDS_ENABLEJOY,
                                      IDS_DISABLEJOY },
   };

#define nDriverROOTS ((int)(sizeof(aDriverRoot) / sizeof(aDriverRoot[0])))

static LPCTSTR aDriversToSKIP[] =
   {
   TEXT( "MMDRV.DLL" ),
   TEXT( "MIDIMAP.DLL" ),
   TEXT( "MSACM32.DRV" )
   };


static TCHAR cszMMDRVDLL[]    = TEXT("MMDRV.DLL");
static TCHAR cszAliasKERNEL[] = TEXT("KERNEL");
static TCHAR cszRegValueLOADTYPE[] = TEXT("Load Type");

#define nDriversToSKIP ((int)( sizeof(aDriversToSKIP)   \
                             / sizeof(aDriversToSKIP[0]) ))

static HIMAGELIST  hImageList = NULL;   // image list for treeview in advdlg
DriverClass g_dcFilterClass = dcINVALID;

short       DriverClassToRootIndex        (DriverClass);
DriverClass GuessDriverClass              (PIDRIVER);
#ifdef FIX_BUG_15451
DriverClass GuessDriverClassFromAlias     (LPTSTR);
#endif // FIX_BUG_15451
DriverClass GuessDriverClassFromTreeItem  (HTREEITEM hti);
BOOL        EnsureRootIndexExists         (HWND, short);
HTREEITEM   AdvDlgFindTopLevel            (void);
BOOL        InitAdvDlgTree                (HWND);
void        FreeAdvDlgTree                (HWND);
void        TreeContextMenu               (HWND, HWND);

int         lstrnicmp      (LPTSTR, LPTSTR, size_t);
LPTSTR      lstrchr        (LPTSTR, TCHAR);
void        lstrncpy       (LPTSTR, LPTSTR, size_t);

void        ShowDeviceProperties          (HWND, HTREEITEM);

PIDRIVER    FindIDriverByTreeItem         (HTREEITEM);

#ifdef FIX_BUG_15451
HTREEITEM   FindTreeItemByDriverName      (LPTSTR);
#endif // FIX_BUG_15451

// We want to run "control joy.cpl" when the joystick devices
// are highlight and the user clicks Add/Remove/Properties buttons.
BOOL RunJoyControlPanel(void);  //qzheng

/*
 ***
 *
 */


DWORD GetFileDateTime     (LPTSTR);
LPTSTR  GetProfile          (LPTSTR,LPTSTR, LPTSTR, LPTSTR, int);
void  AddIDrivers         (HWND, LPTSTR, LPTSTR);
HTREEITEM AddIDriver      (HWND, PIDRIVER, DriverClass);
BOOL  AddIDriverByName    (HWND, LPCWSTR, DriverClass);
PIDRIVER GetSelectedIDriver (HWND);
BOOL  FillTreeFromWinMM   (HWND);
BOOL  FillTreeFromMSACM   (HWND);
BOOL  FillTreeFromMCI     (HWND);
BOOL  FillTreeFromMIDI    (HWND);
BOOL  FillTreeFromRemaining (HWND);
void  FillTreeFromRemainingBySection (HWND, long ii, LPCTSTR, DriverClass);
BOOL CALLBACK FillTreeFromMSACMQueryCallback (HACMDRIVERID, DWORD_PTR, DWORD);
int __cdecl FillTreeFromMSACMSortCallback (const void *p1, const void *p2);
BOOL  InitAvailable       (HWND, int);
void  RemoveAvailable     (HWND);
BOOL  UserInstalled       (LPTSTR);
INT_PTR  RestartDlg          (HWND, unsigned, WPARAM, LPARAM);
INT_PTR  AddUnlistedDlg      (HWND, unsigned, WPARAM, LPARAM);
INT_PTR   AvailableDriversDlg (HWND, unsigned, WPARAM, LPARAM);
INT_PTR  AdvDlg              (HWND, unsigned, WPARAM, LPARAM);
void  ReBoot              (HWND);
BOOL  GetMappable         (PIDRIVER);
BOOL  SetMappable         (PIRESOURCE, BOOL);

#define REGSTR_PATH_WAVEMAPPER  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Wave Mapper")
#define REGSTR_VALUE_MAPPABLE   TEXT("Mappable")

#define REGSTR_PATH_MCI         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\MCI")
#define REGSTR_PATH_MCI32       TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\MCI32")
#define REGSTR_PATH_DRIVERS     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers")
#define REGSTR_PATH_DRIVERS32   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32")


/*
 * REALLOC - Allows expansion of GlobalAlloc()'d block while retaining contents
 *
 *    Newly-allocated portions of memory are initialized to zero, while
 *    the contents of reallocated portions of memory are retained.
 *
 * Parameters:
 *    LPVOID   _pData....allocated array
 *    mysize_t _cOld.....current count of elements in allocated array
 *    mysize_t _cNew.....minimum number of elements requested
 *    mysize_t _cDelta...granularity of increase
 *
 * Example:
 *    {
 *    mysize_t   cElements = 0; // Number of elements allocated so far
 *    DataType  *aElements = NULL;  // Allocated array of DataType
 *
 *    // At this point, cElements == 0 (obviously)
 *
 *    REALLOC (aElements, cElements, 10, 16)
 *
 *    // The line above requested 10 elements, and indicated that elements
 *    // should be allocated in increments of 16.  So cElements is 16 at this
 *    // point (thus, sizeof(aElements) == sizeof(DataType)*16).
 *
 *    REALLOC (aElements, cElements, 12, 16)
 *
 *    // The line above requested 12 elements.  Since cElements is already 16,
 *    // REALLOC knows that 12 elements are already available--and does nothing.
 *
 *    REALLOC (aElements, cElements, 17, 16)
 *
 *    // The line above requested 17 elements, in increments of 16.  aElements
 *    // has been reallocated to contain 32 elements, and cElements is
 *    // therefore 32.
 *
 *    GlobalFree ((HGLOBAL)aElements);  // All done!
 *    aElements = NULL;
 *    cElements = 0;
 *    }
 *
 *
 */

typedef signed long mysize_t;

#ifdef REALLOC
#undef REALLOC
#endif
#define REALLOC(_pData,_cOld,_cNew,_cDelta) \
        ReallocFn (sizeof(*_pData), (void **)&_pData, &_cOld, _cNew, _cDelta)

#ifdef DivRoundUp
#undef DivRoundUp
#endif
#define DivRoundUp(_a,_b) ( (LONG)(((_a) + (_b) -1) / (_b)) )

#ifdef RoundUp
#undef RoundUp
#endif
#define RoundUp(_a,_b) ( DivRoundUp(_a,_b) * (LONG)_b )

BOOL ReallocFn (mysize_t cbElement,
                LPVOID *ppOld, mysize_t *pcOld, mysize_t cNew, mysize_t cDelta)
{
   LPVOID     pNew;
   mysize_t   cbOld, cbNew;

            // First check if we actually need to reallocate or not.
            // It's possible that {ppOld} was already allocated with
            // enough space.
            //
   if ( ((*ppOld) != NULL)  && (cNew <= (*pcOld)) )
      return TRUE;

            // Oh well.  Determine how much space we need, and how much
            // is allocated now.
            //
   cNew  = RoundUp (cNew, cDelta);
   cbNew = cbElement * cNew;
   cbOld = (ppOld == NULL) ? 0 : (cbElement * (*pcOld));

            // Allocate the space and copy over the original contents.
            // Zero-fill the remaining space.
            //
   if ((pNew = (LPVOID)GlobalAlloc (GMEM_FIXED, cbNew)) == NULL)
      return FALSE;

   if (cbOld != 0)
      {
      memcpy (pNew, *ppOld, cbOld);
      GlobalFree ((HGLOBAL)(*ppOld));
      }

   memset (&((char*)pNew)[ cbOld ], 0x00, cbNew -cbOld);

            // Finally, update the passed-in pointers and we're done.
            //
   *pcOld = cNew;
   *ppOld = pNew;

   return TRUE;
}


/*
 * PIDRIVER ARRAY
 *
 * The AddIDrivers() routine LocalAlloc()'s a single IDRIVER structure
 * for each installed device driver.  Pointers to these structures are
 * retained in the InstalledDriver array, and indices into this array
 * are stored as the LPARAM values for each tree item.  Each element
 * in the array stores not only a pointer to the driver's IDRIVER structure,
 * but also a DWORD which, as a combination of aDriverRoot[].dwBit values,
 * reflects the tree root items under which the driver has tree items.
 *
 */

typedef struct  // InstalledDriver
   {
   PIDRIVER  pIDriver;     // Pointer to AddIDrivers()'s PIDRIVER structure
   DWORD     dwBits;       // Combination of aDriverRoot[].dwBit flags
   } InstalledDriver;

InstalledDriver  *aInstalledDrivers = NULL;
mysize_t          cInstalledDrivers = 0;

#define NOPIDRIVER  ((LPARAM)-1)



/*
 *  CheckSectionAccess()
 *
 *  See if we can read/write to a given section
 */


 BOOL CheckSectionAccess(TCHAR *szIniFile, TCHAR *SectionName)
 {
     static TCHAR TestKey[] = TEXT("TestKey!!!");
     static TCHAR TestData[] = TEXT("TestData");
     static TCHAR ReturnData[50];

    /*
     *   Check we can write, read back and delete our key
     */

     return WritePrivateProfileString(SectionName,
                                      TestKey,
                                      TestData,
                                      szIniFile) &&

            GetPrivateProfileString(SectionName,
                                    TestKey,
                                    TEXT(""),
                                    ReturnData,
                                    sizeof(ReturnData) / sizeof(TCHAR),
                                    szIniFile) == (DWORD)wcslen(TestData) &&

            WritePrivateProfileString(SectionName,
                                      TestKey,
                                      NULL,
                                      szIniFile);
 }


/*
 *  CheckIniAccess()
 *
 *  Checks access to our 2 .ini file sections - DRIVERS_SECTION and
 *  MCI_SECTION by just writing and reading some junk
 *
 *  Basically if we don't have access to these sections we're not
 *  going to allow Add and Remove.  The individual MCI drivers must
 *  take care not to put their data into non-writeable storage although
 *  this completely messes up the default parameters thing so we're going
 *  to put these into a well-known key in the win.ini file (ie per user).
 *
 */

 BOOL CheckIniAccess(void)
 {
     return CheckSectionAccess(szSysIni, szDrivers) &&
            CheckSectionAccess(szSysIni, szMCI) &&
            CheckSectionAccess(szControlIni, szUserDrivers) &&
            CheckSectionAccess(szControlIni, szDriversDesc) &&
            CheckSectionAccess(szControlIni, szRelatedDesc);
 }

/*
 *  QueryRemoveDrivers()
 *
 *  Ask the user if they're sure.  If the Driver is one required by the
 *  system (ie not listed in [Userinstallable.drivers] in control.ini)
 *  warn the user of that too.
 */

 BOOL QueryRemoveDrivers(HWND hDlg, LPTSTR szKey, LPTSTR szDesc)
 {
     TCHAR bufout[MAXSTR];

     if (UserInstalled(szKey))
          wsprintf(bufout, szRemoveOrNot, (LPTSTR)szDesc);
     else
          wsprintf(bufout, szRemoveOrNotStrict, (LPTSTR)szDesc);

     return (MessageBox(hDlg, bufout, szRemove,
                    MB_ICONEXCLAMATION | MB_TASKMODAL | MB_YESNO) == IDYES );
 }

/*
 *  GetProfile()
 *
 *  Get private profile strings.
 */

 LPTSTR GetProfile(LPTSTR pstrAppName, LPTSTR pstrKeyName, LPTSTR pstrIniFile,
                 LPTSTR pstrRet, int cbSize)
 {
     TCHAR szNULL[2];

     szNULL[0] = TEXT('\0');
     GetPrivateProfileString(pstrAppName, (pstrKeyName==NULL) ? NULL :
         (LPTSTR)pstrKeyName, szNULL, pstrRet, cbSize/sizeof(TCHAR), pstrIniFile);
     return(pstrRet);
 }

/*********************************************************************
 *
 *  AddIDrivers()
 *
 *  Add drivers in the passed key strings list to the InstalledDrivers array
 *
 *********************************************************************/

void AddIDrivers(HWND hWnd, LPTSTR pstrKeys, LPTSTR pstrSection)
{
    PIDRIVER    pIDriver;
    LPTSTR        pstrKey;
    LPTSTR        pstrDesc;

    pstrKey = pstrKeys;
    pstrDesc = (LPTSTR)LocalAlloc(LPTR, (MAXSTR * sizeof(TCHAR)));

	if (!pstrDesc) return;

   /*
    *  parse key strings for profile, and make IDRIVER structs
    */

    while ( *pstrKey )
    {
        pIDriver = (PIDRIVER)LocalAlloc(LPTR, sizeof(IDRIVER));
        if ( pIDriver )
        {
            LPTSTR        pstr;

            if (*GetProfile(pstrSection, pstrKey, szSysIni, pIDriver->szFile,
                sizeof(pIDriver->szFile)) == TEXT('\0'))
            {
                LocalFree((HANDLE)pIDriver);
                goto nextkey;
            }

            for ( pstr=pIDriver->szFile; *pstr && (*pstr!=COMMA) &&
                (*pstr!=SPACE); pstr++ )
                    ;
            *pstr = TEXT('\0');

#ifdef TRASHDRIVERDESC
            if (bDescFileValid)
#endif
              /*
               *  try to load the cached description
               */

               GetProfile(szDriversDesc,
                          pIDriver->szFile,
                          szControlIni,
                          pIDriver->szDesc,
                          sizeof(pIDriver->szDesc));

           /*
            *  if we failed, then try to get the information from
            *  mmdriver.inf or the exehdr
            */

            if (pIDriver->szDesc[0] == TEXT('\0'))
            {
               int nResult = LoadDescFromFile(pIDriver, pstrKey, pstrDesc, MAXSTR);
			   if( nResult == DESC_ERROR	
			   ||  nResult == DESC_NOFILE ) 
			   {
                    LocalFree((HANDLE)pIDriver);
                    goto nextkey;
			   }
			   else
               {
                   if (!*pstrDesc)
                   {
                       /*
                        *  failed to load a description.
                        *  The file isn't in setup.inf
                        *  and doesn't have exehdr information
                        */

                        lstrcpy(pIDriver->szDesc, pIDriver->szFile);
                        lstrcat(pIDriver->szDesc, szNoDesc);
                   }
                   else
                        lstrcpy(pIDriver->szDesc, pstrDesc);

                   WritePrivateProfileString(szDriversDesc, pIDriver->szFile,
                               pIDriver->szDesc, szControlIni);
               }
            }

            wcsncpy(pIDriver->szAlias, pstrKey, sizeof(pIDriver->szAlias)/sizeof(TCHAR));
            pIDriver->szAlias[sizeof(pIDriver->szAlias)/sizeof(TCHAR) - 1] = TEXT('\0');
            wcscpy(pIDriver->wszAlias, pIDriver->szAlias);

            wcsncpy(pIDriver->szSection, pstrSection,sizeof(pIDriver->szSection)/sizeof(TCHAR));
            pIDriver->szSection[sizeof(pIDriver->szSection)/sizeof(TCHAR) - 1] = TEXT('\0');
            wcscpy(pIDriver->wszSection, pIDriver->szSection);

            pIDriver->KernelDriver = IsFileKernelDriver(pIDriver->szFile);
            pIDriver->fQueryable = pIDriver->KernelDriver ? 0 : -1;

            pIDriver->lp = 0L;

            if (!AddIDriverToArray (pIDriver))
               LocalFree((HANDLE)pIDriver);
        }
        else
           break;  //ERROR Low Memory

nextkey: while (*pstrKey++);
    }
    LocalFree((HANDLE)pstrDesc);
}


/*
 * AddIDriverToArray - Adds the given PIDRIVER to the InstalledDrivers array
 *
 */

BOOL AddIDriverToArray (PIDRIVER pIDriver)
{
    mysize_t  ii;

    if (pIDriver == NULL)
    {
        return FALSE;
    }

            // Don't create duplicate entries in this array; one PIDRIVER
            // per driver-file is sufficient.
            //
    for (ii = 0; ii < cInstalledDrivers; ++ii)
    {
        if (aInstalledDrivers[ ii ].pIDriver != NULL)
        {
            if (!lstrcmpi (aInstalledDrivers[ ii ].pIDriver->szFile,
                           pIDriver->szFile))
            {
                return FALSE;
            }
        }
    }

            // To reduce repetitive calls to GlobalAlloc(), we'll allocate
            // space for an additional 50 InstalledDriver entries within
            // the aInstalledDrivers array each time we run out of space.
            //
#define nDriverEntriesToAllocAtONCE   50

    for (ii = 0; ii < cInstalledDrivers; ++ii)
    {
        if (aInstalledDrivers[ ii ].pIDriver == NULL)
            break;
    }

    if (ii >= cInstalledDrivers)
    {
        if (!REALLOC (aInstalledDrivers,   // Array
                      cInstalledDrivers,   // Current size of array
                      1+ii,                // Requested size of array
                      nDriverEntriesToAllocAtONCE))
        {
            return FALSE;
        }
    }

    aInstalledDrivers[ ii ].pIDriver = pIDriver;
    aInstalledDrivers[ ii ].dwBits = 0L;

    return TRUE;
}


/*********************************************************************
 *
 *  FindInstallableDriversSection()
 *
 *********************************************************************/

PINF FindInstallableDriversSection(PINF pinf)
{
    PINF pinfFound;

    pinfFound = infFindSection(pinf, szMDrivers32);

    if (pinfFound == NULL) {
        pinfFound = infFindSection(pinf, szMDrivers);
    }

    return pinfFound;
}

//NOTE: Returns nSize as a count of bytes, not characters (later calls expect this)
int GetINISectionSize(LPCTSTR pstrSection, LPCTSTR pstrFile)
{
    int ncbSize = 0;
    int ncbMaxSize = 0;

    while (ncbSize >= ncbMaxSize)
    {
        TCHAR szNULL[2];
        LPTSTR pStr = NULL;

        szNULL[0] = TEXT('\0');

        ncbMaxSize += SECTION; //allocate another 512 bytes

        pStr = (LPTSTR)LocalAlloc(LPTR, ncbMaxSize);

        if (!pStr)
        {
            //we're trying to allocate too much memory ...
            //drop out and use the last smaller size that worked
            break;
        }

        ncbSize = GetPrivateProfileString(pstrSection, NULL, szNULL, pStr, ncbMaxSize/sizeof(TCHAR), pstrFile);
        ncbSize = (ncbSize+2) * sizeof(TCHAR);  //convert to byte count, adding two chars
                                                //to account for terminating null and API's truncation

        LocalFree(pStr);
    }

    return (ncbSize);
}


/*********************************************************************
 *
 *  InitInstalled()
 *
 *  Add the drivers installed in [DRIVERS] and [MCI] to the Installed
 *  Drivers list box.
 *
 *********************************************************************/

BOOL InitInstalled(HWND hWnd, LPTSTR pstrSection)
{
    BOOL    bSuccess=FALSE;
    LPTSTR    pstr;
    int nSize = SECTION;

#ifdef TRASHDRIVERDESC
    UINT    wTime;
    BOOL    fForce;
    TCHAR    szOut[10];

    wTime = LOWORD(GetFileDateTime(szControlIni)) >> 1;
    if (fForce = (GetPrivateProfileInt((LPTSTR)szUserDrivers,
                   (LPTSTR)szLastQuery,  0, (LPTSTR)szControlIni) != wTime))
    {
        wsprintf(szOut, TEXT("%d"), wTime);
        WritePrivateProfileString((LPTSTR)szUserDrivers, (LPTSTR)szLastQuery,
                                        szOut, (LPTSTR)szControlIni);
        WritePrivateProfileString((LPTSTR)szDriversDesc, NULL, NULL,
                                                (LPTSTR)szControlIni);
        bDescFileValid = FALSE;
    }
    else
        bDescFileValid = TRUE;
#endif

    nSize = GetINISectionSize(pstrSection, szSysIni);

    pstr = (LPTSTR)LocalAlloc(LPTR, nSize);
    if ( pstr )
    {
        if (*GetProfile(pstrSection, NULL, szSysIni, pstr, nSize ))
        {
            AddIDrivers(hWnd,pstr,pstrSection);
            bSuccess = TRUE;
        }

        LocalFree((HANDLE)pstr);
    }

    return(bSuccess);
}


/*
 * RefreshAdvDlgTree - Clears the Devices tree, and fills it back in
 *
 */

void RefreshAdvDlgTree (void)
{
   if (hAdvDlgTree != NULL)
      {
      SendMessage (hAdvDlgTree, WM_SETREDRAW, FALSE, 0L);

      FreeAdvDlgTree (hAdvDlgTree);
      InitAdvDlgTree (hAdvDlgTree);
      InitInstalled (GetParent (hAdvDlgTree), szDrivers);
      InitInstalled (GetParent (hAdvDlgTree), szMCI);
      FillTreeInAdvDlg (hAdvDlgTree, NULL);

      SendMessage (hAdvDlgTree, WM_SETREDRAW, TRUE, 0L);
      }
}


/*
 * FillTreeInAdvDlg - Adds TreeItems for each entry in aInstalledDrivers
 *
 * If pIDriver is specified, the first treeitem to mention that driver
 * will be highlighted.
 *
 */

BOOL FillTreeInAdvDlg (HWND hTree, PIDRIVER pIDriver)
{
   if (!FillTreeFromWinMM (hTree))
      return FALSE;

   if (!FillTreeFromMSACM (hTree))
      return FALSE;

   if (!FillTreeFromMCI (hTree))
      return FALSE;

   if (!FillTreeFromMIDI (hTree))
      return FALSE;

   if (!FillTreeFromRemaining (hTree))
      return FALSE;

   if (pIDriver != NULL)    // Do we have to highlight a pIDriver?
      {
      short idr;

      for (idr = 0; idr < nDriverROOTS; idr++)
         {
         HTREEITEM  hti;

         if ((hti = aDriverRoot[ idr ].hti) == NULL)
            continue;

         for (hti = TreeView_GetChild (hTree, hti);
              hti != NULL;
              hti = TreeView_GetNextSibling (hTree, hti))
            {
            if (pIDriver == FindIDriverByTreeItem (hti))
               {
               TreeView_SelectItem (hTree, hti);
               break;
               }
            }

         if (hti != NULL)   // Found and selected a TreeItem?
            break;  // Then we're done!
         }
      }

   return TRUE;
}


/*
 * FillTreeFromWinMM - Adds tree items for all WinMM-controlled MM devices
 *
 * This routine adds tree items under the following DriverClasses:
 *    dcWAVE    - waveOut*
 *    dcMIXER   - mixer*
 *    dcAUX     - aux*
 *
 */

BOOL FillTreeFromWinMM (HWND hTree)
{
   UINT     iDevice;
   UINT     cDevices;
   WCHAR    szDriver[ cchRESOURCE ];

            // Add entries for each waveOut device
            //
   cDevices = waveOutGetNumDevs ();
   for (iDevice = 0; iDevice < cDevices; ++iDevice)
      {
      if (waveOutMessage (HWAVEOUT_INDEX(iDevice),
                          DRV_QUERYFILENAME,
                          (DWORD_PTR)szDriver,
                          (DWORD_PTR)cchRESOURCE) == MMSYSERR_NOERROR)
         {
         AddIDriverByName (hTree, szDriver, dcWAVE);
         }
      }

            // Add entries for each mixer device
            //
   cDevices = mixerGetNumDevs ();
   for (iDevice = 0; iDevice < cDevices; ++iDevice)
      {
      if (mixerMessage (HMIXER_INDEX(iDevice),
                        DRV_QUERYFILENAME,
                        (DWORD_PTR)szDriver,
                        (DWORD_PTR)cchRESOURCE) == MMSYSERR_NOERROR)
         {
         AddIDriverByName (hTree, szDriver, dcMIXER);
         }
      }

            // Add entries for each aux device
            //
   cDevices = auxGetNumDevs ();
   for (iDevice = 0; iDevice < cDevices; ++iDevice)
      {
      if (auxOutMessage (iDevice,
                         DRV_QUERYFILENAME,
                         (DWORD_PTR)szDriver,
                         (DWORD_PTR)cchRESOURCE) == MMSYSERR_NOERROR)
         {
         AddIDriverByName (hTree, szDriver, dcAUX);
         }
      }

   return TRUE;
}


/*
 * FillTreeFromMSACM - Adds tree items for all MSACM-controlled MM devices
 *
 * This routine adds tree items under the following DriverClasses:
 *    dcACODEC  - acmDriverEnum()
 *
 * Note that, since audio codecs are supposed to be sorted in the tree,
 * all audio codec treeitems are first deleted from the tree (if there
 * are any at this point) then all audio codecs are added in their
 * sorted order.
 *
 */

typedef struct
   {
   DWORD     dwPriority;    // priority of this audio codec
   PIDRIVER  pIDriver;      // matching driver file (or NULL)
   WORD      wMid;          // manufacturer ID
   WORD      wPid;          // product ID
   TCHAR      szDesc[ ACMDRIVERDETAILS_LONGNAME_CHARS ];
   } AudioCodec;

AudioCodec  *pCodecs;
mysize_t     cCodecs;

extern BOOL gfLoadedACM;   // From MSACMCPL.C

BOOL FillTreeFromMSACM (HWND hTree)
{
   MMRESULT  mmr;
   short     idr;
   mysize_t  ii;

   if (!gfLoadedACM)
      {
      if (LoadACM())
         gfLoadedACM = TRUE;
      }
   if (!gfLoadedACM)
      return FALSE;

            // Step one: get rid of any audio codecs listed in the tree
            //
   if ((idr = DriverClassToRootIndex (dcACODEC)) != -1)
      {
      if (aDriverRoot[ idr ].hti != NULL)
         {
         HTREEITEM hti;

         while ((hti = TreeView_GetChild (hTree, aDriverRoot[ idr ].hti)) != 0)
            {
            TreeView_DeleteItem (hTree, hti);

            if (hti == TreeView_GetChild (hTree, aDriverRoot[ idr ].hti))
               break;  // if it didn't delete, make sure we don't loop forever!
            }
         }

      for (ii = 0; ii < cInstalledDrivers; ++ii)
         {
         aInstalledDrivers[ ii ].dwBits &= ~aDriverRoot[ idr ].dwBit;
         }
      }

            // Step two: query ACM to obtain the list of codecs
            //
   pCodecs = NULL;
   cCodecs = 0;

   mmr = (MMRESULT)acmDriverEnum (FillTreeFromMSACMQueryCallback,
                        0,
                        ACM_DRIVERENUMF_NOLOCAL | ACM_DRIVERENUMF_DISABLED);

               // Step three: sort the list of codecs and add each to the tree
               //
   if ((mmr == MMSYSERR_NOERROR) && (pCodecs != NULL))
      {
      mysize_t  iiDr;

      qsort (pCodecs, (size_t)cCodecs, sizeof(AudioCodec),
             FillTreeFromMSACMSortCallback);

                  // Assign lp=wMid+wPid for each audio codec we find
                  //
      for (iiDr = 0; iiDr < cInstalledDrivers; ++iiDr)
         {
         if (aInstalledDrivers[ iiDr ].pIDriver == NULL)
            continue;
         if (aInstalledDrivers[ iiDr ].pIDriver->lp != 0L)  // already did this
            continue;

         if (GuessDriverClass (aInstalledDrivers[ iiDr ].pIDriver) == dcACODEC)
            {
            HANDLE hDriver;

            hDriver = OpenDriver (aInstalledDrivers[iiDr].pIDriver->wszAlias,
                                  aInstalledDrivers[iiDr].pIDriver->wszSection,
                                  0L);
            if (hDriver != NULL)
               {
               ACMDRIVERDETAILSW add;
               memset ((TCHAR *)&add, 0x00, sizeof(add));
               add.cbStruct = sizeof(add);
               SendDriverMessage (hDriver, ACMDM_DRIVER_DETAILS, (LONG_PTR)&add, 0);
               CloseDriver (hDriver, 0L, 0L);

               aInstalledDrivers[ iiDr ].pIDriver->lp = MAKELONG( add.wMid,
                                                                  add.wPid );
               }
            }
         }

                  // Search for installed drivers with matching lp=wMid+wPid's
                  //
      for (iiDr = 0; iiDr < cInstalledDrivers; ++iiDr)
         {
         if (aInstalledDrivers[ iiDr ].pIDriver == NULL)
            continue;

         if ((aInstalledDrivers[ iiDr ].pIDriver->szAlias[0] == TEXT('\0')) ||
             (GuessDriverClass (aInstalledDrivers[iiDr].pIDriver) == dcACODEC))
            {
            for (ii = 0; ii < cCodecs; ++ii)
               {
               if (pCodecs[ ii ].dwPriority == 0)
                  continue;

               if ( (pCodecs[ ii ].wMid ==
                     LOWORD( aInstalledDrivers[ iiDr ].pIDriver->lp )) &&
                    (pCodecs[ ii ].wPid ==
                     HIWORD( aInstalledDrivers[ iiDr ].pIDriver->lp )) )
                  {
                  pCodecs[ ii ].pIDriver = aInstalledDrivers[ iiDr ].pIDriver;
                  break;
                  }
               }
            }
         }

                  // Add each in-use entry in pCodecs to the treeview
                  //
      for (ii = 0; ii < cCodecs; ++ii)
         {
         if (pCodecs[ ii ].dwPriority == 0)
            continue;

                     // The PCM converter, for instance, won't have a matching
                     // PID.  So create a bogus one--the lack of an szAlias
                     // will let us know it's bogus--and insert it into the
                     // aInstalledDrivers array.
                     //
         if (pCodecs[ ii ].pIDriver == NULL)
            {
            PIDRIVER  pid = (PIDRIVER)LocalAlloc(LPTR, sizeof(IDRIVER));

            if (pid != NULL)
               {
               memset (pid, 0x00, sizeof(IDRIVER));
               pid->lp = MAKELONG( pCodecs[ ii ].wMid, pCodecs[ ii ].wPid );
               lstrcpy (pid->szDesc, pCodecs[ ii ].szDesc);

               if (!AddIDriverToArray (pid))
                  LocalFree ((HLOCAL)pid);
               else
                  {
                  pCodecs[ ii ].pIDriver = pid;
                  }
               }
            }

         if (pCodecs[ ii ].pIDriver != NULL)
            {
            AddIDriver (hTree, pCodecs[ ii ].pIDriver, dcACODEC);
            }
         }
      }

               // Cleanup
               //
   if (pCodecs != NULL)
      {
      GlobalFree ((HGLOBAL)pCodecs);
      pCodecs = NULL;
      cCodecs = 0;
      }

   return (mmr == MMSYSERR_NOERROR) ? TRUE : FALSE;
}


/*
 * FillTreeFromMCI - Adds tree items for all MCI devices
 *
 * This routine adds tree items under the following DriverClasses:
 *    dcMCI     - mciSendCommand
 *
 */

BOOL FillTreeFromMCI (HWND hTree)
{
   MCI_SYSINFO_PARMS mciSysInfo;
   TCHAR szAlias[ cchRESOURCE ];

            // How many MCI devices does WinMM know about?
            //
   memset ((TCHAR *)&mciSysInfo, 0x00, sizeof(mciSysInfo));
   mciSysInfo.lpstrReturn = szAlias;
   mciSysInfo.dwRetSize = cchLENGTH(szAlias);
   mciSysInfo.wDeviceType = MCI_ALL_DEVICE_ID;

   if (mciSendCommand (MCI_ALL_DEVICE_ID,
                       MCI_SYSINFO,
                       MCI_SYSINFO_QUANTITY,
                       (DWORD_PTR)&mciSysInfo) == 0)
      {
      DWORD    iDevice;
      DWORD    cDevices;

      cDevices = *((DWORD *)(mciSysInfo.lpstrReturn));

               // Get the name of each MCI device in turn.
               //
      for (iDevice = 0; iDevice < cDevices; ++iDevice)
         {
         mysize_t ii;

         memset ((TCHAR *)&mciSysInfo, 0x00, sizeof(mciSysInfo));
         mciSysInfo.lpstrReturn = szAlias;
         mciSysInfo.dwRetSize = cchLENGTH(szAlias);
         mciSysInfo.wDeviceType = MCI_ALL_DEVICE_ID;
         mciSysInfo.dwNumber = 1+iDevice;  // note: 1-based, not 0-based!

         if (mciSendCommand (MCI_ALL_DEVICE_ID,
                             MCI_SYSINFO,
                             MCI_SYSINFO_NAME,
                             (DWORD_PTR)&mciSysInfo) != 0)
            {
            continue;
            }

                  // Got an alias--search the InstalledDrivers array
                  // and try to find a matching PIDRIVER.
                  //
         for (ii = 0; ii < cInstalledDrivers; ++ii)
            {
            if (aInstalledDrivers[ ii ].pIDriver == NULL)
               continue;
            if (!lstrcmpi (aInstalledDrivers[ ii ].pIDriver->szAlias, szAlias))
               {
#ifdef GET_MCI_DEVICE_DESCRIPTIONS_FROM_THEIR_DEVICES
               MCI_OPEN_PARMS  mciOpen;
               MCI_INFO_PARMS  mciInfo;
               MCIERROR        rc;

                        // It's an installed, functioning, happy MCI device.
                        // Open it up and see what it calls itself; update the
                        // description in the PIDRIVER (what's in there was
                        // obtained from the registry, thus from MMDRIVER.INF,
                        // and we instead want what Media Player lists in its
                        // Device menu).
                        //
               memset ((TCHAR *)&mciOpen, 0x00, sizeof(mciOpen));
               mciOpen.lpstrDeviceType = szAlias;

               rc = mciSendCommand (0,MCI_OPEN,MCI_OPEN_TYPE,(DWORD)&mciOpen);
               if (rc == MCIERR_MUST_USE_SHAREABLE)
                  {
                  rc = mciSendCommand (0, MCI_OPEN,
                                       MCI_OPEN_TYPE | MCI_OPEN_SHAREABLE,
                                       (DWORD)&mciOpen);
                  }
               if (rc == 0)
                  {
                  TCHAR szDesc[ cchRESOURCE ];
                  szDesc[0] = 0;

                  mciInfo.lpstrReturn = szDesc;
                  mciInfo.dwRetSize = cchLENGTH(szDesc);

                  if (mciSendCommand (mciOpen.wDeviceID,
                                      MCI_INFO,
                                      MCI_INFO_PRODUCT,
                                      (DWORD)&mciInfo) == 0)
                     {
                     lstrcpy (aInstalledDrivers[ ii ].pIDriver->szDesc, szDesc);
                     }

                  mciSendCommand (mciOpen.wDeviceID, MCI_CLOSE, 0L, 0);
                  }
#endif // GET_MCI_DEVICE_DESCRIPTIONS_FROM_THEIR_DEVICES

               AddIDriver (hTree, aInstalledDrivers[ ii ].pIDriver, dcMCI);
               break;
               }
            }
         }
      }

   return TRUE;
}


/*
 * FillTreeFromMIDI - Adds tree items for all MIDI devices and instruments
 *
 * This routine adds tree items under the following DriverClasses:
 *    dcMIDI    - LoadInstruments() provides necessary data
 *
 */

BOOL FillTreeFromMIDI (HWND hTree)
{
   MCMIDI mcm;
   UINT   iiRoot;
   int    idrMIDI;

   if ((idrMIDI = DriverClassToRootIndex (dcMIDI)) == -1)
   return FALSE;

            // First load in all relevant information regarding MIDI
            // instruments.  Fortunately, all that work is encapsulated
            // nicely within one routine.
            //
   memset (&mcm, 0x00, sizeof(mcm));
   LoadInstruments (&mcm, FALSE);

            // Each entry in mcm's api array is one of three things:
            //  - a parent (say, a sound card)
            //  - a child (say, an external instrument)
            //  - the "(none)" thing that we want to skip
            //
            // Add each parent to the tree, and when we find a parent,
            // add all its children.
            //
   for (iiRoot = 0; iiRoot < mcm.nInstr; ++iiRoot)
      {
      TCHAR    szName[ MAXSTR ];
      LPTSTR   pch;
      PIDRIVER pid;

      if (mcm.api[ iiRoot ] == NULL)
         continue;
      if (mcm.api[ iiRoot ]->piParent != NULL)
         continue;
      if (mcm.api[ iiRoot ]->szKey[0] == TEXT('\0'))
         continue;

               // Found a parent!  If we can match it to an installed driver,
               // add it to the tree.  Note that mcm.api[]->szKey will
               // be of the form "MMDRV.DLL<0000>"--we need to strip off
               // the "<0000>" before we can match this thing to a PIDRIVER.
               //
      lstrcpy (szName, mcm.api[ iiRoot ]->szKey);
      if ((pch = lstrchr (szName, TEXT('<'))) != NULL)
         *pch = TEXT('\0');

      if ((pid = FindIDriverByName (szName)) != NULL)
         {
         HTREEITEM hti;
         UINT      ii;
         TV_ITEM   tvi;

         if ((hti = AddIDriver (hTree, pid, dcMIDI)) == NULL)
            continue;

#if 0
         tvi.mask = TVIF_TEXT;
         tvi.hItem = hti;
         tvi.pszText = mcm.api[ iiRoot ]->szFriendly;
         TreeView_SetItem(hTree, &tvi);
#endif

                  // We've added this parent.  See if it has any children,
                  // and if so, stick 'em in the tree.
                  //
         for (ii = 0; ii < mcm.nInstr; ++ii)
            {
            PINSTRUM lp;
            TV_INSERTSTRUCT ti;

            if (mcm.api[ ii ] == NULL)
               continue;
            if (mcm.api[ ii ]->piParent != mcm.api[ iiRoot ])
               continue;

                     // Yep--it's got a parent.  Allocate a second copy
                     // of this PINSTRUM; that copy will be our LPARAM value.
                     //
            if ((lp = (PINSTRUM)LocalAlloc(LPTR,sizeof (INSTRUM))) == NULL)
               continue;
            memcpy ((TCHAR *)lp, (TCHAR *)mcm.api[ ii ], sizeof (INSTRUM));

                     // Now add a treeitem for this instrument.
                     //
            ti.hParent = hti;
            ti.hInsertAfter = TVI_LAST;
            ti.item.mask = TVIF_TEXT | TVIF_PARAM |
                           TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            ti.item.iImage = (int)idrMIDI;
            ti.item.iSelectedImage = (int)idrMIDI;
            ti.item.pszText = mcm.api[ ii ]->szFriendly;
            ti.item.lParam = (LPARAM)lp;

            if (!TreeView_InsertItem (hTree, &ti))
               break;
            }
         }
      }

            // Done--cleanup and we're out of here.
            //
   FreeInstruments (&mcm);

   if (mcm.hkMidi)
      RegCloseKey (mcm.hkMidi);

   return TRUE;
}


            // To reduce repetitive calls to GlobalAlloc(), we'll allocate
            // space for an additional 10 AudioCodec entries within
            // the pCodecs array each time we run out of space.
            //
#define nAudioCodecEntriesToAllocAtONCE   10

BOOL CALLBACK FillTreeFromMSACMQueryCallback (HACMDRIVERID hadid,
                                              DWORD_PTR dwUser,
                                              DWORD fdwSupport)
{
   short       ii;
   AudioCodec *pac;
   ACMDRIVERDETAILS add;

            // Find or create a place in which to store information
            // about this codec
            //
   for (ii = 0; ii < cCodecs; ++ii)
      {
      if (pCodecs[ ii ].dwPriority == 0)
         break;
      }
   if (ii >= cCodecs)
      {
        if (!REALLOC (pCodecs, cCodecs, 1+ii, nAudioCodecEntriesToAllocAtONCE))
            return FALSE;
      }
   pac = &pCodecs[ ii ];    // for shorthand

            // Find out about this codec
            //
   memset ((TCHAR *)&add, 0x00, sizeof(add));
   add.cbStruct = sizeof(add);
   if (acmDriverDetails (hadid, &add, 0) == MMSYSERR_NOERROR)
      {
      acmMetrics ((HACMOBJ)hadid,ACM_METRIC_DRIVER_PRIORITY,&pac->dwPriority);

      lstrcpy (pac->szDesc, add.szLongName);

      pac->wMid = add.wMid;
      pac->wPid = add.wPid;

      pac->pIDriver = NULL;
      }

   return TRUE; // keep counting
}


int __cdecl FillTreeFromMSACMSortCallback (const void *p1, const void *p2)
{
   if (((AudioCodec *)p1)->dwPriority == 0)
      return 1;
   if (((AudioCodec *)p2)->dwPriority == 0)
      return -1;
   return ((AudioCodec *)p1)->dwPriority - ((AudioCodec *)p2)->dwPriority;
}



/*
 * FillTreeFromRemaining - Adds tree items for all remaining MM devices
 *
 * This routine adds a single tree item for each entry in the aInstalledDrivers
 * array which is not already represented somewhere in the tree.  The
 * classification is based on the driver's alias--if that fails, it is lumped
 * under dcOTHER.
 *
 */

BOOL FillTreeFromRemaining (HWND hTree)
{
   mysize_t ii;

   for (ii = 0; ii < cInstalledDrivers; ++ii)
      {
      UINT iiSkipCheck;

      if (aInstalledDrivers[ ii ].pIDriver == NULL)
         continue;
      if (aInstalledDrivers[ ii ].pIDriver->szAlias[0] == TEXT('\0'))
         continue;

            // (don't do this for any not-to-be-displayed drivers)
            //
      for (iiSkipCheck = 0; iiSkipCheck < nDriversToSKIP; iiSkipCheck++)
         {
         if (!FileNameCmp ((LPTSTR)aDriversToSKIP[ iiSkipCheck ],
                           (LPTSTR)aInstalledDrivers[ ii ].pIDriver->szFile))
            break;
         }
      if (iiSkipCheck < nDriversToSKIP)
         continue;

            // Zip through the {drivers,drivers32,mci,mci32} sections, to
            // try to classify this driver. If we find a classification
            // for which we haven't already added an entry in the tree,
            // add another.
            //
      FillTreeFromRemainingBySection (hTree,
                                      ii,
                                      REGSTR_PATH_DRIVERS,
                                      dcINVALID);

      FillTreeFromRemainingBySection (hTree,
                                      ii,
                                      REGSTR_PATH_DRIVERS32,
                                      dcINVALID);

      FillTreeFromRemainingBySection (hTree,
                                      ii,
                                      REGSTR_PATH_MCI,
                                      dcMCI);

      FillTreeFromRemainingBySection (hTree,
                                      ii,
                                      REGSTR_PATH_MCI32,
                                      dcMCI);

            // If the dwBits element is zero, then this driver hasn't
            // already been assigned a treeitem elsewhere.  In that event,
            // call AddIDriver() with dcOTHER--to tell it to lump this
            // driver under "Other Drivers".
            //
      if (aInstalledDrivers[ ii ].dwBits == 0)
         {
         AddIDriver (hTree, aInstalledDrivers[ ii ].pIDriver, dcOTHER);
         }
      }

   return TRUE;
}


void FillTreeFromRemainingBySection (HWND hTree,
                                     long iiDriver,
                                     LPCTSTR pszSection,
                                     DriverClass dcSection)
{
   HKEY hk;
   UINT ii;

   if (RegOpenKey (HKEY_LOCAL_MACHINE, pszSection, &hk))
      return;

   for (ii = 0; ; ++ii)
      {
      TCHAR  szLHS[ cchRESOURCE ];
      TCHAR  szRHS[ cchRESOURCE ];
      DWORD  dw1;
      DWORD  dw2;
      DWORD  dw3;

      dw1 = cchRESOURCE;
      dw3 = cchRESOURCE;
      if (RegEnumValue (hk, ii,  szLHS, &dw1,
                        0, &dw2, (LPBYTE)szRHS, &dw3) != ERROR_SUCCESS)
         {
         break;
         }

      if (!FileNameCmp (szRHS, aInstalledDrivers[ iiDriver ].pIDriver->szFile))
         {
         DriverClass dc;

         if ((dc = dcSection) == dcINVALID)
            dc = GuessDriverClassFromAlias (szLHS);

         if ((dc == dcINVALID) || (dc == dcOTHER))
            continue;

         (void)AddIDriver (hTree, aInstalledDrivers[ iiDriver ].pIDriver, dc);
         }
      }

   RegCloseKey (hk);
}


#ifdef FIX_BUG_15451
HWND MakeThisCPLLookLikeTheOldCPL (HWND hWndCPL)
{
   TCHAR  szTitle[ cchRESOURCE ];
   HWND   hWndOldCPL = NULL;

   GetWindowText (hWndCPL, szTitle, cchRESOURCE);

   for (hWndOldCPL = GetWindow (hWndCPL, GW_HWNDFIRST);
        hWndOldCPL != NULL;
        hWndOldCPL = GetWindow (hWndOldCPL, GW_HWNDNEXT))
      {
      TCHAR  szTitleTest[ cchRESOURCE ];
      GetWindowText (hWndOldCPL, szTitleTest, cchRESOURCE);
      if ( (!lstrcmpi (szTitle, szTitleTest)) && (hWndCPL != hWndOldCPL) )
         {
         RECT  rOld;
         GetWindowRect (hWndOldCPL, &rOld);
         SetWindowPos (hWndCPL, hWndOldCPL, rOld.left, rOld.top,
                       0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
         SetWindowPos (hWndOldCPL, hWndCPL, 0, 0, 0, 0,
                       SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
         }
      }

    return hWndOldCPL;
}


HWND MakeThisDialogLookLikeTheOldDialog (HWND hDlg)
{
   TCHAR  szTitle[ cchRESOURCE ];
   RECT   rOld;
   POINT  pt;
   HWND   hWndOldDlg;

   GetWindowText (hDlg, szTitle, cchRESOURCE);

   for (hWndOldDlg = GetWindow (hDlg, GW_HWNDFIRST);
        hWndOldDlg != NULL;
        hWndOldDlg = GetWindow (hWndOldDlg, GW_HWNDNEXT))
      {
      TCHAR  szTitleTest[ cchRESOURCE ];
      GetWindowText (hWndOldDlg, szTitleTest, cchRESOURCE);
      if ( (!lstrcmpi (szTitle, szTitleTest)) && (hDlg != hWndOldDlg) )
         {
         GetWindowRect (hWndOldDlg, &rOld);

         SetWindowPos (hDlg, NULL, rOld.left, rOld.top, 0, 0,
                       SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

         return hWndOldDlg;
         }
      }

   return NULL;
}



BOOL WaitForNewCPLWindow (HWND hWndMyDlg)
{
   TCHAR  szTitle[ cchRESOURCE ];
   HWND   hWnd;
   DWORD  tickStart;

#define msecMAXWAIT   5000

   hWndMyDlg = GetParent (hWndMyDlg); // (hWndMyDlg was a property sheet)

   GetWindowText (hWndMyDlg, szTitle, cchRESOURCE);

   for (tickStart = GetTickCount();
        GetTickCount() - tickStart < msecMAXWAIT;)
      {
      MSG msg;

      for (hWnd = GetWindow (hWndMyDlg, GW_HWNDFIRST);
           hWnd != NULL;
           hWnd = GetWindow (hWnd, GW_HWNDNEXT))
         {
         TCHAR  szTitleTest[ cchRESOURCE ];
         if (!IsWindowVisible (hWnd))
            continue;
         GetWindowText (hWnd, szTitleTest, cchRESOURCE);
         if ( (!lstrcmpi (szTitle, szTitleTest)) && (hWnd != hWndMyDlg) )
            {
            PropSheet_PressButton (hWndMyDlg, PSBTN_CANCEL);
            hWnd = GetParent (GetParent (hAdvDlgTree));
            PropSheet_PressButton (hWnd, PSBTN_CANCEL);
            return TRUE;
            }
         }

      if (PeekMessage (&msg, NULL, 0, 0, PM_NOREMOVE))
         {
         if (GetMessage (&msg, NULL, 0, 0))
            {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
            }
         }
      }

   return FALSE;
}
#endif // FIX_BUG_15451


        // Prevent any more REMOVE button presses
        // Otherwise one can get stacked up and cause trouble,
        // particularly if it is assocated with a driver that
        // is automatically removed.  We have to use a static
        // as any focus changes cause the button to change state.
        //
static long fWorking = 0;




/********************************************************************
 *
 *  AdvDlg ()
 *
 *  Display list of installed installable drivers.  Return TRUE/FALSE
 *  indicating if should restart windows.
 *
 ********************************************************************/

const static DWORD aAdvDlgHelpIds[] = {  // Context Help IDs
    IDC_ADV_TREE,    IDH_GENERIC_DEVICES,
    ID_ADV_PROP,     IDH_ADV_PROPERTIES,
    ID_ADV_REMOVE,   IDH_MMCPL_DEVPROP_REMOVE,
    0, 0
};

void MapDriverClass(DWORD_PTR dwSetupClass)
{
    g_dcFilterClass = dcINVALID;

    switch (dwSetupClass)
    {
        case IS_MS_MMMCI :
        {
            g_dcFilterClass = dcMCI;
        }
        break;

        case IS_MS_MMVID :
        {
            g_dcFilterClass = dcVCODEC;
        }
        break;

        case IS_MS_MMACM :
        {
            g_dcFilterClass = dcACODEC;
        }
        break;

        case IS_MS_MMVCD :
        {
            g_dcFilterClass = dcVIDCAP;
        }
        break;

        case IS_MS_MMDRV :
        {
            g_dcFilterClass = dcLEGACY;
        }
        break;
    }
}

INT_PTR AdvDlg (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HANDLE          hWndI, hWnd;
    PIDRIVER        pIDriver;
    DWORD_PTR       dwType = 0;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
#ifdef FIX_BUG_15451
        if (szDriverWhichNeedsSettings[0] != TEXT('\0'))
        {
            MakeThisCPLLookLikeTheOldCPL (GetParent(hDlg));
        }
#endif // FIX_BUG_15451

            wsStartWait();

            if (lParam)
            {
                dwType = ((LPPROPSHEETPAGE) lParam)->lParam;
            }

            MapDriverClass(dwType);

            hWndI = GetDlgItem(hDlg, IDC_ADV_TREE);
            SendMessage(hWndI,WM_SETREDRAW, FALSE, 0L);

            InitAdvDlgTree (hWndI); // initialize the treeview display

           /*
            *  Handle the fact that we may not be able to update our .ini
            *  sections
            *
            */

            IniFileWriteAllowed = CheckIniAccess();

                  // Note nasty sneaky hack: using (A|B) instead of (A&&B)
                  // makes both functions evaluate in either success or
                  // failure cases.
                  //
            IniFileReadAllowed = ( InitInstalled (hDlg, szDrivers) |
                                   InitInstalled (hDlg, szMCI) );

            FillTreeInAdvDlg (GetDlgItem (hDlg, IDC_ADV_TREE), NULL);

            wsEndWait();

            if ((!IniFileReadAllowed) || (!IniFileWriteAllowed))
            {
                TCHAR szCantAdd[120];
                EnableWindow(GetDlgItem(hDlg, ID_ADV_ADD),FALSE);
                EnableWindow(GetDlgItem(hDlg, ID_ADV_REMOVE),FALSE);
                LoadString(myInstance,IDS_CANTADD,szCantAdd,sizeof(szCantAdd)/sizeof(TCHAR));
                MessageBox(hDlg, szCantAdd, szError,
                                MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
            }


            SendMessage (hWndI, WM_SETREDRAW, TRUE, 0L);

            break;

        case WM_COMMAND:
            hWndI = GetDlgItem(hDlg, IDC_ADV_TREE);
            hWndMain = hDlg;

            pIDriver = GetSelectedIDriver (hWndI);

            switch ( LOWORD(wParam ))
            {
                case ID_ADV_PROP:
                    {
                HTREEITEM    htiCur = TreeView_GetSelection (hWndI);
                DriverClass  dc = GuessDriverClassFromTreeItem (htiCur);

                        if (fWorking)
                            break;

                        ++fWorking; // Just starting an operation

                        if( dc == dcJOY )
                            // We want to run "control joy.cpl" when the joystick devices
                            // are highlight and the user clicks Properties buttons.
                            RunJoyControlPanel();
            else
                        ShowDeviceProperties (hDlg, TreeView_GetSelection(hWndI));

                    --fWorking; // Finished with this operation
                    }
                    break;

                case ID_WHATSTHIS:
                    {
                    WinHelp((HWND)GetDlgItem (hDlg, IDC_ADV_TREE),
                            gszWindowsHlp, HELP_WM_HELP,
                           (UINT_PTR)(LPTSTR)aAdvDlgHelpIds);
                    }
                    break;

                case ID_ADV_REMOVE:
                    {
                    HWND         hTree = GetDlgItem (hDlg, IDC_ADV_TREE);
                    HTREEITEM    htiCur = TreeView_GetSelection (hTree);
                    DriverClass  dc = GuessDriverClassFromTreeItem (htiCur);
                    PIDRIVER     pid;
                    LONG_PTR         Status;

                    if ((!IniFileReadAllowed) || (!IniFileWriteAllowed))
                       break;   // (button should be disabled)

                    if( dc == dcJOY ) {
                         RunJoyControlPanel();
                break;
            }

                    if (TreeView_GetParent (hAdvDlgTree, htiCur) &&
                        TreeView_GetGrandParent (hAdvDlgTree, htiCur) &&
                        (GuessDriverClassFromTreeItem (
                                 TreeView_GetGrandParent (hAdvDlgTree, htiCur)
                                                      ) == dcMIDI))
                       {
                       TV_ITEM tvi;
                       PINSTRUM pin;

                       tvi.mask = TVIF_PARAM;
                       tvi.hItem = htiCur;
                       tvi.lParam = 0;
                       TreeView_GetItem(hAdvDlgTree, &tvi);

                       if ((pin = (PINSTRUM)tvi.lParam) != NULL)
                          {
                          RemoveInstrumentByKeyName (pin->szKey);
                          RefreshAdvDlgTree ();
                          KickMapper (hDlg);
                          }

                       break;
                       }

                    if ((pid = FindIDriverByTreeItem (htiCur)) == NULL)
                       break;

                    if (dc == dcLEGACY)
                    {
                        dc = GuessDriverClass(pid);
                    }

                    if (pid->szAlias[0] == TEXT('\0'))
                       {
                       TCHAR szCantRemove[ cchRESOURCE ];
                       GetString(szCantRemove, IDS_ACMREMOVEFAIL);
                       MessageBox(hDlg, szCantRemove, szError,
                                  MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
                       break;
                       }

                    if (fWorking)
                       break;
                    ++fWorking; // Just starting an operation

                    if (QueryRemoveDrivers (hDlg, pid->szAlias, pid->szDesc))
                       {
                       if ((Status = PostRemove (pid, TRUE)) != DRVCNF_CANCEL)
                          {
                          switch (dc)
                             {
                             case dcMIDI:
                                   break;
                             case dcACODEC:
                                   acmDeleteCodec (LOWORD(pid->lp),
                                                   HIWORD(pid->lp));
                                   break;
                             default:
                                   break;
                             }

                          iRestartMessage = IDS_RESTART_REM;

                          if (Status == DRVCNF_RESTART)
                             {
                             DialogBox (myInstance,
                                        MAKEINTRESOURCE(DLG_RESTART),
                                        hDlg,
                                        RestartDlg);
                             }
                          }
                       }

                    --fWorking; // Finished with this operation
                    }
                    break;

                case ID_ADV_ADD:
                    {
                HTREEITEM    htiCur = TreeView_GetSelection (hWndI);
                DriverClass  dc = GuessDriverClassFromTreeItem (htiCur);

                        if ((!IniFileReadAllowed) || (!IniFileWriteAllowed))
                            break;  // (button should be disabled)

                        if( dc == dcJOY ) {
                            RunJoyControlPanel();
                break;
            }

                    if (fWorking)
                       break;
                    ++fWorking; // Just starting an operation

                    bCopyEvenIfOlder = FALSE;

                    DialogBox(myInstance, MAKEINTRESOURCE(DLG_KNOWN), hDlg,
                              AvailableDriversDlg);

                    bCopyEvenIfOlder = FALSE;

                    --fWorking; // Finished with this operation
                    }
                    break;


                case ID_ADV_TSHOOT:
                    {
                        TCHAR szCommand[ MAX_PATH ];
                        STARTUPINFO si;
                        PROCESS_INFORMATION pi;
                        LoadString(myInstance,IDS_TSHOOT, szCommand, sizeof(szCommand)/sizeof(TCHAR));
                        ZeroMemory(&si, sizeof(si));
                        si.cb = sizeof(si);
                        si.dwFlags = STARTF_USESHOWWINDOW;
                        si.wShowWindow = SW_NORMAL;
                        if (CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, 0, NULL, &si, &pi)) {
                            CloseHandle(pi.hThread);
                            CloseHandle(pi.hProcess);
                        }
                    }
                    break;

#ifdef FIX_BUG_15451
        case ID_INIT:
            if (szDriverWhichNeedsSettings[0] != TEXT('\0'))
               {
               HTREEITEM hti;

               if ((hti = FindTreeItemByDriverName (
                        szDriverWhichNeedsSettings)) != 0)
               {
               TreeView_Expand (hAdvDlgTree,
                        TreeView_GetParent(hAdvDlgTree,hti),
                        TVE_EXPAND);
               TreeView_SelectItem(hAdvDlgTree,hti);
               FORWARD_WM_COMMAND(hDlg,ID_ADV_PROP,0,0,PostMessage);
               }
               else
               {
               szDriverWhichNeedsSettings[0] = 0;
               }
               }
                    break;
#endif // FIX_BUG_15451

                default:
                    return(FALSE);
            }
            break;

      case WM_NOTIFY:
            {
            NMHDR         *lpnm   = (NMHDR *)lParam;
            LPNM_TREEVIEW  lpnmtv = (LPNM_TREEVIEW)lParam;

            switch (lpnm->code)
               {
               case PSN_KILLACTIVE:
                     FORWARD_WM_COMMAND (hDlg, IDOK, 0, 0, SendMessage);
                    break;

               case PSN_APPLY:
                     FORWARD_WM_COMMAND (hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

               case PSN_SETACTIVE:
                     FORWARD_WM_COMMAND (hDlg, ID_INIT, 0, 0, SendMessage);
                    break;

               case PSN_RESET:
                     FORWARD_WM_COMMAND (hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;

               case NM_DBLCLK:
                              // show properties or expand/collapse tree node.
                              //
                     if (lpnm->idFrom == (UINT)IDC_ADV_TREE)
                        {
                        HWND           hTree =  GetDlgItem (hDlg, IDC_ADV_TREE);
                        HTREEITEM      htiCur = TreeView_GetSelection (hTree);
                        TV_HITTESTINFO tvht;

                        if (!htiCur)
                           break;

                        GetCursorPos (&tvht.pt);
                        ScreenToClient (hTree, &tvht.pt);
                        TreeView_HitTest (hTree, &tvht);

                        if ( (tvht.flags & TVHT_ONITEM) &&
                             (TreeView_GetChild (hTree, htiCur) == NULL) &&
                             (IsWindowEnabled (GetDlgItem(hDlg,ID_ADV_PROP))) )
                           {
                           FORWARD_WM_COMMAND(hDlg,ID_ADV_PROP,0,0,PostMessage);
                           }
                        }
                    break;

               case NM_RCLICK:
                     TreeContextMenu (hDlg, GetDlgItem (hDlg, IDC_ADV_TREE));
                     return TRUE;
                    break;
               }
            }
           break;


        // The TreeView has its own right-click handling, and presents a
        // "What's This?" automatically--so don't handle WM_CONTEXTMENU
        // for that control.
        //
        case WM_CONTEXTMENU:
            if (wParam != (WPARAM)GetDlgItem (hDlg, IDC_ADV_TREE))
            {
                WinHelp((HWND)wParam, gszWindowsHlp, HELP_CONTEXTMENU,
                       (UINT_PTR)(LPTSTR)aAdvDlgHelpIds);
            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszWindowsHlp,
                  HELP_WM_HELP, (UINT_PTR)(LPTSTR)aAdvDlgHelpIds);
            break;

        case WM_DESTROY:
            FreeAdvDlgTree (GetDlgItem (hDlg, IDC_ADV_TREE));
            return FALSE;
            break;

        default:
            return FALSE;
            break;
    }
    return(TRUE);
}


/*
 *** TreeContextMenu
 *
 * This function displays the context menu that pops up when the
 * user right clicks on any of the tree view items.
 *
 */
void TreeContextMenu (HWND hWnd, HWND hKeyTreeWnd)
{
   DWORD MessagePos;
   POINT MessagePoint;
   TV_HITTESTINFO TVHitTestInfo;
   HMENU hContextMenu;
   HMENU hContextPopupMenu;
   TV_ITEM TVItem;
   int MenuCommand;
   TCHAR szCollapse[32];

            // dont bring up a menu unless click is on the item.
            //
   MessagePos = GetMessagePos();
   MessagePoint.x = GET_X_LPARAM(MessagePos);
   MessagePoint.y = GET_Y_LPARAM(MessagePos);

   TVHitTestInfo.pt = MessagePoint;
   ScreenToClient(hKeyTreeWnd, &TVHitTestInfo.pt);
   TVItem.hItem = TreeView_HitTest(hKeyTreeWnd, &TVHitTestInfo);

   if (TVItem.hItem == NULL)
      return;

   hContextMenu = LoadMenu(ghInstance, MAKEINTRESOURCE(POPUP_TREE_CONTEXT));
   if (hContextMenu == NULL)
      return;

   hContextPopupMenu = GetSubMenu (hContextMenu, 0);

   TVItem.mask = TVIF_STATE | TVIF_HANDLE | TVIF_CHILDREN | TVIF_PARAM;
   TreeView_GetItem(hKeyTreeWnd, &TVItem);

               // show collapse item because we are expanded?
               //
   if (TVItem.state & TVIS_EXPANDED)
      {
      LoadString(ghInstance, IDS_COLLAPSE, szCollapse, sizeof(szCollapse)/sizeof(TCHAR));
      ModifyMenu(hContextPopupMenu, ID_TOGGLE, MF_BYCOMMAND | MF_STRING,
                 ID_TOGGLE, szCollapse);
      }
   SetMenuDefaultItem (hContextPopupMenu, ID_TOGGLE, MF_BYCOMMAND);

   if (TVItem.cChildren == 0) //gray expand/collaps if no children
      {
      SetMenuDefaultItem(hContextPopupMenu, ID_ADV_PROP, MF_BYCOMMAND);
      EnableMenuItem(hContextPopupMenu, ID_TOGGLE, MF_GRAYED |MF_BYCOMMAND);
      }

   TreeView_SelectItem (hKeyTreeWnd, TVItem.hItem);
   MenuCommand = TrackPopupMenuEx (hContextPopupMenu,
                                   TPM_RETURNCMD | TPM_RIGHTBUTTON |
                                   TPM_LEFTALIGN | TPM_TOPALIGN,
                                   MessagePoint.x, MessagePoint.y,
                                   hWnd, NULL);

   DestroyMenu (hContextMenu);
   FORWARD_WM_COMMAND(hWnd, MenuCommand, 0, 0, SendMessage);
}



/*--------------------------------------------------------------------------*
 *                                                                          *
 *                                                                          *
 *  LB_AVAILABLE Dialog Routines                                            *
 *                                                                          *
 *                                                                          *
 *--------------------------------------------------------------------------*/

/*
 *  DLG: LB_AVAILABLE
 *
 *  InitAvailable()
 *
 *  Add the available drivers from mmdriver.inf to the passed list box.
 *  The format of [Installable.drivers] in setup.inf is:
 *  profile=disk#:driverfile,"type1,type2","Installable driver Description","vxd1.386,vxd2.386","opt1,2,3"
 *
 *  for example:
 *
 *  driver1=6:sndblst.drv,"midi,wave","SoundBlaster MIDI and Waveform drivers","vdmad.386,vadmad.386","3,260"
 */

BOOL InitAvailable(HWND hWnd, int iLine)
{
    PINF    pinf;
    BOOL    bInitd=FALSE;
    LPTSTR    pstrKey;
    int     iIndex;
	LONG	lResult;
    TCHAR    szDesc[MAX_INF_LINE_LEN];

    SendMessage(hWnd,WM_SETREDRAW, FALSE, 0L);

   /*
    *  Parse the list of keywords and load their strings
    */

    for (pinf = FindInstallableDriversSection(NULL); pinf; pinf = infNextLine(pinf))
    {
        //
        // found at least one keyname!
        //
		pstrKey = (LPTSTR)LocalAlloc(LPTR, (MAX_SYS_INF_LEN * sizeof(TCHAR)));
		if( pstrKey == NULL )
			break;

        if( ERROR_SUCCESS == infParseField(pinf, 0, pstrKey, MAX_SYS_INF_LEN)
		&&  ERROR_SUCCESS == infParseField(pinf, 3, szDesc, SIZEOF(szDesc)) )
		{
			/*
			*  add the installable driver's description to listbox, and filename as data
			*/
			if ( (iIndex = (int)SendMessage(hWnd, LB_ADDSTRING, 0, (LONG_PTR)(LPTSTR)szDesc)) != LB_ERR )
			{
				SendMessage(hWnd, LB_SETITEMDATA, iIndex, (LONG_PTR)pstrKey);
		        bInitd = TRUE;
			}
		}
		else
		{
			LocalFree( pstrKey );
			pstrKey = NULL;
		}
    }

    if (iLine == UNLIST_LINE)
    {
        //
        // Add the "Install unlisted..." choice to the top of the list
        // box.
        LoadString(myInstance, IDS_UPDATED, szDesc, sizeof(szDesc)/sizeof(TCHAR));
        if ((iIndex = (int)(LONG)SendMessage(hWnd, LB_INSERTSTRING, 0, (LPARAM)(LPTSTR)szDesc)) != LB_ERR)
            SendMessage(hWnd, LB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)0);
     }
     if (bInitd)

         SendMessage(hWnd, LB_SETCURSEL, 0, 0L );


     SendMessage(hWnd,WM_SETREDRAW, TRUE, 0L);
     return(bInitd);
}


/*
 *  DLG: LB_AVAILABLE
 *
 *  RemoveAvailable()
 *
 *  Remove all drivers from the listbox and free all storage associated with
 *  the keyname
 */

void RemoveAvailable(HWND hWnd)
{
    int iIndex;
    HWND hWndA;
    LPTSTR pstrKey;

    hWndA = GetDlgItem(hWnd, LB_AVAILABLE);
    iIndex = (int)SendMessage(hWndA, LB_GETCOUNT, 0, 0L);
    while ( iIndex-- > 0)
    {
        if (( (pstrKey = (LPTSTR)SendMessage(hWndA, LB_GETITEMDATA, iIndex,
            0L)) != (LPTSTR)LB_ERR ) && pstrKey)
            LocalFree((HLOCAL)pstrKey);
    }
}


/*
 *  DLG: LB_AVAILABLE
 *
 *  AvailableDriversDlg()
 *
 *  List the available installable drivers or return FALSE if there are none.
 */

const static DWORD aAvailDlgHelpIds[] = {  // Context Help IDs
    LB_AVAILABLE,    IDH_ADD_DRIVER_LIST,
    ID_DRVSTRING,    IDH_ADD_DRIVER_LIST,

    0, 0
};

INT_PTR AvailableDriversDlg(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPTSTR    pstrKey;    //-jyg- added

    HWND    hWndA;
    int     iIndex;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            ShowWindow(hWnd, TRUE);
            wsStartWait();
            if (pinfOldDefault)
            {
                infSetDefault(pinfOldDefault);
                pinfOldDefault = NULL;
            }

            if ( !InitAvailable(hWndA = GetDlgItem(hWnd, LB_AVAILABLE), UNLIST_LINE))
            {
               /*
                *  We weren't able to find the [installable.drivers] section
                *  of the
                *  mmdriver.inf OR it was corrupt.  Go ahead and query the
                *  user to find an oemsetup.inf to make our default.  This
                *  is a bad state.
                */
                EndDialog(hWnd, FALSE);
                bFindOEM = TRUE;
                wcscpy(szDrv, szOemInf);
                if (DialogBox(myInstance, MAKEINTRESOURCE(DLG_INSERTDISK),
                        hWnd,  AddDriversDlg) == TRUE)
                    PostMessage(hWnd, WM_INITDIALOG, 0, 0L);
                else
                    pinfOldDefault = infSetDefault(pinfOldDefault);

                bFindOEM = FALSE;
            }
            wsEndWait();
            break;

        case WM_COMMAND:

            switch ( LOWORD(wParam ))
            {
                case LB_AVAILABLE:

                    // Hm... We've picked it.

                    if ( HIWORD(wParam) == LBN_DBLCLK )
                        SendMessage(hWnd, WM_COMMAND, IDOK, 0L);
                    break;

                case IDOK:

                   /*
                    *  We've made our selection
                    */

                    hWndA = GetDlgItem(hWnd, LB_AVAILABLE);

                    if ( (iIndex = (int)SendMessage(hWndA, LB_GETCURSEL, 0, 0L)) != LB_ERR)
                    {
                        if (!iIndex)
                        {
                           /*
                            *  The first entry is for OEMs
                            */

                            INT_PTR iFound;
                            bBadOemSetup = FALSE;

                            bCopyEvenIfOlder = TRUE;
                            bFindOEM = TRUE;
                            hMesgBoxParent = hWnd;
                            while ((iFound = DialogBox(myInstance,
                                    MAKEINTRESOURCE(DLG_INSERTDISK), hWnd,
                                            AddDriversDlg)) == 2);
                            if (iFound == 1)
                            {
                                    RemoveAvailable(hWnd);
                                    SendDlgItemMessage(hWnd, LB_AVAILABLE,
                                            LB_RESETCONTENT, 0, 0L);
                                    PostMessage(hWnd, WM_INITDIALOG, 0, 0L);
                            }
                            bFindOEM = FALSE;
                        }
                        else
                        {
                           /*
                            *  The user selected an entry from our .inf
                            */

                            wsStartWait();

                           /*
                            *  The  data associated with the list item is
                            *  the driver key name (field 0 in the inf file).
                            */

                            pstrKey = (LPTSTR)SendMessage(hWndA, LB_GETITEMDATA, iIndex, 0L);
                            bCopyingRelated = FALSE;
                            bQueryExist = TRUE;

                            if (InstallDrivers(hWndMain, hWnd, pstrKey))
                            {
                               RefreshAdvDlgTree ();
                               wsEndWait();


                              /*
                               *  If bRestart is true then the system must
                               *  be restarted to activate these changes
                               */

                               if (bRestart)
                               {
                                  iRestartMessage= IDS_RESTART_ADD;
                                  DialogBox(myInstance,
                                          MAKEINTRESOURCE(DLG_RESTART), hWnd,
                                              RestartDlg);
                               }
                            }
                            else
                               wsEndWait();

                            bRestart = FALSE;
                            bRelated = FALSE;
                        }
                    }
                    EndDialog(hWnd, FALSE);
                    break;

                case IDCANCEL:
                    EndDialog(hWnd, FALSE);
                    break;

                default:
                    return(FALSE);
            }
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, gszWindowsHlp, HELP_CONTEXTMENU,
                  (UINT_PTR)(LPTSTR)aAvailDlgHelpIds);
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszWindowsHlp,
                  HELP_WM_HELP, (UINT_PTR)(LPTSTR)aAvailDlgHelpIds);
            break;

        case WM_DESTROY:
            //
            // free the strings added as DATAITEM to the avail list

            RemoveAvailable(hWnd);
            return(FALSE);

        default:
            return FALSE;
         break;
    }
    return(TRUE);
}


BOOL DriversDllInitialize( IN PVOID hInstance
                  , IN DWORD ulReason
                  , IN PCONTEXT pctx OPTIONAL
                  )
{
    if (ulReason != DLL_PROCESS_ATTACH)
        return TRUE;

    myInstance = hInstance;
    LoadString(myInstance, IDS_CLOSE,  aszClose, sizeof(aszClose)/sizeof(TCHAR));
    LoadString(myInstance, IDS_DRIVERDESC, szDriversDesc, sizeof(szDriversDesc)/sizeof(TCHAR));
    LoadString(myInstance, IDS_FILE_ERROR, szFileError, sizeof(szFileError)/sizeof(TCHAR));
    LoadString(myInstance, IDS_INSTALLDRIVERS, szMDrivers, sizeof(szMDrivers)/sizeof(TCHAR));
    LoadString(myInstance, IDS_INSTALLDRIVERS32, szMDrivers32, sizeof(szMDrivers)/sizeof(TCHAR));
    LoadString(myInstance, IDS_RELATEDDESC, szRelatedDesc, sizeof(szRelatedDesc)/sizeof(TCHAR));
    LoadString(myInstance, IDS_USERINSTALLDRIVERS, szUserDrivers, sizeof(szUserDrivers)/sizeof(TCHAR));
    LoadString(myInstance, IDS_UNLISTED, (LPTSTR)szUnlisted, sizeof(szUnlisted)/sizeof(TCHAR));
    LoadString(myInstance, IDS_KNOWN, szKnown, sizeof(szKnown)/sizeof(TCHAR));
    LoadString(myInstance, IDS_OEMSETUP, szOemInf, sizeof(szOemInf)/sizeof(TCHAR));
    LoadString(myInstance, IDS_SYSTEM, szSystem, sizeof(szSystem)/sizeof(TCHAR));
    LoadString(myInstance, IDS_OUT_OF_REMOVE_SPACE, szOutOfRemoveSpace, sizeof(szOutOfRemoveSpace)/sizeof(TCHAR));
    LoadString(myInstance, IDS_NO_DESCRIPTION, szNoDesc, sizeof(szNoDesc)/sizeof(TCHAR));
    LoadString(myInstance, IDS_ERRORBOX, szError, sizeof(szError)/sizeof(TCHAR));
    LoadString(myInstance, IDS_REMOVEORNOT, szRemoveOrNot, sizeof(szRemoveOrNot)/sizeof(TCHAR));
    LoadString(myInstance, IDS_REMOVEORNOTSTRICT, szRemoveOrNotStrict, sizeof(szRemoveOrNotStrict)/sizeof(TCHAR));
    LoadString(myInstance, IDS_SETUPINF, szSetupInf, sizeof(szSetupInf)/sizeof(TCHAR));
    LoadString(myInstance, IDS_APPNAME, szAppName, sizeof(szAppName)/sizeof(TCHAR));

    LoadString(myInstance, IDS_DRIVERS, szDrivers, sizeof(szDrivers)/sizeof(TCHAR));
    LoadString(myInstance, IDS_REMOVE, szRemove, sizeof(szRemove)/sizeof(TCHAR));
    LoadString(myInstance, IDS_CONTROLINI, szControlIni, sizeof(szControlIni)/sizeof(TCHAR));
    LoadString(myInstance, IDS_SYSINI, szSysIni, sizeof(szSysIni)/sizeof(TCHAR));
    LoadString(myInstance, IDS_MCI, szMCI, sizeof(szMCI)/sizeof(TCHAR));
    LoadString(myInstance, IDS_DEFDRIVE, szDirOfSrc, sizeof(szDirOfSrc)/sizeof(TCHAR));
    LoadString(myInstance, IDS_CONTROL_HLP_FILE, szDriversHlp, sizeof(szDriversHlp)/sizeof(TCHAR));
    LoadString(myInstance, IDS_LASTQUERY, szLastQuery, sizeof(szLastQuery)/sizeof(TCHAR));

    return TRUE;
}

void DeleteCPLCache(void)
{
    HKEY hKeyCache;

    if (ERROR_SUCCESS ==
        RegOpenKey(HKEY_CURRENT_USER,
                   TEXT("Control Panel\\Cache\\multimed.cpl"),
                   &hKeyCache)) {
        for ( ; ; ) {
            TCHAR Name[MAX_PATH+1]; // This is the max size that RegEnumKey()+NULL can return

            if (ERROR_SUCCESS ==
                RegEnumKey(hKeyCache,
                           0,
                           Name,
                           ARRAYSIZE(Name))) {
                HKEY hSubKey;

                RegDeleteKey(hKeyCache, Name);
            } else {
                break;    // leave loop
            }
        }

        RegDeleteKey(hKeyCache, NULL);
        RegCloseKey(hKeyCache);
    }
}


/*
** RestartDlg()
**
** Offer user the choice to (not) restart windows.
*/
INT_PTR RestartDlg(HWND hDlg, unsigned uiMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uiMessage)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
               case IDCANCEL:
                    //
                    // don't restart windows
                    //
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    //
                    // do restart windows, *dont* dismiss dialog incase
                    // the user canceled it.
                    //
                    ReBoot(hDlg);
                    SetActiveWindow(hDlg);
                    //EndDialog(hDlg, TRUE);
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_INITDIALOG:
              /*
              **  Delete the control panel's cache so it will get it
              **  right!
              */

              DeleteCPLCache();


              if (iRestartMessage)
              {
                TCHAR szMesg1[300];
                TCHAR szMesg2[300];

                LoadString(myInstance, iRestartMessage, szMesg1, sizeof(szMesg1)/sizeof(TCHAR));
                wsprintf(szMesg2, szMesg1, (LPTSTR)szRestartDrv);
                SetDlgItemText(hDlg, IDS_RESTARTTEXT, (LPTSTR)szMesg2);

                if (iRestartMessage == IDS_RESTART_NOSOUND)
                {
                  PostMessage (hDlg, WM_NEXTDLGCTL,
                               (WPARAM)GetDlgItem(hDlg,IDOK), (LPARAM)TRUE);
                }
              }
              return TRUE;

        case WM_KEYUP:
            if (wParam == VK_F3)
                //
                // don't restart windows
                //
                EndDialog(hDlg, FALSE);
            break;

        default:
            break;
    }
    return FALSE;
}

/*
 * UserInstalled()
 *
 *
 */

BOOL UserInstalled(LPTSTR szKey)
{
        TCHAR buf[MAXSTR];
        LPTSTR lpstr = NULL;
        ZeroMemory (buf, sizeof (buf)); // make prefix happy.

        lpstr = GetProfile (szUserDrivers, (LPTSTR)szKey, szControlIni, buf, sizeof(buf));
        if (lpstr && *lpstr != TEXT('\0'))
            return(TRUE);
        else
            return(FALSE);
}

/*
 *   AddUnlistedDlg()
 *
 *   The following function processes requests by the user to install unlisted
 *   or updated drivers.
 *
 *   PARAMETERS:  The normal Dialog box parameters
 *   RETURN VALUE:  The usual Dialog box return value
 */

INT_PTR AddUnlistedDlg(HWND hDlg, unsigned nMsg, WPARAM wParam, LPARAM lParam)
{
  switch (nMsg)
  {
      case WM_INITDIALOG:
      {
          HWND hListDrivers;
          BOOL bFoundDrivers;

          wsStartWait();
          hListDrivers = GetDlgItem(hDlg, LB_UNLISTED);

          /* Search for drivers */
          bFoundDrivers = InitAvailable(hListDrivers, NO_UNLIST_LINE);
          if (!bFoundDrivers)
          {
                //
                // We weren't able to find the MMDRIVERS section of the
                // setup.inf OR it was corrupt.  Go ahead and query the
                // user to find an oemsetup.inf to make our default.  This
                // is a bad state.
                //

                INT_PTR iFound;

                bFindOEM = TRUE;
                bBadOemSetup = TRUE;
                while ((iFound = DialogBox(myInstance,
                        MAKEINTRESOURCE(DLG_INSERTDISK), hMesgBoxParent,
                                AddDriversDlg)) == 2);
                bFindOEM = FALSE;
                if (iFound == 1)
                {
                        SendDlgItemMessage(hDlg, LB_AVAILABLE,
                                LB_RESETCONTENT, 0, 0L);
                        PostMessage(hDlg, WM_INITDIALOG, 0, 0L);
                }
                EndDialog(hDlg, FALSE);
          }
          SendMessage(hListDrivers, LB_SETCURSEL, 0, 0L);
          wsEndWait();

          break;
        }

      case WM_COMMAND:
        switch (LOWORD(wParam))
        {
            case IDH_DLG_ADD_UNKNOWN:
              goto DoHelp;

            case LB_UNLISTED:
              if (HIWORD(wParam) != LBN_DBLCLK)
                  break;

              // else Fall through here
            case IDOK:
            {
             HWND hWndA;
             int iIndex;
             LPTSTR pstrKey;

             hWndA = GetDlgItem(hDlg, LB_UNLISTED);
             if ( (iIndex = (int)SendMessage(hWndA, LB_GETCURSEL, 0, 0L))
                                                             != LB_ERR)
             {
                wsStartWait();
                pstrKey = (LPTSTR)SendMessage(hWndA, LB_GETITEMDATA, iIndex, 0L);
                bCopyingRelated = FALSE;
                bQueryExist = TRUE;
                if (InstallDrivers(hWndMain, hDlg, pstrKey))
                {
                   RefreshAdvDlgTree ();
                   wsEndWait();

                   if (bRestart)
                   {
                      iRestartMessage= IDS_RESTART_ADD;
                      DialogBox(myInstance,   MAKEINTRESOURCE(DLG_RESTART),
                                                      hDlg, RestartDlg);
                   }
                 }
                 else
                   wsEndWait();
                 bRelated = FALSE;
                 bRestart = FALSE;
              }
              EndDialog(hDlg, FALSE);
            }
            break;

            case IDCANCEL:
              EndDialog(hDlg, wParam);
              break;

            default:
              return FALSE;
          }
        break;

      case WM_HELP:
DoHelp:
        WinHelp (hDlg, gszWindowsHlp, HELP_CONTEXT, IDH_MMCPL_DEVPROP_ENABLE);
        break;

      default:
        return FALSE;
   }
   return TRUE;
}
/*
 *  ReBoot()
 *
 *  Restart the system.  If this fails we put up a message box
 */

 void ReBoot(HWND hDlg)
 {
     DWORD Error;
     BOOLEAN WasEnabled;

    /*
     *  We must adjust our privilege level to be allowed to restart the
     *  system
     */

     RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                         TRUE,
                         FALSE,
                         &WasEnabled
                       );
    /*
     *  Try to reboot the system
     */

     if (!ExitWindowsEx(EWX_REBOOT, 0xFFFFFFFF)) {

         Error = GetLastError();

        /*
         *  Put up a message box if we failed
         */

         if (Error != NO_ERROR) {
            TCHAR szCantRestart[80];
            LoadString(myInstance,
                       Error == ERROR_PRIVILEGE_NOT_HELD  ||
                       Error == ERROR_NOT_ALL_ASSIGNED  ||
                       Error == ERROR_ACCESS_DENIED ?
                           IDS_CANNOT_RESTART_PRIVILEGE :
                           IDS_CANNOT_RESTART_UNKNOWN,
                       szCantRestart,
                       sizeof(szCantRestart)/sizeof(TCHAR));

            MessageBox(hDlg, szCantRestart, szError,
                       MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
         }
     }
 }


void OpenDriverError(HWND hDlg, LPTSTR szDriver, LPTSTR szFile)
{
        TCHAR szMesg[MAXSTR];
        TCHAR szMesg2[MAXSTR];

        LoadString(myInstance, IDS_INSTALLING_DRIVERS, szMesg, sizeof(szMesg)/sizeof(TCHAR));
        wsprintf(szMesg2, szMesg, szDriver, szFile);
        MessageBox(hDlg, szMesg2, szError, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);

}


/*
 *** AddIDriver - Adds a treeitem referencing the given PIDRIVER
 *
 * Note that the listed PIDRIVER should already have been added to the
 * aInstalledDrivers array (via AddIDriverToArray()) before calling this
 * routine.
 *
 */

HTREEITEM AddIDriver (HWND hTree, PIDRIVER pIDriver, DriverClass dc)
{
   short           idr;
   TV_INSERTSTRUCT ti;
   HTREEITEM       hti;
   short           ii;
   TCHAR           szFile[ _MAX_FNAME +1 +_MAX_EXT +1 ];
   TCHAR           szExt[ _MAX_EXT +1 ];
   TCHAR           szDesc[ cchRESOURCE ];

            // don't add an entry for one of the to-be-skipped drivers
            //
   lsplitpath (pIDriver->szFile, NULL, NULL, szFile, szExt);

   if (szExt[0] != TEXT('\0'))
      lstrcat (szFile, szExt);

    //check to see if we're trying to put a PNP driver into the legacy tree
    if (g_dcFilterClass == dcLEGACY)
    {
        if ((dc == dcWAVE) ||
            (dc == dcMIDI) ||
            (dc == dcMIXER) ||
            (dc == dcAUX))
        {
            if (IsPnPDriver(szFile))
            {
                return FALSE;
            }
        }
    }

   if (dc != dcMIDI)
      {
      for (ii = 0; ii < nDriversToSKIP; ii++)
         {
         if (!lstrcmpi (szFile, aDriversToSKIP[ ii ]))
            return FALSE;
         }
      }

            // If we were given a DriverClass, then the caller has
            // specified where we should create an entry--add the "Audio for"
            // (etc) tag before the description, and add it.
            //
            // Otherwise, determine where this driver belongs in the tree
            //
   if (dc != dcINVALID)
      {
      TCHAR   szTag[ cchRESOURCE ];

      switch (dc)
         {
         case dcWAVE:   GetString (szTag, IDS_AUDIOFOR);
                       break;
         case dcMIDI:   GetString (szTag, IDS_MIDIFOR);
                       break;
         case dcMIXER:  GetString (szTag, IDS_MIXERFOR);
                       break;
         case dcAUX:    GetString (szTag, IDS_AUXFOR);
                       break;
         default:       lstrcpy (szTag, TEXT("%s"));
                       break;
         }

      wsprintf (szDesc, szTag, pIDriver->szDesc);
      }
   else
      {
      if ((dc = GuessDriverClass (pIDriver)) == dcINVALID)
         return FALSE;

      lstrcpy (szDesc, pIDriver->szDesc);
      }

            // map that classification into an index within the
            // root entries of the tree (aDriverRoot[])
            //
   if ((idr = DriverClassToRootIndex (dc)) == -1)
      return FALSE;

            // if this driver already has an entry under this DriverClass,
            // then don't add another.
            //
   for (ii =0; ii < cInstalledDrivers; ++ii)
      {
      if (aInstalledDrivers[ ii ].pIDriver == pIDriver)
         break;
      }
   if (ii >= cInstalledDrivers)
      {
      ii = (short)NOPIDRIVER;
      }
   else if (aInstalledDrivers[ ii ].dwBits & aDriverRoot[ idr ].dwBit)
      {
      return FALSE; // Already have an entry here!
      }

            // since not all roots need exist all the time, make sure
            // this classification HAS a root in the tree
            //
   if (!EnsureRootIndexExists (hTree, idr))
      return FALSE;

            // finally, insert an item into the tree for this driver
            // note that for audio codecs to be sorted properly, they must
            // be added via this routine in their appropriate order--ie,
            // call this routine for the highest-priority codec first.
            //
   ti.hParent = aDriverRoot[ idr ].hti;
   ti.hInsertAfter = (dc == dcACODEC) ? TVI_LAST : TVI_SORT;
   ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
   ti.item.iImage = (int)idr;
   ti.item.iSelectedImage = (int)idr;
   ti.item.pszText = szDesc;
   ti.item.lParam = ii;

   if ((hti = TreeView_InsertItem (hTree, &ti)) == NULL)
      return FALSE;

   if (ii != NOPIDRIVER)
      aInstalledDrivers[ ii ].dwBits |= aDriverRoot[ idr ].dwBit;

   return hti;
}


BOOL AddIDriverByName (HWND hTree, LPCWSTR wszFile, DriverClass dc)
{
   LPTSTR pch;
   TCHAR tszFile[ max(cchRESOURCE, MAX_PATH) ];
   PIDRIVER pid;

#ifdef UNICODE
   lstrcpy (tszFile, wszFile);
#else
   wcstombs (tszFile, wszFile, cchRESOURCE);
#endif

            // Strip off any trailing whitespace
            //
   if (tszFile[0] == TEXT('\0'))
      return FALSE;

   for (pch = &tszFile[ lstrlen(tszFile)-1 ];
        pch >= tszFile && (*pch == TEXT('\t') || *pch == TEXT(' '));
        --pch)
      ;
   *(1+pch) = TEXT('\0');

            // If this is MMDRV.DLL, then it's possibly providing the
            // user-mode component for kernel-mode drivers.  Since it's
            // apparently impossible to determine the name of the .SYS
            // file which is providing a "\\.\WaveIn0" device (etc),
            // we'll use a hack: Check around for anyone registered
            // under the alias "Kernel", and use that.
            //
   if (!lstrcmpi (tszFile, cszMMDRVDLL))
      {
      mysize_t ii;
      for (ii = 0; ii < cInstalledDrivers; ++ii)
         {
         if (aInstalledDrivers[ ii ].pIDriver == NULL)
            continue;
         if (!lstrnicmp (aInstalledDrivers[ ii ].pIDriver->szAlias,
                         cszAliasKERNEL,
                         lstrlen(cszAliasKERNEL)))
            {
            lstrcpy (tszFile, aInstalledDrivers[ ii ].pIDriver->szFile);
            break;
            }
         }
      if (ii >= cInstalledDrivers)
         return FALSE;
      }

            // Find the driver in the aInstalledDriver array, and add
            // an entry for it in the tree.
            //
   if ((pid = FindIDriverByName (tszFile)) == NULL)
      return FALSE;

   if (AddIDriver (hTree, pid, dc) == NULL)
      return FALSE;

   return TRUE;
}


/*
 *** RemoveIDriver - Removes (and optionally frees) an IDRIVER from hAdvDlgTree
 *
 */

void RemoveIDriver (HWND hTree, PIDRIVER pIDriver, BOOL fFreeToo)
{
   mysize_t   ii;
   short      idr;
   HTREEITEM  hti;

            // Find each TreeItem which references this entry.
            //
   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if ((hti = aDriverRoot[ idr ].hti) == NULL)
         continue;

      hti = TreeView_GetChild (hTree, hti);
      while (hti != NULL)
         {
         if (pIDriver != FindIDriverByTreeItem (hti))
            {
            hti = TreeView_GetNextSibling (hTree, hti);
            continue;
            }

         // We found a tree item which uses this driver, so delete the
         // item.  Also note that this may cause the driver's parent
         // node to no longer be necessary.
         //

         TreeView_DeleteItem (hTree, hti);
         hti = TreeView_GetChild (hTree, aDriverRoot[ idr ].hti);

         if (!aDriverRoot[ idr ].fAlwaysMake)   // may no longer need parent?
            {
            if (hti == NULL)                    // parent now has no children?
               {
               TreeView_DeleteItem (hTree, aDriverRoot[ idr ].hti);
               aDriverRoot[ idr ].hti = NULL;
               }
            }
         }
      }

            // See if we can find the given pIDriver within the
            // aInstalledDriver array.
            //
   for (ii = 0; ii < cInstalledDrivers; ++ii)
      {
      if (aInstalledDrivers[ ii ].pIDriver == pIDriver)
         {
         aInstalledDrivers[ ii ].dwBits = 0L;   // no longer in tree at all

         if (fFreeToo)
            {
            LocalFree ((HANDLE)aInstalledDrivers[ ii ].pIDriver);
            aInstalledDrivers[ ii ].pIDriver = NULL;
            }

         break;   // There's only one entry in this array for each pIDriver
         }
      }
}


#ifdef FIX_BUG_15451
HTREEITEM FindTreeItemByDriverName (LPTSTR pszName)
{
   PIDRIVER   pid;
   short      idr;
   HTREEITEM  hti;

   if ((pid = FindIDriverByName (pszName)) == NULL)
      return (HTREEITEM)0;

   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if ((hti = aDriverRoot[ idr ].hti) == NULL)
         continue;

      for (hti = TreeView_GetChild (hAdvDlgTree, hti);
           hti != NULL;
           hti = TreeView_GetNextSibling (hAdvDlgTree, hti))
         {
         if (pid == FindIDriverByTreeItem (hti))
            {
            return hti;
            }
         }
     }

   return (HTREEITEM)0;
}
#endif // FIX_BUG_15451


PIDRIVER FindIDriverByTreeItem (HTREEITEM hti)
{
   TV_ITEM tvi;

   tvi.mask = TVIF_PARAM;
   tvi.hItem = hti;
   TreeView_GetItem (hAdvDlgTree, &tvi);

   if ( (tvi.lParam < 0) ||
        (tvi.lParam >= cInstalledDrivers) )
      {
      return NULL;
      }

   return aInstalledDrivers[ tvi.lParam ].pIDriver;
}


/*
 *** FindIDriverByName - Returns the first found IDRIVER structure with a name
 *
 */

PIDRIVER FindIDriverByName (LPTSTR szFile)
{
   mysize_t ii;

   for (ii = 0; ii < cInstalledDrivers; ++ii)
      {
      if (aInstalledDrivers[ ii ].pIDriver == NULL)
         continue;
      if (aInstalledDrivers[ ii ].pIDriver->szAlias[0] == TEXT('\0'))
         continue;

      if (!FileNameCmp (aInstalledDrivers[ ii ].pIDriver->szFile, szFile))
         return aInstalledDrivers[ ii ].pIDriver;
      }

    return NULL;
}


PIDRIVER FindIDriverByResource (PIRESOURCE pir)
{
   return FindIDriverByName (FileName( pir->szFile ));
}


/*
 *** GetSelectedIDriver - Returns the IDRIVER structure the user has selected
 *
 */

PIDRIVER GetSelectedIDriver (HWND hTree)
{
   HTREEITEM  htiCur = TreeView_GetSelection (hTree);

   if (htiCur == NULL)
      return NULL;

   return FindIDriverByTreeItem (htiCur);
}


/*
 *** DriverClassToRootIndex - obtain idr for which {aDriverRoot[idr].dc == dc}
 *
 * The array index for aDriverRoot[] is NOT a DriverClass--that is,
 * aDriverRoot[ PickAnyDC ].dc is not necessarily equal to PickAnyDC.
 * Given a DC, this routine finds the index into aDriverRoot which references
 * that DC.
 *
 */

short DriverClassToRootIndex (DriverClass dc)
{
   short  idr;

   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if (aDriverRoot[ idr ].dc == dc)
         return idr;
      }

   return -1;
}


/*
 *** GetDriverClass - guess a DriverClass based on an IDRIVER structure
 *
 * The registry has several different aliases which it uses in the LHS
 * of HKLM\software\microsoft\windowsnt\drivers,drivers32,etc to indicate
 * the classification of a particular driver.  These include:
 *
 * AUX, MIDI, MIDIMAPPER, MIXER, MSACM.*, VIDC.* WAVE, WAVEMAPPER
 *
 * as well as others--the full array of known entries is tracked within
 * aDriverKeywords[].  In addition, any of these may be followed by a
 * string of digits by which they are distinguished.  This routine parses
 * these keywords and returns a corresponding DriverClass enum.
 *
 */

DriverClass GuessDriverClass (PIDRIVER pid)
{
#ifdef FIX_BUG_15451
   return GuessDriverClassFromAlias (pid->szAlias);
}



DriverClass GuessDriverClassFromAlias (LPTSTR pszAlias)
{
#endif // FIX_BUG_15451
   TCHAR   szAlias[ cchRESOURCE ];
   TCHAR  *pch;
   short   ii;

#ifdef FIX_BUG_15451
   lstrcpy (szAlias, pszAlias); // Make a local copy so we can munge it
#else // FIX_BUG_15451
   lstrcpy (szAlias, pid->szAlias); // Make a local copy so we can munge it
#endif // FIX_BUG_15451

   if ((pch = lstrchr (szAlias, TEXT('.'))) != NULL)
      *pch = TEXT('0');

   for (ii = 0; ii < nDriverKEYWORDS; ii++)
      {
      if (!lstrnicmp (szAlias,
                      aDriverKeyword[ii].psz,
                      lstrlen (aDriverKeyword[ii].psz)))
         {
         return aDriverKeyword[ii].dc;
         }
      }

   return dcOTHER;
}


DriverClass GuessDriverClassFromTreeItem (HTREEITEM hti)
{
   short  idr;

   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if (hti == aDriverRoot[idr].hti)
         return aDriverRoot[idr].dc;
      }

   return (g_dcFilterClass);
}



/*
 *** EnsureRootIndexExists - makes sure a given parent exists in hAdvDlgTree
 *
 */

BOOL EnsureRootIndexExists (HWND hTree, short idr)
{
   TV_INSERTSTRUCT ti;
   TCHAR           szDesc[ cchRESOURCE ];
   HWND            hwndParent = NULL;
   HWND            hwndName   = NULL;

            // If we already HAVE a root in the tree, we're done.
            //
   if (aDriverRoot[ idr ].hti != NULL)
      return TRUE;

    if (g_dcFilterClass != dcINVALID)
    {
        if (g_dcFilterClass == dcLEGACY)
        {
            if ((aDriverRoot[ idr ].dc != dcWAVE) &&
                (aDriverRoot[ idr ].dc != dcMIDI) &&
                (aDriverRoot[ idr ].dc != dcMIXER) &&
                (aDriverRoot[ idr ].dc != dcAUX))
            {
                return FALSE;
            }
        }
        else if (aDriverRoot[ idr ].dc != g_dcFilterClass)
        {
            return FALSE;
        }
    }

   aDriverRoot[idr].hti = TVI_ROOT;

   LoadString (myInstance, aDriverRoot[idr].idDesc, szDesc, cchRESOURCE);

    if ((g_dcFilterClass == dcINVALID) || (g_dcFilterClass == dcLEGACY))
    {
       ti.hInsertAfter = TVI_LAST;
       ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
       ti.item.iImage = idr;
       ti.item.iSelectedImage = idr;
       ti.item.pszText = szDesc;
       ti.item.lParam = NOPIDRIVER;

       if (aDriverRoot[idr].dc == dcINVALID)
          ti.hParent = TVI_ROOT;
       else
          ti.hParent = AdvDlgFindTopLevel ();

       if ((aDriverRoot[idr].hti = TreeView_InsertItem (hTree, &ti)) == NULL)
          return FALSE;
    }

    if (g_dcFilterClass != dcINVALID)
    {
       hwndParent = GetParent(hTree);
       if (hwndParent)
       {
            hwndName = GetDlgItem(hwndParent,IDC_DEVICECLASS);
            if (hwndName)
            {
                if (g_dcFilterClass == dcLEGACY)
                {
                    LoadString (myInstance, IDS_WAVE_HEADER, szDesc, cchRESOURCE);
                }

                SetWindowText(hwndName,szDesc);
            }
       }
    }

   return TRUE;
}


/*
 **** AdvDlgFindTopLevel - Finds the HTREEITEM associated with the tree root
 *
 * If there's a "Multimedia Devices" tree item under which the other roots
 * are collected, this will return that item.  Otherwise, it returns TVI_ROOT.
 *
 */

HTREEITEM AdvDlgFindTopLevel (void)
{
   short  idr;

   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if (aDriverRoot[idr].dc == dcINVALID)
         return aDriverRoot[idr].hti;
      }

   return TVI_ROOT;
}



/*
 **** InitAdvDlgTree - Prepares the AdvDlg's treeview to display devices
 *
 */

BOOL InitAdvDlgTree (HWND hTree)
{
   int   cxIcon, cyIcon;
   short idr;
   UINT  uFlags;
   DWORD dwLayout;

   #ifdef UNICODE
   TreeView_SetUnicodeFormat(hTree,TRUE);
   #endif

    // Make sure we start with a clean slate
    //
   hAdvDlgTree = hTree;
   SendMessage (hTree, WM_SETREDRAW, FALSE, 0L);

   for (idr = 0; idr < nDriverROOTS; idr++)
   {
      aDriverRoot[ idr ].hti = NULL;
      aDriverRoot[ idr ].dwBit = ((DWORD)1) << idr;
   }

            // Create an imagelist for the icons in the treeview
            //
   cxIcon = (int)GetSystemMetrics (SM_CXSMICON);
   cyIcon = (int)GetSystemMetrics (SM_CYSMICON);
   uFlags = ILC_MASK | ILC_COLOR32;

   if (GetProcessDefaultLayout(&dwLayout) &&
            (dwLayout & LAYOUT_RTL)) 
   {
       uFlags |= ILC_MIRROR;
   }

   if ((hImageList = ImageList_Create (cxIcon, cyIcon,
                                       uFlags, nDriverROOTS, 1)) == NULL)
      return FALSE;

   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      HICON hi = LoadImage (myInstance,
                            MAKEINTRESOURCE( aDriverRoot[idr].idIcon ),
                            IMAGE_ICON, cxIcon, cyIcon, LR_DEFAULTCOLOR);
      ImageList_AddIcon (hImageList, hi);
      }

   TreeView_SetImageList (hTree, hImageList, TVSIL_NORMAL);


    if (g_dcFilterClass == dcINVALID)
    {
            // Create the root nodes that are supposed to exist
            // even without children (note that not all are)
            //
   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if (aDriverRoot[ idr ].dc == dcINVALID)
         {
         if (!EnsureRootIndexExists (hTree, idr))
            return FALSE;
         }
      }
   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if (aDriverRoot[ idr ].dc != dcINVALID && aDriverRoot[ idr ].fAlwaysMake)
         {
         if (!EnsureRootIndexExists (hTree, idr))
            return FALSE;
         }
      }
    }
            // Expand the tree somewhat, so the user doesn't get
            // greeted by a blank page
            //
   TreeView_Expand (hTree, AdvDlgFindTopLevel(), TVE_EXPAND);

   SendMessage (hTree, WM_SETREDRAW, TRUE, 0L);
   return TRUE;
}


/*
 **** FreeAdvDlgTree - Removes and frees all items within the AdvDlg treeview
 *
 */

void FreeAdvDlgTree (HWND hTree)
{
   short  idr;

            // Delete all leaf nodes
            //
   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      HTREEITEM  hti;

      if (aDriverRoot[idr].dc == dcINVALID)
         continue;
      if (aDriverRoot[idr].hti == NULL)
         continue;

      while ((hti = TreeView_GetChild (hTree, aDriverRoot[idr].hti)) != NULL)
         {
         if (aDriverRoot[ idr ].dc == dcMIDI)
            {
            HTREEITEM  htiInstrument;

            while ((htiInstrument = TreeView_GetChild (hTree, hti)) != NULL)
               {
               TV_ITEM tvi;
               tvi.mask = TVIF_PARAM;
               tvi.hItem = htiInstrument;
               tvi.lParam = 0;

               TreeView_GetItem(hTree, &tvi);

               if (tvi.lParam != 0)
                  LocalFree ((HANDLE)tvi.lParam);

               TreeView_DeleteItem (hTree, htiInstrument);
               }
            }

         TreeView_DeleteItem (hTree, hti);
         }
      }

            // Delete everything else
            //
   TreeView_DeleteAllItems (hTree);

            // Delete the tree's image list
            //
   if (hImageList)
      {
      TreeView_SetImageList (hTree, NULL, TVSIL_NORMAL);
      ImageList_Destroy (hImageList);
      hImageList = NULL;
      }

            // Delete the InstalledDrivers array
            //
   if (aInstalledDrivers != NULL)
      {
      mysize_t  ii;
      for (ii = 0; ii < cInstalledDrivers; ++ii)
         {
         if (aInstalledDrivers[ ii ].pIDriver != NULL)
            {
            LocalFree ((HANDLE)aInstalledDrivers[ ii ].pIDriver);
            aInstalledDrivers[ ii ].pIDriver = NULL;
            }
         }

      GlobalFree ((HGLOBAL)aInstalledDrivers);
      aInstalledDrivers = NULL;
      cInstalledDrivers = 0;
      }
}


int lstrnicmp (LPTSTR pszA, LPTSTR pszB, size_t cch)
{
#ifdef UNICODE
   size_t  cchA, cchB;
   TCHAR  *pch;

   for (cchA = 1, pch = pszA; cchA < cch; cchA++, pch++)
      {
      if (*pch == TEXT('\0'))
         break;
      }
   for (cchB = 1, pch = pszB; cchB < cch; cchB++, pch++)
      {
      if (*pch == TEXT('\0'))
         break;
      }

   return (CompareStringW (GetThreadLocale(), NORM_IGNORECASE,
                           pszA, cchA, pszB, cchB)
          )-2;  // CompareStringW returns {1,2,3} instead of {-1,0,1}.
#else
   return _strnicmp (pszA, pszB, cch);
#endif
}


LPTSTR lstrchr (LPTSTR pszTarget, TCHAR ch)
{
   size_t ich;
   if (pszTarget == NULL)
      return NULL;
   for (ich = 0; pszTarget[ich] != TEXT('\0'); ich++)
      {
      if (pszTarget[ich] == ch)
         return &pszTarget[ ich ];
      }

   return NULL;
}


void lsplitpath (LPTSTR pszSource,
                 LPTSTR pszDrive, LPTSTR pszPath, LPTSTR pszName, LPTSTR pszExt)
{
   LPTSTR   pszLastSlash = NULL;
   LPTSTR   pszLastDot = NULL;
   LPTSTR   pch;
   size_t   cchCopy;

        /*
         * NOTE: This routine was snitched out of USERPRI.LIB 'cause the
         * one in there doesn't split the extension off the name properly.
         *
         * We assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *      <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *      0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *      ':'
         *  dir:
         *      0 to _MAX_DIR-1 characters in the form of an absolute path
         *      (leading '/' or '\') or relative path, the last of which, if
         *      any, must be a '/' or '\'.  E.g -
         *      absolute path:
         *          \top\next\last\     ; or
         *          /top/next/last/
         *      relative path:
         *          top\next\last\      ; or
         *          top/next/last/
         *      Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *      0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *      0 to _MAX_EXT-1 characters where, if any, the first must be a
         *      '.'
         *
         */

             // extract drive letter and :, if any
             //
   if (*(pszSource + _MAX_DRIVE - 2) == TEXT(':'))
      {
      if (pszDrive)
         {
         lstrncpy (pszDrive, pszSource, _MAX_DRIVE-1);
         pszDrive[ _MAX_DRIVE-1 ] = TEXT('\0');
         }
      pszSource += _MAX_DRIVE-1;
      }
    else if (pszDrive)
      {
      *pszDrive = TEXT('\0');
      }

          // extract path string, if any.  pszSource now points to the first
          // character of the path, if any, or the filename or extension, if
          // no path was specified.  Scan ahead for the last occurence, if
          // any, of a '/' or '\' path separator character.  If none is found,
          // there is no path.  We will also note the last '.' character found,
          // if any, to aid in handling the extension.
          //
   for (pch = pszSource; *pch != TEXT('\0'); pch++)
      {
      if (*pch == TEXT('/') || *pch == TEXT('\\'))
         pszLastSlash = pch;
      else if (*pch == TEXT('.'))
         pszLastDot = pch;
      }

          // if we found a '\\' or '/', fill in pszPath
          //
   if (pszLastSlash)
      {
      if (pszPath)
         {
         cchCopy = (size_t)min((UINT)_MAX_DIR-1, (pszLastSlash-pszSource) + 1);
         lstrncpy (pszPath, pszSource, cchCopy);
         pszPath[ cchCopy ] = 0;
         }
      pszSource = pszLastSlash +1;
      }
   else if (pszPath)
      {
      *pszPath = TEXT('\0');
      }

             // extract file name and extension, if any.  Path now points to
             // the first character of the file name, if any, or the extension
             // if no file name was given.  Dot points to the '.' beginning the
             // extension, if any.
             //

   if (pszLastDot && (pszLastDot >= pszSource))
      {
               // found the marker for an extension -
               // copy the file name up to the '.'.
               //
      if (pszName)
         {
         cchCopy = (size_t)min( (UINT)_MAX_DIR-1, (pszLastDot-pszSource) );
         lstrncpy (pszName, pszSource, cchCopy);
         pszName[ cchCopy ] = 0;
         }

               // now we can get the extension
               //
      if (pszExt)
         {
         lstrncpy (pszExt, pszLastDot, _MAX_EXT -1);
         pszExt[ _MAX_EXT-1 ] = TEXT('\0');
         }
      }
   else
      {
               // found no extension, give empty extension and copy rest of
               // string into fname.
               //
      if (pszName)
         {
         lstrncpy (pszName, pszSource, _MAX_FNAME -1);
         pszName[ _MAX_FNAME -1 ] = TEXT('\0');
         }

      if (pszExt)
         {
         *pszExt = TEXT('\0');
         }
      }

}

void lstrncpy (LPTSTR pszTarget, LPTSTR pszSource, size_t cch)
{
   size_t ich;
   for (ich = 0; ich < cch; ich++)
      {
      if ((pszTarget[ich] = pszSource[ich]) == TEXT('\0'))
         break;
      }
}



/*
 * DEVICE PROPERTY SHEETS _____________________________________________________
 *
 */

         // General flag macros
         //
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))

BOOL          InstrumentToResource      (PIRESOURCE, HTREEITEM);
BOOL          DriverToResource          (HWND,PIRESOURCE,PIDRIVER,DriverClass);
DriverClass   OldClassIDToDriverClass   (int);
void          FreeClassNode             (PCLASSNODE);
PIDRIVER      FindIDriverByResource     (PIRESOURCE);
void          EnableDriverService       (PIRESOURCE, BOOL);

BOOL PASCAL DoDevPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
STATIC void SetDevStatus(int iStatus, HWND hDlg);
INT_PTR CALLBACK ACMDlg(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);


/*
 *** DriverToResource - create a PIRESOURCE structure from a PIDRIVER structure
 *
 * The Win95 code uses PIRESOURCEs (among other structures) to keep track of
 * the item in the Advanced tab's treeview; the old WinNT code used PIDRIVER
 * structures to keep track of the items in its listbox.  The tree now uses
 * PIDRIVER structures, but we create PIRESOURCE structures out of 'em before
 * passing control off to the Win95 properties dialogs, which came through
 * largely unmodified.
 *
 * BTW, I retained the PIDRIVER structures as the main treeview structure
 * because it prevented difficulty in porting over the Install/Remove Driver
 * code from the old NT code.
 *
 */

BOOL DriverToResource (HWND hPar, PIRESOURCE pir, PIDRIVER pid, DriverClass dc)
{
   if (dc == dcINVALID)
      {
      if ((dc = GuessDriverClass (pid)) == dcINVALID)
         return FALSE;
      }

   if ((pir->pcn = (PCLASSNODE)LocalAlloc (LPTR, sizeof(CLASSNODE))) == NULL)
      return FALSE;

   if (!DriverClassToClassNode (pir->pcn, dc))
      {
      LocalFree ((HANDLE)pir->pcn);
      return FALSE;
      }

   if (dc == dcACODEC)
      pir->iNode = 3;   // 1=class, 2=device, 3=acm, 4=instmt
// else if (dc == dcINSTRUMENT)
//    pir->iNode = 4;   // 1=class, 2=device, 3=acm, 4=instmt
   else
      pir->iNode = 2;   // 1=class, 2=device, 3=acm, 4=instmt

   lstrcpy (pir->szFriendlyName, pid->szDesc);
   lstrcpy (pir->szDesc,         pid->szDesc);
   lstrcpy (pir->szFile,         pid->szFile);
   lstrcpy (pir->szDrvEntry,     pid->szAlias);
   lstrcpy (pir->szClass,        pir->pcn->szClass);

   pid->fQueryable = IsConfigurable (pid, hPar);
   pir->fQueryable = (short)pid->fQueryable;
   pir->iClassID = (short)DriverClassToOldClassID (dc);
   pir->szParam[0] = 0;
   pir->dnDevNode = 0;
   pir->hDriver = NULL;

            // Find fStatus, which despite its name is really a series of
            // flags--in Win95 it's composed of DEV_* flags (from the old
            // mmcpl.h), but those are tied with PNP.  Here, we use the
            // dwStatus* flags:
            //
   pir->fStatus = (int)GetDriverStatus (pid);

   return TRUE;
}


BOOL InstrumentToResource (PIRESOURCE pir, HTREEITEM hti)
{
   TV_ITEM tvi;
   PINSTRUM pin;

   tvi.mask = TVIF_PARAM;
   tvi.hItem = hti;
   tvi.lParam = 0;
   TreeView_GetItem(hAdvDlgTree, &tvi);

   if ((pin = (PINSTRUM)tvi.lParam) == NULL)
      return FALSE;


   if ((pir->pcn = (PCLASSNODE)LocalAlloc (LPTR, sizeof(CLASSNODE))) == NULL)
      return FALSE;

   if (!DriverClassToClassNode (pir->pcn, dcMIDI))
      {
      LocalFree ((HANDLE)pir->pcn);
      return FALSE;
      }

   pir->iNode = 4;  // 1=class, 2=device, 3=acm, 4=instmt

   lstrcpy (pir->szFriendlyName, pin->szFriendly);
   lstrcpy (pir->szDesc,         pin->szKey);
// lstrcpy (pir->szFile,         TEXT("unused"));
// lstrcpy (pir->szDrvEntry,     TEXT("unused"));
   lstrcpy (pir->szClass,        pir->pcn->szClass);

   pir->fQueryable = FALSE;
   pir->iClassID = MIDI_ID;
   pir->szParam[0] = 0;
   pir->dnDevNode = 0;
   pir->hDriver = NULL;
   pir->fStatus = 0;

   return TRUE;
}


BOOL DriverClassToClassNode (PCLASSNODE pcn, DriverClass dc)
{
   short  idr;
   short  ii;
   int    cxIcon, cyIcon;

   if ((idr = DriverClassToRootIndex (dc)) == -1)
      return FALSE;

   pcn->iNode = 1;  // 1=class, 2=device, 3=acm, 4=instmt

   GetString (pcn->szClassName, aDriverRoot[idr].idDesc);
   pcn->szClass[0] = TEXT('\0');

   for (ii = 0; ii < nKeywordDESCS; ii++)
      {
      if (aKeywordDesc[ii].dc == dc)
         {
         lstrcpy (pcn->szClass, aKeywordDesc[ii].psz);
         break;
         }
      }

   cxIcon = (int)GetSystemMetrics (SM_CXICON);
   cyIcon = (int)GetSystemMetrics (SM_CYICON);

   pcn->hIcon = LoadImage (myInstance,
                           MAKEINTRESOURCE( aDriverRoot[ idr ].idIcon ),
                           IMAGE_ICON, cxIcon, cyIcon, LR_DEFAULTCOLOR);

   return TRUE;
}


int DriverClassToOldClassID (DriverClass dc)
{
   switch (dc)
      {
      case dcWAVE:   return WAVE_ID;      break;
      case dcMIDI:   return MIDI_ID;      break;
      case dcMIXER:  return MIXER_ID;     break;
      case dcAUX:    return AUX_ID;       break;
      case dcMCI:    return MCI_ID;       break;
      case dcACODEC: return ACM_ID;       break;
      case dcVCODEC: return ICM_ID;       break;
      case dcVIDCAP: return VIDCAP_ID;    break;
      case dcJOY:    return JOYSTICK_ID;  break;
      default:       return JOYSTICK_ID;  break;
      }
}


DriverClass OldClassIDToDriverClass (int ii)
{
   switch (ii)
      {
      case WAVE_ID:      return dcWAVE;    break;
      case MIDI_ID:      return dcMIDI;    break;
      case MIXER_ID:     return dcMIXER;   break;
      case AUX_ID:       return dcAUX;     break;
      case MCI_ID:       return dcMCI;     break;
      case ACM_ID:       return dcACODEC;  break;
      case ICM_ID:       return dcVCODEC;  break;
      case VIDCAP_ID:    return dcVIDCAP;  break;
      case JOYSTICK_ID:  return dcJOY;     break;
      default:           return dcOTHER;
      }
}


void FreeIResource (PIRESOURCE pir)
{
   if (pir->pcn != NULL)
      {
      FreeClassNode (pir->pcn);
      LocalFree ((HANDLE)pir->pcn);
      pir->pcn = NULL;
      }
}


void FreeClassNode (PCLASSNODE pcn)
{
   if (pcn->hIcon != NULL)
      {
      DestroyIcon (pcn->hIcon);
      pcn->hIcon = NULL;
      }
}


DWORD GetDriverStatus (PIDRIVER pid)
{
   DWORD     dwStatus;
   SC_HANDLE scManager;
   SC_HANDLE scDriver;
   TCHAR     szName[ cchRESOURCE ];

   dwStatus = 0;

   lsplitpath (pid->szFile, NULL, NULL, szName, NULL);

            // First step: determine if the driver has a service
            //
   if ((scManager = OpenSCManager (NULL, NULL, GENERIC_READ)) != NULL)
      {
      if ((scDriver = OpenService (scManager, szName, GENERIC_READ)) != NULL)
         {
         QUERY_SERVICE_CONFIG  qsc;
         SERVICE_STATUS        ss;
         DWORD                 cbReq;
         void                 *pqsc;

         SetFlag (dwStatus, dwStatusHASSERVICE);

                  // Great!  It has a service.  Find out if the service
                  // is actively running, and whether it is disabled.
                  //
         if (QueryServiceConfig (scDriver, &qsc, sizeof(qsc), &cbReq))
            {
            if (qsc.dwStartType != SERVICE_DISABLED)
               {
               SetFlag (dwStatus, dwStatusSvcENABLED);
               }
            }
         else if ((pqsc = (void *)LocalAlloc (LPTR, cbReq)) != NULL)
            {
            if (QueryServiceConfig (scDriver,
                                    (QUERY_SERVICE_CONFIG *)pqsc,
                                    cbReq, &cbReq))
               {
               if ( ((QUERY_SERVICE_CONFIG *)pqsc)->dwStartType
                     != SERVICE_DISABLED)
                  {
                  SetFlag (dwStatus, dwStatusSvcENABLED);
                  }
               }

            LocalFree ((HANDLE)pqsc);
            }

         if (QueryServiceStatus (scDriver, &ss))
            {
            if ((ss.dwCurrentState != SERVICE_STOPPED) &&
                (ss.dwCurrentState != SERVICE_STOP_PENDING))
               {
               SetFlag (dwStatus, dwStatusSvcSTARTED);
               }
            }

         CloseServiceHandle (scDriver);
         }

      CloseServiceHandle (scManager);
      }

            // If no service, see if we can talk to the driver itself
            //
   if (!IsFlagSet (dwStatus, dwStatusHASSERVICE))
      {
      HANDLE hDriver;

      if ((hDriver = OpenDriver (pid->wszAlias, pid->wszSection, 0L)) != NULL)
         {
         SetFlag (dwStatus, dwStatusDRIVEROK);

         CloseDriver (hDriver, 0L, 0L);
         }
      }

            // If it's a wave device, can we map through it?
            //
   if (GetMappable (pid))
      {
      SetFlag (dwStatus, dwStatusMAPPABLE);
      }

   return dwStatus;
}


void GetTreeItemNodeDesc (LPTSTR pszTarget, PIRESOURCE pir)
{
   lstrcpy (pszTarget, pir->szFriendlyName);
}


void GetTreeItemNodeID (LPTSTR pszTarget, PIRESOURCE pir)
{
   DriverClass dc;
   CLASSNODE cn;

   *pszTarget = 0;  // In case we fail later

   dc = OldClassIDToDriverClass (pir->iClassID);
   if (!DriverClassToClassNode (&cn, dc))
      return;

   switch (pir->iNode)  // 1=class, 2=device, 3=acm, 4=instmt
      {
      case 1:   // class
         lstrcpy (pszTarget, cn.szClass);
         break;

      case 2:   // instrument
         wsprintf (pszTarget, TEXT("%s\\%s"), cn.szClass, pir->szDrvEntry);
         break;

      case 4:   // instrument
         lstrcpy (pszTarget, pir->szDesc);
         break;

      default:
         lstrcpy (pszTarget, pir->szDesc);
         break;
      }

   FreeClassNode (&cn);
}


void ShowDeviceProperties (HWND hPar, HTREEITEM hti)
{
   IRESOURCE   ir;
   CLASSNODE   cn;
   DEVTREENODE dtn;
   short       idr;
   TCHAR        szTitle[ cchRESOURCE ];
   TCHAR        szTab[ cchRESOURCE ];
   DriverClass dc;
   PIDRIVER    pid;

   if (hti == NULL)
      return;

   if (TreeView_GetParent (hAdvDlgTree, hti) &&
       TreeView_GetGrandParent (hAdvDlgTree, hti) &&
       (GuessDriverClassFromTreeItem (
                       TreeView_GetGrandParent (hAdvDlgTree, hti)
                                     ) == dcMIDI))
      {
      if (InstrumentToResource (&ir, hti))
         {
         ShowMidiPropSheet (NULL,
                            ir.szFriendlyName,
                            hPar,
                            MIDI_INSTRUMENT_PROP,
                            ir.szFriendlyName,
                            hti,
                            (LPARAM)&ir,
                            (LPARAM)hAdvDlgTree);

         FreeIResource (&ir);
         }
      return;
      }
   else if ((pid = FindIDriverByTreeItem (hti)) != NULL)
      {
      dc = GuessDriverClassFromTreeItem (TreeView_GetParent(hAdvDlgTree,hti));
      if (dc == dcINVALID)
         {
         if ((dc = GuessDriverClass (pid)) == dcINVALID)
            return;
         }
      }
   else
      {
      if ((dc = GuessDriverClassFromTreeItem (hti)) == dcINVALID)
         return;
      }

   if (g_dcFilterClass != dcINVALID)
   {
        if ((dc == dcOTHER) || (dc == dcINVALID))
        {
            dc = g_dcFilterClass;
        }
   }

   if ((idr = DriverClassToRootIndex (dc)) == -1)
      return;

   if (pid == NULL) // Just want class properties?
      {
      if (!DriverClassToClassNode (&cn, dc))
         return;

      if (dc == dcMIDI) // MIDI class properties?
         {
         GetString (szTitle, aDriverRoot[idr].idDesc);

         ShowMidiPropSheet (NULL,
                            szTitle,
                            hPar,
                            MIDI_CLASS_PROP,
                            szTitle,
                            hti,
                            (LPARAM)&cn,
                            (LPARAM)hAdvDlgTree);
         }
      else // Generic class properties?  (nothing to do, really)
         {
         GetString (szTab,   IDS_GENERAL);
         GetString (szTitle, aDriverRoot[idr].idDesc);

         dtn.lParam = (LPARAM)&cn;
         dtn.hwndTree = hAdvDlgTree;

         ShowPropSheet (szTab,
                        DevPropDlg,
                        DLG_DEV_PROP,
                        hPar,
                        szTitle,
                        (LPARAM)&dtn);
         }

      FreeClassNode (&cn);
      }
   else
      {
      switch (dc)
         {
         case dcACODEC:
               GetString (szTab, IDS_GENERAL);

               ShowPropSheet (szTab,
                              ACMDlg,
                              DLG_ACMDEV_PROP,
                              hPar,
                              pid->szDesc,
                              pid->lp);

               // Re-sort the Audio Codec entries, in case their priorities
               // have changed.  Then find treeview item for this codec,
               // and select it.
               //
               {
               HTREEITEM  hti;
               short      idr;

               SendMessage (hAdvDlgTree, WM_SETREDRAW, FALSE, 0L);
               FillTreeFromMSACM (hAdvDlgTree);
               SendMessage (hAdvDlgTree, WM_SETREDRAW, TRUE, 0L);

               if ((idr = DriverClassToRootIndex (dcACODEC)) != -1)
                  {
                  if ((hti = aDriverRoot[ idr ].hti) != NULL)
                     {
                     for (hti = TreeView_GetChild (hAdvDlgTree, hti);
                          hti != NULL;
                          hti = TreeView_GetNextSibling (hAdvDlgTree, hti))
                        {
                        if (pid == FindIDriverByTreeItem (hti))
                           {
                           TreeView_SelectItem (hAdvDlgTree, hti);
                           break;
                           }
                        }
                     }
                  }
               }
              break;

         case dcMIDI:
               if (!DriverToResource (hPar, &ir, pid, dc))
                  break;

               GetString (szTab, IDS_GENERAL);

               dtn.lParam = (LPARAM)&ir;
               dtn.hwndTree = hAdvDlgTree;

               ShowWithMidiDevPropSheet (szTab,
                                         DevPropDlg,
                                         DLG_DEV_PROP,
                                         hPar,
                                         pid->szDesc,
                                         hti,
                                         (LPARAM)&dtn,
                                         (LPARAM)&ir,
                                         (LPARAM)hAdvDlgTree);

               FreeIResource (&ir);
              break;

         case dcWAVE:
               if (!DriverToResource (hPar, &ir, pid, dc))
                  break;

               GetString (szTab, IDS_GENERAL);

               dtn.lParam = (LPARAM)&ir;
               dtn.hwndTree = hAdvDlgTree;

               ShowPropSheet (szTab,
                              DevPropDlg,
                              DLG_WAVDEV_PROP,
                              hPar,
                              pid->szDesc,
                              (LPARAM)&dtn);

               FreeIResource (&ir);
              break;

         default:
               if (!DriverToResource (hPar, &ir, pid, dc))
                  break;

               GetString (szTab, IDS_GENERAL);

               dtn.lParam = (LPARAM)&ir;
               dtn.hwndTree = hAdvDlgTree;

               ShowPropSheet (szTab,
                              DevPropDlg,
                              DLG_DEV_PROP,
                              hPar,
                              pid->szDesc,
                              (LPARAM)&dtn);

               FreeIResource (&ir);
              break;
         }
      }
}



#include "medhelp.h"

const static DWORD aDevPropHelpIds[] = {  // Context Help IDs
    ID_DEV_SETTINGS,     IDH_MMCPL_DEVPROP_SETTINGS,
    IDC_DEV_ICON,        NO_HELP,
    IDC_DEV_DESC,        NO_HELP,
    IDC_DEV_STATUS,      NO_HELP,
    IDC_ENABLE,          IDH_MMCPL_DEVPROP_ENABLE,
    IDC_DISABLE,         IDH_MMCPL_DEVPROP_DISABLE,
    IDC_DONOTMAP,        IDH_MMCPL_DEVPROP_DONT_MAP,
    0, 0
};

/*
 ***************************************************************
 * DlgProc for device Property sheet.
 ***************************************************************
 */
INT_PTR CALLBACK DevPropDlg (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR   *lpnm;

    switch (uMsg)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                    break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;
            }
            break;

        case WM_INITDIALOG:
        {
            PIRESOURCE pIResource;
            PCLASSNODE pcn;
            PDEVTREENODE pdtn = (PDEVTREENODE)(((LPPROPSHEETPAGE)lParam)->lParam);

            SetWindowLongPtr(hDlg, DWLP_USER, ((LPPROPSHEETPAGE)lParam)->lParam);

            if (*((short *)(pdtn->lParam)) == 1)
            {
                HWND hwndTree = pdtn->hwndTree;
                HTREEITEM  htiCur = TreeView_GetSelection(hwndTree);
                TCHAR   sz[cchRESOURCE];
                TV_ITEM tvi;

                tvi.mask = TVIF_CHILDREN;
                tvi.hItem = htiCur;
                TreeView_GetItem(hwndTree, &tvi);

                pcn = (PCLASSNODE)(pdtn->lParam);
                //set class icon.
                SendDlgItemMessage(hDlg, IDC_DEV_ICON, STM_SETICON, (WPARAM)pcn->hIcon , 0L);
                SetWindowText(GetDlgItem(hDlg, IDC_DEV_DESC), pcn->szClassName);
                DestroyWindow(GetDlgItem(hDlg, IDC_ENABLE));
                DestroyWindow(GetDlgItem(hDlg, IDC_DISABLE));
                DestroyWindow(GetDlgItem(hDlg, ID_DEV_SETTINGS));

                GetString (sz, (tvi.cChildren) ? IDS_NOPROP : IDS_NODEVS);
                SetWindowText(GetDlgItem(hDlg, IDC_DEV_STATUS), sz);
            }
            else
            {
                pIResource = (PIRESOURCE)(pdtn->lParam);
                SendDlgItemMessage(hDlg, IDC_DEV_ICON, STM_SETICON, (WPARAM)pIResource->pcn->hIcon , 0L);
                SetWindowText(GetDlgItem(hDlg, IDC_DEV_DESC), pIResource->szDesc);
                if (!IsFlagSet(pIResource->fStatus, dwStatusHASSERVICE) &&
                    !IsFlagSet(pIResource->fStatus, dwStatusDRIVEROK))
                {
                    SetDevStatus(pIResource->fStatus, hDlg);
                }
                else
                {
                    if (pIResource->iClassID == WAVE_ID)
                    {
                        CheckDlgButton (hDlg,
    IDC_DONOTMAP,
    IsFlagClear(pIResource->fStatus,
              dwStatusMAPPABLE));
                    }

                    if (!pIResource->fQueryable || pIResource->fQueryable == -1)
                        EnableWindow(GetDlgItem(hDlg, ID_DEV_SETTINGS), FALSE);
                    if (!IsFlagSet (pIResource->fStatus, dwStatusHASSERVICE))
                    {
                        DestroyWindow(GetDlgItem(hDlg, IDC_ENABLE));
                        DestroyWindow(GetDlgItem(hDlg, IDC_DISABLE));
                    }
                    else
                    {
                        TCHAR szStatusStr[MAXSTR];
                        DriverClass dc;
                        short idr;

                        dc = OldClassIDToDriverClass (pIResource->iClassID);
                        idr = DriverClassToRootIndex (dc);

                        if (idr == -1)
                        {
                           DestroyWindow (GetDlgItem(hDlg, IDC_ENABLE));
                           DestroyWindow (GetDlgItem(hDlg, IDC_DISABLE));
                        }
                        else
                        {
                           GetString (szStatusStr, aDriverRoot[idr].idEnable);
                           SetDlgItemText(hDlg, IDC_ENABLE, szStatusStr);
                           GetString (szStatusStr, aDriverRoot[idr].idDisable);
                           SetDlgItemText(hDlg, IDC_DISABLE, szStatusStr);
                        }
                    }
                }
                SetDevStatus(pIResource->fStatus, hDlg);
            }

#ifdef FIX_BUG_15451
            if (szDriverWhichNeedsSettings[0] != TEXT('\0'))
            {
                MakeThisDialogLookLikeTheOldDialog (GetParent(hDlg));
            }
#endif // FIX_BUG_15451
            break;
        }

        case WM_DESTROY:
            break;

        case WM_DROPFILES:
            break;

        case WM_CONTEXTMENU:
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (UINT_PTR) (LPTSTR) aDevPropHelpIds);
            return TRUE;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
                    (UINT_PTR) (LPTSTR) aDevPropHelpIds);
            return TRUE;
        }

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoDevPropCommand);
            break;
    }
    return FALSE;
}

/*
 ***************************************************************
 *
 ***************************************************************
 */
BOOL PASCAL DoDevPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    PDEVTREENODE pdtn = (PDEVTREENODE)GetWindowLongPtr(hDlg, DWLP_USER);
    PIRESOURCE pIResource;
    static int fDevStatus;

    if (!pdtn)
        return FALSE;
    pIResource = (PIRESOURCE)(pdtn->lParam);

    switch (id)
    {

    case ID_APPLY:
        if ((pIResource->iNode == 2) && (fDevStatus != pIResource->fStatus))
        {
            if ( (IsFlagSet (fDevStatus, dwStatusMAPPABLE)) !=
                 (IsFlagSet (pIResource->fStatus, dwStatusMAPPABLE)) )
            {
                SetMappable (pIResource,
                             (BOOL)IsFlagSet (fDevStatus, dwStatusMAPPABLE));
            }

            if ( (IsFlagSet (fDevStatus, dwStatusHASSERVICE)) &&
                 (IsFlagSet (fDevStatus, dwStatusSvcENABLED) !=
                  IsFlagSet (pIResource->fStatus, dwStatusSvcENABLED)) )
            {
#if 0 // TODO: Multiportmidi
                if ( (pIResource->iClassID == MIDI_ID) &&
                     (IsFlagSet(fDevStatus, DEV_MULTIPORTMIDI)) )
                {
                    EnableMultiPortMIDI (pIResource,
                                         IsFlagSet (fDevStatus,
                dwStatusSvcENABLED));
                }
                else
#endif
                {
                    EnableDriverService (pIResource,
                                         IsFlagSet (fDevStatus,
                dwStatusSvcENABLED));
                }
            }
            DisplayMessage(hDlg, IDS_CHANGESAVED, IDS_RESTART, MB_OK);
        }
        return TRUE;

    case IDOK:
        return TRUE;
    case IDCANCEL:
        break;

    case ID_INIT:
        if (pIResource->iNode == 2)
            fDevStatus = pIResource->fStatus;
#ifdef FIX_BUG_15451
        if (szDriverWhichNeedsSettings[0] != TEXT('\0'))
        {
            FORWARD_WM_COMMAND(hDlg,ID_DEV_SETTINGS,0,0,PostMessage);
        }
#endif // FIX_BUG_15451
        break;

    case IDC_DONOTMAP:
        if(Button_GetCheck(GetDlgItem(hDlg, IDC_DONOTMAP)))
            ClearFlag(fDevStatus, dwStatusMAPPABLE);
        else
            SetFlag(fDevStatus, dwStatusMAPPABLE);
        PropSheet_Changed(GetParent(hDlg),hDlg);
        break;

    case IDC_ENABLE:
        if (IsFlagSet (fDevStatus, dwStatusHASSERVICE))
        {
           SetFlag(fDevStatus, dwStatusSvcENABLED);
           SetDevStatus(fDevStatus, hDlg);
           PropSheet_Changed(GetParent(hDlg),hDlg);
#if 0 // TODO: Multiportmidi
           if (IsFlagSet(fDevStatus, DEV_MULTIPORTMIDI))
           {
               DisplayMessage(hDlg, IDS_ENABLE, IDS_ENABLEMULTIPORTMIDI, MB_OK);
           }
#endif
        }
        break;

    case IDC_DISABLE:
        if (IsFlagSet (fDevStatus, dwStatusHASSERVICE))
        {
           ClearFlag(fDevStatus, dwStatusSvcENABLED);
           SetDevStatus(fDevStatus, hDlg);
           PropSheet_Changed(GetParent(hDlg),hDlg);
#if 0 // TODO: Multiportmidi
           if (IsFlagSet(fDevStatus, DEV_MULTIPORTMIDI))
           {
               DisplayMessage(hDlg, IDS_DISABLE, IDS_DISABLEMULTIPORTMIDI, MB_OK);
           }
#endif
        }
        break;

    case ID_DEV_SETTINGS:
#ifdef FIX_BUG_15451
        if (szDriverWhichNeedsSettings[0] != TEXT('\0'))
        {
            ConfigureDriver (hDlg, szDriverWhichNeedsSettings);
            szDriverWhichNeedsSettings[0] = 0;
        }
        else
        {
            PIDRIVER  pid;

            if ((pid = FindIDriverByResource (pIResource)) == NULL)
                break;

            ShowDriverSettings (hDlg, pid->szFile);
        }
#else // FIX_BUG_15451
    {
        PIDRIVER  pid;
        HANDLE    hDriver;

        if ((pid = FindIDriverByResource (pIResource)) == NULL)
            break;

        if ((hDriver = OpenDriver (pid->wszAlias, pid->wszSection, 0L)) == 0)
        {
            OpenDriverError(hDlg, pid->szDesc, pid->szFile);
        }
        else
        {
            DRVCONFIGINFO   DrvConfigInfo;
            InitDrvConfigInfo(&DrvConfigInfo, pid);
            if ((SendDriverMessage(
                     hDriver,
                     DRV_CONFIGURE,
                     (LONG)hDlg,
                     (LONG)(LPDRVCONFIGINFO)&DrvConfigInfo) ==
                DRVCNF_RESTART))
            {
               iRestartMessage= 0;
               DialogBox(myInstance,
                  MAKEINTRESOURCE(DLG_RESTART), hDlg, RestartDlg);
            }
            CloseDriver(hDriver, 0L, 0L);
        }
        }
#endif // FIX_BUG_15451
        break;
    }
    return FALSE;
}


/*
 ***************************************************************
 * Check the status flag for the device and display the appropriate text the
 *  the device properties prop sheet.
 ***************************************************************
 */
STATIC void SetDevStatus(int iStatus, HWND hDlg)
{
    HWND hwndS = GetDlgItem(hDlg, IDC_DEV_STATUS);
    TCHAR szStatus[cchRESOURCE];

    if (IsFlagSet (iStatus, dwStatusHASSERVICE))
    {
        if (IsFlagSet (iStatus, dwStatusSvcENABLED))
        {
            if (IsFlagSet (iStatus, dwStatusSvcSTARTED))
                GetString (szStatus, IDS_DEVENABLEDOK);
            else
                GetString (szStatus, IDS_DEVENABLEDNOTOK);

            CheckRadioButton (hDlg, IDC_ENABLE, IDC_DISABLE, IDC_ENABLE);
        }
        else // service has been disabled
        {
            if (IsFlagSet (iStatus, dwStatusSvcSTARTED))
                GetString (szStatus, IDS_DEVDISABLEDOK);
            else
                GetString (szStatus, IDS_DEVDISABLED);

            CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_DISABLE);
        }

        SetWindowText(hwndS, szStatus);
    }
    else // driver does not have a service, and thus can't be disabled
    {
        if (IsFlagSet (iStatus, dwStatusDRIVEROK))
            GetString (szStatus, IDS_DEVENABLEDOK);
        else
            GetString (szStatus, IDS_DEVENABLEDNODRIVER);

        CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_ENABLE);
        SetWindowText(hwndS, szStatus);
    }
}


/*
 *** EnableDriverService - enable or disable a service-based driver
 *
 * If Enable, the service will be set to start==system_start.
 * If !Enable, the service will be set to start==disabled.
 *
 */

void EnableDriverService (PIRESOURCE pir, BOOL fEnable)
{
   SC_HANDLE scManager;
   SC_HANDLE scDriver;
   TCHAR     szName[ cchRESOURCE ];

   lsplitpath (pir->szFile, NULL, NULL, szName, NULL);

            // First step: determine if the driver has a service
            //
   if ((scManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS)) != NULL)
      {
      if ((scDriver = OpenService (scManager, szName, SERVICE_ALL_ACCESS)) != 0)
         {
         QUERY_SERVICE_CONFIG  qsc;
         SERVICE_STATUS        ss;
         DWORD                 cbReq;
         void                 *pqsc;

         ChangeServiceConfig (scDriver,
                              SERVICE_NO_CHANGE,
                              (fEnable) ? SERVICE_SYSTEM_START
                                        : SERVICE_DISABLED,
                              SERVICE_NO_CHANGE,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);

         CloseServiceHandle (scDriver);
         }

      CloseServiceHandle (scManager);
      }
}


/*
 ***************************************************************
 * SetMappable
 *
 * Sets the "Mappable" value for wave devices in the registry.
 * The registry key is created if necessary
 *
 ***************************************************************
 */

BOOL SetMappable (PIRESOURCE pIResource, BOOL fMappable)
{
    TCHAR   szFile[ _MAX_FNAME +1 +_MAX_EXT +1 ];
    TCHAR   szExt[ _MAX_EXT +1 ];
    TCHAR   szRegKey[MAX_PATH+1];
    DWORD   dwMappable;
    HKEY    hKey;

    dwMappable = (fMappable) ? 1 : 0;

    lsplitpath (pIResource->szFile, NULL, NULL, szFile, szExt);
    if (szExt[0] != TEXT('\0'))
        lstrcat (szFile, szExt);

    wsprintf (szRegKey, TEXT("%s\\%s"), REGSTR_PATH_WAVEMAPPER, szFile);

    if (RegCreateKey (HKEY_LOCAL_MACHINE, szRegKey, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    if (RegSetValueEx (hKey,
                       REGSTR_VALUE_MAPPABLE,
                       (DWORD)0,
                       REG_DWORD,
                       (void *)&dwMappable,
                       sizeof(dwMappable)) != ERROR_SUCCESS)
    {
        RegCloseKey (hKey);
        return FALSE;
    }

    RegCloseKey (hKey);

    if (fMappable)
    {
        SetFlag(pIResource->fStatus, dwStatusMAPPABLE);
    }
    else
    {
        ClearFlag(pIResource->fStatus, dwStatusMAPPABLE);
    }

    return TRUE;
}


BOOL GetMappable (PIDRIVER pIDriver)
{
    TCHAR   szFile[ _MAX_FNAME +1 +_MAX_EXT +1 ];
    TCHAR   szExt[ _MAX_EXT +1 ];
    TCHAR   szRegKey[MAX_PATH+1];
    DWORD   dwMappable;
    DWORD   dwSize;
    DWORD   dwType;
    HKEY    hKey;

    lsplitpath (pIDriver->szFile, NULL, NULL, szFile, szExt);
    if (szExt[0] != TEXT('\0'))
        lstrcat (szFile, szExt);

    wsprintf (szRegKey, TEXT("%s\\%s"), REGSTR_PATH_WAVEMAPPER, szFile);

    if (RegOpenKey (HKEY_LOCAL_MACHINE, szRegKey, &hKey) != ERROR_SUCCESS)
    {
        return TRUE;
    }

    dwSize = sizeof(dwMappable);
    if (RegQueryValueEx (hKey,
                         REGSTR_VALUE_MAPPABLE,
                         NULL,
                         &dwType,
                         (void *)&dwMappable,
                         &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey (hKey);
        return TRUE;
    }

    RegCloseKey (hKey);

    return (dwMappable) ? TRUE : FALSE;
}


#ifdef FIX_BUG_15451

        // FixDriverService - work around known problems with sound drivers
        //
        // If there was a functioning kernel-mode service in place before the
        // config dialog was presented, then there should still be one
        // afterwards.  However, there are two known problems with the
        // currently-release drivers:
        //
        // 1) The service may not have shut down properly, and is stuck
        //    in a STOP_PENDING state(*).  If this is the case, we need to
        //    ensure that the service is set to load on SYSTEM_START, and
        //    tell the user that the machine has to be rebooted before sound
        //    will work again.
        //
        // 2) The service may have failed to restart properly, and is
        //    stopped(**).  If this is the case, and LoadType!=0, try setting
        //    LoadType=1 and starting the service.
        //
        // (*) -- bug #15451 in NT/SUR, where pending IRPs and open mixer
        //        handles prevent the service from shutting down
        //
        // (**) -- bug #XXXXX in NT/SUR, where some RISC machines stop the
        //         service, set LoadType=1, and fail to restart the service
        //         after you cancel their config dialog
        //
BOOL FixDriverService (PIDRIVER pid)
{
    SC_HANDLE scManager;
    SC_HANDLE scDriver;
    SERVICE_STATUS ss;
    BOOL rc = FALSE;
    TCHAR szName[ cchRESOURCE ];

    lsplitpath (pid->szFile, NULL, NULL, szName, NULL);

    // First step: open the service...even if it's hosed, we should
    // still be able to do this.
    //
    if ((scManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS)) == 0)
    {
        return FALSE;
    }
    if ((scDriver = OpenService (scManager, szName, SERVICE_ALL_ACCESS)) == 0)
    {
        CloseServiceHandle (scManager);
        return FALSE;
    }

    // Now check its status.  Look for STOP_PENDING and STOPPED states.
    //
    if (QueryServiceStatus (scDriver, &ss))
    {
        if (ss.dwCurrentState == SERVICE_STOP_PENDING)
        {
            // The service didn't stop properly--we'll have to reboot.
            // Make sure the service is configured such that it will start
            // properly when we restart.
            //
            ChangeServiceConfig (scDriver,
                                 SERVICE_NO_CHANGE,
                                 SERVICE_SYSTEM_START,   // Enable this puppy!
                                 SERVICE_NO_CHANGE,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);

            // Tell the caller that a reboot is mandatory
            rc = TRUE;
        }
        else if (ss.dwCurrentState == SERVICE_STOPPED)
        {
            TCHAR szKey[ cchRESOURCE ];
            HKEY  hkParams;

            // The service stopped, but didn't restart properly--it could
            // just be the LoadType problem.  To fix this, we'll need
            // to enumerate all the keys underneath the key
            // HKLM\System\CurrentControlSet\Services\(thisdriver)\Parameters,
            // and look for ...\Parameters\*\LoadType==(DWORD)1.
            //
            // First step is to open HKLM\System\CCS\Services\(driver)\Parms.
            //
            wsprintf (szKey, TEXT("%s\\%s\\Parameters"),
                             REGSTR_PATH_SERVICES,
                             szName);

            if (RegOpenKey (HKEY_LOCAL_MACHINE, szKey, &hkParams) == 0)
            {
                DWORD cSubKeys;
                DWORD iSubKey;
                BOOL fFixedLoadType = FALSE;

                // Find out how many subkeys there are under here--the
                // keys we want are named "Device0" through "Device(n-1)"
                //
                RegQueryInfoKey (hkParams,
                                 NULL,          // lpClass
                                 NULL,          // lpcbClass
                                 NULL,          // lpReserved
                                 &cSubKeys,     // Whoops!  We want this.
                                 NULL,          // lpcbMaxSubKeyLen
                                 NULL,          // lpcbMaxClassLen
                                 NULL,          // lpcValues
                                 NULL,          // lpcbMaxValueNameLen
                                 NULL,          // lpcbMaxValueLen
                                 NULL,          // lpcbSecurityDescriptor
                                 NULL);         // lpftLastWriteTime

                // Open each subkey in turn, and look for a LoadType=
                // which is bogus.
                //
                for (iSubKey = 0; iSubKey < cSubKeys; ++iSubKey)
                {
                    HKEY hk;
                    TCHAR szSubKey[ cchRESOURCE ];
                    wsprintf (szSubKey, TEXT("Device%lu"), (LONG)iSubKey);

                    if (RegOpenKey (hkParams, szSubKey, &hk) == ERROR_SUCCESS)
                    {
                        DWORD dwLoadType;
                        DWORD dwType;
                        DWORD dwSize = sizeof(dwType);

                        if (RegQueryValueEx (hk,
                                             cszRegValueLOADTYPE,
                                             NULL,
                                             &dwType,
                                             (void *)&dwLoadType,
                                             &dwSize) == 0)
                        {
                            if (dwLoadType == 1)
                            {
                                dwLoadType = 0;
                                fFixedLoadType = TRUE;

                                RegSetValueEx (hk,
                                               cszRegValueLOADTYPE,
                                               0,
                                               REG_DWORD,
                                               (void *)&dwLoadType,
                                               sizeof(dwLoadType));
                            }
                        }

                        RegCloseKey (hk);
                    }
                }

                // If we fixed a LoadType value, try to restart the service.
                //
                if (fFixedLoadType)
                {
                    if (StartService (scDriver, 0, NULL))
                    {
                        ChangeServiceConfig (scDriver,
                                             SERVICE_NO_CHANGE,
                                             SERVICE_SYSTEM_START,
                                             SERVICE_NO_CHANGE,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL);
                    }
                }
            }
        }
    }


    // Clean up.  We'll return TRUE if a reboot is necessary, and FALSE
    // otherwise.
    //
    CloseServiceHandle (scDriver);
    CloseServiceHandle (scManager);
    return rc;
}


void ConfigureDriver (HWND hDlg, LPTSTR pszName)
{
    PIDRIVER  pid;
    HANDLE    hDriver;
    BOOL      fShowTrayVol;
    BOOL      fRestartDialog = FALSE;

    if ((pid = FindIDriverByName (pszName)) == NULL)
        return;

    fShowTrayVol = GetTrayVolumeEnabled();
    if (fShowTrayVol)
        SetTrayVolumeEnabled(FALSE);

    if ((hDriver = OpenDriver (pid->wszAlias, pid->wszSection, 0L)) == 0)
    {
        OpenDriverError(hDlg, pid->szDesc, pid->szFile);
    }
    else
    {
        DWORD dwStatus = GetDriverStatus (pid);
        BOOL fHadService = IsFlagSet (dwStatus, dwStatusSvcSTARTED) &&
                           IsFlagSet (dwStatus, dwStatusHASSERVICE);

        DRVCONFIGINFO   DrvConfigInfo;
        InitDrvConfigInfo(&DrvConfigInfo, pid);
        if ((SendDriverMessage(
                 hDriver,
                 DRV_CONFIGURE,
                 (LONG_PTR)hDlg,
                 (LONG_PTR)(LPDRVCONFIGINFO)&DrvConfigInfo) ==
            DRVCNF_RESTART))
        {
            iRestartMessage = 0;
            fRestartDialog = TRUE;
        }
        CloseDriver(hDriver, 0L, 0L);

        // If there was a functioning kernel-mode service in place before the
        // config dialog was presented, then we should verify that there is
        // still one in place now.  See FixDriverService() for details.
        //
        if (fHadService)
        {
            dwStatus = GetDriverStatus (pid);

            if (!IsFlagSet (dwStatus, dwStatusSvcSTARTED) ||
                !IsFlagSet (dwStatus, dwStatusHASSERVICE))
            {
                if (FixDriverService (pid))
                {
                    iRestartMessage = IDS_RESTART_NOSOUND;
                    fRestartDialog = TRUE;
                }
            }
        }
    }


    if (fShowTrayVol)
        SetTrayVolumeEnabled(TRUE);

    if (fRestartDialog)
    {
        DialogBox(myInstance,MAKEINTRESOURCE(DLG_RESTART),hDlg,RestartDlg);
    }
}


BOOL fDeviceHasMixers (LPTSTR pszName)
{
    HKEY  hk;
    UINT  ii;
    BOOL  rc = FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_DRIVERS32, &hk))
    {
        return FALSE;
    }

    for (ii = 0; ; ++ii)
    {
        TCHAR  szLHS[ cchRESOURCE ];
        TCHAR  szRHS[ cchRESOURCE ];
        DWORD  dw1;
        DWORD  dw2;
        DWORD  dw3;

        dw1 = cchRESOURCE;
        dw3 = cchRESOURCE;
        if (RegEnumValue (hk, ii,  szLHS, &dw1,
                          0, &dw2, (LPBYTE)szRHS, &dw3) != ERROR_SUCCESS)
        {
            break;
        }

        if ( (GuessDriverClassFromAlias (szLHS) == dcMIXER) &&
             (!FileNameCmp (pszName, szRHS)) )
        {
            rc = TRUE;
            break;
        }
    }

    RegCloseKey (hk);
    return rc;
}
#endif // FIX_BUG_15451


TCHAR c_tszControlExeS[] = TEXT("control.exe %s");

BOOL RunJoyControlPanel(void)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR tsz[MAX_PATH];
    BOOL  fRtn;

    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
    wsprintf(tsz, c_tszControlExeS, TEXT("joy.cpl"));
    if (CreateProcess(0, tsz, 0, 0, 0, 0, 0, 0, &si, &pi)) {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    fRtn = TRUE;
    } else {
        fRtn = FALSE;
    }

    return fRtn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\dslevel.cpp ===
//--------------------------------------------------------------------------;
//
//  File: dslevel.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;


#include "mmcpl.h"

#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>

#include "utils.h"
#include "medhelp.h"
#include "dslevel.h"
#include "perfpage.h"
#include "speakers.h"

#include <initguid.h>
#include <dsound.h>
#include <dsprv.h>

#define REG_KEY_SPEAKERTYPE TEXT("Speaker Type")

typedef HRESULT (STDAPICALLTYPE *LPFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);
typedef HRESULT (STDAPICALLTYPE *LPFNDIRECTSOUNDCREATE)(LPGUID, LPDIRECTSOUND*, IUnknown FAR *);
typedef HRESULT (STDAPICALLTYPE *LPFNDIRECTSOUNDCAPTURECREATE)(LPGUID, LPDIRECTSOUNDCAPTURE*, IUnknown FAR *);


HRESULT 
DirectSoundPrivateCreate
(
    OUT LPKSPROPERTYSET *   ppKsPropertySet
)
{
    HMODULE                 hLibDsound              = NULL;
    LPFNDLLGETCLASSOBJECT   pfnDllGetClassObject    = NULL;
    LPCLASSFACTORY          pClassFactory           = NULL;
    LPKSPROPERTYSET         pKsPropertySet          = NULL;
    HRESULT                 hr                      = DS_OK;
    
    // Load dsound.dll
    hLibDsound = LoadLibrary(TEXT("dsound.dll"));

    if(!hLibDsound)
    {
        hr = DSERR_GENERIC;
    }

    // Find DllGetClassObject
    if(SUCCEEDED(hr))
    {
        pfnDllGetClassObject = 
            (LPFNDLLGETCLASSOBJECT)GetProcAddress
            (
                hLibDsound, 
                "DllGetClassObject"
            );

        if(!pfnDllGetClassObject)
        {
            hr = DSERR_GENERIC;
        }
    }

    // Create a class factory object    
    if(SUCCEEDED(hr))
    {
        hr = 
            pfnDllGetClassObject
            (
                CLSID_DirectSoundPrivate, 
                IID_IClassFactory, 
                (LPVOID *)&pClassFactory
            );
    }

    // Create the DirectSoundPrivate object and query for an IKsPropertySet
    // interface
    if(SUCCEEDED(hr))
    {
        hr = 
            pClassFactory->CreateInstance
            (
                NULL, 
                IID_IKsPropertySet, 
                (LPVOID *)&pKsPropertySet
            );
    }

    // Release the class factory
    if(pClassFactory)
    {
        pClassFactory->Release();
    }

    // Handle final success or failure
    if(SUCCEEDED(hr))
    {
        *ppKsPropertySet = pKsPropertySet;
    }
    else if(pKsPropertySet)
    {
        pKsPropertySet->Release();
    }

    FreeLibrary(hLibDsound);

    return hr;
}


HRESULT 
DSGetGuidFromName
(
    IN  LPTSTR              szName, 
    IN  BOOL                fRecord, 
    OUT LPGUID              pGuid
)
{
    LPKSPROPERTYSET         pKsPropertySet  = NULL;
    HRESULT                 hr;

    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA 
        WaveDeviceMap;

    // Create the DirectSoundPrivate object
    hr = 
        DirectSoundPrivateCreate
        (
            &pKsPropertySet
        );

    // Attempt to map the waveIn/waveOut device string to a DirectSound device
    // GUID.
    if(SUCCEEDED(hr))
    {
        WaveDeviceMap.DeviceName = szName;
        WaveDeviceMap.DataFlow = fRecord ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;

        hr = 
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundDevice, 
                DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING, 
                NULL, 
                0, 
                &WaveDeviceMap, 
                sizeof(WaveDeviceMap), 
                NULL
            );
    }

    // Clean up
    if(pKsPropertySet)
    {
        pKsPropertySet->Release();
    }

    if(SUCCEEDED(hr))
    {
        *pGuid = WaveDeviceMap.DeviceId;
    }

    return hr;
}

HRESULT
DSSetupFunctions
(
    LPFNDIRECTSOUNDCREATE* pfnDSCreate,
    LPFNDIRECTSOUNDCAPTURECREATE* pfnDSCaptureCreate
)
{
    HMODULE                 hLibDsound              = NULL;
    HRESULT                 hr                      = DS_OK;
    
    // Load dsound.dll
    hLibDsound = LoadLibrary(TEXT("dsound.dll"));

    if(!hLibDsound)
    {
        hr = DSERR_GENERIC;
    }

    // Find DirectSoundCreate
    if(SUCCEEDED(hr))
    {
        *pfnDSCreate = 
            (LPFNDIRECTSOUNDCREATE)GetProcAddress
            (
                hLibDsound, 
                "DirectSoundCreate"
            );

        if(!(*pfnDSCreate))
        {
            hr = DSERR_GENERIC;
        }
    } //end DirectSoundCreate

    // Find DirectSoundCaptureCreate
    if(SUCCEEDED(hr))
    {
        *pfnDSCaptureCreate = 
            (LPFNDIRECTSOUNDCAPTURECREATE)GetProcAddress
            (
                hLibDsound, 
                "DirectSoundCaptureCreate"
            );

        if(!(*pfnDSCaptureCreate))
        {
            hr = DSERR_GENERIC;
        }
    } //end DirectSoundCaptureCreate

    FreeLibrary(hLibDsound);

    return (hr);
}

void
DSCleanup
(
    IN  LPKSPROPERTYSET         pKsPropertySet,
    IN  LPDIRECTSOUND           pDirectSound,
    IN  LPDIRECTSOUNDCAPTURE    pDirectSoundCapture
)
{
    if(pKsPropertySet)
    {
        pKsPropertySet->Release();
    }

    if(pDirectSound)
    {
        pDirectSound->Release();
    }

    if(pDirectSoundCapture)
    {
        pDirectSoundCapture->Release();
    }
}

HRESULT
DSInitialize
(
    IN  GUID                    guid, 
    IN  BOOL                    fRecord, 
    OUT LPKSPROPERTYSET*        ppKsPropertySet,
    OUT LPLPDIRECTSOUND         ppDirectSound,
    OUT LPLPDIRECTSOUNDCAPTURE  ppDirectSoundCapture
)
{
    HRESULT                 hr;

    LPFNDIRECTSOUNDCREATE           pfnDirectSoundCreate = NULL;
    LPFNDIRECTSOUNDCAPTURECREATE    pfnDirectSoundCaptureCreate = NULL;

    // Initialize variables to return
    *ppKsPropertySet = NULL;
    *ppDirectSound = NULL;
    *ppDirectSoundCapture = NULL;

    // Find the necessary DirectSound functions
    hr = DSSetupFunctions(&pfnDirectSoundCreate, &pfnDirectSoundCaptureCreate);

    if (FAILED(hr))
    {
        return (hr);
    }

    // Create the DirectSound object
    if(fRecord)
    {
        hr = 
            pfnDirectSoundCaptureCreate
            (
                &guid, 
                ppDirectSoundCapture, 
                NULL
            );
    }
    else
    {
        hr = 
            pfnDirectSoundCreate
            (
                &guid, 
                ppDirectSound, 
                NULL
            );
    }
    
    // Create the DirectSoundPrivate object
    if(SUCCEEDED(hr))
    {
        hr = 
            DirectSoundPrivateCreate
            (
                ppKsPropertySet
            );
    }

    // Clean up
    if(FAILED(hr))
    {
        DSCleanup
        (
            *ppKsPropertySet,
            *ppDirectSound,
            *ppDirectSoundCapture
        );
        *ppKsPropertySet = NULL;
        *ppDirectSound = NULL;
        *ppDirectSoundCapture = NULL;
    }

    return hr;
}

HRESULT
DSGetAcceleration
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    OUT LPDWORD             pdwHWLevel
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr;

    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA   
        BasicAcceleration;
    
    // Find the necessary DirectSound functions
    hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );

    // Get properties for this device
    if(SUCCEEDED(hr))
    {
        BasicAcceleration.DeviceId = guid;

        // Get the default acceleration level
        hr = 
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundBasicAcceleration, 
                DSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT, 
                NULL, 
                0, 
                &BasicAcceleration, 
                sizeof(BasicAcceleration), 
                NULL
            );

        if (SUCCEEDED(hr))
        {
            gAudData.dwDefaultHWLevel = BasicAcceleration.Level;
        }
        
        // Get the basic HW acceleration level.  This property will return
        // S_FALSE if no error occurred, but the registry value did not exist.
        

        hr = 
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundBasicAcceleration, 
                DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION, 
                NULL, 
                0, 
                &BasicAcceleration, 
                sizeof(BasicAcceleration), 
                NULL
            );

        if(SUCCEEDED(hr))
        {
            *pdwHWLevel = BasicAcceleration.Level;
        }
        else
        {
            *pdwHWLevel = gAudData.dwDefaultHWLevel;
        }
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT
DSGetSrcQuality
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    OUT LPDWORD             pdwSRCLevel
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr;

    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA                 
        SrcQuality;

    // Find the necessary DirectSound functions
    hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );

    // Get properties for this device
    if(SUCCEEDED(hr))
    {
        // Get the mixer SRC quality.  This property will return S_FALSE 
        // if no error occurred, but the registry value did not exist.
        SrcQuality.DeviceId = guid;
        
        hr = 
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundMixer, 
                DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY, 
                NULL, 
                0, 
                &SrcQuality, 
                sizeof(SrcQuality), 
                NULL
            );

        if(SUCCEEDED(hr))
        {
            // The CPL only uses the 3 highest of 4 possible SRC values
            *pdwSRCLevel = SrcQuality.Quality;

            if(*pdwSRCLevel > 0)
            {
                (*pdwSRCLevel)--;
            }
        }
        else
        {
            *pdwSRCLevel = DEFAULT_SRC_LEVEL;
        }
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT
DSGetSpeakerConfigType
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    OUT LPDWORD             pdwSpeakerConfig,
    OUT LPDWORD             pdwSpeakerType
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr                  = DS_OK;
    HRESULT                 hrSpeakerType;

    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA
        SpeakerType;

    // Can't get the speaker type if we're recording
    if(fRecord)
    {
        hr = E_INVALIDARG;
    }

    // Find the necessary DirectSound functions
    if(SUCCEEDED(hr))
    {
        hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );
    }

    // Get properties for this device
    if(SUCCEEDED(hr))
    {
        // Get the speaker config
        hr = 
            pDirectSound->GetSpeakerConfig
            (
                pdwSpeakerConfig
            );

        if(FAILED(hr))
        {
            *pdwSpeakerConfig = DSSPEAKER_STEREO;
        }

        // Get the speaker type.  This property will return failure
        // if the registry value doesn't exist.
        SpeakerType.DeviceId = guid;
        SpeakerType.SubKeyName = REG_KEY_SPEAKERTYPE;
        SpeakerType.ValueName = REG_KEY_SPEAKERTYPE;
        SpeakerType.RegistryDataType = REG_DWORD;
        SpeakerType.Data = pdwSpeakerType;
        SpeakerType.DataSize = sizeof(pdwSpeakerType);

        hrSpeakerType = 
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundPersistentData, 
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA, 
                NULL, 
                0, 
                &SpeakerType, 
                sizeof(SpeakerType), 
                NULL
            );

        if(FAILED(hrSpeakerType))
        {
            *pdwSpeakerType = SPEAKERS_DEFAULT_TYPE;
        }
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT 
DSGetCplValues
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    OUT LPCPLDATA           pData
)
{
    HRESULT                 hr;

    // Get the basic HW acceleration level.
    pData->dwHWLevel = gAudData.dwDefaultHWLevel;
    hr = DSGetAcceleration
    (
        guid,
        fRecord,
        &pData->dwHWLevel
    );

    // Get the mixer SRC quality.
    pData->dwSRCLevel = DEFAULT_SRC_LEVEL;
    hr = DSGetSrcQuality
    (
        guid,
        fRecord,
        &pData->dwSRCLevel
    );

    // Get playback-specific settings
    if(!fRecord)
    {
        // Get the speaker config
        pData->dwSpeakerConfig = DSSPEAKER_STEREO;
        pData->dwSpeakerType = SPEAKERS_DEFAULT_TYPE;
        hr = DSGetSpeakerConfigType
        (
            guid,
            fRecord,
            &pData->dwSpeakerConfig,
            &pData->dwSpeakerType
        );
    }

    return DS_OK;
}


HRESULT
DSSetAcceleration
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    IN  DWORD               dwHWLevel
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr;

    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA   
        BasicAcceleration;
    
    // Find the necessary DirectSound functions
    hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );

    // Get properties for this device
    if(SUCCEEDED(hr))
    {
        BasicAcceleration.DeviceId = guid;
        BasicAcceleration.Level = (DIRECTSOUNDBASICACCELERATION_LEVEL)dwHWLevel;

        // Set the basic HW acceleration level
        hr = 
            pKsPropertySet->Set
            (
                DSPROPSETID_DirectSoundBasicAcceleration, 
                DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION, 
                NULL, 
                0, 
                &BasicAcceleration, 
                sizeof(BasicAcceleration)
            );
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT
DSSetSrcQuality
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    IN  DWORD               dwSRCLevel
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr;

    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA                 
        SrcQuality;
    
    // Find the necessary DirectSound functions
    hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );

    // Get properties for this device
    if(SUCCEEDED(hr))
    {
        SrcQuality.DeviceId = guid;

        // The CPL only uses the 3 highest of 4 possible SRC values
        SrcQuality.Quality = (DIRECTSOUNDMIXER_SRCQUALITY)(dwSRCLevel + 1);

        // Set the mixer SRC quality
        hr = 
            pKsPropertySet->Set
            (
                DSPROPSETID_DirectSoundMixer, 
                DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY, 
                NULL, 
                0, 
                &SrcQuality, 
                sizeof(SrcQuality)
            );
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT
DSSetSpeakerConfigType
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    IN  DWORD               dwSpeakerConfig,
    IN  DWORD               dwSpeakerType
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr                  = DS_OK;

    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA
        SpeakerType;

    // Can't set the speaker type if we're recording
    if(fRecord)
    {
        hr = E_INVALIDARG;
    }

    // Find the necessary DirectSound functions
    if(SUCCEEDED(hr))
    {
        hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );
    }

    // Set the speaker config
    if(SUCCEEDED(hr))
    {
        hr = 
            pDirectSound->SetSpeakerConfig
            (
                dwSpeakerConfig
            );
    }

    // Set the speaker type
    if(SUCCEEDED(hr))
    {
        SpeakerType.DeviceId = guid;
        SpeakerType.SubKeyName = REG_KEY_SPEAKERTYPE;
        SpeakerType.ValueName = REG_KEY_SPEAKERTYPE;
        SpeakerType.RegistryDataType = REG_DWORD;
        SpeakerType.Data = &dwSpeakerType;
        SpeakerType.DataSize = sizeof(dwSpeakerType);

        hr = 
            pKsPropertySet->Set
            (
                DSPROPSETID_DirectSoundPersistentData, 
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA, 
                NULL, 
                0, 
                &SpeakerType, 
                sizeof(SpeakerType)
            );
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT 
DSSetCplValues
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    IN  const LPCPLDATA     pData
)
{
    HRESULT                 hr;

    // Set the basic HW acceleration level
    hr =
        DSSetAcceleration
        (
            guid,
            fRecord,
            pData->dwHWLevel
        );

    // Set the mixer SRC quality
    if(SUCCEEDED(hr))
    {
        hr =
            DSSetSrcQuality
            (
                guid,
                fRecord,
                pData->dwSRCLevel // +1 is done in DSSetSrcQuality
            );
    }

    // Set the speaker config
    if(SUCCEEDED(hr) && !fRecord)
    {
        DSSetSpeakerConfigType
        (
            guid,
            fRecord,
            pData->dwSpeakerConfig,
            pData->dwSpeakerType
        );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\filecopy.h ===
#ifndef FILECOPY_H
#define FILECOPY_H

BOOL GetInstallPath(LPTSTR szDirOfSrc);
void wsStartWait();
void wsEndWait();
int fDialog(int id, HWND hwnd, DLGPROC fpfn);
UINT wsCopyError(int n, LPTSTR szFile);
UINT wsInsertDisk(LPTSTR Disk, LPTSTR szSrcPath);
INT_PTR wsDiskDlg(HWND hDlg, UINT uiMessage, UINT wParam, LPARAM lParam);
UINT wsCopySingleStatus(int msg, DWORD_PTR n, LPTSTR szFile);
INT_PTR wsExistDlg(HWND hDlg, UINT uiMessage, UINT wParam, LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\effects.cpp ===
/*
 ***************************************************************
 *
 *  This file contains the functions to display and submit changes 
 *     for sound effects
 *
 *  Copyright 2000, Microsoft Corporation
 *
 *  History:
 *
 *    03/2000 - tsharp (Created)
 *
 ***************************************************************
 */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <cpl.h>
#include <shellapi.h>
#include <ole2.h>
#include <mmddkp.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "mmcpl.h"
#include "draw.h"
#include "medhelp.h"
#include "gfxui.h"

#include <dsound.h>
#include <dsprv.h>
#include "advaudio.h"

/****************** Debug Off *********************/
//#define DEBUG
//#define _INC_MMDEBUG_CODE_ TRUE
//#include "mmdebug.h"
// End debug stuff

#define MAX_GFX_COUNT                  128    // maximum number of global effects (Gfx) processed 
#define MAX_LIST_DESC                  50     // maximum length of Gfx description in list view
#define FILLER_MSG                     257    // maximum number of Gfx applicable to the system

const static DWORD aKeyWordIds[] =
{
	IDC_EFFECT_STATIC, IDH_EFFECT_STATIC,
    IDC_TEXT_32,       NO_HELP,
	IDB_EFFECT_PROP,   IDH_EFFECT_PROP,
	0,0
};

/****************************************************************
 * Definitions
 ***************************************************************/

typedef HRESULT (WINAPI *GETCLASSOBJECTFUNC)( REFCLSID, REFIID, LPVOID * );


/***************************************************************
 * File Globals
 ***************************************************************/
PGFXUILIST gpFullList;
PGFXUILIST gpGfxInitList;
PGFXUI     gpGfxNodeArray[MAX_GFX_COUNT];

/***************************************************************
 * extern
 ***************************************************************/
extern "C" {
extern DWORD GetWaveOutID(BOOL *pfPreferred);
}

/***************************************************************
 * Prototypes
 ***************************************************************/

DWORD GetWaveOutID(void)
{
    return GetWaveOutID(NULL);
}

/***************************************************************
 * GetListIndex
 *
 * Description:
 *      Returns the selected index for the combobox.  Always add one
 *      for the first entry of "None"
 *
 * Parameters:
 *      HWND    DWORD    - GFX ID
 *
 * Returns:    
 *      int              - Index number of the selected item
 *
 ***************************************************************/

int GetListIndex(PGFXUI pGfx)
{
    int iIndex = 0;
    int iCnt = 0;

    if (pGfx)
    {
        while (gpGfxNodeArray[iCnt])
        {
            if (lstrcmpi(pGfx->pszName, gpGfxNodeArray[iCnt++]->pszName) == 0 ) 
            {
                iIndex = iCnt;
                break;
            }
        }
       
        
    }
	return (iIndex);
}


/***************************************************************
 * CheckEffect
 *
 * Description:
 *      Check to see if effect has properties, 
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *
 * Returns:    BOOL
 *      TRUE if all the events for the selected module were read from the reg
 *        database, else FALSE
 ***************************************************************/


BOOL PASCAL CheckEffect(HWND hDlg)
{
    PGFXUI   pGfxTemp = NULL;
    PGFXUI   pGfxBase = NULL;
    DWORD    dwIndex  = (DWORD)SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_GETCURSEL,0,0);

    if (0 == dwIndex) return FALSE;

    if (!gpGfxNodeArray[dwIndex-1]) return FALSE;
    else pGfxTemp = gpGfxNodeArray[dwIndex-1];

    if (!gpGfxInitList->puiList) return FALSE;
    else pGfxBase = gpGfxInitList->puiList;

    if (lstrcmpi(pGfxTemp->pszName, pGfxBase->pszName) == 0)
        return GFXUI_CanShowProperties(pGfxBase);
    else return FALSE;

}


/***************************************************************
 * SetEffects
 *
 * Description:
 *      Adds all the effects to the ListView, 
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *
 * Returns:    None
 ***************************************************************/


void SetEffects(HWND hDlg)
{
    PGFXUI   pGfxDelete;
    PGFXUI   pGfxTemp;
    PGFXUI   pGfxBase;
    DWORD    dwIndex  = (DWORD)SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_GETCURSEL,0,0);

    // Check to see Index is in range
    if ((0 != dwIndex)&&(gpGfxNodeArray[dwIndex-1]))
        pGfxBase = gpGfxNodeArray[dwIndex-1];
    else 
        pGfxBase = NULL;

    if (gpGfxInitList->puiList)
        pGfxTemp = gpGfxInitList->puiList;
    else
        pGfxTemp = NULL;
    
    // No GFX Selected or previously set
    if ((0 == dwIndex)&&(!pGfxTemp)) return;

    // GFX has not been changed
    if (pGfxTemp && pGfxBase)
        if (lstrcmpi(pGfxTemp->pszName, pGfxBase->pszName) == 0)
            return;

    // If there was a previous GFX it is assigned to pGfxTemp
    // to be deleted
    gpGfxInitList->puiList = NULL;

    if (pGfxBase)
        GFXUI_CreateAddGFX(&(gpGfxInitList->puiList), pGfxBase);
      
    GFXUI_Apply (&gpGfxInitList, &pGfxTemp);

    EnableWindow(GetDlgItem(hDlg, IDB_EFFECT_PROP), CheckEffect(hDlg));

    return;
}


/***************************************************************
 * LoadEffects
 *
 * Description:
 *      Adds all the effects to the ListView, 
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *
 * Returns:    
 *      None
 *
 ***************************************************************/

void LoadEffects(HWND hDlg)
{
    TCHAR   szBuffer[MAX_PATH];
    DWORD   dwDefDeviceId = 0;
	DWORD   dwType =0;
    DWORD   dwDeviceId = 0;
    DWORD   dwIndex = 0;
    UINT    uMixId;
    HRESULT hr;

    PGFXUILIST pRetList = NULL;
    PGFXUI     pTempGFX = NULL;

    dwDeviceId = gAudData.waveId;
    dwDefDeviceId = GetWaveOutID();

    if (dwDeviceId != dwDefDeviceId) ShowWindow (GetDlgItem(hDlg, IDB_EFFECT_PLAY), SW_HIDE);
	
    if (gAudData.fRecord)
            dwType = GFXTYPE_CAPTURE;
    else
            dwType = GFXTYPE_RENDER;

    if (mixerGetID(HMIXEROBJ_INDEX(dwDeviceId), &uMixId, gAudData.fRecord ? MIXER_OBJECTF_WAVEIN : MIXER_OBJECTF_WAVEOUT)) uMixId = (-1);

    hr = GFXUI_CreateList(uMixId, dwType, FALSE, &pRetList);

    if (SUCCEEDED (hr))
    {
        ASSERT(pRetList);
        gpGfxInitList = pRetList;
        pTempGFX = gpGfxInitList->puiList;
    }

    if(SUCCEEDED (hr) && pTempGFX)
    {
		dwIndex  = GetListIndex(pTempGFX);
        SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_SETCURSEL, dwIndex, 0);
    } else {        
        SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_SETCURSEL,0,0);
    }

    EnableWindow(GetDlgItem(hDlg, IDB_EFFECT_PROP), CheckEffect(hDlg));

}


/***************************************************************
 * LoadEffectList
 *
 * Description:
 *      Adds all the effects to the Combobox, 
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *
 * Returns:    
 *      None
 *
 ***************************************************************/

void LoadEffectList(HWND hDlg)
{
    int     nItemNum = 0;
    TCHAR   szBuffer[MAX_PATH];
    DWORD   dwType = 0;
    DWORD   dwWaveId = 0;
    UINT    uMixId;
    PGFXUI  pList = NULL;
    HRESULT hr;
	
    SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_RESETCONTENT,0,0);

    LoadString (ghInstance, IDS_NOGFXSET, szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
    SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) szBuffer);

    if (gAudData.fRecord)
        dwType = GFXTYPE_CAPTURE;
    else
        dwType = GFXTYPE_RENDER;

    dwWaveId = gAudData.waveId;

    if (mixerGetID(HMIXEROBJ_INDEX(dwWaveId), &uMixId, gAudData.fRecord ? MIXER_OBJECTF_WAVEIN : MIXER_OBJECTF_WAVEOUT)) uMixId = (-1);

    hr = GFXUI_CreateList(uMixId, dwType, TRUE, &gpFullList);

    if (SUCCEEDED (hr))
    {
        ASSERT(gpFullList);
        pList = gpFullList->puiList;
    }

    if(SUCCEEDED (hr) && pList)
    {
        do
        {
            SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) pList->pszName);
            gpGfxNodeArray[nItemNum] = pList;
            nItemNum++;

            pList = pList->pNext;

        }while(pList);
        gpGfxNodeArray[nItemNum] = NULL;

 	}
}

/****************************************************************
 *  ShowProperties
 *
 *  Description:
 *        Show properties button if applicable.
 *
 *  Parameters:
 *        HWND        hDlg            window handle of dialog window
 *
 *  Returns:     
 *        None
 *
 ****************************************************************/

void ShowProperties (HWND hDlg)
{
 
    PGFXUI   pGfxTemp = NULL;
    PGFXUI   pGfxBase = NULL;
    DWORD    dwIndex  = (DWORD)SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_GETCURSEL,0,0);

    if (0 == dwIndex) return;

    if (!gpGfxNodeArray[dwIndex-1]) return;
    else pGfxTemp = gpGfxNodeArray[dwIndex-1];

    if (!gpGfxInitList->puiList) return;
    else pGfxBase = gpGfxInitList->puiList;

    if (lstrcmpi(pGfxTemp->pszName, pGfxBase->pszName) == 0)
        GFXUI_Properties (pGfxBase, hDlg);;
    
    return;
}

/****************************************************************
 *  ChangeGFX
 *
 *  Description:
 *        Show properties button if applicable.
 *
 *  Parameters:
 *        HWND        hDlg            window handle of dialog window
 *
 *  Returns:     
 *        None
 *
 ****************************************************************/

void ChangeGFX (HWND hDlg)
{
    DWORD dwIndex = 0;
    HWND  hwndSheet = GetParent(hDlg);

    EnableWindow(GetDlgItem(hDlg, IDB_EFFECT_PROP), FALSE);

    dwIndex = (DWORD)SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_GETCURSEL,0,0);

	if (dwIndex != CB_ERR)
    {
        EnableWindow(GetDlgItem(hDlg, IDB_EFFECT_PROP), CheckEffect(hDlg));

        PropSheet_Changed(hwndSheet,hDlg);
    }
}

/*
 ***************************************************************
 *  EffectDlg
 *
 *  Description:
 *        EffectDlg for MM control panel applet.
 *
 *  Parameters:
 *   HWND        hDlg            window handle of dialog window
 *   UINT        uiMessage       message number
 *   WPARAM        wParam          message-dependent
 *   LPARAM        lParam          message-dependent
 *
 *  Returns:    BOOL
 *      TRUE if message has been processed, else FALSE
 *
 ***************************************************************
 */
INT_PTR CALLBACK SoundEffectsDlg(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
	NMHDR FAR * lpnm;

    switch (uMsg)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;

 				break;
            }
            break;

        case WM_INITDIALOG:
        {
            LoadEffectList(hDlg);
            if (gAudData.fRecord)
            {
                // Hide the "Play Default Sound" button for Recording devices
                ShowWindow (GetDlgItem(hDlg, IDB_EFFECT_PLAY), SW_HIDE);
            }
			LoadEffects(hDlg);
        }
        break;

        case WM_DESTROY:
        {
            GFXUI_FreeList(&gpGfxInitList);
            GFXUI_FreeList(&gpFullList);
            break;
        }

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU,
                                  (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;

        case WM_COMMAND:
    
		    switch (LOWORD(wParam))    
            {
		    case ID_APPLY:
                {   
			        SetEffects(hDlg);
                }
                break;

            case IDC_EFFECT_LIST:
				{
                    if (HIWORD(wParam) == CBN_SELCHANGE) ChangeGFX(hDlg);
				}
                break;

            case IDB_EFFECT_PROP:
                {
                    ShowProperties (hDlg);
                }
                break;

            case IDB_EFFECT_PLAY:
                {
                    PlaySound(TEXT(".Default"), NULL, SND_FILENAME | SND_ASYNC );
                }
                break;
            }
            break;

        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\gfxui.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  gfxui.h
//
//      This file defines the functions that are used by the Global
//      Effects (GFX) page to drive manipulate the effects for a 
//      mixer.
//
//  History:
//      10 June 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

//=============================================================================
//                            Include files
//=============================================================================
#include <mmsysp.h> // Middle Layer

// GFXUI element status flags
#define GFX_DEFAULT  0X00000000
#define GFX_CREATED  0X00000001 // Id, Order, & Type are valid
#define GFX_ADD      0X00000002

typedef struct _GFXUI GFXUI;
typedef GFXUI* PGFXUI;

typedef struct _GFXUI
{
	PWSTR  pszName;
	PWSTR  pszFactoryDi;
    DWORD  Id;
    DWORD  Type; 
    DWORD  Order;
    DWORD  nFlags;
    CLSID  clsidUI;
    PGFXUI pNext;
} **PPGFXUI;

typedef struct 
{
	DWORD  dwType;
    PWSTR  pszZoneDi;
    PGFXUI puiList;
} GFXUILIST, *PGFXUILIST, **PPGFXUILIST;


//
// API Prototypes
//

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

// Interface
HRESULT GFXUI_CreateList (DWORD dwMixID, DWORD dwType, BOOL fAll, PPGFXUILIST ppList);
BOOL    GFXUI_CheckDevice (DWORD dwMixID, DWORD dwType);
void    GFXUI_FreeList (PPGFXUILIST ppList);
HRESULT GFXUI_Properties (PGFXUI puiGFX, HWND hWndOwner);
HRESULT GFXUI_CreateAddGFX (PPGFXUI ppuiGFXAdd, PGFXUI puiGFXSource);
HRESULT GFXUI_Apply (PPGFXUILIST ppListApply, PPGFXUI ppuiListDelete);

#ifdef __cplusplus
} // extern "C"
#endif

// Helpers
BOOL GFXUI_CanShowProperties (PGFXUI puiGFX);


//
// Local Function Prototypes
//
HRESULT InitList (DWORD dwMixID, DWORD dwType, PPGFXUILIST ppList);
HRESULT AddNode (PCWSTR pszGfxFactoryDi, DWORD Id, REFCLSID rclsid, DWORD Type, DWORD Order, DWORD nFlags, PPGFXUILIST ppList);
HRESULT AddFactoryNode (PCWSTR pszGfxFactoryDi, PPGFXUILIST ppList);
void    FreeNode (PPGFXUI ppNode);
void    FreeListNodes (PPGFXUI ppuiList);
HRESULT AttachNode (PPGFXUILIST ppList, PGFXUI pNode);
HRESULT CreateNode (PCWSTR pszName, PCWSTR pszGfxFactoryDi, PPGFXUI ppNode);
HRESULT GetFriendlyName (PCWSTR pszGfxFactoryDi, PWSTR* ppszName);
HKEY    OpenGfxRegKey (PCWSTR pszGfxFactoryDi, REGSAM sam);
UINT    GetListSize (PGFXUI puiList);
PTCHAR  GetInterfaceName (DWORD dwMixerID);
// Callback
LONG    GFXEnum (PVOID Context, DWORD Id, PCWSTR GfxFactoryDi, REFCLSID rclsid, DWORD Type, DWORD Order);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\helpid.h ===
#include "medhelp.h"

#define IDH_MIDI_DEVICE 	2410
#define IDH_MIDI_ENABLED	2411
#define IDH_MIDI_PORT		2412
#define IDH_CONFIGMIDI_POWER	2415
#define IDH_CONFIGMIDI_CHANNELS 2416
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\gfxui.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  gfxui.c
//
//      This file defines the functions that are used by the Global
//      Effects (GFX) page to drive manipulate the effects for a 
//      mixer.
//
//  History:
//      10 June 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

//=============================================================================
//                            Include files
//=============================================================================
#include <windows.h>
#include <windowsx.h>
#include "mmcpl.h"
#include <mmddkp.h>
#include <olectl.h>
#include <ocidl.h>
#include "gfxui.h"

#define ADDGFX
#define REGSTR_VAL_FRIENDLYNAME TEXT("FriendlyName")


//
// IDataObject Implementation
//
class GFXDataObject : public IDataObject
{
public:
    GFXDataObject (DWORD dwGfxID) { m_cRef = 1; m_dwGfxID = dwGfxID; }

    // IUnknown interface
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef ()  { return ++m_cRef; }
    STDMETHODIMP_(ULONG) Release () { return --m_cRef; }

	STDMETHODIMP GetData (FORMATETC * pformatetcIn, STGMEDIUM * pmedium);
    STDMETHODIMP GetDataHere (FORMATETC * pformatetc, STGMEDIUM *pmedium) { return E_NOTIMPL; }
	STDMETHODIMP QueryGetData (FORMATETC * pformatetc) { return E_NOTIMPL; }
	STDMETHODIMP GetCanonicalFormatEtc (FORMATETC * pformatetcIn, FORMATETC * pFormatetcOut) { return E_NOTIMPL; }
	STDMETHODIMP SetData (FORMATETC * pformatetc, STGMEDIUM * pmedium, BOOL fRelease) { return E_NOTIMPL; }
	STDMETHODIMP EnumFormatEtc (DWORD dwDirection, IEnumFORMATETC ** ppenumFormatEtc ) { return E_NOTIMPL; }
	STDMETHODIMP DAdvise (FORMATETC * pformatetc, DWORD advf, IAdviseSink* pAdvSnk, DWORD * pdwConnection) { return E_NOTIMPL; }
	STDMETHODIMP DUnadvise (DWORD dwConnection) { return E_NOTIMPL; }
	STDMETHODIMP EnumDAdvise (IEnumSTATDATA ** ppenumAdvise) { return E_NOTIMPL; }

private:
	UINT  m_cRef;
    DWORD m_dwGfxID;

};

STDMETHODIMP GFXDataObject::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    
    if (!ppvObj)
        return E_POINTER;

	*ppvObj = NULL;
	if (IsEqualIID(riid,IID_IDataObject) ||
		IsEqualIID(riid,IID_IUnknown))
		*ppvObj = (IDataObject *) this;
	else
	    return E_NOINTERFACE;

	((IUnknown *) *ppvObj) -> AddRef ();

	return S_OK;

}

STDMETHODIMP GFXDataObject::GetData (LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)							// @parm Storage to be created.
{

    HRESULT hr = E_INVALIDARG;

    if (pformatetc && pmedium && TYMED_HGLOBAL == pformatetc -> tymed)
    {
        HANDLE hGfx = NULL;

#ifdef ADDGFX
        hr = gfxOpenGfx (m_dwGfxID, &hGfx);
#endif // ADDGFX

        if (SUCCEEDED (hr))
        {
            pmedium -> tymed = TYMED_HGLOBAL;
	        pmedium -> pUnkForRelease = NULL;	
	        pmedium -> hGlobal = hGfx;
        }
    }

    return hr;

}



HRESULT InitList (DWORD dwMixID, DWORD dwType, PPGFXUILIST ppList)
{

    HRESULT hr = E_INVALIDARG;

    if (ppList)
    {
        PGFXUILIST pList = (PGFXUILIST) LocalAlloc (LPTR, sizeof (GFXUILIST));
        *ppList = NULL; // Init pointer

        if (pList)
        {
            hr = S_OK;
	        pList -> dwType    = dwType;
            pList -> puiList   = NULL;
#ifdef UNICODE
            pList -> pszZoneDi = (PWSTR) GetInterfaceName (dwMixID);
#else
            pList -> pszZoneDi = NULL; // This should not happen
#endif
            if (pList -> pszZoneDi)
            {
                // Return new list
                *ppList = pList;
            }
            else
            {
                // Error!
                LocalFree (pList);
                hr = E_OUTOFMEMORY;
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;

}


void GFXUI_FreeList (PPGFXUILIST ppList)
{
    
    if (ppList)
    {
        PGFXUILIST pList = *ppList;

        if (pList)
        {
            // Free Zone
            if (pList -> pszZoneDi)
                GlobalFreePtr (pList -> pszZoneDi);
            pList -> pszZoneDi = NULL;

            // Free GFX List
            FreeListNodes (&(pList -> puiList));

            // Free list
            LocalFree (pList);
            *ppList = NULL;
        }
    }
}


void FreeListNodes (PPGFXUI ppuiList)
{

    if (ppuiList)
    {
        PGFXUI pNodeDelete;
        PGFXUI puiList = *ppuiList;

        // Free list nodes
        while (puiList)
        {
            pNodeDelete = puiList;
            puiList = puiList -> pNext;
            FreeNode (&pNodeDelete);
        }

        *ppuiList = NULL;
    }
}


void FreeNode (PPGFXUI ppNode)
{

    if (ppNode && *ppNode)
    {
        PGFXUI pNode = *ppNode;

        // Free the strings
        if (pNode -> pszName)
            LocalFree (pNode -> pszName);
        if (pNode -> pszFactoryDi)
            LocalFree (pNode -> pszFactoryDi);

        // Free the node
        LocalFree (pNode);
        *ppNode = NULL;
    }
}


HKEY OpenGfxRegKey (PCWSTR pszGfxFactoryDi, REGSAM sam)
{

    HKEY hkeyGfx = NULL;

    if (pszGfxFactoryDi)
    {
        HDEVINFO DeviceInfoSet = SetupDiCreateDeviceInfoList (NULL, NULL); 
        
        if (INVALID_HANDLE_VALUE != DeviceInfoSet)
        {
            SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
            DeviceInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

            if (SetupDiOpenDeviceInterface (DeviceInfoSet, pszGfxFactoryDi, 
                                            0, &DeviceInterfaceData))
            {
                 hkeyGfx = SetupDiOpenDeviceInterfaceRegKey (
                                DeviceInfoSet, &DeviceInterfaceData,
                                0, sam);
            }
            SetupDiDestroyDeviceInfoList (DeviceInfoSet);
        }
    }

    return hkeyGfx;

}


HRESULT GetFriendlyName (PCWSTR pszGfxFactoryDi, PWSTR* ppszName)
{

    HRESULT hr = E_INVALIDARG;
    HKEY hkeyGfx = NULL;

    // Check parameters
    if (ppszName && pszGfxFactoryDi)
    {
        HKEY hkeyGfx = OpenGfxRegKey (pszGfxFactoryDi, KEY_READ);
        *ppszName = NULL;

        if (hkeyGfx)
        {
            WCHAR szBuffer[MAX_PATH];
            DWORD dwType = REG_SZ;
            DWORD cb     = sizeof (szBuffer) / sizeof (szBuffer[0]);

            hr = S_OK;

            if (ERROR_SUCCESS == RegQueryValueEx (hkeyGfx, REGSTR_VAL_FRIENDLYNAME, NULL, &dwType, (LPBYTE)szBuffer, &cb))
            {
                *ppszName = (PWSTR) LocalAlloc (LPTR, lstrlen (szBuffer)*2+2);
                if (*ppszName)
                    wcscpy (*ppszName, szBuffer);
                else
                    hr = E_OUTOFMEMORY;
            }
            else
                hr = REGDB_E_READREGDB;

            RegCloseKey (hkeyGfx);
        }
    }

    return hr;

}


HRESULT AddFactoryNode (PCWSTR pszGfxFactoryDi, PPGFXUILIST ppList)
{
    return AddNode (pszGfxFactoryDi, 0, GUID_NULL, 0, 0, 0, ppList);
}


HRESULT AddNode (PCWSTR pszGfxFactoryDi, DWORD Id, REFCLSID rclsid, DWORD Type, 
                 DWORD Order, DWORD nFlags, PPGFXUILIST ppList)
{

    PGFXUI pNode = NULL;
    HRESULT hr = S_OK;

    // Check parameters
    if (!ppList || !(*ppList) || !pszGfxFactoryDi)
        return E_INVALIDARG;

    // Create node
    if (SUCCEEDED (hr = CreateNode (NULL, pszGfxFactoryDi, &pNode)))
    {
        if (pNode)
        {
            // Initilize the rest of the values
            pNode -> Id      = Id; 
            pNode -> Type    = Type;
            pNode -> Order   = Order;
            pNode -> nFlags  = nFlags;
            pNode -> clsidUI = rclsid;

            if (FAILED (hr = AttachNode (ppList, pNode)))
                FreeNode (&pNode);
        }
        else
            hr = E_UNEXPECTED;

    }

    return hr;

}


// Note: This function always adds the node to the list IN ORDER
//       IFF (pNode -> nFlags & GFX_CREATED).
HRESULT AttachNode (PPGFXUILIST ppList, PGFXUI pNode)
{

    HRESULT hr = E_INVALIDARG;

    // Check parameters
    if (ppList && (*ppList) && pNode)
    {
        PGFXUI puiList = (*ppList) -> puiList;
        hr = S_OK;

        // Make sure our next pointer starts out null..
        pNode -> pNext = NULL;

        if (puiList)
        {
            if (!(pNode -> nFlags & GFX_CREATED) ||
                (puiList -> Order >= pNode -> Order))
            {
                // Order is not available, just stick it on the front or
                // the order happens to put the node at the front.
                pNode -> pNext = puiList;
                puiList = pNode;
            }
            else
            {
                PGFXUI pSearch = puiList;
            
                if (!(puiList -> pNext))
                {
                    // One element list. We know the new node doesn't belong
                    // at the head of the list, so it is behind.
                    puiList -> pNext = pNode;
                } else {

                    while (pSearch -> pNext)
                    {
                        if (!(pSearch -> pNext -> nFlags & GFX_CREATED))
                        {
                            hr = E_INVALIDARG;
                            break; // Cannot mix list types
                        }
    
                        if (pSearch -> pNext -> Order >= pNode -> Order)
                        {
                            // We found the insertion point!
                            pNode -> pNext = pSearch -> pNext;
                            pSearch -> pNext = pNode;
                            break;
                        }
    
                        if (!(pSearch -> pNext -> pNext))
                        {
                            // At end of list, attach node to end
                            pSearch -> pNext -> pNext = pNode;
                            break;
                        }
    
                        // Move to next element
                        pSearch = pSearch -> pNext;
                    }
                    
                }
            }
        }
        else
        {
            // First element of the list
            puiList = pNode;
        }

        if (SUCCEEDED (hr))
        {
            // Ensure we pass back the correct list pointer
            (*ppList) -> puiList = puiList;
        }
    }

    return hr;

}


LONG GFXEnum (PVOID Context, DWORD Id, PCWSTR GfxFactoryDi, REFCLSID rclsid, DWORD Type, DWORD Order)
{

    PGFXUILIST pList = (PGFXUILIST) Context;
    HRESULT hr = E_INVALIDARG;

    if (pList)
    {
        if (Type == pList->dwType)
        {
            if (FAILED (hr = AddNode (GfxFactoryDi, Id, rclsid, Type, Order, GFX_CREATED, &pList)))
            {
                // Error, free the list
                GFXUI_FreeList (&pList);
                Context = NULL;
            }
        }
        else hr = NOERROR;
    }

    return hr;

}


BOOL GFXUI_CheckDevice (DWORD dwMixID, DWORD dwType)
{

    HRESULT     hr = S_OK;
    BOOL        fRet = FALSE;
    PGFXUILIST  pList = NULL;
    
    if (SUCCEEDED (hr = InitList (dwMixID, dwType, &pList)))
    {
        if (pList && pList -> pszZoneDi)
        {
            PDEVICEINTERFACELIST pdiList = NULL;                    
            LONG                 lResult = NO_ERROR;
                
            lResult = gfxCreateGfxFactoriesList (pList -> pszZoneDi, &pdiList);

            if ((lResult == NO_ERROR) && pdiList)
            {
                fRet = TRUE;
                gfxDestroyDeviceInterfaceList (pdiList);
            }
            
            GFXUI_FreeList (&pList);
        }

    }
    return fRet;
}


HRESULT GFXUI_CreateList (DWORD dwMixID, DWORD dwType, BOOL fAll, PPGFXUILIST ppList)
{

    HRESULT hr = E_INVALIDARG;
    
    if (ppList)
    {
        hr = S_OK;

        if (SUCCEEDED (hr = InitList (dwMixID, dwType, ppList)))
        {
            if (*ppList && (*ppList) -> pszZoneDi)
            {
                if (!fAll)
                {
                    hr = gfxEnumerateGfxs ((*ppList) -> pszZoneDi, GFXEnum, (*ppList));
                }
                else
                {
                    PDEVICEINTERFACELIST pdiList = NULL;                    

                    hr = gfxCreateGfxFactoriesList ((*ppList) -> pszZoneDi, &pdiList);

                    if (SUCCEEDED (hr) && pdiList)
                    {
                        LONG lIndex;
                    
                        for (lIndex = 0; lIndex < pdiList -> Count; lIndex++)
                        {
                            hr = AddFactoryNode ((pdiList -> DeviceInterface)[lIndex], ppList);
                            if (FAILED (hr))
                            {
                                GFXUI_FreeList (ppList);
                                break;
                            }
                        }

                        gfxDestroyDeviceInterfaceList (pdiList);
                    }
                    else
                    {
                        GFXUI_FreeList (ppList);
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            else
                hr = E_UNEXPECTED;
        }

    }

    return hr;

}


HRESULT GFXUI_Properties (PGFXUI puiGFX, HWND hWndOwner)
{

    HRESULT hr = E_INVALIDARG;

    if (puiGFX && GFXUI_CanShowProperties (puiGFX) && IsWindow (hWndOwner))
    {
        ISpecifyPropertyPages* pISpecifyPropertyPages = NULL;

        // Get the Vendor UI Property Pages Interface
        hr = CoCreateInstance (puiGFX -> clsidUI, NULL, CLSCTX_INPROC_SERVER, IID_ISpecifyPropertyPages, (void**)&pISpecifyPropertyPages);
        if (SUCCEEDED (hr) && !pISpecifyPropertyPages)
            hr = E_UNEXPECTED;

        if (SUCCEEDED (hr))
        {
            CAUUID Pages;
            ZeroMemory (&Pages, sizeof (Pages));

            // Get the VendorUI Property Page CLSID's
            hr = pISpecifyPropertyPages -> GetPages (&Pages);
            if (SUCCEEDED (hr) && (Pages.cElems == 0 || !Pages.pElems))
                hr = E_UNEXPECTED;

            if (SUCCEEDED (hr))
            {
                RECT rcWindow;

                if (GetWindowRect (hWndOwner, &rcWindow))
                {
                    TCHAR szCaption[MAX_PATH];
                    GFXDataObject DataObject (puiGFX -> Id);
                    IUnknown* punkDataObject = &DataObject;

                    // Load the VendorUI caption
                    LoadString (ghInstance, IDS_EFFECTS_PROPERTY_CAPTION, szCaption, sizeof (szCaption)/sizeof(TCHAR));

                    // Bring up the Vendor UI
                    hr = OleCreatePropertyFrame (hWndOwner, rcWindow.left + 10, rcWindow.top + 10,
                                                 szCaption, 1, &punkDataObject, Pages.cElems, 
                                                 Pages.pElems, GetSystemDefaultLangID (), 
                                                 0, NULL);

                }
                else
                    hr = E_FAIL;

                CoTaskMemFree (Pages.pElems);
            }

            pISpecifyPropertyPages -> Release ();
        }
    }

    return hr;

}


UINT GetListSize (PGFXUI puiList)
{

    UINT uiSize = 0;
    PGFXUI puiListSeek = puiList;

    while (puiListSeek)
    {
        puiListSeek = puiListSeek -> pNext;
        uiSize++;
    }

    return uiSize;

}


HRESULT GFXUI_Apply (PPGFXUILIST ppListApply, PPGFXUI ppuiListDelete)
{

    HRESULT hr = E_INVALIDARG;
    PGFXUILIST pListApply  = (ppListApply  ? *ppListApply    : NULL);
    PGFXUI puiListDelete = (ppuiListDelete ? *ppuiListDelete : NULL);

    if ((pListApply && pListApply -> puiList) || puiListDelete)
    {

        PGFXREMOVEREQUEST paGfxRemoveRequests = NULL;
        PGFXMODIFYREQUEST paGfxModifyRequests = NULL;
        PGFXADDREQUEST    paGfxAddRequests    = NULL;
        ULONG cGfxRemoveRequests = 0;
	    ULONG cGfxModifyRequests = 0;
	    ULONG cGfxAddRequests    = 0;
        ULONG cApplyList = GetListSize (pListApply ? pListApply -> puiList : NULL);
        ULONG cDeleteList = GetListSize (puiListDelete);
        PGFXUI puiListSeek = NULL;

        hr = S_OK;

        // This function needs to create:
        //      - Deleted Array of GFXREMOVEREQUEST's
        //      - Modify Array of GFXMODIFYREQUEST's
        //      - Add Array of GFXADDREQUEST's
        // 
        // The deleted array is fairly easy, just pull out the 
        // marked ones. With the remaining, we need to loop through
        // them comparing order and create modify records as needed
        // to modify their order (except for the add records where
        // we must save the nessary order in the add request array).
        // Then we create the add array (perhaps with the modify array)
        // and fill in everything else (other than order).
        //
        // Then call GFX_BatchChange().
        //
        // Afterword, we need to update our list accordingly (i.e. delete 
        // nodes, update order, etc).

        // Create our parameters
        // Note: These buffers are really upper bounds on the memory we will need.
        //       We will count the actual requests we make and pass that value to
        //       the GFX function call.
        if (0 < cDeleteList)
        {
            paGfxRemoveRequests = (PGFXREMOVEREQUEST) LocalAlloc (LPTR, sizeof (*paGfxRemoveRequests) * cDeleteList);
            if (!paGfxRemoveRequests)
                hr = E_OUTOFMEMORY;
        }
        if (0 < cApplyList)
        {
            paGfxModifyRequests = (PGFXMODIFYREQUEST) LocalAlloc (LPTR, sizeof (*paGfxModifyRequests) * cApplyList);
            paGfxAddRequests    = (PGFXADDREQUEST) LocalAlloc (LPTR, sizeof (*paGfxAddRequests) * cApplyList);
            if (!paGfxModifyRequests || !paGfxAddRequests)
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED (hr))
        {
            UINT uiIndx;
            DWORD dwOrder = 0;

            // Create the remove parameter
            puiListSeek = puiListDelete;
            for (uiIndx = 0; uiIndx < cDeleteList; uiIndx++)
            {
                // Make sure this is created before we ask to delete it.
                // (It may be an AddNode that was deleted before creation).
                if (puiListSeek -> nFlags & GFX_CREATED)
                {
                    (paGfxRemoveRequests + cGfxRemoveRequests) -> IdToRemove = puiListSeek -> Id;
                    (paGfxRemoveRequests + cGfxRemoveRequests) -> Error = S_OK;
                    cGfxRemoveRequests++;
                }
                puiListSeek = puiListSeek -> pNext;
            }

            // Create the modify and add parameters
            puiListSeek = pListApply ? pListApply -> puiList : NULL;
            for (uiIndx = 0; uiIndx < cApplyList; uiIndx++)
            {
                if (puiListSeek -> nFlags & GFX_ADD)
                {
                    (paGfxAddRequests + cGfxAddRequests) -> ZoneFactoryDi = pListApply  -> pszZoneDi;
                    (paGfxAddRequests + cGfxAddRequests) -> GfxFactoryDi  = puiListSeek -> pszFactoryDi;
                    (paGfxAddRequests + cGfxAddRequests) -> Type          = pListApply  -> dwType;
                    (paGfxAddRequests + cGfxAddRequests) -> Order         = dwOrder++;
                    (paGfxAddRequests + cGfxAddRequests) -> NewId         = 0;
                    (paGfxAddRequests + cGfxAddRequests) -> Error         = S_OK;
                    cGfxAddRequests++;
                }
                else
                {
                    if (puiListSeek -> nFlags & GFX_CREATED)
                    {
                        // We only need to add modify records for GFX'es
                        // that are no longer in order.
                        if (puiListSeek -> Order < dwOrder)
                        {
                            (paGfxModifyRequests + cGfxModifyRequests) -> IdToModify = puiListSeek -> Id;
                            (paGfxModifyRequests + cGfxModifyRequests) -> NewOrder   = dwOrder++;
                            (paGfxModifyRequests + cGfxModifyRequests) -> Error      = S_OK;
                            cGfxModifyRequests++;
                        }
                        else
                            dwOrder = (puiListSeek -> Order + 1);
                    }
                    else
                    {
                        // Bogus list entry, abort everything!
                        hr = E_INVALIDARG;
                        break;
                    }
                }
                puiListSeek = puiListSeek -> pNext;
            }

            if (SUCCEEDED (hr))
            {
#ifdef ADDGFX
                hr = gfxBatchChange (paGfxRemoveRequests, cGfxRemoveRequests,
                                     paGfxModifyRequests, cGfxModifyRequests,
                                     paGfxAddRequests, cGfxAddRequests);
#endif // ADDGFX
                if (SUCCEEDED (hr))
                {
                    PGFXMODIFYREQUEST paGfxModifySeek = paGfxModifyRequests;
                    PGFXADDREQUEST    paGfxAddSeek    = paGfxAddRequests;

                    // Update the passed arrays
                    FreeListNodes (ppuiListDelete);

                    puiListSeek = pListApply ? pListApply -> puiList : NULL;
                    for (uiIndx = 0; uiIndx < cApplyList; uiIndx++)
                    {
                        // Update the list items.
                        if (puiListSeek -> nFlags & GFX_ADD)
                        {
                            // Update the newly create GFX
                            puiListSeek -> nFlags = GFX_CREATED;
                            puiListSeek -> Id     = paGfxAddSeek -> NewId;
                            puiListSeek -> Type   = paGfxAddSeek -> Type;
                            puiListSeek -> Order  = paGfxAddSeek -> Order;
                            paGfxAddSeek++;
                        }
                        else // must be (puiListSeek -> nFlags & GFX_CREATED)
                        {
                            // Update the order
                            puiListSeek -> Order = paGfxModifySeek -> NewOrder;
                            paGfxModifySeek++;
                        }
                    }
                }
            }
        }

        // Free parameters
        if (paGfxRemoveRequests)
            LocalFree (paGfxRemoveRequests);
        if (paGfxModifyRequests)
            LocalFree (paGfxModifyRequests);
        if (paGfxAddRequests)
            LocalFree (paGfxAddRequests);

    }

    return hr;

}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
PTCHAR GetInterfaceName (DWORD dwMixerID)
{
	MMRESULT mmr;
	ULONG cbSize=0;
	TCHAR *szInterfaceName=NULL;

	//Query for the Device interface name
	mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
	if(MMSYSERR_NOERROR == mmr)
	{
		szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
		if(!szInterfaceName)
		{
			return NULL;
		}

		mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
		if(MMSYSERR_NOERROR != mmr)
		{
			GlobalFreePtr(szInterfaceName);
			return NULL;
		}
	}

    return szInterfaceName;
}


BOOL GFXUI_CanShowProperties (PGFXUI puiGFX)
{
    return (puiGFX && (puiGFX -> nFlags & GFX_CREATED) && (puiGFX -> clsidUI != GUID_NULL));
}


HRESULT CreateNode (PCWSTR pszName, PCWSTR pszGfxFactoryDi, PPGFXUI ppNode)
{

    HRESULT hr = E_INVALIDARG;
    
    if (ppNode)
    {
        // Create node
        PGFXUI pNode = (PGFXUI) LocalAlloc (LPTR, sizeof (GFXUI));
        hr = S_OK;

        if (pNode)
        {
            ZeroMemory (pNode, sizeof (GFXUI));

            // Create the strings
            if (pszName)
            {
                pNode -> pszName = (PWSTR) LocalAlloc (LPTR, lstrlen (pszName)*2+2);
                if (pNode -> pszName)
                    wcscpy (pNode -> pszName, pszName);
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                // If there is no name, get it from the factory
                pNode -> pszName = NULL;
                if (pszGfxFactoryDi)
                    hr = GetFriendlyName (pszGfxFactoryDi, &(pNode -> pszName));
            }

            if (SUCCEEDED (hr) && pszGfxFactoryDi)
            {
                pNode -> pszFactoryDi = (PWSTR) LocalAlloc (LPTR, lstrlen (pszGfxFactoryDi)*2+2);
                if (pNode -> pszFactoryDi)
                    wcscpy (pNode -> pszFactoryDi, pszGfxFactoryDi);
                else
                    hr = E_OUTOFMEMORY;
            }

            if (SUCCEEDED (hr))
                // Return node
                *ppNode = pNode;
            else
                // Free node
                FreeNode (&pNode);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


// This function creates an "addable" GFXUI element that will be able
// to create a new GFX when you call GFXUI_Apply() with this new element
// in the list.
HRESULT GFXUI_CreateAddGFX (PPGFXUI ppuiGFXAdd, PGFXUI puiGFXSource)
{

    HRESULT hr = E_INVALIDARG;

    if (ppuiGFXAdd && puiGFXSource)
    {
        *ppuiGFXAdd = NULL;

        hr = CreateNode (puiGFXSource -> pszName, 
                         puiGFXSource -> pszFactoryDi, ppuiGFXAdd);

        if (SUCCEEDED (hr))
        {
            if (*ppuiGFXAdd)
            {
                // Indicate that this is a new 'Add' node.
                (*ppuiGFXAdd) -> nFlags = GFX_ADD;
            }
            else
                hr = E_UNEXPECTED;
        }
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\filecopy.c ===
/**************************************************************************
 *
 *  FILECOPY.C
 *
 *  Copyright (C) Microsoft, 1990, All Rights Reserved.
 *
 *  Control Panel Applet for installing installable driver.
 *
 *  This file contains hooks to SULIB, COMPRESS libraries, and the dialogs
 *  from the display applet to prompt for insert disk, error action...
 *
 *  Note SULIB.LIB, COMPRESS.LIB, SULIB.H come from the display applet
 *  and are updated here if/when updated there.
 *
 *  History:
 *
 *      Sat Oct 27 1990 -by- MichaelE
 *          Munged from display applet's DLG.C.
 *
 **************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include "drivers.h"
#include "sulib.h"
#include <cphelp.h>

// Hidden parameter between wsSingleCopyStatus and wExistDlg

static TCHAR     szErrMsg[MAXSTR];

// Hidden parameters passed from wsInsertDisk to wDiskDlg

static TCHAR     CurrentDisk[MAX_PATH];
static LPTSTR    szEdit;

// Function prototypes

BOOL wsInfParseInit    (void);
int  fDialog           (int, HWND, DLGPROC);
UINT wsCopyError       (int, LPTSTR);
UINT wsInsertDisk      (LPTSTR, LPTSTR);
INT_PTR wsDiskDlg         (HWND, UINT, WPARAM, LPARAM);
INT_PTR wsExistDlg        (HWND, UINT, WPARAM, LPARAM);

/*
 *  Load the description from the inf file or the driver file.
 *
 *  The type of file is also returned in the driver structure.
 *
 *  Parameters :
 *       pIDriver - Pointer to driver data - in particular the driver file name
 *       pstrKey  - The ini file key under which the driver should be found
 *       pstrDesc - Where to return the description
 *       cchDesc  - Size of destination buffer (pstrDesc) in characters.
 *                  Length must be large enough to hold all of the
 *                  description including the null terminator.
 */

 int LoadDescFromFile(PIDRIVER pIDriver, LPTSTR pstrKey, LPTSTR pstrDesc, size_t cchDesc)
{
     PINF        pinf;
     TCHAR        szFileName[MAX_INF_LINE_LEN];
     LPTSTR        pstrFile = pIDriver->szFile;
     TCHAR        ExpandedName[MAX_PATH];
     LPTSTR        FilePart;
	 LONG		  lResult;

    /*
     *  See if the file can be found
     */


     if (SearchPath(NULL, pstrFile, NULL, MAX_PATH, ExpandedName, &FilePart)
         == 0) {
         return(DESC_NOFILE);
     }

    /*
     * -jyg- Let's look in the mmdriver.inf first!
     */

     for (pinf = FindInstallableDriversSection(NULL);
          pinf;
          pinf = infNextLine(pinf))
     {
         lResult = infParseField(pinf, 1, szFileName, SIZEOF(szFileName)); // compare filename
		 if( INF_PARSE_FAILED(lResult) )
		 {
			 return DESC_ERROR;
		 }

        /*
         *  FileName strips of drive and path
         */

         if (lstrcmpi(FileName(pstrFile), FileName(szFileName)) == 0)
         {
             lResult = infParseField(pinf, 3, pstrDesc, cchDesc); // get Description Field
			 if( INF_PARSE_FAILED(lResult) )
			 {
				 return DESC_ERROR;
			 }

             return DESC_INF;
         }
     }

    /*
     *  If that failed try to get the description from the file
     */

     if (!GetFileTitle(ExpandedName, pstrDesc, MAXSTR)) {
         return DESC_EXE;
     } else {
         return DESC_NOFILE;
     }
 }

/*
 *  Find the install path from the registry if there is one there
 */

 BOOL GetInstallPath(LPTSTR szDirOfSrc)
 {
     HKEY RegHandle;
     DWORD Type;
     DWORD Length = MAX_PATH - 1;
     BOOL Found = FALSE;

     if (MMSYSERR_NOERROR ==
         RegOpenKey(HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                    &RegHandle)) {

         if (MMSYSERR_NOERROR ==
             RegQueryValueEx(RegHandle,
                             TEXT("SourcePath"),
                             NULL,
                             &Type,
                             (LPBYTE)szDirOfSrc,
                             &Length) &&
             Type == REG_SZ) {

             Found = TRUE;
         }

         RegCloseKey(RegHandle);

     }

     return Found;
 }

/*
 *  Initialize the SULIB library stuff which loads the mmdriver.inf file
 *  into RAM and parses it all over the place.
 */

 BOOL wsInfParseInit(void)
 {
     TCHAR       szPathName[MAX_PATH];
     TCHAR*      pszFilePart;
     PINF        pinf;
     TCHAR       szNoInf[MAXSTR];
     TCHAR       iDrive;
     static BOOL bChkCDROM = FALSE;
     HANDLE      hFile;

	 szPathName[0] = '\0';

    /*
     *  put up an hour glass here
     */

     wsStartWait();

     hFile = CreateFile(szSetupInf, GENERIC_READ, FILE_SHARE_READ,NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

     if (hFile == INVALID_HANDLE_VALUE)
     {
         wsEndWait();
         LoadString(myInstance, IDS_NOINF, szNoInf, sizeof(szNoInf)/sizeof(TCHAR));
         MessageBox(hMesgBoxParent, szNoInf, szDrivers, MB_OK | MB_ICONEXCLAMATION);
         return FALSE;
     }

     CloseHandle(hFile);

     GetFullPathName(szSetupInf,sizeof(szPathName)/sizeof(TCHAR),szPathName,&pszFilePart);

     pinf = infOpen(szPathName);

     wsEndWait();

     if (GetWindowsDirectory(szSetupPath, sizeof(szSetupPath)/sizeof(TCHAR)))
		 szSetupPath[0] = '\0';

     if (bChkCDROM == FALSE) {

         /*
          *  Use the setup path from the registry if there is one
          */

          if (!GetInstallPath(szDirOfSrc))
          {
             /*
              *  use the CD ROM drive as the default drive (if there is one)
              */

              for ( iDrive=TEXT('A'); iDrive <= TEXT('Z'); iDrive++ ) {
                  szDirOfSrc[0] = iDrive;

                  if ( GetDriveType(szDirOfSrc) == DRIVE_CDROM)
                  {
                          break;
                  }
                 /*
                  *  If we didn't find a CD ROM default to the A drive
                  */

                  if (iDrive == TEXT('Z')) {
                      szDirOfSrc[0] = TEXT('A');
                  }
              }
          }

          bChkCDROM = TRUE;
     }

     lstrcpy(szDiskPath, szDirOfSrc);

     return TRUE;
 }


/*----------------------------------------------------------------------------*\
|   wsStartWait()                                                              |
|                                                                              |
|   Turn the WinSetup cursor to a hour glass                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/
void wsStartWait()
{
    SetCursor(LoadCursor(NULL,IDC_WAIT));
}

/*----------------------------------------------------------------------------*\
|   wsEndWait()                                                                |
|                                                                              |
|   Turn the WinSetup cursor back to what it was                               |
|                                                                              |
\*----------------------------------------------------------------------------*/
void wsEndWait()
{
    SetCursor(LoadCursor(NULL,IDC_ARROW));
}


/*----------------------------------------------------------------------------*\
|   fDialog(id,hwnd,fpfn)                                                      |
|                                                                              |
|   Description:                                                               |
|       This function displays a dialog box and returns the exit code.         |
|                                                                              |
|   Arguments:                                                                 |
|       id              resource id of dialog to display                       |
|       hwnd            parent window of dialog                                |
|       fpfn            dialog message function                                |
|                                                                              |
|   Returns:                                                                   |
|       exit code of dialog (what was passed to EndDialog)                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
int fDialog(int id, HWND hwnd, DLGPROC fpfn)
{
    return ( (int)DialogBox(myInstance, MAKEINTRESOURCE(id), hwnd, fpfn) );
}


/****************************************************************************
 *                                                                             |
 *wsCopyError()                                                                |
 *                                                                             |
 *  Handles errors, as the result of copying files.                            |
 *                                                                             |
 *  This may include net contention errors, in which case the user must        |
 *  retry the operation.                                                       |
 *                                                                             |
 *  Parameters :
 *
 *     n      - Copy error number
 *
 *     szFile - the fully qualified name of the file we are copying
 *
 *  Returns
 *
 *     Always returns FC_ABORT
 *
 ****************************************************************************/
 UINT wsCopyError(int n, LPTSTR szFile)
 {
     TCHAR strBuf[MAXSTR];
     int i = 0;

    /*
     *  We do not want to report any errors that occur while installing
     *  related drivers to the user
     */

     if (bCopyingRelated)
          return(FC_ABORT);

    /*
     *  check for out of disk space
     */

     if (n == ERROR_DISK_FULL) {

        LoadString(myInstance, IDS_OUTOFDISK, strBuf, MAXSTR);

     } else {

       /*
        *  Check to see if a copy has been done on a file that is currently
        *  loaded by the system.
        *
        *  n is the return code from VerInstallFile after translating
        *  by ConvertFlagToValue
        */

        if (n == FC_ERROR_LOADED_DRIVER)
        {
            BOOL bFound = FALSE;
            PIDRIVER pIDriver;

           /*
            *  The driver is in use :
            *
            *  Search the list of curently installed drivers to see
            *  if this file is one of them.  If so tell the user to
            *  de-install and re-start.
            *
            *  If the driver is not currently installed then tell
            *  the user to re-start in the hope that it will then
            *  not be loaded (and so in use)
            *
            *  Note that there is another case not catered for that
            *  this is just a file in the driver's copy list which
            *  failed to copy because it was 'in use'.
            *
            */

            pIDriver = FindIDriverByName (FileName(szFile));

            if (pIDriver != NULL)    // Found an already-installed driver?
            {
                TCHAR sztemp[MAXSTR];
                LoadString(myInstance,
                           IDS_FILEINUSEREM,
                           sztemp,
                           sizeof(sztemp)/sizeof(TCHAR));

                wsprintf(strBuf, sztemp, (LPTSTR)pIDriver->szDesc);
                bFound = TRUE;
            } else {
                iRestartMessage = IDS_FILEINUSEADD;
                DialogBox(myInstance,
                          MAKEINTRESOURCE(DLG_RESTART),
                          hMesgBoxParent,
                          RestartDlg);

                return(FC_ABORT);
            }

        } else {
			if (n == ERROR_INSUFFICIENT_BUFFER) {

				/*
				 * Tell the user a buffer overflowed when attempting to 
				 * load strings from an .inf file.
				 */

				LoadString(myInstance, IDS_INVALIDINF, strBuf, MAXSTR);

			} else {

				/*
				 *  Tell the user there is a problem which we don't
				 *  understand here.
				 */

				 LoadString(myInstance,
						    IDS_UNABLE_TOINSTALL,
						    strBuf,
						    MAXSTR);
			}
        }
     }

    /*
     *  Put up the message box we have selected.
     */

     MessageBox(hMesgBoxParent,
                strBuf,
                szFileError,
                MB_OK | MB_ICONEXCLAMATION  | MB_TASKMODAL);

     return (FC_ABORT);

 }


/*----------------------------------------------------------------------------*\
|                                                                              |
| wsInsertDisk()                                                               |
|                                                                              |
|   Handles errors, as the result of copying files.                            |
|                                                                              |
\*----------------------------------------------------------------------------*/
UINT wsInsertDisk(LPTSTR Disk, LPTSTR szSrcPath)
{
    UINT temp;
    int i;

   /*
    *  Create the real disk letter
    */
    for (i = 0; Disk[i] != TEXT('\0') && Disk[i] != TEXT(':'); i++) {
        CurrentDisk[i] = Disk[i];
    }
    CurrentDisk[i] = TEXT('\0'); // Null terminate

    szEdit = szSrcPath;

    bFindOEM = TRUE;
    temp =  (UINT)fDialog(DLG_INSERTDISK, GetActiveWindow(), wsDiskDlg);
    bFindOEM = FALSE;
    return(temp);
}


/*----------------------------------------------------------------------------*
|   wsDiskDlg( hDlg, uiMessage, wParam, lParam )                               |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of about dialog window                   |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/

INT_PTR wsDiskDlg(HWND hDlg, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{

    switch (uiMessage)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDH_DLG_INSERT_DISK:
                   goto DoHelp;

                case IDS_BROWSE:

                  /*
                   *  Call the browse dialog to open drivers
                   */

                   BrowseDlg(hDlg,
                             3);    // index 3 points to no filter
                                    // - see szFilter
                   break;

                case IDOK:

                   /*
                    *  szEdit points to the path that will be retried
                    *  if the copy fails
                    */

                    GetDlgItemText(hDlg, ID_EDIT, szEdit, MAX_PATH);
                    RemoveSpaces(szDiskPath, szEdit);
                    lstrcpy(szEdit, szDiskPath);
                    EndDialog(hDlg, FC_RETRY);
                    UpdateWindow(hMesgBoxParent);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FC_ABORT);
                    break;
            }
            return TRUE;

        case WM_INITDIALOG:
            {

            TCHAR DisksSection[MAXSTR];

           /*
            *  now look in the [disks] section for the disk name
            *  the disk name is the second field.
            */

            TCHAR buf[MAXSTR];
            TCHAR buf2[MAXSTR];
            TCHAR bufout[MAXSTR];
			LONG  lResult;

            *buf = TEXT('\0');
            *buf2 = TEXT('\0');

           /*
            *  See what the name of the section should be
            */

            LoadString(myInstance,
                       IDS_DISKS,
                       DisksSection,
                       sizeof(DisksSection)/sizeof(TCHAR));

            lResult = infGetProfileString(NULL, DisksSection, CurrentDisk, (LPTSTR)buf, SIZEOF(buf));
		    ASSERT( INF_PARSE_SUCCESS(lResult) );
            if (lResult == ERROR_SUCCESS)
			{

               /*
                * Position of description in Windows NT
                */

               lResult = infParseField(buf, 1, buf2, SIZEOF(buf2));
		       ASSERT( INF_PARSE_SUCCESS(lResult) );
            }
			else if(lResult == ERROR_NOT_FOUND)
			{

               /*
                *  Didn't find the section we were looking for so try
                *  the old names
                */

			   lResult = infGetProfileString(NULL, TEXT("disks"), CurrentDisk, (LPTSTR)buf, SIZEOF(buf));
		       ASSERT( INF_PARSE_SUCCESS(lResult) );
			   if (ERROR_NOT_FOUND == lResult)
			   {
                   lResult = infGetProfileString(NULL, TEXT("oemdisks"), CurrentDisk, (LPTSTR)buf, SIZEOF(buf));
		           ASSERT( INF_PARSE_SUCCESS(lResult) );
			   }

			   if (ERROR_SUCCESS == lResult)
			   {
	               lResult = infParseField(buf, 2, buf2, SIZEOF(buf2));
		           ASSERT( INF_PARSE_SUCCESS(lResult) );
			   }
            }

			if( *buf2 )
			{
	            wsprintf(bufout, szKnown, (LPTSTR)buf2, (LPTSTR)szDrv);
		        SetDlgItemText(hDlg,ID_TEXT,bufout);
			}
            SetDlgItemText(hDlg,ID_EDIT,szEdit);

            return TRUE;
            }
        default:
            if (uiMessage == wHelpMessage) {
DoHelp:
               WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_DLG_INSERT_DISK);
               return TRUE;
            }
            else
                return FALSE;
         break;
    }
}

/*--------------------------------------------------------------------------
 *
 * Function : wsCopySingleStatus
 *     File copying callback routine
 *
 * Parameters :
 *     msg - Which callback function
 *     n   - various
 *     szFile - which file
 *
 * this call back only copies it's file if it does not exist in the
 * path.
 *
 *--------------------------------------------------------------------------*/

 UINT wsCopySingleStatus(int msg, DWORD_PTR n, LPTSTR szFile)
 {
    OFSTRUCT ofs;
    TCHAR szFullPath[MAX_PATH];
    TCHAR szDriverExists[MAXSTR];
    HANDLE hFile;

    switch (msg)
     {
         case COPY_INSERTDISK:
             return wsInsertDisk((LPTSTR)n, szFile);

         case COPY_ERROR:
             return wsCopyError((int)n, szFile);


         case COPY_QUERYCOPY:

            /*
             *  See if the file already exists in the windows system
             *  directory
             */

             GetSystemDirectory(szFullPath, MAX_PATH);

             if (IsFileKernelDriver(szFile)) {
                 lstrcat(szFullPath, TEXT("\\drivers"));
             }

             lstrcat(szFullPath, TEXT("\\"));

             lstrcat(szFullPath, RemoveDiskId(szFile));

             hFile = CreateFile(szFullPath, GENERIC_READ, FILE_SHARE_READ,NULL, 
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
             if (hFile != INVALID_HANDLE_VALUE)
             {
                /*
                 *  DriverCopy remembers whether to copy from
                 *  current or new after we have queried the user
                 *  once
                 */

                 static int DriverCopy;

                 if (bQueryExist)
                 {
                     bQueryExist = FALSE;

                     LoadString(myInstance,
                                IDS_DRIVER_EXISTS,
                                szDriverExists,
                                sizeof(szDriverExists)/sizeof(TCHAR));

                     wsprintf(szErrMsg, szDriverExists, FileName(szFile));

                    /*
                     *  Ask the user whether to copy or not ?
                     */

                     DriverCopy = (int)DialogBox(myInstance,
                                            MAKEINTRESOURCE(DLG_EXISTS),
                                            hMesgBoxParent,
                                            wsExistDlg);
                 }
                 CloseHandle(hFile);
                 return DriverCopy;
             } else {

                 return CopyNew;
             }

         case COPY_START:
         case COPY_END:
             SetErrorMode(msg == COPY_START);    // don't crit error on us
             break;
     }
     return FC_IGNORE;
 }

/*
 *  Function : wsExistDlg - 'File exists' dialog
 */

 INT_PTR wsExistDlg(HWND hDlg, UINT uiMessage, WPARAM wParam, LPARAM lParam)
 {
     switch (uiMessage)
     {
         case WM_COMMAND:
             switch (LOWORD(wParam))
             {
                 case ID_CURRENT:

                     EndDialog(hDlg, CopyCurrent);
                     break;

                 case ID_NEW:

                    /*
                     *  User selected to copy the new files over the
                     *  existing ones
                     */

                     EndDialog(hDlg, CopyNew);
                     break;

                 case IDCANCEL:
                     EndDialog(hDlg, CopyNeither);  // Cancel
                     break;
             }
             return TRUE;

         case WM_INITDIALOG:
             SetDlgItemText(hDlg, ID_STATUS2, szErrMsg);
             return TRUE;

         default:
          break;
     }
     return FALSE;
 }

/*
 *  Function : RemoveSpaces
 *     Copies a string removing leading and trailing spaces but allowing
 *     for long file names with internal spaces.
 *
 *  Parameters :
 *     szPath - The output result
 *     szEdit - The input path
 */

 VOID RemoveSpaces(LPTSTR szPath, LPTSTR szEdit)
 {
     LPTSTR szLastSpaceList;

     while (*szEdit == TEXT(' ')) {
         szEdit = CharNext(szEdit);
     }

     lstrcpy(szPath, szEdit);

     for (szLastSpaceList = NULL;
          *szPath != TEXT('\0');
          szPath = CharNext(szPath)) {

        if (*szPath == TEXT(' ')) {
            if (szLastSpaceList == NULL) {
                szLastSpaceList = szPath;
            }
        } else {
            szLastSpaceList = NULL;
        }

     }

     if (szLastSpaceList != NULL) {
         *szLastSpaceList = TEXT('\0');
     }
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\idf.h ===
//************************************************************************
//**
//**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//**  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//**  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//**  A PARTICULAR PURPOSE.
//**
//**  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//**
//**  IDF.h
//**
//**  DESCRIPTION:
//**     This file contains the format of the .IDF files.
//**
//**  HISTORY:
//**     04/29/93       created.
//**     07/04/93       added UNICODE for displayable strings.
//**     09/04/93       added keymaps.
//**     09/05/93       added ID's for channel types.
//**
//************************************************************************

/*
@doc  EXTERNAL SDK

@types   IDFHEADER |
   This is the format of the "hdr " chunk in a Microsoft IDF file.
   This will be the first subchunk of a "MMAP" list chunk.  This will 
   provide information on the IDF itself; what version, who created it,
   and a unique ASCII ID for the instrument.

@field   DWORD | cbStruct |
   This is the inclusive size of the header structure.

@field   DWORD | dwVersion |
   This is the version of the IDF file.
   under.

@field   DWORD | dwCreator |
   This is the creator ID for the IDF.

@field   DWORD | cbInstID |
   This is the size of the unique instrument identifier including the NULL.

@field   BYTE | abInstID[] |
   This is the actual ASCII bytes of the unique instrument id. This _IS_ 
   NULL terminated.  There is no UNICODE version of this since this will
   only be used internally and not displayed to the user.

@othertype  IDFHEADER * | PIDFHEADER |
   A memory model dependant pointer to the structure.

@othertype  IDFHEADER FAR* | LPIDFHEADER |
   A far pointer to the structure.
*/

typedef struct tag_IDFHEADER
{
   DWORD cbStruct;

   DWORD dwVersion;
   DWORD dwCreator;

   DWORD cbInstID;
   BYTE  abInstID[1];
} IDFHEADER, *PIDFHEADER, FAR *LPIDFHEADER;


/*
@doc  EXTERNAL SDK

@types   IDFINSTINFO |
   This is the format of the "inst" chunk in a Microsoft IDF file.
   This chunk will contain information on the instrument, e.g. who
   manufactured it, the name of the instrument, it's manufacturer and
   product id's and a revision number.

@field   DWORD | cbStruct |
   This is the inclusive size of the instrument information structure.

@field   DWORD | dwManufactID |
   Manufacturer's ID.

@field   DWORD | dwProductID |
   Product's ID.

@field   DWORD | dwRevision |
   Revision of the product.

@field   DWORD | cbManufactASCII |
   Length of the ASCII version of the manufacturuers name.

@field   DWORD | cbManufactUNICODE |
   Length of the UNICODE version of the manufacturuers name.

@field   DWORD | cbProductASCII |
   Length of the ASCII version of the product name.

@field   DWORD | cbProductUNICODE |
   Length of the UNICODE version of the product name.

@field   BYTE | abData[] |
   Contains the ASCII and UNICODE strings for the manufacturer and product
   names.  NOTE that all strings are separated by a NULL and the NULL IS
   counted in the string lengths.

@othertype  IDFINSTINFO * | PIDFINSTINFO |
   A memory model dependant pointer to the structure.

@othertype  IDFINSTINFO FAR * | LPIDFINSTINFO |
   A far pointer to the structure.

@comm The idea is that the cbManufactXXXXX and cbProductXXXXX will be the
      offsets into the bData array of bytes and it will contain a complete
      string that you can strcpy out.  That is why the NULL is included in
      the byte count and in the actual data.
*/

typedef struct tag_IDFINSTINFO
{
   DWORD cbStruct;

   DWORD dwManufactID;
   DWORD dwProductID;
   DWORD dwRevision;

   DWORD cbManufactASCII;
   DWORD cbManufactUNICODE;
   DWORD cbProductASCII;
   DWORD cbProductUNICODE;

   BYTE  abData[1];
} IDFINSTINFO, FAR *LPIDFINSTINFO;

/*
@doc  EXTERNAL SDK

@types   IDFINSTCAPS |
   This is the format of the "caps" chunk in a Microsoft IDF file.
   This chunk will contain information on the MIDI capabilities of
   the device. e.g. basic channel of the instrument, number of channels
   that the instrument has available. the polyphony of the instrument, 
   whether or not it supports General MIDI, etc....

@field   DWORD | cbStruct |
   This is the size of the capabilities structure.

@field   DWORD | fdwFlags |
   Flags specifiying additional capabilities of an instrument.

@flag IDFINSTCAPS_F_GENERAL_MIDI |
   Instrument supports General MIDI.

@flag IDFINSTCAPS_F_SYSTEMEXCLUSIVE |
   Instrument supports system exclusive messages

@field   DWORD | dwBasicChannel |
   The basic channel for the instrument.

@field   DWORD | cNumChannels |
   Number of channels that the instrument supports to.

@field   DWORD | cInstrumentPolyphony |
   The total polyphony for the instrument.

@field   DWORD | cChannelPolyphony |
   The polyphony per channel.

@othertype  IDFINSTCAPS * | PIDFINSTCAPS |
   A memory model dependant pointer to the structure.

@othertype  IDFINSTCAPS FAR * | LPIDFINSTCAPS |
   A far pointer to the structure.
*/

typedef struct tag_IDFINSTCAPS
{
   DWORD cbStruct;
   DWORD fdwFlags;
   DWORD dwBasicChannel;
   DWORD cNumChannels;
   DWORD cInstrumentPolyphony;
   DWORD cChannelPolyphony;
} IDFINSTCAPS, *PIDFINSTCAPS, FAR *LPIDFINSTCAPS;

#define  IDFINSTCAPS_F_GENERAL_MIDI       0x00000001
#define  IDFINSTCAPS_F_SYSTEMEXCLUSIVE    0x00000002

/*
@doc  EXTERNAL SDK

@types   IDFCHANNELHDR |
   This is the format of the "chan" chunk in a Microsoft IDF file.
   This contains a description on what "type" a channel is, i.e. 
   is it a General MIDI channel, a drum channel, etc... Directly 
   following this header is the actual data on each channel.

@field   DWORD | cbStruct |
   This is the size of the channel header structure.

@field   DWORD | fdwFlags |
   Flags describing the channel type information.

@flag IDFCHANNELHDR_F_GENERAL_MIDI |
   If this flag is set then any channels that are not defined in the 
   IDF are General MIDI channel types.  If this flag is _NOT_ set then
   any channels that are not defined in the IDF are undefined and should 
   NOT be used in mapping. This flag overrides the contents of dwGeneralMask
   and dwDrumMask.

@field DWORD | dwGeneralMask |
   This mask indicates which channels are available for
   use as general channels. The channels will be considered usable even if
   there is no associcate IDFCHANNELINFO structure defined.

@field DWORD | dwDrumMask |
   This mask indicates which channels are available for
   use as drum channels. The channels will be considered usable even if
   there is no associcate IDFCHANNELINFO structure defined.

@field   DWORD | cNumChannels |
   This is the number of channels that follows the header.

@othertype  IDFCHANNELHDR * | PIDFCHANNELHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFCHANNELHDR FAR * | LPIDFCHANNELHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFCHANNELHDR
{
   DWORD cbStruct;
   DWORD dwGeneralMask;
   DWORD dwDrumMask;
   DWORD dwReserved;                    // Must be zero
   DWORD fdwFlags;
} IDFCHANNELHDR, *PIDFCHANNELHDR, FAR *LPIDFCHANNELHDR;

#define  IDFCHANNELHDR_F_GENERAL_MIDI     0x00000001


/*
@doc  EXTERNAL SDK

@types    IDFCHANNELINFO |
   This is the format of the actual channel information for Microsoft
   authored IDF files. This is the Microsoft supported format for
   channel information.

@field   DWORD | dwChannel |
   This is the channel number that the structure defines.

@field   DWORD | fdwChannel |
   Defines the possible types this channel can be.

   @flag    IDFCHANNELINFO_F_GENERAL_CHANNEL |
       Indicates that this channel may be a general channel.

   @flag    IDFCHANNELINFO_F_DRUM_CHANNEL |
       Indicates that this channel may be a drum channel.

@field   DWORD | cbInitData |
    Specifies the length of the data which should be sent to initialize
    the channel. This data will be send to initialize the channel each
    time the mapper is opened.

@field    BYTE | abData[] |
    This field contains the actual initialization data.
    <f cbInitData> should indicate the length of this sequence,
    byte aligned. However, the actual sequence should be padded so that
    it is actually DWORD aligned (i.e. even multiple
    of four bytes). <f cbStruct> should reflect the padded length of
    the sequences.
        
@othertype  IDFCHANNELINFO * | PIDFCHANNELINFO |
   A memory model dependant pointer to the structure.

@othertype  IDFCHANNELINFO FAR * | LPIDFCHANNELINFO |
   A far pointer to the structure.
*/

typedef struct tag_IDFCHANNELINFO
{
   DWORD cbStruct;
   DWORD dwChannel;
   DWORD cbInitData;
   BYTE  abData[];
} IDFCHANNELINFO, *PIDFCHANNELINFO, FAR *LPIDFCHANNELINFO;

/*
@doc  EXTERNAL SDK

@types   IDFPATCHMAPHDR |
   This is the format of the "map " chunk in a Microsoft IDF file.
   This chunk contains information on the patch map used for the 
   instrument. Directly following this header is the actual mapping 
   information for each patch.

@field   DWORD | cbStruct |
   This is the size of the patch map header structure.

@field   BYTE | abPatchMap[128] |
   This array contains the actual patch map. The incoming patch is
   used to index the array; the array contents are the new patch value
   and must be in the range 0x00-0x7F. Patch maps will only apply to
   channels of type general. If the instrument needs a patch change
   on a drum channel, it should be included in the initialization data
   in the IDFCHANNELINFO.

@othertype  IDFPATCHMAPHDR * | PIDFPATCHMAPHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFPATCHMAPHDR FAR * | LPIDFPATCHMAPHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFPATCHMAPHDR
{
   DWORD cbStruct;
   BYTE  abPatchMap[128];
           
} IDFPATCHMAPHDR, *PIDFPATCHMAPHDR, FAR *LPIDFPATCHMAPHDR;

/*
@doc  EXTERNAL SDK

@types   IDFKEYMAPHDR |
   This is the format of the "key " chunk in a Microsoft IDF file.
   This chunk contains information on the all of the key maps used 
   for a given instrument. The information that is in this structure
   pertains to all of the key maps for the instrument.  It contains
   the total number of key maps for the instrument and whether or not
   the key maps are General MIDI.

@field   DWORD | cbStruct |
   This is the size of the key map header structure.

@field   DWORD | cNumKeyMaps |
   This is the number of key maps that follow the header.

@field   DWORD | cbKeyMap |
   This is the size of each key map that follows the header.   

@othertype  IDFPATCHMAPHDR * | PIDFPATCHMAPHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFPATCHMAPHDR FAR * | LPIDFPATCHMAPHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFKEYMAPHDR
{
   DWORD cbStruct;
   DWORD cNumKeyMaps;
   DWORD cbKeyMap;
} IDFKEYMAPHDR, *PIDFKEYMAPHDR, FAR *LPIDFKEYMAPHDR;

/*
@doc  EXTERNAL SDK

@types   IDFKEYMAP |
   This is the format of the "gkey" or "dkey" chunk in a Microsoft
   IDF file. This chunk contains information on the all of the key maps
   used for a given instrument. The information that is in this structure
   pertains to all of the key maps for the instrument.  It contains
   the total number of key maps for the instrument and whether or not
   the key maps are General MIDI.

@field   DWORD | cbStruct |
   This is the size of the key map header structure.

@field   BYTE | abKeyMap[128] |
    This field contains the actual key map. The incoming key number from
    a note on or note off message is used to index this array; the array
    contents are the new key value. If the high bit it set in the new
    key value, then the note on or note off will be ignore; otherwise,
    it will be transmitted with the new key value.
    
@othertype  IDFKEYMAP * | PIDFKEYMAP |
   A memory model dependant pointer to the structure.

@othertype  IDFKEYMAP FAR * | LPIDFKEYMAP |
   A far pointer to the structure.
*/

typedef struct tag_IDFKEYMAP
{
   DWORD cbStruct;
   BYTE  abKeyMap[128];
} IDFKEYMAP, *PIDFKEYMAP, FAR *LPIDFKEYMAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\infparse.c ===
/*
 * Infparse.c - Setup.inf parsing code.
 * Clark Cyr, Mike Colee, Todd Laney
 * Copyright (C) Microsoft, 1989
 * March 15, 1989
 *
 *  Modification History:
 *
 *  3/15/89  CC  Clark wrote this code for control Panel. This is windows
 *               code.
 *
 *  3/20/89  MC  Decided this code would work for Dos and windows portion
 *               of setup. take out windows specifc stuff like local alloc's
 *               and dialog stuff. Replace it with standard C run time calls.
 *
 *  3/24/89  Toddla TOTAL rewrite! nothing is the same any more.
 *
 *  6/29/89  MC fixed getprofilestring func to not strip quotes if more
 *              than one field exists.
 */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <stdlib.h>
#include "drivers.h"
#include "sulib.h"

/*** hack.  to avoid realloc problems we make READ_BUFSIZE
            as big as the inf file, thus avoiding any reallocs */

#define READ_BUFSIZE    27000   /* size of inf buffer */
#define TMP_BUFSIZE     1024    /* size of temp reads */

#define EOF        0x1A
#define ISEOL(c)     ((c) == '\n' || (c) == '\r' || (c) == '\0' || (c) == EOF)
#define ISSEP(c)   ((c) == '='  || (c) == ',')
#define ISWHITE(c) ((c) == ' '  || (c) == '\t' || (c) == '\n' || (c) == '\r')
#define ISNOISE(c) ((c) == '"')

#define QUOTE   '"'
#define EQUAL   '='

PINF   pinfDefault = NULL;

static LPSTR   pBuf;
static PINF    pInf;
static UINT    iBuf;
static UINT    iInf;

/* Globaly used pointers to non-translatable text strings. */

extern TCHAR *pszPATH;

/* Local prototypes */

BOOL multifields(PINF);


static TCHAR GETC(int fh)
{
    register UINT n;

    if (!pBuf)
        return EOF;

    n = iBuf % TMP_BUFSIZE;

    if (n == 0)
    {
       _lread(fh,pBuf,TMP_BUFSIZE);
    }
    iBuf++;
    return pBuf[n];
}

static void PUTC(TCHAR c)
{
    if (!pInf)
        return;

    pInf[iInf++] = c;
}

static void MODIFYC(TCHAR c)
{
    if (!pInf)
        return;

    pInf[iInf++ - 1] = c;
}

static TCHAR LASTC(void) {
    if (!pInf) return ' ';

    if (iInf == 0) {
        return ' ';
    }
    return pInf[iInf - 1];
}

/* int infLoadFile()      Load a entire INF file into memory
 *                        comments are removed, each line is terminated
 *                        by a \0 each section is terminated by a \0\0
 *                        ONLY spaces inside of " " are preserved
 *                        the end of file is marked with a ^Z
 *
 *   RETURNS:  A pointer to a block of memory containg file, NULL if failure
 *
 */
PINF infLoadFile(int fh)
{
    UINT    len;
    TCHAR    c;
    BOOL    fQuote = FALSE;
    BOOL    inSectionName = FALSE;

    if (fh == -1)
      return NULL;

    len = (UINT)_llseek(fh,0L,SEEK_END);

    _llseek(fh,0L,SEEK_SET);

    iBuf = 0;
    iInf = 0;
    pBuf = ALLOC(TMP_BUFSIZE);          // temp buffer
    if (!pBuf)
        return NULL;
    pInf = FALLOC(len*sizeof(TCHAR));                 // destination, at least as big as file
    if (!pInf) {
        FREE((HANDLE)pBuf);
        return NULL;
    }

    while (iBuf < len)
    {
        c = GETC(fh);
loop:
        if (iBuf >= len)
            break;

        switch (c)
        {
            case TEXT('['):
                inSectionName = TRUE;
                PUTC(c);
                break;

            case TEXT(']'):
                if (inSectionName) {
                    if (LASTC() == TEXT(' ')) {
                        MODIFYC(c);
                    } else {
                        PUTC(c);
                    }
                    inSectionName = FALSE;
                } else {
                    PUTC(c);
                }
                break;

            case TEXT('\r'):      /* ignore '\r' */
                break;

            case TEXT('\n'):
                for (; ISWHITE(c); c = GETC(fh))
                    ;
                if (c != TEXT(';'))
                    PUTC(0);    /* all lines end in a \0 */

                if (c == TEXT('[')) {
                    PUTC(0);    /* all sections end with \0\0 */
                }

                fQuote = FALSE;
                goto loop;
                break;

            case TEXT('\t'):
            case TEXT(' '):
                if (inSectionName) {
                    if (LASTC() != TEXT(' ') && LASTC() != TEXT(']'))
                        PUTC(TEXT(' '));
                } else {
                    if (fQuote)
                        PUTC(c);
                }
                break;

            case TEXT('"'):
                fQuote = !fQuote;
                PUTC(c);
                break;

            case TEXT(';'):
                for (; !ISEOL(c); c = GETC(fh))
                    ;
                goto loop;
                break;

            default:
                PUTC(c);
                break;
        }
    }

    PUTC(0);
    PUTC(0);
    PUTC(EOF);
    FREE((HANDLE)pBuf);

    // try to shrink this block


    // just leave pInf it's original size.  don't bother shrinking it

    return pInf;
}

/* PINF FAR PASCAL infOpen()
 *   PARAMETERS
 *           szInf - path to inf file to open and load
 *
 *   RETURNS:  A pointer to the parsed inf file if successful,
 *             Null pointer in the case of failure.
 *
 *   ENTER:
 *   EXIT:   To caller
 */

PINF infOpen(LPTSTR szInf)
{
    TCHAR    szBuf[MAX_PATH];
    int     fh;
    PINF    pinf;

    fh = -1;

    if (szInf == NULL)
        szInf = szSetupInf;

    /*
     * Next try to open passed parameter as is. For Dos half.
     */
    if (fh == -1)
    {
        fh = HandleToUlong(CreateFile(szInf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    }
    /*
     * Next try destination path\system32. for win half.
     */
    if (fh == -1) {
        lstrcpy(szBuf, szSetupPath);
      catpath(szBuf, TEXT("system32"));
      catpath(szBuf, szInf);
      fh = HandleToUlong(CreateFile(szBuf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    }
    /*
     * Next try destination path. for initial setup.
     */
    if (fh == -1) {
        lstrcpy(szBuf, szSetupPath);
      catpath(szBuf, szInf);
      fh = HandleToUlong(CreateFile(szBuf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    }
    if (fh != -1)
    {
        pinf = infLoadFile(fh);
        _lclose(fh);

        if (pinf && !pinfDefault)
            pinfDefault = pinf;

        return pinf;
    }
    return NULL;
}

/* void FAR PASCAL infClose(PINF pinf)
 *
 *   ENTER:
 *   EXIT:   To caller
 */
void infClose(PINF pinf)
{
    if (pinf == NULL)
        pinf = pinfDefault;

    if (pinf != NULL)
    {
        FFREE(pinf);

        if (pinf == pinfDefault)
            pinfDefault = NULL;
    }
}


/* FindSection  locates a section in Setup.Inf.  Sections are
 *               assumed to be delimited by a '[' as the first
 *               character on a line.
 *
 * Arguments:   pInf     Pointer to SETUP.INF buffer
 *              pszSect  LPTSTR to section name
 *
 * Return:      UINT file position of the first line in the section
 *               0 if section not found
 */

UINT_PTR FindSection(PINF pInf, LPTSTR pszSect)
{
    BOOL        fFound = FALSE;
    int         nLen = lstrlen(pszSect);
    PINF        pch;

    if (!pInf)
        return 0;

    pch = pInf;
    while (!fFound && *pch != EOF)
    {
        if (*pch++ == TEXT('['))
        {
            fFound = !_wcsnicmp(pszSect, pch, nLen) && pch[nLen] == TEXT(']');
        }

        /*
         * go to the next line, dont forget to skip over \0 and \0\0
         */
        while (*pch != EOF && *pch != TEXT('\0'))
            pch++;

        while (*pch == 0)
            pch++;
    }
    return((fFound && *pch != TEXT('[') && *pch != EOF) ? pch - pInf : 0);
}

/* LONG fnGetDataString(npszData,szDataStr,szBuf,cchBuf)
 *
 * Called by functions that read sections of information from setup.inf
 * to obtain strings that are set equal to keywords. Example:
 *
 * welcome=("Hello There")
 *
 * This function will return a pointer to the null terminated string
 * "Hello There".
 *
 * ENTRY:
 *
 * npszData    : pointer to entire section taken from setup.inf
 * szDataStr   : pointer to key word to look for (welcome in example above.)
 * szBuf       : pointer to a buffer to hold result
 * cchBuf      : size of destination buffer (szBuf) in characters.
 *               length must be large enough to hold all of the
 *               text including the null terminator.
 *
 * EXIT: returns ERROR_SUCCESS if successful, ERROR_NOT_FOUND or ERROR_INSUFFICIENT_BUFFER if failure.
 *
 */
LONG fnGetDataString(PINF npszData, LPTSTR szDataStr, LPTSTR szBuf, size_t cchBuf)
{
	LPTSTR szBufOrig = szBuf;
    int len = lstrlen(szDataStr);

    while (npszData)
    {
            if (!_wcsnicmp(npszData,szDataStr,len))  // looking for correct prof.
            {
               npszData += len;            // found !, look past prof str.
               while (ISWHITE(*npszData))  // pull out the garbage.
                       npszData++;
          if (*npszData == EQUAL)     // Now we have what were looking for !
               {
                       npszData++;

             if (!multifields(npszData) )
             {
                while (ISWHITE(*npszData) || ISNOISE(*npszData))
                             npszData++;

                          while (*npszData)
						  {
                             *szBuf++ = *npszData++;
						     cchBuf--;
							 ASSERT( cchBuf > 0 );
						     if( cchBuf <= 0 )
							 {
							     *szBufOrig = TEXT('\0'); 
							     return ERROR_INSUFFICIENT_BUFFER;
							 }
						  }

                       /*
                        * remove trailing spaces, and those pesky ()'s
                           */

                while (ISWHITE(szBuf[-1]) || ISNOISE(szBuf[-1]))
                             szBuf--;

                          *szBuf = 0;
                          return ERROR_SUCCESS;
             }
             else
             {
                while (*npszData)
				{
                   *szBuf++ = *npszData++;
				   cchBuf--;
				   ASSERT( cchBuf > 0 );
				   if( cchBuf <= 0 )
				   {
						*szBufOrig = TEXT('\0'); 
						return ERROR_INSUFFICIENT_BUFFER;
				   }	
				}
                *szBuf = TEXT('\0');
                return ERROR_SUCCESS;
             }
               }
       }
       npszData = infNextLine(npszData);
    }
    *szBuf = 0;
    return ERROR_NOT_FOUND;
}

/*  PINF FAR PASCAL infSetDefault(pinf)
 *
 *  Sets the default INF file
 *
 * ENTRY:
 *      pinf            : inf file to be new default
 *
 * EXIT: returns old default
 *
 */
PINF infSetDefault(PINF pinf)
{
    PINF pinfT;

    pinfT = pinfDefault;
    pinfDefault = pinf;
    return pinfT;
}

/*  PINF FAR PASCAL infFindSection(pinf,szSection)
 *
 *  Reads a entire section into memory and returns a pointer to it
 *
 * ENTRY:
 *      pinf            : inf file to search for section
 *      szSection       : section name to read
 *
 * EXIT: returns pointer to section, NULL if error
 *
 */
PINF infFindSection(PINF pinf, LPTSTR szSection)
{
    UINT_PTR   pos;

    if (pinf == NULL)
        pinf = pinfDefault;

    pos = FindSection(pinf, szSection);
    return pos ? pinf + pos : NULL;
}

/*  LONG FAR PASCAL infGetProfileString(szSection,szItem,szBuf,cchBuf)
*
 *  Reads a single string from a section in SETUP.INF
 *
 *  [section]
 *      item = string
 *
 * ENTRY:
 *      szSection       : pointer to section name to read.
 *      szItem          : pointer to item name to read
 *      szBuf           : pointer to a buffer to hold result
 *      cchBuf          : size of destination buffer (szBuf) in characters.
 *                        length must be large enough to hold all of the
 *                        text including the null terminator.
 *
 * EXIT: returns ERROR_SUCCESS if successful, ERROR_NOT_FOUND or ERROR_INSUFFICIENT_BUFFER if failure.
 *
 */
LONG infGetProfileString(PINF pinf, LPTSTR szSection,LPTSTR szItem,LPTSTR szBuf,size_t cchBuf)
{
    PINF    pSection;

    pSection = infFindSection(pinf,szSection);
    if (pSection )
        return fnGetDataString(pSection,szItem,szBuf,cchBuf);
    else
        *szBuf = 0;
    return ERROR_NOT_FOUND;
}

/* LONG FAR PASCAL infParseField(szData,n,szBuf,cchBuf)
 *
 * Given a line from SETUP.INF, will extract the nth field from the string
 * fields are assumed separated by comma's.  Leading and trailing spaces
 * are removed.
 *
 * ENTRY:
 *
 * szData    : pointer to line from SETUP.INF
 * n         : field to extract. ( 1 based )
 *             0 is field before a '=' sign
 * szBuf     : pointer to buffer to hold extracted field
 * cchBuf    : size of destination buffer (szBuf) in characters.
 *             length must be large enough to hold all of the
 *             text including the null terminator.
 *
 * EXIT: returns ERROR_SUCCESS if successful,
 *               ERROR_INVALID_PARAMETER, ERROR_NOT_FOUND or ERROR_INSUFFICIENT_BUFFER if failure.
 *
 */
LONG infParseField(PINF szData, int n, LPTSTR szBuf, size_t cchBuf)
{
    BOOL    fQuote = FALSE;
    PINF    pch;
    LPTSTR   ptr;

	ASSERT(szData != NULL);
	ASSERT(szBuf != NULL);
    if (!szData || !szBuf)
	{
		if( szBuf )
		{
	        szBuf[0] = 0;            // make szBuf empty
		}
        return ERROR_INVALID_PARAMETER;	
	}

    /*
     * find the first separator
     */
    for (pch=szData; *pch && !ISSEP(*pch); pch++) {
      if ( *pch == QUOTE )
         fQuote = !fQuote;
    }

    if (n == 0 && *pch != TEXT('='))
	{
        szBuf[0] = 0;            // make szBuf empty
        return ERROR_NOT_FOUND;	
	}

    if (n > 0 && *pch == TEXT('=') && !fQuote)
        szData = ++pch;

    /*
     *  locate the nth comma, that is not inside of quotes
     */
    fQuote = FALSE;
    while (n > 1)
    {
            while (*szData)
            {
          if (!fQuote && ISSEP(*szData))
                   break;

          if (*szData == QUOTE)
                   fQuote = !fQuote;

               szData++;
            }

            if (!*szData) {
               szBuf[0] = 0;            // make szBuf empty
               return ERROR_NOT_FOUND;
            }

            szData++;
            n--;
    }
    /*
     * now copy the field to szBuf
     */
    while (ISWHITE(*szData))
            szData++;

    fQuote = FALSE;
    ptr = szBuf;                // fill output buffer with this
    while (*szData)
    {
       if (*szData == QUOTE)
               fQuote = !fQuote;
       else if (!fQuote && ISSEP(*szData))
               break;
            else
			{
               *ptr++ = *szData;
			   cchBuf--;
			   ASSERT( cchBuf > 0 );
			   if( cchBuf <= 0 )
			   {
				   *szBuf = TEXT('\0');
				   return ERROR_INSUFFICIENT_BUFFER;
			   }
			}
            szData++;
    }
    /*
     * remove trailing spaces, and those pesky ()'s
     */
    while ((ptr > szBuf) && (ISWHITE(ptr[-1]) || ISNOISE(ptr[-1])))
            ptr--;

    *ptr = 0;
    return ERROR_SUCCESS;
}

/* BOOL multifields(LPTSTR npszData);
 *
 * Given a line line from mmdriver.inf that was after a profile
 * string this function will determine if that line has more than one
 * field. ie. Fields are seperated by commas that are NOT contained between
 * quotes.
 *
 * ENYRY:
 *
 * npszData : a line from setup.inf Example "xyz adapter",1:foobar.drv
 *
 * EXIT: This function will return TRUE if the line containes more than
 *       one field, ie the function would return TRUE for the example line
 *       shown above.
 *
 */
BOOL multifields(PINF npszData)
{
   BOOL    fQuote = FALSE;

        while (*npszData)
        {
      if (!fQuote && ISSEP(*npszData))
                   return TRUE;

      if (*npszData == QUOTE)
                   fQuote = !fQuote;

           npszData++;
        }
   return FALSE;
}

/* LPTSTR FAR PASCAL infNextLine(sz)
 *
 * Given a line from SETUP.INF, advance to the next line.  will skip past the
 * ending NULL character checking for end of buffer \0\0
 *
 * ENTRY:
 *
 * sz        : pointer to line from a SETUP.INF section
 *
 * EXIT: returns pointer to next line if successful, NULL if failure.
 *
 */
PINF infNextLine(PINF pinf)
{
    if (!pinf)
        return NULL;

    while (*pinf != 0 || *(pinf + 1) == TEXT(' '))
        pinf++;

    return *++pinf ? pinf : NULL;
}

/* int FAR PASCAL infLineCount(pinf)
 *
 * Given a section from SETUP.INF, returns the number of lines in the section
 *
 * ENTRY:
 *
 * pinf      : pointer to a section from SETUP.INF
 *
 * EXIT: returns line count
 *
 */
int infLineCount(PINF pinf)
{
    int n = 0;

    for (n=0; pinf; pinf = infNextLine(pinf))
        n++;

    return n;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\install.h ===
#ifndef INSTALL_H
#define INSTALL_H

///////////////////////////////////////////////////////////////////////////////


#define SECTION         512                   // Maximum size of section
#define MAXSTR          256
#define UNLIST_LINE     1
#define NO_UNLIST_LINE  0
#define WEC_RESTART     0x42
#define DESC_ERROR		4
#define DESC_SYS        3
#define DESC_INF        2
#define DESC_EXE        1
#define DESC_NOFILE     0

#define FALLOC(n)                ((VOID *)GlobalAlloc(GPTR, n))
#define FFREE(n)                 GlobalFree(n)
#define ALLOC(n)                 (VOID *)LocalAlloc(LPTR,n)
#define FREE(p)                  LocalFree(p)
#define REALLOC(p,n)             LocalRealloc(p,n,LMEM_MOVEABLE)

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0

#define MAXFILESPECLEN       MAX_PATH /* drive: + path length max + Null Byte */
#define MAX_INF_LINE_LEN     256      /* Maximum length of any .inf line */
#define MAX_SYS_INF_LEN      256      /* ##: + 8.3 + NULL */
#define MAX_SECT_NAME_LEN    40       /* Max length of a section Name. */
#define MAX_FILE_SPEC        MAX_PATH // 8.3 + X: + NULL.

#define DISK_SECT              TEXT("disks")
#define OEMDISK_SECT           TEXT("oemdisks")

/* Return codes from 'file exists' dialog */

enum {
    CopyNeither,            // User wants to cancel if file exists
    CopyCurrent,            // User wants to use current file
    CopyNew                 // User wants to copy new file
};

#define SLASH(c)     ((c) == TEXT('/')|| (c) == TEXT('\\'))
#define CHSEPSTR                TEXT("\\")
#define COMMA   TEXT(',')
#define SPACE   TEXT(' ')

/* Globals and routines for .inf file parsing */

typedef LPTSTR    PINF;

/* Message types for FileCopy callback function */

typedef BOOL (*FPFNCOPY) (int,DWORD_PTR,LPTSTR);
#define COPY_ERROR          0x0001
#define COPY_INSERTDISK     0x0003
#define COPY_QUERYCOPY      0x0004
#define COPY_START          0x0005
#define COPY_END            0x0006
#define COPY_EXISTS         0x0007

/* Option Flag values for FileCopy */

#define FC_FILE              0x0000
#define FC_LIST              0x0001
#define FC_SECTION           0x0002
#define FC_QUALIFIED         0x0008
#define FC_DEST_QUALIFIED    0x0010
#define FC_LISTTYPE          0x0020
#define FC_CALLBACK_WITH_VER 0x0040

#define FC_ABORT    0
#define FC_IGNORE   1
#define FC_RETRY    2
#define FC_ERROR_LOADED_DRIVER  0x80


/*******************************************************************
 *
 * Global Variables
 *
 *******************************************************************/

 // Path to the directory where we found the .inf file

 extern char szSetupPath[MAX_PATH];

 // Path to the user's disk(s)

 extern char szDiskPath[MAX_PATH];   // Path to the default drive -
                                     //
 extern BOOL bRetry;

 // Name of the driver being installed

 extern char szDrv[120];

 //

 extern char szFileError[50];

 // Parent window for file copy dialogues

 extern HWND hMesgBoxParent;

 // TRUE on copying first file to prompt user if file already exists
 // FALSE for subsequent copies

 extern BOOL bQueryExist;

///////////////////////////////////////////////////////////////////////////////

BOOL DefCopyCallback(int msg, DWORD_PTR n, LPTSTR szFile);
UINT FileCopy (LPTSTR szSource, LPTSTR szDir, FPFNCOPY fpfnCopy, UINT fCopy, HWND hPar, BOOL fQuery);
LONG TryCopy(LPTSTR, LPTSTR, LPTSTR, FPFNCOPY);
LONG GetDiskPath(LPTSTR Disk, LPTSTR szPath, size_t cchPath);
LONG ExpandFileName(LPTSTR szFile, LPTSTR szPath);
void catpath(LPTSTR path, LPTSTR sz);
LPTSTR FileName(LPTSTR szPath);
LPTSTR RemoveDiskId(LPTSTR szPath);
LPTSTR StripPathName(LPTSTR szPath);
BOOL IsFileKernelDriver(LPTSTR szPath);
UINT ConvertFlagToValue(DWORD dwFlags);
BOOL IsValidDiskette(int iDrive);
BOOL IsDiskInDrive(int iDisk);
BOOL GetInstallPath(LPTSTR szDirOfSrc);
BOOL wsInfParseInit(void);
void wsStartWait();
void wsEndWait();
int fDialog(int id, HWND hwnd, DLGPROC fpfn);
UINT wsCopyError(int n, LPTSTR szFile);
UINT wsInsertDisk(LPTSTR Disk, LPTSTR szSrcPath);
INT_PTR wsDiskDlg(HWND hDlg, UINT uiMessage, UINT wParam, LPARAM lParam);
UINT wsCopySingleStatus(int msg, DWORD_PTR n, LPTSTR szFile);
INT_PTR wsExistDlg(HWND hDlg, UINT uiMessage, UINT wParam, LPARAM lParam);
VOID RemoveSpaces(LPTSTR szPath, LPTSTR szEdit);
PINF infLoadFile(int fh);
PINF infOpen(LPTSTR szInf);
void infClose(PINF pinf);
UINT_PTR FindSection(PINF pInf, LPTSTR pszSect);
LONG fnGetDataString(PINF npszData, LPTSTR szDataStr, LPTSTR szBuf, size_t cchBuf);
PINF infSetDefault(PINF pinf);
PINF infFindSection(PINF pinf, LPTSTR szSection);
LONG infGetProfileString(PINF pinf, LPTSTR szSection, LPTSTR szItem, LPTSTR szBuf, size_t cchBuf);
LONG infParseField(PINF szData, int n, LPTSTR szBuf, size_t cchBuf);
int infLineCount(PINF pinf);
PINF infNextLine(PINF pinf);
int infLineCount(PINF pinf);
PINF infFindInstallableDriversSection(PINF pinf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\midi.c ===
/*==========================================================================*/
//
//  midi.c
//
//  Copyright (C) 1993-1994 Microsoft Corporation.  All Rights Reserved.
/*==========================================================================*/

#include "mmcpl.h"
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <cpl.h> 
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <string.h>
#include <memory.h>
#include <regstr.h>
#include "draw.h"
#include "utils.h"
#include "roland.h"

#include "midi.h"
#include "tchar.h"

//#include "newexe.h"
#include <winnt.h>

#if defined DEBUG || defined DEBUG_RETAIL
 extern TCHAR szNestLevel[];
 TCHAR szNestLevel[] = TEXT ("0MidiProp:");
 #define MODULE_DEBUG_PREFIX szNestLevel
#endif

#define _INC_MMDEBUG_CODE_ TRUE
#include "mmdebug.h"

#include "medhelp.h"

#ifndef TVIS_ALL
#define TVIS_ALL 0xFF7F // internal
#endif

#ifndef MIDI_IO_CONTROL
#define MIDI_IO_CONTROL 0x00000008L     // internal
#endif

#ifndef DRV_F_ADD       // FEATURE: These should be in MMDDK.H
#define DRV_F_ADD                0x00000000
#define DRV_F_REMOVE             0x00000001
#define DRV_F_CHANGE             0x00000002
#define DRV_F_PROP_INSTR         0x00000004
#define DRV_F_NEWDEFAULTS        0x00000008
#define DRV_F_PARAM_IS_DEVNODE   0x10000000
#endif

/*==========================================================================*/

// containing struct for what would otherwise be global variables
//
struct _globalstate gs;

// this is the registry key that has midi instrument aliases
// as subkeys
//
SZCODE cszSchemeRoot[] =  REGSTR_PATH_PRIVATEPROPERTIES TEXT ("\\MIDI\\Schemes");

SZCODE cszMidiMapRoot[] = REGSTR_PATH_MULTIMEDIA TEXT ("\\MIDIMap");

// this is the registry key that has midi driver/port names
//
SZCODE cszDriversRoot[] = REGSTR_PATH_MEDIARESOURCES TEXT ("\\MIDI");

// this is the list of known hindered midi drivers (or rather,
// known drivers that require special idf's)
//
SZCODE cszHinderedMidiList[] = REGSTR_PATH_MEDIARESOURCES TEXT ("\\NonGeneralMIDIDriverList");

SZCODE  cszFriendlyName[]     = TEXT ("FriendlyName");
SZCODE  cszDescription[]      = TEXT ("Description");
SZCODE  cszSlashInstruments[] = TEXT ("\\Instruments");
SZCODE  cszExternal[]         = TEXT ("External");
SZCODE  cszActive[]           = TEXT ("Active");
SZCODE  cszDefinition[]       = TEXT ("Definition");
SZCODE  cszPort[]             = TEXT ("Port");
SZCODE  cszMidiSlash[]        = TEXT ("midi\\");
SZCODE  csz02d[]              = TEXT ("%02d");
SZCODE  cszEmpty[]            = TEXT ("");

static SZCODE cszChannels[]            = TEXT ("Channels");
static SZCODE cszCurrentScheme[]       = TEXT ("CurrentScheme");
static SZCODE cszCurrentInstrument[]   = TEXT ("CurrentInstrument");
static SZCODE cszUseScheme[]           = TEXT ("UseScheme");
static SZCODE cszAutoScheme[]          = TEXT ("AutoScheme");
static SZCODE cszRunOnceCount[]        = TEXT ("ConfigureCount");
static SZCODE cszDriverList[]          = TEXT ("DriverList");
static SZCODE cszDriverVal[]           = TEXT ("Driver");

//
// structures used to hold data for the control panel dialogs.
//
//
typedef struct _midi_scheme {
    PMCMIDI  pmcm;
    HKEY     hkSchemes;
    TCHAR    szNone[MAX_ALIAS];
    DWORD    dwChanMask;
    TCHAR    szName[MAX_ALIAS];
    UINT     nChildren;
    BOOL     bDirty;
    struct {
	PINSTRUM  pi;
	DWORD     dwMask;
	} a[NUM_CHANNEL*4 +1];
    } MSCHEME, * PMSCHEME;

typedef struct _midi_cpl {
    LPPROPSHEETPAGE ppsp;

    MSCHEME         ms;
    TCHAR           szScheme[MAX_ALIAS];
    TCHAR           szDefault[MAX_ALIAS];
    PINSTRUM        piSingle;
    BOOL            bUseScheme;
    BOOL            bAutoScheme;  // TRUE if scheme was auto created
    DWORD           dwRunCount;   // counts the number of times runonce
    LPTSTR           pszReason;    // reason for choosing external port
    BOOL            bDlgType2;
    BOOL            bPastInit;
    BOOL            bIgnoreSelChange;

    MCMIDI          mcm;

    } MCLOCAL, * PMCLOCAL;

BOOL WINAPI ShowDetails (
    HWND     hWnd,
    PMCLOCAL pmcl);

LONG SHRegDeleteKey(HKEY hKey, LPCTSTR lpSubKey);

static UINT
DeviceIDFromDriverName(
    PTSTR pstrDriverName);

extern BOOL AccessServiceController(void);

/*+ SimulateNotify
 *
 *-=================================================================*/

STATICFN LRESULT SimulateNotify (
    HWND hWnd,
    WORD uId,
    WORD wNotify)
{
    #ifdef _WIN32
     return SendMessage (hWnd, WM_COMMAND,
			 MAKELONG(uId, wNotify),
			 (LPARAM)GetDlgItem (hWnd, uId));
    #else
    #error this code is not designed for 16 bits
    #endif
}


/*+ Confirm
 *
 *-=================================================================*/

STATICFN UINT Confirm (
    HWND    hWnd,
    UINT    idQuery,
    LPTSTR  pszArg)
{
    TCHAR szQuery[255];
    TCHAR sz[255];

    LoadString (ghInstance, idQuery, sz, NUMELMS(sz));
    wsprintf (szQuery, sz, pszArg);

    LoadString (ghInstance, IDS_DEF_CAPTION, sz, NUMELMS(sz));

    return MessageBox (hWnd, szQuery, sz, MB_YESNO | MB_ICONQUESTION);
}


/*+ TellUser
 *
 *-=================================================================*/

STATICFN UINT TellUser (
    HWND    hWnd,
    UINT    idQuery,
    LPTSTR  pszArg)
{
    TCHAR szQuery[255];
    TCHAR sz[255];

    LoadString (ghInstance, idQuery, sz, NUMELMS(sz));
    wsprintf (szQuery, sz, pszArg);

    LoadString (ghInstance, IDS_DEF_CAPTION, sz, NUMELMS(sz));

    return MessageBox (hWnd, szQuery, sz, MB_OK | MB_ICONINFORMATION);
}



/*+ ForwardBillNotify
 *
 *-=================================================================*/

STATICFN void ForwardBillNotify (
    HWND  hWnd,
    NMHDR FAR * lpnm)
{
    static struct {
	UINT code;
	UINT uId;
	} amap[] = {PSN_KILLACTIVE, IDOK,
		    PSN_APPLY,      ID_APPLY,
		    PSN_SETACTIVE,  ID_INIT,
		    PSN_RESET,      IDCANCEL,
		    };
    UINT ii;

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("ForwardBillNotify() code = %X\r\n"), lpnm->code);
#endif

    for (ii = 0; ii < NUMELMS(amap); ++ii)
	if (lpnm->code == amap[ii].code)
	{
	    FORWARD_WM_COMMAND (hWnd, amap[ii].uId, 0, 0, SendMessage);
	    break;
	}
    return;
}


/*+
 *
 *-=================================================================*/

STATICFN void EnumChildrenIntoCombo (
    HWND   hWndT,
    LPTSTR pszSelect,
    HKEY   hKey)
{
    TCHAR  sz[MAX_ALIAS];
    DWORD  cch = sizeof(sz)/sizeof(TCHAR);
    UINT   ii = 0;

    //SetWindowRedraw (hWndT, FALSE);
    ComboBox_ResetContent (hWndT);

    if (!hKey)
	return;

    while (RegEnumKey (hKey, ii, sz, cch) == ERROR_SUCCESS)
    {
	int ix = ComboBox_AddString (hWndT, sz);
	//ComboBox_SetItemData (hWndT, ix, ii);
	++ii;
    }

    ii = 0;
    if (pszSelect)
       ii = ComboBox_FindString (hWndT, -1, pszSelect);

    ComboBox_SetCurSel (hWndT, ii);
}

STDAPI_(BOOL) QueryGSSynth(LPTSTR pszDriver)
{
    MIDIOUTCAPS moc;
    MMRESULT    mmr;
    UINT        mid;
    BOOL        fGSSynth = FALSE;

    
    if (pszDriver)
    {
        mid = DeviceIDFromDriverName(pszDriver);

        if (mid!=(UINT)-1)
        {
            mmr = midiOutGetDevCaps(mid, &moc, sizeof(moc));

            if (MMSYSERR_NOERROR == mmr)
            {
                if ((moc.wMid == MM_MICROSOFT) && (moc.wPid == MM_MSFT_WDMAUDIO_MIDIOUT) && (moc.wTechnology == MOD_SWSYNTH))
                {
                    fGSSynth = TRUE;
                } //end if synth
            } //end if no mm error
        } //end if mid is valid
    } //end if driver is valid string

    return(fGSSynth);
}

/*+
 *
 *-=================================================================*/

LONG WINAPI GetAlias (
    HKEY   hKey,
    LPTSTR szSub,
    LPTSTR pszAlias,
    DWORD  cchAlias,
    BOOL * pbExtern,
    BOOL * pbActive)
{
    LONG  lRet;
    DWORD cbSize;
    HKEY  hkSub;
    DWORD dw;

#ifdef DEBUG
    AuxDebugEx (8, DEBUGLINE TEXT ("GetAlias(%08x,'%s',%08x,%d,%08x)\r\n"),
		hKey, szSub, pszAlias, cchAlias, pbExtern);
#endif

    if (!(lRet = RegOpenKeyEx (hKey, szSub, 0, KEY_QUERY_VALUE, &hkSub)))
    {
	cbSize = cchAlias * sizeof (TCHAR);
	if ((lRet = RegQueryValueEx (hkSub, cszFriendlyName, NULL, &dw, (LPBYTE)pszAlias, &cbSize)) || cbSize <= 2)
	{
	    cbSize = cchAlias * sizeof (TCHAR);
	    if ((lRet = RegQueryValueEx (hkSub, cszDescription, NULL, &dw, (LPBYTE)pszAlias, &cbSize)) || cbSize <= 2)
	    {
		TCHAR szDriver[MAXSTR];

		cbSize = sizeof(szDriver);
		if (!RegQueryValueEx(hkSub, cszDriverVal, NULL, &dw, (LPBYTE)szDriver, &cbSize))
		{
		    LoadVERSION();
		    if (!LoadDesc(szDriver, pszAlias))
			lstrcpy(pszAlias, szDriver);
		    FreeVERSION();

		    cbSize = (lstrlen(pszAlias)+1) * sizeof(TCHAR);
		    RegSetValueEx(hkSub, cszFriendlyName, (DWORD)0, REG_SZ, (LPBYTE)pszAlias, cbSize);
		    RegSetValueEx(hkSub, cszDescription, (DWORD)0, REG_SZ, (LPBYTE)pszAlias, cbSize);
		}
		else
		    pszAlias[0] = 0;
	    }
	}

	if (pbExtern)
	{
	    *pbExtern = 0;
	    cbSize = sizeof(*pbExtern);
	    if (!(lRet = RegQueryValueEx (hkSub, cszExternal, NULL, &dw, (LPBYTE)pbExtern, &cbSize)))
	    {
		if (REG_SZ == dw)
		    *pbExtern = (*(LPTSTR)pbExtern == TEXT('0')) ? FALSE : TRUE;
	    }
	}

	if (pbActive)
	{
	    *pbActive = 0;
	    cbSize = sizeof(*pbActive);
	    if (!(lRet = RegQueryValueEx (hkSub, cszActive, NULL, &dw, (LPBYTE)pbActive, &cbSize)))
	    {
		if (REG_SZ == dw)
		    *pbActive = (*(LPTSTR)pbActive == TEXT('1')) ? TRUE : FALSE;
	    }
	}

	RegCloseKey (hkSub);
    }

   #ifdef DEBUG
    if (lRet)
    {
	TCHAR szErr[MAX_PATH];

	FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS, NULL, lRet, 0,
		      szErr, NUMELMS(szErr), NULL);

#ifdef DEBUG
	AuxDebugEx (1, DEBUGLINE TEXT ("GetAlias failed: %d %s\r\n"), lRet, szErr);
#endif
    }
   #endif

    return lRet;
}


/*+
 *
 *-=================================================================*/

LONG WINAPI GetDriverFilename (
    HKEY    hKey,
    LPTSTR  szSub,
    LPTSTR  pszDriver,
    DWORD   cchDriver)
{
    HKEY  hkSub;
    LONG  lRet;

    if (!(lRet = RegOpenKeyEx (hKey, szSub, 0, KEY_QUERY_VALUE, &hkSub)))
    {
       DWORD dwType;
       TCHAR sz[MAX_PATH];
       UINT  cb = sizeof(sz);

       // get the contents of the 'driver' value of the given key.
       // then copy the filename part
       //
       lRet = RegQueryValueEx(hkSub, cszDriverVal, NULL, &dwType, (LPBYTE)sz, &cb);
       if (lRet || dwType != REG_SZ)
	   *pszDriver = 0;
       else
       {
	   LPTSTR psz = sz;
	   UINT   ii;

	   // scan forward till we get to the file part of the pathname
	   // then copy that part into the supplied buffer
	   //
	   for (ii = 0; psz[ii]; )
	   {
		if (psz[ii] == TEXT('\\') || psz[ii] == TEXT(':'))
		{
		    psz += ii+1;
		    ii = 0;
		}
		else
		    ++ii;
	   }
	   lstrcpyn (pszDriver, psz, cchDriver);
       }
       RegCloseKey (hkSub);
    }
    return lRet;
}


/*+ LoadInstruments
 *
 * load interesting data for all instruments, if bDriverAsAlias
 * is true, then put driver filename in szFriendly field of each
 * instrument. (scheme init uses this for hindered driver detection)
 * if !bDriverAsAlias, put friendly name in friendly name slot
 *
 *
 *-=================================================================*/

void WINAPI LoadInstruments (
    PMCMIDI pmcm,
    BOOL    bDriverAsAlias)
{
    HKEY     hkMidi;
    TCHAR    sz[MAX_ALIAS];
    DWORD    cch = sizeof(sz)/sizeof(TCHAR);
    UINT     ii;
    UINT     nInstr;
    PINSTRUM pi;
    UINT     idxPort = 0;

    pmcm->nInstr = 0;
    pmcm->bHasExternal = FALSE;

    if (!(hkMidi = pmcm->hkMidi))
    {
	if (RegCreateKey (HKEY_LOCAL_MACHINE, cszDriversRoot, &hkMidi))
	    return;
	pmcm->hkMidi = hkMidi;
    }

    if (!(pi = pmcm->api[0]))
    {
	pmcm->api[0] = pi = (LPVOID)LocalAlloc (LPTR, sizeof(*pi));
	if (!pi)
	    return;
    }

    for (cch = sizeof(pi->szKey)/sizeof(TCHAR), nInstr = 0, ii = 0;
	 ! RegEnumKey (hkMidi, ii, pi->szKey, cch);
	 ++ii)
    {
	UINT        jj;
	HKEY        hkInst;
	PINSTRUM    piParent;
	BOOL        bActive = FALSE;

	// get driver alias, external, and active flags.  This has the side
	// effect of initializing the friendly name key for legacy drivers
	// that have neither friendly name, nor description
	//
	GetAlias (hkMidi, pi->szKey, pi->szFriendly, 
		  NUMELMS(pi->szFriendly), &pi->bExternal, &bActive);

	// if requested, stomp friendly name with driver filename
	//
	if (bDriverAsAlias)
	    GetDriverFilename (hkMidi, pi->szKey, 
			       pi->szFriendly, NUMELMS(pi->szFriendly));

    pi->fGSSynth = QueryGSSynth(pi->szKey);
    pi->uID = idxPort;

	if (pi->bExternal)
	    pmcm->bHasExternal = TRUE;

	pi->piParent = 0;
	pi->bActive = bActive;
	piParent = pi;

	++nInstr;
	if (nInstr >= NUMELMS(pmcm->api))
	{
	    assert2 (0, TEXT ("Tell JohnKn to make midi instrument table bigger"));
	    break;
	}

	if (!(pi = pmcm->api[nInstr]))
	{
	    pmcm->api[nInstr] = pi = (LPVOID)LocalAlloc (LPTR, sizeof(*pi));
	    if (!pi)
		break;
	}

	// open the parent's instruments subkey
	//
	lstrcpy (sz, piParent->szKey);
	lstrcat (sz, cszSlashInstruments);
	if (RegCreateKey (hkMidi, sz, &hkInst))
	    continue;

	// enum the instruments and add them to the list
	//
	for (jj = 0; ! RegEnumKey (hkInst, jj, sz, cch); ++jj)
	{
	    lstrcpy (pi->szKey, piParent->szKey);
	    lstrcat (pi->szKey, cszSlashInstruments);
	    lstrcat (pi->szKey, cszSlash);
	    lstrcat (pi->szKey, sz);

	    GetAlias (hkInst, sz, pi->szFriendly, 
		      NUMELMS(pi->szFriendly), NULL, NULL);
	    pi->piParent = piParent;
	    pi->bExternal = FALSE;
	    pi->bActive = bActive;

	    ++nInstr;
	    if (nInstr >= NUMELMS(pmcm->api))
	    {
		assert2 (0, TEXT ("Tell JohnKn to make midi instrument table bigger"));
		break;
	    }

	    if (!(pi = pmcm->api[nInstr]))
	    {
		pmcm->api[nInstr] = pi = (LPVOID)LocalAlloc (LPTR, sizeof(*pi));
		if (!pi)
		    break;
	    }
	}

	RegCloseKey (hkInst);
    }

    // create a 'none' entry at the end
    //
    if (pi)
    {
	pi->piParent = 0;
	pi->bExternal = FALSE;
	pi->bActive = TRUE;
	pi->szKey[0] = 0;
	LoadString (ghInstance, IDS_NONE, pi->szFriendly, NUMELMS(pi->szFriendly));
	++nInstr;
    }

    pmcm->nInstr = nInstr;
}


/*+
 *
 *-=================================================================*/

void WINAPI FreeInstruments (
    PMCMIDI pmcm)
{
    UINT ii;

    for (ii = 0; ii < NUMELMS (pmcm->api); ++ii)
	if (pmcm->api[ii])
	    LocalFree ((HLOCAL)(PVOID)pmcm->api[ii]), pmcm->api[ii] = NULL;

    pmcm->nInstr = 0;
}



#ifdef DEBUG
/*+ CleanStringCopy
 *
 * Replaces unprintable characters with '.'
 *
 *-=================================================================*/

STATICFN LPTSTR CleanStringCopy (
    LPTSTR pszOut,
    LPTSTR pszIn,
    UINT   cbOut)
{
    LPTSTR psz = pszOut;
    while (cbOut && *pszIn)
    {
	*psz = (*pszIn >= 32 && *pszIn < 127) ? *pszIn : TEXT('.');
	++psz;
	++pszIn;
    }

    *psz = 0;
    return pszOut;
}


/*+ DumpInstruments
 *
 *-=================================================================*/

STATICFN void DumpInstruments (
    PMCMIDI pmcm)
{
    UINT     ii;
    PINSTRUM pi;

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("DumpInstruments(%08x) nInstr=%d\r\n"),
		pmcm, pmcm->nInstr);
#endif

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
	TCHAR szKey[MAX_ALIAS];
	TCHAR szFriendly[MAX_ALIAS];

	pi = pmcm->api[ii];
	if (!pi)
	{
#ifdef DEBUG
	    AuxDebugEx (2, TEXT ("\tapi[%d] NULL\r\n"), ii);
#endif
	    continue;
	}

	CleanStringCopy (szKey, pi->szKey, NUMELMS(szKey));
	CleanStringCopy (szFriendly, pi->szFriendly, NUMELMS(szFriendly));

#ifdef DEBUG
	AuxDebugEx (3, TEXT ("\tapi[%d]%08X p:%08x x:%d a:%d '%s' '%s'\r\n"),
		    ii, pi, pi->piParent,
		    pi->bExternal, pi->bActive,
		    szKey, szFriendly);
#endif
    }
}
#endif


/*+
 *
 *-=================================================================*/

STATICFN PINSTRUM WINAPI FindInstrumPath (
    PMCMIDI pmcm,
    LPTSTR   pszPath)
{
    UINT  ii;

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
	assert (pmcm->api[ii]);
	if (IsSzEqual(pszPath, pmcm->api[ii]->szKey))
	    return pmcm->api[ii];
    }

    return NULL;
}


/*+
 *
 *-=================================================================*/

PINSTRUM WINAPI FindInstrumentFromKey (
    PMCMIDI  pmcm,
    LPTSTR   pszKey)
{
    UINT  ii;

    if (!pszKey || !pszKey[0])
	return NULL;

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
	assert (pmcm->api[ii]);
	if (IsSzEqual(pszKey, pmcm->api[ii]->szKey))
	    return pmcm->api[ii];
    }

    return NULL;
}



/*+
 *
 *-=================================================================*/

STATICFN void LoadInstrumentsIntoCombo (
    HWND     hWnd,
    UINT     uId,
    PINSTRUM piSelect,
    PMCMIDI  pmcm)
{
    HWND   hWndT = GetDlgItem (hWnd, uId);
    UINT   ii;
    int    ix;

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("LoadInstrumentsIntoCombo(%08X,%d,%08x,%08x)\r\n"),
		hWnd, uId, piSelect, pmcm);
#endif

    assert (hWndT);
    if (!hWndT)
	return;

    if (pmcm->nInstr > 0)
	SetWindowRedraw (hWndT, FALSE);
    ComboBox_ResetContent(hWndT);

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
	if (ii == pmcm->nInstr-1)
	   SetWindowRedraw (hWndT, TRUE);

	if (pmcm->api[ii]->bActive
       #ifdef EXCLUDE_EXTERNAL
	    && !pmcm->api[ii]->bExternal
       #endif
	   )
	{
#ifdef DEBUG
	    AuxDebugEx (7, DEBUGLINE TEXT ("Instrument[%d] = '%s'\r\n"),
			ii, pmcm->api[ii]->szFriendly);
#endif

	    ix = ComboBox_AddString (hWndT, pmcm->api[ii]->szFriendly);
	    ComboBox_SetItemData (hWndT, ix, (LPARAM)pmcm->api[ii]);

	    if (piSelect && pmcm->api[ii] == piSelect)
		ComboBox_SetCurSel (hWndT, ix);
	}
    }
}


/*+
 *
 *-=================================================================*/

STATICFN void LoadInstrumentsIntoTree (
    HWND     hWnd,
    UINT     uId,
    UINT     uIdSingle,
    PINSTRUM piSelect,
    PMCLOCAL pmcl)
{
    PMCMIDI   pmcm = &pmcl->mcm;
    HWND      hWndT = GetDlgItem (hWnd, uId);
    UINT      ii;
    HTREEITEM htiSelect = NULL;
    HTREEITEM htiParent = TVI_ROOT;

    assert (hWndT);
    if (!hWndT)
	return;

    #ifdef UNICODE
    TreeView_SetUnicodeFormat(hWndT,TRUE);
    #endif

    //if (pmcm->nInstr > 0)
    //    SetWindowRedraw (hWndT, FALSE);
    pmcl->bIgnoreSelChange = TRUE;
#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("tv_DeleteAllItems(%08X)\r\n"), hWndT);
#endif
    TreeView_DeleteAllItems(hWndT);
#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("tv_DeleteAllItems(%08X) ends\r\n"), hWndT);
#endif

    pmcl->bIgnoreSelChange = FALSE;

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
	PINSTRUM        pi = pmcm->api[ii];
	TV_INSERTSTRUCT ti;
	HTREEITEM       hti;

	//if (ii == pmcm->nInstr-1)
	//   SetWindowRedraw (hWndT, TRUE);

	if (!pi->szKey[0] || !pi->bActive)
	    continue;

	ZeroMemory (&ti, sizeof(ti));

	ti.hParent = TVI_ROOT;
	if (pi->piParent)
	    ti.hParent = htiParent;

	ti.hInsertAfter   = TVI_SORT;
	ti.item.mask      = TVIF_TEXT | TVIF_STATE | TVIF_PARAM;

	// TV_ITEM may not be ported to UNICODE ?!?
	ti.item.pszText   = pi->szFriendly;
	ti.item.state     = TVIS_EXPANDED;
	ti.item.stateMask = TVIS_ALL;
	ti.item.lParam    = (LPARAM)pi;

	hti = TreeView_InsertItem (hWndT, &ti);

	if (piSelect && (piSelect == pi))
	   htiSelect = hti;

	if ( ! pi->piParent)
	    htiParent = hti;
    }

    // if a 'single' control id has been specified, propagate
    // selected item text into this control
    //
    if (uIdSingle)
    {
	if (htiSelect)
	{
	    assert (piSelect);
	    TreeView_SelectItem (hWndT, htiSelect);
	    SetDlgItemText (hWnd, uIdSingle, piSelect->szFriendly);
        EnableWindow(GetDlgItem(hWnd, IDC_ABOUTSYNTH), piSelect->fGSSynth);
	}
	else
	    SetDlgItemText (hWnd, uIdSingle, cszEmpty);
    }

}


/*+
 *
 *-=================================================================*/

STATICFN void LoadSchemesIntoCombo (
    HWND     hWnd,
    UINT     uId,
    LPTSTR   pszSelect,
    PMSCHEME pms)
{
    HWND  hWndT = GetDlgItem (hWnd, uId);
    HKEY  hKey;

    assert (hWndT);
    if (!hWndT)
	return;

    hKey = pms->hkSchemes;
    if (!hKey &&
	!RegCreateKey (HKEY_LOCAL_MACHINE, cszSchemeRoot, &hKey))
	pms->hkSchemes = hKey;

    EnumChildrenIntoCombo (hWndT, pszSelect, hKey);
}


/*+ ChildKeyExists
 *
 * given an open registry key, and the name of a child of that
 * registry key,  returns true if a child key with the given
 * name exists.
 *
 *-=================================================================*/

STATICFN BOOL ChildKeyExists (
    HKEY     hKey,
    LPTSTR   pszChild)
{
    TCHAR  sz[MAX_ALIAS];
    UINT   ii;

    if (!hKey)
	return FALSE;

    for (ii = 0; ! RegEnumKey (hKey, ii, sz, sizeof(sz)/sizeof(TCHAR)); ++ii)
    {
	if (IsSzEqual (pszChild, sz))
	    return TRUE;
    }

    return FALSE;
}


/*+ LoadSchemeFromReg
 *
 *-=================================================================*/

STATICFN void LoadSchemeFromReg (
    PMCMIDI   pmcm,
    PMSCHEME  pms,
    LPTSTR    pszName)
{
    HKEY  hKey;
    DWORD dwAccum;
    UINT  count;

    // try to open the indicated scheme key in the registry
    // and read channel map from it.  Failure here is permissible.
    // it indicates that we are createing a new scheme.
    //
    count = 0;
    if (RegOpenKey (pms->hkSchemes, pszName, &hKey) == ERROR_SUCCESS)
    {
	DWORD cb;
	TCHAR sz[MAX_ALIAS];

	while (RegEnumKey (hKey, count, sz, sizeof(sz)/sizeof(TCHAR)) == ERROR_SUCCESS)
	{
	    HKEY  hKeyA;
	    DWORD dwType;

	    if (RegOpenKey (hKey, sz, &hKeyA) != ERROR_SUCCESS)
		    break;

	    pms->a[count].pi = NULL;
	    cb = sizeof(sz);
	    if ( ! RegQueryValue (hKeyA, NULL, sz, &cb))
		    pms->a[count].pi = FindInstrumPath (pmcm, sz);

	    pms->a[count].dwMask = 0;
	    cb = sizeof(pms->a[count].dwMask);
	    RegQueryValueEx (hKeyA, cszChannels, NULL,
			     &dwType, (LPBYTE)&pms->a[count].dwMask, &cb);

	    assert (dwType == REG_DWORD);

	    RegCloseKey (hKeyA);

        // Don't allow empty entries
	    //assert (pms->a[ii].dwMask);
        if (0 == pms->a[count].dwMask)
        {
    	    pms->a[count].pi = NULL;
        }
        
        ++count;

#ifdef DEBUG
	    AuxDebugEx (4, DEBUGLINE TEXT ("[%d]Chan %08X Alias '%s'\r\n"),
			count, pms->a[count].dwMask, pms->a[count].pi
					       ? pms->a[count].pi->szFriendly
					       : TEXT ("(null)"));
#endif
	    if (count == NUMELMS(pms->a) -1)
		    break;
	}

	RegCloseKey (hKey);
    }
    pms->nChildren = count;
    lstrcpyn (pms->szName, pszName, NUMELMS(pms->szName));

    // slam a dummy (none) alias that matches all channels
    // at the end of our channel/alias list
    //
    assert (count < NUMELMS(pms->a));
    pms->a[count].dwMask = (DWORD)~0;
    pms->a[count].pi = NULL;

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("[%d]Chan %08X Alias '%s'\r\n"),
		count, pms->a[count].dwMask, "null");
#endif

    // make sure scheme channel masks are in a valid state
    //
    for (dwAccum = 0, count = 0; count < NUMELMS(pms->a); ++count)
    {
	pms->a[count].dwMask &= ~dwAccum;
	dwAccum |= pms->a[count].dwMask;
    }

    return;
}


/*+ KickMapper
 *
 *-=================================================================*/


void WINAPI KickMapper (
    HWND hWnd)
{
    HMIDIOUT  hmo;

    if (! midiOutOpen(&hmo, MIDI_MAPPER, 0, 0, MIDI_IO_CONTROL))
    {
	BOOL bDone;

#ifdef DEBUG
	AuxDebugEx (2, DEBUGLINE TEXT ("Kicking Midi Mapper\r\n"));
#endif

	bDone = midiOutMessage(hmo, DRVM_MAPPER_RECONFIGURE, 0, DRV_F_PROP_INSTR);
	
	midiOutClose(hmo);
    /*
    //no longer necessary due to winmm change allowing configure during play
	if (!bDone && hWnd)
	    TellUser (hWnd, IDS_MAPPER_BUSY, NULL);
    */
    }

#ifdef DEBUG
    AuxDebugEx (2, DEBUGLINE TEXT ("Done Kicking Midi Mapper\r\n"));
#endif
}


/*+ SaveSchemeToReg
 *
 *-=================================================================*/

STATICFN void SaveSchemeToReg (
    PMCMIDI   pmcm,
    PMSCHEME  pms,
    LPTSTR    pszName,
    HWND      hWnd)
{
    TCHAR sz[MAX_ALIAS];
    HKEY  hKey;
    DWORD dwAccum;
    UINT  ii;
    UINT  kk;
    UINT  cb;

    #ifdef DEBUG
     AuxDebugEx (4, DEBUGLINE TEXT ("Saving Scheme '%s' children=%d\r\n"),
		 pszName, pms->nChildren);
     for (ii = 0; ii < NUMELMS(pms->a); ++ii)
     {
	 AuxDebugEx (4, TEXT ("\t%08X '%s'\r\n"),
		     pms->a[ii].dwMask,
		     pms->a[ii].pi ? pms->a[ii].pi->szKey : TEXT ("(null)"));
     }
    #endif

    // make sure scheme channel masks are in a valid state,
    // that is, prevent a channel bit from being set in more
    // than one member of a scheme
    //
    for (dwAccum = 0, ii = 0; ii < NUMELMS(pms->a); ++ii)
    {
	pms->a[ii].dwMask &= ~dwAccum;
	dwAccum |= pms->a[ii].dwMask;
    }

    // try to open/create the indicated scheme key in the registry
    // and write/update channel map to it.
    //
    if (!RegCreateKey (pms->hkSchemes, pszName, &hKey))
    {
	HKEY  hKeyA;
	BOOL  bKill;

	// salvage all of the existing keys that we can. delete
	// the rest.
	//
	for (dwAccum = 0, ii = 0; !RegEnumKey (hKey, ii, sz, sizeof(sz)/sizeof(TCHAR)); ++ii)
	{
	    if (ii >= NUMELMS(pms->a))
		break;

	    // we reuse the first N keys in this scheme
	    // and delete the rest.
	    //
	    bKill = TRUE;
	    if (((dwAccum & 0xFFFF) != 0xFFFF) &&
		pms->a[ii].pi &&
		(!ii || (pms->a[ii].pi->szKey[0] && pms->a[ii].dwMask)))
	       bKill = FALSE;

	    dwAccum |= pms->a[ii].dwMask;

	    // if we have an obsolete alias key, remove it now
	    // otherwise create/open the alias key and set it's
	    // channel property to the correct value.
	    //
	    if (bKill)
	    {
#ifdef DEBUG
		AuxDebugEx (3, DEBUGLINE TEXT ("Deleting key[%d] '%s'\r\n"), ii, sz);
#endif
		RegDeleteKey (hKey, sz);
	    }
	    else
	    {
#ifdef DEBUG
		AuxDebugEx (3, DEBUGLINE TEXT ("Reusing key[%d] '%s'\r\n"), ii, pms->a[ii].pi->szKey);
#endif
		if (RegOpenKeyEx (hKey, sz, 0, KEY_ALL_ACCESS, &hKeyA))
		    break;


		cb = (lstrlen(pms->a[ii].pi->szKey) + 1) * sizeof(TCHAR);
		RegSetValueEx (hKeyA, NULL, 0, REG_SZ,
			       (LPBYTE)(pms->a[ii].pi->szKey), cb);

		RegSetValueEx (hKeyA, cszChannels, 0,
			       REG_DWORD,
			       (LPBYTE)&pms->a[ii].dwMask,
			       sizeof(DWORD));

		RegCloseKey (hKeyA);
	    }

	}

	// if we have channels that have not yet been written.
	// do that now
	//
	for (kk = 0; ii < NUMELMS(pms->a); ++ii)
	{
	    // if this alias has any assigned channels, create
	    // a key and give it a channels value
	    //
	    if (pms->a[ii].pi &&
		(!ii || (pms->a[ii].pi->szKey[0] && pms->a[ii].dwMask)))
	    {
#ifdef DEBUG
		AuxDebugEx (3, DEBUGLINE TEXT ("Creating key[%d] '%s'\r\n"), ii, pms->a[ii].pi->szKey);
#endif
		// find an unused keyname;
		//
		for ( ; kk < NUMELMS(pms->a); ++kk)
		{
		   wsprintf (sz, csz02d, kk);
		   if (RegOpenKey (hKey, sz, &hKeyA))
		       break;
		   RegCloseKey (hKeyA);
		}

		// create a key with that name
		//
		if (RegCreateKey (hKey, sz, &hKeyA))
		    break;

		cb = (lstrlen(pms->a[ii].pi->szKey) + 1) * sizeof(TCHAR);
		RegSetValueEx (hKeyA, NULL, 0, REG_SZ,
			       (LPBYTE)(pms->a[ii].pi->szKey),cb);

#ifdef DEBUG
		AuxDebugEx (3, DEBUGLINE TEXT ("Setting Channel Value %08X\r\n"), pms->a[ii].dwMask);
#endif
		RegSetValueEx (hKeyA, cszChannels, 0,
			       REG_DWORD,
			       (LPBYTE)&pms->a[ii].dwMask,
			       sizeof(DWORD));

		RegCloseKey (hKeyA);
	    }
	}

	RegCloseKey (hKey);
    }

    // if no HWND supplied, we are in the runonce, so we dont
    // want to kick mapper just because a scheme has changed
    //
    if (hWnd)
       KickMapper (hWnd);
    return;
}


/*+ DeleteSchemeFromReg
 *
 *-=================================================================*/

STATICFN void DeleteSchemeFromReg (
    HKEY      hkSchemes,
    LPTSTR    pszName)
{
    TCHAR sz[MAX_ALIAS];
    HKEY  hKey;
    UINT  ii;

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("DeletingSchemeFromReg(%08X,'%s')\r\n"),
		hkSchemes,pszName);
#endif
    SHRegDeleteKey(hkSchemes, pszName);
/*
    // if we cannot open this key as a child of the 'schemes' key
    // we are done.
    //
    if (RegOpenKey (hkSchemes, pszName, &hKey))
	return;

    // Before we can delete a key, we must delete its children
    //
    for (ii = 0; !RegEnumKey (hKey, ii, sz, sizeof(sz)/sizeof(TCHAR)); ++ii)
    {
	// if we have an obsolete alias key, remove it now
	// otherwise create/open the alias key and set it's
	// channel property to the correct value.
	//
	AuxDebugEx (3, DEBUGLINE TEXT ("Deleting key[%d] '%s'\r\n"), ii, sz);
	RegDeleteKey (hKey, sz);
    }

    RegCloseKey (hKey);

    // now delete this key
    //
    RegDeleteKey (hkSchemes, pszName);
    return;
*/
}


/*+
 *
 *-=================================================================*/

STATICFN void LoadChannelsIntoList (
    HWND     hWnd,
    UINT     uId,
    UINT     uIdLabel,
    PMSCHEME pms)
{
    HWND  hWndT = GetDlgItem (hWnd, uId);
    RECT  rc;
    UINT  ii;
    UINT  nChan;
    int   nTabs;

    assert (pms);

    // empty the list
    //
    SetWindowRedraw (hWndT, FALSE);
    ListBox_ResetContent (hWndT);

    // calculate the width of the tabstop
    // so that the second column lines up under the indicated
    // label
    //
    GetWindowRect (GetDlgItem(hWnd, uIdLabel), &rc);
    nTabs = rc.left;
    GetWindowRect (hWnd, &rc);
    nTabs = MulDiv(nTabs - rc.left, 4, LOWORD(GetDialogBaseUnits()));
    ListBox_SetTabStops (hWndT, 1, &nTabs);

    // fill the list with channel data
    //
    for (nChan = 0; nChan < NUM_CHANNEL; ++nChan)
    {
	static CONST TCHAR cszDtabS[] = TEXT ("%d\t%s");
	TCHAR sz[MAX_ALIAS + 10];

	for (ii = 0; ii < NUMELMS(pms->a); ++ii)
	   if (pms->a[ii].dwMask & (1 << nChan))
	       break;
	assert (ii < NUMELMS(pms->a));

	wsprintf (sz, cszDtabS, nChan+1,
		  pms->a[ii].pi ? pms->a[ii].pi->szFriendly
					 : pms->szNone);
	if (nChan == (UINT)NUM_CHANNEL-1)
	   SetWindowRedraw (hWndT, TRUE);
	ListBox_InsertString (hWndT, nChan, sz);

	if (pms->dwChanMask & (1 << nChan))
	    ListBox_SetSel (hWndT, TRUE, nChan);
    }
}


/*+
 *
 *-=================================================================*/

/*+ ChannelMaskToEdit
 *
 * convert a bit mask to a string containing list of set bits
 * and bit ranges. Then SetWindowText the result into the given
 * edit control.
 *
 * This function loads prefix text from resource strings.
 *
 * For Example: ChannelMaskToEdit(....0x0000F0F) would set the text
 * 'Channels 1-4,9-12'.
 *
 *-=================================================================*/

STATICFN void ChannelMaskToEdit (
    HWND     hWnd,
    UINT     uId,
    DWORD    dwMask)
{
    HWND   hWndT = GetDlgItem (hWnd, uId);
    TCHAR  sz[NUM_CHANNEL * 4 + MAX_ALIAS];

    if (!dwMask)
	LoadString (ghInstance, IDS_NOCHAN, sz, NUMELMS(sz));
    else
    {
	LPTSTR psz;
	LPTSTR pszT;
	int    ii;
	int    iSpan;
	DWORD  dwLast;
	DWORD  dwBit;

	LoadString (ghInstance,
		    (dwMask & (dwMask-1)) ? IDS_CHANPLURAL : IDS_CHANSINGULAR,
		    sz, NUMELMS(sz));

	pszT = psz = sz + lstrlen(sz);

	for (ii = 0, dwBit = 1, dwLast = 0, iSpan = 0;
	     ii <= 32;
	     dwLast = dwMask & dwBit, ++ii, dwBit += dwBit)
	{
	    if ((dwMask & dwBit) ^ (dwLast + dwLast))
	    {
		static CONST TCHAR cszCommaD[] = TEXT (",%d");
		static CONST TCHAR cszDashD[] = TEXT ("-%d");

		if ( ! dwLast)
		    psz += wsprintf (psz, cszCommaD, ii+1);
		else if (iSpan)
		    psz += wsprintf (psz, cszDashD, ii);
		iSpan = 0;
	    }
	    else
		++iSpan;
	}

	*pszT = TEXT (' ');
    }

    SetWindowText (hWndT, sz);
}



/*+ MidiChangeCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiChangeCommands (
    HWND hWnd,
    UINT wId,
    HWND hWndCtl,
    UINT wNotify)
{
    PMCLOCAL pmcl = GetDlgData(hWnd);
    PMSCHEME pms = &pmcl->ms;

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("MidiChangeCommands(%08X,%d,%08X,%d)\r\n"),
		hWnd, wId, hWndCtl, wNotify);
#endif

    switch (wId)
    {
	case ID_APPLY:
	    return TRUE;

	case IDOK:
	{
	    int  ix;
	    HWND hWndT = GetDlgItem (hWnd, IDC_INSTRUMENTS);

	    ix = ComboBox_GetCurSel (hWndT);
	    if (ix >= 0)
	    {
		BOOL     bFound = FALSE;
		PINSTRUM piSel;
	BOOL     bFoundFirst = FALSE;

		piSel = (LPVOID)ComboBox_GetItemData (hWndT, ix);
		assert (!IsBadWritePtr(piSel, sizeof(*piSel)));

		// has the <none> item been selected?  in this
		// case, set stuff up so that we will not try
		// to add none to the scheme, but we will clear
		// all bits from other channels that are set
		// to none.
		//
		if ( ! piSel || ! piSel->szKey[0])
		    piSel = NULL, bFound = TRUE;

		// turn channels on for this instrument and off for
		// other instruments in this scheme.
		//
	for (ix = 0; ix < (int)NUMELMS(pms->a); ++ix)
	{
		    if (pms->a[ix].pi != piSel)
		pms->a[ix].dwMask &= ~pms->dwChanMask;
		    else if (! pms->a[ix].pi)
	    {
		if (! bFoundFirst)
		{
		    pms->a[ix].dwMask |= pms->dwChanMask;
		    bFound = TRUE;
		    bFoundFirst = TRUE;
		}
	    }
	    else
		    {
		pms->a[ix].dwMask |= pms->dwChanMask;
		bFound = TRUE;
		    }
	}

		// if this instrument was not already in the scheme,
		// find an empty slot and add it to the scheme.
		//
		if (!bFound)
	{
	    for (ix = 0; ix < (int)NUMELMS(pms->a); ++ix)
	    {
		if ( ! pms->a[ix].dwMask)
		{
		    pms->a[ix].dwMask = pms->dwChanMask;
		    pms->a[ix].pi = piSel;
		    bFound = TRUE;
		    break;
		}
	    }
	}

		assert2 (bFound, TEXT ("no room to add instrument to scheme"));
	    }
	    EndDialog (hWnd, IDOK);
	    break;
	}

	case IDCANCEL:
	    EndDialog (hWnd, IDCANCEL);
	    break;

	//
	//case ID_INIT:
	//    break;
    }

    return FALSE;
}


/*+ SaveAsDlgProc
 *
 *-=================================================================*/

const static DWORD aSaveAsHelpIds[] = {  // Context Help IDs
    IDE_SCHEMENAME,     IDH_MIDI_SAVEDLG_SCHEMENAME,

    0, 0
};

INT_PTR CALLBACK SaveAsDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
	case WM_COMMAND:
	    switch (GET_WM_COMMAND_ID(wParam, lParam))
	    {
		case IDOK:
		{
		    LPTSTR pszName = GetDlgData (hWnd);
		    assert (pszName);
		    GetDlgItemText (hWnd, IDE_SCHEMENAME, pszName, MAX_ALIAS);
		}
		// fall through
		case IDCANCEL:
		   EndDialog (hWnd, GET_WM_COMMAND_ID(wParam, lParam));
		   break;
	    }
	    break;
	
	case WM_CLOSE:
	    SendMessage (hWnd, WM_COMMAND, IDCANCEL, 0);
	    break;

	case WM_INITDIALOG:
	{
	    LPTSTR pszName = (LPVOID) lParam;
	    assert (pszName);
	    SetDlgData (hWnd, pszName);
	    SetDlgItemText (hWnd, IDE_SCHEMENAME, pszName);
	    break;
	}
    
	case WM_CONTEXTMENU:
	    WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
		    (UINT_PTR) (LPTSTR) aSaveAsHelpIds);
	    return TRUE;

	case WM_HELP:
	{
	    LPHELPINFO lphi = (LPVOID) lParam;
	    WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
		    (UINT_PTR) (LPTSTR) aSaveAsHelpIds);
	    return TRUE;
	}
    }

    return FALSE;
}



/*+ GetNewSchemeName
 *
 *-=================================================================*/

STATICFN BOOL WINAPI GetNewSchemeName (
    HWND     hWnd,
    HKEY     hkSchemes,
    LPTSTR   pszName)
{
    TCHAR szNew[MAX_ALIAS];
    UINT_PTR  uBtn;

    lstrcpyn (szNew, pszName, ARRAYSIZE(szNew));

    uBtn = DialogBoxParam (ghInstance,
			   MAKEINTRESOURCE(IDD_SAVENAME),
			   hWnd,
			   SaveAsDlgProc,
			   (LPARAM)szNew);
    if (IDOK == uBtn)
    {
	if (ChildKeyExists (hkSchemes, szNew))
	    uBtn = Confirm (hWnd, IDS_QUERY_OVERSCHEME, szNew);
	else
	    lstrcpy (pszName, szNew);
    }

    return (IDOK == uBtn || IDYES == uBtn);
}


/*+ MidiChangeDlgProc
 *
 *-=================================================================*/

const static DWORD aChngInstrHelpIds[] = {  // Context Help IDs
    IDC_INSTRUMENTS,     IDH_ADDMIDI_INSTRUMENT,
    IDC_TEXT_1,          IDH_ADDMIDI_CHANNEL,
    IDE_SHOW_CHANNELS,   IDH_ADDMIDI_CHANNEL,

    0, 0
};

INT_PTR CALLBACK MidiChangeDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
	case WM_COMMAND:
	    HANDLE_WM_COMMAND (hWnd, wParam, lParam, MidiChangeCommands);
	    break;
	
	case WM_NOTIFY:
	    ForwardBillNotify(hWnd, (NMHDR FAR *)lParam);
	    break;
	
	case WM_CLOSE:
	    SendMessage (hWnd, WM_COMMAND, IDCANCEL, 0);
	    break;

	case WM_INITDIALOG:
	{
	    PMCLOCAL pmcl = (LPVOID) lParam;
	    PMSCHEME pms = &pmcl->ms;

	    SetDlgData (hWnd, pmcl);

	    LoadInstrumentsIntoCombo (hWnd, IDC_INSTRUMENTS, NULL, &pmcl->mcm);
	    ChannelMaskToEdit (hWnd, IDE_SHOW_CHANNELS, pms->dwChanMask);
	    break;
	}

	//case WM_DESTROY:
	//    break;

	case WM_CONTEXTMENU:
	    WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
		    (UINT_PTR) (LPTSTR) aChngInstrHelpIds);
	    return TRUE;

	case WM_HELP:
	{
	    LPHELPINFO lphi = (LPVOID) lParam;
	    WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
		    (UINT_PTR) (LPTSTR) aChngInstrHelpIds);
	    return TRUE;
	}
    }

    return FALSE;
}


/*+ MidiConfigCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiConfigCommands (
    HWND hWnd,
    UINT wId,
    HWND hWndCtl,
    UINT wNotify)
{
    PMCLOCAL pmcl = GetDlgData(hWnd);
    PMSCHEME pms  = &pmcl->ms;

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("MidiConfigCommands(%08X,%d,%08X,%d)\r\n"),
		hWnd, wId, hWndCtl, wNotify);
#endif

    switch (wId)
    {
	case IDB_CHANGE:
	{
	    UINT_PTR uRet;
	    int      ii;
	    HWND     hWndList = GetDlgItem (hWnd, IDL_CHANNELS);

#ifdef DEBUG
	    AuxDebugEx (2, DEBUGLINE TEXT ("Launching Change Dialog\r\n"));
#endif
	    pms->dwChanMask = 0;
	    for (ii = 0; ii < NUM_CHANNEL; ++ii)
		 if (ListBox_GetSel (hWndList, ii))
		    pms->dwChanMask |= (1 << ii);

	    uRet = DialogBoxParam (ghInstance,
				   MAKEINTRESOURCE(IDD_MIDICHANGE),
				   hWnd,
				   MidiChangeDlgProc,
				   (LPARAM)pmcl);
	    if (uRet == IDOK)
	    {
	       LoadChannelsIntoList (hWnd, IDL_CHANNELS, IDC_TEXT_1, pms);
	       pms->bDirty = TRUE;
	    }
	    break;
	}

	case IDB_DELETE:
	    if (IsSzEqual(pmcl->szScheme, pmcl->szDefault))
	    {
		break;
	    }
	    if (Confirm (hWnd, IDS_QUERY_DELETESCHEME, pmcl->szScheme) == IDYES)
	    {
		HWND hWndCtl = GetDlgItem (hWnd, IDC_SCHEMES);
		int  ix = ComboBox_FindStringExact (hWndCtl, -1, pmcl->szScheme);
		assert (ix >= 0);

		DeleteSchemeFromReg (pms->hkSchemes, pmcl->szScheme);

		ComboBox_DeleteString (hWndCtl, ix);
		ComboBox_SetCurSel (hWndCtl, 0);
		SimulateNotify (hWnd, IDC_SCHEMES, CBN_SELCHANGE);
	    }
	    break;

	case IDB_SAVE_AS:
	    if (GetNewSchemeName (hWnd, pms->hkSchemes, pmcl->szScheme))
	    {
		SaveSchemeToReg (&pmcl->mcm, pms, pmcl->szScheme, hWnd);

		LoadSchemesIntoCombo (hWnd, IDC_SCHEMES,
				      pmcl->szScheme, pms);
	    }
	    SimulateNotify (hWnd, IDC_SCHEMES, CBN_SELCHANGE);
	    break;

	case IDC_SCHEMES:
	    if (wNotify == CBN_SELCHANGE)
	    {
		int   ix;

		ix = ComboBox_GetCurSel (hWndCtl);
		if (ix >= 0)
		    ComboBox_GetLBText (hWndCtl, ix, pmcl->szScheme);

		LoadSchemeFromReg (&pmcl->mcm, pms, pmcl->szScheme);

		pms->dwChanMask = 0;
		LoadChannelsIntoList (hWnd, IDL_CHANNELS, IDC_TEXT_1, pms);

		EnableWindow (GetDlgItem (hWnd, IDB_DELETE),
			      !IsSzEqual(pmcl->szDefault, pmcl->szScheme));
	    }
	    break;

	case IDL_CHANNELS:
	    if (wNotify == LBN_SELCHANGE)
	    {
		int ix;

		ix = ListBox_GetSelCount (hWndCtl);
		EnableWindow (GetDlgItem (hWnd, IDB_CHANGE), (ix > 0));
	    }
	    break;

	case IDOK:
	{
	    SaveSchemeToReg (&pmcl->mcm, pms, pmcl->szScheme, hWnd);

	    EndDialog (hWnd, IDOK);
	    break;
	}

	case IDCANCEL:
	    EndDialog (hWnd, IDCANCEL);
	    break;
    }

    return FALSE;
}


/*+ MidiConfigDlgProc
 *
 *-=================================================================*/

const static DWORD aMidiConfigHelpIds[] = {  // Context Help IDs
    IDC_GROUPBOX,    IDH_COMM_GROUPBOX,
    IDC_SCHEMES,     IDH_MIDI_CFGDLG_SCHEME,
    IDB_SAVE_AS,     IDH_MIDI_CFGDLG_SAVEAS,
    IDB_DELETE,      IDH_MIDI_CFGDLG_DELETE,
    IDC_GROUPBOX_2,  IDH_COMM_GROUPBOX,
    IDL_CHANNELS,    IDH_MIDI_INSTRUMENTS,
    IDB_CHANGE,      IDH_MIDI_CFGDLG_CHANGE,
    IDC_TEXT_1,      IDH_MIDI_INSTRUMENTS,
    IDC_TEXT_2,      IDH_MIDI_INSTRUMENTS,
    IDC_TEXT_3,      NO_HELP,

    0, 0
};

INT_PTR CALLBACK MidiConfigDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
	case WM_COMMAND:
	    HANDLE_WM_COMMAND (hWnd, wParam, lParam, MidiConfigCommands);
	    break;
	
	case WM_NOTIFY:
	    ForwardBillNotify(hWnd, (NMHDR FAR *)lParam);
	    break;

	case WM_CLOSE:
	    SendMessage (hWnd, WM_COMMAND, IDCANCEL, 0);
	    break;

	case WM_INITDIALOG:
	{
	    PMCLOCAL pmcl = (LPVOID) lParam;
	    
	    assert (pmcl);

	    SetDlgData (hWnd, pmcl);
	    LoadString (ghInstance, IDS_NONE, pmcl->ms.szNone, NUMELMS(pmcl->ms.szNone));

	    LoadSchemesIntoCombo (hWnd, IDC_SCHEMES, pmcl->szScheme, &pmcl->ms);
	    SimulateNotify (hWnd, IDC_SCHEMES, CBN_SELCHANGE);

	    EnableWindow (GetDlgItem(hWnd, IDB_CHANGE), FALSE);
	    break;
	}

	case WM_CONTEXTMENU:
	    WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
		    (UINT_PTR) (LPTSTR) aMidiConfigHelpIds);
	    return TRUE;

	case WM_HELP:
	{
	    LPHELPINFO lphi = (LPVOID) lParam;
	    WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
		    (UINT_PTR) (LPTSTR) aMidiConfigHelpIds);
	    return TRUE;
	}
    }

    return FALSE;
}


STATICFN void WINAPI PickMidiInstrument(
    LPTSTR   pszKey)
{
    HKEY            hKeyMR, hKeyDriver;
    UINT            cDevs;
    UINT            ii, jj;
    DWORD           cbSize, dwType;
    LPMIDIOUTCAPS   pmoc;
    MMRESULT        mmr;
    PWSTR           pszDevIntDev, pszDevIntKey;
    UINT            aTech[]  = { MOD_SWSYNTH,
                                 MOD_WAVETABLE,
                                 MOD_SYNTH,
                                 MOD_FMSYNTH,
                                 MOD_SQSYNTH,
                                 MOD_MIDIPORT};
    UINT            cTech    = sizeof(aTech)/sizeof(aTech[0]);
    TCHAR           szKey[MAX_ALIAS];
    TCHAR           szPname[MAXPNAMELEN];
    TCHAR           szPnameTarget[MAXPNAMELEN];
    LONG            lr;

    szPname[0] = 0;
    cDevs = midiOutGetNumDevs();

    if (0 == cDevs)
    {
        return;
    }

    pmoc = (LPMIDIOUTCAPS)LocalAlloc (LPTR, cDevs * sizeof(MIDIOUTCAPS));

    if (NULL == pmoc)
    {
        return;
    }

    for (ii = cDevs; ii; ii--)
    {
        mmr = midiOutGetDevCaps(ii - 1, &(pmoc[ii - 1]), sizeof(MIDIOUTCAPS));

        if (MMSYSERR_NOERROR != mmr)
        {
            LocalFree ((HLOCAL)pmoc);
            return;
        }
    }

    for (ii = 0; ii < cTech; ii++)
    {
        for (jj = cDevs; jj; jj--)
        {
            if (pmoc[jj - 1].wTechnology == aTech[ii])
            {
                lstrcpy(szPname, pmoc[jj - 1].szPname);
                break;
            }
        }

        if (jj)
        {
            //  Broke out of inner loop, found match

            break;
        }
    }

    LocalFree ((HLOCAL)pmoc);

    if (0 == jj)
    {
        //  This should never happen...

        return;
    }

    jj--;

    mmr = midiOutMessage (HMIDIOUT_INDEX(jj), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)(PULONG)&cbSize, 0L);

    if (MMSYSERR_NOERROR != mmr)
    {
        return;
    }

	pszDevIntDev = (PWSTR)LocalAlloc (LPTR, cbSize);

    if (NULL == pszDevIntDev)
    {
        return;
    }

    mmr = midiOutMessage (HMIDIOUT_INDEX(jj), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)pszDevIntDev, (DWORD)cbSize);

    if (MMSYSERR_NOERROR != mmr)
    {
        LocalFree ((HLOCAL)pszDevIntDev);
        return;
    }

    lr = RegOpenKey(HKEY_LOCAL_MACHINE, cszDriversRoot, &hKeyMR);

    if (ERROR_SUCCESS != lr)
    {
        LocalFree ((HLOCAL)pszDevIntDev);
        return;
    }

    for (ii = 0; ; )
    {
        lr = RegEnumKey(hKeyMR, ii++, szKey, sizeof(szKey)/sizeof(szKey[0]));

        if (ERROR_SUCCESS != lr)
        {
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        lr = RegOpenKey(hKeyMR, szKey, &hKeyDriver);

        if (ERROR_SUCCESS != lr)
        {
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        cbSize = sizeof(szPnameTarget);

        lr = RegQueryValueEx(
                hKeyDriver,
                cszActive,
                NULL,
                &dwType,
                (LPSTR)szPnameTarget,
                &cbSize);

        if (ERROR_SUCCESS != lr)
        {
            RegCloseKey(hKeyDriver);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        if (TEXT('1') != szPnameTarget[0])
        {
            RegCloseKey(hKeyDriver);
            continue;
        }

        cbSize = sizeof(szPnameTarget);

        lr = RegQueryValueEx(
                hKeyDriver,
                cszDescription,
                NULL,
                &dwType,
                (LPSTR)szPnameTarget,
                &cbSize);

        if (ERROR_SUCCESS != lr)
        {
            RegCloseKey(hKeyDriver);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        if (0 != lstrcmp(szPnameTarget, szPname))
        {
            RegCloseKey(hKeyDriver);
            continue;
        }

        cbSize = 0;

        lr = RegQueryValueExW (
                hKeyDriver,
                L"DeviceInterface",
                NULL,
                &dwType,
                (LPSTR)NULL,
                &cbSize);

        if (ERROR_SUCCESS != lr)
        {
            RegCloseKey(hKeyDriver);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        pszDevIntKey = (PWSTR) LocalAlloc (LPTR, cbSize);

        if (NULL == pszDevIntKey)
        {
            RegCloseKey(hKeyDriver);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        lr = RegQueryValueExW (
                hKeyDriver,
                L"DeviceInterface",
                NULL,
                &dwType,
                (LPSTR)pszDevIntKey,
                &cbSize);

        RegCloseKey(hKeyDriver);

        if (ERROR_SUCCESS != lr)
        {
            LocalFree ((HLOCAL)pszDevIntKey);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            return;
        }

        if (0 == lstrcmpiW(pszDevIntKey, pszDevIntDev))
        {
            LocalFree ((HLOCAL)pszDevIntKey);
            RegCloseKey(hKeyMR);
            LocalFree ((HLOCAL)pszDevIntDev);
            lstrcpy(pszKey, szKey);
            return;
        }

        LocalFree ((HLOCAL)pszDevIntKey);
    }
}


/*+ SaveLocal
 *
 *-=================================================================*/

STATICFN void WINAPI SaveLocal (
    PMCLOCAL pmcl,
    BOOL     bUserSetting,
    HWND     hWnd)  // optional window to report errors: NULL - no reports
{
    HKEY hKey = NULL;
    UINT cb;

#ifdef DEBUG
    AuxDebugEx (2, DEBUGLINE TEXT ("SaveLocal(%08X,%X) %s\r\n"),
		pmcl, hWnd, pmcl->pszReason ? pmcl->pszReason : TEXT (""));
#endif
    
    if ((RegCreateKey (HKEY_CURRENT_USER, cszMidiMapRoot, &hKey) == ERROR_SUCCESS) && hKey)
    {
    	cb = (lstrlen(pmcl->szScheme) + 1) * sizeof(TCHAR);
	    RegSetValueEx (hKey, cszCurrentScheme, 0, REG_SZ,
		               (LPBYTE)pmcl->szScheme, cb);

	    //assert (pmcl->piSingle);
	    if ((pmcl->piSingle) && (pmcl->piSingle->bActive))
	    {
#ifdef DEBUG
	        AuxDebugEx (2, DEBUGLINE TEXT ("Setting CurrentInstrument Key to %08X '%s'\r\n"),
			            pmcl->piSingle, pmcl->piSingle->szKey);
#endif
    	    cb = (lstrlen(pmcl->piSingle->szKey) + 1) * sizeof(TCHAR);
	        RegSetValueEx (hKey, cszCurrentInstrument, 0, REG_SZ,
		    	           (LPBYTE)(pmcl->piSingle->szKey),
			               cb);
	    }
	    else
	    {
            // Assume No Match

            TCHAR   szKey[MAX_ALIAS];
            LONG    lr;

            szKey[0] = 0;

	        RegSetValueEx (hKey, cszCurrentInstrument, 0, REG_SZ, (LPBYTE)cszEmpty, 0);
            PickMidiInstrument(szKey);

	        cb = (lstrlen(szKey) + 1) * sizeof(TCHAR);
	        lr = RegSetValueEx (hKey, cszCurrentInstrument, 0, REG_SZ,
			                (LPBYTE)(szKey), cb);
            
	    }

	    RegSetValueEx (hKey, cszUseScheme, 0, REG_DWORD,
		               (LPBYTE)&pmcl->bUseScheme, sizeof(pmcl->bUseScheme));

	    if (bUserSetting)
	        pmcl->bAutoScheme = FALSE;

	    RegSetValueEx (hKey, cszAutoScheme, 0, REG_DWORD,
		               (LPBYTE)&pmcl->bAutoScheme, sizeof(pmcl->bAutoScheme));

	    RegSetValueEx (hKey, cszRunOnceCount, 0, REG_DWORD,
		               (LPBYTE)&pmcl->dwRunCount, sizeof(pmcl->dwRunCount));

	    if (pmcl->pszReason)
	    {
	        cb = (lstrlen(pmcl->pszReason) + 1) * sizeof(TCHAR);
	        RegSetValueEx (hKey, cszDriverList, 0, REG_SZ,
			               (LPBYTE)pmcl->pszReason, cb);
	    }
	    else
	        RegSetValueEx (hKey, cszDriverList, 0, REG_SZ, (LPBYTE)cszEmpty, 0);

	    RegCloseKey (hKey);

	    // Don't Kick mapper unless we have a window
	    if (hWnd)
	        KickMapper (hWnd);
    }
}


/*+ InitLocal
 *
 *-=================================================================*/

STATICFN void WINAPI InitLocal (
    PMCLOCAL pmcl,
    LPARAM   lParam,
    BOOL     bDriverAsAlias) // driver as alias mode used only for scheme init
{
    HKEY hKey;

    LoadString (ghInstance, IDS_DEFAULT_SCHEME_NAME,
		pmcl->szDefault, NUMELMS(pmcl->szDefault));

    // NOTE : Comment below regarding RunOnceSchemeInit is in reference
    //  to an obsolete RunOnce initialization.
    //
    // we allow driver as alias (szFriendly) only for InitLocal when called
    // from RunOnceSchemeInit.  this works because in this case we have
    // no UI so we dont need the friendly names for anything.
    //
    assert (!bDriverAsAlias || lParam == 0);
    LoadInstruments (&pmcl->mcm, bDriverAsAlias);

   #ifdef DEBUG
    if (mmdebug_OutputLevel >= 3)
       DumpInstruments (&pmcl->mcm);
   #endif

    if (RegCreateKey (HKEY_CURRENT_USER, cszMidiMapRoot, &hKey) == ERROR_SUCCESS)
    {
	DWORD cb;
	DWORD dwType;
	TCHAR szSingle[MAX_ALIAS];

	cb = sizeof(pmcl->szScheme);
	if (RegQueryValueEx (hKey, cszCurrentScheme, NULL, &dwType, (LPBYTE)pmcl->szScheme, &cb))
	    pmcl->szScheme[0] = 0;

	pmcl->piSingle = NULL;
	cb = sizeof(szSingle);
	if (!RegQueryValueEx (hKey, cszCurrentInstrument, NULL, &dwType, (LPBYTE)szSingle, &cb))
	    pmcl->piSingle = FindInstrumentFromKey (&pmcl->mcm, szSingle);

	cb = sizeof(pmcl->bUseScheme);
	if (RegQueryValueEx (hKey, cszUseScheme, NULL, &dwType, (LPBYTE)&pmcl->bUseScheme, &cb))
	    pmcl->bUseScheme = 0;

	cb = sizeof(pmcl->bAutoScheme);
	if (RegQueryValueEx (hKey, cszAutoScheme, NULL, &dwType, (LPBYTE)&pmcl->bAutoScheme, &cb))
	    pmcl->bAutoScheme = TRUE;

	cb = sizeof(pmcl->dwRunCount);
	if (RegQueryValueEx (hKey, cszRunOnceCount, NULL, &dwType, (LPBYTE)&pmcl->dwRunCount, &cb))
	    pmcl->dwRunCount = 0;

	pmcl->pszReason = NULL;

	RegCloseKey (hKey);
    }

    pmcl->ppsp = (LPVOID)lParam;
}


/*+ FixupHinderedIDFs
 *
 *-=================================================================*/

VOID WINAPI FixupHinderedIDFs (
    PMCLOCAL pmcl,
    LPTSTR   pszTemp,  // ptr to temp memory
    UINT     cchTemp)  // size of temp memory
{
    HKEY     hkHind; // hinderedMidiList root
    LPTSTR   pszDriver = pszTemp; // max size is short filename
    UINT     cch;
    LPTSTR   pszIDF = (LPVOID)(pszTemp + MAX_PATH);
    UINT     cbSize;
    DWORD    iEnum;
    DWORD    dwType;

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("FixupHinderedIDFs(%08x)\r\n"), pmcl);
#endif
    assert (pszTemp);
    assert (cchTemp > MAX_PATH + MAX_PATH + 64);

    // the midi key should have already been opened.
    //
    assert (pmcl->mcm.hkMidi);

    if (RegCreateKey (HKEY_LOCAL_MACHINE, cszHinderedMidiList, &hkHind))
	return;

    // enumerate the known hindered driver list looking for
    // drivers that need to have their IDF's set
    //
    for (iEnum = 0, cch = MAX_PATH, cbSize = (MAX_PATH + 64) * sizeof(TCHAR);
	 ! RegEnumValue (hkHind, iEnum, pszDriver, &cch, NULL, &dwType, (LPBYTE)pszIDF, &cbSize);
	 ++iEnum, cch = MAX_PATH, cbSize = (MAX_PATH + 64) * sizeof(TCHAR))
    {
	UINT ii;

#ifdef DEBUG
	AuxDebugEx (3, DEBUGLINE TEXT ("enum[%d] pszDriver='%s' pszIDF='%s'\r\n"), iEnum, pszDriver, pszIDF);
#endif
	// just to be careful.  ignore any registry entry that
	// does not have string data
	//
	assert (dwType == REG_SZ);
	if (dwType != REG_SZ)
	    continue;

	// scan through the list of drivers looking for one that is
	// internal, and has the same driver name as one of our known
	// list of hindered drivers.  if we find one, force its
	// IDF to be the given IDF
	//
	for (ii = 0; ii < pmcl->mcm.nInstr; ++ii)
	{
	    PINSTRUM pi = pmcl->mcm.api[ii];
	    HKEY hkSub;

	    if (!pi || !pi->szKey[0] || pi->bExternal ||
		!IsSzEqual (pi->szFriendly, pszDriver))
		continue;

#ifdef DEBUG
	    AuxDebugEx (2, DEBUGLINE TEXT ("forcing driver '%s' to use IDF '%s'\r\n"), pi->szKey, pszIDF);
#endif
	    if ( ! RegOpenKeyEx (pmcl->mcm.hkMidi, pi->szKey, 0, KEY_ALL_ACCESS, &hkSub))
	    {
		RegSetValueEx (hkSub, cszDefinition, 0, REG_SZ, (LPBYTE)pszIDF, cbSize);
		RegCloseKey (hkSub);
	    }
	}
    }

    RegCloseKey (hkHind);
    return;
}


STDAPI_(void) HandleSynthAboutBox(HWND hWnd)
{
    HWND hTree =  GetDlgItem(hWnd, IDL_INSTRUMENTS);
    HTREEITEM hItem = TreeView_GetSelection(hTree);
    TV_ITEM       ti;
    PINSTRUM      pi;

    memset(&ti, 0, sizeof(ti));
    ti.mask       = TVIF_PARAM;
    ti.hItem      = hItem;
    
    TreeView_GetItem (hTree, &ti);
    pi = (LPVOID)ti.lParam; 

    if (pi)
    {
        UINT uWaveID;

        if (GetWaveID(&uWaveID) != (MMRESULT)MMSYSERR_ERROR)
        {
            WAVEOUTCAPS woc;

            if (waveOutGetDevCaps(uWaveID, &woc, sizeof(woc)) == MMSYSERR_NOERROR)
            {
                RolandProp(hWnd, ghInstance, woc.szPname);
            }  
        }
    }
}



/*+ MidiCplCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiCplCommands (
    HWND hWnd,
    UINT wId,
    HWND hWndCtl,
    UINT wNotify)
{
    PMCLOCAL pmcl = GetDlgData(hWnd);

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("MidiCplCommands(%08X,%X,%08X,%d)\r\n"),
		hWnd, wId, hWndCtl, wNotify);
#endif

    assert (pmcl);
    if (!pmcl)
	return FALSE;

    switch (wId)
    {
	case IDB_CONFIGURE:
	{
	    UINT_PTR uRet;
	    TCHAR    szOld[MAX_ALIAS];

#ifdef DEBUG
	    AuxDebugEx (2, DEBUGLINE TEXT ("Launching Config Dialog\r\n"));
#endif

	    lstrcpy (szOld, pmcl->szScheme);
	    uRet = DialogBoxParam (ghInstance,
				   MAKEINTRESOURCE(IDD_MIDICONFIG),
				   hWnd,
				   MidiConfigDlgProc,
				   (LPARAM)pmcl);
	    if (uRet != IDOK)
		lstrcpy (pmcl->szScheme, szOld);
	    else
		PropSheet_Changed(GetParent(hWnd), hWnd);

	    LoadSchemesIntoCombo (hWnd, IDC_SCHEMES, pmcl->szScheme, &pmcl->ms);
	}
	    break;

    case IDC_ABOUTSYNTH:
    {
        HandleSynthAboutBox(hWnd);
    }
    break;

	case IDB_ADDWIZ:
#ifdef DEBUG
	    AuxDebugEx (2, DEBUGLINE TEXT ("Launching Midi Wizard\r\n"));
#endif
	    MidiInstrumentsWizard (hWnd, &pmcl->mcm, NULL);

	    LoadInstruments (&pmcl->mcm, FALSE);
	   #ifdef DEBUG
	    if (mmdebug_OutputLevel >= 3)
	       DumpInstruments (&pmcl->mcm);
	   #endif

	    if (pmcl->bDlgType2)
	    {
		LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS, IDC_INSTRUMENTS,
					 pmcl->piSingle, pmcl);
	    }
	    else
	    {
		LoadInstrumentsIntoCombo (hWnd, IDC_INSTRUMENTS,
					  pmcl->piSingle, &pmcl->mcm);
	    }
	    MMExtPropSheetCallback(MM_EPS_BLIND_TREECHANGE, 0,0,0);
	    break;

	case IDC_SCHEMES:
	    if (wNotify == CBN_SELCHANGE)
	    {
		int   ix;

		ix = ComboBox_GetCurSel (hWndCtl);
		if (ix >= 0)
		    ComboBox_GetLBText (hWndCtl, ix, pmcl->szScheme);
		PropSheet_Changed(GetParent(hWnd), hWnd);
	    }
	    break;

	case IDC_INSTRUMENTS:
	    if (wNotify == CBN_SELCHANGE)
	    {
		int   ix;

		assert (!pmcl->bDlgType2);

		ix = ComboBox_GetCurSel (hWndCtl);
		if (ix >= 0)
		{
		    pmcl->piSingle = (LPVOID)ComboBox_GetItemData (hWndCtl, ix);
		}
		PropSheet_Changed(GetParent(hWnd), hWnd);
	    }
	    break;

	case IDC_RADIO_CUSTOM:
	case IDC_RADIO_SINGLE:
	    {
	    BOOL bUseScheme = pmcl->bUseScheme;
	    pmcl->bUseScheme = IsDlgButtonChecked (hWnd, IDC_RADIO_CUSTOM);
	    if (bUseScheme != pmcl->bUseScheme)
		PropSheet_Changed(GetParent(hWnd), hWnd);

	    if (pmcl->bDlgType2)
	    {
		HWND hWndCtl;
		EnableWindow(GetDlgItem (hWnd, IDL_INSTRUMENTS), !pmcl->bUseScheme);
		if (hWndCtl = GetDlgItem (hWnd, IDB_DETAILS))
		    EnableWindow(hWndCtl, !pmcl->bUseScheme);
	    }
	    EnableWindow(GetDlgItem (hWnd, IDC_INSTRUMENTS), !pmcl->bUseScheme);
	    EnableWindow(GetDlgItem (hWnd, IDC_SCHEMES), pmcl->bUseScheme);
	    EnableWindow(GetDlgItem (hWnd, IDC_SCHEMESLABEL), pmcl->bUseScheme);
	    EnableWindow(GetDlgItem (hWnd, IDB_CONFIGURE), pmcl->bUseScheme);
	    }
	    break;

       #if 1 //def DETAILS_FROM_MAIN_CPL
	case IDB_DETAILS:
	    assert (pmcl->bDlgType2);
	    if (pmcl->bDlgType2)
	    {
		TCHAR szSingle[MAX_PATH];
		int  ix;

		ix = ComboBox_GetCurSel (hWndCtl);
		if (ix >= 0)
		    pmcl->piSingle = (LPVOID)ComboBox_GetItemData (hWndCtl, ix);

		szSingle[0] = 0;
		if (pmcl->piSingle)
		    lstrcpy (szSingle, pmcl->piSingle->szKey);

		if (ShowDetails (hWnd, pmcl))
		{
		    LoadInstruments (&pmcl->mcm, FALSE);
		    pmcl->piSingle = FindInstrumentFromKey (&pmcl->mcm, szSingle);

		    LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS,
					     IDC_INSTRUMENTS, pmcl->piSingle,
					     pmcl);
		}
	    }
	    break;
       #endif

	case ID_INIT:
	    LoadInstruments (&pmcl->mcm, FALSE);
	   #ifdef DEBUG
	    if (mmdebug_OutputLevel >= 3)
	       DumpInstruments (&pmcl->mcm);
	   #endif

	    if (pmcl->bDlgType2)
	    {
		LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS, IDC_INSTRUMENTS,
					 pmcl->piSingle, pmcl);
	    }
	    else
	    {
		LoadInstrumentsIntoCombo (hWnd, IDC_INSTRUMENTS,
					  pmcl->piSingle, &pmcl->mcm);
	    }
	    break;

	case ID_APPLY:
	    pmcl->bUseScheme = IsDlgButtonChecked (hWnd, IDC_RADIO_CUSTOM);
	    SaveLocal (pmcl, TRUE, hWnd);
	    break;

	case IDOK:
	    pmcl->bUseScheme = IsDlgButtonChecked (hWnd, IDC_RADIO_CUSTOM);
	    break;

	case IDCANCEL:
	    break;

	//
	//case ID_INIT:
	//    break;
    }

    return FALSE;
}


/*+ HandleInstrumentsSelChange
 *
 *-=================================================================*/

STATICFN BOOL WINAPI HandleInstrumentsSelChange (
    HWND     hWnd,
    LPNMHDR  lpnm)
{
    PMCLOCAL      pmcl = GetDlgData(hWnd);
    LPNM_TREEVIEW pntv = (LPVOID)lpnm;
    LPTV_ITEM     pti  = &pntv->itemNew;
    TV_ITEM       ti;
    PINSTRUM      pi;
    TCHAR         szSingle[MAX_ALIAS];
    BOOL          bChange = FALSE;

    if (!pmcl || pmcl->bIgnoreSelChange)
	return FALSE;

    // setup ti to get text & # of children
    // from the IDF filename entry.
    //
    ti.mask       = TVIF_TEXT | TVIF_PARAM;
    ti.pszText    = szSingle;
    ti.cchTextMax = NUMELMS(szSingle);
    ti.hItem      = pti->hItem;

    TreeView_GetItem (lpnm->hwndFrom, &ti);
    pi = (LPVOID)ti.lParam; // FindInstrument (&pmcl->mcm, szSingle);

#ifdef DEBUG
    AuxDebugEx (2, DEBUGLINE TEXT ("HandInstSelChg(%X,...) %X %X Init=%d\r\n"),
		hWnd, pmcl->piSingle, pi, !pmcl->bPastInit);
#endif

    SetDlgItemText (hWnd, IDC_INSTRUMENTS, szSingle);
    if (pmcl->piSingle != pi)
    {
	EnableWindow(GetDlgItem(hWnd,IDC_ABOUTSYNTH),pi->fGSSynth);
    bChange = TRUE;
	pmcl->piSingle = pi;
    }

    return (bChange && pmcl->bPastInit);
}


/*+ MidiCplDlgProc
 *
 *-=================================================================*/

const static DWORD aKeyWordIds[] = {  // Context Help IDs
    IDC_GROUPBOX,     IDH_COMM_GROUPBOX,
    IDC_RADIO_SINGLE, IDH_MIDI_SINGLE_INST_BUTTON,
    IDC_INSTRUMENTS,  IDH_MIDI_SINGLE_INST,
    IDL_INSTRUMENTS,  IDH_MIDI_SINGLE_INST_LIST,
    IDC_RADIO_CUSTOM, IDH_MIDI_CUST_CONFIG,
    IDC_SCHEMESLABEL, IDH_MIDI_SCHEME,
    IDC_SCHEMES,      IDH_MIDI_SCHEME,
	IDC_ABOUTSYNTH,	  IDH_ABOUT,
    //IDB_DETAILS,      IDH_MIDI_SINGLE_INST_PROP,
    IDB_CONFIGURE,    IDH_MIDI_CONFIG_SCHEME,
    IDB_ADDWIZ,       IDH_MIDI_ADD_NEW,

    0, 0
};

INT_PTR CALLBACK MidiCplDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("MidiCplDlgProc(%08X,%X,%08X,%08X)\r\n"),
		hWnd, uMsg, wParam, lParam);
#endif

    switch (uMsg)
    {
	case WM_COMMAND:
	    HANDLE_WM_COMMAND (hWnd, wParam, lParam, MidiCplCommands);
	    break;
	
	case WM_NOTIFY:
	{
	    LPNMHDR lpnm = (LPVOID)lParam;
	    if (lpnm->idFrom == (UINT)IDL_INSTRUMENTS &&
		lpnm->code == TVN_SELCHANGED)
	    {
		if (HandleInstrumentsSelChange (hWnd, lpnm))
		    PropSheet_Changed(GetParent(hWnd), hWnd);
	    }
	    else
		ForwardBillNotify(hWnd, (NMHDR FAR *)lParam);
	}
	    break;
	
	case WM_INITDIALOG:
	{
	    PMCLOCAL pmcl;
	    
	    pmcl = (LPVOID)LocalAlloc(LPTR, sizeof(*pmcl));
	    SetDlgData (hWnd, pmcl);
	    if (!pmcl)
	    {
		break;
	    }
	    pmcl->bPastInit = FALSE;

	    InitLocal (pmcl, lParam, FALSE);
	    EnableWindow (GetDlgItem (hWnd, IDB_ADDWIZ), pmcl->mcm.bHasExternal & AccessServiceController());
		EnableWindow(GetDlgItem(hWnd, IDC_ABOUTSYNTH), FALSE);

	    if (GetDlgItem(hWnd, IDL_INSTRUMENTS))
	    {
		pmcl->bDlgType2 = TRUE;
		LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS,
					 IDC_INSTRUMENTS, pmcl->piSingle,
					 pmcl);
	    }
	    else
	    {
		pmcl->bDlgType2 = FALSE;
		LoadInstrumentsIntoCombo (hWnd, IDC_INSTRUMENTS,
					  pmcl->piSingle, &pmcl->mcm);
	    }

	    CheckRadioButton (hWnd,
			      IDC_RADIO_SINGLE,
			      IDC_RADIO_CUSTOM,
			      pmcl->bUseScheme ? IDC_RADIO_CUSTOM
					       : IDC_RADIO_SINGLE);

	    LoadSchemesIntoCombo (hWnd, IDC_SCHEMES,
				  pmcl->szScheme, &pmcl->ms);

	    if (pmcl->mcm.nInstr > 1)
	    {
	       if (pmcl->bDlgType2)
	       {
		   HWND hWndCtl;

		   EnableWindow(GetDlgItem (hWnd, IDL_INSTRUMENTS), !pmcl->bUseScheme);
		   if (hWndCtl = GetDlgItem (hWnd, IDB_DETAILS))
		      EnableWindow (hWndCtl, !pmcl->bUseScheme);
	       }
	       EnableWindow(GetDlgItem (hWnd, IDC_INSTRUMENTS), !pmcl->bUseScheme);
	       EnableWindow(GetDlgItem (hWnd, IDC_SCHEMES), pmcl->bUseScheme);
	       EnableWindow(GetDlgItem (hWnd, IDC_SCHEMESLABEL), pmcl->bUseScheme);
	       EnableWindow(GetDlgItem (hWnd, IDB_CONFIGURE), pmcl->bUseScheme);
	    }
	    else
	    {
		UINT aid[] = { IDL_INSTRUMENTS, IDC_INSTRUMENTS, IDC_SCHEMES,
			       IDC_RADIO_SINGLE, IDC_RADIO_CUSTOM,
			       IDB_CONFIGURE, IDB_DETAILS, IDB_ADDWIZ };
		UINT ii;

		for (ii = 0; ii < NUMELMS(aid); ++ii)
		{
		    HWND hWndCtl = GetDlgItem (hWnd, aid[ii]);
		    if (hWndCtl)
			EnableWindow (hWndCtl, FALSE);
		}
	    }
	    pmcl->bPastInit = TRUE;
	    break;
	}

	case WM_DESTROY:
	{
	    PMCLOCAL pmcl = GetDlgData(hWnd);

#ifdef DEBUG
	    AuxDebugEx (5, DEBUGLINE TEXT ("MidiCPL - begin WM_DESTROY\r\n"));
#endif
	    if (pmcl)
	    {
		if (pmcl->mcm.hkMidi)
		    RegCloseKey (pmcl->mcm.hkMidi);
		if (pmcl->ms.hkSchemes)
		    RegCloseKey (pmcl->ms.hkSchemes);

		FreeInstruments (&pmcl->mcm);
		SetDlgData (hWnd, 0);
		LocalFree ((HLOCAL)(UINT_PTR)(DWORD_PTR)pmcl);
	    }
#ifdef DEBUG
	    AuxDebugEx (5, DEBUGLINE TEXT ("MidiCPL -  done with WM_DESTROY\r\n"));
#endif
	    break;
	}

	//case WM_DROPFILES:
	//    break;

	case WM_CONTEXTMENU:
	    WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
		    (UINT_PTR) (LPTSTR) aKeyWordIds);
	    return TRUE;

	case WM_HELP:
	{
	    LPHELPINFO lphi = (LPVOID) lParam;
	    WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
		    (UINT_PTR) (LPTSTR) aKeyWordIds);
	    return TRUE;
	}

       #if 0
	default:
	    if (uMsg == wHelpMessage)
	    {
		WinHelp (hWnd, gszWindowsHlp, HELP_CONTEXT, ID_SND_HELP);
		return TRUE;
	    }
	    break;
       #endif
    }

    return FALSE;
}


/*+ MidiClassCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiClassCommands (
    HWND hWnd,
    UINT wId,
    HWND hWndCtl,
    UINT wNotify)
{
    PMCLOCAL pmcl = GetDlgData(hWnd);

	if (!pmcl) return FALSE;

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("MidiClassCommands(%08X,%d,%08X,%d)\r\n"),
		hWnd, wId, hWndCtl, wNotify);
#endif

    switch (wId)
    {
	case IDB_ADDWIZ:
	    MidiInstrumentsWizard (hWnd, &pmcl->mcm, NULL);
	    LoadInstruments (&pmcl->mcm, FALSE);
	    LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS, 0, NULL, pmcl);

	    // flog the parent property sheet to let it know that we have
	    // made changes to the advanced midi page structures
	    //
	    {
		PMPSARGS  pmpsa = (LPVOID)pmcl->ppsp->lParam;
		if (pmpsa && pmpsa->lpfnMMExtPSCallback)
		    pmpsa->lpfnMMExtPSCallback (MM_EPS_TREECHANGE, 0, 0, pmpsa->lParam);
	    }
	    break;

	//case ID_APPLY:
	//    return TRUE;
	//
	//case IDCANCEL:
	//    break;
    }

    return FALSE;
}


/*+ MidiClassDlgProc
 *
 *-=================================================================*/

const static DWORD aMidiClassHelpIds[] = {  // Context Help IDs
    IDB_ADDWIZ,      IDH_MIDI_ADD_NEW,
    IDC_CLASS_ICON,  NO_HELP,
    IDC_CLASS_LABEL, NO_HELP,
    IDL_INSTRUMENTS, IDH_MMCPL_DEVPROP_INST_LIST,

    0, 0
};

INT_PTR CALLBACK MidiClassDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
	case WM_COMMAND:
	    HANDLE_WM_COMMAND (hWnd, wParam, lParam, MidiClassCommands);
	    break;
	
	case WM_NOTIFY:
	    ForwardBillNotify (hWnd, (NMHDR FAR *)lParam);
	    break;
	
	case WM_INITDIALOG:
	{
	    PMCLOCAL pmcl;
	    TCHAR    sz[MAX_ALIAS];
	    
	    pmcl = (LPVOID)LocalAlloc(LPTR, sizeof(*pmcl));
	    SetDlgData (hWnd, pmcl);
	    if (!pmcl)
	    {
		break;
	    }


	    InitLocal (pmcl, lParam, FALSE);

#ifdef DEBUG
	    AuxDebugEx (5, DEBUGLINE TEXT ("midiClass.WM_INITDLG ppsp=%08X\r\n"), pmcl->ppsp);
#endif
	    //AuxDebugDump (8, pmcl->ppsp, sizeof(*pmcl->ppsp));

	    LoadString (ghInstance, IDS_MIDI_DEV_AND_INST, sz, NUMELMS(sz));
	    SetDlgItemText (hWnd, IDC_CLASS_LABEL, sz);
	    Static_SetIcon(GetDlgItem (hWnd, IDC_CLASS_ICON),
			   LoadIcon (ghInstance, MAKEINTRESOURCE(IDI_INSTRUMENT)));

	    LoadInstrumentsIntoTree (hWnd, IDL_INSTRUMENTS, 0, NULL, pmcl);
	    EnableWindow (GetDlgItem (hWnd, IDB_ADDWIZ), pmcl->mcm.bHasExternal & AccessServiceController());
	    break;
	}

	case WM_DESTROY:
	{
	    PMCLOCAL pmcl = GetDlgData(hWnd);

	    if (pmcl)
	    {
		if (pmcl->mcm.hkMidi)
		    RegCloseKey (pmcl->mcm.hkMidi);
		if (pmcl->ms.hkSchemes)
		    RegCloseKey (pmcl->ms.hkSchemes);

		FreeInstruments (&pmcl->mcm);
		LocalFree ((HLOCAL)(UINT_PTR)(DWORD_PTR)pmcl);
	    }
	    break;
	}
    
	case WM_CONTEXTMENU:
	    WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
		    (UINT_PTR) (LPTSTR) aMidiClassHelpIds);
	    return TRUE;

	case WM_HELP:
	{
	    LPHELPINFO lphi = (LPVOID) lParam;
	    WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
		    (UINT_PTR) (LPTSTR) aMidiClassHelpIds);
	    return TRUE;
	}
    }

    return FALSE;
}


/*+ PropPageCallback
 *
 *  add a property page
 *
 *-=================================================================*/

UINT CALLBACK PropPageCallback (
    HWND            hwnd,
    UINT            uMsg,
    LPPROPSHEETPAGE ppsp)
{
    if (uMsg == PSPCB_RELEASE) {
	//LocalFree ((HLOCAL)(UINT)(DWORD)ppsp->pszTitle);
	LocalFree ((HLOCAL)ppsp->lParam);
    }
    return 1;
}


/*+ AddPropPage
 *
 *  add a property page
 *
 *-=================================================================*/

STATICFN HPROPSHEETPAGE WINAPI AddPropPage (
    LPCTSTR                     pszTitle,
    LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,
    DLGPROC                     fnDlgProc,
    UINT                        idTemplate,
    LPARAM                      lParam)
{
    PROPSHEETPAGE   psp;
    PMPSARGS        pmpsa;
    UINT            cbSize;

    cbSize = sizeof(MPSARGS) + lstrlen (pszTitle) * sizeof(TCHAR);
    if (pmpsa = (PVOID) LocalAlloc (LPTR, cbSize))
    {
	HPROPSHEETPAGE  hpsp;

	lstrcpy (pmpsa->szTitle, pszTitle);
	pmpsa->lpfnMMExtPSCallback = lpfnAddPropSheetPage;
	pmpsa->lParam = lParam;

	psp.dwSize      = sizeof(psp);
	psp.dwFlags     = PSP_USETITLE | PSP_USECALLBACK;
	psp.hInstance   = ghInstance;
	psp.pszTemplate = MAKEINTRESOURCE(idTemplate);
	psp.pszIcon     = NULL;
	psp.pszTitle    = pmpsa->szTitle;
	psp.pfnDlgProc  = fnDlgProc;
	psp.lParam      = (LPARAM)pmpsa;
	psp.pfnCallback = PropPageCallback;
	psp.pcRefParent = NULL;

	if (hpsp = CreatePropertySheetPage (&psp))
	{
	    if ( ! lpfnAddPropSheetPage ||
		lpfnAddPropSheetPage (MM_EPS_ADDSHEET, (DWORD_PTR)hpsp, 0, lParam))
	    {

		return hpsp;
	    }
	    DestroyPropertySheetPage (hpsp);
	    LocalFree ((HLOCAL) pmpsa);
	}
    }
    return NULL;
}


/*+ AddInstrumentPages
 *
 *  add a midi page to a property sheet.  Invoked from Advanced tab
 *  of Muitimedia control panel when class midi is selected from
 *  the list.
 *
 *-=================================================================*/

BOOL CALLBACK  AddInstrumentPages (
    LPCTSTR                     pszTitle,
    LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,
    LPARAM                      lParam)
{
    HPROPSHEETPAGE hpsp;
    TCHAR          sz[MAX_ALIAS];

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("AddInstrumentPages(%08X,%08X,%08X)\r\n"),
		pszTitle, lpfnAddPropSheetPage, lParam);
#endif

    LoadString (ghInstance, IDS_GENERAL, sz, NUMELMS(sz));
    hpsp = AddPropPage (sz,
			lpfnAddPropSheetPage,
			MidiInstrumentDlgProc,
			IDD_INSTRUMENT_GEN,
			lParam);
    if ( ! hpsp)
	return FALSE;

    LoadString (ghInstance, IDS_MIDIDETAILS, sz, NUMELMS(sz));
    hpsp = AddPropPage (sz,
			lpfnAddPropSheetPage,
			MidiInstrumentDlgProc,
			IDD_INSTRUMENT_DETAIL,
			lParam);

    return (hpsp != NULL);
}


/*+ AddDevicePages
 *
 *  add a midi page to a property sheet.  Invoked from Advanced tab
 *  of Multimedia control panel when class midi is selected from
 *  the list.
 *
 *-=================================================================*/

BOOL CALLBACK  AddDevicePages (
    LPCTSTR                     pszTitle,
    LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,
    LPARAM                      lParam)
{
    HPROPSHEETPAGE hpsp;
    TCHAR          sz[MAX_ALIAS];

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("AddInstrumentPages(%08X,%08X,%08X)\r\n"),
		pszTitle, lpfnAddPropSheetPage, lParam);
#endif

    LoadString (ghInstance, IDS_MIDIDETAILS, sz, NUMELMS(sz));
    hpsp = AddPropPage (sz,
			lpfnAddPropSheetPage,
			MidiInstrumentDlgProc,
			IDD_DEVICE_DETAIL,
			lParam);

    return (hpsp != NULL);
}


/*+ ShowDetails
 *
 *  Show Instrument or device details sheet and allow edits
 *  return TRUE if changes were made
 *
 *-=================================================================*/

struct _show_details_args {
    PMCLOCAL        pmcl;
    BOOL            bChanged;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[2];
    };

BOOL CALLBACK fnPropCallback (
    DWORD dwFunc,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2,
    DWORD_PTR dwInstance)
{
    struct _show_details_args * psda = (LPVOID)dwInstance;

    assert (psda);
    if (!psda)
	return FALSE;

    switch (dwFunc)
    {
	case MM_EPS_GETNODEDESC:
	    *(LPTSTR)dwParam1 = 0;
	    if (psda->pmcl->piSingle)
	       lstrcpyn ((LPTSTR)dwParam1, psda->pmcl->piSingle->szFriendly, (int)(dwParam2/sizeof(TCHAR)));
	    break;

	case MM_EPS_GETNODEID:
	    *(LPTSTR)dwParam1 = 0;
	    if (psda->pmcl->piSingle)
	    {
		lstrcpy ((LPTSTR)dwParam1, cszMidiSlash);
		lstrcat ((LPTSTR)dwParam1, psda->pmcl->piSingle->szKey);
	    }
	    break;

	case MM_EPS_ADDSHEET:
	    if (psda->psh.nPages >= NUMELMS(psda->hpsp)-1)
		return FALSE;
	    psda->psh.phpage[psda->psh.nPages++] = (HPROPSHEETPAGE)dwParam1;
	    break;

	case MM_EPS_TREECHANGE:
	    psda->bChanged = TRUE;
	    break;

	default:
	    return FALSE;
    }

    return TRUE;
}

BOOL WINAPI ShowDetails (
    HWND     hWnd,
    PMCLOCAL pmcl)
{
    struct _show_details_args sda;
    TCHAR           szTitle[MAX_ALIAS];
    HPROPSHEETPAGE  hpsp;
    UINT            idDlg;

    idDlg = IDD_DEVICE_DETAIL;
    if (pmcl->piSingle && pmcl->piSingle->piParent)
	idDlg = IDD_INSTRUMENT_DETAIL;

    ZeroMemory (&sda, sizeof(sda));
    sda.pmcl            = pmcl;
    sda.psh.dwSize      = sizeof(sda.psh);
    sda.psh.dwFlags     = PSH_PROPTITLE;
    sda.psh.hwndParent  = hWnd;
    sda.psh.hInstance   = ghInstance;
    sda.psh.pszCaption  = MAKEINTRESOURCE (IDS_MMPROP);
    sda.psh.nPages      = 0;
    sda.psh.nStartPage  = 0;
    sda.psh.phpage      = sda.hpsp;

    LoadString (ghInstance, IDS_MIDIDETAILS, szTitle, NUMELMS(szTitle));
    hpsp = AddPropPage (szTitle,
			fnPropCallback,
			MidiInstrumentDlgProc,
			idDlg,
			(LPARAM)&sda);
    if (hpsp)
	sda.psh.nPages = 1;

    PropertySheet (&sda.psh);
    return sda.bChanged;
}

/*+ AddMidiPages
 *
 *  add a midi page to a property sheet.  Invoked from Advanced tab
 *  of Muitimedia control panel when class midi is selected from
 *  the list.
 *
 *-=================================================================*/

BOOL CALLBACK  AddMidiPages (
    LPCTSTR                     pszTitle,
    LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,
    LPARAM                      lParam)
{
    HPROPSHEETPAGE hpsp;
    TCHAR          sz[MAX_ALIAS];

    LoadString (ghInstance, IDS_GENERAL, sz, NUMELMS(sz));
    hpsp = AddPropPage (sz,
			lpfnAddPropSheetPage,
			MidiClassDlgProc,
			IDD_MIDICLASS_GEN,
			lParam);
    return (hpsp != NULL);
}


/*+ AddSimpleMidiPages
 *
 *  add a midi page to a MM control panel.
 *
 *-=================================================================*/

BOOL CALLBACK  AddSimpleMidiPages (
    LPTSTR                      pszTitle,
    LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,
    LPARAM                      lParam)
{
    HPROPSHEETPAGE hpsp;
    //static CONST TCHAR sz[13] = TEXT ("            ");
    //UINT cch = lstrlen (pszTitle);

    DebugSetOutputLevel (GetProfileInt(TEXT ("Debug"), TEXT ("midiprop"), 0));

    // pad my tab to 12 spaces so it looks nice with the
    // other simple tabls (as per request of vijr)
    //
    //if (cch < NUMELMS(sz)-2)
    //{
    //    lstrcpy (sz + NUMELMS(sz)/2 - cch/2, pszTitle);
    //    pszTitle = sz;
    //    pszTitle[lstrlen(pszTitle)] = TEXT (' ');
    //}

    hpsp = AddPropPage (pszTitle,
			lpfnAddPropSheetPage,
			MidiCplDlgProc,
			IDD_CPL_MIDI2,
			lParam);
    return (hpsp != NULL);
}


/*
 ***************************************************************
 *  BOOL PASCAL LoadDesc(LPCTSTR pszFile, LPCTSTR pszDesc)
 *      This function gets the description string from the executable
 *      file specified. We first try to get the string from the version info
 *      If that fails then we try to get the string from the exehdr.
 *      If that fails we return a NULL string. 
 *      Return TRUE on success, else FALSE.
 ***************************************************************
 */

BOOL PASCAL LoadDesc(LPCTSTR pszFile, LPTSTR pszDesc)
{
   LPTSTR           psz;
   static TCHAR     szProfile[MAXSTR];
   UINT             cchSize;
   HANDLE           hFind;
   WIN32_FIND_DATA  wfd;
  
   DPF (TEXT ("LoadDesc: %s\r\n"), pszFile);

   // Make sure file exists
   hFind = FindFirstFile (pszFile, &wfd);
   if (hFind == INVALID_HANDLE_VALUE)
	   return(FALSE);
   FindClose (hFind);

   // Get User Friendly name from Version Info
   if (GetVerDesc (wfd.cFileName, pszDesc))
	   return TRUE;

   //
   // As a last resort, look at the description in the Executable Header
   //

   cchSize = sizeof(szProfile)/sizeof(TCHAR);
   if ((! GetExeDesc (wfd.cFileName, szProfile, cchSize)) ||
	    (lstrlen (szProfile) < 3))
      {
	   *pszDesc = 0;
	   return(FALSE);    
      }
   else    
      {    
	   // There is EXEHDR information Parse according to driver spec
	   psz = szProfile;
	   while (*psz && *psz++ != TEXT (':'))
	      {
	      ; // skip type information
	      }
	   if (!(*psz))
	      psz = szProfile;
	   lstrcpy (pszDesc, psz);
	   return(TRUE);
      }
}


/* BOOL FAR PASCAL GetExeDesc(szFile, szBuff, cchBuff)
 *
 *  Function will return the an executable's description
 *
 *      szFile      - Path Name a new exe
 *      pszBuf      - Buffer to place returned info
 *      cchBuf      - Size of buffer (in characters
 *
 *  returns:  TRUE if successful, FALSE otherwise.
 */

STATIC BOOL FAR PASCAL GetExeDesc(
    LPTSTR  szFile, 
    LPTSTR  pszBuff, 
    int     cchBuff)
{
   DWORD             dwSig;
   WORD              wSig;
   HANDLE            hFile;
   DWORD             offset;
   BYTE              cbLen;
   DWORD             cbRead;
   IMAGE_DOS_HEADER  doshdr;    // Original EXE Header

      // Open File
   hFile = CreateFile (szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
		       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
   if (hFile == INVALID_HANDLE_VALUE)
      return FALSE;

   // Get Original Dos Header
   if ((! ReadFile (hFile, (LPVOID)&doshdr, sizeof(doshdr), &cbRead, NULL)) ||
       (cbRead != sizeof(doshdr)) ||             // Read Error
       (doshdr.e_magic != IMAGE_DOS_SIGNATURE))  // Invalid DOS Header
      {
      goto error;        /* Abort("Not an exe",h); */
      }

   // Seek to new header
   offset = doshdr.e_lfanew;
   SetFilePointer (hFile, offset, NULL, FILE_BEGIN);
   
   // Read in signature
   if ((! ReadFile (hFile, (LPVOID)&dwSig, sizeof(dwSig), &cbRead, NULL)) ||
       (cbRead != sizeof(dwSig)))            // Read Error
      {
      goto error;        /* Abort("Not an exe",h); */
      }
   wSig = LOWORD (dwSig);

   if (dwSig == IMAGE_NT_SIGNATURE)
      {   
      DPF (TEXT ("GetExeDesc: NT Portable Executable Format\r\n"));

      // NOTE - The NT Portatble Executable Format does not store
      //        the executable's user friendly name.
      goto error;
      }
   else if (wSig == IMAGE_OS2_SIGNATURE) 
      {
      IMAGE_OS2_HEADER  winhdr;    // New Windows/OS2 header
      TCHAR              szInfo[256];

      DPF (TEXT ("GetExeDesc: Windows or OS2 Executable Format\r\n"));

      // Seek to Windows Header
      offset = doshdr.e_lfanew;
      SetFilePointer (hFile, offset, NULL, FILE_BEGIN);

      // Read Windows Header
      if ((! ReadFile (hFile, (LPVOID)&winhdr, sizeof(winhdr), 
		       &cbRead, NULL)) || 
	  (cbRead != sizeof(winhdr)) || // Read Error
	  (winhdr.ne_magic != IMAGE_OS2_SIGNATURE)) // Invalid Windows Header
	 {
	 goto error;
	 }

      // Seek to module name which is the first entry in the non-resident name table
      offset = winhdr.ne_nrestab;
      SetFilePointer (hFile, offset, NULL, FILE_BEGIN);

      // Get Size of Module Name
      if ((! ReadFile (hFile, (LPVOID)&cbLen, sizeof(BYTE),
		       &cbRead, NULL)) || 
	  (cbRead != sizeof(BYTE)))
	 {
	 goto error;
	 }

      cchBuff--;         // leave room for a \0

      if (cbLen > (BYTE)cchBuff)
	 cbLen = (BYTE)cchBuff;

      // Read Module Name
      if ((! ReadFile (hFile, (LPVOID)szInfo, cbLen,
		       &cbRead, NULL)) || 
	  (cbRead != cbLen))
	 {
	 goto error;
	 }
      szInfo[cbLen] = 0;

      // Copy to Buffer
      lstrcpy (pszBuff, szInfo);
      }
   else if (wSig == IMAGE_VXD_SIGNATURE)
      {
      IMAGE_VXD_HEADER  vxdhdr;    // New Windows/OS2 VXD  Header
      TCHAR              szInfo[256];

      DPF (TEXT ("GetExeDesc: Windows or OS2 VXD Executable Format\r\n"));

      // Seek to VXD Header
      offset = doshdr.e_lfanew;
      SetFilePointer (hFile, offset, NULL, FILE_BEGIN);

      // Read VXD Header
      if ((! ReadFile (hFile, (LPVOID)&vxdhdr, sizeof(vxdhdr), 
		       &cbRead, NULL)) || 
	  (cbRead != sizeof(vxdhdr)) || // Read Error
	  (vxdhdr.e32_magic != IMAGE_VXD_SIGNATURE)) // Invalid VXD Header
	 {
	 goto error;
	 }

      // Seek to module name which is the first entry in the non-resident name table
      offset = vxdhdr.e32_nrestab;
      SetFilePointer (hFile, offset, NULL, FILE_BEGIN);

      // Get Size of Module Name
      if ((! ReadFile (hFile, (LPVOID)&cbLen, sizeof(BYTE),
		       &cbRead, NULL)) || 
	  (cbRead != sizeof(BYTE)))
	 {
	 goto error;
	 }

      cchBuff--;         // leave room for a \0

      if (cbLen > (BYTE)cchBuff)
	 cbLen = (BYTE)cchBuff;

      // Read Module Name
      if ((! ReadFile (hFile, (LPVOID)szInfo, cbLen,
		       &cbRead, NULL)) || 
	  (cbRead != cbLen))
	 {
	 goto error;
	 }
      szInfo[cbLen] = 0;

      // Copy to Buffer
      lstrcpy (pszBuff, szInfo);
      }
   else
      {
      DPF (TEXT ("GetExeDesc: Unknown Executable\r\n"));
      goto error;        /* Abort("Not an exe",h); */
      }

   CloseHandle (hFile);
   return TRUE;

error:
   CloseHandle (hFile);
   return FALSE;
}


/*
 ***************************************************************
 * STATIC INT_PTR GetVerDesc
 *      Loads the version DLL and uses it to get Version Description string 
 *      from the specified file.
 ***************************************************************
 */

STATIC INT_PTR PASCAL GetVerDesc (LPCTSTR pstrFile, LPTSTR pstrDesc)
{
    DWORD_PTR dwVerInfoSize;
    DWORD dwVerHnd;
    INT_PTR  bRetCode;

	bRetCode = FALSE;

    DPF( TEXT ("Getting VERSION string for %s \r\n"), pstrFile);

    dwVerInfoSize = GetFileVersionInfoSize (pstrFile, &dwVerHnd);

    if (dwVerInfoSize) 
    {
	LPBYTE   lpVffInfo;             // Pointer to block to hold info

	// Get a block big enough to hold version info
	if (lpVffInfo  = (LPBYTE) GlobalAllocPtr(GMEM_MOVEABLE, dwVerInfoSize)) 
	{


	   // Get the File Version first
	    if (GetFileVersionInfo (pstrFile, 0L, 
				    dwVerInfoSize, lpVffInfo)) 
	    {
		static SZCODE cszFileDescr[] = TEXT ("\\StringFileInfo\\040904E4\\FileDescription");
		TCHAR   szBuf[MAX_PATH];
		LPTSTR  lpVersion;       
		WORD    wVersionLen;

		   // Now try to get the FileDescription
		   // First try this for the "Translation" entry, and then
		   // try the American english translation.  
		   // Keep track of the string length for easy updating.  
		   // 040904E4 represents the language ID and the four 
		   // least significant digits represent the codepage for 
		   // which the data is formatted.  The language ID is 
		   // composed of two parts: the low ten bits represent 
		   // the major language and the high six bits represent 
		   // the sub language.

		lstrcpy(szBuf, cszFileDescr);
     
		wVersionLen   = 0;
		lpVersion     = NULL;

		// Look for the corresponding string. 
		bRetCode = VerQueryValue((LPVOID)lpVffInfo,    
					 (LPTSTR)szBuf,
					 (void FAR* FAR*)&lpVersion,
					 (UINT FAR *) &wVersionLen);

		if (bRetCode && wVersionLen > 2 && lpVersion)
		{
		    lstrcpy (pstrDesc, lpVersion);
		}
		else
		    bRetCode = FALSE;


		// Let go of the memory
		GlobalFreePtr(lpVffInfo);
	    }
	}
    } else
	bRetCode = FALSE;
    return bRetCode;
}




LONG SHRegDeleteKey(HKEY hKey, LPCTSTR lpSubKey)
{
    LONG    lResult;
    HKEY    hkSubKey;
    DWORD   dwIndex;
    TCHAR   szSubKeyName[MAX_PATH + 1];
    DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
    TCHAR   szClass[MAX_PATH];
    DWORD   cchClass = ARRAYSIZE(szClass);
    DWORD   dwDummy1, dwDummy2, dwDummy3, dwDummy4, dwDummy5, dwDummy6;
    FILETIME ft;

    // Open the subkey so we can enumerate any children
    lResult = RegOpenKeyEx(hKey, lpSubKey, 0, KEY_ALL_ACCESS, &hkSubKey);
    if (ERROR_SUCCESS == lResult)
    {
	// I can't just call RegEnumKey with an ever-increasing index, because
	// I'm deleting the subkeys as I go, which alters the indices of the
	// remaining subkeys in an implementation-dependent way.  In order to
	// be safe, I have to count backwards while deleting the subkeys.

	// Find out how many subkeys there are
	lResult = RegQueryInfoKey(hkSubKey, 
				  szClass, 
				  &cchClass, 
				  NULL, 
				  &dwIndex, // The # of subkeys -- all we need
				  &dwDummy1,
				  &dwDummy2,
				  &dwDummy3,
				  &dwDummy4,
				  &dwDummy5,
				  &dwDummy6,
				  &ft);

	if (ERROR_SUCCESS == lResult)
	{
	    // dwIndex is now the count of subkeys, but it needs to be 
	    // zero-based for RegEnumKey, so I'll pre-decrement, rather
	    // than post-decrement.
	    while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
	    {
		SHRegDeleteKey(hkSubKey, szSubKeyName);
	    }
	}

	RegCloseKey(hkSubKey);

	lResult = RegDeleteKey(hKey, lpSubKey);
    }
    
    return lResult;
} // End SHRegDeleteKey


/* DeviceIDFromDriverName
 *
 * Query MMSYSTEM to find the given device. Return its base device ID.
 * Return -1 if we cannot find the driver
 */
static UINT
DeviceIDFromDriverName(
    PTSTR pstrDriverName)
{
    UINT idxDev;
    UINT cPorts;
    DWORD cPort;
    PTSTR pstrDriver;
    MMRESULT mmr;


    if (NULL == (pstrDriver = LocalAlloc(LPTR, MAX_ALIAS*sizeof(TCHAR))))
    {
        AuxDebugEx(3, DEBUGLINE TEXT("DN->ID: LocalAlloc() failed.\r\n"));
        return (UINT)-1;
    }

    // Walk through the base device ID of each driver. Use MMSYSTEM's
    // driver query messages to find out how many ports & the driver name
    //
    cPorts = midiOutGetNumDevs();
    for (idxDev = 0; idxDev < cPorts; idxDev++)
    {
        if (MMSYSERR_NOERROR != (mmr = midiOutMessage(HMIDIOUT_INDEX(idxDev),
            DRV_QUERYNUMPORTS,
            (DWORD_PTR)(LPDWORD)&cPort,
            0)))
        {
            // Something is wrong with this driver. Skip it
            //
            AuxDebugEx(3, DEBUGLINE TEXT("DN->ID: DRV_QUERYNUMPORTS(%u)->%u\r\n"),
                       (UINT)idxDev,
                       (UINT)mmr);
            continue;
        }

        if (MMSYSERR_NOERROR != (mmr = midiOutMessage(HMIDIOUT_INDEX(idxDev),
            DRV_QUERYDRVENTRY,
            (DWORD_PTR)(LPTSTR)pstrDriver,
            MAX_ALIAS)))
        {
            AuxDebugEx(3, DEBUGLINE TEXT("DN->ID: DRV_QUERYDRVENTRY(%u)->%u\r\n"),
                       (UINT)idxDev,
                       (UINT)mmr);
            continue;
        }

        if (!_tcscmp(pstrDriver, pstrDriverName))
            break;
    }

    if (idxDev >= cPorts)
    {
        AuxDebugEx(3, DEBUGLINE TEXT("DN->ID: No match for [%s]\r\n"),
                   (LPTSTR)pstrDriverName);
        idxDev = (UINT)-1;
    }
    else
        AuxDebugEx(3, DEBUGLINE TEXT("DN->ID: [%s] at %d\r\n"),
                   (LPTSTR)pstrDriverName,
                   (int)idxDev);

    LocalFree(pstrDriver);
    return (int)idxDev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\medhelp.h ===
// Context Help IDs for the Sound and Multimedia Control Panels                 
// Updated: 5-12-00, with new values for MMC Panels. See "Updated"
// section at bottom of file for new entries. 
// Pete Mentele
//


#ifndef NO_HELP
#define NO_HELP                                 ((DWORD) -1) // Disables Help for a control
#endif

#define IDH_COMM_GROUPBOX                       28548  // Value copied from help.h
#define IDH_FPROP_GEN_NAME                      4708   // Value copied from help.h
#define IDH_FPROP_GEN_ICON                      4779   // Value copied from help.h

#define IDH_ADDMIDI_CHANNEL                     2400
#define IDH_ADDMIDI_INSTRUMENT                  2401
#define IDH_ADV_PROPERTIES                      2402
#define IDH_AUDIO_CUST_ATTRIB                   2403
#define IDH_AUDIO_CUST_FORMAT                   2404
#define IDH_AUDIO_CUST_NAME                     2405
#define IDH_AUDIO_CUST_REMOVE                   2406
#define IDH_AUDIO_CUST_SAVEAS                   2407
#define IDH_AUDIO_PLAY_PREFER_DEV               2408
#define IDH_AUDIO_PLAY_VOL                      2409
#define IDH_AUDIO_REC_CUST                      2410
#define IDH_AUDIO_REC_PREFER_DEV                2411
#define IDH_AUDIO_REC_PREFER_QUAL               2412
#define IDH_AUDIO_REC_VOL                       2413
#define IDH_AUDIO_USE_PREF_ONLY                 2414
#define IDH_AUDIO_PLAY_PREFER_QUAL              2417
#define IDH_AUDIO_PLAY_CUST                     2418
#define IDH_CD_PLAY_ANALOG                      2420
#define IDH_CD_VOL_HEADPHONE                    2420
#define IDH_EVENT_BROWSE                        2422
#define IDH_EVENT_DELETE_BUTTON                 2423
#define IDH_EVENT_EVENT                         2424
#define IDH_EVENT_FILE                          2425
#define IDH_EVENT_LABEL                         2427
#define IDH_EVENT_PLAY                          2428
#define IDH_EVENT_SAVEAS_BUTTON                 2430
#define IDH_EVENT_SCHEME                        2431
#define IDH_SOUNDS_SYS_VOL_CONTROL              2432
#define IDH_EVENT_STOP                          2434
#define IDH_GENERIC_DEVICES                     2435
#define IDH_MIDI_ADD_NEW                        2436
#define IDH_MIDI_CFGDLG_CHANGE                  2437
#define IDH_MIDI_CFGDLG_DELETE                  2438
#define IDH_MIDI_CFGDLG_SAVEAS                  2439
#define IDH_MIDI_CFGDLG_SCHEME                  2440
#define IDH_MIDI_CONFIG_SCHEME                  2441
#define IDH_MIDI_CUST_CONFIG                    2442
#define IDH_MIDI_INSTRUMENTS                    2443
#define IDH_MIDI_SAVEDLG_SCHEMENAME             2444
#define IDH_MIDI_SCHEME                         2445
#define IDH_MIDI_SINGLE_INST                    2446
#define IDH_MMCPL_DEVPROP_ABOUT                 2447
#define IDH_MMCPL_DEVPROP_CHANGE_PRI            2448
#define IDH_MMCPL_DEVPROP_DETAILS_BROWSE        2449
#define IDH_MMCPL_DEVPROP_DETAILS_INS_DEF       2450
#define IDH_MMCPL_DEVPROP_DETAILS_INSTRUMENT    2451
#define IDH_MMCPL_DEVPROP_DISABLE               2452
#define IDH_MMCPL_DEVPROP_DONT_MAP              2453
#define IDH_MMCPL_DEVPROP_ENABLE                2454
#define IDH_MMCPL_DEVPROP_REMOVE                2455
#define IDH_MMCPL_DEVPROP_SETTINGS              2456
#define IDH_ADD_DRIVER_LIST                     2457
#define IDH_MIDI_SINGLE_INST_BUTTON             2458
#define IDH_SAVEAS_SCHEMENAME                   2459
#define IDH_VIDEO_FIXED_WINDOW                  2460
#define IDH_VIDEO_FULL_SCREEN                   2461
#define IDH_VIDEO_GRAPHIC                       2462
#define IDH_MMCPL_DEVPROP_DETAILS_MIDI_PORT     2463
#define IDH_MIDI_SINGLE_INST_LIST               2464
#define IDH_MMCPL_DEVPROP_INST_LIST             2465
#define IDH_ADV_ADDDRIVER                       2466
#define IDH_AUDIO_SHOW_INDICATOR                2467
#define IDH_CD_CDROM_DRIVE                      2468
#define IDH_EVENT_BROWSE_PREVIEW                2469
#define IDH_FCAB_MM_COPYRIGHT                   2470
#define IDH_FCAB_MM_FILELEN                     2471
#define IDH_FCAB_MM_AUDIOFORMAT                 2472
#define IDH_FCAB_MM_MIDISEQUENCENAME            2473
#define IDH_FCAB_MM_VIDEOFORMAT                 2474
#define IDH_FCAB_MM_DETAILSINFO                 2475
#define IDH_FCAB_MM_PREVIEW_CONTROL             2476
#define IDH_AUDIO_CUST_SAVEAS_SAVE_FORMAT       2477
#define IDH_VIDEO_ADVANCED_BUTTON               2478
#define IDH_VIDEO_ADVANCED_COMPAT               2479

// 2480 - 2499 reserved for joy.cpl.

//////////////
// Help ID's for advanced audio dialog
//////////////

#define IDH_ADV_AUDIO_ACCELERATION              2602
#define IDH_ADV_AUDIO_SRCQUALITY                2603
#define IDH_ADV_AUDIO_RESTOREDEFAULTS           2604
#define IDH_ADV_AUDIO_PLAY_PROP                 2605
#define IDH_ADV_AUDIO_REC_PROP                  2606
#define IDH_SPEAKERS_PICKER                     2607
#define IDH_SPEAKERS_IMAGE                      2608
#define IDH_CD_CDROM_VOLUME                     2609

//////////////
// Help ID's for advanced Voice dialog
//////////////

#define IDH_VOICE_SPEAKERICON                   2624
#define IDH_VOICE_LAUNCH_VOCVOL                 2623
#define IDH_VOICE_PLAYBACK_ADVVOC               2627
#define IDH_VOICE_RECORDICON                    2625
#define IDH_VOICE_LAUNCH_CAPVOL                 2622
#define IDH_VOICE_CAPTURE_ADVVOL                2626
#define IDH_VOICE_ADVANCED_TEST                 2621 

#define IDH_SOUNDS_VOL_MUTE_BUTTON              90001
#define IDH_AUDIO_MIDI_VOL                      90002
#define IDH_CDROM_PROPERTIES_DIGITAL	        90003

//////////////
// Generic Help ID for the about dialog box
// Displays in MIDI Music Playback group box, 
// under Audio tab.
//////////////
#define IDH_ABOUT	80000


///////////////////////
//
// Updated: 5-12-00, by Pete Mentele
// New values for additions made by Roger Wynn, inserted by Pete Mentele. 
//
// Using values 2500-2599 for the following items.
//
///////////////////////

// Volume Page
#define IDH_VOLUME_BRAND                        2500
#define IDH_VOLUME_MIXER                        2502
#define IDH_LAUNCH_MULTICHANNEL                 2510

// Multichannel Page
#define IDH_MC_ALL_SLIDERS                      2514
#define IDH_MC_MOVE_TOGETHER                    2560
#define IDH_MC_RESTORE                          2562

// Effects
#define IDH_EFFECT_STATIC                       2584
#define IDH_EFFECT_UP                           2586
#define IDH_EFFECT_DOWN                         2588
#define IDH_EFFECT_PROP                         2590
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\legcyinf.c ===
#include "mmcpl.h"

#include <tchar.h>
#include <initguid.h>
#include <devguid.h>

#include "drivers.h"
#include "sulib.h"
#include "trayvol.h"
#include "debug.h"

static PTSTR szLocalAllocFailMsg = TEXT("Failed memory allocation\n");

#define GUESS_LEGACY_SERVICE_NAME 0
#define tsizeof(s)  (sizeof(s)/sizeof(TCHAR))

// Generic listnode structure
typedef struct _LISTNODE
{
    struct _LISTNODE *pNext;
} LISTNODE;

// Structure describing a source disk entry
typedef struct _SOURCEDISK
{
    struct _SOURCEDISK *pNext;  // Next source disk in list
    TCHAR szDiskName[_MAX_PATH]; // Description of this disk
    int   DiskId;
} SOURCEDISK;

// Structure describing a file to copy
// We keep a list of these files in two places:
// 1. A global list of all files copied by the inf attached to the LEGACY_INF struct.
// 2. A pair driver-specific lists (user & kernel) attached to the LEGACY_DRIVER struct.
typedef struct _FILETOCOPY
{
    struct _FILETOCOPY *pNext;      // Next file to copy
    TCHAR szFileName[_MAX_FNAME];   // Name of file to copy
    int   DiskId;
} FILETOCOPY;

// Structure representing a legacy driver's information
typedef struct _LEGACY_DRIVER
{
    struct _LEGACY_DRIVER *pNext;

    TCHAR szDevNameKey[32];     // Device name key
    TCHAR szUserDevDrv[32];     // User-level device driver
    TCHAR szClasses[128];       // List of device classes this driver supports
    TCHAR szDesc[128];          // Description of device
    TCHAR szVxD[32];            // Name of VxD driver (not supported)
    TCHAR szParams[128];        // Params (not supported)
    TCHAR szDependency[128];    // Dependent device (not supported)
    FILETOCOPY *UserCopyList;   // List of all user files to copy
    FILETOCOPY *KernCopyList;   // List of all kernel files to copy
} LEGACY_DRIVER;

// Structure representing a legacy inf
typedef struct _LEGACY_INF
{
    struct _LEGACY_INF *pNext;

    TCHAR szLegInfPath[_MAX_PATH];   // Path to original legacy inf
    TCHAR szNewInfPath[_MAX_PATH];   // Path to converted inf
    LEGACY_DRIVER *DriverList;      // List of all drivers in this inf
    SOURCEDISK *SourceDiskList;     // List of all source disks in this inf
    FILETOCOPY *FileList;           // List of all files copied as part of this inf
} LEGACY_INF;

// Root structure for the whole tree
typedef struct _PROCESS_INF_INFO
{
    TCHAR szLegInfDir[_MAX_PATH];    // Directory where legacy infs are located
    TCHAR szNewInfDir[_MAX_PATH];    // Temp directory where new infs are generated
    TCHAR szSysInfDir[_MAX_PATH];    // Windows inf directory
    TCHAR szTemplate[_MAX_PATH];     // Template to search for
    LEGACY_INF *LegInfList;          // List of all infs to be converted
} PROCESS_INF_INFO;

#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
// Debugging routine to dump the contents of a LEGACY_INF list
void DumpLegacyInfInfo(PROCESS_INF_INFO *pPII)
{
    LEGACY_INF *pLI;
    LEGACY_DRIVER *pLD;

    for (pLI=pPII->LegInfList;pLI;pLI=pLI->pNext)
    {
        dlog1("Dumping legacy inf %s\n",pLI->szLegInfPath);

        dlog("Dump of legacy driver info:\n");
        for (pLD=pLI->DriverList; pLD; pLD=pLD->pNext)
        {
            dlog1("DriverNode=0x%x",    pLD);
            dlog1("\tszDevNameKey=%s",  pLD->szDevNameKey);
            dlog1("\tszUserDevDrv=%s",  pLD->szUserDevDrv);
            dlog1("\tszClasses=%s",     pLD->szClasses);
            dlog1("\tszDesc=%s",        pLD->szDesc);
            dlog1("\tszVxD=%s",         pLD->szVxD);
            dlog1("\tszParams=%s",      pLD->szParams);
            dlog1("\tszDependency=%s",  pLD->szDependency);
        }
    }

    return;
}
#else
    #define DumpLegacyInfInfo()
#endif


// Function to remove a directory tree and all its subtrees
void RemoveDirectoryTree(PTSTR szDirTree)
{
    TCHAR  PathBuffer[_MAX_PATH];
    PTSTR CurrentFile;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

	PathBuffer[0] = '\0';

    // Build a file spec to find all files in specified directory
    // (i.e., <DirPath>\*.INF)
    lstrcpyn(PathBuffer, szDirTree, ARRAYSIZE(PathBuffer));
    catpath(PathBuffer,TEXT("\\*"));

    // Get a pointer to the end of the path part of the string
    // (minus the wildcard filename), so that we can append
    // each filename to it.
    CurrentFile = _tcsrchr(PathBuffer, TEXT('\\')) + 1;

    FindHandle = FindFirstFile(PathBuffer, &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        return;
    }

    do
    {
        // Skip '.' and '..' files, or else we crash!
        if ( (!_tcsicmp(FindData.cFileName,TEXT("."))) ||
             (!_tcsicmp(FindData.cFileName,TEXT(".."))) )
        {
            continue;
        }

        // Build the full pathname.
        _tcscpy(CurrentFile, FindData.cFileName);

        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            RemoveDirectoryTree(PathBuffer);
        }
        else
        {
            DeleteFile(PathBuffer);
        }
    } while (FindNextFile(FindHandle, &FindData));

    // Remember to close the find handle
    FindClose(FindHandle);

    // Now remove the directory
    RemoveDirectory(szDirTree);

    return;
}

// Generic routine to free a list
void FreeList(LISTNODE *pList)
{
    LISTNODE *pNext;
    while (pList)
    {
        pNext = pList->pNext;
        LocalFree(pList);
        pList=pNext;
    }

    return;
}

// Routine to free all memory that is part of a PROCESS_INF_INFO struct
void DestroyLegacyInfInfo(PROCESS_INF_INFO *pPII)
{

    LEGACY_INF    *pLIList, *pLINext;
    LEGACY_DRIVER *pLDList, *pLDNext;

    pLIList=pPII->LegInfList;
    while (pLIList)
    {
        pLINext = pLIList->pNext;

        pLDList = pLIList->DriverList;
        while (pLDList)
        {
            pLDNext = pLDList->pNext;

            // Free file copy lists
            FreeList((LISTNODE *)pLDList->UserCopyList);
            FreeList((LISTNODE *)pLDList->KernCopyList);

            // Free Driver node
            LocalFree(pLDList);

            pLDList = pLDNext;
        }

        // Free the source disk list
        FreeList((LISTNODE *)pLIList->SourceDiskList);

        // Free the file list
        FreeList((LISTNODE *)pLIList->FileList);

        // Free up the legacy inf structure
        LocalFree(pLIList);

        pLIList = pLINext;
    }

    // Free the pPII struct
    LocalFree(pPII);

    return;
}

// Searches a file list for a matching entry
FILETOCOPY *FindFile(PTSTR szFileName, FILETOCOPY *pFileList)
{
    FILETOCOPY *pFTC;

    for (pFTC=pFileList;pFTC;pFTC=pFTC->pNext)
    {
        if (!_tcsicmp(szFileName,pFTC->szFileName))
        {
            return pFileList;
        }
    }

    return NULL;
}

// Generic function for adding a file to a copy list
BOOL AddFileToFileList(PTSTR szFileName, int DiskId, FILETOCOPY **ppList)
{
    FILETOCOPY *pFTC;

    // Only add the entry if another one doesn't already exist
    if (!FindFile(szFileName,*ppList))
    {
        pFTC = (FILETOCOPY *)LocalAlloc(LPTR, sizeof(FILETOCOPY));
        if (!pFTC)
        {
            dlogt(szLocalAllocFailMsg);
            return FALSE;
        }

        // Save the fields
        pFTC->DiskId=DiskId;
        _tcscpy(pFTC->szFileName,szFileName);

        // Put it in the list
        pFTC->pNext=(*ppList);
        (*ppList)=pFTC;
    }

    return TRUE;
}

// Add a file to both the global and driver-specific copy lists
BOOL AddFileToCopyList(LEGACY_INF *pLI, LEGACY_DRIVER *pLD, TCHAR *szIdFile)
{
    int DiskId;
    TCHAR *szFileName;

    // szFile has both a disk ID and a file name, e.g. "1:foo.drv"
    // Get the disk ID and file name from szFile
    DiskId = _ttol(szIdFile);
    szFileName = RemoveDiskId(szIdFile);

    // Add the file to the global list
    AddFileToFileList(szFileName,DiskId,&(pLI->FileList));

    // Add the file to the correct driver-specific list
    if (IsFileKernelDriver(szFileName))
    {
        AddFileToFileList(szFileName,DiskId,&(pLD->KernCopyList));
    }
    else
    {
        AddFileToFileList(szFileName,DiskId,&(pLD->UserCopyList));
    }

    return TRUE;
}

// Build the data structure associated with a legacy inf file
// and return a pointer to it, or NULL if failure
LEGACY_INF *CreateLegacyInf(IN PCTSTR szLegInfPath)
{
    HINF hInf;              // Handle to the legacy inf
    INFCONTEXT InfContext;  // Inf context struct for parsing inf file

    LEGACY_INF *pLI;        // Struct describing this inf
    LEGACY_DRIVER *pLDList; // ptrs to drivers in this inf
    LEGACY_DRIVER *pLD;
    TCHAR szIdFile[32];     // Holds <DiskId>:<File> strings, e.g. "1:foo.drv"
    int MediaDescFieldId;

    // Open the inf file
    hInf = SetupOpenInfFile( szLegInfPath, NULL, INF_STYLE_OLDNT, NULL);
    if (hInf==INVALID_HANDLE_VALUE)
    {
        return NULL;
    }

    // Try to open the Installable.drivers32 or Installable.drivers section
    if (!SetupFindFirstLine(  hInf,TEXT("Installable.drivers32"),NULL,&InfContext))
    {
        if (!SetupFindFirstLine(  hInf,TEXT("Installable.drivers"),NULL,&InfContext))
        {
            SetupCloseInfFile(hInf);
            return NULL;
        }
    }

    // Allocate the LEGACY_INF struct which is the root of the data struct
    pLI = (LEGACY_INF *)LocalAlloc(LPTR, sizeof(LEGACY_INF));
    if (!pLI)
    {
        dlogt(szLocalAllocFailMsg);
        SetupCloseInfFile(hInf);
        return NULL;
    }

    // Save off the path to the legacy inf
    _tcscpy(pLI->szLegInfPath, szLegInfPath);

    // Init all other fields to 'safe' values
    pLI->szNewInfPath[0]='\0';
    pLI->DriverList=NULL;
    pLI->SourceDiskList=NULL;
    pLI->FileList=NULL;

    // Build legacy driver list
    pLDList = NULL;
    do
    {
        // Allocate a structure to hold info about this driver
        pLD = (LEGACY_DRIVER *)LocalAlloc(LPTR, sizeof(LEGACY_DRIVER));
        if (!pLD)
        {
            dlogt(szLocalAllocFailMsg);
            break;
        }

        // Init fields
        pLD->UserCopyList=NULL;
        pLD->KernCopyList=NULL;

        // parse the driver installation line
        SetupGetStringField(&InfContext,0,pLD->szDevNameKey,tsizeof(pLD->szDevNameKey),NULL);

        // The user-level driver has a disk id prepended to it. Throw it away.
        SetupGetStringField(&InfContext,1,szIdFile         ,tsizeof(szIdFile) ,NULL);
        _tcscpy(pLD->szUserDevDrv,RemoveDiskId(szIdFile));

        SetupGetStringField(&InfContext,2,pLD->szClasses   ,tsizeof(pLD->szClasses)   ,NULL);
        SetupGetStringField(&InfContext,3,pLD->szDesc      ,tsizeof(pLD->szDesc)      ,NULL);
        SetupGetStringField(&InfContext,4,pLD->szVxD       ,tsizeof(pLD->szVxD)       ,NULL);
        SetupGetStringField(&InfContext,5,pLD->szParams    ,tsizeof(pLD->szParams)    ,NULL);
        SetupGetStringField(&InfContext,6,pLD->szDependency,tsizeof(pLD->szDependency),NULL);

        // Remember to also copy the user-level driver
        AddFileToCopyList(pLI,pLD,szIdFile);

        // Put it into the list
        pLD->pNext = pLDList;
        pLDList = pLD;
    } while (SetupFindNextLine(&InfContext,&InfContext));

    // Status check- did we find any drivers?
    // If not, clean up and get out now!
    if (pLDList==NULL)
    {
        dlog1("CreateLegacyInf: Didn't find any drivers in inf %s\n",szLegInfPath);
        SetupCloseInfFile(hInf);
        LocalFree(pLI);
        return NULL;
    }

    // Save list in Legacy Inf structure
    pLI->DriverList = pLDList;

    // Generate file copy lists
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // Now add the other files into the list
        if (SetupFindFirstLine(hInf,pLD->szDevNameKey,NULL,&InfContext))
        {
            do
            {
                SetupGetStringField(&InfContext,0,szIdFile,tsizeof(szIdFile),NULL);
                AddFileToCopyList(pLI,pLD,szIdFile);
            } while (SetupFindNextLine(&InfContext,&InfContext));
        }
    }

    // Generate the SourceDiskList iff we find a section that lists them
    if (SetupFindFirstLine(hInf,TEXT("Source Media Descriptions"),NULL,&InfContext))
    {
        MediaDescFieldId=1;
    }
    else if (SetupFindFirstLine(hInf,TEXT("disks"),NULL,&InfContext))   // Old style
    {
        MediaDescFieldId=2;
    }
    else if (SetupFindFirstLine(hInf,TEXT("disks"),NULL,&InfContext))   // Old style
    {
        MediaDescFieldId=2;
    }
    else
    {
        MediaDescFieldId=0;
    }

    if (MediaDescFieldId)
    {
        do
        {
            SOURCEDISK *pSD;

            TCHAR szDiskId[8];
            pSD = (SOURCEDISK *)LocalAlloc(LPTR, sizeof(SOURCEDISK));
            if (!pSD)
            {
                dlogt(szLocalAllocFailMsg);
                break;
            }

            // Read the disk ID and description
            SetupGetIntField(&InfContext,0,&pSD->DiskId);
            SetupGetStringField(&InfContext,MediaDescFieldId,pSD->szDiskName,tsizeof(pSD->szDiskName),NULL);

            // Put it in the list
            pSD->pNext = pLI->SourceDiskList;
            pLI->SourceDiskList = pSD;
        } while (SetupFindNextLine(&InfContext,&InfContext));
    }

    SetupCloseInfFile(hInf);

    return pLI;
}


// Build a list containing information about all the legacy infs in the specified directory
PROCESS_INF_INFO *BuildLegacyInfInfo(PTSTR szLegacyInfDir, BOOL bEnumSingleInf)
{
    LEGACY_INF *pLegacyInf;
    PROCESS_INF_INFO *pPII;
    TCHAR  PathBuffer[_MAX_PATH];

    dlog1("ProcessLegacyInfDirectory processing directory %s\n",szLegacyInfDir);

    // Allocate a process inf info struct to hold params relating to the conversion process
    pPII = (PROCESS_INF_INFO *)LocalAlloc(LPTR, sizeof(PROCESS_INF_INFO));
    if (!pPII)
    {
        dlogt(szLocalAllocFailMsg);
        return NULL;
    }

    // Get a path to the windows inf directory
    if (!GetWindowsDirectory(pPII->szSysInfDir,tsizeof(pPII->szSysInfDir)))
	{
		DestroyLegacyInfInfo(pPII);
        return NULL;
    }

    catpath(pPII->szSysInfDir,TEXT("\\INF"));

    // Create a temp dir for the new infs under the windows inf directory
    _tcscpy(pPII->szNewInfDir,pPII->szSysInfDir);
    catpath(pPII->szNewInfDir,TEXT("\\MEDIAINF"));

    // If the directory exists, delete it
    RemoveDirectoryTree(pPII->szNewInfDir);

    // Now create it.
    CreateDirectory(pPII->szNewInfDir,NULL);

    // Init list to NULL
    pPII->LegInfList=NULL;

    if (bEnumSingleInf) // If bEnumSingleInf true, szLegacyInfDir points to a single file
    {
        // Grab the path to the directory and store it in pPII->szLegInfDir
        _tcscpy(PathBuffer,szLegacyInfDir);
        _tcscpy(pPII->szLegInfDir,StripPathName(PathBuffer));

        // Load all the information about the legacy inf
        pLegacyInf = CreateLegacyInf(szLegacyInfDir);

        // If no error, link it into the list
        if (pLegacyInf)
        {
            pLegacyInf->pNext = pPII->LegInfList;
            pPII->LegInfList  = pLegacyInf;
        }

    }
    else    // bEnumSingleInf false, szLegacyInfDir points to a directory
    {
        HANDLE FindHandle;
        WIN32_FIND_DATA FindData;
        PTSTR CurrentInfFile;

        // Save path to original infs
        _tcscpy(pPII->szLegInfDir,szLegacyInfDir);

        // Build a file spec to find all INFs in specified directory, i.e., "<DirPath>\*.INF"
        _tcscpy(PathBuffer, szLegacyInfDir);
        catpath(PathBuffer,TEXT("\\*.INF"));

        // Get a pointer to the end of the path part of the string
        // (minus the wildcard filename), so that we can append
        // each filename to it.
        CurrentInfFile = _tcsrchr(PathBuffer, TEXT('\\')) + 1;

        // Search for all the inf files in this directory
        FindHandle = FindFirstFile(PathBuffer, &FindData);
        if (FindHandle != INVALID_HANDLE_VALUE)
        {
            do
            {
                // Build the full pathname.
                _tcscpy(CurrentInfFile, FindData.cFileName);

                // Load all the information about the legacy inf
                pLegacyInf = CreateLegacyInf(PathBuffer);

                // If no error, link it into the list
                if (pLegacyInf)
                {
                    pLegacyInf->pNext = pPII->LegInfList;
                    pPII->LegInfList = pLegacyInf;
                }
            } while (FindNextFile(FindHandle, &FindData));

            // Remember to close the find handle
            FindClose(FindHandle);
        }
    }

    // If we didn't find any drivers, just return NULL.
    if (pPII->LegInfList==NULL)
    {
        DestroyLegacyInfInfo(pPII);
        return NULL;
    }

    return pPII;
}

// Create a unique inf file in the temp directory
// Files will have the name INFxxxx.INF, where xxxx is a value between 0 and 1000
HANDLE OpenUniqueInfFile(PTSTR szDir, PTSTR szNewPath)
{
    HANDLE hInf;
    int Id;

    // Try up to 1000 values before giving up
    for (Id=0;Id<1000;Id++)
    {
        wsprintf(szNewPath,TEXT("%s\\INF%d.inf"),szDir,Id);

        // Setting CREATE_NEW flag will make call fail if file already exists
        hInf = CreateFile(  szNewPath,
                            GENERIC_WRITE|GENERIC_READ,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            0);

        // If we got back a valid handle, we can return
        if (hInf!=INVALID_HANDLE_VALUE)
        {
            return hInf;
        }
    }

    // Never found a valid handle. Give up.
    dlog("OpenUniqueInfFile: Couldn't create unique inf\n");
    return INVALID_HANDLE_VALUE;
}

// Helper function to append one formatted line of text to an open inf
void cdecl InfPrintf(HANDLE hInf, LPTSTR szFormat, ...)
{
    TCHAR Buf[MAXSTRINGLEN];
    int   nChars;

    // format into buffer
    va_list va;
    va_start (va, szFormat);
    nChars = wvsprintf (Buf,szFormat,va);
    va_end (va);

    // Append cr-lf
    _tcscpy(&Buf[nChars],TEXT("\r\n"));
    nChars+=2;

#ifdef UNICODE
    {
        int   mbCount;
        char  mbBuf[MAXSTRINGLEN];

        // Need to converto to mbcs before writing to file
        mbCount = WideCharToMultiByte(  GetACP(),               // code page
                                        WC_NO_BEST_FIT_CHARS,   // performance and mapping flags
                                        Buf,                    // address of wide-character string
                                        nChars,                 // number of characters in string
                                        mbBuf,                  // address of buffer for new string
                                        sizeof(mbBuf),          // size of buffer
                                        NULL,                   // address of default for unmappable characters
                                        NULL                    // address of flag set when default char. used
                                     );

        // Write line out to file
        WriteFile(hInf,mbBuf,mbCount,&mbCount,NULL);
    }
#else
    WriteFile(hInf,Buf,nChars,&nChars,NULL);
#endif

    return;
}

// Creates a new NT5-style inf file in the temporary directory.
BOOL CreateNewInfFile(PROCESS_INF_INFO *pPII, LEGACY_INF *pLI)
{
    SOURCEDISK *pSD;
    TCHAR szTmpKey[_MAX_PATH];
    LEGACY_DRIVER *pLDList, *pLD;
    HANDLE hInf;
    FILETOCOPY *pFTC;

    // Get a pointer to the legacy driver list
    pLDList = pLI->DriverList;

    dlog1("Creating new inf file %s\n",pPII->szNewInfDir);

    hInf = OpenUniqueInfFile(pPII->szNewInfDir, pLI->szNewInfPath);
    if (hInf==INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    // Write out version section
    InfPrintf(hInf,TEXT("[version]"));
    InfPrintf(hInf,TEXT("Signature=\"$WINDOWS NT$\""));
    InfPrintf(hInf,TEXT("Class=MEDIA"));
    InfPrintf(hInf,TEXT("ClassGUID=\"{4d36e96c-e325-11ce-bfc1-08002be10318}\""));
    InfPrintf(hInf,TEXT("Provider=Unknown"));

    // Write out Manufacturer section
    InfPrintf(hInf,TEXT("[Manufacturer]"));
    InfPrintf(hInf,TEXT("Unknown=OldDrvs"));

    // Write out OldDrvs section
    InfPrintf(hInf,TEXT("[OldDrvs]"));
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // Create an key to index into the strings section
        // This gives us something like:
        // %foo% = foo
        InfPrintf(hInf,TEXT("%%%s%%=%s"),pLD->szDevNameKey,pLD->szDevNameKey);
    }

    // Write out install section for each device
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // install section header, remember NT only
        InfPrintf(hInf,TEXT("[%s.NT]"),pLD->szDevNameKey);

        // DriverVer entry. Pick a date that's earlier than any NT5 infs
        InfPrintf(hInf,TEXT("DriverVer = 1/1/1998, 4.0.0.0"));

        // Addreg entry
        InfPrintf(hInf,TEXT("AddReg=%s.AddReg"),pLD->szDevNameKey);

        // CopyFiles entry
        InfPrintf(hInf,TEXT("CopyFiles=%s.CopyFiles.User,%s.CopyFiles.Kern"),pLD->szDevNameKey,pLD->szDevNameKey);

        // Reboot entry. Legacy drivers always require a reboot
        InfPrintf(hInf,TEXT("Reboot"));
    }

    // Write out the services section for each device
    // Legacy drivers have a stub services key
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {

        InfPrintf(hInf,TEXT("[%s.NT.Services]"),pLD->szDevNameKey);
#if GUESS_LEGACY_SERVICE_NAME
        // If we install a .sys file, assume that the service name is the same as the filename
        pFTC=pLD->KernCopyList;
        if (pFTC)
        {
            TCHAR szServiceName[_MAX_FNAME];
            lsplitpath(pFTC->szFileName,NULL,NULL,szServiceName,NULL);

            InfPrintf(hInf,TEXT("AddService=%s,0x2,%s_Service_Inst"),szServiceName,szServiceName);
            InfPrintf(hInf,TEXT("[%s_Service_Inst]"),szServiceName);
            InfPrintf(hInf,TEXT("DisplayName    = %%%s%%"),pLD->szDevNameKey);
            InfPrintf(hInf,TEXT("ServiceType    = 1"));
            InfPrintf(hInf,TEXT("StartType      = 1"));
            InfPrintf(hInf,TEXT("ErrorControl   = 1"));
            InfPrintf(hInf,TEXT("ServiceBinary  = %%12%%\\%s"),pFTC->szFileName);
            InfPrintf(hInf,TEXT("LoadOrderGroup = Base"));
        }
        else
        {
            InfPrintf(hInf,TEXT("AddService=,0x2"));
        }
#else
        InfPrintf(hInf,TEXT("AddService=,0x2"));
#endif

    }

    // Write out the AddReg section for each device
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        int nClasses;
        TCHAR szClasses[_MAX_PATH];
        TCHAR *pszState, *pszClass;

        // section header
        InfPrintf(hInf,TEXT("[%s.AddReg]"),pLD->szDevNameKey);
        InfPrintf(hInf,TEXT("HKR,Drivers,SubClasses,,\"%s\""),pLD->szClasses);

        // For safety, copy the string (mystrtok corrupts the original source string)
        _tcscpy(szClasses,pLD->szClasses);
        for (
            pszClass = mystrtok(szClasses,NULL,&pszState);
            pszClass;
            pszClass = mystrtok(NULL,NULL,&pszState)
            )
        {
            InfPrintf(hInf,TEXT("HKR,\"Drivers\\%s\\%s\", Driver,,%s"),         pszClass,pLD->szUserDevDrv,pLD->szUserDevDrv);
            InfPrintf(hInf,TEXT("HKR,\"Drivers\\%s\\%s\", Description,,%%%s%%"),pszClass,pLD->szUserDevDrv,pLD->szDevNameKey);
        }
    }

    // Write out the CopyFiles section for each device for user files
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // section header
        InfPrintf(hInf,TEXT("[%s.CopyFiles.User]"),pLD->szDevNameKey);
        for (pFTC=pLD->UserCopyList;pFTC;pFTC=pFTC->pNext)
        {
            InfPrintf(hInf,TEXT("%s"),pFTC->szFileName);
        }
    }

    // Write out the CopyFiles section for each device for kern files
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // section header
        InfPrintf(hInf,TEXT("[%s.CopyFiles.Kern]"),pLD->szDevNameKey);
        for (pFTC=pLD->KernCopyList;pFTC;pFTC=pFTC->pNext)
        {
            InfPrintf(hInf,TEXT("%s"),pFTC->szFileName);
        }
    }

    // Write out DestinationDirs section
    InfPrintf(hInf,TEXT("[DestinationDirs]"));
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        InfPrintf(hInf,TEXT("%s.CopyFiles.User = 11"),pLD->szDevNameKey);
        InfPrintf(hInf,TEXT("%s.CopyFiles.Kern = 12"),pLD->szDevNameKey);
    }

    // Write out the SourceDisksNames section
    InfPrintf(hInf,TEXT("[SourceDisksNames]"));
    for (pSD=pLI->SourceDiskList;pSD;pSD=pSD->pNext)
    {
        InfPrintf(hInf,TEXT("%d = \"%s\",\"\",1"),pSD->DiskId,pSD->szDiskName);
    }
    // Write out the SourceDisksFiles section
    InfPrintf(hInf,TEXT("[SourceDisksFiles]"));
    for (pFTC=pLI->FileList;pFTC;pFTC=pFTC->pNext)
    {
        InfPrintf(hInf,TEXT("%s=%d"),pFTC->szFileName,pFTC->DiskId);
    }

    // Write out Strings section
    InfPrintf(hInf,TEXT("[Strings]"));
    for (pLD=pLDList;pLD;pLD=pLD->pNext)
    {
        // Create the device description
        InfPrintf(hInf,TEXT("%s=\"%s\""),pLD->szDevNameKey,pLD->szDesc);
    }

    CloseHandle(hInf);

    return TRUE;
}

// Creates a PNF file in the temporary directory to go along with the inf
// This allows us to have the inf file in one directory while the driver's
// files are in a different directory.
BOOL CreateNewPnfFile(PROCESS_INF_INFO *pPII, LEGACY_INF *pLI)
{
    BOOL bSuccess;

    TCHAR szSysInfPath[_MAX_PATH];
    TCHAR szSysPnfPath[_MAX_PATH];
    TCHAR szTmpPnfPath[_MAX_PATH];

    TCHAR szSysInfDrive[_MAX_DRIVE];
    TCHAR szSysInfDir[_MAX_DIR];
    TCHAR szSysInfFile[_MAX_FNAME];

    TCHAR szNewInfDrive[_MAX_DRIVE];
    TCHAR szNewInfDir[_MAX_DIR];
    TCHAR szNewInfFile[_MAX_FNAME];

    // Copy inf to inf directory to create pnf file
    bSuccess = SetupCopyOEMInf(
                              pLI->szNewInfPath,       //    IN  PCSTR   SourceInfFileName,
                              pPII->szLegInfDir,       //    IN  PCSTR   OEMSourceMediaLocation,         OPTIONAL
                              SPOST_PATH,   //    IN  DWORD   OEMSourceMediaType,
                              0,            //    IN  DWORD   CopyStyle,
                              szSysInfPath, //    OUT PSTR    DestinationInfFileName,         OPTIONAL
                              tsizeof(szSysInfPath),   //    IN  DWORD   DestinationInfFileNameSize,
                              NULL,         //    OUT PDWORD  RequiredSize,                   OPTIONAL
                              NULL          //    OUT PSTR   *DestinationInfFileNameComponent OPTIONAL
                              );

    if (!bSuccess)
    {
        dlog1("CreateNewPnfFile: SetupCopyOEMInf failed for inf %s\n",pLI->szNewInfPath);
        return FALSE;
    }

    // Cut apart the directory names
    lsplitpath(szSysInfPath,      szSysInfDrive, szSysInfDir, szSysInfFile, NULL);
    lsplitpath(pLI->szNewInfPath, szNewInfDrive, szNewInfDir, szNewInfFile, NULL);

    // Copy the pnf file back to the original directory
    wsprintf(szSysPnfPath,TEXT("%s%s%s.pnf"), szSysInfDrive, szSysInfDir, szSysInfFile);
    wsprintf(szTmpPnfPath,TEXT("%s%s%s.pnf"), szNewInfDrive, szNewInfDir, szNewInfFile);
    CopyFile(szSysPnfPath, szTmpPnfPath, FALSE);

    // Delete the inf and pnf file in the system inf directory
    DeleteFile(szSysInfPath);
    DeleteFile(szSysPnfPath);

    return TRUE;
}

// Create a new inf file for each legacy inf in the list
BOOL ProcessLegacyInfInfo(PROCESS_INF_INFO *pPII)
{
    LEGACY_INF *pLI;
    BOOL bSuccess;

    for (pLI=pPII->LegInfList;pLI;pLI=pLI->pNext)
    {
        bSuccess = CreateNewInfFile(pPII,pLI);
        if (bSuccess)
        {
            CreateNewPnfFile(pPII,pLI);
        }
    }

    return TRUE;
}

BOOL ConvertLegacyInfDir(PTSTR szLegacyDir, PTSTR szNewDir, BOOL bEnumSingleInf)
{
    PROCESS_INF_INFO *pPII;

    // Couldn't find any NT5-style drivers. Try to find some legacy inf files.
    // Build the list
    pPII = BuildLegacyInfInfo(szLegacyDir, bEnumSingleInf);
    if (!pPII)
    {
        return FALSE;
    }

    // Process the list
    ProcessLegacyInfInfo(pPII);

    if (bEnumSingleInf)
    {
        // if bEnumSingleInf is true, we should return a path to the new inf
        // (there should be exactly one)
        _tcscpy(szNewDir,pPII->LegInfList->szNewInfPath);
    }
    else
    {
        // if bEnumSingleInf is false, we should return a path to the directory
        _tcscpy(szNewDir,pPII->szNewInfDir);
    }

    // Cleanup data structures
    DestroyLegacyInfInfo(pPII);

    return TRUE;
}

int CountDriverInfoList(IN HDEVINFO         DeviceInfoSet,
                        IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
                        IN DWORD            DriverType
                       )
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    int DriverCount = 0;
    int Count = 0;

    // Count the number of drivers in the list
    DriverInfoData.cbSize = sizeof(DriverInfoData);
    while (SetupDiEnumDriverInfo(DeviceInfoSet,
                                 DeviceInfoData,
                                 DriverType,
                                 Count,
                                 &DriverInfoData))
    {
        // Only count drivers which don't have the DNF_BAD_DRIVER flag set
        DriverInstallParams.cbSize=sizeof(DriverInstallParams);
        if (SetupDiGetDriverInstallParams(DeviceInfoSet, DeviceInfoData, &DriverInfoData, &DriverInstallParams))
        {
            if (!(DriverInstallParams.Flags & DNF_BAD_DRIVER))
            {
                DriverCount++;
            }
        }
        Count++;
    }

    return DriverCount;
}

// Called to display a list of drivers to be installed
DWORD Media_SelectDevice(IN HDEVINFO         DeviceInfoSet,
                         IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                        )
{
    BOOL bResult;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    int DriverCount;

    // Undocumented: When user selects "Have Disk", setupapi only looks at the
    // class driver list. Therefore, we'll only work with that list
    DWORD DriverType = SPDIT_CLASSDRIVER;

    // Get the path to where the inf files are located
    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    bResult = SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                            DeviceInfoData,
                                            &DeviceInstallParams);

    if (!bResult)
    {
        return ERROR_DI_DO_DEFAULT;
    }

    // For safety, don't support append mode
    if (DeviceInstallParams.FlagsEx & DI_FLAGSEX_APPENDDRIVERLIST)
    {
        return ERROR_DI_DO_DEFAULT;
    }        

    // If not going outside of inf directory, the DriverPath field will be an
    // empty string. In this case, don't do special processing.
    if (DeviceInstallParams.DriverPath[0]=='\0')
    {
        return ERROR_DI_DO_DEFAULT;
    }

    // We're going off to an OEM directory.

    // See if setup can find any NT5-compatible inf files

    // Try to build a driver info list in the current directory
    if (DeviceInfoSet) SetupDiDestroyDriverInfoList(DeviceInfoSet,DeviceInfoData,DriverType);
    SetupDiBuildDriverInfoList(DeviceInfoSet,DeviceInfoData,DriverType);

    // Filter out non NT inf files (e.g. Win9x inf files)
    if (DeviceInfoSet) 
        FilterOutNonNTInfs(DeviceInfoSet,DeviceInfoData,DriverType);

    // Now count the number of drivers
    DriverCount = CountDriverInfoList(DeviceInfoSet,DeviceInfoData,DriverType);

    // If we found at least one NT5 driver for this device, just return
    if (DriverCount>0)
    {
        return ERROR_DI_DO_DEFAULT;
    }

    // Didn't find any NT5 drivers.

    // Destroy the existing list
    SetupDiDestroyDriverInfoList(DeviceInfoSet,DeviceInfoData,DriverType);

    //Retrieve the device install params prior to setting new INF path and update 
    //any information DeviceInstallParams 
    bResult = SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                            DeviceInfoData,
                                            &DeviceInstallParams);

    if (!bResult)
    {
        return ERROR_DI_DO_DEFAULT;
    }
    // Convert any legacy infs and get back ptr to temp directory for converted infs
    bResult = ConvertLegacyInfDir(DeviceInstallParams.DriverPath, DeviceInstallParams.DriverPath, (DeviceInstallParams.Flags & DI_ENUMSINGLEINF));
    if (!bResult)
    {
        return ERROR_DI_DO_DEFAULT; // Didn't find any legacy infs
    }

    //Clean up this DI_FLAGSEX_FILTERSIMILARDRIVERS for old NT 4 driver installation.
    DeviceInstallParams.FlagsEx &=  ~DI_FLAGSEX_FILTERSIMILARDRIVERS;

    // Save new driver path
    bResult = SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                            DeviceInfoData,
                                            &DeviceInstallParams);

    // Note: We don't have to call SetupDiBuildDriverInfoList; setupapi will do that for us
    // with the new path to the infs.
    return ERROR_DI_DO_DEFAULT;
}

BOOL CreateRootDevice( IN     HDEVINFO    DeviceInfoSet,
                       IN     PTSTR       DeviceId,
                       IN     BOOL        bInstallNow
                     )
{
    BOOL                    bResult;
    SP_DEVINFO_DATA         DeviceInfoData;
    SP_DRVINFO_DATA         DriverInfoData;
    SP_DEVINSTALL_PARAMS    DeviceInstallParams;
    TCHAR                   tmpBuffer[100];
    DWORD                   bufferLen;
    DWORD                   Error;

    // Attempt to manufacture a new device information element for the root enumerated device
    _tcscpy(tmpBuffer,TEXT("ROOT\\MEDIA\\"));
    if ((lstrlen(tmpBuffer)+ lstrlen(DeviceId)) < ARRAYSIZE(tmpBuffer))
    {
        _tcscat(tmpBuffer,DeviceId);
    }

    dlog2("CreateRootDevice: DeviceId = %s, Device = %s%",DeviceId,tmpBuffer);

    // Try to create the device info
    DeviceInfoData.cbSize = sizeof( DeviceInfoData );
    bResult = SetupDiCreateDeviceInfo( DeviceInfoSet,
                                       tmpBuffer,
                                       (GUID *) &GUID_DEVCLASS_MEDIA,
                                       NULL, // PCTSTR DeviceDescription
                                       NULL, // HWND hwndParent
                                       0,
                                       &DeviceInfoData );
    if (!bResult)
    {
        Error = GetLastError();
        dlog1("CreateRootDevice: SetupDiCreateDeviceInfo failed Error=%x",Error);
        return (Error == ERROR_DEVINST_ALREADY_EXISTS);
    }

    // Set the hardware ID.
    _tcscpy(tmpBuffer, DeviceId);
    bufferLen = _tcslen(tmpBuffer);                 // Get buffer len in chars
    tmpBuffer[bufferLen+1] = TEXT('\0');            // must terminate with an extra null (so we have two nulls)
    bufferLen = (bufferLen + 2) * sizeof(TCHAR);    // Convert buffer length to bytes & add extra for two nulls
    bResult = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                &DeviceInfoData,
                                                SPDRP_HARDWAREID,
                                                (PBYTE)tmpBuffer,
                                                bufferLen );
    if (!bResult) goto CreateRootDevice_err;

    // Setup some flags before building a driver list
    bResult = SetupDiGetDeviceInstallParams( DeviceInfoSet,&DeviceInfoData,&DeviceInstallParams);
    if (bResult)
    {

        _tcscpy( DeviceInstallParams.DriverPath, TEXT( "" ) );
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_USECLASSFORCOMPAT;
        bResult = SetupDiSetDeviceInstallParams( DeviceInfoSet,&DeviceInfoData,&DeviceInstallParams);
    }

    // Build a compatible driver list for this new device...
    bResult = SetupDiBuildDriverInfoList( DeviceInfoSet,
                                          &DeviceInfoData,
                                          SPDIT_COMPATDRIVER);
    if (!bResult) goto CreateRootDevice_err;

    // Get the first driver on the list
    DriverInfoData.cbSize = sizeof (DriverInfoData);
    bResult = SetupDiEnumDriverInfo( DeviceInfoSet,
                                     &DeviceInfoData,
                                     SPDIT_COMPATDRIVER,
                                     0,
                                     &DriverInfoData);
    if (!bResult) goto CreateRootDevice_err;

    // Save the device description
    bResult = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                &DeviceInfoData,
                                                SPDRP_DEVICEDESC,
                                                (PBYTE) DriverInfoData.Description,
                                                (_tcslen( DriverInfoData.Description ) + 1) * sizeof( TCHAR ) );
    if (!bResult) goto CreateRootDevice_err;

    // Set the selected driver
    bResult = SetupDiSetSelectedDriver( DeviceInfoSet,
                                        &DeviceInfoData,
                                        &DriverInfoData);
    if (!bResult) goto CreateRootDevice_err;

    // Register the device so it is not a phantom anymore
    bResult = SetupDiRegisterDeviceInfo( DeviceInfoSet,
                                         &DeviceInfoData,
                                         0,
                                         NULL,
                                         NULL,
                                         NULL);
    if (!bResult) goto CreateRootDevice_err;

    return bResult;

    // Error, delete the device info and give up
    CreateRootDevice_err:
    SetupDiDeleteDeviceInfo (DeviceInfoSet, &DeviceInfoData);
    return FALSE;
}

DWORD Media_MigrateLegacy(IN HDEVINFO         DeviceInfoSet,
                          IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                         )
{
    BOOL bInstallNow = TRUE;

    CreateRootDevice(DeviceInfoSet, TEXT("MS_MMMCI"), bInstallNow);
    CreateRootDevice(DeviceInfoSet, TEXT("MS_MMVID"), bInstallNow);
    CreateRootDevice(DeviceInfoSet, TEXT("MS_MMACM"), bInstallNow);
    CreateRootDevice(DeviceInfoSet, TEXT("MS_MMVCD"), bInstallNow);
    CreateRootDevice(DeviceInfoSet, TEXT("MS_MMDRV"), bInstallNow);
    return NO_ERROR;
}

int IsSpecialDriver(HDEVINFO         DeviceInfoSet,
                    PSP_DEVINFO_DATA DeviceInfoData)
{
    BOOL bResult;
    TCHAR HardwareId[32];
    bResult = SetupDiGetDeviceRegistryProperty( DeviceInfoSet,
                                                DeviceInfoData,
                                                SPDRP_HARDWAREID,
                                                NULL,
                                                (PBYTE)HardwareId,
                                                sizeof(HardwareId),
                                                NULL );

    if (!_tcscmp(HardwareId,TEXT("MS_MMMCI")))
        return IS_MS_MMMCI;
    else if (!_tcscmp(HardwareId,TEXT("MS_MMVID")))
        return IS_MS_MMVID;
    else if (!_tcscmp(HardwareId,TEXT("MS_MMACM")))
        return IS_MS_MMACM;
    else if (!_tcscmp(HardwareId,TEXT("MS_MMVCD")))
        return IS_MS_MMVCD;
    else if (!_tcscmp(HardwareId,TEXT("MS_MMDRV")))
        return IS_MS_MMDRV;
    return 0;
}

BOOL IsPnPDriver(IN PTSTR szName)
{
    LONG lRet;
    HKEY hkClass;

    int  iDriverInst;
    TCHAR szDriverInst[32];
    HKEY hkDriverInst;

    int iDriverType;
    TCHAR szDriverType[32];
    HKEY hkDriverType;

    int iDriverName;
    TCHAR szDriverName[32];

    // Open class key
    hkClass = SetupDiOpenClassRegKey((GUID *) &GUID_DEVCLASS_MEDIA, KEY_READ);
    if (hkClass == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    // enumerate each driver instances (e.g. 0000, 0001, etc.)
    for (iDriverInst = 0;
        !RegEnumKey(hkClass, iDriverInst, szDriverInst, sizeof(szDriverInst)/sizeof(TCHAR));
        iDriverInst++)
    {
        // Open the Drivers subkey, (e.g. 0000\Drivers)
        if (lstrlen(szDriverInst) > 23) // 23 is the max length minus "\Drivers" plus a NULL
        {
            continue;
        }
        _tcscat(szDriverInst,TEXT("\\Drivers"));
        lRet = RegOpenKey(hkClass, szDriverInst, &hkDriverInst);
        if (lRet!=ERROR_SUCCESS)
        {
            continue;
        }

        // Enumerate each of the driver types (e.g. wave, midi, mixer, etc.)
        for (iDriverType = 0;
            !RegEnumKey(hkDriverInst, iDriverType, szDriverType, sizeof(szDriverType)/sizeof(TCHAR));
            iDriverType++)
        {

            // Open the driver type subkey
            lRet = RegOpenKey(hkDriverInst, szDriverType, &hkDriverType);
            if (lRet!=ERROR_SUCCESS)
            {
                continue;
            }

            // Enumerate each of the driver names (e.g. foo.drv)
            for (iDriverName = 0;
                !RegEnumKey(hkDriverType, iDriverName, szDriverName, sizeof(szDriverName)/sizeof(TCHAR));
                iDriverName++)
            {

                // Does this name match the one we were passed?
                if (!_tcsicmp(szName,szDriverName))
                {
                    RegCloseKey(hkDriverType);
                    RegCloseKey(hkDriverInst);
                    RegCloseKey(hkClass);
                    return TRUE;
                }
            }
            RegCloseKey(hkDriverType);
        }
        RegCloseKey(hkDriverInst);
    }
    RegCloseKey(hkClass);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\midi.h ===
/*  MIDI.H
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**
**  Multimedia Control Panel MIDI Applet.
**
**  Display a list of all installed MIDI devices, allow user to configure
**  existing or install new ones.
**
*/ 

//---------------------------------------------------------------------------
#ifndef RC_INVOKED
//---------------------------------------------------------------------------


#ifndef MIDI_DPF
 #define MIDI_DPF AuxDebugEx
#endif

void PASCAL UpdateListBox(HWND hDlg);

#define  MAX_ALIAS     80
#define  NUM_CHANNEL   16
#define  NUM_TABSTOPS  1

#define  BITONE        1

// Common states
#define  CHANGE_NONE    0

// Instrument states
#define  CHANGE_ACTIVE  1
#define  CHANGE_CHANNEL 2

// Driver states
#define  CHANGE_REMOVE  4
#define  CHANGE_ADD     8

#define  IS_INSTRUMENT(hwnd, i)  (!((LPINSTRUMENT)ListBox_GetItemData(hwnd, i))->fDevice)

typedef struct tag_Driver FAR * LPDRIVER;

#ifndef NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#define SetDlgData(h,lp)  SetWindowLongPtr (h, DWLP_USER, (LONG_PTR)lp)
#define GetDlgData(h)     (LPVOID)GetWindowLongPtr (h, DWLP_USER)

// lParam of PROPSHEETPAGE points to a struct like this.
// it is freed in ReleasePropSheet() function.
//
typedef struct _midi_ps_args {
    LPFNMMEXTPROPSHEETCALLBACK  lpfnMMExtPSCallback;
    LPARAM                      lParam;
    TCHAR                       szTitle[1];
    } MPSARGS, * PMPSARGS;

// info for internal & external midi instruments
//
typedef struct _instrum * PINSTRUM;
typedef struct _instrum {
    PINSTRUM      piParent;
    BOOL          bExternal;
    BOOL          bActive;
    BOOL          fGSSynth;
    UINT          uID;
    TCHAR         szKey[MAX_ALIAS];
    TCHAR         szFriendly[MAX_ALIAS];
    } INSTRUM;

// the the loaded array of all instruments, used to refresh
// lists of all instruments and the treeview's of instruments
// and how they are connected
//
typedef struct _midi_instrums {
    HKEY          hkMidi;
    UINT          nInstr;
    BOOL          bHasExternal;
    PINSTRUM      api[128];
    } MCMIDI, * PMCMIDI;

//------------------ function prototypes ------------------------------------

// midi.c
//
INT_PTR CALLBACK MidiCplDlgProc (
   HWND hWnd,
   UINT uMsgId,
   WPARAM wParam,
   LPARAM lParam);

LONG WINAPI GetAlias (
    HKEY  hKey,
    LPTSTR szSub,
    LPTSTR pszAlias,
    DWORD cbAlias,
    BOOL *pbExtern,
    BOOL *pbActive);

void WINAPI LoadInstruments (
    PMCMIDI pmcm,
    BOOL    bDriverAsAlias);

void WINAPI FreeInstruments (
    PMCMIDI pmcm);

PINSTRUM WINAPI FindInstrument (
    PMCMIDI pmcm,
    LPTSTR  pszFriendly);

void WINAPI KickMapper (
    HWND hWnd);

// iface.c
//
BOOL WINAPI InitIface (
   HINSTANCE hInst,
   DWORD     dwReason,
   LPVOID    lpReserved);

// class.c
//
INT_PTR CALLBACK MidiClassDlgProc (
   HWND hWnd,
   UINT uMsgId,
   WPARAM wParam,
   LPARAM lParam);

INT_PTR CALLBACK MidiInstrumentDlgProc (
   HWND hWnd,
   UINT uMsgId,
   WPARAM wParam,
   LPARAM lParam);

INT_PTR MidiInstrumentsWizard (
    HWND  hWnd,
    PMCMIDI pmcm,       // optional
    LPTSTR pszCmd);

//void LoadInstrumentsIntoTree (
//    HWND     hWnd,
//    UINT     uId,
//    LPTSTR   pszSelect,
//    HKEY *   phkMidi);

BOOL WINAPI RemoveInstrumentByKeyName (
    LPCTSTR pszKey);


// containing struct for what would otherwise be global variables
// only one instance of this structure is used.  (declared in main.c)
//
struct _globalstate {
    int                   cRef;

    BOOL                  fLoadedRegInfo;
    TCHAR                 szPlayCmdLn[128];
    TCHAR                 szOpenCmdLn[128];
    TCHAR                 szNewCmdLn[128];

    HWND                  hWndDeviceList;
    HWND                  hWndInstrList;
    //HWND                  hWndMainList;

    BOOL                  fChangeInput;
    BOOL                  fChangeOutput;
    BOOL                  fInputPort;
    DWORD                 dwReconfigFlags;

    WORD                  wHelpMessage;
    WORD                  wFill;

    UINT                  nDrivers;
    UINT                  nMaxDrivers;
    //DRIVER                aDrivers[16];
    };
extern struct _globalstate gs;

#endif // ifndef RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\mmcpl.h ===
/*
 ***************************************************************
 *  mmcpl.h
 *
 *  Header file for mm control applet.
 *
 *
 *  History:
 *
 *      January -by- VijR
 *          Created.
 ***************************************************************
 */

#ifndef MMCPL_H
#define MMCPL_H

#define _INC_OLE
#ifndef STRICT
#define STRICT
#endif

#pragma warning( disable: 4103)
#include <windows.h>        // also includes windowsx.h
#include <shellapi.h>       // for registration functions
#include <windowsx.h>
#include <ole2.h>
#include <mmsystem.h>
#include <setupapi.h>

#include <shlobj.h>         // Shell OLE interfaces
#include <string.h>
#ifndef INITGUID
#include <shlobjp.h>
#endif
#include <commdlg.h>

#include "rcids.h"          // Resource declaration

#define PUBLIC          FAR PASCAL
#define CPUBLIC         FAR _cdecl
#define PRIVATE         NEAR PASCAL

//#include "utils.h"          // Common macros


/* Temporarily here until someone defines these for 16 bit side again. */
#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS            0L
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof((x))/sizeof((x)[0]))
#endif

/*
 ***************************************************************
 * Constants and Definitions
 ***************************************************************
 */
#define     MIDI        TEXT("MIDI")
#define     ACM         TEXT("ACM")
#define     MSACM       TEXT("MSACM.")
#define     WAVE        TEXT("Wave")
#define     MIDIMAP     TEXT("MidiMapper")
#define     WAVEMAP     TEXT("WaveMapper")
#define     AUX         TEXT("Aux")
#define     MIXER       TEXT("Mixer")
#define     JOYSTICK    TEXT("Joystick")
#define     MCI         TEXT("MCI")
#define     ICM         TEXT("ICM")
#define     ICMSTR      TEXT("VIDC.")
#define     ICMSTR2     TEXT("VIDS.")
#define     VIDCAP      TEXT("MSVIDEO")

#define     AUDIO       TEXT("Audio")
#define     CDAUDIO     TEXT("CDAudio")
#define     VIDEO       TEXT("Video")
#define     VOICE       TEXT("Voice")
#define     VOLUME      TEXT("Volume")


#define MAXSTR                  256    // maximum size of a string or filename
#define SZCODE                  const TCHAR
#define INTCODE                 const int
#define WINDOWS_DEFAULTENTRY    1
#define NONE_ENTRY              0

#define MAXNAME                 32      // Maximum name length
#define MAXLNAME                64
#define MAXMESSAGE              128     // Maximum resource string message
#define MAXSTRINGLEN            256     // Maximum output string length
#define MAXINTLEN               7       // Maximum interger string length
#define MAXLONGLEN              11      // Maximum long string length
#define MAXMSGLEN               512     // Maximum message length



#define WAVE_ID         0
#define MIDI_ID         1
#define MIXER_ID        2
#define AUX_ID          3
#define MCI_ID          4
#define ACM_ID          5
#define ICM_ID          6
#define VIDCAP_ID       7
#define JOYSTICK_ID     8

DEFINE_GUID(CLSID_mmsePropSheetHandler, 0x00022613L, 0x0000, 0x0000, 0xC0, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x46);

#define HWAVEOUT_MAPPER       ((HWAVEOUT)IntToPtr(WAVE_MAPPER))
#define HWAVEIN_MAPPER        ((HWAVEIN)IntToPtr(WAVE_MAPPER))
#define HMIDIOUT_MAPPER       ((HMIDIOUT)IntToPtr(WAVE_MAPPER))

#define HWAVEOUT_INDEX(i)     ((HWAVEOUT)IntToPtr(i))
#define HWAVEIN_INDEX(i)      ((HWAVEIN)IntToPtr(i))
#define HMIDIOUT_INDEX(i)     ((HMIDIOUT)IntToPtr(i))
#define HMIXER_INDEX(i)       ((HMIXER)IntToPtr(i))
#define HMIXEROBJ_INDEX(i)    ((HMIXEROBJ)IntToPtr(i))


/*
 ***************************************************************
 * Internal STRUCTS used by mm.cpl
 ***************************************************************
 */

typedef struct _ClassNode
{
    short iNode;    //1 if class, 2 if device , 3-> ACM, 4->instrument
    TCHAR szClassName[64];
    TCHAR szClass[16];
    HICON hIcon;
} CLASSNODE, * PCLASSNODE;


typedef struct iResources
{
    short   iNode;
    TCHAR    szFriendlyName[MAXSTR];
    TCHAR    szDesc[MAXSTR];
    TCHAR    szParam[64];
    TCHAR    szFile[MAXSTR];
    TCHAR    szDrvEntry[64];
    TCHAR    szClass[16];
    HDRVR   hDriver;
    DWORD   dnDevNode;
    short   fQueryable;     // 0 -> can't, 1 -> can, -1 -> need to check
    short   iClassID;
    int     fStatus; //0 -> Disabled, 1-> Enabled and entry in reg, 2->Enabled but no entry in reg (i.e.old dev), 3->Enabled and ACTIVE, 4->inactive
    PCLASSNODE  pcn;
}IRESOURCE, *PIRESOURCE;

typedef struct _Instrument
{
    short   iNode;
    TCHAR    szFriendlyName[MAXSTR];
    TCHAR    szInstr[64];
    PIRESOURCE     pDev;
}INSTRUMENT, * PINSTRUMENT;

typedef struct event
{
    short   iNode;    //1 if module 2 if event
    short   fHasSound;
    LPTSTR    pszEvent;
    LPTSTR    pszEventLabel;
    LPTSTR    pszPath;
    struct event *npNextEvent;
} EVENT,  *PEVENT;

typedef struct module
{
    short   iNode;    //1 if module 2 if event
    LPTSTR    pszKey;
    LPTSTR    pszLabel;
    BOOL    fChange;
    PEVENT  npList;
} MODULE, *PMODULE;

typedef struct _AudioDlgInfo
{
    UINT    uPrefIn;
    UINT    uPrefOut;
    UINT    uPrefMIDIOut;
    UINT    cNumOutDevs;
    UINT    cNumInDevs;
    UINT    cNumMIDIOutDevs;
    BOOL    fPrefOnly;
} AUDIODLGINFO, * PAUDIODLGINFO;


typedef struct
{
    HDEVINFO            hDevInfo;
    PSP_DEVINFO_DATA    pDevInfoData;

} ALLDEVINFO, *PALLDEVINFO;

/*
 ***************************************************************
 * Globals and Strings used to loadstring resources at startup
 ***************************************************************
 */
#ifdef __cplusplus
extern "C" {
#endif

extern TCHAR        gszNone[];
extern TCHAR        gszRemoveScheme[];
extern TCHAR        gszChangeScheme[];
extern SZCODE      gszWindowsHlp[];
extern SZCODE      gszNull[];

extern SZCODE      cszWavExt[];
extern SZCODE      cszMIDIExt[];
extern SZCODE      cszRMIExt[];
extern SZCODE      cszAVIExt[];
extern SZCODE      cszSlash[];

extern SZCODE      cszAUDIO[];
extern SZCODE      cszVIDEO[];
extern SZCODE      cszCDAUDIO[];
extern SZCODE      cszMIDI[];

extern TCHAR       gszDevEnabled[];
extern TCHAR       gszDevDisabled[];
extern TCHAR       gszGeneral[];

extern HINSTANCE ghInstance;
extern BOOL gfVoiceTab;
extern HWND ghVocDlg;
extern BOOL gfRedisplayCPL;

extern INT_PTR PASCAL GetVerDesc (LPCTSTR pstrFile, LPTSTR pstrDesc);
extern BOOL PASCAL GetExeDesc (LPTSTR szFile, LPTSTR pszBuff, int cchBuff);
extern BOOL PASCAL LoadDesc(LPCTSTR pstrFile, LPTSTR pstrDesc);
extern void AddExt(LPTSTR pszFile, LPCTSTR cszExt);
extern BOOL PASCAL ValidateRegistry(void);


#define GEI_MODNAME         0x01
#define GEI_DESCRIPTION     0x02
#define GEI_FLAGS           0x03
#define GEI_EXEHDR          0x04
#define GEI_FAPI            0x05

MMRESULT GetWaveID(UINT *puWaveID);

void PASCAL ShowPropSheet(LPCTSTR            pszTitle,
    DLGPROC             pfnDialog,
    UINT                idTemplate,
    HWND                hWndParent,
    LPTSTR               pszCaption,
    LPARAM              lParam);

void PASCAL ShowMidiPropSheet(LPPROPSHEETHEADER ppshExt, LPCTSTR pszTitle,
    HWND                hWndParent,
    short               iMidiPropType,
    LPTSTR               pszCaption,
    HTREEITEM           hti,
    LPARAM              lParam1,
    LPARAM              lParam2);

void PASCAL ShowWithMidiDevPropSheet(LPCTSTR            pszTitle,
    DLGPROC             pfnDialog,
    UINT                idTemplate,
    HWND                hWndParent,
    LPTSTR               pszCaption,
    HTREEITEM           hti,
    LPARAM lParam, LPARAM lParamExt1, LPARAM lParamExt2);

#define MT_WAVE 1
#define MT_MIDI 2
#define MT_AVI  3
#define MT_ASF  4
#define MT_ERROR 0
BOOL mmpsh_ShowFileDetails(LPTSTR pszCaption, HWND hwndParent, LPTSTR pszFile, short iMediaType);

INT_PTR mmse_MessageBox(HWND hwndP,  LPTSTR szMsg, LPTSTR szTitle, UINT uStyle);


void PASCAL GetPropSheet(LPCTSTR            pszTitle,
    LPCTSTR              pszClass,
    DLGPROC             pfnDialog,
    UINT                idTemplate,
    HWND                hWndParent,
    HICON               hClassIcon,
    LPPROPSHEETHEADER ppsh, HPROPSHEETPAGE  * lphpsp);

BOOL      PASCAL ErrorBox               (HWND, int, LPTSTR);
int       PASCAL DisplayMessage(HWND hDlg, int iResTitle, int iResMsg, UINT uStyle);


BOOL ACMEnumCodecs(void);
void ACMCleanUp(void);
void ACMNodeChange(HWND hDlg);

BOOL CALLBACK MMExtPropSheetCallback(DWORD dwFunc, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwInstance);
typedef BOOL (CALLBACK FAR * LPFNMMEXTPROPSHEETCALLBACK)(DWORD dwFunc, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwInstance);

//Following are functions currently supported by the callback functions:
//dwInstance parameter which is passed to the external module when its entry point
//is called MUST always be passed back along with all the functions.

#define MM_EPS_GETNODEDESC      0x00000001
    //Gets the description displayed in the tree for the node for which the External Prop. Sheet is up.
    //For 'simple' property sheet this just returns a sheet Name
    //dwParam1 is a pointer to a string buffer in which the description is returned

#define MM_EPS_GETNODEID        0x00000002
    //Gets the Reg. Key Path offset from the MediaResources key
    //For 'simple' property sheet this just returns a sheet class
    //dwParam1 is a pointer to a string buffer in which the Key Path is returned

#define MM_EPS_ADDSHEET         0x00000003
    //Adds a property sheet for the current node in the tree.
    //dwParam1 = HPROPSHEETPAGE for the page being added.

#define MM_EPS_TREECHANGE       0x00000004
    //Notifies the CPL that the tree styructure has change. On receiving this function
    //the CPL rebuilds the subtree at this level and all levels below it.

#define MM_EPS_BLIND_TREECHANGE    0x00000005
    //Notification from MIDI sheet that something has changed in the MIDI subtree.
    //BLIND because the sheet was not launched from the Adv. Tab, so we dont know
    //what the heck he is talking about.

BOOL CALLBACK  AddSimpleMidiPages (LPTSTR    pszTitle, LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,LPARAM lParam);
BOOL CALLBACK  AddMidiPages (LPCTSTR    pszTitle, LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,LPARAM lParam);
BOOL CALLBACK  AddDevicePages (LPCTSTR    pszTitle, LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,LPARAM lParam);
BOOL CALLBACK  AddInstrumentPages (LPCTSTR    pszTitle, LPFNMMEXTPROPSHEETCALLBACK  lpfnAddPropSheetPage,LPARAM lParam);

#ifdef FIX_BUG_15451
void ShowDriverSettings (HWND hDlg, LPTSTR pszName);
#endif // FIX_BUG_15451

#ifdef __cplusplus
} // extern "C"
#endif

#define MIDI_CLASS_PROP 1
#define MIDI_DEVICE_PROP 2
#define MIDI_INSTRUMENT_PROP 3


#define WM_ACMMAP_ACM_NOTIFY        (WM_USER + 100)

/*
 ***************************************************************
 * DEBUG Definitions
 ***************************************************************
 */
#ifdef ASSERT
#undef ASSERT
#endif
#ifdef DEBUG
#define STATIC
#ifdef DEBUG_TRACE
#define DPF_T    dprintf
#else
#define DPF_T 1 ? (void)0 : (void)
#endif
void FAR cdecl dprintf(LPSTR szFormat, ...);
#define DPF    dprintf
#define ddd    dprintf
#define ASSERT(f)                                                       \
    {                                                                   \
        if (!(f))                                                       \
            DPF("ERROR-ERROR#####: Assertion failed in %s on line %d @@@@@",__FILE__, __LINE__);                          \
    }


#else
#define STATIC static
#define ASSERT(f)
#define DPF 1 ? (void)0 : (void)
#define DPF_T 1 ? (void)0 : (void)
#endif

#endif // MMCPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\install.c ===
/*************************************************************************
 *
 *  INSTALL.C
 *
 *  Copyright (C) Microsoft, 1991, All Rights Reserved.
 *
 *  History:
 *
 *      Thu Oct 17 1991 -by- Sanjaya
 *      Created. Culled out of drivers.c
 *
 *************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <winsvc.h>
#include <memory.h>
#include <string.h>
#include <cpl.h>
#include <regstr.h>
#include <infstr.h>
#include <cphelp.h>
#include <stdlib.h>
#include "drivers.h"
#include "sulib.h"
#include "debug.h"

BOOL     GetValidAlias           (LPTSTR, LPTSTR);
BOOL     SelectInstalled         (HWND, PIDRIVER, LPTSTR, HDEVINFO, PSP_DEVINFO_DATA);
void     InitDrvConfigInfo       (LPDRVCONFIGINFO, PIDRIVER );
BOOL     InstallDrivers          (HWND, HWND, LPTSTR);
void     RemoveAlreadyInstalled  (LPTSTR, LPTSTR);
void     CheckIniDrivers         (LPTSTR, LPTSTR);
void     RemoveDriverParams      (LPTSTR, LPTSTR);

void     InsertNewIDriverNodeInList(PIDRIVER *, PIDRIVER);
void     DestroyIDriverNodeList(PIDRIVER, BOOL, BOOL);


/*
 ***************************************************************
 * Global strings
 ***************************************************************
 */
CONST TCHAR gszDriversSubkeyName[]      = TEXT("Drivers");
CONST TCHAR gszSubClassesValue[]        = TEXT("SubClasses");
CONST TCHAR gszDescriptionValue[]       = TEXT("Description");
CONST TCHAR gszDriverValue[]            = TEXT("Driver");
static CONST TCHAR gszAliasValue[]             = TEXT("Alias");
static CONST TCHAR gszAliasWOW64Value[]        = TEXT("AliasWOW64");
static CONST TCHAR gszWaveWOW64Value[]         = TEXT("WOW64");


/**************************************************************************
 *
 *  InstallDrivers()
 *
 *  Install a driver and set of driver types.
 *
 *  Parameters :
 *      hwnd      - Window handle of the main drivers.cpl windows
 *      hwndAvail - Handle of the 'available drivers' dialog window
 *      pstrKey   - Key name of the inf section item we are installing
 *
 *  This routine calls itself recursively to install related drivers
 *  (as listed in the .inf file).
 *
 **************************************************************************/

BOOL InstallDrivers(HWND hWnd, HWND hWndAvail, LPTSTR pstrKey)
{
    IDRIVER     IDTemplate; // temporary for installing, removing, etc.
    PIDRIVER    pIDriver=NULL;
    int         n;
    TCHAR        szTypes[MAXSTR];
    TCHAR        szType[MAXSTR];
    TCHAR        szParams[MAXSTR];

    szTypes[0] = TEXT('\0');

    hMesgBoxParent = hWndAvail;

    /*
     * mmAddNewDriver needs a buffer for all types we've actually installed
     * User critical errors will pop up a task modal
     */

    IDTemplate.bRelated = FALSE;
    IDTemplate.szRemove[0] = TEXT('\0');

    /*
     *  Do the copying and extract the list of types (WAVE, MIDI, ...)
     *  and the other driver data
     */

    if (!mmAddNewDriver(pstrKey, szTypes, &IDTemplate))
        return FALSE;

    szTypes[lstrlen(szTypes)-1] = TEXT('\0');         // Remove space left at end

    RemoveAlreadyInstalled(IDTemplate.szFile, IDTemplate.szSection);

    /*
     *  At this point we assume the drivers were actually copied.
     *  Now we need to add them to the installed list.
     *  For each driver type we create an IDRIVER and add to the listbox
     */

    for (n = 1; ; n++)
    {
		LONG lResult = infParseField(szTypes, n, szType, SIZEOF(szType));
		if( INF_PARSE_FAILED(lResult) )
		{
			return FALSE;
		}
		else if( lResult != ERROR_SUCCESS )
		{
			ASSERT( lResult == ERROR_NOT_FOUND );
			break;
		}

        /*
         *  Find a valid alias for this device (eg Wave2).  This is
         *  used as the key in the [MCI] or [drivers] section.
         */

        if (GetValidAlias(szType, IDTemplate.szSection) == FALSE)
        {
            /*
             *  Exceeded the maximum, tell the user
             */

            LPTSTR pstrMessage;
            TCHAR szApp[MAXSTR];
            TCHAR szMessage[MAXSTR];

            LoadString(myInstance,
                       IDS_CONFIGURE_DRIVER,
                       szApp,
                       sizeof(szApp)/sizeof(TCHAR));

            LoadString(myInstance,
                       IDS_TOO_MANY_DRIVERS,
                       szMessage,
                       sizeof(szMessage)/sizeof(TCHAR));

            if (NULL !=
                (pstrMessage =
                 (LPTSTR)LocalAlloc(LPTR,
                                    sizeof(szMessage) + (lstrlen(szType)*sizeof(TCHAR)))))
            {
                wsprintf(pstrMessage, szMessage, (LPTSTR)szType);

                MessageBox(hWndAvail,
                           pstrMessage,
                           szApp,
                           MB_OK | MB_ICONEXCLAMATION|MB_TASKMODAL);

                LocalFree((HANDLE)pstrMessage);
            }
            continue;
        }

        if ( (pIDriver = (PIDRIVER)LocalAlloc(LPTR, sizeof(IDRIVER))) != NULL)
        {
            /*
             *  Copy all fields
             */

            memcpy(pIDriver, &IDTemplate, sizeof(IDRIVER));
            wcsncpy(pIDriver->szAlias, szType, sizeof(pIDriver->szAlias)/sizeof(TCHAR));
            pIDriver->szAlias[sizeof(pIDriver->szAlias)/sizeof(TCHAR) - 1] = TEXT('\0');
            wcscpy(pIDriver->wszAlias, pIDriver->szAlias);


            /*
             *  Want only one instance of each driver to show up in the list
             *  of installed drivers. Thus for the remaining drivers just
             *  place an entry in the drivers section of system.ini
             */


            if ( n > 1)
            {


                if (wcslen(szParams) != 0 && !pIDriver->KernelDriver)
                {
                    /*
                     *  Write their parameters to a section bearing their
                     *  file name with an alias reflecting their alias
                     */

                    WriteProfileString(pIDriver->szFile,
                                       pIDriver->szAlias,
                                       szParams);
                }

                WritePrivateProfileString(pIDriver->szSection,
                                          pIDriver->szAlias,
                                          pIDriver->szFile,
                                          szSysIni);
            }
            else
            {


                /*
                 *  Reduce to just the driver name
                 */

                RemoveDriverParams(pIDriver->szFile, szParams);

                wcscpy(pIDriver->wszFile, pIDriver->szFile);

                if (wcslen(szParams) != 0 && !pIDriver->KernelDriver)
                {
                    /*
                     *  Write their parameters to a section bearing their
                     *  file name with an alias reflecting their alias
                     */

                    WriteProfileString(pIDriver->szFile,
                                       pIDriver->szAlias,
                                       szParams);
                }

                WritePrivateProfileString(pIDriver->szSection,
                                          pIDriver->szAlias,
                                          pIDriver->szFile,
                                          szSysIni);

                /*
                 *  Call the driver to see if it can be configured
                 *  and configure it if it can be
                 */

                if (!SelectInstalled(hWndAvail, pIDriver, szParams, INVALID_HANDLE_VALUE, NULL))
                {

                    /*
                     *  Error talking to driver
                     */

                    WritePrivateProfileString(pIDriver->szSection,
                                              pIDriver->szAlias,
                                              NULL,
                                              szSysIni);

                    WriteProfileString(pIDriver->szFile,
                                       pIDriver->szAlias,
                                       NULL);

                    RemoveIDriver (hAdvDlgTree, pIDriver, TRUE);
                    return FALSE;
                }

                /*
                 *  for displaying the driver desc. in the restart mesg
                 */

                if (!bRelated || pIDriver->bRelated)
                {
                    wcsncpy(szRestartDrv, pIDriver->szDesc, ARRAYSIZE(szRestartDrv));
                    szRestartDrv[ARRAYSIZE(szRestartDrv)-1] = TEXT('\0'); // Make sure there is a NULL terminator
                }

                /*
                 *  We need to write out the driver description to the
                 *  control.ini section [Userinstallable.drivers]
                 *  so we can differentiate between user and system drivers
                 *
                 *  This is tested by the function UserInstalled when
                 *  the user tries to remove a driver and merely
                 *  affects which message the user gets when being
                 *  asked to confirm removal (non user-installed drivers
                 *  are described as being necessary to the system).
                 */

                WritePrivateProfileString(szUserDrivers,
                                          pIDriver->szAlias,
                                          pIDriver->szFile,
                                          szControlIni);


                /*
                 *  Update [related.desc] section of control.ini :
                 *
                 *  ALIAS=driver name list
                 *
                 *  When the driver whose alias is ALIAS is removed
                 *  the drivers in the name list will also be removed.
                 *  These were the drivers in the related drivers list
                 *  when the driver is installed.
                 */

                WritePrivateProfileString(szRelatedDesc,
                                          pIDriver->szAlias,
                                          pIDriver->szRemove,
                                          szControlIni);


                /*
                 * Cache the description string in control.ini in the
                 * drivers description section.
                 *
                 * The key is the driver file name + extension.
                 */

                WritePrivateProfileString(szDriversDesc,
                                          pIDriver->szFile,
                                          pIDriver->szDesc,
                                          szControlIni);

#ifdef DOBOOT // We don't do the boot section on NT

                if (bInstallBootLine)
                {
                    szTemp[MAXSTR];

                    GetPrivateProfileString(szBoot,
                                            szDrivers,
                                            szTemp,
                                            szTemp,
                                            sizeof(szTemp) / sizeof(TCHAR),
                                            szSysIni);
                    wcscat(szTemp, TEXT(" "));
                    wcscat(szTemp, pIDriver->szAlias);
                    WritePrivateProfileString(szBoot,
                                              szDrivers,
                                              szTemp,
                                              szSysIni);
                    bInstallBootLine = FALSE;
                }
#endif // DOBOOT
            }
        }
        else
            return FALSE;                       //ERROR
    }


    /*
     *  If no types were added then fail
     */

    if (pIDriver == NULL)
    {
        return FALSE;
    }

    /*
     *  If there are related drivers listed in the .inf section to install
     *  then install them now by calling ourselves.  Use IDTemplate which
     *  is where mmAddNewDriver put the data.
     */

    if (IDTemplate.bRelated == TRUE)
    {

        int i;
        TCHAR szTemp[MAXSTR];

        /*
         *  Tell file copying to abort rather than put up errors
         */

        bCopyingRelated = TRUE;

        for (i = 1; (infParseField(IDTemplate.szRelated, i, szTemp, SIZEOF(szTemp)) == ERROR_SUCCESS);i++)
        {

            InstallDrivers(hWnd, hWndAvail, szTemp);
        }
    }
    return TRUE;
}

BOOL SelectInstalledKernelDriver(PIDRIVER pIDriver, LPTSTR pszParams)
{
    SC_HANDLE SCManagerHandle;
    SC_HANDLE ServiceHandle;
    TCHAR ServiceName[MAX_PATH];
    TCHAR BinaryPath[MAX_PATH];
    BOOL Success;
    SC_LOCK ServicesDatabaseLock;
    DWORD dwTagId;

    /*
     *  These drivers are not configurable
     */

    pIDriver->fQueryable = 0;

    /*
     *  The services controller will create the registry node to
     *  which we can add the device parameters value
     */

    wcscpy(BinaryPath, TEXT("\\SystemRoot\\system32\\drivers\\"));
    wcscat(BinaryPath, pIDriver->szFile);

    /*
     *  First try and obtain a handle to the service controller
     */

    SCManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (SCManagerHandle == NULL)
        return FALSE;

    /*
     *  Lock the service controller database to avoid deadlocks
     *  we have to loop because we can't wait
     */


    for (ServicesDatabaseLock = NULL;
        (ServicesDatabaseLock =
         LockServiceDatabase(SCManagerHandle))
        == NULL;
        Sleep(100))
    {
    }

    {
        TCHAR drive[MAX_PATH], directory[MAX_PATH], ext[MAX_PATH];
        lsplitpath(pIDriver->szFile, drive, directory, ServiceName, ext);
    }


    ServiceHandle = CreateService(SCManagerHandle,
                                  ServiceName,
                                  NULL,
                                  SERVICE_ALL_ACCESS,
                                  SERVICE_KERNEL_DRIVER,
                                  SERVICE_DEMAND_START,
                                  SERVICE_ERROR_NORMAL,
                                  BinaryPath,
                                  TEXT("Base"),
                                  &dwTagId,
                                  TEXT("\0"),
                                  NULL,
                                  NULL);

    UnlockServiceDatabase(ServicesDatabaseLock);

    if (ServiceHandle == NULL)
    {
        CloseServiceHandle(SCManagerHandle);
        return FALSE;
    }

    /*
     *  Try to write the parameters to the registry if there
     *  are any
     */

    if (wcslen(pszParams))
    {

        HKEY ParmsKey;
        TCHAR RegPath[MAX_PATH];
        wcscpy(RegPath, TEXT("\\SYSTEM\\CurrentControlSet\\Services\\"));
        wcscat(RegPath, ServiceName);
        wcscat(RegPath, TEXT("\\Parameters"));

        Success = RegCreateKey(HKEY_LOCAL_MACHINE,
                               RegPath,
                               &ParmsKey) == ERROR_SUCCESS &&
                  RegSetValue(ParmsKey,
                              TEXT(""),
                              REG_SZ,
                              pszParams,
                              wcslen(pszParams)*sizeof(TCHAR)) == ERROR_SUCCESS &&
                  RegCloseKey(ParmsKey) == ERROR_SUCCESS;

    }
    else
    {
        Success = TRUE;
    }

    /*
     *  Service created so try and start it
     */

    if (Success)
    {
        //  We tell them to restart just in case
        bRestart = TRUE;

        /*
         *  Load the kernel driver by starting the service.
         *  If this is successful it should be safe to let
         *  the system load the driver at system start so
         *  we change the start type.
         */

        Success =
            StartService(ServiceHandle, 0, NULL) &&
            ChangeServiceConfig(ServiceHandle,
                                SERVICE_NO_CHANGE,
                                SERVICE_SYSTEM_START,
                                SERVICE_NO_CHANGE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if (!Success)
        {
            TCHAR szMesg[MAXSTR];
            TCHAR szMesg2[MAXSTR];
            TCHAR szTitle[50];

            /*
             *  Uninstall driver if we couldn't load it
             */

            for (ServicesDatabaseLock = NULL;
                (ServicesDatabaseLock =
                 LockServiceDatabase(SCManagerHandle))
                == NULL;
                Sleep(100))
            {
            }

            DeleteService(ServiceHandle);

            UnlockServiceDatabase(ServicesDatabaseLock);

            /*
             *  Tell the user there was a configuration error
             *  (our best guess).
             */

            LoadString(myInstance, IDS_DRIVER_CONFIG_ERROR, szMesg, sizeof(szMesg)/sizeof(TCHAR));
            LoadString(myInstance, IDS_CONFIGURE_DRIVER, szTitle, sizeof(szTitle)/sizeof(TCHAR));
            wsprintf(szMesg2, szMesg, FileName(pIDriver->szFile));
            MessageBox(hMesgBoxParent, szMesg2, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
        }
    }

    CloseServiceHandle(ServiceHandle);
    CloseServiceHandle(SCManagerHandle);

    return Success;
}

/************************************************************************
 *
 *  SelectInstalled()
 *
 *  Check if the driver can be configured and configure it if it can be.
 *
 *  hwnd           - Our window - parent for driver to make its config window
 *  pIDriver       - info about the driver
 *  params         - the drivers parameters from the .inf file.
 *  DeviceInfoSet  - Optionally, specifies the set containing the PnP device
 *                   being installed.  Specify INVALID_HANDLE_VALUE is this
 *                   parameter is not present.
 *  DeviceInfoData - Optionally, specifies the PnP device being installed
 *                   (ignored if DeviceInfoSet is not specified).
 *
 *  Returns FALSE if an error occurred, otherwise TRUE.  GetLastError() may
 *  be called to determine the cause of the failure.
 *
 ************************************************************************/

BOOL SelectInstalled(HWND hwnd, PIDRIVER pIDriver, LPTSTR pszParams, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
    BOOL bSuccess      = TRUE;  // Assume we succeed
    BOOL bPutUpMessage = FALSE; // Assume we don't have to put up a message
    HANDLE hDriver = 0;
    DRVCONFIGINFO DrvConfigInfo;
    DWORD_PTR DrvMsgResult;
    DWORD ConfigFlags;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    HKEY hkDrv = NULL;

    // Open device reg key
    hkDrv = SetupDiOpenDevRegKey(DeviceInfoSet,
                                 DeviceInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DRV,
                                 KEY_ALL_ACCESS);

    if (!hkDrv)
    {
        return GetLastError();
    }

    wsStartWait();

    /*
     *  If it's a kernel driver call the services controller to
     *  install the driver (unless it's a PnP device, in which case
     *  SetupDiInstallDevice would've already handled any necessary
     *  service installation).
     */

    if (pIDriver->KernelDriver)
    {
        // If DeviceInfoSet is a valid handle, then this is a PnP device
        // and there's nothing we need to do. Otherwise, config the kernel driver.
        if (DeviceInfoSet == INVALID_HANDLE_VALUE)
            bSuccess = SelectInstalledKernelDriver(pIDriver,pszParams);
        goto SelectInstalled_exit;
    }

    //  See if we can open the driver
    hDriver = OpenDriver(pIDriver->wszFile, NULL, 0L);

    if (!hDriver)
    {
        bSuccess      = FALSE;
        bPutUpMessage = TRUE;
        goto SelectInstalled_exit;
    }

    // Driver opened, prepare to send config messages to driver
    InitDrvConfigInfo(&DrvConfigInfo, pIDriver);

    // On ISAPNP devices, we need to set the CONFIGFLAG_NEEDS_FORCED_CONFIG before
    // we call into the driver to setup resources.
    if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                          DeviceInfoData,
                                          SPDRP_CONFIGFLAGS,
                                          NULL,
                                          (PBYTE)&ConfigFlags,
                                          sizeof(ConfigFlags),
                                          NULL))
    {
        ConfigFlags = 0;
    }

    ConfigFlags |= CONFIGFLAG_NEEDS_FORCED_CONFIG;

    SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_CONFIGFLAGS,
                                     (PBYTE)&ConfigFlags,
                                     sizeof(ConfigFlags)
                                    );

    // See if this is a PnP device by trying to send it a PnP install message.
    // Call driver with DRV_PNPINSTALL
    DrvMsgResult = SendDriverMessage(hDriver,
                                     DRV_PNPINSTALL,
                                     (LONG_PTR)DeviceInfoSet,
                                     (LONG_PTR)DeviceInfoData);

    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);

    // Look at result of DRV_PNPINSTALL
    switch (DrvMsgResult)
    {
    case DRVCNF_RESTART :
        // The installation was successful, but a reboot is required.
        // Ensure that the 'need reboot' flag in the device's installation parameters.
        DeviceInstallParams.Flags |= DI_NEEDREBOOT;

        // Let fall through to processing of successful installation.
    case DRVCNF_OK :
        // Remember that this is a PNPISA device driver
        RegSetValueEx(hkDrv,TEXT("DriverType"),0,REG_SZ,(LPBYTE)(TEXT("PNPISA")),14);

        break;

    default:
        // The driver did not want to install.
        // This may be because
        // 1) The user wanted to cancel
        // 2) Installation failed for some other reason
        // 3) This is not an ISAPNP driver (it's either a legacy driver or a WDM driver)
        //    and it doesn't support the DRV_PNPINSTALLis messsage.
        // Unfortunately, we don't have fine enough granularity in the return codes to
        // distinguish between these cases.

        // Assume it's a legacy or WDM driver that doesn't support DRV_PNPINSTALL.
        // Try calling DRV_INSTALL instead.

        // Remember to clear CONFIGFLAG_NEEDS_FORCED_CONFIG flag, which shouldn't be set
        // for legacy or WDM drivers.
        ConfigFlags &= ~CONFIGFLAG_NEEDS_FORCED_CONFIG;
        SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_CONFIGFLAGS,
                                         (PBYTE)&ConfigFlags,
                                         sizeof(ConfigFlags)
                                        );

        // Call driver with DRV_INSTALL
        DrvMsgResult = SendDriverMessage(hDriver,
                                         DRV_INSTALL,
                                         0L,
                                         (LONG_PTR)(LPDRVCONFIGINFO)&DrvConfigInfo);
        // Look at result of DRV_INSTALL
        switch (DrvMsgResult)
        {
        case DRVCNF_RESTART:
            // Remember to restart, then fall through to OK case
            DeviceInstallParams.Flags |= DI_NEEDREBOOT;
            bRestart = TRUE;
        case DRVCNF_OK:
            // Remember whether the driver is configurable
            // If it's a WDM driver, it will return FALSE.
            pIDriver->fQueryable =
                (int)SendDriverMessage(hDriver,
                                       DRV_QUERYCONFIGURE,
                                       0L,
                                       0L);

            // If the driver is configurable then configure it.
            // Configuring the driver may result in a need to restart
            // the system.  The user may also cancel install.
            if (pIDriver->fQueryable)
            {
                RegSetValueEx(hkDrv,TEXT("DriverType"),0,REG_SZ,(LPBYTE)(TEXT("Legacy")),14);

                switch (SendDriverMessage(hDriver,
                                          DRV_CONFIGURE,
                                          (LONG_PTR)hwnd,
                                          (LONG_PTR)(LPDRVCONFIGINFO)&DrvConfigInfo))
                {
                case DRVCNF_RESTART:
                    DeviceInstallParams.Flags |= DI_NEEDREBOOT;
                    bRestart = TRUE;
                case DRVCNF_OK:
                    break;

                case DRVCNF_CANCEL:
                    // Don't put up the error box if the user cancelled
                    bSuccess = FALSE;
                    break;
                }
            }
            break;
        case DRVCNF_CANCEL:
            // The driver did not want to install
            SetLastError(ERROR_CANCELLED);
            bPutUpMessage = TRUE;
            bSuccess = FALSE;
            break;
        }
    }

    SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);

    SelectInstalled_exit:

    if (hkDrv)
    {
        RegCloseKey(hkDrv);
    }

    if (hDriver)
    {
        CloseDriver(hDriver, 0L, 0L);
    }

    //  If dealing with the driver resulted in error then put up a message
    if (bPutUpMessage)
    {
        OpenDriverError(hwnd, pIDriver->szDesc, pIDriver->szFile);
    }

    wsEndWait();

    return bSuccess;
}

/***********************************************************************
 *
 *  InitDrvConfigInfo()
 *
 *  Initialize Driver Configuration Information.
 *
 ***********************************************************************/

void InitDrvConfigInfo( LPDRVCONFIGINFO lpDrvConfigInfo, PIDRIVER pIDriver )
{
    lpDrvConfigInfo->dwDCISize          = sizeof(DRVCONFIGINFO);
    lpDrvConfigInfo->lpszDCISectionName = pIDriver->wszSection;
    lpDrvConfigInfo->lpszDCIAliasName   = pIDriver->wszAlias;
}

/***********************************************************************
 *
 *  GetValidAlias()
 *
 *  pstrType     - Input  - the type
 *                 Output - New alias for that type
 *
 *  pstrSection  - The system.ini section we're dealing with
 *
 *  Create a valid alias name for a type.  Searches the system.ini file
 *  in the drivers section for aliases of the type already defined and
 *  returns a new alias (eg WAVE1).
 *
 ***********************************************************************/
BOOL GetValidAlias(LPTSTR pstrType, LPTSTR pstrSection)
{
    TCHAR keystr[32];
    TCHAR *pstrTypeEnd;
    int AppendVal;
    DWORD CharsFound;

    pstrTypeEnd = pstrType + wcslen(pstrType);
    for (AppendVal=0; AppendVal<=9; AppendVal++)
    {
        if (AppendVal!=0)
        {
            _itow(AppendVal,pstrTypeEnd,10);
        }

        CharsFound = GetPrivateProfileString( pstrSection,
                                            pstrType,
                                            TEXT(""),
                                            keystr,
                                            sizeof(keystr) / sizeof(TCHAR),
                                            szSysIni);

        if (!CharsFound)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*******************************************************************
 *
 *  IsConfigurable
 *
 *  Find if a driver supports configuration
 *
 *******************************************************************/

BOOL IsConfigurable(PIDRIVER pIDriver, HWND hwnd)
{
    HANDLE hDriver;

    wsStartWait();

    /*
     *  have we ever checked if this driver is queryable?
     */

    if ( pIDriver->fQueryable == -1 )
    {

        /*
         *  Check it's not a kernel driver
         */

        if (pIDriver->KernelDriver)
        {
            pIDriver->fQueryable = 0;
        }
        else
        {

            /*
             *  Open the driver and ask it if it is configurable
             */

            hDriver = OpenDriver(pIDriver->wszAlias, pIDriver->wszSection, 0L);

            if (hDriver)
            {
                pIDriver->fQueryable =
                    (int)SendDriverMessage(hDriver,
                                           DRV_QUERYCONFIGURE,
                                           0L,
                                           0L);

                CloseDriver(hDriver, 0L, 0L);
            }
            else
            {
                pIDriver->fQueryable = 0;
                OpenDriverError(hwnd, pIDriver->szDesc, pIDriver->szFile);
                wsEndWait();
                return(FALSE);
            }
        }
    }
    wsEndWait();
    return((BOOL)pIDriver->fQueryable);
}

/******************************************************************
 *
 *  Find any driver with the same name currently installed and
 *  remove it
 *
 *  szFile     - File name of driver
 *  szSection  - system.ini section ([MCI] or [drivers]).
 *
 ******************************************************************/

void RemoveAlreadyInstalled(LPTSTR szFile, LPTSTR szSection)
{
    PIDRIVER pIDriver;

    pIDriver = FindIDriverByName (szFile);

    if (pIDriver != NULL)
    {
        PostRemove(pIDriver, FALSE);
        return;
    }

    CheckIniDrivers(szFile, szSection);
}

/******************************************************************
 *
 *  Remove system.ini file entries for our driver
 *
 *  szFile    - driver file name
 *  szSection - [drivers] or [MCI]
 *
 ******************************************************************/

void CheckIniDrivers(LPTSTR szFile, LPTSTR szSection)
{
    TCHAR allkeystr[MAXSTR * 2];
    TCHAR szRemovefile[20];
    TCHAR *keystr;

    GetPrivateProfileString(szSection,
                            NULL,
                            NULL,
                            allkeystr,
                            sizeof(allkeystr) / sizeof(TCHAR),
                            szSysIni);

    keystr = allkeystr;
    while (wcslen(keystr) > 0)
    {

        GetPrivateProfileString(szSection,
                                keystr,
                                NULL,
                                szRemovefile,
                                sizeof(szRemovefile) / sizeof(TCHAR),
                                szSysIni);

        if (!FileNameCmp(szFile, szRemovefile))
            RemoveDriverEntry(keystr, szFile, szSection, FALSE);

        keystr = &keystr[wcslen(keystr) + 1];
    }
}

/******************************************************************
 *
 *   RemoveDriverParams
 *
 *   Remove anything after the next token
 *
 ******************************************************************/

void RemoveDriverParams(LPTSTR szFile, LPTSTR Params)
{
    for (;*szFile == TEXT(' '); szFile++);
    for (;*szFile != TEXT(' ') && *szFile != TEXT('\0'); szFile++);
    if (*szFile == TEXT(' '))
    {
        *szFile = TEXT('\0');
        for (;*++szFile == TEXT(' '););
        wcscpy(Params, szFile);
    }
    else
    {
        *Params = TEXT('\0');
    }
}


DWORD
    InstallDriversForPnPDevice(
                              IN HWND             hWnd,
                              IN HDEVINFO         DeviceInfoSet,
                              IN PSP_DEVINFO_DATA DeviceInfoData
                              )
/*++

Routine Description:

    This routine traverses the "Drivers" tree under the specified device's software
    key, adding each multimedia type entry present to the Drivers32 key of the registry.
    The driver is then invoked to perform any configuration necessary for that type.

Arguments:

    hWnd - Supplies the handle of the window to be used as the parent for any UI.

    DeviceInfoSet - Supplies a handle to the device information set containing the
        multimedia device being installed.

    DeviceInfoData - Supplies the address of the SP_DEVINFO_DATA structure representing
        the multimedia device being installed.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error code.

--*/
{
    HKEY hKey, hDriversKey, hTypeInstanceKey;
    TCHAR szTypes[MAXSTR];
    TCHAR szType[MAXSTR];
    DWORD Err;
    DWORD RegDataType, cbRegDataSize, RegKeyIndex;
    int i;
    PIDRIVER pIDriver, pPrevIDriver;
    PIDRIVER IDriverList = NULL, IDriverListToCleanUp = NULL;
    TCHAR CharBuffer[MAX_PATH + sizeof(TCHAR)];
    LPCTSTR CurrentFilename;
    BOOL bNoMoreAliases = FALSE;
    LPCTSTR szAliasStringToUse;   // Pointer to the Alias value name to use
    BOOL bIsWOW64Process = FALSE; // TRUE if we're running under WOW64

    //
    // If we're running in WOW64, we need to use a different Alias string so that
    // we don't overwrite the 64-bit alias string
    //
    if( IsWow64Process(GetCurrentProcess(), &bIsWOW64Process)
    &&  bIsWOW64Process )
    {
        szAliasStringToUse = gszAliasWOW64Value;
    }
    else
    {
        szAliasStringToUse = gszAliasValue;
    }

    if ((hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                     DeviceInfoData,
                                     DICS_FLAG_GLOBAL,
                                     0,
                                     DIREG_DRV,
                                     KEY_ALL_ACCESS)) == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    //
    // What we're really interested in is the "Drivers" subkey.
    //
    Err = (DWORD)RegOpenKeyEx(hKey, gszDriversSubkeyName, 0, KEY_ALL_ACCESS, &hDriversKey);

    RegCloseKey(hKey);      // don't need this key anymore.

    if (Err != ERROR_SUCCESS)
    {
        //
        // If the key is not present, then there is no work to do.
        //
        return NO_ERROR;
    }

    //
    // Retrieve the "SubClasses" value from this key.  This contains a comma-delimited
    // list of all multimedia type entries associated with this device.
    //
    cbRegDataSize = sizeof(szTypes);
    if ((Err = RegQueryValueEx(hDriversKey,
                               gszSubClassesValue,
                               NULL,
                               &RegDataType,
                               (PBYTE)szTypes,
                               &cbRegDataSize)) != ERROR_SUCCESS)
    {
        goto clean0;
    }

    if ((RegDataType != REG_SZ) || !cbRegDataSize)
    {
        Err = ERROR_INVALID_DATA;
        goto clean0;
    }


    //
    // OK, we have the list of types, now process each one.
    //
    for (i = 1; Err == NO_ERROR ; i++)
    {
		LONG lResult = infParseField(szTypes, i, szType, SIZEOF(szType));
		if( INF_PARSE_FAILED(lResult) )
		{
			Err = ERROR_INVALID_DATA;
            break;
		}
		else if( lResult != ERROR_SUCCESS )
		{
			ASSERT( lResult == ERROR_NOT_FOUND );
			break;	
		}

#ifdef _WIN64
        //
        // Check for magic WaveWOW64 value
        if( 0 == _wcsnicmp( szType, gszWaveWOW64Value, wcslen(gszWaveWOW64Value) ) )
        {
            // Thunk the installation to the 32-bit mmsys.cpl installer
            mmWOW64ThunkMediaClassInstaller(DIF_INSTALLDEVICE, DeviceInfoSet, DeviceInfoData);

            continue;
        }
#endif //_WIN64

        if (RegOpenKeyEx(hDriversKey, szType, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        {
            //
            // Couldn't find a subkey for this entry--move on to the next one.
            //
            continue;
        }

        for (RegKeyIndex = 0;
            ((Err == NO_ERROR) &&
             (RegEnumKey(hKey, RegKeyIndex, CharBuffer, sizeof(CharBuffer)/sizeof(TCHAR)) == ERROR_SUCCESS));
            RegKeyIndex++)
        {
            if (RegOpenKeyEx(hKey, CharBuffer, 0, KEY_ALL_ACCESS, &hTypeInstanceKey) != ERROR_SUCCESS)
            {
                //
                // For some reason, we couldn't open the key we just enumerated.  Oh well, move on
                // to the next one.
                //
                continue;
            }

            if (!(pIDriver = (PIDRIVER)LocalAlloc(LPTR, sizeof(IDRIVER))))
            {
                //
                // Not enough memory!  Abort the whole thing.
                //
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto CloseInstanceAndContinue;
            }

            //
            // Retrieve the description and driver filename from this key.
            //
            cbRegDataSize = sizeof(pIDriver->szDesc);
            if ((RegQueryValueEx(hTypeInstanceKey,
                                 gszDescriptionValue,
                                 NULL,
                                 &RegDataType,
                                 (LPBYTE)pIDriver->szDesc,
                                 &cbRegDataSize) != ERROR_SUCCESS)
                || (RegDataType != REG_SZ) || !cbRegDataSize)
            {
                LocalFree((HANDLE)pIDriver);
                goto CloseInstanceAndContinue;
            }

            wcsncpy(pIDriver->szSection,
                    wcsstr(pIDriver->szDesc, TEXT("MCI")) ? szMCI : szDrivers,
                    sizeof(pIDriver->szSection) / sizeof(TCHAR)
                   );

            cbRegDataSize = sizeof(pIDriver->szFile);
            if ((RegQueryValueEx(hTypeInstanceKey,
                                 gszDriverValue,
                                 NULL,
                                 &RegDataType,
                                 (LPBYTE)pIDriver->szFile,
                                 &cbRegDataSize) != ERROR_SUCCESS)
                || (RegDataType != REG_SZ) || !cbRegDataSize)
            {
                LocalFree((HANDLE)pIDriver);
                goto CloseInstanceAndContinue;
            }

            pIDriver->KernelDriver = IsFileKernelDriver(pIDriver->szFile);

            //
            // Find a valid alias for this device (eg Wave2).  This is
            // used as the key in the [MCI] or [Drivers32] section.
            //
            wcsncpy(pIDriver->szAlias, szType, sizeof(pIDriver->szAlias) / sizeof(TCHAR));

            if (!GetValidAlias(pIDriver->szAlias, pIDriver->szSection))
            {
                //
                // Exceeded the maximum--but can't tell the user.  We can't bring up a dialog
                // in the services.exe process
                //
                bNoMoreAliases = TRUE;
                LocalFree((HANDLE)pIDriver);
                goto CloseInstanceAndContinue;
            }

            //
            // Fill in the Unicode fields from the ANSI ones.
            //
            wcscpy(pIDriver->wszSection, pIDriver->szSection);
            wcscpy(pIDriver->wszAlias,   pIDriver->szAlias);
            wcscpy(pIDriver->wszFile,    pIDriver->szFile);

            //
            // We must write the alias out now, because we may need to generate
            // other aliases for this same type, and we can't generate a unique
            // alias unless all existing aliases are present in the relevant
            // registry key.
            //
            WritePrivateProfileString(pIDriver->szSection,
                                      pIDriver->szAlias,
                                      pIDriver->szFile,
                                      szSysIni
                                     );

            //
            // We also must write the alias out to the key we're currently in (under
            // the device's software key), because during uninstall, we need to be
            // able to figure out what devices get removed.
            //
            RegSetValueEx(hTypeInstanceKey,
                          szAliasStringToUse,
                          0,
                          REG_SZ,
                          (PBYTE)(pIDriver->szAlias),
                          (wcslen(pIDriver->szAlias)*sizeof(TCHAR)) + sizeof(TCHAR)
                         );

            //
            // Add this new IDriver node to our linked list.  The list is sorted by
            // driver filename, and this node should be inserted at the end of the
            // the group of nodes that have the same driver filename.
            //
            InsertNewIDriverNodeInList(&IDriverList, pIDriver);

            CloseInstanceAndContinue:

            RegCloseKey(hTypeInstanceKey);
        }

        RegCloseKey(hKey);
    }

    if ((Err == NO_ERROR) && !IDriverList)
    {
        //  We actually don't want to present the ugly "Data is invalid" error if we ran out of aliases
        if (bNoMoreAliases)
        {
            DestroyIDriverNodeList(IDriverList, TRUE, FALSE);
            goto clean0;
        }
        else
        {
            //
            // We didn't find anything to install!
            //
            Err = ERROR_INVALID_DATA;
        }
    }

    if (Err != NO_ERROR)
    {
        //
        // Clean up anything we put in the multimedia sections of the registry.
        //
        DestroyIDriverNodeList(IDriverList, TRUE, FALSE);
        goto clean0;
    }

    //
    // If we get to here, then we've successfully built up a list of all driver entries
    // we need to install.  Now, traverse the list, and install each one.
    //
    CurrentFilename = NULL;
    *CharBuffer = TEXT('\0');        // use this character buffer to contain (empty) parameter string.
    pIDriver = IDriverList;
    pPrevIDriver = NULL;

    while (pIDriver)
    {
        if (!CurrentFilename || _wcsicmp(CurrentFilename, pIDriver->szFile))
        {
            //
            // This is the first entry we've encountered for this driver.  We need
            // to call the driver to see if it can be configured, and configure it
            // if it can be.
            //
            if (SelectInstalled(hWnd, pIDriver, CharBuffer, DeviceInfoSet, DeviceInfoData))
            {
                //
                // Move this IDriver node to our list of clean-up items.  This is used in
                // case we hit an error with some other driver, and we need to notify this
                // driver that even though it was successful, someone else messed up and
                // complete removal of the device must occur.
                //
                if (pPrevIDriver)
                {
                    pPrevIDriver->related = pIDriver->related;
                }
                else
                {
                    IDriverList = pIDriver->related;
                }
                pIDriver->related = IDriverListToCleanUp;
                IDriverListToCleanUp = pIDriver;
            }
            else
            {
                //
                // Error talking to driver
                //
                Err = GetLastError();
                goto clean1;
            }

#if 0       // We don't need this piece of code in the Plug&Play install case.

            /*
             *  for displaying the driver desc. in the restart mesg
             */
            if (!bRelated || pIDriver->bRelated)
            {
                wcsncpy(szRestartDrv, pIDriver->szDesc, ARRAYSIZE(szRestartDrv));
                szRestartDrv[ARRAYSIZE(szRestartDrv)-1] = TEXT('\0'); // Make sure there is a NULL terminator
            }
#endif

            //
            // We need to write out the driver description to the
            // control.ini section [Userinstallable.drivers]
            // so we can differentiate between user and system drivers
            //
            // This is tested by the function UserInstalled when
            // the user tries to remove a driver and merely
            // affects which message the user gets when being
            // asked to confirm removal (non user-installed drivers
            // are described as being necessary to the system).
            //
            WritePrivateProfileString(szUserDrivers,
                                      pIDriver->szAlias,
                                      pIDriver->szFile,
                                      szControlIni
                                     );

            //
            // Update [related.desc] section of control.ini :
            //
            // ALIAS=driver name list
            //
            // When the driver whose alias is ALIAS is removed
            // the drivers in the name list will also be removed.
            // These were the drivers in the related drivers list
            // when the driver is installed.
            //
            WritePrivateProfileString(szRelatedDesc,
                                      pIDriver->szAlias,
                                      pIDriver->szRemove,
                                      szControlIni
                                     );

            //
            // Cache the description string in control.ini in the
            // drivers description section.
            //
            // The key is the driver file name + extension.
            //
            WritePrivateProfileString(szDriversDesc,
                                      pIDriver->szFile,
                                      pIDriver->szDesc,
                                      szControlIni
                                     );

#ifdef DOBOOT // We don't do the boot section on NT

            if (bInstallBootLine)
            {
                szTemp[MAXSTR];

                GetPrivateProfileString(szBoot,
                                        szDrivers,
                                        szTemp,
                                        szTemp,
                                        sizeof(szTemp) / sizeof(TCHAR),
                                        szSysIni);
                wcscat(szTemp, TEXT(" "));
                wcscat(szTemp, pIDriver->szAlias);
                WritePrivateProfileString(szBoot,
                                          szDrivers,
                                          szTemp,
                                          szSysIni);
                bInstallBootLine = FALSE;
            }
#endif // DOBOOT

            //
            // Update our "CurrentFilename" pointer, so that we'll know when we
            // move from one driver filename to another.
            //
            CurrentFilename = pIDriver->szFile;

            //
            // Move on to the next IDriver node IN THE ORIGINAL LIST.  We can't simply
            // move on the 'related' pointer in our node anymore, since we moved it
            // into our clean-up list.
            //
            if (pPrevIDriver)
            {
                pIDriver = pPrevIDriver->related;
            }
            else
            {
                pIDriver = IDriverList;
            }

        }
        else
        {
            //
            // We've already configured this driver.  Leave it in its original list,
            // and move on to the next node.
            //
            pPrevIDriver = pIDriver;
            pIDriver = pIDriver->related;
        }
    }

    clean1:

    DestroyIDriverNodeList(IDriverListToCleanUp, (Err != NO_ERROR), TRUE);
    DestroyIDriverNodeList(IDriverList, (Err != NO_ERROR), FALSE);

    clean0:

    RegCloseKey(hDriversKey);

    return Err;
}


void
    InsertNewIDriverNodeInList(
                              IN OUT PIDRIVER *IDriverList,
                              IN     PIDRIVER  NewIDriverNode
                              )
/*++

Routine Description:

    This routine inserts a new IDriver node into the specified linked list of IDriver
    nodes.  The list is sorted by driver filename, and this node will be placed after
    any existing nodes having this same driver filename.

Arguments:

    IDriverList - Supplies the address of the variable that points to the head of the
        linked list.  If the new node is inserted at the head of the list, this variable
        will be updated upon return to reflect the new head of the list.

    NewIDriverNode - Supplies the address of the new driver node to be inserted into the
        list.

Return Value:

    None.

--*/
{
    PIDRIVER CurNode, PrevNode;

    for (CurNode = *IDriverList, PrevNode = NULL;
        CurNode;
        PrevNode = CurNode, CurNode = CurNode->related)
    {
        if (_wcsicmp(CurNode->szFile, NewIDriverNode->szFile) > 0)
        {
            break;
        }
    }

    //
    // Insert the new IDriver node in front of the current one.
    //
    NewIDriverNode->related = CurNode;
    if (PrevNode)
    {
        PrevNode->related = NewIDriverNode;
    }
    else
    {
        *IDriverList = NewIDriverNode;
    }
}


void
    DestroyIDriverNodeList(
                          IN PIDRIVER IDriverList,
                          IN BOOL     CleanRegistryValues,
                          IN BOOL     NotifyDriverOfCleanUp
                          )
/*++

Routine Description:

    This routine frees all memory associated with the nodes in the specified IDriver
    linked list.  It also optionally cleans up any modifications that were previously
    made as a result of an attempted install.

Arguments:

    IDriverList - Points to the head of the linked list of IDriver nodes.

    CleanRegistryValues - If TRUE, then the multimedia registry values previously
        created (e.g., Drivers32 aliases) will be deleted.

    NotifyDriverOfCleanUp - If TRUE, then the driver will be notified of its removal.
        This only applies to non-kernel (i.e., installable) drivers, and this flag is
        ignored if CleanRegistryValues is FALSE.

Return Value:

    None.

--*/
{
    PIDRIVER NextNode;
    HANDLE hDriver;

    while (IDriverList)
    {
        NextNode = IDriverList->related;
        if (CleanRegistryValues)
        {
            if (NotifyDriverOfCleanUp && !IDriverList->KernelDriver)
            {
                if (hDriver = OpenDriver(IDriverList->wszAlias, IDriverList->wszSection, 0L))
                {
                    SendDriverMessage(hDriver, DRV_REMOVE, 0L, 0L);
                    CloseDriver(hDriver, 0L, 0L);
                }
            }
            WritePrivateProfileString(IDriverList->szSection,
                                      IDriverList->szAlias,
                                      NULL,
                                      szSysIni
                                     );

            WriteProfileString(IDriverList->szFile, IDriverList->szAlias, NULL);
        }
        LocalFree((HANDLE)IDriverList);
        IDriverList = NextNode;
    }
}


BOOL DriverNodeSupportsNt(IN HDEVINFO         DeviceInfoSet,
                          IN PSP_DEVINFO_DATA DeviceInfoData,
                          IN PSP_DRVINFO_DATA DriverInfoData
                         )
/*++

Routine Description:

    This routine determines whether the driver node specified is capable of
    installing on Windows NT (as opposed to being a Win95-only driver node).
    This determination is made based upon whether or not there is a corresponding
    service install section for this device install section.

Return Value:

    If the driver node supports Windows NT, the return value is TRUE, otherwise
    it is FALSE.

--*/
{
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF hInf;
    DWORD Err;
    TCHAR ActualSectionName[255];
    DWORD ActualSectionNameLen;
    LONG LineCount;
    CONST TCHAR szServiceInstallSuffix[] = TEXT(".") INFSTR_SUBKEY_SERVICES;

    // Get name and section to install from
    DriverInfoDetailData.cbSize = sizeof(DriverInfoDetailData);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    DriverInfoData,
                                    &DriverInfoDetailData,
                                    sizeof(DriverInfoDetailData),
                                    NULL) &&
        ((Err = GetLastError()) != ERROR_INSUFFICIENT_BUFFER))
    {
        return FALSE;
    }

    //
    // Open the associated INF file.
    //
    if ((hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName, NULL, INF_STYLE_WIN4, NULL)) == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    //
    // Retrieve the actual name of the install section to be used for this
    // driver node.
    //
    SetupDiGetActualSectionToInstall(hInf,
                                     DriverInfoDetailData.SectionName,
                                     ActualSectionName,
                                     sizeof(ActualSectionName) / sizeof(TCHAR),
                                     &ActualSectionNameLen,
                                     NULL
                                    );

    //
    // Generate the service install section name, and see if it exists.
    //
    CopyMemory(&(ActualSectionName[ActualSectionNameLen - 1]),
               szServiceInstallSuffix,
               sizeof(szServiceInstallSuffix)
              );

    LineCount = SetupGetLineCount(hInf, ActualSectionName);

    SetupCloseInfFile(hInf);

    return (LineCount != -1);
}

// Go through the list of drivers and try to keep from installing or displaying any non-NT drivers
// Warning: If you call this function with DeviceInfoData NULL, it will have to enumerate and open
// every media inf there is, which may take awhile.
BOOL FilterOutNonNTInfs(IN HDEVINFO         DeviceInfoSet,
                        IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
                        DWORD DriverType
                       )
{
    DWORD MemberIndex;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;

    MemberIndex = 0;
    DriverInfoData.cbSize = sizeof(DriverInfoData);
    while (SetupDiEnumDriverInfo(DeviceInfoSet,DeviceInfoData,DriverType,MemberIndex,&DriverInfoData))
    {
        if (!DriverNodeSupportsNt(DeviceInfoSet, DeviceInfoData, &DriverInfoData))
        {
            // If driver doesn't support NT, try to exclude from list & max out rank
            DriverInstallParams.cbSize=sizeof(DriverInstallParams);
            if (SetupDiGetDriverInstallParams(DeviceInfoSet, DeviceInfoData, &DriverInfoData, &DriverInstallParams))
            {
                DriverInstallParams.Flags |= DNF_EXCLUDEFROMLIST | DNF_BAD_DRIVER;
                DriverInstallParams.Rank = 10000;
                SetupDiSetDriverInstallParams(DeviceInfoSet, DeviceInfoData, &DriverInfoData, &DriverInstallParams);
            }
        }
        MemberIndex++;
    }

    return TRUE;
}

DWORD Media_SelectBestCompatDrv(IN HDEVINFO         DeviceInfoSet,
                                IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                               )
{
    DWORD DriverType = (DeviceInfoData ? SPDIT_COMPATDRIVER : SPDIT_CLASSDRIVER);

    FilterOutNonNTInfs(DeviceInfoSet, DeviceInfoData, DriverType);
    return ERROR_DI_DO_DEFAULT;
}

DWORD Media_AllowInstall(IN HDEVINFO         DeviceInfoSet,
                         IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                        )
{
    DWORD Err;
    SP_DRVINFO_DATA DriverInfoData;

    // Verify that the driver node selected for this device supports NT.
    // It will probably be a pretty common scenario for users to try to
    // give us their Win95 INFs.
    DriverInfoData.cbSize = sizeof(DriverInfoData);
    if (!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData))
    {
        // NULL driver?
        return ERROR_DI_DO_DEFAULT;
    }

    if (!DriverNodeSupportsNt(DeviceInfoSet,
                              DeviceInfoData,
                              &DriverInfoData))
    {
        dlog("Media_AllowInstall: Not an NT driver");
        return ERROR_DI_DONT_INSTALL;
    }

    return ERROR_DI_DO_DEFAULT;
}

DWORD Media_InstallDevice(IN HDEVINFO         DeviceInfoSet,
                          IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                         )
{
    DWORD Err, ConfigFlags;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    HWND hWnd;
    SC_HANDLE schScm;

    //
    // if we are in setup then let's ensure the
    // SetupPreferredAudioDevicesCount value is in the driver registry for
    // devices that already have MME drivers installed.  This is so audiosrv's
    // MigrateAutoSetupPreferredAudio logic does not interpret this as a new
    // device installation.
    //
    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams))
    {
    	if (DI_FLAGSEX_IN_SYSTEM_SETUP & DeviceInstallParams.FlagsEx)
    	{
    	   HKEY hkDriver;
    	   hkDriver = SetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE);
    	   if (INVALID_HANDLE_VALUE != hkDriver)
    	   {
    	   	HKEY hkMmeDrivers;
    	        LONG l;
    	        l = RegOpenKeyEx(hkDriver, TEXT("Drivers"), 0, KEY_QUERY_VALUE, &hkMmeDrivers);
    	        if (ERROR_FILE_NOT_FOUND != l)
    	        {
        	    l = RegQueryValueEx(hkDriver, TEXT("SetupPreferredAudioDevicesCount"), NULL, NULL, NULL, NULL);
        	    if (ERROR_FILE_NOT_FOUND == l)
        	    {
        	        DWORD dw = 0;
        	        RegSetValueEx(hkDriver, TEXT("SetupPreferredAudioDevicesCount"), 0, REG_DWORD, (PBYTE)&dw, sizeof(dw));
        	    }
        	    RegCloseKey(hkMmeDrivers);
    	        }
    	   	RegCloseKey(hkDriver);
    	   }
    	}
    }

    // First remove any driver that was already installed
    Media_RemoveDevice(DeviceInfoSet,DeviceInfoData);

    DriverInfoData.cbSize = sizeof(DriverInfoData);
    if (!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData))
    {
        //
        // The NULL driver is to be installed for this device.  We don't need to
        // do anything special in that case.
        //
        dlog("Media_InstallDevice: Null driver");
        return ERROR_DI_DO_DEFAULT;
    }

    dlog("Media_InstallDevice: Calling SetupDiInstallDevice");
    if (!SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData))
    {

        Err = GetLastError();

        dlog("Media_InstallDevice: SetupDiInstallDevice failed");
        //
        // In certain circumstances, we have INFs that control some of the functions on the
        // card, but not all (e.g., our sndblst driver controls wave, midi, aux, mixer but
        // not the fancy 3D stuff).  In order to give the user a descriptive name that lets
        // them know what we're trying to install, the INF contains driver nodes for devices
        // it can't support.  If this is the case, then SetupDiInstallDevice will fail with
        // ERROR_NO_ASSOCIATED_SERVICE.  If this happens, we want to clear the
        // CONFIGFLAG_REINSTALL that got set, so we don't keep hounding the user about this.
        // While we're at it, we go ahead and store the driver node's device description as
        // the device instance's description, so that we know what the device instances are
        // later on (for diagnostic purposes, mainly).
        //
        if (Err == ERROR_NO_ASSOCIATED_SERVICE)
        {

            // Clear reinstall flag
            if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_CONFIGFLAGS,
                                                 NULL,
                                                 (PBYTE)&ConfigFlags,
                                                 sizeof(ConfigFlags),
                                                 NULL))
            {
                ConfigFlags &= ~CONFIGFLAG_REINSTALL;
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_CONFIGFLAGS,
                                                 (PBYTE)&ConfigFlags,
                                                 sizeof(ConfigFlags)
                                                );
            }

            // Save description of device
            SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_DEVICEDESC,
                                             (PBYTE)DriverInfoData.Description,
                                             (lstrlen(DriverInfoData.Description) + 1) * sizeof(TCHAR)
                                            );
        }

        goto Media_InstallDevice_exit;
    }

    //
    // Get the device install parameters, so we'll know what parent window to use for any
    // UI that occurs during configuration of this device.
    //
    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams))
    {
        hWnd = DeviceInstallParams.hwndParent;
    }
    else
    {
        hWnd = NULL;
    }

    //
    // The INF will have created a "Drivers" subkey under the device's software key.
    // This tree, in turn, contains subtrees for each type of driver (aux, midi, etc.)
    // applicable for this device.  We must now traverse this tree, and create entries
    // in Drivers32 for each function alias.
    //
    dlog("Media_InstallDevice: Calling InstallDriversForPnPDevice");
    if ((Err = InstallDriversForPnPDevice(hWnd, DeviceInfoSet, DeviceInfoData)) != NO_ERROR)
    {
        //
        // The device is in an unknown state.  Disable it by setting the
        // CONFIGFLAG_DISABLED config flag, and mark it as needing a reinstall.
        //
        if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                              DeviceInfoData,
                                              SPDRP_CONFIGFLAGS,
                                              NULL,
                                              (PBYTE)&ConfigFlags,
                                              sizeof(ConfigFlags),
                                              NULL))
        {
            ConfigFlags = 0;
        }

        ConfigFlags |= (CONFIGFLAG_DISABLED | CONFIGFLAG_REINSTALL);

        SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_CONFIGFLAGS,
                                         (PBYTE)&ConfigFlags,
                                         sizeof(ConfigFlags)
                                        );

        //
        // Delete the Driver= entry from the Dev Reg Key and delete the
        // DrvRegKey.
        //
        SetupDiDeleteDevRegKey(DeviceInfoSet,
                               DeviceInfoData,
                               DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGGENERAL,
                               0,
                               DIREG_DRV
                              );

        SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_DRIVER, NULL, 0);

        //
        // Also, delete the service property, so we'll know this device instance needs to be
        // cleaned up if we later reboot and don't find the device.
        //
        SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_SERVICE, NULL, 0);

        goto Media_InstallDevice_exit;
    }
    
    //
    // Attempt to start the AudioSrv Win32 service
    //
    schScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (schScm) {
        SC_HANDLE schAudioSrv;
        schAudioSrv = OpenService(schScm, TEXT("AudioSrv"), SERVICE_QUERY_STATUS | SERVICE_START);
        if (schAudioSrv) {
            SERVICE_STATUS AudioSrvStatus;
            if (QueryServiceStatus(schAudioSrv, &AudioSrvStatus)) {
                if (SERVICE_STOPPED == AudioSrvStatus.dwCurrentState) {
                    if (!StartService(schAudioSrv, 0, NULL)) {
                        dlog("Media_InstallDevice: StartService on AudioSrv failed");
                    }
                }
            } else {
                dlog("Media_InstallDevice: QueryServiceStatus on AudioSrv failed");
            }
            CloseServiceHandle(schAudioSrv);
        } else {
            dlog("Media_InstallDevice: OpenService on AudioSrv failed");
        }
        CloseServiceHandle(schScm);
    } else {
        dlog("Media_InstallDevice: OpenSCManager failed");
    }

    Err = NO_ERROR;

    Media_InstallDevice_exit:

    dlog("Media_InstallDevice: Returning");
    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\mmcpl.c ===
/*==========================================================================*/
//
//  mmcpl.c
//
//  Copyright (C) 1993-1994 Microsoft Corporation.  All Rights Reserved.
//
//    06/94    -Created- VijR
//
/*==========================================================================*/

#pragma warning( disable: 4103)
#include "mmcpl.h"
#include <cpl.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <infstr.h>
#include <devguid.h>

#include "draw.h"
#include "utils.h"
#include "drivers.h"
#include "sulib.h"
#include <tchar.h>
#include <hwtab.h>
#include "debug.h"
#include "start.h"

#ifndef cchRESOURCE
    #define cchRESOURCE 256
#endif

/*
 ***************************************************************
 * Globals
 ***************************************************************
 */
HINSTANCE   ghInstance  = NULL;
BOOL        gfNukeExt   = -1;
HWND        ghwndMsgBox = NULL;
HWND        ghwndAdvProp = NULL;
BOOL        gfVoiceTab  = FALSE;
BOOL        gfRedisplayCPL = FALSE;

#ifdef FIX_BUG_15451
static TCHAR cszFORKLINE[] = TEXT("RUNDLL32.EXE MMSYS.CPL,ShowDriverSettingsAfterFork %s");
#endif // FIX_BUG_15451

SZCODE cszAUDIO[] = AUDIO;
SZCODE cszVIDEO[] = VIDEO;
SZCODE cszCDAUDIO[] = CDAUDIO;
SZCODE cszMIDI[] = MIDI;
SZCODE cszVOICE[]    = VOICE;
SZCODE cszVOLUME[]    = VOLUME;

/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */

typedef struct _ExtPropSheetCBParam //Callback Parameter
{
    HTREEITEM hti;
    LPPROPSHEETHEADER    ppsh;
    LPARAM lParam1;    //PIRESOURCE/PINSTRUMENT etc. depending on node. (OR) Simple propsheet class
    LPARAM lParam2; //hwndTree (OR) Simple propsheet name
} EXTPROPSHEETCBPARAM, *PEXTPROPSHEETCBPARAM;

typedef struct _MBInfo
{
    LPTSTR szTitle;
    LPTSTR szMsg;
    UINT  uStyle;
} MBINFO, *PMBINFO;


/*
 ***************************************************************
 * Defines
 ***************************************************************
 */

#define    MAXPAGES    8    // MAX number of sheets allowed
#define    MAXMODULES    32    // MAX number of external modules allowed
#define    MAXCLASSSIZE    64

#define cComma    TEXT(',')
#define PROPTABSIZE 13

#define GetString(_str,_id,_hi)  LoadString (_hi, _id, _str, sizeof(_str)/sizeof(TCHAR))

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
static SZCODE    aszSimpleProperties[] = REGSTR_PATH_MEDIARESOURCES TEXT("\\MediaExtensions\\shellx\\SimpleProperties\\");
static SZCODE    aszShellName[]    = TEXT("ShellName");

static UINT     g_cRefCnt;            // keeps track of the ref count
static int      g_cProcesses        = 0;
static int      g_nStartPage        = 0;

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */
INT_PTR CALLBACK AudioDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK VideoDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK CDDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ACMDlg(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK SoundDlg(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK VolumeDlg(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AddDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AdvDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK HardwareDlgProc(HWND hdlg, UINT uMsg, WPARAM wp, LPARAM lp);
INT_PTR CALLBACK VoiceDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK StartDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RebootDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
//INT_PTR CALLBACK EffectDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);



//
// This is the dialog procedure for the "Hardware" page.
//


INT_PTR CALLBACK HardwareDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    static HWND s_hwndHW = NULL;

    switch (uMessage)
    {
        case WM_NOTIFY:
        {
            NMHDR * pnmhdr = (NMHDR *) lParam;
            int code = pnmhdr->code;

            switch (code)
            {
                case HWN_FILTERITEM:
                {
                    NMHWTAB *pnmht = (NMHWTAB *) lParam;
                    BOOL fFilter = FALSE;

                    if (!pnmht->fHidden)    // Let's not bother looking at devices already hidden
                    {
                        fFilter = FALSE;
                    }

                    return(TRUE);
                }
                break;

                case HWN_SELECTIONCHANGED:
                {
                    NMHWTAB *pnmht = (NMHWTAB *) lParam;

                    if (pnmht)
                    {
                        if (pnmht->pdinf)
                        {
                            if (IsEqualGUID(&(pnmht->pdinf->ClassGuid),&GUID_DEVCLASS_CDROM))
                            {
                                SetWindowText(s_hwndHW, TEXT("hh.exe ms-its:tshoot.chm::/hdw_drives.htm"));
                            }
                            else
                            {
                                SetWindowText(s_hwndHW, TEXT("hh.exe ms-its:tshoot.chm::/tssound.htm"));
                            }
                        }
                    }
                }
                break;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            GUID guidClass[2];

            guidClass[0] = GUID_DEVCLASS_CDROM;
            guidClass[1] = GUID_DEVCLASS_MEDIA;

            s_hwndHW = DeviceCreateHardwarePageEx(hDlg, (const GUID *) &guidClass, 2, HWTAB_LARGELIST );

            if (s_hwndHW)
            {
                SetWindowText(s_hwndHW, TEXT("hh.exe ms-its:tshoot.chm::/tssound.htm"));
            }
            else
            {
                DestroyWindow(hDlg); // catastrophic failure
            }
        }
        return FALSE;
    }

    return FALSE;
}



INT_PTR CALLBACK CD_HardwareDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            HWND hwndHW;

            hwndHW = DeviceCreateHardwarePageEx(hDlg, &GUID_DEVCLASS_CDROM, 1, HWTAB_SMALLLIST);

            if (hwndHW)
            {
                SetWindowText(hwndHW, TEXT("hh.exe ms-its:tshoot.chm::/hdw_multi.htm"));
            }
            else
            {
                DestroyWindow(hDlg); // catastrophic failure
            }
        }
        return FALSE;
    }

    return FALSE;
}



/*
 ***************************************************************
 ***************************************************************
 */

INT_PTR FAR PASCAL mmse_MessageBoxProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg)
    {
    case WM_INITDIALOG:
        {
            PMBINFO pmbInfo = (PMBINFO)lParam;
            UINT uStyle = pmbInfo->uStyle;

            SetWindowText(hDlg, pmbInfo->szTitle);
            SetWindowText(GetDlgItem(hDlg, MMSE_TEXT), pmbInfo->szMsg);
            if (IsFlagClear(uStyle, MMSE_OK))
                DestroyWindow(GetDlgItem(hDlg, MMSE_OK));
            if (IsFlagClear(uStyle, MMSE_YES))
                DestroyWindow(GetDlgItem(hDlg, MMSE_YES));
            if (IsFlagClear(uStyle, MMSE_NO))
                DestroyWindow(GetDlgItem(hDlg, MMSE_NO));
            ghwndMsgBox = hDlg;
            break;
        }
    case WM_DESTROY:
        ghwndMsgBox = NULL;
        break;
    case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case MMSE_YES:
                EndDialog(hDlg, MMSE_YES);
                break;
            case MMSE_NO:
                EndDialog(hDlg, MMSE_NO);
                break;
            case MMSE_OK:
                EndDialog(hDlg, MMSE_OK);
                break;
            }
            break;
        }
    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR mmse_MessageBox(HWND hwndP,  LPTSTR szMsg, LPTSTR szTitle, UINT uStyle)
{
    MBINFO mbInfo;

    mbInfo.szMsg = szMsg;
    mbInfo.szTitle = szTitle;
    mbInfo.uStyle = uStyle;

    return DialogBoxParam(ghInstance, MAKEINTRESOURCE(DLG_MESSAGE_BOX), hwndP, mmse_MessageBoxProc, (LPARAM)&mbInfo);
}

/*==========================================================================*/
int StrByteLen(LPTSTR sz)
{
    LPTSTR psz;

    if (!sz)
        return 0;
    for (psz = sz; *psz; psz = CharNext(psz))
        ;
    return (int)(psz - sz);
}

static void NukeExt(LPTSTR sz)
{
    int len;

    len = StrByteLen(sz);

    if (len > 4 && sz[len-4] == TEXT('.'))
        sz[len-4] = 0;
}

static LPTSTR NukePath(LPTSTR sz)
{
    LPTSTR pTmp, pSlash;

    for (pSlash = pTmp = sz; *pTmp; pTmp = CharNext(pTmp))
    {
        if (*pTmp == TEXT('\\'))
            pSlash = pTmp;
    }
    return (pSlash == sz ? pSlash : pSlash+1);
}

void    CheckNukeExtOption(LPTSTR sz)
{
    SHFILEINFO sfi;

    SHGetFileInfo(sz, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME);
    if (lstrcmpi((LPTSTR)(sfi.szDisplayName+lstrlen(sfi.szDisplayName)-4), cszWavExt))
        gfNukeExt = TRUE;
    else
        gfNukeExt = FALSE;
}

LPTSTR PASCAL NiceName(LPTSTR sz, BOOL fNukePath)
{
    SHFILEINFO sfi;

    if (gfNukeExt == -1)
        CheckNukeExtOption(sz);

    if (!SHGetFileInfo(sz, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME))
        return sz;

    if (fNukePath)
    {
        lstrcpy(sz, sfi.szDisplayName);
    }
    else
    {
        LPTSTR lpszFileName;

        lpszFileName = NukePath(sz);
        lstrcpy(lpszFileName, sfi.szDisplayName);
        if (lpszFileName != sz)
            CharUpperBuff(sz, 1);
    }
    return sz;
}



/*
 ***************************************************************
 * ErrorBox
 *
 * Description:
 *        Brings up error Dialog displaying error
 *
 * Parameters:
 *        HWND    hDlg  - Window handle
 *        int        iResource    - id of the resource to be loaded
 *        LPTSTR    lpszDesc - The string to be inserted in the resource string
 *
 * Returns:            BOOL
 *
 ***************************************************************
 */
BOOL PASCAL ErrorBox(HWND hDlg, int iResource, LPTSTR lpszDesc)
{
    TCHAR szBuf[MAXMSGLEN];
    TCHAR szTitle[MAXSTR];
    TCHAR szResource[MAXMSGLEN];

    LoadString(ghInstance, iResource, szResource, MAXSTR);
    LoadString(ghInstance, IDS_ERROR, szTitle, MAXSTR);
    wsprintf(szBuf, szResource, lpszDesc);
    MessageBox(hDlg, szBuf, szTitle, MB_APPLMODAL | MB_OK |MB_ICONSTOP);
    return TRUE;
}

int PASCAL DisplayMessage(HWND hDlg, int iResTitle, int iResMsg, UINT uStyle)
{
    TCHAR szBuf[MAXMSGLEN];
    TCHAR szTitle[MAXSTR];
    UINT uAddStyle = MB_APPLMODAL;

    if (!LoadString(ghInstance, iResTitle, szTitle, MAXSTR))
        return FALSE;
    if (!LoadString(ghInstance, iResMsg, szBuf, MAXSTR))
        return FALSE;
    if (uStyle & MB_OK)
        uAddStyle |= MB_ICONASTERISK;
    else
        uAddStyle |= MB_ICONQUESTION;
    return MessageBox(hDlg, szBuf, szTitle,  uStyle | uAddStyle);
}


//Adds spaces around Tab Names to make them all approx. same size.
STATIC void PadWithSpaces(LPTSTR szName, LPTSTR szPaddedName)
{
    static SZCODE cszFmt[] = TEXT("%s%s%s");
    TCHAR szPad[8];
    int i;

    i = PROPTABSIZE - lstrlen(szName);

    i = (i <= 0) ? 0 : i/2;
    for (szPad[i] = TEXT('\0');i; i--)
        szPad[i-1] =  TEXT(' ');
    wsprintf(szPaddedName, cszFmt, szPad, szName, szPad);
}

/*==========================================================================*/
UINT CALLBACK  CallbackPage(
                           HWND        hwnd,
                           UINT        uMsg,
                           LPPROPSHEETPAGE    ppsp)
{
    if (uMsg == PSPCB_RELEASE)
    {
        DPF_T("* RelasePage %s *", (LPTSTR)ppsp->pszTitle);
    }
    return 1;
}

/*==========================================================================*/
static BOOL PASCAL NEAR AddPage(
                               LPPROPSHEETHEADER    ppsh,
                               LPCTSTR            pszTitle,
                               DLGPROC            pfnDialog,
                               UINT            idTemplate,
                               LPARAM            lParam)
{
    if (ppsh->nPages < MAXPAGES)
    {

        if (pfnDialog)
        {
            PROPSHEETPAGE    psp;
            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USECALLBACK;
            psp.hInstance = ghInstance;
            psp.pszTemplate = MAKEINTRESOURCE(idTemplate);
            psp.pszIcon = NULL;
            psp.pszTitle = pszTitle;
            psp.pfnDlgProc = pfnDialog;
            psp.lParam = (LPARAM)lParam;
            psp.pfnCallback = CallbackPage;
            psp.pcRefParent = NULL;
            if (ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp))
            {
                ppsh->nPages++;
                return TRUE;
            }
        }
    }
    return FALSE;
}

/*==========================================================================*/
BOOL CALLBACK MMExtPropSheetCallback(DWORD dwFunc, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwInstance)
{
    PEXTPROPSHEETCBPARAM pcbp = (PEXTPROPSHEETCBPARAM)dwInstance;

    if (!pcbp && dwFunc != MM_EPS_BLIND_TREECHANGE)
        return FALSE;
    switch (dwFunc)
    {
    case MM_EPS_GETNODEDESC:
        {
            if (!dwParam1)
                return FALSE;
            if (pcbp->hti == NULL)
                lstrcpy((LPTSTR)dwParam1, (LPTSTR)pcbp->lParam2);
            else
            {
                GetTreeItemNodeDesc ((LPTSTR)dwParam1,
                                     (PIRESOURCE)pcbp->lParam1);
            }
            break;
        }
    case MM_EPS_GETNODEID:
        {
            if (!dwParam1)
                return FALSE;
            if (pcbp->hti == NULL)
                lstrcpy((LPTSTR)dwParam1, (LPTSTR)pcbp->lParam2);
            else
            {
                GetTreeItemNodeID ((LPTSTR)dwParam1,
                                   (PIRESOURCE)pcbp->lParam1);
            }
            break;
        }
    case MM_EPS_ADDSHEET:
        {
            HPROPSHEETPAGE    hpsp = (HPROPSHEETPAGE)dwParam1;

            if (hpsp && (pcbp->ppsh->nPages < MAXPAGES))
            {
                pcbp->ppsh->phpage[pcbp->ppsh->nPages++] = hpsp;
                return TRUE;
            }
            return FALSE;
        }
    case MM_EPS_TREECHANGE:
        {
            RefreshAdvDlgTree ();
            break;
        }
    case MM_EPS_BLIND_TREECHANGE:
        {
            RefreshAdvDlgTree ();
            break;
        }
    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK SpeechDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

/*==========================================================================*/
static BOOL PASCAL NEAR AddSpeechPage(LPPROPSHEETHEADER    ppsh)
{
    TCHAR    aszTitleRes[128];
    TCHAR     szTmp[32];

    LoadString(ghInstance, IDS_SPEECH_NAME, aszTitleRes, sizeof(aszTitleRes)/sizeof(TCHAR));
    PadWithSpaces((LPTSTR)aszTitleRes, (LPTSTR)szTmp);
    return AddPage(ppsh, szTmp, SpeechDlgProc, IDD_SPEECH, (LPARAM)NULL);
}

/*==========================================================================*/
static BOOL PASCAL NEAR AddAdvancedPage(
                                       LPPROPSHEETHEADER    ppsh)
{
    TCHAR    aszTitleRes[128];
    TCHAR     szTmp[32];

    LoadString(ghInstance, IDS_ADVANCED, aszTitleRes, sizeof(aszTitleRes)/sizeof(TCHAR));
    PadWithSpaces((LPTSTR)aszTitleRes, (LPTSTR)szTmp);
    return AddPage(ppsh, szTmp, AdvDlg, ADVDLG, (LPARAM)NULL);
}

/*==========================================================================*/
static BOOL PASCAL NEAR AddStartPage(
                                       LPPROPSHEETHEADER    ppsh)
{
    TCHAR    aszTitleRes[128];
    TCHAR    szTmp[32];

    LoadString(ghInstance, IDS_START, aszTitleRes, sizeof(aszTitleRes)/sizeof(TCHAR));
    PadWithSpaces((LPTSTR)aszTitleRes, (LPTSTR)szTmp);
    return AddPage(ppsh, szTmp, StartDlg, STARTDLG, (LPARAM)NULL);
}

/*==========================================================================*/
static BOOL PASCAL NEAR AddRebootPage(
                                       LPPROPSHEETHEADER    ppsh)
{
    TCHAR    aszTitleRes[128];
    TCHAR    szTmp[32];

    LoadString(ghInstance, IDS_START, aszTitleRes, sizeof(aszTitleRes)/sizeof(TCHAR));
    PadWithSpaces((LPTSTR)aszTitleRes, (LPTSTR)szTmp);
    return AddPage(ppsh, szTmp, RebootDlg, REBOOTDLG, (LPARAM)NULL);
}

/*==========================================================================*/
static BOOL PASCAL NEAR AddHardwarePage(
                                       LPPROPSHEETHEADER    ppsh)
{
    TCHAR    aszTitleRes[128];
    TCHAR     szTmp[32];

    // Don't add a hardware tab if the admin restricted it
    if (SHRestricted(REST_NOHARDWARETAB))
        return FALSE;

    LoadString(ghInstance, IDS_HARDWARE, aszTitleRes, sizeof(aszTitleRes)/sizeof(TCHAR));
    PadWithSpaces((LPTSTR)aszTitleRes, (LPTSTR)szTmp);
    return AddPage(ppsh, szTmp, HardwareDlgProc, HWDLG, (LPARAM)NULL);
}

/*==========================================================================*/
static BOOL PASCAL NEAR AddSchemesPage(
                                      LPPROPSHEETHEADER    ppsh)
{
    TCHAR    aszTitleRes[128];

    LoadString(ghInstance, IDS_EVENTSNAME, aszTitleRes, sizeof(aszTitleRes)/sizeof(TCHAR));
    return AddPage(ppsh, aszTitleRes, SoundDlg, SOUNDDIALOG, (LPARAM)NULL);
}

/*==========================================================================*/

static void PASCAL NEAR AddInternalPages (LPPROPSHEETHEADER ppsh)
{
    static EXTPROPSHEETCBPARAM cbp;
    TCHAR  szText[ cchRESOURCE ];
    TCHAR  szPadded[ cchRESOURCE ];


    // Add the Volume page
    //
    GetString (szText, IDS_VOLUMENAME, ghInstance);
    PadWithSpaces (szText, szPadded);
    AddPage (ppsh, szPadded, VolumeDlg, IDD_VOLUME, (LPARAM)NULL);

    // Add the Sound Scheme page
    //
    GetString (szText, IDS_EVENTSNAME, ghInstance);
    PadWithSpaces (szText, szPadded);
    AddPage (ppsh, szPadded, SoundDlg, SOUNDDIALOG, (LPARAM)NULL);

    // Add the Audio page
    //
    GetString (szText, IDS_AUDIO_TAB, ghInstance);
    PadWithSpaces (szText, szPadded);
    AddPage (ppsh, szPadded, AudioDlg, AUDIODLG, (LPARAM)NULL);

    // Add the Voice page
    //
    GetString (szText, IDS_VOICE, ghInstance);
    PadWithSpaces (szText, szPadded);
    AddPage (ppsh, szPadded, VoiceDlg, VOICEDLG, (LPARAM)NULL);
}


static void InitPSH(LPPROPSHEETHEADER ppsh, HWND hwndParent, LPTSTR pszCaption, HPROPSHEETPAGE    FAR * phpsp)
{
    ppsh->dwSize = sizeof(PROPSHEETHEADER);
    ppsh->dwFlags = PSH_PROPTITLE;
    ppsh->hwndParent = hwndParent;
    ppsh->hInstance = ghInstance;
    ppsh->pszCaption = pszCaption;
    ppsh->nPages = 0;
    ppsh->nStartPage = 0;
    ppsh->phpage = phpsp;
}


/*==========================================================================*/
#ifdef FIX_BUG_15451
static void PASCAL cplMMDoubleClick (HWND hCPlWnd, int nStartPage)
#else // FIX_BUG_15451
static void PASCAL cplMMDoubleClick (HWND hCPlWnd)
#endif // FIX_BUG_15451
{
    PROPSHEETHEADER   psh;
    HPROPSHEETPAGE    hpsp[MAXPAGES];
    TCHAR strOldDir[MAX_PATH], strSysDir[MAX_PATH];

    strOldDir[0] = TEXT('\0');
    strSysDir[0] = TEXT('\0');

    GetSystemDirectory(strSysDir, MAX_PATH);
    GetCurrentDirectory(MAX_PATH, strOldDir);
    SetCurrentDirectory(strSysDir);
    wsInfParseInit();

    InitCommonControls();
    OleInitialize(NULL);

    RegSndCntrlClass((LPCTSTR)DISPFRAMCLASS);

    do
    {
        gfRedisplayCPL = FALSE;

        InitPSH(&psh,hCPlWnd,(LPTSTR)MAKEINTRESOURCE(IDS_MMNAME),hpsp);
#ifdef FIX_BUG_15451
        psh.nStartPage = nStartPage;
#else // FIX_BUG_15451
        psh.nStartPage = g_nStartPage;
#endif // FIX_BUG_15451
        g_nStartPage = 0;

        if (AudioServiceStarted())
        {
            if (RebootNeeded())
            {
                AddRebootPage(&psh);
            }
            else
            {
                AddInternalPages(&psh);
                AddHardwarePage(&psh);
            }
        }
        else
        {
            AddStartPage(&psh);
        }
        PropertySheet(&psh);
    }
    while( gfRedisplayCPL == TRUE );

    OleUninitialize();

    infClose(NULL);
    SetCurrentDirectory(strOldDir);
}

/*==========================================================================*/
static void PASCAL cplEventsDoubleClick (HWND hCPlWnd)
{
    PROPSHEETHEADER    psh;
    HPROPSHEETPAGE    hpsp[MAXPAGES];

    InitCommonControls();
    RegSndCntrlClass((LPCTSTR)DISPFRAMCLASS);
    InitPSH(&psh,hCPlWnd,(LPTSTR)MAKEINTRESOURCE(IDS_EVENTSNAME),hpsp);
    AddSchemesPage(&psh);
    PropertySheet(&psh);
}

#ifdef FIX_BUG_15451
/*==========================================================================*/
/*
 * ShowDriverSettings
 * ShowDriverSettingsAfterFork
 *
 * When the user selects DevicesTab.<anydevice>.Properties.Settings, a
 * DRV_CONFIGURE message is sent to the selected user-mode driver, to cause
 * it to display its configuration dialog.  The sound drivers shipped with
 * NT (SNDBLST,MVAUDIO,SNDSYS) exhibit a bug in this condition: when the
 * configuration dialog is complete (regardless of whether OK or CANCEL was
 * selected), these drivers attempt to unload-and-reload their kernel-mode
 * component in order to begin using the new (or restore the original)
 * driver settings.  The unload request fails, because both the Audio tab
 * and SNDVOL.EXE have open mixer handles and pending IRPs within the kernel
 * driver (the latter are used to provide notifications of volume changes).
 * Worse, when the unload fails, it leaves the driver useless: its state
 * remains STOP_PENDING, and it cannot be resurrected without logging off
 * and back on.
 *
 * These routines have been provided as a temporary workaround for bug 15451,
 * which describes the problem mentioned above.  The theory behind this
 * solution is two-fold:
 *   1- close SNDVOL.EXE as soon as a driver's configuration dialog is
 *      to be displayed, and restart it directly thereafter.  This prevents
 *      it from maintaining any open handles to and/or pending IRPs within the
 *      kernel driver.
 *   2- if the Audio tab has ever been displayed, it will have open mixers
 *      which must be closed.  Because a bug/design flaw within these sound
 *      drivers prevents the mixers from being closed without killing this
 *      process (the sound drivers each cache open mixer handles), the
 *      routine ShowDriverSettings forks a new MMSYS.CPL process, which is
 *      then used to display the driver's settings dialog.
 *
 * The flow of this solution follows:
 *
 * 1- MMSYS.CPL starts on Audio tab, setting fHaveStartedAudioDialog to TRUE.
 * 2- User selects Devices tab.
 * 3- User selects a device driver.
 * 4- User selects Properties+Settings; control reaches ShowDriverSettings().
 * 5- ShowDriverSettings() determines if there is a need to fork a new process:
 *    this will be the case if the Audio tab has been displayed, and the
 *    device for which it is to display settings contains mixers.  If either
 *    of these conditions is false, ShowDriverSettings displays the driver's
 *    settings dialog directly (via ConfigureDriver()).
 * 6- ShowDriverSettings() uses WinExec() to fork a new process, using
 *    the routine ShowDriverSettingsAfterFork() as an entry point.  If the
 *    exec fails, ShowDriverSettings() displays the driver's settings dialog
 *    directly (via ConfigureDriver()).
 * PROCESS 1:                           PROCESS 2:
 * 7- Enters WaitForNewCPLWindow(),     1- ShowDriverSettingsAfterFork() will
 *    which will wait up to 5 seconds      receive on its command-line the
 *    for the new MMSYS.CPL process        name of the driver for which
 *    to open a driver Properties          settings have been requested.  It
 *    dialog which matches its own:        opens the primary dialog, using the
 *    if it finds such a dialog,           Devices tab as the initial tab--
 *    WaitForNewCPLWindow() will post      so that the Advanced tab is never
 *    IDCANCEL messages to both the        displayed, and because the Devices
 *    current driver Properties dialog,    tab is the active tab on the other
 *    and to this process's main           process.
 *    dialog, terminating this process. 2- During WM_INITDIALOG of the Devices
 *                                         dialog, this process searches for
 *                                       the previous process' MMSYS.CPL dialog.
 *                                     If successful, it moves this MMSYS.CPL
 *                                   dialog directly behind the previous dialog.
 *                              3- During ID_INIT of the Devices dialog, this
 *                               process searches the TreeView for the driver
 *                             which was named on the comand-line: if found,
 *                           it highlights the TreeItem and simulates a press
 *                         of the Properties button
 *                    4- During WM_INITDIALOG of the device's Properties dialog,
 *                     this process searches for the previous process' device's
 *                   properties dialog.  If successful, it moves this dialog
 *                 directly behind its counterpart.
 *            5- During ID_INIT of the device's Properties dialog, this process
 *             simulates a press of the Settings button
 *        6- When the Settings button is pressed, this process recognizes that
 *         it has been forked and skips the call to ShowDriverSettings(),
 *       instead simply displaying the driver's settings dialog (via
 *     ConfigureDriver()).
 *
 * Let it be known that this is a hack, and should be removed post-beta.
 *
 */

extern BOOL fHaveStartedAudioDialog;    // in MSACMCPL.C

void ShowDriverSettings (HWND hDlg, LPTSTR pszName)
{
    if (fHaveStartedAudioDialog && fDeviceHasMixers (pszName))
    {
        TCHAR  szForkLine[ cchRESOURCE *2 ];

        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        wsprintf (szForkLine, cszFORKLINE, pszName);

        if (CreateProcess(NULL,szForkLine,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
        {
            (void)WaitForNewCPLWindow (hDlg);
        }
        else
        {
            ConfigureDriver (hDlg, pszName);
        }
    }
    else
    {
        ConfigureDriver (hDlg, pszName);
    }
}


void WINAPI ShowDriverSettingsAfterFork (
                                        HWND hwndStub,
                                        HINSTANCE hAppInstance,
                                        LPTSTR lpszCmdLine,
                                        int nCmdShow)
{
    #ifdef UNICODE
    WCHAR szCmdLine[ cchRESOURCE ];
    #else
        #define szCmdLine lpszCmdLine
    #endif

    if(szCmdLine)
        return;

    lstrcpy (szDriverWhichNeedsSettings, szCmdLine);
    cplMMDoubleClick (NULL, 4); // 4==Start on Advanced ("Devices") tab
}

void WINAPI ShowDriverSettingsAfterForkW (
                                         HWND hwndStub,
                                         HINSTANCE hAppInstance,
                                         LPWSTR lpwszCmdLine,
                                         int nCmdShow)
{
    #ifdef UNICODE
        #define szCmdLine lpwszCmdLine
    #else
    CHAR szCmdLine[ cchRESOURCE ];
    wcstombs(szCmdLine, lpwszCmdLine, cchRESOURCE);
    #endif

    lstrcpy (szDriverWhichNeedsSettings, szCmdLine);
    cplMMDoubleClick (NULL, 4); // 4==Start on Advanced ("Devices") tab
}

#endif // FIX_BUG_15451

// Globals to support sound event command line parameters.

#define MAX_SND_EVNT_CMD_LINE 32
TCHAR    gszCmdLineApp[MAX_SND_EVNT_CMD_LINE];
TCHAR    gszCmdLineEvent[MAX_SND_EVNT_CMD_LINE];

/*==========================================================================*/
LONG CPlApplet(
              HWND    hCPlWnd,
              UINT    Msg,
              LPARAM  lParam1,
              LPARAM  lParam2)
{
    switch (Msg)
    {
    case CPL_INIT:
        wHelpMessage = RegisterWindowMessage(TEXT("ShellHelp"));
        DPF_T("*CPL_INIT*");
        g_cRefCnt++;
        return (LRESULT)TRUE;

    case CPL_GETCOUNT:
        return (LRESULT)1;

    case CPL_INQUIRE:
        DPF_T("*CPL_INQUIRE*");
        switch (lParam1)
        {
        case 0:
            ((LPCPLINFO)lParam2)->idIcon = IDI_MMICON;
            ((LPCPLINFO)lParam2)->idName = IDS_MMNAME;
            ((LPCPLINFO)lParam2)->idInfo = IDS_MMINFO;
            break;
        default:
            return FALSE;
        }
        ((LPCPLINFO)lParam2)->lData = 0L;
        return TRUE;

    case CPL_NEWINQUIRE:
        switch (lParam1)
        {
        case 0:
            ((LPNEWCPLINFO)lParam2)->hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_MMICON));
            LoadString(ghInstance, IDS_MMNAME, ((LPNEWCPLINFO)lParam2)->szName, sizeof(((LPNEWCPLINFO)lParam2)->szName)/sizeof(TCHAR));
            LoadString(ghInstance, IDS_MMINFO, ((LPNEWCPLINFO)lParam2)->szInfo, sizeof(((LPNEWCPLINFO)lParam2)->szInfo)/sizeof(TCHAR));
            break;
        default:
            return FALSE;
        }
        ((LPNEWCPLINFO)lParam2)->dwHelpContext = 0;
        ((LPNEWCPLINFO)lParam2)->dwSize = sizeof(NEWCPLINFO);
        ((LPNEWCPLINFO)lParam2)->lData = 0L;
        ((LPNEWCPLINFO)lParam2)->szHelpFile[0] = 0;
        return TRUE;

    case CPL_DBLCLK:
        DPF_T("* CPL_DBLCLICK*");
        // Do the applet thing.
        switch (lParam1)
        {
        case 0:
            // Check for obsolete command line (see comments
            // under CPL_STARTWPARAMS)
            if ((-1) == g_nStartPage) break;

#ifdef FIX_BUG_15451
            lstrcpy (szDriverWhichNeedsSettings, TEXT(""));
            cplMMDoubleClick(hCPlWnd, g_nStartPage);
#else // FIX_BUG_15451
            cplMMDoubleClick(hCPlWnd);
#endif // FIX_BUG_15451
            break;
        }
        break;

    case CPL_STARTWPARMS:
        switch (lParam1)
        {
        case 0:
            if (lParam2 && *((LPTSTR)lParam2))
            {
                TCHAR c;

                c = *((LPTSTR)lParam2);
                if (c > TEXT('0') && c < TEXT('5'))
                {
                    g_nStartPage = c - TEXT('0');
                    break;
                }

                // The "S" command line was used on Windows 98 and Windows 98
                // SE.  The command line was written to the Active Setup
                // registry to run logic to setup preferred devices on a
                // specific PnP device instance.  It is obsolete and handled in
                // winmm.dll itself.  This cpl should do nothing for this
                // command line.
                if ((c == TEXT('S')) || (c == TEXT('s'))) {
                    g_nStartPage = (-1);
                    break;
                }
            }
            g_nStartPage = 0;
            break;

            // For sound events, the passed in parameter indicates a module
            // name and event. If a name is passed only show it's sound events.
            // If a name and event are passed only show the event.
            /*        case 1:

                        if (lParam2 && *((LPTSTR)lParam2))
                        {
                            TCHAR *psz;

                            if ((psz = wcschr((LPTSTR)lParam2, TEXT(','))) != NULL)
                            {
                                *psz++ = TEXT('\0');
                                wcsncpy(gszCmdLineEvent, psz, MAX_SND_EVNT_CMD_LINE/sizeof(TCHAR));
                                gszCmdLineEvent[MAX_SND_EVNT_CMD_LINE-sizeof(TCHAR)] = TEXT('\0');
                            }
                            wcsncpy(gszCmdLineApp, (LPTSTR)lParam2,
                                    MAX_SND_EVNT_CMD_LINE/sizeof(TCHAR));
                            gszCmdLineApp[MAX_SND_EVNT_CMD_LINE-sizeof(TCHAR)] = TEXT('\0');
                        }
                        break; */
        }

        break;

    case CPL_EXIT:
        DPF_T("* CPL_EXIT*");
        g_cRefCnt--;
        break;
    }
    return 0;
}


void PASCAL ShowPropSheet(LPCTSTR            pszTitle,
                          DLGPROC            pfnDialog,
                          UINT            idTemplate,
                          HWND            hWndParent,
                          LPTSTR            pszCaption,
                          LPARAM lParam)
{
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[MAXPAGES];


    InitPSH(&psh,hWndParent,pszCaption,hpsp);
    AddPage(&psh, pszTitle,  pfnDialog, idTemplate, lParam);
    PropertySheet(&psh);

}

void PASCAL ShowMidiPropSheet(LPPROPSHEETHEADER ppshExt,
                              LPCTSTR    pszTitle,
                              HWND      hWndParent,
                              short     iMidiPropType,
                              LPTSTR     pszCaption,
                              HTREEITEM hti,
                              LPARAM    lParam1,
                              LPARAM    lParam2)
{
    PROPSHEETHEADER psh;
    LPPROPSHEETHEADER ppsh;
    HPROPSHEETPAGE  hpsp[MAXPAGES];
    static EXTPROPSHEETCBPARAM cbp;

    if (!ppshExt)
    {
        ppsh = &psh;
        InitPSH(ppsh,hWndParent,pszCaption,hpsp);
    }
    else
        ppsh = ppshExt;

    cbp.lParam1 = lParam1;
    cbp.lParam2 = lParam2;
    cbp.hti = hti;
    cbp.ppsh = ppsh;

    if (iMidiPropType == MIDI_CLASS_PROP)
    {
        if (AddMidiPages((LPVOID)pszTitle, MMExtPropSheetCallback, (LPARAM)&cbp))
        {
            PropertySheet(ppsh);
        }
    }
    else if (iMidiPropType == MIDI_INSTRUMENT_PROP)
    {
        if (AddInstrumentPages((LPVOID)pszTitle, MMExtPropSheetCallback, (LPARAM)&cbp))
        {
            PropertySheet(ppsh);
        }
    }
    else
    {
        if (AddDevicePages((LPVOID)pszTitle, MMExtPropSheetCallback, (LPARAM)&cbp))
        {
            PropertySheet(ppsh);
        }
    }
}

void PASCAL ShowWithMidiDevPropSheet(LPCTSTR            pszTitle,
                                     DLGPROC            pfnDialog,
                                     UINT            idTemplate,
                                     HWND            hWndParent,
                                     LPTSTR            pszCaption,
                                     HTREEITEM    hti,
                                     LPARAM lParam, LPARAM lParamExt1, LPARAM lParamExt2)
{
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[MAXPAGES];


    InitPSH(&psh,hWndParent,pszCaption,hpsp);
    AddPage(&psh, pszTitle,  pfnDialog, idTemplate, lParam);
    PropertySheet(&psh);
    // Disabling the details sheet - obsolete 01/10/2001
    //ShowMidiPropSheet(&psh, pszCaption, hWndParent,MIDI_DEVICE_PROP,pszCaption,hti,lParamExt1,lParamExt2);
}

BOOL WINAPI ShowMMCPLPropertySheetW(HWND hwndParent, LPCTSTR pszPropSheetID, LPTSTR pszTabName, LPTSTR pszCaption)
{
    DLGPROC pfnDlgProc;
    UINT    idTemplate;
    HWND    hwndP;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[MAXPAGES];

    if (GetWindowLongPtr(hwndParent, GWL_EXSTYLE) & WS_EX_TOPMOST)
        hwndP = NULL;
    else
        hwndP = hwndParent;

    InitPSH(&psh,hwndP,pszCaption,hpsp);
    psh.dwFlags = 0;

    if (!lstrcmpi(pszPropSheetID, cszAUDIO))
    {
        pfnDlgProc = AudioDlg;
        idTemplate = AUDIODLG;
        goto ShowSheet;
    }
	if (!lstrcmpi(pszPropSheetID, cszVOICE))
    {
        pfnDlgProc = VoiceDlg;
        idTemplate = VOICEDLG;
        goto ShowSheet;
    } 
	if (!lstrcmpi(pszPropSheetID, cszVOLUME))
    {
        pfnDlgProc = VolumeDlg;
        idTemplate = IDD_VOLUME;
        goto ShowSheet;
    } 
    if (!lstrcmpi(pszPropSheetID, cszVIDEO))
    {
        pfnDlgProc = VideoDlg;
        idTemplate = VIDEODLG;
        goto ShowSheet;
    }
    if (!lstrcmpi(pszPropSheetID, cszCDAUDIO))
    {
        pfnDlgProc = CD_HardwareDlgProc;
        idTemplate = HWDLG;
        goto ShowSheet;
    }
    if (!lstrcmpi(pszPropSheetID, cszMIDI))
    {
    /*
        static EXTPROPSHEETCBPARAM cbpMIDI;

        cbpMIDI.ppsh = &psh;
        cbpMIDI.hti = NULL;
        cbpMIDI.lParam1 = (LPARAM)pszPropSheetID;
        cbpMIDI.lParam2 = (LPARAM)pszTabName;
        AddSimpleMidiPages((LPVOID)pszTabName, MMExtPropSheetCallback, (LPARAM)&cbpMIDI);
        PropertySheet(&psh);
        return TRUE;
      */

        pfnDlgProc = AudioDlg;
        idTemplate = AUDIODLG;
        goto ShowSheet;

    }

    return FALSE;
    ShowSheet:
    AddPage(&psh, pszTabName,  pfnDlgProc, idTemplate, (LPARAM)NULL);
    PropertySheet(&psh);
    return TRUE;
}

BOOL WINAPI ShowMMCPLPropertySheet(HWND hwndParent, LPCSTR pszPropSheetID, LPSTR pszTabName, LPSTR pszCaption)
{
    DLGPROC pfnDlgProc;
    UINT    idTemplate;
    HWND    hwndP;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[MAXPAGES];
    TCHAR szPropSheetID[MAX_PATH];
    TCHAR szTabName[MAX_PATH];
    TCHAR szCaption[MAX_PATH];

    //convert three params into UNICODE strings
    MultiByteToWideChar( GetACP(), 0, pszPropSheetID, -1, szPropSheetID, sizeof(szPropSheetID) / sizeof(TCHAR) );
    MultiByteToWideChar( GetACP(), 0, pszTabName,     -1, szTabName,     sizeof(szTabName)     / sizeof(TCHAR) );
    MultiByteToWideChar( GetACP(), 0, pszCaption,     -1, szCaption,     sizeof(szCaption)     / sizeof(TCHAR) );

    return (ShowMMCPLPropertySheetW(hwndParent,szPropSheetID,szTabName,szCaption));
}

//allows you to show control panel from RUNDLL32
DWORD WINAPI ShowFullControlPanel(HWND hwndP, HINSTANCE hInst, LPTSTR szCmd, int nShow)
{
    cplMMDoubleClick(hwndP, 0);
    return 0;
}

DWORD WINAPI ShowAudioPropertySheet(HWND hwndP, HINSTANCE hInst, LPTSTR szCmd, int nShow)
{
    TCHAR szAudio[MAXLNAME];
    TCHAR szAudioProperties[MAXLNAME];
    char mbcszAUDIO[MAXLNAME];
    char mbszAudio[MAXLNAME];
    char mbszAudioProperties[MAXLNAME];
    HWND hwndPrev;

    LoadString(ghInstance, IDS_AUDIOPROPERTIES, szAudioProperties, sizeof(szAudioProperties)/sizeof(TCHAR));
    hwndPrev = FindWindow(NULL,szAudioProperties);
    if (hwndPrev)
    {
        SetForegroundWindow(hwndPrev);
    }
    else
    {
        LoadString(ghInstance, IDS_WAVE_HEADER, szAudio, sizeof(szAudio)/sizeof(TCHAR));
        ShowMMCPLPropertySheetW(hwndP, cszAUDIO, szAudio, szAudioProperties);
    }
    return 0;
}


DWORD WINAPI mmseRunOnce(HWND hwnd, HINSTANCE hInst, LPSTR lpszCmdLine, int nShow)
{
    // This is an obsolete function formerly used to migrate
    // registry and driver information.  We leave the export
    // in place in case an old installation has left a RunOnce
    // command in place to execute this function.
    return 0;
}

DWORD WINAPI mmseRunOnceW(HWND hwnd, HINSTANCE hInst, LPWSTR lpwszCmdLine, int nShow)
{
    // This is an obsolete function formerly used to migrate
    // registry and driver information.  We leave the export
    // in place in case an old installation has left a RunOnce
    // command in place to execute this function.
    return 0;
}

extern BOOL DriversDllInitialize (IN PVOID, IN DWORD, IN PCONTEXT OPTIONAL);

BOOL DllInitialize (IN PVOID hInstance,
                    IN DWORD ulReason,
                    IN PCONTEXT pctx OPTIONAL)
{
    // patch in the old DRIVERS.DLL code (see DRIVERS.C)
    //
    DriversDllInitialize (hInstance, ulReason, pctx);

    if (ulReason == DLL_PROCESS_ATTACH)
    {
        ++g_cProcesses;
        ghInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
        return TRUE;
    }

    if (ulReason == DLL_PROCESS_DETACH)
    {
        --g_cProcesses;
        return TRUE;
    }

    return TRUE;
}

DWORD
    WINAPI
    MediaClassInstaller(
                       IN DI_FUNCTION      InstallFunction,
                       IN HDEVINFO         DeviceInfoSet,
                       IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                       )
/*++

Routine Description:

    This routine acts as the class installer for Media devices.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    DWORD dwRet=ERROR_DI_DO_DEFAULT;

    switch (InstallFunction)
    {

    case DIF_SELECTBESTCOMPATDRV:
        dwRet = Media_SelectBestCompatDrv(DeviceInfoSet,DeviceInfoData);
        break;

    case DIF_ALLOW_INSTALL:
        dwRet = Media_AllowInstall(DeviceInfoSet,DeviceInfoData);
        break;

    case DIF_INSTALLDEVICE :
        dwRet = Media_InstallDevice(DeviceInfoSet, DeviceInfoData);
        break;

    case DIF_REMOVE:
        dwRet = Media_RemoveDevice(DeviceInfoSet,DeviceInfoData);
        break;

    case DIF_SELECTDEVICE:
        dwRet = Media_SelectDevice(DeviceInfoSet,DeviceInfoData);
        break;

    case DIF_FIRSTTIMESETUP:
        // Fall through

    case DIF_DETECT:
        dwRet = Media_MigrateLegacy(DeviceInfoSet,DeviceInfoData);
        break;

    }

    return dwRet;

}

DWORD WINAPI mmWOW64MediaInstallDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    HWND hWnd;

    //
    // Get the device install parameters, so we'll know what parent window to use for any
    // UI that occurs during configuration of this device.
    //
    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams))
    {
        hWnd = DeviceInstallParams.hwndParent;
    }
    else
    {
        hWnd = NULL;
    }

    //
    // The INF will have created a "Drivers" subkey under the device's software key.
    // This tree, in turn, contains subtrees for each type of driver (aux, midi, etc.)
    // applicable for this device.  We must now traverse this tree, and create entries
    // in Drivers32 for each function alias.
    //
    return InstallDriversForPnPDevice(hWnd, DeviceInfoSet, DeviceInfoData);
}


DWORD WINAPI mmWOW64MediaRemoveDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
    if( RemoveDriver(DeviceInfoSet, DeviceInfoData) )
    {
        return NO_ERROR;
    }
    else
    {
        return ERROR_BAD_DRIVER;
    }
}


DWORD WINAPI mmWOW64MediaClassInstallerA(HWND hwnd, HINSTANCE hInst, LPSTR lpszCmdLine, int nShow)
/*++

Routine Description:

    This routine acts as a thunking layer for calling the 32-bit
        installation functions from the 64-bit setup via RunDLL32.exe.

Arguments:

    hwnd - not used

    hInst - not used

    lpwszCmdLine - command line arguments: "Instance ID (string)" DI_FUNCTION (as an integer)

    nShow - not used

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    LPSTR strInstanceID = NULL;
    LPSTR strInstallIndex = NULL;
    DWORD dwInstallIndex = 0;
    LPSTR strTemp = NULL;
    HDEVINFO DeviceInfoSet = NULL;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD dwResult = NO_ERROR;

    // Find first quote
    strTemp = strchr( lpszCmdLine, '\"' );
    if( !strTemp )
    {
        return ERROR_INVALID_PARAMETER;
    }


    // Instance ID

    // Skip first quote
    strInstanceID = ++strTemp;

    // Find second quote
    strTemp = strchr( strTemp, '\"' );
    if( !strTemp )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // NULL-terminate the InstanceID
    *strTemp = 0;


    // Install Index

    // Skip the NULL
    strInstallIndex = ++strTemp;


    // Convert the installation index
    dwInstallIndex = atoi( strInstallIndex );


    // Create a device handle
    DeviceInfoSet = SetupDiCreateDeviceInfoList( NULL, NULL );
    if( INVALID_HANDLE_VALUE == DeviceInfoSet )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Create the device info structure
    ZeroMemory( &DeviceInfoData, sizeof(SP_DEVINFO_DATA) );
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if( 0 == SetupDiOpenDeviceInfoA( DeviceInfoSet, strInstanceID, NULL, 0, &DeviceInfoData ) )
    {
        dwResult = GetLastError();
    }

    // Do the installation task
    if( NO_ERROR == dwResult )
    {
        switch( dwInstallIndex )
        {
        case DIF_INSTALLDEVICE:
            dwResult = mmWOW64MediaInstallDevice(DeviceInfoSet, &DeviceInfoData);
            break;
        case DIF_REMOVE:
            dwResult = mmWOW64MediaRemoveDevice(DeviceInfoSet, &DeviceInfoData);
            break;
        default:
            dwResult = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    SetupDiDestroyDeviceInfoList( DeviceInfoSet );

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\mmdriver.c ===
/*----------------------------------------------------------------------------
 | mmdriver.c - Install Multimedia Drivers
 |
 | Copyright (C) Microsoft, 1989, 1990.  All Rights Reserved
 |
 |  History:
 |      09/11/90    davidle     created
 |          Install Multimedia Drivers
 |
 |      Tue Jan 29 1991 -by- MichaelE
 |          Redesigned installing installable drivers so additional drivers
 |        can be installed by adding them to setup.inf's [installable.drivers]
 |
 |      Wed Mar 20 1991 -by- MichaelE
 |          Changed mmAddInstallableDriver to accept multiple VxDs.
 |          Changed and WriteNextPrivateProfileString to check if the profile
 |          being concatenated is already there.
 |
 |      Sun Apr 14 1991 -by- MichaelE
 |          WriteNextPrivateProfileString -> Next386EnhDevice.
 |
 |      Sun Apr 14 1991 -by- JohnYG
 |          Taken from setup for drivers applet.
 |
 |      Wed Jun 05 1991 -by- MichaelE
 |          Added FileCopy of associated file list to windows system dir.
 |
 *----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <winsvc.h>
#include <string.h>
#include <stdlib.h>
#include "drivers.h"
#include "sulib.h"

/*
 *  Local functions
 */

 static BOOL mmAddInstallableDriver         (PINF, LPTSTR, LPTSTR, PIDRIVER );
 static BOOL GetDrivers                     (PINF, LPTSTR, LPTSTR);

/**************************************************************************
 *
 *  AccessServiceController()
 *
 *  Check we will be able to access the service controller to install
 *  a driver
 *
 *  returns FALSE if we can't get access - otherwise TRUE
 *
 **************************************************************************/
 BOOL AccessServiceController(void)
 {

     SC_HANDLE SCManagerHandle;

     SCManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
     if (SCManagerHandle == NULL) {
         return FALSE;
     }

     CloseServiceHandle(SCManagerHandle);

     return TRUE;
 }


/**************************************************************************
 *
 *  mmDisplayInfFileErrMsg()
 *
 *  This function displays an error message when the inf file contains
 *  corrupt data.
 *
 **************************************************************************/

 void mmDisplayInfFileErrMsg( void )
 {
     TCHAR strBuf[MAXSTR];

    /*
     *  We do not want to report any errors that occur while installing
     *  related drivers to the user
     */

     if( bCopyingRelated )
	 {
          return;
	 }

	 LoadString(myInstance, IDS_INVALIDINF, strBuf, MAXSTR);
     MessageBox(hMesgBoxParent,
                strBuf,
                szFileError,
                MB_OK | MB_ICONEXCLAMATION  | MB_TASKMODAL);
 }


/**************************************************************************
 *
 *  mmAddNewDriver() - only exported function in this file.
 *
 *  This function installs (copies) a driver
 *
 *  returns FALSE if no drivers could be installed.
 *          TRUE if at least one driver installation was sucessful.
 *          All added types in lpszNewTypes buffer.
 *
 **************************************************************************/

 BOOL mmAddNewDriver( LPTSTR lpstrDriver, LPTSTR lpstrNewTypes, PIDRIVER pIDriver )
 {
     PINF pinf;

     if ((pinf = FindInstallableDriversSection(NULL)) == NULL)
         return FALSE;

     return mmAddInstallableDriver(pinf, lpstrDriver, lpstrNewTypes, pIDriver);
 }


/**************************************************************************
 * mmAddInstallableDriver() - Do the dirty work looking for VxD's copying them
 *     looking for drivers, copying them, and returning the best type names.
 *
 *
 **************************************************************************/

BOOL mmAddInstallableDriver( PINF pInfIDrivers,
                             LPTSTR pstrDriver,
                             LPTSTR lpstrNewTypes,
                             PIDRIVER pIDriver)
{
    LPTSTR pstr, pstrSection;
    static TCHAR szTemp[10];
    PINF pInfSection= pInfIDrivers;
	LONG lResult;
    int  i;
    TCHAR szBuffer[MAX_INF_LINE_LEN],
         szFilename[MAXSTR],
         szType[MAX_SECT_NAME_LEN];

   /*
    *  format of a line in [installable.drivers] of setup.inf:
    *  driver profile =                            [0]
    *                   filename,                  [1]
    *                   "type(s)",                 [2]
    *                   "description",             [3]
    *                   "VxD and .sys filename(s)",[4]
    *                   "default config params"    [5]
    *                   "Related drivers"          [6]
    *
    *  find the driver profile line in szMDrivers we are installing
    */

    while ( TRUE )
    {
        lResult = infParseField( pInfIDrivers, 0, szBuffer, SIZEOF(szBuffer) );
		if( INF_PARSE_FAILED(lResult) )
		{
			mmDisplayInfFileErrMsg();
			return FALSE;
		}
        if ( lstrcmpi( szBuffer, pstrDriver ) == 0 )
            break;
        else if ( ! (pInfIDrivers = infNextLine( pInfIDrivers )) )
            return FALSE;
    }

   /*
    *  copy the driver file and add driver type(s) to the installable
    *  driver section
    */

    if ( infParseField(pInfIDrivers, 1, szFilename, SIZEOF(szFilename)) != ERROR_SUCCESS )
	{
		mmDisplayInfFileErrMsg();
        return FALSE;
	}


   /*
    *  Ignore the disk number
    */

    wcscpy(szDrv, RemoveDiskId(szFilename));

   /*
    *  Cache whether it's a kernel driver
    */

    pIDriver->KernelDriver = IsFileKernelDriver(szFilename);

   /*
    *  Can't install kernel drivers if don't have privilege
    */

    if (pIDriver->KernelDriver && !AccessServiceController()) {

        TCHAR szMesg[MAXSTR];
        TCHAR szMesg2[MAXSTR];
        TCHAR szTitle[50];

        LoadString(myInstance, IDS_INSUFFICIENT_PRIVILEGE, szMesg, sizeof(szMesg)/sizeof(TCHAR));
        LoadString(myInstance, IDS_CONFIGURE_DRIVER, szTitle, sizeof(szTitle)/sizeof(TCHAR));
        wsprintf(szMesg2, szMesg, szDrv);
        MessageBox(hMesgBoxParent, szMesg2, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);

        return FALSE;
    }

   /*
    *  Do the file copying
    */

    if (FileCopy( szFilename,
                  szSystem,
                  (FPFNCOPY)wsCopySingleStatus,
                  FC_FILE ) != NO_ERROR) {
        return FALSE;
    }

   /*
    *  Add options
    */

    lResult = infParseField (pInfIDrivers,5,szBuffer+1, SIZEOF(szBuffer)-1);
	if( INF_PARSE_FAILED(lResult) )
	{
		mmDisplayInfFileErrMsg();
		return FALSE;
	}
	else if( lResult == ERROR_SUCCESS )
	{
		szBuffer[0]=TEXT(' ');
		lstrcat(szFilename,szBuffer);
	}

   /*
    *  copy filename and options
    */

    wcsncpy(pIDriver->szFile, FileName(szFilename), sizeof(pIDriver->szFile)/sizeof(TCHAR));
    pIDriver->szFile[sizeof(pIDriver->szFile)/sizeof(TCHAR) - 1] = 0;

   /*
    *  copy description
    */

    lResult = infParseField( pInfIDrivers, 3, pIDriver->szDesc, SIZEOF(pIDriver->szDesc) );
	if( INF_PARSE_FAILED(lResult) )
	{
		mmDisplayInfFileErrMsg();
		return FALSE;
	}

   /*
    *  determine the section from the description.  A kernel driver
    *  will appear as a driver of type 'KERNEL' in system.ini
    *
    *  If the description contains [MCI] then it's MCI.
    */

    if (wcsstr(pIDriver->szDesc, TEXT("MCI")))
        pstrSection = szMCI;
    else
        pstrSection = szDrivers;

   /*
    *  Copy name plus parameters to our driver data
    */

    wcsncpy(pIDriver->szSection, pstrSection, sizeof(pIDriver->szSection)/sizeof(TCHAR));
    pIDriver->szSection[sizeof(pIDriver->szSection)/sizeof(TCHAR) - 1] = TEXT('\0');
    wcscpy(pIDriver->wszSection, pIDriver->szSection);

   /*
    *  We return all types in a parseable, contcatentated string
    */
	lResult = infParseField( pInfIDrivers, 2, szBuffer, SIZEOF(szBuffer) );
	if( INF_PARSE_FAILED(lResult) )
	{
		mmDisplayInfFileErrMsg();
		return FALSE;
	}
    for ( i = 1; ; i++ )
    {
		lResult = infParseField( szBuffer, i, szType, SIZEOF(szType) );
		if( INF_PARSE_FAILED(lResult) )
		{
			mmDisplayInfFileErrMsg();
			return FALSE;
		}
		else if( lResult != ERROR_SUCCESS )
		{
			break;
		}

        pstr = &(szType[lstrlen(szType)]);
        *pstr++ = TEXT(',');
        *pstr = 0;
        lstrcat(lpstrNewTypes, szType );
    }

    if (!*lpstrNewTypes)

      /*
       *  We weren't able to return any types.
       */
       return FALSE;

   /*
    *  copy an associated file list (if it exists) to windows system dir
    */

    if (FileCopy(pstrDriver,
                 szSystem,
                 (FPFNCOPY)wsCopySingleStatus,
                 FC_SECTION) != ERROR_SUCCESS)

        return(FALSE);


   /*
    *  if there are system driver files copy them to the system
    *  drivers directory.
    *
    *  NOTE that it is assumed here that any installation and
    *  configuration for these drivers is performed by the main
    *  (.drv) driver being installed.
    *
    */

    lResult = infParseField( pInfIDrivers, 4, szBuffer, SIZEOF(szBuffer) );
	if( INF_PARSE_FAILED(lResult) )
	{
		mmDisplayInfFileErrMsg();
		return FALSE;
	}
    if ( (lResult == ERROR_SUCCESS) && szBuffer[0] )
    {
        for ( i = 1; ; i++ )
        {
			lResult = infParseField( szBuffer, i, szFilename, SIZEOF(szFilename) );
			if( INF_PARSE_FAILED(lResult) )
			{
				mmDisplayInfFileErrMsg();
				return FALSE;
			}
			else if( lResult != ERROR_SUCCESS )
			{
				break;
			}

            wcscpy(szDrv, RemoveDiskId(szFilename));

           /*
            *  FileCopy will adjust the 'system' directory to
            *  system\drivers.  It's done this way because FileCopy
            *  must anyway look for old files in the same directory.
            */

            if (FileCopy(szFilename,
                         szSystem,
                         (FPFNCOPY)wsCopySingleStatus,
                         FC_FILE )
                != ERROR_SUCCESS)
            {
                return FALSE;
            }
        }
    }

#ifdef DOBOOT // Don't do boot section on NT

    lResult = infParseField(pInfIDrivers, 7, szTemp, SIZEOF(szTemp));
	if( INF_PARSE_FAILED(lResult) )
	{
		mmDisplayInfFileErrMsg();
		return FALSE;
	}

    if (!_strcmpi(szTemp, szBoot))
        bInstallBootLine = TRUE;

#endif // DOBOOT


   /*
    *  Read the related drivers list (drivers which must/can also be
    *  be installed).
    */

    if (bRelated == FALSE)
    {
       lResult = infParseField(pInfIDrivers, 6, pIDriver->szRelated, SIZEOF(pIDriver->szRelated));
	   if( INF_PARSE_FAILED(lResult) )
	   {
		   mmDisplayInfFileErrMsg();
		   return FALSE;
	   }
       if (wcslen(pIDriver->szRelated))
       {
          if( !GetDrivers(pInfSection, pIDriver->szRelated, pIDriver->szRemove) )
		  {
			   mmDisplayInfFileErrMsg();
			   return FALSE;
		  }
          pIDriver->bRelated = TRUE;
          bRelated = TRUE;
       }
    }
    return TRUE;
}

/*
 *  Used to get the list of the related driver filenames
 *
 *  pInfIDrivers - Pointer to the [installable.drivers] section or equivalent
 *  szAliasList  - List of driver aliases (ie key values - eg msalib).
 *  szDriverList - List of drivers file names found
 */

BOOL GetDrivers(PINF pInfIDrivers, LPTSTR szAliasList, LPTSTR szDriverList)
{
    TCHAR szBuffer[50];
    TCHAR szAlias[50];
    TCHAR szFileName[50];
    PINF pInfILocal;
	LONG lResult;
    BOOL bEnd;
    int i;

    for ( i = 1; ; i++ )
    {
		lResult = infParseField(szAliasList, i, szAlias, SIZEOF(szAlias));
		if( INF_PARSE_FAILED(lResult) )
		{
			return FALSE;
		}
		else if( lResult != ERROR_SUCCESS )
		{
			break;
		}

        pInfILocal = pInfIDrivers;
        bEnd = FALSE;
        while (!bEnd)
        {
            lResult = infParseField( pInfILocal, 0, szBuffer, SIZEOF(szBuffer));
		    if( INF_PARSE_FAILED(lResult) )
			{
			    return FALSE;
			}
            if (lstrcmpi( szBuffer, szAlias) == 0 )
            {
                lResult = infParseField(pInfILocal, 1, szFileName, SIZEOF(szFileName));
				if( INF_PARSE_FAILED(lResult) )
				{
					return FALSE;
				}
				else if( lResult == ERROR_SUCCESS )
                {
                    lstrcat(szDriverList, RemoveDiskId(szFileName));
                    lstrcat(szDriverList, TEXT(","));
                }
                break;
            }
            else
                if ( ! (pInfILocal = infNextLine( pInfILocal )) )
                    bEnd = TRUE;
        }
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\mmse.c ===
//****************************************************************************
//
//  Module:     MMSE.DLL
//  File:       mmse.c
//  Content:    This file contains the moudle initialization.
//  History:
//      06/1994    -By-    Vij Rajarajan (VijR)
//
//  Copyright (c) Microsoft Corporation 1991-1994
//
//****************************************************************************

#define INITGUID
#include "mmcpl.h"
#include <coguid.h>
#include <oleguid.h>
#include <shlguid.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <vfw.h>

#include <shlobj.h>
#undef INITGUID
#include <shlobjp.h>
//****************************************************************************
// Initialize GUIDs (should be done only and at-least once per DLL/EXE)
//****************************************************************************

#include <commctrl.h>
#include <prsht.h>
#include "draw.h"
#include "utils.h"
#include "medhelp.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */
typedef HWND (VFWAPIV * FN_MCIWNDCREATE)();

//---------------------------------------------------------------------------
// MMPSH class
//---------------------------------------------------------------------------

typedef struct _mmInfoList MMINFOLIST;
typedef MMINFOLIST * PMMINFOLIST;

typedef struct _mmInfoList
{
    TCHAR szInfoDesc[80];
    LPSTR pszInfo;
    FOURCC ckid;
    PMMINFOLIST  pNext;
};


// mmse class structure.  This is used for instances of
// IPersistFolder, IShellFolder, and IShellDetails.
typedef struct _mmpsh
    {
    // We use the pf also as our IUnknown interface
    IShellExtInit          sei;             // 1st base class
    IShellPropSheetExt  pse;             // 2nd base class
    LPDATAOBJECT        pdtobj;
    UINT                cRef;           // reference count
    LPTSTR    pszFileObj;
    UINT uLen;
    short iMediaType;
    PVOID    pAudioFormatInfo;
    PVOID    pVideoFormatInfo;
    HPALETTE    hPal;
    HBITMAP     hDispBMP;
    HICON        hIcon;
    PMMINFOLIST pInfoList;
    } mmpsh, * PMMPSH;

/*
 ***************************************************************
 * Defines
 ***************************************************************
 */
#define MIDICOPYRIGHTSTR    pAudioFormatInfo
#define MIDISEQNAMESTR      pVideoFormatInfo

#define MAXNUMSTREAMS   50

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
int       g_cRef          = 0;

SZCODE cszWavExt[]  = TEXT(".WAV");
SZCODE cszMIDIExt[] = TEXT(".MID");
SZCODE cszRMIExt[]  = TEXT(".RMI");
SZCODE cszAVIExt[]  = TEXT(".AVI");
SZCODE cszASFExt[]  = TEXT(".ASF");
SZCODE cszSlash[]   = TEXT("\\");

static SZCODE aszMIDIDev[] = TEXT("sequencer");

static TCHAR szDetailsTab[64];
static TCHAR szPreviewTab[64];

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */
LPTSTR PASCAL NiceName(LPTSTR sz, BOOL fNukePath);

/*
 ***************************************************************
 ***************************************************************
 */

DWORD mmpshGetFileSize(LPTSTR szFile)
{
    HANDLE hFile;
    OFSTRUCT of;
    DWORD dwSize = 0;

    hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ,NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        dwSize = GetFileSize(hFile, NULL);
        CloseHandle(hFile);
    }
    return dwSize;
}

STATIC void ReleaseInfoList(PMMPSH pmmpsh)
{
    PMMINFOLIST pCur;

    pCur = pmmpsh->pInfoList;
    while (pCur)
    {
        PMMINFOLIST pTmp;

        pTmp = pCur;
        pCur = pCur->pNext;
        LocalFree((HLOCAL)pTmp->pszInfo);
        LocalFree((HLOCAL)pTmp);
    }
    pmmpsh->pInfoList = NULL;
}


STATIC BOOL AddInfoToList(PMMPSH pmmpsh, LPSTR pInfo, FOURCC ckid)
{
    PMMINFOLIST pCur;
    int idStr;

    for (pCur = pmmpsh->pInfoList; pCur && pCur->pNext ; pCur = pCur->pNext)
        if (pCur->ckid == ckid)
            return TRUE;

    if (!pCur)
    {
        pCur = pmmpsh->pInfoList = (PMMINFOLIST)LocalAlloc(LPTR, sizeof(MMINFOLIST));
    }
    else
    {
        pCur->pNext = (PMMINFOLIST)LocalAlloc(LPTR, sizeof(MMINFOLIST));
        pCur = pCur->pNext;
    }
    if (!pCur)
        return FALSE;

    pCur->ckid = ckid;
    pCur->pszInfo = pInfo;

    switch (ckid)
    {
        case FOURCC_INAM:
            idStr = IDS_FOURCC_INAM;
            break;
        case FOURCC_ICOP:
            idStr = IDS_FOURCC_ICOP;
            break;
        case FOURCC_ICMT:
            idStr = IDS_FOURCC_ICMT;
            break;
        case FOURCC_ISBJ:
            idStr = IDS_FOURCC_ISBJ;
            break;
        case FOURCC_ICRD:
            idStr = IDS_FOURCC_ICRD;
            break;
        case FOURCC_IART:
            idStr = IDS_FOURCC_IART;
            break;
        case FOURCC_DISP:
            idStr = IDS_FOURCC_DISP;
            break;
        case FOURCC_ICMS:
            idStr = IDS_FOURCC_ICMS;
            break;
        case FOURCC_ICRP:
            idStr = IDS_FOURCC_ICRP;
            break;
        case FOURCC_IDIM:
            idStr = IDS_FOURCC_IDIM;
            break;
        case FOURCC_IDPI:
            idStr = IDS_FOURCC_IDPI;
            break;
        case FOURCC_IENG:
            idStr = IDS_FOURCC_IENG;
            break;
        case FOURCC_IGNR:
            idStr = IDS_FOURCC_IGNR;
            break;
        case FOURCC_IKEY:
            idStr = IDS_FOURCC_IKEY;
            break;
        case FOURCC_ILGT:
            idStr = IDS_FOURCC_ILGT;
            break;
        case FOURCC_IARL:
            idStr = IDS_FOURCC_IARL;
            break;
        case FOURCC_IMED:
            idStr = IDS_FOURCC_IMED;
            break;
        case FOURCC_IPLT:
            idStr = IDS_FOURCC_IPLT;
            break;
        case FOURCC_IPRD:
            idStr = IDS_FOURCC_IPRD;
            break;
        case FOURCC_ISFT:
            idStr = IDS_FOURCC_ISFT;
            break;
        case FOURCC_ISHP:
            idStr = IDS_FOURCC_ISHP;
            break;
        case FOURCC_ISRC:
            idStr = IDS_FOURCC_ISRC;
            break;
        case FOURCC_ISRF:
            idStr = IDS_FOURCC_ISRF;
            break;
        case FOURCC_ITCH:
            idStr = IDS_FOURCC_ITCH;
            break;
    }
    if (idStr)
        LoadString(ghInstance, idStr, pCur->szInfoDesc, sizeof(pCur->szInfoDesc)/sizeof(TCHAR));
    return TRUE;
}


typedef    struct tagWaveDesc
{
    DWORD    dSize;
    WORD    wFormatSize;
    NPWAVEFORMATEX    pwavefmt;
}    WAVEDESC,* PWAVEDESC;


STATIC BOOL PASCAL NEAR ReadWaveHeader(HMMIO hmmio,
    PWAVEDESC    pwd)
{
    MMCKINFO    mmckRIFF;
    MMCKINFO    mmck;
    MMRESULT    wError;

    mmckRIFF.fccType = mmioWAVE;
    if (wError = mmioDescend(hmmio, &mmckRIFF, NULL, MMIO_FINDRIFF))
    {
        return FALSE;
    }
    mmck.ckid = mmioFMT;
    if (wError = mmioDescend(hmmio, &mmck, &mmckRIFF, MMIO_FINDCHUNK))
    {
        return FALSE;
    }
    if (mmck.cksize < sizeof(WAVEFORMAT))
    {
        return FALSE;
    }
    pwd->wFormatSize = (WORD)mmck.cksize;
    pwd->pwavefmt = (NPWAVEFORMATEX)LocalAlloc(LPTR, pwd->wFormatSize);
    if (!pwd->pwavefmt)
    {
        return FALSE;
    }
    if ((DWORD)mmioRead(hmmio, (HPSTR)pwd->pwavefmt, mmck.cksize) != mmck.cksize)
    {
        goto RetErr;
    }
    if (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM)
    {
        if (pwd->wFormatSize < sizeof(PCMWAVEFORMAT))
        {
            goto RetErr;
        }
    }
    else if ((pwd->wFormatSize < sizeof(WAVEFORMATEX)) || (pwd->wFormatSize < sizeof(WAVEFORMATEX) + pwd->pwavefmt->cbSize))
    {
        goto RetErr;
    }
    if (wError = mmioAscend(hmmio, &mmck, 0))
    {
        goto RetErr;
    }
    mmck.ckid = mmioDATA;
    if (wError = mmioDescend(hmmio, &mmck, &mmckRIFF, MMIO_FINDCHUNK))
    {
        goto RetErr;
    }
    pwd->dSize = mmck.cksize;
    return TRUE;
RetErr:
    LocalFree((HLOCAL)pwd->pwavefmt);
    pwd->pwavefmt = NULL;
    return FALSE;
}



STATIC void GetWaveInfo(HMMIO hmmio, PMMPSH pmmpsh)
{
    WAVEDESC wd;

    if (!ReadWaveHeader(hmmio, &wd))
        return;

    pmmpsh->uLen = (UINT)MulDiv(wd.dSize, 1000, wd.pwavefmt->nAvgBytesPerSec);
    pmmpsh->pAudioFormatInfo = (PVOID)wd.pwavefmt;
}

STATIC void GetMCIInfo(LPTSTR pszFile, PMMPSH pmmpsh)
{
    TCHAR    szMIDIInfo[MAXSTR];
    MCI_OPEN_PARMS      mciOpen;    /* Structure for MCI_OPEN command */
    DWORD dwFlags;
    DWORD dw;
    UINT wDevID;
    MCI_STATUS_PARMS        mciStatus;
    MCI_SET_PARMS           mciSet;        /* Structure for MCI_SET command */
    MCI_INFO_PARMS          mciInfo;
        /* Open a file with an explicitly specified device */

    memset(&mciOpen, 0x00, sizeof(mciOpen));

    mciOpen.lpstrDeviceType = aszMIDIDev;
    mciOpen.lpstrElementName = pszFile;
    dwFlags = MCI_WAIT | MCI_OPEN_ELEMENT | MCI_OPEN_TYPE;
    dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, dwFlags,(DWORD_PTR)(LPVOID)&mciOpen);
    if (dw)
        return;
    wDevID = mciOpen.wDeviceID;

    mciSet.dwTimeFormat = MCI_FORMAT_MILLISECONDS;

    dw = mciSendCommand(wDevID, MCI_SET, MCI_SET_TIME_FORMAT,
        (DWORD_PTR) (LPVOID) &mciSet);
    if (dw)
    {
        mciSendCommand(wDevID, MCI_CLOSE, 0L, (DWORD_PTR)0);
        return;
    }

    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dw = mciSendCommand(wDevID, MCI_STATUS, MCI_STATUS_ITEM,
        (DWORD_PTR) (LPTSTR) &mciStatus);
    if (dw)
        pmmpsh->uLen = 0;
    else
        pmmpsh->uLen = (UINT)mciStatus.dwReturn;

    mciInfo.dwCallback  = 0;
    mciInfo.lpstrReturn = szMIDIInfo;
    mciInfo.dwRetSize   = sizeof(szMIDIInfo);

    szMIDIInfo[0] = TEXT('\0');

    dw = mciSendCommand(wDevID, MCI_INFO,  MCI_INFO_COPYRIGHT, (DWORD_PTR)(LPVOID)&mciInfo);

    if (dw == 0 && lstrlen(szMIDIInfo))
    {
        pmmpsh->MIDICOPYRIGHTSTR = LocalAlloc(LPTR, lstrlen(szMIDIInfo) + 1);
        if (pmmpsh->MIDICOPYRIGHTSTR)
        {
            lstrcpy((LPTSTR)pmmpsh->MIDICOPYRIGHTSTR, szMIDIInfo);
        }
    }

    mciInfo.lpstrReturn = szMIDIInfo;
    mciInfo.dwRetSize   = sizeof(szMIDIInfo);

    szMIDIInfo[0] = TEXT('\0');

    dw = mciSendCommand(wDevID, MCI_INFO,  MCI_INFO_NAME, (DWORD_PTR)(LPVOID)&mciInfo);

    if (dw == 0 && lstrlen(szMIDIInfo))
    {
        pmmpsh->MIDISEQNAMESTR = LocalAlloc(LPTR, lstrlen(szMIDIInfo) + 1);
        if (pmmpsh->MIDISEQNAMESTR)
        {
            lstrcpy((LPTSTR)pmmpsh->MIDISEQNAMESTR, szMIDIInfo);
        }
    }

    mciSendCommand(wDevID, MCI_CLOSE, 0L, (DWORD)0);

}

STATIC void GetMIDIInfo(LPTSTR pszFile, PMMPSH pmmpsh)
{
    GetMCIInfo(pszFile, pmmpsh);
}

STATIC void ReadAviStreams(LPTSTR pszFile, PMMPSH pmmpsh)
{
    HRESULT     hr;
    PAVIFILE    pfile;
    int         i;
    PAVISTREAM  pavi;
    PAVISTREAM  apavi[MAXNUMSTREAMS];    // the current streams
    AVISTREAMINFO  avis;
    LONG        timeStart;            // cached start, end, length
    LONG        timeEnd;
    int         cpavi;
    TCHAR szDecSep[10];
    TCHAR szListSep[10];

    hr = (HRESULT)AVIFileOpen(&pfile, pszFile, 0, 0L);

    if (FAILED(hr))
    {
        DPF("Unable to open %s", pszFile);
        return;
    }

    for (i = 0; i < MAXNUMSTREAMS; i++)
    {
        if (AVIFileGetStream(pfile, &pavi, 0L, i) != AVIERR_OK)
        {
            break;
        }

        apavi[i] = pavi;
    }

    //
    // See if there are still more streams in the file
    //
    if ((i == MAXNUMSTREAMS) && 
        (AVIFileGetStream(pfile, &pavi, 0L, i) == AVIERR_OK))
    {
        AVIStreamRelease(pavi);
        DPF("Exceeded maximum number of streams");
    }

    //
    // Couldn't get any streams out of this file
    //
    if (i == 0)
    {
        DPF("Unable to open any streams in %s", pszFile);
        if (pfile)
            AVIFileRelease(pfile);
        return;
    }

    cpavi = i;

    //
    // Start with bogus times
    //
    timeStart = 0x7FFFFFFF;
    timeEnd   = 0;

    //bug 141733, get the local decimal and list separators
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_SDECIMAL, szDecSep, sizeof(szDecSep)/sizeof(TCHAR) );
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_SLIST, szListSep, sizeof(szListSep)/sizeof(TCHAR) );

    //
    // Walk through and init all streams loaded
    //
    for (i = 0; i < cpavi; i++)
    {

        AVIStreamInfo(apavi[i], &avis, sizeof(avis));

        switch(avis.fccType)
        {
            case streamtypeVIDEO:
            {
                LONG cbFormat;
                LPVOID lpFormat;
                ICINFO icInfo;
                HIC hic;
                DWORD dwTimeLen;
                DWORD dwSize;
                int iFrameRate;
                TCHAR szFormat[MAXSTR];

                if (pmmpsh->pVideoFormatInfo)
                    break;

                AVIStreamFormatSize(apavi[i], 0, &cbFormat);
                pmmpsh->pVideoFormatInfo = (PVOID)LocalAlloc(LPTR, MAX_PATH);
                if (!pmmpsh->pVideoFormatInfo)
                    break;
                dwSize = mmpshGetFileSize(pszFile);
                dwTimeLen =  (DWORD)(AVIStreamEndTime(apavi[i]) - AVIStreamStartTime(apavi[i]));
                iFrameRate = MulDiv(avis.dwLength, 1000000, dwTimeLen);
                lpFormat = (LPVOID)LocalAlloc(LPTR, cbFormat);
                if (!lpFormat)
                {
                    goto BadFormat;
                }
                AVIStreamReadFormat(apavi[i], 0, lpFormat, &cbFormat);
                hic = (HIC)ICLocate(FOURCC_VIDC, avis.fccHandler, lpFormat, NULL, (WORD)ICMODE_DECOMPRESS);
                if (hic || ((LPBITMAPINFOHEADER)lpFormat)->biCompression == 0)
                {
                    TCHAR szName[48];

                    if (((LPBITMAPINFOHEADER)lpFormat)->biCompression)
                    {
                        ICGetInfo(hic, &icInfo, sizeof(ICINFO));
                        ICClose(hic);
                        //WideCharToMultiByte(CP_ACP, 0, icInfo.szName, -1, szName, sizeof(szName), NULL, NULL);
                        wcscpy(szName,icInfo.szName);
                    }
                    else
                    {
                        LoadString(ghInstance, IDS_UNCOMPRESSED, szName, sizeof(szName)/sizeof(TCHAR));
                    }
                    LoadString(ghInstance, IDS_GOODFORMAT, szFormat, sizeof(szFormat)/sizeof(TCHAR));

                    wsprintf((LPTSTR)pmmpsh->pVideoFormatInfo, szFormat, (avis.rcFrame.right - avis.rcFrame.left),
                                (avis.rcFrame.bottom - avis.rcFrame.top), szListSep, ((LPBITMAPINFOHEADER)lpFormat)->biBitCount, szListSep,
                                avis.dwLength, szListSep, (UINT)(iFrameRate/1000), szDecSep, (UINT)(iFrameRate%1000), szListSep, MulDiv(dwSize, 1000,dwTimeLen)/1024, szListSep, szName);

                    goto GoodFormat;

                }
BadFormat:
                LoadString(ghInstance, IDS_BADFORMAT, szFormat, sizeof(szFormat)/sizeof(TCHAR));
                wsprintf((LPTSTR)pmmpsh->pVideoFormatInfo, szFormat, (avis.rcFrame.right - avis.rcFrame.left),
                                (avis.rcFrame.bottom - avis.rcFrame.top), szListSep,
                                avis.dwLength, szListSep, (UINT)(iFrameRate/1000), szDecSep, (UINT)(iFrameRate%1000), szListSep, MulDiv(dwSize, 1000,dwTimeLen)/1024, szListSep);
GoodFormat:
                LocalFree((HLOCAL)lpFormat);
                break;
            }
            case streamtypeAUDIO:
            {
                LONG        cbFormat;

                AVIStreamFormatSize(apavi[i], 0, &cbFormat);
                pmmpsh->pAudioFormatInfo = (LPVOID)LocalAlloc(LPTR, cbFormat);
                if (!pmmpsh->pAudioFormatInfo)
                    break;
                AVIStreamReadFormat(apavi[i], 0, pmmpsh->pAudioFormatInfo, &cbFormat);
                break;
            }
            default:
                break;
        }

    //
    // We're finding the earliest and latest start and end points for
    // our scrollbar.
    //
        timeStart = (LONG)min(timeStart, AVIStreamStartTime(apavi[i]));
        timeEnd   = (LONG)max(timeEnd, AVIStreamEndTime(apavi[i]));
    }
    pmmpsh->uLen = (UINT)(timeEnd - timeStart);
    DPF("The file length is %d \r\n", pmmpsh->uLen);

    for (i = 0; i < cpavi; i++)
    {
        AVIStreamRelease(apavi[i]);
    }
    AVIFileRelease(pfile);
}


STATIC void GetAVIInfo(LPTSTR pszFile, PMMPSH pmmpsh)
{
    if (!LoadAVI())
    {
        DPF("****Load AVI failed**\r\n");
        ASSERT(FALSE);
        return;
    }
    if (!LoadVFW())
    {
        DPF("****Load VFW failed**\r\n");
        ASSERT(FALSE);
        FreeAVI();
        return;
    }
    AVIFileInit();
    ReadAviStreams(pszFile, pmmpsh);
    AVIFileExit();
    if (!FreeVFW())
    {
        DPF("****Free VFW failed**\r\n");
        ASSERT(FALSE);
    }
    if (!FreeAVI())
    {
        DPF("****Free AVI failed**\r\n");
        ASSERT(FALSE);
    }
}

STATIC void GetASFInfo(LPTSTR pszFile, PMMPSH pmmpsh)
{
}




STATIC void GetMediaInfo(HMMIO hmmio, PMMPSH pmmpsh)
{
    switch (pmmpsh->iMediaType)
    {
        case MT_WAVE:
            GetWaveInfo(hmmio, pmmpsh);
            break;
        case MT_MIDI:
            GetMIDIInfo(pmmpsh->pszFileObj, pmmpsh);
            break;
        case MT_AVI:
            GetAVIInfo(pmmpsh->pszFileObj, pmmpsh);
            break;
        case MT_ASF:
            GetASFInfo(pmmpsh->pszFileObj, pmmpsh);
            break;
    }
}

STATIC HANDLE PASCAL GetRiffAll(PMMPSH pmmpsh)
{
    MMCKINFO    ck;
    MMCKINFO    ckINFO;
    MMCKINFO    ckRIFF;
    HANDLE    h = NULL;
    LONG        lSize;
    DWORD       dw;
    HMMIO   hmmio;
    BOOL     fDoneDISP;
    BOOL     fDoneINFO;
    BOOL    fDoneName;
    LPSTR pInfo;

    hmmio = mmioOpen(pmmpsh->pszFileObj, NULL, MMIO_ALLOCBUF | MMIO_READ);

    if (!hmmio)
        goto error;

    GetMediaInfo(hmmio, pmmpsh);
    if (pmmpsh->uLen == 0)
        goto error;
    mmioSeek(hmmio, 0, SEEK_SET);

    /* descend the input file into the RIFF chunk */
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
        goto error;

    if (ckRIFF.ckid != FOURCC_RIFF)
        goto error;

    fDoneDISP = fDoneINFO = fDoneName = FALSE;
    while (!(fDoneDISP && fDoneINFO) && !mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        if (ck.ckid == FOURCC_DISP)
        {
            /* Read dword into dw, break if read unsuccessful */
            if (mmioRead(hmmio, (LPVOID)&dw, sizeof(dw)) != (LONG)sizeof(dw))
                goto error;

            /* Find out how much memory to allocate */
            lSize = ck.cksize - sizeof(dw);
            if ((int)dw == CF_DIB && h == NULL)
            {
                /* get a handle to memory to hold the description and
                    lock it down */

                if ((h = GlobalAlloc(GHND, lSize+4)) == NULL)
                    goto error;

                if (mmioRead(hmmio, GlobalLock(h), lSize) != lSize)
                    goto error;

                fDoneDISP = TRUE;
            }
            else if ((int)dw == CF_TEXT)
            {
                pInfo = (LPSTR)LocalAlloc(LPTR, lSize+1);//+1 not required I think
                if (!pInfo)
                    goto error;

                if (!mmioRead(hmmio, pInfo,  lSize))
                    goto error;

                AddInfoToList(pmmpsh, pInfo, ck.ckid );
                fDoneName = TRUE;

            }

        }
        else if (ck.ckid    == FOURCC_LIST &&
                 ck.fccType == FOURCC_INFO &&
                 !fDoneINFO)
        {
            while (!mmioDescend(hmmio, &ckINFO, &ck, 0))
            {
                switch (ckINFO.ckid)
                {
                    case FOURCC_ISBJ:
                    case FOURCC_INAM:
                    case FOURCC_ICOP:
                    case FOURCC_ICRD:
                    case FOURCC_IART:
                    case FOURCC_ICMS:
                    case FOURCC_ICMT:
                    case FOURCC_ICRP:
                    case FOURCC_IDIM:
                    case FOURCC_IARL:
                    case FOURCC_IDPI:
                    case FOURCC_IENG:
                    case FOURCC_IGNR:
                    case FOURCC_IKEY:
                    case FOURCC_ILGT:
                    case FOURCC_IMED:
                    case FOURCC_IPLT:
                    case FOURCC_IPRD:
                    case FOURCC_ISFT:
                    case FOURCC_ISHP:
                    case FOURCC_ISRC:
                    case FOURCC_ISRF:
                    case FOURCC_ITCH:
                        pInfo = (LPSTR)LocalAlloc(LPTR, ck.cksize+1);//+1 not required I think
                        if (!pInfo)
                            goto error;

                        if (!mmioRead(hmmio, pInfo,  ck.cksize))
                            goto error;

                        AddInfoToList(pmmpsh, pInfo, ckINFO.ckid);
                        if (ckINFO.ckid == FOURCC_INAM)
                            fDoneName = TRUE;
                        break;
                }

                if (mmioAscend(hmmio, &ckINFO, 0))
                    break;
            }
        }


        /* Ascend so that we can descend into next chunk
         */
        if (mmioAscend(hmmio, &ck, 0))
            break;
    }

    goto exit;

error:
    if (h)
    {
        GlobalUnlock(h);
        GlobalFree(h);
    }
    h = NULL;
    ReleaseInfoList(pmmpsh);

exit:
    if (hmmio)
        mmioClose(hmmio,0);
    return h;
}

STATIC BOOL PASCAL WaveGetFormatDescription
(
    LPWAVEFORMATEX          pwfx,
    LPTSTR                   pszDesc
)
{
    UINT_PTR             mmr;
    TCHAR                pszFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    TCHAR                pszFormat[ACMFORMATDETAILS_FORMAT_CHARS];
    BOOL                bRet = FALSE;
    TCHAR                szListSep[10];
    //
    //  get the name for the format tag of the specified format
    //

    if (!pwfx)
    {
        pszDesc[0] = TEXT('\0');
        return TRUE;
    }
    if (!LoadACM())
    {
        DPF("****Load ACM failed**\r\n");
        ASSERT(FALSE);
        return FALSE;
    }
    if (NULL != pszFormatTag)
    {
       PACMFORMATTAGDETAILSW paftd;

        //
        //  initialize all unused members of the ACMFORMATTAGDETAILS
        //  structure to zero
        //
        paftd = (PACMFORMATTAGDETAILSW)LocalAlloc(LPTR, sizeof(ACMFORMATTAGDETAILSW));
        if (!paftd)
            goto RetErr;
        //
        //  fill in the required members of the ACMFORMATTAGDETAILS
        //  structure for the ACM_FORMATTAGDETAILSF_FORMATTAG query
        //
        paftd->cbStruct    = sizeof(ACMFORMATTAGDETAILSW);
        paftd->dwFormatTag = pwfx->wFormatTag;

        //
        //  ask the ACM to find the first available driver that
        //  supports the specified format tag
        //
        mmr = acmFormatTagDetails(NULL,
                                  paftd,
                                  ACM_FORMATTAGDETAILSF_FORMATTAG);
        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  copy the format tag name into the caller's buffer
            //
            lstrcpy(pszFormatTag, paftd->szFormatTag);
        }
        else
        {
            static const struct _wfm_names {
                UINT   uFormatTag;
                UINT   uIDS;
                } aWaveFmtNames[] = {
                WAVE_FORMAT_PCM,                 IDS_FORMAT_PCM,
                WAVE_FORMAT_ADPCM,               IDS_FORMAT_ADPCM,
                WAVE_FORMAT_IBM_CVSD,            IDS_FORMAT_IBM_CVSD,
                WAVE_FORMAT_ALAW,                IDS_FORMAT_ALAW,
                WAVE_FORMAT_MULAW,               IDS_FORMAT_MULAW,
                WAVE_FORMAT_OKI_ADPCM,           IDS_FORMAT_OKI_ADPCM,
                WAVE_FORMAT_IMA_ADPCM,           IDS_FORMAT_IMA_ADPCM,
                WAVE_FORMAT_MEDIASPACE_ADPCM,    IDS_FORMAT_MEDIASPACE_ADPCM,
                WAVE_FORMAT_SIERRA_ADPCM,        IDS_FORMAT_SIERRA_ADPCM,
                WAVE_FORMAT_G723_ADPCM,          IDS_FORMAT_G723_ADPCM,
                WAVE_FORMAT_DIGISTD,             IDS_FORMAT_DIGISTD,
                WAVE_FORMAT_DIGIFIX,             IDS_FORMAT_DIGIFIX,
                WAVE_FORMAT_YAMAHA_ADPCM,        IDS_FORMAT_YAMAHA_ADPCM,
                WAVE_FORMAT_SONARC,              IDS_FORMAT_SONARC,
                WAVE_FORMAT_DSPGROUP_TRUESPEECH, IDS_FORMAT_DSPGROUP_TRUESPEECH,
                WAVE_FORMAT_ECHOSC1,             IDS_FORMAT_ECHOSC1,
                WAVE_FORMAT_AUDIOFILE_AF36,      IDS_FORMAT_AUDIOFILE_AF36,
                WAVE_FORMAT_APTX,                IDS_FORMAT_APTX,
                WAVE_FORMAT_AUDIOFILE_AF10,      IDS_FORMAT_AUDIOFILE_AF10,
                WAVE_FORMAT_DOLBY_AC2,           IDS_FORMAT_DOLBY_AC2,
                WAVE_FORMAT_GSM610,              IDS_FORMAT_GSM610,
                WAVE_FORMAT_G721_ADPCM,          IDS_FORMAT_G721_ADPCM,
                WAVE_FORMAT_CREATIVE_ADPCM,      IDS_FORMAT_CREATIVE_ADPCM,
                0,                               IDS_UNKFORMAT,
                };
                UINT ii;

            //
            // no ACM driver is available that supports the
            // specified format tag. look up the tag id
            // in our table of tag names (above)
            //
            for (ii = 0; aWaveFmtNames[ii].uFormatTag; ii++)
                if (pwfx->wFormatTag == aWaveFmtNames[ii].uFormatTag)
                    break;
            LoadString(ghInstance, aWaveFmtNames[ii].uIDS, pszFormatTag, ACMFORMATTAGDETAILS_FORMATTAG_CHARS);
        }
        LocalFree((HLOCAL)paftd);
    }

    //
    //  get the description of the attributes for the specified
    //  format
    //
    if (NULL != pszFormat)
    {
        PACMFORMATDETAILSW    pafd;

        //
        //  initialize all unused members of the ACMFORMATDETAILS
        //  structure to zero
        //
        pafd = (PACMFORMATDETAILSW)LocalAlloc(LPTR, sizeof(ACMFORMATDETAILSW));
        if (!pafd)
            goto RetErr;

        //
        //  fill in the required members of the ACMFORMATDETAILS
        //  structure for the ACM_FORMATDETAILSF_FORMAT query
        //
        pafd->cbStruct    = sizeof(ACMFORMATDETAILSW);
        pafd->dwFormatTag = pwfx->wFormatTag;
        pafd->pwfx        = pwfx;

        //
        //  the cbwfx member must be initialized to the total size
        //  in bytes needed for the specified format. for a PCM
        //  format, the cbSize member of the WAVEFORMATEX structure
        //  is not valid.
        //
        if (WAVE_FORMAT_PCM == pwfx->wFormatTag)
        {
            pafd->cbwfx   = sizeof(PCMWAVEFORMAT);
        }
        else
        {
            pafd->cbwfx   = sizeof(WAVEFORMATEX) + pwfx->cbSize;
        }

        //
        //  ask the ACM to find the first available driver that
        //  supports the specified format
        //
        mmr = acmFormatDetails(NULL, pafd, ACM_FORMATDETAILSF_FORMAT);
        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  copy the format attributes description into the caller's
            //  buffer
            //
            lstrcpy(pszFormat, pafd->szFormat);
        }
        else
        {
            pszFormat[0] = TEXT('\0');
        }
        LocalFree((HLOCAL)pafd);
    }
    //bug 141733, get the local decimal and list separators
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_SLIST, szListSep, sizeof(szListSep)/sizeof(TCHAR) );
    wsprintf(pszDesc, TEXT("%s%s %s"), pszFormatTag, szListSep, pszFormat);
    bRet = TRUE;

RetErr:
    if (!FreeACM())
    {
        DPF("****Free ACM failed**\r\n");
        ASSERT(FALSE);
    }
    return bRet;
} // AcmAppGetFormatDescription()



STATIC void ShowInfoList(PMMPSH pmmpsh, HWND hDlg)
{
    PMMINFOLIST pCur;
    TCHAR* szTemp;
    HWND hwndLB = GetDlgItem(hDlg, IDD_INFO_NAME);
    TCHAR szNoCopyRight[MAXSTR];
    int iIndex;

    LoadString(ghInstance, IDS_NOCOPYRIGHT, szNoCopyRight, sizeof(szNoCopyRight)/sizeof(TCHAR));
    SetDlgItemText(hDlg, IDD_COPYRIGHT, szNoCopyRight);
    if (!pmmpsh->pInfoList)
    {
        DestroyWindow(GetDlgItem(hDlg, IDC_DETAILSINFO_GRP));
        DestroyWindow(GetDlgItem(hDlg, IDC_ITEMSLABEL));
        DestroyWindow(GetDlgItem(hDlg, IDC_DESCLABEL));
        DestroyWindow(GetDlgItem(hDlg, IDD_INFO_NAME));
        DestroyWindow(GetDlgItem(hDlg, IDD_INFO_VALUE));
        return;
    }
    for (pCur = pmmpsh->pInfoList; pCur; pCur = pCur->pNext)
    {
        int nTempSize = (strlen(pCur->pszInfo)*sizeof(TCHAR))+sizeof(TCHAR);
        szTemp = (LPTSTR)LocalAlloc(LPTR, nTempSize);
		if (!szTemp) return;

        MultiByteToWideChar(GetACP(), 0,
                            pCur->pszInfo, -1,
                            szTemp, nTempSize);

        if (pCur->ckid == FOURCC_ICOP)
        {
            SetDlgItemText(hDlg, IDD_COPYRIGHT, szTemp);
            LocalFree(szTemp);
            continue;
        }
        iIndex = ListBox_AddString(hwndLB, pCur->szInfoDesc);
        if (iIndex != LB_ERR)
        {
            //reassigning wide pointer back into "info" so it will get cleaned up later
            pCur->pszInfo = (LPSTR)szTemp;
            ListBox_SetItemData(hwndLB, iIndex, (LPARAM)pCur->pszInfo);
        }
    }
    SetFocus(hwndLB);
    if (ListBox_SetCurSel(hwndLB, 0) != LB_ERR)
        FORWARD_WM_COMMAND(hDlg, IDD_INFO_NAME, hwndLB, LBN_SELCHANGE, PostMessage);
}

BOOL PASCAL DoDetailsCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {

    case ID_APPLY:
        return TRUE;

    case IDOK:
        break;

    case IDCANCEL:
        break;

    case ID_INIT:
    {
        PMMPSH pmmpsh = (PMMPSH)GetWindowLongPtr(hDlg, DWLP_USER);


        if (pmmpsh->hDispBMP)
        {
            HWND hwndDisp = GetDlgItem(hDlg,IDD_DISPFRAME);
            HDC hdc;
            HPALETTE hpalT;
            int i;

            SendMessage(hwndDisp, (UINT)DF_PM_SETBITMAP, (WPARAM)pmmpsh->hDispBMP,
                                                                (LPARAM)pmmpsh->hPal);

            /*
            * If realizing the palette causes the palette to change,
            * redraw completely.
            */

            hdc = GetDC(hwndDisp);
            hpalT = SelectPalette (hdc, pmmpsh->hPal, FALSE);

            i = RealizePalette(hdc); /* i == entries that changed  */

            SelectPalette (hdc, hpalT, FALSE);
            ReleaseDC(hwndDisp, hdc);


            /* If any palette entries changed, repaint the window. */

            if (i > 0)
            {
                InvalidateRect(hwndDisp, NULL, TRUE);
            }
        }
        break;
    }

    case IDD_INFO_NAME:
        if (codeNotify == LBN_SELCHANGE)
        {
            int iIndex = ListBox_GetCurSel(hwndCtl);
            LPTSTR pszInfo = (LPTSTR)ListBox_GetItemData(hwndCtl, iIndex);

            SetDlgItemText(hDlg, IDD_INFO_VALUE, pszInfo);
        }
        break;
    }
    return FALSE;
}


STATIC void ShowMediaLen(PMMPSH pmmpsh, HWND hwnd)
{
    TCHAR szBuf[MAXSTR];
    TCHAR szFmt[MAXSTR];
    UINT uMin;
    UINT uSec;
    UINT umSec;
    UINT uLen;
    TCHAR szDecSep[10];

    uLen = pmmpsh->uLen;

    if ((!uLen && pmmpsh->iMediaType != MT_WAVE) || (!pmmpsh->pAudioFormatInfo && pmmpsh->iMediaType != MT_MIDI && pmmpsh->iMediaType != MT_AVI && pmmpsh->iMediaType != MT_ASF))
    {
        LoadString(ghInstance, IDS_BADFILE, szBuf, sizeof(szBuf)/sizeof(TCHAR));
        SetWindowText(hwnd, szBuf);
        return;
    }
    uMin = (UINT)(uLen/60000);
    uSec = (UINT)((uLen/1000) % 60);
    umSec = (UINT)(uLen % 1000);

    //bug 141733, get the local decimal separator
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_SDECIMAL, szDecSep, sizeof(szDecSep)/sizeof(TCHAR) );

    if (uMin)
    {

        LoadString(ghInstance, IDS_MINFMT, szFmt, sizeof(szFmt)/sizeof(TCHAR));
        wsprintf(szBuf, szFmt, uMin, uSec, szDecSep, umSec);
    }
    else
    {

        LoadString(ghInstance, IDS_SECFMT, szFmt, sizeof(szFmt)/sizeof(TCHAR));
        wsprintf(szBuf, szFmt, uSec, szDecSep, umSec);
    }
    SetWindowText(hwnd, szBuf);
}


STATIC void ShowMediaFormat(PMMPSH pmmpsh, HWND hDlg)
{
    switch (pmmpsh->iMediaType)
    {
        case MT_WAVE:
        {
            TCHAR szDesc[MAX_PATH];

            szDesc[0] = TEXT('\0');
            WaveGetFormatDescription((LPWAVEFORMATEX)pmmpsh->pAudioFormatInfo, szDesc);
            SetDlgItemText(hDlg, IDD_AUDIOFORMAT, szDesc);
            DestroyWindow(GetDlgItem(hDlg, IDD_VIDEOFORMAT));
            DestroyWindow(GetDlgItem(hDlg, IDD_VIDEOFORMATLABEL));
            DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCELABEL));
            DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCENAME));
            break;
        }
        case MT_MIDI:
            DestroyWindow(GetDlgItem(hDlg, IDD_AUDIOFORMAT));
            DestroyWindow(GetDlgItem(hDlg, IDD_AUDIOFORMATLABEL));
            DestroyWindow(GetDlgItem(hDlg, IDD_VIDEOFORMAT));
            DestroyWindow(GetDlgItem(hDlg, IDD_VIDEOFORMATLABEL));
            if (pmmpsh->MIDICOPYRIGHTSTR)
                SetDlgItemText(hDlg, IDD_COPYRIGHT, (LPTSTR)pmmpsh->MIDICOPYRIGHTSTR);
            if (pmmpsh->MIDISEQNAMESTR)
                SetDlgItemText(hDlg, IDD_MIDISEQUENCENAME, (LPTSTR)pmmpsh->MIDISEQNAMESTR);
            else
            {
                DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCELABEL));
                DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCENAME));
            }
            break;
        case MT_AVI:
        {
            TCHAR szDesc[MAX_PATH];

            DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCELABEL));
            DestroyWindow(GetDlgItem(hDlg, IDD_MIDISEQUENCENAME));

            szDesc[0] = TEXT('\0');
            if (pmmpsh->pVideoFormatInfo)
                SetDlgItemText(hDlg, IDD_VIDEOFORMAT, (LPTSTR)pmmpsh->pVideoFormatInfo);
            else
                SetDlgItemText(hDlg, IDD_VIDEOFORMAT, (LPTSTR)szDesc);
            WaveGetFormatDescription((LPWAVEFORMATEX)pmmpsh->pAudioFormatInfo, szDesc);
            SetDlgItemText(hDlg, IDD_AUDIOFORMAT, szDesc);
            break;
        }
        case MT_ASF:
        {
            break;
        }
    }
}

const static DWORD aFileDetailsIds[] = {  // Context Help IDs
    IDD_DISPFRAME,          NO_HELP,
    IDD_DISP_ICON,          IDH_FPROP_GEN_ICON,
    IDD_FILENAME,           IDH_FPROP_GEN_NAME,
    IDD_CRLABEL,            IDH_FCAB_MM_COPYRIGHT,
    IDD_COPYRIGHT,          IDH_FCAB_MM_COPYRIGHT,
    IDD_LENLABEL,           IDH_FCAB_MM_FILELEN,
    IDD_FILELEN,            IDH_FCAB_MM_FILELEN,
    IDD_AUDIOFORMATLABEL,   IDH_FCAB_MM_AUDIOFORMAT,
    IDD_AUDIOFORMAT,        IDH_FCAB_MM_AUDIOFORMAT,
    IDD_MIDISEQUENCELABEL,  IDH_FCAB_MM_MIDISEQUENCENAME,
    IDD_MIDISEQUENCENAME,   IDH_FCAB_MM_MIDISEQUENCENAME,
    IDD_VIDEOFORMATLABEL,   IDH_FCAB_MM_VIDEOFORMAT,
    IDD_VIDEOFORMAT,        IDH_FCAB_MM_VIDEOFORMAT,
    IDC_DETAILSINFO_GRP,    IDH_FCAB_MM_DETAILSINFO,
    IDC_ITEMSLABEL,         IDH_FCAB_MM_DETAILSINFO,
    IDC_DESCLABEL,          IDH_FCAB_MM_DETAILSINFO,
    IDD_INFO_NAME,          IDH_FCAB_MM_DETAILSINFO,
    IDD_INFO_VALUE,         IDH_FCAB_MM_DETAILSINFO,

    0, 0
};

INT_PTR CALLBACK FileDetailsDlg(HWND hDlg, UINT uMsg, WPARAM wParam,
                                                            LPARAM lParam)
{
    NMHDR FAR   *lpnm;

    switch (uMsg)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                    break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;
            }
            break;

        case WM_INITDIALOG:
        {
            PMMPSH pmmpsh = (PMMPSH)(((LPPROPSHEETPAGE)lParam)->lParam);
            TCHAR szFile[MAX_PATH];
            HANDLE hDib = NULL;
            HCURSOR hCursor;

            hCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));

            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pmmpsh);

            if (!pmmpsh->pInfoList)
            {
                hDib = GetRiffAll(pmmpsh);
            }

			if (!hDib)
				break;

            pmmpsh->hPal = bmfCreateDIBPalette(hDib);
            pmmpsh->hDispBMP = bmfBitmapFromDIB(hDib, pmmpsh->hPal);
            if (hDib)
            {
                GlobalUnlock(hDib);
                hDib = GlobalFree(hDib);
            }
            if (!pmmpsh->hDispBMP)
            {
                int iIconID;

                switch (pmmpsh->iMediaType)
                {
                    case MT_WAVE:
                        iIconID = IDI_DWAVE;
                        break;
                    case MT_MIDI:
                        iIconID = IDI_DMIDI;
                        break;
                    case MT_AVI:
                    case MT_ASF:
                        iIconID = IDI_DVIDEO;
                        break;
                }
                DestroyWindow(GetDlgItem(hDlg,IDD_DISPFRAME));
                pmmpsh->hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(iIconID));
                Static_SetIcon(GetDlgItem(hDlg, IDD_DISP_ICON), pmmpsh->hIcon);
            }
            else
            {
                DestroyWindow(GetDlgItem(hDlg,IDD_DISP_ICON));
                //SendDlgItemMessage(hDlg, (int)IDD_DISPFRAME, (UINT)DF_PM_SETBITMAP, (WPARAM)pmmpsh->hDispBMP,
                //                                                (LPARAM)pmmpsh->hPal);
            }

            lstrcpy(szFile, pmmpsh->pszFileObj);
            NiceName(szFile, TRUE);
            SetDlgItemText(hDlg, IDD_FILENAME, szFile);

            ShowMediaLen(pmmpsh, GetDlgItem(hDlg, IDD_FILELEN));
            ShowInfoList(pmmpsh, hDlg);
            ShowMediaFormat(pmmpsh, hDlg);
            SetCursor(hCursor);
            break;
        }

        case WM_DESTROY:
        {
            PMMPSH pmmpsh = (PMMPSH)GetWindowLongPtr(hDlg, DWLP_USER);

            if (pmmpsh->hDispBMP)
                DeleteObject(pmmpsh->hDispBMP);
            if (pmmpsh->hIcon)
                DestroyIcon(pmmpsh->hIcon);
            if (pmmpsh->hPal)
                DeleteObject(pmmpsh->hPal);
            if (pmmpsh->pAudioFormatInfo)
                LocalFree((HLOCAL)pmmpsh->pAudioFormatInfo);
            if (pmmpsh->pVideoFormatInfo)
                LocalFree((HLOCAL)pmmpsh->pVideoFormatInfo);
            break;
        }

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, gszWindowsHlp, HELP_CONTEXTMENU,
                                            (UINT_PTR)(LPTSTR)aFileDetailsIds);
            return TRUE;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszWindowsHlp, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aFileDetailsIds);
            return TRUE;

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoDetailsCommand);
            break;
    }
    return FALSE;
}


static DWORD aPreviewIds[] = {  // Context Help IDs
    0,                      IDH_FCAB_MM_PREVIEW_CONTROL,
    IDD_DISP_ICON,          IDH_FPROP_GEN_ICON,
    IDD_FILENAME,           IDH_FPROP_GEN_NAME,

    0, 0
};

INT_PTR CALLBACK PreviewDlg(HWND hDlg, UINT uMsg, WPARAM wParam,
                                                            LPARAM lParam)
{
    static BOOL fLoadedVFW;
    static HICON hIcon;
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            NMHDR FAR   *lpnm;

            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                {
                    HWND hwndMCI = (HWND)GetWindowLongPtr(hDlg, DWLP_USER);

                    DPF("***PSN_KILLACTIVE***\r\n");
                    if (IsWindow(hwndMCI))
                         MCIWndStop(hwndMCI);
                    break;
                }

                case PSN_APPLY:
                    DPF("***PSN_APPLY***\r\n");
                    return TRUE;

            }
            break;
        }

        case WM_INITDIALOG:
        {
            PMMPSH pmmpsh = (PMMPSH)(((LPPROPSHEETPAGE)lParam)->lParam);
            HCURSOR hCursor;
            HWND     hwndMCI;
            HWND    hwndTitle;
            RECT    rcWnd;
            RECT     rcDlg;
            TCHAR     szFile[MAX_PATH];
            TCHAR    szTitle[MAXSTR];
            TCHAR    szTmp[MAXSTR];
#ifndef DEBUG_BUILT_LINKED
            FN_MCIWNDCREATE fnMCIWndCreate;
#endif

            hCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));
            lstrcpy(szFile, pmmpsh->pszFileObj);
            NiceName(szFile, TRUE);
            LoadString(ghInstance, IDS_PREVIEWOF, szTmp, sizeof(szTmp)/sizeof(TCHAR));
            wsprintf(szTitle, szTmp, szFile);
            hwndTitle = GetDlgItem(hDlg, IDD_FILENAME);
            SetWindowText(hwndTitle, szTitle);

            fLoadedVFW = FALSE;
            if (!LoadVFW())
            {
                DPF("****Load VFW failed**\r\n");
                ASSERT(FALSE);
                break;
            }
            fLoadedVFW = TRUE;
#ifndef DEBUG_BUILT_LINKED
            fnMCIWndCreate = (FN_MCIWNDCREATE)MCIWndCreateW;
            hwndMCI = fnMCIWndCreate(hDlg, ghInstance, (DWORD)MCIWNDF_NOMENU, (LPCTSTR)pmmpsh->pszFileObj);
#else
            hwndMCI = MCIWndCreateW(hDlg, ghInstance, (DWORD)MCIWNDF_NOMENU, (LPCTSTR)pmmpsh->pszFileObj);
#endif
            aPreviewIds[0] = GetDlgCtrlID(hwndMCI);
            GetWindowRect(hwndMCI, &rcWnd);
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rcWnd, 2);
            GetWindowRect(hDlg, &rcDlg);
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rcDlg, 2);
            hIcon = NULL;
            switch (pmmpsh->iMediaType)
            {
                case MT_WAVE:
                case MT_MIDI:
                {
                    int ircWndTop;

                    ircWndTop = (int)((rcDlg.bottom - rcDlg.top)/2) - 50;
                    rcWnd.top +=  ircWndTop;
                    rcWnd.bottom += ircWndTop;
                    rcWnd.left = 20;
                    rcWnd.right = rcDlg.right - 20;

                    MoveWindow(hwndMCI,  rcWnd.left, rcWnd.top, (rcWnd.right - rcWnd.left),
                                        (rcWnd.bottom - rcWnd.top), FALSE);
                    GetWindowRect(hwndTitle, &rcWnd);
                    MapWindowPoints(NULL, hDlg, (LPPOINT)&rcWnd, 2);
                    OffsetRect(&rcWnd, 52, 36);
                    MoveWindow(hwndTitle,  rcWnd.left, rcWnd.top, (rcWnd.right - rcWnd.left),
                                        (rcWnd.bottom - rcWnd.top), FALSE);
                    hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_DWAVE+pmmpsh->iMediaType-1));
                    Static_SetIcon(GetDlgItem(hDlg, IDD_DISP_ICON),hIcon);

                    break;
                }
                case MT_AVI:
                {
                     int iDlgHt = rcDlg.bottom - rcDlg.top -15;     //15 for the title
                    int iDlgWth = rcDlg.right - rcDlg.left;
                    int iWndHt = rcWnd.bottom - rcWnd.top;
                    int iWndWth = rcWnd.right - rcWnd.left;

                    DestroyWindow(GetDlgItem(hDlg, IDD_DISP_ICON));
                    if (iWndWth < iDlgWth && iWndHt < iDlgHt)
                    {
                        int ixOff = (int)((iDlgWth - iWndWth)/2);
                        int iyOff = (int)((iDlgHt - iWndHt)/2) + 15;

                        OffsetRect(&rcWnd, ixOff, iyOff);
                        MoveWindow(hwndMCI,  rcWnd.left, rcWnd.top, (rcWnd.right - rcWnd.left),
                                        (rcWnd.bottom - rcWnd.top), FALSE);
                    }
                    else
                    {
                        int ixExcess = iWndWth - iDlgWth;
                        int iyExcess = iWndHt - (iDlgHt - 15); //Take another 15 off
                        int ixOff;
                        int iyOff;
                        RECT     rcSource;
                        RECT    rcDest;
                        RECT    rcDestWnd;

                        MCIWndGetDest(hwndMCI, &rcSource);
                        //DPF("The Video Window is too big: SHRINKING\r\nrcSource = %d,%d,%d%d ** rcWnd=%d,%d,%d,%d ** rcDlg=%d,%d,%d,%d\r\n",
                        //    rcSource.left,rcSource.top,rcSource.right,rcSource.bottom,
                        //    rcWnd.left,rcWnd.top,rcWnd.right,rcWnd.bottom,
                        //    rcDlg.left,rcDlg.top,rcDlg.right,rcDlg.bottom);
                        rcDest.top = rcSource.top;          // new boundaries
                        rcDest.left = rcSource.left;
                        if (ixExcess > iyExcess)
                        {
                            rcDest.right = rcSource.left +
                                (((rcSource.right - rcSource.left)*(iDlgWth - 20))/iWndWth);
                            rcDest.bottom = rcSource.top +
                                (((rcSource.bottom - rcSource.top)*(iDlgWth - 20))/iWndWth);
                            //DPF("rcDest =  %d,%d,%d,%d\r\n",rcDest.left,rcDest.top,rcDest.right,rcDest.bottom);
                        }
                        else
                        {
                            rcDest.right = rcSource.left +
                                (((rcSource.right - rcSource.left)*(iDlgHt - 20))/iWndHt);
                            rcDest.bottom = rcSource.top +
                                (((rcSource.bottom - rcSource.top)*(iDlgHt - 20))/iWndHt);
                        }
                        rcDestWnd.top = rcWnd.top;
                        rcDestWnd.left = rcWnd.left;
                        rcDestWnd.right = rcWnd.left + (rcDest.right - rcDest.left);
                        rcDestWnd.bottom = rcWnd.top + (rcDest.bottom - rcDest.top)
                                            + (iWndHt - (rcSource.bottom - rcSource.top));
                        //DPF("rcDestWnd =  %d,%d,%d,%d\r\n",rcDestWnd.left,rcDestWnd.top,rcDestWnd.right,rcDestWnd.bottom);

                        ixOff = (int)((iDlgWth - (rcDestWnd.right - rcDestWnd.left))/2);
                        iyOff = (int)((iDlgHt - (rcDestWnd.bottom - rcDestWnd.top))/2) + 15;
                        //DPF("ixOff = %, iyOff = %d\r\n", ixOff, iyOff);
                        OffsetRect(&rcDestWnd, ixOff, iyOff);
                        MCIWndPutDest(hwndMCI, &rcDest);
                        MoveWindow(hwndMCI,  rcDestWnd.left, rcDestWnd.top, (rcDestWnd.right - rcDestWnd.left),
                                        (rcDestWnd.bottom - rcDestWnd.top), FALSE);

                    }
                    break;

                case MT_ASF: 
                    break;
                }
            }

            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)hwndMCI);
            SetCursor(hCursor);
            break;
        }

        case WM_CLOSE:
            DPF("***WM_CLOSE***\r\n");
            break;


        case WM_DESTROY:
        {
            HWND hwndMCI = (HWND)GetWindowLongPtr(hDlg, DWLP_USER);

            DPF("***WM_DESTROY***\r\n");
            if (hIcon)
            {
                DestroyIcon(hIcon);
                hIcon = NULL;
            }
            if (IsWindow(hwndMCI))
                MCIWndDestroy(hwndMCI);
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)NULL);

            if (!fLoadedVFW)
                break;
            if (!FreeVFW())
            {
                DPF("****Free VFW failed**\r\n");
                ASSERT(FALSE);
            }
            fLoadedVFW = FALSE;
            break;
        }

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, gszWindowsHlp, HELP_CONTEXTMENU,
                                            (UINT_PTR)(LPTSTR)aPreviewIds);
            return TRUE;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszWindowsHlp, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aPreviewIds);
            return TRUE;

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
        {
            HWND hwndMCI = (HWND)GetWindowLongPtr(hDlg, DWLP_USER);

            SendMessage(hwndMCI, uMsg, wParam, lParam);
            break;
        }
    }
    return FALSE;
}


//---------------------------------------------------------------------------
// mmse IUnknown base member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP mmpsh_QueryInterface(
    LPUNKNOWN punk,
    REFIID riid,
    LPVOID FAR* ppvOut)
{
    PMMPSH this = IToClass(mmpsh, sei, punk);
    HRESULT hres = ResultFromScode(E_NOINTERFACE);
    *ppvOut = NULL;

    if (IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IShellExtInit))
    {
        // We use the sei field as our IUnknown as well
        *ppvOut = &this->sei;
        this->cRef++;
        hres = NOERROR;
    }
    else if (IsEqualIID(riid, &IID_IShellPropSheetExt))
    {
        (LPSHELLPROPSHEETEXT)*ppvOut = &this->pse;
        this->cRef++;
        hres = NOERROR;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IUnknown::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_AddRef(
    LPUNKNOWN punk)
{
    PMMPSH this = IToClass(mmpsh, sei, punk);

    return ++this->cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_Release(
    LPUNKNOWN punk)
{
    PMMPSH this = IToClass(mmpsh, sei, punk);

    if (--this->cRef)
    {
        return this->cRef;
    }

    DPF_T("*^*^*^*^*^*^*^*^*^MMPSH nuked , RefCnt = %d *^*^*^*^ \r\n", (g_cRef - 1));
    if (this->pdtobj)
    {
        this->pdtobj->lpVtbl->Release(this->pdtobj);
    }

    if (this->pszFileObj)
    {
        LocalFree((HLOCAL)this->pszFileObj);
    }
    ReleaseInfoList(this);

    LocalFree((HLOCAL)this);
    --g_cRef;
    return 0;
}



/*----------------------------------------------------------
Purpose: IShellExtInit::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP mmpsh_SEI_QueryInterface(
    LPSHELLEXTINIT psei,
    REFIID riid,
    LPVOID FAR* ppvOut)
{
    PMMPSH this = IToClass(mmpsh, sei, psei);

    return mmpsh_QueryInterface((LPUNKNOWN)&this->sei, riid, ppvOut);
}


/*----------------------------------------------------------
Purpose: IShellExtInit::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_SEI_AddRef(
    LPSHELLEXTINIT psei)
{
    PMMPSH this = IToClass(mmpsh, sei, psei);

    return mmpsh_AddRef((LPUNKNOWN)&this->sei);
}


/*----------------------------------------------------------
Purpose: IShellExtInit::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_SEI_Release(
    LPSHELLEXTINIT psei)
{
    PMMPSH this = IToClass(mmpsh, sei, psei);
    return mmpsh_Release((LPUNKNOWN)&this->sei);
}


/*----------------------------------------------------------
Purpose: MMPSHReleaseStgMedium

Returns: NOERROR
Cond:    --
*/
HRESULT MMPSHReleaseStgMedium(LPSTGMEDIUM pmedium)
{
    //
    // Double-check pUnkForRelease in case we're not supposed to
    // release the medium.
    //
    if (NULL == pmedium->pUnkForRelease)
    {
        switch(pmedium->tymed)
        {
            case TYMED_HGLOBAL:
                GlobalFree(pmedium->hGlobal);
                break;

            case TYMED_ISTORAGE:
                pmedium->pstg->lpVtbl->Release(pmedium->pstg);
                break;

            case TYMED_ISTREAM:
                pmedium->pstm->lpVtbl->Release(pmedium->pstm);
                break;

            default:
                ASSERT(FALSE);  // unknown type
                break;
        }
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IShellExtInit::Initialize

Returns: noerror
Cond:    --
*/
STDMETHODIMP mmpsh_SEI_Initialize(
    LPSHELLEXTINIT psei,
    LPCITEMIDLIST pidlObj,
    LPDATAOBJECT pdtobj,
    HKEY hkeyProgID)
{
    HRESULT hres = NOERROR;
    PMMPSH this = IToClass(mmpsh, sei, psei);
DPF("mmpsh_SEI_Initialize called\n");

    if (pdtobj)
    {
        STGMEDIUM    medium;
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

        if (this->pdtobj)
        {
            this->pdtobj->lpVtbl->Release(this->pdtobj);
        }
        this->pdtobj = pdtobj;
        pdtobj->lpVtbl->AddRef(pdtobj);

        hres = pdtobj->lpVtbl->GetData(pdtobj, &fmte, &medium);
        if(SUCCEEDED(hres))
        {
            if (DragQueryFile(medium.hGlobal, (UINT)-1, NULL, 0))
            {
                TCHAR szPath[MAX_PATH];
                int iIndex;
                DWORD dwSize = 0;

				szPath[0] = '\0';

                DragQueryFile(medium.hGlobal, 0, szPath, sizeof(szPath)/sizeof(TCHAR));

                dwSize = mmpshGetFileSize(szPath);
                if (dwSize != 0)
                {
                    iIndex = lstrlen(szPath) - 4;
                    if (!lstrcmpi((LPTSTR)(szPath+iIndex), cszWavExt))
                        this->iMediaType = MT_WAVE;
                    else if (!lstrcmpi((LPTSTR)(szPath+iIndex), cszMIDIExt))
                        this->iMediaType = MT_MIDI;
                    else if (!lstrcmpi((LPTSTR)(szPath+iIndex), cszRMIExt))
                        this->iMediaType = MT_MIDI;
                    else if (!lstrcmpi((LPTSTR)(szPath+iIndex), cszAVIExt))
                        this->iMediaType = MT_AVI;
                    else if (!lstrcmpi((LPTSTR)(szPath+iIndex), cszASFExt))
                        this->iMediaType = MT_ASF;
                    else
                        this->iMediaType = MT_ERROR;

                    if (!this->pszFileObj || lstrcmpi(this->pszFileObj, szPath))
                    {
                        if (this->pszFileObj)
                            LocalFree((HLOCAL)this->pszFileObj);
                        ReleaseInfoList(this);
                        if (this->iMediaType)
                        {
                            this->pszFileObj = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szPath)*sizeof(TCHAR))+sizeof(TCHAR));
                            if (this->pszFileObj) lstrcpy(this->pszFileObj , szPath);
                        }
                        else
                            hres = ResultFromScode(E_FAIL);
                    }
                }
                else
                    hres = ResultFromScode(E_FAIL);
            }
            //
            // Release STGMEDIUM if we're responsible for doing that.
            //
            if (NULL == medium.pUnkForRelease)
                MMPSHReleaseStgMedium(&medium);
        }
        else
            return hres;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP mmpsh_PSE_QueryInterface(
    LPSHELLPROPSHEETEXT ppse,
    REFIID riid,
    LPVOID FAR* ppvOut)
{
    PMMPSH this = IToClass(mmpsh, pse, ppse);

    return mmpsh_QueryInterface((LPUNKNOWN)&this->sei, riid, ppvOut);
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_PSE_AddRef(
    LPSHELLPROPSHEETEXT ppse)
{
    PMMPSH this = IToClass(mmpsh, pse, ppse);

    return mmpsh_AddRef((LPUNKNOWN)&this->sei);
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) mmpsh_PSE_Release(
    LPSHELLPROPSHEETEXT ppse)
{
    PMMPSH this = IToClass(mmpsh, pse, ppse);
    return mmpsh_Release((LPUNKNOWN)&this->sei);
}

/*==========================================================================*/
UINT CALLBACK DetailsPageCallback(
    HWND        hwnd,
    UINT        uMsg,
    LPPROPSHEETPAGE    ppsp)
{
    if (uMsg == PSPCB_RELEASE)
        if (((PMMPSH)(ppsp->lParam))->pse.lpVtbl)
            ((PMMPSH)(ppsp->lParam))->pse.lpVtbl->Release(&(((PMMPSH)(ppsp->lParam))->pse));
        else
        {
            LocalFree((HLOCAL)((PMMPSH)(ppsp->lParam))->pszFileObj);
            LocalFree((HLOCAL)ppsp->lParam);
        }
    return 1;
}


BOOL AddDetailsPage(
    LPTSTR pszTitle,
    LPFNADDPROPSHEETPAGE    lpfnAddPropSheetPage,
    LPARAM            lDlgParam,
    LPARAM            lParam)
{
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE    hpsp;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE | PSP_USECALLBACK;
    psp.hInstance = ghInstance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_FILE_DETAILS);
    psp.pszIcon = NULL;
    psp.pszTitle = pszTitle;
    psp.pfnDlgProc = FileDetailsDlg;
    psp.lParam = lDlgParam;
    psp.pfnCallback = DetailsPageCallback;
    psp.pcRefParent = NULL;
    if (hpsp = CreatePropertySheetPage(&psp))
    {
        if (lpfnAddPropSheetPage(hpsp, lParam))
            return TRUE;
        DestroyPropertySheetPage(hpsp);
    }
    return FALSE;
}

UINT CALLBACK PreviewPageCallback(
    HWND        hwnd,
    UINT        uMsg,
    LPPROPSHEETPAGE    ppsp)
{
    return 1;
}



BOOL AddPreviewPage(
    LPTSTR pszTitle,
    LPFNADDPROPSHEETPAGE    lpfnAddPropSheetPage,
    LPARAM            lDlgParam,
    LPARAM            lParam)
{
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE    hpsp;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE | PSP_USECALLBACK;
    psp.hInstance = ghInstance;
    psp.pszTemplate = MAKEINTRESOURCE(PREVIEW_DLG);
    psp.pszIcon = NULL;
    psp.pszTitle = pszTitle;
    psp.pfnDlgProc = PreviewDlg;
    psp.lParam = lDlgParam;
    psp.pfnCallback = PreviewPageCallback;
    psp.pcRefParent = NULL;
    if (hpsp = CreatePropertySheetPage(&psp))
    {
        if (lpfnAddPropSheetPage(hpsp, lParam))
            return TRUE;
        DestroyPropertySheetPage(hpsp);
    }
    return FALSE;
}



/*----------------------------------------------------------
Purpose: IShellPropSheetExt::AddPages

Returns: NOERROR
Cond:    --
*/
STDMETHODIMP mmpsh_PSE_AddPages(
    LPSHELLPROPSHEETEXT ppse,
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam)
{
    PMMPSH this = IToClass(mmpsh, pse, ppse);
/*  BOOL fAddPreview = FALSE;

    LoadString(ghInstance, IDS_DETAILS, szDetailsTab, sizeof(szDetailsTab)/sizeof(TCHAR));
    RegSndCntrlClass((LPCTSTR)DISPFRAMCLASS);
    AddDetailsPage(szDetailsTab,lpfnAddPage,(LPARAM)this, lParam);
    switch (this->iMediaType)
    {
        case MT_AVI:
            fAddPreview = TRUE;
            break;
        case MT_WAVE:
            if (waveOutGetNumDevs() > 0)
                fAddPreview = TRUE;
            break;
        case MT_MIDI:
            if (midiOutGetNumDevs() > 0)
                fAddPreview = TRUE;
            break;
    }
    if (fAddPreview)
    {
        LoadString(ghInstance, IDS_PREVIEW, szPreviewTab, sizeof(szPreviewTab)/sizeof(TCHAR));
        AddPreviewPage(szPreviewTab,lpfnAddPage,(LPARAM)this, lParam);
    } */
    ppse->lpVtbl->AddRef(ppse);
    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::ReplacePage

Returns: E_NOTIMPL
Cond:    --
*/
STDMETHODIMP mmpsh_PSE_ReplacePage(
    LPSHELLPROPSHEETEXT ppse,
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam)
{
        return ResultFromScode(E_NOTIMPL);
}



IShellExtInitVtbl c_mmpshSEIVtbl =
{
    mmpsh_SEI_QueryInterface,
    mmpsh_SEI_AddRef,
    mmpsh_SEI_Release,
    mmpsh_SEI_Initialize
};

IShellPropSheetExtVtbl c_mmpshPSEVtbl =
{
    mmpsh_PSE_QueryInterface,
    mmpsh_PSE_AddRef,
    mmpsh_PSE_Release,
    mmpsh_PSE_AddPages,
    mmpsh_PSE_ReplacePage
} ;


HRESULT CALLBACK mmpsh_CreatePSHInstance(
    LPUNKNOWN punkOuter,
    REFIID riid,
    LPVOID FAR* ppvOut)
{
    HRESULT hres;
    PMMPSH this;

    DPF_T("*^*^*^*^*^*^*^*^mmpsh_CreatePSHInstance*^*^*^*^*^*^*^*^\r\n");

    // The  handler does not support aggregation.
    if (punkOuter)
    {
        hres = ResultFromScode(CLASS_E_NOAGGREGATION);
        goto Leave;
    }

    this = LocalAlloc(LPTR, sizeof(*this));
    if (!this)
    {
        hres = ResultFromScode(E_OUTOFMEMORY);
        goto Leave;
    }
    this->sei.lpVtbl = &c_mmpshSEIVtbl;
    this->pse.lpVtbl = &c_mmpshPSEVtbl;
    this->cRef = 1;

    ++g_cRef;

    // Note that the Release member will free the object, if
    // QueryInterface failed.
    hres = this->sei.lpVtbl->QueryInterface(&this->sei, riid, ppvOut);
    this->sei.lpVtbl->Release(&this->sei);

Leave:

    return hres;        // S_OK or E_NOINTERFACE
}

BOOL mmpsh_ShowFileDetails(LPTSTR pszCaption,
        HWND hwndParent,
        LPTSTR pszFile,
        short iMediaType)
{
    PMMPSH pmmpsh;
    TCHAR     szTabName[64];

    pmmpsh = (PMMPSH)LocalAlloc(LPTR, sizeof(*pmmpsh));

    if (!pmmpsh)
        return FALSE;

    pmmpsh->pszFileObj = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pszFile)*sizeof(TCHAR))+sizeof(TCHAR));

    if (!pmmpsh->pszFileObj)
	{
		LocalFree((HLOCAL)pmmpsh);
        return FALSE;
	}

    lstrcpy(pmmpsh->pszFileObj , pszFile);
    pmmpsh->iMediaType = iMediaType;
    LoadString(ghInstance, IDS_DETAILS, szTabName, sizeof(szTabName)/sizeof(TCHAR));
    ShowPropSheet(szTabName,FileDetailsDlg,DLG_FILE_DETAILS,hwndParent,pszCaption,(LPARAM)pmmpsh);

    return TRUE;
}

BOOL ResolveLink(LPTSTR szPath, LPTSTR szResolved, LONG cbSize)
{
    IShellLink *psl = NULL;
    HRESULT hres;

    hres = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, &IID_IShellLink, &psl);
    if (SUCCEEDED(hres))
    {
        IPersistFile *ppf;

        hres = psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);
        if (SUCCEEDED(hres))
        {
            WCHAR wszPath[MAX_PATH];

            hres = StringCchCopyW(wszPath, ARRAYSIZE(wszPath), szPath);
            if (SUCCEEDED(hres))
            {
                hres = ppf->lpVtbl->Load(ppf, wszPath, 0);
                if (SUCCEEDED(hres))
                {
                    psl->lpVtbl->Resolve(psl, NULL, SLR_NO_UI);

                    hres = psl->lpVtbl->GetPath(psl, szResolved, cbSize/sizeof(TCHAR), NULL, SLGP_SHORTPATH);
                }
            }

            ppf->lpVtbl->Release(ppf);
        }

        psl->lpVtbl->Release(psl);
    }

    return SUCCEEDED(hres);
}



//---------------------------------------------------------------------------
// EXPORTED API
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Standard shell entry-point

Returns: standard
Cond:    --
*/
STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR* ppv)
{

    // We are supposed return the class object for this class.  Instead
    // of fully implementing it in this DLL, we just call a helper
    // function in the shell DLL which creates a default class factory
    // object for us. When its CreateInstance member is called, it
    // will call back our create instance function.
    //

    if (IsEqualIID(rclsid, &CLSID_mmsePropSheetHandler))
    {
        return SHCreateDefClassObject(
                    riid,                   // Interface ID
                    ppv,                    // Non-null to aggregate
                    mmpsh_CreatePSHInstance,  // Callback function
                    &g_cRef,                // Reference count of this DLL
                    &IID_IShellExtInit);   // Init interface
    }
    return ResultFromScode(REGDB_E_CLASSNOTREG);
}


//****************************************************************************
// STDAPI DllCanUnLoadNow()
//
// This function is called by shell
//
//****************************************************************************

STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;

    if (0 == g_cRef)
    {
        DPF("DllCanUnloadNow says OK (Ref=%d)",
            g_cRef);

        hr = ResultFromScode(S_OK);
    }
    else
    {
        DPF("DllCanUnloadNow says FALSE (Ref=%d)",
            g_cRef);

        hr = ResultFromScode(S_FALSE);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\mmdebug.h ===
/*
 * johnkn's debug logging and assert macros
 *
 */

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_
//
// prototypes for debug functions.
//
    #define SQUAWKNUMZ(num) TEXT(#num)
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK TEXT(__FILE__) TEXT("(") SQUAWKNUM(__LINE__) TEXT(") ----")
    #define DEBUGLINE TEXT(__FILE__) TEXT("(") SQUAWKNUM(__LINE__) TEXT(") ")

    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        int  FAR _cdecl AuxDebugEx(int, LPTSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        int  WINAPI DebugSetOutputLevel (int);

       #if defined DEBUG_RETAIL
        #define INLINE_BREAK
       #else
        #if !defined _WIN32 || defined _X86_
         #define INLINE_BREAK _asm {int 3}
        #else
         #define INLINE_BREAK DebugBreak()
        #endif
       #endif

       #undef  assert
       #define assert(exp) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") TEXT(#exp) TEXT("\r\n")); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert2
       #define assert2(exp,sz) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n")); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert3
       #define assert3(exp,sz,arg) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n"), (arg)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert4
       #define assert4(exp,sz,arg1,arg2) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n"), (arg1),(arg2)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert5
       #define assert5(exp,sz,arg1,arg2,arg3) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE TEXT("assert failed: ") sz TEXT("\r\n"), (arg1),(arg2),(arg3)); \
               INLINE_BREAK;\
               }\
           }

      #define STATICFN

    #else // defined(DEBUG)

      #define AuxDebugEx  1 ? (void)0 :
      #define AuxDebugDump(a,b,c)

      #define assert(a)          ((void)0)
      #define assert2(a,b)       ((void)0)
      #define assert3(a,b,c)     ((void)0)
      #define assert4(a,b,c,d)   ((void)0)
      #define assert5(a,b,c,d,e) ((void)0)

      #define INLINE_BREAK
      #define DebugSetOutputLevel(i)
      #define STATICFN static

   #endif // defined(DEBUG)

   #define AuxDebug(sz) AuxDebugEx (1, DEBUGLINE sz TEXT("\r\n"))
   #define AuxDebug2(sz,a) AuxDebugEx (1, DEBUGLINE sz TEXT("\r\n"), (a))

#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE

    #include <stdarg.h>

    #if !defined _WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

    int    mmdebug_OutputLevel = 0;

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/

    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPTSTR lpFormat,
       ...)
       {
       TCHAR     szBuf[1024];
       int      cb;
       va_list  va;
       TCHAR   * psz;

       if (mmdebug_OutputLevel >= iLevel)
          {
          va_start (va, lpFormat);
          cb = wvsprintf (szBuf, lpFormat, va);
          va_end (va);

          // eat leading ..\..\ which we get from __FILE__ since
          // george's wierd generic makefile stuff.
          //
          psz = szBuf;
          while (psz[0] == TEXT('.') && psz[1] == TEXT('.') && psz[2] == TEXT('\\'))
             psz += 3;

          #ifdef MODULE_DEBUG_PREFIX
           OutputDebugString (MODULE_DEBUG_PREFIX);
          #endif

          OutputDebugString (psz);
          }

       return cb;
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/

    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = NULL;
       TCHAR     szBuf[128];
       LPTSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];

       if (mmdebug_OutputLevel <= iLevel || nCount <= 0)
          return;

       do {
          cb = wsprintf (szBuf, TEXT("\t%08X: "), lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = TEXT('.');
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpy (psz, TEXT(".. "));
             else
                {
                wsprintf (psz, TEXT("%02X "), lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpy (psz, TEXT("\r\n"));

          #ifdef MODULE_DEBUG_PREFIX
           OutputDebugString (MODULE_DEBUG_PREFIX);
          #endif

          OutputDebugString (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }

    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/

    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel)
        {
        int nOldLevel = mmdebug_OutputLevel;
        mmdebug_OutputLevel = nLevel;
        return nOldLevel;
        }

    void FAR cdecl dprintf(LPSTR szFormat, ...)
    {
        TCHAR ach[MAXSTRINGLEN];
        TCHAR szUniFormat[MAXSTRINGLEN];
        
        int  s,d;
        va_list arg;

        MultiByteToWideChar(GetACP(), 0,
                        szFormat, -1,
                        szUniFormat, sizeof(szUniFormat)/sizeof(TCHAR));

        va_start (arg, szUniFormat);

        s = wvsprintf (ach,szUniFormat,arg);
        va_end(arg);

        for (d=sizeof(ach)-1; s>=0; s--)
        {
            if ((ach[d--] = ach[s]) == TEXT('\n'))
                ach[d--] = TEXT('\r');
        }

       va_end(arg);

        OutputDebugStr(TEXT("MMSYS.CPL: "));
        OutputDebugStr(ach+d+1);
    }


    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\multchan.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  multchan.c
//
//      This file defines the functions that drive the multichannel 
//      volume tab of the Sounds & Multimedia control panel.
//
//  History:
//      13 March 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

// Prototypes
INT_PTR CALLBACK MultichannelDlg (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT SetDevice (UINT uiMixID, DWORD dwDest, DWORD dwVolID);
UINT GetPageStringID ();

BOOL OnInitDialogMC (HWND hDlg, HWND hwndFocus, LPARAM lParam);
void OnDestroyMC (HWND hDlg);
void OnNotifyMC (HWND hDlg, LPNMHDR pnmh);
BOOL PASCAL OnCommandMC (HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
void FreeMCMixer ();
HRESULT GetMCVolume ();
void DisplayMCVolumeControl (HWND hDlg);
void ShowAndEnableWindow (HWND hwnd, BOOL fEnable);
void UpdateMCVolumeSliders (HWND hDlg);
void MCVolumeScroll (HWND hwnd, HWND hwndCtl, UINT code, int pos);
BOOL SetMCVolume (DWORD dwChannel, DWORD dwVol, BOOL fMoveTogether);
BOOL SliderIDtoChannel (UINT uiSliderID, DWORD* pdwChannel);
void HandleMCPowerBroadcast (HWND hWnd, WPARAM wParam, LPARAM lParam);
void InitMCVolume (HWND hDlg);
void FreeAll ();
BOOL GetSpeakerLabel (DWORD dwSpeakerType, UINT uiSliderIndx, WCHAR* szLabel, int nSize);
BOOL GetSpeakerType (DWORD* pdwSpeakerType);

void MCDeviceChange_Cleanup ();
void MCDeviceChange_Init (HWND hWnd, DWORD dwMixerID);
void MCDeviceChange_Change (HWND hDlg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\multchan.c ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  multchan.c
//
//      This file defines the functions that drive the multichannel 
//      volume tab of the Sounds & Multimedia control panel.
//
//  History:
//      13 March 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

//=============================================================================
//                            Include files
//=============================================================================
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <regstr.h>
#include <dbt.h>
#include "medhelp.h"
#include "mmcpl.h"
#include "multchan.h"
#include "speakers.h"
#include "dslevel.h"

// Externals
extern BOOL DeviceChange_GetHandle(DWORD dwMixerID, HANDLE *phDevice);
extern HRESULT DSGetGuidFromName(LPTSTR szName, BOOL fRecord, LPGUID pGuid);
extern HRESULT DSGetCplValues(GUID guid, BOOL fRecord, LPCPLDATA pData);

// Globals
UINT                g_uiMCMixID            = 0;
HMIXER              g_hMCMixer             = NULL;
UINT                g_uiMCPageStringID     = 0;
UINT                g_uiMCDescStringID     = 0;
LPVOID              g_paPrevious           = NULL;
BOOL                g_fInternalMCGenerated = FALSE;
BOOL                g_fMCChanged           = FALSE;
MIXERCONTROLDETAILS g_mcdMC;
MIXERLINE           g_mlMCDst;
WNDPROC             g_fnMCPSProc           = NULL;
UINT                g_uiMCDevChange        = 0;
HWND                g_hWndMC               = NULL;
static HDEVNOTIFY   g_hMCDeviceEventContext= NULL;

// Constants
#define VOLUME_TICS (500) // VOLUME_TICS * VOLUME_MAX must be less than 0xFFFFFFFF
#define VOLUME_MAX  (0xFFFF)
#define VOLUME_MIN  (0)
#define MC_SLIDER_COUNT (8) // Update Code & Dialog Template if change this value!
static INTCODE  aKeyWordIds[] =
{
    IDC_MC_DESCRIPTION,      NO_HELP,
    IDC_MC_ZERO_LOW,         IDH_MC_ALL_SLIDERS,
    IDC_MC_ZERO,             IDH_MC_ALL_SLIDERS,
    IDC_MC_ZERO_VOLUME,      IDH_MC_ALL_SLIDERS,
    IDC_MC_ZERO_HIGH,        IDH_MC_ALL_SLIDERS,
    IDC_MC_ONE_LOW,          IDH_MC_ALL_SLIDERS,
    IDC_MC_ONE,              IDH_MC_ALL_SLIDERS,
    IDC_MC_ONE_VOLUME,       IDH_MC_ALL_SLIDERS,
    IDC_MC_ONE_HIGH,         IDH_MC_ALL_SLIDERS,
    IDC_MC_TWO_LOW,          IDH_MC_ALL_SLIDERS,
    IDC_MC_TWO,              IDH_MC_ALL_SLIDERS,
    IDC_MC_TWO_VOLUME,       IDH_MC_ALL_SLIDERS,
    IDC_MC_TWO_HIGH,         IDH_MC_ALL_SLIDERS,
    IDC_MC_THREE_LOW,        IDH_MC_ALL_SLIDERS,
    IDC_MC_THREE,            IDH_MC_ALL_SLIDERS,
    IDC_MC_THREE_VOLUME,     IDH_MC_ALL_SLIDERS,
    IDC_MC_THREE_HIGH,       IDH_MC_ALL_SLIDERS,
    IDC_MC_FOUR_LOW,         IDH_MC_ALL_SLIDERS,
    IDC_MC_FOUR,             IDH_MC_ALL_SLIDERS,
    IDC_MC_FOUR_VOLUME,      IDH_MC_ALL_SLIDERS,
    IDC_MC_FOUR_HIGH,        IDH_MC_ALL_SLIDERS,
    IDC_MC_FIVE_LOW,         IDH_MC_ALL_SLIDERS,
    IDC_MC_FIVE,             IDH_MC_ALL_SLIDERS,
    IDC_MC_FIVE_VOLUME,      IDH_MC_ALL_SLIDERS,
    IDC_MC_FIVE_HIGH,        IDH_MC_ALL_SLIDERS,
    IDC_MC_SIX_LOW,          IDH_MC_ALL_SLIDERS,
    IDC_MC_SIX,              IDH_MC_ALL_SLIDERS,
    IDC_MC_SIX_VOLUME,       IDH_MC_ALL_SLIDERS,
    IDC_MC_SIX_HIGH,         IDH_MC_ALL_SLIDERS,
    IDC_MC_SEVEN_LOW,        IDH_MC_ALL_SLIDERS,
    IDC_MC_SEVEN,            IDH_MC_ALL_SLIDERS,
    IDC_MC_SEVEN_VOLUME,     IDH_MC_ALL_SLIDERS,
    IDC_MC_SEVEN_HIGH,       IDH_MC_ALL_SLIDERS,
    IDC_MC_MOVE_TOGETHER,    IDH_MC_MOVE_TOGETHER,
    IDC_MC_RESTORE,          IDH_MC_RESTORE,
    0,0
};

///////////////////////////////////////////////////////////////////////////////
//
//  %%Function: MCTabProc
//
//  Parameters: hDlg = window handle of dialog window.
//              uiMessage = message ID.
//              wParam = message-dependent.
//              lParam = message-dependent.
//
//  Returns: TRUE if message has been processed, else FALSE
//
//  Description: Dialog proc for multichannel control panel page device change
//               message.
//
//
///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK MCTabProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    if (iMsg == g_uiMCDevChange)
    {
        InitMCVolume (g_hWndMC);
    }
        
    return CallWindowProc (g_fnMCPSProc, hwnd, iMsg, wParam, lParam);
}


///////////////////////////////////////////////////////////////////////////////
//
//  %%Function: MultichannelDlg
//
//  Parameters: hDlg = window handle of dialog window.
//              uiMessage = message ID.
//              wParam = message-dependent.
//              lParam = message-dependent.
//
//  Returns: TRUE if message has been processed, else FALSE
//
//  Description: Dialog proc for multichannel volume control panel page.
//
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK MultichannelDlg (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            OnNotifyMC (hDlg, (LPNMHDR) lParam);
        }
        break;

        case WM_INITDIALOG:
        {
            HANDLE_WM_INITDIALOG (hDlg, wParam, lParam, OnInitDialogMC);
        }
        break;

        case WM_DESTROY:
        {
            HANDLE_WM_DESTROY (hDlg, wParam, lParam, OnDestroyMC);
        }
        break;

        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND (hDlg, wParam, lParam, OnCommandMC);
        }
        break;

	    case WM_HSCROLL:
        {
	        HANDLE_WM_HSCROLL (hDlg, wParam, lParam, MCVolumeScroll);
	    }
        break;

        case WM_POWERBROADCAST:
        {
            HandleMCPowerBroadcast (hDlg, wParam, lParam);
        }
        break;

        case MM_MIXM_LINE_CHANGE:
        case MM_MIXM_CONTROL_CHANGE:
        {
            if (!g_fInternalMCGenerated)
            {
                DisplayMCVolumeControl (hDlg);
            }

            g_fInternalMCGenerated = FALSE;
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND)wParam, NULL, HELP_CONTEXTMENU,
                                            (UINT_PTR)(LPTSTR)aKeyWordIds);
        }
        break;

        case WM_HELP:
        {
            WinHelp (((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aKeyWordIds);
        }
        break;
        
        case WM_DEVICECHANGE:
        {
            MCDeviceChange_Change (hDlg, wParam, lParam);
        }
        break;

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE :
        {
            int iLastSliderID = IDC_MC_ZERO_VOLUME + (MC_SLIDER_COUNT - 1) * 4;
            int indx = IDC_MC_ZERO_VOLUME;
            for (; indx <= iLastSliderID; indx += 4)
                SendDlgItemMessage (hDlg, indx, uMsg, wParam, lParam);
        }
        break;

    }

    return FALSE;

}


void InitMCVolume (HWND hDlg)
{
    FreeMCMixer ();

    if (MMSYSERR_NOERROR == mixerOpen (&g_hMCMixer, g_uiMCMixID, (DWORD_PTR) hDlg, 0L, CALLBACK_WINDOW))
    {
        if (SUCCEEDED (GetMCVolume ()) && g_paPrevious && g_mcdMC.paDetails)
        {
            // Copy data so can undo volume changes
            memcpy (g_paPrevious, g_mcdMC.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
            DisplayMCVolumeControl (hDlg);
        }
        MCDeviceChange_Init (hDlg, g_uiMCMixID);
    }
}


BOOL OnInitDialogMC (HWND hDlg, HWND hwndFocus, LPARAM lParam)
{

    TCHAR szDescription [255];
    LoadString (ghInstance, g_uiMCDescStringID, szDescription, sizeof (szDescription)/sizeof (TCHAR));
    SetWindowText (GetDlgItem (hDlg, IDC_MC_DESCRIPTION), szDescription);

    // Init Globals
    g_fInternalMCGenerated = FALSE;
    g_fMCChanged           = FALSE;
    g_hWndMC               = hDlg;
    // Set Device Change Notification
    g_fnMCPSProc = (WNDPROC) SetWindowLongPtr (GetParent (hDlg), GWLP_WNDPROC, (LONG_PTR) MCTabProc);
    g_uiMCDevChange = RegisterWindowMessage (_T("winmm_devicechange"));

    // Init Volume
    InitMCVolume (hDlg);

    return FALSE;
}


void OnDestroyMC (HWND hDlg)
{
    // Unregister from notifications
    MCDeviceChange_Cleanup ();
    SetWindowLongPtr (GetParent (hDlg), GWLP_WNDPROC, (LONG_PTR) g_fnMCPSProc);  

    FreeAll ();
}


void OnNotifyMC (HWND hDlg, LPNMHDR pnmh)
{
    if (!pnmh)
    {
        DPF ("bad WM_NOTIFY pointer\n");            
        return;
    }

    switch (pnmh->code)
    {
        case PSN_KILLACTIVE:
            FORWARD_WM_COMMAND (hDlg, IDOK, 0, 0, SendMessage);
            break;

        case PSN_APPLY:
            FORWARD_WM_COMMAND (hDlg, ID_APPLY, 0, 0, SendMessage);
            break;

        case PSN_RESET:
            FORWARD_WM_COMMAND (hDlg, IDCANCEL, 0, 0, SendMessage);
            break;
    }
}


BOOL PASCAL OnCommandMC (HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_MC_RESTORE:
        {
            // Move all sliders to center
            UINT  uiIndx;
            for (uiIndx = 0; uiIndx < g_mlMCDst.cChannels; uiIndx++)
            {
                ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + uiIndx) -> dwValue = VOLUME_MAX/2;
            }
            g_fInternalMCGenerated = FALSE;
            mixerSetControlDetails ((HMIXEROBJ) g_hMCMixer, &g_mcdMC, MIXER_SETCONTROLDETAILSF_VALUE);

            if (!g_fMCChanged)
            {
                g_fMCChanged = TRUE;
                PropSheet_Changed (GetParent (hDlg), hDlg);
            }
        }
        break;

        case ID_APPLY:
        {
            if (SUCCEEDED (GetMCVolume ()) && g_paPrevious && g_mcdMC.paDetails)
            {
                // Copy data so can undo volume changes
                memcpy (g_paPrevious, g_mcdMC.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
                DisplayMCVolumeControl (hDlg);
            }

            g_fMCChanged = FALSE;
            return TRUE;
        }
        break;

        case IDOK:
        {
        }
        break;

        case IDCANCEL:
        {
            if (g_paPrevious && g_mcdMC.paDetails)
            {
                // Undo volume changes
                memcpy (g_mcdMC.paDetails, g_paPrevious, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
                g_fInternalMCGenerated = TRUE;
                mixerSetControlDetails ((HMIXEROBJ) g_hMCMixer, &g_mcdMC, MIXER_SETCONTROLDETAILSF_VALUE);
            }
            WinHelp (hDlg, gszWindowsHlp, HELP_QUIT, 0L);
        }
        break;

    }


   return FALSE;

}


void HandleMCPowerBroadcast (HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
	    case PBT_APMQUERYSUSPEND:
        {
            FreeMCMixer ();
        }
	    break;

	    case PBT_APMQUERYSUSPENDFAILED:
	    case PBT_APMRESUMESUSPEND:
        {
            InitMCVolume (hWnd);
        }
	    break;
    }
}


BOOL SliderIDtoChannel (UINT uiSliderID, DWORD* pdwChannel)
{

    if (!pdwChannel)
        return FALSE;

    // Determine channel number (index)
    switch (uiSliderID)
    {
        case IDC_MC_ZERO_VOLUME:    // Left 
            *pdwChannel = 0; 
            break;
        case IDC_MC_ONE_VOLUME:     // Right 
            *pdwChannel = 1;
            break;
        case IDC_MC_TWO_VOLUME:     // Center 
            *pdwChannel = 2;
            break;
        case IDC_MC_THREE_VOLUME:   // Back Left
            *pdwChannel = 3;
            break;
        case IDC_MC_FOUR_VOLUME:    // Back Right 
            *pdwChannel = 4;
            break;
        case IDC_MC_FIVE_VOLUME:    // Low Frequency
            *pdwChannel = 5;
            break;
        case IDC_MC_SIX_VOLUME:     // Left of Center
            *pdwChannel = 6;
            break;
        case IDC_MC_SEVEN_VOLUME:   // Right of Center
            *pdwChannel = 7;
            break;
        default:
            return FALSE;
    }

    return ((*pdwChannel) < g_mlMCDst.cChannels);

}


// Called in response to slider movement, computes new volume level and sets it
// it also controls the apply state (changed or not)
void MCVolumeScroll (HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
    
    BOOL  fSet;
    BOOL  fMoveTogether;
    DWORD dwChannel; 
    DWORD dwSliderVol;
    DWORD dwNewMixerVol;
    DWORD dwOldMixerVol;
    DWORD dwVolume;

    fMoveTogether = IsDlgButtonChecked (hwnd, IDC_MC_MOVE_TOGETHER);
    if (SliderIDtoChannel (GetDlgCtrlID (hwndCtl), &dwChannel))
    {
        // Set the new volume
        dwSliderVol   = (DWORD) SendMessage (hwndCtl, TBM_GETPOS, 0, 0);
        dwNewMixerVol = (VOLUME_MAX * dwSliderVol + VOLUME_TICS / 2) / VOLUME_TICS;
        dwOldMixerVol = (g_paPrevious ? ((MIXERCONTROLDETAILS_UNSIGNED*)g_paPrevious + dwChannel) -> dwValue : 0);
        fSet          = SetMCVolume (dwChannel, dwNewMixerVol, fMoveTogether);

        if (!fSet)
        {
            // Restore the correct thumb position.
            dwVolume = (VOLUME_TICS * ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + dwChannel) -> dwValue + VOLUME_MAX / 2) / VOLUME_MAX;
            SendMessage (hwndCtl, TBM_SETPOS, TRUE, dwVolume);
        }

        if ((fMoveTogether || dwOldMixerVol != dwNewMixerVol) && !g_fMCChanged)
        {
            g_fMCChanged = TRUE;
            PropSheet_Changed (GetParent (hwnd), hwnd);
        }
    }
    
}

// Sets the volume level
//
BOOL SetMCVolume (DWORD dwChannel, DWORD dwVol, BOOL fMoveTogether)
{

    BOOL  fReturn;
    UINT  uiIndx;
    DWORD dwValue;
    long lMoveValue;
    long lMoveValueActual;

    fReturn = TRUE;
    if (dwChannel < g_mlMCDst.cChannels && g_mcdMC.paDetails && g_hMCMixer)
    {
        if (fMoveTogether)
        {
            // Note: Do not set g_fInternalMCGenerated = TRUE here because we are relying
            //       on the change notification to update the other sliders.
            lMoveValue = (long)((double)dwVol - (double)(((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + dwChannel) -> dwValue));
            lMoveValueActual = lMoveValue;

            // Don't bother if no move requested.
            if (lMoveValue == 0)
                return TRUE; // Already Set

            // Ensure that the new value is within the range of all the sliders that are
            // being used. This will ensure that we maintain the distance between sliders 
            // as they are being moved.
            for (uiIndx = 0; uiIndx < g_mlMCDst.cChannels; uiIndx++)
            {
                dwValue = ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + uiIndx) -> dwValue;
                if (VOLUME_MIN > ((long)dwValue+lMoveValueActual))
                {
                    lMoveValueActual = VOLUME_MIN - dwValue;
                }
                else
                {
                    if (VOLUME_MAX < ((long)dwValue+lMoveValueActual))
                        lMoveValueActual = VOLUME_MAX - dwValue;
                }
            }

            if (lMoveValueActual != 0)
            {
                // Update the values
                for (uiIndx = 0; uiIndx < g_mlMCDst.cChannels; uiIndx++)
                {
                    dwValue = ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + uiIndx) -> dwValue;
                    ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + uiIndx) -> dwValue = (DWORD)((long) dwValue + lMoveValueActual);
                }
            }
            else
            {
                // Let user know that they can move no farther in the current direction.
                // Note: We use the PC Speaker instead of the mixer because this is an
                //       indicator that they are at either min or max volume for one of
                //       the sliders. Since these are channel volume sliders, if we used
                //       the mixer, the user would either not hear anything (min volume)
                //       or get blown away (max volume).
                MessageBeep (-1 /*PC Speaker*/);
                fReturn = FALSE;
            }
        }
        else
        {
            g_fInternalMCGenerated = TRUE;
            ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + dwChannel) -> dwValue = dwVol;
        }
        
        mixerSetControlDetails ((HMIXEROBJ) g_hMCMixer, &g_mcdMC, MIXER_SETCONTROLDETAILSF_VALUE);
    }

    return fReturn;

}


void ShowAndEnableWindow (HWND hwnd, BOOL fEnable)
{
    EnableWindow (hwnd, fEnable);
    ShowWindow (hwnd, fEnable ? SW_SHOW : SW_HIDE);
}


void DisplayMCVolumeControl (HWND hDlg)
{
    
    HWND hwndVol = NULL;
    HWND hwndLabel = NULL;
    WCHAR szLabel[MAX_PATH];
    BOOL fEnabled;
    UINT uiIndx;
    DWORD dwSpeakerType = TYPE_STEREODESKTOP;
    BOOL fPlayback = (MIXERLINE_COMPONENTTYPE_DST_SPEAKERS == g_mlMCDst.dwComponentType);
    ZeroMemory (szLabel, sizeof (szLabel));

    // Get Speaker Configuration Type
    if (fPlayback)
        GetSpeakerType (&dwSpeakerType);

    for (uiIndx = 0; uiIndx < MC_SLIDER_COUNT; uiIndx++)
    {

        fEnabled = (uiIndx < g_mlMCDst.cChannels);

        // Set up the volume slider
        hwndVol = GetDlgItem (hDlg, IDC_MC_ZERO_VOLUME + uiIndx * 4);
        SendMessage (hwndVol, TBM_SETTICFREQ, VOLUME_TICS / 10, 0);
        SendMessage (hwndVol, TBM_SETRANGE, FALSE, MAKELONG (0, VOLUME_TICS));

        // Enable/Disable sliders
        hwndLabel = GetDlgItem (hDlg, IDC_MC_ZERO + uiIndx * 4);
        ShowAndEnableWindow (hwndVol, fEnabled);
        ShowAndEnableWindow (hwndLabel, fEnabled);
        ShowAndEnableWindow (GetDlgItem (hDlg, IDC_MC_ZERO_LOW + uiIndx * 4), fEnabled);
        ShowAndEnableWindow (GetDlgItem (hDlg, IDC_MC_ZERO_HIGH + uiIndx * 4), fEnabled);

        if (fPlayback)
        {
            GetSpeakerLabel (dwSpeakerType, uiIndx, szLabel, sizeof(szLabel)/sizeof(TCHAR));
        }
        else
        {
            LoadString (ghInstance, IDS_MC_CHANNEL_ZERO + uiIndx, szLabel, MAX_PATH);
        }
        SetWindowText (hwndLabel, szLabel);

    }

    if (0 < g_mlMCDst.cChannels)
    {
        UpdateMCVolumeSliders (hDlg);
    }

}


BOOL GetSpeakerType (DWORD* pdwSpeakerType)
{

    BOOL fReturn = FALSE;

    if (pdwSpeakerType)
    {
        MIXERCAPS mc;

        *pdwSpeakerType = TYPE_STEREODESKTOP; // Init Value
        if (MMSYSERR_NOERROR == mixerGetDevCaps (g_uiMCMixID, &mc, sizeof (mc)))
        {
            GUID guid;
            if (SUCCEEDED (DSGetGuidFromName (mc.szPname, FALSE, &guid)))
            {
                CPLDATA cpldata;
                if (SUCCEEDED (DSGetCplValues (guid, FALSE, &cpldata)))
                {
                    *pdwSpeakerType = cpldata.dwSpeakerType;
                    fReturn = TRUE;
                }
            }
        }
    }

    return fReturn;

}

BOOL GetSpeakerLabel (DWORD dwSpeakerType, UINT uiSliderIndx, WCHAR* szLabel, int nSize)
{

    if (uiSliderIndx >= MC_SLIDER_COUNT || !szLabel || nSize <= 0)
        // Invalid
        return FALSE;

    switch (dwSpeakerType)
    {
        //
        // Mono
        //
        case TYPE_NOSPEAKERS:
        case TYPE_MONOLAPTOP:
            if (0 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_CENTER, szLabel, nSize));
            break;

        //
        // Stereo
        //
        case TYPE_HEADPHONES:
        case TYPE_STEREODESKTOP:
        case TYPE_STEREOLAPTOP:
        case TYPE_STEREOMONITOR:
        case TYPE_STEREOCPU:
        case TYPE_MOUNTEDSTEREO:
        case TYPE_STEREOKEYBOARD:
            // Left & Right Channel ...
            if (0 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LEFT, szLabel, nSize));
            else if (1 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_RIGHT, szLabel, nSize));
            break;

        //
        // Greater than Stereo
        //
        case TYPE_SURROUND:
            // Left & Right Channel ...
            if (0 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LEFT, szLabel, nSize));
            else if (1 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_RIGHT, szLabel, nSize));
            // Center Front & Back
            else if (2 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_CENTER, szLabel, nSize));
            else if (3 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_BACKCENTER, szLabel, nSize));
            break;

        case TYPE_QUADRAPHONIC:
            // Left & Right Channel ...
            if (0 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LEFT, szLabel, nSize));
            else if (1 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_RIGHT, szLabel, nSize));
            // Back Left & Back Right Channel ...
            else if (2 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_BACKLEFT, szLabel, nSize));
            else if (3 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_BACKRIGHT, szLabel, nSize));
            break;

        case TYPE_SURROUND_5_1:
        case TYPE_SURROUND_7_1:
            // Left & Right Channel ...
            if (0 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LEFT, szLabel, nSize));
            else if (1 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_RIGHT, szLabel, nSize));

            // Center Channel ...
            if (2 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_CENTER, szLabel, nSize));
            // Low Frequency ...
            if (3 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LOWFREQUENCY, szLabel, nSize));

            // Back Left & Back Right Channel ...
            if (4 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_BACKLEFT, szLabel, nSize));
            else if (5 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_BACKRIGHT, szLabel, nSize));

            if (TYPE_SURROUND_5_1 == dwSpeakerType)
                break;

            // Left of Center & Right of Center Channel ...
            if (6 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_LEFT_OF_CENTER, szLabel, nSize));
            else if (7 == uiSliderIndx)
                return (LoadString (ghInstance, IDS_MC_SPEAKER_RIGHT_OF_CENTER, szLabel, nSize));

            break;

    }

    // If we are here, we don't know the speaker type or we have too many 
    // channels for a known type, just use the generic channel text ...
    return (LoadString (ghInstance, IDS_MC_CHANNEL_ZERO + uiSliderIndx, szLabel, nSize));

}


// Called to update the slider when the volume is changed externally
//
void UpdateMCVolumeSliders (HWND hDlg)
{
    if (g_hMCMixer && g_mcdMC.paDetails && SUCCEEDED (GetMCVolume ()))
    {
        UINT uiIndx;
        DWORD dwVolume;
        MIXERCONTROLDETAILS_UNSIGNED mcuVolume;
        for (uiIndx = 0; uiIndx < g_mlMCDst.cChannels; uiIndx++)
        {
            mcuVolume = *((MIXERCONTROLDETAILS_UNSIGNED*)g_mcdMC.paDetails + uiIndx);
            dwVolume = (VOLUME_TICS * mcuVolume.dwValue + VOLUME_MAX / 2) / VOLUME_MAX;
            SendMessage (GetDlgItem (hDlg, IDC_MC_ZERO_VOLUME + uiIndx * 4), TBM_SETPOS, TRUE, dwVolume);
        }
    }
}


void FreeAll ()
{
    FreeMCMixer ();
    if (g_mcdMC.paDetails)
    {
        LocalFree (g_mcdMC.paDetails);
        g_mcdMC.paDetails = NULL;
    }
    if (g_paPrevious)
    {
        LocalFree (g_paPrevious);
        g_paPrevious = NULL;
    }
    ZeroMemory (&g_mcdMC, sizeof (g_mcdMC));
    ZeroMemory (&g_mlMCDst, sizeof (g_mlMCDst));
}

void FreeMCMixer ()
{
    if (g_hMCMixer)
    {
        mixerClose (g_hMCMixer);
        g_hMCMixer = NULL;
    }
}


HRESULT SetDevice (UINT uiMixID, DWORD dwDest, DWORD dwVolID)
{

    HMIXER hMixer = NULL;
    HRESULT hr = E_FAIL;

    // Free any current mixer stuff
    FreeAll ();

    if (MMSYSERR_NOERROR == mixerOpen (&hMixer, uiMixID, 0, 0, MIXER_OBJECTF_MIXER))
    {
        g_mlMCDst.cbStruct      = sizeof (g_mlMCDst);
        g_mlMCDst.dwDestination = dwDest;
    
        if (MMSYSERR_NOERROR == mixerGetLineInfo ((HMIXEROBJ) hMixer, &g_mlMCDst, MIXER_GETLINEINFOF_DESTINATION))
        {
            g_mcdMC.cbStruct     = sizeof (g_mcdMC);
            g_mcdMC.dwControlID    = dwVolID;
            g_mcdMC.cChannels      = g_mlMCDst.cChannels;
            g_mcdMC.hwndOwner      = 0;
            g_mcdMC.cMultipleItems = 0;
            g_mcdMC.cbDetails      = sizeof (DWORD); // seems like it would be sizeof(g_mcd),
                                                     // but actually, it is the size of a single value
                                                     // and is multiplied by channel in the driver.
            g_mcdMC.paDetails = (MIXERCONTROLDETAILS_UNSIGNED*) LocalAlloc (LPTR, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
            g_paPrevious = (MIXERCONTROLDETAILS_UNSIGNED*) LocalAlloc (LPTR, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
            if (g_mcdMC.paDetails && g_paPrevious)
            {
                hr = S_OK;

                // Init our other globals
                g_uiMCMixID = uiMixID;
                switch (g_mlMCDst.dwComponentType)
                {
                    case MIXERLINE_COMPONENTTYPE_DST_SPEAKERS:
                        g_uiMCPageStringID = IDS_MC_PLAYBACK;
                        g_uiMCDescStringID = IDS_MC_PLAYBACK_DESC;
                        break;

                    case MIXERLINE_COMPONENTTYPE_DST_WAVEIN:
                    case MIXERLINE_COMPONENTTYPE_DST_VOICEIN:
                        g_uiMCPageStringID = IDS_MC_RECORDING;
                        g_uiMCDescStringID = IDS_MC_RECORDING_DESC;
                        break;

                    default:
                        g_uiMCPageStringID = IDS_MC_OTHER;
                        g_uiMCDescStringID = IDS_MC_OTHER_DESC;
                        break;

                }
            }
        }

        mixerClose (hMixer);
    }

    return hr;

}


HRESULT GetMCVolume ()
{
    HRESULT hr = E_FAIL;
    if (g_hMCMixer && g_mcdMC.paDetails)
    {
        ZeroMemory (g_mcdMC.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlMCDst.cChannels);
        hr = mixerGetControlDetails ((HMIXEROBJ)g_hMCMixer, &g_mcdMC, MIXER_GETCONTROLDETAILSF_VALUE);
    }
    return hr;
}


UINT GetPageStringID () 
{ 
    return g_uiMCPageStringID; 
}


void MCDeviceChange_Cleanup ()
{
   if (g_hMCDeviceEventContext) 
   {
       UnregisterDeviceNotification (g_hMCDeviceEventContext);
       g_hMCDeviceEventContext = NULL;
   }
}


void MCDeviceChange_Init (HWND hWnd, DWORD dwMixerID)
{
	DEV_BROADCAST_HANDLE DevBrodHandle;
	HANDLE hMixerDevice=NULL;

	//If we had registered already for device notifications, unregister ourselves.
	MCDeviceChange_Cleanup();

	//If we get the device handle register for device notifications on it.
	if(DeviceChange_GetHandle(dwMixerID, &hMixerDevice))
	{
		memset(&DevBrodHandle, 0, sizeof(DEV_BROADCAST_HANDLE));

		DevBrodHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
		DevBrodHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
		DevBrodHandle.dbch_handle = hMixerDevice;

		g_hMCDeviceEventContext = RegisterDeviceNotification(hWnd, &DevBrodHandle, DEVICE_NOTIFY_WINDOW_HANDLE);

		if(hMixerDevice)
		{
			CloseHandle(hMixerDevice);
			hMixerDevice = NULL;
		}
	}
}


// Handle the case where we need to dump mixer handle so PnP can get rid of a device
// We assume we will get the WINMM_DEVICECHANGE handle when the dust settles after a remove or add
// except for DEVICEQUERYREMOVEFAILED which will not generate that message.
//
void MCDeviceChange_Change (HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	PDEV_BROADCAST_HANDLE bh = (PDEV_BROADCAST_HANDLE)lParam;

	if(!g_hMCDeviceEventContext || !bh || bh->dbch_devicetype != DBT_DEVTYP_HANDLE)
	{
		return;
	}
	
    switch (wParam)
    {
	    case DBT_DEVICEQUERYREMOVE:     // Must free up Mixer if they are trying to remove the device           
        {
            FreeMCMixer ();
        }
        break;

	    case DBT_DEVICEQUERYREMOVEFAILED:   // Didn't happen, need to re-acquire mixer
        {
            InitMCVolume (hDlg);
        }
        break; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\perfpage.cpp ===
//--------------------------------------------------------------------------;
//
//  File: perfpage.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#include "mmcpl.h"
#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "utils.h"
#include "medhelp.h"


#include "advaudio.h"
#include "perfpage.h" 

////////////
// Defines
////////////


//////////////
// Help ID's
//////////////


#pragma data_seg(".text")
const static DWORD aAdvAudioHelp[] = {
    IDC_ACCELERATION,       IDH_ADV_AUDIO_ACCELERATION,
    IDC_HWMESSAGE,          IDH_ADV_AUDIO_ACCELERATION,
    IDC_SRCQUALITY,         IDH_ADV_AUDIO_SRCQUALITY,
    IDC_SRCMSG,             IDH_ADV_AUDIO_SRCQUALITY,
    IDC_DEFAULTS,           IDH_ADV_AUDIO_RESTOREDEFAULTS,
    IDC_ICON_3,             IDH_COMM_GROUPBOX,
    IDC_TEXT_14,            IDH_COMM_GROUPBOX,
    IDC_TEXT_15,            IDH_COMM_GROUPBOX,
    IDC_TEXT_16,            IDH_ADV_AUDIO_ACCELERATION,
    IDC_TEXT_17,            IDH_ADV_AUDIO_SRCQUALITY,
    IDC_TEXT_18,            IDH_ADV_AUDIO_ACCELERATION,
    IDC_TEXT_19,            IDH_ADV_AUDIO_ACCELERATION,
    IDC_TEXT_20,            IDH_ADV_AUDIO_SRCQUALITY,
    IDC_TEXT_21,            IDH_ADV_AUDIO_SRCQUALITY,

    0, 0
};
#pragma data_seg()


//////////////
// Functions
//////////////

void SetHardwareLevel(HWND hwnd, DWORD dwHWLevel)
{
    TCHAR str[255];

    SendDlgItemMessage( hwnd, IDC_ACCELERATION, TBM_SETPOS, TRUE, dwHWLevel);
    LoadString( ghInst, IDS_AUDHW1 + dwHWLevel, str, sizeof( str )/sizeof(TCHAR) );
    SetDlgItemText(hwnd, IDC_HWMESSAGE, str);

    gAudData.current.dwHWLevel = dwHWLevel;

    ToggleApplyButton(hwnd);
}



void SetSRCLevel(HWND hwnd, DWORD dwSRCLevel)
{
    TCHAR str[255];

    SendDlgItemMessage( hwnd, IDC_SRCQUALITY, TBM_SETPOS, TRUE, dwSRCLevel);
    LoadString( ghInst, IDS_SRCQUALITY1 + dwSRCLevel, str, sizeof( str )/sizeof(TCHAR) );
    SetDlgItemText(hwnd, IDC_SRCMSG, str);

    gAudData.current.dwSRCLevel = dwSRCLevel;

    ToggleApplyButton(hwnd);
}




void RestoreDefaults(HWND hwnd)
{
    // Check if we can set the acceleration level
    if (SUCCEEDED(CheckDSAccelerationPriv(gAudData.devGuid, gAudData.fRecord, NULL)))
    {
        SetHardwareLevel(hwnd,gAudData.dwDefaultHWLevel);
    }

    // Check if we can set the quality level
    if (SUCCEEDED(CheckDSSrcQualityPriv(gAudData.devGuid, gAudData.fRecord, NULL)))
    {
        SetSRCLevel(hwnd,DEFAULT_SRC_LEVEL);
    }
}




BOOL InitAdvDialog(HWND hwnd)
{
    HWND     hwndDlgItem;
    BOOL     fEnableAcceleration;
    BOOL     fEnableSrcQuality;
    DWORD    dwHWLevel = gAudData.current.dwHWLevel;
    DWORD    dwSRCLevel = gAudData.current.dwSRCLevel;

    SendDlgItemMessage( hwnd, IDC_ACCELERATION, TBM_SETRANGE, TRUE, MAKELONG( 0, MAX_HW_LEVEL ) );
    SendDlgItemMessage( hwnd, IDC_SRCQUALITY, TBM_SETRANGE, TRUE, MAKELONG( 0, MAX_SRC_LEVEL ) );

    SetHardwareLevel(hwnd,dwHWLevel);
    SetSRCLevel(hwnd,dwSRCLevel);

    // Check if we can set the acceleration level
    if (FAILED(CheckDSAccelerationPriv(gAudData.devGuid, gAudData.fRecord, NULL)))
    {
        // No - disable the slider
        fEnableAcceleration = FALSE;
    }
    else
    {
        // Yes - enable the slider
        fEnableAcceleration = TRUE;
    }
    
    // Enable/disable the acceleration slider appropriately
    hwndDlgItem = GetDlgItem( hwnd, IDC_ACCELERATION );
    if (hwndDlgItem)
    {
        EnableWindow( hwndDlgItem, fEnableAcceleration );
    }
    
    // Check if we can set the quality level
    if (FAILED(CheckDSSrcQualityPriv(gAudData.devGuid, gAudData.fRecord, NULL)))
    {
        // No - disable the slider
        fEnableSrcQuality = FALSE;
    }
    else
    {
        // Yes - enable the slider
        fEnableSrcQuality = TRUE;
    }

    // Enable/disable the quality slider appropriately
    hwndDlgItem = GetDlgItem( hwnd, IDC_SRCQUALITY );
    if (hwndDlgItem)
    {
        EnableWindow( hwndDlgItem, fEnableSrcQuality );
    }

    // Enable/disable the defaults button
    hwndDlgItem = GetDlgItem( hwnd, IDC_DEFAULTS );
    if (hwndDlgItem)
    {
        EnableWindow( hwndDlgItem, fEnableAcceleration || fEnableSrcQuality );
    }
                
    return(TRUE);
}



INT_PTR CALLBACK PerformanceHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fReturnVal = FALSE;
        
    switch (msg) 
    { 
        default:
            fReturnVal = FALSE;
        break;
        
        case WM_INITDIALOG:
        {
            fReturnVal = InitAdvDialog(hDlg);
        }        
        break;

        case WM_CONTEXTMENU:
        {      
            WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (UINT_PTR)(LPTSTR)aAdvAudioHelp);
            fReturnVal = TRUE;
        }
        break;
           
        case WM_HELP:
        {        
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (UINT_PTR)(LPTSTR)aAdvAudioHelp);
            fReturnVal = TRUE;
        }
        break;

        case WM_HSCROLL:
        {
            HWND hScroll = (HWND) lParam;

            if (hScroll == GetDlgItem(hDlg,IDC_ACCELERATION))
            {
                SetHardwareLevel(hDlg,(DWORD) SendDlgItemMessage( hDlg, IDC_ACCELERATION, TBM_GETPOS, 0, 0 ));
            }
            else if (hScroll == GetDlgItem(hDlg, IDC_SRCQUALITY))
            {
                SetSRCLevel(hDlg, (DWORD) SendDlgItemMessage( hDlg, IDC_SRCQUALITY, TBM_GETPOS, 0, 0 ));
            }
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDC_DEFAULTS:
                    RestoreDefaults(hDlg);
                break;

                default:
                    fReturnVal = FALSE;
                break;
            }
            break;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
                case PSN_APPLY:
                {
                    ApplyCurrentSettings(&gAudData);
                }
            }
        }
    }

    return fReturnVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\mmdevldr.h ===
/*
 *  MMDEVLDR.H - The main include file for the DevLoader
 *
 *  Version 4.00
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 */

#ifdef _WIN32								/* ;BeginInternal */
#define MMDEVLDR_IOCTL_GETVERSION           0
#define MMDEVLDR_IOCTL_LINPAGELOCK          1
#define MMDEVLDR_IOCTL_LINPAGEUNLOCK        2
#define MMDEVLDR_IOCTL_RING0THREADHANDLE    3
#define MMDEVLDR_IOCTL_QUEUEAPC             4
#define MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR   5
#define MMDEVLDR_IOCTL_CLOSEVXDHANDLE       6
#define MMDEVLDR_IOCTL_PAGEALLOCATE         7
#define MMDEVLDR_IOCTL_PAGEFREE             8
#define MMDEVLDR_IOCTL_GETDEVICESTATUS      9

#define MM_DEVSTATUS_ERROR          0
#define MM_DEVSTATUS_STARTED        1
#define MM_DEVSTATUS_UNKNOWNPROB    2
#define MM_DEVSTATUS_DISABLED       3


typedef struct tagLOCKUNLOCKPARMS
{
    DWORD           dwStartPage;
    DWORD           dwPageCount;
    DWORD           fdwOperation;
}   LOCKUNLOCKPARMS;

typedef struct tagQUEUEAPCPARMS
{
    DWORD           fnCallback;
    DWORD_PTR       dwUser;
    DWORD           hRing0Thd;
}   QUEUEAPCPARMS;

typedef struct tagPAGEALLOCATEPARMS
{
    DWORD           dwFlags;
    DWORD           dwPageCount;
} PAGEALLOCATEPARMS;

typedef struct tagPAGEALLOCATERETURN
{
    VOID *          lpvBase;
    DWORD           hMem;
    DWORD           dwPageCount;
    DWORD           dwPhysBase;
} PAGEALLOCATERETURN;

#endif

#ifdef MMDEVLDR_VXD					
#define MM_STOP 	0					
#define MM_START 	1					
#define MM_MMDEVLDR_UP  3			


#define CONFIG_QUERYSTART	0x01000

#define MAXLEN	256 					

typedef struct tagMMDEVNODE
{
   DEVNODE      dn ;
   DWORD        dwDevStatus ;
   VMMLIST      hlDrivers ;

} MMDEVNODE, *PMMDEVNODE ;


typedef struct tagMMDRVNODE
{
   CMCONFIGHANDLER  pConfigHandler ;
   DWORD            dwRefData ;

} MMDRVNODE, *PMMDRVNODE ;

//
// macros
//

#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))

#if defined(DEBUG_RETAIL) || defined(DEBUG)
#define	DBG_TRACE(strings) {\
	_Debug_Printf_Service( "MMDEVLDR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#ifdef DEBUG
#define	DBG_ERROR(strings) {\
	_Debug_Printf_Service( "MMDEVLDR ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");\
	{_asm	int	3}}
#else
#define	DBG_ERROR(strings) {\
	_Debug_Printf_Service( "MMDEVLDR ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#endif
#else
   #define DBG_TRACE(strings)
   #define DBG_ERROR(strings)
#endif

#ifdef DEBUG
#define DPF( strings ) _Debug_Printf_Service##strings;
#else
#define DPF( strings )
#endif

#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") : " str

//
// internal function prototypes
//

void MMDEVLDR_Call_MMSystem(DEVNODE dnDevNode, DWORD fLoad);
void MMDEVLDR_CheckForMMSystem(void);
DWORD StringLen(PCHAR psz);
PCHAR StringCopy(PCHAR pszDst, PCHAR pszSrc);
PCHAR StringCat(PCHAR pszDst, PCHAR pszSrc);

#pragma warning (disable:4035)		// turn off no return code warning
PSTR VXDINLINE Get_Environment_String
(
    PSTR            pszName
)
{
    _asm push esi
    _asm mov esi, pszName
    VMMCall( Get_Environment_String ) ;
    _asm mov   eax, edx
    _asm pop   esi
}
#pragma warning (default:4035)     // turn on no return code warning

BOOL _InitGlobalEnvironment() ;

VOID MMDEVLDR_SetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

BOOL MMDEVLDR_GetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue,
    UINT            uBufSize
) ;

VOID MMDEVLDR_RemoveEnvironmentString
(
    PSTR            pszName
) ;

VOID	MMDEVLDR_AddEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

#else								/* ;EndInternal */


#define Multimedia_OEM_ID   0x0440	//            ; MS Reserved OEM # 34
#define MMDEVLDR_DEVICE_ID  Multimedia_OEM_ID + 10 	//;MMDEVLDR's device ID

#ifdef Begin_Service_Table		// define only if vmm.h is included

#define	MMDEVLDR_Service	Declare_Service
#pragma warning (disable:4003)		// turn off not enough params warning

//MACROS
Begin_Service_Table(MMDEVLDR)

MMDEVLDR_Service	(MMDEVLDR_Register_Device_Driver, LOCAL)
MMDEVLDR_Service	(MMDEVLDR_SetDevicePresence)
MMDEVLDR_Service  (MMDEVLDR_SetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_GetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_RemoveEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_AddEnvironmentString)

End_Service_Table(MMDEVLDR)
//ENDMACROS

#pragma warning (default:4003)		// turn on not enough params warning

#pragma warning (disable:4035)		// turn off no return code warning

VOID VXDINLINE MMDEVLDR_Register_Device_Driver
(
    DEVNODE         dnDevNode,
    DWORD           fnConfigHandler,
    DWORD_PTR       dwUserData
)
{
    _asm push ebx
    _asm mov eax,dnDevNode
    _asm mov ebx,fnConfigHandler
    _asm mov ecx,dwUserData
    Touch_Register(edx)
    VxDCall(MMDEVLDR_Register_Device_Driver);
    _asm pop ebx
}

VOID VXDINLINE MMDEVLDR_SetDevicePresence
(
    DEVNODE         dn,
    PCHAR           pszReg,
    BOOL            fPresent
)
{
    _asm push fPresent
    _asm push pszReg
    _asm push dn
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetDevicePresence);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_SetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetEnvironmentString);
    _asm add  esp, 2*4
} ;

BOOL VXDINLINE MMDEVLDR_GetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue,
    UINT            uBufSize
)
{
    _asm push uBufSize
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_GetEnvironmentString);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_RemoveEnvironmentString
(
    PCHAR           pszName
)
{
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_RemoveEnvironmentString);
    _asm add  esp, 4
} ;

VOID VXDINLINE MMDEVLDR_AddEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_AddEnvironmentString);
    _asm add  esp, 2*4
} ;

#pragma warning (disable:4035)		// turn on no return code warning

#endif // Begin_Service_Table

#endif 			/* ;Internal */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\msacmcpl.c ===
//==========================================================================;
//
//  cpl.c
//
//  Copyright (c) 1991-1993 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//
//
//  History:
//      07/94        VijR (Vij Rajarajan);
//
//      10/95        R Jernigan - removed link to Adv tab's treeview control
//
//==========================================================================;
#include "mmcpl.h"
#include <windowsx.h>
#include <mmsystem.h>
#include <dbt.h>
#include <ks.h>
#include <ksmedia.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <msacmdlg.h>
#include <stdlib.h>
#include "gfxui.h"
#include "drivers.h"
#include "advaudio.h"
#include "roland.h"

#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <devguid.h>

#define WM_ACMMAP_ACM_NOTIFY        (WM_USER + 100)

#include <memory.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "trayvol.h"

#include "utils.h"
#include "medhelp.h"

/*
 ***************************************************************
 * Defines
 ***************************************************************
 */

#ifndef DRV_F_ADD
#define DRV_F_ADD              0x00000000         // TODO: Should be in MMDDK.H
#define DRV_F_REMOVE           0x00000001
#define DRV_F_CHANGE           0x00000002
#define DRV_F_PROP_INSTR       0x00000004
#define DRV_F_NEWDEFAULTS      0x00000008
#define DRV_F_PARAM_IS_DEVNODE 0x10000000
#endif

#ifndef ACMHELPMSGCONTEXTMENU                                  // TODO: Should
#define ACMHELPMSGCONTEXTMENU   TEXT("acmchoose_contextmenu")  // be in MSACM.H
#define ACMHELPMSGCONTEXTHELP   TEXT("acmchoose_contexthelp")
#endif

#ifndef ACMFORMATCHOOSE_STYLEF_CONTEXTHELP    // TODO: Should be in MSACM.H
#define ACMFORMATCHOOSE_STYLEF_CONTEXTHELP    0x00000080L
#endif

/*
 ***************************************************************
 * Globals
 ***************************************************************
 */

BOOL        gfLoadedACM;
UINT        giDevChange = 0;
WNDPROC     gfnPSProc = NULL;
HWND        ghDlg;

/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */
typedef struct tACMDRIVERSETTINGS
    {
    HACMDRIVERID        hadid;
    DWORD               fdwSupport;
    DWORD               dwPriority;
    } ACMDRIVERSETTINGS, FAR *LPACMDRIVERSETTINGS;

typedef struct _CplCodecInfo
    {
    TCHAR szDesc[128];
    ACMDRIVERSETTINGS ads;
    HICON hIcon;
    BOOL  fMadeIcon;
    }CPLCODECINFO, * PCPLCODECINFO;



/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
static CONST TCHAR      aszFormatNumber[]       = TEXT("%lu");

//
//  These hold Window Message IDs for the two messages sent from the
//  Customize dialog (acmFormatChoose) for context-sensitive help.
//
UINT guCustomizeContextMenu = WM_NULL;
UINT guCustomizeContextHelp = WM_NULL;
BOOL fHaveStartedAudioDialog = FALSE;


/*
 ***************************************************************
 * extern
 ***************************************************************
 */

//
//  this string variable must be large enough to hold the IDS_TXT_DISABLED
//  resource string.. for USA, this is '(disabled)'--which is 11 bytes
//  including the NULL terminator.
//
TCHAR gszDevEnabled[256];
TCHAR gszDevDisabled[256];

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */

BOOL PASCAL DoACMPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
BOOL PASCAL DoAudioCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
BOOL PASCAL CustomizeDialog(HWND hDlg, LPTSTR szNewFormat, DWORD cbSize);
void DoAdvancedSetup(HWND hwnd);

void WAVEOUTInit(HWND hDlg, PAUDIODLGINFO pai);
void WAVEINInit(HWND hDlg, PAUDIODLGINFO pai);


PCPLCODECINFO acmFindCodecInfo         (WORD, WORD);
BOOL CALLBACK acmFindCodecInfoCallback (HACMDRIVERID, DWORD_PTR, DWORD);
void          acmFreeCodecInfo         (PCPLCODECINFO);

UINT          acmCountCodecs           (void);
BOOL CALLBACK acmCountCodecsEnum       (HACMDRIVERID, DWORD_PTR, DWORD);


#ifndef ACM_DRIVERREMOVEF_UNINSTALL
#define ACM_DRIVERREMOVEF_UNINSTALL 0x00000001L
#endif

/*
 ***************************************************************
 ***************************************************************
 */

void acmDeleteCodec (WORD wMid, WORD wPid)
{
    PCPLCODECINFO pci;

    if ((pci = acmFindCodecInfo (wMid, wPid)) != NULL)
    {
        acmDriverRemove (pci->ads.hadid, ACM_DRIVERREMOVEF_UNINSTALL);
        acmFreeCodecInfo (pci);
    }
}




//--------------------------------------------------------------------------;
//
//  INT_PTR DlgProcACMAboutBox
//
//  Description:
//
//
//  Arguments:
//
//  Return (BOOL):
//
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

INT_PTR CALLBACK DlgProcACMAboutBox
(
    HWND                hwnd,
    UINT                uMsg,
    WPARAM              wParam,
    LPARAM              lParam
)
{
    TCHAR               ach[80];
    TCHAR               szFormat[80];
    LPACMDRIVERDETAILS  padd;
    DWORD               dw1;
    DWORD               dw2;
    UINT                uCmdId;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            padd = (LPACMDRIVERDETAILSW)lParam;

            if (NULL == padd)
            {
                DPF(0, "!DlgProcACMAboutBox: NULL driver details passed!");
                return (TRUE);
            }

            //
            //  fill in all the static text controls with the long info
            //  returned from the driver
            //
            LoadString(ghInstance, IDS_ABOUT_TITLE, szFormat, sizeof(szFormat)/sizeof(TCHAR));
            wsprintf(ach, szFormat, (LPTSTR)padd->szShortName);
            SetWindowText(hwnd, ach);

            //
            //  if the driver supplies an icon, then use it..
            //
            if (NULL != padd->hicon)
            {
                Static_SetIcon(GetDlgItem(hwnd, IDD_ABOUT_ICON_DRIVER), padd->hicon);
            }

            SetDlgItemText(hwnd, IDD_ABOUT_TXT_DESCRIPTION, padd->szLongName);

            dw1 = padd->vdwACM;
            dw2 = padd->vdwDriver;
            LoadString(ghInstance, IDS_ABOUT_VERSION, szFormat, sizeof(szFormat)/sizeof(TCHAR));
            wsprintf(ach, szFormat, HIWORD(dw2) >> 8, (BYTE)HIWORD(dw2), HIWORD(dw1) >> 8, (BYTE)HIWORD(dw1));
            SetDlgItemText(hwnd,IDD_ABOUT_TXT_VERSION, ach);
            SetDlgItemText(hwnd, IDD_ABOUT_TXT_COPYRIGHT, padd->szCopyright);
            SetDlgItemText(hwnd, IDD_ABOUT_TXT_LICENSING, padd->szLicensing);
            SetDlgItemText(hwnd, IDD_ABOUT_TXT_FEATURES, padd->szFeatures);
            return (TRUE);
        }
        break;

        case WM_COMMAND:
        {
            uCmdId = GET_WM_COMMAND_ID(wParam,lParam);

            if ((uCmdId == IDOK) || (uCmdId == IDCANCEL))
            EndDialog(hwnd, wParam == uCmdId);
            return (TRUE);
        }
        break;

    }

    return (FALSE);
} // DlgProcACMAboutBox()


//--------------------------------------------------------------------------;
//
//  void ControlAboutDriver
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//      LPACMDRIVERSETTINGS pads:
//
//  Return (void):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

STATIC void  ControlAboutDriver
(
    HWND                    hwnd,
    LPACMDRIVERSETTINGS     pads
)
{
    PACMDRIVERDETAILSW   padd;
    MMRESULT             mmr;

    if (NULL == pads)
    {
        return;
    }

    //
    //  if the driver returns MMSYSERR_NOTSUPPORTED, then we need to
    //  display the info--otherwise, it supposedly displayed a dialog
    //  (or had a critical error?)
    //
    mmr = (MMRESULT)acmDriverMessage((HACMDRIVER)pads->hadid, ACMDM_DRIVER_ABOUT, (LPARAM)hwnd, 0L);

    if ((MMRESULT)MMSYSERR_NOTSUPPORTED != mmr)
    {
        return;
    }

    //
    //  alloc some zero-init'd memory to hold the about box info
    //
    padd = (PACMDRIVERDETAILS)LocalAlloc(LPTR, sizeof(*padd));
    if (NULL == padd)
    {
        DPF("!PACMDRIVERDETAILSA LocalAlloc failed");
        return;
    }
    //
    //  get info and bring up a generic about box...
    //
    padd->cbStruct = sizeof(*padd);
    mmr = (MMRESULT)acmDriverDetails(pads->hadid, padd, 0L);
    if (MMSYSERR_NOERROR == mmr)
    {
        DialogBoxParam(ghInstance, MAKEINTRESOURCE(DLG_ABOUT_MSACM), hwnd, DlgProcACMAboutBox, (LPARAM)(LPVOID)padd);
    }

    LocalFree((HLOCAL)padd);
} // ControlAboutDriver()


//--------------------------------------------------------------------------;
//
//  BOOL ControlConfigureDriver
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//      LPACMDRIVERSETTINGS pads:
//
//  Return (BOOL):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

STATIC BOOL  ControlConfigureDriver
(
    HWND                    hwnd,
    LPACMDRIVERSETTINGS     pads
)
{
    if (NULL == pads)
    {
        return (FALSE);
    }

    if (acmDriverMessage((HACMDRIVER)pads->hadid,DRV_CONFIGURE,(LPARAM)hwnd,0L) == DRVCNF_RESTART)
    {
        DisplayMessage(hwnd, IDS_CHANGESAVED, IDS_RESTART, MB_OK);
    }

    return (TRUE);
} // ControlConfigureDriver()




STATIC void CommitCodecChanges(LPACMDRIVERSETTINGS pads)
{
    MMRESULT            mmr;
    BOOL                fDisabled;
    DWORD               fdwPriority;

    mmr = (MMRESULT)acmDriverPriority(NULL, 0L, ACM_DRIVERPRIORITYF_BEGIN);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlApplySettings: acmDriverPriority(end) failed! mmr=%u", mmr);
        return;
    }

    fDisabled = (0 != (ACMDRIVERDETAILS_SUPPORTF_DISABLED & pads->fdwSupport));

    fdwPriority = fDisabled ? ACM_DRIVERPRIORITYF_DISABLE : ACM_DRIVERPRIORITYF_ENABLE;

    mmr = (MMRESULT)acmDriverPriority(pads->hadid, pads->dwPriority, fdwPriority);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlApplySettings: acmDriverPriority(%.04Xh, %lu, %.08lXh) failed! mmr=%u",
        pads->hadid, pads->dwPriority, fdwPriority, mmr);
    }

    mmr = (MMRESULT)acmDriverPriority(NULL, 0L, ACM_DRIVERPRIORITYF_END);
}


const static DWORD aACMDlgHelpIds[] = {  // Context Help IDs
    ID_DEV_SETTINGS,              IDH_MMCPL_DEVPROP_SETTINGS,
    IDD_CPL_BTN_ABOUT,            IDH_MMCPL_DEVPROP_ABOUT,
    IDC_ENABLE,                   IDH_MMCPL_DEVPROP_ENABLE,
    IDC_DISABLE,                  IDH_MMCPL_DEVPROP_DISABLE,
    IDC_DEV_ICON,                 NO_HELP,
    IDC_DEV_DESC,                 NO_HELP,
    IDC_DEV_STATUS,               NO_HELP,
    IDD_PRIORITY_TXT_FROMTO,      IDH_MMCPL_DEVPROP_CHANGE_PRI,
    IDD_PRIORITY_COMBO_PRIORITY,  IDH_MMCPL_DEVPROP_CHANGE_PRI,

    0, 0
};

INT_PTR CALLBACK ACMDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR   *lpnm;
    static PCPLCODECINFO pci = NULL;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            lpnm = (NMHDR FAR *)lParam;

            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                break;

                case PSN_SETACTIVE:
                    //FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                break;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            HWND hwndS = GetDlgItem(hDlg, IDC_DEV_STATUS);
            LPARAM lpUser = ((LPPROPSHEETPAGE)lParam)->lParam;

            if ((pci = acmFindCodecInfo (LOWORD(lpUser), HIWORD(lpUser))) == NULL)
            {
                FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                break;
            }

            acmMetrics((HACMOBJ)pci->ads.hadid, ACM_METRIC_DRIVER_PRIORITY, &(pci->ads.dwPriority));
            acmMetrics((HACMOBJ)pci->ads.hadid, ACM_METRIC_DRIVER_SUPPORT, &(pci->ads.fdwSupport));


            SendDlgItemMessage(hDlg, IDC_DEV_ICON, STM_SETICON, (WPARAM)pci->hIcon, 0L);

            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pci);
            SetWindowText(GetDlgItem(hDlg, IDC_DEV_DESC), pci->szDesc);

            LoadString (ghInstance, IDS_DEVENABLEDOK, gszDevEnabled, sizeof(gszDevEnabled)/sizeof(TCHAR));
            LoadString (ghInstance, IDS_DEVDISABLED, gszDevDisabled, sizeof(gszDevDisabled)/sizeof(TCHAR));

            if(pci->ads.fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED)
            {
                SetWindowText(hwndS, gszDevDisabled);
                CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_DISABLE);
            }
            else
            {
                SetWindowText(hwndS, gszDevEnabled);
                CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_ENABLE);
            }

            EnableWindow(GetDlgItem(hDlg, ID_DEV_SETTINGS), (MMRESULT)acmDriverMessage((HACMDRIVER)pci->ads.hadid,DRV_QUERYCONFIGURE,0,0));

            FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
        }
        break;

        case WM_DESTROY:
        {
            FORWARD_WM_COMMAND(hDlg, ID_REBUILD, 0, 0, SendMessage);

            if (pci != NULL)
            {
                acmFreeCodecInfo (pci);
                pci = NULL;
            }
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU, (UINT_PTR) (LPTSTR) aACMDlgHelpIds);
            return TRUE;
        }
        break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP, (UINT_PTR) (LPTSTR) aACMDlgHelpIds);
            return TRUE;
        }
        break;

        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoACMPropCommand);
        }
        break;
    }
    return FALSE;
}


BOOL PASCAL DoACMPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    PCPLCODECINFO           pci;
    LPACMDRIVERSETTINGS     pads;
    static int              iPriority = 0;
    static BOOL             fDisabled = TRUE;
    static BOOL             fRebuild;
    HWND hwndS =            GetDlgItem(hDlg, IDC_DEV_STATUS);

    if ((pci = (PCPLCODECINFO)GetWindowLongPtr(hDlg,DWLP_USER)) == NULL)
    {
        return FALSE;
    }

    pads = &(pci->ads);

    switch (id)
    {
        case ID_APPLY:
        {
            HWND hcb = GetDlgItem(hDlg, IDD_PRIORITY_COMBO_PRIORITY);
            if ((fDisabled != Button_GetCheck(GetDlgItem(hDlg, IDC_DISABLE))) || (iPriority != ComboBox_GetCurSel(hcb)+1))
            {
                pads->fdwSupport ^= ACMDRIVERDETAILS_SUPPORTF_DISABLED;
                fDisabled = (0 != (pads->fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED));
                iPriority = pads->dwPriority  = ComboBox_GetCurSel(hcb)+1;
                CommitCodecChanges(pads);
                fRebuild = TRUE;
            }
            return TRUE;
        }

        case ID_REBUILD:
        {
            if (fRebuild && pci)
            {
                SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)0);
                fRebuild = FALSE;
            }
        }
        break;

        case ID_INIT:
        {
            TCHAR achFromTo[80];
            TCHAR ach[80];
            HWND hcb;
            UINT u;
            UINT nCodecs;

            iPriority = (int)pads->dwPriority;
            fDisabled = (0 != (pads->fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED));
            fRebuild = FALSE;

            LoadString(ghInstance, IDS_PRIORITY_FROMTO, achFromTo, sizeof(achFromTo)/sizeof(TCHAR));

            wsprintf(ach, achFromTo, iPriority);
            SetDlgItemText(hDlg, IDD_PRIORITY_TXT_FROMTO, ach);

            hcb = GetDlgItem(hDlg, IDD_PRIORITY_COMBO_PRIORITY);

            nCodecs = acmCountCodecs();

            for (u = 1; u <= (UINT)nCodecs; u++)
            {
                wsprintf(ach, aszFormatNumber, (DWORD)u);
                ComboBox_AddString(hcb, ach);
            }

            ComboBox_SetCurSel(hcb, iPriority - 1);
        }
        break;

        case IDD_PRIORITY_COMBO_PRIORITY:
        {
            switch (codeNotify)
            {
                case CBN_SELCHANGE:
                {
                    PropSheet_Changed(GetParent(hDlg),hDlg);
                }
                break;
            }
        }
        break;


        case IDC_ENABLE:
        {
            SetWindowText(hwndS, gszDevEnabled);
            CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_ENABLE);
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;

        case IDC_DISABLE:
        {
            SetWindowText(hwndS, gszDevDisabled);
            CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_DISABLE);
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;

        case ID_DEV_SETTINGS:
        {
            ControlConfigureDriver(hDlg, pads);
        }
        break;

        case IDD_CPL_BTN_ABOUT:
        {
            ControlAboutDriver(hDlg, pads);
        }
        break;
    }

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetWaveOutID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD_PTR       dwWaveID = 0;
    DWORD           dwFlags = 0;

    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(DWORD)(dwWaveID);
}

///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
void SetWaveOutID(DWORD dwWaveID, BOOL fPrefOnly)
{
    MMRESULT    mmr;
    DWORD       dwParam1, dwParam2;
    DWORD       dwFlags = fPrefOnly ? 0x00000001 : 0x00000000;

    mmr = waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_PREFERRED_SET, dwWaveID, dwFlags);
}



///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetWaveInID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD_PTR       dwWaveID = 0;
    DWORD           dwFlags = 0;

    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveInMessage(HWAVEIN_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(DWORD)(dwWaveID);
}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
void SetWaveInID(DWORD dwWaveID, BOOL fPrefOnly)
{
    MMRESULT    mmr;
    DWORD       dwParam1, dwParam2;
    DWORD       dwFlags = fPrefOnly ? 0x00000001 : 0x00000000;

    mmr = waveInMessage(HWAVEIN_MAPPER, DRVM_MAPPER_PREFERRED_SET, dwWaveID, dwFlags);
}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetMIDIOutID(void)
{
    MMRESULT        mmr;
    DWORD           dwWaveID;
    DWORD           dwFlags = 0;

    mmr = midiOutMessage(HMIDIOUT_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    return(dwWaveID);
}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
void SetMIDIOutID(DWORD dwWaveID)
{
    MMRESULT    mmr;
    DWORD       dwParam1, dwParam2;

    mmr = midiOutMessage(HMIDIOUT_MAPPER, DRVM_MAPPER_PREFERRED_SET, dwWaveID, 0);
}




void GetPrefInfo(PAUDIODLGINFO pai, HWND hDlg )
{
    MMRESULT        mmr;

    // Load WaveOut Info
	pai->cNumOutDevs = waveOutGetNumDevs();
    pai->uPrefOut = GetWaveOutID(&pai->fPrefOnly);


    // Load WaveIn Info
    pai->cNumInDevs  = waveInGetNumDevs();
    pai->uPrefIn = GetWaveInID(NULL);


    // Load MIDI Out info
    pai->cNumMIDIOutDevs  = midiOutGetNumDevs();
    pai->uPrefMIDIOut = GetMIDIOutID();
}



STATIC void EnablePlayVolCtrls(HWND hDlg, BOOL fEnable)
{
    EnableWindow( GetDlgItem(hDlg, IDC_LAUNCH_SNDVOL) , fEnable);
    EnableWindow( GetDlgItem(hDlg, IDC_PLAYBACK_ADVSETUP) , fEnable);
}

STATIC void EnableRecVolCtrls(HWND hDlg, BOOL fEnable, BOOL fControl)
{
    EnableWindow( GetDlgItem(hDlg, IDC_LAUNCH_RECVOL) , fEnable);
    EnableWindow( GetDlgItem(hDlg, IDC_RECORD_ADVSETUP) , fControl);
}


STATIC void EnableMIDIVolCtrls(HWND hDlg, BOOL fEnable)
{
    EnableWindow( GetDlgItem(hDlg, IDC_LAUNCH_MUSICVOL) , fEnable);
}


STATIC void SetDeviceOut(PAUDIODLGINFO pai, UINT uID, HWND hDlg)
{
    BOOL    fEnabled = FALSE;
    HMIXER  hMixer = NULL;
    UINT    uMixID;

    pai->uPrefOut = uID;     // New device, lets setup buttons for this device

    if(MMSYSERR_NOERROR == mixerGetID(HMIXEROBJ_INDEX(pai->uPrefOut), &uMixID, MIXER_OBJECTF_WAVEOUT))
    {
        if(MMSYSERR_NOERROR == mixerOpen(&hMixer, uMixID, 0L, 0L, 0L))
        {
            fEnabled = TRUE;
            mixerClose(hMixer);
        }
	}

	EnablePlayVolCtrls(hDlg, fEnabled);
}



DWORD CountInputs(DWORD dwMixID)
{
    MIXERCAPS   mc;
    MMRESULT    mmr;
    DWORD dwCount = 0;

    mmr = mixerGetDevCaps(dwMixID, &mc, sizeof(mc));

    if (mmr == MMSYSERR_NOERROR)
    {
        MIXERLINE   mlDst;
        DWORD       dwDestination;
        DWORD       cDestinations;

        cDestinations = mc.cDestinations;

        for (dwDestination = 0; dwDestination < cDestinations; dwDestination++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination = dwDestination;

            if (mixerGetLineInfo(HMIXEROBJ_INDEX(dwMixID), &mlDst, MIXER_GETLINEINFOF_DESTINATION  ) == MMSYSERR_NOERROR)
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_WAVEIN ||    // needs to be a likely output destination
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_VOICEIN)
                {
                    DWORD cConnections = mlDst.cConnections;

                    dwCount += mlDst.cControls;

                    if (cConnections)
                    {
                        DWORD dwSource;

                        for (dwSource = 0; dwSource < cConnections; dwSource++)
                        {
                            mlDst.dwDestination = dwDestination;
                            mlDst.dwSource = dwSource;

                            if (mixerGetLineInfo(HMIXEROBJ_INDEX(dwMixID), &mlDst, MIXER_GETLINEINFOF_SOURCE ) == MMSYSERR_NOERROR)
                            {
                                dwCount += mlDst.cControls;
                            }
                        }
                    }
                }
            }
        }
    }

    return(dwCount);
}


STATIC void SetDeviceIn(PAUDIODLGINFO pai, UINT uID, HWND hDlg)
{
    BOOL    fEnabled = FALSE;
    BOOL    fControl = FALSE;
    HMIXER  hMixer = NULL;
    UINT    uMixID;

    pai->uPrefIn = uID;     // New device, lets setup buttons for this device

    if( (MMSYSERR_NOERROR == mixerGetID(HMIXEROBJ_INDEX(pai->uPrefIn),&uMixID, MIXER_OBJECTF_WAVEIN)))
    {
        if( MMSYSERR_NOERROR == mixerOpen(&hMixer, uMixID, 0L, 0L, 0L))  
        {
            if (CountInputs(uMixID))
            {
		        fEnabled = TRUE;

                // If the capture device is not GFX capable, then there are no tabs to display
                fControl = GFXUI_CheckDevice(uMixID, GFXTYPE_CAPTURE);
            }

            mixerClose(hMixer);
        }
    }

    EnableRecVolCtrls(hDlg, fEnabled, fControl);
}


STATIC void SetMIDIDeviceOut(PAUDIODLGINFO pai, UINT uID, HWND hDlg)
{
    BOOL        fEnabled = FALSE;
    HMIXER      hMixer = NULL;
    UINT        uMixID;
    MIDIOUTCAPS moc;
    MMRESULT    mmr;
    UINT        mid;

    pai->uPrefMIDIOut = uID;     // New device, lets setup buttons for this device

    if(MMSYSERR_NOERROR == mixerGetID(HMIXEROBJ_INDEX(pai->uPrefMIDIOut), &uMixID, MIXER_OBJECTF_MIDIOUT))
    {
        if(MMSYSERR_NOERROR == mixerOpen(&hMixer, uMixID, 0L, 0L, 0L))
        {
            fEnabled = TRUE;
            mixerClose(hMixer);
        }
    }

    EnableMIDIVolCtrls(hDlg, fEnabled);

    fEnabled = FALSE;
    mmr = midiOutGetDevCaps(pai->uPrefMIDIOut, &moc, sizeof(moc));

    if (MMSYSERR_NOERROR == mmr)
    {
        if ((moc.wMid == MM_MICROSOFT) && (moc.wPid == MM_MSFT_WDMAUDIO_MIDIOUT) && (moc.wTechnology == MOD_SWSYNTH))
        {
            fEnabled = TRUE;
        }
    }

    EnableWindow( GetDlgItem(hDlg, IDC_MUSIC_ABOUT) , fEnabled);
}


STDAPI_(void) DoRolandAbout(HWND hWnd)
{
    UINT uWaveID = 0;

    if (GetWaveID(&uWaveID) != (MMRESULT)MMSYSERR_ERROR)
    {
        WAVEOUTCAPS woc;

        if (waveOutGetDevCaps(uWaveID, &woc, sizeof(woc)) == MMSYSERR_NOERROR)
        {
            RolandProp(hWnd, ghInstance, woc.szPname);
        }
    }
}


STATIC void SetPrefInfo(PAUDIODLGINFO pai, HWND hDlg )
{
    HWND    hwndCBPlay   = GetDlgItem(hDlg, IDC_AUDIO_CB_PLAY);
    HWND    hwndCBRec    = GetDlgItem(hDlg, IDC_AUDIO_CB_REC);
    HWND    hwndCBMIDI   = GetDlgItem(hDlg, IDC_MUSIC_CB_PLAY);
    HKEY    hkeyAcm;
    UINT    item, deviceID;
    TCHAR   szPref[MAXSTR];

    pai->fPrefOnly = Button_GetCheck(GetDlgItem(hDlg, IDC_AUDIO_PREF));

    item = (UINT)ComboBox_GetCurSel(hwndCBPlay);

    if (item != CB_ERR)
    {
        deviceID = (UINT)ComboBox_GetItemData(hwndCBPlay, item);

        if(deviceID != pai->uPrefOut)             // Make sure device changed
        {
            SetDeviceOut(pai, deviceID, hDlg);    // Configure controls for this device
        }
    }

    item = (UINT)ComboBox_GetCurSel(hwndCBRec);

    if (item != CB_ERR)
    {
        deviceID = (UINT)ComboBox_GetItemData(hwndCBRec, item);

        if( deviceID != pai->uPrefIn )            // Make sure device changed
        {
            SetDeviceIn(pai, deviceID, hDlg);     // Configure controls for this device
        }
    }

    item = (UINT)ComboBox_GetCurSel(hwndCBMIDI);

    if (item != CB_ERR)
    {
        deviceID = (UINT)ComboBox_GetItemData(hwndCBMIDI, item);

        if(deviceID != pai->uPrefMIDIOut)         // Make sure device changed
        {
            SetMIDIDeviceOut(pai, deviceID, hDlg);    // Configure controls for this device
        }
    }

    SetWaveOutID(pai->uPrefOut, pai->fPrefOnly);
    SetWaveInID(pai->uPrefIn, pai->fPrefOnly);
    SetMIDIOutID(pai->uPrefMIDIOut);

    WAVEOUTInit(hDlg, pai);
    WAVEINInit(hDlg, pai);

    //  MIDI Devices are not remapped...
}



STATIC void MSACM_NotifyMapper(void)
{
    waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, DRV_F_NEWDEFAULTS);
    waveInMessage(HWAVEIN_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, DRV_F_NEWDEFAULTS);
    midiOutMessage(HMIDIOUT_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, DRV_F_NEWDEFAULTS);
}



STATIC void WAVEOUTInit(HWND hDlg, PAUDIODLGINFO pai)
{
    HWND        hwndCBPlay = GetDlgItem(hDlg, IDC_AUDIO_CB_PLAY);
    MMRESULT    mr;
    UINT        device;
    TCHAR       szNoAudio[128];

    szNoAudio[0] = TEXT('\0');

    ComboBox_ResetContent(hwndCBPlay);

    if (pai->cNumOutDevs == 0)
    {
        LoadString (ghInstance, IDS_NOAUDIOPLAY, szNoAudio, sizeof(szNoAudio)/sizeof(TCHAR));
        ComboBox_AddString(hwndCBPlay, szNoAudio);
        ComboBox_SetItemData(hwndCBPlay, 0, (LPARAM)-1);
        ComboBox_SetCurSel(hwndCBPlay, 0);
        EnableWindow( hwndCBPlay, FALSE );
        EnablePlayVolCtrls(hDlg, FALSE);
	}
    else
    {
        EnableWindow( hwndCBPlay, TRUE );

        for (device = 0; device < pai->cNumOutDevs; device++)
        {
            WAVEOUTCAPS     woc;
            int newItem;

            woc.szPname[0]  = TEXT('\0');

            if (waveOutGetDevCapsW(device, &woc, sizeof(woc)))
            {
                continue;
            }

            woc.szPname[sizeof(woc.szPname)/sizeof(TCHAR) - 1] = TEXT('\0');

            newItem = ComboBox_AddString(hwndCBPlay, woc.szPname);

            if (newItem != CB_ERR && newItem != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwndCBPlay, newItem, (LPARAM)device);

                if (device == pai->uPrefOut)
                {
                    ComboBox_SetCurSel(hwndCBPlay, newItem);
                    SetDeviceOut(pai, device, hDlg);
                }
            }
        }
    }
}

STATIC void WAVEINInit(HWND hDlg, PAUDIODLGINFO pai)
{
    HWND        hwndCBRec = GetDlgItem(hDlg, IDC_AUDIO_CB_REC);
    MMRESULT    mr;
    UINT        device;
    TCHAR       szNoAudio[128];

    ComboBox_ResetContent(hwndCBRec);

    if (pai->cNumInDevs == 0)
    {
        LoadString (ghInstance, IDS_NOAUDIOREC, szNoAudio, sizeof(szNoAudio)/sizeof(TCHAR));
        ComboBox_AddString(hwndCBRec, szNoAudio);
        ComboBox_SetItemData(hwndCBRec, 0, (LPARAM)-1);
        ComboBox_SetCurSel(hwndCBRec, 0);
        EnableWindow( hwndCBRec, FALSE );
        EnableRecVolCtrls(hDlg, FALSE, FALSE);
    }
    else
    {
        EnableWindow( hwndCBRec, TRUE );

        for (device = 0; device < pai->cNumInDevs; device++)
        {
            WAVEINCAPSW     wic;
            int newItem;

            wic.szPname[0]  = TEXT('\0');

            if (waveInGetDevCapsW(device, &wic, sizeof(wic)))
            {
                continue;
            }

            wic.szPname[sizeof(wic.szPname)/sizeof(TCHAR) - 1] = TEXT('\0');

            newItem = ComboBox_AddString(hwndCBRec, wic.szPname);

            if (newItem != CB_ERR && newItem != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwndCBRec, newItem, (LPARAM)device);

                if (device == pai->uPrefIn)
                {
                    ComboBox_SetCurSel(hwndCBRec, newItem);
                    SetDeviceIn(pai, device, hDlg);
                }
            }
        }
    }
}


STATIC void MIDIInit(HWND hDlg, PAUDIODLGINFO pai)
{
    HWND        hwnd  = GetDlgItem(hDlg, IDC_MUSIC_CB_PLAY);
    MMRESULT    mr;
    UINT        device;
    TCHAR       szNoAudio[128];

    ComboBox_ResetContent(hwnd);

    szNoAudio[0] = TEXT('\0');

    EnableWindow( GetDlgItem(hDlg, IDC_MUSIC_ABOUT) , FALSE);

    if (pai->cNumMIDIOutDevs == 0)
    {
        LoadString (ghInstance, IDS_NOMIDIPLAY, szNoAudio, sizeof(szNoAudio)/sizeof(TCHAR));
        ComboBox_AddString(hwnd, szNoAudio);
        ComboBox_SetItemData(hwnd, 0, (LPARAM)-1);
        ComboBox_SetCurSel(hwnd, 0);
        EnableWindow( hwnd, FALSE );
        EnableMIDIVolCtrls(hDlg, FALSE);
    }
    else
    {
        EnableWindow( hwnd, TRUE );
        for (device = 0; device < pai->cNumMIDIOutDevs; device++)
        {
            MIDIOUTCAPS moc;
            int newItem;

            moc.szPname[0]  = TEXT('\0');

            if (midiOutGetDevCapsW(device, &moc, sizeof(moc)))
            {
                continue;
            }

            moc.szPname[sizeof(moc.szPname)/sizeof(TCHAR) - 1] = TEXT('\0');

            newItem = ComboBox_AddString(hwnd, moc.szPname);

            if (newItem != CB_ERR && newItem != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwnd, newItem, (LPARAM)device);

                if (device == pai->uPrefMIDIOut)
                {
                    ComboBox_SetCurSel(hwnd, newItem);
                    SetMIDIDeviceOut(pai, device, hDlg);
                }
            }
        }
    }
}



STATIC void AudioDlgInit(HWND hDlg)
{
    PAUDIODLGINFO pai = (PAUDIODLGINFO)LocalAlloc(LPTR, sizeof(AUDIODLGINFO));

	if (!pai) return;

    //
    //  Register context-sensitive help messages from the Customize dialog.
    //
    guCustomizeContextMenu = RegisterWindowMessage( ACMHELPMSGCONTEXTMENU );
    guCustomizeContextHelp = RegisterWindowMessage( ACMHELPMSGCONTEXTHELP );

    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pai);

    GetPrefInfo(pai, hDlg);
    CheckDlgButton(hDlg, IDC_AUDIO_PREF, pai->fPrefOnly);

    WAVEOUTInit(hDlg, pai);
    WAVEINInit(hDlg, pai);
    MIDIInit(hDlg, pai);

    if (!(pai->cNumInDevs || pai->cNumOutDevs || pai->cNumMIDIOutDevs))
    {
        CheckDlgButton(hDlg, IDC_AUDIO_PREF, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_AUDIO_PREF), FALSE);
    }

}


const static DWORD aAudioHelpIds[] = {  // Context Help IDs
    IDC_GROUPBOX,            IDH_COMM_GROUPBOX,
    IDI_SPEAKERICON,         IDH_COMM_GROUPBOX,
    IDC_ICON_6,              IDH_COMM_GROUPBOX,
    IDC_TEXT_4,              IDH_AUDIO_PLAY_PREFER_DEV,
    IDC_AUDIO_CB_PLAY,       IDH_AUDIO_PLAY_PREFER_DEV,
    IDC_LAUNCH_SNDVOL,       IDH_AUDIO_PLAY_VOL,
    IDC_PLAYBACK_ADVSETUP,   IDH_ADV_AUDIO_PLAY_PROP,

    IDC_GROUPBOX_2,          IDH_COMM_GROUPBOX,
    IDI_RECORDICON,          IDH_COMM_GROUPBOX,
    IDC_ICON_7,              IDH_COMM_GROUPBOX,
    IDC_TEXT_8,              IDH_AUDIO_REC_PREFER_DEV,
    IDC_AUDIO_CB_REC,        IDH_AUDIO_REC_PREFER_DEV,
    IDC_LAUNCH_RECVOL,       IDH_AUDIO_REC_VOL,
    IDC_RECORD_ADVSETUP,     IDH_ADV_AUDIO_REC_PROP,

    IDC_GROUPBOX_3,          IDH_COMM_GROUPBOX,
    IDI_MUSICICON,           IDH_COMM_GROUPBOX,
    IDC_ICON_8,              IDH_COMM_GROUPBOX,
    IDC_TEXT_9,              IDH_MIDI_SINGLE_INST_BUTTON,
    IDC_MUSIC_CB_PLAY,       IDH_MIDI_SINGLE_INST_BUTTON,
    IDC_LAUNCH_MUSICVOL,     IDH_AUDIO_MIDI_VOL,
    IDC_MUSIC_ABOUT,         IDH_ABOUT,

    IDC_AUDIO_PREF,          IDH_AUDIO_USE_PREF_ONLY,

    0, 0
};

const static DWORD aCustomizeHelpIds[] = {
    IDD_ACMFORMATCHOOSE_CMB_FORMAT,     IDH_AUDIO_CUST_ATTRIB,
    IDD_ACMFORMATCHOOSE_CMB_FORMATTAG,  IDH_AUDIO_CUST_FORMAT,
    IDD_ACMFORMATCHOOSE_CMB_CUSTOM,     IDH_AUDIO_CUST_NAME,
    IDD_ACMFORMATCHOOSE_BTN_DELNAME,    IDH_AUDIO_CUST_REMOVE,
    IDD_ACMFORMATCHOOSE_BTN_SETNAME,    IDH_AUDIO_CUST_SAVEAS,

    0, 0
};



void WinMMDeviceChange(HWND hDlg)
{
    PAUDIODLGINFO pai = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

//    MSACM_NotifyMapper();

    GetPrefInfo(pai, hDlg);
    CheckDlgButton(hDlg, IDC_AUDIO_PREF, pai->fPrefOnly);

    WAVEOUTInit(hDlg, pai);
    WAVEINInit(hDlg, pai);
    MIDIInit(hDlg, pai);

    if (!(pai->cNumInDevs || pai->cNumOutDevs || pai->cNumMIDIOutDevs))
    {
        CheckDlgButton(hDlg, IDC_AUDIO_PREF, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_AUDIO_PREF), FALSE);
    }
}



LRESULT CALLBACK AudioTabProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    if (iMsg == giDevChange)
    {
        WinMMDeviceChange(ghDlg);
    }

    return CallWindowProc(gfnPSProc,hwnd,iMsg,wParam,lParam);
}


void InitDeviceChange(HWND hDlg)
{
    gfnPSProc = (WNDPROC) SetWindowLongPtr(GetParent(hDlg),GWLP_WNDPROC,(LONG_PTR)AudioTabProc);
    giDevChange = RegisterWindowMessage(TEXT("winmm_devicechange"));
}

void UninitDeviceChange(HWND hDlg)
{
    SetWindowLongPtr(GetParent(hDlg),GWLP_WNDPROC,(LONG_PTR)gfnPSProc);
}




BOOL CALLBACK AudioDlg(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    NMHDR FAR   *lpnm;
    PAUDIODLGINFO pai;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                break;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            ghDlg = hDlg;

            InitDeviceChange(hDlg);

            if (!gfLoadedACM)
            {
                if (LoadACM())
                {
                    gfLoadedACM = TRUE;
                }
                else
                {
                    DPF("****Load ACM failed**\r\n");
                    ASSERT(FALSE);
                    ErrorBox(hDlg, IDS_CANTLOADACM, NULL);
                    ExitThread(0);
                }
            }

            AudioDlgInit(hDlg);
        }
        break;

        case WM_DESTROY:
        {
            UninitDeviceChange(hDlg);

            pai = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

            LocalFree((HLOCAL)pai);

            if (gfLoadedACM)
            {
                if (!FreeACM())
                {
                    DPF("****Free ACM failed**\r\n");
                    ASSERT(FALSE);
                }

                gfLoadedACM = FALSE;
            }
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU, (UINT_PTR) (LPTSTR) aAudioHelpIds);
            return TRUE;
        }
        break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP, (UINT_PTR) (LPTSTR) aAudioHelpIds);
            return TRUE;
        }
        break;

        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoAudioCommand);
        }
        break;

        default:
        {
            //
            //  Handle context-sensitive help messages from Customize dlg.
            //
            if( uMsg == guCustomizeContextMenu )
            {
                WinHelp( (HWND)wParam, NULL, HELP_CONTEXTMENU, (UINT_PTR)(LPTSTR)aCustomizeHelpIds );
            }
            else if( uMsg == guCustomizeContextHelp )
            {
                WinHelp( ((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (UINT_PTR)(LPTSTR)aCustomizeHelpIds);
            }
        }
        break;
    }
    return FALSE;
}

void ErrorMsgBox(HWND hDlg, UINT uTitle, UINT uMessage)
{
    TCHAR szMsg[MAXSTR];
    TCHAR szTitle[MAXSTR];

    LoadString(ghInstance, IDS_ERROR_TITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_ERROR_NOSNDVOL, szMsg, sizeof(szMsg)/sizeof(TCHAR));
    MessageBox(hDlg, szMsg,szTitle,MB_OK);
}


void LaunchPlaybackVolume(HWND hDlg)
{
    HWND    hwndCBPlay  = GetDlgItem(hDlg, IDC_AUDIO_CB_PLAY);
    UINT    item;

    item = (UINT)ComboBox_GetCurSel(hwndCBPlay);

    if (item != CB_ERR)
    {
        TCHAR szCmd[MAXSTR];
        UINT uDeviceID;
        MMRESULT mmr;

        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        uDeviceID = (UINT)ComboBox_GetItemData(hwndCBPlay, item);
        mmr = mixerGetID(HMIXEROBJ_INDEX(uDeviceID), &uDeviceID, MIXER_OBJECTF_WAVEOUT);

        if (mmr == MMSYSERR_NOERROR)
        {
            wsprintf(szCmd,TEXT("sndvol32.exe -D %d"),uDeviceID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOSNDVOL);
            }
        }
        else
        {
            ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOMIXER);
        }
    }
}


void LaunchRecordVolume(HWND hDlg)
{
    HWND    hwndCBRec  = GetDlgItem(hDlg, IDC_AUDIO_CB_REC);
    UINT    item;

    item = (UINT)ComboBox_GetCurSel(hwndCBRec);

    if (item != CB_ERR)
    {
        TCHAR szCmd[MAXSTR];
        UINT uDeviceID;
        MMRESULT mmr;
        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        uDeviceID = (UINT)ComboBox_GetItemData(hwndCBRec, item);

        mmr = mixerGetID(HMIXEROBJ_INDEX(uDeviceID), &uDeviceID, MIXER_OBJECTF_WAVEIN);

        if (mmr == MMSYSERR_NOERROR)
        {
            wsprintf(szCmd,TEXT("sndvol32.exe -R -D %d"),uDeviceID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOSNDVOL);
            }
        }
        else
        {
            ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOMIXER);
        }
    }
}

void LaunchMIDIVolume(HWND hDlg)
{
    HWND    hwndCBMIDI  = GetDlgItem(hDlg, IDC_MUSIC_CB_PLAY);
    UINT    item;

    item = (UINT)ComboBox_GetCurSel(hwndCBMIDI);

    if (item != CB_ERR)
    {
        TCHAR szCmd[MAXSTR];
        DWORD dwDeviceID;
        MMRESULT mmr;
        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        dwDeviceID = (UINT)ComboBox_GetItemData(hwndCBMIDI, item);

        mmr = mixerGetID(HMIXEROBJ_INDEX(dwDeviceID), &dwDeviceID, MIXER_OBJECTF_MIDIOUT);

        if (mmr == MMSYSERR_NOERROR)
        {
            wsprintf(szCmd,TEXT("sndvol32.exe -D %d"),dwDeviceID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOSNDVOL);
            }
        }
        else
        {
            ErrorMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOMIXER);
        }
    }
}

BOOL PASCAL DoAudioCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    PAUDIODLGINFO pai = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!gfLoadedACM)
    {
        return FALSE;
    }

    switch (id)
    {
        case ID_APPLY:
        {
            SetPrefInfo(pai, hDlg);
        }
        break;

        case IDC_AUDIO_CB_PLAY:
        case IDC_AUDIO_CB_REC:
        case IDC_MUSIC_CB_PLAY:
        {
            switch (codeNotify)
            {
                case CBN_SELCHANGE:
                {
                    PropSheet_Changed(GetParent(hDlg),hDlg);

                    if ((id ==  IDC_AUDIO_CB_PLAY) || (id ==  IDC_AUDIO_CB_REC) || id == IDC_MUSIC_CB_PLAY)
                    {
                        int iIndex;
                        AUDIODLGINFO aiTmp;
                        PAUDIODLGINFO paiTmp = &aiTmp;

                        iIndex = ComboBox_GetCurSel(hwndCtl);

                        if (iIndex != CB_ERR)
                        {
                            if (id == IDC_AUDIO_CB_PLAY)
                            {
                                paiTmp->uPrefOut = (UINT)ComboBox_GetItemData(hwndCtl, iIndex);
                                SetDeviceOut(paiTmp, paiTmp->uPrefOut, hDlg);
                            }
                            else if (id == IDC_AUDIO_CB_REC)
                            {
                                paiTmp->uPrefIn = (UINT)ComboBox_GetItemData(hwndCtl, iIndex);
                                SetDeviceIn(paiTmp, paiTmp->uPrefIn, hDlg);
                            }
                            else if (id == IDC_MUSIC_CB_PLAY)
                            {
                                paiTmp->uPrefMIDIOut = (UINT)ComboBox_GetItemData(hwndCtl, iIndex);
                                SetMIDIDeviceOut(paiTmp, paiTmp->uPrefMIDIOut, hDlg);
                            }
                        }
                    }
                }
                break;
            }
        }
        break;


        case IDC_AUDIO_PREF:
        {
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;

        case IDC_MUSIC_ABOUT:
        {
            DoRolandAbout(hDlg);
        }
        break;

        case IDC_LAUNCH_SNDVOL:
        {
            LaunchPlaybackVolume(hDlg);
        }
        break;

        case IDC_LAUNCH_RECVOL:
        {
            LaunchRecordVolume(hDlg);
        }
        break;

        case IDC_LAUNCH_MUSICVOL:
        {
            LaunchMIDIVolume(hDlg);
        }
        break;

        case IDC_PLAYBACK_ADVSETUP:
        {
            HWND    hwndCBPlay  = GetDlgItem(hDlg, IDC_AUDIO_CB_PLAY);
            DWORD   dwDeviceID;
            UINT    u;
            TCHAR   szPrefOut[MAXSTR];

            u = (UINT)ComboBox_GetCurSel(hwndCBPlay);

            if (u != CB_ERR)
            {
                ComboBox_GetLBText(hwndCBPlay, u, (LPARAM)(LPVOID)szPrefOut);
                dwDeviceID = (DWORD)ComboBox_GetItemData(hwndCBPlay, u);
                AdvancedAudio(hDlg,  ghInstance, gszWindowsHlp, dwDeviceID, szPrefOut, FALSE);
            }
        }
        break;

        case IDC_RECORD_ADVSETUP:
        {
            HWND    hwndCBRec  = GetDlgItem(hDlg, IDC_AUDIO_CB_REC);
            DWORD   dwDeviceID;
            UINT    u;
            TCHAR   szPrefIn[MAXSTR];

            u = (UINT)ComboBox_GetCurSel(hwndCBRec);

            if (u != CB_ERR)
            {
                ComboBox_GetLBText(hwndCBRec, u, (LPARAM)(LPVOID)szPrefIn);
                dwDeviceID = (DWORD)ComboBox_GetItemData(hwndCBRec, u);
                AdvancedAudio(hDlg,  ghInstance, gszWindowsHlp, dwDeviceID, szPrefIn, TRUE);
            }
        }
        break;
    }

    return FALSE;
}



BOOL PASCAL CustomizeDialog(HWND hDlg, LPTSTR szNewFormat, DWORD cbSize)
{
    BOOL                fRet = FALSE;  // assume the worse
    ACMFORMATCHOOSE     cwf;
    LRESULT             lr;
    DWORD               dwMaxFormatSize;
    PWAVEFORMATEX       spWaveFormat;
    TCHAR               szCustomize[64];

    lr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT,(LPVOID)&dwMaxFormatSize);

    if (lr != 0)
    {
        goto CustomizeOut;
    }

    /* This LocalAlloc is freed in WAVE.C: DestroyWave() */
    spWaveFormat = (PWAVEFORMATEX)LocalAlloc(LPTR, (UINT)dwMaxFormatSize);

    _fmemset(&cwf, 0, sizeof(cwf));

     LoadString(ghInstance, IDS_CUSTOMIZE, szCustomize, sizeof(szCustomize)/sizeof(TCHAR));
    cwf.cbStruct    = sizeof(cwf);
    cwf.hwndOwner   = hDlg;
    cwf.fdwStyle    = ACMFORMATCHOOSE_STYLEF_CONTEXTHELP;
    cwf.fdwEnum     = ACM_FORMATENUMF_INPUT;
    cwf.pszTitle    = (LPTSTR)szCustomize;
    cwf.pwfx        = (LPWAVEFORMATEX)spWaveFormat;
    cwf.cbwfx       = dwMaxFormatSize;

    cwf.pszName =     szNewFormat;
    cwf.cchName = cbSize;

    lr = acmFormatChooseW(&cwf);
    if (lr == MMSYSERR_NOERROR)
    {
        fRet = TRUE;
    }
#ifdef DEBUG
    else
    {
        TCHAR a[200];
        wsprintf(a,TEXT("MSACMCPL: acmFormatChoose failed (lr=%u).\n"),lr);
        OutputDebugString(a);
    }
#endif

CustomizeOut:
    return fRet;                // return our result
} /* NewSndDialog() */


///////////////////////////////////////////////////////////////////////////////

void acmFreeCodecInfo (PCPLCODECINFO pcci)
{
    if (pcci->fMadeIcon && pcci->hIcon)
    {
        DestroyIcon (pcci->hIcon);
        pcci->hIcon = NULL;
        pcci->fMadeIcon = FALSE;
    }

   LocalFree ((HANDLE)pcci);
}


typedef struct // FindCodecData
    {
    BOOL              fFound;
    ACMDRIVERDETAILSW add;
    WORD              wMid, wPid;
    HACMDRIVERID      hadid;
    DWORD             fdwSupport;
    } FindCodecData;

PCPLCODECINFO acmFindCodecInfo (WORD wMidMatch, WORD wPidMatch)
{
    MMRESULT      mmr;
    FindCodecData fcd;
    PCPLCODECINFO pcci;

    fcd.fFound = FALSE;
    fcd.wMid = wMidMatch;
    fcd.wPid = wPidMatch;
//  fcd.add is filled in by acmFindCodecCallback during the following enum:

    mmr = (MMRESULT)acmDriverEnum (acmFindCodecInfoCallback,
             (DWORD_PTR)&fcd,   // (data passed as arg2 to callback)
             ACM_DRIVERENUMF_NOLOCAL |
             ACM_DRIVERENUMF_DISABLED);

    if (MMSYSERR_NOERROR != mmr)
    {
        return NULL;
    }

    if (!fcd.fFound)
    {
        return NULL;
    }

     // Congratulations--we found a matching ACM driver.  Now
     // we need to create a CPLCODECINFO structure to describe it,
     // so the rest of the code in this file will work without
     // mods.  <<sigh>>  A CPLCODECINFO structure doesn't have
     // anything special--it's just a place to track info about
     // an ACM driver.  The most important thing is the HACMDRIVERID.
     //
    if ((pcci = (PCPLCODECINFO)LocalAlloc(LPTR, sizeof(CPLCODECINFO))) == NULL)
    {
        return NULL;
    }

    lstrcpy (pcci->szDesc, fcd.add.szLongName);
    pcci->ads.hadid = fcd.hadid;
    pcci->ads.fdwSupport = fcd.fdwSupport;

    pcci->fMadeIcon = FALSE;

    if ((pcci->hIcon = fcd.add.hicon) == NULL)
    {
       int cxIcon, cyIcon;
       cxIcon = (int)GetSystemMetrics (SM_CXICON);
       cyIcon = (int)GetSystemMetrics (SM_CYICON);
       pcci->hIcon = LoadImage (myInstance,
                MAKEINTRESOURCE( IDI_ACM ),
                IMAGE_ICON, cxIcon, cyIcon, LR_DEFAULTCOLOR);
       pcci->fMadeIcon = TRUE;
    }

    acmMetrics ((HACMOBJ)pcci->ads.hadid,
        ACM_METRIC_DRIVER_PRIORITY,
        &(pcci->ads.dwPriority));

    return pcci;
}



BOOL CALLBACK acmFindCodecInfoCallback (HACMDRIVERID hadid,
                    DWORD_PTR dwUser,
                    DWORD fdwSupport)
{
    FindCodecData *pfcd;

        // dwUser is really a pointer to a FindCodecData
        // structure, supplied by the guy who called acmDriverEnum.
        //
    if ((pfcd = (FindCodecData *)dwUser) == NULL)
    {
        return FALSE;
    }

        // No details?  Try the next driver.
        //
    pfcd->add.cbStruct = sizeof(pfcd->add);
    if (acmDriverDetailsW (hadid, &pfcd->add, 0L) != MMSYSERR_NOERROR)
    {
        return TRUE;
    }

        // Great.  Now see if the driver we found matches
        // pfcd->wMid/wPad; if so we're done, else keep searching.
        //
    if ((pfcd->wMid == pfcd->add.wMid) && (pfcd->wPid == pfcd->add.wPid) )
    {
        pfcd->hadid = hadid;
        pfcd->fFound = TRUE;
        pfcd->fdwSupport = fdwSupport;
        return FALSE; // found it! leave pfcd->add intact and leave.
    }

    return TRUE; // not the right driver--keep looking
}


UINT acmCountCodecs (void)
{
    MMRESULT      mmr;
    UINT          nCodecs = 0;

    mmr = (MMRESULT)acmDriverEnum (acmCountCodecsEnum,
             (DWORD_PTR)&nCodecs,
             ACM_DRIVERENUMF_NOLOCAL |
             ACM_DRIVERENUMF_DISABLED);

    if (MMSYSERR_NOERROR != mmr)
    {
        return 0;
    }

    return nCodecs;
}



BOOL CALLBACK acmCountCodecsEnum (HACMDRIVERID hadid,
                  DWORD_PTR dwUser,
                  DWORD fdwSupport)
{
    UINT *pnCodecs;

        // dwUser is really a pointer to a UINT being used to
        // count the number of codecs we encounter.
        //
    if ((pnCodecs = (UINT *)dwUser) == NULL)
    {
        return FALSE;
    }

    ++ (*pnCodecs);

    return TRUE; // keep counting
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\rcids.h ===
//****************************************************************************
//
//  Module:     MMSE.DLL
//  File:       rcids.h
//  Content:    This file contains all the constant declaration for the
//              MMSE resources.
//  History:
//      06/1994    -By-    Vij Rajarajan (VijR)
//
//  Copyright (c) Microsoft Corporation 1991-1994
//
//****************************************************************************


//*****************************************************************************
// Icon ID number section
//*****************************************************************************

#include <cphelp.h>

#define ID_BASE_START                   0x1000
                                                         
#define ID_BASE_CONTROL                 (ID_BASE_START + 0x0500)    // 0x0100 - 0x0400 reserved
#define ID_BASE_STRINGS                 (ID_BASE_START + 0x0600)
#define ID_BASE_FILEPROP_STRINGS        (ID_BASE_START + 0x0700)
#define ID_BASE_EVENTS_STRINGS          (ID_BASE_START + 0x0800)
#define ID_BASE_MIDI_STRINGS            (ID_BASE_START + 0x0900)
#define ID_SIMPLE_PROP                  (ID_BASE_START + 0x0A00)
#define ID_ADVANCED_PROP                (ID_BASE_START + 0x1000)
#define ID_MIDI_PROP                    (ID_BASE_START + 0x1100)
#define ID_FILE_DETAILS                 (ID_BASE_START + 0x1200)
#define ID_EVENTS_START                 (ID_BASE_START + 0x1300)
#define ID_VOICE_PROP                   (ID_BASE_START + 0x1400)
#define ID_MULTICHANNEL_PROP            (ID_BASE_START + 0x1500)
#define ID_EFFECT_PROP                  (ID_BASE_START + 0x1600)
#define ID_BASE_CHANNEL_STRINGS         (ID_BASE_START + 0x1700)
#define ID_START_PROP                   (ID_BASE_START + 0x1800)
#define ID_BASE_CREDENTIALS_STRINGS     (ID_BASE_START + 0x1900)


#define IDC_STATIC                      -1

/////////////////////////////////////////////////////////////////////
// ICONS
/////////////////////////////////////////////////////////////////////
#define IDI_MMICON                      3004    //DO NOT CHANGE THIS ID. Other files depend on this number
#define IDI_IDFICON                     0x1101
#define IDI_WAVE                        0x1102
#define IDI_MIDI                        0x1103
#define IDI_MIXER                       0x1104
#define IDI_AUX                         0x1105
#define IDI_MCI                         0x1106
#define IDI_ICM                         0x1107
#define IDI_ACM                         0x1108
#define IDI_JOYSTICK                    0x1109
#define IDI_SOUNDSCHEMES                0x110A
#define IDI_AUDIO                       0x110B
#define IDI_VIDEO                       0x110C
#define IDI_CDAUDIO                     0x110D
#define IDI_PROGRAM                     0x110E
#define IDI_MSACM                       0x110F
#define IDI_PLAYBACK                    0x1110
#define IDI_RECORD                      0x1111
#define IDI_DWAVE                       0x1112
#define IDI_DMIDI                       0x1113
#define IDI_DVIDEO                      0x1114
#define IDI_INSTRUMENT                  0x1115
#define IDI_CHANNEL                     0x1116
#define IDI_BLANK                       0x1117
#define IDI_SELECTED_IDF                0x1118
#define IDI_NONSEL_IDF                  0x1119
#define IDI_MICROPHONE                  0x111A
#define IDI_SPEAKERICON                 0x111B
#define IDI_RECORDICON                  0x111C
#define IDI_MUSICICON                   0x111D
#define IDI_VOLUME                      0x111E
#define IDI_VOLUP                       0x111F
#define IDI_VOLDOWN                     0x1120
#define IDI_VOLMUTE                     0x1121
#define IDI_VOLMUTEUP                   0x1122
#define IDI_VOLMUTEDOWN                 0x1123
#define IDI_VOLTRANS                    0x1124
#define IDI_GS                          0x1125
#define IDI_MIDIKEY                     0x1126

#define IDI_VOC_SPEAKERICON             0x1127
#define IDI_VOC_RECORDICON              0x1128
#define IDI_MUTESPEAKERICON             0x1129
#define IDI_REBOOTICON                  0x112A


////////////////////////////////////////////////////////////////////
//BITMAPS
////////////////////////////////////////////////////////////////////

#define IDB_PLAY                        0x1200
#define IDB_STOP                        0x1201
#define IDB_WIZBMP                      0x1202
#define IDB_MONITOR                     0x1203
#define IDB_HEADPHONES                  0x1204
#define IDB_STEREODESKTOP               0x1205
#define IDB_MONOLAPTOP                  0x1206
#define IDB_STEREOLAPTOP                0x1207
#define IDB_STEREOMONITOR               0x1208
#define IDB_STEREOCPU                   0x1209
#define IDB_MOUNTEDSTEREO               0x120A
#define IDB_STEREOKEYBOARD              0x120B
#define IDB_QUADRAPHONIC                0x120C
#define IDB_SURROUND                    0x120D
#define IDB_SURROUND_5_1                0x120E
#define IDB_ROLAND                      0x120F
#define IDB_MULTICHANNEL_SPKR           0x1210
#define IDB_VOLUME_BRAND                0x1211
#define IDB_NOSPEAKERS                  0x1212
#define IDB_SURROUND_7_1                0x1213

////////////////////////////////////////////////////////////////////
// DIALOGS
////////////////////////////////////////////////////////////////////

#define CDDLG                           0x1300
#define VIDEODLG                        0x1301
#define AUDIODLG                        0x1302
#define EVENTSDLG                       0x1303
#define DLG_DEV_PROP                    0x1304
#define DLG_CPL_MSACM                   0x1305
#define DLG_ABOUT_MSACM                 0x1306
#define DLG_PRIORITY_SET                0x1307
#define DLG_WAVDEV_PROP                 0x1308
#define DLG_ACMDEV_PROP                 0x1309
#define DLG_FILE_DETAILS                0x130A
#define DLG_MESSAGE_BOX                 0x130B
#define SOUNDDIALOG                     0x130C
#define SAVESCHEMEDLG                   0x130D
#define PREVIEW_DLG                     0x130E
#define IDD_CPL_MIDI                    0x130F
#define IDD_MIDICHANGE                  0x1310
#define IDD_MIDICONFIG                  0x1311
#define IDD_SAVENAME                    0x1312
#define IDD_CPL_MIDI2                   0x1313
#define IDD_MIDICLASS_GEN               0x1314
#define IDD_DEVICE_DETAIL               0x1315
#define IDD_INSTRUMENT_GEN              0x1316
#define IDD_INSTRUMENT_DETAIL           0x1317
#define IDD_MIDIWIZ01                   0x1318
#define IDD_MIDIWIZ02                   0x1319
#define IDD_MIDIWIZ03                   0x131A
#define IDD_MIDIWIZ04                   0x131B
#define ADVVIDEODLG                     0x131C
#define ID_ADVVIDEO_COMPAT              0x131D
#define ID_VIDEO_ADVANCED               0x131E
#define IDD_ROLAND                      0x131F
#define BROWSEDLGTEMPLATE               0x1320
#define IDD_SPEAKERS                    0x1321
#define IDD_PLAYBACKPERF                0x1322
#define IDD_CAPTUREPERF                 0x1323
#define DLG_PP_DRIVERSETTINGS           0x1324
#define IDD_SPEECH                      0x1325
#define HWDLG                           0x1326
#define DM_ADVDLG                       0x1327
#define DM_CDDLG                        0x1328
#define IDD_VOLUME                      0x1329
#define VOICEDLG                        0x132A
#define STARTDLG                        0x132B
#define IDD_MULTICHANNEL                0x132D
#define EFFECTSDLG                      0x132E
#define IDD_ADDEFFECTSDLG               0x132F
#define REBOOTDLG                       0x1330

////////////////////////////////////////////////////////////////////
// MENUS
////////////////////////////////////////////////////////////////////

#define POPUP_TREE_CONTEXT              0x1400
#define MMSE_YES                        0x1401
#define MMSE_NO                         0x1402
#define MMSE_CANCEL                     0x1403
#define MMSE_OK                         0x1404
#define MMSE_YESNO                      0x1405
#define MMSE_YESNOCANCEL                0x1406
#define MMSE_TEXT                       0x1407



////////////////////////////////////////////////////////////////////
// STRINGS
////////////////////////////////////////////////////////////////////

#define IDS_EVENTSNAME                  (ID_BASE_STRINGS + 0x0000)
#define IDS_EVENTSINFO                  (ID_BASE_STRINGS + 0x0001)
#define IDS_AUDIOPROPERTIES             (ID_BASE_STRINGS + 0x0002)
#define IDS_ADVAUDIOTITLE               (ID_BASE_STRINGS + 0x0003)
#define IDS_ABOUT_TITLE                 (ID_BASE_STRINGS + 0x0004)
#define IDS_ABOUT_VERSION               (ID_BASE_STRINGS + 0x0005)
#define IDS_PRIORITY_FROMTO             (ID_BASE_STRINGS + 0x0006)
#define IDS_TXT_DISABLED                (ID_BASE_STRINGS + 0x0007)
#define IDS_CUSTOMIZE                   (ID_BASE_STRINGS + 0x0008)
#define IDS_HIGHQUALITY                 (ID_BASE_STRINGS + 0x0009)
#define IDS_MEDIUMQUALITY               (ID_BASE_STRINGS + 0x000A)
#define IDS_LOWQUALITY                  (ID_BASE_STRINGS + 0x000B)
#define IDS_1QSCREENSIZE                (ID_BASE_STRINGS + 0x000C)
#define IDS_2QSCREENSIZE                (ID_BASE_STRINGS + 0x000D)
#define IDS_3QSCREENSIZE                (ID_BASE_STRINGS + 0x000E)
#define IDS_VIDEOMAXIMIZED              (ID_BASE_STRINGS + 0x000F)
#define IDS_NOAUDIOPLAY                 (ID_BASE_STRINGS + 0x0010)
#define IDS_NOAUDIOREC                  (ID_BASE_STRINGS + 0x0011)
#define IDS_TRAYVOLLNK                  (ID_BASE_STRINGS + 0x0012)
#define IDS_NORMALSIZE                  (ID_BASE_STRINGS + 0x0013)
#define IDS_ZOOMEDSIZE                  (ID_BASE_STRINGS + 0x0014)
#define IDS_NOMIDIPLAY                  (ID_BASE_STRINGS + 0x0015)
#define IDS_SYSREMOVE                   (ID_BASE_STRINGS + 0x0017)
#define IDS_REMOVED                     (ID_BASE_STRINGS + 0x0018)
#define IDS_RESTART                     (ID_BASE_STRINGS + 0x0019)
#define IDS_DELETE                      (ID_BASE_STRINGS + 0x001A)
#define IDS_MMDRIVERS                   (ID_BASE_STRINGS + 0x001B)
#define IDS_GENERAL                     (ID_BASE_STRINGS + 0x001C)
#define IDS_NOPROP                      (ID_BASE_STRINGS + 0x001D)
#define IDS_DEVDISABLEDOK               (ID_BASE_STRINGS + 0x001E)
#define IDS_DEVDISABLED                 (ID_BASE_STRINGS + 0x001F)
#define IDS_REMOVEWARN                  (ID_BASE_STRINGS + 0x0020)
#define IDS_REINSTALL                   (ID_BASE_STRINGS + 0x0021)
#define IDS_ADVANCED                    (ID_BASE_STRINGS + 0x0022)
#define IDS_DEVENABLEDOK                (ID_BASE_STRINGS + 0x0023)
#define IDS_DEVENABLEDNOTOK             (ID_BASE_STRINGS + 0x0024)
#define IDS_CHANGESAVED                 (ID_BASE_STRINGS + 0x0025)
#define IDS_COLLAPSE                    (ID_BASE_STRINGS + 0x0026)
#define IDS_DEVFRIENDLYYESNO            (ID_BASE_STRINGS + 0x0027)
#define IDS_FRIENDLYWARNING             (ID_BASE_STRINGS + 0x0028)
#define IDS_FRIENDLYNAME                (ID_BASE_STRINGS + 0x0029)
#define IDS_INSTRFRIENDLYYESNO          (ID_BASE_STRINGS + 0x002A)
#define IDS_NODEVS                      (ID_BASE_STRINGS + 0x002B)
#define IDS_NONE                        (ID_BASE_STRINGS + 0x002C)
#define IDS_ACMREMOVEFAIL               (ID_BASE_STRINGS + 0x002D)
#define IDS_AUDIOFOR                    (ID_BASE_STRINGS + 0x002E)
#define IDS_MIDIFOR                     (ID_BASE_STRINGS + 0x002F)
#define IDS_MIXERFOR                    (ID_BASE_STRINGS + 0x0030)
#define IDS_AUXFOR                      (ID_BASE_STRINGS + 0x0031)
#define IDS_ENABLEAUDIO                 (ID_BASE_STRINGS + 0x0032)
#define IDS_ENABLEMIDI                  (ID_BASE_STRINGS + 0x0033)
#define IDS_ENABLEMIXER                 (ID_BASE_STRINGS + 0x0034)
#define IDS_ENABLEAUX                   (ID_BASE_STRINGS + 0x0035)
#define IDS_ENABLEMCI                   (ID_BASE_STRINGS + 0x0036)
#define IDS_ENABLEACM                   (ID_BASE_STRINGS + 0x0037)
#define IDS_ENABLEICM                   (ID_BASE_STRINGS + 0x0038)
#define IDS_ENABLECAP                   (ID_BASE_STRINGS + 0x0039)
#define IDS_ENABLEJOY                   (ID_BASE_STRINGS + 0x003A)
#define IDS_DISABLEAUDIO                (ID_BASE_STRINGS + 0x003B)
#define IDS_DISABLEMIDI                 (ID_BASE_STRINGS + 0x003C)
#define IDS_DISABLEMIXER                (ID_BASE_STRINGS + 0x003D)
#define IDS_DISABLEAUX                  (ID_BASE_STRINGS + 0x003E)
#define IDS_DISABLEMCI                  (ID_BASE_STRINGS + 0x003F)
#define IDS_DISABLEACM                  (ID_BASE_STRINGS + 0x0040)
#define IDS_DISABLEICM                  (ID_BASE_STRINGS + 0x0041)
#define IDS_DISABLECAP                  (ID_BASE_STRINGS + 0x0042)
#define IDS_DISABLEJOY                  (ID_BASE_STRINGS + 0x0043)
#define IDS_CANTLOADACM                 (ID_BASE_STRINGS + 0x0044)
#define IDS_REMOVEHARDWAREWARN          (ID_BASE_STRINGS + 0x0045)
#define IDS_AUDIO                       (ID_BASE_STRINGS + 0x0046)
#define IDS_MIDI                        (ID_BASE_STRINGS + 0x0047)
#define IDS_MIXER                       (ID_BASE_STRINGS + 0x0048)
#define IDS_AUX                         (ID_BASE_STRINGS + 0x0049)
#define IDS_ACM                         (ID_BASE_STRINGS + 0x004A)
#define IDS_ICM                         (ID_BASE_STRINGS + 0x004B)
#define IDS_CAP                         (ID_BASE_STRINGS + 0x004C)
#define IDS_JOY                         (ID_BASE_STRINGS + 0x004D)
#define IDS_SYSREMOVEINFO               (ID_BASE_STRINGS + 0x004E)
#define IDS_REMOVEPNPWARN               (ID_BASE_STRINGS + 0x004F)
#define IDS_REMOVEMULTIPORTMIDI         (ID_BASE_STRINGS + 0x0050)
#define IDS_DISABLE                     (ID_BASE_STRINGS + 0x0051)
#define IDS_DISABLEMULTIPORTMIDI        (ID_BASE_STRINGS + 0x0052)
#define IDS_ENABLE                      (ID_BASE_STRINGS + 0x0053)
#define IDS_ENABLEMULTIPORTMIDI         (ID_BASE_STRINGS + 0x0054)
#define IDS_DEVENABLEDNODRIVER          (ID_BASE_STRINGS + 0x0055)
#define IDS_PNPPROBLEM                  (ID_BASE_STRINGS + 0x0056)
#define IDS_NOSNDVOL                    (ID_BASE_STRINGS + 0x0057)
#define IDS_RESTART_NOSOUND             (ID_BASE_STRINGS + 0x0058)
#define IDS_SPEECH_NAME                 (ID_BASE_STRINGS + 0x0059)
#define IDS_DESCRIPTION                 (ID_BASE_STRINGS + 0x005A)
#define IDS_CAPTION                     (ID_BASE_STRINGS + 0x005B)
#define IDS_E_INSTALL                   (ID_BASE_STRINGS + 0x005C)
#define IDS_E_ENGINE                    (ID_BASE_STRINGS + 0x005D)
#define IDS_MM_HEADER                   (ID_BASE_STRINGS + 0x005E)
#define IDS_AUX_HEADER                  (ID_BASE_STRINGS + 0x005F)
#define IDS_MIDI_HEADER                 (ID_BASE_STRINGS + 0x0060)
#define IDS_MIXER_HEADER                (ID_BASE_STRINGS + 0x0061)
#define IDS_WAVE_HEADER                 (ID_BASE_STRINGS + 0x0062)
#define IDS_MCI_HEADER                  (ID_BASE_STRINGS + 0x0063)
#define IDS_ACM_HEADER                  (ID_BASE_STRINGS + 0x0064)
#define IDS_ICM_HEADER                  (ID_BASE_STRINGS + 0x0065)
#define IDS_OTHER_HEADER                (ID_BASE_STRINGS + 0x0066)
#define IDS_VIDCAP_HEADER               (ID_BASE_STRINGS + 0x0067)
#define IDS_JOYSTICK_HEADER             (ID_BASE_STRINGS + 0x0068)
#define IDS_AUDIO_TAB                   (ID_BASE_STRINGS + 0x0069)
#define IDS_VIDEO_TAB                   (ID_BASE_STRINGS + 0x006A)
#define IDS_CDAUDIO_TAB                 (ID_BASE_STRINGS + 0x006B)
#define IDS_MIDI_TAB                    (ID_BASE_STRINGS + 0x006C)
#define IDS_VIDEO                       (ID_BASE_STRINGS + 0x006D)
#define IDS_CDMUSIC                     (ID_BASE_STRINGS + 0x006E)
#define IDS_AUDHW1                      (ID_BASE_STRINGS + 0x006F)
#define IDS_AUDHW2                      (ID_BASE_STRINGS + 0x0070)
#define IDS_AUDHW3                      (ID_BASE_STRINGS + 0x0071)
#define IDS_AUDHW4                      (ID_BASE_STRINGS + 0x0072)
#define IDS_SRCQUALITY1                 (ID_BASE_STRINGS + 0x0073)
#define IDS_SRCQUALITY2                 (ID_BASE_STRINGS + 0x0074)
#define IDS_SRCQUALITY3                 (ID_BASE_STRINGS + 0x0075)
#define IDS_SPEAKER1                    (ID_BASE_STRINGS + 0x0076)
#define IDS_SPEAKER2                    (ID_BASE_STRINGS + 0x0077)
#define IDS_SPEAKER3                    (ID_BASE_STRINGS + 0x0078)
#define IDS_SPEAKER4                    (ID_BASE_STRINGS + 0x0079)
#define IDS_SPEAKER5                    (ID_BASE_STRINGS + 0x007A)
#define IDS_SPEAKER6                    (ID_BASE_STRINGS + 0x007B)
#define IDS_SPEAKER7                    (ID_BASE_STRINGS + 0x007C)
#define IDS_SPEAKER8                    (ID_BASE_STRINGS + 0x007D)
#define IDS_SPEAKER9                    (ID_BASE_STRINGS + 0x007E)
#define IDS_SPEAKER10                   (ID_BASE_STRINGS + 0x007F)
#define IDS_SPEAKER11                   (ID_BASE_STRINGS + 0x0080)
#define IDS_SPEAKER12                   (ID_BASE_STRINGS + 0x0081)
#define IDS_SPEAKER13                   (ID_BASE_STRINGS + 0x0082)
#define IDS_ERROR_TITLE                 (ID_BASE_STRINGS + 0x0083)
#define IDS_ERROR_NOSNDVOL              (ID_BASE_STRINGS + 0x0084)
#define IDS_ERROR_NOMIXER               (ID_BASE_STRINGS + 0x0085)
#define IDS_USEANYDEVICE                (ID_BASE_STRINGS + 0x0086)
#define IDS_ERROR_DSPRIVS               (ID_BASE_STRINGS + 0x0087)
#define IDS_ERROR_DSGENERAL             (ID_BASE_STRINGS + 0x0088)
#define IDS_E_MICWIZARD                 (ID_BASE_STRINGS + 0x0089)
#define IDS_HARDWARE                    (ID_BASE_STRINGS + 0x008A)
#define IDS_MMNAME                      (ID_BASE_STRINGS + 0x008B)
#define IDS_MMINFO                      (ID_BASE_STRINGS + 0x008C)
#define IDS_MMHELP                      (ID_BASE_STRINGS + 0x008D)
#define IDS_VOLUMENAME                  (ID_BASE_STRINGS + 0x008E)
#define IDS_VOICE                       (ID_BASE_STRINGS + 0x008F)
#define IDS_ERROR_NOVOCVOL              (ID_BASE_STRINGS + 0x0090)
#define IDS_ERROR_NOVOCDIAG             (ID_BASE_STRINGS + 0x0091)
#define IDS_ERROR_VOICE_TITLE           (ID_BASE_STRINGS + 0x0092)
// Other Strings (mostly for Multichannel page)
#define IDS_MC_PLAYBACK                 (ID_BASE_STRINGS + 0x0093)
#define IDS_MC_RECORDING                (ID_BASE_STRINGS + 0x0094)
#define IDS_MC_OTHER                    (ID_BASE_STRINGS + 0x0095)
#define IDS_MC_PLAYBACK_DESC            (ID_BASE_STRINGS + 0x0096)
#define IDS_MC_RECORDING_DESC           (ID_BASE_STRINGS + 0x0097)
#define IDS_MC_OTHER_DESC               (ID_BASE_STRINGS + 0x0098)
#define IDS_OLD_CHANNEL_ZERO            (ID_BASE_STRINGS + 0x0099)
#define IDS_OLD_CHANNEL_ONE             (ID_BASE_STRINGS + 0x009A)
#define IDS_OLD_CHANNEL_TWO             (ID_BASE_STRINGS + 0x009B)
#define IDS_OLD_CHANNEL_THREE           (ID_BASE_STRINGS + 0x009C)
#define IDS_OLD_CHANNEL_FOUR            (ID_BASE_STRINGS + 0x009D)
#define IDS_OLD_CHANNEL_FIVE            (ID_BASE_STRINGS + 0x009E)
#define IDS_TIP_PLAY                    (ID_BASE_STRINGS + 0x009F)
#define IDS_MC_SPEAKER_LEFT             (ID_BASE_STRINGS + 0x00A0)
#define IDS_MC_SPEAKER_RIGHT            (ID_BASE_STRINGS + 0x00A1)
#define IDS_MC_SPEAKER_CENTER           (ID_BASE_STRINGS + 0x00A2)
#define IDS_MC_SPEAKER_BACKLEFT         (ID_BASE_STRINGS + 0x00A3)
#define IDS_MC_SPEAKER_BACKRIGHT        (ID_BASE_STRINGS + 0x00A4)
#define IDS_MC_SPEAKER_LOWFREQUENCY     (ID_BASE_STRINGS + 0x00A5)
#define IDS_NOGFXSET                    (ID_BASE_STRINGS + 0x00A7)
#define IDS_NOGFXFOUND                  (ID_BASE_STRINGS + 0x00A8)
#define IDS_MC_SPEAKER_BACKCENTER       (ID_BASE_STRINGS + 0x00A9)
#define IDS_MC_SPEAKER_LEFT_OF_CENTER   (ID_BASE_STRINGS + 0x00AA)
#define IDS_MC_SPEAKER_RIGHT_OF_CENTER  (ID_BASE_STRINGS + 0x00AB)
#define IDS_EFFECTS_PROPERTY_CAPTION    (ID_BASE_STRINGS + 0x00AC)
#define IDS_START                       (ID_BASE_STRINGS + 0x00AD)

////////////////////////////////////////////////////////////////////
// Display names for Sound Events
// DO NOT CHANGE THESE - THEY ARE IN HIVEDEF.INX!!!!!!!!!!
////////////////////////////////////////////////////////////////////

#define IDS_REG_DEFAULT                 (ID_BASE_STRINGS + 0x00C0)
#define IDS_REG_APPGPF                  (ID_BASE_STRINGS + 0x00C1)
#define IDS_REG_CLOSE                   (ID_BASE_STRINGS + 0x00C2)
#define IDS_REG_CRITBATT                (ID_BASE_STRINGS + 0x00C3)
#define IDS_REG_DEVCONN                 (ID_BASE_STRINGS + 0x00C4)
#define IDS_REG_DEVDISCONN              (ID_BASE_STRINGS + 0x00C5)
#define IDS_REG_DEVFAIL                 (ID_BASE_STRINGS + 0x00C6)
#define IDS_REG_EMPTY                   (ID_BASE_STRINGS + 0x00C7)
#define IDS_REG_LOWBATT                 (ID_BASE_STRINGS + 0x00C8)
#define IDS_REG_MAX                     (ID_BASE_STRINGS + 0x00C9)
#define IDS_REG_MENUCMD                 (ID_BASE_STRINGS + 0x00CA)
#define IDS_REG_MENUPOP                 (ID_BASE_STRINGS + 0x00CB)
#define IDS_REG_MIN                     (ID_BASE_STRINGS + 0x00CC)
#define IDS_REG_MAIL                    (ID_BASE_STRINGS + 0x00CD)
#define IDS_REG_NAV                     (ID_BASE_STRINGS + 0x00CE)
#define IDS_REG_OPEN                    (ID_BASE_STRINGS + 0x00CF)
#define IDS_REG_PRINT                   (ID_BASE_STRINGS + 0x00D0)
#define IDS_REG_RESDOWN                 (ID_BASE_STRINGS + 0x00D1)
#define IDS_REG_RESUP                   (ID_BASE_STRINGS + 0x00D2)
#define IDS_REG_SYSAST                  (ID_BASE_STRINGS + 0x00D3)
#define IDS_REG_SYSDEF                  (ID_BASE_STRINGS + 0x00D4)
#define IDS_REG_SYSEXCL                 (ID_BASE_STRINGS + 0x00D5)
#define IDS_REG_SYSEXIT                 (ID_BASE_STRINGS + 0x00D6)
#define IDS_REG_SYSHAND                 (ID_BASE_STRINGS + 0x00D7)
#define IDS_REG_SYSNOT                  (ID_BASE_STRINGS + 0x00D8)
#define IDS_REG_SYSQUEST                (ID_BASE_STRINGS + 0x00D9)
#define IDS_REG_SYSSTART                (ID_BASE_STRINGS + 0x00DA)
#define IDS_REG_SYSMENU                 (ID_BASE_STRINGS + 0x00DB)
#define IDS_REG_LOGOFF                  (ID_BASE_STRINGS + 0x00DC)
#define IDS_REG_LOGON                   (ID_BASE_STRINGS + 0x00DD)

#define IDS_REG_EXPLORE                 (ID_BASE_STRINGS + 0x00DE)
#define IDS_REG_HARDWARE                (ID_BASE_STRINGS + 0x00DF)
#define IDS_REG_WINDOWS                 (ID_BASE_STRINGS + 0x00E0)

////////////////////////////////////////////////////////////////////
// CHANNEL STRINGS (Must be in sequential order)
////////////////////////////////////////////////////////////////////

#define IDS_MC_CHANNEL_ZERO             (ID_BASE_CHANNEL_STRINGS + 0x0000)
#define IDS_MC_CHANNEL_ONE              (ID_BASE_CHANNEL_STRINGS + 0x0001)
#define IDS_MC_CHANNEL_TWO              (ID_BASE_CHANNEL_STRINGS + 0x0002)
#define IDS_MC_CHANNEL_THREE            (ID_BASE_CHANNEL_STRINGS + 0x0003)
#define IDS_MC_CHANNEL_FOUR             (ID_BASE_CHANNEL_STRINGS + 0x0004)
#define IDS_MC_CHANNEL_FIVE             (ID_BASE_CHANNEL_STRINGS + 0x0005)
#define IDS_MC_CHANNEL_SIX              (ID_BASE_CHANNEL_STRINGS + 0x0006)
#define IDS_MC_CHANNEL_SEVEN            (ID_BASE_CHANNEL_STRINGS + 0x0007)


////////////////////////////////////////////////////////////////////
// FILE PROPERTY STRINGS
////////////////////////////////////////////////////////////////////

#define IDS_FOURCC_IARL                 (ID_BASE_FILEPROP_STRINGS + 0x0000)
#define IDS_FOURCC_IART                 (ID_BASE_FILEPROP_STRINGS + 0x0001)
#define IDS_FOURCC_ICMS                 (ID_BASE_FILEPROP_STRINGS + 0x0002)
#define IDS_FOURCC_ICMT                 (ID_BASE_FILEPROP_STRINGS + 0x0003)
#define IDS_FOURCC_ICOP                 (ID_BASE_FILEPROP_STRINGS + 0x0004)
#define IDS_FOURCC_ICRD                 (ID_BASE_FILEPROP_STRINGS + 0x0005)
#define IDS_FOURCC_ICRP                 (ID_BASE_FILEPROP_STRINGS + 0x0006)
#define IDS_FOURCC_IDIM                 (ID_BASE_FILEPROP_STRINGS + 0x0007)
#define IDS_FOURCC_IDPI                 (ID_BASE_FILEPROP_STRINGS + 0x0008)
#define IDS_FOURCC_IENG                 (ID_BASE_FILEPROP_STRINGS + 0x0009)
#define IDS_FOURCC_IGNR                 (ID_BASE_FILEPROP_STRINGS + 0x000A)
#define IDS_FOURCC_IKEY                 (ID_BASE_FILEPROP_STRINGS + 0x000B)
#define IDS_FOURCC_ILGT                 (ID_BASE_FILEPROP_STRINGS + 0x000C)
#define IDS_FOURCC_IMED                 (ID_BASE_FILEPROP_STRINGS + 0x000D)
#define IDS_FOURCC_INAM                 (ID_BASE_FILEPROP_STRINGS + 0x000E)
#define IDS_FOURCC_IPLT                 (ID_BASE_FILEPROP_STRINGS + 0x000F)
#define IDS_FOURCC_IPRD                 (ID_BASE_FILEPROP_STRINGS + 0x0010)
#define IDS_FOURCC_ISBJ                 (ID_BASE_FILEPROP_STRINGS + 0x0011)
#define IDS_FOURCC_ISFT                 (ID_BASE_FILEPROP_STRINGS + 0x0012)
#define IDS_FOURCC_ISHP                 (ID_BASE_FILEPROP_STRINGS + 0x0013)
#define IDS_FOURCC_ISRC                 (ID_BASE_FILEPROP_STRINGS + 0x0014)
#define IDS_FOURCC_ISRF                 (ID_BASE_FILEPROP_STRINGS + 0x0015)
#define IDS_FOURCC_ITCH                 (ID_BASE_FILEPROP_STRINGS + 0x0016)
#define IDS_FOURCC_DISP                 (ID_BASE_FILEPROP_STRINGS + 0x0017)
#define IDS_NOCOPYRIGHT                 (ID_BASE_FILEPROP_STRINGS + 0x0018)
#define IDS_UNKFORMAT                   (ID_BASE_FILEPROP_STRINGS + 0x0019)
#define IDS_BADFILE                     (ID_BASE_FILEPROP_STRINGS + 0x001A)
#define IDS_MINFMT                      (ID_BASE_FILEPROP_STRINGS + 0x001B)
#define IDS_SECFMT                      (ID_BASE_FILEPROP_STRINGS + 0x001C)
#define IDS_DETAILS                     (ID_BASE_FILEPROP_STRINGS + 0x001D)
#define IDS_PREVIEW                     (ID_BASE_FILEPROP_STRINGS + 0x001E)
#define IDS_PREVIEWOF                   (ID_BASE_FILEPROP_STRINGS + 0x001F)
#define IDS_GOODFORMAT                  (ID_BASE_FILEPROP_STRINGS + 0x0020)
#define IDS_BADFORMAT                   (ID_BASE_FILEPROP_STRINGS + 0x0021)
#define IDS_UNCOMPRESSED                (ID_BASE_FILEPROP_STRINGS + 0x0022)
#define IDS_FORMAT_PCM                  (ID_BASE_FILEPROP_STRINGS + 0x0023)
#define IDS_FORMAT_ADPCM                (ID_BASE_FILEPROP_STRINGS + 0x0024)
#define IDS_FORMAT_IBM_CVSD             (ID_BASE_FILEPROP_STRINGS + 0x0025)
#define IDS_FORMAT_ALAW                 (ID_BASE_FILEPROP_STRINGS + 0x0026)
#define IDS_FORMAT_MULAW                (ID_BASE_FILEPROP_STRINGS + 0x0027)
#define IDS_FORMAT_OKI_ADPCM            (ID_BASE_FILEPROP_STRINGS + 0x0028)
#define IDS_FORMAT_IMA_ADPCM            (ID_BASE_FILEPROP_STRINGS + 0x0029)
#define IDS_FORMAT_MEDIASPACE_ADPCM     (ID_BASE_FILEPROP_STRINGS + 0x002A)
#define IDS_FORMAT_SIERRA_ADPCM         (ID_BASE_FILEPROP_STRINGS + 0x002B)
#define IDS_FORMAT_G723_ADPCM           (ID_BASE_FILEPROP_STRINGS + 0x002C)
#define IDS_FORMAT_DIGISTD              (ID_BASE_FILEPROP_STRINGS + 0x002D)
#define IDS_FORMAT_DIGIFIX              (ID_BASE_FILEPROP_STRINGS + 0x002E)
#define IDS_FORMAT_YAMAHA_ADPCM         (ID_BASE_FILEPROP_STRINGS + 0x002F)
#define IDS_FORMAT_SONARC               (ID_BASE_FILEPROP_STRINGS + 0x0030)
#define IDS_FORMAT_DSPGROUP_TRUESPEECH  (ID_BASE_FILEPROP_STRINGS + 0x0031)
#define IDS_FORMAT_ECHOSC1              (ID_BASE_FILEPROP_STRINGS + 0x0032)
#define IDS_FORMAT_AUDIOFILE_AF36       (ID_BASE_FILEPROP_STRINGS + 0x0033)
#define IDS_FORMAT_APTX                 (ID_BASE_FILEPROP_STRINGS + 0x0034)
#define IDS_FORMAT_AUDIOFILE_AF10       (ID_BASE_FILEPROP_STRINGS + 0x0035)
#define IDS_FORMAT_DOLBY_AC2            (ID_BASE_FILEPROP_STRINGS + 0x0036)
#define IDS_FORMAT_GSM610               (ID_BASE_FILEPROP_STRINGS + 0x0037)
#define IDS_FORMAT_G721_ADPCM           (ID_BASE_FILEPROP_STRINGS + 0x0038)
#define IDS_FORMAT_CREATIVE_ADPCM       (ID_BASE_FILEPROP_STRINGS + 0x0039)


////////////////////////////////////////////////////////////////////
// CREDENTIALS PROMPT
////////////////////////////////////////////////////////////////////

#define IDS_CREDUI_PROMPT               (ID_BASE_CREDENTIALS_STRINGS + 0x0000)
#define IDS_CREDUI_TITLE                (ID_BASE_CREDENTIALS_STRINGS + 0x0001)
#define IDS_CREDUI_REBOOT_PROMPT        (ID_BASE_CREDENTIALS_STRINGS + 0x0002)
#define IDS_REBOOT_TITLE                (ID_BASE_CREDENTIALS_STRINGS + 0x0003)
#define IDS_REBOOT_PROMPT               (ID_BASE_CREDENTIALS_STRINGS + 0x0004)


////////////////////////////////////////////////////////////////////
// EVENT STRINGS
////////////////////////////////////////////////////////////////////

#define IDS_BROWSEFORSOUND              (ID_BASE_EVENTS_STRINGS + 0x0000)
#define IDS_UNKNOWN                     (ID_BASE_EVENTS_STRINGS + 0x0001)
#define IDS_REMOVESCHEME                (ID_BASE_EVENTS_STRINGS + 0x0002)
#define IDS_CHANGESCHEME                (ID_BASE_EVENTS_STRINGS + 0x0003)
#define IDS_SOUND                       (ID_BASE_EVENTS_STRINGS + 0x0004)
#define IDS_WINDOWSDEFAULT              (ID_BASE_EVENTS_STRINGS + 0x0005)
#define IDS_ERRORFILEPLAY               (ID_BASE_EVENTS_STRINGS + 0x0006)
#define IDS_ERRORUNKNOWNPLAY            (ID_BASE_EVENTS_STRINGS + 0x0007)
#define IDS_ERRORFORMATPLAY             (ID_BASE_EVENTS_STRINGS + 0x0008)
#define IDS_ERRORPLAY                   (ID_BASE_EVENTS_STRINGS + 0x0009)
#define IDS_NOWAVEDEV                   (ID_BASE_EVENTS_STRINGS + 0x000A)
#define IDS_NODESC                      (ID_BASE_EVENTS_STRINGS + 0x000B)
#define IDS_SAVESCHEME                  (ID_BASE_EVENTS_STRINGS + 0x000C)
#define IDS_CONFIRMREMOVE               (ID_BASE_EVENTS_STRINGS + 0x000D)
#define IDS_NOOVERWRITEDEFAULT          (ID_BASE_EVENTS_STRINGS + 0x000E)
#define IDS_SAVECHANGE                  (ID_BASE_EVENTS_STRINGS + 0x000F)
#define IDS_OVERWRITESCHEME             (ID_BASE_EVENTS_STRINGS + 0x0010)
#define IDS_ERRORDEVBUSY                (ID_BASE_EVENTS_STRINGS + 0x0011)
#define IDS_NONECHOSEN                  (ID_BASE_EVENTS_STRINGS + 0x0012)
#define IDS_DEFAULTAPP                  (ID_BASE_EVENTS_STRINGS + 0x0013)
#define IDS_INVALIDFILE                 (ID_BASE_EVENTS_STRINGS + 0x0014)
#define IDS_NULLCHAR                    (ID_BASE_EVENTS_STRINGS + 0x0015)
#define IDS_WAVFILES                    (ID_BASE_EVENTS_STRINGS + 0x0016)
#define IDS_NOSNDFILE                   (ID_BASE_EVENTS_STRINGS + 0x0017)
#define IDS_NOSNDFILETITLE              (ID_BASE_EVENTS_STRINGS + 0x0018)
#define IDS_OK                          (ID_BASE_EVENTS_STRINGS + 0x0019)
#define IDS_INVALIDFILEQUERY            (ID_BASE_EVENTS_STRINGS + 0x001A)
#define IDS_ISNOTSNDFILE                (ID_BASE_EVENTS_STRINGS + 0x001B)
#define IDS_SCHEMENOTSAVED              (ID_BASE_EVENTS_STRINGS + 0x001C)
#define IDS_PREVSCHEME                  (ID_BASE_EVENTS_STRINGS + 0x001D)

////////////////////////////////////////////////////////////////////
// MIDI STRINGS
////////////////////////////////////////////////////////////////////

#define IDS_MMPROP                      (ID_BASE_MIDI_STRINGS + 0x0000)
#define IDS_NOCHAN                      (ID_BASE_MIDI_STRINGS + 0x0001)
#define IDS_CHANPLURAL                  (ID_BASE_MIDI_STRINGS + 0x0002)
#define IDS_CHANSINGULAR                (ID_BASE_MIDI_STRINGS + 0x0003)
#define IDS_MIDIDETAILS                 (ID_BASE_MIDI_STRINGS + 0x0004)
#define IDS_MIDI_DEV_AND_INST           (ID_BASE_MIDI_STRINGS + 0x0005)
#define IDS_UNSPECIFIED                 (ID_BASE_MIDI_STRINGS + 0x0006)
#define IDS_DEFAULT_SCHEME_NAME         (ID_BASE_MIDI_STRINGS + 0x0007)
#define IDS_RUNONCEWIZLABEL             (ID_BASE_MIDI_STRINGS + 0x0008)
#define IDS_DEF_DEFINITION              (ID_BASE_MIDI_STRINGS + 0x0009)
#define IDS_DEF_INSTRNAME               (ID_BASE_MIDI_STRINGS + 0x000A)
#define IDS_QUERY_DELETESCHEME          (ID_BASE_MIDI_STRINGS + 0x000B)
#define IDS_DEF_CAPTION                 (ID_BASE_MIDI_STRINGS + 0x000C)
#define IDS_QUERY_OVERSCHEME            (ID_BASE_MIDI_STRINGS + 0x000D)
#define IDS_WIZNAME                     (ID_BASE_MIDI_STRINGS + 0x000E)
#define IDS_IDFFILES                    (ID_BASE_MIDI_STRINGS + 0x000F)
#define IDS_IDF_CAPTION                 (ID_BASE_MIDI_STRINGS + 0x0010)
#define IDS_QUERY_OVERIDF               (ID_BASE_MIDI_STRINGS + 0x0011)
#define IDS_MAPPER_BUSY                 (ID_BASE_MIDI_STRINGS + 0x0012)

////////////////////////////////////////////////////////////////////
// SOME CONTROL ID's
////////////////////////////////////////////////////////////////////

#define IDC_CD_TB_VOLUME                (ID_SIMPLE_PROP + 0x0000)
#define IDC_CD_CB_SELECT                (ID_SIMPLE_PROP + 0x0001)
#define IDC_VIDEO_INWINDOW              (ID_SIMPLE_PROP + 0x0002)
#define IDC_VIDEO_FULLSCREEN            (ID_SIMPLE_PROP + 0x0003)
#define IDC_VIDEO_CB_SIZE               (ID_SIMPLE_PROP + 0x0004)
#define IDC_SCREENSAMPLE                (ID_SIMPLE_PROP + 0x0005)
#define IDC_AUDIO_CB_PLAY               (ID_SIMPLE_PROP + 0x0006)
#define IDC_AUDIO_CB_REC                (ID_SIMPLE_PROP + 0x0007)
#define IDC_MUSIC_CB_PLAY               (ID_SIMPLE_PROP + 0x0008)
#define IDC_AUDIO_PREF                  (ID_SIMPLE_PROP + 0x0009)
#define IDC_TASKBAR_VOLUME              (ID_SIMPLE_PROP + 0x000A)
#define IDC_LAUNCH_SNDVOL               (ID_SIMPLE_PROP + 0x000B)
#define IDC_LAUNCH_RECVOL               (ID_SIMPLE_PROP + 0x000C)
#define IDC_LAUNCH_MUSICVOL             (ID_SIMPLE_PROP + 0x000D)
#define IDC_PLAYBACK_ADVSETUP           (ID_SIMPLE_PROP + 0x000E)
#define IDC_MASTERVOLUME                (ID_SIMPLE_PROP + 0x000F)
#define IDC_RECORD_ADVSETUP             (ID_SIMPLE_PROP + 0x0010)
#define IDC_MUSIC_ABOUT                 (ID_SIMPLE_PROP + 0x0011)
#define IDC_VOLUME_LOW                  (ID_SIMPLE_PROP + 0x0012)
#define IDC_VOLUME_HIGH                 (ID_SIMPLE_PROP + 0x0013)
#define ID_APPLY                        (ID_SIMPLE_PROP + 0x0014)
#define ID_INIT                         (ID_SIMPLE_PROP + 0x0015)
#define ID_REMOVE                       (ID_SIMPLE_PROP + 0x0016)
#define ID_REBUILD                      (ID_SIMPLE_PROP + 0x0017)
#define IDC_CDEN_DIGAUDIO               (ID_SIMPLE_PROP + 0x0018)
#define IDC_SOUND_FILES                 (ID_SIMPLE_PROP + 0x0019)
#define IDC_EVENT_TREE                  (ID_SIMPLE_PROP + 0x001A)
#define IDD_INPUT                       (ID_SIMPLE_PROP + 0x001B)
#define IDC_TTS_ABOUT                   (ID_SIMPLE_PROP + 0x001C)
#define IDC_SR_MIC                      (ID_SIMPLE_PROP + 0x001D)
#define IDC_SRLIST                      (ID_SIMPLE_PROP + 0x001E)
#define IDC_SR_GENERAL                  (ID_SIMPLE_PROP + 0x001F)
#define IDC_SR_ABOUT                    (ID_SIMPLE_PROP + 0x0020)
#define IDC_SR_TRAIN                    (ID_SIMPLE_PROP + 0x0021)
#define IDC_SR_PRONUNCIATION            (ID_SIMPLE_PROP + 0x0022)
#define IDC_TTSLIST                     (ID_SIMPLE_PROP + 0x0023)
#define IDC_TTS_TRANSLATE               (ID_SIMPLE_PROP + 0x0024)
#define IDC_TTS_GENERAL                 (ID_SIMPLE_PROP + 0x0025)
#define IDC_TTS_PRONUNCIATION           (ID_SIMPLE_PROP + 0x0026)
#define IDD_OUTPUT                      (ID_SIMPLE_PROP + 0x0027)
#define IDC_VOLUME_MIXER                (ID_SIMPLE_PROP + 0x0028)
#define IDC_VOLUME_MUTE                 (ID_SIMPLE_PROP + 0x0029)
#define IDC_LAUNCH_MULTICHANNEL         (ID_SIMPLE_PROP + 0x0030)
#define IDC_STATIC_EVENT                (ID_SIMPLE_PROP + 0x0031)

////////////////////////////////////////////////////////////////////
// ADVANCED PROPERTY CONTROLS
////////////////////////////////////////////////////////////////////

#define IDD_CPL_BTN_ABOUT               (ID_ADVANCED_PROP + 0x0000)
#define IDD_ABOUT_TXT_DESCRIPTION       (ID_ADVANCED_PROP + 0x0001)
#define IDD_ABOUT_TXT_VERSION           (ID_ADVANCED_PROP + 0x0002)
#define IDD_ABOUT_TXT_COPYRIGHT         (ID_ADVANCED_PROP + 0x0003)
#define IDD_ABOUT_TXT_LICENSING         (ID_ADVANCED_PROP + 0x0004)
#define IDD_ABOUT_TXT_FEATURES          (ID_ADVANCED_PROP + 0x0005)
#define IDD_PRIORITY_TXT_FROMTO         (ID_ADVANCED_PROP + 0x0006)
#define IDD_PRIORITY_COMBO_PRIORITY     (ID_ADVANCED_PROP + 0x0007)
#define IDD_ABOUT_ICON_DRIVER           (ID_ADVANCED_PROP + 0x0008)
#define IDC_DONOTMAP                    (ID_ADVANCED_PROP + 0x0009)
#define ID_TOGGLE                       (ID_ADVANCED_PROP + 0x000A)
#define ID_ADV_REMOVE                   (ID_ADVANCED_PROP + 0x000B)
#define IDC_ENABLE                      (ID_ADVANCED_PROP + 0x000C)
#define IDC_DISABLE                     (ID_ADVANCED_PROP + 0x000D)
#define IDC_DEV_ICON                    (ID_ADVANCED_PROP + 0x000E)
#define IDC_DEV_DESC                    (ID_ADVANCED_PROP + 0x000F)
#define IDC_DEV_STATUS                  (ID_ADVANCED_PROP + 0x0010)
#define ID_DEV_SETTINGS                 (ID_ADVANCED_PROP + 0x0011)
#define ID_WHATSTHIS                    (ID_ADVANCED_PROP + 0x0012)
#define IDC_ADV_TREE                    (ID_ADVANCED_PROP + 0x0013)
#define IDC_DEVICECLASS                 (ID_ADVANCED_PROP + 0x0014)



////////////////////////////////////////////////////////////////////
// CONTROL IDS
////////////////////////////////////////////////////////////////////

#define IDC_IMAGEFRAME                  (ID_BASE_CONTROL + 0x0000)
#define IDD_DISPFRAME                   (ID_BASE_CONTROL + 0x0001)
#define IDD_FILENAME                    (ID_BASE_CONTROL + 0x0002)
#define IDD_CRLABEL                     (ID_BASE_CONTROL + 0x0003)
#define IDD_COPYRIGHT                   (ID_BASE_CONTROL + 0x0004)
#define IDD_LENLABEL                    (ID_BASE_CONTROL + 0x0005)
#define IDD_FILELEN                     (ID_BASE_CONTROL + 0x0006)
#define IDD_AUDIOFORMAT                 (ID_BASE_CONTROL + 0x0007)
#define IDD_AUDIOFORMATLABEL            (ID_BASE_CONTROL + 0x0008)
#define IDD_VIDEOFORMAT                 (ID_BASE_CONTROL + 0x0009)
#define IDD_VIDEOFORMATLABEL            (ID_BASE_CONTROL + 0x000A)
#define IDD_INFO_NAME                   (ID_BASE_CONTROL + 0x000B)
#define IDD_INFO_VALUE                  (ID_BASE_CONTROL + 0x000C)
#define IDD_DISP_ICON                   (ID_BASE_CONTROL + 0x000D)
#define IDC_DETAILSINFO_GRP             (ID_BASE_CONTROL + 0x000E)
#define IDC_ITEMSLABEL                  (ID_BASE_CONTROL + 0x000F)
#define IDC_DESCLABEL                   (ID_BASE_CONTROL + 0x0010)
#define IDD_MIDISEQUENCELABEL           (ID_BASE_CONTROL + 0x0011)
#define IDD_MIDISEQUENCENAME            (ID_BASE_CONTROL + 0x0012)
#define IDC_ACCELERATION                (ID_BASE_CONTROL + 0x0013)
#define IDC_SRCQUALITY                  (ID_BASE_CONTROL + 0x0014)
#define IDC_PREFERREDONLY               (ID_BASE_CONTROL + 0x0015)
#define IDC_HWMESSAGE                   (ID_BASE_CONTROL + 0x0016)
#define IDC_SRCMSG                      (ID_BASE_CONTROL + 0x0017)
#define IDC_DEFAULTS                    (ID_BASE_CONTROL + 0x0018)
#define IDC_SPEAKERCONFIG               (ID_BASE_CONTROL + 0x0019)
#define IDAPPLY                         (ID_BASE_CONTROL + 0x001A)
#define IDC_VOLUME_BRAND                (ID_BASE_CONTROL + 0x001B)
#define IDC_VOLUME_ICON                 (ID_BASE_CONTROL + 0x001C)
#define IDC_VOLUME_SPEAKER_BITMAP       (ID_BASE_CONTROL + 0x001D)
#define IDC_VOLUME_ICON_BRAND           (ID_BASE_CONTROL + 0x001E)


////////////////////////////////////////////////////////////////////
// MIDI CONTROL IDS
////////////////////////////////////////////////////////////////////

#define IDC_INSTRUMENTS                 (ID_MIDI_PROP + 0x0000)
#define IDC_SCHEMES                     (ID_MIDI_PROP + 0x0001)
#define IDL_CHANNELS                    (ID_MIDI_PROP + 0x0002)
#define IDE_SHOW_CHANNELS               (ID_MIDI_PROP + 0x0003)
#define IDE_SCHEMENAME                  (ID_MIDI_PROP + 0x0004)
#define IDB_DETAILS                     (ID_MIDI_PROP + 0x0005)
#define IDC_RADIO_SINGLE                (ID_MIDI_PROP + 0x0006)
#define IDC_RADIO_CUSTOM                (ID_MIDI_PROP + 0x0007)
#define IDB_CONFIGURE                   (ID_MIDI_PROP + 0x0008)
#define IDB_DELETE                      (ID_MIDI_PROP + 0x0009)
#define IDB_SAVE_AS                     (ID_MIDI_PROP + 0x000A)
#define IDB_CHANGE                      (ID_MIDI_PROP + 0x000B)
#define IDB_REMOVE                      (ID_MIDI_PROP + 0x000C)
#define IDE_ALIAS                       (ID_MIDI_PROP + 0x000D)
#define IDC_TYPES                       (ID_MIDI_PROP + 0x000E)
#define IDC_DEVICES                     (ID_MIDI_PROP + 0x000F)
#define IDL_INSTRUMENTS                 (ID_MIDI_PROP + 0x0010)
#define IDC_CLASS_ICON                  (ID_MIDI_PROP + 0x0011)
#define IDC_INSTRUMENT_LABEL            (ID_MIDI_PROP + 0x0012)
#define IDC_CLASS_LABEL                 (ID_MIDI_PROP + 0x0013)
#define IDC_DEVICE_TYPE                 (ID_MIDI_PROP + 0x0014)
#define IDC_MANUFACTURER                (ID_MIDI_PROP + 0x0015)
#define IDB_NEWTYPE                     (ID_MIDI_PROP + 0x0016)
#define IDB_ADDWIZ                      (ID_MIDI_PROP + 0x0017)
#define IDC_WIZBMP                      (ID_MIDI_PROP + 0x0018)
#define IDC_GROUPBOX                    (ID_MIDI_PROP + 0x0019)
#define IDC_SCHEMESLABEL                (ID_MIDI_PROP + 0x001A)
#define IDC_TEXT_1                      (ID_MIDI_PROP + 0x001B)
#define IDC_TEXT_2                      (ID_MIDI_PROP + 0x001C)
#define IDC_TEXT_3                      (ID_MIDI_PROP + 0x001D)
#define IDC_TEXT_4                      (ID_MIDI_PROP + 0x001E)
#define IDC_TEXT_5                      (ID_MIDI_PROP + 0x001F)
#define IDC_TEXT_6                      (ID_MIDI_PROP + 0x0020)
#define IDC_TEXT_7                      (ID_MIDI_PROP + 0x0021)
#define IDC_TEXT_8                      (ID_MIDI_PROP + 0x0022)
#define IDC_TEXT_9                      (ID_MIDI_PROP + 0x0023)
#define IDC_GROUPBOX_2                  (ID_MIDI_PROP + 0x0024)
#define IDC_ICON_1                      (ID_MIDI_PROP + 0x0025)
#define IDC_ICON_2                      (ID_MIDI_PROP + 0x0026)
#define IDE_TYPES                       (ID_MIDI_PROP + 0x0027)
#define IDC_TEXT_10                     (ID_MIDI_PROP + 0x0028)
#define IDC_TEXT_11                     (ID_MIDI_PROP + 0x0029)
#define IDC_TEXT_12                     (ID_MIDI_PROP + 0x002A)
#define IDC_TEXT_13                     (ID_MIDI_PROP + 0x002B)
#define IDC_TEXT_14                     (ID_MIDI_PROP + 0x002C)
#define IDC_TEXT_15                     (ID_MIDI_PROP + 0x002E)
#define IDC_TEXT_16                     (ID_MIDI_PROP + 0x002F)
#define IDC_TEXT_17                     (ID_MIDI_PROP + 0x0030)
#define IDC_TEXT_18                     (ID_MIDI_PROP + 0x0031)
#define IDC_TEXT_19                     (ID_MIDI_PROP + 0x0032)
#define IDC_TEXT_20                     (ID_MIDI_PROP + 0x0033)
#define IDC_TEXT_21                     (ID_MIDI_PROP + 0x0034)
#define IDC_TEXT_22                     (ID_MIDI_PROP + 0x0035)
#define IDC_TEXT_23                     (ID_MIDI_PROP + 0x0036)
#define IDC_TEXT_24                     (ID_MIDI_PROP + 0x0037)
#define IDC_TEXT_25                     (ID_MIDI_PROP + 0x0038)
#define IDC_TEXT_26                     (ID_MIDI_PROP + 0x0039)
#define IDC_TEXT_27                     (ID_MIDI_PROP + 0x003A)
#define IDC_TEXT_28                     (ID_MIDI_PROP + 0x003B)
#define IDC_TEXT_29                     (ID_MIDI_PROP + 0x003C)
#define IDC_TEXT_30                     (ID_MIDI_PROP + 0x003D)
#define IDC_TEXT_31                     (ID_MIDI_PROP + 0x003E)
#define IDC_TEXT_32                     (ID_MIDI_PROP + 0x003F)
#define IDC_ICON_3                      (ID_MIDI_PROP + 0x0040)
#define IDC_ICON_4                      (ID_MIDI_PROP + 0x0041)
#define IDC_ICON_5                      (ID_MIDI_PROP + 0x0042)
#define IDC_ICON_6                      (ID_MIDI_PROP + 0x0043)
#define IDC_ICON_7                      (ID_MIDI_PROP + 0x0044)
#define IDC_ICON_8                      (ID_MIDI_PROP + 0x0045)
#define IDC_ABOUTSYNTH                  (ID_MIDI_PROP + 0x0046)
#define IDC_LOGO_FRAME                  (ID_MIDI_PROP + 0x0047)
#define IDC_RENDERER                    (ID_MIDI_PROP + 0x0048)
#define IDC_GROUPBOX_3                  (ID_MIDI_PROP + 0x0049)
#define IDC_TEXT_33                     (ID_MIDI_PROP + 0x004A)


////////////////////////////////////////////////////////////////////
// EVENTS IDS
////////////////////////////////////////////////////////////////////

#define ID_SCHEMENAME                   (ID_EVENTS_START + 0x0000)
#define LB_INSTALLED                    (ID_EVENTS_START + 0x0001)
#define ID_PLAY                         (ID_EVENTS_START + 0x0002)
#define ID_REMOVE_SCHEME                (ID_EVENTS_START + 0x0004)
#define ID_SAVE_SCHEME                  (ID_EVENTS_START + 0x0005)
#define CB_SCHEMES                      (ID_EVENTS_START + 0x0006)
#define ID_INSTALL                      (ID_EVENTS_START + 0x0007)
#define ID_CONFIGURE                    (ID_EVENTS_START + 0x0008)
#define ID_STOP                         (ID_EVENTS_START + 0x0009)
#define ID_BROWSE                       (ID_EVENTS_START + 0x000B)
#define IDC_STATIC_PREVIEW              (ID_EVENTS_START + 0x000C)
#define IDC_STATIC_NAME                 (ID_EVENTS_START + 0x000D)
#define IDC_SOUNDGRP                    (ID_EVENTS_START + 0x000E)
#define ID_DESC                         (ID_EVENTS_START + 0x000F)
#define ID_SAVEAS_HELP                  (ID_EVENTS_START + 0x0010)

////////////////////////////////////////////////////////////////////
// Multichannel Page ID's
////////////////////////////////////////////////////////////////////

#define IDC_MC_ZERO                     (ID_MULTICHANNEL_PROP + 0x0000)
#define IDC_MC_ZERO_LOW                 (ID_MULTICHANNEL_PROP + 0x0001)
#define IDC_MC_ZERO_HIGH                (ID_MULTICHANNEL_PROP + 0x0002)
#define IDC_MC_ZERO_VOLUME              (ID_MULTICHANNEL_PROP + 0x0003)
#define IDC_MC_ONE                      (ID_MULTICHANNEL_PROP + 0x0004)
#define IDC_MC_ONE_LOW                  (ID_MULTICHANNEL_PROP + 0x0005)
#define IDC_MC_ONE_HIGH                 (ID_MULTICHANNEL_PROP + 0x0006)
#define IDC_MC_ONE_VOLUME               (ID_MULTICHANNEL_PROP + 0x0007)
#define IDC_MC_TWO                      (ID_MULTICHANNEL_PROP + 0x0008)
#define IDC_MC_TWO_LOW                  (ID_MULTICHANNEL_PROP + 0x0009)
#define IDC_MC_TWO_HIGH                 (ID_MULTICHANNEL_PROP + 0x000A)
#define IDC_MC_TWO_VOLUME               (ID_MULTICHANNEL_PROP + 0x000B)
#define IDC_MC_THREE                    (ID_MULTICHANNEL_PROP + 0x000C)
#define IDC_MC_THREE_LOW                (ID_MULTICHANNEL_PROP + 0x000D)
#define IDC_MC_THREE_HIGH               (ID_MULTICHANNEL_PROP + 0x000E)
#define IDC_MC_THREE_VOLUME             (ID_MULTICHANNEL_PROP + 0x000F)
#define IDC_MC_FOUR                     (ID_MULTICHANNEL_PROP + 0x0010)
#define IDC_MC_FOUR_LOW                 (ID_MULTICHANNEL_PROP + 0x0011)
#define IDC_MC_FOUR_HIGH                (ID_MULTICHANNEL_PROP + 0x0012)
#define IDC_MC_FOUR_VOLUME              (ID_MULTICHANNEL_PROP + 0x0013)
#define IDC_MC_FIVE                     (ID_MULTICHANNEL_PROP + 0x0014)
#define IDC_MC_FIVE_LOW                 (ID_MULTICHANNEL_PROP + 0x0015)
#define IDC_MC_FIVE_HIGH                (ID_MULTICHANNEL_PROP + 0x0016)
#define IDC_MC_FIVE_VOLUME              (ID_MULTICHANNEL_PROP + 0x0017)
#define IDC_MC_SIX                      (ID_MULTICHANNEL_PROP + 0x0018)
#define IDC_MC_SIX_LOW                  (ID_MULTICHANNEL_PROP + 0x0019)
#define IDC_MC_SIX_HIGH                 (ID_MULTICHANNEL_PROP + 0x001A)
#define IDC_MC_SIX_VOLUME               (ID_MULTICHANNEL_PROP + 0x001B)
#define IDC_MC_SEVEN                    (ID_MULTICHANNEL_PROP + 0x001C)
#define IDC_MC_SEVEN_LOW                (ID_MULTICHANNEL_PROP + 0x001D)
#define IDC_MC_SEVEN_HIGH               (ID_MULTICHANNEL_PROP + 0x001E)
#define IDC_MC_SEVEN_VOLUME             (ID_MULTICHANNEL_PROP + 0x001F)
#define IDC_MC_MOVE_TOGETHER            (ID_MULTICHANNEL_PROP + 0x0020)
#define IDC_MC_RESTORE                  (ID_MULTICHANNEL_PROP + 0x0021)
#define IDC_MC_DESCRIPTION              (ID_MULTICHANNEL_PROP + 0x0022)

/*
 ***************************************************************
 * Defines for Voice CPL.
 ***************************************************************     
 */     
#define IDC_ICON_VOC_1                   (ID_VOICE_PROP + 0x0001) 
#define IDC_ICON_VOC_2                   (ID_VOICE_PROP + 0x0002) 
#define IDC_GROUPBOX_VOC_1               (ID_VOICE_PROP + 0x0003) 
#define IDC_GROUPBOX_VOC_2               (ID_VOICE_PROP + 0x0004) 
#define IDC_TEXT_VOC_1                   (ID_VOICE_PROP + 0x0005)
#define IDC_TEXT_VOC_2                   (ID_VOICE_PROP + 0x0006)
#define IDC_VOICE_CB_PLAY                (ID_VOICE_PROP + 0x0007)
#define IDC_VOICE_CB_REC                 (ID_VOICE_PROP + 0x0008)
#define IDC_LAUNCH_VOCVOL                (ID_VOICE_PROP + 0x0009)
#define IDC_PLAYBACK_ADVVOC              (ID_VOICE_PROP + 0x000A)
#define IDC_CAPTURE_ADVVOL               (ID_VOICE_PROP + 0x000B)
#define IDC_LAUNCH_CAPVOL                (ID_VOICE_PROP + 0x000C)
#define IDC_ADVANCED_DIAG                (ID_VOICE_PROP + 0x000D)

/*
 ***************************************************************
 * Defines for Start & Reboot CPL.
 ***************************************************************     
 */     
#define IDC_ICON_START_1                 (ID_START_PROP + 0x0001) 
#define IDC_GROUPBOX_START_1             (ID_START_PROP + 0x0003) 
#define IDC_TEXT_START_1                 (ID_START_PROP + 0x0005)
#define IDC_TEXT_START_2                 (ID_START_PROP + 0x0006)
#define IDC_TEXT_START_3                 (ID_START_PROP + 0x0007)
#define IDC_TEXT_START_4                 (ID_START_PROP + 0x0008)
#define IDC_START_CHECK                  (ID_START_PROP + 0x000D)

#define IDC_ICON_REBOOT_1                 (ID_START_PROP + 0x0011) 
#define IDC_GROUPBOX_REBOOT_1             (ID_START_PROP + 0x0013) 
#define IDC_TEXT_REBOOT_1                 (ID_START_PROP + 0x0015)
#define IDC_TEXT_REBOOT_2                 (ID_START_PROP + 0x0016)
#define IDC_TEXT_REBOOT_3                 (ID_START_PROP + 0x0017)

/*
 ***************************************************************
 * Defines for Effects CPL.
 ***************************************************************     
 */     
#define IDC_EFFECT_LIST                  (ID_EFFECT_PROP + 0x0001) 
#define IDB_EFFECT_PROP                  (ID_EFFECT_PROP + 0x0004) 
#define IDC_EFFECT_STATIC                (ID_EFFECT_PROP + 0x0005) 
#define IDB_EFFECT_PLAY                  (ID_EFFECT_PROP + 0x0008) 
#define IDC_EFFECT_HELPTEXT              (ID_EFFECT_PROP + 0x000B) 


////////////////////////////////////////////////////////////////////
// mmioFOURCC
////////////////////////////////////////////////////////////////////

#define FOURCC_INFO mmioFOURCC('I','N','F','O')
#define FOURCC_DISP mmioFOURCC('D','I','S','P')
#define FOURCC_IARL mmioFOURCC('I','A','R','L')
#define FOURCC_IART mmioFOURCC('I','A','R','T')
#define FOURCC_ICMS mmioFOURCC('I','C','M','S')
#define FOURCC_ICMT mmioFOURCC('I','C','M','T')
#define FOURCC_ICOP mmioFOURCC('I','C','O','P')
#define FOURCC_ICRD mmioFOURCC('I','C','R','D')
#define FOURCC_ICRP mmioFOURCC('I','C','R','P')
#define FOURCC_IDIM mmioFOURCC('I','D','I','M')
#define FOURCC_IDPI mmioFOURCC('I','D','P','I')
#define FOURCC_IENG mmioFOURCC('I','E','N','G')
#define FOURCC_IGNR mmioFOURCC('I','G','N','R')
#define FOURCC_IKEY mmioFOURCC('I','K','E','Y')
#define FOURCC_ILGT mmioFOURCC('I','L','G','T')
#define FOURCC_IMED mmioFOURCC('I','M','E','D')
#define FOURCC_INAM mmioFOURCC('I','N','A','M')
#define FOURCC_IPLT mmioFOURCC('I','P','L','T')
#define FOURCC_IPRD mmioFOURCC('I','P','R','D')
#define FOURCC_ISBJ mmioFOURCC('I','S','B','J')
#define FOURCC_ISFT mmioFOURCC('I','S','F','T')
#define FOURCC_ISHP mmioFOURCC('I','S','H','P')
#define FOURCC_ISRC mmioFOURCC('I','S','R','C')
#define FOURCC_ISRF mmioFOURCC('I','S','R','F')
#define FOURCC_ITCH mmioFOURCC('I','T','C','H')
#define FOURCC_VIDC mmioFOURCC('V','I','D','C')

#define mmioWAVE    mmioFOURCC('W','A','V','E')
#define mmioFMT     mmioFOURCC('f','m','t',' ')
#define mmioDATA    mmioFOURCC('d','a','t','a')
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\roland.cpp ===
//--------------------------------------------------------------------------;
//
//  File: Roland.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//--------------------------------------------------------------------------;

#include "mmcpl.h"
#include <windowsx.h>
#include <cpl.h>
#include <commctrl.h>
#include <string.h>
#include <memory.h>

////////////
// Functions
////////////


INT_PTR CALLBACK RolandDlgHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fReturnVal = FALSE;
	static HBITMAP hLogo = NULL;
    	
    switch (msg)
    {
    	default:
			fReturnVal = FALSE;
		break;
		
        case WM_SYSCOLORCHANGE:
        {
            if (hLogo)
            {
                DeleteObject( (HGDIOBJ) hLogo);
                hLogo = NULL;
            }

            hLogo = (HBITMAP) LoadImage(ghInstance,MAKEINTATOM(IDB_ROLAND), IMAGE_BITMAP, 0, 0, LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS);

            if (hLogo)
            {
                SendDlgItemMessage(hDlg, IDC_LOGO_FRAME, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hLogo);
            }

            fReturnVal = TRUE;
        }
        break;

        case WM_DESTROY:
        {
            if (hLogo)
            {
                DeleteObject( (HGDIOBJ) hLogo);
                hLogo = NULL;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            if (lParam)
            {
                SetWindowText(GetDlgItem(hDlg, IDC_RENDERER), (TCHAR *) lParam);
            }

            hLogo = (HBITMAP) LoadImage(ghInstance,MAKEINTATOM(IDB_ROLAND), IMAGE_BITMAP, 0, 0, LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS);

            if (hLogo)
            {
                SendDlgItemMessage(hDlg, IDC_LOGO_FRAME, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hLogo);
            }

            fReturnVal = TRUE;
        }		
		break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                case IDOK:
	            	EndDialog(hDlg, TRUE);
				break;
            }
            break;
        }
    }

    return fReturnVal;
}

STDAPI_(void) RolandProp(HWND hwnd, HINSTANCE hInst, TCHAR *szName)
{
	DialogBoxParam(hInst,MAKEINTRESOURCE(IDD_ROLAND),hwnd, RolandDlgHandler, (LPARAM) szName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\perfpage.h ===
//--------------------------------------------------------------------------;
//
//  File: perfpage.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;

#ifndef PERFPAGE_HEADER
#define PERFPAGE_HEADER


#define MAX_HW_LEVEL			(3)
#define MAX_SRC_LEVEL			(2)
#define DEFAULT_HW_LEVEL		(2)
#define DEFAULT_SRC_LEVEL		(2)


INT_PTR CALLBACK PerformanceHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);


#endif // PERFPAGE_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\reboot.c ===
//==========================================================================;
//
//  reboot.c
//
//  Copyright (c) 1991-2002 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//
//
//  History:
//      07/02        tsharp  (Trey Sharp);
//
//
//==========================================================================;

#include "mmcpl.h"
#include <windowsx.h>
#include <mmsystem.h>
#include <dbt.h>
#include <ks.h>
#include <ksmedia.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <msacmdlg.h>
#include <stdlib.h>
#include "gfxui.h"
#include "drivers.h"
#include "advaudio.h"
#include "roland.h"

#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <devguid.h>

#include <memory.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "trayvol.h"

#include "utils.h"
#include "medhelp.h"
#include "start.h"


/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */


/*
 ***************************************************************
 * extern
 ***************************************************************
 */


/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */

BOOL PASCAL DoRebootCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);

STATIC void REBOOTInit(HWND hDlg)
{
    // Add initializing code here
}


const static DWORD aRebootHelpIds[] = {  // Context Help IDs
    IDC_GROUPBOX_REBOOT_1,               NO_HELP,
    IDC_ICON_REBOOT_1,                   NO_HELP,
    IDC_TEXT_REBOOT_1,                   NO_HELP,
    IDC_TEXT_REBOOT_2,                   NO_HELP,
    
    0, 0
};


BOOL CALLBACK RebootDlg(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    NMHDR FAR   *lpnm;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                break;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            REBOOTInit(hDlg);
        }
        break;

        case WM_DESTROY:
        {
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aRebootHelpIds);
            return TRUE;
        }
        break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aRebootHelpIds);
            return TRUE;
        }
        break;

        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoRebootCommand);
        }
        break;

        default:
        {
        }
        break;
    }
    return FALSE;
}


BOOL PASCAL DoRebootCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{

    switch (id)
    {
        case IDOK:
        {
            HANDLE hToken;
            DWORD dwError;

            dwError = RebootSystem( hDlg, FALSE, FALSE, FALSE );
            while( dwError == ERROR_PRIVILEGE_NOT_HELD  ||
                   dwError == ERROR_NOT_ALL_ASSIGNED  ||
                   dwError == ERROR_ACCESS_DENIED )
            {
                hToken = GetAdminPrivilege( IDS_CREDUI_REBOOT_PROMPT );
                if( hToken )
                {
                    dwError = RebootSystem( hDlg, TRUE, FALSE, FALSE );
                    ReleaseAdminPrivilege( hToken );
                }
                else
                {
                    // User cancelled credentials UI, so force CPL to remain open
                    gfRedisplayCPL = TRUE; 

                    // Force break from while statement
                    dwError = ERROR_CANCELLED;
                }
            }
        }
        break;
    }

    return FALSE;
}

BOOL RebootNeeded(void)
{
    HKEY    hkTmp;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE
			     , REGSTR_TEMP_REBOOT
			     , 0
			     , KEY_READ
			     , &hkTmp ) == ERROR_SUCCESS)
    {
        RegCloseKey(hkTmp);
        return TRUE;
    }
    return FALSE;
}

DWORD RebootSystem( HWND hDlg, BOOL fUseThreadToken, BOOL fAskUser, BOOL fDisplayPrivilegeError )
{
    HANDLE hToken; 
    TOKEN_PRIVILEGES tkp; 
    DWORD dwError;

    if( fAskUser )
    {
        TCHAR achTitle[CREDUI_REBOOT_TITLE_MAX_LENGTH];
        TCHAR achPrompt[CREDUI_REBOOT_PROMPT_MAX_LENGTH];
        
        LoadString( ghInstance, IDS_REBOOT_TITLE, achTitle, CREDUI_REBOOT_TITLE_MAX_LENGTH );
        LoadString( ghInstance, IDS_REBOOT_PROMPT, achPrompt, CREDUI_REBOOT_PROMPT_MAX_LENGTH );
        
        if( IDNO == MessageBox(hDlg, achPrompt, achTitle, MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL) )
        {
            // User cancelled reboot, so force CPL to remain open
            gfRedisplayCPL = TRUE; 
            return ERROR_CANCELLED;
        }
    }

    if( fUseThreadToken )
    {
        // Get a token for this thread 
        if( !OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, TRUE, &hToken) ) 
        {
            hToken = NULL;
        }
    }
    else
    {
        // Get a token for this process 
        if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken) ) 
        {
            hToken = NULL;
        }
    }

    if( hToken )
    {
        // Get the LUID for the shutdown privilege. 
        LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid ); 
         
        tkp.PrivilegeCount = 1;  // one privilege to set    
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
         
        // Get the shutdown privilege for this process. 
        AdjustTokenPrivileges( hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0 ); 

        // Close the access token handle
        CloseHandle( hToken );
 
        // Shut down the system
        if( ExitWindowsEx(EWX_REBOOT, SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG) ) 
        {
            return NO_ERROR;
        }
    }

    // Display error message
    dwError = GetLastError();
    if( dwError != NO_ERROR )
    {
        TCHAR achTitle[CREDUI_TITLE_MAX_LENGTH];
        TCHAR achCantRestart[80];
        UINT nResourceId; 

        if( dwError == ERROR_PRIVILEGE_NOT_HELD  
        ||  dwError == ERROR_NOT_ALL_ASSIGNED  
        ||  dwError == ERROR_ACCESS_DENIED )
        {
            nResourceId = IDS_CANNOT_RESTART_PRIVILEGE;
        }
        else
        {
            nResourceId = IDS_CANNOT_RESTART_UNKNOWN;
        }

        if( nResourceId == IDS_CANNOT_RESTART_UNKNOWN
        ||  fDisplayPrivilegeError )
        {
            // We are 'displaying' an error message, so force CPL to remain open
            gfRedisplayCPL = TRUE; 

            LoadString( ghInstance, IDS_CREDUI_TITLE, achTitle, CREDUI_TITLE_MAX_LENGTH );
            LoadString( ghInstance, nResourceId, achCantRestart, sizeof(achCantRestart)/sizeof(TCHAR) );
            MessageBox( hDlg, achCantRestart, achTitle, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL );
        }
    }
    else
    {
        // Something did not work as expected, so force CPL to remain open
        gfRedisplayCPL = TRUE; 
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\scheme.c ===
/*
 ***************************************************************
 *
 *  This file contains the routines to read and write to the reg database
 *
 *  Copyright 1993, Microsoft Corporation
 *
 *  History:
 *
 *    07/94 - VijR (Created)
 *
 ***************************************************************
 */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <cpl.h>
#include <shellapi.h>
#include <ole2.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include "mmcpl.h"
#include "draw.h"
#include "medhelp.h"

/*
 ***************************************************************
 * Definitions
 ***************************************************************
 */
#define KEYLEN  8           //length of artificially created key
#define MAXSCHEME  37      //max length of scheme name



/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
static SZCODE   aszDefaultScheme[]      = TEXT("Appevents\\schemes");
static SZCODE   aszDefaultApp[]         = TEXT("Appevents\\schemes\\apps\\.default");
static SZCODE   aszApps[]               = TEXT("Appevents\\schemes\\apps");
static SZCODE   aszLabels[]             = TEXT("Appevents\\eventlabels");
static SZCODE   aszDisplayLabels[]      = TEXT("DispFileName");
static SZCODE   aszNames[]              = TEXT("Appevents\\schemes\\Names");
static SZCODE   aszDefault[]            = TEXT(".default");
static SZCODE   aszCurrent[]            = TEXT(".current");
static SZCODE   aszMMTask[]             = TEXT("MMTask");
static INTCODE  aKeyWordIds[]           =
{
    ID_SCHEMENAME, IDH_SAVEAS_SCHEMENAME,
    0,0
};
static SZCODE   cszSslashS[] = TEXT("%s\\%s");

/*
 ***************************************************************
 * extern
 ***************************************************************
 */
extern HWND         ghWnd;
extern BOOL         gfChanged;
extern BOOL         gfNewScheme;
extern BOOL         gfDeletingTree;
extern int          giScheme;
extern TCHAR         gszDefaultApp[];
extern TCHAR         gszNullScheme[];
extern TCHAR         gszCmdLineApp[];
extern TCHAR         gszCmdLineEvent[];

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */

BOOL PASCAL RemoveScheme            (HWND);
BOOL PASCAL RegAddScheme            (HWND, LPTSTR);
BOOL PASCAL RegNewScheme            (HWND, LPTSTR, LPTSTR, BOOL);
BOOL PASCAL RegSetDefault           (LPTSTR);
BOOL PASCAL RegDeleteScheme         (HWND, int);
BOOL PASCAL LoadEvents              (HWND, HTREEITEM, PMODULE);
BOOL PASCAL LoadModules             (HWND, LPTSTR);
BOOL PASCAL ClearModules            (HWND, HWND, BOOL);
BOOL PASCAL NewModule               (HWND, LPTSTR, LPTSTR, LPTSTR, int);
BOOL PASCAL FindEventLabel          (LPTSTR, LPTSTR);
BOOL PASCAL AddScheme               (HWND, LPTSTR, LPTSTR, BOOL, int);
void PASCAL GetMediaPath            (LPTSTR, size_t);
void PASCAL RemoveMediaPath         (LPTSTR, LPTSTR);
void PASCAL AddMediaPath            (LPTSTR, LPTSTR);

int ExRegQueryValue (HKEY, LPTSTR, LPBYTE, DWORD *);

//sndfile.c
BOOL PASCAL ShowSoundMapping        (HWND, PEVENT);
int StrByteLen                      (LPTSTR);

//drivers.c
int lstrnicmp (LPTSTR, LPTSTR, size_t);
LPTSTR lstrchr (LPTSTR, TCHAR);

/*
 ***************************************************************
 ***************************************************************
 */

static void AppendRegKeys (
    LPTSTR  szBuf,
    LPCTSTR szLeft,
    LPCTSTR szRight)
{
    static SZCODE cszSlash[] = TEXT("\\");
    lstrcpy (szBuf, szLeft);
    lstrcat (szBuf, cszSlash);
    lstrcat (szBuf, szRight);
}




/*
 ***************************************************************
 *  SaveSchemeDlg
 *
 *  Description: Dialog handler for save schemes dialog.
 *        checks if given scheme name exists and if so
 *        whether it should be overwritten.
 *        if yes then delete current scheme.
 *        scheme under a new name, else just add a new scheme
 *        The user can choose to cancel
 *
 *  Arguments:
 *      HWND    hDlg    -    window handle of dialog window
 *      UINT    uiMessage -  message number
 *      WPARAM    wParam  -  message-dependent
 *      LPARAM    lParam  -  message-dependent
 *
 *  Returns:    BOOL
 *      TRUE if message has been processed, else FALSE
 *
 ***************************************************************************
 */
INT_PTR CALLBACK SaveSchemeDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR    szBuf[MAXSTR];
    TCHAR    szTemp[MAXSTR];
    TCHAR    szMesg[MAXSTR];
    int        iResult;
    int        iIndex;
    HWND    hDlgParent = ghWnd;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            szBuf[0] = TEXT('\0');
            DPF("IN Init\n");
            Edit_LimitText(GetDlgItem(hDlg, ID_SCHEMENAME), MAXSCHEME);

            Edit_SetText(GetDlgItem(hDlg, ID_SCHEMENAME), (LPTSTR)lParam);
            // dump the text from lparam into the edit control.
                
            break;

        case WM_COMMAND:

        switch (wParam)
        {
            case IDOK:
            {
                LPTSTR pszKey;

                Edit_GetText(GetDlgItem(hDlg, ID_SCHEMENAME), szBuf, MAXSTR);

                //prevent null-string names
                if (lstrlen(szBuf) == 0)
                {
                    LoadString(ghInstance, IDS_INVALIDFILE, szTemp, MAXSTR);
                    MessageBox(hDlg, szTemp, gszChangeScheme, MB_ICONERROR | MB_OK);
                    break;
                }

                iIndex = ComboBox_FindStringExact(GetDlgItem(hDlgParent,
                                                    CB_SCHEMES), 0, szBuf);
                pszKey = (LPTSTR)ComboBox_GetItemData(GetDlgItem(hDlgParent,CB_SCHEMES), iIndex);

                if (iIndex != CB_ERR)
                {
                    if (!lstrcmpi((LPTSTR)pszKey, aszDefault) || !lstrcmpi((LPTSTR)pszKey, gszNullScheme))
                    {
                        LoadString(ghInstance, IDS_NOOVERWRITEDEFAULT, szTemp,
                                                                    MAXSTR);
                        wsprintf(szMesg, szTemp, (LPTSTR)szBuf);
                        iResult = MessageBox(hDlg, szMesg, gszChangeScheme,
                            MB_ICONEXCLAMATION | MB_TASKMODAL | MB_OKCANCEL);

                        if (iResult == IDOK)
                        {
                            break;
                        }

                    }
                    else
                    {
                        LoadString(ghInstance, IDS_OVERWRITESCHEME, szTemp,
                                                                    MAXSTR);
                        wsprintf(szMesg, szTemp, (LPTSTR)szBuf);
                        iResult = MessageBox(hDlg, szMesg, gszChangeScheme,
                        MB_ICONEXCLAMATION | MB_TASKMODAL | MB_YESNOCANCEL);

                        if (iResult == IDYES)
                        {
                            RegDeleteScheme(GetDlgItem(hDlgParent,
                                                    CB_SCHEMES), iIndex);
                            RegAddScheme(hDlgParent, szBuf);
                            PropSheet_Changed(GetParent(hDlg),hDlg);
                        }
                        else
                        {
                            if (iResult == IDNO)
                                break;

                            if (iResult == IDCANCEL)
                            {
                                EndDialog(hDlg, FALSE);
                                break;
                            }
                        }
                    }
                }
                else
                {

                    RegAddScheme(hDlgParent, szBuf);
                    PropSheet_Changed(GetParent(hDlg),hDlg);
                }
                gfChanged = TRUE;
                EndDialog(hDlg, TRUE);
                DPF("Done save\n");
                break;
            }

            case IDCANCEL:
                EndDialog(hDlg, FALSE);
                DPF("Done save\n");
                break;


            case ID_SCHEMENAME:

                if ((HIWORD(lParam) == EN_ERRSPACE) ||
                                            (HIWORD(lParam) == EN_MAXTEXT))
                    MessageBeep(MB_OK);

                else
                    if (HIWORD(lParam) == EN_CHANGE)
                    {

                        GetWindowText(GetDlgItem(hDlg, ID_SCHEMENAME), szBuf,
                                                                MAXSTR - 1);
                        EnableWindow(GetDlgItem(hDlg, IDOK), *szBuf);
                    }
                break;

            default:
                break;
            }
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU,
                                    (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;
    }
    return FALSE;
}

/*
 ***************************************************************
 *  RegNewScheme
 *
 *  Description:
 *        Saves the scheme in the reg database. If the fQuery flag is
 *        set then a messages box is brought up, asking if the schem should
 *        be saved
 *
 *  Arguments:
 *        HWND    hDlg    -    Handle to the dialog
 *      LPTSTR    lpszScheme -    pointer to scheme name.
 *      BOOL    fQuery -  If TRUE and lpszScheme is in reg.db bring up msgbox.
 *
 *  Returns:    BOOL
 *      TRUE if the new scheme is succesfully added or if the user chooses
 *        not to save
 *
 ***************************************************************
 */
BOOL PASCAL RegNewScheme(HWND hDlg, LPTSTR lpszKey, LPTSTR lpszLabel,
                                                                BOOL fQuery)
{
    PMODULE npModule;
    PEVENT  npPtr;
    TCHAR     szBuf[MAXSTR];
    TCHAR     szLabel[MAXSTR];
    HTREEITEM hti;
    TV_ITEM    tvi;
    HWND hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);

    if (fQuery)
    {
        LoadString(ghInstance, IDS_SAVECHANGE, szBuf, MAXSTR);
        LoadString(ghInstance, IDS_SAVESCHEME, szLabel, MAXSTR);
        if (MessageBox(hDlg, szBuf, szLabel,
                    MB_ICONEXCLAMATION | MB_TASKMODAL | MB_YESNO) == IDNO)
            return TRUE;
    }

    for (hti = TreeView_GetRoot(hwndTree); hti; hti = TreeView_GetNextSibling(hwndTree, hti))
    {
        tvi.mask = TVIF_PARAM;
        tvi.hItem = hti;
        TreeView_GetItem(hwndTree, &tvi);

        npModule = (PMODULE)tvi.lParam;
        if ((npPtr = npModule->npList) == NULL)
            break;

        for (; npPtr != NULL; npPtr = npPtr->npNextEvent)
        {
            HKEY hk = NULL;
            DWORD dwType;
            static SZCODE cszFmt[] = TEXT("%s\\%s\\%s\\%s");
            wsprintf(szBuf, cszFmt, (LPTSTR)aszApps,
                    (LPTSTR)npModule->pszKey, (LPTSTR)npPtr->pszEvent, lpszKey);
            DPF("setting  %s to %s\n", (LPTSTR)szBuf, (LPTSTR)npPtr->pszPath);

            RemoveMediaPath (szLabel, npPtr->pszPath);
            dwType = (lstrchr (szLabel, TEXT('%'))) ? REG_EXPAND_SZ : REG_SZ;

            // Set file name
            if ((RegCreateKey (HKEY_CURRENT_USER, szBuf, &hk) == ERROR_SUCCESS) && hk)
            {
               if (RegSetValueEx (hk, NULL, 0, dwType, (LPBYTE)szLabel,
                                  (1+lstrlen(szLabel))*sizeof(TCHAR)) != ERROR_SUCCESS)
               {
                   DPF("fail %s for %s,\n", (LPTSTR)szLabel, (LPTSTR)szBuf);
               }

               RegCloseKey (hk);
            }

        }
    }
    return TRUE;
}

/*
 ***************************************************************
 *  RegAddScheme
 *
 *  Description:
 *        Adds the given scheme to the reg database by creating a key using
 *        upto the first KEYLEN letters of the schemename. If the strlen
 *        id less than KEYLEN, '0's are added till the key is KEYLEN long.
 *        This key is checked for uniqueness and then RegNewScheme is called.
 *
 *  Arguments:
 *      HWND    hDlg     -   Handle to the dialog
 *      LPTSTR    lpszScheme  -  pointer to scheme name.
 *
 *  Returns:    BOOL
 *      TRUE if message successful, else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL RegAddScheme(HWND hDlg, LPTSTR lpszScheme)
{
    TCHAR    szKey[32];
    LPTSTR    pszKey;
    int     iIndex;
    int     iLen;
    int     iStrLen;
    HWND    hWndC;
    HKEY    hkScheme;
    HKEY    hkBase;

    hWndC = GetDlgItem(hDlg, CB_SCHEMES);
    iLen = StrByteLen(lpszScheme);
    iStrLen = lstrlen(lpszScheme);

    if (iStrLen < KEYLEN)
    {
        lstrcpy(szKey, lpszScheme);
        iIndex = iLen;
        szKey[iIndex] = TEXT('0');
        szKey[iIndex+sizeof(TCHAR)] = TEXT('\0');
    }
    else
    {
        lstrcpyn(szKey, lpszScheme, KEYLEN-1);
        iIndex = StrByteLen(szKey);
        szKey[iIndex] = TEXT('0');
        szKey[iIndex+sizeof(TCHAR)] = TEXT('\0');
    }
    if (RegOpenKey(HKEY_CURRENT_USER, aszNames, &hkBase) != ERROR_SUCCESS)
    {
        DPF("Failed to open asznames\n");
        return FALSE;
    }
    gfNewScheme = FALSE;
    while (RegOpenKey(hkBase, szKey, &hkScheme) == ERROR_SUCCESS)
    {
        szKey[iIndex]++;
        RegCloseKey(hkScheme);
    }

    if (RegSetValue(hkBase, szKey, REG_SZ, lpszScheme, 0) != ERROR_SUCCESS)
    {
        static SZCODE cszFmt[] = TEXT("%lx");
        wsprintf((LPTSTR)szKey, cszFmt, GetCurrentTime());    //High chance of unique ness. This is to deal with some
                                                            //DBCS problems.
        if (RegSetValue(hkBase, szKey, REG_SZ, lpszScheme, 0) != ERROR_SUCCESS)
        {
            DPF("Couldn't set scheme value %s\n", lpszScheme);
            RegCloseKey(hkBase);
            return FALSE;
        }
    }
    RegCloseKey(hkBase);

    if (RegNewScheme(hDlg, szKey, lpszScheme, FALSE))
    {
        iIndex = ComboBox_GetCount(hWndC);
        ComboBox_InsertString(hWndC, iIndex, lpszScheme);

        pszKey = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szKey)*sizeof(TCHAR)) + sizeof(TCHAR));
        if (pszKey == NULL)
        {
            DPF("Failed Alloc\n");
            return FALSE;
        }
        lstrcpy(pszKey, szKey);


        ComboBox_SetItemData(hWndC, iIndex, (LPVOID)pszKey);
        ComboBox_SetCurSel(hWndC, iIndex);

        giScheme =     ComboBox_GetCurSel(hWndC);
        EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME), TRUE);
    }

    return TRUE;
}

/*
 ***************************************************************
 *  RemoveScheme(hDlg)
 *
 *  Description:
 *          Deletes current scheme; removes it from dialog
 *        combo box, sets the current scheme to <None>,
 *        if it is set to be default. removes it as default
 *          The remove and save buttons
 *        are disabled since the <none> scheme is selected
 *
 *  Arguments:
 *      HWND    hDlg    window handle of dialog window
 *
 *  Returns:    BOOL
 *      TRUE if message successful, else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL RemoveScheme(HWND hDlg)
{
    TCHAR szBuf[MAXSTR];
    TCHAR szScheme[MAXSTR];
    TCHAR szMsg[MAXSTR];
    int  i;
    HWND hWndC;
    HWND        hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);

    hWndC = GetDlgItem(hDlg, CB_SCHEMES);
    /* first confirm that this scheme is really to be deleted.
    */
    i = ComboBox_GetCurSel(hWndC);
    if (i == CB_ERR)
        return FALSE;

    LoadString(ghInstance, IDS_CONFIRMREMOVE, szMsg, MAXSTR);
    ComboBox_GetLBText(hWndC, i, szScheme);
    wsprintf(szBuf, szMsg, (LPTSTR)szScheme);

    if (MessageBox(hDlg, szBuf, gszRemoveScheme,
                    MB_ICONEXCLAMATION | MB_TASKMODAL | MB_YESNO) == IDYES)
    {
        static SZCODE  aszControlIniSchemeFormat[] = TEXT("SoundScheme.%s");
        static SZCODE  aszControlIni[] = TEXT("control.ini");
        static SZCODE  aszSoundSchemes[] = TEXT("SoundSchemes");
        TCHAR  szControlIniScheme[MAXSTR];

        /* Remove from the list of schemes, and select none */

        EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_SAVE_SCHEME), FALSE);

        ClearModules(hDlg, hwndTree, TRUE);
        RegDeleteScheme(hWndC, i);
        wsprintf(szControlIniScheme, aszControlIniSchemeFormat, szScheme);
        WritePrivateProfileString(szControlIniScheme, NULL, NULL, aszControlIni);
        WritePrivateProfileString(aszSoundSchemes, szScheme, NULL, aszControlIni);
        return TRUE;
    }
    return FALSE;
}

/*
 ***************************************************************
 *  RegSetDefault
 *
 *  Description: Sets the given scheme as the default scheme in the reg
 *               database
 *
 *  Arguments:
 *      LPTSTR    lpKey - name of default scheme
 *
 *  Returns:    BOOL
 *      TRUE if value set successful, else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL RegSetDefault(LPTSTR lpszKey)
{
    if (RegSetValue(HKEY_CURRENT_USER, aszDefaultScheme, REG_SZ, lpszKey,
                                                0) != ERROR_SUCCESS)
    {
        DPF("Failed to set Value %s,\n", lpszKey);
        return FALSE;
    }
    return TRUE;
}

/*
 ***************************************************************
 *  RegDeleteScheme
 *
 *  Description: Deletes the given scheme from the reg database.
 *
 *  Arguments:
 *        HWND    hDlg    - Dialog window handle
 *        int        iIndex   - Index in Combobox
 *
 *  Returns:    BOOL
 *      TRUE if deletion is successful, else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL RegDeleteScheme(HWND hWndC, int iIndex)
{
    LPTSTR    pszKey;
    TCHAR    szKey[MAXSTR];
    TCHAR    szBuf[MAXSTR];
    TCHAR    szEvent[MAXSTR];
    TCHAR    szApp[MAXSTR];
    HKEY    hkApp;
    HKEY    hkAppList;
    LONG    cbSize;
    int        iEvent;
    int        iApp;

    if (hWndC)
    {
        pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, iIndex);
        lstrcpy(szKey, pszKey);
        if (ComboBox_DeleteString(hWndC, iIndex) == CB_ERR)
        {
            DPF("Couldn't delete string %s,\n", (LPTSTR)szKey);
            return FALSE;
        }
        //ComboBox_SetCurSel(hWndC, 0);

        AppendRegKeys (szBuf, aszNames, szKey);
        if (RegDeleteKey(HKEY_CURRENT_USER, szBuf) != ERROR_SUCCESS)
        {
            DPF("Failed to delete %s key\n", (LPTSTR)szBuf);
            //return FALSE;
        }

        cbSize = sizeof(szBuf);
        if ((RegQueryValue(HKEY_CURRENT_USER, aszDefaultScheme, szBuf, &cbSize)
                                    != ERROR_SUCCESS) || (cbSize < 2))
        {
            DPF("Failed to get value of default scheme\n");
            RegSetDefault(gszNullScheme);
        }
        else
            if (!lstrcmpi(szBuf, szKey))
            {
                RegSetDefault(gszNullScheme);
                RegDeleteScheme(NULL, 0);
            }
    }
    else
    {
        lstrcpy(szKey, (LPTSTR)aszCurrent);
    }
    if (RegOpenKey(HKEY_CURRENT_USER, aszApps, &hkAppList) != ERROR_SUCCESS)
    {
        DPF("Failed to open that %s key\n", (LPTSTR)aszApps);
        return FALSE;
    }
    for (iApp = 0; RegEnumKey(hkAppList, iApp, szApp, sizeof(szApp)/sizeof(TCHAR))
                                                == ERROR_SUCCESS; iApp++)
    {
        if (RegOpenKey(hkAppList, szApp, &hkApp) != ERROR_SUCCESS)
        {
            DPF("Failed to open the %s key\n", (LPTSTR)szApp);
            continue;
        }
        for (iEvent = 0; RegEnumKey(hkApp, iEvent, szEvent, sizeof(szEvent)/sizeof(TCHAR))
                                                == ERROR_SUCCESS; iEvent++)
        {
            AppendRegKeys (szBuf, szEvent, szKey);
            if (RegDeleteKey(hkApp, szBuf) != ERROR_SUCCESS)
                DPF("No entry for scheme %s under event %s\n", (LPTSTR)szKey,
                                                            (LPTSTR)szEvent);
        }
        RegCloseKey(hkApp);
    }
    RegCloseKey(hkAppList);

    return TRUE;
}

/*
 ***************************************************************
 * LoadEvents
 *
 * Description:
 *      Adds all the events to the CB_EVENTS Combobox, corresponding to
 *        the selected module.
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *        int        iIndex    - The index of the selected module in the Combobox.
 *
 * Returns:    BOOL
 *      TRUE if all the events for the selected module were read from the reg
 *        database, else FALSE
 ***************************************************************
 */
BOOL PASCAL LoadEvents(HWND hwndTree, HTREEITEM htiParent, PMODULE npModule)
{
    PEVENT  npPtr;
    HTREEITEM hti;
    TV_INSERTSTRUCT ti;

    if (npModule == NULL)
    {
        DPF("Couldn't find module\n");
        return FALSE;
    }
    npPtr = npModule->npList;

    for (; npPtr != NULL; npPtr = npPtr->npNextEvent)
    {
        if (!gszCmdLineEvent[0])
        {
            npPtr->iNode = 2;
            ti.hParent = htiParent;
            ti.hInsertAfter = TVI_SORT;
            ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            if (npPtr->fHasSound)
                ti.item.iImage = ti.item.iSelectedImage  = 1;
            else
                ti.item.iImage = ti.item.iSelectedImage  = 2;
            ti.item.pszText = npPtr->pszEventLabel;
            ti.item.lParam = (LPARAM)npPtr;
            hti = TreeView_InsertItem(hwndTree, &ti);

            if (!hti)
            {
                DPF("Couldn't add event Dataitem\n");
                return FALSE;
            }
        }
        else
        {
            // If a command line event was specified, only show this event.
            if (!lstrcmpi(npPtr->pszEventLabel, gszCmdLineEvent))
            {
                npPtr->iNode = 2;
                ti.hParent = htiParent;
                ti.hInsertAfter = TVI_SORT;
                ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                if (npPtr->fHasSound)
                    ti.item.iImage = ti.item.iSelectedImage  = 1;
                else
                    ti.item.iImage = ti.item.iSelectedImage  = 2;
                ti.item.pszText = npPtr->pszEventLabel;
                ti.item.lParam = (LPARAM)npPtr;
                hti = TreeView_InsertItem(hwndTree, &ti);

                if (!hti)
                {
                    DPF("Couldn't add event Dataitem\n");
                    return FALSE;
                }
                break;
            }
        }
    }
    return TRUE;
}

/*
 ***************************************************************
 *  LoadModules
 *
 *  Description: Adds all the strings and event data items to the
 *              list box for the given scheme
 *
 *  Arguments:
 *      HWND    hDlg   -    window handle of dialog window
 *      LPTSTR    lpszScheme  -   The current scheme
 *
 *  Returns:    BOOL
 *      TRUE if the modules for the scheme were read from reg db else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL LoadModules(HWND hDlg, LPTSTR lpszScheme)
{
    TCHAR     szLabel[MAXSTR];
    TCHAR     szApp[MAXSTR];
    TCHAR     szBuf[MAXSTR];
    HWND      hwndTree;
    HKEY      hKeyDisplayName;
    HKEY      hkAppList;
    int       iApp;
    DWORD     cbSize;
    HTREEITEM hti;
    HWND      hWndC =   GetDlgItem(hDlg, CB_SCHEMES);

    hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);

    ClearModules(hDlg, hwndTree, FALSE);

    if (RegOpenKey(HKEY_CURRENT_USER, aszApps, &hkAppList) != ERROR_SUCCESS)
    {
        DPF("Failed to open %s key\n", (LPTSTR)aszApps);
        return FALSE;
    }

    SendMessage(hwndTree, WM_SETREDRAW, FALSE, 0L);

    for (iApp = 0; RegEnumKey(hkAppList, iApp, szApp, sizeof(szApp)/sizeof(TCHAR))
                                                == ERROR_SUCCESS; iApp++)
    {

        AppendRegKeys (szBuf, aszApps, szApp);
        if (RegOpenKey (HKEY_CURRENT_USER, szBuf, &hKeyDisplayName) != ERROR_SUCCESS)
        {
            DPF("Failed to open key %s for event %s\n", (LPTSTR)szBuf, (LPTSTR)szApp);
            // If Key is not found, Display event name
            lstrcpy((LPTSTR)szLabel, szApp);
        }
        else
        {
            cbSize = sizeof(szLabel)/sizeof(TCHAR);
            if (ERROR_SUCCESS != SHLoadRegUIString(hKeyDisplayName, aszDisplayLabels, szLabel, cbSize))
            {
                // Load Default String if Localized String is not found
                if (ERROR_SUCCESS != SHLoadRegUIString(hKeyDisplayName, TEXT(""), szLabel, cbSize))
                {
                    // If Default String is not found, load Event name
                    DPF("Failed to get Display value for %s key\n", (LPTSTR)szApp);
                    lstrcpy((LPTSTR)szLabel, szApp);
                }
            }
            RegCloseKey (hKeyDisplayName);
        }

        if(!lstrcmpi((LPTSTR)szLabel, (LPTSTR)aszMMTask))
            continue;

        if (!NewModule(hwndTree, lpszScheme, szLabel, szApp, iApp))
        {
            DPF("failed in new module for %s module\n", (LPTSTR)szApp);
            RegCloseKey(hkAppList);
            return FALSE;
        }
    }
    hti = NULL;

    for (hti = TreeView_GetRoot(hwndTree); hti; hti = TreeView_GetNextSibling(hwndTree, hti))
        TreeView_Expand(hwndTree, hti, TVE_EXPAND);

    SendMessage(hwndTree, WM_VSCROLL, (WPARAM)SB_TOP, 0L);
    SendMessage(hwndTree, WM_SETREDRAW, TRUE, 0L);

    // Select the event if one was passed on the command line.
    if (gszCmdLineEvent[0])
    {
        if ((hti = TreeView_GetRoot(hwndTree)) != NULL) {
            if ((hti = TreeView_GetChild(hwndTree, hti)) != NULL) {
                TreeView_SelectItem(hwndTree, hti);
            }
        }
    }

    RegCloseKey(hkAppList);
    if (iApp == 0)
        return FALSE;

    return TRUE;
}

/***************************************************************
 * NewModule
 *
 * Description:
 *      Adds a data item associated with the module in the CB_MODULE
 *      Combobox control.
 *
 * Parameters:
 *      HWND    hDlg - Dialog window handle.
 *      LPTSTR    lpszScheme - the handle to the key of the current scheme
 *      LPTSTR    lpszLabel - the string to be added to the Combobox
 *      LPTSTR    lpszKey - a string to be added as a data item
 *      int        iVal  - Combobox index where the data item should go

 *
 * returns: BOOL
 *        TRUE if data item is successfully added
 *
 ***************************************************************
 */
BOOL PASCAL NewModule(HWND hwndTree, LPTSTR  lpszScheme, LPTSTR  lpszLabel,
                                                    LPTSTR lpszKey, int iVal)
{
    //int      iIndex;
    int      iEvent;
    LONG     cbSize;
    HKEY     hkApp;
    PMODULE npModule;
    PEVENT  npPtr = NULL;
    PEVENT  npNextPtr = NULL;
    TCHAR     szEvent[MAXSTR];
    TCHAR     szBuf[MAXSTR];
    TCHAR     szTemp[MAXSTR];
    HTREEITEM hti;
    TV_INSERTSTRUCT ti;
    DWORD dwType;
    HKEY hkEvent;
    HKEY hKeyDisplayName;

    npModule = (PMODULE)LocalAlloc(LPTR, sizeof(MODULE));
    if (npModule == NULL)
    {
        DPF("Failed Alloc\n");
        return FALSE;
    }
    npModule->pszKey = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpszKey)*sizeof(TCHAR)) + sizeof(TCHAR));
    npModule->pszLabel = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpszLabel)*sizeof(TCHAR)) + sizeof(TCHAR));

    if (npModule->pszKey == NULL)
    {
        DPF("Failed Alloc\n");
        return FALSE;
    }
    if (npModule->pszLabel == NULL)
    {
        DPF("Failed Alloc\n");
        return FALSE;
    }
    lstrcpy(npModule->pszKey, lpszKey);
    lstrcpy(npModule->pszLabel, lpszLabel);

    AppendRegKeys (szBuf, aszApps, lpszKey);
    if (RegOpenKey(HKEY_CURRENT_USER, szBuf, &hkApp) != ERROR_SUCCESS)
    {
        DPF("Failed to open %s key\n", (LPTSTR)szBuf);
        return FALSE;
    }

    for (iEvent = 0; RegEnumKey(hkApp, iEvent, szEvent, sizeof(szEvent)/sizeof(TCHAR))
                                                == ERROR_SUCCESS; iEvent++)
    {
        npPtr = (PEVENT)LocalAlloc(LPTR, sizeof(EVENT));
        if (npPtr == NULL)
        {
            DPF("Failed Alloc\n");
            RegCloseKey(hkApp);
            return FALSE;
        }
        npPtr->npNextEvent = NULL;
        npPtr->pszEvent = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szEvent)*sizeof(TCHAR)) + sizeof(TCHAR));
        if (npPtr->pszEvent == NULL)
        {
            DPF("Failed Alloc\n");
            RegCloseKey(hkApp);
            return FALSE;
        }
        lstrcpy(npPtr->pszEvent, szEvent);

        AppendRegKeys (szBuf, aszLabels, szEvent);
        if (RegOpenKey (HKEY_CURRENT_USER, szBuf, &hKeyDisplayName) != ERROR_SUCCESS)
        {
            DPF("Failed to open key %s for event %s\n", (LPTSTR)szBuf, (LPTSTR)szEvent);
            // If Key is not found, Display event name
            lstrcpy(szTemp, szEvent);
        }
        else
        {
            cbSize = sizeof(szTemp)/sizeof(TCHAR);
            if (ERROR_SUCCESS != SHLoadRegUIString(hKeyDisplayName, aszDisplayLabels, szTemp, cbSize))
            {
                // Load Default String if Localized String is not found
                if (ERROR_SUCCESS != SHLoadRegUIString(hKeyDisplayName, TEXT(""), szTemp, cbSize))
                {
                    // If Default String is not found, load Event name
                    DPF("Failed to get Display value for %s key\n", (LPTSTR)szEvent);
                    lstrcpy(szTemp, szEvent);
                }
            }
            RegCloseKey (hKeyDisplayName);
        }
 
        npPtr->pszEventLabel = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szTemp)*sizeof(TCHAR)) + sizeof(TCHAR));
        if (npPtr->pszEventLabel == NULL)
        {
            DPF("Failed Alloc\n");
            RegCloseKey(hkApp);
            return FALSE;
        }
        lstrcpy(npPtr->pszEventLabel, szTemp);

        // Query name of file; key is szEvent

        AppendRegKeys (szBuf, szEvent, lpszScheme);

        cbSize = sizeof(szTemp);
        if (ExRegQueryValue(hkApp, szBuf, (LPBYTE)szTemp, &cbSize) != ERROR_SUCCESS)
        {
            TCHAR szCurrentScheme[MAX_PATH];

            AppendRegKeys (szCurrentScheme, szEvent, aszCurrent);
            if (lstrcmpi(gszNullScheme, lpszScheme) && !ExRegQueryValue(hkApp, szCurrentScheme, (LPBYTE)szTemp, &cbSize))
            {
                HKEY hkNew;

                if (!RegCreateKey(hkApp, szBuf, &hkNew))
                {
                    if (!RegSetValue(hkNew, NULL, REG_SZ, szTemp, lstrlen(szTemp)+sizeof(TCHAR)) && cbSize >= 5)
                        npPtr->fHasSound = TRUE;
                    else
                        szTemp[0] = TEXT('\0');
                    RegCloseKey(hkNew);
                }
            }
            else
                szTemp[0] = TEXT('\0');
        }
        else if(cbSize < 5)
            szTemp[0] = TEXT('\0');
        else
            npPtr->fHasSound = TRUE;
        npPtr->pszPath = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szTemp)*sizeof(TCHAR)) + sizeof(TCHAR));
        if (npPtr->pszPath == NULL)
        {
            DPF("Failed Alloc\n");
            RegCloseKey(hkApp);
            return FALSE;
        }
        lstrcpy(npPtr->pszPath, szTemp);

        npPtr->npNextEvent = NULL;
        if (!npModule->npList)
        {
            npModule->npList = npPtr;
            npNextPtr = npPtr;
        }
        else
        {
            npNextPtr->npNextEvent = npPtr;
            npNextPtr = npNextPtr->npNextEvent;
        }
    }

    RegCloseKey(hkApp);
    npModule->iNode = 1;
    ti.hParent = TVI_ROOT;
    if (!gszCmdLineApp[0])
    {
        if (!lstrcmpi((LPTSTR)npModule->pszLabel, (LPTSTR)gszDefaultApp))
            ti.hInsertAfter = TVI_FIRST;
        else
            ti.hInsertAfter = TVI_LAST;
        ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        ti.item.iImage = ti.item.iSelectedImage = 0;
        ti.item.pszText = npModule->pszLabel;
        ti.item.lParam = (LPARAM)npModule;
        hti = TreeView_InsertItem(hwndTree, &ti);

        if (!hti)
        {
            DPF("Couldn't add module dataitem\n");
            return FALSE;
        }
        LoadEvents(hwndTree, hti, npModule);
    }
    else
    {
        // If a command line app was specified, only show it's events.
        if (!lstrcmpi((LPTSTR)npModule->pszLabel, (LPTSTR)gszCmdLineApp))
        {
            ti.hInsertAfter = TVI_LAST;
            ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            ti.item.iImage = ti.item.iSelectedImage = 0;
            ti.item.pszText = npModule->pszLabel;
            ti.item.lParam = (LPARAM)npModule;
            hti = TreeView_InsertItem(hwndTree, &ti);

            if (!hti)
            {
                DPF("Couldn't add module dataitem\n");
                return FALSE;
            }
            LoadEvents(hwndTree, hti, npModule);
        }
    }

    return TRUE;
}

/*
 ***************************************************************
 * ClearModules
 *
 * Description:
 *      Frees the storage used for mappings, and removes the
 *      entries in the list box
 *
 * Parameters:
 *      HWND hDlg - Dialog window handle.
 *        BOOL fDisable - If true disable  save, remove and browse controls
 *
 * returns: BOOL
 *
 ***************************************************************
 */
BOOL PASCAL ClearModules(HWND hDlg, HWND hwndTree, BOOL fDisable)
{
    PMODULE npModule;
    PEVENT  npPtr;
    PEVENT  pEvent;
    HTREEITEM hti;
    TV_ITEM    tvi;


    hti = NULL;
    for (hti = TreeView_GetRoot(hwndTree); hti; hti = TreeView_GetNextSibling(hwndTree, hti))
    {
        tvi.mask = TVIF_PARAM;
        tvi.hItem = hti;
        TreeView_GetItem(hwndTree, &tvi);

        npModule = (PMODULE)tvi.lParam;
        if (npModule)
        {
            for (npPtr = npModule->npList; npPtr != NULL;)
            {
                pEvent = npPtr;
                npPtr = npPtr->npNextEvent;
                if (pEvent)
                {
                    LocalFree((HLOCAL)pEvent->pszEvent);
                    LocalFree((HLOCAL)pEvent->pszEventLabel);
                    if (pEvent->pszPath)
                        LocalFree((HLOCAL)pEvent->pszPath);
                    LocalFree((HLOCAL)pEvent);
                }
            }
            LocalFree((HLOCAL)npModule->pszKey);
            LocalFree((HLOCAL)npModule->pszLabel);
            LocalFree((HLOCAL)npModule);
        }
    }
    gfDeletingTree = TRUE;
    SendMessage(hwndTree, WM_SETREDRAW, FALSE, 0L);
    TreeView_DeleteAllItems(hwndTree);
    SendMessage(hwndTree, WM_SETREDRAW, TRUE, 0L);
    gfDeletingTree = FALSE;

    //if (hti)
    //    LocalFree((HLOCAL)szScheme);
    return TRUE;
}

/*
 ***************************************************************
 * AddScheme
 *
 * Description:
 *    Adds a scheme to the CB_SCHEME combobox
 *
 * Parameters:
 *      HWND hDlg - Dialog window handle.
 *        LPTSTR    szLabel        -- Printable name of scheme
 *        LPTSTR    szScheme    -- registry key for scheme
 *        BOOL    fInsert        -- Insert or add
 *        int        iInsert        -- position to insert if finsert is set
 *
 * returns: BOOL
 *
 ***************************************************************
 */
BOOL PASCAL AddScheme(HWND hWndC, LPTSTR szLabel, LPTSTR szScheme,
                                                    BOOL fInsert, int iInsert)
{
    int      iIndex        = 0;
    LPTSTR     pszKey;

    pszKey = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szScheme)*sizeof(TCHAR)) + sizeof(TCHAR));
    if (pszKey == NULL)
    {
        DPF("Failed Alloc\n");
        return FALSE;
    }
    lstrcpy(pszKey, szScheme);

    if (fInsert)
    {
        if (ComboBox_InsertString(hWndC, iInsert, szLabel) != CB_ERR)
        {
            if (ComboBox_SetItemData(hWndC, iInsert,(LPVOID)pszKey) == CB_ERR)
            {
                DPF("couldn't set itemdata %s\n", (LPTSTR)pszKey);
                return FALSE;
            }
        }
        else
        {
            DPF("couldn't insert %s\n", (LPTSTR)szLabel);
            return FALSE;
        }
    }
    else
    {
        if ((iIndex = ComboBox_AddString(hWndC, szLabel)) != CB_ERR)
        {
            if (ComboBox_SetItemData(hWndC, iIndex, (LPVOID)pszKey) == CB_ERR)
            {
                DPF("couldn't set itemdata %s\n", (LPTSTR)pszKey);
                return FALSE;
            }
        }
        else
        {
            DPF("couldn't add %s\n", (LPTSTR)szLabel);
            return FALSE;
        }
    }
    return TRUE;
}


/*
 ***************************************************************
 * GetMediaPath
 *
 * Description:
 *      Fills in a buffer with the current setting for MediaPath,
 *      with a trailing backslash (usually "c:\windows\media\" etc).
 *      If there's no setting (very unlikely), the return buffer
 *      will be given "".
 *
 ***************************************************************
 */
void PASCAL GetMediaPath (LPTSTR pszMediaPath, size_t cchMax)
{
    static TCHAR szMediaPath[ MAX_PATH ] = TEXT("");

    if (szMediaPath[0] == TEXT('\0'))
    {
        HKEY hk;

        if (RegOpenKey (HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, &hk) == 0)
        {
            DWORD dwType;
            DWORD cb = sizeof(szMediaPath);

            if (RegQueryValueEx (hk, REGSTR_VAL_MEDIA, NULL,
                                 &dwType, (LPBYTE)szMediaPath, &cb) != 0)
            {
                szMediaPath[0] = TEXT('\0');
            }

            if ( (szMediaPath[0] != TEXT('\0')) &&
                 (szMediaPath[ lstrlen(szMediaPath)-1 ] != TEXT('\\')) )
            {
                lstrcat (szMediaPath, TEXT("\\"));
            }

            RegCloseKey (hk);
        }
    } 

    lstrcpyn (pszMediaPath, szMediaPath, cchMax-1);
}


/*
 ***************************************************************
 * RemoveMediaPath
 *
 * Description:
 *      Checks to see if a given filename resides within MediaPath;
 *      if so, yanks its parent path ("c:\win\media\ding.wav" becomes
 *      just "ding.wav", etc)
 *
 ***************************************************************
 */
void PASCAL RemoveMediaPath (LPTSTR pszTarget, LPTSTR pszSource)
{
    TCHAR szMediaPath[ MAX_PATH ] = TEXT("");

    GetMediaPath (szMediaPath, MAX_PATH);

    if (szMediaPath[0] == TEXT('\0'))
    {
        lstrcpy (pszTarget, pszSource);
    }
    else
    {
        size_t cch = lstrlen (szMediaPath);

        if (!lstrnicmp (pszSource, szMediaPath, cch))
        {
            lstrcpy (pszTarget, &pszSource[ cch ]);
        }
        else
        {
            lstrcpy (pszTarget, pszSource);
        }
    }
}


/*
 ***************************************************************
 * AddMediaPath
 *
 * Description:
 *      If the given filename doesn't have a path, prepends the
 *      current setting of MediaPath to it ("ding.wav"->"c:\win\media\ding.wav")
 *
 ***************************************************************
 */
void PASCAL AddMediaPath (LPTSTR pszTarget, LPTSTR pszSource)
{
    if (lstrchr (pszSource, TEXT('\\')) != NULL)
    {
        lstrcpy (pszTarget, pszSource);
    }
    else
    {
        TCHAR szMediaPath[ MAX_PATH ] = TEXT("");

        GetMediaPath (szMediaPath, MAX_PATH);

        if (szMediaPath[0] == TEXT('\0'))
        {
            lstrcpy (pszTarget, pszSource);
        }
        else
        {
            lstrcpy (pszTarget, szMediaPath);
            lstrcat (pszTarget, pszSource);
        }
    }
}


/*
 ***************************************************************
 * ExRegQueryValue
 *
 * Description:
 *      Just a wrapper for RegQueryValue(); this one doesn't choke
 *      on REG_EXPAND_SZ's.
 *
 ***************************************************************
 */
int ExRegQueryValue (HKEY hkParent, LPTSTR szSubKey, LPBYTE pszBuffer, DWORD *pdwSize)
{
   HKEY hkSubKey;
   int rc;

   if ((rc = RegOpenKey (hkParent, szSubKey, &hkSubKey)) == ERROR_SUCCESS)
   {
       DWORD dwType;

       rc = RegQueryValueEx (hkSubKey, NULL, NULL, &dwType, pszBuffer, pdwSize);

       RegCloseKey (hkSubKey);
   }

   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\remove.c ===
/*  REMOVE.C
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**  Multimedia Control Panel Applet for removing
**  device drivers.  See the ispec doc DRIVERS.DOC for more information.
**
**  History:
**
**      Thu Oct 17 1991 -by- Sanjaya
**      Created. Originally part of drivers.c
*/

#include <windows.h>
#include <mmsystem.h>
#include <winsvc.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <cpl.h>
#include <cphelp.h>
#include <regstr.h>

#include "drivers.h"
#include "sulib.h"
#include "mmcpl.h"

BOOL     SetValidAlias      (LPTSTR, LPTSTR);

static CONST TCHAR gszRunDLL32Path[]    = TEXT("\"%s\\RUNDLL32.EXE\" \"%s\\MMSYS.CPL\",mmWOW64MediaClassInstallerA \"%s\"%d");
static CONST TCHAR gszAliasValue[]      = TEXT("Alias");
static CONST TCHAR gszAliasWOW64Value[] = TEXT("AliasWOW64");
static CONST TCHAR gszWaveWOW64Value[]  = TEXT("WOW64");

#ifdef DOBOOT
BOOL     FindBootDriver     (TCHAR *);
PSTR     strstri            (LPTSTR, LPTSTR);
#endif // DOBOOT

/*
 *  RemoveService(szFile)
 *
 *  Remove the service corresponding to the file szFile
 *
 *  returns TRUE if successful, FALSE otherwise
 */

BOOL RemoveService(LPTSTR szFile)
{
    SC_HANDLE SCManagerHandle;
    SC_HANDLE ServiceHandle;
    TCHAR ServiceName[MAX_PATH];
    BOOL Status = FALSE;

    /*
     *  Extract the service name from the file name
     */

    {
        TCHAR drive[MAX_PATH], directory[MAX_PATH], ext[MAX_PATH];
        lsplitpath(szFile, drive, directory, ServiceName, ext);
    }

    /*
     *  First try and obtain a handle to the service controller
     */

    SCManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (SCManagerHandle == NULL)
    {

        TCHAR szMesg[MAXSTR];
        TCHAR szMesg2[MAXSTR];

        LoadString(myInstance, IDS_INSUFFICIENT_PRIVILEGE, szMesg, sizeof(szMesg)/sizeof(TCHAR));
        wsprintf(szMesg2, szMesg, szFile);
        MessageBox(hMesgBoxParent, szMesg2, szRemove, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
        return FALSE;
    }


    ServiceHandle = OpenService(SCManagerHandle,
                                ServiceName,
                                SERVICE_ALL_ACCESS);
    if (ServiceHandle != NULL)
    {
        SERVICE_STATUS ServiceStatus;
        SC_LOCK ServicesDatabaseLock;

        /*
         *  Stop the service if possible.
         */

        ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);

        /*
         *  Delete the service.
         *  We aren't detecting if we can just carry on.
         */

        /*
         *  Lock the service controller database to avoid deadlocks
         *  we have to loop because we can't wait
         */


        for (ServicesDatabaseLock = NULL;
            (ServicesDatabaseLock =
             LockServiceDatabase(SCManagerHandle))
            == NULL;
            Sleep(100))
        {
        }

        Status = DeleteService(ServiceHandle);

        UnlockServiceDatabase(ServicesDatabaseLock);

        CloseServiceHandle(ServiceHandle);
    }
    else
    {

        /*
         *  It's possible there was no services entry so the driver
         *  wasn't really installed after all.
         */

        LONG Error = GetLastError();

        if (Error == ERROR_FILE_NOT_FOUND ||
            Error == ERROR_PATH_NOT_FOUND ||
            Error == ERROR_SERVICE_DOES_NOT_EXIST)
        {
            Status = TRUE;
        }
    }

    CloseServiceHandle(SCManagerHandle);

    return Status;
}

/*
**  PostRemove()
**
**  Mark an installed driver for removal later AND remove the driver's entry
**  in SYSTEM.INI to avoid conflicts when we add or remove later.
*/
LONG_PTR PostRemove(PIDRIVER pIDriver, BOOL bLookAtRelated)
{

    TCHAR *keystr;
    TCHAR allkeystr[MAXSTR];
    TCHAR szfile[MAX_PATH];
    HANDLE hDriver;
    LONG_PTR Status = DRVCNF_CANCEL;
    LPTSTR pstr;


    GetPrivateProfileString(pIDriver->szSection,
                            pIDriver->szAlias,
                            pIDriver->szFile,
                            pIDriver->szFile,
                            MAX_PATH,
                            szSysIni);


    /*
     *  Remove parameters from file name
     */


    if (pIDriver->szFile)
    {
        for ( pstr=pIDriver->szFile; *pstr && (*pstr!=COMMA) &&
            (*pstr!=SPACE); pstr++ )
            ;
        *pstr = TEXT('\0');
    }

    if (bLookAtRelated && (!bRelated || pIDriver->bRelated))
    {
        wcsncpy(szRestartDrv,  pIDriver->szDesc, ARRAYSIZE(szRestartDrv));
        szRestartDrv[ARRAYSIZE(szRestartDrv)-1] = TEXT('\0'); // Make sure there is a NULL terminator
    }

    /*
     *  If it's a kernel driver remove it from the config registry
     *  and services controller
     */

    if (pIDriver->KernelDriver)
    {

        Status = RemoveService(pIDriver->szFile) ? DRVCNF_RESTART : DRVCNF_CANCEL;

        if (Status == DRVCNF_CANCEL)
        {
            return DRVCNF_CANCEL;
        }

    }
    else
    {

        hDriver = OpenDriver(pIDriver->wszAlias, pIDriver->wszSection, 0L);

        if (hDriver)
        {

            /*
             *  Removal can fail so don't mark as deleted in this case
             */

            Status = SendDriverMessage(hDriver, DRV_REMOVE, 0L, 0L);
            CloseDriver(hDriver, 0L, 0L);

            if (Status == DRVCNF_CANCEL)
            {
                return DRVCNF_CANCEL;
            }
        }
    }

    // Remove the driver from the treeview,
    //  but don't free its structure
    //
    RemoveIDriver (hAdvDlgTree, pIDriver, FALSE);

    if (bLookAtRelated)
    {
        TCHAR allkeystr[MAXSTR];

        if (GetPrivateProfileString(szRelatedDesc, pIDriver->szAlias,
                                    allkeystr, allkeystr, sizeof(allkeystr) / sizeof(TCHAR), szControlIni))
        {
            int  i;
            TCHAR szTemp[MAXSTR];

            for (i = 1; (infParseField(allkeystr, i, szTemp, SIZEOF(szTemp)) == ERROR_SUCCESS); i++)
            {
                PIDRIVER pid;

                if ((pid = FindIDriverByName (szTemp)) != NULL)
                {
                    if (PostRemove (pid, FALSE) == DRVCNF_RESTART)
                    {
                        Status = DRVCNF_RESTART;
                    }
                }
            }
        }
    }

    // Remove the driver entry from SYSTEM.INI so you don't
    // conflict with other drivers.

    GetPrivateProfileString(pIDriver->szSection, NULL, NULL,
                            allkeystr, sizeof(allkeystr) / sizeof(TCHAR), szSysIni);
    keystr = allkeystr;
    while (wcslen(keystr) > 0)
    {
        GetPrivateProfileString(pIDriver->szSection, keystr, NULL, szfile, sizeof(szfile) / sizeof(TCHAR), szSysIni);
        if (!FileNameCmp(pIDriver->szFile, szfile))
            RemoveDriverEntry(keystr, pIDriver->szFile, pIDriver->szSection, bLookAtRelated);
        keystr = &keystr[wcslen(keystr) + 1];
    }
    return Status;
}



void RemoveDriverEntry (LPTSTR szKey, LPTSTR szFile, LPTSTR szSection, BOOL bLookAtRelated)
{

    /*
     *  Remove entry for loading driver
     */

    WritePrivateProfileString(szSection, szKey, NULL, szSysIni);

    /*
     *  Delete entry for parameters for this driver
     */

    WriteProfileString(szFile, szKey, NULL);

    /*
     *  Remove entry which says this is a user driver (as opposed to
     *  a pre-installed one).
     */

    WritePrivateProfileString(szUserDrivers, szKey, NULL, szControlIni);

    /*
     *  Remove description
     */

    WritePrivateProfileString(szDriversDesc, szFile, NULL, szControlIni);

    /*
     *  Remove links to related drivers
     */

    WritePrivateProfileString(szRelatedDesc, szKey, NULL, szControlIni);

#ifdef DOBOOT
    FindBootDriver(szKey);
#endif // DOBOOT

    if (bLookAtRelated)
        SetValidAlias(szKey, szSection);
}


/*
 *  SetValidAlias()
 *
 * Check to see if the alias removed would create a hole in the device
 * numbering scheme. If so switch the last device number with the deleted one.
 */
BOOL SetValidAlias(LPTSTR pstrType, LPTSTR pstrSection)
{
    TCHAR *keystr;
    static TCHAR allkeystr[MAXSTR];
    static TCHAR szExKey[MAXSTR], szExFile[MAXSTR], szExDesc[MAXSTR];
    BOOL bfound = FALSE, bExchange = FALSE;
    int val, maxval = 0, typelen, len;

    /*
     *  Getting length of alias
     */

    len = typelen = wcslen(pstrType);

    // If the last TCHAR on the type is a number don't consider it

    if (pstrType[typelen - 1] > TEXT('0') && pstrType[typelen - 1] <= TEXT('9'))
        typelen--;

    // Get all the aliases in the drivers section

    GetPrivateProfileString(pstrSection, NULL, NULL, allkeystr,
                            sizeof(allkeystr) / sizeof(TCHAR), szSysIni);
    keystr = allkeystr;
    while (*keystr != TEXT('\0'))
    {
        // Compare the root of the aliases
        if (!_wcsnicmp(keystr, pstrType, typelen) && ((keystr[typelen] <= TEXT('9') && keystr[typelen] > TEXT('0')) || keystr[typelen] == TEXT('\0')))
        {

            //We found a common alias
            bfound = TRUE;
            val = _wtoi(&keystr[typelen]);
            if (val > maxval)
            {
                maxval = val;
                wcscpy(szExKey, keystr);
            }
        }
        //Pointer to next alias
        keystr = &keystr[wcslen(keystr) + 1];
    }
    //If we found one
    if (bfound)
    {
        if (len == typelen)
            bExchange = TRUE;
        else
            if (_wtoi(&pstrType[typelen]) < maxval)
            bExchange = TRUE;

        // We need to exchange it with the one we found
        if (bExchange)
        {
            //Exchanging the one in the drivers section in system.ini
            GetPrivateProfileString(pstrSection, szExKey, NULL, szExFile,
                                    sizeof(szExFile) / sizeof(TCHAR), szSysIni);
            WritePrivateProfileString(pstrSection, szExKey, NULL, szSysIni);
            WritePrivateProfileString(pstrSection, pstrType, szExFile, szSysIni);

#ifdef TRASHDRIVERDESC
            //Exchanging the one in the drivers description section of control.ini
            GetPrivateProfileString(szDriversDesc, szExKey, NULL, szExDesc, sizeof(szExFile) / sizeof(TCHAR), szControlIni);
            WritePrivateProfileString(szDriversDesc, szExKey, NULL, szControlIni);
            WritePrivateProfileString(szDriversDesc, pstrType, szExDesc, szControlIni);
#endif

            //If any related drivers were present under old alias switch them
            GetPrivateProfileString(szRelatedDesc, szExKey, NULL, szExDesc, sizeof(szExFile) / sizeof(TCHAR), szControlIni);

            if (wcslen(szExDesc))
            {
                WritePrivateProfileString(szRelatedDesc, szExKey, NULL, szControlIni);
                WritePrivateProfileString(szRelatedDesc, pstrType, szExDesc, szControlIni);
            }

            //If user installed driver under old alias switch them
            GetPrivateProfileString(szUserDrivers, szExKey, NULL, szExDesc, sizeof(szExFile) / sizeof(TCHAR), szControlIni);

            if (wcslen(szExDesc))
            {
                WritePrivateProfileString(szUserDrivers, szExKey, NULL, szControlIni);
                WritePrivateProfileString(szUserDrivers, pstrType, szExDesc, szControlIni);
            }

#ifdef DOBOOT
            if (FindBootDriver(szExKey))
            {
                static TCHAR szTemp[MAXSTR];

                GetPrivateProfileString(szBoot, szDrivers, szTemp, szTemp,
                                        sizeof(szTemp) / sizeof(TCHAR), szSysIni);
                strcat(szTemp, TEXT(" "));
                strcat(szTemp, pstrType);
                WritePrivateProfileString(szBoot, szDrivers, szTemp, szSysIni);
            }
#endif // DOBOOT

        }
    }
    return(bExchange);
}

int FileNameCmp(TCHAR far *pch1, TCHAR far *pch2)
{
    LPTSTR pchEOS;

    while (*pch1 == TEXT(' ')) pch1++; // eat spaces
    while (*pch2 == TEXT(' ')) pch2++; // eat spaces

    for (pchEOS = pch1; *pchEOS && *pchEOS != TEXT(' '); pchEOS++);

    return _wcsnicmp(pch1, pch2, (size_t)(pchEOS - pch1));
}

#ifdef DOBOOT

PSTR strstri(LPTSTR pszStr, LPTSTR pszKey)
{
    while (pszStr)
        if (!_strnicmp(pszStr, pszKey, lstrlen(pszKey)))
            return(pszStr);
        else
            pszStr++;
    return(NULL);
}

/*
 *   FindBootDriver()
 *  Checks to see if the driver alias is on the drivers line of the
 *  boot section. If so the alias is removed from the line.
 */

BOOL FindBootDriver(TCHAR *szKey)
{
    TCHAR *ptr;
    int wKeyLen = (int)wcslen(szKey);
    TCHAR *endkey;
    static TCHAR szDriverline[MAXSTR];

    GetPrivateProfileString(TEXT("boot"), TEXT("drivers"), szDriverline, szDriverline,
                            MAX_PATH, szSysIni);
    ptr = strstri(szDriverline, szKey);
    if (ptr)
    {

        if ((((ptr != szDriverline) && (*(ptr - 1) == TEXT(' ') )) ||
             (ptr == szDriverline)) &&
            (*(ptr + wKeyLen) == TEXT(' ') || *(ptr + wKeyLen) == NULL))
        {
            endkey = ptr + wKeyLen;
            while (*endkey)
                *ptr++ = *endkey++;
            *ptr = NULL;
            WritePrivateProfileString(TEXT("boot"), TEXT("drivers"), szDriverline,
                                      szSysIni);
            return(TRUE);
        }
    }
    return(FALSE);
}

#endif // DOBOOT

// Steal use of function in midi.c to delete a reg subtree.
LONG SHRegDeleteKey(HKEY hKey, LPCTSTR lpSubKey);

//****************************************************************************
// Function: mystrtok()
//
// Purpose: Returns a pointer to the next token in a string.
//
// Parameters:
//      SrcString   String containing token(s)
//      Seps        Set of delimiter characters
//      State       Pointer to a char* to hold state info
// Return Code:
//      Ptr to next token, or NULL if no tokens left
//
// Comments:
//      Fixes problem with standard strtok, which can't be called recursively.
//
//****************************************************************************
LPTSTR mystrtok(LPTSTR SrcString, LPCTSTR Seps, LPTSTR FAR *State)
{
    LPTSTR ThisString;
    LPTSTR NextString;

    // If Seps is NULL, use default separators
    if (!Seps)
    {
        Seps = TEXT(" ,\t");  // space, comma, tab chars
    }

    if (SrcString)
        ThisString = SrcString;
    else
        ThisString = *State;

    // Find beginning of the current string
    ThisString = ThisString + wcsspn(ThisString,Seps);
    if (ThisString[0]==TEXT('\0'))
        return NULL;

    // Find the end of the current string
    NextString = ThisString + wcscspn(ThisString,Seps);
    if (NextString[0]!=TEXT('\0'))
    {
        *NextString++=TEXT('\0');
    }

    *State = NextString;
    return ThisString;
}

BOOL RemoveDriver(IN HDEVINFO         DeviceInfoSet,
                  IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                 )
{
    BOOL bRet = FALSE;          // Return value

    TCHAR szDriverKey[MAX_PATH]; // Value of Driver's key in Enum branch
    TCHAR *pszDrvInst;           // Driver's instance, e.g. "0000", "0001", etc.

    HKEY hkDevReg  = NULL;      // Key to Driver portion of registry (e.g. classguid\0000)
    HKEY hkDrivers32 = NULL;    // Key to Drivers32 portion of registry
    HKEY hkDrivers = NULL;      // Key to classguid\0000\Drivers

    TCHAR szSubClasses[256];     // List of subclasses to process
    TCHAR *strtok_State;         // strtok state
    TCHAR *pszClass;             // Information about e.g. classguid\0000\Drivers\wave
    HKEY hkClass;

    DWORD idxR3DriverName;      // Information about e.g. classguid\0000\Drivers\wave\foo.drv
    HKEY hkR3DriverName;
    TCHAR szR3DriverName[64];

    TCHAR szAlias[64];           // Alias in Drivers32 (e.g. wave1)
    TCHAR szDriver[64];          // Name of driver

    DWORD cbLen;

    LPCTSTR szAliasStringToUse;  // Pointer to the Alias value name to use
    BOOL bIsWOW64Process = FALSE;// TRUE if we're running under WOW64

    //
    // If we're running in WOW64, we need to use a different Alias string so that
    // we don't overwrite the 64-bit alias string
    //
    if( IsWow64Process(GetCurrentProcess(), &bIsWOW64Process)
    &&  bIsWOW64Process )
    {
        szAliasStringToUse = gszAliasWOW64Value;
    }
    else
    {
        szAliasStringToUse = gszAliasValue;
    }

    // Get the Drivers key value under the device's Enum branch,
    // e.g. something like "{4D36E96C-E325-11CE-BFC1-08002BE10318}\0000"
    SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_DRIVER ,
                                     NULL,
                                     (LPBYTE)szDriverKey,
                                     MAX_PATH,
                                     NULL);

    // Get everything after the last \ character
    pszDrvInst = wcsrchr(szDriverKey,TEXT('\\'));
    if (!pszDrvInst)
    {
        goto RemoveDrivers32_exit;
    }
    pszDrvInst++;
    // Now pszDrvInst points to a string with the Driver Instance, e.g. "0000"

    // Open the Drivers32 section of the registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32"),
                   &hkDrivers32))
    {
        goto RemoveDrivers32_exit;
    }

    // Open the Driver reg key
    hkDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);
    if (hkDevReg == INVALID_HANDLE_VALUE)
    {
        goto RemoveDrivers32_exit;
    }

    // Enumerate through supporter classes in the Drivers subkey
    if (RegOpenKey(hkDevReg, TEXT("Drivers"), &hkDrivers))
    {
        goto RemoveDrivers32_exit;
    }

    // Read the SubClasses key to determine which subclasses to process
    cbLen=sizeof(szSubClasses);
    if (RegQueryValueEx(hkDrivers, TEXT("Subclasses"), NULL, NULL, (LPBYTE)szSubClasses, &cbLen))
    {
        goto RemoveDrivers32_exit;
    }

    // Enumerate all the subclasses
    for (
        pszClass = mystrtok(szSubClasses,NULL,&strtok_State);
        pszClass;
        pszClass = mystrtok(NULL,NULL,&strtok_State)
        )
    {
#ifdef _WIN64
        //
        // Check for magic WaveWOW64 value
        if( 0 == _wcsnicmp( pszClass, gszWaveWOW64Value, wcslen(gszWaveWOW64Value) ) )
        {
            // Thunk the installation to the 32-bit mmsys.cpl installer
            mmWOW64ThunkMediaClassInstaller(DIF_REMOVE, DeviceInfoSet, DeviceInfoData);

            continue;
        }
#endif //_WIN64

        // Open up each subclass
        if (RegOpenKey(hkDrivers, pszClass, &hkClass))
        {
            continue;
        }

        // Under each class is a set of driver name subkeys.
        // For each driver (e.g. foo1.drv, foo2.drv, etc.)
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {

            // Open the key to the driver name
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Get the value of Driver under the driver name key
            cbLen = sizeof(szDriver);
            if (!RegQueryValueEx(hkR3DriverName, TEXT("Driver"), NULL, NULL, (LPBYTE)szDriver, &cbLen))
            {
                // Send the driver a DRV_REMOVE message to the driver
                HANDLE hDriver;

                hDriver = OpenDriver(szDriver, NULL, 0L);

                if (hDriver)
                {
                    SendDriverMessage(hDriver, DRV_REMOVE, 0L, 0L);
                    CloseDriver(hDriver, 0L, 0L);
                }
            }

            // Get the value of Alias under the driver name key
            cbLen = sizeof(szAlias);
            if (!RegQueryValueEx(hkR3DriverName, szAliasStringToUse, NULL, NULL, (LPBYTE)szAlias, &cbLen))
            {
                // Delete the corresponding entry in Drivers32
                RegDeleteValue(hkDrivers32,szAlias);
            }

            // Close the Driver Name key
            RegCloseKey(hkR3DriverName);
        }
        // Close the class key
        RegCloseKey(hkClass);
    }

    bRet = TRUE;

    RemoveDrivers32_exit:

    if (hkDrivers32)    RegCloseKey(hkDrivers32);
    if (hkDevReg)       RegCloseKey(hkDevReg);
    if (hkDrivers)      RegCloseKey(hkDrivers);

    return bRet;
}

// The driver's private registry section is located in something like:
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96C-E325-11CE-BFC1-08002BE10318}\xxxx
// where xxxx is the device instance (e.g. 0000, 0001, etc.)
// These last four digits are used to index into the driver's MediaResources section.

// For example, suppose a device has a driver instance
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96C-E325-11CE-BFC1-08002BE10318}\0001
// and under that entry there is a Drivers\wave\foo.drv, meaning that the foo.drv driver supports a wave
// API.
// In this case, there would be an entry in
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\MediaResources\wave\foo.drv<0001>
//
// On removal, we need to delete that entry.
BOOL RemoveMediaResources(IN HDEVINFO         DeviceInfoSet,
                          IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                         )


{
    BOOL bRet = FALSE;          // Return value

    TCHAR szDriverKey[MAX_PATH]; // Value of Driver's key in Enum branch
    TCHAR *pszDrvInst;           // Driver's instance, e.g. "0000", "0001", etc.

    HKEY hkDevReg  = NULL;      // Key to Driver portion of registry (e.g. classguid\0000)
    HKEY hkDrivers = NULL;      // Key to classguid\0000\Drivers
    HKEY hkMR      = NULL;      // Handle to MediaResources section

    TCHAR szSubClasses[256];     // List of subclasses to process
    TCHAR *strtok_State;         // strtok state
    TCHAR *pszClass;             // Information about e.g. classguid\0000\Drivers\wave
    HKEY hkClass;

    DWORD idxR3DriverName;      // Information about e.g. classguid\0000\Drivers\wave\foo.drv
    HKEY hkR3DriverName;
    TCHAR szR3DriverName[64];

    TCHAR szDriver[64];          // Driver name (e.g. foo.drv)
    DWORD cbLen;                // Size of szDriver

    TCHAR szDevNode[MAX_PATH+1];         // Path to driver's reg entry
    TCHAR szSoftwareKey[MAX_PATH+1];     // Value of SOFTWAREKEY

    // Open Media Resources section of registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_MEDIARESOURCES, &hkMR))
    {
        goto RemoveMediaResources_exit;
    }

    // Get the Drivers key value under the device's Enum branch,
    // e.g. something like "{4D36E96C-E325-11CE-BFC1-08002BE10318}\0000"
    SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_DRIVER ,
                                     NULL,
                                     (LPBYTE)szDriverKey,
                                     MAX_PATH,
                                     NULL);

    // Get everything after the last \ character
    pszDrvInst = wcsrchr(szDriverKey,TEXT('\\'));
    if (!pszDrvInst)
    {
        goto RemoveMediaResources_exit;
    }
    pszDrvInst++;
    // Now pszDrvInst points to a string with the Driver Instance, e.g. "0000"

    // Get full path to driver key
    wsprintf(szDevNode,
             TEXT("%s\\%s"),
             REGSTR_PATH_CLASS_NT,
             (LPTSTR)szDriverKey);

    // Open the Driver reg key
    hkDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);
    if (hkDevReg == INVALID_HANDLE_VALUE)
    {
        goto RemoveMediaResources_exit;
    }

    // Enumerate through supporter classes in the Drivers subkey
    if (RegOpenKey(hkDevReg, TEXT("Drivers"), &hkDrivers))
    {
        goto RemoveMediaResources_exit;
    }

    // Read the SubClasses key to determine which subclasses to process
    cbLen=sizeof(szSubClasses);
    if (RegQueryValueEx(hkDrivers, TEXT("Subclasses"), NULL, NULL, (LPBYTE)szSubClasses, &cbLen))
    {
        goto RemoveMediaResources_exit;
    }

    // Enumerate all the subclasses
    for (
        pszClass = mystrtok(szSubClasses,NULL,&strtok_State);
        pszClass;
        pszClass = mystrtok(NULL,NULL,&strtok_State)
        )
    {
        if (RegOpenKey(hkDrivers, pszClass, &hkClass))
        {
            continue;
        }

        // Under each class is a set of driver name subkeys.
        // For each driver (e.g. foo1.drv, foo2.drv, etc.)
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {

            // Open the key to the driver name
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Get the value of Driver in under the driver name key
            cbLen = sizeof(szDriver);
            if (!RegQueryValueEx(hkR3DriverName, TEXT("Driver"), NULL, NULL, (LPBYTE)szDriver, &cbLen))
            {
                TCHAR szR3Path[256];

                // Create a path to the MediaResources entry to be deleted
                wsprintf(szR3Path,
                         TEXT("%s\\%s\\%s<%s>"),
                         REGSTR_PATH_MEDIARESOURCES,
                         (LPTSTR)pszClass,
                         (LPTSTR)szDriver,
                         (LPTSTR)pszDrvInst);
                // Delete the key
                SHRegDeleteKey(HKEY_LOCAL_MACHINE, szR3Path);
            }
            // Close the Driver Name key
            RegCloseKey(hkR3DriverName);
        }

        // Close the class key in the devnode
        RegCloseKey(hkClass);

        // Backup mechanism, in case we missed something.
        // This shouldn't be necessary, but Win98 does it.

        // Open the class key in MediaResources
        if (RegOpenKey(hkMR, pszClass, &hkClass))
        {
            continue;
        }
        // Count the number of subkeys under the class key
        // We're gonna do this backwards because we'll be deleting keys later
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {
            ;
        }

        // For each driver subkey, working backwards.
        // Subkeys are e.g. msacm.iac2, msacm.imaadpcm, etc.
        for (idxR3DriverName--;
            ((int)idxR3DriverName >= 0) &&
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName--)
        {
            // Open the driver key
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Query the value of "SOFTWAREKEY"
            szSoftwareKey[0]=TEXT('\0');      // Init to safe value in case call fails

            cbLen = sizeof(szSoftwareKey);
            RegQueryValueEx(hkR3DriverName, TEXT("SOFTWAREKEY"), NULL, NULL, (LPBYTE)szSoftwareKey, &cbLen);

            // Close now, since we might delete in next line
            RegCloseKey(hkR3DriverName);

            // If the value of "SOFTWAREKEY" matches the path to the devnode, delete the key
            if (!lstrcmpi(szSoftwareKey, szDevNode))
            {
                SHRegDeleteKey(hkClass, szR3DriverName);
            }
        }

        // Close the class key in MediaResources
        RegCloseKey(hkClass);
    }

    bRet = TRUE;

    RemoveMediaResources_exit:
    if (hkDevReg && (hkDevReg!=INVALID_HANDLE_VALUE))   
            RegCloseKey(hkDevReg);
    if (hkDrivers )  
            RegCloseKey(hkDrivers);
    if (hkMR)        
            RegCloseKey(hkMR);

    return bRet;
}

// Clear out entries in the Driver's branch of the registry, e.g. in {4D36E96C-E325-11CE-BFC1-08002BE10318}\0000
BOOL RemoveDriverInfo(IN HDEVINFO         DeviceInfoSet,
                      IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                     )
{
    HKEY hkDevReg;      // Key to Driver portion of registry (e.g. classguid\0000)

    // Remove entries in the driver's reg section
    hkDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);
    if (hkDevReg == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    // Delete any entries that might cause trouble
    RegDeleteValue(hkDevReg,REGSTR_VAL_DEVLOADER);
    RegDeleteValue(hkDevReg,REGSTR_VAL_DRIVER);
    RegDeleteValue(hkDevReg,REGSTR_VAL_ENUMPROPPAGES);
    RegDeleteValue(hkDevReg,TEXT("NTMPDriver"));
    RegDeleteValue(hkDevReg,TEXT("AssociatedFilters"));
    RegDeleteValue(hkDevReg,TEXT("FDMA"));
    RegDeleteValue(hkDevReg,TEXT("DriverType"));

    // Blow away the Drivers subtree
    SHRegDeleteKey(hkDevReg,TEXT("Drivers"));

    // For future use, allow a key under which everything gets blown away
    SHRegDeleteKey(hkDevReg,TEXT("UnretainedSettings"));

    RegCloseKey(hkDevReg);

    return TRUE;
}

// Clear out entries in the Device's Enum branch of the registry:
BOOL RemoveDeviceInfo(IN HDEVINFO         DeviceInfoSet,
                      IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                     )
{
    // Remove the Driver key. It looks something like "Driver = {4D36E96C-E325-11CE-BFC1-08002BE10318}\0000"
    // !!NO don't remove driver key, or else on driver upgrade system loses track of node & creates a new one
    //    SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_DRIVER , NULL, 0);

    // Remove the Service key.
    // Make sure before doing anything else that there is no service property for
    // this device instance.  This allows us to know whether we should clean up the
    // device instance if we boot and find that it's no longer present.
    SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_SERVICE, NULL, 0);

    return TRUE;
}


/* 5/14/98 andyraf for NT5 */
/* Media_RemoveDevice
 *
 * This function gets called on driver removal (DIF_REMOVE) and driver installation (DIF_INSTALL).
 * It cleans up all the registry entries associated with the driver.
 */
DWORD Media_RemoveDevice(IN HDEVINFO         DeviceInfoSet,
                         IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                        )
{
#if 0
    // Don't know how to do this on NT5
    if ((diFunction == DIF_REMOVE) &&
        (lpdi->Flags & DI_CLASSINSTALLPARAMS) &&
        (((LPREMOVEDEVICE_PARAMS)lpdi->lpClassInstallParams)->dwFlags & DI_REMOVEDEVICE_CONFIGSPECIFIC))
    {
        return ERROR_DI_DO_DEFAULT;
    }

    // Not needed on NT5??
    CleanupDummySysIniDevs();           //remove the wave=*.drv and midi=*.drv dummy devices.
#endif

#if 0   // We'll allow people to remove these drivers for now
    if (IsSpecialDriver(DeviceInfoSet, DeviceInfoData))
    {
        return NO_ERROR;
    }
#endif

    // Send DRV_REMOVE to each driver and clean out Drivers32 section of registry
    RemoveDriver        (DeviceInfoSet, DeviceInfoData);

    // Clean out MediaResources section of registry
    RemoveMediaResources(DeviceInfoSet, DeviceInfoData);

    // Clean out driver's classguid\instance section of registry
    RemoveDriverInfo    (DeviceInfoSet, DeviceInfoData);

    // Clean out device's enum section of registry
    RemoveDeviceInfo    (DeviceInfoSet, DeviceInfoData);

    return ERROR_DI_DO_DEFAULT;
}

#if 0   // Unused at present
BOOL AddDrivers32(IN HDEVINFO         DeviceInfoSet,
                  IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                 )
{
    BOOL bRet = FALSE;          // Return value

    TCHAR szDriverKey[MAX_PATH]; // Value of Driver's key in Enum branch
    TCHAR *pszDrvInst;           // Driver's instance, e.g. "0000", "0001", etc.

    HKEY hkDevReg  = NULL;      // Key to Driver portion of registry (e.g. classguid\0000)
    HKEY hkDrivers32 = NULL;    // Key to Drivers32 portion of registry
    HKEY hkDrivers = NULL;      // Key to classguid\0000\Drivers
    HKEY hkDriversDesc = NULL;  // Key to drivers.desc portion of registry

    TCHAR szSubClasses[256];     // List of subclasses to process
    TCHAR *strtok_State;         // strtok state
    TCHAR *pszClass;             // Information about e.g. classguid\0000\Drivers\wave
    HKEY hkClass;

    DWORD idxR3DriverName;      // Information about e.g. classguid\0000\Drivers\wave\foo.drv
    HKEY hkR3DriverName;
    TCHAR szR3DriverName[64];

    TCHAR szAlias[64];           // Alias in Drivers32 (e.g. wave1)

    TCHAR szDriver[64];          // Name of driver
    TCHAR szDescription[MAX_PATH];

    DWORD cbLen;

    // Get the Drivers key value under the device's Enum branch,
    // e.g. something like "{4D36E96C-E325-11CE-BFC1-08002BE10318}\0000"
    SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_DRIVER ,
                                     NULL,
                                     (LPBYTE)szDriverKey,
                                     MAX_PATH,
                                     NULL);

    // Get everything after the last \ character
    pszDrvInst = strrchr(szDriverKey,TEXT('\\'));
    if (!pszDrvInst)
    {
        goto RemoveDrivers32_exit;
    }
    pszDrvInst++;
    // Now pszDrvInst points to a string with the Driver Instance, e.g. "0000"

    // Open the Drivers32 section of the registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32"),
                   &hkDrivers32))
    {
        goto RemoveDrivers32_exit;
    }

    // If we're adding a driver, need to open key to drivers.desc also
    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc"),
                   &hkDriversDesc))
    {
        goto RemoveDrivers32_exit;
    }

    // Open the Driver reg key
    hkDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);
    if (hkDevReg == INVALID_HANDLE_VALUE)
    {
        goto RemoveDrivers32_exit;
    }

    // Enumerate through supporter classes in the Drivers subkey
    if (RegOpenKey(hkDevReg, TEXT("Drivers"), &hkDrivers))
    {
        goto RemoveDrivers32_exit;
    }

    // Read the SubClasses key to determine which subclasses to process
    cbLen=sizeof(szSubClasses);
    if (RegQueryValueEx(hkDrivers, TEXT("Subclasses"), NULL, NULL, (LPBYTE)szSubClasses, &cbLen))
    {
        goto RemoveDrivers32_exit;
    }

    // Enumerate all the subclasses
    for (
        pszClass = mystrtok(szSubClasses,NULL,&strtok_State);
        pszClass;
        pszClass = mystrtok(NULL,NULL,&strtok_State)
        )
    {
        // Open up each subclass
        if (RegOpenKey(hkDrivers, pszClass, &hkClass))
        {
            continue;
        }

        // Under each class is a set of driver name subkeys.
        // For each driver (e.g. foo1.drv, foo2.drv, etc.)
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {

            // Open the key to the driver name
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Get driver name
            cbLen = sizeof(szDriver);
            if (!RegQueryValueEx(hkR3DriverName, TEXT("Driver"), NULL, NULL, (LPBYTE)szDriver, &cbLen))
            {
                // Create the alias
                wsprintf(szAlias,TEXT("%s.%s<%s>"),(LPTSTR)pszClass,(LPTSTR)szDriver,(LPTSTR)pszDrvInst);

                // Write into Drivers32
                RegSetValueExA(hkDrivers32,szAlias,0,REG_SZ,(PBYTE)szDriver,(wcslen(szDriver)*sizeof(TCHAR)) + sizeof(TCHAR));

                // Write alias back into driver's reg area
                RegSetValueExA(hkR3DriverName,TEXT("Alias"),0,REG_SZ,(PBYTE)szAlias,(wcslen(szAlias)*sizeof(TCHAR)) + sizeof(TCHAR));
            }

            // Write out Description
            // Get driver description
            cbLen = sizeof(szDescription);
            if (!RegQueryValueEx(hkR3DriverName, TEXT("Description"), NULL, NULL, (LPBYTE)szDescription, &cbLen))
            {
                RegSetValueExA(hkDriversDesc,szDriver,0,REG_SZ,(PBYTE)szDescription,(wcslen(szDescription)*sizeof(TCHAR)) + sizeof(TCHAR));
            }

            // Close the Driver Name key
            RegCloseKey(hkR3DriverName);
        }
        // Close the class key
        RegCloseKey(hkClass);
    }

    bRet = TRUE;

    RemoveDrivers32_exit:

    if (hkDrivers32)    RegCloseKey(hkDrivers32);
    if (hkDevReg)       RegCloseKey(hkDevReg);
    if (hkDrivers)      RegCloseKey(hkDrivers);
    if (hkDriversDesc)  RegCloseKey(hkDriversDesc);

    return bRet;
}
#endif

#if 0 // Unused at present
// The driver's private registry section is located in something like:
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96C-E325-11CE-BFC1-08002BE10318}\xxxx
// where xxxx is the device instance (e.g. 0000, 0001, etc.)
// These last four digits are used to index into the driver's MediaResources section.

// For example, suppose a device has a driver instance
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96C-E325-11CE-BFC1-08002BE10318}\0001
// and under that entry there is a Drivers\wave\foo.drv, meaning that the foo.drv driver supports a wave
// API.
// In this case, there would be an entry in
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\MediaResources\wave\foo.drv<0001>
//
// On removal, we need to delete that entry.
BOOL AddMediaResources(IN HDEVINFO         DeviceInfoSet,
                       IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                      )


{
    BOOL bRet = FALSE;          // Return value

    TCHAR szDriverKey[MAX_PATH]; // Value of Driver's key in Enum branch
    TCHAR *pszDrvInst;           // Driver's instance, e.g. "0000", "0001", etc.

    HKEY hkDevReg  = NULL;      // Key to Driver portion of registry (e.g. classguid\0000)
    HKEY hkDrivers = NULL;      // Key to classguid\0000\Drivers
    HKEY hkMR      = NULL;      // Handle to MediaResources section

    TCHAR szSubClasses[256];     // List of subclasses to process
    TCHAR *strtok_State;         // strtok state
    TCHAR *pszClass;             // Information about e.g. classguid\0000\Drivers\wave
    HKEY hkClass;

    DWORD idxR3DriverName;      // Information about e.g. classguid\0000\Drivers\wave\foo.drv
    HKEY hkR3DriverName;
    TCHAR szR3DriverName[64];

    TCHAR szDriver[64];          // Driver name (e.g. foo.drv)
    DWORD cbLen;                // Size of szDriver

    TCHAR szDevNode[MAX_PATH+1];         // Path to driver's reg entry
    TCHAR szSoftwareKey[MAX_PATH+1];     // Value of SOFTWAREKEY

    // Open Media Resources section of registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_MEDIARESOURCES, &hkMR))
    {
        goto RemoveMediaResources_exit;
    }

    // Get the Drivers key value under the device's Enum branch,
    // e.g. something like "{4D36E96C-E325-11CE-BFC1-08002BE10318}\0000"
    SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_DRIVER ,
                                     NULL,
                                     (LPBYTE)szDriverKey,
                                     MAX_PATH,
                                     NULL);

    // Get everything after the last \ character
    pszDrvInst = strrchr(szDriverKey,TEXT('\\'));
    if (!pszDrvInst)
    {
        goto RemoveMediaResources_exit;
    }
    pszDrvInst++;
    // Now pszDrvInst points to a string with the Driver Instance, e.g. "0000"

    // Get full path to driver key
    wsprintf(szDevNode,
             TEXT("%s\\%s"),
             REGSTR_PATH_CLASS_NT,
             (LPTSTR)szDriverKey);

    // Open the Driver reg key
    hkDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);
    if (hkDevReg == INVALID_HANDLE_VALUE)
    {
        goto RemoveMediaResources_exit;
    }

    // Enumerate through supporter classes in the Drivers subkey
    if (RegOpenKey(hkDevReg, TEXT("Drivers"), &hkDrivers))
    {
        goto RemoveMediaResources_exit;
    }

    // Read the SubClasses key to determine which subclasses to process
    cbLen=sizeof(szSubClasses);
    if (RegQueryValueEx(hkDrivers, TEXT("Subclasses"), NULL, NULL, (LPBYTE)szSubClasses, &cbLen))
    {
        goto RemoveMediaResources_exit;
    }

    // Enumerate all the subclasses
    for (
        pszClass = mystrtok(szSubClasses,NULL,&strtok_State);
        pszClass;
        pszClass = mystrtok(NULL,NULL,&strtok_State)
        )
    {
        if (RegOpenKey(hkDrivers, pszClass, &hkClass))
        {
            continue;
        }

        // Under each class is a set of driver name subkeys.
        // For each driver (e.g. foo1.drv, foo2.drv, etc.)
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {

            // Open the key to the driver name
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Get the value of Driver in under the driver name key
            cbLen = sizeof(szDriver);
            if (!RegQueryValueEx(hkR3DriverName, TEXT("Driver"), NULL, NULL, (LPBYTE)szDriver, &cbLen))
            {
                HKEY hkMRClass;
                HKEY hkMRDriver;
                TCHAR szMRDriver[256];

                // Create the class key if it doesn't already exist
                if (!RegCreateKey(hkMR,pszClass,&hkMRClass))
                {
                    continue;
                }

                // Create the driver key if it doesn't already exist
                wsprintf(szMRDriver,
                         TEXT("%s<%s>"),
                         (LPTSTR)szDriver,
                         (LPTSTR)pszDrvInst);

                if (!RegCreateKey(hkMRClass,szMRDriver,&hkMRDriver))
                {
                    RegCloseKey(hkMRClass);
                    continue;
                }

                // Migrate the values from the driver into the MediaResources key
                // First write out driver name
                // FEATURE: Not implemented yet.

                RegCloseKey(hkMRClass);
                RegCloseKey(hkMRDriver);
            }
            // Close the Driver Name key
            RegCloseKey(hkR3DriverName);
        }

        // Close the class key in the devnode
        RegCloseKey(hkClass);
    }

    bRet = TRUE;

    RemoveMediaResources_exit:
    if (hkDevReg)   RegCloseKey(hkDevReg);
    if (hkDrivers)  RegCloseKey(hkDrivers);
    if (hkMR)       RegCloseKey(hkMR);

    return bRet;
}
#endif

#ifdef _WIN64
void mmWOW64ThunkMediaClassInstaller(DWORD dwInstallationFlag, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
    DWORD dwInstanceIDSize = 0;
    DWORD dwWow64DirSize = 0;
    LPTSTR tcstrDeviceInstanceId = NULL;
    LPTSTR tcstrWow64Directory = NULL;
    LPTSTR tcstrRunDLL32Path = NULL;
    PROCESS_INFORMATION processInformation;
    STARTUPINFO startupInfo;

    // Get the device instance ID
    SetupDiGetDeviceInstanceId( DeviceInfoSet, DeviceInfoData, NULL, 0, &dwInstanceIDSize );
    if( 0 == dwInstanceIDSize )
    {
        // Unable to retrieve required size - return
        return;
    }

    tcstrDeviceInstanceId = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * dwInstanceIDSize);
    if( NULL == tcstrDeviceInstanceId
    ||  0 == SetupDiGetDeviceInstanceId( DeviceInfoSet, DeviceInfoData, tcstrDeviceInstanceId, dwInstanceIDSize, NULL ) )
    {
        // Unable to retrieve device instance ID - return
        LocalFree((HANDLE)tcstrDeviceInstanceId);
        return;
    }

    dwWow64DirSize = GetSystemWow64Directory( NULL, 0 );
    if( 0 == dwWow64DirSize )
    {
        // Unable to retrieve the Wow64Directory size - return
        LocalFree((HANDLE)tcstrDeviceInstanceId);
        return;
    }

    tcstrWow64Directory = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * dwWow64DirSize);
    if( NULL == tcstrWow64Directory
    ||  0 == GetSystemWow64Directory( tcstrWow64Directory, dwWow64DirSize ) )
    {
        // Unable to retrieve the Wow64Directory - return
        LocalFree((HANDLE)tcstrWow64Directory);
        LocalFree((HANDLE)tcstrDeviceInstanceId);
        return;
    }

    // The full path is the size of the format string, plus two times the length of the system path,
    // plus the length of the instance ID, plus 10 (maximum length of a DWORD)
    tcstrRunDLL32Path = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (wcslen(gszRunDLL32Path) +
        dwWow64DirSize * 2 + dwInstanceIDSize + 10));
    if( NULL == tcstrRunDLL32Path )
    {
        // Unable to allocate RunDLL32 path - return
        LocalFree((HANDLE)tcstrWow64Directory);
        LocalFree((HANDLE)tcstrDeviceInstanceId);
        return;
    }

    // Create the command line
    wsprintf( tcstrRunDLL32Path, gszRunDLL32Path, tcstrWow64Directory, tcstrWow64Directory, tcstrDeviceInstanceId, dwInstallationFlag );

    // Initialize the CreateProcess structures
    ZeroMemory( &processInformation, sizeof(PROCESS_INFORMATION) );
    ZeroMemory( &startupInfo, sizeof(STARTUPINFO) );
    startupInfo.cb = sizeof(STARTUPINFO);

    if( CreateProcess( NULL, tcstrRunDLL32Path, NULL, NULL, FALSE,
	    CREATE_NO_WINDOW, NULL, NULL, &startupInfo, &processInformation ) )
    {
        // Wait for the process to end
	    WaitForSingleObject( processInformation.hProcess, 5000 );

	    // Close process and thread handles. 
	    CloseHandle( processInformation.hProcess );
	    CloseHandle( processInformation.hThread );
    }

    // Free up the strings we allocated
    LocalFree((HANDLE)tcstrRunDLL32Path);
    LocalFree((HANDLE)tcstrWow64Directory);
    LocalFree((HANDLE)tcstrDeviceInstanceId);
}
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\roland.h ===
//--------------------------------------------------------------------------;
//
//  File: Roland.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;

STDAPI_(void) RolandProp(HWND hwnd, HINSTANCE hInst, TCHAR *szName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\sndfile.c ===
/*
 ***************************************************************
 *  sndfile.c
 *
 *  This file contains the code to fill up the list and combo boxes,
 *  show the RIFF Dibs and the current sound mappings 
 *
 *  Copyright 1993, Microsoft Corporation     
 *
 *  History:
 *
 *    07/94 - VijR (Created)
 *        
 ***************************************************************
 */
#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <ole2.h>
#include <prsht.h>
#include <cpl.h>
#include "mmcpl.h"
#include "draw.h"
#include "sound.h"

/*
 ***************************************************************
 * Globals
 ***************************************************************
 */
HSOUND ghse;


/*
 ***************************************************************
 * extern
 ***************************************************************
 */
extern TCHAR        gszMediaDir[];
extern TCHAR        gszCurDir[];
extern BOOL        gfWaveExists;   // indicates wave device in system.
extern BOOL        gfChanged;      // Is set TRUE if any changes are made
extern BOOL        gfNewScheme;  

//Globals used in painting disp chunk display.
extern HTREEITEM   ghOldItem;

/*
 ***************************************************************
 * Defines 
 ***************************************************************
 */                                                
#define DF_PM_SETBITMAP    (WM_USER+1)   
#define FOURCC_INFO mmioFOURCC('I','N','F','O')
#define FOURCC_DISP mmioFOURCC('D','I','S','P')
#define FOURCC_INAM mmioFOURCC('I','N','A','M')
#define FOURCC_ISBJ mmioFOURCC('I','S','B','J')
#define MAXDESCLEN    220

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */
HANDLE PASCAL GetRiffDisp        (HMMIO);
BOOL PASCAL ShowSoundMapping    (HWND, PEVENT);
BOOL PASCAL ChangeSoundMapping  (HWND, LPTSTR, PEVENT);
BOOL PASCAL PlaySoundFile       (HWND, LPTSTR);
BOOL PASCAL ChangeSetting        (LPTSTR*, LPTSTR);
LPTSTR PASCAL NiceName(LPTSTR sz, BOOL fNukePath);

// Stuff in dib.c
//
HPALETTE WINAPI  bmfCreateDIBPalette(HANDLE);
HBITMAP  WINAPI  bmfBitmapFromDIB(HANDLE, HPALETTE);

// Stuff in drivers.c
//
LPTSTR lstrchr (LPTSTR, TCHAR);
int lstrnicmp (LPTSTR, LPTSTR, size_t);

// Stuff in scheme.c
//
void PASCAL AddMediaPath        (LPTSTR, LPTSTR);

/*
 ***************************************************************
 ***************************************************************
 */
STATIC void NEAR PASCAL ChopPath(LPTSTR lpszFile)
{
    TCHAR szTmp[MAX_PATH];
    size_t cchTest = lstrlen (gszCurDir);

    szTmp[0] = TEXT('\0');

    ExpandEnvironmentStrings(lpszFile, (LPTSTR)szTmp, MAXSTR);
    lstrcpy(lpszFile,szTmp);

    if (gszCurDir[ cchTest-1 ] == TEXT('\\'))
       --cchTest;
    
    lstrcpy((LPTSTR)szTmp, lpszFile);
    if (!lstrnicmp((LPTSTR)szTmp, (LPTSTR)gszCurDir, cchTest))
    {
        if (szTmp[ cchTest ] == TEXT('\\'))
        {
            lstrcpy(lpszFile, (LPTSTR)(szTmp+cchTest+1));
        }
    }
}
/*
 ***************************************************************
 * QualifyFileName
 *
 * Description:
 *    Verifies the existence and readability of a file.
 *
 * Parameters:
 *    LPTSTR    lpszFile    - name of file to check.
 *    LPTSTR    lpszPath    - returning full pathname of file.     
 *  int        csSize        - Size of return buffer
 *
 * Returns:    BOOL
 *         True if absolute path exists
 *
 ***************************************************************
 */

BOOL PASCAL QualifyFileName(LPTSTR lpszFile, LPTSTR lpszPath, int cbSize, BOOL fTryCurDir)
{
    BOOL     fErrMode;
    BOOL     f = FALSE;
    BOOL     fHadEnvStrings;
    TCHAR     szTmpFile[MAXSTR];
    int len;
    BOOL fTriedCurDir;
    TCHAR*      pszFilePart;
    HFILE   hFile;

    if (!lpszFile)
        return FALSE;

    fHadEnvStrings = (lstrchr (lpszFile, TEXT('%')) != NULL) ? TRUE : FALSE;

    ExpandEnvironmentStrings (lpszFile, (LPTSTR)szTmpFile, MAXSTR);
    len =  lstrlen((LPTSTR)szTmpFile)+1;

    fErrMode = SetErrorMode(TRUE);  // we will handle errors

    AddExt (szTmpFile, cszWavExt);

    fTriedCurDir = FALSE;

TryOpen:
    hFile = (HFILE)HandleToUlong(CreateFile(szTmpFile,GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    if (-1 != hFile)
    {
        if (fHadEnvStrings)
            lstrcpyn(lpszPath, lpszFile, cbSize);
        else
            GetFullPathName(szTmpFile,cbSize/sizeof(TCHAR),lpszPath,&pszFilePart);
        f = TRUE;

        CloseHandle(LongToHandle(hFile));
    }
    else
    /*
    ** If the test above failed, we try converting the name to OEM
    ** character set and try again.
    */
    {
        /*
        ** First, is it in MediaPath?
        **
        */
        if (lstrchr (lpszFile, TEXT('\\')) == NULL)
        {
            TCHAR szCurDirFile[MAXSTR];
            AddMediaPath (szCurDirFile, lpszFile);
            if (-1 != (HFILE)HandleToUlong(CreateFile(szCurDirFile, GENERIC_R