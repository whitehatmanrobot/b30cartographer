entPromptDlg();

protected:
    // From CBaseContentDlg
    HRESULT _FillListView();
    HRESULT _InitStatics();
    HRESULT _InitSelections();
    HRESULT _OnListSelChange();

private:
    LRESULT OnOK(WORD wNotif);

    HRESULT _InitDataObjects();
    HRESULT _InitDominantContent();

    HRESULT _InitExistingSettings();
    HRESULT _SaveSettings(BOOL fSoftCommit);

    HRESULT _UpdateHandlerSettings();

    CContentTypeData                _data;
    CDLManager<CContentTypeData>    _dlmanager;
};

///////////////////////////////////////////////////////////////////////////////
// Dialog to show when there is mixed content and current setting is "prompt
// each time"
class CMixedContentDlg : public CBaseContentDlg
{
public:
    CMixedContentDlg();
    virtual ~CMixedContentDlg();

protected:
    LRESULT OnOK(WORD wNotif);

    // From CBaseContentDlg
    HRESULT _FillListView();
    HRESULT _InitStatics();
    HRESULT _InitSelections();
    HRESULT _OnListSelChange();

private:
    HRESULT _InitDataObjects();

    CDPA<CContentTypeData> _dpaContentTypeData;
};


///////////////////////////////////////////////////////////////////////////////
// Dialog to show when there is no content and current setting is "prompt
// each time"
class CNoContentDlg : public CBaseContentDlg
{
public:
    CNoContentDlg();
    virtual ~CNoContentDlg();

protected:
    // From CBaseContentDlg
    HRESULT _FillListView();
    HRESULT _InitStatics();
    HRESULT _InitSelections();
    HRESULT _OnListSelChange();

private:
    LRESULT OnOK(WORD wNotif);

    HRESULT _InitDataObjects();

    HRESULT _InitExistingSettings();
    HRESULT _SaveSettings(BOOL fSoftCommit);

    HRESULT _UpdateHandlerSettings();

    CNoContentData                  _data;
    CDLManager<CNoContentData>      _dlmanager;
};

#endif //HWPROMPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\apprmdlg.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "apprmdlg.h"

#include "mtpt.h"
#include "hwcmmn.h"

#include "mixctnt.h"

static DWORD s_rgdwHelpIDsArray[] =
{  // Context Help IDs
    IDC_AP_MXCT_TOPICON,              NO_HELP,
    IDC_AP_MXCT_TOPTEXT,              NO_HELP,
    IDC_AP_MXCT_TOPTEXT2,              NO_HELP,
    IDC_AP_MXCT_LIST,              NO_HELP,
    IDC_AP_MXCT_CHECKBOX,              NO_HELP,
    0, 0
};

CBaseContentDlg::CBaseContentDlg() : CBaseDlg((ULONG_PTR)s_rgdwHelpIDsArray),
    _pszDeviceID(NULL), _hiconInfo(NULL), _hiconTop(NULL)
{}

CBaseContentDlg::~CBaseContentDlg()
{
    if (_pszDeviceID)
    {
        LocalFree((HLOCAL)_pszDeviceID);
    }

    if (_hiconInfo)
    {
        DestroyIcon(_hiconInfo);
    }

    if (_hiconTop)
    {
        DestroyIcon(_hiconTop);
    }
}

HRESULT CBaseContentDlg::_SetHandler()
{
    CHandlerData* phandlerdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&phandlerdata);

    if (SUCCEEDED(hr))
    {
        hr = StringCchCopy(_szHandler, ARRAYSIZE(_szHandler),
            phandlerdata->_pszHandler);

        phandlerdata->Release();
    }

    return hr;
}   

HRESULT CBaseContentDlg::Init(LPCWSTR pszDeviceID, LPCWSTR pszDeviceIDAlt,
    DWORD dwContentType, BOOL fCheckAlwaysDoThis)
{
    HRESULT hr = E_INVALIDARG;

    _fCheckAlwaysDoThis = fCheckAlwaysDoThis;

    if (pszDeviceID)
    {
        _pszDeviceID = StrDup(pszDeviceID);

        if (_pszDeviceID)
        {
            _szDeviceIDAlt[0] = 0;

            if (pszDeviceIDAlt)
            {
                if (InRange(*pszDeviceIDAlt, 'a', 'z') ||
                    InRange(*pszDeviceIDAlt, 'A', 'Z'))
                {
                    hr = StringCchCopy(_szDeviceIDAlt, ARRAYSIZE(_szDeviceIDAlt),
                        pszDeviceIDAlt);

                    if (SUCCEEDED(hr))
                    {
                        _dwContentType = dwContentType;

                        hr = _GetContentTypeHandler(dwContentType, _szContentTypeHandler,
                            ARRAYSIZE(_szContentTypeHandler));
                    }
                }
            }

            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }    
    }
        
    return hr;
}

#define COL_ACTION      0
#define COL_PROVIDER    1

const UINT c_auTileColumns[] = {COL_ACTION, COL_PROVIDER};
const UINT c_auTileSubItems[] = {COL_PROVIDER};

HRESULT CBaseContentDlg::_InitListView()
{
    HWND hwndList = GetDlgItem(_hwnd, IDC_AP_MXCT_LIST);

    HRESULT hr = _uilListView.Init(hwndList);

    if (SUCCEEDED(hr))
    {
        hr = _uilListView.InitTileInfo(c_auTileSubItems, ARRAYSIZE(c_auTileSubItems));

        if (SUCCEEDED(hr))
        {
            RECT rc = {0};
            LVTILEVIEWINFO lvtvi = {0};
            HIMAGELIST himagelist;

            ListView_SetView(hwndList, LV_VIEW_TILE);

            for (int i = 0; i < ARRAYSIZE(c_auTileColumns); ++i)
            {
                LVCOLUMN lvcolumn = {0};

                lvcolumn.mask = LVCF_SUBITEM;
                lvcolumn.iSubItem = c_auTileColumns[i];
                ListView_InsertColumn(hwndList, i, &lvcolumn);
            }

            GetClientRect(hwndList, &rc);

            lvtvi.cbSize = sizeof(LVTILEVIEWINFO);
            lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
            lvtvi.dwFlags = LVTVIF_FIXEDWIDTH;
    
            // Leave room for the scroll bar when setting tile sizes or listview gets screwed up.
            lvtvi.sizeTile.cx = ((rc.right - rc.left) - GetSystemMetrics(SM_CXVSCROLL));
            lvtvi.cLines = ARRAYSIZE(c_auTileSubItems);
            ListView_SetTileViewInfo(hwndList, &lvtvi);

            Shell_GetImageLists(&himagelist, NULL);

            if (himagelist)
            {
                ListView_SetImageList(hwndList, himagelist, LVSIL_NORMAL);
                hr = S_OK;
            }
        }
    }

    return hr;
}

LRESULT CBaseContentDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = _InitListView();

    if (SUCCEEDED(hr))
    {
        hr = _FillListView();

        if (SUCCEEDED(hr))
        {
            hr = _InitStaticsCommon();

            if (SUCCEEDED(hr))
            {
                hr = _InitStatics();

                if (SUCCEEDED(hr))
                {
                    hr = _InitSelections();
                }
            }
        }
    }

    if (_szDeviceIDAlt[0])
    {
        _SetAutoplayPromptHWND(_szDeviceIDAlt, _hwnd);
    }

    return TRUE;
}

LRESULT CBaseContentDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    LPNMHDR pNMHDR = (NMHDR *)lParam;
    UINT_PTR idFrom = pNMHDR->idFrom;
    UINT uCode = pNMHDR->code;

    switch (idFrom)
    {
    case IDC_AP_MXCT_LIST:

        if (LVN_ITEMCHANGED == uCode)
        {
            NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;

            // Is a new item being selected/unselected?
            if (pNMLV->uChanged & LVIF_STATE)
            {
                // Yes
                _OnListSelChange();
            }
        }
        else if (NM_DBLCLK == uCode)
        {
            OnOK(0);
        }

        lRes = CBaseDlg::OnNotify(wParam, lParam);
        break;

    default:
        lRes = CBaseDlg::OnNotify(wParam, lParam);
        break;
    }

    return lRes;    
}

LRESULT CBaseContentDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    _uilListView.ResetContent();

    return CBaseDlg::OnDestroy(wParam, lParam);
}

LRESULT CBaseContentDlg::OnOK(WORD wNotif)
{
    // Wait cursor...  
    EndDialog(_hwnd, IDOK);
    
    return FALSE;
}

LRESULT CBaseContentDlg::OnCancel(WORD wNotif)
{
    EndDialog(_hwnd, IDCANCEL);

    return FALSE;
}

HRESULT CBaseContentDlg::_InitStaticsCommon()
{
    // Initialize _szDeviceName to something
    HRESULT hr = _InitDeviceName();

    if (SUCCEEDED(hr))
    {
        SetWindowText(_hwnd, _szDeviceName);
    }

    if (_fCheckAlwaysDoThis)
    {
        Button_SetCheck(GetDlgItem(_hwnd, IDC_AP_MXCT_CHECKBOX), _fCheckAlwaysDoThis);
    }

    if (_szDeviceIDAlt[0])
    {
        // Initialize _szDeviceName to something
        CMountPoint* pmtpt = CMountPoint::GetMountPoint(_szDeviceIDAlt);

        if (pmtpt)
        {
            WCHAR szIconLocation[MAX_PATH + 12];
            int iIcon = pmtpt->GetIcon(szIconLocation, ARRAYSIZE(szIconLocation));

            if (SUCCEEDED(hr))
            {
                if (!szIconLocation[0])
                {
                    hr = StringCchCopy(szIconLocation, ARRAYSIZE(szIconLocation),
                        TEXT("shell32.dll"));
                }

                if (SUCCEEDED(hr))
                {
                    int iImage = Shell_GetCachedImageIndex(szIconLocation, iIcon, 0);

                    HIMAGELIST himagelist;

                    if ((-1 != iImage) && Shell_GetImageLists(&himagelist, NULL))
                    {
                        _hiconTop = ImageList_GetIcon(himagelist, iImage, ILD_TRANSPARENT);

                        SendDlgItemMessage(_hwnd, IDC_AP_MXCT_TOPICON, STM_SETIMAGE,
                            IMAGE_ICON, (LPARAM)_hiconTop);
                    }
                }
            }

            pmtpt->Release();
        }
    }

    return hr;
}

HRESULT CBaseContentDlg::_InitDeviceName()
{
    HRESULT hr = E_FAIL;

    if (_szDeviceIDAlt[0])
    {
        CMountPoint* pmtpt = CMountPoint::GetMountPoint(_szDeviceIDAlt);

        if (pmtpt)
        {
            hr = pmtpt->GetDisplayName(_szDeviceName, ARRAYSIZE(_szDeviceName));

            pmtpt->Release();
        }
    }
    
    if (FAILED(hr))
    {
        GetWindowText(_hwnd, _szDeviceName, ARRAYSIZE(_szDeviceName));
        hr = S_FALSE;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
CHWContentPromptDlg::CHWContentPromptDlg() : CBaseContentDlg()
{}
      
CHWContentPromptDlg::~CHWContentPromptDlg()
{}

HRESULT CHWContentPromptDlg::_InitDataObjects()
{
    HRESULT hr = _data.Init(_pszDeviceID, _dwContentType);

    if (SUCCEEDED(hr))
    {
        hr = _dlmanager.AddDataObject(&_data);
    }

    return hr;
}

HRESULT CHWContentPromptDlg::_FillListView()
{
    HRESULT hr = _InitDataObjects();

    if (SUCCEEDED(hr))
    {
        int c = _data.GetHandlerCount();
        for (int i = 0; SUCCEEDED(hr) && (i < c); ++i)
        {
            CHandlerData* phandlerdata = _data.GetHandlerData(i);
            if (phandlerdata)
            {
                CHandlerLVItem* puidata = new CHandlerLVItem();

                if (puidata)
                {
                    hr = puidata->InitData(phandlerdata);

                    if (SUCCEEDED(hr))
                    {
                        hr = _uilListView.AddItem(puidata);
                    }

                    if (FAILED(hr))
                    {
                        delete puidata;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                phandlerdata->Release();
            }
        }
    }

    return hr;
}

HRESULT CHWContentPromptDlg::_InitStatics()
{
    // Set content icon
    if (_hiconTop)
    {
        DestroyIcon(_hiconTop);
    }

    _hiconTop = _GetIconFromIconLocation(_data._szIconLocation, FALSE);

    SendDlgItemMessage(_hwnd, IDC_AP_MXCT_CONTENTICON, STM_SETIMAGE,
        IMAGE_ICON, (LPARAM)_hiconTop);

    // Set content name
    SetDlgItemText(_hwnd, IDC_AP_MXCT_CONTENTTYPE, _data._szIconLabel);

    return S_OK;
}

HRESULT CHWContentPromptDlg::_InitSelections()
{
    HRESULT hr;
    
    if (_data._pszHandlerDefaultOriginal && *(_data._pszHandlerDefaultOriginal))
    {
        hr = _uilListView.SelectItem(_data._pszHandlerDefaultOriginal);
    }
    else
    {
        hr = _uilListView.SelectFirstItem();
    }

    if (SUCCEEDED(hr))
    {
        CHandlerData* phandlerdata;

        hr = _uilListView.GetSelectedItemData(&phandlerdata);

        if (SUCCEEDED(hr))
        {
            hr = StringCchCopy(_szHandler, ARRAYSIZE(_szHandler),
                phandlerdata->_pszHandler);

            if (SUCCEEDED(hr))
            {
                _SetHandlerDefault(&(_data._pszHandlerDefault),
                    phandlerdata->_pszHandler);
            }

            phandlerdata->Release();
        }
    }

    Button_SetCheck(GetDlgItem(_hwnd, IDC_AP_MXCT_CHECKBOX), _fCheckAlwaysDoThis);

    return hr;
}

HRESULT CHWContentPromptDlg::_UpdateHandlerSettings()
{
    CHandlerData* phandlerdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&phandlerdata);

    if (SUCCEEDED(hr))
    {
        _SetHandlerDefault(&(_data._pszHandlerDefault), phandlerdata->_pszHandler);

        phandlerdata->Release();
    }

    return hr;
}

HRESULT CHWContentPromptDlg::_OnListSelChange()
{
    return _UpdateHandlerSettings();
}

LRESULT CHWContentPromptDlg::OnOK(WORD wNotif)
{
    if (BST_CHECKED == Button_GetCheck(GetDlgItem(_hwnd, IDC_AP_MXCT_CHECKBOX)))
    {
        _SaveSettings(FALSE);

        // return value????
    }
    else
    {
        _SaveSettings(TRUE);
    }

    _SetHandler();

    // Do default processing
    return CBaseContentDlg::OnOK(wNotif);
}

HRESULT CHWContentPromptDlg::_SaveSettings(BOOL fSoftCommit)
{
    _data._fSoftCommit = fSoftCommit;

    return _dlmanager.Commit();
}

CMixedContentDlg::CMixedContentDlg() : _dpaContentTypeData(NULL)
{
}
      
CMixedContentDlg::~CMixedContentDlg()
{
    if (_dpaContentTypeData)
    {
        int c = _dpaContentTypeData.GetPtrCount();

        for (int i = 0; i < c; ++i)
        {
            CContentTypeData* pdata = _dpaContentTypeData.GetPtr(i);
            pdata->Release();
        }

        _dpaContentTypeData.Destroy();
    }
}

const DWORD c_rgdwContentTypeAutoplay[] =
{
    CT_AUTOPLAYMUSIC,
    CT_AUTOPLAYPIX,
    CT_AUTOPLAYMOVIE,
};

HRESULT CMixedContentDlg::_InitDataObjects()
{
    HRESULT hr = _dpaContentTypeData.Create(4) ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        for (DWORD dw = 0; dw < ARRAYSIZE(c_rgdwContentTypeAutoplay); ++dw)
        {
            if (_dwContentType & c_rgdwContentTypeAutoplay[dw])
            {
                CContentTypeData* pdata = new CContentTypeData();

                if (pdata)
                {
                    hr = pdata->Init(_pszDeviceID, _dwContentType & c_rgdwContentTypeAutoplay[dw]);

                    if (SUCCEEDED(hr))
                    {
                        if (-1 == _dpaContentTypeData.AppendPtr(pdata))
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if (FAILED(hr))
                    {
                        pdata->Release();
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            // Eliminate the duplicates.  Go thru all the content types
            // and then thru all their handlers and see if their would
            // not be two duplicate handlers that were brought by two diff
            // content type.  E.g.: Open folder is registered for music,
            // pictures and video
            int cContentType = _dpaContentTypeData.GetPtrCount();

            for (int iContentType = 0; iContentType < cContentType; ++iContentType)
            {
                CContentTypeData* pdata = _dpaContentTypeData.GetPtr(iContentType);

                if (pdata)
                {
                    int cHandler = pdata->GetHandlerCount();
                    for (int iHandler = 0; iHandler < cHandler; ++iHandler)
                    {
                        CHandlerData* phandlerdata = pdata->GetHandlerData(iHandler);
                        if (phandlerdata)
                        {
                            for (int iContentTypeInner = 0;
                                iContentTypeInner < cContentType;
                                ++iContentTypeInner)
                            {
                                BOOL fExitInnerLoop = FALSE;

                                // Cannot have duplicate handler within same content type
                                if (iContentTypeInner != iContentType)
                                {
                                    CContentTypeData* pdataInner = _dpaContentTypeData.GetPtr(iContentTypeInner);
                                    if (pdataInner)
                                    {
                                        int cHandlerInner = pdataInner->GetHandlerCount();
                                        for (int iHandlerInner = 0;
                                            !fExitInnerLoop && (iHandlerInner < cHandlerInner);
                                            ++iHandlerInner)
                                        {
                                            CHandlerData* phandlerdataInner = pdataInner->GetHandlerData(iHandlerInner);
                                            if (phandlerdataInner)
                                            {
                                                if (!lstrcmp(phandlerdataInner->_pszHandler,
                                                    phandlerdata->_pszHandler))
                                                {
                                                    pdataInner->RemoveHandler(iHandlerInner);
                                                    // Can be only one duplicate for a
                                                    // handler within another content type
                                                    fExitInnerLoop = TRUE;
                                                }
                                                phandlerdataInner->Release();
                                            }
                                        }
                                    }
                                }
                            }
                            phandlerdata->Release();
                        }
                    }
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CMixedContentDlg::_FillListView()
{
    HRESULT hr = _InitDataObjects();

    if (SUCCEEDED(hr))
    {
        if (_dpaContentTypeData)
        {
            int c = _dpaContentTypeData.GetPtrCount();

            for (int i = 0; SUCCEEDED(hr) && (i < c); ++i)
            {
                CContentTypeData* pdata = _dpaContentTypeData.GetPtr(i);

                if (pdata)
                {
                    pdata->AddRef();

                    int cHandler = pdata->GetHandlerCount();
                    for (int j = 0; SUCCEEDED(hr) && (j < cHandler); ++j)
                    {
                        CHandlerData* phandlerdata = pdata->GetHandlerData(j);
                        if (phandlerdata)
                        {
                            CHandlerLVItem* puidata = new CHandlerLVItem();

                            if (puidata)
                            {
                                hr = puidata->InitData(phandlerdata);

                                if (SUCCEEDED(hr))
                                {
                                    hr = _uilListView.AddItem(puidata);
                                }

                                if (FAILED(hr))
                                {
                                    delete puidata;
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }

                            phandlerdata->Release();
                        }
                    }

                    pdata->Release();
                }
            }
        }
    }

    return hr;
}

HRESULT CMixedContentDlg::_InitStatics()
{
    return S_OK;
}

HRESULT CMixedContentDlg::_InitSelections()
{
    HRESULT hr = _uilListView.SelectFirstItem();

    if (SUCCEEDED(hr))
    {
        CHandlerData* phandlerdata;

        hr = _uilListView.GetSelectedItemData(&phandlerdata);

        if (SUCCEEDED(hr))
        {
            hr = StringCchCopy(_szHandler, ARRAYSIZE(_szHandler),
                phandlerdata->_pszHandler);

            phandlerdata->Release();
        }
    }

    return hr;
}

HRESULT CMixedContentDlg::_OnListSelChange()
{
    return S_OK;
}

LRESULT CMixedContentDlg::OnOK(WORD wNotif)
{
    _SetHandler();

    if (_dpaContentTypeData)
    {
        BOOL fFound = FALSE;
        int c = _dpaContentTypeData.GetPtrCount();

        for (int i = 0; !fFound && (i < c); ++i)
        {
            CContentTypeData* pdata = _dpaContentTypeData.GetPtr(i);

            if (pdata)
            {
                pdata->AddRef();
                int cHandler = pdata->GetHandlerCount();
                for (int j = 0; !fFound && (j < cHandler); ++j)
                {
                    CHandlerData* phandlerdata = pdata->GetHandlerData(j);
                    if (phandlerdata)
                    {
                        if (!lstrcmp(phandlerdata->_pszHandler,
                            _szHandler))
                        {
                            StringCchCopy(_szContentTypeHandler,
                                ARRAYSIZE(_szContentTypeHandler),
                                pdata->_szContentTypeHandler);

                            fFound = TRUE;
                        }

                        phandlerdata->Release();
                    }
                }

                pdata->Release();
            }
        }
    }
    
    // Do default processing
    return CBaseContentDlg::OnOK(wNotif);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CNoContentDlg::CNoContentDlg() : CBaseContentDlg()
{}
      
CNoContentDlg::~CNoContentDlg()
{}

HRESULT CNoContentDlg::_InitDataObjects()
{
    HRESULT hr = _data.Init(_pszDeviceID);

    if (SUCCEEDED(hr))
    {
        hr = _dlmanager.AddDataObject(&_data);
    }

    _SetAutoplayPromptHWND(_pszDeviceID, _hwnd);

    return hr;
}

HRESULT CNoContentDlg::_FillListView()
{
    HRESULT hr = _InitDataObjects();

    if (SUCCEEDED(hr))
    {
        int c = _data.GetHandlerCount();
        for (int i = 0; SUCCEEDED(hr) && (i < c); ++i)
        {
            CHandlerData* phandlerdata = _data.GetHandlerData(i);
            if (phandlerdata)
            {
                CHandlerLVItem* puidata = new CHandlerLVItem();

                if (puidata)
                {
                    hr = puidata->InitData(phandlerdata);

                    if (SUCCEEDED(hr))
                    {
                        hr = _uilListView.AddItem(puidata);
                    }

                    if (FAILED(hr))
                    {
                        delete puidata;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                phandlerdata->Release();
            }
        }
    }

    return hr;
}

HRESULT CNoContentDlg::_InitStatics()
{
    if (_hiconTop)
    {
        DestroyIcon(_hiconTop);
    }

    // Set device icon
    _hiconTop = _GetIconFromIconLocation(_data._pszIconLocation, TRUE);

    SendDlgItemMessage(_hwnd, IDC_AP_MXCT_TOPICON, STM_SETIMAGE,
        IMAGE_ICON, (LPARAM)_hiconTop);
    
    // Set device name
    SetWindowText(_hwnd, _data._pszIconLabel);

    return S_OK;
}

HRESULT CNoContentDlg::_InitSelections()
{
    HRESULT hr;
    
    if (_data._pszHandlerDefaultOriginal && *(_data._pszHandlerDefaultOriginal))
    {
        hr = _uilListView.SelectItem(_data._pszHandlerDefaultOriginal);
    }
    else
    {
        hr = _uilListView.SelectFirstItem();
    }

    if (SUCCEEDED(hr))
    {
        CHandlerData* phandlerdata;

        hr = _uilListView.GetSelectedItemData(&phandlerdata);

        if (SUCCEEDED(hr))
        {
            hr = StringCchCopy(_szHandler, ARRAYSIZE(_szHandler),
                phandlerdata->_pszHandler);

            if (SUCCEEDED(hr))
            {
                _SetHandlerDefault(&(_data._pszHandlerDefault),
                    phandlerdata->_pszHandler);
            }

            phandlerdata->Release();
        }
    }

    Button_SetCheck(GetDlgItem(_hwnd, IDC_AP_MXCT_CHECKBOX), _fCheckAlwaysDoThis);

    return hr;
}

HRESULT CNoContentDlg::_UpdateHandlerSettings()
{
    CHandlerData* phandlerdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&phandlerdata);

    if (SUCCEEDED(hr))
    {
        _SetHandlerDefault(&(_data._pszHandlerDefault), phandlerdata->_pszHandler);

        phandlerdata->Release();
    }

    return hr;
}

HRESULT CNoContentDlg::_OnListSelChange()
{
    return _UpdateHandlerSettings();
}

LRESULT CNoContentDlg::OnOK(WORD wNotif)
{
    if (BST_CHECKED == Button_GetCheck(GetDlgItem(_hwnd, IDC_AP_MXCT_CHECKBOX)))
    {
        _SaveSettings(FALSE);

        // return value????
    }
    else
    {
        _SaveSettings(TRUE);
    }

    _SetHandler();

    // Do default processing
    return CBaseContentDlg::OnOK(wNotif);
}

HRESULT CNoContentDlg::_SaveSettings(BOOL fSoftCommit)
{
    _data._fSoftCommit = fSoftCommit;

    return _dlmanager.Commit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ascstr.h ===
#ifndef ASCSTR_H
#define ASCSTR_H

#include "ftcmmn.h"

#define ASENUM                          DWORD
#define ASENUM_NONE                     0x00000000
#define ASENUM_EXT                      0x00000001
#define ASENUM_PROGID                   0x00000002
#define ASENUM_ACTION                   0x00000004
#define ASENUM_ASSOC_YES                0x10000000
#define ASENUM_ASSOC_NO                 0x20000000
#define ASENUM_ASSOC_ALL                (ASENUM_ASSOC_YES | ASENUM_ASSOC_NO)
#define ASENUM_NOEXCLUDED               0x40000000
#define ASENUM_NOEXPLORERSHELLACTION    0x80000000
#define ASENUM_NOEXE                    0x01000000
#define ASENUM_SHOWONLY                 0x02000000

#define ASENUM_MAINMASK                 0x00000007


#define AIINIT                          DWORD
#define AIINIT_NONE                     0x00000000
#define AIINIT_EXT                      0x00000001
#define AIINIT_PROGID                   0x00000002
#define AIINIT_ACTION                   0x00000004

// Watch out! Begin
// All flags in this section can be OR'ed with the other flags AIBOOL, AISTR, ...
// so keep these values "globally" unique.
#define AIALL                           DWORD
#define AIALL_NONE                      0x00000000
#define AIALL_PERUSER                   0x10000000
// Watch out! End

#define AISTR                           DWORD
#define AISTR_NONE                      0x00000000
// This returns an extension WITHOUT the dot
#define AISTR_EXT                       0x00000001 
// This returns an extension WITH the dot
#define AISTR_DOTEXT                    0x00000002
#define AISTR_PROGID                    0x00000004
#define AISTR_PROGIDDESCR               0x00000008
#define AISTR_APPPATH                   0x00000010
#define AISTR_APPFRIENDLY               0x00000020
#define AISTR_ACTION                    0x00000040
#define AISTR_PROGIDDEFAULTACTION       0x00000080
#define AISTR_ICONLOCATION              0x00000100
#define AISTR_ACTIONFRIENDLY            0x00000200

#define AIDWORD                         DWORD
#define AIDWORD_NONE                    0x00000000
#define AIDWORD_APPSMALLICON            0x00000001
#define AIDWORD_APPLARGEICON            0x00000002
#define AIDWORD_DOCSMALLICON            0x00000004
#define AIDWORD_DOCLARGEICON            0x00000008
#define AIDWORD_PROGIDEDITFLAGS         0x00000010
#define AIDWORD_ACTIONATTRIBUTES        0x00000020

#define AIBOOL                          DWORD
#define AIBOOL_CONFIRMOPEN              0x00000001
// removed quick view constant - dsheldon
#define AIBOOL_ALWAYSSHOWEXT            0x00000004
#define AIBOOL_BROWSEINPLACE            0x00000008
#define AIBOOL_BROWSEINPLACEENABLED     0x00000010
#define AIBOOL_EDITDESCR                0x00000020
#define AIBOOL_EDITDOCICON              0x00000040
#define AIBOOL_EDIT                     0x00000080
#define AIBOOL_EDITREMOVE               0x00000100
#define AIBOOL_EXTASSOCIATED            0x00000200
#define AIBOOL_EXTEXIST                 0x00000400
#define AIBOOL_EXCLUDE                  0x00000800
#define AIBOOL_SHOW                     0x00001000
#define AIBOOL_PERUSERINFOAVAILABLE     0x00002000
#define AIBOOL_PROGIDHASNOEXT           0x00004000

#define AIDATA                          DWORD
#define AIDATA_PROGIDACTION             0x00000001

class IAssocInfo : public IUnknown
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG,Release)() PURE;

    // IAssocInfo methods
    //  Init
    STDMETHOD(Init)(AIINIT aiinitFlags, LPTSTR pszStr) PURE;
    STDMETHOD(InitComplex)(AIINIT aiinitFlags1, LPTSTR pszStr1,
        AIINIT aiinitFlags2, LPTSTR pszStr2) PURE;
    //  Get
    STDMETHOD(GetString)(AISTR aistrFlags, LPTSTR pszStr, DWORD* cchStr) PURE;
    STDMETHOD(GetDWORD)(AIDWORD aidwordFlags, DWORD* pdwdata) PURE;
    STDMETHOD(GetBOOL)(AIDWORD aiboolFlags, BOOL* pfBool) PURE;
    STDMETHOD(GetData)(AIDWORD aidataFlags, PBYTE pbData, DWORD* pcbData) PURE;
    //  Set
    STDMETHOD(SetString)(AISTR aistrFlags, LPTSTR pszStr) PURE;
    STDMETHOD(SetDWORD)(AIDWORD aidwordFlags, DWORD dwData) PURE;
    STDMETHOD(SetBOOL)(AIDWORD aiboolFlags, BOOL fBool) PURE;
    STDMETHOD(SetData)(AIDWORD aidataFlags, PBYTE pbData, DWORD cbData) PURE;
    //  Create
    STDMETHOD(Create)() PURE;
    //  Delete
    STDMETHOD(DelString)(AISTR aistrFlags) PURE;
    STDMETHOD(Delete)(AIALL aiallFlags) PURE;
};

class IEnumAssocInfo : public IUnknown
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // IEnumAssocInfo methods
    //  Initialization
    STDMETHOD(Init)(ASENUM asenumFlags, LPTSTR pszStr,
        AIINIT aiinitFlags) PURE;

    //  Standard IEnum methods
    STDMETHOD(Next)(IAssocInfo** ppAI) PURE;
    STDMETHOD(Skip)(DWORD dwSkip) PURE;
    STDMETHOD(Reset)() PURE;
    STDMETHOD(Clone)(IEnumAssocInfo* pEnum) PURE;
};

class IAssocStore : public IUnknown
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG,Release)() PURE;

    // IAssocStore methods
    //  Enum
    STDMETHOD(EnumAssocInfo)(ASENUM asenumFlags, LPTSTR pszStr, 
        AIINIT aiinitFlags, IEnumAssocInfo** ppEnum) PURE;
    //  Get/Set
    STDMETHOD(GetAssocInfo)(LPTSTR pszStr, AIINIT aiinitFlags, 
        IAssocInfo** ppAI) PURE;
    STDMETHOD(GetComplexAssocInfo)(LPTSTR pszStr1, AIINIT aiinitFlags1, 
        LPTSTR pszStr2, AIINIT aiinitFlags2, IAssocInfo** ppAI) PURE;
    // 
    STDMETHOD(CheckAccess)() PURE;
};

#endif //ASCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\assocarray.cpp ===
#include "shellprv.h"
#include <dpa.h>
#include <enumt.h>

typedef HRESULT (*PFNELEMCREATE)(const CLSID *pclsid, PCWSTR pszClass, IAssociationElement **ppae);

typedef struct _AEINFO
{
    ASSOCELEM_MASK mask;
    const CLSID *pclsid;
    PCWSTR pszClass;       //  NULL indicates to use the _pszClass
    PFNELEMCREATE pfnCreate;
    IAssociationElement *pae;
} AEINFO;

typedef enum
{
    GETELEM_RETRY       = -2,
    GETELEM_DONE        = -1,
    GETELEM_TRYNEXT     = 0,
    GETELEM_SUCCEEDED   = 1,
}GETELEMRESULT;

#define TRYNEXT(gr)     ((gr) >= GETELEM_TRYNEXT)


HRESULT _QueryString(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz, const IID *piid)
{
    return pae->QueryString(query, pszCue, ppsz);
}

HRESULT _QueryDirect(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, FLAGGED_BYTE_BLOB **ppblob, const IID *piid)
{
    return pae->QueryDirect(query, pszCue, ppblob);
}

HRESULT _QueryDword(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, DWORD *pdw, const IID *piid)
{
    return pae->QueryDword(query, pszCue, pdw);
}

HRESULT _QueryExists(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, void *pv, const IID *piid)
{
    return pae->QueryExists(query, pszCue);
}

HRESULT _QueryObject(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, void **ppv, const IID *piid)
{
    return pae->QueryObject(query, pszCue, *piid, ppv);
}


class CAssocArray : public IAssociationArray,
                    public IAssociationArrayInitialize,
                    public IQueryAssociations

{
public:
    CAssocArray() : _cRef(1), _hrInit(-1), _maskInclude(-1) {}
    ~CAssocArray() { _Reset(); }
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef()
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    //  IAssociationArrayInitialize
    STDMETHODIMP InitClassElements(
        ASSOCELEM_MASK maskBase, 
        PCWSTR pszClass);
        
    STDMETHODIMP InsertElements(
        ASSOCELEM_MASK mask, 
        IEnumAssociationElements *peae);

    STDMETHODIMP FilterElements(ASSOCELEM_MASK maskInclude)
        { _maskInclude = maskInclude; return S_OK; }
        
    //  IAssociationArray
    STDMETHODIMP EnumElements(
        ASSOCELEM_MASK mask, 
        IEnumAssociationElements **ppeae);

    STDMETHODIMP QueryString(
        ASSOCELEM_MASK mask, 
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz)
        {
            return _QueryElementAny(_QueryString, mask, query, pszCue, ppsz, NULL);
        }

    STDMETHODIMP QueryDword(
        ASSOCELEM_MASK mask, 
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        DWORD *pdw)
        {
            return _QueryElementAny(_QueryDword, mask, query, pszCue, pdw, NULL);
        }

    STDMETHODIMP QueryDirect(
        ASSOCELEM_MASK mask, 
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        FLAGGED_BYTE_BLOB **ppblob)
        {
            return _QueryElementAny(_QueryDirect, mask, query, pszCue, ppblob, NULL);
        }

    STDMETHODIMP QueryExists(
        ASSOCELEM_MASK mask, 
        ASSOCQUERY query, 
        PCWSTR pszCue)
        {
            return _QueryElementAny(_QueryExists, mask, query, pszCue, (void*)NULL, NULL);
        }

    STDMETHODIMP QueryObject(
        ASSOCELEM_MASK mask, 
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        REFIID riid,
        void **ppv)
        {
            return _QueryElementAny(_QueryObject, mask, query, pszCue, ppv, &riid);
        }

    // IQueryAssociations methods
    STDMETHODIMP Init(ASSOCF flags, LPCTSTR pszAssoc, HKEY hkProgid, HWND hwnd);
    STDMETHODIMP GetString(ASSOCF flags, ASSOCSTR str, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut);
    STDMETHODIMP GetKey(ASSOCF flags, ASSOCKEY, LPCWSTR pszExtra, HKEY *phkeyOut);
    STDMETHODIMP GetData(ASSOCF flags, ASSOCDATA data, LPCWSTR pszExtra, LPVOID pvOut, DWORD *pcbOut);
    STDMETHODIMP GetEnum(ASSOCF flags, ASSOCENUM assocenum, LPCWSTR pszExtra, REFIID riid, LPVOID *ppvOut)
        { return E_NOTIMPL; }


    GETELEMRESULT GetElement(int i, ASSOCELEM_MASK mask, IAssociationElement **ppae);

protected:  // methods
    void _Reset();
    HRESULT _InsertSingleElement(IAssociationElement *pae);
    HRESULT _GetCachedVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement **ppaeVerb, IAssociationElement **ppaeElem);
    void _SetCachedVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement *paeVerb, IAssociationElement *paeVerbParent);
    GETELEMRESULT _GetElement(int i, ASSOCELEM_MASK mask, IAssociationElement **ppae);
    BOOL _FirstElement(ASSOCELEM_MASK mask, IAssociationElement **ppae);
    HRESULT _GetVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement **ppaeVerb, IAssociationElement **ppaeElem);
    void _InitDelayedElements(int i, ASSOCELEM_MASK mask);
    template<class T> HRESULT _QueryElementAny(HRESULT (CALLBACK *pfnAny)(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, T pData, const IID *piid), ASSOCELEM_MASK mask, ASSOCQUERY query, PCWSTR pszCue, T pData, const IID *piid)
    {
        mask &= _maskInclude;
        IAssociationElement *pae;        
        HRESULT hr = E_FAIL;
        if ((AQF_CUEIS_SHELLVERB & query) && _CacheVerb(query))
        {
            //  delegate to the verb object if the cue is a verb
            //  except for AQVS_APPLICATION_FRIENDLYNAME which
            //  has some funky delegation issues.
            IAssociationElement *paeParent;        
            hr = _GetVerbElement(mask, pszCue, &pae, &paeParent);
            if (SUCCEEDED(hr))
            {
                if (query == AQVS_APPLICATION_FRIENDLYNAME)
                    hr = pfnAny(paeParent, query, pszCue, pData, piid);
                else
                    hr = pfnAny(pae, query, NULL, pData, piid);
                pae->Release();
                paeParent->Release();
            }
        }
        else
        {
            for (int i = 0; FAILED(hr) && TRYNEXT(GetElement(i, mask, &pae)); i++)
            {
                if (pae)
                {
                    hr = pfnAny(pae, query, pszCue, pData, piid);
                    pae->Release();
                    if (SUCCEEDED(hr))
                        break;
                }
            }
        }

        return hr;
    }

    BOOL _CacheVerb(ASSOCQUERY query)
    {
        //  if we are init'd with an app element and
        //  querying for app specific values dont request the verb element
        return !_fUsingAppElement || (query != AQVS_APPLICATION_PATH && query != AQVS_APPLICATION_FRIENDLYNAME && query != AQVO_APPLICATION_DELEGATE);
    }
    
private:  // members
    LONG _cRef;
    HRESULT _hrInit;
    PWSTR _pszClass;
    ASSOCELEM_MASK _maskInclude;
    BOOL _fUsingAppElement;
    CDSA<AEINFO> _dsaElems;
    IEnumAssociationElements *_penumData;
    ASSOCELEM_MASK _maskData;
    IEnumAssociationElements *_penumExtra;
    ASSOCELEM_MASK _maskExtra;
    IAssociationElement *_paeVerb;
    PWSTR _pszVerb;
    ASSOCELEM_MASK _maskVerb;
    IAssociationElement *_paeVerbParent;
};

int CALLBACK _AeinfoDelete(AEINFO *paei, void *pv)
{
    if (paei->pae)
        paei->pae->Release();
    return 1;        
}

void CAssocArray::_Reset()
{
    if (_hrInit != -1)
    {
        if (_dsaElems)
            _dsaElems.DestroyCallbackEx(_AeinfoDelete, (void*)NULL);
        if (_pszClass)
        {
            CoTaskMemFree(_pszClass);
            _pszClass = NULL;
        }
            
        ATOMICRELEASE(_penumData);
        ATOMICRELEASE(_penumExtra);
        ATOMICRELEASE(_paeVerb);
        if (_pszVerb)
        {
            LocalFree(_pszVerb);
            _pszVerb;
        }
        ATOMICRELEASE(_paeVerbParent);
        _fUsingAppElement = FALSE;
        _hrInit = -1;
    }
}

HRESULT CAssocArray::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAssocArray, IAssociationArray),
        QITABENT(CAssocArray, IQueryAssociations),
        QITABENT(CAssocArray, IAssociationArrayInitialize),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}


#define AEINFOPROGID(m, s)  { m, &CLSID_AssocProgidElement, s, AssocElemCreateForClass, NULL}
#define MAKEAEINFO(m, c, s, p)  { m, c, s, p, NULL}
HRESULT AssocElemCreateForUser(const CLSID *pclsid, PCWSTR pszClass, IAssociationElement **ppae)
{
    WCHAR sz[64];
    DWORD cb = sizeof(sz);
    HRESULT hr = SKGetValue(SHELLKEY_HKCU_FILEEXTS, pszClass, L"Progid", NULL, sz, &cb);
    if(SUCCEEDED(hr))
    {
        hr = AssocElemCreateForClass(&CLSID_AssocProgidElement, sz, ppae);
    }

    if (FAILED(hr))
    {
        cb = sizeof(sz);
        hr = SKGetValue(SHELLKEY_HKCU_FILEEXTS, pszClass, L"Application", NULL, sz, &cb);
        if (SUCCEEDED(hr))
        {
            hr = AssocElemCreateForClass(&CLSID_AssocApplicationElement, sz, ppae);
        }
    }

    return hr;
}

static const AEINFO s_rgaeinfoProgid[] =
{
    AEINFOPROGID(ASSOCELEM_DEFAULT, NULL),
};

static const AEINFO s_rgaeinfoExtension[] = 
{
    MAKEAEINFO(ASSOCELEM_USER, NULL, NULL, AssocElemCreateForUser),        //  app or progid
    AEINFOPROGID(ASSOCELEM_DEFAULT, NULL),
    MAKEAEINFO(ASSOCELEM_SYSTEM_EXT, &CLSID_AssocSystemElement, NULL, AssocElemCreateForClass),
    MAKEAEINFO(ASSOCELEM_SYSTEM_PERCEIVED, &CLSID_AssocPerceivedElement, NULL, AssocElemCreateForClass),
};

static const AEINFO s_rgaeinfoClsid[] = 
{
//    MAKEAEINFO(UserClsid),      //  clsid
    MAKEAEINFO(ASSOCELEM_DEFAULT, &CLSID_AssocClsidElement, NULL, AssocElemCreateForClass),
//    AEINFOPROGID(ASSOCELEM_PROGID, NULL),         //  progid
};

static const AEINFO s_aeinfoFolder = MAKEAEINFO(ASSOCELEM_BASEIS_FOLDER, &CLSID_AssocFolderElement, NULL, AssocElemCreateForClass);
static const AEINFO s_aeinfoStar = MAKEAEINFO(ASSOCELEM_BASEIS_STAR, &CLSID_AssocStarElement, NULL, AssocElemCreateForClass);

BOOL CAssocArray::_FirstElement(ASSOCELEM_MASK mask, IAssociationElement **ppae)
{
    GETELEMRESULT res = GETELEM_TRYNEXT;
    int cTrys = 0;
    while (res == GETELEM_TRYNEXT)
    {
        //  if it fails or succeeds we are done
        //  but if it calls TRYNEXT we loop
        res = GetElement(cTrys++, mask, ppae);
    }
    return res == GETELEM_SUCCEEDED;
}

HRESULT CAssocArray::InitClassElements(ASSOCELEM_MASK maskBase, PCWSTR pszClass)
{
    _Reset();
    //  depending on what we think this is, 
    //  we do things a little differently
    ASSERT(*pszClass);
    HRESULT hr = SHStrDup(pszClass, &_pszClass);
    if (SUCCEEDED(hr))
    {
        //  6 is the most that we will need
        //  in InitClassElements()
        hr = _dsaElems.Create(6) ? S_OK : E_OUTOFMEMORY;
        if (SUCCEEDED(hr))
        {
            const AEINFO *rgAeinfo;
            DWORD cAeinfo;
            if (*_pszClass == L'.')
            {
                rgAeinfo = s_rgaeinfoExtension;
                cAeinfo = ARRAYSIZE(s_rgaeinfoExtension);
            }
            else if (*_pszClass == L'{')
            {
                rgAeinfo = s_rgaeinfoClsid;
                cAeinfo = ARRAYSIZE(s_rgaeinfoClsid);
            }
            else
            {
                rgAeinfo = s_rgaeinfoProgid;
                cAeinfo = ARRAYSIZE(s_rgaeinfoProgid);
            }

            for (DWORD i = 0; i < cAeinfo; i++)
            {
                _dsaElems.AppendItem((AEINFO *)&rgAeinfo[i]);
            }

            if (ASSOCELEM_BASEIS_FOLDER & maskBase)
                _dsaElems.AppendItem((AEINFO *)&s_aeinfoFolder);
            
            if (ASSOCELEM_BASEIS_STAR & maskBase)
                _dsaElems.AppendItem((AEINFO *)&s_aeinfoStar);

            //  we return S_FALSE if there is no default or user 
            //  association.  we treat this as an unknown type
            IAssociationElement *pae;
            if (_FirstElement(ASSOCELEM_USER | ASSOCELEM_DEFAULT, &pae))
            {
                pae->Release();
                hr = S_OK;
            }
            else
                hr = S_FALSE;
        }
    }

    _hrInit = hr;
    return hr;
}
                
HRESULT CAssocArray::InsertElements(ASSOCELEM_MASK mask, IEnumAssociationElements *peae)
{
    HRESULT hr = E_UNEXPECTED;
    if (!_penumData && (mask & ASSOCELEM_DATA))
    {
        _penumData = peae;
        peae->AddRef();
        _maskData = mask;
            
        hr = S_OK;
    }
    if (!_penumExtra && (mask & ASSOCELEM_EXTRA))
    {
        _penumExtra = peae;
        peae->AddRef();
        _maskExtra = mask;
        hr = S_OK;
    }
    return hr;
}

class CEnumAssocElems : public CEnumAssociationElements 
{
public:
    CEnumAssocElems(CAssocArray *paa, ASSOCELEM_MASK mask) : _mask(mask), _paa(paa)
        {   _paa->AddRef(); }
        
    ~CEnumAssocElems()  { _paa->Release(); }
    
protected: // methods
    virtual BOOL _Next(IAssociationElement **ppae);

protected:    
    ASSOCELEM_MASK _mask;
    CAssocArray *_paa;
};

HRESULT CAssocArray::EnumElements(ASSOCELEM_MASK mask, IEnumAssociationElements **ppeae)
{
    mask &= _maskInclude;
    *ppeae = new CEnumAssocElems(this, mask);
    return *ppeae ? S_OK : E_OUTOFMEMORY;
}

void CAssocArray::_InitDelayedElements(int i, ASSOCELEM_MASK mask)
{
    ULONG c;
    IAssociationElement *pae;
    if (i == 0 && _penumData && ((mask & _maskData) == _maskData))
    {
        //  init the DSA with the data
        int iInsert = 0;
        while (S_OK == _penumData->Next(1, &pae, &c))
        {
            AEINFO ae = {ASSOCELEM_DATA, NULL, NULL, NULL, pae};
            if (DSA_ERR != _dsaElems.InsertItem(iInsert++, &ae))
            {
                pae->AddRef();
            }
            pae->Release();
        }

        ATOMICRELEASE(_penumData);
    }

    if (_penumExtra && (mask & ASSOCELEM_EXTRA) && i == _dsaElems.GetItemCount())
    {
        //  init the DSA with the data
        while (S_OK == _penumExtra->Next(1, &pae, &c))
        {
            AEINFO ae = {ASSOCELEM_EXTRA, NULL, NULL, NULL, pae};
            if (DSA_ERR != _dsaElems.AppendItem(&ae))
            {
                pae->AddRef();
            }
            pae->Release();
        }

        ATOMICRELEASE(_penumExtra);
    }
}

GETELEMRESULT CAssocArray::_GetElement(int i, ASSOCELEM_MASK mask, IAssociationElement **ppae)
{
    GETELEMRESULT res = GETELEM_DONE;
    AEINFO *paei = _dsaElems.GetItemPtr(i);
    if (paei)
    {
        //  if this is one that we want to use
        //  please do
        if (paei->mask & mask)
        {
            if (!paei->pae)
            {
                //  try to create only once
                PCWSTR pszClass = paei->pszClass ? paei->pszClass : _pszClass;
                //  make sure we dont query again
                //  if we dont need to
                HRESULT hr = paei->pfnCreate(paei->pclsid, pszClass, &paei->pae);
                if (FAILED(hr))
                {
                    _dsaElems.DeleteItem(i);
                    //  retry the current index
                    res = GETELEM_RETRY;
                }
                else if (hr == S_FALSE)
                {
                    //  this is returned when the element
                    //  is valid but points to an alternate location
                    //  specifically the HKCR\Progid falls back to HKCR\.ext
                    //  which is kind of weird.  maybe we should move this
                    //  to ASSOCELEM_EXTRA???
                }
                    
            }

            if (paei->pae)
            {
                *ppae = paei->pae;
                paei->pae->AddRef();
                res = GETELEM_SUCCEEDED;
            }
        }
        else
        {
            res = GETELEM_TRYNEXT;
        }
    }
    return res;
}

GETELEMRESULT CAssocArray::GetElement(int i, ASSOCELEM_MASK mask, IAssociationElement **ppae)
{
    GETELEMRESULT res = GETELEM_RETRY;
    *ppae = 0;
    if (_dsaElems)
    {
        _InitDelayedElements(i, mask);
        while (GETELEM_RETRY == res && i < _dsaElems.GetItemCount())
        {
            res = _GetElement(i, mask, ppae);
        } 
    }
    return res;
}

BOOL CEnumAssocElems::_Next(IAssociationElement **ppae)
{
    GETELEMRESULT res = GETELEM_TRYNEXT;
    UINT cTrys = 0;
    while (res == GETELEM_TRYNEXT)
    {
        //  if it fails or succeeds we are done
        //  but if it calls TRYNEXT we loop
        res = _paa->GetElement(_cNext + cTrys++, _mask, ppae);
    }
    //  fix up _cNext when we skip
    _cNext += cTrys - 1;
    return res == GETELEM_SUCCEEDED;
}

typedef struct
{
    ASSOCQUERY query;
    PCWSTR pszCue;
} AQXLATE;

#define MAKEAQX(a, q, s)    { q, s }

static const AQXLATE s_rgaqxStrings[] = 
{
    MAKEAQX(ASSOCSTR_COMMAND, AQVS_COMMAND, NULL),
    MAKEAQX(ASSOCSTR_EXECUTABLE, AQVS_APPLICATION_PATH, NULL),
    MAKEAQX(ASSOCSTR_FRIENDLYDOCNAME, AQS_FRIENDLYTYPENAME, NULL),   //  friendly name of the document type
    MAKEAQX(ASSOCSTR_FRIENDLYAPPNAME, AQVS_APPLICATION_FRIENDLYNAME, NULL),
    MAKEAQX(ASSOCSTR_NOOPEN, AQNS_NAMED_MUI_STRING, L"NoOpen"),
    MAKEAQX(ASSOCSTR_SHELLNEWVALUE, (ASSOCQUERY)0, NULL),
    MAKEAQX(ASSOCSTR_DDECOMMAND, AQVS_DDECOMMAND, NULL),
    MAKEAQX(ASSOCSTR_DDEIFEXEC, AQVS_DDEIFEXEC, NULL),
    MAKEAQX(ASSOCSTR_DDEAPPLICATION, AQVS_DDEAPPLICATION, NULL),
    MAKEAQX(ASSOCSTR_DDETOPIC, AQVS_DDETOPIC, NULL),
    MAKEAQX(ASSOCSTR_INFOTIP, AQNS_NAMED_MUI_STRING, L"InfoTip"),
    MAKEAQX(ASSOCSTR_QUICKTIP, AQNS_NAMED_MUI_STRING, L"QuickTip"),
    MAKEAQX(ASSOCSTR_TILEINFO, AQNS_NAMED_MUI_STRING, L"TileInfo"),
    MAKEAQX(ASSOCSTR_CONTENTTYPE, AQS_CONTENTTYPE, NULL),
    MAKEAQX(ASSOCSTR_DEFAULTICON, AQS_DEFAULTICON, NULL),
    MAKEAQX(ASSOCSTR_SHELLEXTENSION, AQNS_SHELLEX_HANDLER, NULL),
};

HRESULT _CopyOut(BOOL fNoTruncate, PCWSTR pszIn, PWSTR psz, DWORD *pcch)
{
    //  if caller doesnt want any return size, 
    //  the incoming pointer is actually the size of the buffer
    
    ASSERT(pcch);
    ASSERT(psz || !IS_INTRESOURCE(pcch));
    
    HRESULT hr;
    DWORD cch = IS_INTRESOURCE(pcch) ? PtrToUlong(pcch) : *pcch;
    DWORD cchStr = lstrlenW(pszIn);

    if (psz)
    {
        if (!fNoTruncate || cch > cchStr)
        {
            StrCpyNW(psz, pszIn, cch);
            hr = S_OK;
        }
        else
            hr = E_POINTER;
    }
    else
        hr = S_FALSE;
    
    //  return the number of chars written/required
    if (!IS_INTRESOURCE(pcch))
        *pcch = (hr == S_OK) ? lstrlen(psz) + 1 : cchStr + 1;

    return hr;
}

ASSOCELEM_MASK _MaskFromFlags(ASSOCF flags)
{
    ASSOCELEM_MASK mask = ASSOCELEM_MASK_QUERYNORMAL;

    if (flags & ASSOCF_IGNOREBASECLASS)
        mask &= (ASSOCELEM_USER | ASSOCELEM_DEFAULT);

    if (flags & ASSOCF_NOUSERSETTINGS)
        mask &= ~ASSOCELEM_USER;

    return mask;
}

HRESULT CAssocArray::GetString(ASSOCF flags, ASSOCSTR str, LPCTSTR pszCue, LPTSTR pszOut, DWORD *pcchOut)
{
    HRESULT hr = E_UNEXPECTED;
    if (str && str < ASSOCSTR_MAX && pcchOut && (pszOut || !IS_INTRESOURCE(pcchOut)))
    {
        //  subtract the first one to make a zero based offset
        int index = str - ASSOCSTR_COMMAND;
        if (!pszCue)
            pszCue = s_rgaqxStrings[index].pszCue;            

        if (s_rgaqxStrings[index].query)
        {
            PWSTR psz;
            hr = QueryString(_MaskFromFlags(flags), s_rgaqxStrings[index].query, pszCue, &psz);
            if (SUCCEEDED(hr))
            {
                hr = _CopyOut(flags & ASSOCF_NOTRUNCATE, psz, pszOut, pcchOut);
                CoTaskMemFree(psz);
            }
        }
        //  else call win2k code for shellnew?
        //  
    }
    
    return hr; 
}

static const AQXLATE s_rgaqxDatas[] = 
{
    MAKEAQX(ASSOCDATA_MSIDESCRIPTOR, AQVD_MSIDESCRIPTOR, NULL),
    MAKEAQX(ASSOCDATA_NOACTIVATEHANDLER, AQV_NOACTIVATEHANDLER, NULL),
    MAKEAQX(ASSOCDATA_QUERYCLASSSTORE, AQN_NAMED_VALUE, L"QueryClassStore"),
    MAKEAQX(ASSOCDATA_HASPERUSERASSOC, (ASSOCQUERY)0, NULL),
    MAKEAQX(ASSOCDATA_EDITFLAGS, AQN_NAMED_VALUE, L"EditFlags"),
    MAKEAQX(ASSOCDATA_VALUE, AQN_NAMED_VALUE, NULL),
};

HRESULT _CopyDataOut(BOOL fNoTruncate, FLAGGED_BYTE_BLOB *pblob, void *pv, DWORD *pcb)
{
    //  if caller doesnt want any return size, 
    //  the incoming pointer is actually the size of the buffer
    ASSERT(pcb);
    ASSERT(pv || !IS_INTRESOURCE(pcb));
    
    HRESULT hr;
    DWORD cb = IS_INTRESOURCE(pcb) ? PtrToUlong(pcb) : *pcb;
    if (pv)
    {
        if (!fNoTruncate || cb >= pblob->clSize)
        {
            //  copy the smaller of the src or dst
            cb = min(cb, pblob->clSize);
            memcpy(pv, pblob->abData, cb);
            hr = S_OK;
        }
        else
            hr = E_POINTER;
    }
    else
        hr = S_FALSE;
    
    //  return the number of chars written/required
    if (!IS_INTRESOURCE(pcb))
        *pcb = pblob->clSize;

    return hr;
}

HRESULT CAssocArray::GetData(ASSOCF flags, ASSOCDATA data, PCWSTR pszCue, LPVOID pvOut, DWORD *pcbOut)
{
    HRESULT hr = E_INVALIDARG;
    if (data && data < ASSOCDATA_MAX)
    {
        //  subtract the first one to make a zero based offset
        int index = data - ASSOCDATA_MSIDESCRIPTOR;
        if (!pszCue)
            pszCue = s_rgaqxDatas[index].pszCue;            

        if (s_rgaqxDatas[index].query)
        {
            if (pcbOut)
            {
                FLAGGED_BYTE_BLOB *pblob;            
                hr = QueryDirect(_MaskFromFlags(flags), s_rgaqxDatas[index].query, pszCue, &pblob);
                if (SUCCEEDED(hr))
                {
                    hr = _CopyDataOut(flags & ASSOCF_NOTRUNCATE, pblob, pvOut, pcbOut);
                    CoTaskMemFree(pblob);
                }
            }
            else
            {
                hr = QueryExists(_MaskFromFlags(flags), s_rgaqxDatas[index].query, pszCue);
            }
        }
        else
        {
            if (data == ASSOCDATA_HASPERUSERASSOC)
            {
                IAssociationElement *pae;
                if (_FirstElement(ASSOCELEM_USER, &pae))
                {
                    pae->Release();
                    hr = S_OK;
                }
                else
                    hr = S_FALSE;
            }
        }
                
            
    }
    
    return hr;
}

BOOL _IsSameVerb(PCWSTR pszV1, PCWSTR pszV2)
{
    if (!pszV1 && !pszV2)
        return TRUE;
    else if (pszV1 && pszV2 && 0 == StrCmpIW(pszV1, pszV2))
        return TRUE;
    return FALSE;
}

HRESULT CAssocArray::_GetCachedVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement **ppaeVerb, IAssociationElement **ppaeElem)
{
    if (_paeVerb
    && mask == _maskVerb
    && _IsSameVerb(pszVerb, _pszVerb))
    {
        *ppaeVerb = _paeVerb;
        _paeVerb->AddRef();

        if (ppaeElem)
        {
            *ppaeElem = _paeVerbParent;
            _paeVerbParent->AddRef();
        }
        return S_OK;
    }
    else
    {
        *ppaeVerb = NULL;

        if (ppaeElem)
            *ppaeElem = NULL;
        return E_FAIL;
    }
}

void CAssocArray::_SetCachedVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement *paeVerb, IAssociationElement *paeVerbParent)
{
    if (_paeVerb)
    {
        ATOMICRELEASE(_paeVerb);
        ATOMICRELEASE(_paeVerbParent);
        if (_pszVerb)
            LocalFree(_pszVerb);
    }

    if (pszVerb)
        _pszVerb = StrDupW(pszVerb);
    else
        _pszVerb = NULL;

    if (_pszVerb || !pszVerb)
    {
        _paeVerb = paeVerb;
        _paeVerb->AddRef();
        _paeVerbParent = paeVerbParent;
        _paeVerbParent->AddRef();
        _maskVerb = mask;
    }
}
        
HRESULT CAssocArray::_GetVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement **ppaeVerb, IAssociationElement **ppaeElem)
{
    HRESULT hr = _GetCachedVerbElement(mask, pszVerb, ppaeVerb, ppaeElem);
    IAssociationElement *pae;
    for (int i = 0; FAILED(hr) && TRYNEXT(GetElement(i, mask, &pae)); i++)
    {
        if (pae)
        {
            hr = pae->QueryObject(AQVO_SHELLVERB_DELEGATE, pszVerb, IID_PPV_ARG(IAssociationElement, ppaeVerb));
            if (SUCCEEDED(hr))
            {
                _SetCachedVerbElement(mask, pszVerb, *ppaeVerb, pae);
                if (ppaeElem)
                {
                    pae->AddRef();
                    *ppaeElem = pae;
                }
            }
            pae->Release();
        }
    }
    return hr;
}

HRESULT CAssocArray::GetKey(ASSOCF flags, ASSOCKEY key, LPCTSTR pszCue, HKEY *phkey)
{
    HRESULT hr = E_INVALIDARG;
    *phkey = NULL;

    if (key && key < ASSOCKEY_MAX)
    {
        IAssociationElement *pae;
        switch (key)
        {
        case ASSOCKEY_SHELLEXECCLASS:    
            {
                IAssociationElement *paeVerb;
                hr = _GetVerbElement(_MaskFromFlags(flags) & _maskInclude, pszCue, &paeVerb, &pae);
                if (SUCCEEDED(hr))
                {
                    //  we dont use the verb element
                    paeVerb->Release();
                }
            }
            break;

        case ASSOCKEY_APP:
            //  get app element
            hr = QueryObject(ASSOCELEM_MASK_QUERYNORMAL, AQVO_APPLICATION_DELEGATE, pszCue, IID_PPV_ARG(IAssociationElement, &pae));
            break;
            
        case ASSOCKEY_CLASS:
            {
                hr = _FirstElement(_MaskFromFlags(flags) & _maskInclude, &pae) == GETELEM_SUCCEEDED ? S_OK : E_FAIL;
            }
            break;

        case ASSOCKEY_BASECLASS:
            hr = _FirstElement(ASSOCELEM_BASE & _maskInclude, &pae) == GETELEM_SUCCEEDED ? S_OK : E_FAIL;
            break;
        }

        if (SUCCEEDED(hr))
        {
            hr = AssocKeyFromElement(pae, phkey);
            pae->Release();
        }
    }
    return hr;
}            

HRESULT CAssocArray::_InsertSingleElement(IAssociationElement *pae)
{
    AEINFO ae = {ASSOCELEM_DEFAULT, NULL, NULL, NULL, pae};
    ASSERT(!_dsaElems);
    if (_dsaElems.Create(1) && (DSA_ERR != _dsaElems.AppendItem(&ae)))
    {
        pae->AddRef();
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CAssocArray::Init(ASSOCF flags, LPCTSTR pszAssoc, HKEY hkProgid, HWND hwnd)
{
    IAssociationElement *pae;
    HRESULT hr = (pszAssoc || hkProgid) ? S_OK : E_INVALIDARG;
    if (SUCCEEDED(hr))
    {
        _Reset();
        _fUsingAppElement = flags & ASSOCF_INIT_BYEXENAME;
        
        if (hkProgid)
        {
            const CLSID *pclsid;
            if (_fUsingAppElement)
                pclsid = &CLSID_AssocApplicationElement;
            else if (flags & ASSOCF_INIT_NOREMAPCLSID)
                pclsid = &CLSID_AssocClsidElement;
            else
                pclsid = &CLSID_AssocProgidElement;
            
            hr = AssocElemCreateForKey(pclsid, hkProgid, &pae);
            if (SUCCEEDED(hr))
            {
                hr = _InsertSingleElement(pae);
                pae->Release();
            }
        }
        else if (_fUsingAppElement)
        {
            ASSERT(pszAssoc);
            hr = AssocElemCreateForClass(&CLSID_AssocApplicationElement, pszAssoc, &pae);
            if (SUCCEEDED(hr))
            {
                hr = _InsertSingleElement(pae);
                pae->Release();
            }
        }
        else
        {
            ASSERT(pszAssoc);
            ASSOCELEM_MASK maskBase = 0;
            if (flags & ASSOCF_INIT_DEFAULTTOFOLDER)
                maskBase |= ASSOCELEM_BASEIS_FOLDER;
            if (flags & ASSOCF_INIT_DEFAULTTOSTAR)
                maskBase |= ASSOCELEM_BASEIS_STAR;

            if (StrChr(pszAssoc, TEXT('\\')))
                pszAssoc = PathFindExtension(pszAssoc);

            if (*pszAssoc)
                hr = InitClassElements(maskBase, pszAssoc);
            else
                hr = E_INVALIDARG;
        }
    }
    _hrInit = hr;
    return hr;
}

STDAPI CQueryAssociations_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{

    HRESULT hr = E_INVALIDARG;

    if (ppv)
    {
        *ppv = NULL;

        if (punkOuter)
            return CLASS_E_NOAGGREGATION;        

        CAssocArray *passoc = new CAssocArray();

        if (passoc)
        {
            hr = passoc->QueryInterface(riid, ppv);
            passoc->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\autocm.cpp ===
#include "shellprv.h"
#include "clsobj.h"
#include "dpa.h"
#include "ids.h"
#include "ole2dup.h"

/////////////////////////////////////////////////////////////////////////////
// CAutomationCM

class CAutomationCM :
    public IContextMenu,
    public IShellExtInit,
    public IPersistPropertyBag
{

public:

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);
    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO pici);
    STDMETHOD(GetCommandString)(THIS_
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax);

    // *** IShellExtInit methods ***
    STDMETHOD(Initialize)(THIS_
                          LPCITEMIDLIST pidlFolder,
                          IDataObject *pdtobj,
                          HKEY hkeyProgID) { return S_OK; }

    // *** IPersist methods ***
    STDMETHOD(GetClassID)(THIS_
                    CLSID *pclsid);


    // *** IPersistPropertyBag methods ***
    STDMETHOD(InitNew)(THIS);
    STDMETHOD(Load)(THIS_
                    IPropertyBag *pbg,
                    IErrorLog *plog);
    STDMETHOD(Save)(THIS_
                    IPropertyBag *pbg,
                    BOOL fClearDirty,
                    BOOL FSaveAllProperties) { return E_NOTIMPL; }

public:
    CAutomationCM() : _cRef(1) { }
private:
    ~CAutomationCM();

    static BOOL _DestroyVARIANTARG(VARIANTARG *pvarg, LPVOID)
    {
        ::VariantClear(pvarg);
        return TRUE;
    }

    enum {
        // Any method with more than MAXPARAMS parameters should be taken
        // outside and shot.
        // Note: If you change MAXPARAMS, make sure that szParamN[] is
        // big enough in IPersistPropertyBag::Load.
        MAXPARAMS = 1000,
    };

    LONG        _cRef;
    IDispatch * _pdisp;
    BSTR        _bsProperties;
    DISPID      _dispid;
    BOOL        _fInitialized;
    DISPPARAMS  _dp;
    CDSA<VARIANTARG> _dsaVarg;
    TCHAR       _szCommandName[MAX_PATH];
    TCHAR       _szMenuItem[MAX_PATH];
};

STDAPI CAutomationCM_CreateInstance(IUnknown * punkOuter, REFIID riid, void ** ppvOut)
{
    // clsobj.c should've filtered out the aggregated scenario already
    ASSERT(punkOuter == NULL);

    *ppvOut = NULL;
    CAutomationCM *pauto = new CAutomationCM;
    if (!pauto)
        return E_OUTOFMEMORY;

    HRESULT hr = pauto->QueryInterface(riid, ppvOut);
    pauto->Release();
    return hr;
}

CAutomationCM::~CAutomationCM()
{
    InitNew();
    ASSERT(!_dsaVarg);
}

// *** IUnknown::QueryInterface ***
HRESULT CAutomationCM::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =  {
        QITABENT(CAutomationCM, IContextMenu),          // IID_IContextMenu
        QITABENT(CAutomationCM, IShellExtInit),         // IID_IShellExtInit
        QITABENT(CAutomationCM, IPersist),              // IID_IPersist (base for IPersistPropertyBag)
        QITABENT(CAutomationCM, IPersistPropertyBag),   // IID_IPersistPropertyBag
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// *** IUnknown::AddRef ***
STDMETHODIMP_(ULONG) CAutomationCM::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

// *** IUnknown::Release ***
STDMETHODIMP_(ULONG) CAutomationCM::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// *** IPersist::GetClassID ***
HRESULT CAutomationCM::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_AutomationCM;
    return S_OK;
}

// *** IPersistPropertyBag::InitNew ***
HRESULT CAutomationCM::InitNew()
{
    ATOMICRELEASE(_pdisp);

    ::SysFreeString(_bsProperties);
    _bsProperties = NULL;

    // Free the DISPPARAMs
    if (_dsaVarg)
    {
        _dsaVarg.DestroyCallback(_DestroyVARIANTARG, 0);
    }
    _dp.cArgs = 0;

    _fInitialized = FALSE;

    return S_OK;
}

//
//  Property bag items:
//
//  CLSID = object to CoCreate(IID_IDispatch)
//  command = display name of command
//  method = name of method (GetIDsOfNames)
//  param1 .. paramN = parameters (up to MAXPARAMS)
//
//  Parameters are passed as BSTRs (or whatever type SHPropertyBagOnRegKey
//  returns.)
//
//  It is the responsibility of the target IDispatch to coerce the types
//  as appropriate.
//

// *** IPersistPropertyBag::Load ***
HRESULT CAutomationCM::Load(IPropertyBag *pbag, IErrorLog *plog)
{
    HRESULT hr;

    // Erase any old state
    InitNew();

    // Get the CLSID we are dispatching through
    CLSID clsid;
    hr = SHPropertyBag_ReadGUID(pbag, L"CLSID", &clsid);
    if (SUCCEEDED(hr))
    {
        // Must use SHExCoCreateInstance to go through the approval/app compat layer
        hr = SHExtCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IDispatch, &_pdisp));
    }

    // Map the method to a DISPID
    if (SUCCEEDED(hr))
    {
        BSTR bs;
        hr = SHPropertyBag_ReadBSTR(pbag, L"method", &bs);
        if (SUCCEEDED(hr))
        {
            LPOLESTR pname = bs;
            hr = _pdisp->GetIDsOfNames(IID_NULL, &pname, 1, 0, &_dispid);
            ::SysFreeString(bs);
        }
    }

    // Read in the parameters
    if (SUCCEEDED(hr))
    {
        if (_dsaVarg.Create(4))
        {
            WCHAR szParamN[16]; // worst-case: "param1000"
            VARIANT var;

            while (_dsaVarg.GetItemCount() < MAXPARAMS)
            {
                wnsprintfW(szParamN, ARRAYSIZE(szParamN), L"param%d",
                           _dsaVarg.GetItemCount()+1);
                VariantInit(&var);
                var.vt = VT_BSTR;
                if (FAILED(pbag->Read(szParamN, &var, NULL)))
                {
                    // No more parameters
                    break;
                }
                if (_dsaVarg.AppendItem((VARIANTARG*)&var) < 0)
                {
                    ::VariantClear(&var);
                    hr =  E_OUTOFMEMORY;
                    break;
                }
            }
        }
        else
        {
            // Could not create _dsaVarg
            hr = E_OUTOFMEMORY;
        }
    }

    // Get the command name
    if (SUCCEEDED(hr))
    {
        hr = SHPropertyBag_ReadStr(pbag, L"command", _szCommandName, ARRAYSIZE(_szCommandName));
        if (SUCCEEDED(hr))
        {
            hr = SHLoadIndirectString(_szCommandName, _szCommandName, ARRAYSIZE(_szCommandName), NULL);
        }
    }

    // Get the properties string (optional)
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(SHPropertyBag_ReadBSTR(pbag, L"properties", &_bsProperties)))
        {
            ASSERT(_bsProperties);

            // Ignore failure here; we'll detect it later
            SHPropertyBag_ReadStr(pbag, L"propertiestext", _szMenuItem, ARRAYSIZE(_szMenuItem));
            SHLoadIndirectString(_szMenuItem, _szMenuItem, ARRAYSIZE(_szMenuItem), NULL);
        }
    }

    _fInitialized = SUCCEEDED(hr);
    return hr;
}

// *** IContextMenu::QueryContextMenu ***
HRESULT CAutomationCM::QueryContextMenu(
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags)
{
    if (!_fInitialized) return E_FAIL;

    HRESULT hr;

    // Must have room for two items (the command and possibly also Properties)
    if (idCmdFirst + 1 <= idCmdLast)
    {
        if (InsertMenuW(hmenu, indexMenu, MF_BYPOSITION | MF_STRING,
                        idCmdFirst, _szCommandName))
        {
            if (_szMenuItem[0])
            {
                InsertMenuW(hmenu, indexMenu+1, MF_BYPOSITION | MF_STRING,
                            idCmdFirst+1, _szMenuItem);
            }
        }
        hr = ResultFromShort(2); // number of items added
    }
    else
    {
        hr = E_FAIL; // unable to add items
    }

    return hr;
}

const LPCSTR c_rgAutoCMCommands[] = {
    "open",                     // command 0
    "properties",               // command 1 - optional
};

// *** IContextMenu::InvokeCommand ***
HRESULT CAutomationCM::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    if (!_fInitialized) return E_FAIL;

    HRESULT hr;

    int iCmd;

    if (!IS_INTRESOURCE(pici->lpVerb))
    {
        // If this loop fails to find a match, iCmd will be out of range
        // and will hit the "default:" in the switch statement below.
        for (iCmd = 0; iCmd < ARRAYSIZE(c_rgAutoCMCommands) - 1; iCmd++)
        {
            if (lstrcmpiA(pici->lpVerb, c_rgAutoCMCommands[iCmd]) == 0)
            {
                break;
            }
        }
    }
    else
    {
        iCmd = PtrToLong(pici->lpVerb);
    }

    switch (iCmd)
    {
    case 0:                     // open
        _dp.cArgs = _dsaVarg.GetItemCount();
        _dp.rgvarg = _dp.cArgs ? _dsaVarg.GetItemPtr(0) : NULL;
        hr = _pdisp->Invoke(_dispid, IID_NULL, 0, DISPATCH_METHOD, &_dp, NULL, NULL, NULL);
        break;

    case 1:
        if (_bsProperties)
        {
            hr = ShellExecCmdLine(pici->hwnd, _bsProperties,
                                  NULL, SW_SHOWNORMAL, NULL, 0) ? S_OK : E_FAIL;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}

// *** IContextMenu::GetCommandString ***
HRESULT CAutomationCM::GetCommandString(
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax)
{
    if (!_fInitialized) return E_FAIL;
    switch (uType)
    {
    case GCS_VERBA:
        if (idCmd < ARRAYSIZE(c_rgAutoCMCommands))
        {
            SHAnsiToAnsi(c_rgAutoCMCommands[idCmd], (LPSTR)pszName, cchMax);
            return S_OK;
        }
        break;

    case GCS_VERBW:
        if (idCmd < ARRAYSIZE(c_rgAutoCMCommands))
        {
            SHAnsiToUnicode(c_rgAutoCMCommands[idCmd], (LPWSTR)pszName, cchMax);
            return S_OK;
        }
        break;
    }

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\atldisp.h ===
#ifndef __ATL_IDISPATCH_H__
#define __ATL_IDISPATCH_H__

#include "unicpp/stdafx.h"

extern LCID g_lcidLocale;


#pragma pack(push, _ATL_PACKING)

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif // ATL_NO_NAMESPACE



template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE CShell32AtlIDispatch
                    : public IOleObjectImpl<T>
{
public:
    CShell32AtlIDispatch();
    ~CShell32AtlIDispatch();

    // *** IDispatch ***
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);

    // *** IProvideClassInfo ***
    virtual STDMETHODIMP GetClassInfo(ITypeInfo** pptinfo);

    // *** IOleObject ***
    virtual STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);

    virtual STDMETHODIMP DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent, HWND hwnd);
    virtual STDMETHODIMP TranslateAcceleratorPriv(T * pThis, MSG *pMsg, IOleClientSite * pocs);

    virtual STDMETHODIMP PrivateQI(REFIID iid, void ** ppvObject) = 0;

protected:
    // Helper functions;
    ITypeInfo *         _pClassTypeInfo;             // ITypeInfo of class
    IFileSearchBand *   _pdisp;                      // This will not contain a ref because it's equal to 'this'.
};


template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
CShell32AtlIDispatch<T, pclsid, piid, plibid, wMajor, wMinor, tihclass>::CShell32AtlIDispatch()
{
    // This allocator should have zero inited the memory, so assert the member variables are empty.
    ASSERT(!_pClassTypeInfo);
}

template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
CShell32AtlIDispatch<T, pclsid, piid, plibid, wMajor, wMinor, tihclass>::~CShell32AtlIDispatch()
{
    if (_pClassTypeInfo)
        _pClassTypeInfo->Release();

    // _pdisp doesn't have a ref so it's OK if it's not NULL.
}


// *** IProvideClassInfo ***
template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, wMajor, wMinor, tihclass>::GetClassInfo(ITypeInfo ** ppTI)
{
    if (!_pClassTypeInfo) 
        GetTypeInfoFromLibId(LANGIDFROMLCID(g_lcidLocale), LIBID_Shell32, 1, 0, *pclsid, &_pClassTypeInfo);

    if (_pClassTypeInfo)
    {
        _pClassTypeInfo->AddRef();
        *ppTI = _pClassTypeInfo;
        return S_OK;
    }

    *ppTI = NULL;
    return E_FAIL;
}


// *** IDispatch ***
template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, wMajor, wMinor, tihclass>::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo)
{
    HRESULT hr = S_OK;

    *ppITypeInfo = NULL;

    if (0 != itinfo)
        return(TYPE_E_ELEMENTNOTFOUND);

    //Load a type lib if we don't have the information already.
    if (NULL == *ppITypeInfo)
    {
        ITypeInfo * pITIDisp;

        hr = GetTypeInfoFromLibId(lcid, LIBID_Shell32, 1, 0, *piid, &pITIDisp);

        if (SUCCEEDED(hr))
        {
            HRESULT hrT;
            HREFTYPE hrefType;

            // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
            // returns the ITypeInfo of the IDispatch-part only. We need to
            // find the ITypeInfo for the dual interface-part.
            //
            hrT = pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType);
            if (SUCCEEDED(hrT))
                hrT = pITIDisp->GetRefTypeInfo(hrefType, ppITypeInfo);

            ASSERT(SUCCEEDED(hrT));
            pITIDisp->Release();
        }
    }

    return hr;
}


template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, wMajor, wMinor, tihclass>::GetIDsOfNames(REFIID // riid
    , LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{
    ITypeInfo* pInfo;
    HRESULT hr = GetTypeInfo(0, lcid, &pInfo);

    if (pInfo != NULL)
    {
        hr = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
        pInfo->Release();
    }

    return hr;
}

template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, wMajor, wMinor, tihclass>::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    HRESULT hr = E_FAIL;
    DISPPARAMS dispparams = {0};

    if (!pdispparams)
        pdispparams = &dispparams;  // otherwise OLE Fails when passed NULL.

    // make sure we have an interface to hand off to Invoke
    if (NULL == _pdisp)
    {
        hr = PrivateQI(*piid, (LPVOID*)&_pdisp);
        ASSERT(SUCCEEDED(hr));

        // don't hold a refcount on ourself
        _pdisp->Release();
    }

    ITypeInfo * pITypeInfo;
    hr = GetTypeInfo(0, lcid, &pITypeInfo);
    if (SUCCEEDED(hr))
    {
        //Clear exceptions
        SetErrorInfo(0L, NULL);

        hr = pITypeInfo->Invoke(_pdisp, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        pITypeInfo->Release();
    }

    return hr;
}


#define DW_MISC_STATUS (OLEMISC_SETCLIENTSITEFIRST | OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_RECOMPOSEONRESIZE | \
                        OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT)

template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, wMajor, wMinor, tihclass>::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    *pdwStatus = DW_MISC_STATUS;
    return S_OK;
}


template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, wMajor, wMinor, tihclass>::DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent, HWND hwnd)
{
    HRESULT hr = IOleObjectImpl<T>::DoVerbUIActivate(prcPosRect, hwndParent);
    
    if (hwnd)
        ::SetFocus(hwnd);

    return hr;
}


template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, wMajor, wMinor, tihclass>::TranslateAcceleratorPriv(T * pThis, MSG *pMsg, IOleClientSite * pocs)
{
    HRESULT hr = S_FALSE;

    if (!EVAL(pMsg))
        return E_INVALIDARG;

    hr = pThis->T::TranslateAcceleratorInternal(pMsg, pocs);
    if (FAILED(hr))
    {
        if (WM_KEYDOWN == pMsg->message)
        {
            switch (pMsg->wParam)
            {
            // We can't handle RETURN because the script wants that
            // for post and other reasons
            //case VK_RETURN:
            case VK_ESCAPE:
            case VK_END:
            case VK_HOME:
            case VK_LEFT:
            case VK_UP:
            case VK_RIGHT:
            case VK_DOWN:
            case VK_DELETE:
                if (TranslateMessage(pMsg))
                {
                    DispatchMessage(pMsg);
                    hr = S_OK;
                }
                break;
            case VK_TAB:
                {
                    CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(pocs);
                    if (EVAL(spSite))
                        hr = spSite->TranslateAccelerator(pMsg, 0);
                }
                break;
            default:
                break;
            }
        }

        if (S_OK != hr)
        {
            // We didn't handle it so give our base class a chances.
            hr = pThis->IOleInPlaceActiveObjectImpl<T>::TranslateAccelerator(pMsg);
        }
    }

    return hr;
}


#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif // ATL_NO_NAMESPACE


#endif // __ATL_IDISPATCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\balmsg.cpp ===
#include "shellprv.h"

#define BALLOON_SHOW_TIME       15000   // 15 sec
#define BALLOON_REPEAT_DELAY    10000   // 10 sec

#define WM_NOTIFY_MESSAGE   (WM_USER + 100)

#define IDT_REMINDER    1
#define IDT_DESTROY     2
#define IDT_QUERYCANCEL 3
#define IDT_NOBALLOON   4

class CUserNotification : public IUserNotification
{
public:
    CUserNotification();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IUserNotification
    STDMETHODIMP SetBalloonInfo(LPCWSTR pszTitle, LPCWSTR pszText, DWORD dwInfoFlags);
    STDMETHODIMP SetBalloonRetry(DWORD dwShowTime, DWORD dwInterval, UINT cRetryCount);
    STDMETHODIMP SetIconInfo(HICON hIcon, LPCWSTR pszToolTip);
    STDMETHODIMP Show(IQueryContinue *pqc, DWORD dwContinuePollInterval);
    STDMETHODIMP PlaySound(LPCWSTR pszSoundName);

private:
    ~CUserNotification();
    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CALLBACK _WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _GetWindow();
    BOOL _SyncInfo();
    BOOL _SyncIcon();
    void _DelayDestroy(HRESULT hrDone);
    void _Timeout();
    void _RemoveNotifyIcon();

    LONG _cRef;
    HWND _hwnd;
    HICON _hicon;
    DWORD _dwShowTime;
    DWORD _dwInterval;
    UINT _cRetryCount;
    HRESULT _hrDone;
    DWORD _dwContinuePollInterval;
    IQueryContinue *_pqc;

    DWORD _dwInfoFlags;
    WCHAR *_pszTitle;
    WCHAR *_pszText;
    WCHAR *_pszToolTip;
};

CUserNotification::CUserNotification()
    : _cRef(1), _cRetryCount(-1), _dwShowTime(BALLOON_SHOW_TIME),
      _dwInterval(BALLOON_REPEAT_DELAY), _dwInfoFlags(NIIF_NONE)
{
}

CUserNotification::~CUserNotification()
{
    Str_SetPtrW(&_pszToolTip, NULL);
    Str_SetPtrW(&_pszTitle, NULL);
    Str_SetPtrW(&_pszText, NULL);

    if (_hwnd)
    {
        _RemoveNotifyIcon();
        DestroyWindow(_hwnd);
    }

    if (_hicon)
        DestroyIcon(_hicon);
}

STDMETHODIMP_(ULONG) CUserNotification::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CUserNotification::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CUserNotification::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CUserNotification, IUserNotification),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

HRESULT CUserNotification::SetBalloonInfo(LPCWSTR pszTitle, LPCWSTR pszText, DWORD dwInfoFlags)
{
    Str_SetPtrW(&_pszTitle, pszTitle);
    Str_SetPtrW(&_pszText, pszText);
    _dwInfoFlags = dwInfoFlags;
    _SyncInfo();    // may fail if balloon _hwnd has not been created yet

    return S_OK;
}

HRESULT CUserNotification::SetBalloonRetry(DWORD dwShowTime, DWORD dwInterval, UINT cRetryCount)
{
    if (-1 != dwShowTime)
        _dwShowTime = dwShowTime;

    if (-1 != dwInterval)
        _dwInterval = dwInterval;

    _cRetryCount = cRetryCount;
    return S_OK;
}

HRESULT CUserNotification::SetIconInfo(HICON hIcon, LPCWSTR pszToolTip)
{
    if (_hicon)
        DestroyIcon(_hicon);

    if (hIcon == NULL)
    {
        _hicon = NULL;
        switch(_dwInfoFlags & NIIF_ICON_MASK)
        {
            case NIIF_INFO:
                _hicon = LoadIcon(NULL, IDI_INFORMATION);
                break;
            case NIIF_WARNING:
                _hicon = LoadIcon(NULL, IDI_WARNING);
                break;
            case NIIF_ERROR:
                _hicon = LoadIcon(NULL, IDI_ERROR);
                break;
        }
    }
    else
    {
        _hicon = CopyIcon(hIcon);
    }

    Str_SetPtrW(&_pszToolTip, pszToolTip);
    _SyncIcon();

    return S_OK;
}

// returns:
//      S_OK        
//          user clicked on the balloon or icon
//      S_FALSE     
//          query continue callback (pcq) cancelled the notification UI
//      HRESULT_FROM_WIN32(ERROR_CANCELLED)
//          timeouts expired (user ignored the UI)
HRESULT CUserNotification::Show(IQueryContinue *pqc, DWORD dwContinuePollInterval)
{
    HRESULT hr = _GetWindow();
    if (SUCCEEDED(hr))
    {
        if (pqc)
        {
            _pqc = pqc; // don't need a ref since we don't return from here
            _dwContinuePollInterval = dwContinuePollInterval > 100 ? dwContinuePollInterval : 500;
            SetTimer(_hwnd, IDT_QUERYCANCEL, _dwContinuePollInterval, NULL);
        }

        // if there is no balloon info specified then there won't be a "balloon timeout" event
        // thus we need to do this ourselves. this lets people use this object for non balloon
        // notification icons
        if ((NULL == _pszTitle) && (NULL == _pszText))
        {
            SetTimer(_hwnd, IDT_NOBALLOON, _dwShowTime, NULL);
        }

        MSG msg;
        while (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        hr = _hrDone;
        if (pqc)
        {
            KillTimer(_hwnd, IDT_QUERYCANCEL);  // in case any are in the queue
            _pqc = NULL;    // to avoid possible problems
        }
    }
    return hr;
}

HRESULT CUserNotification::PlaySound(LPCWSTR pszSoundName)
{
    SHPlaySound(pszSoundName);
    return S_OK;
}

// take down our notification icon
void CUserNotification::_RemoveNotifyIcon()
{
    NOTIFYICONDATA nid = { sizeof(nid), _hwnd, 0 };
    Shell_NotifyIcon(NIM_DELETE, &nid);
}

// the balloon related data (title, body test, dwInfoFlags, timeout
BOOL CUserNotification::_SyncInfo()
{
    BOOL bRet = FALSE;
    if (_hwnd)
    {
        NOTIFYICONDATA nid = { sizeof(nid), _hwnd, 0, NIF_INFO };
        if (_pszTitle)
        {
            StringCchCopy(nid.szInfoTitle, ARRAYSIZE(nid.szInfoTitle), _pszTitle); // ok to truncate
        }
        if (_pszText)
        {
            StringCchCopy(nid.szInfo, ARRAYSIZE(nid.szInfo), _pszText); // ok to truncate
        }
        nid.dwInfoFlags = _dwInfoFlags;
        nid.uTimeout = _dwShowTime;

        bRet = Shell_NotifyIcon(NIM_MODIFY, &nid);
    }
    return bRet;
}

BOOL CUserNotification::_SyncIcon()
{
    BOOL bRet = FALSE;
    if (_hwnd)
    {
        NOTIFYICONDATA nid = { sizeof(nid), _hwnd, 0, NIF_ICON | NIF_TIP};
        nid.hIcon = _hicon ? _hicon : LoadIcon(NULL, IDI_WINLOGO);
        if (_pszToolTip)
        {
            StringCchCopy(nid.szTip, ARRAYSIZE(nid.szTip), _pszToolTip); // ok to truncate
        }

        bRet = Shell_NotifyIcon(NIM_MODIFY, &nid);
    }
    return bRet;
}

HRESULT CUserNotification::_GetWindow()
{
    HRESULT hr = S_OK;
    if (NULL == _hwnd)
    {
        _hwnd = SHCreateWorkerWindow(s_WndProc, NULL, 0, 0, NULL, this);
        if (_hwnd)
        {
            NOTIFYICONDATA nid = { sizeof(nid), _hwnd, 0, NIF_MESSAGE, WM_NOTIFY_MESSAGE };

            if (Shell_NotifyIcon(NIM_ADD, &nid))
            {
                _SyncIcon();
                _SyncInfo();
            }
            else
            {
                DestroyWindow(_hwnd);
                _hwnd = NULL;
                hr = E_FAIL;
            }
        }
    }
    return hr;
}

void CUserNotification::_DelayDestroy(HRESULT hrDone)
{
    _hrDone = hrDone;
    SetTimer(_hwnd, IDT_DESTROY, 250, NULL);
}

void CUserNotification::_Timeout()
{
    if (_cRetryCount)
    {
        _cRetryCount--;
        SetTimer(_hwnd, IDT_REMINDER, _dwInterval, NULL);
    }
    else
    {
        // timeout, same HRESULT as user cancel
        _DelayDestroy(HRESULT_FROM_WIN32(ERROR_CANCELLED)); 
    }
}

LRESULT CALLBACK CUserNotification::_WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    switch (uMsg)
    {
    case WM_NCDESTROY:
        SetWindowLongPtr(_hwnd, 0, NULL);
        _hwnd = NULL;
        break;

    case WM_TIMER:
        KillTimer(_hwnd, wParam);    // make all timers single shot
        switch (wParam)
        {
        case IDT_REMINDER:
            _SyncInfo();
            break;

        case IDT_DESTROY:
            _RemoveNotifyIcon();
            PostQuitMessage(0); // exit our msg loop
            break;

        case IDT_QUERYCANCEL:
            if (_pqc && (S_OK == _pqc->QueryContinue()))
                SetTimer(_hwnd, IDT_QUERYCANCEL, _dwContinuePollInterval, NULL);
            else
                _DelayDestroy(S_FALSE); // callback cancelled
            break;

        case IDT_NOBALLOON:
            _Timeout();
            break;
        }
        break;

    case WM_NOTIFY_MESSAGE:
        switch (lParam)
        {
        case NIN_BALLOONSHOW:
        case NIN_BALLOONHIDE:
            break;

        case NIN_BALLOONTIMEOUT:
            _Timeout();
            break;

        case NIN_BALLOONUSERCLICK:
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            _DelayDestroy(S_OK);    // user click
            break;

        default:
            break;
        }
        break;

    default:
        lres = DefWindowProc(_hwnd, uMsg, wParam, lParam);
        break;
    }
    return lres;
}

LRESULT CALLBACK CUserNotification::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUserNotification *pun = (CUserNotification *)GetWindowLongPtr(hwnd, 0);

    if (WM_CREATE == uMsg)
    {
        CREATESTRUCT *pcs = (CREATESTRUCT *)lParam;
        pun = (CUserNotification *)pcs->lpCreateParams;
        pun->_hwnd = hwnd;
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)pun);
    }

    return pun ? pun->_WndProc(uMsg, wParam, lParam) : DefWindowProc(hwnd, uMsg, wParam, lParam);
}

STDAPI CUserNotification_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CUserNotification* p = new CUserNotification();
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppv = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\basedlg.h ===
#ifndef BASEDLG_H
#define BASEDLG_H

class CBaseDlg
{
public:
    CBaseDlg(ULONG_PTR ulpAHelpIDsArray);
    LONG AddRef();
    LONG Release();

public:
    INT_PTR DoModal(HINSTANCE hinst, LPTSTR pszResource, HWND hwndParent);

protected:
    virtual ~CBaseDlg();
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam) = 0;
    virtual LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnHelp(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnContextMenu(WPARAM wParam, LPARAM lParam);

    virtual LRESULT OnOK(WORD wNotif);
    virtual LRESULT OnCancel(WORD wNotif);

    virtual LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

    ULONG_PTR GetHelpIDsArray();

// Misc
    void SetHWND(HWND hwnd) { _hwnd = hwnd; }
    void ResetHWND() { _hwnd = NULL; }

protected:
    HWND            _hwnd;
    HCURSOR         _hcursorWait;
    HCURSOR         _hcursorOld;

    ULONG_PTR       _rgdwHelpIDsArray;

private:
    LONG                _cRef;
public:
    static BOOL_PTR CALLBACK BaseDlgWndProc(HWND hwnd, UINT uMsg, 
        WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK BaseDlgPropSheetCallback( HWND hwnd, 
        UINT uMsg, LPPROPSHEETPAGE ppsp);

};

#endif //BASEDLG_H}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\basedlg.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "basedlg.h"

CBaseDlg::CBaseDlg(ULONG_PTR ulpAHelpIDsArray) :
     _cRef(1), _rgdwHelpIDsArray(ulpAHelpIDsArray)
{}

CBaseDlg::~CBaseDlg()
{}


LONG CBaseDlg::AddRef()
{
    return (InterlockedIncrement(&_cRef));
}

LONG CBaseDlg::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

INT_PTR CBaseDlg::DoModal(HINSTANCE hinst, LPTSTR pszResource, HWND hwndParent)
{
    PROPSHEETPAGE psp;
    psp.lParam = (LPARAM)this;
    return DialogBoxParam(hinst, pszResource, hwndParent,
        CBaseDlg::BaseDlgWndProc, (LPARAM)&psp);
}

ULONG_PTR CBaseDlg::GetHelpIDsArray()
{
    return _rgdwHelpIDsArray;
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CBaseDlg::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            lRes = OnInitDialog(wParam, lParam);
            break;

        case WM_COMMAND:
            lRes = OnCommand(wParam, lParam);
            break;

        case WM_NOTIFY:
            lRes = OnNotify(wParam, lParam);
            break;

        case WM_DESTROY:
            lRes = OnDestroy(wParam, lParam);
            break;

        case WM_HELP:
        {
            lRes = OnHelp(wParam, lParam);
            break;
        }
        case WM_CONTEXTMENU:
        {
            lRes = OnContextMenu(wParam, lParam);
            break;
        }
        default:
            break;
    }

    return lRes;
}

LRESULT CBaseDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDOK:
            lRes = OnOK(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDCANCEL:
            lRes = OnCancel(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        default:
            break;
    }

    return lRes;    
}

LRESULT CBaseDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    return 0;
}

LRESULT CBaseDlg::OnHelp(WPARAM wParam, LPARAM lParam)
{
    HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;
    int iCtrlID = GetDlgCtrlID(hwndItem);

    WinHelp(hwndItem, NULL, HELP_WM_HELP, GetHelpIDsArray());

    return TRUE;
}

LRESULT CBaseDlg::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    BOOL lRes=FALSE;
    
    if (HTCLIENT == (int)SendMessage(_hwnd, WM_NCHITTEST, 0, lParam))
    {
        POINT pt;
        HWND hwndItem = NULL;
        int iCtrlID = 0;
        
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(_hwnd, &pt);
        
        hwndItem = ChildWindowFromPoint(_hwnd, pt);
        iCtrlID = GetDlgCtrlID(hwndItem);

        WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, GetHelpIDsArray());
        
        lRes = TRUE;
    }
    else
    {
        lRes = FALSE;
    }

    return lRes;
}


LRESULT CBaseDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    ResetHWND();

    SetWindowLongPtr(_hwnd, GWLP_USERDATA, NULL);
    Release();
    
    return FALSE;
}


//static
BOOL_PTR CALLBACK CBaseDlg::BaseDlgWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBaseDlg* pThis = (CBaseDlg*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (WM_INITDIALOG == uMsg)
    {
        pThis = (CBaseDlg*)(((PROPSHEETPAGE*)lParam)->lParam);

        if (pThis)
        {
            pThis->SetHWND(hwnd);

            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);
            pThis->AddRef();

            SetForegroundWindow(hwnd);
        }
    }

    if (pThis)
    {
        return pThis->WndProc(uMsg, wParam, lParam);
    }
    else
        return 0;
}


UINT CALLBACK CBaseDlg::BaseDlgPropSheetCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    UINT    uResult = 0;
    CBaseDlg* pThis = (CBaseDlg*)ppsp->lParam;
    
    switch (uMsg)
    {
        case PSPCB_CREATE:
        {
            uResult = 1;
            break;
        }
        case PSPCB_RELEASE:
        {
            if (pThis)
                pThis->Release();
            break;
        }
    }
    
    return uResult;
}

LRESULT CBaseDlg::OnOK(WORD wNotif)
{
    return FALSE;
}

LRESULT CBaseDlg::OnCancel(WORD wNotif)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\bldtrack.h ===
//
// NT5 tracking is compiled into all NT builds, but only runs on
// NT5 by honoring the g_RunOnNT5 bool.
//

#if defined(WINNT)

#define ENABLE_TRACK 1
#define DM_TRACK 0x0100

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\basefvcb.h ===
#ifndef _BASEFVCB_
#define _BASEFVCB_

#include <cowsite.h>

// base shell folder view callback to derive from

class CBaseShellFolderViewCB : public IShellFolderViewCB, 
                               public IServiceProvider, 
                               public CObjectWithSite
{
public:
    CBaseShellFolderViewCB(LPCITEMIDLIST pidl, LONG lEvents);
    STDMETHOD(RealMessage)(UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellFolderViewCB
    STDMETHODIMP MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv) { *ppv = NULL; return E_NOTIMPL; };

protected:
    virtual ~CBaseShellFolderViewCB();

    HRESULT _BrowseObject(LPCITEMIDLIST pidlFull, UINT uFlags = 0)
    {
        IShellBrowser* psb;
        HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
        if (SUCCEEDED(hr))
        {
            hr = psb->BrowseObject(pidlFull, uFlags);
            psb->Release();
        }
        return hr;
    }

    HWND _hwndMain;
    LONG _cRef;
    LPITEMIDLIST _pidl;
    LONG _lEvents;
};


// view callback helpers

typedef struct {
    ULONGLONG cbBytes;      // total size of items selected
    int nItems;             // number of items selected

    int cFiles;             // # of files
    int cHiddenFiles;       // # of hiddenf iles
    ULONGLONG cbSize;       // total size of selected files

    int cNonFolders;        // how many non-folders we have

    TCHAR szDrive[MAX_PATH];// drive info (if in explorer mode)
    ULONGLONG cbFree;       // drive free space
} FSSELCHANGEINFO;

// status bar helpers to be used from the view callback
STDAPI ViewUpdateStatusBar(IUnknown *psite, LPCITEMIDLIST pidlFolder, FSSELCHANGEINFO *pfssci);
STDAPI_(void) ViewInsertDeleteItem(IShellFolder2 *psf, FSSELCHANGEINFO *pfssci, LPCITEMIDLIST pidl, int iMul);
STDAPI_(void) ViewSelChange(IShellFolder2 *psf, SFVM_SELCHANGE_DATA* pdvsci, FSSELCHANGEINFO *pfssci);
STDAPI_(void) ResizeStatus(IUnknown *psite, UINT cx);
STDAPI_(void) InitializeStatus(IUnknown *psite);
STDAPI_(void) SetStatusText(IUnknown *psite, LPCTSTR *ppszText, int iStart, int iEnd);

// view callback helpers
STDAPI DefaultGetWebViewTemplateFromHandler(LPCTSTR pszKey, SFVM_WEBVIEW_TEMPLATE_DATA* pvi);
STDAPI DefaultGetWebViewTemplateFromClsid(REFCLSID clsid, SFVM_WEBVIEW_TEMPLATE_DATA* pvi);
STDAPI DefaultGetWebViewTemplateFromPath(LPCTSTR pszDir, SFVM_WEBVIEW_TEMPLATE_DATA* pvi);

#endif // _BASEFVCB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\bbckfldr.cpp ===
#include "shellprv.h"
#pragma hdrstop

#include "bitbuck.h"
#include "util.h"
#include "copy.h"
#include "prop.h" // for COLUMN_INFO
#include "propsht.h"
#include "datautil.h"
#include "views.h"
#include "defview.h"    // for WM_DSV_FSNOTIFY
#include "fsdata.h"
#include "idldrop.h"
#include "clsobj.h"
#include "basefvcb.h"
#include "idlcomm.h" // for HIDA
#include "filefldr.h"
#include <idhidden.h>
#include "enumidlist.h"
#include "contextmenu.h"

#include "strsafe.h"

class CBitBucket;
class CBitBucketViewCB;
class CBitBucketEnum;
class CBitBucketDropTarget;
class CBitBucketData;

typedef struct  {
    CBitBucket *pbb;
    HWND hwnd;
    IDataObject *pdtobj;
    IStream *pstmDataObj;
    ULONG_PTR idCmd;
    POINT ptDrop;
    BOOL fSameHwnd;
    BOOL fDragDrop;
} BBTHREADDATA;


class CBitBucket :
    public IPersistFolder2,
    public IShellFolder2,
    public IContextMenu,
    public IShellPropSheetExt,
    public IShellExtInit
{
    friend CBitBucketEnum;
    friend CBitBucketViewCB;
    friend CBitBucketDropTarget;
    friend CBitBucketData;

public:
    CBitBucket();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pclsid);

    // IPersistFolder
    STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHOD(GetCurFolder)(LPITEMIDLIST *ppidl);

    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, IBindCtx *pbc, LPOLESTR pszDisplayName, ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHOD(EnumObjects)(HWND hwnd, SHCONTF grfFlags, IEnumIDList **ppenumIDList);
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv);
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv);
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHOD(CreateViewObject)(HWND hwnd, REFIID riid, void **ppv);
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST *apidl, SFGAOF *rgfInOut);
    STDMETHOD(GetUIObjectOf)(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, UINT *rgfReserved, void **ppv);
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, SHGDNF dwFlags, LPSTRRET lpName);
    STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, SHGDNF dwFlags, LPITEMIDLIST *ppidlOut);

    // IShellFolder2
    STDMETHOD(GetDefaultSearchGUID)(GUID *pguid);
    STDMETHOD(EnumSearches)(IEnumExtraSearch **ppenum);
    STDMETHOD(GetDefaultColumn)(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHOD(GetDefaultColumnState)(UINT iColumn, SHCOLSTATEF *pdwFlags);
    STDMETHOD(GetDetailsEx)(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *psd);
    STDMETHOD(MapColumnToSCID)(UINT iColumn, SHCOLUMNID *pscid);

    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // IShellPropSheetExt
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

protected:
    LPITEMIDLIST DataEntryToIDList(BBDATAENTRYW *pbbde);
    LPITEMIDLIST PathToIDList(LPCTSTR pszPath);
    HGLOBAL BuildDestSpecs(LPIDA pida);

private:
    ~CBitBucket();

    static HRESULT CALLBACK _ItemMenuCallBack(IShellFolder *psf, HWND hwnd,
                IDataObject * pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static HRESULT CALLBACK _BackgroundMenuCallBack(IShellFolder *psf, HWND hwnd,
                IDataObject * pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK _GlobalSettingsCalback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    static BOOL_PTR CALLBACK _FilePropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR CALLBACK _DriveDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR CALLBACK _GlobalPropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static DWORD CALLBACK _DispatchThreadProc(void *pv);
    static BOOL CALLBACK _AddPagesCallback(HPROPSHEETPAGE psp, LPARAM lParam);
    static DWORD WINAPI _DropThreadInit(BBTHREADDATA *pbbtd);
    static void _GlobalPropOnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
    static CBitBucket *_FromFolder(IShellFolder *psf);
    
    HRESULT _LaunchThread(HWND hwnd, IDataObject *pdtobj, WPARAM idCmd);
    void _GetDeletedFileTime(LPCITEMIDLIST pidl, FILETIME *pft);
    DWORD _GetDeletedSize(LPCITEMIDLIST pidl);
    void _FileProperties(IDataObject *pdtobj);
    void _DefaultProperties();
    int _CompareOriginal(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    int _DriveIDFromIDList(LPCITEMIDLIST pidl);
    HRESULT _FolderFromIDList(LPCITEMIDLIST pidl, REFIID riid, void **ppv);
    HRESULT _FolderFromDrive(int idDrive, REFIID riid, void **ppv);
    HRESULT _InitBindCtx();
    BOOL _MapColIndex(UINT *piColumn);
    PUBBDATAENTRYA _IsValid(LPCITEMIDLIST pidl);
    HRESULT _OriginalPath(LPCITEMIDLIST pidl, TCHAR *pszOrig, UINT cch);
    HRESULT _OriginalDirectory(LPCITEMIDLIST pidl, TCHAR *pszOrig, UINT cch);

    void _RestoreFileList(HWND hwnd, IDataObject * pdtobj);
    void _NukeFileList(HWND hwnd, IDataObject * pdtobj);
    int _DataObjToFileOpString(IDataObject *pdtobj, LPTSTR *ppszSrc, LPTSTR *ppszDest);
    HRESULT _GetDriveDisplayName(int idDrive, LPTSTR pszName, UINT cchSize);
    HRESULT _Compare(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    LPITEMIDLIST _DriveInfoToIDList(int idDrive, int iIndex);
    DWORD _IsFolder(LPCITEMIDLIST pidl);
    UINT _SizeColumn();

    LONG _cRef;
    LPITEMIDLIST _pidl;
    UINT _uiColumnSize;

    IUnknown *_rgFolders[MAX_BITBUCKETS];
};

class CBitBucketViewCB : public CBaseShellFolderViewCB
{
public:
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    friend HRESULT Create_CBitBucketViewCB(CBitBucket* psf, IShellFolderViewCB **ppsfvcb);
    CBitBucketViewCB(CBitBucket *pbbf) : CBaseShellFolderViewCB(pbbf->_pidl, 0), _pbbf(pbbf)
    { 
        ZeroMemory(&_fssci, sizeof(_fssci));
        _pbbf->AddRef();
    }
    ~CBitBucketViewCB()
    {
        _pbbf->Release();
    }

    HRESULT _HandleFSNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    HRESULT OnBACKGROUNDENUM(DWORD pv)
    {
        return S_OK;
    }

    HRESULT OnGetCCHMax(DWORD pv, LPCITEMIDLIST wP, UINT *lP)
    {
        return S_OK;
    }

    HRESULT OnSelChange(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA*lP)
    {
        ViewSelChange(_pbbf, lP, &_fssci);
        return S_OK;
    }

    HRESULT OnFSNotify(DWORD pv, LPCITEMIDLIST *ppidl, LPARAM lP)
    {
        return _HandleFSNotify((LONG)lP, ppidl[0], ppidl[1]);
    }

    HRESULT OnUpdateStatusBar(DWORD pv, BOOL wP)
    {
        return ViewUpdateStatusBar(_punkSite, _pidl, &_fssci);
    }

    HRESULT OnWindowCreated(DWORD pv, HWND hwnd)
    {
        for (int i = 0; i < MAX_BITBUCKETS; i++)
        {
            SHChangeNotifyEntry fsne = {0};

            ASSERT(FALSE == fsne.fRecursive);

            // make it if it's there so that we'll get any events
            if (MakeBitBucket(i))
            {
                fsne.pidl = g_pBitBucket[i]->pidl;
                UINT u = SHChangeNotifyRegister(hwnd, SHCNRF_NewDelivery | SHCNRF_ShellLevel | SHCNRF_InterruptLevel,
                                           SHCNE_DISKEVENTS, WM_DSV_FSNOTIFY,  1,  &fsne);
            }
        }

        // _fssci.szDrive[0] == '\0'   // no drive specific stuff
        InitializeStatus(_punkSite);
        return S_OK;
    }

    HRESULT OnInsertDeleteItem(int iMul, LPCITEMIDLIST pidl)
    {
        ViewInsertDeleteItem(_pbbf, &_fssci, pidl, iMul);
        //since recycle bin doesn't receive shcne_xxx
        //defview doesn't update status bar
        OnUpdateStatusBar(0, FALSE);
        return S_OK;
    }

    HRESULT OnWindowDestroy(DWORD pv, HWND hwnd)
    {
        SHChangeNotifyDeregisterWindow(hwnd);   // deregister all
        return S_OK;
    }

    HRESULT OnSize(DWORD pv, UINT cx, UINT cy)
    {
        ResizeStatus(_punkSite, cx);
        return S_OK;
    }

    HRESULT OnEnumeratedItems(DWORD pv, UINT celt, LPCITEMIDLIST *rgpidl)
    {
        _cItems = celt;
        return S_OK;
    }

    HRESULT OnDefViewMode(DWORD pv, FOLDERVIEWMODE*lP)
    {
        if (IsOS(OS_SERVERADMINUI))
            *lP = FVM_DETAILS;    // Server Admin always gets DETAILS
        else if (_cItems < DEFVIEW_FVM_MANY_CUTOFF)
            *lP = FVM_TILE;
        else
            *lP = FVM_ICON;
        return S_OK;
    }

    HRESULT OnGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA *phtd)
    {
        HRESULT hr = S_OK;
        if (IsOS(OS_ANYSERVER))
        {
            hr = StringCchCopyW(phtd->wszHelpFile, ARRAYSIZE(phtd->wszHelpFile), L"recycle.chm > windefault");
        }
        else
        {
            hr = StringCchCopyW(phtd->wszHelpTopic, ARRAYSIZE(phtd->wszHelpTopic), L"hcp://services/subsite?node=Unmapped/Recycle_Bin");
        }
        return hr;
    }

    FSSELCHANGEINFO _fssci;
    CBitBucket *_pbbf;
    UINT _cItems;

    // Web View implementation
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
public:
    static HRESULT _OnEmptyRecycleBin(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnRestore(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _HaveDeletedItems(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
};

HRESULT Create_CBitBucketViewCB(CBitBucket* psf, IShellFolderViewCB **ppsfvcb)
{
    HRESULT hr;
    CBitBucketViewCB* psfvcb = new CBitBucketViewCB(psf);
    if (psfvcb)
    {
        *ppsfvcb = SAFECAST(psfvcb, IShellFolderViewCB*);
        hr = S_OK;
    }
    else
    {
        *ppsfvcb = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CBitBucketViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL;
    return S_OK;
}

HRESULT CBitBucketViewCB::_OnEmptyRecycleBin(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CBitBucketViewCB* pThis = (CBitBucketViewCB*)(void*)pv;

    HRESULT hr = SHInvokeCommandOnPidl(pThis->_hwndMain, NULL, pThis->_pidl, 0, "empty");

    if (S_FALSE == hr)
        MessageBeep(0); // let the user know the click was processed, but nothing was there to delete

    return hr;
}

HRESULT CBitBucketViewCB::_OnRestore(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    IDataObject *pdo;
    CBitBucketViewCB* pThis = (CBitBucketViewCB*)(void*)pv;
    HRESULT hr = S_OK;

    if (!psiItemArray)
    {
        hr = E_FAIL;

        IFolderView* pfv;
        if (pThis->_punkSite && SUCCEEDED(pThis->_punkSite->QueryInterface(IID_PPV_ARG(IFolderView, &pfv))))
        {
            hr = pfv->Items(SVGIO_ALLVIEW, IID_PPV_ARG(IDataObject, &pdo));
            pfv->Release();
        }
    }
    else
    {
        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo));
    }


    if (SUCCEEDED(hr))
    {
        hr = SHInvokeCommandOnDataObject(pThis->_hwndMain, NULL, pdo, 0, "undelete");
        ATOMICRELEASE(pdo);
    }

    return hr;
}

HRESULT CBitBucketViewCB::_HaveDeletedItems(IUnknown* /*pv*/,IShellItemArray * /* psiItemArray */, BOOL /*fOkToBeSlow*/, UISTATE* puisState)
{
    *puisState = IsRecycleBinEmpty() ? UIS_DISABLED : UIS_ENABLED;
    return S_OK;
}

const WVTASKITEM c_BitBucketTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_BITBUCKET, IDS_HEADER_BITBUCKET_TT);
const WVTASKITEM c_BitBucketTaskList[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_EMPTYRECYCLEBIN, IDS_TASK_EMPTYRECYCLEBIN_TT, IDI_TASK_EMPTYRECYCLEBIN, CBitBucketViewCB::_HaveDeletedItems, CBitBucketViewCB::_OnEmptyRecycleBin),
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL, L"shell32.dll", IDS_TASK_RESTORE_ALL, IDS_TASK_RESTORE_ITEM, IDS_TASK_RESTORE_ITEM, IDS_TASK_RESTORE_ITEMS, IDS_TASK_RESTORE_TT, IDI_TASK_RESTOREITEMS, CBitBucketViewCB::_HaveDeletedItems, CBitBucketViewCB::_OnRestore),
};

HRESULT CBitBucketViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    Create_IUIElement(&c_BitBucketTaskHeader, &(pData->pFolderTaskHeader));

    LPCTSTR rgcsidl[] = { MAKEINTRESOURCE(CSIDL_DESKTOP), MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };
    CreateIEnumIDListOnCSIDLs(NULL, rgcsidl, ARRAYSIZE(rgcsidl), &(pData->penumOtherPlaces));

    return S_OK;
}

HRESULT CBitBucketViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    pTasks->dwUpdateFlags = SFVMWVTSDF_CONTENTSCHANGE;
    Create_IEnumUICommand((IUnknown*)(void*)this, c_BitBucketTaskList, ARRAYSIZE(c_BitBucketTaskList), &pTasks->penumFolderTasks);

    return S_OK;
}

HRESULT CBitBucketViewCB::_HandleFSNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];

    // pidls must be child of drives or network
    // (actually only drives work for right now)
    // that way we won't get duplicate events
    if ((!ILIsParent((LPCITEMIDLIST)&c_idlDrives, pidl1, FALSE) && !ILIsParent((LPCITEMIDLIST)&c_idlNet, pidl1, FALSE)) ||
        (pidl2 && !ILIsParent((LPCITEMIDLIST)&c_idlDrives, pidl2, FALSE) && !ILIsParent((LPCITEMIDLIST)&c_idlNet, pidl2, FALSE)))
    {
        return S_FALSE;
    }

    SHGetPathFromIDList(pidl1, szPath);
    LPTSTR pszFileName = PathFindFileName(szPath);

    if (!lstrcmpi(pszFileName, c_szInfo2) ||
        !lstrcmpi(pszFileName, c_szInfo) ||
        !lstrcmpi(pszFileName, c_szDesktopIni))
    {
        // we ignore changes to these files because they mean we were simply doing bookeeping 
        // (eg updating the info file, re-creating the desktop.ini, etc)
        return S_FALSE;
    }

    switch (lEvent)
    {
    case SHCNE_RENAMEFOLDER:
    case SHCNE_RENAMEITEM:
        {
            // if the rename's target is in a bitbucket, then do a create.
            // otherwise, return S_OK..

            int idDrive = DriveIDFromBBPath(szPath);

            if (MakeBitBucket(idDrive) && ILIsParent(g_pBitBucket[idDrive]->pidl, pidl1, TRUE))
            {
                hr = _HandleFSNotify((lEvent == SHCNE_RENAMEITEM) ? SHCNE_DELETE : SHCNE_RMDIR, pidl1, NULL);
            }
        }
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        {
            LPITEMIDLIST pidl = _pbbf->PathToIDList(szPath);
            if (pidl)
            {
                ShellFolderView_AddObject(_hwndMain, pidl);
                hr = S_FALSE;
            }
        }
        break;

    case SHCNE_DELETE:
    case SHCNE_RMDIR: 
        // if this was a delete into the recycle bin, pidl2 will exist
        if (pidl2)
        {
            hr = _HandleFSNotify((lEvent == SHCNE_DELETE) ? SHCNE_CREATE : SHCNE_MKDIR, pidl2, NULL);
        }
        else
        {
            ShellFolderView_RemoveObject(_hwndMain, ILFindLastID(pidl1));
            hr = S_FALSE;
        }
        break;

    case SHCNE_UPDATEDIR:
        // we recieved an updatedir, which means we probably had more than 10 fsnotify events come in,
        // so we just refresh our brains out.
        ShellFolderView_RefreshAll(_hwndMain);
        break;

    default:
        hr = S_FALSE;   // didn't handle this message
        break;
    }

    return hr;
}



STDMETHODIMP CBitBucketViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_GETHELPTOPIC, OnGetHelpTopic);
    HANDLE_MSG(0, SFVM_GETCCHMAX, OnGetCCHMax);
    HANDLE_MSG(0, SFVM_SELCHANGE, OnSelChange);
    HANDLE_MSG(0, SFVM_FSNOTIFY, OnFSNotify);
    HANDLE_MSG(0, SFVM_UPDATESTATUSBAR, OnUpdateStatusBar);
    HANDLE_MSG(0, SFVM_WINDOWCREATED, OnWindowCreated);
    HANDLE_MSG(1 , SFVM_INSERTITEM, OnInsertDeleteItem);
    HANDLE_MSG(-1, SFVM_DELETEITEM, OnInsertDeleteItem);
    HANDLE_MSG(0, SFVM_WINDOWDESTROY, OnWindowDestroy);
    HANDLE_MSG(0, SFVM_ENUMERATEDITEMS, OnEnumeratedItems);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDefViewMode);
    HANDLE_MSG(0, SFVM_SIZE, OnSize);
    HANDLE_MSG(0, SFVM_BACKGROUNDENUM, OnBACKGROUNDENUM);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);

    default:
        return E_FAIL;
    }

    return S_OK;
}

typedef struct _bbpropsheetinfo
{
    PROPSHEETPAGE psp;

    int idDrive;

    BOOL fNukeOnDelete;
    BOOL fOriginalNukeOnDelete;

    int iPercent;
    int iOriginalPercent;

    // the following two fields are valid only for the "global" tab, where they represent the state
    // of the "Configure drives independently" / "Use one setting for all drives" checkbox
    BOOL fUseGlobalSettings;
    BOOL fOriginalUseGlobalSettings;

    // the following fields are for policy overrides
    BOOL fPolicyNukeOnDelete;
    BOOL fPolicyPercent;

    // this is a pointer to the global property sheet page after it has been copied somewhere by the 
    // CreatePropertySheetPage(), we use this to get to the global state of the % slider and fNukeOnDelete
    // from the other tabs
    struct _bbpropsheetinfo* pGlobal;
} BBPROPSHEETINFO;


const static DWORD aBitBucketPropHelpIDs[] = {  // Context Help IDs
    IDD_ATTR_GROUPBOX,  IDH_COMM_GROUPBOX,
    IDC_INDEPENDENT,    IDH_RECYCLE_CONFIG_INDEP,
    IDC_GLOBAL,         IDH_RECYCLE_CONFIG_ALL,
    IDC_DISKSIZE,       IDH_RECYCLE_DRIVE_SIZE,
    IDC_DISKSIZEDATA,   IDH_RECYCLE_DRIVE_SIZE,
    IDC_BYTESIZE,       IDH_RECYCLE_BIN_SIZE,
    IDC_BYTESIZEDATA,   IDH_RECYCLE_BIN_SIZE,
    IDC_NUKEONDELETE,   IDH_RECYCLE_PURGE_ON_DEL,
    IDC_BBSIZE,         IDH_RECYCLE_MAX_SIZE,
    IDC_BBSIZETEXT,     IDH_RECYCLE_MAX_SIZE,
    IDC_CONFIRMDELETE,  IDH_DELETE_CONFIRM_DLG,
    IDC_TEXT,           NO_HELP,
    0, 0
};

const static DWORD aBitBucketHelpIDs[] = {  // Context Help IDs
    IDD_LINE_1,        NO_HELP,
    IDD_LINE_2,        NO_HELP,
    IDD_ITEMICON,      IDH_FPROP_GEN_ICON,
    IDD_NAME,          IDH_FPROP_GEN_NAME,
    IDD_FILETYPE_TXT,  IDH_FPROP_GEN_TYPE,
    IDD_FILETYPE,      IDH_FPROP_GEN_TYPE,
    IDD_FILESIZE_TXT,  IDH_FPROP_GEN_SIZE,
    IDD_FILESIZE,      IDH_FPROP_GEN_SIZE,
    IDD_LOCATION_TXT,  IDH_FCAB_DELFILEPROP_LOCATION,
    IDD_LOCATION,      IDH_FCAB_DELFILEPROP_LOCATION,
    IDD_DELETED_TXT,   IDH_FCAB_DELFILEPROP_DELETED,
    IDD_DELETED,       IDH_FCAB_DELFILEPROP_DELETED,
    IDD_CREATED_TXT,   IDH_FPROP_GEN_DATE_CREATED,
    IDD_CREATED,       IDH_FPROP_GEN_DATE_CREATED,
    IDD_READONLY,      IDH_FCAB_DELFILEPROP_READONLY,
    IDD_HIDDEN,        IDH_FCAB_DELFILEPROP_HIDDEN,
    IDD_ARCHIVE,       IDH_FCAB_DELFILEPROP_ARCHIVE,
    IDD_ATTR_GROUPBOX, IDH_COMM_GROUPBOX,
    0, 0
};

CBitBucket::CBitBucket() : _cRef(1), _pidl(NULL), _uiColumnSize(-1)
{
}

CBitBucket::~CBitBucket()
{
    for (int i = 0; i < ARRAYSIZE(_rgFolders); i++)
    {
        if (_rgFolders[i])
            _rgFolders[i]->Release();
    }

    ILFree(_pidl);
}

STDMETHODIMP CBitBucket::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBitBucket, IPersistFolder2),                      // IID_IPersistFolder2
        QITABENTMULTI(CBitBucket, IPersistFolder, IPersistFolder2), // IID_IPersistFolder
        QITABENT(CBitBucket, IShellFolder2),                        // IID_IShellFolder2
        QITABENTMULTI(CBitBucket, IShellFolder, IShellFolder2),     // IID_IShellFolder
        QITABENT(CBitBucket, IContextMenu),                         // IID_IContextMenu
        QITABENT(CBitBucket, IShellPropSheetExt),                   // IID_IShellPropSheetExt
        QITABENT(CBitBucket, IShellExtInit),                        // IID_IShellExtInit
        { 0 },                             
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr) && riid == CLSID_RecycleBin)
    {
        *ppv = this;                // not ref counted
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP_(ULONG) CBitBucket::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBitBucket::Release()
{
    ULONG cRef = InterlockedDecrement(&_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

#pragma pack(1)
typedef struct {
    HIDDENITEMID hid;
    BBDATAENTRYA bbde;
} HIDDENRECYCLEBINDATA;
#pragma pack()
    
typedef HIDDENRECYCLEBINDATA UNALIGNED *PUHIDDENRECYCLEBINDATA;
#define HRBD_CURRENTVERSION 0

PUBBDATAENTRYA CBitBucket::_IsValid(LPCITEMIDLIST pidl)
{
    if (pidl)
    {
        PUHIDDENRECYCLEBINDATA phrbd = (PUHIDDENRECYCLEBINDATA)ILFindHiddenID(pidl, IDLHID_RECYCLEBINDATA);
        if (phrbd && phrbd->hid.wVersion >= HRBD_CURRENTVERSION)
            return &phrbd->bbde;
    }
    return NULL;
}

HRESULT CBitBucket::_OriginalPath(LPCITEMIDLIST pidl, TCHAR *pszOrig, UINT cch)
{
    ASSERT(pidl == ILFindLastID(pidl));

    *pszOrig = 0;
    HRESULT hr;
    PUBBDATAENTRYA pbbde = _IsValid(pidl);
    if (pbbde)
    {
        if (!ILGetHiddenString(pidl, IDLHID_RECYCLEBINORIGINAL, pszOrig, cch))
        {
            SHAnsiToTChar(pbbde->szOriginal, pszOrig, cch);
        }
        hr = *pszOrig ? S_OK : S_FALSE;
    }
    else
    {
        ASSERTMSG(pbbde != NULL, "_OriginalPath: caller needs to call _IsValid on the pidl passed to us!");
        hr = E_FAIL;
    }
    return hr;
}

HRESULT CBitBucket::_OriginalDirectory(LPCITEMIDLIST pidl, TCHAR *pszOrig, UINT cch)
{
    HRESULT hr = _OriginalPath(pidl, pszOrig, cch);
    if (SUCCEEDED(hr))
        PathRemoveFileSpec(pszOrig);
    return hr;
}

// subclass member function to support CF_HDROP and CF_NETRESOURCE
// in:
//      hida    bitbucket id array
//
// out:
//      HGLOBAL with double NULL terminated string list of destination names
//

HGLOBAL CBitBucket::BuildDestSpecs(LPIDA pida)
{
    LPCITEMIDLIST pidl;
    TCHAR szTemp[MAX_PATH];
    UINT cbAlloc = sizeof(TCHAR);    // for double NULL termination

    for (UINT i = 0; pidl = IDA_GetIDListPtr(pida, i); i++)
    {
        _OriginalPath(pidl, szTemp, ARRAYSIZE(szTemp));

        cbAlloc += lstrlen(PathFindFileName(szTemp)) * sizeof(TCHAR) + sizeof(TCHAR);
    }
    LPTSTR pszRet = (LPTSTR) LocalAlloc(LPTR, cbAlloc);
    if (pszRet)
    {
        LPTSTR pszDest = pszRet;
        for (i = 0; pidl = IDA_GetIDListPtr(pida, i); i++)
        {
            UINT cbRemain = cbAlloc - (pszDest - pszRet) * sizeof(TCHAR);
            _OriginalPath(pidl, szTemp, ARRAYSIZE(szTemp));
            if (SUCCEEDED(StringCbCopy(pszDest, cbRemain, PathFindFileName(szTemp))))
            {
                pszDest += lstrlen(pszDest) + 1;

                ASSERT((ULONG_PTR)((LPBYTE)pszDest - (LPBYTE)pszRet) < cbAlloc);
                ASSERT(*(pszDest) == 0);    // zero init alloc
            }
            else
            {
                delete pszRet;
                pszRet = NULL;
                break;
            }
        }        
#ifdef DEBUG
        if (pszRet)
        {
            ASSERT((LPTSTR)((LPBYTE)pszRet + cbAlloc - sizeof(TCHAR)) == pszDest);
            ASSERT(*pszDest == 0);  // zero init alloc
        }
#endif // DEBUG        
    }
    return pszRet;
}

class CBitBucketData : public CFSIDLData
{
public:
    CBitBucketData(CBitBucket *pbbf, UINT cidl, LPCITEMIDLIST apidl[]): CFSIDLData(pbbf->_pidl, cidl, apidl, NULL), _pbbf(pbbf) 
    { 
        _pbbf->AddRef();
    }

    // IDataObject methods overwrite
    STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);

private:
    ~CBitBucketData()
    {
        _pbbf->Release();
    }

    CBitBucket *_pbbf;
};

STDMETHODIMP CBitBucketData::QueryGetData(FORMATETC * pformatetc)
{
    ASSERT(g_cfFileNameMap);

    if (pformatetc->cfFormat == g_cfFileNameMap && (pformatetc->tymed & TYMED_HGLOBAL))
    {
        return S_OK; // same as S_OK
    }
    return CFSIDLData::QueryGetData(pformatetc);
}

STDMETHODIMP CBitBucketData::GetData(FORMATETC * pformatetcIn, STGMEDIUM * pmedium)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(g_cfFileNameMap);

    if (pformatetcIn->cfFormat == g_cfFileNameMap && (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        STGMEDIUM medium;

        LPIDA pida = DataObj_GetHIDA(this, &medium);
        if (medium.hGlobal)
        {
            pmedium->hGlobal = _pbbf->BuildDestSpecs(pida);
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->pUnkForRelease = NULL;

            HIDA_ReleaseStgMedium(pida, &medium);

            hr = pmedium->hGlobal ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = CFSIDLData::GetData(pformatetcIn, pmedium);
    }

    return hr;
}

//
// We need to be able to compare the names of two bbpidls.  Since either of
// them could be a unicode name, we might have to convert both to unicode.
//
int CBitBucket::_CompareOriginal(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    TCHAR szOrig1[MAX_PATH], szOrig2[MAX_PATH];
    
    if (SUCCEEDED(_OriginalPath(pidl1, szOrig1, ARRAYSIZE(szOrig1))) &&
        SUCCEEDED(_OriginalPath(pidl2, szOrig2, ARRAYSIZE(szOrig2))))
    {
        PathRemoveFileSpec(szOrig1);
        PathRemoveFileSpec(szOrig2);
        return lstrcmpi(szOrig1,szOrig2);
    }
    
    return -1;  // failure, say 2 > 1
}

// we are cheating here passing pidl1 and pidl2 to one folder when
// the could have come from different folders. but since these are
// file system we can get away with this, see findfldr.cpp for the
// code to deal with this in the general case

HRESULT CBitBucket::_Compare(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    IShellFolder *psf;
    HRESULT hr = _FolderFromIDList(pidl1, IID_PPV_ARG(IShellFolder, &psf));
    if (SUCCEEDED(hr))
    {
        hr = psf->CompareIDs(lParam, pidl1, pidl2);
        psf->Release();
    }
    return hr;
}

enum
{
    ICOL_NAME = 0,
    ICOL_ORIGINAL = 1,
    ICOL_DATEDELETED = 2,
};

const COLUMN_INFO c_bb_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,             30, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_DELETEDFROM,      30, IDS_DELETEDFROM_COL),
    DEFINE_COL_DATE_ENTRY(SCID_DATEDELETED,         IDS_DATEDELETED_COL),
};

STDMETHODIMP CBitBucket::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(pidl1 == ILFindLastID(pidl1));

    UINT iColumn = ((DWORD)lParam & SHCIDS_COLUMNMASK);

    PUBBDATAENTRYA pbbde1 = _IsValid(pidl1);    // both may be NULL for pure FS pidl
    PUBBDATAENTRYA pbbde2 = _IsValid(pidl2);    // generated by change notify

    if (_MapColIndex(&iColumn))
    {
        switch (iColumn)
        {
        case ICOL_NAME:
            // compare the real filenames first, if they are different,
            // try comparing the display name
            hr = _Compare(lParam, pidl1, pidl2);
            if (0 == hr)
                return hr;  // fs pidl comapre says they are the same
            else
            {
                TCHAR sz1[MAX_PATH], sz2[MAX_PATH];
                DisplayNameOf(this, pidl1, SHGDN_INFOLDER, sz1, ARRAYSIZE(sz1));
                DisplayNameOf(this, pidl2, SHGDN_INFOLDER, sz2, ARRAYSIZE(sz2));
                int iRes = StrCmpLogicalRestricted(sz1, sz2);
                if (iRes)
                    return ResultFromShort(iRes);

                if (pbbde1 && pbbde2)
                    return ResultFromShort(pbbde1->idDrive - pbbde2->idDrive);
            }
            break;

        case ICOL_ORIGINAL:
            {
                int iRes = _CompareOriginal(pidl1, pidl2);
                if (iRes)
                    return ResultFromShort(iRes);
            }
            break;

        case ICOL_DATEDELETED:
            {
                FILETIME ft1, ft2;
                _GetDeletedFileTime(pidl1, &ft1);
                _GetDeletedFileTime(pidl2, &ft2);
                int iRes = CompareFileTime(&ft1, &ft2);
                if (iRes)
                    return ResultFromShort(iRes);
            }
            break;
        }
        lParam &= ~SHCIDS_COLUMNMASK;   // fall thorugh to sort on name...
    }
    else if (pbbde1 && pbbde2 && (_SizeColumn() == iColumn))
    {
        if (pbbde1->dwSize < pbbde2->dwSize)
            return ResultFromShort(-1);
        if (pbbde1->dwSize > pbbde2->dwSize)
            return ResultFromShort(1);
        lParam &= ~SHCIDS_COLUMNMASK;   // fall thorugh to sort on name...
    }
    else
    {
        lParam = (lParam & ~SHCIDS_COLUMNMASK) | iColumn;
    }

    return _Compare(lParam, pidl1, pidl2);
}

STDMETHODIMP CBitBucket::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfOut)
{
    HRESULT hr;
    if (IsSelf(cidl, apidl))
    {
        // asking about folder as a whole
        *rgfOut = SFGAO_FOLDER | SFGAO_DROPTARGET | SFGAO_HASPROPSHEET;

        if (SHRestricted(REST_BITBUCKNOPROP))
        {
            *rgfOut &= ~SFGAO_HASPROPSHEET;
        }

        hr = S_OK;
    }
    else
    {
        IShellFolder *psf;
        hr = _FolderFromIDList(apidl[0], IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetAttributesOf(cidl, apidl, rgfOut);
            psf->Release();
            // only allow these attributes to be returned
            *rgfOut &= (SFGAO_CANMOVE | SFGAO_CANDELETE | SFGAO_HASPROPSHEET | SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM | SFGAO_LINK);
        }
    }
    return hr;
}

int CBitBucket::_DataObjToFileOpString(IDataObject *pdtobj, LPTSTR *ppszSrc, LPTSTR *ppszDest)
{
    int cItems = 0;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);

    *ppszSrc = NULL;
    *ppszDest = NULL;

    if (pida)
    {
        cItems = pida->cidl;

        // start with null terminated strings
        int cchSrc = 1, cchDest = 1;
        
        LPTSTR pszSrc = (LPTSTR)LocalAlloc(LPTR, cchSrc * sizeof(TCHAR));
        LPTSTR pszDest = (LPTSTR)LocalAlloc(LPTR, cchDest * sizeof(TCHAR));

        if (!pszSrc || !pszDest)
        {
            // skip the loop and fail
            cItems = 0;
        }

        for (int i = 0 ; i < cItems; i++) 
        {
            LPITEMIDLIST pidl = IDA_FullIDList(pida, i);
            if (pidl)
            {
                TCHAR szTemp[MAX_PATH];

                // src
                SHGetPathFromIDList(pidl, szTemp);

                // Done with this already. Free now in case we exit early.
                ILFree(pidl);

                int cchSrcFile = lstrlen(szTemp) + 1;
                LPTSTR psz = (LPTSTR)LocalReAlloc((HLOCAL)pszSrc, (cchSrc + cchSrcFile) * sizeof(TCHAR), LMEM_MOVEABLE | LMEM_ZEROINIT);
                if (psz)
                {
                    pszSrc = psz;
                    if (SUCCEEDED(StringCchCopy( pszSrc + cchSrc - 1, cchSrcFile, szTemp)))
                    {
                        cchSrc += cchSrcFile;
                    }
                    else
                    {
                        cItems = 0;
                        break;
                    }
                }
                else
                {
                    cItems = 0;
                    break;
                }

                // dest
                _OriginalPath(IDA_GetIDListPtr(pida, i), szTemp, ARRAYSIZE(szTemp));

                int cchDestFile = lstrlen(szTemp) + 1;
                psz = (LPTSTR)LocalReAlloc((HLOCAL)pszDest, (cchDest + cchDestFile) * sizeof(TCHAR), LMEM_MOVEABLE | LMEM_ZEROINIT);
                if (psz)
                {
                    pszDest = psz;
                    if (SUCCEEDED(StringCchCopy(pszDest + cchDest - 1, cchDestFile, szTemp)))
                    {
                        cchDest += cchDestFile;
                    }
                    else
                    {
                        cItems = 0;
                        break;
                    }
                }
                else
                {
                    // out of memory!
                    cItems = 0;
                    break;
                }
            }
        }

        if (0 == cItems)
        {
            // ok to pass NULL here
            LocalFree((HLOCAL)pszSrc);
            LocalFree((HLOCAL)pszDest);
        }
        else
        {
            *ppszSrc = pszSrc;
            *ppszDest = pszDest;
        }

        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return cItems;
}


//
// restores the list of files in the IDataObject
//
void CBitBucket::_RestoreFileList(HWND hwnd, IDataObject * pdtobj)
{
    LPTSTR pszSrc, pszDest;

    if (_DataObjToFileOpString(pdtobj, &pszSrc, &pszDest))
    {
        // now do the actual restore.
        SHFILEOPSTRUCT sFileOp = { hwnd, FO_MOVE, pszSrc, pszDest,
                                   FOF_MULTIDESTFILES | FOF_SIMPLEPROGRESS | FOF_NOCONFIRMMKDIR,
                                   FALSE, NULL, MAKEINTRESOURCE(IDS_BB_RESTORINGFILES)};

        DECLAREWAITCURSOR;

        SetWaitCursor();

        if (SHFileOperation(&sFileOp) == ERROR_SUCCESS)
        {
            SHChangeNotifyHandleEvents();
            BBCheckRestoredFiles(pszSrc);
        }

        LocalFree((HLOCAL)pszSrc);
        LocalFree((HLOCAL)pszDest);

        ResetWaitCursor();
    }
}


//
// nukes the list of files in the IDataObject
//
void CBitBucket::_NukeFileList(HWND hwnd, IDataObject * pdtobj)
{
    LPTSTR pszSrc, pszDest;
    int nFiles = _DataObjToFileOpString(pdtobj, &pszSrc, &pszDest);
    if (nFiles)
    {
        // now do the actual nuke.
        WIN32_FIND_DATA fd;
        CONFIRM_DATA cd = {CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_PROGRAM_FILE | CONFIRM_MULTIPLE, 0};
        SHFILEOPSTRUCT sFileOp = { hwnd, FO_DELETE, pszSrc, NULL, FOF_NOCONFIRMATION | FOF_SIMPLEPROGRESS, 
                                   FALSE, NULL, MAKEINTRESOURCE(IDS_BB_DELETINGWASTEBASKETFILES)};

        DECLAREWAITCURSOR;

        SetWaitCursor();

        fd.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
        if (ConfirmFileOp(hwnd, NULL, &cd, nFiles, 0, CONFIRM_DELETE_FILE | CONFIRM_WASTEBASKET_PURGE, pszDest, &fd, NULL, &fd, NULL) == IDYES)
        {
            SHFileOperation(&sFileOp);
            
            SHChangeNotifyHandleEvents();

            // update the icon if there are objects left in the list
            int iItems = (int) ShellFolderView_GetObjectCount(hwnd);
            UpdateIcon(iItems);
        }

        LocalFree((HLOCAL)pszSrc);
        LocalFree((HLOCAL)pszDest);

        ResetWaitCursor();
    }
}

void EnableTrackbarAndFamily(HWND hDlg, BOOL f)
{
    EnableWindow(GetDlgItem(hDlg, IDC_BBSIZE), f);
    EnableWindow(GetDlgItem(hDlg, IDC_BBSIZETEXT), f);
    EnableWindow(GetDlgItem(hDlg, IDC_TEXT), f);
}

void CBitBucket::_GlobalPropOnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    BBPROPSHEETINFO *ppsi = (BBPROPSHEETINFO *)GetWindowLongPtr(hDlg, DWLP_USER);
    BOOL fNukeOnDelete;
    
    switch (id)
    {
    case IDC_GLOBAL:
    case IDC_INDEPENDENT:
        fNukeOnDelete = IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE);
        
        ppsi->fUseGlobalSettings = (IsDlgButtonChecked(hDlg, IDC_GLOBAL) == BST_CHECKED) ? TRUE : FALSE;
        EnableWindow(GetDlgItem(hDlg, IDC_NUKEONDELETE), ppsi->fUseGlobalSettings && !ppsi->fPolicyNukeOnDelete);
        EnableTrackbarAndFamily(hDlg, ppsi->fUseGlobalSettings && !fNukeOnDelete && !ppsi->fPolicyPercent);
        
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
        break;
        
    case IDC_NUKEONDELETE:
        fNukeOnDelete = IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE);
        if (fNukeOnDelete)
        {                
            // In order to help protect users, when they turn on "Remove files immedately" we also
            // check the "show delete confimation" box automatically for them. Thus, they will have
            // to explicitly uncheck it if they do not want confimation that their files will be nuked.
            CheckDlgButton(hDlg, IDC_CONFIRMDELETE, BST_CHECKED);
        }

        ppsi->fNukeOnDelete = fNukeOnDelete;
        EnableTrackbarAndFamily(hDlg, !fNukeOnDelete && !ppsi->fPolicyPercent);
        // fall through
    case IDC_CONFIRMDELETE:
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
        break;
    }
}

void RelayMessageToChildren(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    for (HWND hwndChild = GetWindow(hwnd, GW_CHILD); hwndChild != NULL; hwndChild = GetWindow(hwndChild, GW_HWNDNEXT))
    {
        SendMessage(hwndChild, uMessage, wParam, lParam);
    }
}

//
// This is the dlg proc for the "Global" tab on the recycle bin
//
BOOL_PTR CALLBACK CBitBucket::_GlobalPropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BBPROPSHEETINFO *ppsi = (BBPROPSHEETINFO *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) 
    {
    HANDLE_MSG(hDlg, WM_COMMAND, _GlobalPropOnCommand);

    case WM_INITDIALOG: 
        {
            HWND hwndTrack = GetDlgItem(hDlg, IDC_BBSIZE);
            SHELLSTATE ss;

            // make sure the info we have is current
            RefreshAllBBDriveSettings();

            ppsi = (BBPROPSHEETINFO *)lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            SendMessage(hwndTrack, TBM_SETTICFREQ, 10, 0);
            SendMessage(hwndTrack, TBM_SETRANGE, FALSE, MAKELONG(0, 100));
            SendMessage(hwndTrack, TBM_SETPOS, TRUE, ppsi->iOriginalPercent);

            EnableWindow(GetDlgItem(hDlg, IDC_NUKEONDELETE), ppsi->fUseGlobalSettings && !ppsi->fPolicyNukeOnDelete);
            EnableTrackbarAndFamily(hDlg, ppsi->fUseGlobalSettings && !ppsi->fNukeOnDelete && !ppsi->fPolicyPercent);
            CheckDlgButton(hDlg, IDC_NUKEONDELETE, ppsi->fNukeOnDelete);
            CheckRadioButton(hDlg, IDC_INDEPENDENT, IDC_GLOBAL, ppsi->fUseGlobalSettings ? IDC_GLOBAL : IDC_INDEPENDENT);
            EnableWindow(GetDlgItem(hDlg, IDC_INDEPENDENT), !ppsi->fPolicyNukeOnDelete);

            SHGetSetSettings(&ss, SSF_NOCONFIRMRECYCLE, FALSE);
            CheckDlgButton(hDlg, IDC_CONFIRMDELETE, !ss.fNoConfirmRecycle);
            EnableWindow(GetDlgItem(hDlg, IDC_CONFIRMDELETE), !SHRestricted(REST_BITBUCKCONFIRMDELETE));
        }
    // fall through to set iGlobalPercent
    case WM_HSCROLL: 
        {
            TCHAR szPercent[20];
            HWND hwndTrack = GetDlgItem(hDlg, IDC_BBSIZE);
            
            ppsi->iPercent = (int) SendMessage(hwndTrack, TBM_GETPOS, 0, 0);

            // ok to truncate since this is for display only
            StringCchPrintf(szPercent, ARRAYSIZE(szPercent), TEXT("%d%%"), ppsi->iPercent);
            SetDlgItemText(hDlg, IDC_BBSIZETEXT, szPercent);
            
            if (ppsi->iPercent != ppsi->iOriginalPercent)
            {
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                
                if (ppsi->iPercent == 0)
                {
                    // In order to help protect users, when they set the % slider to zero we also
                    // check the "show delete confimation" box automatically for them. Thus, they will have
                    // to explicitly uncheck it if they do not want confimation that their files will be nuked.
                    CheckDlgButton(hDlg, IDC_CONFIRMDELETE, BST_CHECKED);
                }
            }
            
            return TRUE;
        }

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBitBucketPropHelpIDs);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(void *) aBitBucketPropHelpIDs);
        return TRUE;

    case WM_WININICHANGE:
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        RelayMessageToChildren(hDlg, uMsg, wParam, lParam);
        break;

    case WM_DESTROY:
        CheckCompactAndPurge();
        SHUpdateRecycleBinIcon();
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case PSN_APPLY:
            {
                SHELLSTATE ss;

                ss.fNoConfirmRecycle = !IsDlgButtonChecked(hDlg, IDC_CONFIRMDELETE);
                SHGetSetSettings(&ss, SSF_NOCONFIRMRECYCLE, TRUE);
                
                ppsi->fNukeOnDelete = (IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE) == BST_CHECKED) ? TRUE : FALSE;
                ppsi->fUseGlobalSettings = (IsDlgButtonChecked(hDlg, IDC_INDEPENDENT) == BST_CHECKED) ? FALSE : TRUE;

                // if anything on the global tab changed, update all the drives
                if (ppsi->fUseGlobalSettings != ppsi->fOriginalUseGlobalSettings    ||
                    ppsi->fNukeOnDelete != ppsi->fOriginalNukeOnDelete              ||
                    ppsi->iPercent != ppsi->iOriginalPercent)
                {
                    // NOTE: We get a PSN_APPLY after all the drive tabs. This has to be this way so that
                    // if global settings change, then the global tab will re-apply all the most current settings
                    // bassed on the global variables that get set above.

                    // this sets the new global settings in the registry
                    if (!PersistGlobalSettings(ppsi->fUseGlobalSettings, ppsi->fNukeOnDelete, ppsi->iPercent))
                    {
                        // we failed, so show the error dialog and bail
                        ShellMessageBox(HINST_THISDLL,
                                        hDlg,
                                        MAKEINTRESOURCE(IDS_BB_CANNOTCHANGESETTINGS),
                                        MAKEINTRESOURCE(IDS_WASTEBASKET),
                                        MB_OK | MB_ICONEXCLAMATION);

                        SetDlgMsgResult(hDlg, WM_NOTIFY, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    for (int i = 0; i < MAX_BITBUCKETS; i++)
                    {
                        if (MakeBitBucket(i))
                        {
                            BOOL bPurge = TRUE;

                            // we need to purge all the drives in this case
                            RegSetValueEx(g_pBitBucket[i]->hkeyPerUser, TEXT("NeedToPurge"), 0, REG_DWORD, (LPBYTE)&bPurge, sizeof(bPurge));

                            RefreshBBDriveSettings(i);
                        }
                    }

                    ppsi->fOriginalUseGlobalSettings = ppsi->fUseGlobalSettings;
                    ppsi->fOriginalNukeOnDelete = ppsi->fNukeOnDelete; 
                    ppsi->iOriginalPercent = ppsi->iPercent;
                }
            }
        }
        break;

        SetDlgMsgResult(hDlg, WM_NOTIFY, 0);
        return TRUE;
    }

    return FALSE;
}

BOOL_PTR CALLBACK CBitBucket::_DriveDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BBPROPSHEETINFO *ppsi = (BBPROPSHEETINFO *)GetWindowLongPtr(hDlg, DWLP_USER);
    TCHAR szDiskSpace[40];

    switch (uMsg) 
    {
    case WM_INITDIALOG: 
    {
        HWND hwndTrack = GetDlgItem(hDlg, IDC_BBSIZE);

        ppsi = (BBPROPSHEETINFO *)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        SendMessage(hwndTrack, TBM_SETTICFREQ, 10, 0);
        SendMessage(hwndTrack, TBM_SETRANGE, FALSE, MAKELONG(0, 100));
        SendMessage(hwndTrack, TBM_SETPOS, TRUE, ppsi->iPercent);
        CheckDlgButton(hDlg, IDC_NUKEONDELETE, ppsi->fNukeOnDelete);

        // set the disk space info
        StrFormatByteSize64(g_pBitBucket[ppsi->idDrive]->qwDiskSize, szDiskSpace, ARRAYSIZE(szDiskSpace));
        SetDlgItemText(hDlg, IDC_DISKSIZEDATA, szDiskSpace);
        wParam = 0;
    }
    // fall through

    case WM_HSCROLL:
    {
        ULARGE_INTEGER ulBucketSize;
        HWND hwndTrack = GetDlgItem(hDlg, IDC_BBSIZE);
        ppsi->iPercent = (int)SendMessage(hwndTrack, TBM_GETPOS, 0, 0);

        // ok to truncate since this is for display only
        StringCchPrintf(szDiskSpace, ARRAYSIZE(szDiskSpace), TEXT("%d%%"), ppsi->iPercent);
        SetDlgItemText(hDlg, IDC_BBSIZETEXT, szDiskSpace);
                   
        if (ppsi->iPercent != ppsi->iOriginalPercent) 
        {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
        }

        // we peg the max size of the recycle bin to 4 gig
        ulBucketSize.QuadPart = (ppsi->pGlobal->fUseGlobalSettings ? ppsi->pGlobal->iPercent : ppsi->iPercent) * (g_pBitBucket[ppsi->idDrive]->qwDiskSize / 100);
        StrFormatByteSize64(ulBucketSize.HighPart ? (DWORD)-1 : ulBucketSize.LowPart, szDiskSpace, ARRAYSIZE(szDiskSpace));
        SetDlgItemText(hDlg, IDC_BYTESIZEDATA, szDiskSpace);
        return TRUE;
    }

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBitBucketPropHelpIDs);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(void *) aBitBucketPropHelpIDs);
        return TRUE;

    case WM_COMMAND:
        {
            WORD wCommandID = GET_WM_COMMAND_ID(wParam, lParam);
            if (wCommandID == IDC_NUKEONDELETE)
            {
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                EnableTrackbarAndFamily(hDlg, !IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE) && !ppsi->fPolicyPercent);
                EnableWindow(GetDlgItem(hDlg, IDC_BYTESIZE), !IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE));
                EnableWindow(GetDlgItem(hDlg, IDC_BYTESIZEDATA), !IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE));
            }
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_APPLY:
            {
                ppsi->fNukeOnDelete = (IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE) == BST_CHECKED) ? TRUE : FALSE;

                // update the info in the registry
                if (!PersistBBDriveSettings(ppsi->idDrive, ppsi->iPercent, ppsi->fNukeOnDelete))
                {
                    // we failed, so show the error dialog and bail
                    ShellMessageBox(HINST_THISDLL, hDlg,
                                    MAKEINTRESOURCE(IDS_BB_CANNOTCHANGESETTINGS),
                                    MAKEINTRESOURCE(IDS_WASTEBASKET),
                                    MB_OK | MB_ICONEXCLAMATION);

                    SetDlgMsgResult(hDlg, WM_NOTIFY, PSNRET_INVALID_NOCHANGEPAGE);
                    return TRUE;
                }
            
                // only purge this drive if the user set the slider to a smaller value       
                if (ppsi->iPercent < ppsi->iOriginalPercent)
                {
                    BOOL bPurge = TRUE;

                    // since this drive just shrunk, we need to purge the files in it
                    RegSetValueEx(g_pBitBucket[ppsi->idDrive]->hkeyPerUser, TEXT("NeedToPurge"), 0, REG_DWORD, (LPBYTE)&bPurge, sizeof(bPurge));
                }

                ppsi->iOriginalPercent = ppsi->iPercent;
                ppsi->fOriginalNukeOnDelete = ppsi->fNukeOnDelete;
            
                // update the g_pBitBucket[] for this drive

                // NOTE: We get a PSN_APPLY before the global tab does. This has to be this way so that
                // if global settings change, then the global tab will re-apply all the most current settings
                // bassed on the global variables that get set in his tab.
                RefreshBBDriveSettings(ppsi->idDrive);
            }
            break;

        case PSN_SETACTIVE:
            {   
                BOOL fNukeOnDelete;
                fNukeOnDelete = ppsi->pGlobal->fUseGlobalSettings ? ppsi->pGlobal->fNukeOnDelete :
                                                                    IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE);

                EnableWindow(GetDlgItem(hDlg, IDC_NUKEONDELETE), !ppsi->pGlobal->fUseGlobalSettings && !ppsi->fPolicyNukeOnDelete);
                EnableTrackbarAndFamily(hDlg, !ppsi->pGlobal->fUseGlobalSettings && !fNukeOnDelete && !ppsi->fPolicyPercent);
                EnableWindow(GetDlgItem(hDlg, IDC_BYTESIZE), !fNukeOnDelete);
                EnableWindow(GetDlgItem(hDlg, IDC_BYTESIZEDATA), !fNukeOnDelete);

                // send this to make sure that the "space reserved" field is accurate when using global settings
                SendMessage(hDlg, WM_HSCROLL, 0, 0);
            }
            break;
        }

        SetDlgMsgResult(hDlg, WM_NOTIFY, 0);
        return TRUE;
    }

    return FALSE;
}


typedef struct {
    PROPSHEETPAGE psp;
    LPITEMIDLIST pidl;
    FILETIME ftDeleted;
    DWORD dwSize;
    TCHAR szOriginal[MAX_PATH];
} BBFILEPROPINFO;


// property sheet page for a file/folder in the bitbucket

BOOL_PTR CALLBACK CBitBucket::_FilePropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BBFILEPROPINFO * pbbfpi = (BBFILEPROPINFO *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR szTemp[MAX_PATH];

            pbbfpi = (BBFILEPROPINFO *)lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            
            SHFILEINFO sfi = {0};
            SHGetFileInfo((LPTSTR)pbbfpi->pidl, 0, &sfi, sizeof(sfi), 
                SHGFI_PIDL | SHGFI_TYPENAME | SHGFI_ICON | SHGFI_LARGEICON | SHGFI_ADDOVERLAYS | SHGFI_DISPLAYNAME);
            
            // icon
            ReplaceDlgIcon(hDlg, IDD_ITEMICON, sfi.hIcon);
            
            // Type
            SetDlgItemText(hDlg, IDD_FILETYPE, sfi.szTypeName);
            
            // ok to truncate since this is for display
            StringCchCopy(szTemp, ARRAYSIZE(szTemp), pbbfpi->szOriginal);
            PathRemoveExtension(szTemp);
            SetDlgItemText(hDlg, IDD_NAME, PathFindFileName(szTemp));
            
            // origin
            PathRemoveFileSpec(szTemp);
            SetDlgItemText(hDlg, IDD_LOCATION, PathFindFileName(szTemp));
            
            // deleted time
            SetDateTimeText(hDlg, IDD_DELETED, &pbbfpi->ftDeleted);
            
            // Size
            StrFormatByteSize64(pbbfpi->dwSize, szTemp, ARRAYSIZE(szTemp));
            SetDlgItemText(hDlg, IDD_FILESIZE, szTemp);
                
            if (SHGetPathFromIDList(pbbfpi->pidl, szTemp))
            {
                WIN32_FIND_DATA fd;
                HANDLE hfind = FindFirstFile(szTemp, &fd);
                if (hfind != INVALID_HANDLE_VALUE)
                {
                    SetDateTimeText(hDlg, IDD_CREATED, &fd.ftCreationTime);
                    FindClose(hfind);

                    // We don't allow user to change compression attribute on a deleted file
                    // but we do show the current compressed state
                    TCHAR szRoot[MAX_PATH], szFSName[12];
            
                    // If file's volume doesn't support compression, don't show
                    // "Compressed" checkbox.
                    // If compression is supported, show the checkbox and check/uncheck
                    // it to indicate compression state of the file
                    StringCchCopy(szRoot, ARRAYSIZE(szRoot), szTemp);   // ok to truncate since we strip to root below
                    PathStripToRoot(szRoot);
                    PathAddBackslash(szRoot);    // for UNC (MyDocs) case

                    DWORD dwVolumeFlags;
                    if (GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, &dwVolumeFlags, szFSName, ARRAYSIZE(szFSName)))
                    {
                        if (dwVolumeFlags & FS_FILE_COMPRESSION)
                        {
                            if (fd.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED)
                                CheckDlgButton(hDlg, IDD_COMPRESS, 1);
                            ShowWindow(GetDlgItem(hDlg, IDD_COMPRESS), SW_SHOW);
                        }
                
                        if (dwVolumeFlags & FS_FILE_ENCRYPTION)
                        {
                            if (fd.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)
                                CheckDlgButton(hDlg, IDD_ENCRYPT, 1);
                            ShowWindow(GetDlgItem(hDlg, IDD_ENCRYPT), SW_SHOW);
                        }
                    }
                
                    // file attributes
                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
                        CheckDlgButton(hDlg, IDD_READONLY, 1);
                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE)
                        CheckDlgButton(hDlg, IDD_ARCHIVE, 1);
                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
                        CheckDlgButton(hDlg, IDD_HIDDEN, 1);
                }
            }
        }
        break;

    case WM_WININICHANGE:
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        RelayMessageToChildren(hDlg, uMsg, wParam, lParam);
        break;

    case WM_DESTROY:
        ReplaceDlgIcon(hDlg, IDD_ITEMICON, NULL);
        break;

    case WM_COMMAND:
        {
            UINT id = GET_WM_COMMAND_ID(wParam, lParam);
            switch (id)
            {
            case IDD_RESTORE:
                if (S_OK == SHInvokeCommandOnPidl(hDlg, NULL, pbbfpi->pidl, 0, "undelete"))
                {
                    // We succeeded, so disable the button (invoking again will fail)
                    EnableWindow(GetDlgItem(hDlg, IDD_RESTORE), FALSE);
                }
                break;
            }
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_APPLY:
        case PSN_SETACTIVE:
        case PSN_KILLACTIVE:
            return TRUE;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBitBucketHelpIDs);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(void *) aBitBucketHelpIDs);
        return TRUE;
    }

    return FALSE;
}

HRESULT CBitBucket::_GetDriveDisplayName(int idDrive, LPTSTR pszName, UINT cchSize)
{
    TCHAR szDrive[MAX_PATH];
    HRESULT hr = E_UNEXPECTED;

    if (DriveIDToBBRoot(idDrive, szDrive))
    {
        SHFILEINFO sfi;

        if (SHGetFileInfo(szDrive, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME))
        {
            hr = StringCchCopy(pszName, cchSize, sfi.szDisplayName);
        }
        
        // If SERVERDRIVE, attempt to overwrite the default display name with the display
        // name for the mydocs folder on the desktop, since SERVERDRIVE==mydocs for now
        if (idDrive == SERVERDRIVE) 
        {
            hr = GetMyDocumentsDisplayName(pszName, cchSize);
        }
    }

    return hr;
}

BOOL CALLBACK CBitBucket::_AddPagesCallback(HPROPSHEETPAGE psp, LPARAM lParam)
{
    LPPROPSHEETHEADER ppsh = (LPPROPSHEETHEADER)lParam;

    ppsh->phpage[ppsh->nPages] = psp;
    ppsh->nPages++;
    
    return TRUE;
}

// properties for recycle bin
void CBitBucket::_DefaultProperties()
{
    UNIQUESTUBINFO usi;
    if (EnsureUniqueStub(_pidl, STUBCLASS_PROPSHEET, NULL, &usi))
    {
        HPROPSHEETPAGE ahpage[MAXPROPPAGES];
        PROPSHEETHEADER psh = {0};

        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_PROPTITLE;
        psh.hInstance = HINST_THISDLL;
        psh.phpage = ahpage;

        AddPages(_AddPagesCallback, (LPARAM)&psh);

        psh.pszCaption = MAKEINTRESOURCE(IDS_WASTEBASKET);
        psh.hwndParent = usi.hwndStub;
        
        PropertySheet(&psh);
        
        FreeUniqueStub(&usi);
    }
}

// deals with alignment and pidl validation for you
void CBitBucket::_GetDeletedFileTime(LPCITEMIDLIST pidl, FILETIME *pft)
{
    ZeroMemory(pft, sizeof(*pft));
    PUBBDATAENTRYA pbbde = _IsValid(pidl);
    if (pbbde)
        *pft = pbbde->ft;
}

DWORD CBitBucket::_GetDeletedSize(LPCITEMIDLIST pidl)
{
    PUBBDATAENTRYA pbbde = _IsValid(pidl);
    return pbbde ? pbbde->dwSize : 0;
}

// recycled items properties
// note: we only show the proeprties for the first file if there is a multiple selection
void CBitBucket::_FileProperties(IDataObject *pdtobj)
{
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        BBFILEPROPINFO bbfpi = {0};
        bbfpi.pidl = IDA_FullIDList(pida, 0);
        if (bbfpi.pidl)
        {
            UNIQUESTUBINFO usi;
            if (EnsureUniqueStub(bbfpi.pidl, STUBCLASS_PROPSHEET, NULL, &usi)) 
            {
                HPROPSHEETPAGE ahpage[MAXPROPPAGES];
                TCHAR szTitle[80];

                bbfpi.psp.dwSize = sizeof(bbfpi);
                bbfpi.psp.hInstance = HINST_THISDLL;
                bbfpi.psp.pszTemplate = MAKEINTRESOURCE(DLG_DELETEDFILEPROP);
                bbfpi.psp.pfnDlgProc = _FilePropDlgProc;
                bbfpi.psp.pszTitle = szTitle;

                _OriginalPath(IDA_GetIDListPtr(pida, 0), bbfpi.szOriginal, ARRAYSIZE(bbfpi.szOriginal));
                bbfpi.dwSize = _GetDeletedSize(IDA_GetIDListPtr(pida, 0));

                _GetDeletedFileTime(IDA_GetIDListPtr(pida, 0), &bbfpi.ftDeleted);

                // ok to truncate since this is for display only
                StringCchCopy(szTitle, ARRAYSIZE(szTitle), PathFindFileName(bbfpi.szOriginal));
                PathRemoveExtension(szTitle);

                PROPSHEETHEADER psh = {0};
                psh.dwSize = sizeof(psh);
                psh.dwFlags = PSH_PROPTITLE;
                psh.hInstance = HINST_THISDLL;
                psh.phpage = ahpage;

                psh.phpage[0] = CreatePropertySheetPage(&bbfpi.psp);
                if (psh.phpage[0])
                {
                    psh.nPages = 1;
                    psh.pszCaption = szTitle;

                    psh.hwndParent = usi.hwndStub;
                    PropertySheet(&psh);
                }

                FreeUniqueStub(&usi);
            }
            ILFree(bbfpi.pidl);
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return;
}

DWORD WINAPI CBitBucket::_DropThreadInit(BBTHREADDATA *pbbtd)
{
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (SUCCEEDED(pbbtd->pdtobj->GetData(&fmte, &medium))) 
    {
        // call delete here so that files will be moved in
        // their respective bins, not necessarily this one.
        DRAGINFO di;

        di.uSize = sizeof(DRAGINFO);

        if (DragQueryInfo((HDROP) medium.hGlobal, &di))
        {
            // Since BBWillRecycle() can return true even when the file will NOT be
            // recycled (eg the file will be nuked), we want to warn the user when we 
            // are going to nuke something that they initiall thought that it would
            // be recycled
            UINT fOptions = SD_WARNONNUKE; 

            if (!BBWillRecycle(di.lpFileList, NULL) ||
                (di.lpFileList && (di.lpFileList[lstrlen(di.lpFileList)+1] == 0)
                 && PathIsShortcutToProgram(di.lpFileList)))
                fOptions = SD_USERCONFIRMATION; 

            if (IsFileInBitBucket(di.lpFileList)) 
            {
                LPITEMIDLIST *ppidl = NULL;
                int cidl = CreateMoveCopyList((HDROP)medium.hGlobal, NULL, &ppidl);
                if (ppidl) 
                {
                    // Bug#163533 (edwardp 8/15/00) Change this to use PositionItems.
                    PositionItems_DontUse(pbbtd->hwnd, cidl, ppidl, pbbtd->pdtobj, &pbbtd->ptDrop, pbbtd->fDragDrop, FALSE);
                    FreeIDListArray(ppidl, cidl);
                }
            } 
            else 
            {
                TransferDelete(pbbtd->hwnd, (HDROP) medium.hGlobal, fOptions);
            }

            SHChangeNotifyHandleEvents();
            SHFree(di.lpFileList);
        }
        ReleaseStgMedium(&medium);
    }
    return 0;
}


DWORD CALLBACK CBitBucket::_DispatchThreadProc(void *pv)
{
    BBTHREADDATA *pbbtd = (BBTHREADDATA *)pv;

    if (pbbtd->pstmDataObj)
    {
        CoGetInterfaceAndReleaseStream(pbbtd->pstmDataObj, IID_PPV_ARG(IDataObject, &pbbtd->pdtobj));
        pbbtd->pstmDataObj = NULL;  // this is dead
    }

    switch (pbbtd->idCmd)
    {
    case DFM_CMD_MOVE:
        if (pbbtd->pdtobj)
            _DropThreadInit(pbbtd);
        break;

    case DFM_CMD_PROPERTIES:
    case FSIDM_PROPERTIESBG:
        if (pbbtd->pdtobj)
            pbbtd->pbb->_FileProperties(pbbtd->pdtobj);
        else
            pbbtd->pbb->_DefaultProperties();   // no data object for the background
        break;

    case DFM_CMD_DELETE:
        if (pbbtd->pdtobj)
            pbbtd->pbb->_NukeFileList(pbbtd->hwnd, pbbtd->pdtobj);
        break;

    case FSIDM_RESTORE:
        if (pbbtd->pdtobj)
            pbbtd->pbb->_RestoreFileList(pbbtd->hwnd, pbbtd->pdtobj);
        break;
    }

    if (pbbtd->pdtobj)
        pbbtd->pdtobj->Release();

    pbbtd->pbb->Release();

    LocalFree((HLOCAL)pbbtd);
    return 0;
}

HRESULT CBitBucket::_LaunchThread(HWND hwnd, IDataObject *pdtobj, WPARAM idCmd)
{
    HRESULT hr = E_OUTOFMEMORY;
    BBTHREADDATA *pbbtd = (BBTHREADDATA *)LocalAlloc(LPTR, sizeof(*pbbtd));
    if (pbbtd)
    {
        pbbtd->hwnd = hwnd;
        pbbtd->idCmd = idCmd;
        pbbtd->pbb = this;
        pbbtd->pbb->AddRef();

        if (idCmd == DFM_CMD_MOVE)
            pbbtd->fDragDrop = (BOOL)ShellFolderView_GetDropPoint(hwnd, &pbbtd->ptDrop);

        if (pdtobj)
            CoMarshalInterThreadInterfaceInStream(IID_IDataObject, (IUnknown *)pdtobj, &pbbtd->pstmDataObj);

        if (SHCreateThread(_DispatchThreadProc, pbbtd, CTF_COINIT, NULL))
        {
            hr = S_OK;
        }
        else
        {
            if (pbbtd->pstmDataObj)
                pbbtd->pstmDataObj->Release();

            pbbtd->pbb->Release();
            LocalFree((HLOCAL)pbbtd);
        }
    }
    return hr;
}

HRESULT GetVerb(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL bUnicode)
{
    HRESULT hr;
    LPCTSTR psz;

    switch (idCmd)
    {
    case FSIDM_RESTORE:
        psz = TEXT("undelete");
        break;

    case FSIDM_PURGEALL:
        psz = TEXT("empty");
        break;

    default:
        return E_NOTIMPL;
    }

    if (bUnicode)
        hr = SHTCharToUnicode(psz, (LPWSTR)pszName, cchMax);
    else
        hr = SHTCharToAnsi(psz, (LPSTR)pszName, cchMax);

    return hr;
}

CBitBucket *CBitBucket::_FromFolder(IShellFolder *psf)
{
    CBitBucket *pbbf = NULL;
    if (psf)
        psf->QueryInterface(CLSID_RecycleBin, (void **)&pbbf);
    return pbbf;
}

// item context menu callback
HRESULT CALLBACK CBitBucket::_ItemMenuCallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, 
                                               UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBitBucket *pbbf = _FromFolder(psf);
    HRESULT hr = S_OK;     // assume no error

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_BITBUCKET_ITEM, 0, (QCMINFO *)lParam);
        hr = S_OK;
        break;
        
    case DFM_GETDEFSTATICID:
        *(WPARAM *)lParam = DFM_CMD_PROPERTIES;
        hr = S_OK;
        break;
        
    case DFM_MAPCOMMANDNAME:
        if (lstrcmpi((LPCTSTR)lParam, TEXT("undelete")) == 0)
        {
            *(UINT_PTR *)wParam = FSIDM_RESTORE;
        }
        else
        {
            hr = E_FAIL;    // command not found
        }
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam) 
        {
        case FSIDM_RESTORE:
        case DFM_CMD_DELETE:
        case DFM_CMD_PROPERTIES:
            hr = pbbf->_LaunchThread(hwnd, pdtobj, wParam);
            break;

        default:
            hr = S_FALSE;
            break;
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETVERBA:
    case DFM_GETVERBW:
        hr = GetVerb((UINT_PTR)(LOWORD(wParam)), (LPSTR)lParam, (UINT)(HIWORD(wParam)), uMsg == DFM_GETVERBW);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

class CBitBucketDropTarget : public CIDLDropTarget
{
public:
    CBitBucketDropTarget(HWND hwnd, CBitBucket *pbbf) : CIDLDropTarget(hwnd), _pbbf(pbbf) 
    { 
        _pbbf->AddRef();
    }

    // IDropTarget (override base class)
    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    ~CBitBucketDropTarget()
    {
        _pbbf->Release();
    }

    CBitBucket *_pbbf;
};

//
//  This function puts DROPEFFECT_LINK in *pdwEffect, only if the data object
//  contains one or more net resource.
//
STDMETHODIMP CBitBucketDropTarget::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    TraceMsg(TF_BITBUCKET, "Bitbucket: CBitBucketDropTarget::DragEnter");

    // Call the base class first
    CIDLDropTarget::DragEnter(pDataObj, grfKeyState, pt, pdwEffect);

    // we don't really care what is in the data object, as long as move
    // is supported by the source we say you can move it to the wastbasket
    // in the case of files we will do the regular recycle bin stuff, if
    // it is not files we will just say it is moved and let the source delete it
    *pdwEffect &= DROPEFFECT_MOVE;

    m_dwEffectLastReturned = *pdwEffect;

    return S_OK;
}


// This function creates a connection to a dropped net resource object.
STDMETHODIMP CBitBucketDropTarget::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    BOOL fWebFoldersHack = FALSE;
    HRESULT hr;

    // only move operation is allowed
    *pdwEffect &= DROPEFFECT_MOVE;

    if (*pdwEffect)
    {
        hr = CIDLDropTarget::DragDropMenu(DROPEFFECT_MOVE, pDataObj,
                pt, pdwEffect, NULL, NULL, POPUP_NONDEFAULTDD, grfKeyState);

        if (hr == S_FALSE)
        {
            // let callers know where this is about to go
            // Defview cares where it went so it can handle non-filesys items
            // SHScrap cares because it needs to close the file so we can delete it
            DataObj_SetDropTarget(pDataObj, &CLSID_RecycleBin);

            if (DataObj_GetDWORD(pDataObj, g_cfNotRecyclable, 0))
            {
                if (ShellMessageBox(HINST_THISDLL, NULL,
                                    MAKEINTRESOURCE(IDS_CONFIRMNOTRECYCLABLE),
                                    MAKEINTRESOURCE(IDS_RECCLEAN_NAMETEXT),
                                    MB_SETFOREGROUND | MB_ICONQUESTION | MB_YESNO) == IDNO)
                {
                    *pdwEffect = DROPEFFECT_NONE;
                    goto lCancel;
                }
            }

            if (m_dwData & DTID_HDROP)  // CF_HDROP
            {
                _pbbf->_LaunchThread(_GetWindow(), pDataObj, DFM_CMD_MOVE);

                // since we will move the file ourself, known as an optimised move, 
                // we return zero here. this is per the OLE spec

                *pdwEffect = DROPEFFECT_NONE;
            }
            else
            {
                // if it was not files, we just say we moved the data, letting the
                // source deleted it. lets hope they support undo...

                *pdwEffect = DROPEFFECT_MOVE;

                // HACK: Put up a "you can't undo this" warning for web folders.
                {
                    STGMEDIUM stgmed;
                    LPIDA pida = DataObj_GetHIDA(pDataObj, &stgmed);
                    if (pida)
                    {
                        LPCITEMIDLIST pidl = IDA_GetIDListPtr(pida, -1);
                        if (pidl)
                        {
                            IPersist *pPers;
                            hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IPersist, &pPers), NULL);
                            if (SUCCEEDED(hr))
                            {
                                CLSID clsidSource;
                                hr = pPers->GetClassID(&clsidSource);
                                if (SUCCEEDED(hr) &&
                                    IsEqualGUID(clsidSource, CLSID_WebFolders))
                                {
                                    if (ShellMessageBox(HINST_THISDLL, NULL,
                                                        MAKEINTRESOURCE(IDS_CONFIRMNOTRECYCLABLE),
                                                        MAKEINTRESOURCE(IDS_RECCLEAN_NAMETEXT),
                                                        MB_SETFOREGROUND | MB_ICONQUESTION | MB_YESNO) == IDNO)
                                    {
                                        *pdwEffect = DROPEFFECT_NONE;
                                        pPers->Release();
                                        HIDA_ReleaseStgMedium (pida, &stgmed);
                                        goto lCancel;
                                    }
                                    else
                                    {
                                        fWebFoldersHack = TRUE;
                                    }
                                }
                                pPers->Release();
                            }
                        }
                        HIDA_ReleaseStgMedium(pida, &stgmed);
                    }
                }
            }
lCancel:
            if (!fWebFoldersHack)
            {
                DataObj_SetDWORD(pDataObj, g_cfPerformedDropEffect, *pdwEffect);
                DataObj_SetDWORD(pDataObj, g_cfLogicalPerformedDropEffect, DROPEFFECT_MOVE);
            }
            else
            {
                // Make web folders really delete its source file.
                DataObj_SetDWORD (pDataObj, g_cfPerformedDropEffect, 0);
            }
        }
    }

    CIDLDropTarget::DragLeave();

    return S_OK;
}

HRESULT CALLBACK CBitBucket::_BackgroundMenuCallBack(IShellFolder *psf, HWND hwnd,
                IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBitBucket *pbbf = _FromFolder(psf);
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU_BOTTOM:
        if (!(wParam & (CMF_VERBSONLY | CMF_DVFILE)))
        {
            QCMINFO *pqcm = (QCMINFO*)lParam;
            UINT idFirst = pqcm->idCmdFirst;

            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_PROPERTIES_BG, 0, (QCMINFO *)lParam);

            if (SHRestricted(REST_BITBUCKNOPROP))
            {
                // Disable the Properties menu item
                EnableMenuItem(pqcm->hmenu, idFirst + FSIDM_PROPERTIESBG, MF_GRAYED | MF_BYCOMMAND);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_PROPERTIESBG:
            hr = pbbf->_LaunchThread(hwnd, NULL, FSIDM_PROPERTIESBG);
            break;

        case DFM_CMD_PASTE:
        case DFM_CMD_PROPERTIES:
            hr = S_FALSE;   // do this for me
            break;

        default:
            hr = E_FAIL;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

STDMETHODIMP CBitBucket::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        IShellFolderViewCB* psfvcb;
        hr = Create_CBitBucketViewCB(this, &psfvcb);
        if (SUCCEEDED(hr))
        {
            SFV_CREATE sSFV = {0};
            sSFV.cbSize   = sizeof(sSFV);
            sSFV.pshf     = SAFECAST(this, IShellFolder *);
            sSFV.psfvcb   = psfvcb;

            hr = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);

            psfvcb->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        CBitBucketDropTarget *pbbdt = new CBitBucketDropTarget(hwnd, this);
        if (pbbdt)
        {
            hr = pbbdt->_Init(_pidl);
            if (SUCCEEDED(hr))
                hr = pbbdt->QueryInterface(riid, ppv);
            pbbdt->Release();
        }
        else
            hr = E_OUTOFMEMORY;

    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        IContextMenu* pcmBase;
        hr = CDefFolderMenu_Create(NULL, hwnd, 0, NULL, SAFECAST(this, IShellFolder *), _BackgroundMenuCallBack,
                                   NULL, NULL, &pcmBase);
        if (SUCCEEDED(hr))
        {
            IContextMenu* pcmFolder = SAFECAST(this, IContextMenu*);
            IContextMenu* rgpcm[] = { pcmFolder, pcmBase };

            hr = Create_ContextMenuOnContextMenuArray(rgpcm, ARRAYSIZE(rgpcm), riid, ppv);

            pcmBase->Release();
        }
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

// search the database on idDrive for file with index iIndex

LPITEMIDLIST CBitBucket::_DriveInfoToIDList(int idDrive, int iIndex)
{
    LPITEMIDLIST pidl = NULL;
    HANDLE hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        // read records until we find an index match
        BBDATAENTRYW bbdew;

        while (ReadNextDataEntry(hFile, &bbdew, TRUE, idDrive))
        {
            if (bbdew.iIndex == iIndex)
            {
                ASSERT(idDrive == bbdew.idDrive);
                pidl = DataEntryToIDList(&bbdew);
                break;
            }
        }
        CloseBBInfoFile(hFile, idDrive);
    }
    return pidl;
}

// we implement this supporting D<drive_id><index>.ext

STDMETHODIMP CBitBucket::ParseDisplayName(HWND hwnd, IBindCtx *pbc, LPOLESTR pwszDisplayName, 
                                          ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    if (!ppidl)
        return E_INVALIDARG;

    *ppidl = NULL;
    
    if (!pwszDisplayName)
        return E_INVALIDARG;

    int idDrive, iIndex;
    HRESULT hr = BBFileNameToInfo(pwszDisplayName, &idDrive, &iIndex);
    if (SUCCEEDED(hr))
    {
        // since anyone can call us with a path that is under the recycled directory,
        // we need to check to make sure that we have inited this drive:
        if (MakeBitBucket(idDrive))
        {
            *ppidl = _DriveInfoToIDList(idDrive, iIndex);
            hr = *ppidl ? S_OK : E_FAIL;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

// takes a full path to a file in a recycle bin storage folder and creates a 
// single level bitbucket pidl

LPITEMIDLIST CBitBucket::PathToIDList(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl = NULL;
    int idDrive = DriveIDFromBBPath(pszPath);

    ASSERT(idDrive >= 0);       // general UNC case will generate -1

    int iIndex = BBPathToIndex(pszPath);
    if (iIndex != -1)
    {
        pidl = _DriveInfoToIDList(idDrive, iIndex);
    }
    return pidl;
}

STDMETHODIMP CBitBucket::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                       REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (cidl && IsEqualIID(riid, IID_IDataObject))
    {
        CBitBucketData *pbbd = new CBitBucketData(this, cidl, apidl);
        if (pbbd)
        {
            hr = pbbd->QueryInterface(riid, ppv);
            pbbd->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hr = CDefFolderMenu_Create(_pidl, hwnd, cidl, apidl,
            SAFECAST(this, IShellFolder *), _ItemMenuCallBack, NULL, NULL, (IContextMenu**)ppv);
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = E_FAIL; // You can't drop on internal items of the bitbucket!
    }
    else if (cidl == 1)
    {
        // blindly delegate unknown riid's to folder!
        IShellFolder *psf;
        hr = _FolderFromIDList(apidl[0], IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
            if (SUCCEEDED(hr) && IsEqualIID(riid, IID_IQueryInfo))
            {
                WrapInfotip(SAFECAST(this, IShellFolder2 *), apidl[0], &SCID_DELETEDFROM, (IUnknown *)*ppv);
            }
            psf->Release();
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

HRESULT CBitBucket::_FolderFromDrive(int idDrive, REFIID riid, void **ppv)
{
    *ppv = NULL;

    ASSERT(idDrive < ARRAYSIZE(_rgFolders));

    if (NULL == _rgFolders[idDrive])
    {
        PERSIST_FOLDER_TARGET_INFO pfti = {0};

        if (DriveIDToBBPath(idDrive, pfti.szTargetParsingName))
        {
            pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY;
            pfti.csidl = -1;

            CFSFolder_CreateFolder(NULL, NULL, _pidl, &pfti, IID_PPV_ARG(IUnknown, &_rgFolders[idDrive]));
        }
    }

    return _rgFolders[idDrive] ? _rgFolders[idDrive]->QueryInterface(riid, ppv) : E_FAIL;
}

// accepts NULL, or undecorated recycle bin pidl (raw file system pidl).
// in these cases computes the default recycle bin file system folder
// index so we will defer to that.

int CBitBucket::_DriveIDFromIDList(LPCITEMIDLIST pidl)
{
    int iDrive = 0;

    PUBBDATAENTRYA pbbde = _IsValid(pidl);
    if (pbbde)
    {
        iDrive = pbbde->idDrive;
    }
    else
    {
        // unknown, compute the default recycle bin folder index
        TCHAR szPath[MAX_PATH];
        if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)))
        {
            iDrive = PathGetDriveNumber(szPath);
            if (iDrive < 0)
                iDrive = 0;
        }
    }
    ASSERT(iDrive >= 0 && iDrive < ARRAYSIZE(_rgFolders));
    return iDrive;
}

// in:
//      pidl of item, or NULL for default folder (base recycle bin)

HRESULT CBitBucket::_FolderFromIDList(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    return _FolderFromDrive(_DriveIDFromIDList(pidl), riid, ppv);
}

// create a bitbucket pidl, start with the file system pidl, then add the extra data sections as needed

LPITEMIDLIST CBitBucket::DataEntryToIDList(BBDATAENTRYW *pbbde)
{
    WCHAR szFile[MAX_PATH];
    LPITEMIDLIST pidl = NULL;

    if (GetDeletedFileName(szFile, ARRAYSIZE(szFile), pbbde))
    {
        IShellFolder *psf;

        if (SUCCEEDED(_FolderFromDrive(pbbde->idDrive, IID_PPV_ARG(IShellFolder, &psf))))
        {
            if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, szFile, NULL, &pidl, NULL)))
            {
                HIDDENRECYCLEBINDATA hrbd = { {sizeof(hrbd), HRBD_CURRENTVERSION, IDLHID_RECYCLEBINDATA}};
                hrbd.bbde = *((LPBBDATAENTRYA)pbbde);

                pidl = ILAppendHiddenID(pidl, &hrbd.hid);
                if (pidl)
                {
                    if (g_pBitBucket[pbbde->idDrive]->fIsUnicode && 
                        !DoesStringRoundTrip(pbbde->szOriginal, NULL, 0))
                    {
                        pidl = ILAppendHiddenStringW(pidl, IDLHID_RECYCLEBINORIGINAL, pbbde->szOriginal);
                    }
                }
            }

            psf->Release();
        }
    }

    return pidl;
}

class CBitBucketEnum : public IEnumIDList
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IEnumIDList
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumIDList **ppenum);
    
    CBitBucketEnum(CBitBucket *pbbf, DWORD grfFlags);

private:
    HRESULT _BuildEnumDPA();
    ~CBitBucketEnum();

    LONG _cRef;
    CBitBucket *_pbbf;
    HDPA _hdpa;
    int _nItem;
    DWORD _grfFlags;
};

CBitBucketEnum::CBitBucketEnum(CBitBucket *pbbf, DWORD grfFlags) : 
    _cRef(1), _pbbf(pbbf), _grfFlags(grfFlags)
{
    _pbbf->AddRef();
}

CBitBucketEnum::~CBitBucketEnum()
{
    Reset();
    _pbbf->Release();
}

STDMETHODIMP CBitBucketEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBitBucketEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CBitBucketEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBitBucketEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


#ifdef DEBUG
#define BB_DELETED_ENTRY_MAX 10     // smaller to force compaction more often
#else
#define BB_DELETED_ENTRY_MAX 100
#endif

// on the first ::Next() call snapshot the data needed to do the enum

HRESULT CBitBucketEnum::_BuildEnumDPA()
{
    HRESULT hr = S_OK;

    if (NULL == _hdpa)
    {
        _hdpa = DPA_CreateEx(0, NULL);
        if (_hdpa)
        {
            if (_grfFlags & SHCONTF_NONFOLDERS) //if they asked for folders we have none so leave DPA empty
            {
                // loop through the bitbucket drives to find an info file
                for (int iBitBucket = 0; iBitBucket < MAX_BITBUCKETS; iBitBucket++)
                {
                    if (MakeBitBucket(iBitBucket)) 
                    {
                        int cDeleted = 0;
                        HANDLE hFile = OpenBBInfoFile(iBitBucket, OPENBBINFO_WRITE, 0);
                        if (INVALID_HANDLE_VALUE != hFile)
                        {
                            BBDATAENTRYW bbdew;

                            while (ReadNextDataEntry(hFile, &bbdew, FALSE, iBitBucket))
                            {
                                if (IsDeletedEntry(&bbdew))
                                    cDeleted++;
                                else
                                {
                                    ASSERT(iBitBucket == bbdew.idDrive);

                                    LPITEMIDLIST pidl = _pbbf->DataEntryToIDList(&bbdew);
                                    if (pidl)
                                    {
                                        if (-1 == DPA_AppendPtr(_hdpa, pidl))
                                            ILFree(pidl);
                                    }
                                }
                            }

                            if (cDeleted > BB_DELETED_ENTRY_MAX)
                            {
                                BOOL bTrue = TRUE;

                                // set the registry key so that we will compact the info file after the next delete operation
                                RegSetValueEx(g_pBitBucket[iBitBucket]->hkeyPerUser, TEXT("NeedToCompact"), 0, REG_DWORD, (LPBYTE)&bTrue, sizeof(bTrue));
                            }
                            CloseBBInfoFile(hFile, iBitBucket);
                        }
                    }
                }
            }    
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

STDMETHODIMP CBitBucketEnum::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    *ppidl = NULL;
    
    HRESULT hr = _BuildEnumDPA();
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)DPA_GetPtr(_hdpa, _nItem);
        if (pidl)
        {
            hr = SHILClone(pidl, ppidl);    
            _nItem++;
        }
        else
        {
            hr = S_FALSE; // no more items
        }
    }

    if (pceltFetched)
        *pceltFetched = (hr == S_OK) ? 1 : 0;

    return hr;
}

STDMETHODIMP CBitBucketEnum::Skip(ULONG celt) 
{
    HRESULT hr = E_FAIL;
    if (_hdpa)
    {
        _nItem += celt;
        if (_nItem >= DPA_GetPtrCount(_hdpa))
        {
            _nItem = DPA_GetPtrCount(_hdpa);
            hr = S_FALSE;
        }
        else
        {
            hr = S_OK;
        }
    }
        
    return hr;
}

STDMETHODIMP CBitBucketEnum::Reset()
{
    DPA_FreeIDArray(_hdpa);
    _hdpa = NULL;
    _nItem = 0;
    return S_OK;
}

STDMETHODIMP CBitBucketEnum::Clone(IEnumIDList **ppenum) 
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CBitBucket::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    *ppenum = NULL;

    HRESULT hr;
    CBitBucketEnum *penum = new CBitBucketEnum(this, grfFlags);
    if (penum)
    {
        hr = penum->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        penum->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP CBitBucket::BindToObject(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_NOTIMPL;
    if (riid != IID_IShellFolder && riid != IID_IShellFolder2)
    {
        // let IPropertySetStorage/IStream/etc binds go through
        IShellFolder *psf;
        hr = _FolderFromIDList(pidl, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->BindToObject(pidl, pbc, riid, ppv);
            psf->Release();
        }
    }
    return hr;
}

STDMETHODIMP CBitBucket::BindToStorage(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

DWORD CBitBucket::_IsFolder(LPCITEMIDLIST pidl)
{
    DWORD dwAttributes = SFGAO_FOLDER;
    HRESULT hr = GetAttributesOf(1, &pidl, &dwAttributes);
    return (SUCCEEDED(hr) && (SFGAO_FOLDER & dwAttributes)) ? FILE_ATTRIBUTE_DIRECTORY : 0;
}

STDMETHODIMP CBitBucket::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET *psr)
{
    HRESULT hr;
    // on change notifications we can get file system pidls that don't have our
    // extra data in them. in this case we need to delegate to the file system
    // folder
    if ((0 == (dwFlags & SHGDN_FORPARSING)) && _IsValid(pidl))
    {
        TCHAR szTemp[MAX_PATH];
        hr = _OriginalPath(pidl, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))
        {
            if (dwFlags & SHGDN_INFOLDER)
            {
                SHFILEINFO sfi;
                if (SHGetFileInfo(szTemp, _IsFolder(pidl), &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME))
                {
                    hr = StringToStrRet(sfi.szDisplayName, psr);
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = StringToStrRet(szTemp, psr);
            }
        }
    }
    else
    {
        IShellFolder *psf;
        hr = _FolderFromIDList(pidl, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetDisplayNameOf(pidl, dwFlags, psr);
            psf->Release();
        }
    }
    return hr;
}

STDMETHODIMP CBitBucket::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD dwRes, LPITEMIDLIST *ppidlOut)
{
    return E_FAIL;
}

STDMETHODIMP CBitBucket::GetDefaultSearchGUID(GUID *pguid)
{
    return DefaultSearchGUID(pguid);
}

STDMETHODIMP CBitBucket::EnumSearches(IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CBitBucket::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBitBucket::GetDefaultColumnState(UINT iColumn, DWORD *pdwState)
{
    HRESULT hr;
    if (_MapColIndex(&iColumn))
    {
        *pdwState = c_bb_cols[iColumn].csFlags | SHCOLSTATE_PREFER_VARCMP;
        hr = S_OK;
    }
    else
    {
        IShellFolder2 *psf;
        hr = _FolderFromIDList(NULL, IID_PPV_ARG(IShellFolder2, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetDefaultColumnState(iColumn, pdwState);
            psf->Release();
        }
    }
    return hr;
}

STDMETHODIMP CBitBucket::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr;
    if (IsEqualSCID(*pscid, SCID_DELETEDFROM))
    {
        TCHAR szTemp[MAX_PATH];
        hr = _OriginalDirectory(pidl, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))
            hr = InitVariantFromStr(pv, szTemp);
    }
    else if (IsEqualSCID(*pscid, SCID_DATEDELETED))
    {
        FILETIME ft;
        _GetDeletedFileTime(pidl, &ft);
        hr = InitVariantFromFileTime(&ft, pv);
    }
    else if (IsEqualSCID(*pscid, SCID_DIRECTORY))
    {
        // don't let this get through to file folder as we want to hide
        // the real file system folder from callers
        VariantInit(pv);
        hr = E_FAIL;
    }
    else if (IsEqualSCID(*pscid, SCID_SIZE))
    {
        pv->ullVal = _GetDeletedSize(pidl);
        pv->vt = VT_UI8;
        hr = S_OK;
    }
    else 
    {
        IShellFolder2 *psf;
        hr = _FolderFromIDList(pidl, IID_PPV_ARG(IShellFolder2, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetDetailsEx(pidl, pscid, pv);
            psf->Release();
        }
    }
    return hr;
}

BOOL CBitBucket::_MapColIndex(UINT *piColumn)
{
    switch (*piColumn)
    {
    case ICOL_NAME:             // 0
    case ICOL_ORIGINAL:         // 1
    case ICOL_DATEDELETED:      // 2
        return TRUE;

    default:                    // >= 3
        *piColumn -= ICOL_DATEDELETED;
        return FALSE;
    }
}

STDMETHODIMP CBitBucket::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi)
{
    HRESULT hr;
    if (_MapColIndex(&iColumn))
    {
        if (pidl)
        {
            TCHAR szTemp[MAX_PATH];
            szTemp[0] = 0;

            switch (iColumn)
            {
            case ICOL_NAME:
                DisplayNameOf(this, pidl, SHGDN_INFOLDER, szTemp, ARRAYSIZE(szTemp));
                break;

            case ICOL_ORIGINAL:
                _OriginalDirectory(pidl, szTemp, ARRAYSIZE(szTemp));
                break;

            case ICOL_DATEDELETED:
                {
                    FILETIME ft;
                    _GetDeletedFileTime(pidl, &ft);
                    DWORD dwFlags = FDTF_DEFAULT;

                    switch (pdi->fmt)
                    {
                    case LVCFMT_LEFT_TO_RIGHT:
                        dwFlags |= FDTF_LTRDATE;
                        break;

                    case LVCFMT_RIGHT_TO_LEFT:
                        dwFlags |= FDTF_RTLDATE;
                        break;
                    }

                    SHFormatDateTime(&ft, &dwFlags, szTemp, ARRAYSIZE(szTemp));
                }
                break;
            }
            hr = StringToStrRet(szTemp, &pdi->str);
        }
        else
        {
            hr = GetDetailsOfInfo(c_bb_cols, ARRAYSIZE(c_bb_cols), iColumn, pdi);
        }
    }
    else
    {
        if (pidl && (_SizeColumn() == iColumn))
        {
            TCHAR szTemp[64];
            StrFormatKBSize(_GetDeletedSize(pidl), szTemp, ARRAYSIZE(szTemp));
            hr = StringToStrRet(szTemp, &pdi->str);
        }
        else
        {
            IShellFolder2 *psf;
            hr = _FolderFromIDList(pidl, IID_PPV_ARG(IShellFolder2, &psf));
            if (SUCCEEDED(hr))
            {
                hr = psf->GetDetailsOf(pidl, iColumn, pdi);
                psf->Release();
            }
        }
    }
    return hr;
}

UINT CBitBucket::_SizeColumn()
{
    if (-1 == _uiColumnSize)
    {
        _uiColumnSize = MapSCIDToColumn(SAFECAST(this, IShellFolder2 *), &SCID_SIZE);
        _MapColIndex(&_uiColumnSize);    // map to other folder index space
    }
    return _uiColumnSize;
}

STDMETHODIMP CBitBucket::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    HRESULT hr;
    if (_MapColIndex(&iColumn))
    {
        hr = MapColumnToSCIDImpl(c_bb_cols, ARRAYSIZE(c_bb_cols), iColumn, pscid);
    }
    else
    {
        IShellFolder2 *psf;
        hr = _FolderFromIDList(NULL, IID_PPV_ARG(IShellFolder2, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->MapColumnToSCID(iColumn, pscid);
            psf->Release();
        }
    }
    return hr;
}


// IPersist
STDMETHODIMP CBitBucket::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_RecycleBin;
    return S_OK;
}

// IPersistFolder
STDMETHODIMP CBitBucket::Initialize(LPCITEMIDLIST pidl)
{
    return Pidl_Set(&_pidl, pidl) ? S_OK : E_OUTOFMEMORY;
}

// IPersistFolder2
STDMETHODIMP CBitBucket::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(_pidl, ppidl);
}

// IShellExtInit
STDMETHODIMP CBitBucket::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    return S_OK;
}

// IContextMenu
STDMETHODIMP CBitBucket::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    int idMax = idCmdFirst;
    HMENU hmMerge = SHLoadPopupMenu(HINST_THISDLL, POPUP_BITBUCKET_POPUPMERGE);
    if (hmMerge)
    {
        if (IsRecycleBinEmpty())
        {
            EnableMenuItem(hmMerge, FSIDM_PURGEALL, MF_GRAYED | MF_BYCOMMAND);
        }
        
        idMax = Shell_MergeMenus(hmenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, 0);

        DestroyMenu(hmMerge);
    }

    return ResultFromShort(idMax - idCmdFirst);
}

const ICIVERBTOIDMAP c_sBBCmdInfo[] = {
    { L"empty", "empty", FSIDM_PURGEALL, FSIDM_PURGEALL, },
};

STDMETHODIMP CBitBucket::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT idCmd;
    HRESULT hr = SHMapICIVerbToCmdID(pici, c_sBBCmdInfo, ARRAYSIZE(c_sBBCmdInfo), &idCmd);
    if (SUCCEEDED(hr))
    {
        switch (idCmd)
        {
        case FSIDM_PURGEALL:
            hr = BBPurgeAll(pici->hwnd, 0);

            // command is ours, let caller know we processed it (but we want the right success code)
            if (FAILED(hr))
                hr = S_FALSE;
            break;

        default:
            hr = E_FAIL;
            break;
        }
    }

    return hr;
}

STDMETHODIMP CBitBucket::GetCommandString(UINT_PTR idCmd, UINT  wFlags, UINT * pwReserved, LPSTR pszName, UINT cchMax)
{
    switch (wFlags)
    {
    case GCS_VERBA:
    case GCS_VERBW:
        return SHMapCmdIDToVerb(idCmd, c_sBBCmdInfo, ARRAYSIZE(c_sBBCmdInfo), pszName, cchMax, wFlags == GCS_VERBW);

    case GCS_HELPTEXTA:
        return LoadStringA(HINST_THISDLL,
                          (UINT)(idCmd + IDS_MH_FSIDM_FIRST),
                          pszName, cchMax) ? S_OK : E_OUTOFMEMORY;
    case GCS_HELPTEXTW:
        return LoadStringW(HINST_THISDLL,
                          (UINT)(idCmd + IDS_MH_FSIDM_FIRST),
                          (LPWSTR)pszName, cchMax) ? S_OK : E_OUTOFMEMORY;
    default:
        return E_NOTIMPL;
    }
}

//
//  Callback function that saves the location of the HPROPSHEETPAGE's
//  LPPROPSHEETPAGE so we can pass it to other propsheet pages.
//
UINT CALLBACK CBitBucket::_GlobalSettingsCalback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    switch (uMsg)
    {
    case PSPCB_ADDREF:
        {
            // we save off the address of the "real" ppsi in the pGlobal param of the
            // the template, so that the other drives can get to the global page information
            BBPROPSHEETINFO *ppsiGlobal = (BBPROPSHEETINFO *)ppsp;
            BBPROPSHEETINFO *ppsiTemplate = (BBPROPSHEETINFO *)ppsp->lParam;
            ppsiTemplate->pGlobal = ppsiGlobal;
            ppsiGlobal->pGlobal = ppsiGlobal;
        }
        break;

    case PSPCB_CREATE:
        return TRUE;                    // Yes, please create me
    }
    return 0;
}

STDMETHODIMP CBitBucket::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HRESULT hr;
    
    if (SHRestricted(REST_BITBUCKNOPROP))
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        BBPROPSHEETINFO bbpsp;
        TCHAR szTitle[MAX_PATH];

        // read in the global settings
        DWORD dwSize1 = sizeof(bbpsp.fUseGlobalSettings);
        DWORD dwSize2 = sizeof(bbpsp.iOriginalPercent);
        DWORD dwSize3 = sizeof(bbpsp.fOriginalNukeOnDelete);
        if (RegQueryValueEx(g_hkBitBucket, TEXT("UseGlobalSettings"), NULL, NULL, (LPBYTE)&bbpsp.fOriginalUseGlobalSettings, &dwSize1) != ERROR_SUCCESS ||
            RegQueryValueEx(g_hkBitBucket, TEXT("Percent"), NULL, NULL, (LPBYTE)&bbpsp.iOriginalPercent, &dwSize2) != ERROR_SUCCESS ||
            RegQueryValueEx(g_hkBitBucket, TEXT("NukeOnDelete"), NULL, NULL, (LPBYTE)&bbpsp.fOriginalNukeOnDelete, &dwSize3) != ERROR_SUCCESS)
        {
            ASSERTMSG(FALSE, "Bitbucket: could not read global settings from the registry, re-regsvr32 shell32.dll!!");
            bbpsp.fUseGlobalSettings = TRUE;
            bbpsp.iOriginalPercent = 10;
            bbpsp.fOriginalNukeOnDelete = FALSE;
        }
        bbpsp.iOriginalPercent = max(0, min(100, bbpsp.iOriginalPercent));

        // Check policies

        bbpsp.fPolicyNukeOnDelete = SHRestricted(REST_BITBUCKNUKEONDELETE);
        if (bbpsp.fPolicyNukeOnDelete)
        {
            bbpsp.fOriginalNukeOnDelete = TRUE;
            bbpsp.fOriginalUseGlobalSettings = TRUE;
        }

        bbpsp.fPolicyPercent = (ReadPolicySetting(NULL,
                                                L"Explorer",
                                                L"RecycleBinSize",
                                                (LPBYTE)&bbpsp.iPercent,
                                                sizeof(bbpsp.iPercent)) == ERROR_SUCCESS);
        if (bbpsp.fPolicyPercent)
        {
            bbpsp.iOriginalPercent = bbpsp.iPercent;
        }
        else
        {
            bbpsp.iPercent = bbpsp.iOriginalPercent;
        }

        bbpsp.fUseGlobalSettings = bbpsp.fOriginalUseGlobalSettings;
        bbpsp.fNukeOnDelete = bbpsp.fOriginalNukeOnDelete;

        bbpsp.psp.dwSize = sizeof(bbpsp);
        bbpsp.psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
        bbpsp.psp.hInstance = HINST_THISDLL;
        bbpsp.psp.pszTemplate = MAKEINTRESOURCE(DLG_BITBUCKET_GENCONFIG);
        bbpsp.psp.pfnDlgProc = _GlobalPropDlgProc;
        bbpsp.psp.lParam = (LPARAM)&bbpsp;
        // the callback will fill the bbpsp.pGlobal with the pointer to the "real" psp after it has been copied
        // so that the other drive pages can get to the global information
        bbpsp.psp.pfnCallback = _GlobalSettingsCalback;

        // add the "Global" settings page
        HPROPSHEETPAGE hpageGlobal = CreatePropertySheetPage(&bbpsp.psp);
        
        if (hpageGlobal)
        {
            int idDrive;
            int iPage;

            // If this assertion fires, it means that comctl32 lost
            // backwards-compatibility with Win95 shell, WinNT4 shell,
            // and IE4 shell, all of which relied on this undocumented
            // behavior.
            ASSERT(bbpsp.pGlobal == (BBPROPSHEETINFO *)((LPBYTE)hpageGlobal + 2 * sizeof(void *)));

            pfnAddPage(hpageGlobal, lParam);

            // now create the pages for the individual drives
            bbpsp.psp.dwFlags = PSP_USETITLE;
            bbpsp.psp.pszTemplate = MAKEINTRESOURCE(DLG_BITBUCKET_CONFIG);
            bbpsp.psp.pfnDlgProc = _DriveDlgProc;
            bbpsp.psp.pszTitle = szTitle;

            for (idDrive = 0, iPage = 1; (idDrive < MAX_BITBUCKETS) && (iPage < MAXPROPPAGES); idDrive++)
            {
                if (MakeBitBucket(idDrive))
                {
                    dwSize1 = sizeof(bbpsp.iOriginalPercent);
                    dwSize2 = sizeof(bbpsp.fOriginalNukeOnDelete);
                    if (RegQueryValueEx(g_pBitBucket[idDrive]->hkey, TEXT("Percent"), NULL, NULL, (LPBYTE)&bbpsp.iOriginalPercent, &dwSize1) != ERROR_SUCCESS ||
                        RegQueryValueEx(g_pBitBucket[idDrive]->hkey, TEXT("NukeOnDelete"), NULL, NULL, (LPBYTE)&bbpsp.fOriginalNukeOnDelete, &dwSize2) != ERROR_SUCCESS)
                    {
                        TraceMsg(TF_BITBUCKET, "Bitbucket: could not read settings from the registry for drive %d, using lame defaults", idDrive);
                        bbpsp.iOriginalPercent = 10;
                        bbpsp.fOriginalNukeOnDelete = FALSE;
                    }
                    
                    // sanity check
                    bbpsp.iOriginalPercent = max(0, min(100, bbpsp.iOriginalPercent));

                    if (bbpsp.fPolicyNukeOnDelete)
                    {
                        bbpsp.fOriginalNukeOnDelete = TRUE;
                    }

                    if (bbpsp.fPolicyPercent)
                    {
                        bbpsp.iOriginalPercent = bbpsp.iPercent;
                    }

                    bbpsp.iPercent = bbpsp.iOriginalPercent;
                    bbpsp.fNukeOnDelete = bbpsp.fOriginalNukeOnDelete;

                    bbpsp.idDrive = idDrive;

                    if (SUCCEEDED(_GetDriveDisplayName(idDrive, szTitle, ARRAYSIZE(szTitle))))
                    {
                        HPROPSHEETPAGE hpageDrive = CreatePropertySheetPage(&bbpsp.psp);

                        if (hpageDrive)
                        {
                            pfnAddPage(hpageDrive, lParam);
                        }
                    }
                }
            }

            hr = S_OK;
        }
        else
        {
            hr = ResultFromLastError();
        }
    }

    return hr;
}

STDMETHODIMP CBitBucket::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam)
{
    return E_NOTIMPL;
}

STDAPI CBitBucket_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    CBitBucket *pbb = new CBitBucket();
    if (pbb)
    {
        if (InitBBGlobals())
            hr = pbb->QueryInterface(riid, ppv);
        pbb->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\bitbuck.c ===
#include "shellprv.h"
#pragma hdrstop

#include <regstr.h>     // REGSTR_PATH_POLICIES
#include "bitbuck.h"
#include "fstreex.h"
#include "copy.h"
#include "filetbl.h"
#include "propsht.h"
#include "datautil.h"
#include "cscuiext.h"

// mtpt.cpp
STDAPI_(BOOL) CMtPt_IsSecure(int iDrive);

// copy.c
void FOUndo_AddInfo(LPUNDOATOM lpua, LPTSTR pszSrc, LPTSTR pszDest, DWORD dwAttributes);
void FOUndo_FileReallyDeleted(LPTSTR pszFile);
void CALLBACK FOUndo_Release(LPUNDOATOM lpua);
void FOUndo_FileRestored(LPCTSTR pszFile);

// drivesx.c
DWORD PathGetClusterSize(LPCTSTR pszPath);

// bitbcksf.c
int DataObjToFileOpString(IDataObject * pdtobj, LPTSTR * ppszSrc, LPTSTR * ppszDest);


//
// per-process global bitbucket data
//
BOOL g_fBBInited = FALSE;                           // have we initialized our global data yet?
BOOL g_bIsProcessExplorer = FALSE;                  // are we the main explorer process? (if so, we persist the state info in the registry)
BBSYNCOBJECT *g_pBitBucket[MAX_BITBUCKETS] = {0};   // our array of bbso's that protect each bucket
HANDLE g_hgcGlobalDirtyCount = INVALID_HANDLE_VALUE;// a global counter to tell us if the global settings have changed and we need to re-read them
LONG g_lProcessDirtyCount = 0;                      // out current dirty count; we compare this to hgcDirtyCount to see if we need to update the settings from the registry
HANDLE g_hgcNumDeleters= INVALID_HANDLE_VALUE;      // a global counter that indicates the total # of people who are currently doing recycle bin file operations
HKEY g_hkBitBucket = NULL;                          // reg key that points to HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\BitBucket
HKEY g_hkBitBucketPerUser = NULL;                   // reg key that points to HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\BitBucket


//
// prototypes
//
void PersistBBDriveInfo(int idDrive);
BOOL IsFileDeletable(LPCTSTR pszFile);
BOOL CreateRecyclerDirectory(int idDrive);
void PurgeOneBitBucket(HWND hwnd, int idDrive, DWORD dwFlags);
int CountDeletedFilesOnDrive(int idDrive, ULARGE_INTEGER *puliSize, int iMaxFiles);
BOOL GetBBDriveSettings(int idDrive, ULONGLONG *pcbDiskSpace);
void DeleteOldBBRegInfo(int idDrive);
BOOL IsBitBucketInited(int idDrive);
void FreeBBInfo(BBSYNCOBJECT *pbbso);
SECURITY_DESCRIPTOR* CreateRecycleBinSecurityDescriptor();


#define MAX_DELETE_ATTEMPTS  5
#define SLEEP_DELETE_ATTEMPT 1000

int DriveIDFromBBPath(LPCTSTR pszPath)
{
    TCHAR szNetHomeDir[MAX_PATH];
    LPCTSTR pszTempPath = pszPath;

    // NOTE: If we want to make recycle bin support recycling paths under mounted volumes
    // we need to modify this to sniff the path for mounted volume junction points
    int idDrive = PathGetDriveNumber(pszTempPath);

    if ((idDrive == -1) && GetNetHomeDir(szNetHomeDir))
    {
        int iLen = lstrlen(szNetHomeDir);

        // NOTE: we don't want to let you recycle the nethomedir itself, so
        // insure that pszPath is larger than the nethomedir path
        // (neither is trailed with a backslash)
        if ((iLen < lstrlen(pszTempPath)) &&
            (PathCommonPrefix(szNetHomeDir, pszTempPath, NULL) == iLen))
        {
            // this is a subdir of the nethomedir, so we recycle it to the net home server
            // which is drive 26
            return SERVERDRIVE;
        }
    }

    return idDrive;
}


BOOL DriveIDToBBRoot(int idDrive, LPTSTR pszPath)
{
    *pszPath = TEXT('\0');

    ASSERT(idDrive >= 0);
    
    if (SERVERDRIVE == idDrive) 
    {
        // nethomedir case
        if (!GetNetHomeDir(pszPath))
        {
            ASSERT(*pszPath == TEXT('\0'));
            TraceMsg(TF_BITBUCKET, "BitBucket: Machine does NOT have a NETHOMEDIR");
        }
        else
        {
            // use the nethomedir
            ASSERT(*pszPath != TEXT('\0'));
        }
    }
    else
    {
        // build up the "C:\" string
        PathBuildRoot(pszPath, idDrive);
    }

    return (*pszPath != TEXT('\0'));
}


BOOL DriveIDToBBVolumeRoot(int idDrive, LPTSTR szPath)
{
    BOOL bRet = FALSE;

    if (DriveIDToBBRoot(idDrive, szPath))
    {
        PathStripToRoot(szPath);
        
        if (PathAddBackslash(szPath))
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

BOOL DriveIDToBBPath(int idDrive, LPTSTR pszPath)
{
    BOOL bRet = FALSE;

    if (DriveIDToBBRoot(idDrive, pszPath))
    {
        // NOTE: always append the SID for the SERVERDRIVE case
        if ((SERVERDRIVE == idDrive) || (CMtPt_IsSecure(idDrive)))
        {
            LPTSTR pszInmate = GetUserSid(NULL);
            if (pszInmate)
            {
                if (PathAppend(pszPath, TEXT("RECYCLER"))   &&
                    PathAppend(pszPath, pszInmate))
                {
                    bRet = TRUE;
                }

                LocalFree((HLOCAL)pszInmate);
            }
        }
        else
        {
            if (PathAppend(pszPath, TEXT("Recycled")))
            {
                bRet = TRUE;
            }
        }
    }

    return bRet;
}

TCHAR DriveChar(int idDrive)
{
    TCHAR chDrive = (SERVERDRIVE == idDrive) ? TEXT('@') : TEXT('a') + idDrive;

    ASSERT(idDrive >= 0 && idDrive < MAX_BITBUCKETS);
    return chDrive;
}

//
// converts "c:\recycled\whatver"  to "c"
//          \\nethomedir\share  to "@"
//
BOOL DriveIDToBBRegKey(int idDrive, LPTSTR pszValue)
{
    pszValue[0] = DriveChar(idDrive);
    pszValue[1] = TEXT('\0');

    return TRUE;
}


// Finds out if the given UNC path points to a real netware server,
// since netware in the recycle bin don't play well together.
//
// NOTE:  We cache the last passed server\share because the MyDocs almost *never* changes so
//        we don't have to hit the net if the path is the same as last time.
BOOL CheckForBBOnNovellServer(LPCTSTR pszUNCPath)
{
    static TCHAR s_szLastServerQueried[MAX_PATH] = {0};
    static BOOL s_bLastRet;
    BOOL bRet = FALSE;

    if (pszUNCPath && pszUNCPath[0])
    {
        BOOL bIsCached;
        TCHAR szServerName[MAX_PATH];

        // reduce the UNC path to \\server\share
        StringCchCopy(szServerName, ARRAYSIZE(szServerName), pszUNCPath);
        PathStripToRoot(szServerName);

        ENTERCRITICAL;
        bIsCached = (lstrcmpi(szServerName, s_szLastServerQueried) == 0);
        if (bIsCached)
        {
            // use the cached retval
            bRet = s_bLastRet;
        }
        LEAVECRITICAL;

        if (!bIsCached)
        {
            TCHAR szNetwareProvider[MAX_PATH];
            DWORD cchNetwareProvider = ARRAYSIZE(szNetwareProvider);

            ASSERT(PathIsUNC(pszUNCPath));

            // is the netware provider installed?
            if (WNetGetProviderName(WNNC_NET_NETWARE, szNetwareProvider, &cchNetwareProvider) == NO_ERROR)
            {
                NETRESOURCE nr = {0};
                
                nr.dwType = RESOURCETYPE_DISK;
                nr.lpLocalName = NULL;              // don't map a drive
                nr.lpRemoteName = szServerName;
                nr.lpProvider = szNetwareProvider;  // use netware provider only

                if (WNetAddConnection3(NULL, &nr, NULL, NULL, 0) == NO_ERROR)
                {
                    bRet = TRUE;

                    // delete the connection (will fail if still in use)
                    WNetCancelConnection2(szServerName, 0, FALSE);
                }
            }

            ENTERCRITICAL;
            // update the last queried path
            StringCchCopy(s_szLastServerQueried, ARRAYSIZE(s_szLastServerQueried), szServerName);

            // update cacehed retval
            s_bLastRet = bRet;
            LEAVECRITICAL;
        }
    }

    return bRet;
}


/*
 Network home drive code (from win95 days) is being used to support the recycle bin
 for users with mydocs redirected to a UNC path

 "Drive 26" specifies the network homedir

 This can return "" = (no net home dir, unknown setup, etc.)
                 or a string ( global ) pointing to the homedir (lfn)
*/
BOOL GetNetHomeDir(LPTSTR pszNetHomeDir)
{
    static TCHAR s_szCachedMyDocs[MAX_PATH] = {0};
    static DWORD s_dwCachedTickCount = 0;
    DWORD dwCurrentTickCount = GetTickCount();
    DWORD dwTickDelta;

    if (dwCurrentTickCount >= s_dwCachedTickCount)
    {
        dwTickDelta = dwCurrentTickCount - s_dwCachedTickCount;
    }
    else
    {
        // protect against 49.7 day rollover by forcing refresh
        dwTickDelta = (11 * 1000);
    }

    // is our cache more than 10 seconds old?
    if (dwTickDelta > (10 * 1000))
    {
        // update our cache time
        s_dwCachedTickCount = dwCurrentTickCount;

        if (SHGetSpecialFolderPath(NULL, pszNetHomeDir, CSIDL_PERSONAL, FALSE))
        {
            TCHAR szOldBBDir[MAX_PATH];

            if (PathIsUNC(pszNetHomeDir))
            {
                // Remove the trailing backslash (if present)
                // because this string will be passed to PathCommonPrefix()
                PathRemoveBackslash(pszNetHomeDir);

                // If mydocs is redirected to a UNC path on a Novell server, we need to return FALSE when 
                // IsFileDeletable is called, or the call to NtSetInformationFile with Disposition.DeleteFile=TRUE
                // will delete the file instantly even though there are open handles.
                if (CheckForBBOnNovellServer(pszNetHomeDir))
                {
                    pszNetHomeDir[0] = TEXT('\0');
                }
            }
            else
            {
                pszNetHomeDir[0] = TEXT('\0');
            }

            // check to see if the mydocs path has changed
            if (g_pBitBucket[SERVERDRIVE]                           &&
                (g_pBitBucket[SERVERDRIVE] != (BBSYNCOBJECT *)-1)   &&
                g_pBitBucket[SERVERDRIVE]->pidl                     &&
                SHGetPathFromIDList(g_pBitBucket[SERVERDRIVE]->pidl, szOldBBDir))
            {
                // we should always find "\RECYCLER\" because this is an old recycle bin directory.
                LPTSTR pszTemp = StrRStrI(szOldBBDir, NULL, TEXT("\\RECYCLER\\"));
                ASSERT(pszTemp);

                // cut the string off before the "\RECYCLER\<SID>" part so we can compare it to the current mydocs path
                *pszTemp = TEXT('\0');

                if (lstrcmpi(szOldBBDir, pszNetHomeDir) != 0)
                {   
                    if (*pszNetHomeDir)
                    {
                        TCHAR szNewBBDir[MAX_PATH];
                        LPITEMIDLIST pidl = NULL;

                        // mydocs was redirected to a different UNC path, so update the bbsyncobject for the SERVERDRIVE

                        // copy the new mydocs location and add the "\RECYCLER\<SID>" part back on
                        if (SUCCEEDED(StringCchCopy(szNewBBDir, ARRAYSIZE(szNewBBDir), pszNetHomeDir)) &&
                            PathAppend(szNewBBDir, pszTemp + 1))
                        {
                            WIN32_FIND_DATA fd = {0};

                            // create a simple pidl since "RECYCLER\<SID>" subdirectory might not exist yet
                            fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                            StringCchCopy(fd.cFileName, ARRAYSIZE(fd.cFileName), szNewBBDir);
                            SHSimpleIDListFromFindData(szNewBBDir, &fd, &pidl);
                        }

                        if (pidl)
                        {
                            LPITEMIDLIST pidlOld;
                            ULARGE_INTEGER ulFreeUser, ulTotal, ulFree;
                            DWORD dwClusterSize;
                            BOOL bUpdateSize = FALSE;

                            if (SHGetDiskFreeSpaceEx(pszNetHomeDir, &ulFreeUser, &ulTotal, &ulFree))
                            {
                                dwClusterSize = PathGetClusterSize(pszNetHomeDir);
                                bUpdateSize = TRUE;
                            }

                            ENTERCRITICAL;
                            // swap in the new pidl
                            pidlOld = g_pBitBucket[SERVERDRIVE]->pidl;
                            g_pBitBucket[SERVERDRIVE]->pidl = pidl;
                            ILFree(pidlOld);

                            // set the cchBBDir
                            g_pBitBucket[SERVERDRIVE]->cchBBDir = lstrlen(szNewBBDir);

                            g_pBitBucket[SERVERDRIVE]->fInited = TRUE;

                            // update the size fields
                            if (bUpdateSize)
                            {
                                ULARGE_INTEGER ulMaxSize;

                                g_pBitBucket[SERVERDRIVE]->dwClusterSize = dwClusterSize;
                                g_pBitBucket[SERVERDRIVE]->qwDiskSize = ulTotal.QuadPart;

                                // we limit the max size of the recycle bin to ~4 gig
                                ulMaxSize.QuadPart = min(((ulTotal.QuadPart / 100) * g_pBitBucket[SERVERDRIVE]->iPercent), (DWORD)-1);
                                ASSERT(ulMaxSize.HighPart == 0);
                                g_pBitBucket[SERVERDRIVE]->cbMaxSize = ulMaxSize.LowPart;
                            }
                            LEAVECRITICAL;
                        }
                    }
                    else
                    {
                        // mydocs was redireced back to a local path, so flag this drive as not inited so we wont do any more
                        // recycle bin operations on it.
                        ENTERCRITICAL;
                        g_pBitBucket[SERVERDRIVE]->fInited = FALSE;
                        LEAVECRITICAL;
                    }
                }
                else
                {
                    // the mydocs previously to pointed to \\foo\bar, and the user has set it back to that path again.
                    // so flag the drive as inited so we can start using it again.
                    if (g_pBitBucket[SERVERDRIVE]->fInited == FALSE)
                    {
                        ENTERCRITICAL;
                        g_pBitBucket[SERVERDRIVE]->fInited = TRUE;
                        LEAVECRITICAL;
                    }
                }
            }
        }
        else
        {
            pszNetHomeDir[0] = TEXT('\0');
        }

        ENTERCRITICAL;
        // update the cached value
        StringCchCopy(s_szCachedMyDocs, ARRAYSIZE(s_szCachedMyDocs), pszNetHomeDir);
        LEAVECRITICAL;
    }
    else
    {
        ENTERCRITICAL;
        // cache is still good
        StringCchCopy(pszNetHomeDir, MAX_PATH, s_szCachedMyDocs);
        LEAVECRITICAL;
    }

    return (BOOL)pszNetHomeDir[0];
}


STDAPI_(BOOL) IsBitBucketableDrive(int idDrive)
{
    BOOL bRet = FALSE;
    TCHAR szBBRoot[MAX_PATH];
    TCHAR szFileSystem[MAX_PATH];
    TCHAR szPath[4];
    DWORD dwAllowBitBuck = SHRestricted(REST_ALLOWBITBUCKDRIVES);
    
    if ((idDrive < 0)               ||
        (idDrive >= MAX_BITBUCKETS) ||
        (g_pBitBucket[idDrive] == (BBSYNCOBJECT *)-1))
    {
        // we dont support recycle bin for the general UNC case or we have 
        // flagged this drive as not having a recycle bin for one reason or another.
        return FALSE;
    }

    if (IsBitBucketInited(idDrive))
    {
        // the struct is allready allocated and inited, so this is a bitbucketable drive
        return TRUE;
    }

    if (idDrive == SERVERDRIVE)
    {
        bRet = GetNetHomeDir(szBBRoot);
    }
    else if ((GetDriveType(PathBuildRoot(szPath, idDrive)) == DRIVE_FIXED) ||
             (dwAllowBitBuck & (1 << idDrive)))
    {
        bRet = TRUE;
    }

    if (bRet && (idDrive != SERVERDRIVE))
    {
        // also check to make sure that the drive isint RAW (unformatted)
        if (DriveIDToBBRoot(idDrive, szBBRoot))
        {
            if(!GetVolumeInformation(szBBRoot, NULL, 0, NULL, NULL, NULL, szFileSystem, ARRAYSIZE(szFileSystem)) ||
               lstrcmpi(szFileSystem, TEXT("RAW")) == 0)
            {
                bRet = FALSE;
            }
            else
            {
                // the drive better be NTFS, FAT or FAT32, else we need to know about it and handle it properly
                ASSERT((lstrcmpi(szFileSystem, TEXT("NTFS")) == 0)  || 
                    (lstrcmpi(szFileSystem, TEXT("FAT")) == 0)   ||
                    (lstrcmpi(szFileSystem, TEXT("FAT32")) == 0));
            }
        }
        else
        {
            // path must be too long
            bRet = FALSE;
        }
    }

    return bRet;
}


// c:\recycled => c:\recycled\info2 (the new IE4/NT5/Win98 info file)
__inline BOOL GetBBInfo2FileSpec(LPTSTR pszBBPath, LPTSTR pszInfo)
{
    return PathCombine(pszInfo, pszBBPath, c_szInfo2) ? TRUE : FALSE;
}


// c:\recycled => c:\recycled\info (the old win95/NT4 info file)
__inline BOOL GetBBInfoFileSpec(LPTSTR pszBBPath, LPTSTR pszInfo)
{
    return PathCombine(pszInfo, pszBBPath, c_szInfo) ? TRUE : FALSE;
}


__inline BOOL IsBitBucketInited(int idDrive)
{
    BOOL bRet;

    // InitBBDriveInfo could fail and we free and set g_pBitBucket[idDrive] = -1. So there
    // is a small window between when we check g_pBitBucket[idDrive] and when we deref 
    // g_pBitBucket[idDrive]->fInited, to protect against g_pBitBucket[idDrive] being freed 
    // in this window we use the crit sec.
    ENTERCRITICAL;
    bRet = (g_pBitBucket[idDrive]                           &&
            (g_pBitBucket[idDrive] != (BBSYNCOBJECT *)-1)   && 
            g_pBitBucket[idDrive]->fInited);
    LEAVECRITICAL;

    return bRet;
}


BOOL RevOldBBInfoFileHeader(HANDLE hFile, BBDATAHEADER *pbbdh)
{
    // Verify that this is a valid info file
    if (pbbdh->cbDataEntrySize == sizeof(BBDATAENTRYW)) 
    {
        if (pbbdh->idVersion == BITBUCKET_WIN95_VERSION ||
            pbbdh->idVersion == BITBUCKET_NT4_VERSION   ||
            pbbdh->idVersion == BITBUCKET_WIN98IE4INT_VERSION)
        {
            DWORD dwBytesWritten;

            // now seek back to 0 and write in the new stuff
            pbbdh->idVersion = BITBUCKET_FINAL_VERSION;
            SetFilePointer(hFile, 0, NULL, FILE_BEGIN); // go to the beginning
            WriteFile(hFile, (LPBYTE)pbbdh, sizeof(BBDATAHEADER), &dwBytesWritten, NULL);
            
            ASSERT(dwBytesWritten == sizeof(BBDATAHEADER));
        }

        return (pbbdh->idVersion == BITBUCKET_FINAL_VERSION);
    }
    return FALSE;
}


//
// We need to update the cCurrent and cFiles in the info file header
// for compat with win98/IE4 machines.
//
BOOL UpdateBBInfoFileHeader(int idDrive)
{
    BBDATAHEADER bbdh = {0, 0, 0, sizeof(BBDATAENTRYW), 0}; // defaults
    HANDLE hFile;
    BOOL bRet = FALSE; // assume failure;

    // Pass 1 for the # of retry attempts since we are called during shutdown and if another process
    // is using the recycle bin we will hang and get the "End Task" dialog (bad!).
    hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 1);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        BBDATAENTRYW bbdew;
        DWORD dwBytesRead;

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        bRet = ReadFile(hFile, &bbdh, sizeof(BBDATAHEADER), &dwBytesRead, NULL);
        if (bRet && dwBytesRead == sizeof(BBDATAHEADER))
        {
            ULARGE_INTEGER uliSize;
            DWORD dwBytesWritten;

            bbdh.idVersion = BITBUCKET_FINAL_VERSION;
            bbdh.cCurrent = SHGlobalCounterGetValue(g_pBitBucket[idDrive]->hgcNextFileNum);
            bbdh.cFiles = CountDeletedFilesOnDrive(idDrive, &uliSize, 0);
            bbdh.dwSize = uliSize.LowPart;
            
            SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
            WriteFile(hFile, (LPBYTE)&bbdh, sizeof(BBDATAHEADER), &dwBytesWritten, NULL);
            
            ASSERT(dwBytesWritten == sizeof(BBDATAHEADER));
            bRet = TRUE;
        }

        ASSERT((g_pBitBucket[idDrive]->fIsUnicode && (sizeof(BBDATAENTRYW) == bbdh.cbDataEntrySize)) ||
               (!g_pBitBucket[idDrive]->fIsUnicode && (sizeof(BBDATAENTRYA) == bbdh.cbDataEntrySize)));

        // Since we dont flag entries that were deleted in the info file as deleted 
        // immeadeately, we need to go through and mark them as such now
        while (ReadNextDataEntry(hFile, &bbdew, TRUE, idDrive))
        {
            // do nothing
        }

        CloseBBInfoFile(hFile, idDrive);
    }

    if (!bRet)
    {
        TraceMsg(TF_BITBUCKET, "Bitbucket: failed to update drive %d for win98/NT4 compat!!", idDrive);
    }

    return bRet;
}

BOOL ResetInfoFileHeader(HANDLE hFile, BOOL fIsUnicode)
{
    DWORD dwBytesWritten;
    BBDATAHEADER bbdh = { BITBUCKET_FINAL_VERSION, 0, 0,
             fIsUnicode ? sizeof(BBDATAENTRYW) : sizeof(BBDATAENTRYA), 0};
    BOOL  fSuccess = FALSE;

    ASSERT(INVALID_HANDLE_VALUE != hFile);

    if (-1 != SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
    {
        if (WriteFile(hFile, (LPBYTE)&bbdh, sizeof(BBDATAHEADER), &dwBytesWritten, NULL) &&
            dwBytesWritten == sizeof(BBDATAHEADER))
        {
            if (SetEndOfFile(hFile))
            {
                fSuccess = TRUE;
            }
        }
    }

    return fSuccess;    
}

BOOL CreateInfoFile(idDrive)
{
    TCHAR szBBPath[MAX_PATH];
    TCHAR szInfoFile[MAX_PATH];
    HANDLE hFile;
    BOOL   fSuccess = FALSE;

    if (DriveIDToBBPath(idDrive, szBBPath) &&
        GetBBInfo2FileSpec(szBBPath, szInfoFile))
    {
        hFile = OpenBBInfoFile(idDrive, OPENBBINFO_CREATE, 0);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            fSuccess = ResetInfoFileHeader(hFile, TRUE);
            CloseHandle(hFile);

            if (fSuccess)
            {
                // We explicitly call SHChangeNotify so that we can generate a change specifically
                // for the info file. The recycle bin shell folder will then ignore any updates to
                // the info file.
                SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szInfoFile, NULL);
            }
        }
    }
    
    if (!fSuccess)
    {
        TraceMsg(TF_WARNING, "Bitbucket: faild to create file info file!!");
    }
    return fSuccess;
}

//  GetNT4BBAcl() - Creates a ACL structure for allowing access for 
//                  only the current user,the administrators group, or the system.
//                  Returns a pointer to an access control list 
//                  structure in the local heap; it can be
//                  free'd with LocalFree.
//
// !! HACKHACK !! - This code was basically taken right out of NT4 so that we can
//                  compare against the old NT4 recycle bin ACL. The new helper function
//                  GetShellSecurityDescriptor puts the ACE's in a different order
//                  than this function, and so we memcmp the ACL against botht this
//                  one and the new win2k one.
PACL GetNT4BBAcl()
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL         pAcl = NULL;
    PTOKEN_USER  pUser = NULL;
    PSID         psidSystem = NULL;
    PSID         psidAdmin = NULL;
    DWORD        cbAcl;
    DWORD        aceIndex;
    ACE_HEADER * lpAceHeader;
    UINT         nCnt = 2;  // inheritable; so two ACE's for each user
    BOOL         bSuccess = FALSE;


    //
    // Get the USER token so we can grab its SID for the DACL.
    //
    pUser = GetUserToken(NULL);
    if (!pUser)
    {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to get user.  Error = %d", GetLastError());
        goto Exit;
    }

    //
    // Get the system sid
    //
    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to initialize system sid.  Error = %d", GetLastError());
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to initialize admin sid.  Error = %d", GetLastError());
         goto Exit;
    }


    //
    // Allocate space for the DACL
    //
    cbAcl = sizeof(ACL) +
            (nCnt * GetLengthSid(pUser->User.Sid)) +
            (nCnt * GetLengthSid(psidSystem)) +
            (nCnt * GetLengthSid(psidAdmin)) +
            (nCnt * 3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    pAcl = (PACL)LocalAlloc(LPTR, cbAcl);
    if (!pAcl) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to allocate acl.  Error = %d", GetLastError());
        goto Exit;
    }

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to initialize acl.  Error = %d", GetLastError());
        goto Exit;
    }

    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //
    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pUser->User.Sid)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, pUser->User.Sid)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    bSuccess = TRUE;
    
Exit:
    if (pUser)
        LocalFree(pUser);

    if (psidSystem)
        FreeSid(psidSystem);

    if (psidAdmin)
        FreeSid(psidAdmin);

    if (!bSuccess && pAcl)
    {
        LocalFree(pAcl);
        pAcl = NULL;
    }

    return pAcl;
}


//
// this checks to make sure that the users recycle bin directory is properly acl'ed
//
BOOL CheckRecycleBinAcls(idDrive)
{
    BOOL bIsSecure = TRUE;
    TCHAR szBBPath[MAX_PATH];
    PSECURITY_DESCRIPTOR psdCurrent = NULL;
    PSID psidOwner;
    PACL pdaclCurrent;
    DWORD dwLengthNeeded = 0;

    if ((idDrive == SERVERDRIVE) || !CMtPt_IsSecure(idDrive))
    {
        // either redirected mydocs case (assume mydocs is already secured) or it 
        // is not an NTFS drive, so no ACL's to check
        return TRUE;
    }

    if (!DriveIDToBBPath(idDrive, szBBPath))
    {
        return FALSE;
    }

    if (!GetFileSecurity(szBBPath,
                         DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
                         NULL,
                         0,
                         &dwLengthNeeded) &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        psdCurrent = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwLengthNeeded);
    }

    if (psdCurrent)    
    {
        BOOL bDefault = FALSE;
        BOOL bPresent = FALSE;

        if (GetFileSecurity(szBBPath,
                            DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
                            psdCurrent,
                            dwLengthNeeded,
                            &dwLengthNeeded) &&
            GetSecurityDescriptorOwner(psdCurrent, &psidOwner, &bDefault) && psidOwner &&
            GetSecurityDescriptorDacl(psdCurrent, &bPresent, &pdaclCurrent, &bDefault) && pdaclCurrent)
        {
            PTOKEN_USER pUser = GetUserToken(NULL);
        
            if (pUser)
            {
                if (!EqualSid(psidOwner, pUser->User.Sid))
                {
                    // the user is not the owner of the dir, check to see if the owner is the Administrators group or the System
                    // (we consider the directory to be secure if the owner is either of these two)
                    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
                    PSID psidAdministrators = NULL;
                    PSID psidSystem = NULL;

                    if (AllocateAndInitializeSid(&sia, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psidAdministrators) && 
                        AllocateAndInitializeSid(&sia, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &psidSystem))
                    {
                        if (!EqualSid(psidOwner, psidAdministrators) && !EqualSid(psidOwner, psidSystem))
                        {
                            // directory is not owned by the user, or the Administrators group or the system, we thus consider it unsecure.
                            TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: dir %s has possibly unsecure owner!", szBBPath);
                            bIsSecure = FALSE;
                        }

                        if (psidAdministrators)
                            FreeSid(psidAdministrators);

                        if (psidSystem)
                            FreeSid(psidSystem);
                    }
                    else
                    {
                        TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: AllocateAndInitializeSid failed, assuming %s is unsecure", szBBPath);
                        bIsSecure = FALSE;
                    }
                }

                if (bIsSecure)
                {
                    // directory owner checked out ok, lets see if the acl is what we expect...
                    SECURITY_DESCRIPTOR* psdRecycle = CreateRecycleBinSecurityDescriptor();

                    if (psdRecycle)
                    {
                        // to compare acls, we do a size check and then a memcmp (aclui code does the same)
                        if ((psdRecycle->Dacl->AclSize != pdaclCurrent->AclSize) ||
                            (memcmp(psdRecycle->Dacl, pdaclCurrent, pdaclCurrent->AclSize) != 0))
                        {
                            // acl sizes were different or they didn't memcmp, so check against the old NT4 style acl
                            // (in NT4 we added the ACE's in a different order which causes the memcmp to fail, even 
                            // though the ACL is equivilant)
                            PACL pAclNT4 = GetNT4BBAcl();

                            if (pAclNT4)
                            {
                                // do the same size / memcmp check
                                if ((pAclNT4->AclSize != pdaclCurrent->AclSize) ||
                                    (memcmp(pAclNT4, pdaclCurrent, pdaclCurrent->AclSize) != 0))
                                {
                                    // acl sizes were different or they didn't memcmp, so assume the dir is unsecure
                                    bIsSecure = FALSE;
                                }

                                LocalFree(pAclNT4);
                            }
                            else
                            {
                                TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: GetNT4BBSecurityAttributes failed, assuming %s is unsecure", szBBPath);
                                bIsSecure = FALSE;
                            }
                        }

                        LocalFree(psdRecycle);
                    }
                    else
                    {
                        TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: CreateRecycleBinSecurityDescriptor failed, assuming %s is unsecure", szBBPath);
                        bIsSecure = FALSE;
                    }

                }

                LocalFree(pUser);
            }
            else
            {
                // couldnt' get the users sid, so assume the dir is unsecure
                TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: failed to get the users sid, assuming %s is unsecure", szBBPath);
                bIsSecure = FALSE;
            }
        }
        else
        {
            // GetFileSecurity failed, assume the dir is unsecure
            TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: GetFileSecurity failed, assuming %s is unsecure", szBBPath);
            bIsSecure = FALSE;
        }

        LocalFree(psdCurrent);
    }
    else
    {
        // GetFileSecurity failed, assume the dir is unsecure
        TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: GetFileSecurity failed or memory allocation failed, assume %s is unsecure", szBBPath);
        bIsSecure = FALSE;
    }
    
    if (!bIsSecure)
    {
        TCHAR szDriveName[MAX_PATH];

        if (DriveIDToBBRoot(idDrive, szDriveName))
        {
            if (ShellMessageBox(HINST_THISDLL, 
                                NULL,
                                MAKEINTRESOURCE(IDS_RECYCLEBININVALIDFORMAT),
                                MAKEINTRESOURCE(IDS_WASTEBASKET),
                                MB_YESNO | MB_ICONEXCLAMATION | MB_SETFOREGROUND,
                                szDriveName) == IDYES)
            {
                TCHAR szBBPathToNuke[MAX_PATH + 1]; // +1 for double null
                SHFILEOPSTRUCT fo = {NULL,
                                    FO_DELETE,
                                    szBBPathToNuke,
                                    NULL,
                                    FOF_NOCONFIRMATION | FOF_SILENT,
                                    FALSE,
                                    NULL,
                                    NULL};

                if (SUCCEEDED(StringCchCopy(szBBPathToNuke, ARRAYSIZE(szBBPathToNuke) - 1, szBBPath)))
                {
                    szBBPathToNuke[lstrlen(szBBPathToNuke) + 1] = TEXT('\0'); // double null terminate

                    // try to nuke the old recycle bin for this drive
                    if (SHFileOperation(&fo) == ERROR_SUCCESS)
                    {
                        // now create the new secure one
                        bIsSecure = CreateRecyclerDirectory(idDrive);
                    }
                }
            }
        }
    }
   
    return bIsSecure;
}


//
// this verifies the info file header infomation
//
BOOL VerifyBBInfoFileHeader(int idDrive)
{
    BBDATAHEADER bbdh = {0, 0, 0, sizeof(BBDATAENTRYW), 0}; // defaults
    HANDLE hFile;
    TCHAR szBBPath[MAX_PATH];
    TCHAR szInfo[MAX_PATH];
    BOOL fSuccess = FALSE;

    // check for the the old win95 INFO file
    if (!DriveIDToBBPath(idDrive, szBBPath) ||
        !GetBBInfoFileSpec(szBBPath, szInfo))
    {
        return FALSE;
    }
    
    hFile = CreateFile(szInfo, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_RANDOM_ACCESS, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        DWORD dwBytesRead;

        if (ReadFile(hFile, &bbdh, sizeof(BBDATAHEADER), &dwBytesRead, NULL) &&
            (dwBytesRead == sizeof(BBDATAHEADER)))
        {
            TraceMsg(TF_BITBUCKET, "Bitbucket: migrating info in old database file %s", szInfo);
            fSuccess = RevOldBBInfoFileHeader(hFile, &bbdh);
        }

        CloseHandle(hFile);

        if (fSuccess) 
        {
            // rename from INFO -> INFO2
            TCHAR szInfoNew[MAX_PATH];

            GetBBInfo2FileSpec(szBBPath, szInfoNew);
            TraceMsg(TF_BITBUCKET, "Bitbucket: renaming %s to %s !!", szInfo, szInfoNew);
            SHMoveFile(szInfo, szInfoNew, SHCNE_RENAMEITEM);
        }
        else
        {
            goto bad_info_file;
        }
    }

    // Failed to open or rev the old info file. Next, we check for the existance of the new info2 file
    // to see if the drive has a bitbucket format that is greater than what we can handle
    if (!fSuccess)
    {
        hFile = OpenBBInfoFile(idDrive, OPENBBINFO_READ, 0);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            BOOL bRet;
            DWORD dwBytesRead;

            SetFilePointer(hFile, 0, NULL, FILE_BEGIN); // go to the beginning
            bRet = ReadFile(hFile, &bbdh, sizeof(BBDATAHEADER), &dwBytesRead, NULL);
            CloseBBInfoFile(hFile, idDrive);

            if ((bRet == 0)                                 ||
                (dwBytesRead != sizeof(BBDATAHEADER))       ||
                (bbdh.idVersion > BITBUCKET_FINAL_VERSION)  ||
                (bbdh.cbDataEntrySize != sizeof(BBDATAENTRYA) && bbdh.cbDataEntrySize != sizeof(BBDATAENTRYW)))
            {
                TCHAR szDriveName[MAX_PATH];

                // either we had a corrupt win95 info file, or an info2 file whose version is greater than ours
                // so we just empy the recycle bin.
bad_info_file:
                // since we failed to read the existing header, assume the native format
                g_pBitBucket[idDrive]->fIsUnicode = TRUE;

                // find out which drive it is that is corrupt
                

                if (!DriveIDToBBRoot(idDrive, szDriveName) ||
                    (ShellMessageBox(HINST_THISDLL, 
                                    NULL,
                                    MAKEINTRESOURCE(IDS_RECYCLEBININVALIDFORMAT),
                                    MAKEINTRESOURCE(IDS_WASTEBASKET),
                                    MB_YESNO | MB_ICONEXCLAMATION | MB_SETFOREGROUND,
                                    szDriveName) == IDYES))
                {
                    // nuke this bucket since it is hosed
                    PurgeOneBitBucket(NULL, idDrive, SHERB_NOCONFIRMATION);
                    return TRUE;
                }

                hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);

                if (hFile != INVALID_HANDLE_VALUE)
                {
                    DWORD dwBytesWritten;

                    bbdh.idVersion = BITBUCKET_FINAL_VERSION;

                    if (bbdh.cbDataEntrySize != sizeof(BBDATAENTRYW) &&
                        bbdh.cbDataEntrySize != sizeof(BBDATAENTRYA))
                    {
                        // assume the native data entry size
                        bbdh.cbDataEntrySize = sizeof(BBDATAENTRYW);
                    }

                    g_pBitBucket[idDrive]->fIsUnicode = (bbdh.cbDataEntrySize == sizeof(BBDATAENTRYW));
            
                    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
                    WriteFile(hFile, (LPBYTE)&bbdh, sizeof(BBDATAHEADER), &dwBytesWritten, NULL);
                    ASSERT(dwBytesWritten == sizeof(BBDATAHEADER));
            
                    CloseBBInfoFile(hFile, idDrive);
                    fSuccess = TRUE;
                }
                else
                {

                    fSuccess = FALSE;
                }
            }
            else if (bbdh.idVersion != BITBUCKET_FINAL_VERSION)
            {
                // old info2 information
                fSuccess = RevOldBBInfoFileHeader(hFile, &bbdh);
            }
            else
            {
                // the header info is current
                fSuccess = TRUE;
            }
        }
        else
        {
            // brand spanking new drive, so go create the info file now.
            fSuccess = CreateInfoFile(idDrive);
        }
    }

    // get the only relevant thing in the header, whether it is unicode or not 
    g_pBitBucket[idDrive]->fIsUnicode = (bbdh.cbDataEntrySize == sizeof(BBDATAENTRYW));

    return fSuccess;
}


LONG FindInitialNextFileNum(idDrive)
{
    int iRet = 0;
    TCHAR szBBFileSpec[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFind;

    if (DriveIDToBBPath(idDrive, szBBFileSpec) &&
        PathAppend(szBBFileSpec, TEXT("D*.*")))
    {
        hFind = FindFirstFile(szBBFileSpec, &fd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (!PathIsDotOrDotDot(fd.cFileName) && lstrcmpi(fd.cFileName, c_szDesktopIni))
                {
                    int iCurrent = BBPathToIndex(fd.cFileName);
                    if (iCurrent > iRet)
                    {
                        iRet = iCurrent;
                    }
                }
            } while (FindNextFile(hFind, &fd));

            FindClose(hFind);
        }
    }

    ASSERT(iRet >= 0);
    
    return (LONG)iRet;
}

BOOL InitBBDriveInfo(int idDrive)
{
    BOOL bRet = FALSE;
    TCHAR szName[MAX_PATH];
    DWORD dwDisp;
    LONG lInitialCount = 0;
    
    // build up the string "BitBucket.<drive letter>"
    if (SUCCEEDED(StringCchCopy(szName, ARRAYSIZE(szName), TEXT("BitBucket."))) &&
        DriveIDToBBRegKey(idDrive, &szName[10])                                 &&  // 10 for length of "BitBucket."
        SUCCEEDED(StringCchCat(szName, ARRAYSIZE(szName), TEXT(".DirtyCount"))))
    {
        g_pBitBucket[idDrive]->hgcDirtyCount = SHGlobalCounterCreateNamed(szName, 0); // BitBucket.<drive letter>.DirtyCount

        if (g_pBitBucket[idDrive]->hgcDirtyCount == INVALID_HANDLE_VALUE)
        {
            ASSERTMSG(FALSE, "BitBucket: failed to create hgcDirtyCount for drive %d !!", idDrive);
            return FALSE;
        }

        // now create the subkey for this drive
        DriveIDToBBRegKey(idDrive, szName);

        // the per-user key is volatile since we only use this for temporary bookeeping (eg need to purge / compact).
        // the exception to this rule is the SERVERDRIVE case, because this is the users "My Documents" so we let it 
        // and we also need to store the path under that key (it has to roam with the user)
        if (RegCreateKeyEx(g_hkBitBucketPerUser,
                           szName,
                           0,
                           NULL,
                           (SERVERDRIVE == idDrive) ? REG_OPTION_NON_VOLATILE : REG_OPTION_VOLATILE,
                           KEY_SET_VALUE | KEY_QUERY_VALUE,
                           NULL,
                           &g_pBitBucket[idDrive]->hkeyPerUser,
                           &dwDisp) != ERROR_SUCCESS)
        {
            ASSERTMSG(FALSE, "BitBucket: Could not create HKCU BitBucket registry key for drive %s", szName);
            g_pBitBucket[idDrive]->hkeyPerUser = NULL;
            return FALSE;
        }

        if (RegCreateKeyEx(g_hkBitBucket,
                           szName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           MAXIMUM_ALLOWED,         // user may or may not have permissions to change global bb settings
                           NULL,
                           &g_pBitBucket[idDrive]->hkey,
                           &dwDisp) != ERROR_SUCCESS)
        {
            TraceMsg(TF_BITBUCKET, "BitBucket: Could not create HKLM BitBucket registry key for drive %s, falling back to HKLM global key! ", szName);
            if (RegOpenKeyEx(g_hkBitBucket,
                             NULL,
                             0,
                             KEY_QUERY_VALUE,       // use KEY_QUERY_VALUE so when we read the settings for this drive we will read the global values (but not try and overwrite them!)
                             &g_pBitBucket[idDrive]->hkey) != ERROR_SUCCESS)
            {
                ASSERTMSG(FALSE, "BitBucket: Could not duplicate HKLM Global Bitbucket key!");
                return FALSE;
            }
        }

        // load the rest of the settings (hgcNextFileNum, fIsUnicode, iPercent, cbMaxSize, dwClusterSize, and fNukeOnDelete)
        bRet = GetBBDriveSettings(idDrive, NULL);
    }

    return bRet;
}


BOOL AllocBBDriveInfo(int idDrive)
{
    TCHAR szBBPath[MAX_PATH];
    LPITEMIDLIST pidl = NULL;
    BOOL bRet = FALSE; // assume failure

    if (DriveIDToBBPath(idDrive, szBBPath))
    {
        pidl = ILCreateFromPath(szBBPath);

        if (!pidl && !PathFileExists(szBBPath))
        {
            if (CreateRecyclerDirectory(idDrive))
            {
                pidl = ILCreateFromPath(szBBPath);
            }
        }
    }

    if (pidl)
    {
        BBSYNCOBJECT *pbbso = (BBSYNCOBJECT *)LocalAlloc(LPTR, sizeof(*pbbso));
        if (pbbso)
        {
            if (SHInterlockedCompareExchange(&g_pBitBucket[idDrive], pbbso, NULL))
            {
                DWORD dwInitialTickCount = GetTickCount();
                BOOL bKeepWaiting = TRUE;

                // Some other thread beat us to creating this bitbucket.
                // We can't return until that thread has inited the bitbucket
                // since some of the members might not be valid yet.
                LocalFree(pbbso);
                ILFree(pidl);

                do
                {
                    if (g_pBitBucket[idDrive] == (BBSYNCOBJECT *)-1)
                    {
                        // this volume is flagged as not being recycleable for some reason...
                        break;
                    }

                    // Spin until the bitbucket struct is inited
                    Sleep(50);
                    
                    bKeepWaiting = !IsBitBucketInited(idDrive);

                    // we should never spin more than ~15 seconds
                    if (((GetTickCount() - dwInitialTickCount) >= (60 * 1000))  && bKeepWaiting)
                    {
                        ASSERTMSG(FALSE, "AllocBBDriveInfo: other thread took longer that 1 minute to init a bitbucket?!?");
                        break;
                    }

                } while (bKeepWaiting);

                return ((g_pBitBucket[idDrive] != NULL) && 
                        (g_pBitBucket[idDrive] != (BBSYNCOBJECT *)-1));
            }

            ASSERT(g_pBitBucket[idDrive] && (g_pBitBucket[idDrive] != (BBSYNCOBJECT *)-1));
            g_pBitBucket[idDrive]->pidl = pidl;
            g_pBitBucket[idDrive]->cchBBDir = lstrlen(szBBPath);

            if (InitBBDriveInfo(idDrive))
            {
                // Success!!
                g_pBitBucket[idDrive]->fInited = TRUE;
                bRet = TRUE;
            }
            else
            {
                // we failed for some weird reason
                TraceMsg(TF_WARNING, "Bitbucket: InitBBDriveInfo() failed on drive %d", idDrive);
                ILFree(pidl);
                
                ENTERCRITICAL;
                // take the critical section to protect people who call IsBitBucketInited()
                FreeBBInfo(g_pBitBucket[idDrive]);

                if (idDrive == SERVERDRIVE)
                {
                    // We set it to null in the serverdrive case so we will always retry. This allows 
                    // the user to re-direct and try to recycle on a new location.
                    g_pBitBucket[idDrive] = NULL;
                }
                else
                {
                    // set it to -1 here so we dont try any future recycle operations on this volume
                    g_pBitBucket[idDrive] = (BBSYNCOBJECT *)-1;
                }
                LEAVECRITICAL;
            }
        }
        else
        {
            ILFree(pidl);
        }
    }

    return bRet;
}


BOOL InitBBGlobals()
{
    if (!g_fBBInited)
    {
        // Save this now beceause at shutdown the desktop window will already be gone,
        // so we need to find out if we are the main explorer process now.
        if (!g_bIsProcessExplorer)
        {
            g_bIsProcessExplorer = IsWindowInProcess(GetShellWindow());
        }

        // do we have our global hkey that points to HKLM\Software\Microsoft\Windows\CurrentVersion\BitBucket yet?
        if (!g_hkBitBucket)
        {
            g_hkBitBucket = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("BitBucket"), TRUE);
            if (!g_hkBitBucket)
            {
                TraceMsg(TF_WARNING, "Bitbucket: Could not create g_hkBitBucket!");
                return FALSE;
            }
        }

        // do we have our global hkey that points to HKCU\Software\Microsoft\Windows\CurrentVersion\BitBucket yet?
        if (!g_hkBitBucketPerUser)
        {
            g_hkBitBucketPerUser = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, TEXT("BitBucket"), TRUE);
            if (!g_hkBitBucketPerUser)
            {
                TraceMsg(TF_WARNING, "Bitbucket: Could not create g_hkBitBucketPerUser!");
                return FALSE;
            }
        }

        // have we initialized the global settings dirty counter yet
        if (g_hgcGlobalDirtyCount == INVALID_HANDLE_VALUE)
        {
            g_hgcGlobalDirtyCount = SHGlobalCounterCreateNamed(TEXT("BitBucket.GlobalDirtyCount"), 0);

            if (g_hgcGlobalDirtyCount == INVALID_HANDLE_VALUE)
            {
                TraceMsg(TF_WARNING, "Bitbucket: failed to create g_hgcGlobalDirtyCount!");
                return FALSE;
            }

            g_lProcessDirtyCount = SHGlobalCounterGetValue(g_hgcGlobalDirtyCount);
        }

        // have we initialized the global # of people doing recycle bin file operations?
        if (g_hgcNumDeleters == INVALID_HANDLE_VALUE)
        {
            g_hgcNumDeleters = SHGlobalCounterCreateNamed(TEXT("BitBucket.NumDeleters"), 0);

            if (g_hgcGlobalDirtyCount == INVALID_HANDLE_VALUE)
            {
                TraceMsg(TF_WARNING, "Bitbucket: failed to create g_hgcGlobalDirtyCount!");
                return FALSE;
            }
        }

        // we inited everything!!
        g_fBBInited = TRUE;
    }

    return g_fBBInited;
}


void FreeBBInfo(BBSYNCOBJECT *pbbso)
{
    if (pbbso->hgcNextFileNum)
        CloseHandle(pbbso->hgcNextFileNum);

    if (pbbso->hgcDirtyCount)
        CloseHandle(pbbso->hgcDirtyCount);

    if (pbbso->hkey)
        RegCloseKey(pbbso->hkey);
    
    if (pbbso->hkeyPerUser)
        RegCloseKey(pbbso->hkeyPerUser);

    LocalFree(pbbso);
}


//
// This function is exported from shell32 so that explorer can call us during WM_ENDSESSION
// and we can go save a bunch of state and free all the semaphores. 
STDAPI_(void) SaveRecycleBinInfo()
{
    if (g_bIsProcessExplorer)
    {
        LONG lGlobalDirtyCount;
        BOOL bGlobalUpdate = FALSE; // did global settings change?
        int i;

        // We are going to persist the info to the registry, so check to see if we need to 
        // update our info now
        lGlobalDirtyCount = SHGlobalCounterGetValue(g_hgcGlobalDirtyCount);
        if (g_lProcessDirtyCount < lGlobalDirtyCount)
        {
            g_lProcessDirtyCount = lGlobalDirtyCount;
            RefreshAllBBDriveSettings();
            bGlobalUpdate = TRUE;
        }

        for (i = 0; i < MAX_BITBUCKETS ; i++)
        {
            if (IsBitBucketInited(i))
            {
                LONG lBucketDirtyCount = SHGlobalCounterGetValue(g_pBitBucket[i]->hgcDirtyCount);

                // if we didnt do a global update, check this bucket specifically to see if it is dirty
                // and we need to update it
                if (!bGlobalUpdate && g_pBitBucket[i]->lCurrentDirtyCount < lBucketDirtyCount)
                {
                    g_pBitBucket[i]->lCurrentDirtyCount = lBucketDirtyCount;
                    RefreshBBDriveSettings(i);
                }

                // save all of the volume serial # and whether the drive is unicode to the registry
                PersistBBDriveInfo(i);

                // we also update the header for win98/IE4 compat
                UpdateBBInfoFileHeader(i);
            }
        }
    }
}


void BitBucket_Terminate()
{
    int i;

    // free the global recycle bin structs
    for (i = 0; i < MAX_BITBUCKETS ; i++)
    {
        if ((g_pBitBucket[i]) && (g_pBitBucket[i] != (BBSYNCOBJECT *)-1))
        {
            ENTERCRITICAL;
            FreeBBInfo(g_pBitBucket[i]);
            g_pBitBucket[i] = NULL;
            LEAVECRITICAL;
        }
    }

    if (g_hgcGlobalDirtyCount != INVALID_HANDLE_VALUE)
        CloseHandle(g_hgcGlobalDirtyCount);

    if (g_hgcNumDeleters != INVALID_HANDLE_VALUE)
        CloseHandle(g_hgcNumDeleters);

    if (g_hkBitBucketPerUser != NULL)
        RegCloseKey(g_hkBitBucketPerUser);

    if (g_hkBitBucket != NULL)
        RegCloseKey(g_hkBitBucket);
}

//
// refreshes g_pBitBucket with new global settings
//
BOOL RefreshAllBBDriveSettings()
{
    int i;

    // since global settings changes affect all the drives, update all the drives
    for (i = 0; i < MAX_BITBUCKETS; i++)
    {
        if ((g_pBitBucket[i]) && (g_pBitBucket[i] != (BBSYNCOBJECT *)-1))
        {
            RefreshBBDriveSettings(i);
        }
    }
    
    return TRUE;
}


BOOL ReadBBDriveSetting(HKEY hkey, LPTSTR pszValue, LPBYTE pbData, DWORD cbData)
{
    DWORD dwSize;

retry:

    dwSize = cbData;
    if (RegQueryValueEx(hkey, pszValue, NULL, NULL, pbData, &dwSize) != ERROR_SUCCESS)
    {
        if (hkey == g_hkBitBucket)
        {
            ASSERTMSG(FALSE, "Missing global bitbucket data: run regsvr32 on shell32.dll !!");
            return FALSE;
        }
        else
        {
            // we are missing the per-bitbuckt information, so fall back to the global stuff
            hkey = g_hkBitBucket;
            goto retry;
        }
    }

    return TRUE;
}

//
// Same as SHGetRestriction, except you can tell the difference between
// "policy not set" and "policy set with value=0"
//
DWORD ReadPolicySetting(LPCWSTR pszBaseKey, LPCWSTR pszGroup, LPCWSTR pszRestriction, LPBYTE pbData, DWORD cbData)
{
    // Make sure the string is long enough to hold longest one...
    WCHAR szSubKey[MAX_PATH];
    DWORD dwSize;
    DWORD dwRet;

    //
    // This restriction hasn't been read yet.
    //
    if (!pszBaseKey)
    {
        pszBaseKey = REGSTR_PATH_POLICIES;
    }
    
    if (PathCombineW(szSubKey, pszBaseKey, pszGroup))
    {
        // Check local machine first and let it override what the
        // HKCU policy has done.
        dwSize = cbData;
        dwRet = SHGetValueW(HKEY_LOCAL_MACHINE, szSubKey, pszRestriction, NULL, pbData, &dwSize);
        if (ERROR_SUCCESS != dwRet)
        {
            // Check current user if we didn't find anything for the local machine.
            dwSize = cbData;
            dwRet = SHGetValueW(HKEY_CURRENT_USER, szSubKey, pszRestriction, NULL, pbData, &dwSize);
        }
    }
    else
    {
        dwRet = ERROR_FILE_NOT_FOUND;
    }

    return dwRet;
}

BOOL RefreshBBDriveSettings(int idDrive)
{
    HKEY hkey;
    ULARGE_INTEGER ulMaxSize;
    BOOL fUseGlobalSettings = TRUE;
    DWORD dwSize;

    ASSERT(g_pBitBucket[idDrive] && (g_pBitBucket[idDrive] != (BBSYNCOBJECT *)-1));

    dwSize = sizeof(fUseGlobalSettings);
    RegQueryValueEx(g_hkBitBucket, TEXT("UseGlobalSettings"), NULL, NULL, (LPBYTE)&fUseGlobalSettings, &dwSize);
    
    if (fUseGlobalSettings)
    {
        hkey = g_hkBitBucket;
    }
    else
    {
        hkey = g_pBitBucket[idDrive]->hkey;
    }

    // read the iPercent value

    if (ERROR_SUCCESS == ReadPolicySetting(NULL, L"Explorer", L"RecycleBinSize", (LPBYTE)&g_pBitBucket[idDrive]->iPercent, sizeof(g_pBitBucket[idDrive]->iPercent)))
    {
        // Make sure it's not too big or too small
        g_pBitBucket[idDrive]->iPercent = max(0, min(100, g_pBitBucket[idDrive]->iPercent));
    }
    else if (!ReadBBDriveSetting(hkey, TEXT("Percent"), (LPBYTE)&g_pBitBucket[idDrive]->iPercent, sizeof(g_pBitBucket[idDrive]->iPercent)))
    {
        // default
        g_pBitBucket[idDrive]->iPercent = 10;
    }

    // read the fNukeOnDelete value

    if (SHRestricted(REST_BITBUCKNUKEONDELETE))
    {
        g_pBitBucket[idDrive]->fNukeOnDelete = TRUE;
    }
    else if (!ReadBBDriveSetting(hkey, TEXT("NukeOnDelete"), (LPBYTE)&g_pBitBucket[idDrive]->fNukeOnDelete, sizeof(g_pBitBucket[idDrive]->fNukeOnDelete)))
    {
        // default
        g_pBitBucket[idDrive]->fNukeOnDelete = FALSE;
    }

    // re-calculate cbMaxSize based on the new iPercent
    ulMaxSize.QuadPart = min((g_pBitBucket[idDrive]->qwDiskSize / 100) * g_pBitBucket[idDrive]->iPercent, (DWORD)-1);
    ASSERT(ulMaxSize.HighPart == 0);
    g_pBitBucket[idDrive]->cbMaxSize = ulMaxSize.LowPart;

    // since we just refreshed the settings from the registry, we are now up to date
    g_pBitBucket[idDrive]->lCurrentDirtyCount = SHGlobalCounterGetValue(g_pBitBucket[idDrive]->hgcDirtyCount);

    return TRUE;
}


//
// this function is used to compact the bitbucked INFO files.
//
// we do a lazy delete (just mark the entries as deleted) and when we hit a
// certain number of bogus entries in the info file, we need to go through and clean up the
// garbage and compact the file.
//
DWORD CALLBACK CompactBBInfoFileThread(void *pData)
{
    int idDrive = PtrToLong(pData);

    //
    // PERF (reinerf) - as an optimization, we might want to check here to see
    // if someone is waiting to empty the bitbucket since if we are going to empty
    // this bucket there is no point in wasting time compacting it.
    //

    HANDLE hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        // work in chunks of 10
        BBDATAENTRYW bbdewArray[10]; // use a unicode array, but it might end up holding BBDATAENTRYA stucts
        LPBBDATAENTRYW pbbdew = bbdewArray;
        int iNumEntries = 0;
        DWORD dwDataEntrySize = g_pBitBucket[idDrive]->fIsUnicode ? sizeof(BBDATAENTRYW) : sizeof(BBDATAENTRYA);
        DWORD dwReadPos = 0;
        DWORD dwBytesWritten;

        // save off the inital write pos
        DWORD dwWritePos = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

        while (ReadNextDataEntry(hFile, pbbdew, TRUE, idDrive))
        {
            ASSERT(!IsDeletedEntry(pbbdew));

            iNumEntries++;

            // do we have 10 entries yet?
            if (iNumEntries == ARRAYSIZE(bbdewArray))
            {
                iNumEntries = 0;

                TraceMsg(TF_BITBUCKET, "Bitbucket: Compacting drive %d: dwRead = %d, dwWrite = %d, writing 10 entries", idDrive, dwReadPos, dwWritePos);

                // save where we are for reading
                dwReadPos = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

                // then go to where we are for writing
                SetFilePointer(hFile, dwWritePos, NULL, FILE_BEGIN);

                // write it out
                if (!WriteFile(hFile, (LPBYTE)bbdewArray, dwDataEntrySize * ARRAYSIZE(bbdewArray), &dwBytesWritten, NULL) || dwBytesWritten != (dwDataEntrySize * ARRAYSIZE(bbdewArray)))
                {
                    // we're in big trouble if this happens.
                    // bail completely so that at worst, we only have a few bad records.
                    // if we keep trying to write from this point, but the write point is
                    // we'll nuke all the records
                    ASSERTMSG(FALSE, "Bitbucket: we were compacting drive %d and it is totally messed up", idDrive);
                    break;
                }

                // sucess! move our write pos to the end of were we finished writing
                dwWritePos += (dwDataEntrySize * ARRAYSIZE(bbdewArray));
                
                // go back to were we left off reading
                SetFilePointer(hFile, dwReadPos, NULL, FILE_BEGIN);

                // reset our lparray pointer
                pbbdew = bbdewArray;
            }
            else
            {
                // dont have 10 entries yet, so keep going
                pbbdew = (LPBBDATAENTRYW)((LPBYTE)pbbdew + dwDataEntrySize);
            }
        }

        TraceMsg(TF_BITBUCKET, "Bitbucket: Compacting drive %d: dwRead = %d, dwWrite = %d, writing last %d entries", idDrive, dwReadPos, dwWritePos, iNumEntries);

        // write whatever we have left over
        SetFilePointer(hFile, dwWritePos, NULL, FILE_BEGIN);
        WriteFile(hFile, (LPBYTE)bbdewArray, dwDataEntrySize * iNumEntries, &dwBytesWritten, NULL);
        ASSERT(dwBytesWritten == (dwDataEntrySize * iNumEntries));
        SetEndOfFile(hFile);
        CloseBBInfoFile(hFile, idDrive);
    }

    return 0;
}

void CompactBBInfoFile(int idDrive)
{
    HANDLE hThread;
    DWORD idThread;

    // try to spin up a background thread to do the work for us
    hThread = CreateThread(NULL, 0, CompactBBInfoFileThread, IntToPtr(idDrive), 0, &idThread);

    if (hThread)
    {
        // let the background thread do the work
        CloseHandle(hThread);
    }
    else
    {
        TraceMsg(TF_BITBUCKET, "BBCompact - failed to create backgound thread! Doing work on this thread");
        CompactBBInfoFileThread(IntToPtr(idDrive));
    }
}

BOOL GetDeletedFileNameFromParts(LPTSTR pszFileName, size_t cchFileName, int idDrive, int iIndex, LPCTSTR pszOriginal)
{
    return SUCCEEDED(StringCchPrintf(pszFileName,
                                     cchFileName,
                                     TEXT("D%c%d%s"),
                                     DriveChar(idDrive),
                                     iIndex,
                                     PathFindExtension(pszOriginal)));
}

BOOL GetDeletedFileName(LPTSTR pszFileName, size_t cchFileName, const BBDATAENTRYW* pbbdew)
{
    return GetDeletedFileNameFromParts(pszFileName, cchFileName, pbbdew->idDrive, pbbdew->iIndex, pbbdew->szOriginal);
}


// get the full path to the file/folder in the recycle bin location
BOOL GetDeletedFilePath(LPTSTR pszPath, const BBDATAENTRYW* pbbdew)
{
    BOOL bRet = FALSE;
    TCHAR szFileName[MAX_PATH];
    
    if (DriveIDToBBPath(pbbdew->idDrive, pszPath)   &&
        GetDeletedFileName(szFileName, ARRAYSIZE(szFileName), pbbdew)      &&
        PathAppend(pszPath, szFileName))
    {
        bRet = TRUE;
    }

    return bRet;
}


void UpdateIcon(BOOL fFull)
{
    LONG    cbData;
    DWORD   dwType;
    HKEY    hkeyCLSID = NULL;
    HKEY    hkeyUserCLSID = NULL;
    TCHAR   szTemp[MAX_PATH];
    TCHAR   szNewValue[MAX_PATH];
    TCHAR   szValue[MAX_PATH];

    TraceMsg(TF_BITBUCKET, "BitBucket: UpdateIcon %s", fFull ? TEXT("Full") : TEXT("Empty"));

    szValue[0] = 0;
    szNewValue[0] = 0;

    // get the HKCR CLSID key (HKCR\CLSID\CLSID_RecycleBin\DefaultIcon)
    if (FAILED(SHRegGetCLSIDKey(&CLSID_RecycleBin, c_szDefaultIcon, FALSE, FALSE, &hkeyCLSID)))
        goto error;

    // get the per-user CLSID
    // HKCU
    //      NT: Software\Microsoft\Windows\CurrentVersion\Explorer\CLSID
    //      9x: Software\Classes\CLSID
    if (FAILED(SHRegGetCLSIDKey(&CLSID_RecycleBin, c_szDefaultIcon, TRUE, FALSE, &hkeyUserCLSID)))
    {
        // it most likely failed because the reg key dosent exist, so create it now
        if (FAILED(SHRegGetCLSIDKey(&CLSID_RecycleBin, c_szDefaultIcon, TRUE, TRUE, &hkeyUserCLSID)))
            goto error;

        // now that we created it, lets copy the stuff from HKLM there
        
        // get the local machine default icon
        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyCLSID, NULL, 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
            goto error;

        // set the per-user default icon
        RegSetValueEx(hkeyUserCLSID, NULL, 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
        
        // get the local machine full icon
        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyCLSID, TEXT("Full"), 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
            goto error;

        // set the per-user full icon
        RegSetValueEx(hkeyUserCLSID, TEXT("Full"), 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));

        // get the local machine empty icon
        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyCLSID, TEXT("Empty"), 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
            goto error;

        // set the per-user empty icon
        RegSetValueEx(hkeyUserCLSID, TEXT("Empty"), 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
    }

    // try the per user first, if we dont find it, then copy the information from HKCR\CLSID\etc...
    // to the per-user location
    cbData = sizeof(szTemp);
    if (RegQueryValueEx(hkeyUserCLSID, NULL, 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
    {
        // get the local machine default icon
        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyCLSID, NULL, 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
            goto error;

        // set the per-user default icon
        RegSetValueEx(hkeyUserCLSID, NULL, 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
    }
    StringCchCopy(szValue, ARRAYSIZE(szValue), szTemp);

    cbData = sizeof(szTemp);
    if (RegQueryValueEx(hkeyUserCLSID, fFull ? TEXT("Full") : TEXT("Empty"), 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
    {
        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyCLSID, fFull ? TEXT("Full") : TEXT("Empty"), 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
            goto error;

        // set the per-user full/empty icon
        RegSetValueEx(hkeyUserCLSID, fFull ? TEXT("Full") : TEXT("Empty"), 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
    }
    StringCchCopy(szNewValue, ARRAYSIZE(szNewValue), szTemp);
    
    if (lstrcmpi(szNewValue, szValue) != 0)
    {
        TCHAR szExpandedValue[MAX_PATH];
        LPTSTR szIconIndex;

        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyUserCLSID, fFull ? TEXT("Full") : TEXT("Empty"), 0, &dwType, (LPBYTE)szTemp, &cbData) == ERROR_SUCCESS)
        {
            // we always update the per user default icon, because recycle bins are per user on NTFS
            RegSetValueEx(hkeyUserCLSID, NULL, 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
        }

        if (SHExpandEnvironmentStrings(szValue, szExpandedValue, ARRAYSIZE(szExpandedValue)))
        {
            szIconIndex = StrRChr(szExpandedValue, NULL, TEXT(','));

            if (szIconIndex)  
            {
                int id;
                int iNum = StrToInt(szIconIndex + 1);

                *szIconIndex = TEXT('\0'); // end szValue after the dll name

                // ..and tell anyone viewing this image index to update
                id = LookupIconIndex(szExpandedValue, iNum, 0);
                SHUpdateImage(szExpandedValue, iNum, 0, id);
                SHChangeNotifyHandleEvents();
            }
        }
    }

error:
    if (hkeyCLSID)
        RegCloseKey(hkeyCLSID);
    
    if (hkeyUserCLSID)
        RegCloseKey(hkeyUserCLSID);
}


//
// this loads the settings for this drive.  it obeys the "use global" bit
//
BOOL GetBBDriveSettings(int idDrive, ULONGLONG *pcbDiskSpace)
{
    TCHAR szDrive[MAX_PATH];
    TCHAR szName[MAX_PATH];
    TCHAR szVolume[MAX_PATH];
    TCHAR szPath[MAX_PATH];
    ULARGE_INTEGER ulFreeUser, ulTotal, ulFree;
    DWORD dwSize1;
    DWORD dwSerialNumber, dwSerialNumberFromRegistry;
    LONG lInitialCount;
    BOOL bHaveCachedRegInfo = FALSE;
    BOOL bRet = TRUE;
    HKEY hkey;

    // Get volume root since we are going to call GetVolumeInformation()
    if (!DriveIDToBBVolumeRoot(idDrive, szVolume) ||
        !DriveIDToBBPath(idDrive, szDrive)        ||
        !GetBBInfo2FileSpec(szDrive, szName))
    {
        return FALSE;
    }

    if (idDrive == SERVERDRIVE)
    {
        // in the SERVERDRIVE case everything is under HKCU, so use the per-user key
        hkey = g_pBitBucket[idDrive]->hkeyPerUser;
    }
    else
    {
        hkey = g_pBitBucket[idDrive]->hkey;
    }

    // first we need to check to see we have cached registry info for this drive, or if this 
    // is a new drive
    dwSize1 = sizeof(dwSerialNumberFromRegistry);

    if (PathFileExists(szName)                                  &&
        (RegQueryValueEx(hkey,
                         TEXT("VolumeSerialNumber"),
                         NULL,
                         NULL,
                         (LPBYTE)&dwSerialNumberFromRegistry,
                         &dwSize1) == ERROR_SUCCESS)            &&
        GetVolumeInformation(szVolume,
                             NULL,
                             0,
                             &dwSerialNumber,
                             NULL,
                             NULL,
                             NULL,
                             0)                                 &&
        (dwSerialNumber == dwSerialNumberFromRegistry))
    {
        // we were able to read the drive serial number and it matched the regsitry, so
        // assume that the cached reg info is valid
        bHaveCachedRegInfo = TRUE;
    }
    
    // do some extra checks in the SERVERDRIVE case to make sure that the path matches in addition to the volume serial number.
    // (eg nethomedir could be on the same volume but a different path)
    if (bHaveCachedRegInfo && (SERVERDRIVE == idDrive))
    {
        DWORD cbPath = sizeof(szPath);

        if ((RegQueryValueEx(hkey, TEXT("Path"), NULL, NULL, (LPBYTE) szPath, &cbPath) != ERROR_SUCCESS) ||
            (lstrcmpi(szPath, szDrive) != 0))
        {
            // couldn't read the path or it didnt match, so no we can't use the cached info
            bHaveCachedRegInfo = FALSE;
        }
    }

 
    if (!bHaveCachedRegInfo)
    {
        TraceMsg(TF_BITBUCKET, "Bitbucket: new drive %s detected!!!", szDrive);
        // this is a new volume, so delete any old registry info we had
        DeleteOldBBRegInfo(idDrive);
        
        // And also migrate the win95 info if it exists
        // NOTE: this also fills in the g_pBitBucket[idDrive]->fIsUnicode
        VerifyBBInfoFileHeader(idDrive);
    }
    else
    {
        // set g_pBitBucket[idDrive]->fIsUnicode based on the registry info
        dwSize1 = sizeof(g_pBitBucket[idDrive]->fIsUnicode);
        if (RegQueryValueEx(hkey, TEXT("IsUnicode"), NULL, NULL, (LPBYTE)&g_pBitBucket[idDrive]->fIsUnicode, &dwSize1) != ERROR_SUCCESS)
        {
            TraceMsg(TF_BITBUCKET, "Bitbucket: IsUnicode missing from registry for drive %s !!", szDrive);
            
            // instead, try to get this out of the header
            VerifyBBInfoFileHeader(idDrive);
        }
    }

    // we need to check to make sure that the Recycle Bin folder is properly secured
    if (!CheckRecycleBinAcls(idDrive))
    {
        // we return false if this fails (meaning we detected an unsecure directory and were unable to 
        // fix it or the user didnt want to fix it). This will effectively disable all recycle bin operations
        // on this volume for this session.
        return FALSE;
    }

    // calculate the next file num index
    lInitialCount = FindInitialNextFileNum(idDrive);

    // create the hgcNextFileNume global counter
    ASSERT(lInitialCount >= 0);

    if (SUCCEEDED(StringCchCopy(szName, ARRAYSIZE(szName), TEXT("BitBucket."))) &&
        DriveIDToBBRegKey(idDrive, &szName[10])                                 &&  // 10 = lstrlen("BitBucket.")
        SUCCEEDED(StringCchCat(szName, ARRAYSIZE(szName), TEXT(".NextFileNum"))))
    {
        // BitBucket.<drive letter>.NextFileNum
        g_pBitBucket[idDrive]->hgcNextFileNum = SHGlobalCounterCreateNamed(szName, lInitialCount);
    }
    else
    {
        g_pBitBucket[idDrive]->hgcNextFileNum = INVALID_HANDLE_VALUE;
    }

    if (g_pBitBucket[idDrive]->hgcNextFileNum == INVALID_HANDLE_VALUE)
    {
        ASSERTMSG(FALSE, "BitBucket: failed to create hgcNextFileNum for drive %s !!", szDrive);
        return FALSE;
    }

    // we call SHGetDiskFreeSpaceEx so we can respect quotas on NTFS
    if (DriveIDToBBRoot(idDrive, szDrive) &&
        SHGetDiskFreeSpaceEx(szDrive, &ulFreeUser, &ulTotal, &ulFree))
    {
        g_pBitBucket[idDrive]->dwClusterSize = PathGetClusterSize(szDrive);
        g_pBitBucket[idDrive]->qwDiskSize = ulTotal.QuadPart;
    }
    else
    {
        if (idDrive == SERVERDRIVE)
        {
            g_pBitBucket[idDrive]->dwClusterSize = 2048;
            g_pBitBucket[idDrive]->qwDiskSize = 0x7FFFFFFF;
        }
        else
        {
            ASSERTMSG(FALSE, "Bitbucket: SHGetDiskFreeSpaceEx failed on %s !!", szDrive);
            
            g_pBitBucket[idDrive]->dwClusterSize = 0;
            g_pBitBucket[idDrive]->qwDiskSize = 0;
        }
    }

    if (pcbDiskSpace)
    {
        *pcbDiskSpace = g_pBitBucket[idDrive]->qwDiskSize;
    }

    // Read the Percent and NukeOnDelete settings, and recalculate cbMaxSize.
    RefreshBBDriveSettings(idDrive);

    TraceMsg(TF_BITBUCKET,
             "GetBBDriveSettings: Drive %s, fIsUnicode=%d, iPercent=%d, cbMaxSize=%d, fNukeOnDelete=%d, NextFileNum=%d",
             szDrive,
             g_pBitBucket[idDrive]->fIsUnicode,
             g_pBitBucket[idDrive]->iPercent,
             g_pBitBucket[idDrive]->cbMaxSize,
             g_pBitBucket[idDrive]->fNukeOnDelete,
             SHGlobalCounterGetValue(g_pBitBucket[idDrive]->hgcNextFileNum));

    return TRUE;
}


//
// cleans up old iPercent and fNukeOnDelete registry keys when we dectect a new drive
//
void DeleteOldBBRegInfo(idDrive)
{
    RegDeleteValue(g_pBitBucket[idDrive]->hkey, TEXT("Percent"));
    RegDeleteValue(g_pBitBucket[idDrive]->hkey, TEXT("NukeOnDelete"));
    RegDeleteValue(g_pBitBucket[idDrive]->hkey, TEXT("IsUnicode"));
}


//
// This gets called when explorer exits to persist the volume serial # and
// whether the drive is unicode for the specified drive.
//
void PersistBBDriveInfo(int idDrive)
{
    TCHAR szVolume[MAX_PATH];
    DWORD dwSerialNumber;
    HKEY hkey;

    if (SERVERDRIVE == idDrive)
    {
        TCHAR szPath[MAX_PATH];

        // in the SERVERDRIVE case everything is under HKCU, so use the per-user key
        hkey = g_pBitBucket[idDrive]->hkeyPerUser;

        if (DriveIDToBBPath(idDrive, szPath))
        {
            RegSetValueEx(hkey, TEXT("Path"), 0, REG_SZ, (LPBYTE) szPath, sizeof(TCHAR) * (lstrlen(szPath) + 1));
        }
    }
    else
    {
        hkey = g_pBitBucket[idDrive]->hkey;
    }

    if (DriveIDToBBVolumeRoot(idDrive, szVolume))
    {
        // write out the volume serial # so we can detect when a new drive comes along and give it the default settings
        // NOTE: we will fail to write out the volume serial # if we are a normal user and HKLM is locked down. Oh well.
        if (GetVolumeInformation(szVolume, NULL, 0, &dwSerialNumber, NULL, NULL, NULL, 0))
        {
            RegSetValueEx(hkey, TEXT("VolumeSerialNumber"), 0, REG_DWORD, (LPBYTE)&dwSerialNumber, sizeof(dwSerialNumber));
        }
    }

    // save off fIsUnicode as well
    RegSetValueEx(hkey, TEXT("IsUnicode"), 0, REG_DWORD, (LPBYTE)&g_pBitBucket[idDrive]->fIsUnicode, sizeof(g_pBitBucket[idDrive]->fIsUnicode));
}


//
// This is what gets called when the user tweaks the drive settings for all the drives (the global settings)
//
BOOL PersistGlobalSettings(BOOL fUseGlobalSettings, BOOL fNukeOnDelete, int iPercent)
{
    ASSERT(g_hkBitBucket);

    if (RegSetValueEx(g_hkBitBucket, TEXT("Percent"), 0, REG_DWORD, (LPBYTE)&iPercent, sizeof(iPercent)) != ERROR_SUCCESS ||
        RegSetValueEx(g_hkBitBucket, TEXT("NukeOnDelete"), 0, REG_DWORD, (LPBYTE)&fNukeOnDelete, sizeof(fNukeOnDelete)) != ERROR_SUCCESS ||
        RegSetValueEx(g_hkBitBucket, TEXT("UseGlobalSettings"), 0, REG_DWORD, (LPBYTE)&fUseGlobalSettings, sizeof(fUseGlobalSettings)) != ERROR_SUCCESS)        
    {
         TraceMsg(TF_BITBUCKET, "Bitbucket: failed to update global bitbucket data in the registry!!");
         return FALSE;
    }

    // since we just updated the global drive settings, we need to increment the dirty count and set our own
    g_lProcessDirtyCount = SHGlobalCounterIncrement(g_hgcGlobalDirtyCount);

    return TRUE;
}

//
// This is what gets called when the user tweaks the drive settings for a drive via the
// Recycle Bin property sheet page. The only thing we care about is the % slider and the
// "Do not move files to the recycle bin" settings.
// 
BOOL PersistBBDriveSettings(int idDrive, int iPercent, BOOL fNukeOnDelete)
{
    if (RegSetValueEx(g_pBitBucket[idDrive]->hkey, TEXT("Percent"), 0, REG_DWORD, (LPBYTE)&iPercent, sizeof(iPercent)) != ERROR_SUCCESS ||
        RegSetValueEx(g_pBitBucket[idDrive]->hkey, TEXT("NukeOnDelete"), 0, REG_DWORD, (LPBYTE)&fNukeOnDelete, sizeof(fNukeOnDelete)) != ERROR_SUCCESS)
    {
        TraceMsg(TF_BITBUCKET, "Bitbucket: unable to persist drive settings for drive %d", idDrive);
        return FALSE;
    }

    // since we just updated the drive settings, we need to increment the dirty count for this drive
    g_pBitBucket[idDrive]->lCurrentDirtyCount = SHGlobalCounterIncrement(g_pBitBucket[idDrive]->hgcDirtyCount);

    return TRUE;
}


//
// walks the multi-string pszSrc and sets up the undo info
//
void BBCheckRestoredFiles(LPCTSTR pszSrc)
{
    if (pszSrc && IsFileInBitBucket(pszSrc)) 
    {
        LPCTSTR pszTemp = pszSrc;

        while (*pszTemp) 
        {
            FOUndo_FileRestored(pszTemp);
            pszTemp += (lstrlen(pszTemp) + 1);
        }

        SHUpdateRecycleBinIcon();
    }
}


//
// This is the quick and efficent way to tell if the Recycle Bin is empty or not
//
STDAPI_(BOOL) IsRecycleBinEmpty()
{
    int i;
    
    for (i = 0; i < MAX_BITBUCKETS; i++) 
    {
        if (CountDeletedFilesOnDrive(i, NULL, 1))
            return FALSE;
    }

    return TRUE;
}


//
// Finds out how many files are deleted on this drive, and optionally the total size of those files.
// Also, stop counting if the total # of files equals iMaxFiles.
//
// NOTE: if you pass iMaxFiles = 0, then we ignore the parameter and count up all the files/sizes
// 
int CountDeletedFilesOnDrive(int idDrive, ULARGE_INTEGER *puliSize, int iMaxFiles)
{
    int cFiles = 0;
    HANDLE hFile;
    WIN32_FIND_DATA wfd;
    TCHAR szBBPath[MAX_PATH];
    TCHAR szBBFileSpec[MAX_PATH];

    if (puliSize)
    {
        puliSize->QuadPart = 0;
    }
    
    if (!IsBitBucketableDrive(idDrive)      ||
        !DriveIDToBBPath(idDrive, szBBPath) ||
        !PathCombine(szBBFileSpec, szBBPath, TEXT("D*.*")))
    {
        return 0;
    }

    hFile = FindFirstFile(szBBFileSpec, &wfd);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return 0;
    }

    do
    {
        if (PathIsDotOrDotDot(wfd.cFileName) || lstrcmpi(wfd.cFileName, c_szDesktopIni) == 0)
        {
            continue;
        }

        cFiles++;

        if (puliSize)
        {
            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                FOLDERCONTENTSINFO fci = {0};
                TCHAR szDir[MAX_PATH];
                fci.bContinue = TRUE;

                // PERF (reinerf) - for perf we should try to avoid
                // calling FolderSize here. Perhaps we could encode the size
                // as part of the extension?
                if (SUCCEEDED(StringCchCopy(szDir, ARRAYSIZE(szDir), szBBPath)) &&
                    PathAppend(szDir, wfd.cFileName))
                {
                    FolderSize(szDir, &fci);
                    puliSize->QuadPart += fci.cbSize;
                }
            }
            else
            {
                // simple file case
                ULARGE_INTEGER uliTemp;
                uliTemp.LowPart = wfd.nFileSizeLow;
                uliTemp.HighPart = wfd.nFileSizeHigh;
                puliSize->QuadPart += uliTemp.QuadPart;
            }
        }

        if ((iMaxFiles > 0) && (cFiles >= iMaxFiles))
        {
            break;
        }

    } while (FindNextFile(hFile, &wfd));

    FindClose(hFile);

    return cFiles;
}


//
// Returns the number of files in the Recycle Bin, and optionally the drive id
// if there's only one file, and optionally the total size of all the stuff.
//
// We also stop counting if iMaxFiles is nonzero and we find that many
// files. This helps perf by having a cutoff point where we use a generic error
// message instead of the exact # of files. If iMaxFiles is zero, we give the true
// count of files.
//
// NOTE: don't use this if you just want to check to see if the recycle bin is 
// empty or full!! Use IsRecycleBinEmpty() instead
//
int BBTotalCount(LPINT pidDrive, ULARGE_INTEGER *puliSize, int iMaxFiles)
{
    int i;
    int idDrive;
    int nFiles = 0;

    if (puliSize)
    {
        puliSize->QuadPart = 0;
    }

    for (i = 0; i < MAX_BITBUCKETS; i++) 
    {
        int nFilesOld = nFiles;

        ULARGE_INTEGER uliSize;
        nFiles += CountDeletedFilesOnDrive(i, puliSize ? &uliSize : NULL, iMaxFiles - nFilesOld);
     
        if (puliSize)
        {
            puliSize->QuadPart += uliSize.QuadPart;
        }
        
        if (nFilesOld == 0 && nFiles == 1)
        {
            // if just one file, set the drive id
            idDrive = i;
        }

        if (iMaxFiles > 0 && nFiles >= iMaxFiles)
            break;
    }

    if (pidDrive)
        *pidDrive = (nFiles == 1) ? idDrive : 0;

    return nFiles;
}


//
// gets the number of files and and size of the bitbucket for the given drive
//
SHSTDAPI SHQueryRecycleBin(LPCTSTR pszRootPath, LPSHQUERYRBINFO pSHQueryInfo)
{
    ULARGE_INTEGER uliSize;
    DWORD dwNumItems = 0;

    uliSize.QuadPart = 0;

    // since this fn is exported, we need to check to see if we need to 
    // init our global data first
    if (!InitBBGlobals())
    {
        return E_OUTOFMEMORY;
    }

    if (!pSHQueryInfo  ||
        (pSHQueryInfo->cbSize < sizeof(SHQUERYRBINFO)))
    {
        return E_INVALIDARG;
    }

    if (pszRootPath && pszRootPath[0] != TEXT('\0'))
    {
        int idDrive = DriveIDFromBBPath(pszRootPath);
        if (MakeBitBucket(idDrive))
        {
            dwNumItems = CountDeletedFilesOnDrive(idDrive, &uliSize, 0);
        }
    }
    else
    {
        //
        // NTRAID#NTBUG9-146905-2001/03/15-jeffreys
        //
        // This is a public API, documented to return the totals for all
        // recycle bins when no path is given. This was broken in Windows
        // 2000 and Millennium.
        //
        dwNumItems = BBTotalCount(NULL, &uliSize, 0);
    }

    pSHQueryInfo->i64Size = uliSize.QuadPart;
    pSHQueryInfo->i64NumItems = (__int64)dwNumItems;

    return S_OK;
}

SHSTDAPI SHQueryRecycleBinA(LPCSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo)
{
    WCHAR wszPath[MAX_PATH];

    SHAnsiToUnicode(pszRootPath, wszPath, ARRAYSIZE(wszPath));
    return SHQueryRecycleBin(wszPath, pSHQueryRBInfo);
}

//
// Empty the given drive or all drives
//
SHSTDAPI SHEmptyRecycleBin(HWND hWnd, LPCTSTR pszRootPath, DWORD dwFlags)
{
    // since this fn is exported, we need to check to see if we need to 
    // init our global data first
    if (!InitBBGlobals())
    {
        // this could happen in low memory situations, we have no choice but
        // to abort the empty
        return E_OUTOFMEMORY;
    }

    if ((pszRootPath == NULL) || (*pszRootPath == 0))
    {
        BBPurgeAll(hWnd, dwFlags);
    }
    else
    {
        int idDrive = DriveIDFromBBPath(pszRootPath);

        // note: we include MAX_DRIVES(26) which is SERVERDRIVE case!
        if ((idDrive < 0) || (idDrive > MAX_DRIVES))
        {
            return E_INVALIDARG;
        }

        if (MakeBitBucket(idDrive))
        {
            PurgeOneBitBucket(hWnd, idDrive, dwFlags);
        }
    }

    return S_OK;
}

SHSTDAPI SHEmptyRecycleBinA(HWND hWnd, LPCSTR pszRootPath, DWORD dwFlags)
{
    WCHAR wszPath[MAX_PATH];

    SHAnsiToUnicode(pszRootPath, wszPath, ARRAYSIZE(wszPath));
    return SHEmptyRecycleBin(hWnd, wszPath, dwFlags);
}

void MarkBBPurgeAllTime(BOOL bStart)
{
    TCHAR szText[64];
    
    if (g_dwStopWatchMode == 0xffffffff)
        g_dwStopWatchMode = StopWatchMode();    // Since the stopwatch funcs live in shdocvw, delay this call so we don't load shdocvw until we need to

    if (g_dwStopWatchMode)
    {
        StringCchCopy(szText, ARRAYSIZE(szText), TEXT("Shell Empty Recycle"));
        if (bStart)
        {
            StringCchCat(szText, ARRAYSIZE(szText), TEXT(": Start"));
            StopWatch_Start(SWID_BITBUCKET, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
        }
        else
        {
            StringCchCat(szText, ARRAYSIZE(szText), TEXT(": Stop"));
            StopWatch_Stop(SWID_BITBUCKET, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
        }
    }
}

HRESULT BBPurgeAll(HWND hwndOwner, DWORD dwFlags)
{
    TCHAR szPath[MAX_PATH * 2 + 3]; // null space and double null termination
    int nFiles;
    int idDrive;
    BOOL fConfirmed;
    SHFILEOPSTRUCT sFileOp ={hwndOwner,
                             FO_DELETE,
                             szPath,
                             NULL,
                             FOF_NOCONFIRMATION | FOF_SIMPLEPROGRESS,
                             FALSE,
                             NULL,
                             MAKEINTRESOURCE(IDS_BB_EMPTYINGWASTEBASKET)};

    // check to see if we need to init our global data first
    if (!InitBBGlobals())
    {
        // this could happen in low memory situations, we have no choice but
        // to fail the empty
        return E_OUTOFMEMORY;
    }

    if (g_dwStopWatchMode)   // If the shell perf mode is enabled, time the empty operation
    {
        MarkBBPurgeAllTime(TRUE);
    }

    fConfirmed = (dwFlags & SHERB_NOCONFIRMATION);

    if (!fConfirmed) 
    {
        // find out how many files we have...
        BBDATAENTRYW bbdew;
        TCHAR szSrcName[MAX_PATH];

        WIN32_FIND_DATA fd;
        CONFIRM_DATA cd = {CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_PROGRAM_FILE | CONFIRM_MULTIPLE, 0};

        nFiles = BBTotalCount(&idDrive, NULL, MAX_EMPTY_FILES);
        if (!nFiles)
        {
            if (g_dwStopWatchMode)
            {
                MarkBBPurgeAllTime(FALSE);
            }
            return S_FALSE;   // no files to delete
        }

        // first do the confirmation thing
        fd.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

        // We have to call IsBitBucketInited() here since we could be in BBPurgeAll as a result
        // of a corrupt bitbucket. In this case, the g_pBitBucket[idDrive] has not been inited and
        // therefore we can't use it yet
        if (nFiles == 1 && IsBitBucketInited(idDrive))
        {
            HANDLE hFile = OpenBBInfoFile(idDrive, OPENBBINFO_READ, 0);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                ReadNextDataEntry(hFile, &bbdew, TRUE, idDrive);
                CloseBBInfoFile(hFile, idDrive);
                StringCchCopy(szSrcName, ARRAYSIZE(szSrcName), bbdew.szOriginal);
            }
            else
            {
                if (g_dwStopWatchMode)
                {
                    MarkBBPurgeAllTime(FALSE);
                }
                return S_FALSE; // no files to delete
            }
        }
        else
        {
            // If we haven't inited this bucket yet or there are MAX_EMPTY_FILES or more files,
            // then use the generic empty message
            if (nFiles == 1 || nFiles >= MAX_EMPTY_FILES)
            {
                // counting up the total # of files in the bitbucket scales as
                // the # of files (duh!). This can get pretty expensive, so if there
                // are MAX_EMPTY_FILES or more files in the bin, we just give a generic
                // error message
                
                // set this so ConfirmFileOp knows to use the generic message
                nFiles = -1;
            }
            
            szSrcName[0] = 0;
        }
        
        if (ConfirmFileOp(hwndOwner, NULL, &cd, nFiles, 0, CONFIRM_DELETE_FILE | CONFIRM_WASTEBASKET_PURGE, 
            szSrcName, &fd, NULL, &fd, NULL) == IDYES)
        {
            fConfirmed = TRUE;
        }
    }

    if (fConfirmed)
    {
        DECLAREWAITCURSOR;
        SetWaitCursor();
        
        if (dwFlags & SHERB_NOPROGRESSUI)
        {
            sFileOp.fFlags |= FOF_SILENT;
        }

        for (idDrive = 0; (idDrive < MAX_BITBUCKETS) && !sFileOp.fAnyOperationsAborted; idDrive++)
        {
            if (MakeBitBucket(idDrive))
            {
                HANDLE hFile;
                
                // nuke all the BB files (d*.*)
                if (DriveIDToBBPath(idDrive, szPath) &&
                    PathAppend(szPath, c_szDStarDotStar))
                {
                    szPath[lstrlen(szPath) + 1] = 0; // double null terminate

                    // turn off redraw for now.
                    ShellFolderView_SetRedraw(hwndOwner, FALSE);

                    hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);

                    if (INVALID_HANDLE_VALUE != hFile)
                    {
                        // now do the actual delete.
                        if (SHFileOperation(&sFileOp) || sFileOp.fAnyOperationsAborted) 
                        {
                            TraceMsg(TF_BITBUCKET, "Bitbucket: emptying bucket on %s failed or user aborted", szPath);

                            // NOTE: the info file may point to some files that have been deleted,
                            // it will be cleaned up later
                        }
                        else
                        {
                            // reset the info file since we deleted it as part of the empty operation
                            ResetInfoFileHeader(hFile, g_pBitBucket[idDrive]->fIsUnicode);
                        }

                        // we always reset the desktop.ini
                        CreateRecyclerDirectory(idDrive);

                        CloseBBInfoFile(hFile, idDrive);
                    }

                    ShellFolderView_SetRedraw(hwndOwner, TRUE);
                }
            }
        }

        if (!(dwFlags & SHERB_NOSOUND))
        {
            SHPlaySound(TEXT("EmptyRecycleBin"));
        }

        SHUpdateRecycleBinIcon();
        ResetWaitCursor();
    }
    
    if (g_dwStopWatchMode)
    {
        MarkBBPurgeAllTime(FALSE);
    }

    return S_OK;
}


BOOL BBNukeFile(LPCTSTR pszPath, DWORD dwAttribs)
{
    if (Win32DeleteFile(pszPath))
    {
        FOUndo_FileReallyDeleted((LPTSTR)pszPath);
        return TRUE;
    }

    return FALSE;
}


BOOL BBNukeFolder(LPCTSTR pszDir)
{
    TCHAR szPath[MAX_PATH];
    BOOL fRet;

    if (PathCombine(szPath, pszDir, c_szStarDotStar))
    {
        WIN32_FIND_DATA fd;
        HANDLE hfind = FindFirstFile(szPath, &fd);
        if (hfind != INVALID_HANDLE_VALUE)
        {
            do
            {
                LPTSTR pszFile = fd.cAlternateFileName[0] ? fd.cAlternateFileName : fd.cFileName;

                if (pszFile[0] != TEXT('.'))
                {
                    // use the short path name so that we avoid hitting MAX_PATH too soon
                    if (PathCombine(szPath, pszDir, pszFile))
                    {
                        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                        {
                            // even if this fails, we keep going.
                            // we want to delete as much as possible
                            BBNukeFolder(szPath);
                        }
                        else
                        {
                            BBNukeFile(szPath, fd.dwFileAttributes);
                        }
                    }
                }

            } while (FindNextFile(hfind, &fd));

            FindClose(hfind);
        }
    }
    
    fRet = Win32RemoveDirectory(pszDir);
    
    // if everything was successful, we need to notify any undo stuff about this
    if (fRet)
    {
        FOUndo_FileReallyDeleted((LPTSTR)szPath);
    }

    return fRet;
}


BOOL BBNuke(LPCTSTR pszPath)
{
    BOOL fRet = FALSE;
    // verify that the file exists
    DWORD dwAttribs = GetFileAttributes(pszPath);

    TraceMsg(TF_BITBUCKET, "Bitbucket: BBNuke called on %s ", pszPath);
    
    if (dwAttribs != (UINT)-1)
    {
        // this was a directory, we need to recurse in and delete everything inside
        if (dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
        {
            fRet = BBNukeFolder(pszPath);
        }
        else
        {
            fRet = BBNukeFile(pszPath, dwAttribs);
        }
    }

    return fRet;
}

DWORD PurgeBBFiles(int idDrive)
{
    ULARGE_INTEGER uliCurrentSize;

    CountDeletedFilesOnDrive(idDrive, &uliCurrentSize, 0);

    if (uliCurrentSize.HighPart || uliCurrentSize.LowPart > g_pBitBucket[idDrive]->cbMaxSize)
    {
        DWORD dwDataEntrySize = g_pBitBucket[idDrive]->fIsUnicode ? sizeof(BBDATAENTRYW) : sizeof(BBDATAENTRYA);
        HANDLE hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            BBDATAENTRYW bbdew;
            TCHAR szBBPath[MAX_PATH];
            
            if (DriveIDToBBPath(idDrive, szBBPath))
            {
                // while we're too big, find something to delete
                while ((uliCurrentSize.HighPart || uliCurrentSize.LowPart > g_pBitBucket[idDrive]->cbMaxSize)
                        && ReadNextDataEntry(hFile, &bbdew, TRUE, idDrive))
                {
                    TCHAR szPath[MAX_PATH];
                    TCHAR szDeletedFile[MAX_PATH];

                    if (GetDeletedFileName(szDeletedFile, ARRAYSIZE(szDeletedFile), &bbdew) &&
                        PathCombine(szPath, szBBPath, szDeletedFile))
                    {
                        BBNuke(szPath);
                        NukeFileInfoBeforePoint(hFile, &bbdew, dwDataEntrySize);

                        // subtract the size of what we just nuked
                        uliCurrentSize.QuadPart -= bbdew.dwSize;
                    }

                    TraceMsg(TF_BITBUCKET, "Bitbucket: purging drive %d, curent size = %I64u, max size = %d", idDrive, uliCurrentSize.QuadPart, g_pBitBucket[idDrive]->cbMaxSize);
                }
            }

            CloseBBInfoFile(hFile, idDrive);
        }
    }

    return uliCurrentSize.LowPart;
}

STDAPI BBFileNameToInfo(LPCTSTR pszFileName, int *pidDrive, int *piIndex)
{
    HRESULT hr = E_FAIL;

    if (lstrcmpi(pszFileName, c_szInfo)         &&
        lstrcmpi(pszFileName, c_szInfo2)        &&
        lstrcmpi(pszFileName, c_szDesktopIni)   &&
        lstrcmpi(pszFileName, TEXT("Recycled")) &&
        (StrChr(pszFileName, TEXT('\\')) == NULL))   // recycle bin dosen't support multi-level paths
    {
        if ((pszFileName[0] == TEXT('D')) || (pszFileName[0] == TEXT('d')))
        {
            if (pszFileName[1])
            {
                if (pidDrive)
                {
                    hr = S_OK;

                    if (pszFileName[1] == TEXT('@'))
                        *pidDrive = SERVERDRIVE;
                    else if (InRange(pszFileName[1], TEXT('a'), TEXT('z')))
                        *pidDrive = pszFileName[1] - TEXT('a');
                    else if (InRange(pszFileName[1], TEXT('A'), TEXT('Z')))
                        *pidDrive = pszFileName[1] - TEXT('A');
                    else
                        hr = E_FAIL;
                }

                if (piIndex)
                {
                    // this depends on StrToInt stoping is parsing when it hits the file extension
                    *piIndex = StrToInt(&pszFileName[2]);
                    hr = S_OK;
                }
            }
        }
    }

    return hr;
}

// converts C:\RECYCLED\Dc19.foo to 19
int BBPathToIndex(LPCTSTR pszPath)
{
    int iIndex;
    LPTSTR pszFileName = PathFindFileName(pszPath);

    if (SUCCEEDED(BBFileNameToInfo(pszFileName, NULL, &iIndex)))
    {
        return iIndex;
    }

    return -1;
}

BOOL ReadNextDataEntry(HANDLE hFile, LPBBDATAENTRYW pbbdew, BOOL fSkipDeleted, int idDrive)
{
    DWORD dwBytesRead;
    DWORD dwDataEntrySize = g_pBitBucket[idDrive]->fIsUnicode ? sizeof(BBDATAENTRYW) : sizeof(BBDATAENTRYA);

    ZeroMemory(pbbdew, sizeof(*pbbdew));

TryAgain:
    if (ReadFile(hFile, pbbdew, dwDataEntrySize, &dwBytesRead, NULL) && 
        (dwBytesRead == dwDataEntrySize))
    {
        TCHAR szDeleteFileName[MAX_PATH];
        TCHAR szOldPath[MAX_PATH];

        if (fSkipDeleted && IsDeletedEntry(pbbdew))
        {
            goto TryAgain;
        }

        // for ansi entries fill out the unicode version of the original
        if (!g_pBitBucket[idDrive]->fIsUnicode)
        {
            BBDATAENTRYA *pbbdea = (BBDATAENTRYA *)pbbdew;
            SHAnsiToUnicode(pbbdea->szOriginal, pbbdew->szOriginal, ARRAYSIZE(pbbdew->szOriginal));
        }

        // We check for a drive that has had its letter changed since this record was added.
        // In this case, we want to restore the files that were deleted on this volume to this volume.
        if (pbbdew->idDrive != idDrive)
        {
            TCHAR szNewPath[MAX_PATH];

            if (DriveIDToBBPath(idDrive, szOldPath) &&
                SUCCEEDED(StringCchCopy(szNewPath, ARRAYSIZE(szNewPath), szOldPath)))
            {   
                if (GetDeletedFileName(szDeleteFileName, ARRAYSIZE(szDeleteFileName), pbbdew) &&
                    PathAppend(szOldPath, szDeleteFileName))
                {
                    if (GetDeletedFileNameFromParts(szDeleteFileName, ARRAYSIZE(szDeleteFileName), idDrive, pbbdew->iIndex, pbbdew->szOriginal) &&
                        PathAppend(szNewPath, szDeleteFileName))
                    {
                        TraceMsg(TF_BITBUCKET, "Bitbucket: found entry %s corospoinding to old drive letter, whacking it to be on drive %d !!", szOldPath, idDrive);

                        // we need to rename the file from d?0.txt to d<idDrive>0.txt
                        if (!Win32MoveFile(szOldPath, szNewPath, GetFileAttributes(szOldPath) & FILE_ATTRIBUTE_DIRECTORY))
                        {
                            TraceMsg(TF_BITBUCKET, "Bitbucket: failed to rename %s to %s, getlasterror = %d", szOldPath, szNewPath, GetLastError());
                            goto DeleteEntry;
                        }

                        // whack the rest of the information about this entry to match the new drive ID
                        pbbdew->idDrive = idDrive;
                        pbbdew->szShortName[0] = 'A' + (CHAR)idDrive;
                        if (g_pBitBucket[idDrive]->fIsUnicode)
                        {
                            // for unicode volumes we need to whack the first letter of the long name as well
                            pbbdew->szOriginal[0] = L'A' + (WCHAR)idDrive;
                        }
                    }
                }
            }
        }
        else
        {
            // Starting with NT5, when we delete or restore items, we dont bother updating the info file.
            // So we need to make sure that the entry we have has not been restored or really nuked.
            if (GetDeletedFilePath(szOldPath, pbbdew) &&
                !PathFileExists(szOldPath))
            {
DeleteEntry:
                // this entry is really deleted, so mark it as such now
                NukeFileInfoBeforePoint(hFile, pbbdew, dwDataEntrySize);
        
                if (fSkipDeleted)
                {
                    goto TryAgain;
                }
            }
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//
// the file pointer is RIGHT AFTER the entry that we want to delete.
//
// back the file pointer up one record and mark it deleted
//
void NukeFileInfoBeforePoint(HANDLE hFile, LPBBDATAENTRYW pbbdew, DWORD dwDataEntrySize)
{
    DWORD dwBytesWritten;
    LONG lPos = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    ASSERT((DWORD)lPos >= dwDataEntrySize + sizeof(BBDATAHEADER));
    
    if ((DWORD)lPos >= dwDataEntrySize + sizeof(BBDATAHEADER))
    {
        // found the entry.. back up the file pointer to the beginning
        // of this record and mark it as deleted
        lPos -= dwDataEntrySize;
        SetFilePointer(hFile, lPos, NULL, FILE_BEGIN);
        
        MarkEntryDeleted(pbbdew);
        
        if (WriteFile(hFile, pbbdew, dwDataEntrySize, &dwBytesWritten, NULL))
        {
            ASSERT(dwDataEntrySize == dwBytesWritten);
        }
        else
        {
            TraceMsg(TF_BITBUCKET, "Bitbucket: couldn't nuke file info");
            // move the file pointer back to where it was when we entered this function
            SetFilePointer(hFile, lPos + dwDataEntrySize, NULL, FILE_BEGIN);
        }
    }
}


//
// This closes the hFile and sends out an SHCNE_UPDATEITEM for the info file on
// drive idDrive
//
void CloseBBInfoFile(HANDLE hFile, int idDrive)
{
    TCHAR szInfoFile[MAX_PATH];

    ASSERT(hFile != INVALID_HANDLE_VALUE);
    CloseHandle(hFile);

    if (DriveIDToBBPath(idDrive, szInfoFile) &&
        PathAppend(szInfoFile, c_szInfo2))
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szInfoFile, NULL);
    }
}

// One half second (500 ms = 0.5 s)
#define BBINFO_OPEN_RETRY_PERIOD        500
// Retry 30 times (at least 20 s)
#define BBINFO_OPEN_MAX_RETRIES         40

//
// This opens up a handle to the bitbucket info file.
// 
// NOTE: use CloseBBInfoFile so that we generate the proper 
//       SHChangeNotify event for the info file.
//
HANDLE OpenBBInfoFile(int idDrive, DWORD dwFlags, int iRetryCount)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szBBPath[MAX_PATH];
    TCHAR szInfo[MAX_PATH];
    int nAttempts = 0;
    DWORD dwLastErr;
    DECLAREWAITCURSOR;

    if ((iRetryCount == 0) || (iRetryCount > BBINFO_OPEN_MAX_RETRIES))
    {
        // zero retry count means that the caller wants the max # of retries
        iRetryCount = BBINFO_OPEN_MAX_RETRIES;
    }

    if (DriveIDToBBPath(idDrive, szBBPath) &&
        GetBBInfo2FileSpec(szBBPath, szInfo))
    {
        // If we are hitting a sharing violation, retry many times
        do
        {
            nAttempts++;
            hFile = CreateFile(szInfo,
                               GENERIC_READ | ((OPENBBINFO_WRITE & dwFlags) ? GENERIC_WRITE : 0),
                               (OPENBBINFO_WRITE & dwFlags) ? 0 : FILE_SHARE_READ,
                               NULL,
                               (OPENBBINFO_CREATE & dwFlags) ? OPEN_ALWAYS : OPEN_EXISTING,
                               FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_RANDOM_ACCESS,
                               NULL);
            if (INVALID_HANDLE_VALUE != hFile)
            {
                // success!
                break;
            }

            dwLastErr = GetLastError();
            if (ERROR_SHARING_VIOLATION != dwLastErr)
            {
                break;
            }

            TraceMsg(TF_BITBUCKET, "Bitbucket: sharing violation on info file (retry %d)", nAttempts - 1);

            if (nAttempts < iRetryCount)
            {
                SetWaitCursor();
                Sleep(BBINFO_OPEN_RETRY_PERIOD);
                ResetWaitCursor();
            }

        } while (nAttempts < iRetryCount);
    }
    
    if (hFile == INVALID_HANDLE_VALUE)
    {
        TraceMsg(TF_BITBUCKET, "Bitbucket: could not open a handle to %s - error 0x%08x!!", szInfo, dwLastErr); hFile;
    }
    else
    {
        // set the file pointer to just after the dataheader
        SetFilePointer(hFile, sizeof(BBDATAHEADER), NULL, FILE_BEGIN);
    }

    return hFile;
}

void BBAddDeletedFileInfo(LPCTSTR pszOriginal, LPCTSTR pszShortName, int iIndex, int idDrive, DWORD dwSize, HDPA *phdpaDeletedFiles)
{
    BBDATAENTRYW *pbbdew;
    BOOL fSuccess = FALSE; // assume failure

    // Flush the cache regularly
    if (*phdpaDeletedFiles && DPA_GetPtrCount(*phdpaDeletedFiles) >= 1)
    {
        pbbdew = (BBDATAENTRYW *)DPA_FastGetPtr(*phdpaDeletedFiles, 0);
        
        // Flush the cache before we start deleting files on a different drive, or
        // when it's too full
        if (pbbdew->idDrive != idDrive || DPA_GetPtrCount(*phdpaDeletedFiles) >= 128)
        {
            BBFinishDelete(*phdpaDeletedFiles);
            *phdpaDeletedFiles = NULL;
        }
    }

    pbbdew = NULL;

    if (!*phdpaDeletedFiles)
    {
        *phdpaDeletedFiles = DPA_Create(0); // Use default growth value
    }

    if (*phdpaDeletedFiles)
    {
        pbbdew = (BBDATAENTRYW*)LocalAlloc(LPTR, sizeof(*pbbdew));
        if (pbbdew)
        {
            SYSTEMTIME st;

            if (g_pBitBucket[idDrive]->fIsUnicode)
            {
                // Create a BBDATAENTRYW from a unicode name
                StringCchCopy(pbbdew->szOriginal, ARRAYSIZE(pbbdew->szOriginal), pszOriginal);
        
                if (!DoesStringRoundTrip(pszOriginal, pbbdew->szShortName, ARRAYSIZE(pbbdew->szShortName)))
                {
                    SHUnicodeToAnsi(pszShortName, pbbdew->szShortName, ARRAYSIZE(pbbdew->szShortName));
                }
            }
            else
            {
                BBDATAENTRYA *pbbdea = (BBDATAENTRYA *)pbbdew;
                // Create a BBDATAENTRYA from a unicode name
                if (!DoesStringRoundTrip(pszOriginal, pbbdea->szOriginal, ARRAYSIZE(pbbdea->szOriginal)))
                {
                    SHUnicodeToAnsi(pszShortName, pbbdea->szOriginal, ARRAYSIZE(pbbdea->szOriginal));
                }
            }

            pbbdew->iIndex = iIndex;
            pbbdew->idDrive = idDrive;
            pbbdew->dwSize = ROUND_TO_CLUSTER(dwSize, g_pBitBucket[idDrive]->dwClusterSize);

            GetSystemTime(&st);             // Get time of deletion
            SystemTimeToFileTime(&st, &pbbdew->ft);

            if (DPA_AppendPtr(*phdpaDeletedFiles, pbbdew) != -1)
            {
                fSuccess = TRUE;
            }
        }
    }

    if (!fSuccess)
    {
        TCHAR szBBPath[MAX_PATH];
        TCHAR szFileName[MAX_PATH];
        
        ASSERTMSG(FALSE, "BitBucket: failed to record deleted file %s , have to nuke it!!", pszOriginal);

        LocalFree(pbbdew);
        
        // get the recycled dir and tack on the file name
        if (DriveIDToBBPath(idDrive, szBBPath)          &&
            GetDeletedFileNameFromParts(szFileName,
                                        ARRAYSIZE(szFileName),
                                        idDrive,
                                        iIndex,
                                        pszOriginal)    &&
            PathAppend(szBBPath, szFileName))
        {
            // now delete it
            BBNuke(szBBPath);
        }
    }
}

BOOL BBFinishDelete(HDPA hdpaDeletedFiles)
{
    BOOL fSuccess = TRUE; // assume success
    int iDeletedFiles = hdpaDeletedFiles ? DPA_GetPtrCount(hdpaDeletedFiles) : 0;
    if (iDeletedFiles > 0)
    {
        int iCurrentFile = 0;
        BBDATAENTRYW *pbbdew = (BBDATAENTRYW *)DPA_FastGetPtr(hdpaDeletedFiles, iCurrentFile);

        // now write it to the file
        int idDrive = pbbdew->idDrive;
        HANDLE hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwDataEntrySize = g_pBitBucket[idDrive]->fIsUnicode ? sizeof(BBDATAENTRYW) : sizeof(BBDATAENTRYA);

            SetFilePointer(hFile, 0, NULL, FILE_END);

            while (iCurrentFile < iDeletedFiles)
            {
                DWORD dwBytesWritten;
                pbbdew = (BBDATAENTRYW *)DPA_FastGetPtr(hdpaDeletedFiles, iCurrentFile);

                // All deletes should be in the same drive for each batch.
                ASSERT(idDrive == pbbdew->idDrive);

                if (!WriteFile(hFile, pbbdew, dwDataEntrySize, &dwBytesWritten, NULL) ||
                    (dwDataEntrySize != dwBytesWritten))
                {
                    fSuccess = FALSE;
                    break;
                }
                LocalFree(pbbdew);
                iCurrentFile++;
            }

            CloseBBInfoFile(hFile, idDrive);
        }
        else
        {
            fSuccess = FALSE;
        }

        if (!fSuccess)
        {
            TCHAR szBBPath[MAX_PATH];
            int iFilesToNuke;

            for (iFilesToNuke = iCurrentFile; iFilesToNuke < iDeletedFiles; iFilesToNuke++)
            {
                pbbdew = DPA_FastGetPtr(hdpaDeletedFiles, iFilesToNuke);
                
                if (GetDeletedFilePath(szBBPath, pbbdew))
                {
                    // now delete it
                    BBNuke(szBBPath);
                }

                LocalFree(pbbdew);
            }
        }

        if (iCurrentFile != 0)
        {
            BOOL bPurge = TRUE;
        
            // since we sucessfully deleted a file, we set this so at the end of the last SHFileOperation call on this drive
            // we will go back and make sure that there isint too much stuff in the bucket.
            RegSetValueEx(g_pBitBucket[idDrive]->hkeyPerUser, TEXT("NeedToPurge"), 0, REG_DWORD, (LPBYTE)&bPurge, sizeof(bPurge));
        }
    }

    if (hdpaDeletedFiles)
        DPA_Destroy(hdpaDeletedFiles);

    return fSuccess;
}


// creates the proper SECURITY_DESCRIPTOR for securing the recycle bin
//
// NOTE: if return value is non-null, the caller must LocalFree it
//
SECURITY_DESCRIPTOR* CreateRecycleBinSecurityDescriptor()
{
    SHELL_USER_PERMISSION supLocalUser;
    SHELL_USER_PERMISSION supSystem;
    SHELL_USER_PERMISSION supAdministrators;
    PSHELL_USER_PERMISSION aPerms[3] = {&supLocalUser, &supSystem, &supAdministrators};

    // we want the current user to have full control
    supLocalUser.susID = susCurrentUser;
    supLocalUser.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supLocalUser.dwAccessMask = FILE_ALL_ACCESS;
    supLocalUser.fInherit = TRUE;
    supLocalUser.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supLocalUser.dwInheritAccessMask = GENERIC_ALL;

    // we want the SYSTEM to have full control
    supSystem.susID = susSystem;
    supSystem.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supSystem.dwAccessMask = FILE_ALL_ACCESS;
    supSystem.fInherit = TRUE;
    supSystem.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supSystem.dwInheritAccessMask = GENERIC_ALL;

    // we want the Administrators to have full control
    supAdministrators.susID = susAdministrators;
    supAdministrators.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supAdministrators.dwAccessMask = FILE_ALL_ACCESS;
    supAdministrators.fInherit = TRUE;
    supAdministrators.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supAdministrators.dwInheritAccessMask = GENERIC_ALL;

    return GetShellSecurityDescriptor(aPerms, ARRAYSIZE(aPerms));
}

//
// Creates the secure recycle bin directory (eg one with ACL's that protect it)
// for recycle bins on NTFS volumes.
//
BOOL CreateSecureRecyclerDirectory(LPCTSTR pszPath)
{
    BOOL fSuccess = FALSE;      // assume failure
    SECURITY_DESCRIPTOR* psd = CreateRecycleBinSecurityDescriptor();

    if (psd)
    {
        DWORD cbSA = GetSecurityDescriptorLength(psd);
        SECURITY_DESCRIPTOR* psdSelfRelative;

        psdSelfRelative = (SECURITY_DESCRIPTOR*)LocalAlloc(LPTR, cbSA);

        if (psdSelfRelative)
        {
            if (MakeSelfRelativeSD(psd, psdSelfRelative, &cbSA))
            {
                SECURITY_ATTRIBUTES sa;

                // Build the security attributes structure
                sa.nLength = sizeof(SECURITY_ATTRIBUTES);
                sa.lpSecurityDescriptor = psdSelfRelative;
                sa.bInheritHandle = FALSE;

                fSuccess = (SHCreateDirectoryEx(NULL, pszPath, &sa) == ERROR_SUCCESS);
            }

            LocalFree(psdSelfRelative);
        }

        LocalFree(psd);
    }

    return fSuccess;
}

BOOL CreateRecyclerDirectory(int idDrive)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szRoot[MAX_PATH];
    BOOL bResult = FALSE;

    // NOTE: we currently do not to check for FAT/FAT32 drives that have been 
    // upgraded to NTFS and migrate the recycle bin info over
    
    if (DriveIDToBBPath(idDrive, szPath) &&
        DriveIDToBBRoot(idDrive, szRoot))
    {
        BOOL bExists = PathIsDirectory(szPath);

        if (!bExists)
        {
            if (CMtPt_IsSecure(idDrive))
            {
                bExists = CreateSecureRecyclerDirectory(szPath);
            }
            else
            {
                bExists = (SHCreateDirectoryEx(NULL, szPath, NULL) == ERROR_SUCCESS);
            }
        }

        if (bExists && PathAppend(szPath, c_szDesktopIni))
        {
            // CLSID_RecycleBin
            WritePrivateProfileString(STRINI_CLASSINFO, TEXT("CLSID"), TEXT("{645FF040-5081-101B-9F08-00AA002F954E}"), szPath);
            SetFileAttributes(szPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);   // desktop.ini

            PathRemoveFileSpec(szPath);
            // Hide all of the directories along the way until we hit the BB root
            do
            {
                SetFileAttributes(szPath, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
                PathRemoveFileSpec(szPath);

            } while (0 != lstrcmpi(szPath, szRoot));

            // everything's set.  let's add it in
            // try to load the and initalize 
            bResult = TRUE;
        }
    }

    return bResult;
}


//
// this sets up the bitbucket directory and allocs the internal structures
//
BOOL MakeBitBucket(int idDrive)
{
    BOOL bRet = FALSE;

    if (IsBitBucketableDrive(idDrive))
    {
        if (IsBitBucketInited(idDrive))
        {
            LONG lBucketDirtyCount = SHGlobalCounterGetValue(g_pBitBucket[idDrive]->hgcDirtyCount);
            LONG lGlobalDirtyCount = SHGlobalCounterGetValue(g_hgcGlobalDirtyCount);

            // check to see if we need to refresh the settings for this bucket
            if (lGlobalDirtyCount > g_lProcessDirtyCount)
            {
                // global settings change, so refresh all buckets
                g_lProcessDirtyCount = lGlobalDirtyCount;
                RefreshAllBBDriveSettings();
            }
            else if (lBucketDirtyCount > g_pBitBucket[idDrive]->lCurrentDirtyCount)
            {
                // just this buckets settings changed, so refresh only this one
                g_pBitBucket[idDrive]->lCurrentDirtyCount = lBucketDirtyCount;
                RefreshBBDriveSettings(idDrive);
            }
            
            bRet = TRUE;
        }
        else
        {
            bRet = AllocBBDriveInfo(idDrive);
        }
    }

    return bRet;
}


// Tells if a file will *likely* be recycled...
// this could be wrong if:
//
//      * disk is full
//      * file is really a folder
//      * file greater than the allocated size for the recycle directory
//      * file is in use or no ACLS to move or delete it
//
BOOL BBWillRecycle(LPCTSTR pszFile, INT* piRet)
{
    INT iRet = BBDELETE_SUCCESS;
    int idDrive = DriveIDFromBBPath(pszFile);

    // MakeBitBucket will ensure that the global & per-bucket settings we have are current
    if (!MakeBitBucket(idDrive) || g_pBitBucket[idDrive]->fNukeOnDelete || (g_pBitBucket[idDrive]->iPercent == 0))
    {
        iRet = BBDELETE_FORCE_NUKE;
    }
    else if (SERVERDRIVE == idDrive)
    {
        // Check to see if the serverdrive is offline (don't recycle while offline to prevent
        // synchronization conflicts when coming back online):
        TCHAR szVolume[MAX_PATH];
        LONG lStatus;
        
        if (DriveIDToBBVolumeRoot(idDrive, szVolume))
        {
            lStatus = GetOfflineShareStatus(szVolume);
            if ((CSC_SHARESTATUS_OFFLINE == lStatus) || (CSC_SHARESTATUS_SERVERBACK == lStatus))
            {
                iRet = BBDELETE_NUKE_OFFLINE;
            }
        }
        else
        {
            iRet = BBDELETE_NUKE_OFFLINE;
        }
    }

    if (piRet)
    {
        *piRet = iRet;
    }
    return (BBDELETE_SUCCESS == iRet);
}


//
// This is called at the end of the last pending SHFileOperation that involves deletes.
// We wait till there arent any more people deleteing before we go try to compact the info
// file or purge entries and make the bitbucket respect its cbMaxSize.
//
void CheckCompactAndPurge()
{
    int i;
    TCHAR szBBKey[MAX_PATH];
    HKEY hkBBPerUser;

    for (i = 0; i < MAX_BITBUCKETS ; i++)
    {
        DriveIDToBBRegKey(i, szBBKey);
        
        // NOTE: these function needs to manually construct the key because it would like to avoid calling MakeBitBucket()
        // for drives that it has yet to look at (this is a performance optimization)
        if (RegOpenKeyEx(g_hkBitBucketPerUser, szBBKey, 0, KEY_QUERY_VALUE |  KEY_SET_VALUE, &hkBBPerUser) == ERROR_SUCCESS)
        {
            BOOL bCompact = FALSE;
            BOOL bPurge = FALSE;
            DWORD dwSize;

            dwSize = sizeof(bCompact);
            if (RegQueryValueEx(hkBBPerUser, TEXT("NeedToCompact"), NULL, NULL, (LPBYTE)&bCompact, &dwSize) == ERROR_SUCCESS && bCompact == TRUE)
            {
                // reset this key so no one else tries to compact this bitbucket
                RegDeleteValue(hkBBPerUser, TEXT("NeedToCompact"));
            }

            dwSize = sizeof(bPurge);
            if (RegQueryValueEx(hkBBPerUser, TEXT("NeedToPurge"), NULL, NULL, (LPBYTE)&bPurge, &dwSize) == ERROR_SUCCESS && bPurge == TRUE)
            {
                // reset this key so no one else tries to purge this bitbucket
                RegDeleteValue(hkBBPerUser, TEXT("NeedToPurge"));
            }
  
            if (MakeBitBucket(i))
            {
                if (bCompact)
                {
                    TraceMsg(TF_BITBUCKET, "Bitbucket: compacting drive %d",i);
                    CompactBBInfoFile(i);
                }

                if (bPurge)
                {
                    TraceMsg(TF_BITBUCKET, "Bitbucket: purging drive %d", i);
                    PurgeBBFiles(i);
                }
            }

            RegCloseKey(hkBBPerUser);
        }
    }

    SHUpdateRecycleBinIcon();
    SHChangeNotify(0, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, NULL, NULL);
}



// Initialization to call prior to BBDeleteFile
BOOL BBDeleteFileInit(LPTSTR pszFile, INT* piRet)
{
    // check to see if we need to init our global data first
    if (!InitBBGlobals())
    {
        // this could happen in low memory situations, we have no choice but
        // to really nuke the file
        *piRet = BBDELETE_FORCE_NUKE;
        return FALSE;
    }

    if (!BBWillRecycle(pszFile, piRet))
    {
        // We failed to create the recycler directory on the volume, or
        // this is the case where the user has "delete files immeadately" set, or 
        // % max size=0, etc.
        return FALSE;
    }

    return TRUE;
}

// return:
//
//      TRUE    - The file/folder was sucessfully moved to the recycle bin. We set lpiReturn = BBDELETE_SUCCESS for this case.
//
//      FALSE   - The file/folder could not be moved to the recycle bin
//                In this case, the piRet value tells WHY the file/folder could not be recycled:
//                
//                BBDELETE_FORCE_NUKE       - User has "delete file immeadately" set, or % max size=0, or we failed to 
//                                            create the recycler directory.
//
//                BBDELETE_CANNOT_DELETE    - The file/folder is non-deletable because a file under it cannot be deleted.
//                                            This is an NT only case, and it could be caused by acls or the fact that the
//                                            folder or a file in it is currently in use.
//
//                BBDELETE_SIZE_TOO_BIG     - The file/folder is bigger than the max allowable size of the recycle bin.
//
//                BBDELETE_PATH_TOO_LONG    - The path would be too long ( > MAX_PATH), if the file were to be moved to the
//                                            the recycle bin directory at the root of the drive
//
//                BBDELETE_UNKNOWN_ERROR    - Some other error occured, GetLastError() should explain why we failed.
//                            
//
BOOL BBDeleteFile(LPTSTR pszFile, INT* piRet, LPUNDOATOM lpua, BOOL fIsDir, HDPA *phdpaDeletedFiles, ULARGE_INTEGER ulSize)
{
    int iRet;
    TCHAR szBitBucket[MAX_PATH];
    TCHAR szFileName[MAX_PATH];
    TCHAR szShortFileName[MAX_PATH];
    DWORD dwLastError;
    int iIndex;
    int idDrive = DriveIDFromBBPath(pszFile);
    int iAttempts = 0;

    TraceMsg(TF_BITBUCKET, "BBDeleteFile (%s)", pszFile);
    // Before we move the file we save off the "short" name. This is in case we have 
    // a unicode path and we need the ansi short path in case a win95 machine later tries to
    // restore this file. We can't do this later because GetShortPathName relies on the 
    // file actually exising.
    if (!GetShortPathName(pszFile, szShortFileName, ARRAYSIZE(szShortFileName)))
    {
        StringCchCopy(szShortFileName, ARRAYSIZE(szShortFileName), pszFile);
    }

TryMoveAgain:

    // get the target name and move it
    iIndex = SHGlobalCounterIncrement(g_pBitBucket[idDrive]->hgcNextFileNum);
    
    if (GetDeletedFileNameFromParts(szFileName, ARRAYSIZE(szFileName), idDrive, iIndex, pszFile)    &&
        DriveIDToBBPath(idDrive, szBitBucket)                                                       &&
        PathAppend(szBitBucket, szFileName))
    {
        iRet = SHMoveFile(pszFile, szBitBucket, fIsDir ? SHCNE_RMDIR : SHCNE_DELETE);

        // do GetLastError here so that we don't get the last error from the PathFileExists
        dwLastError = (iRet ? ERROR_SUCCESS : GetLastError());

        if (!iRet) 
        {
            TraceMsg(TF_BITBUCKET, "BBDeleteFile : Error(%x) moving file (%s)", dwLastError, pszFile);
            if (ERROR_ALREADY_EXISTS == dwLastError)
            {
                TraceMsg(TF_BITBUCKET, "Bitbucket: BBDeleteFile found a file of the same name (%s) - skipping", szBitBucket);
                // generate a new filename and retry
                goto TryMoveAgain;
            }
            // Since we are moving files that may be temporarily in use (e.g. for thumbnail extraction)
            // we may get a transient error (sharing violation is obvious but we also can get access denied
            // for some reason) so we end up trying this again after a short nap.
            else if (((ERROR_ACCESS_DENIED == dwLastError) || (ERROR_SHARING_VIOLATION == dwLastError)) && 
                     (iAttempts < MAX_DELETE_ATTEMPTS))
            {
                TraceMsg(TF_BITBUCKET, "BBDeleteFile : sleeping a bit to try again");
                iAttempts++;
                Sleep(SLEEP_DELETE_ATTEMPT);  // wait a bit
                goto TryMoveAgain;
            }
            else
            {
                // is our recycled directory still there?
                TCHAR szTemp[MAX_PATH];
                SHGetPathFromIDList(g_pBitBucket[idDrive]->pidl, szTemp);
                // if it already exists or there was some error in creating it, bail
                // else try again
                if (!PathIsDirectory(szTemp) && CreateRecyclerDirectory(idDrive))
                {
                    // if we did just re-create the directory, we need to reset the info
                    // file or the drive will get corrupted.
                    VerifyBBInfoFileHeader(idDrive);
                    goto TryMoveAgain;
                }
            }
        }
        else 
        {
            // success!
            BBAddDeletedFileInfo(pszFile, szShortFileName, iIndex, idDrive, ulSize.LowPart, phdpaDeletedFiles);
    
            if (lpua)
                FOUndo_AddInfo(lpua, pszFile, szBitBucket, 0);
            *piRet = BBDELETE_SUCCESS;
            return TRUE;
        }
    }
    else
    {
        // probably means that the path is too long
        *piRet = BBDELETE_PATH_TOO_LONG;
        return FALSE;
    }

    // set back the correct last error
    SetLastError(dwLastError);
    
    // something bad happened, we dont know what it is
    *piRet = BBDELETE_UNKNOWN_ERROR;

    return FALSE;
}


// Basically it understands how we the trash is layed out which is fine
// as we are in the bitbucket code file... So we skip the first 3
// characters for the root of the name: c:\ and we truncate off the
// last part of the name and the rest should match our deathrow name...
BOOL IsFileInBitBucket(LPCTSTR pszPath)
{
    TCHAR szPath[MAX_PATH];
    int idDrive = DriveIDFromBBPath(pszPath);

    if (IsBitBucketableDrive(idDrive) &&
        DriveIDToBBPath(idDrive, szPath))
    {
        return (PathCommonPrefix(szPath, pszPath, NULL) == lstrlen(szPath));
    }

    return FALSE;
}


//
// This is called by the copy engine when a user selects "undo".
//
// NOTE: takes two multistrings (seperated/double null terminated file lists)
void UndoBBFileDelete(LPCTSTR pszOriginal, LPCTSTR pszDelFile)
{
    SHFILEOPSTRUCT sFileOp = {NULL,
                              FO_MOVE,
                              pszDelFile,
                              pszOriginal,
                              FOF_NOCONFIRMATION | FOF_MULTIDESTFILES | FOF_SIMPLEPROGRESS};

    SHFileOperation(&sFileOp);

    SHUpdateRecycleBinIcon();
}


STDAPI_(void) SHUpdateRecycleBinIcon()
{
    UpdateIcon(!IsRecycleBinEmpty());
}


void PurgeOneBitBucket(HWND hwnd, int idDrive, DWORD dwFlags)
{
    TCHAR szPath[MAX_PATH + 1]; // +1 for the double-null
    HANDLE hFile;
    SHFILEOPSTRUCT sFileOp = {hwnd,
                              FO_DELETE,
                              szPath,
                              NULL,
                              FOF_SIMPLEPROGRESS,
                              FALSE,
                              NULL,
                              MAKEINTRESOURCE(IDS_BB_EMPTYINGWASTEBASKET)};

    ASSERT(g_pBitBucket[idDrive] && (g_pBitBucket[idDrive] != (BBSYNCOBJECT *)-1));

    if (dwFlags & SHERB_NOCONFIRMATION)
    {
        sFileOp.fFlags |= FOF_NOCONFIRMATION;
    }

    if (dwFlags & SHERB_NOPROGRESSUI)
    {
        sFileOp.fFlags |= FOF_SILENT;
    }

    if (DriveIDToBBPath(idDrive, szPath)    &&
        PathAppend(szPath, c_szDStarDotStar))
    {
        szPath[lstrlen(szPath) + 1] = 0; // double null terminate

        hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);

        if (INVALID_HANDLE_VALUE != hFile)
        {
            // now do the actual delete.
            if (SHFileOperation(&sFileOp) || sFileOp.fAnyOperationsAborted)
            {
                TraceMsg(TF_BITBUCKET, "Bitbucket: emptying bucket on %s failed", szPath);

                // NOTE: the info file may point to some files that have been deleted,
                // it will be cleaned up later
            }
            else
            {
                // reset the info file since we just emptied this bucket.
                ResetInfoFileHeader(hFile, g_pBitBucket[idDrive]->fIsUnicode);
            }

            // we always re-create the desktop.ini
            CreateRecyclerDirectory(idDrive);

            CloseBBInfoFile(hFile, idDrive);
        }
    }
    
    SHUpdateRecycleBinIcon();
}


// This function checks to see if an local NT directory is delete-able
//
// returns:
//      TRUE   yes, the dir can be nuked
//      FALSE  for UNC dirs or dirs on network drives, or
//             if the user does not have enough privlidges
//             to delete the file (acls).
//
// NOTE: this code is largely stolen from the RemoveDirectoryW API (windows\base\client\dir.c). if
//       you think that there is a bug in it, then diff it against the DeleteFileW and see it something
//       there changed.
//
// also sets the last error to explain why
//
BOOL IsDirectoryDeletable(LPCTSTR pszDir)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    void *FreeBuffer;
    DWORD dwAttributes;
    BOOL fChangedAttribs = FALSE;

    // return false for any network drives (allow UNC)
    if (IsNetDrive(PathGetDriveNumber(pszDir)))
    {
        return FALSE;
    }

    if (PathIsUNC(pszDir) && PathIsDirectoryEmpty(pszDir))
    {
        // HACKACK - (reinerf) the rdr will nuke the file when we call
        // NtSetInformationFile to set the deleted bit on an empty directory even
        // though we pass READ_CONTROL and we still have a handle to the object.
        // So, to work around this, we just assume we can always delete empty
        // directories (ha!)
        return TRUE;
    }

    // check to see if the dir is readonly
    dwAttributes = GetFileAttributes(pszDir);
    if ((dwAttributes != -1) && (dwAttributes & FILE_ATTRIBUTE_READONLY))
    {
        fChangedAttribs = TRUE;

        if (!SetFileAttributes(pszDir, dwAttributes & ~FILE_ATTRIBUTE_READONLY))
        {
            return FALSE;
        }
    }

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(pszDir,
                                                             &FileName,
                                                             NULL,
                                                             &RelativeName);
    if (!TranslationStatus)
    {
        if (fChangedAttribs)
        {
            // set the attribs back
            SetFileAttributes(pszDir, dwAttributes);
        }

        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length)
    {
        FileName = RelativeName.RelativeName;
    }
    else
    {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               &FileName,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL);

    //
    // Open the directory for delete access.
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    //
    Status = NtOpenFile(&Handle,
                        DELETE | SYNCHRONIZE | FILE_READ_ATTRIBUTES | READ_CONTROL,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT);

    if (!NT_SUCCESS(Status))
    {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if (Status == STATUS_INVALID_PARAMETER)
        {
            //   
            // Re-open not inhibiting the reparse behavior and not needing to read the attributes.
            //
            Status = NtOpenFile(&Handle,
                                DELETE | SYNCHRONIZE | READ_CONTROL,
                                &Obja,
                                &IoStatusBlock,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT);

            if (!NT_SUCCESS(Status))
            {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

                if (fChangedAttribs)
                {
                    // set the attribs back
                    SetFileAttributes(pszDir, dwAttributes);
                }

                SetLastError(RtlNtStatusToDosError(Status));
                return FALSE;
            }
        }
        else
        {
            RtlReleaseRelativeName(&RelativeName);
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

            if (fChangedAttribs)
            {
                // set the attribs back
                SetFileAttributes(pszDir, dwAttributes);
            }
            
            SetLastError(RtlNtStatusToDosError(Status));
            return FALSE;
        }
    }
    else
    {
        //
        // If we found a reparse point that is not a name grafting operation,
        // either a symbolic link or a mount point, we re-open without 
        // inhibiting the reparse behavior.
        //
        Status = NtQueryInformationFile(Handle,
                                        &IoStatusBlock,
                                        (void *) &FileTagInformation,
                                        sizeof(FileTagInformation),
                                        FileAttributeTagInformation);
    
        if (!NT_SUCCESS(Status))
        {
            //
            // Not all File Systems implement all information classes.
            // The value STATUS_INVALID_PARAMETER is returned when a non-supported
            // information class is requested to a back-level File System. As all the
            // parameters to NtQueryInformationFile are correct, we can infer that
            // we found a back-level system.
            //
            // If FileAttributeTagInformation is not implemented, we assume that
            // the file at hand is not a reparse point.
            //

            if ((Status != STATUS_NOT_IMPLEMENTED) && (Status != STATUS_INVALID_PARAMETER))
            {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);

                if (fChangedAttribs)
                {
                    // set the attribs back
                    SetFileAttributes(pszDir, dwAttributes);
                }

                SetLastError(RtlNtStatusToDosError(Status));
                return FALSE;
            }
        }

        if (NT_SUCCESS(Status) && (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))
        {
            if (FileTagInformation.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
            {
                //
                // We want to make sure that we return FALSE for mounted volumes. This will cause BBDeleteFile
                // to return BBDELETE_CANNOT_DELETE so that we will actuall delete the mountpoint and not try to
                // move the mount point to the recycle bin or walk into it.
                //
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);

                if (fChangedAttribs)
                {
                     // set the attribs back
                    SetFileAttributes(pszDir, dwAttributes);
                }

                // hmmm... lets pull ERROR_NOT_A_REPARSE_POINT out of our butt and return that error code!
                SetLastError(ERROR_NOT_A_REPARSE_POINT);
                return FALSE;
            }
        }
    
        if (NT_SUCCESS(Status) && (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))
        {
            //
            // Re-open without inhibiting the reparse behavior and not needing to 
            // read the attributes.
            //
            NtClose(Handle);
            Status = NtOpenFile(&Handle,
                                DELETE | SYNCHRONIZE | READ_CONTROL,
                                &Obja,
                                &IoStatusBlock,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT);

            if (!NT_SUCCESS(Status))
            {
                //
                // When the FS Filter is absent, delete it any way.
                //
                if (Status == STATUS_IO_REPARSE_TAG_NOT_HANDLED)
                {
                    //
                    // We re-open (possible 3rd open) for delete access inhibiting the reparse behavior.
                    //
                    Status = NtOpenFile(&Handle,
                                        DELETE | SYNCHRONIZE | READ_CONTROL,
                                        &Obja,
                                        &IoStatusBlock,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT);
                }

                if (!NT_SUCCESS(Status))
                {
                    RtlReleaseRelativeName(&RelativeName);
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    
                    if (fChangedAttribs)
                    {
                        // set the attribs back
                        SetFileAttributes(pszDir, dwAttributes);
                    }

                    SetLastError(RtlNtStatusToDosError(Status));
                    return FALSE;
                }
            }
        }
    }
    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Attempt to set the delete bit
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(Handle,
                                  &IoStatusBlock,
                                  &Disposition,
                                  sizeof(Disposition),
                                  FileDispositionInformation);

    if (NT_SUCCESS(Status)) 
    {
        //
        // yep, we were able to set the bit, now unset it so its not delted!
        //
        Disposition.DeleteFile = FALSE;
        Status = NtSetInformationFile(Handle,
                                      &IoStatusBlock,
                                      &Disposition,
                                      sizeof(Disposition),
                                      FileDispositionInformation);
        NtClose(Handle);
        
        if (fChangedAttribs)
        {
            // set the attribs back
            SetFileAttributes(pszDir, dwAttributes);
        }
        return TRUE;
    }
    else
    {
        //
        // nope couldnt set the del bit. can't be deleted
        //
        TraceMsg(TF_BITBUCKET, "IsDirectoryDeletable: NtSetInformationFile failed, status=0x%08x", Status);

        NtClose(Handle);

        if (fChangedAttribs)
        {
             // set the attribs back
            SetFileAttributes(pszDir, dwAttributes);
        }

        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }
    return TRUE;
}


// This function checks to see if a local NT file is delete-able
//
// returns:
//      TRUE   yes, the file can be nuked
//      FALSE  for UNC files or files on network drives
//      FALSE  if the file is in use
//
// NOTE: this code is largely stolen from the DeleteFileW API (windows\base\client\filemisc.c). if
//       you think that there is a bug in it, then diff it against the DeleteFileW and see it something
//       there changed.
//
// also sets the last error to explain why
//
BOOL IsFileDeletable(LPCTSTR pszFile)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    void *FreeBuffer;
    BOOLEAN fIsSymbolicLink = FALSE;
    DWORD dwAttributes;
    BOOL fChangedAttribs = FALSE;

    // return false for any network drives
    if (IsNetDrive(PathGetDriveNumber(pszFile)))
    {
        return FALSE;
    }

    // check to see if the file is readonly or system
    dwAttributes = GetFileAttributes(pszFile);
    if (dwAttributes != -1)
    {
        if (dwAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
        {
            fChangedAttribs = TRUE;

            if (!SetFileAttributes(pszFile, dwAttributes & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
            {
                return FALSE;
            }
        }
    }

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(pszFile,
                                                             &FileName,
                                                             NULL,
                                                             &RelativeName);

    if (!TranslationStatus)
    {
        if (fChangedAttribs)
        {
             // set the attribs back
            SetFileAttributes(pszFile, dwAttributes);
        }

        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length)
    {
        FileName = RelativeName.RelativeName;
    }
    else
    {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               &FileName,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL);

    // Open the file for delete access
    Status = NtOpenFile(&Handle,
                        (ACCESS_MASK)DELETE | FILE_READ_ATTRIBUTES | READ_CONTROL,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT);

    if (!NT_SUCCESS(Status))
    {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if (Status == STATUS_INVALID_PARAMETER)
        {
            //
            // Open without inhibiting the reparse behavior and not needing to
            // read the attributes.
            //

            Status = NtOpenFile(&Handle,
                                (ACCESS_MASK)DELETE | READ_CONTROL,
                                &Obja,
                                &IoStatusBlock,
                                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT);

            if (!NT_SUCCESS(Status))
            {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

                if (fChangedAttribs)
                {
                     // set the attribs back
                    SetFileAttributes(pszFile, dwAttributes);
                }

                SetLastError(RtlNtStatusToDosError(Status));
                return FALSE;
            }
        }
        else
        {
            RtlReleaseRelativeName(&RelativeName);
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

            if (fChangedAttribs)
            {
                 // set the attribs back
                SetFileAttributes(pszFile, dwAttributes);
            }

            SetLastError(RtlNtStatusToDosError(Status));
            return FALSE;
        }
    }
    else
    {
        //
        // If we found a reparse point that is not a symbolic link, we re-open
        // without inhibiting the reparse behavior.
        //
        Status = NtQueryInformationFile(Handle,
                                        &IoStatusBlock,
                                        (void *) &FileTagInformation,
                                        sizeof(FileTagInformation),
                                        FileAttributeTagInformation);
        if (!NT_SUCCESS(Status))
        {
            //
            // Not all File Systems implement all information classes.
            // The value STATUS_INVALID_PARAMETER is returned when a non-supported
            // information class is requested to a back-level File System. As all the
            // parameters to NtQueryInformationFile are correct, we can infer that
            // we found a back-level system.
            //
            // If FileAttributeTagInformation is not implemented, we assume that
            // the file at hand is not a reparse point.
            //

            if ((Status != STATUS_NOT_IMPLEMENTED) && (Status != STATUS_INVALID_PARAMETER))
            {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);

                if (fChangedAttribs)
                {
                     // set the attribs back
                    SetFileAttributes(pszFile, dwAttributes);
                }

                SetLastError(RtlNtStatusToDosError(Status));
                return FALSE;
            }
        }

        if (NT_SUCCESS(Status) && (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))
        {
            if (FileTagInformation.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
            {
                fIsSymbolicLink = TRUE;
            }
        }

        if (NT_SUCCESS(Status)                                                 &&
            (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
            !fIsSymbolicLink)
        {
            //
            // Re-open without inhibiting the reparse behavior and not needing to
            // read the attributes.
            //

            NtClose(Handle);
            Status = NtOpenFile(&Handle,
                                (ACCESS_MASK)DELETE | READ_CONTROL,
                                &Obja,
                                &IoStatusBlock,
                                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT);

            if (!NT_SUCCESS(Status))
            {
                //
                // When the FS Filter is absent, delete it any way.
                //

                if (Status == STATUS_IO_REPARSE_TAG_NOT_HANDLED)
                {
                    //
                    // We re-open (possible 3rd open) for delete access inhibiting the reparse behavior.
                    //

                    Status = NtOpenFile(&Handle,
                                        (ACCESS_MASK)DELETE | READ_CONTROL,
                                        &Obja,
                                        &IoStatusBlock,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                        FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT);
                }

                if (!NT_SUCCESS(Status))
                {
                    RtlReleaseRelativeName(&RelativeName);
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

                    if (fChangedAttribs)
                    {
                         // set the attribs back
                        SetFileAttributes(pszFile, dwAttributes);
                    }

                    SetLastError(RtlNtStatusToDosError(Status));
                    return FALSE;
                }
            }
        }
    }

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Attempt to set the delete bit
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(Handle,
                                  &IoStatusBlock,
                                  &Disposition,
                                  sizeof(Disposition),
                                  FileDispositionInformation);

    if (NT_SUCCESS(Status)) 
    {
        //
        // yep, we were able to set the bit, now unset it so its not delted!
        //
        Disposition.DeleteFile = FALSE;
        Status = NtSetInformationFile(Handle,
                                      &IoStatusBlock,
                                      &Disposition,
                                      sizeof(Disposition),
                                      FileDispositionInformation);
        NtClose(Handle);
        
        if (fChangedAttribs)
        {
            // set the attribs back
            SetFileAttributes(pszFile, dwAttributes);
        }
        return TRUE;
    }
    else
    {
        //
        // nope couldnt set the del bit. can't be deleted
        //
        TraceMsg(TF_BITBUCKET, "IsFileDeletable: NtSetInformationFile failed, status=0x%08x", Status);

        NtClose(Handle);

        if (fChangedAttribs)
        {
             // set the attribs back
            SetFileAttributes(pszFile, dwAttributes);
        }

        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }
    return TRUE;
}

BOOL BBCheckDeleteFileSize(int idDrive, ULARGE_INTEGER ulSize)
{
    return (!ulSize.HighPart && g_pBitBucket[idDrive]->cbMaxSize > ulSize.LowPart);
}

int BBRecyclePathLength(int idDrive)
{
    return g_pBitBucket[idDrive]->cchBBDir;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\bitbuck.h ===
#ifndef _BITBUCK_INC
#define _BITBUCK_INC

#include "ids.h"
#include "undo.h"

// whacky #defines

#define DELETEMAX 100000
#define MAX_BITBUCKETS 27
#define MAX_DRIVES 26
#define OPENFILERETRYTIME 500
#define OPENFILERETRYCOUNT 10
#define SERVERDRIVE 26
#define MAX_EMPTY_FILES     100     // if we have MAX_EMPTY_FILES or more then we use the generic "do you want to empty" message.  

#define TF_BITBUCKET 0x10000000
// #define TF_BITBUCKET TF_ERROR

//
// NOTE: The on-disk format of the recycle bin should never have to change again.
//       If you think you need to change it, then you are wrong.
//
#define BITBUCKET_WIN95_VERSION         0       // (info)  Ansi Win95, OSR2 wastebasket
#define BITBUCKET_NT4_VERSION           2       // (info)  Unicode NT4 wastebasket
#define BITBUCKET_WIN98IE4INT_VERSION   4       // (info2) win9x+IE4 integrated, and win98 wastebasket       
#define BITBUCKET_FINAL_VERSION         5       // (info2) NT4+IE4 integraged, win2k, millenium, every future os wastebasket

#define OPENBBINFO_READ                 0x00000000
#define OPENBBINFO_WRITE                0x00000001
#define OPENBBINFO_CREATE               0x00000003

#define IsDeletedEntry(pbbde) (! (((BBDATAENTRYA*)pbbde)->szOriginal[0]) )
#define MarkEntryDeleted(pbbde) ((BBDATAENTRYA*)pbbde)->szOriginal[0] = '\0';

// this is the old (win95) data header.  it's maintained in the info file
// but only used for verification.  for current stuff look at the driveinfo,
// which is kept in the registry.
typedef struct {
    int idVersion;
    int cFiles;                     // the # of items in this drive's recycle bin
    int cCurrent;                   // the current file number.
    UINT cbDataEntrySize;           // size of each entry
    DWORD dwSize;                   // total size of this recycle bin drive
} BBDATAHEADER;

// The bitbucket datafile (INFO on win95, INFO2 on IE4/NT5, etc...) format is as follows:
//
// (binary writes)
//
//      BBDATAHEADER        // header
//      BBDATAENTRY[X]      // array of BBDATAENTRYies
//

typedef struct {
    CHAR szOriginal[MAX_PATH];  // original filename (if szOriginal[0] is 0, then it's a deleted entry)
    int  iIndex;                // index (key to name)
    int idDrive;                // which drive bucket it's currently in
    FILETIME ft;
    DWORD dwSize;
    // shouldn't need file attributes because we did a move file
    // which should have preserved them.
} BBDATAENTRYA, *LPBBDATAENTRYA;

typedef struct {
    CHAR szShortName[MAX_PATH]; // original filename, shortened (if szOriginal[0] is 0, then it's a deleted entry)
    int iIndex;                 // index (key to name)
    int idDrive;                // which drive bucket it's currently in
    FILETIME ft;
    DWORD dwSize;
    WCHAR szOriginal[MAX_PATH]; // original filename
} BBDATAENTRYW, *LPBBDATAENTRYW;

typedef BBDATAENTRYA UNALIGNED *PUBBDATAENTRYA;

// On NT5 we are finally going to have cross-process syncrhonization to 
// the Recycle Bin. We replaced the global LPBBDRIVEINFO array with an
// array of the following structures:
typedef struct {
    BOOL fInited;               // is this particular BBSYNCOBJECT fully inited (needed when we race to create it)
    HANDLE hgcNextFileNum;      // a global counter that garuntees unique deleted file names
    HANDLE hgcDirtyCount;       // a global counter to tell us if we need to re-read the bitbucket settings from the registry (percent, max size, etc)
    LONG lCurrentDirtyCount;    // out current dirty count; we compare this to hgcDirtyCount to see if we need to update the settings from the registry
    HKEY hkey;                  // HKLM reg key, under which we store the settings for this specific bucket (iPercent and fNukeOnDelete).
    HKEY hkeyPerUser;           // HKCU reg key, under which we have volital reg values indicatiog if there is a need to purge or compact this bucket

    BOOL fIsUnicode;            // is this a bitbucket on a drive whose INFO2 file uses BBDATAENTRYW structs?
    int iPercent;               // % of the drive to use for the bitbucket
    DWORD cbMaxSize;            // maximum size of bitbucket (in bytes), NOTE: we use a dword because the biggest the BB can ever grow to is 4 gigabytes.
    DWORD dwClusterSize;        // cluster size of this volume, needed to round all the file sizes
    ULONGLONG qwDiskSize;       // total size of the disk - takes into account quotas on NTFS
    BOOL fNukeOnDelete;         // I love the smell of napalm in the morning.

    LPITEMIDLIST pidl;          // pidl = bitbucket dir for this drive
    int cchBBDir;               // # of characters that makes up the bitbucket directory.

} BBSYNCOBJECT;

#define c_szInfo2           TEXT("INFO2")    // version 2 of the db file (used in IE4, win98, NT5, ...)
#define c_szInfo            TEXT("INFO")     // version 1 of the db file (used in win95, osr2, NT4)
#define c_szDStarDotStar    TEXT("D*.*")

// globals

EXTERN_C BBSYNCOBJECT *g_pBitBucket[MAX_BITBUCKETS];
EXTERN_C HKEY g_hkBitBucket;
EXTERN_C HANDLE g_hgcNumDeleters;

// prototypes by bitbuck.c, bbckfldr.cpp

STDAPI_(BOOL) InitBBGlobals();
STDAPI_(void) BitBucket_Terminate();
STDAPI_(BOOL) IsBitBucketableDrive(int idDrive);
STDAPI_(int)  DriveIDFromBBPath(LPCTSTR pszPath);
STDAPI_(void) UpdateIcon(BOOL fFull);
STDAPI_(void) NukeFileInfoBeforePoint(HANDLE hfile, LPBBDATAENTRYW pbbdew, DWORD dwDataEntrySize);
STDAPI_(BOOL) ReadNextDataEntry(HANDLE hfile, LPBBDATAENTRYW pbbde, BOOL fSkipDeleted, int idDrive);
STDAPI_(void) CloseBBInfoFile(HANDLE hFile, int idDrive);
STDAPI_(HANDLE) OpenBBInfoFile(int idDrive, DWORD dwFlags, int iRetryCount);
STDAPI_(int)  BBPathToIndex(LPCTSTR pszPath);
STDAPI        BBFileNameToInfo(LPCTSTR pszFileName, int *pidDrive, int *piIndex);
STDAPI_(BOOL) GetDeletedFileName(LPTSTR pszFileName, size_t cchFileName, const BBDATAENTRYW *pbbdew);
STDAPI_(BOOL) DriveIDToBBPath(int idDrive, LPTSTR pszPath);
STDAPI_(BOOL) DriveIDToBBRoot(int idDrive, LPTSTR szPath);
STDAPI_(BOOL) DriveIDToBBVolumeRoot(int idDrive, LPTSTR szPath);
STDAPI_(BOOL) GetNetHomeDir(LPTSTR pszPath);
STDAPI_(BOOL) PersistBBDriveSettings(int idDrive, int iPercent, BOOL fNukeOnDelete);
STDAPI_(BOOL) MakeBitBucket(int idDrive);
STDAPI_(DWORD) PurgeBBFiles(int idDrive);
STDAPI_(BOOL) PersistGlobalSettings(BOOL fUseGlobalSettings, BOOL fNukeOnDelete, int iPercent);
STDAPI_(BOOL) RefreshAllBBDriveSettings();
STDAPI_(BOOL) RefreshBBDriveSettings(int idDrive);
STDAPI_(void) CheckCompactAndPurge();
STDAPI        BBPurgeAll(HWND hwndOwner, DWORD dwFlags);
STDAPI_(BOOL) BBDeleteFileInit(LPTSTR pszFile, INT* piRet);
STDAPI_(BOOL) BBDeleteFile(LPTSTR pszFile, INT* piRet, LPUNDOATOM lpua, BOOL fIsDir, HDPA *phdpaDeletedFiles, ULARGE_INTEGER ulSize);
STDAPI_(BOOL) BBFinishDelete(HDPA hdpaDeletedFiles);
STDAPI_(BOOL) IsFileInBitBucket(LPCTSTR pszPath);
STDAPI_(void) UndoBBFileDelete(LPCTSTR pszOriginal, LPCTSTR pszDelFile);
STDAPI_(BOOL) BBWillRecycle(LPCTSTR pszFile, INT* piRet);
STDAPI_(void) BBCheckRestoredFiles(LPCTSTR pszSrc);
STDAPI_(BOOL) BBCheckDeleteFileSize(int idDrive, ULARGE_INTEGER ulSize);
STDAPI_(BOOL) IsFileDeletable(LPCTSTR pszFile);
STDAPI_(BOOL) IsDirectoryDeletable(LPCTSTR pszDir);
STDAPI_(int)  BBRecyclePathLength(int idDrive);


STDAPI_(BOOL) IsRecycleBinEmpty();
STDAPI_(void) SHUpdateRecycleBinIcon();
STDAPI_(void) SaveRecycleBinInfo();

STDAPI_(void) SetDateTimeText(HWND hdlg, int id, const FILETIME *pftUTC);

STDAPI_(DWORD) ReadPolicySetting(LPCWSTR pszBaseKey, LPCWSTR pszGroup, LPCWSTR pszRestriction, LPBYTE pbData, DWORD cbData);

#endif // _BITBUCK_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\bookmk.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "fstreex.h"
#include "bookmk.h"


// *** WARNING *** 
//
// Scrap_CreateFromDataObject is a TCHAR export from SHSCRAP.DLL, if you change its calling convention, you
// must modify PFNSCRAPCREATEFROMDATAOBJECT and the wrapper fn. below 
//
// *** WARNING ***
typedef HRESULT (CALLBACK *PFNSCRAPCREATEFROMDATAOBJECT)(LPCTSTR pszPath, IDataObject *pDataObj, BOOL fLink, LPTSTR pszNewFile);


STDAPI Scrap_CreateFromDataObject(LPCTSTR pszPath, IDataObject *pDataObj, BOOL fLink, LPTSTR pszNewFile)
{
    static PFNSCRAPCREATEFROMDATAOBJECT pfn = (PFNSCRAPCREATEFROMDATAOBJECT)-1;

    if (pfn == (PFNSCRAPCREATEFROMDATAOBJECT)-1)
    {
        HINSTANCE hinst = LoadLibrary(TEXT("shscrap.dll"));

        if (hinst)
        {
            pfn = (PFNSCRAPCREATEFROMDATAOBJECT)GetProcAddress(hinst, "Scrap_CreateFromDataObject");
        }
        else
        {
            pfn = NULL;
        }
    }

    if (pfn)
    {
        return pfn(pszPath, pDataObj, fLink, pszNewFile);
    }

    // for failure cases just return E_UNEXPECTED;
    return E_UNEXPECTED;
}


//
// Parameters:
//  pDataObj    -- The data object passed from the drag source.
//  pt          -- Dropped position (in screen coordinate).
//  pdwEffect   -- Pointer to dwEffect variable to be returned to the drag source.
//
STDAPI SHCreateBookMark(HWND hwnd, LPCTSTR pszPath, IDataObject *pDataObj, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres;
    TCHAR szNewFile[MAX_PATH];
    DECLAREWAITCURSOR;

    // We should have only one bit set.
    ASSERT(*pdwEffect==DROPEFFECT_COPY || *pdwEffect==DROPEFFECT_LINK || *pdwEffect==DROPEFFECT_MOVE);

    SetWaitCursor();
    hres = Scrap_CreateFromDataObject(pszPath, pDataObj, *pdwEffect == DROPEFFECT_LINK, szNewFile);
    ResetWaitCursor();

    if (SUCCEEDED(hres)) 
    {
        SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szNewFile, NULL);
        SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szNewFile, NULL);
        PositionFileFromDrop(hwnd, szNewFile, NULL);
    } 
    else 
    {
        *pdwEffect = 0;
    }

    return hres;
}


#define MAX_FORMATS     20

typedef struct
{
    IEnumFORMATETC efmt;
    LONG         cRef;
    UINT         ifmt;
    UINT         cfmt;
    FORMATETC    afmt[1];
} CStdEnumFmt;

// forward
extern const IEnumFORMATETCVtbl c_CStdEnumFmtVtbl;

//===========================================================================
// CStdEnumFmt : Constructor
//===========================================================================
STDAPI SHCreateStdEnumFmtEtc(UINT cfmt, const FORMATETC afmt[], IEnumFORMATETC **ppenumFormatEtc)
{
    CStdEnumFmt * this = (CStdEnumFmt*)LocalAlloc( LPTR, SIZEOF(CStdEnumFmt) + (cfmt-1)*SIZEOF(FORMATETC));
    if (this)
    {
        this->efmt.lpVtbl = &c_CStdEnumFmtVtbl;
        this->cRef = 1;
        this->cfmt = cfmt;
        memcpy(this->afmt, afmt, cfmt * SIZEOF(FORMATETC));
        *ppenumFormatEtc = &this->efmt;
        return S_OK;
    }
    *ppenumFormatEtc = NULL;
    return E_OUTOFMEMORY;
}

STDAPI SHCreateStdEnumFmtEtcEx(UINT cfmt, const FORMATETC afmt[],
                               IDataObject *pdtInner, IEnumFORMATETC **ppenumFormatEtc)
{
    HRESULT hres;
    FORMATETC *pfmt;
    UINT cfmtTotal;

    if (pdtInner)
    {
        IEnumFORMATETC *penum;
        hres = pdtInner->lpVtbl->EnumFormatEtc(pdtInner, DATADIR_GET, &penum);
        if (SUCCEEDED(hres))
        {
            UINT cfmt2, cGot;
            FORMATETC fmte;

            for (cfmt2 = 0; penum->lpVtbl->Next(penum, 1, &fmte, &cGot) == S_OK; cfmt2++) 
            {
                // count up the number of FormatEnum in cfmt2
                SHFree(fmte.ptd);
            }

            penum->lpVtbl->Reset(penum);
            cfmtTotal = cfmt + cfmt2;

            // Allocate the buffer for total
            pfmt = (FORMATETC *)LocalAlloc(LPTR, SIZEOF(FORMATETC) * cfmtTotal);
            if (pfmt)
            {
                UINT i;
                // Get formatetcs from the inner object
                for (i = 0; i < cfmt2; i++) 
                {
                    penum->lpVtbl->Next(penum, 1, &pfmt[i], &cGot);
                    // NOTE!  We do not support inner objects with non-NULL ptd
                    ASSERT(pfmt[i].ptd == NULL);
                    SHFree(pfmt[i].ptd);
                    pfmt[i].ptd = NULL;
                }

                // Copy the rest
                if (cfmt)
                {
#ifdef DEBUG
                    UINT ifmt;
                    for (ifmt = 0; ifmt < cfmt; ifmt++) {
                        // NOTE!  We do not support non-NULL ptd
                        ASSERT(afmt[ifmt].ptd == NULL);
                    }
#endif
                    memcpy(&pfmt[cfmt2], afmt, SIZEOF(FORMATETC) * cfmt);
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }

            penum->lpVtbl->Release(penum);
        }
    }
    else
    {
        hres = E_FAIL;  // ptInner == NULL
    }

    if (FAILED(hres) && hres != E_OUTOFMEMORY)
    {
        //
        // Ignore none fatal error from pdtInner::EnumFormatEtc
        // We'll come here if
        //  1. pdtInner == NULL or
        //  2. pdtInner->EnumFormatEtc failed (except E_OUTOFMEMORY)
        //
        hres = NOERROR;
        pfmt = (FORMATETC *)afmt;       // safe const -> non const cast
        cfmtTotal = cfmt;
    }

    if (SUCCEEDED(hres)) 
    {
        hres = SHCreateStdEnumFmtEtc(cfmtTotal, pfmt, ppenumFormatEtc);
        if (pfmt != afmt)
            LocalFree((HLOCAL)pfmt);
    }

    return hres;
}

STDMETHODIMP CStdEnumFmt_QueryInterface(IEnumFORMATETC *pefmt, REFIID riid, void **ppvObj)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);

    if (IsEqualIID(riid, &IID_IEnumFORMATETC) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = &this->efmt;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    this->cRef++;
    return NOERROR;
}

STDMETHODIMP_(ULONG) CStdEnumFmt_AddRef(IEnumFORMATETC *pefmt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    return ++this->cRef;
}

STDMETHODIMP_(ULONG) CStdEnumFmt_Release(IEnumFORMATETC *pefmt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    this->cRef--;
    if (this->cRef > 0)
        return this->cRef;

    LocalFree((HLOCAL)this);
    return 0;
}

STDMETHODIMP CStdEnumFmt_Next(IEnumFORMATETC *pefmt, ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    UINT cfetch;
    HRESULT hres = S_FALSE;     // assume less numbers

    if (this->ifmt < this->cfmt)
    {
        cfetch = this->cfmt - this->ifmt;
        if (cfetch>=celt) 
        {
            cfetch = celt;
            hres = S_OK;
        }

        memcpy(rgelt, &this->afmt[this->ifmt], cfetch*SIZEOF(FORMATETC));
        this->ifmt += cfetch;
    }
    else
    {
        cfetch = 0;
    }

    if (pceltFethed)
        *pceltFethed = cfetch;

    return hres;
}

STDMETHODIMP CStdEnumFmt_Skip(IEnumFORMATETC *pefmt, ULONG celt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    this->ifmt += celt;
    if (this->ifmt > this->cfmt) {
        this->ifmt = this->cfmt;
        return S_FALSE;
    }
    return S_OK;
}

STDMETHODIMP CStdEnumFmt_Reset(IEnumFORMATETC *pefmt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    this->ifmt = 0;
    return S_OK;
}

STDMETHODIMP CStdEnumFmt_Clone(IEnumFORMATETC *pefmt, IEnumFORMATETC ** ppenum)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    return SHCreateStdEnumFmtEtc(this->cfmt, this->afmt, ppenum);
}

const IEnumFORMATETCVtbl c_CStdEnumFmtVtbl = {
    CStdEnumFmt_QueryInterface, CStdEnumFmt_AddRef, CStdEnumFmt_Release,
    CStdEnumFmt_Next,
    CStdEnumFmt_Skip,
    CStdEnumFmt_Reset,
    CStdEnumFmt_Clone,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\brfcase.h ===
#include <brfcasep.h>

STDAPI CreateBrfStgFromIDList(LPCITEMIDLIST pidl, HWND hwnd, IBriefcaseStg **ppbs);
STDAPI CreateBrfStgFromPath(LPCTSTR pszPath, HWND hwnd, IBriefcaseStg **ppbs);

STDAPI CBrfData_CreateDataObj(LPCITEMIDLIST pidl, UINT cidl, LPCITEMIDLIST *apidl, IDataObject **ppdtobj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\buytasks.h ===
#ifndef __BUYTASKS_H__
#define __BUYTASKS_H__

// used for the shopping tasks.
typedef struct
{
    LPCWSTR szURLKey;
    LPCWSTR szURLPrefix;
    BOOL bUseDefault;   // If there is no szURLKey, do we navigate with URLPrefix anyway?
} SHOP_INFO;

extern const SHOP_INFO c_BuySampleMusic;
extern const SHOP_INFO c_BuyMusic;
extern const SHOP_INFO c_BuySamplePictures;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\bookmk.h ===
#ifndef _BOOKMK_H_
#define _BOOKMK_H_

#include "idlcomm.h"

STDAPI SHCreateStdEnumFmtEtc(UINT cfmt, const FORMATETC afmt[], IEnumFORMATETC **ppenumFormatEtc);
STDAPI SHCreateStdEnumFmtEtcEx(UINT cfmt, const FORMATETC afmt[], IDataObject *pdtInner, IEnumFORMATETC **ppenumFormatEtc);
STDAPI SHCreateBookMark(HWND hwnd, LPCTSTR pszPath, IDataObject *pDataObj, POINTL pt, DWORD *pdwEffect);

#endif // _BOOKMK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cabstate.c ===
/*----------------------------------------------------------------------------
/ Title;
/   cabstate.c => cabinet state i/o
/
/ Purpose:
/   Provides a clean API to fill out the cabinet state from the registry, if the
/   relevent keys cannot be found then we set the relevant defaults.  This is
/   called by the explorer.
/
/ History:
/   23apr96 daviddv New API which passes the structure size in
/   18mar96 daviddv Bug fix; Added colour state to FALSE when state structure not read
/    7feb96 daviddv Tweeked cabinet state writing
/   30jan96 daviddv Created
/
/----------------------------------------------------------------------------*/
#include "shellprv.h"
#include "regstr.h"
#include "cstrings.h"
#pragma hdrstop


TCHAR const c_szCabinetState[] = REGSTR_PATH_EXPLORER TEXT( "\\CabinetState");
TCHAR const c_szSettings[]     = TEXT("Settings");
TCHAR const c_szFullPath[]     = TEXT("FullPath");

/*----------------------------------------------------------------------------
/   Read in the CABINETSTATE structure from the registry and attempt to validate it.
/
/ Notes:
/   -
/
/ In:
/   lpCabinetState => pointer to CABINETSTATE structure to be filled.
/   cLength = size of structure to be filled
/
/ Out:
/   [lpState] filled in with data
/   fReadFromRegistry == indicates if the structure was actually read from the registry
/                        or if we are giviing the client a default one.
/----------------------------------------------------------------------------*/
STDAPI_(BOOL) ReadCabinetState( CABINETSTATE *lpState, int cLength )
{
    DWORD cbData = SIZEOF(CABINETSTATE);
    BOOL fReadFromRegistry = FALSE;
    CABINETSTATE state;
    SHELLSTATE ss;
    DWORD dwType;
    HKEY hKey;

    ASSERT( lpState );

    SHGetSetSettings(&ss, SSF_WIN95CLASSIC, FALSE);

    if ( lpState && cLength )
    {
        BOOL fReadFullPath = FALSE;
        //
        // Setup the default state of the structure and read in the current state
        // from the registry (over our freshly initialised structure).
        //

        state.cLength                   = SIZEOF(CABINETSTATE);
        state.nVersion                  = CABINETSTATE_VERSION;

        state.fSimpleDefault            = TRUE;
        state.fFullPathTitle            = FALSE;
        state.fSaveLocalView            = TRUE;
        state.fNotShell                 = FALSE;
        state.fNewWindowMode            = BOOLIFY(ss.fWin95Classic);
        state.fShowCompColor            = FALSE;
        state.fDontPrettyNames          = FALSE;
        state.fAdminsCreateCommonGroups = TRUE;
        state.fUnusedFlags              = 0;
        state.fMenuEnumFilter           = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;

        if ( !GetSystemMetrics( SM_CLEANBOOT ) &&
             ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, c_szCabinetState, 0L, KEY_QUERY_VALUE, &hKey ) )
        {
            DWORD dwFullPath=0;
            DWORD cbFullPath=SIZEOF(dwFullPath);
            
            fReadFromRegistry = ( ERROR_SUCCESS == SHQueryValueEx( hKey,
                                                                    c_szSettings,
                                                                    NULL,
                                                                    &dwType,
                                                                    (PVOID) &state, &cbData ) );
            
            if (ERROR_SUCCESS == SHQueryValueEx(hKey, c_szFullPath, NULL, NULL, (LPVOID)&dwFullPath, &cbFullPath))
            {
                fReadFullPath = TRUE;
                state.fFullPathTitle = (BOOL)dwFullPath ? TRUE : FALSE;
            }
            
            RegCloseKey( hKey );
        }

        //
        // Fix the structure if it is an early version and write back into the registry
        // to avoid having to do it again.
        //

        if ( fReadFromRegistry && state.nVersion < CABINETSTATE_VERSION )
        {
            // NT4 and IE4x had the same value for state.nVersion (1), and we have to stomp some of the flags
            // depending on whether we are pre-IE4x or not. To differentiate, we see if c_szFullPath was present.
            // This reg key was introduced only in IE40.
            if ( (state.nVersion < 1) || ((state.nVersion == 1) && !fReadFullPath) )
            {
                state.fNewWindowMode            = BOOLIFY(ss.fWin95Classic);
                state.fAdminsCreateCommonGroups = TRUE;              // Moved post BETA 2 SUR!
                state.fUnusedFlags              = 0;
                state.fMenuEnumFilter           = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
            }

            state.cLength = SIZEOF(CABINETSTATE);
            state.nVersion = CABINETSTATE_VERSION;

            WriteCabinetState( &state );
        }

        //
        // Copy only the requested data back to the caller.
        //

        state.cLength = (int) min( SIZEOF(CABINETSTATE), cLength );
        memcpy( lpState, &state, cLength );
    }

    return fReadFromRegistry;
}

// old export
STDAPI_(BOOL) OldReadCabinetState( LPCABINETSTATE lpState, int cLength )
{
   return ReadCabinetState(lpState, sizeof(CABINETSTATE));
}



/*----------------------------------------------------------------------------
/   Writes a CABINETSTATE structure back into the registry.
/
/ Notes:
/   Attempt to do the right thing when given a small structure to write
/   back so that we don't mess up the users settings.
/
/ In:
/   lpState -> structure to be written
/
/ Out:
/    fSuccess = TRUE / FALSE indicating if state has been seralised
/----------------------------------------------------------------------------*/
STDAPI_(BOOL) WriteCabinetState(CABINETSTATE *lpState)
{
    BOOL fSuccess = FALSE;
    if (lpState)
    {
        CABINETSTATE state;
        HKEY hKey;

        // Check to see if the structure is the right size, if its too small
        // then we must merge it with a real one before writing back!
        if (lpState->cLength < SIZEOF(CABINETSTATE))
        {
            ReadCabinetState(&state, SIZEOF(state));

            memcpy(&state, lpState, lpState->cLength);
            state.cLength = SIZEOF(CABINETSTATE);
            lpState = &state;
        }

        if ( ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_szCabinetState, 0, NULL, 0, KEY_SET_VALUE, NULL, &hKey, NULL) )
        {
            DWORD dwFullPath = lpState->fFullPathTitle ? TRUE : FALSE;

            fSuccess = ERROR_SUCCESS == RegSetValueEx( hKey,
                                                       c_szSettings,
                                                       0,
                                                       REG_BINARY,
                                                       (LPVOID)lpState, (DWORD)SIZEOF(CABINETSTATE) );

            // NOTE: We have to continue writing this key. One of the uses for it is to decide
            // whether we are pre-IE4 or not. See ReadCabinetState()...
            RegSetValueEx(hKey, c_szFullPath, 0, REG_DWORD, (LPVOID)&dwFullPath, sizeof(dwFullPath));
            RegCloseKey( hKey );
        }
    }

    if (fSuccess) 
    {
        // Notify anybody who is listening
        HANDLE hChange = SHGlobalCounterCreate(&GUID_FolderSettingsChange);
        SHGlobalCounterIncrement(hChange);
        SHGlobalCounterDestroy(hChange);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\browse.cpp ===
#include "shellprv.h"

#include "ids.h"
#include "findhlp.h"
#include "shitemid.h"
#include "findfilter.h"
#include <inetreg.h>
#include <help.h>

class CBrowseForFolder;


// Structure to pass information to browse for folder dialog

typedef struct
{
    HWND          hwndOwner;
    LPCITEMIDLIST pidlRoot;      // Root of search.  Typically desktop or my net
    LPTSTR        pszDisplayName;// Return display name of item selected.
    int           *piImage;      // where to return the Image index.
    LPCTSTR       lpszTitle;      // resource (or text to go in the banner over the tree.
    UINT          ulFlags;       // Flags that control the return stuff
    BFFCALLBACK   lpfn;
    LPARAM        lParam;
    HWND          hwndDlg;       // The window handle to the dialog
    HWND          hwndTree;      // The tree control.
    HWND          hwndEdit;
    HTREEITEM     htiCurParent;  // tree item associated with Current shell folder
    IShellFolder  *psfParent;    // Cache of the last IShell folder I needed...
    LPITEMIDLIST  pidlCurrent;   // IDlist of current folder to select
    BOOL          fShowAllObjects; // Should we Show all ?
    BOOL          fUnicode;     // 1:unicode entry pt  0:ansi
} BFSF;


LPITEMIDLIST SHBrowseForFolder2(BFSF * pbfsf);
BOOL_PTR CALLBACK _BrowseDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
LPITEMIDLIST _BFSFUpdateISHCache(BFSF *pbfsf, HTREEITEM hti, LPITEMIDLIST pidlItem);

// We want to use SHBrowseForFolder2 if either:
// 1. pbfsf->lpfn == NULL since the caller wont' customize the dialog, or
// 2. pbfsf->ulFlags
BOOL ShouldUseBrowseForFolder2(BFSF *pbfsf)
{
//    FEATURE:  Enable the following code after we have it working with all the backward compat cases.
//    return (!pbfsf->lpfn || (BIF_NEWDIALOGSTYLE == pbfsf->ulFlags));
    return (BIF_NEWDIALOGSTYLE & pbfsf->ulFlags);
}

STDAPI_(LPITEMIDLIST) SHBrowseForFolder(BROWSEINFO *pbi)
{
    HRESULT hrOle = SHCoInitialize();   // Init OLE for AutoComplete

    // NB: The ANSI Thunk (see below) does not call through this routine,
    // but rather called DialogBoxParam on its own.  If you change this
    // routine, change the A version as well!!
    BFSF bfsf = {
      pbi->hwndOwner,
      pbi->pidlRoot,
      pbi->pszDisplayName,
      &pbi->iImage,
      pbi->lpszTitle,
      pbi->ulFlags,
      pbi->lpfn,
      pbi->lParam,
    };
    HCURSOR hcOld = SetCursor(LoadCursor(NULL,IDC_WAIT));
    SHELLSTATE ss;

    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
    bfsf.fShowAllObjects = BOOLIFY(ss.fShowAllObjects);
    bfsf.fUnicode = 1;

    LPITEMIDLIST pidlRet = NULL;

    if (ShouldUseBrowseForFolder2(&bfsf))
    {
        pidlRet = SHBrowseForFolder2(&bfsf);  // Continue even if OLE wasn't initialized.
    }
    else if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_BROWSEFORFOLDER),
                            pbi->hwndOwner, _BrowseDlgProc, (LPARAM)&bfsf))
    {
        pidlRet = bfsf.pidlCurrent;
    }

    if (pidlRet && !(pbi->ulFlags & BIF_NOTRANSLATETARGETS))
    {
        LPITEMIDLIST pidlTarget;
        if (SUCCEEDED(SHGetTargetFolderIDList(pidlRet, &pidlTarget)))
        {
            ILFree(pidlRet);
            pidlRet = pidlTarget;
        }
    }

    if (hcOld)
        SetCursor(hcOld);

    SHCoUninitialize(hrOle);
    return pidlRet;
}

STDAPI_(LPITEMIDLIST) SHBrowseForFolderA(BROWSEINFOA *pbi)
{
    LPITEMIDLIST pidlRet = NULL;
    HRESULT hrOle = SHCoInitialize();   // Init OLE for AutoComplete
    ThunkText *pThunkText = ConvertStrings(1, pbi->lpszTitle);
    if (pThunkText)
    {
        WCHAR wszReturn[MAX_PATH];
        BFSF bfsf =
        {
            pbi->hwndOwner,
            pbi->pidlRoot,
            wszReturn,
            &pbi->iImage,
            pThunkText->m_pStr[0],   // UNICODE copy of pbi->lpszTitle
            pbi->ulFlags,
            pbi->lpfn,
            pbi->lParam,
        };
        HCURSOR hcOld = SetCursor(LoadCursor(NULL,IDC_WAIT));
        SHELLSTATE ss;

        SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
        bfsf.fShowAllObjects = BOOLIFY(ss.fShowAllObjects);
        bfsf.fUnicode = 0;

        // Now Create the dialog that will be doing the browsing.
        if (ShouldUseBrowseForFolder2(&bfsf))
        {
            pidlRet = SHBrowseForFolder2(&bfsf);
        }
        else if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_BROWSEFORFOLDER),
                                pbi->hwndOwner, _BrowseDlgProc, (LPARAM)&bfsf))
        {
            pidlRet = bfsf.pidlCurrent;
        }

        LocalFree(pThunkText);

        if (hcOld)
            SetCursor(hcOld);

        if (pidlRet)
        {
            if (pbi->pszDisplayName)
            {
                SHUnicodeToAnsi(wszReturn, pbi->pszDisplayName, MAX_PATH);
            }

            if (!(pbi->ulFlags & BIF_NOTRANSLATETARGETS))
            {
                LPITEMIDLIST pidlTarget;
                if (SUCCEEDED(SHGetTargetFolderIDList(pidlRet, &pidlTarget)))
                {
                    ILFree(pidlRet);
                    pidlRet = pidlTarget;
                }
            }
        }
    }

    SHCoUninitialize(hrOle);
    return pidlRet;
}

int BFSFCallback(BFSF *pbfsf, UINT uMsg, LPARAM lParam)
{
    return pbfsf->lpfn ? pbfsf->lpfn(pbfsf->hwndDlg, uMsg, lParam, pbfsf->lParam) : 0;
}

HTREEITEM _BFSFAddItemToTree(HWND hwndTree, HTREEITEM htiParent, LPITEMIDLIST pidl, int cChildren)
{
    TV_INSERTSTRUCT tii;

    // Initialize item to add with callback for everything
    tii.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE |
            TVIF_PARAM | TVIF_CHILDREN;
    tii.hParent = htiParent;
    tii.hInsertAfter = TVI_FIRST;
    tii.item.iImage = I_IMAGECALLBACK;
    tii.item.iSelectedImage = I_IMAGECALLBACK;
    tii.item.pszText = LPSTR_TEXTCALLBACK;   //
    tii.item.cChildren = cChildren; //  Assume it has children
    tii.item.lParam = (LPARAM)pidl;
    return TreeView_InsertItem(hwndTree, &tii);
}

LPITEMIDLIST _BFSFGetIDListFromTreeItem(HWND hwndTree, HTREEITEM hti)
{
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlT;
    TV_ITEM tvi;

    // If no hti passed in, get the selected on.
    if (hti == NULL)
    {
        hti = TreeView_GetSelection(hwndTree);
        if (hti == NULL)
            return(NULL);
    }

    // now lets get the information about the item
    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
    tvi.hItem = hti;
    if (!TreeView_GetItem(hwndTree, &tvi))
        return(NULL);   // Failed again

    pidl = ILClone((LPITEMIDLIST)tvi.lParam);

    // Now walk up parents.
    while ((NULL != (tvi.hItem = TreeView_GetParent(hwndTree, tvi.hItem))) && pidl)
    {
        if (!TreeView_GetItem(hwndTree, &tvi))
            return(pidl);   // will assume I messed up...
        pidlT = ILCombine((LPITEMIDLIST)tvi.lParam, pidl);

        ILFree(pidl);

        pidl = pidlT;

    }
    return pidl;
}


int CALLBACK _BFSFTreeCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    IShellFolder *psfParent = (IShellFolder *)lParamSort;
    HRESULT hr = psfParent->CompareIDs(0, (LPITEMIDLIST)lParam1, (LPITEMIDLIST)lParam2);
    if (FAILED(hr))
        return 0;
    
    return (short)SCODE_CODE(GetScode(hr));
}

void _BFSFSort(BFSF *pbfsf, HTREEITEM hti, IShellFolder *psf)
{
    TV_SORTCB sSortCB;
    sSortCB.hParent = hti;
    sSortCB.lpfnCompare = _BFSFTreeCompare;

    psf->AddRef();
    sSortCB.lParam = (LPARAM)psf;
    TreeView_SortChildrenCB(pbfsf->hwndTree, &sSortCB, FALSE);
    psf->Release();
}

BOOL _BFSFHandleItemExpanding(BFSF *pbfsf, LPNM_TREEVIEW lpnmtv)
{
    LPITEMIDLIST pidlToExpand;
    LPITEMIDLIST pidl;
    IShellFolder *psf;
    BYTE bType;
    DWORD grfFlags;
    BOOL fPrinterTest = FALSE;
    int cAdded = 0;
    TV_ITEM tvi;

    if (lpnmtv->action != TVE_EXPAND)
        return FALSE;

    if ((lpnmtv->itemNew.state & TVIS_EXPANDEDONCE))
        return FALSE;

    // set this bit now because we might be reentered via the wnet apis
    tvi.mask = TVIF_STATE;
    tvi.hItem = lpnmtv->itemNew.hItem;
    tvi.state = TVIS_EXPANDEDONCE;
    tvi.stateMask = TVIS_EXPANDEDONCE;
    TreeView_SetItem(pbfsf->hwndTree, &tvi);


    if (lpnmtv->itemNew.hItem == NULL)
    {
        lpnmtv->itemNew.hItem = TreeView_GetSelection(pbfsf->hwndTree);
        if (lpnmtv->itemNew.hItem == NULL)
            return FALSE;
    }

    pidlToExpand = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree, lpnmtv->itemNew.hItem);

    if (pidlToExpand == NULL)
        return FALSE;

    // Now lets get the IShellFolder and iterator for this object
    // special case to handle if the Pidl is the desktop
    // This is rather gross, but the desktop appears to be simply a pidl
    // of length 0 and ILIsEqual will not work...
    if (FAILED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlToExpand, &psf))))
    {
        ILFree(pidlToExpand);
        return FALSE; // Could not get IShellFolder.
    }


    // Need to do a couple of special cases here to allow us to
    // browse for a network printer.  In this case if we are at server
    // level we then need to change what we search for non folders when
    // we are the level of a server.
    if (pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
    {
        grfFlags = SHCONTF_FOLDERS | SHCONTF_NETPRINTERSRCH | SHCONTF_NONFOLDERS;
        pidl = ILFindLastID(pidlToExpand);
        bType = SIL_GetType(pidl);
        fPrinterTest = ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
    }
    else if (pbfsf->ulFlags & BIF_BROWSEINCLUDEFILES)
        grfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
    else
        grfFlags = SHCONTF_FOLDERS;

    if (pbfsf->fShowAllObjects)
        grfFlags |= SHCONTF_INCLUDEHIDDEN;

    IEnumIDList *penum;
    if (S_OK != psf->EnumObjects(pbfsf->hwndDlg, grfFlags, &penum))
    {
        psf->Release();
        ILFree(pidlToExpand);
        return FALSE;
    }
    // psf->AddRef();

    while (S_OK == penum->Next(1, &pidl, NULL))
    {
        int cChildren = I_CHILDRENCALLBACK;  // Do call back for children
        //
        // We need to special case here in the netcase where we onlyu
        // browse down to workgroups...
        //
        //
        // Here is where I also need to special case to not go below
        // workgroups when the appropriate option is set.
        //
        bType = SIL_GetType(pidl);
        if ((pbfsf->ulFlags & BIF_DONTGOBELOWDOMAIN) && (bType & SHID_NET))
        {
            switch (bType & (SHID_NET | SHID_INGROUPMASK))
            {
            case SHID_NET_SERVER:
                ILFree(pidl);       // Dont want to add this one
                continue;           // Try the next one
            case SHID_NET_DOMAIN:
                cChildren = 0;      // Force to not have children;
            }
        }
        else if ((pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) && (bType & SHID_NET))
        {
            if ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER)
                cChildren = 0;  // Don't expand below it...
        }
        else if (pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
        {
            // Special case when we are only allowing printers.
            // for now I will simply key on the fact that it is non-FS.
            ULONG ulAttr = SFGAO_FILESYSANCESTOR;

            psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &ulAttr);

            if ((ulAttr & SFGAO_FILESYSANCESTOR) == 0)
            {
                cChildren = 0;      // Force to not have children;
            }
            else if (fPrinterTest)
            {
                ILFree(pidl);       // We are down to server level so don't add other things here
                continue;           // Try the next one
            }
        }
        else if (pbfsf->ulFlags & BIF_BROWSEINCLUDEFILES)
        {
            // Lets not use the callback to see if this item has children or not
            // as some or files (no children) and it is not worth writing our own
            // enumerator as we don't want the + to depend on if there are sub-folders
            // but instead it should be if it has files...
            ULONG ulAttr = SFGAO_FOLDER;

            psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &ulAttr);
            if ((ulAttr & SFGAO_FOLDER)== 0)
                cChildren = 0;      // Force to not have children;
            else
                cChildren = 1;
        }

        if (pbfsf->ulFlags & (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS))
        {
            // If we are only looking for FS level things only add items
            // that are in the name space that are file system objects or
            // ancestors of file system objects
            ULONG ulAttr = SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM;

            psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &ulAttr);

            if ((ulAttr & (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM))== 0)
            {
                ILFree(pidl);       // We are down to server level so don't add other things here
                continue;           // Try the next one
            }
        }

        _BFSFAddItemToTree(pbfsf->hwndTree, lpnmtv->itemNew.hItem,
                pidl, cChildren);
        cAdded++;
    }

    // Now Cleanup after ourself
    penum->Release();

    _BFSFSort(pbfsf, lpnmtv->itemNew.hItem, psf);
    psf->Release();
    ILFree(pidlToExpand);

    // If we did not add anything we should update this item to let
    // the user know something happened.
    //
    if (cAdded == 0)
    {
        TV_ITEM tvi;
        tvi.mask = TVIF_CHILDREN | TVIF_HANDLE;   // only change the number of children
        tvi.hItem = lpnmtv->itemNew.hItem;
        tvi.cChildren = 0;

        TreeView_SetItem(pbfsf->hwndTree, &tvi);

    }

    return TRUE;
}

void _BFSFHandleDeleteItem(BFSF *pbfsf, LPNM_TREEVIEW lpnmtv)
{
    // We need to free the IDLists that we allocated previously
    if (lpnmtv->itemOld.lParam != 0)
        ILFree((LPITEMIDLIST)lpnmtv->itemOld.lParam);
}

LPITEMIDLIST _BFSFUpdateISHCache(BFSF *pbfsf, HTREEITEM hti, LPITEMIDLIST pidlItem)
{
    HTREEITEM htiParent;

    if ((pidlItem == NULL) || (pbfsf == NULL))
        return NULL;

    // Need to handle the root case here!
    htiParent = TreeView_GetParent(pbfsf->hwndTree, hti);
    if ((htiParent != pbfsf->htiCurParent) || (pbfsf->psfParent == NULL))
    {
        LPITEMIDLIST pidl;
        IShellFolder *psfDesktop;

        if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
        {
            if (pbfsf->psfParent)
            {
                if (pbfsf->psfParent != psfDesktop)
                    pbfsf->psfParent->Release();
                pbfsf->psfParent = NULL;
            }

            if (htiParent)
            {
                pidl = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree, htiParent);
            }
            else
            {
                //
                // If No Parent then the item here is one of our roots which
                // should be fully qualified.  So try to get the parent by
                // decomposing the ID.
                //
                LPITEMIDLIST pidlT = (LPITEMIDLIST)ILFindLastID(pidlItem);
                if (pidlT != pidlItem)
                {
                    pidl = ILClone(pidlItem);
                    ILRemoveLastID(pidl);
                    pidlItem = pidlT;
                }
                else
                    pidl = NULL;
            }

            pbfsf->htiCurParent = htiParent;

            // If still NULL then we use root of evil...
            SHBindToObject(psfDesktop, IID_X_PPV_ARG(IShellFolder, pidl, &pbfsf->psfParent));
            ILFree(pidl);
            if (pbfsf->psfParent == NULL)
                return NULL;

            psfDesktop->Release();
        }
    }
    return ILFindLastID(pidlItem);
}

void _BFSFGetDisplayInfo(BFSF *pbfsf, TV_DISPINFO *lpnm)
{
    LPITEMIDLIST pidlItem = (LPITEMIDLIST)lpnm->item.lParam;

    if ((lpnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN)) == 0)
        return; // nothing for us to do here.

    pidlItem = _BFSFUpdateISHCache(pbfsf, lpnm->item.hItem, pidlItem);

    if (pidlItem && pbfsf->psfParent)
    {
        TV_ITEM ti;
        ti.mask = 0;
        ti.hItem = (HTREEITEM)lpnm->item.hItem;

        // They are asking for IconIndex.  See if we can find it now.
        // Once found update their list, such that they wont call us back for
        // it again.
        if (lpnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE))
        {
            // We now need to map the item into the right image index.
            ti.iImage = lpnm->item.iImage = SHMapPIDLToSystemImageListIndex(
                    pbfsf->psfParent, pidlItem, &ti.iSelectedImage);
            // we should save it back away to
            lpnm->item.iSelectedImage = ti.iSelectedImage;
            ti.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        }
        // Also see if this guy has any child folders
        if (lpnm->item.mask & TVIF_CHILDREN)
        {
            ULONG ulAttrs = SFGAO_HASSUBFOLDER;
            pbfsf->psfParent->GetAttributesOf(1, (LPCITEMIDLIST *) &pidlItem, &ulAttrs);

            ti.cChildren = lpnm->item.cChildren =
                    (ulAttrs & SFGAO_HASSUBFOLDER)? 1 : 0;

            ti.mask |= TVIF_CHILDREN;

        }

        if (lpnm->item.mask & TVIF_TEXT)
        {
            if (SUCCEEDED(DisplayNameOf(pbfsf->psfParent, pidlItem, SHGDN_INFOLDER, lpnm->item.pszText, lpnm->item.cchTextMax)))
            {
                ti.mask |= TVIF_TEXT;
                ti.pszText = lpnm->item.pszText;
            }
            else
            {
                AssertMsg(0, TEXT("The folder %08x that owns pidl %08x rejected it!"),
                          pbfsf, pidlItem);
                // Oh well - display a blank name and hope for the best.
            }
        }

        // Update the item now
        ti.mask |= TVIF_DI_SETITEM;
    }
}

void DlgEnableOk(HWND hwndDlg, LPARAM lParam)
{
    EnableWindow(GetDlgItem(hwndDlg, IDOK), BOOLFROMPTR(lParam));
    return;
}

void _BFSFHandleSelChanged(BFSF *pbfsf, LPNM_TREEVIEW lpnmtv)
{
    LPITEMIDLIST pidl;

    // We only need to do anything if we only want to return File system
    // level objects.
    if ((pbfsf->ulFlags & (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_BROWSEFORPRINTER | BIF_BROWSEFORCOMPUTER)) == 0)
        goto NotifySelChange;

    // We need to get the attributes of this object...
    pidl = _BFSFUpdateISHCache(pbfsf, lpnmtv->itemNew.hItem,
            (LPITEMIDLIST)lpnmtv->itemNew.lParam);

    if (pidl && pbfsf->psfParent)
    {
        BOOL fEnable = TRUE;

        BYTE bType = SIL_GetType(pidl);
        if ((pbfsf->ulFlags & (BIF_RETURNFSANCESTORS|BIF_RETURNONLYFSDIRS)) != 0)
        {

        int i;
        // if this is the root pidl, then do a get attribs on 0
        // so that we'll get the attributes on the root, rather than
        // random returned values returned by FSFolder
        if (ILIsEmpty(pidl)) 
            i = 0;
        else
            i = 1;

        ULONG ulAttrs = SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR;

        pbfsf->psfParent->GetAttributesOf(i, (LPCITEMIDLIST *) &pidl, &ulAttrs);

            fEnable = (((ulAttrs & SFGAO_FILESYSTEM) && (pbfsf->ulFlags & BIF_RETURNONLYFSDIRS)) ||
                ((ulAttrs & SFGAO_FILESYSANCESTOR) && (pbfsf->ulFlags & BIF_RETURNFSANCESTORS))) ||
                    ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
        }
        else if ((pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) != 0)
            fEnable = ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
        else if ((pbfsf->ulFlags & BIF_BROWSEFORPRINTER) != 0)
        {
            // Printers are of type Share and usage Print...
            fEnable = ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SHARE);
        }

        DlgEnableOk(pbfsf->hwndDlg, fEnable);

    }

NotifySelChange:

    if (pbfsf->ulFlags & BIF_EDITBOX)
    {
        TCHAR szText[MAX_PATH];        // update the edit box
        TVITEM tvi;

        szText[0] = 0;
        tvi.mask = TVIF_TEXT;
        tvi.hItem = lpnmtv->itemNew.hItem;
        tvi.pszText = szText;
        tvi.cchTextMax = ARRAYSIZE(szText);
        TreeView_GetItem(pbfsf->hwndTree, &tvi);
        SetWindowText(pbfsf->hwndEdit, szText);
    }

    if (pbfsf->lpfn)
    {
        pidl = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree, lpnmtv->itemNew.hItem);
        if (pidl)
        {
            BFSFCallback(pbfsf, BFFM_SELCHANGED, (LPARAM)pidl);
            ILFree(pidl);
        }
    }
}

BOOL BrowseSelectPidl(BFSF *pbfsf, LPCITEMIDLIST pidl)
{
    HTREEITEM htiParent;
    LPITEMIDLIST pidlTemp;
    LPITEMIDLIST pidlNext = NULL;
    LPITEMIDLIST pidlParent = NULL;
    BOOL fRet = FALSE;

    htiParent = TreeView_GetChild(pbfsf->hwndTree, NULL);
    if (htiParent) 
    {
        // step through each item of the pidl
        for (;;) 
        {
            TreeView_Expand(pbfsf->hwndTree, htiParent, TVE_EXPAND);
            pidlParent = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree, htiParent);
            if (!pidlParent)
                break;

            pidlNext = ILClone(pidl);
            if (!pidlNext)
                break;

            pidlTemp = ILFindChild(pidlParent, pidlNext);
            if (!pidlTemp)
                break;

            if (ILIsEmpty(pidlTemp)) 
            {
                // found it!
                TreeView_SelectItem(pbfsf->hwndTree, htiParent);
                fRet = TRUE;
                break;
            } 
            else 
            {
                // loop to find the next item
                HTREEITEM htiChild;

                pidlTemp = ILGetNext(pidlTemp);
                if (!pidlTemp)
                    break;
                else
                    pidlTemp->mkid.cb = 0;


                htiChild = TreeView_GetChild(pbfsf->hwndTree, htiParent);
                while (htiChild) 
                {
                    BOOL fEqual;
                    pidlTemp = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree, htiChild);
                    if (!pidlTemp) 
                    {
                        htiChild = NULL;
                        break;
                    }
                    fEqual = ILIsEqual(pidlTemp, pidlNext);

                    ILFree(pidlTemp);
                    if (fEqual) 
                    {
                        break;
                    }
                    else 
                    {
                        htiChild = TreeView_GetNextSibling(pbfsf->hwndTree, htiChild);
                    }
                }

                if (!htiChild) 
                {
                    // we didn't find the next one... bail
                    break;
                }
                else 
                {
                    // the found child becomes the next parent
                    htiParent = htiChild;
                    ILFree(pidlParent);
                    ILFree(pidlNext);
                }
            }
        }
    }

    if (pidlParent) ILFree(pidlParent);
    if (pidlNext) ILFree(pidlNext);
    return fRet;
}

//===========================================================================
// _BrowseForFolderOnBFSFInitDlg - Process the init dialog
//===========================================================================
BOOL _BrowseForFolderOnBFSFInitDlg(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HTREEITEM hti;
    BFSF *pbfsf = (BFSF *)lParam;
    HIMAGELIST himl;
    LPTSTR lpsz;
    TCHAR szTitle[80];    // no title should be bigger than this!
    HWND hwndTree;

    lpsz = ResourceCStrToStr(HINST_THISDLL, pbfsf->lpszTitle);
    SetDlgItemText(hwnd, IDD_BROWSETITLE, lpsz);
    if (lpsz != pbfsf->lpszTitle)
    {
        LocalFree(lpsz);
        lpsz = NULL;
    }

    if(!(IS_WINDOW_RTL_MIRRORED(pbfsf->hwndOwner)))
    {
        SHSetWindowBits(hwnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);
    }
    SetWindowLongPtr(hwnd, DWLP_USER, lParam);
    pbfsf->hwndDlg = hwnd;
    hwndTree = pbfsf->hwndTree = GetDlgItem(hwnd, IDD_FOLDERLIST);

    if (hwndTree)
    {
        UINT swpFlags = SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER
                | SWP_NOACTIVATE;
        RECT rc;
        POINT pt = {0,0};

        GetClientRect(hwndTree, &rc);
        MapWindowPoints(hwndTree, hwnd, (POINT*)&rc, 2);
        pbfsf->hwndEdit = GetDlgItem(hwnd, IDD_BROWSEEDIT);

        if (!(pbfsf->ulFlags & BIF_STATUSTEXT))
        {
            HWND hwndStatus = GetDlgItem(hwnd, IDD_BROWSESTATUS);
            // nuke the status window
            ShowWindow(hwndStatus, SW_HIDE);
            MapWindowPoints(hwndStatus, hwnd, &pt, 1);
            rc.top = pt.y;
            swpFlags =  SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE;
        }

        if (pbfsf->ulFlags & BIF_EDITBOX)
        {
            RECT rcT;
            GetClientRect(pbfsf->hwndEdit, &rcT);
            SetWindowPos(pbfsf->hwndEdit, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
            rc.top += (rcT.bottom - rcT.top) + GetSystemMetrics(SM_CYEDGE) * 4;
            swpFlags =  SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE;
            SHAutoComplete(GetDlgItem(hwnd, IDD_BROWSEEDIT), (SHACF_FILESYSTEM | SHACF_URLALL | SHACF_FILESYS_ONLY));
        }
        else
        {
            DestroyWindow(pbfsf->hwndEdit);
            pbfsf->hwndEdit = NULL;
        }

        Shell_GetImageLists(NULL, &himl);
        TreeView_SetImageList(hwndTree, himl, TVSIL_NORMAL);

        SetWindowLongPtr(hwndTree, GWL_EXSTYLE,
                GetWindowLongPtr(hwndTree, GWL_EXSTYLE) | WS_EX_CLIENTEDGE);

        // Now try to get this window to know to recalc
        SetWindowPos(hwndTree, NULL, rc.left, rc.top,
                     rc.right - rc.left, rc.bottom - rc.top, swpFlags);

    }

    // If they passed in a root, add it, else add the contents of the
    // Root of evil... to the list as ROOT objects.
    if (pbfsf->pidlRoot)
    {
        LPITEMIDLIST pidl;
        if (IS_INTRESOURCE(pbfsf->pidlRoot)) 
        {
            pidl = SHCloneSpecialIDList(NULL, PtrToUlong((void *)pbfsf->pidlRoot), TRUE);
        }
        else 
        {
            pidl = ILClone(pbfsf->pidlRoot);
        }
        // Now lets insert the Root object
        hti = _BFSFAddItemToTree(hwndTree, TVI_ROOT, pidl, 1);
        // Still need to expand below this point. to the starting location
        // That was passed in. But for now expand the first level.
        TreeView_Expand(hwndTree, hti, TVE_EXPAND);
    }
    else
    {
        LPITEMIDLIST pidlDesktop = SHCloneSpecialIDList(NULL, CSIDL_DESKTOP, FALSE);
        HTREEITEM htiRoot = _BFSFAddItemToTree(hwndTree, TVI_ROOT, pidlDesktop, 1);
        BOOL bFoundDrives = FALSE;

        // Expand the first level under the desktop
        TreeView_Expand(hwndTree, htiRoot, TVE_EXPAND);

        // Lets Preexpand the Drives portion....
        hti = TreeView_GetChild(hwndTree, htiRoot);
        while (hti && !bFoundDrives)
        {
            LPITEMIDLIST pidl = _BFSFGetIDListFromTreeItem(hwndTree, hti);
            if (pidl)
            {
                LPITEMIDLIST pidlDrives = SHCloneSpecialIDList(NULL, CSIDL_DRIVES, FALSE);
                if (pidlDrives)
                {
                    bFoundDrives = ILIsEqual(pidl, pidlDrives);
                    if (bFoundDrives)
                    {
                        TreeView_Expand(hwndTree, hti, TVE_EXPAND);
                        TreeView_SelectItem(hwndTree, hti);
                    }
                    ILFree(pidlDrives);
                }
                ILFree(pidl);
            }
            hti = TreeView_GetNextSibling(hwndTree, hti);
        }
    }

    // go to our internal selection changed code to do any window enabling needed
    {
        NM_TREEVIEW nmtv;
        hti = TreeView_GetSelection(hwndTree);
        if (hti) 
        {
            TV_ITEM ti;
            ti.mask = TVIF_PARAM;
            ti.hItem = hti;
            TreeView_GetItem(hwndTree, &ti);
            nmtv.itemNew.hItem = hti;
            nmtv.itemNew.lParam = ti.lParam;

            _BFSFHandleSelChanged(pbfsf, &nmtv);
        }
    }

    if ((pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) != 0)
    {
        LoadString(HINST_THISDLL, IDS_FINDSEARCH_COMPUTER, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hwnd, szTitle);
    }
    else if ((pbfsf->ulFlags & BIF_BROWSEFORPRINTER) != 0)
    {
        LoadString(HINST_THISDLL, IDS_FINDSEARCH_PRINTER, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hwnd, szTitle);
    }

    BFSFCallback(pbfsf, BFFM_INITIALIZED, 0);

    return TRUE;
}


//
// Called when a ANSI app sends BFFM_SETSTATUSTEXT message.
//
void _BFSFSetStatusTextA(BFSF *pbfsf, LPCSTR lpszText)
{
    CHAR szText[100];
    if (IS_INTRESOURCE(lpszText)) 
    {
        LoadStringA(HINST_THISDLL, LOWORD((DWORD_PTR)lpszText), szText, ARRAYSIZE(szText));
        lpszText = szText;
    }

    SetDlgItemTextA(pbfsf->hwndDlg, IDD_BROWSESTATUS, lpszText);
}

// UNICODE BFFM_SETSTATUSTEXT message.

void _BFSFSetStatusTextW(BFSF *pbfsf, LPCWSTR lpszText)
{
    WCHAR szText[100];
    if (IS_INTRESOURCE(lpszText)) 
    {
        LoadStringW(HINST_THISDLL, LOWORD((DWORD_PTR)lpszText), szText, ARRAYSIZE(szText));
        lpszText = szText;
    }

    SetDlgItemTextW(pbfsf->hwndDlg, IDD_BROWSESTATUS, lpszText);
}

// ANSI BFFM_SETSELECTION message.

BOOL _BFSFSetSelectionA(BFSF *pbfsf, BOOL blParamIsPath, LPARAM lParam)
{
    if (blParamIsPath)
    {
        TCHAR szPath[MAX_PATH];
        SHAnsiToTChar((LPCSTR)lParam, szPath, ARRAYSIZE(szPath));
        lParam = (LPARAM)SHSimpleIDListFromPath(szPath);
        if (!lParam)
            return FALSE;  // Failed pidl creation.
    }

    BOOL fRet = BrowseSelectPidl(pbfsf, (LPITEMIDLIST)lParam);

    if (blParamIsPath)
        ILFree((LPITEMIDLIST)lParam);

    return fRet;
}

// UNICODE BFFM_SETSELECTION message.

BOOL _BFSFSetSelectionW(BFSF *pbfsf, BOOL blParamIsPath, LPARAM lParam)
{
    if (blParamIsPath)
    {
        lParam = (LPARAM)SHSimpleIDListFromPath((LPCTSTR)lParam);
        if (!lParam)
            return FALSE;   // Failed pidl creation.
    }

    BOOL fRet = BrowseSelectPidl(pbfsf, (LPITEMIDLIST)lParam);

    if (blParamIsPath)
        ILFree((LPITEMIDLIST)lParam);

    return fRet;
}

// Called when an app sends BFFM_SETOKTEXT message.
void _BFSFSetOkText(BFSF *pbfsf, LPCTSTR pszText)
{
    LPTSTR psz = ResourceCStrToStr(HINST_THISDLL, pszText);
    SetDlgItemText(pbfsf->hwndDlg, IDOK, psz);
    if (psz != pszText)
        LocalFree(psz);
}

// Process the WM_COMMAND message
void _BrowseOnCommand(BFSF *pbfsf, int id, HWND hwndCtl, UINT codeNotify)
{
    HTREEITEM hti;

    switch (id)
    {
    case IDD_BROWSEEDIT:
        if (codeNotify == EN_CHANGE)
        {
            TCHAR szBuf[4];     // (arb. size, anything > 2)

            szBuf[0] = 1;       // if Get fails ('impossible'), enable OK
            GetDlgItemText(pbfsf->hwndDlg, IDD_BROWSEEDIT, szBuf,
                    ARRAYSIZE(szBuf));
            DlgEnableOk(pbfsf->hwndDlg, (WPARAM)(BOOL)szBuf[0]);
        }
        break;

    case IDOK:
    {
        TV_ITEM tvi;
        TCHAR szText[MAX_PATH];
        BOOL fDone = TRUE;

        // We can now update the structure with the idlist of the item selected
        hti = TreeView_GetSelection(pbfsf->hwndTree);
        pbfsf->pidlCurrent = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree,
                hti);

        tvi.mask = TVIF_TEXT | TVIF_IMAGE;
        tvi.hItem = hti;
        tvi.pszText = pbfsf->pszDisplayName;
        if (!tvi.pszText)
            tvi.pszText = szText;
        tvi.cchTextMax = MAX_PATH;
        TreeView_GetItem(pbfsf->hwndTree, &tvi);

        if (pbfsf->ulFlags & BIF_EDITBOX)
        {
            TCHAR szEditTextRaw[MAX_PATH];
            TCHAR szEditText[MAX_PATH];

            GetWindowText(pbfsf->hwndEdit, szEditTextRaw, ARRAYSIZE(szEditTextRaw));
            SHExpandEnvironmentStrings(szEditTextRaw, szEditText, ARRAYSIZE(szEditText));

            if (lstrcmpi(szEditText, tvi.pszText))
            {
                // the two are different, we need to get the user typed one
                LPITEMIDLIST pidl;
                if (SUCCEEDED(SHParseDisplayName(szEditText, NULL, &pidl, 0, NULL)))
                {
                    ILFree(pbfsf->pidlCurrent);
                    pbfsf->pidlCurrent = pidl;
                    StrCpyNW(tvi.pszText, szEditText, MAX_PATH);
                    tvi.iImage = -1;
                }
                else if (pbfsf->ulFlags & BIF_VALIDATE)
                {
                    LPARAM lParam;
                    char szAnsi[MAX_PATH];

                    ASSERTMSG(pbfsf->lpfn != NULL, "No BrowseCallbackProc supplied with BIF_VALIDATE flag");
                    // n.b. we free everything up, not callback (fewer bugs...)
                    ILFree(pbfsf->pidlCurrent);
                    pbfsf->pidlCurrent = NULL;
                    tvi.pszText[0] = 0;
                    tvi.iImage = -1;
                    lParam = (LPARAM)szEditText;
                    if (!pbfsf->fUnicode)
                    {
                        SHUnicodeToAnsi(szEditText, szAnsi, ARRAYSIZE(szAnsi));
                        lParam = (LPARAM)szAnsi;
                    }
                    // 0:EndDialog, 1:continue
                    fDone = BFSFCallback(pbfsf, pbfsf->fUnicode ? BFFM_VALIDATEFAILEDW : BFFM_VALIDATEFAILEDA, lParam) == 0;
                }
                // else old behavior: hand back last-clicked pidl (even
                // though it doesn't match editbox text!)
            }
        }

        if (pbfsf->piImage)
            *pbfsf->piImage = tvi.iImage;
        if (fDone)
            EndDialog(pbfsf->hwndDlg, TRUE);        // To return TRUE.
        break;
    }
    case IDCANCEL:
        EndDialog(pbfsf->hwndDlg, 0);     // to return FALSE from this.
        break;
    }
}

const static DWORD aBrowseHelpIDs[] = {  // Context Help IDs
    IDD_BROWSETITLE,        NO_HELP,
    IDD_BROWSESTATUS,       NO_HELP,
    IDD_FOLDERLABLE,        NO_HELP,
    IDD_BROWSEEDIT,         IDH_DISPLAY_FOLDER,
    IDD_BFF_RESIZE_TAB,     NO_HELP,
    IDD_NEWFOLDER_BUTTON,   IDH_CREATE_NEW_FOLDER,
    IDD_FOLDERLIST,         IDH_BROWSELIST,

    0, 0
};

BOOL_PTR CALLBACK _BrowseDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BFSF *pbfsf = (BFSF *)GetWindowLongPtr(hwndDlg, DWLP_USER);

    switch (msg) 
    {
    HANDLE_MSG(pbfsf, WM_COMMAND, _BrowseOnCommand);

    case WM_INITDIALOG:
        return (BOOL)HANDLE_WM_INITDIALOG(hwndDlg, wParam, lParam, _BrowseForFolderOnBFSFInitDlg);

    case WM_DESTROY:
        if (pbfsf && pbfsf->psfParent)
        {
            IShellFolder *psfDesktop;
            SHGetDesktopFolder(&psfDesktop);
            if (pbfsf->psfParent != psfDesktop)
            {
                pbfsf->psfParent->Release();
                pbfsf->psfParent = NULL;
            }
        }
        break;

    case BFFM_SETSTATUSTEXTA:
        _BFSFSetStatusTextA(pbfsf, (LPCSTR)lParam);
        break;

    case BFFM_SETSTATUSTEXTW:
        _BFSFSetStatusTextW(pbfsf, (LPCWSTR)lParam);
        break;

    case BFFM_SETSELECTIONW:
        return _BFSFSetSelectionW(pbfsf, (BOOL)wParam, lParam);

    case BFFM_SETSELECTIONA:
        return _BFSFSetSelectionA(pbfsf, (BOOL)wParam, lParam);

    case BFFM_ENABLEOK:
        DlgEnableOk(hwndDlg, lParam);
        break;

    case BFFM_SETOKTEXT:
        _BFSFSetOkText(pbfsf, (LPCTSTR)lParam);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case TVN_GETDISPINFOA:
        case TVN_GETDISPINFOW:
            _BFSFGetDisplayInfo(pbfsf, (TV_DISPINFO *)lParam);
            break;

        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            _BFSFHandleItemExpanding(pbfsf, (LPNM_TREEVIEW)lParam);
            break;
        case TVN_ITEMEXPANDEDA:
        case TVN_ITEMEXPANDEDW:
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            break;
        case TVN_DELETEITEMA:
        case TVN_DELETEITEMW:
            _BFSFHandleDeleteItem(pbfsf, (LPNM_TREEVIEW)lParam);
            break;
        case TVN_SELCHANGEDA:
        case TVN_SELCHANGEDW:
            _BFSFHandleSelChanged(pbfsf, (LPNM_TREEVIEW)lParam);
            break;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBrowseHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *) aBrowseHelpIDs);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


// Flags for _OnPidlNavigation()
#define     SHBFFN_NONE                 0x00000000  //
#define     SHBFFN_FIRE_SEL_CHANGE      0x00000001  //
#define     SHBFFN_UPDATE_TREE          0x00000002  //
#define     SHBFFN_STRICT_PARSING       0x00000004  //
#define     SHBFFN_DISPLAY_ERRORS       0x00000008  // If the parse fails, display an error dialog to inform the user.


/***********************************************************************\
    DESCRIPTION:
        The API SHBrowseForFolder will now be able to act differently
    if a callback function isn't provided or the caller specified a flag
    to use the new UI.  We can't rev the old UI because so many 3rd parties
    hack on it that we would break them.  Therefore, we leave the code
    above this point alone and use the code below if and only if we know
    we won't break a 3rd party hacking on our dialog.

  NOTES:
    _pidlSelected/_fEditboxDirty: This is used to keep track of what
        is most up to date, the editbox or the TreeView.
\***********************************************************************/
#define WNDPROP_CBrowseForFolder TEXT("WNDPROP_CBrowseForFolder_THIS")

class CBrowseForFolder : public IFolderFilter
                         , public IFolderFilterSite
{
public:
    LPITEMIDLIST DisplayDialog(BFSF * pbfsf);

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IFolderFilter methods ***
    STDMETHODIMP ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem) {return _ShouldShow(psf, pidlFolder, pidlItem, FALSE);};
    STDMETHODIMP GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags);

    // *** IFolderFilterSite methods ***
    STDMETHODIMP SetFilter(IUnknown* punk);

    CBrowseForFolder(void);
    ~CBrowseForFolder(void);

private:
    // Private Methods
    BOOL_PTR _DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _NameSpaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL _CreateNewFolder(HWND hDlg);
    BOOL _OnCreateNameSpace(HWND hwnd);
    BOOL _OnOK(void);
    void _OnNotify(LPNMHDR pnm);
    BOOL_PTR _OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
    HRESULT _InitAutoComplete(HWND hwndEdit);
    HRESULT _OnInitDialog(HWND hwnd);
    HRESULT _OnInitSize(HWND hwnd);
    HRESULT _OnLoadSize(HWND hwnd);
    HRESULT _OnSaveSize(HWND hwnd);
    HRESULT _OnSizeDialog(HWND hwnd, DWORD dwWidth, DWORD dwHeight);
    HDWP _SizeControls(HWND hwnd, HDWP hdwp, RECT rcTree, int dx, int dy);
    HRESULT _SetDialogSize(HWND hwnd, DWORD dwWidth, DWORD dwHeight);
    BOOL_PTR _OnGetMinMaxInfo(MINMAXINFO * pMinMaxInfo);

    HRESULT _ProcessEditChangeOnOK(BOOL fUpdateTree);
    HRESULT _OnTreeSelectChange(DWORD dwFlags);
    HRESULT _OnSetSelectPathA(LPCSTR pszPath);
    HRESULT _OnSetSelectPathW(LPCWSTR pwzPath);
    HRESULT _OnSetSelectPidl(LPCITEMIDLIST pidl);
    HRESULT _OnSetExpandedPath(LPCTSTR pszPath);
    HRESULT _OnSetExpandedPidl(LPCITEMIDLIST pidl);
    HRESULT _OnPidlNavigation(LPCITEMIDLIST pidl, DWORD dwFlags);
    HRESULT _OfferToPrepPath(OUT LPTSTR szPath, IN DWORD cchSize);

    HRESULT _InitFilter(void);
    HRESULT _DoesMatchFilter(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlChild, BOOL fStrict);
    HRESULT _FilterThisFolder(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlChild);
    BOOL _DoesFilterAllow(LPCITEMIDLIST pidl, BOOL fStrictParsing);
    HRESULT _ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem, BOOL fStrict);

    // Private Member Variables
    LONG                        _cRef;

    INSCTree *                  _pns;
    IWinEventHandler *          _pweh;
    IPersistFolder *            _ppf;      // AutoComplete's interface to set the current working directory for AC.
    LPITEMIDLIST                _pidlSelected;
    BOOL                        _fEditboxDirty; // Is the editbox the last thing the user modified (over the selection tree).
    HWND                        _hwndTv;        // This is the NSC tree.
    HWND                        _hwndBFF;       // This is our NSC host hwnd.
    HWND                        _hDlg;
    BFSF *                      _pbfsf;
    BOOL                        _fPrinterFilter;
    LPITEMIDLIST                _pidlChildFilter; // If non-NULL, we want to filter all children in this filder. (Including grandchildren)
    IFolderFilter *             _pClientFilter; // A client provided filter.

    // Resize Info
    POINT                       _ptLastSize;      // Sizes in Window Coords
    DWORD                       _dwMinWidth;      // Sizes in Client Coords
    DWORD                       _dwMinHeight;     // Sizes in Client Coords
    int                         _cxGrip;
    int                         _cyGrip;

    static BOOL_PTR CALLBACK BrowseForDirDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK NameSpaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

LPITEMIDLIST SHBrowseForFolder2(BFSF * pbfsf)
{
    LPITEMIDLIST pidl = NULL;
    HRESULT hrOle = SHOleInitialize(0);     // The caller may not have inited OLE and we need to CoCreate _pns.
    CBrowseForFolder * pcshbff = new CBrowseForFolder();
    if (pcshbff)
    {
        pidl = pcshbff->DisplayDialog(pbfsf);
        delete pcshbff;
    }

    SHOleUninitialize(hrOle);
    return pidl;
}

CBrowseForFolder::CBrowseForFolder() : _cRef(1)
{
    DllAddRef();
    ASSERT(!_pns);
    ASSERT(!_ppf);
    ASSERT(!_pClientFilter);
}

CBrowseForFolder::~CBrowseForFolder()
{
    ATOMICRELEASE(_pns);
    ATOMICRELEASE(_ppf);
    ATOMICRELEASE(_pweh);
    ATOMICRELEASE(_pClientFilter);

    Pidl_Set(&_pidlSelected, NULL);
    AssertMsg((1 == _cRef), TEXT("CBrowseForFolder isn't a real COM object, but let's make sure people RefCount us like one."));
    _FilterThisFolder(NULL, NULL);

    DllRelease();
}


LPITEMIDLIST CBrowseForFolder::DisplayDialog(BFSF * pbfsf)
{
    _pbfsf = pbfsf;
    HRESULT hr = (HRESULT) DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_BROWSEFORFOLDER2), pbfsf->hwndOwner, BrowseForDirDlgProc, (LPARAM)this);

    return (((S_OK == hr) && _pidlSelected) ? ILClone(_pidlSelected) : NULL);
}


//This WndProc will get the this pointer and call _NameSpaceWndProc() to do all the real work.
// This window proc is for the parent window of the tree control, not the dialog.
LRESULT CALLBACK CBrowseForFolder::NameSpaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{   // GWL_USERDATA
    LRESULT lResult = 0;
    CBrowseForFolder * pThis = (CBrowseForFolder *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_CREATE:
    {
        CREATESTRUCT * pcs = (CREATESTRUCT *) lParam;
        pThis = (CBrowseForFolder *)pcs->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)(void*)(CBrowseForFolder*)pThis);
    }
    break;
    }

    // we get a few messages before we get the WM_INITDIALOG (such as WM_SETFONT)
    // and until we get the WM_INITDIALOG we dont have our pmbci pointer, we just
    // return false
    if (pThis)
        lResult = (LRESULT) pThis->_NameSpaceWndProc(hwnd, uMsg, wParam, lParam);
    else
        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

    return lResult;
}


// Now that NameSpaceWndProc() gave us our this pointer, let's continue.
// This window proc is for the parent window of the tree control, not the dialog.
LRESULT CBrowseForFolder::_NameSpaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;    // 0 means we didn't do anything

    switch (uMsg)
    {
    case WM_CREATE:
        _OnCreateNameSpace(hwnd);
        break;

    case WM_DESTROY:
        IUnknown_SetSite(_pns, NULL);
        break;

    case WM_SETFOCUS:
        SetFocus(_hwndTv);
        break;

    case WM_NOTIFY:
        _OnNotify((LPNMHDR)lParam);
        // Fall Thru...
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_PALETTECHANGED:
        if (_pweh)
            _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, &lResult);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lResult;
}


BOOL_PTR CBrowseForFolder::_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
    case IDOK:
        if (_OnOK())
        {
            EVAL(SUCCEEDED(_OnSaveSize(hDlg)));
            EndDialog(hDlg, (int) S_OK);
            return TRUE;
        }
        break;

    case IDCANCEL:
        EVAL(SUCCEEDED(_OnSaveSize(hDlg)));
        EndDialog(hDlg, (int) S_FALSE);
        return TRUE;
        break;

    case IDD_BROWSEEDIT:
        if (codeNotify == EN_CHANGE)
        {
            TCHAR szBuf[4];     // (arb. size, anything > 2)

            szBuf[0] = 1;       // if Get fails ('impossible'), enable OK
            GetDlgItemText(_hDlg, IDD_BROWSEEDIT, szBuf, ARRAYSIZE(szBuf));
            EnableWindow(GetDlgItem(_hDlg, IDOK), szBuf[0] ? TRUE : FALSE);

            _fEditboxDirty = TRUE;
        }
        break;

    case IDD_NEWFOLDER_BUTTON:
        _CreateNewFolder(hDlg);
        return TRUE;
        break;
    default:
        break;
    }

    return FALSE;
}


// This DlgProc will get the this pointer and call _DlgProc() to do all the real work.
// This window proc is for the dialog.
BOOL_PTR CALLBACK CBrowseForFolder::BrowseForDirDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL_PTR pfResult = FALSE;
    CBrowseForFolder * pThis = (CBrowseForFolder *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pThis = (CBrowseForFolder *)lParam;
        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)(void*)(CBrowseForFolder*)pThis);
        pfResult = TRUE;
        break;
    }

    // we get a few messages before we get the WM_INITDIALOG (such as WM_SETFONT)
    // and until we get the WM_INITDIALOG we dont have our pmbci pointer, we just
    // return false
    if (pThis)
        pfResult = pThis->_DlgProc(hDlg, uMsg, wParam, lParam);

    return pfResult;
}


#define WINDOWSTYLES_EX_BFF    (WS_EX_LEFT | WS_EX_LTRREADING)
#define WINDOWSTYLES_BFF    (WS_CHILD | WS_VISIBLE | WS_TABSTOP)

// Now that BrowseForDirDlgProc() gave us our this pointer, let's continue.
// This window proc is for the dialog.
BOOL_PTR CBrowseForFolder::_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL_PTR pfResult = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EVAL(SUCCEEDED(_OnInitDialog(hDlg)));

        // Give initial focus to the ok button
        pfResult = SetFocus(GetDlgItem(hDlg, IDOK)) == 0;
        // Return FALSE if the ok button got focus.

        break;

    case WM_SIZE:
        EVAL(SUCCEEDED(_OnSizeDialog(hDlg, LOWORD(lParam), HIWORD(lParam))));
        pfResult = FALSE;
        break;

    case WM_GETMINMAXINFO:
        pfResult = _OnGetMinMaxInfo((MINMAXINFO *) lParam);
        break;

    case WM_CLOSE:
        BFSFCallback(_pbfsf, BFFM_IUNKNOWN, (LPARAM)NULL);
        wParam = IDCANCEL;
        // fall through
    case WM_COMMAND:
        pfResult = _OnCommand(hDlg, (int) LOWORD(wParam), (HWND) lParam, (UINT)HIWORD(wParam));
        break;

    // These BFFM_* messages are sent by the callback proc (_pbfsf->lpfn)
    case BFFM_SETSTATUSTEXTA:
        _BFSFSetStatusTextA(_pbfsf, (LPCSTR)lParam);
        break;

    case BFFM_SETSTATUSTEXTW:
        _BFSFSetStatusTextW(_pbfsf, (LPCWSTR)lParam);
        break;

    case BFFM_SETSELECTIONW:
        if ((BOOL)wParam)
        {
            // Is it a path?
            pfResult = SUCCEEDED(_OnSetSelectPathW((LPCWSTR)lParam));
            break;
        }

        // Fall Thru for pidl case
    case BFFM_SETSELECTIONA:
        if ((BOOL)wParam)
        {
            // Is it a path?
            pfResult = SUCCEEDED(_OnSetSelectPathA((LPCSTR)lParam));
            break;
        }

        // We hit the pidl case.
        pfResult = SUCCEEDED(_OnSetSelectPidl((LPCITEMIDLIST)lParam));
        break;

    case BFFM_SETEXPANDED:
        if ((BOOL)wParam)
        {
            // Is it a path?
            pfResult = SUCCEEDED(_OnSetExpandedPath((LPCTSTR)lParam));
            break;
        }

        // We hit the pidl case.
        pfResult = SUCCEEDED(_OnSetExpandedPidl((LPCITEMIDLIST)lParam));
        break;

    case BFFM_ENABLEOK:
        DlgEnableOk(_hDlg, lParam);
        break;

    case BFFM_SETOKTEXT:
        _BFSFSetOkText(_pbfsf, (LPCTSTR)lParam);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            break;

        case TVN_ITEMEXPANDEDA:
        case TVN_ITEMEXPANDEDW:
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            break;

        case TVN_SELCHANGEDA:
        case TVN_SELCHANGEDW:
            _OnTreeSelectChange(SHBFFN_DISPLAY_ERRORS);
            break;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBrowseHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR) aBrowseHelpIDs);
        break;
    }

    return pfResult;
}


HRESULT CBrowseForFolder::_OnInitDialog(HWND hwnd)
{
    RECT rcDlg;
    RECT rcTree;
    WNDCLASS wc = {0};
    LONG lTreeBottom = 0;

    wc.style         = CS_PARENTDC;
    wc.lpfnWndProc   = NameSpaceWndProc;
    wc.hInstance     = HINST_THISDLL;
    wc.lpszClassName = CLASS_NSC;
    SHRegisterClass(&wc);

    _pbfsf->hwndDlg = hwnd;
    _hDlg = hwnd;

    GetWindowRect(GetDlgItem(hwnd, IDD_FOLDERLIST), &rcTree);

    // cannot have both at the same time...
    if ((_pbfsf->ulFlags & (BIF_UAHINT | BIF_EDITBOX)) == (BIF_UAHINT | BIF_EDITBOX))
        _pbfsf->ulFlags &= ~BIF_UAHINT;
    
    if (_pbfsf->ulFlags & BIF_NONEWFOLDERBUTTON)
    {
        EnableWindow(GetDlgItem(hwnd, IDD_NEWFOLDER_BUTTON), FALSE);
        ShowWindow(GetDlgItem(hwnd, IDD_NEWFOLDER_BUTTON), SW_HIDE);
    }

    // Hide the edit box (or hide the UA hint if the edit box is enabled)
    if (!(_pbfsf->ulFlags & BIF_EDITBOX))
    {
        // Hide the edit box
        HWND hwndBrowseEdit = GetDlgItem(hwnd, IDD_BROWSEEDIT);
        HWND hwndBrowseEditLabel = GetDlgItem(hwnd, IDD_FOLDERLABLE);

        EnableWindow(hwndBrowseEdit, FALSE);
        EnableWindow(hwndBrowseEditLabel, FALSE);
        ShowWindow(hwndBrowseEdit, SW_HIDE);
        ShowWindow(hwndBrowseEditLabel, SW_HIDE);

        // Bottom of tree
        RECT rcEdit;
        GetWindowRect(hwndBrowseEdit, &rcEdit);
        lTreeBottom = rcEdit.bottom;
    }

    if (!(_pbfsf->ulFlags & BIF_UAHINT))
    {
        // Hide the UA hint
        HWND hwndBrowseInstruction = GetDlgItem(hwnd, IDD_BROWSEINSTRUCTION);
        EnableWindow(hwndBrowseInstruction, FALSE);
        ShowWindow(hwndBrowseInstruction, SW_HIDE);
    }

    if (!(_pbfsf->ulFlags & (BIF_EDITBOX | BIF_UAHINT)))
    {
        // Neither a UA hint nor an edit box.
        // Increase the size of the tree
        rcTree.bottom = lTreeBottom;
    }

    EnableWindow(GetDlgItem(hwnd, IDD_FOLDERLIST), FALSE);
    ShowWindow(GetDlgItem(hwnd, IDD_FOLDERLIST), SW_HIDE);
    EVAL(MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&rcTree, 2));
    _hwndBFF = CreateWindowEx(WINDOWSTYLES_EX_BFF, CLASS_NSC, NULL, WINDOWSTYLES_BFF, rcTree.left, rcTree.top, RECTWIDTH(rcTree), RECTHEIGHT(rcTree), hwnd, NULL, HINST_THISDLL, (void *)this);
    ASSERT(_hwndBFF);

    // Make sure the NSCTree is the first focusable control after the title static control,
    // so that an accelerator in the title will give focus to the NSCTree.
    SetWindowPos(_hwndBFF, GetDlgItem(hwnd, IDD_FOLDERLIST), 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);

    LPTSTR psz = ResourceCStrToStr(HINST_THISDLL, _pbfsf->lpszTitle);
    if (psz)
    {
        SetWindowText(GetDlgItem(hwnd, IDD_BROWSETITLE), psz);
        if (psz != _pbfsf->lpszTitle)
            LocalFree(psz);
    }

    _InitAutoComplete(GetDlgItem(hwnd, IDD_BROWSEEDIT));
    BFSFCallback(_pbfsf, BFFM_INITIALIZED, 0);
    BFSFCallback(_pbfsf, BFFM_IUNKNOWN, (LPARAM)SAFECAST(this, IFolderFilter *));

    GetClientRect(hwnd, &rcDlg);

    // Get the size of the gripper and position it.
    _cxGrip = GetSystemMetrics(SM_CXVSCROLL);
    _cyGrip = GetSystemMetrics(SM_CYHSCROLL);

    _dwMinWidth = RECTWIDTH(rcDlg);      // Sizes in Client Coords
    _dwMinHeight = RECTHEIGHT(rcDlg);

    GetWindowRect(hwnd, &rcDlg);      // _ptLastSize sizes in Window Coords
    _ptLastSize.x = RECTWIDTH(rcDlg);  // This will force a resize for the first time.
    _ptLastSize.y = RECTHEIGHT(rcDlg);  // This will force a resize for the first time.

    if ((_pbfsf->ulFlags & BIF_BROWSEFORPRINTER) != 0)
    {
        TCHAR szTitle[80];
        LoadString(HINST_THISDLL, IDS_FINDSEARCH_PRINTER, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hwnd, szTitle);
    }

    if (S_OK != _OnLoadSize(hwnd))  // Set the dialog size.
        _OnInitSize(hwnd);

    return S_OK;
}

HRESULT TranslateCloneOrDefault(LPCITEMIDLIST pidl, UINT csidl, LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    if (pidl)
    {
        // map into friendly part of the name space
        hr = SHILAliasTranslate(pidl, ppidl, XLATEALIAS_ALL); 
        if (FAILED(hr))
            hr = SHILClone(pidl, ppidl);
    }
    else
    {
        hr = SHGetFolderLocation(NULL, csidl, NULL, 0, ppidl);
    }
    return hr;
}


BOOL CBrowseForFolder::_OnCreateNameSpace(HWND hwnd)
{
    HRESULT hr = CoCreateInstance(CLSID_NSCTree, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(INSCTree, &_pns));
    if (SUCCEEDED(hr))
    {
        RECT rc;
        DWORD shcontf = SHCONTF_FOLDERS;

        IFolderFilterSite *psffs;
        hr = _pns->QueryInterface(IID_PPV_ARG(IFolderFilterSite, &psffs));
        if (SUCCEEDED(hr))
        {
            hr = psffs->SetFilter(SAFECAST(this, IFolderFilter *));
            psffs->Release();
        }

        _pns->SetNscMode(0);    // 0 == Tree
        _hwndTv = NULL;
        DWORD dwStyle = WS_HSCROLL, dwExStyle = 0;

        // ifdef'd out the following section of code until we can resolve the following problem:
        // A TVS_SINGLEEXPAND tree expands selections even if they are done programatically. This
        // results in My Documents, and any other selections by the client, expanding those nodes.
        if (SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"), 
            TEXT("FriendlyTree"), FALSE, TRUE))
        {
            dwStyle |= TVS_HASBUTTONS | TVS_SINGLEEXPAND | TVS_TRACKSELECT;
            dwExStyle |= TVS_EX_NOSINGLECOLLAPSE;
        }
        else
        {
            dwStyle |= TVS_HASBUTTONS | TVS_HASLINES;
        }

        INSCTree2 *pns2;
        if (dwExStyle && SUCCEEDED(_pns->QueryInterface(IID_PPV_ARG(INSCTree2, &pns2))))
        {
            pns2->CreateTree2(hwnd, dwStyle, dwExStyle, &_hwndTv);
            pns2->Release();
        }
        else
        {
            _pns->CreateTree(hwnd, dwStyle, &_hwndTv);
        }
        _pns->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pweh));

        LPTSTR psz = ResourceCStrToStr(HINST_THISDLL, _pbfsf->lpszTitle);
        if (psz)
        {
            SetWindowText(_hwndTv, psz);
            if (psz != _pbfsf->lpszTitle)
                LocalFree(psz);
        }

        // Turn on the ClientEdge
        SetWindowBits(_hwndTv, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
#define SIZE_ZOOM       1

        // Show the ClientEdge
        GetWindowRect(_hwndTv, &rc);
        MapWindowRect(NULL, GetParent(_hwndTv), &rc);
        InflateRect(&rc, (- SIZE_ZOOM * GetSystemMetrics(SM_CXEDGE)), (- SIZE_ZOOM * GetSystemMetrics(SM_CYEDGE)));
        SetWindowPos(_hwndTv, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER);
        _InitFilter();

        if (_pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
        {
            shcontf |= SHCONTF_NONFOLDERS;
        }

        if (_pbfsf->ulFlags & BIF_BROWSEINCLUDEFILES)
        {
            shcontf |= SHCONTF_NONFOLDERS;
        }

        if (_pbfsf->fShowAllObjects)
        {
            shcontf |= SHCONTF_INCLUDEHIDDEN;
        }

        LPITEMIDLIST pidlRoot;
        TranslateCloneOrDefault(_pbfsf->pidlRoot, CSIDL_DESKTOP, &pidlRoot);

        _pns->Initialize(pidlRoot, shcontf, NSS_DROPTARGET);
        if (!_pbfsf->pidlRoot)
        {
            LPITEMIDLIST pidl;
            if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidl)))
            {
                _pns->SetSelectedItem(pidl, TRUE, FALSE, 0);
                ILFree(pidl);
            }
        }

        ILFree(pidlRoot);

        _pns->ShowWindow(TRUE);
        _OnTreeSelectChange(SHBFFN_UPDATE_TREE | SHBFFN_NONE);
    }

    return TRUE;
}


// returns:
//      TRUE    - close the dialog
//      FALSE   - keep it up

BOOL CBrowseForFolder::_OnOK(void)
{
    HRESULT hr = S_OK;

    if (_pns)
    {
        // We get the <ENTER> event even if it was pressed while in editbox in a rename in
        // the tree.  Is that the case now?
        if (_pns->InLabelEdit())
            return FALSE;   // Yes, so just bail.

        // Was IDD_BROWSEEDIT modified more recently than the selection in the tree?
        if (_fEditboxDirty)
        {
            // No, so _ProcessEditChangeOnOK() will update _pidlSelected with what's in the editbox.
            // SUCCEEDED(hr)->EndDialog, FAILED(hr)->continue

            // NOTE: FALSE means don't update the tree (since the dialog is closing)
            hr = _ProcessEditChangeOnOK(FALSE);
        }
        else
        {
            // The user may have just finished editing the name of a newly created folder
            // and NSC didn't tell use the pidl changes because of the rename. NT #377453.
            // Therefore, we just update the pidl before we leave.
            hr = _OnTreeSelectChange(SHBFFN_NONE);
        }

        if (SUCCEEDED(hr))
        {
            if (_pbfsf->pszDisplayName && _pidlSelected)
            {
                //  the browse struct doesnt contain a buffer
                //  size so we assume MAX_PATH here....
                SHGetNameAndFlags(_pidlSelected, SHGDN_NORMAL, _pbfsf->pszDisplayName, MAX_PATH, NULL);
            }
        }
    }

    return hr == S_OK;
}

#define SIZE_MAX_HEIGHT     1600
#define SIZE_MAX_WIDTH      1200

HRESULT CBrowseForFolder::_OnInitSize(HWND hwnd)
{
    // The user hasn't yet sized the dialog, so we need to generate a good
    // default size.  The goal will be to base the window size on the monitor
    // size with scaling properties.
    //
    // Size Algorithm:
    // a) 1/3 hight of screen - Defined in the resource.
    // b) Never larger than max - Based on a 1600x1200 screen
    // c) Never smaller than min - Defined in the resource.

    DWORD dwWidth;
    DWORD dwHeight;
    HMONITOR hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
    MONITORINFO monInfo = {sizeof(monInfo), 0};

    EVAL(GetMonitorInfo(hmon, &monInfo));

    // a) 1/3 height of screen - Defined in the resource.
    dwHeight = RECTHEIGHT(monInfo.rcWork) / 3;
    dwWidth = (dwHeight * _dwMinHeight) / _dwMinWidth;    // Scale up the width. Make it have the same ratio as _dwMinWidth/_dwMinHeight

    // b) Never larger than max - Based on a 1600x1200 screen
    if (dwWidth > SIZE_MAX_WIDTH)
        dwWidth = SIZE_MAX_WIDTH;
    if (dwHeight > SIZE_MAX_HEIGHT)
        dwHeight = SIZE_MAX_HEIGHT;

    // c) Never smaller than min - Defined in the resource.
    // Set them to the min sizes if they are too small.
    if (dwWidth < _dwMinWidth)
        dwWidth = _dwMinWidth;
    if (dwHeight < _dwMinHeight)
        dwHeight = _dwMinHeight;

    return _SetDialogSize(hwnd, dwWidth, dwHeight);
}


BOOL_PTR CBrowseForFolder::_OnGetMinMaxInfo(MINMAXINFO * pMinMaxInfo)
{
    BOOL_PTR pfResult = 1;

    if (pMinMaxInfo)
    {
        pMinMaxInfo->ptMinTrackSize.x = _dwMinWidth;
        pMinMaxInfo->ptMinTrackSize.y = _dwMinHeight;

        pfResult = 0;   // Indicate it's handled.
    }

    return pfResult;
}


HRESULT CBrowseForFolder::_OnLoadSize(HWND hwnd)
{
    HRESULT hr = S_FALSE;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD cbSize1 = sizeof(dwWidth);
    DWORD cbSize2 = sizeof(dwHeight);

    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("Browse For Folder Width"), NULL, (void *)&dwWidth, &cbSize1)) &&
        (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("Browse For Folder Height"), NULL, (void *)&dwHeight, &cbSize2)))
    {
        HMONITOR hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
        MONITORINFO monInfo = {sizeof(monInfo), 0};
        EVAL(GetMonitorInfo(hmon, &monInfo));

        // Is the saved size within this monitor size?
        if ((dwWidth < (DWORD)RECTWIDTH(monInfo.rcWork)) &&
            (dwHeight < (DWORD)RECTHEIGHT(monInfo.rcWork)))
        {
            // Set them to the min sizes if they are too small.
            if (dwWidth < _dwMinWidth)
                dwWidth = _dwMinWidth;

            if (dwHeight < _dwMinHeight)
                dwHeight = _dwMinHeight;

            hr = _SetDialogSize(hwnd, dwWidth, dwHeight);
        }
    }

    return hr;
}

HRESULT CBrowseForFolder::_OnSaveSize(HWND hwnd)
{
    RECT rc;

    GetClientRect(hwnd, &rc);
    DWORD dwWidth = (rc.right - rc.left);
    DWORD dwHeight = (rc.bottom - rc.top);

    SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("Browse For Folder Width"), REG_DWORD, (void *)&dwWidth, sizeof(dwWidth));
    SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("Browse For Folder Height"), REG_DWORD, (void *)&dwHeight, sizeof(dwHeight));
    return S_OK;
}


HDWP CBrowseForFolder::_SizeControls(HWND hwnd, HDWP hdwp, RECT rcTree, int dx, int dy)
{
    //  Move the controls.
    HWND hwndControl = ::GetWindow(hwnd, GW_CHILD);
    while (hwndControl && hdwp)
    {
        RECT rcControl;

        GetWindowRect(hwndControl, &rcControl);
        MapWindowRect(HWND_DESKTOP, hwnd, &rcControl);

        switch (GetDlgCtrlID(hwndControl))
        {
        case IDD_BROWSETITLE:
            // Increase the width of these controls
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, rcControl.left, rcControl.top, (RECTWIDTH(rcControl) + dx), RECTHEIGHT(rcControl), (SWP_NOZORDER | SWP_NOACTIVATE));
            InvalidateRect(hwndControl, NULL, TRUE);
            break;

        case IDD_FOLDERLABLE:
            // Move these controls down if needed
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, rcControl.left, (rcControl.top + dy), 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE));
            break;

        case IDD_BROWSEEDIT:
            // Increase the width move down if needed
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, rcControl.left, (rcControl.top + dy), (RECTWIDTH(rcControl) + dx), RECTHEIGHT(rcControl), SWP_NOZORDER | SWP_NOACTIVATE);
            break;

        case IDD_BROWSEINSTRUCTION:
            // Increase the width, move down if needed
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, rcControl.left, (rcControl.top + dy), (RECTWIDTH(rcControl) + dx), RECTHEIGHT(rcControl), SWP_NOZORDER | SWP_NOACTIVATE);
            break;

        case IDD_NEWFOLDER_BUTTON:
            // Keep this guy on the left, and move it down if needed.
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, rcControl.left, (rcControl.top + dy), 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE));
            break;

        case IDOK:
        case IDCANCEL:
            // Move these controls to the right, down if needed.
            hdwp = DeferWindowPos(hdwp, hwndControl, NULL, (rcControl.left + dx), (rcControl.top + dy), 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE));
            break;
        }

        hwndControl = ::GetWindow(hwndControl, GW_HWNDNEXT);
    }

    return hdwp;
}


HRESULT CBrowseForFolder::_SetDialogSize(HWND hwnd, DWORD dwWidth, DWORD dwHeight)
{
    HRESULT hr = S_OK;
    RECT rcDlg = {0, 0, dwWidth, dwHeight};

    //  Set the sizing grip to the correct location.
    SetWindowPos(GetDlgItem(hwnd, IDD_BFF_RESIZE_TAB), NULL, (dwWidth - _cxGrip), (dwHeight - _cyGrip), 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE));

    EVAL(AdjustWindowRect(&rcDlg, (DS_MODALFRAME | DS_3DLOOK | WS_POPUP | WS_CAPTION | WS_SYSMENU | DS_CONTEXTHELP | WS_EX_CLIENTEDGE | WS_SIZEBOX), NULL));
    rcDlg.right -= rcDlg.left;  // Adjust for other side.
    rcDlg.bottom -= rcDlg.top;  //

    SetWindowPos(hwnd, NULL, 0, 0, rcDlg.right, rcDlg.bottom, (SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE));
    // We don't need to call _OnSizeDialog() because SetWindowPos() will end up calling WS_SIZE so it will automatically get called.
    return hr;
}


HRESULT CBrowseForFolder::_OnSizeDialog(HWND hwnd, DWORD dwWidth, DWORD dwHeight)
{
    RECT rcNew;      // Sizes in window Coords
    RECT rcTree;      // Sizes in window Coords
    DWORD dwFullWidth;
    DWORD dwFullHeight;

    //  Calculate the deltas in the x and y positions that we need to move
    //  each of the child controls.
    GetWindowRect(hwnd, &rcNew);
    dwFullWidth = RECTWIDTH(rcNew);
    dwFullHeight = RECTHEIGHT(rcNew);

    // If it's smaller than the min, fix it for the rest of the dialog.
    if (dwFullWidth < _dwMinWidth)
        dwFullWidth = _dwMinWidth;
    if (dwFullHeight < _dwMinHeight)
        dwFullHeight = _dwMinHeight;

    int dx = (dwFullWidth - _ptLastSize.x);
    int dy = (dwFullHeight - _ptLastSize.y);

    //  Update the new size.
    _ptLastSize.x = dwFullWidth;
    _ptLastSize.y = dwFullHeight;

    //  Size the view.
    GetWindowRect(_hwndBFF, &rcTree);
    MapWindowRect(HWND_DESKTOP, hwnd, &rcTree);

    // Don't do anything if the size remains the same
    if ((dx != 0) || (dy != 0))
    {
        HDWP hdwp = BeginDeferWindowPos(15);

        //  Set the sizing grip to the correct location.
        SetWindowPos(GetDlgItem(hwnd, IDD_BFF_RESIZE_TAB), NULL, (dwWidth - _cxGrip), (dwHeight - _cyGrip), 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE));

        if (EVAL(hdwp))
        {
            hdwp = DeferWindowPos(hdwp, _hwndBFF, NULL, 0, 0, (RECTWIDTH(rcTree) + dx), (RECTHEIGHT(rcTree) + dy), (SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE));

            if (hdwp)
                hdwp = _SizeControls(hwnd, hdwp, rcTree, dx, dy);

            if (EVAL(hdwp))
                EVAL(EndDeferWindowPos(hdwp));
        }
        SetWindowPos(_hwndTv, NULL, 0, 0, (RECTWIDTH(rcTree) + dx - (SIZE_ZOOM * GetSystemMetrics(SM_CXEDGE))), (RECTHEIGHT(rcTree) + dy - (SIZE_ZOOM * GetSystemMetrics(SM_CYEDGE))), (SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE));
    }

    return S_OK;
}

HRESULT CBrowseForFolder::_OnSetSelectPathA(LPCSTR pszPath)
{
    TCHAR szPath[MAX_PATH];
    SHAnsiToTChar(pszPath, szPath, ARRAYSIZE(szPath));
    return _OnSetSelectPathW(szPath);
}

HRESULT CBrowseForFolder::_OnSetSelectPathW(LPCWSTR pwzPath)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHParseDisplayName(pwzPath, NULL, &pidl, 0, NULL);
    if (SUCCEEDED(hr))
    {
        hr = _OnPidlNavigation(pidl, SHBFFN_UPDATE_TREE);
        ILFree(pidl);
    }
    return hr;
}

HRESULT CBrowseForFolder::_OnSetSelectPidl(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlToFree;
    HRESULT hr = TranslateCloneOrDefault(pidl, CSIDL_PERSONAL, &pidlToFree);
    if (SUCCEEDED(hr))
    {
        hr = _OnPidlNavigation(pidlToFree, SHBFFN_UPDATE_TREE);
        ILFree(pidlToFree);
    }
    return hr;
}

HRESULT CBrowseForFolder::_OnSetExpandedPath(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHParseDisplayName(pszPath, NULL, &pidl, 0, NULL);
    if (SUCCEEDED(hr))
    {
        hr = _OnSetExpandedPidl(pidl);
        ILFree(pidl);
    }
    return hr;
}

HRESULT CBrowseForFolder::_OnSetExpandedPidl(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;
    if (pidl && _pns)
    {
        IShellNameSpace *psns;
        hr = _pns->QueryInterface(IID_PPV_ARG(IShellNameSpace, &psns));
        if (SUCCEEDED(hr))
        {
            VARIANT varPidl;
            hr = InitVariantFromIDList(&varPidl, pidl);
            if (SUCCEEDED(hr))
            {
                hr = psns->Expand(varPidl, 1); // To a depth of 1
                VariantClear(&varPidl);
            }
            psns->Release();
        }
    }

    return hr;
}

BOOL CBrowseForFolder::_DoesFilterAllow(LPCITEMIDLIST pidl, BOOL fStrictParsing)
{
    IShellFolder *psfParent;
    LPCITEMIDLIST pidlChild;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psfParent), &pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = _ShouldShow(psfParent, NULL, pidlChild, fStrictParsing);
        psfParent->Release();
    }

    return ((S_OK == hr) ? TRUE : FALSE);
}


HRESULT CBrowseForFolder::_OnPidlNavigation(LPCITEMIDLIST pidl, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (_DoesFilterAllow(pidl, (SHBFFN_STRICT_PARSING & dwFlags)))
    {
        Pidl_Set(&_pidlSelected, pidl);

        if (_pidlSelected)
        {
            // NOTE: for perf, fUpdateTree is FALSE when closing the dialog, so
            // we don't bother to call INSCTree::SetSelectedItem()
            if ((SHBFFN_UPDATE_TREE & dwFlags) && _pns)
            {
                hr = _pns->SetSelectedItem(_pidlSelected, TRUE, FALSE, 0);
            }
            TCHAR szDisplayName[MAX_URL_STRING];

            hr = SHGetNameAndFlags(_pidlSelected, SHGDN_NORMAL, szDisplayName, SIZECHARS(szDisplayName), NULL);
            if (SUCCEEDED(hr))
            {
                EVAL(SetWindowText(GetDlgItem(_hDlg, IDD_BROWSEEDIT), szDisplayName));
                _fEditboxDirty = FALSE;
            }

            if (SHBFFN_FIRE_SEL_CHANGE & dwFlags)
            {
                // For back compat reasons, we need to re-enable the OK button
                // because the callback may turn it off.
                EnableWindow(GetDlgItem(_hDlg, IDOK), TRUE);
                BFSFCallback(_pbfsf, BFFM_SELCHANGED, (LPARAM)_pidlSelected);
            }

            if (_ppf)  // Tell AutoComplete we are in a new location.
                EVAL(SUCCEEDED(_ppf->Initialize(_pidlSelected)));
        }
    }
    else
    {
        if (SHBFFN_DISPLAY_ERRORS & dwFlags)
        {
            TCHAR szPath[MAX_URL_STRING];

            SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szPath, SIZECHARS(szPath), NULL);

            // Display Error UI.
            ShellMessageBox(HINST_THISDLL, _hDlg, MAKEINTRESOURCE(IDS_FOLDER_NOT_ALLOWED),
                            MAKEINTRESOURCE(IDS_FOLDER_NOT_ALLOWED_TITLE), (MB_OK | MB_ICONHAND), szPath);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
    }

    return hr;
}

BOOL CBrowseForFolder::_CreateNewFolder(HWND hDlg)
{
    IShellFavoritesNameSpace * psfns;
    if (_pns && SUCCEEDED(_pns->QueryInterface(IID_PPV_ARG(IShellFavoritesNameSpace, &psfns))))
    {
        HRESULT hr = psfns->NewFolder();

        if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
        {
            // If it failed, then the user doesn't have permission to create a
            // new folder here.  We can't disable the "New Folder" button because
            // it takes too long (perf) to see if it's supported.  The only way
            // is to determine if "New Folder" is in the ContextMenu.
            ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_NEWFOLDER_NOT_HERE),
                            MAKEINTRESOURCE(IDS_NEWFOLDER_NOT_HERE_TITLE), (MB_OK | MB_ICONHAND));
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                _fEditboxDirty = FALSE; // The newly selected node in the tree is the most up to date.
            }
        }

        psfns->Release();
    }
    return TRUE;
}


HRESULT IUnknown_SetOptions(IUnknown * punk, DWORD dwACLOptions)
{
    IACList2 * pal2;

    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IACList2, &pal2));
    if (SUCCEEDED(hr))
    {
        hr = pal2->SetOptions(dwACLOptions);
        pal2->Release();
    }

    return hr;
}

HRESULT CBrowseForFolder::_InitAutoComplete(HWND hwndEdit)
{
    HRESULT hr = CoCreateInstance(CLSID_ACListISF, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFolder, &_ppf));
    if (SUCCEEDED(hr))
    {
        IAutoComplete2 * pac;

        // Create the AutoComplete Object
        hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IAutoComplete2, &pac));
        if (SUCCEEDED(hr))
        {
            hr = pac->Init(hwndEdit, _ppf, NULL, NULL);

            // Set the autocomplete options
            DWORD dwACOptions = 0;
            if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE))
            {
                dwACOptions |= ACO_AUTOAPPEND;
            }

            if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE))
            {
                dwACOptions |= ACO_AUTOSUGGEST;
            }

            EVAL(SUCCEEDED(pac->SetOptions(dwACOptions)));
            EVAL(SUCCEEDED(IUnknown_SetOptions(_ppf, ACLO_FILESYSONLY)));
            _OnTreeSelectChange(SHBFFN_UPDATE_TREE | SHBFFN_NONE);
            pac->Release();
        }
    }

    return hr;
}


void CBrowseForFolder::_OnNotify(LPNMHDR pnm)
{
    if (pnm)
    {
        switch (pnm->code)
        {
        case TVN_SELCHANGEDA:
        case TVN_SELCHANGEDW:
            _OnTreeSelectChange(SHBFFN_DISPLAY_ERRORS);
            break;
        }
    }
}


/***********************************************************************\
    DESCRIPTION:
        If the string was formatted as a UNC or Drive path, offer to
    create the directory path if it doesn't exist.  If the media isn't
    inserted or formated, offer to do that also.

    PARAMETER:
        szPath: The path the user entered into the editbox after it was
                expanded.
        RETURN: S_OK means it's not a file system path or it exists.
                S_FALSE means it's was a file system path but didn't exist
                        or creating it didn't work but NO ERROR UI was displayed.
                FAILURE(): Error UI was displayed, so caller should not
                           display error UI.
\***********************************************************************/
HRESULT CBrowseForFolder::_OfferToPrepPath(OUT LPTSTR pszPath, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    TCHAR szDisplayName[MAX_URL_STRING];
    BOOL fSkipValidation = FALSE;       // Only skip validation if we display the err UI.

    // TODO: Replace this with CShellUrl->ParseFromOutsideSource(), however, this will require
    //       making CShellUrl (browseui) into a COM object.  This will allow us to parse relative
    //       paths.
    GetDlgItemText(_hDlg, IDD_BROWSEEDIT, szDisplayName, ARRAYSIZE(szDisplayName));

    // Callers
    if (SHExpandEnvironmentStrings(szDisplayName, pszPath, cchSize)
        && (PathIsUNC(pszPath) || (-1 != PathGetDriveNumber(pszPath))))
    {
        hr = E_FAIL;
        // I found a problem where UNC paths to printers
        // will fail SHPathPrepareForWrite().  If the caller is
        // looking for printers, we want to succeed in that case and
        // not fail. 
        if ((_pbfsf->ulFlags & BIF_BROWSEFORPRINTER) && PathIsUNCServerShare(pszPath))
        {
            LPITEMIDLIST pidlTest;
            hr = SHParseDisplayName(pszPath, NULL, &pidlTest, 0, NULL);
            if (SUCCEEDED(hr))
                ILFree(pidlTest);
        }

        if (FAILED(hr))
        {
            // yes, so make sure the drive is inserted (if ejectable)
            // This will also offer to format unformatted drives.
            hr = SHPathPrepareForWrite(_hDlg, NULL, pszPath, SHPPFW_MEDIACHECKONLY);
            if (FAILED_AND_NOT_CANCELED(hr))
            {
                hr = S_OK; // this function needs to succeed for us to be able to send VALIDATEFAILED
            }              
        }
    }
    else
        StrCpyN(pszPath, szDisplayName, cchSize);

    return hr;
}

HRESULT CBrowseForFolder::_ProcessEditChangeOnOK(BOOL fUpdateTree)
{
    TCHAR szPath[MAX_URL_STRING];
    HRESULT hr = _OfferToPrepPath(szPath, ARRAYSIZE(szPath));

    // It will succeed if it was successful or DIDN'T display an error
    // dialog and we didn't.
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHParseDisplayName(szPath, NULL, &pidl, 0, NULL)))
        {
            DWORD dwFlags = (SHBFFN_FIRE_SEL_CHANGE | SHBFFN_STRICT_PARSING | SHBFFN_DISPLAY_ERRORS);

            _fEditboxDirty = FALSE;

            if (fUpdateTree)
                dwFlags |= SHBFFN_UPDATE_TREE;

            hr = _OnPidlNavigation(pidl, dwFlags);
            if (SUCCEEDED(hr))
                _fEditboxDirty = FALSE;
        }

        if ((_pbfsf->ulFlags & BIF_VALIDATE) && !pidl)
        {
            LPARAM lParam;
            CHAR szAnsi[MAX_URL_STRING];
            WCHAR wzUnicode[MAX_URL_STRING];

            if (_pbfsf->fUnicode)
            {
                SHTCharToUnicode(szPath, wzUnicode, ARRAYSIZE(wzUnicode));
                lParam = (LPARAM) wzUnicode;
            }
            else
            {
                SHTCharToAnsi(szPath, szAnsi, ARRAYSIZE(szAnsi));
                lParam = (LPARAM) szAnsi;
            }

            ASSERTMSG(_pbfsf->lpfn != NULL, "No BrowseCallbackProc supplied with BIF_VALIDATE flag");

            // 0:EndDialog, 1:continue
            if (0 == BFSFCallback(_pbfsf, (_pbfsf->fUnicode? BFFM_VALIDATEFAILEDW : BFFM_VALIDATEFAILEDA), lParam))
                hr = S_OK; // This is returned so the dialog can close in _OnOK
            else
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }

        ILFree(pidl);
    }

    return hr;
}


HRESULT CBrowseForFolder::_OnTreeSelectChange(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (_pns)
    {
        LPITEMIDLIST pidl;
        hr = _pns->GetSelectedItem(&pidl, 0);
        if (S_OK == hr)
        {
            hr = _OnPidlNavigation(pidl, (SHBFFN_FIRE_SEL_CHANGE | dwFlags));
            ILFree(pidl);
        }
    }

    return hr;
}


HRESULT CBrowseForFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBrowseForFolder, IFolderFilter),         // IID_IFolderFilter
        QITABENT(CBrowseForFolder, IFolderFilterSite),     // IID_IFolderFilterSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


ULONG CBrowseForFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CBrowseForFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        //
        //  TODO:   gpease  28-FEB-2002
        //          Uh?
        //
// We aren't a real COM object yet.
//    delete this;
    }
    return cRef;
}


HRESULT CBrowseForFolder::_ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem, BOOL fStrict)
{
    HRESULT hr = S_OK;
    BOOL fFilterChildern = FALSE;

    // Do we want to filter our all the children of a certain folder?
    if (_pidlChildFilter)
    {
        // Yes, let's see if the tree walking caller is still
        // in this folder?
        if (pidlFolder && ILIsParent(_pidlChildFilter, pidlFolder, FALSE))
        {
            // Yes, so don't use it.
            hr = S_FALSE;
        }
        else
        {
            // The calling tree walker has walked out side of
            // this folder, so remove the filter.
            _FilterThisFolder(NULL, NULL);
        }
    }

    AssertMsg((ILIsEmpty(pidlItem) || ILIsEmpty(_ILNext(pidlItem))), TEXT("CBrowseForFolder::ShouldShow() pidlItem needs to be only one itemID long because we don't handle that case."));
    if (S_OK == hr)
    {
        hr = _DoesMatchFilter(psf, pidlFolder, pidlItem, fStrict);
    }

    // If this pidl has still not been filtered out, give our client filter a chance.
    if (_pClientFilter && (hr == S_OK))
    {
        hr = _pClientFilter->ShouldShow(psf, pidlFolder, pidlItem);
    }

    return hr;
}


HRESULT CBrowseForFolder::GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags)
{
    if (_pbfsf->ulFlags & BIF_SHAREABLE)
        *pgrfFlags |= SHCONTF_SHAREABLE;

    if (_pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
        *pgrfFlags |= SHCONTF_NETPRINTERSRCH;

    // Also delegate to client filter.
    if (_pClientFilter)
    {
        return _pClientFilter->GetEnumFlags(psf, pidlFolder, phwnd, pgrfFlags);
    }

    return S_OK;
}

    // *** IFolderFilterSite method ***
HRESULT CBrowseForFolder::SetFilter(IUnknown* punk)
{
    HRESULT hr = S_OK;
    
    ATOMICRELEASE(_pClientFilter);
    if (punk)
        hr = punk->QueryInterface(IID_PPV_ARG(IFolderFilter, &_pClientFilter));

    return hr;
}

HRESULT CBrowseForFolder::_FilterThisFolder(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlChild)
{
    if (_pidlChildFilter)
        ILFree(_pidlChildFilter);

    if (pidlChild)
        _pidlChildFilter = ILCombine(pidlFolder, pidlChild);
    else
    {
        if (pidlFolder)
            _pidlChildFilter = ILClone(pidlFolder);
        else
            _pidlChildFilter = NULL;
    }

    return S_OK;
}

HRESULT CBrowseForFolder::_InitFilter(void)
{
    HRESULT hr = S_OK;

    // Need to do a couple of special cases here to allow us to
    // browse for a network printer.  In this case if we are at server
    // level we then need to change what we search for non folders when
    // we are the level of a server.
    if ((_pbfsf->ulFlags & (BIF_BROWSEFORPRINTER | BIF_NEWDIALOGSTYLE)) == BIF_BROWSEFORPRINTER)
    {
        LPCITEMIDLIST pidl = ILFindLastID(_pbfsf->pidlRoot);
    
        _fPrinterFilter = ((SIL_GetType(pidl) & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
    }

    return hr;
}


BOOL IsPidlUrl(IShellFolder *psf, LPCITEMIDLIST pidlChild)
{
    BOOL fIsURL = FALSE;
    WCHAR wzDisplayName[MAX_URL_STRING];

    if (SUCCEEDED(DisplayNameOf(psf, pidlChild, SHGDN_FORPARSING, wzDisplayName, ARRAYSIZE(wzDisplayName))))
    {
        fIsURL = PathIsURLW(wzDisplayName);
    }

    return fIsURL;
}

HRESULT CBrowseForFolder::_DoesMatchFilter(IShellFolder *psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlChild, BOOL fStrict)
{
    HRESULT hr = S_OK;

    // We need to special case here in the netcase where we only
    // browse down to workgroups...
    //
    //
    // Here is where I also need to special case to not go below
    // workgroups when the appropriate option is set.
    
    BYTE bType = SIL_GetType(pidlChild);

    if ((_pbfsf->ulFlags & BIF_DONTGOBELOWDOMAIN) && (bType & SHID_NET))
    {
        switch (bType & (SHID_NET | SHID_INGROUPMASK))
        {
        case SHID_NET_SERVER:
            hr = S_FALSE;           // don't add it
            break;
        case SHID_NET_DOMAIN:
            _FilterThisFolder(pidlFolder, pidlChild);      // Force to not have children;
            break;
        }
    }
    else if ((_pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) && (bType & SHID_NET))
    {
        if ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER)
            _FilterThisFolder(pidlFolder, pidlChild);      // Don't expand below it...
    }
    else if (_pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
    {
        /* This code is a work in progress and will be refined post beta 1 */
        
        IShellLink* pShortcut = NULL;
        if (SUCCEEDED(psf->BindToObject(pidlChild, NULL, IID_PPV_ARG(IShellLink, &pShortcut))))
        {
            LPITEMIDLIST pShortcutTargetIDList = NULL;
            if (SUCCEEDED(pShortcut->GetIDList(&pShortcutTargetIDList)))
            {
                IShellFolder* pTargetParentFolder;
                LPITEMIDLIST pTargetRelativeIDList;
                if (SUCCEEDED(SHBindToIDListParent(pShortcutTargetIDList, IID_PPV_ARG(IShellFolder, &pTargetParentFolder), (LPCITEMIDLIST*) &pTargetRelativeIDList)))
                {
                    BYTE NetResourceArray[2048];
                    NETRESOURCE* pNetResource = (NETRESOURCE*) NetResourceArray;
                    SHGetDataFromIDList(pTargetParentFolder, pTargetRelativeIDList, SHGDFIL_NETRESOURCE, (void*) &NetResourceArray, sizeof(NetResourceArray));
                    if (RESOURCEDISPLAYTYPE_SHARE == pNetResource->dwDisplayType)
                    {
                        hr = S_FALSE;
                    }
                    pTargetParentFolder->Release();
                }
                ILFree(pShortcutTargetIDList);
            }
            pShortcut->Release();
        }

        if (S_OK == hr) // we don't want S_FALSE
        {
            // Special case when we are only allowing printers.
            // for now I will simply key on the fact that it is non-FS.
            ULONG ulAttr = SFGAO_FILESYSANCESTOR;
            
            psf->GetAttributesOf(1, &pidlChild, &ulAttr);
            if ((ulAttr & (SFGAO_FILESYSANCESTOR)) == 0)
            {
                _FilterThisFolder(pidlFolder, pidlChild);      // Don't expand below it...
            }
            else
            {
                if (_fPrinterFilter)
                    hr = S_FALSE;           // don't add it
            }
        }
    }
    else if (!(_pbfsf->ulFlags & BIF_BROWSEINCLUDEFILES))
    {
        // If the caller wants to include URLs and this is an URL,
        // then we are done.  Otherwise, we need to enter this if and
        // filter out items that don't have the SFGAO_FOLDER attribute
        // set.
        if (!(_pbfsf->ulFlags & BIF_BROWSEINCLUDEURLS) || !IsPidlUrl(psf, pidlChild))
        {
            // Lets not use the callback to see if this item has children or not
            // as some or files (no children) and it is not worth writing our own
            // enumerator as we don't want the + to depend on if there are sub-folders
            // but instead it should be if it has files...
            ULONG ulAttr = SFGAO_FOLDER;

            psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidlChild, &ulAttr);
            if ((ulAttr & SFGAO_FOLDER)== 0)
                hr = S_FALSE;           // don't add it
        }
    }

    if (_pbfsf->ulFlags & (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS))
    {
        // If we are only looking for FS level things only add items
        // that are in the name space that are file system objects or
        // ancestors of file system objects
        ULONG ulAttr = 0;

        if (fStrict)
        {
            if (_pbfsf->ulFlags & BIF_RETURNONLYFSDIRS)
                ulAttr |= SFGAO_FILESYSTEM;

            if (_pbfsf->ulFlags & BIF_RETURNFSANCESTORS)
                ulAttr |= SFGAO_FILESYSANCESTOR;
        }
        else
        {
            ulAttr = (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM);
        }

        psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidlChild, &ulAttr);
        if ((ulAttr & (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM))== 0)
        {
            hr = S_FALSE;           // don't add it
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\brffldr.cpp ===
#include "shellprv.h"

#include <brfcasep.h>
#include "filefldr.h"
#include "brfcase.h"
#include "datautil.h"
#include "prop.h"
#include "ids.h"
#include "defview.h"    // for WM_DSV_FSNOTIFY
#include "basefvcb.h"
#include "views.h"

#define MAX_NAME    32

#define HACK_IGNORETYPE     0x04000000

// Values for CBriefcase::_FindNextState
#define FNS_UNDETERMINED   1
#define FNS_STALE          2
#define FNS_DELETED        3

typedef struct
{
    TCHAR   szOrigin[MAX_PATH];
    TCHAR   szStatus[MAX_NAME];
    BOOL    bDetermined:1;
    BOOL    bUpToDate:1;
    BOOL    bDeleted:1;
} BRFINFO;

typedef struct
{
    LPITEMIDLIST    pidl;       // Indexed value
    BRFINFO         bi;
} BRFINFOHDR;

class CBriefcaseViewCB;

class CBriefcase : public CFSFolder
{
    friend CBriefcaseViewCB;

public:
    CBriefcase(IUnknown *punkOuter);
    STDMETHODIMP Init(); // initialize the critical section

    // IShellFolder
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv);

    // IShellFolder2
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHOD (MapColumnToSCID)(UINT iColumn, SHCOLUMNID *pscid);

private:
    ~CBriefcase();

    static DWORD CALLBACK _CalcDetailsThreadProc(void *pv);
    DWORD _CalcDetailsThread();

    void _EnterCS();
    void _LeaveCS();
    static int CALLBACK _CompareIDCallBack(void *pv1, void *pv2, LPARAM lParam);
    BOOL _CreateDetailsThread();
    BOOL _InitDetailsInfoAndThread(IBriefcaseStg *pbrfstg, HWND hwndMain, HANDLE hMutexDelay);
    void _Free();
    void _Reset();
    BOOL _FindCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi);
    BOOL _DeleteCachedName(LPCITEMIDLIST pidl);
    BOOL _FindNextState(UINT uState, BRFINFOHDR *pbihdrOut);
    void _CalcCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi);
    void _CachedNameIsStale(LPCITEMIDLIST pidl, BOOL bDeleted);
    void _AllNamesAreStale();
    BOOL _AddCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi);
    HRESULT _CreateView(HWND hwnd, IShellView **ppsv);

    HWND                _hwndMain;      // evil, view related state
    IBriefcaseStg       *_pbrfstg;      // evil, view related state

    // accessed by background thread
    HDPA                _hdpa;          
    int                 _idpaStaleCur;
    int                 _idpaUndeterminedCur;
    int                 _idpaDeletedCur;
    HANDLE              _hSemPending;    // Pending semaphore
    CRITICAL_SECTION    _cs;
    BOOL                _fcsInit;
    HANDLE              _hEventDie;
    HANDLE              _hThreadCalcDetails;
    HANDLE              _hMutexDelay;    // alias given out by the _pbrfstg
    BOOL                _bFreePending;
#ifdef DEBUG
    UINT                _cUndetermined;
    UINT                _cStale;
    UINT                _cDeleted;
    UINT                _cCSRef;
#endif
};

class CBriefcaseViewCB : public CBaseShellFolderViewCB
{
public:
    CBriefcaseViewCB(CBriefcase *pfolder);
    HRESULT _InitStgForDetails();

    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    ~CBriefcaseViewCB();
    LPCITEMIDLIST _FolderPidl() { return _pfolder->_pidl; }

    HRESULT OnWINDOWCREATED(DWORD pv, HWND hwndView);
    HRESULT OnWINDOWDESTROY(DWORD pv, HWND wP);
    HRESULT OnMergeMenu(DWORD pv, QCMINFO*lP);
    HRESULT OnINVOKECOMMAND(DWORD pv, UINT wP);
    HRESULT OnGetHelpOrTooltipText(BOOL bHelp, UINT wPl, UINT cch, LPTSTR psz);
    HRESULT OnINITMENUPOPUP(DWORD pv, UINT wPl, UINT wPh, HMENU lP);
    HRESULT OnGETBUTTONINFO(DWORD pv, TBINFO* ptbinfo);
    HRESULT OnGETBUTTONS(DWORD pv, UINT wPl, UINT wPh, TBBUTTON*lP);
    HRESULT OnSELCHANGE(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA*lP);
    HRESULT OnQUERYFSNOTIFY(DWORD pv, SHChangeNotifyEntry*lP);
    HRESULT OnFSNOTIFY(DWORD pv, LPCITEMIDLIST*wP, LPARAM lP);
    HRESULT OnQUERYCOPYHOOK(DWORD pv);
    HRESULT OnNOTIFYCOPYHOOK(DWORD pv, COPYHOOKINFO*lP);
    HRESULT OnINSERTITEM(DWORD pv, LPCITEMIDLIST wP);
    HRESULT OnDEFVIEWMODE(DWORD pv, FOLDERVIEWMODE *lP);
    HRESULT OnSupportsIdentity(DWORD pv);
    HRESULT OnGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA * phtd);
    HRESULT OnDELAYWINDOWCREATE(DWORD pv, HWND hwnd);
    HRESULT _GetSelectedObjects(IDataObject **ppdtobj);
    HRESULT _HandleFSNotifyForDefView(LPARAM lEvent, LPCITEMIDLIST * ppidl, LPTSTR pszBuf);
    int _GetSelectedCount();

    CBriefcase *_pfolder;

    IBriefcaseStg       *_pbrfstg;
    LPITEMIDLIST        _pidlRoot;       // Root of briefcase
    HANDLE              _hMutexDelay;
    ULONG               _uSCNRExtra;     // Extra SHChangeNotifyRegister for our pidl...
    TCHAR               _szDBName[MAX_PATH];

    // Web View implementation
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
public:
    static HRESULT _OnUpdate(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc);
};

CBriefcase::CBriefcase(IUnknown *punkOuter) : CFSFolder(punkOuter)
{
    _clsidBind = CLSID_BriefcaseFolder; // in CFSFolder
    _fcsInit = FALSE;
}

CBriefcase::~CBriefcase()
{
    if (_fcsInit)
    {
        DeleteCriticalSection(&_cs);
    }
}

STDMETHODIMP CBriefcase::Init()
{
    _fcsInit = InitializeCriticalSectionAndSpinCount(&_cs, 0);
    return _fcsInit ? S_OK : E_FAIL;
}

enum
{
    ICOL_BRIEFCASE_NAME = 0,
    ICOL_BRIEFCASE_ORIGIN,
    ICOL_BRIEFCASE_STATUS,
    ICOL_BRIEFCASE_SIZE,
    ICOL_BRIEFCASE_TYPE,
    ICOL_BRIEFCASE_MODIFIED,
};

const COLUMN_INFO s_briefcase_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,                 30, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_SYNCCOPYIN,           24, IDS_SYNCCOPYIN_COL),
    DEFINE_COL_STR_ENTRY(SCID_STATUS,               18, IDS_STATUS_COL),
    DEFINE_COL_SIZE_ENTRY(SCID_SIZE,                    IDS_SIZE_COL),
    DEFINE_COL_STR_ENTRY(SCID_TYPE,                 18, IDS_TYPE_COL),
    DEFINE_COL_STR_ENTRY(SCID_WRITETIME,            18, IDS_MODIFIED_COL),
};


#ifdef DEBUG

#define _AssertInCS()     ASSERT(0 < (this)->_cCSRef)
#define _AssertNotInCS()  ASSERT(0 == (this)->_cCSRef)

#else

#define _AssertInCS()
#define _AssertNotInCS()

#endif


void CBriefcase::_EnterCS()
{
    ASSERT(_fcsInit);
    EnterCriticalSection(&_cs);
#ifdef DEBUG
    _cCSRef++;
#endif
}

void CBriefcase::_LeaveCS()
{
    ASSERT(_fcsInit);
    _AssertInCS();
#ifdef DEBUG
    _cCSRef--;
#endif        
    LeaveCriticalSection(&_cs);
}


//---------------------------------------------------------------------------
// Brfview functions:    Expensive cache stuff
//---------------------------------------------------------------------------


// Comparison function for the DPA list

int CALLBACK CBriefcase::_CompareIDCallBack(void *pv1, void *pv2, LPARAM lParam)
{
    BRFINFOHDR *pbihdr1 = (BRFINFOHDR *)pv1;
    BRFINFOHDR *pbihdr2 = (BRFINFOHDR *)pv2;
    CBriefcase *pfolder = (CBriefcase *)lParam;
    HRESULT hr = pfolder->CompareIDs(HACK_IGNORETYPE, pbihdr1->pidl, pbihdr2->pidl);
    
    ASSERT(SUCCEEDED(hr));
    return (short)SCODE_CODE(GetScode(hr));   // (the short cast is important!)
}

// Create the secondary thread for the expensive cache

BOOL CBriefcase::_CreateDetailsThread()
{
    BOOL bRet = FALSE;
    
    // The semaphore is used to determine whether anything
    // needs to be refreshed in the cache.
    _hSemPending = CreateSemaphore(NULL, 0, MAXLONG, NULL);
    if (_hSemPending)
    {
#ifdef DEBUG
        _cStale = 0;
        _cUndetermined = 0;
        _cDeleted = 0;
#endif
        ASSERT(NULL == _hEventDie);
        
        _hEventDie = CreateEvent(NULL, FALSE, FALSE, NULL);
        
        if (_hEventDie)
        {
            // Create the thread that will calculate expensive data
            DWORD idThread;
            _hThreadCalcDetails = CreateThread(NULL, 0, _CalcDetailsThreadProc, this, CREATE_SUSPENDED, &idThread);
            if (_hThreadCalcDetails)
            {
                ResumeThread(_hThreadCalcDetails);
                bRet = TRUE;
            }
            else
            {
                CloseHandle(_hEventDie);
                _hEventDie = NULL;
                
                CloseHandle(_hSemPending);
                _hSemPending = NULL;
            }
        }
        else
        {
            CloseHandle(_hSemPending);
            _hSemPending = NULL;
        }
    }
    
    return bRet;
}

// view callback inits the folder with data it needs to run the GetDetailsOf() stuff
// on a background thread

BOOL CBriefcase::_InitDetailsInfoAndThread(IBriefcaseStg *pbrfstg, HWND hwndMain, HANDLE hMutexDelay)
{
    BOOL bRet = FALSE;

    ASSERT(pbrfstg && hwndMain && hMutexDelay);   // from the init call
    
    _EnterCS();
    {
        if (_hdpa)
        {
            bRet = TRUE;
        }
        else
        {                        
            _hwndMain = hwndMain;
            _hMutexDelay = hMutexDelay;
            _idpaStaleCur = 0;
            _idpaUndeterminedCur = 0;
            _idpaDeletedCur = 0;
            
            _hdpa = DPA_Create(8);
            if (_hdpa)
            {
                bRet = _CreateDetailsThread();
                if (bRet)
                {
                    ASSERT(NULL == _pbrfstg);
                    _pbrfstg = pbrfstg;
                    pbrfstg->AddRef();
                }
                else
                {
                    // Failed
                    DPA_Destroy(_hdpa);
                    _hdpa = NULL;
                }
            }
        }
    }
    _LeaveCS();
    
    return bRet;
}

// Clean up the cache of expensive data

void CBriefcase::_Free()
{
    _EnterCS();
    {
        if (_hEventDie)
        {
            if (_hThreadCalcDetails)
            {
                HANDLE hThread = _hThreadCalcDetails;
                
                SetThreadPriority(hThread, THREAD_PRIORITY_HIGHEST);
                
                // Signal the secondary thread to end
                SetEvent(_hEventDie);
                
                // Make sure we are not in the critical section when
                // we wait for the secondary thread to exit.  Without
                // this check, hitting F5 twice in a row could deadlock.
                _LeaveCS();
                {
                    // Wait for the threads to exit
                    _AssertNotInCS();
                    
                    WaitForSendMessageThread(hThread, INFINITE);
                }
                _EnterCS();
                
                DebugMsg(DM_TRACE, TEXT("Briefcase Secondary thread ended"));
                
                CloseHandle(_hThreadCalcDetails);
                _hThreadCalcDetails = NULL;
            }
            
            CloseHandle(_hEventDie);
            _hEventDie = NULL;
        }
        
        if (_hdpa)
        {
            int idpa = DPA_GetPtrCount(_hdpa);
            while (--idpa >= 0)
            {
                BRFINFOHDR *pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(_hdpa, idpa);
                ILFree(pbihdr->pidl);
                LocalFree((HLOCAL)pbihdr);
            }
            DPA_Destroy(_hdpa);
            _hdpa = NULL;
        }
        
        if (_hSemPending)
        {
            CloseHandle(_hSemPending);
            _hSemPending = NULL;
        }
        
        if (_pbrfstg)
        {
            _pbrfstg->Release();
            _pbrfstg = NULL;

            _hMutexDelay = NULL;    // invalidate our alias
        }
    }
    _LeaveCS();
    
}

// Resets the expensive data cache
void CBriefcase::_Reset()
{
    _AssertNotInCS();
    
    _EnterCS();
    {
        IBriefcaseStg *pbrfstg = _pbrfstg;
        
        if (!_bFreePending && pbrfstg)
        {
            HWND hwndMain = _hwndMain;
            HANDLE hMutex = _hMutexDelay;
            
            pbrfstg->AddRef();
            
            // Since we won't be in the critical section when we
            // wait for the paint thread to exit, set this flag to
            // avoid nasty re-entrant calls.
            _bFreePending = TRUE;
            
            // Reset by freeing and reinitializing.
            _LeaveCS();
            {
                _Free();
                // whacky re-init of ourselevs
                _InitDetailsInfoAndThread(pbrfstg, hwndMain, hMutex);
            }
            _EnterCS();
            
            _bFreePending = FALSE;
            
            pbrfstg->Release();
        }
    }
    _LeaveCS();
    
}

// Finds a cached name structure and returns a copy of it in *pbi.
BOOL CBriefcase::_FindCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi)
{
    BOOL bRet = FALSE;
    
    _EnterCS();
    {
        if (_hdpa)
        {
            BRFINFOHDR bihdr = {0};
            
            bihdr.pidl = (LPITEMIDLIST)pidl;    // const -> non const
            int idpa = DPA_Search(_hdpa, &bihdr, 0, _CompareIDCallBack, (LPARAM)this, DPAS_SORTED);
            if (DPA_ERR != idpa)
            {
                // Yes
                BRFINFOHDR *pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(_hdpa, idpa);
                ASSERT(pbihdr);
                
                *pbi = pbihdr->bi;
                bRet = TRUE;
            }
        }
    }
    _LeaveCS();
    
    
    return bRet;
}

// Deletes a cached name structure.

BOOL CBriefcase::_DeleteCachedName(LPCITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    
    _EnterCS();
    {
        if (_hdpa)
        {
            BRFINFOHDR bihdr = {0};
            
            bihdr.pidl = (LPITEMIDLIST)pidl;    // const -> non const
            int idpa = DPA_Search(_hdpa, &bihdr, 0, _CompareIDCallBack, (LPARAM)this, DPAS_SORTED);
            if (DPA_ERR != idpa)
            {
#ifdef DEBUG
                BRFINFOHDR *pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(_hdpa, idpa);
                ASSERT(pbihdr);
                
                _cDeleted--;
                
                if (!pbihdr->bi.bDetermined)
                    _cUndetermined--;
                else if (!pbihdr->bi.bUpToDate)
                    _cStale--;
#endif
                // Keep index pointers current
                if (_idpaStaleCur >= idpa)
                    _idpaStaleCur--;
                if (_idpaUndeterminedCur >= idpa)
                    _idpaUndeterminedCur--;
                if (_idpaDeletedCur >= idpa)
                    _idpaDeletedCur--;
                
                DPA_DeletePtr(_hdpa, idpa);
                bRet = TRUE;
            }
        }
    }
    _LeaveCS();
    
    
    return bRet;
}


// Finds the next cached name structure that matches the requested state.

BOOL CBriefcase::_FindNextState(UINT uState, BRFINFOHDR *pbihdrOut)
{
    BOOL bRet = FALSE;
    
    ASSERT(pbihdrOut);
    
    _EnterCS();
    {
        if (_hdpa)
        {
            HDPA hdpa = _hdpa;
            int idpaCur;
            int idpa;
            BRFINFOHDR *pbihdr;
            
            int cdpaMax = DPA_GetPtrCount(hdpa);
            
            switch (uState)
            {
            case FNS_UNDETERMINED:
                // Iterate thru the entire list starting at idpa.  We roll this
                // loop out to be two loops: the first iterates the last portion
                // of the list, the second iterates the first portion if the former
                // failed to find anything.
                idpaCur = _idpaUndeterminedCur + 1;
                for (idpa = idpaCur; idpa < cdpaMax; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (!pbihdr->bi.bDetermined)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(idpaCur <= cdpaMax);
                for (idpa = 0; idpa < idpaCur; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (!pbihdr->bi.bDetermined)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(0 == _cUndetermined);
                break;
                
            case FNS_STALE:
                // Iterate thru the entire list starting at idpa.  We roll this
                // loop out to be two loops: the first iterates the last portion
                // of the list, the second iterates the first portion if the former
                // failed to find anything.
                idpaCur = _idpaStaleCur + 1;
                for (idpa = idpaCur; idpa < cdpaMax; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (!pbihdr->bi.bUpToDate)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(idpaCur <= cdpaMax);
                for (idpa = 0; idpa < idpaCur; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (!pbihdr->bi.bUpToDate)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(0 == _cStale);
                break;
                
            case FNS_DELETED:
                // Iterate thru the entire list starting at idpa.  We roll this
                // loop out to be two loops: the first iterates the last portion
                // of the list, the second iterates the first portion if the former
                // failed to find anything.
                idpaCur = _idpaDeletedCur + 1;
                for (idpa = idpaCur; idpa < cdpaMax; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (pbihdr->bi.bDeleted)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(idpaCur <= cdpaMax);
                for (idpa = 0; idpa < idpaCur; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (pbihdr->bi.bDeleted)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(0 == _cDeleted);
                break;
                
            default:
                ASSERT(0);      // should never get here
                break;
            }
            goto Done;
            
Found:
            ASSERT(0 <= idpa && idpa < cdpaMax);
            
            // Found the next item of the requested state
            switch (uState)
            {
            case FNS_UNDETERMINED:
                _idpaUndeterminedCur = idpa;
                break;
                
            case FNS_STALE:
                _idpaStaleCur = idpa;
                break;
                
            case FNS_DELETED:
                _idpaDeletedCur = idpa;
                break;
            }
            
            *pbihdrOut = *pbihdr;
            pbihdrOut->pidl = ILClone(pbihdr->pidl);
            if (pbihdrOut->pidl)
                bRet = TRUE;
        }
Done:;
    }
    _LeaveCS();
    
    return bRet;
}
    
// Recalculates a cached name structure.  This can be an expensive operation
void CBriefcase::_CalcCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi)
{
    _EnterCS();
    {
        if (_hdpa && _pbrfstg)
        {
            LPCIDFOLDER pidf = (LPCIDFOLDER)pidl;
            IBriefcaseStg *pbrfstg = _pbrfstg;
        
            pbrfstg->AddRef();
        
            // Make sure we're out of the critical section when we call
            // the expensive functions!
            _LeaveCS();
            {
                TCHAR szTmp[MAX_PATH];
                _CopyName(pidf, szTmp, ARRAYSIZE(szTmp));
            
                pbrfstg->GetExtraInfo(szTmp, GEI_ORIGIN, (WPARAM)ARRAYSIZE(pbi->szOrigin), (LPARAM)pbi->szOrigin);
                pbrfstg->GetExtraInfo(szTmp, GEI_STATUS, (WPARAM)ARRAYSIZE(pbi->szStatus), (LPARAM)pbi->szStatus);
            }
            
            _EnterCS();
            
            pbrfstg->Release();
        
            // Check again if we are valid
            if (_hdpa)
            {
                // Is the pidl still around so we can update it?
                BRFINFOHDR bihdr = {0};
                bihdr.pidl = (LPITEMIDLIST)pidf;
                int idpa = DPA_Search(_hdpa, &bihdr, 0, _CompareIDCallBack, (LPARAM)this, DPAS_SORTED);
                if (DPA_ERR != idpa)
                {
                    // Yes; update it
                    BRFINFOHDR * pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(_hdpa, idpa);
            
                    ASSERT(!pbihdr->bi.bUpToDate || !pbihdr->bi.bDetermined)
                
                    // This entry may have been marked for deletion while the
                    // expensive calculations were in process above.  Check for
                    // it now.
                    if (pbihdr->bi.bDeleted)
                    {
                        _DeleteCachedName(pidl);
                    }
                    else
                    {
                        pbihdr->bi = *pbi;
                        pbihdr->bi.bUpToDate = TRUE;
                        pbihdr->bi.bDetermined = TRUE;
                
        #ifdef DEBUG
                        if (!pbi->bDetermined)
                            _cUndetermined--;
                        else if (!pbi->bUpToDate)
                            _cStale--;
                        else
                            ASSERT(0);
        #endif
                    }
                }
            }
        }
        _LeaveCS();
    }
}

// Finds a cached name structure and marks it stale
// WARNING: pidl can be a fully qualified pidl that is comming through as a change notify

void CBriefcase::_CachedNameIsStale(LPCITEMIDLIST pidl, BOOL bDeleted)
{
    _EnterCS();
    {
        if (_hdpa)
        {
            BRFINFOHDR bihdr = {0};
            
            bihdr.pidl = ILFindLastID(pidl);    // hope this is all ours
            int idpa = DPA_Search(_hdpa, &bihdr, 0, _CompareIDCallBack, (LPARAM)this, DPAS_SORTED);
            if (DPA_ERR != idpa)
            {
                // Yes; mark it stale
                BRFINFOHDR *pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(_hdpa, idpa);
            
                // Is this cached name pending calculation yet?
                if (pbihdr->bi.bDetermined && pbihdr->bi.bUpToDate &&
                    !pbihdr->bi.bDeleted)
                {
                    // No; signal the calculation thread
                    if (bDeleted)
                    {
                        pbihdr->bi.bDeleted = TRUE;
#ifdef DEBUG
                        _cDeleted++;
#endif
                    }
                    else
                    {
                        pbihdr->bi.bUpToDate = FALSE;
#ifdef DEBUG
                        _cStale++;
#endif
                    }
                
                    // Notify the calculating thread of an item that is pending
                    // calculation
                    ReleaseSemaphore(_hSemPending, 1, NULL);
                }
                else if (bDeleted)
                {
                    // Yes; but mark for deletion anyway
                    pbihdr->bi.bDeleted = TRUE;
#ifdef DEBUG
                    _cDeleted++;
#endif
                }
            }
        }
    }
    _LeaveCS();
}
  
// Marks all cached name structures stale
void CBriefcase::_AllNamesAreStale()
{
    _EnterCS();
    {
        if (_pbrfstg)
        {
            UINT uFlags;
            // Dirty the briefcase storage cache
            _pbrfstg->Notify(NULL, NOE_DIRTYALL, &uFlags, NULL);
        }
    }
    _LeaveCS();
    
    
    // (It is important that we call CBriefcase::_Reset outside of the critical
    // section.  Otherwise, we can deadlock when this function is called
    // while the secondary thread is calculating (hit F5 twice in a row).)
    
    // Clear the entire expensive data cache
    _Reset();
}

// Adds a new item with default values to the extra info list
BOOL CBriefcase::_AddCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi)
{
    BOOL bRet = FALSE;
    
    ASSERT(_pbrfstg && _hwndMain && _hMutexDelay);
    
    _EnterCS();
    {
        if (_hdpa)
        {
            BRFINFOHDR * pbihdr = (BRFINFOHDR *)LocalAlloc(LPTR, sizeof(*pbihdr));
            if (pbihdr)
            {
                pbihdr->pidl = ILClone(pidl);
                if (pbihdr->pidl)
                {
                    int idpa = DPA_AppendPtr(_hdpa, pbihdr);
                    if (DPA_ERR != idpa)
                    {
                        pbihdr->bi.bUpToDate = FALSE;
                        pbihdr->bi.bDetermined = FALSE;
                        pbihdr->bi.bDeleted = FALSE;
                        
                        LoadString(HINST_THISDLL, IDS_DETAILSUNKNOWN, pbihdr->bi.szOrigin, ARRAYSIZE(pbihdr->bi.szOrigin));
                        LoadString(HINST_THISDLL, IDS_DETAILSUNKNOWN, pbihdr->bi.szStatus, ARRAYSIZE(pbihdr->bi.szStatus));
#ifdef DEBUG
                        _cUndetermined++;
#endif
                        DPA_Sort(_hdpa, _CompareIDCallBack, (LPARAM)this);
                    
                        // Notify the calculating thread of an item that is pending
                        // calculation
                        ReleaseSemaphore(_hSemPending, 1, NULL);
                    
                        *pbi = pbihdr->bi;
                        bRet = TRUE;
                    }
                    else
                    {
                        // Failed. Cleanup
                        ILFree(pbihdr->pidl);
                        LocalFree((HLOCAL)pbihdr);
                    }
                }
                else
                {
                    // Failed.  Cleanup
                    LocalFree((HLOCAL)pbihdr);
                }
            }
        }
    }
    _LeaveCS();
    
    return bRet;
}

DWORD CBriefcase::_CalcDetailsThread()
{
    HANDLE rghObjPending[2] = {_hEventDie, _hSemPending};
    HANDLE rghObjDelay[2] = {_hEventDie, _hMutexDelay};
    
    while (TRUE)
    {
        // Wait for an end event or for a job to do
        DWORD dwRet = WaitForMultipleObjects(ARRAYSIZE(rghObjPending), rghObjPending, FALSE, INFINITE);
        if (WAIT_OBJECT_0 == dwRet)
        {
            // Exit thread
            break;
        }
        else
        {
#ifdef DEBUG
            _EnterCS();
            {
                ASSERT(0 < _cUndetermined ||
                    0 < _cStale ||
                    0 < _cDeleted);
            }
            _LeaveCS();
#endif
            // Now wait for an end event or for the delay-calculation mutex
            dwRet = WaitForMultipleObjects(ARRAYSIZE(rghObjDelay), rghObjDelay, FALSE, INFINITE);
            if (WAIT_OBJECT_0 == dwRet)
            {
                // Exit thread
                break;
            }
            else
            {
                // Address deleted entries first
                BRFINFOHDR bihdr;
                if (_FindNextState(FNS_DELETED, &bihdr))
                {
                    _DeleteCachedName(bihdr.pidl);
                    ILFree(bihdr.pidl);
                }
                // Calculate undetermined entries before stale entries
                // to fill the view as quickly as possible
                else if (_FindNextState(FNS_UNDETERMINED, &bihdr) ||
                         _FindNextState(FNS_STALE, &bihdr))
                {
                    _CalcCachedName(bihdr.pidl, &bihdr.bi);
#if 1
                    // ugly way
                    ShellFolderView_RefreshObject(_hwndMain, &bihdr.pidl);
#else
                    // right way, but we don't have _punkSite, here, that is on another thread!
                    IShellFolderView *psfv;
                    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IShellFolderView, &psfv))))
                    {
                        UINT uScratch;
                        psfv->RefreshObject(&bihdr.pidl, &uScratch);
                        psfv->Release();
                    }
#endif
                    ILFree(bihdr.pidl);
                }
                else
                {
                    ASSERT(0);      // Should never get here
                }
                
                ReleaseMutex(_hMutexDelay);
            }
        }
    }
    return 0;
}

DWORD CALLBACK CBriefcase::_CalcDetailsThreadProc(void *pv)
{
    return ((CBriefcase *)pv)->_CalcDetailsThread();
}

// IShellFolder2::GetDetailsOf

STDMETHODIMP CBriefcase::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    HRESULT hr = S_OK;
    TCHAR szTemp[MAX_PATH];
    LPCIDFOLDER pidf = _IsValidID(pidl);

    pDetails->str.uType = STRRET_CSTR;
    pDetails->str.cStr[0] = 0;
    
    if (!pidf)
    {
        hr = GetDetailsOfInfo(s_briefcase_cols, ARRAYSIZE(s_briefcase_cols), iColumn, pDetails);
    }
    else
    {    
        switch (iColumn)
        {
        case ICOL_BRIEFCASE_NAME:
            _CopyName(pidf, szTemp, ARRAYSIZE(szTemp));
            hr = StringToStrRet(szTemp, &pDetails->str);
            break;
        
        case ICOL_BRIEFCASE_ORIGIN:
        case ICOL_BRIEFCASE_STATUS: 
            // only works if the view callback has set us up for this
            if (_pbrfstg)
            {
                BRFINFO bi;

                // Did we find extra info for this file or
                // was the new item added to the extra info list?
                if (_FindCachedName(pidl, &bi) ||
                    _AddCachedName(pidl, &bi))
                {
                    LPTSTR psz = ICOL_BRIEFCASE_ORIGIN == iColumn ? bi.szOrigin : bi.szStatus;
                    hr = StringToStrRet(psz, &pDetails->str);
                }
            }
            break;
        
        case ICOL_BRIEFCASE_SIZE:
            if (!_IsFolder(pidf))
            {
                StrFormatKBSize(pidf->dwSize, szTemp, ARRAYSIZE(szTemp));
                hr = StringToStrRet(szTemp, &pDetails->str);
            }
            break;
        
        case ICOL_BRIEFCASE_TYPE:
            _GetTypeNameBuf(pidf, szTemp, ARRAYSIZE(szTemp));
            hr = StringToStrRet(szTemp, &pDetails->str);
            break;
        
        case ICOL_BRIEFCASE_MODIFIED:
            DosTimeToDateTimeString(pidf->dateModified, pidf->timeModified, szTemp, ARRAYSIZE(szTemp), pDetails->fmt & LVCFMT_DIRECTION_MASK);
            hr = StringToStrRet(szTemp, &pDetails->str);
            break;
        }
    }
    return hr;
}

// IShellFolder2::MapColumnToSCID

STDMETHODIMP CBriefcase::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    return MapColumnToSCIDImpl(s_briefcase_cols, ARRAYSIZE(s_briefcase_cols), iColumn, pscid);
}

// IShellFolder::CompareIDs

STDMETHODIMP CBriefcase::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCIDFOLDER pidf1 = _IsValidID(pidl1);
    LPCIDFOLDER pidf2 = _IsValidID(pidl2);
    
    if (!pidf1 || !pidf2)
    {
        return E_INVALIDARG;
    }
    
    HRESULT hr = _CompareFolderness(pidf1, pidf2);
    if (hr != ResultFromShort(0))
        return hr;
    
    switch (lParam & SHCIDS_COLUMNMASK)
    {
    case ICOL_BRIEFCASE_SIZE:
        if (pidf1->dwSize < pidf2->dwSize)
            return ResultFromShort(-1);
        if (pidf1->dwSize > pidf2->dwSize)
            return ResultFromShort(1);
        goto DoDefault;
        
    case ICOL_BRIEFCASE_TYPE:
        hr = _CompareFileTypes(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;
        
    case ICOL_BRIEFCASE_MODIFIED:
        hr = _CompareModifiedDate(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;
        
    case ICOL_BRIEFCASE_NAME:
        // We need to treat this differently from others bacause
        // pidf1/2 might not be simple.
        hr = CFSFolder::_CompareNames(pidf1, pidf2, TRUE, FALSE);
        
        // REVIEW: (Possible performance gain with some extra code)
        //   We should probably avoid bindings by walking down
        //  the IDList here instead of calling this helper function.
        //
        if (hr == ResultFromShort(0))
        {
            hr = ILCompareRelIDs((IShellFolder *)this, pidl1, pidl2, lParam);
        }
        goto DoDefaultModification;
        
    case ICOL_BRIEFCASE_ORIGIN:
    case ICOL_BRIEFCASE_STATUS: 
        {
            BRFINFO bi1, bi2;
        
            BOOL bVal1 = _FindCachedName(pidl1, &bi1);
            BOOL bVal2 = _FindCachedName(pidl2, &bi2);
            // Do we have this info in our cache?
            if (!bVal1 || !bVal2)
            {
                // No; one or both of them are missing.  Have unknowns gravitate
                // to the bottom of the list.
                // (Don't bother adding them)
            
                if (!bVal1 && !bVal2)
                    hr = ResultFromShort(0);
                else if (!bVal1)
                    hr = ResultFromShort(1);
                else
                    hr = ResultFromShort(-1);
            }
            else
            {
                // Found the info; do a comparison
                if (ICOL_BRIEFCASE_ORIGIN == (lParam & SHCIDS_COLUMNMASK))
                {
                    hr = ResultFromShort(lstrcmp(bi1.szOrigin, bi2.szOrigin));
                }
                else
                {
                    ASSERT(ICOL_BRIEFCASE_STATUS == (lParam & SHCIDS_COLUMNMASK));
                    hr = ResultFromShort(lstrcmp(bi1.szStatus, bi2.szStatus));
                }
            }
        }
        break;
        
    default:
DoDefault:
        // Sort it based on the primary (long) name -- ignore case.
        {
            TCHAR szName1[MAX_PATH], szName2[MAX_PATH];

            _CopyName(pidf1, szName1, ARRAYSIZE(szName1));
            _CopyName(pidf2, szName2, ARRAYSIZE(szName2));

            hr = ResultFromShort(lstrcmpi(szName1, szName2));
        }

DoDefaultModification:
        if (hr == S_OK && (lParam & SHCIDS_ALLFIELDS)) 
        {
            // Must sort by modified date to pick up any file changes!
            hr = _CompareModifiedDate(pidf1, pidf2);
            if (!hr)
                hr = _CompareAttribs(pidf1, pidf2);
        }
    }
    
    return hr;
}


// This function creates an instance of IShellView.

HRESULT CBriefcase::_CreateView(HWND hwnd, IShellView **ppsv)
{
    *ppsv = NULL;     // assume failure

    HRESULT hr;
    CBriefcaseViewCB *pvcb = new CBriefcaseViewCB(this);
    if (pvcb)
    {
        hr = pvcb->_InitStgForDetails();
        if (SUCCEEDED(hr))
        {
            SFV_CREATE sSFV = {0};

            hr = pvcb->QueryInterface(IID_PPV_ARG(IShellFolderViewCB, &sSFV.psfvcb));
            if (SUCCEEDED(hr))
            {
                sSFV.cbSize = sizeof(sSFV);
                sSFV.pshf   = (IShellFolder *)this;

                hr = SHCreateShellFolderView(&sSFV, ppsv);
            }
        }
        pvcb->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// IShellFolder::CreateViewObject

STDMETHODIMP CBriefcase::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    if (IsEqualIID(riid, IID_IShellView))
    {
        hr = _CreateView(hwnd, (IShellView **)ppv);
    }
    else
    {
        // delegate to base class
        hr = CFSFolder::CreateViewObject(hwnd, riid, ppv);
    }

    ASSERT(FAILED(hr) ? (NULL == *ppv) : TRUE);
    return hr;
}


// IShellFolder::GetAttributesOf

STDMETHODIMP CBriefcase::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG * prgfInOut)
{
    // Validate this pidl?
    if (*prgfInOut & SFGAO_VALIDATE)
    {
        // Yes; dirty the briefcase storage entry by sending an update
        // notification
        DebugMsg(DM_TRACE, TEXT("Briefcase: Receiving F5, dirty entire briefcase storage"));
        
        _AllNamesAreStale();
    }
    
    // delegate to base
    return CFSFolder::GetAttributesOf(cidl, apidl, prgfInOut);
}

// IShellFolder::GetUIObjectOf

STDMETHODIMP CBriefcase::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, 
                                       REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr;

    if (cidl > 0 && IsEqualIID(riid, IID_IDataObject))
    {
        // Create an IDataObject interface instance with our
        // own vtable because we support the CFSTR_BRIEFOBJECT clipboard format
        hr = CBrfData_CreateDataObj(_pidl, cidl, (LPCITEMIDLIST *)apidl, (IDataObject **)ppv);
    }
    else
    {
        // delegate to base class
        hr = CFSFolder::GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    }
    return hr;
}

// CFSBrfFolder constructor
STDAPI CFSBrfFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CBriefcase *pbf = new CBriefcase(punkOuter);
    if (pbf)
    {
        hr = pbf->Init();
        if (SUCCEEDED(hr))
        {
            hr = pbf->QueryInterface(riid, ppv);
        }
        pbf->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

const TBBUTTON c_tbBrfCase[] = {
    { 0, FSIDM_UPDATEALL,       TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, -1 },
    { 1, FSIDM_UPDATESELECTION, 0,               TBSTYLE_BUTTON, {0,0}, 0L, -1 },
    { 0,  0,                    TBSTATE_ENABLED, TBSTYLE_SEP   , {0,0}, 0L, -1 },
    };


#define BRFVIEW_EVENTS \
    SHCNE_DISKEVENTS | \
    SHCNE_ASSOCCHANGED | \
    SHCNE_GLOBALEVENTS

HRESULT CBriefcaseViewCB::OnWINDOWCREATED(DWORD pv, HWND hwndView)
{
    SHChangeNotifyEntry fsne;

    ASSERT(_pbrfstg && _hwndMain && _hMutexDelay);   // from the init call

    // view hands folder info needed to details (status, sync path)
    _pfolder->_InitDetailsInfoAndThread(_pbrfstg, _hwndMain, _hMutexDelay);

    // Register an extra SHChangeNotifyRegister for our pidl to try to catch things
    // like UpdateDir 
    fsne.pidl = _FolderPidl();
    fsne.fRecursive = FALSE;
    _uSCNRExtra = SHChangeNotifyRegister(hwndView, SHCNRF_NewDelivery | SHCNRF_ShellLevel | SHCNRF_InterruptLevel,
                                         SHCNE_DISKEVENTS, WM_DSV_FSNOTIFY, 1, &fsne);
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnWINDOWDESTROY(DWORD pv, HWND wP)
{
    _pfolder->_Free();

    // need to release pbrfstg as well
    if (_pbrfstg)
    {
        _pbrfstg->Release();
        _pbrfstg = NULL;

        _hMutexDelay = NULL;    // invalidate our alias
    }

    if (_uSCNRExtra)
    {
        SHChangeNotifyDeregister(_uSCNRExtra);
        _uSCNRExtra = 0;
    }

    return S_OK;
}

HRESULT CBriefcaseViewCB::OnMergeMenu(DWORD pv, QCMINFO *pinfo)
{
    // Merge the briefcase menu onto the menu that CDefView created.
    if (pinfo->hmenu)
    {
        HMENU hmSync = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(POPUP_BRIEFCASE));
        if (hmSync)
        {
            Shell_MergeMenus(pinfo->hmenu, hmSync, pinfo->indexMenu,
                pinfo->idCmdFirst, pinfo->idCmdLast, MM_SUBMENUSHAVEIDS);
            DestroyMenu(hmSync);
        }
    }
    
    return S_OK;
}

HRESULT CBriefcaseViewCB::_GetSelectedObjects(IDataObject **ppdtobj)
{
    IFolderView *pfv;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        hr = pfv->Items(SVGIO_SELECTION, IID_PPV_ARG(IDataObject, ppdtobj));
        pfv->Release();
    }
    return hr;
}

HRESULT CBriefcaseViewCB::OnINVOKECOMMAND(DWORD pv, UINT uID)
{
    IDataObject *pdtobj;
    
    switch (uID)
    {
    case FSIDM_UPDATEALL:
        // Update the entire briefcase
        
        if (SUCCEEDED(SHGetUIObjectFromFullPIDL(_pidlRoot, NULL, IID_PPV_ARG(IDataObject, &pdtobj))))
        {
            _pbrfstg->UpdateObject(pdtobj, _hwndMain);
            pdtobj->Release();
        }
        break;
        
    case FSIDM_UPDATESELECTION:
        // Update the selected objects
        if (SUCCEEDED(_GetSelectedObjects(&pdtobj)))
        {
            _pbrfstg->UpdateObject(pdtobj, _hwndMain);
            pdtobj->Release();
        }
        break;
        
    case FSIDM_SPLIT:
        // Split the selected objects
        if (SUCCEEDED(_GetSelectedObjects(&pdtobj)))
        {
            _pbrfstg->ReleaseObject(pdtobj, _hwndMain);
            pdtobj->Release();
        }
        break;
    }
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnGetHelpOrTooltipText(BOOL bHelp, UINT wPl, UINT cch, LPTSTR psz)
{
    LoadString(HINST_THISDLL, wPl + (bHelp ? IDS_MH_FSIDM_FIRST : IDS_TT_FSIDM_FIRST), psz, cch);
    return S_OK;
}

int CBriefcaseViewCB::_GetSelectedCount()
{
    int cItems = 0;
    IFolderView *pfv;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv))))
    {
        pfv->ItemCount(SVGIO_SELECTION, &cItems);
        pfv->Release();
    }
    return cItems;
}

HRESULT CBriefcaseViewCB::OnINITMENUPOPUP(DWORD pv, UINT idCmdFirst, UINT nIndex, HMENU hmenu)
{
    BOOL bEnabled = _GetSelectedCount() > 0;
    EnableMenuItem(hmenu, idCmdFirst+FSIDM_UPDATESELECTION, bEnabled ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hmenu, idCmdFirst+FSIDM_SPLIT, bEnabled ? MF_ENABLED : MF_GRAYED);    
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnGETBUTTONINFO(DWORD pv, TBINFO* ptbinfo)
{
    ptbinfo->cbuttons = ARRAYSIZE(c_tbBrfCase);
    ptbinfo->uFlags = TBIF_PREPEND;
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnGETBUTTONS(DWORD pv, UINT idCmdFirst, UINT wPh, TBBUTTON *ptbbutton)
{
    IShellBrowser* psb;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hr))
    {
        LRESULT iBtnOffset;
        TBADDBITMAP ab;
    
        // add the toolbar button bitmap, get it's offset
        ab.hInst = HINST_THISDLL;
        ab.nID   = IDB_BRF_TB_SMALL;        // std bitmaps
        psb->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 2, (LPARAM)&ab, &iBtnOffset);
    
        for (int i = 0; i < ARRAYSIZE(c_tbBrfCase); i++)
        {
            ptbbutton[i] = c_tbBrfCase[i];
        
            if (!(c_tbBrfCase[i].fsStyle & TBSTYLE_SEP))
            {
                ptbbutton[i].idCommand += idCmdFirst;
                ptbbutton[i].iBitmap += (int) iBtnOffset;
            }
        }
        psb->Release();
    }
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnSELCHANGE(DWORD pv, UINT idCmdFirst, UINT wPh, SFVM_SELCHANGE_DATA*lP)
{
    IShellBrowser* psb;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hr))
    {
        psb->SendControlMsg(FCW_TOOLBAR, TB_ENABLEBUTTON,
            idCmdFirst + FSIDM_UPDATESELECTION,
            (LPARAM)(_GetSelectedCount() > 0), NULL);
        psb->Release();
    }
    return E_FAIL;     // (we did not update the status area)
}

HRESULT CBriefcaseViewCB::OnQUERYFSNOTIFY(DWORD pv, SHChangeNotifyEntry *pfsne)
{
    // Register to receive global events
    pfsne->pidl = NULL;
    pfsne->fRecursive = TRUE;
    
    return NOERROR;
}

HRESULT CBriefcaseViewCB::_HandleFSNotifyForDefView(LPARAM lEvent, LPCITEMIDLIST * ppidl, LPTSTR pszBuf)
{
    HRESULT hr;
    
    switch (lEvent)
    {
    case SHCNE_RENAMEITEM:
    case SHCNE_RENAMEFOLDER:
        if (!ILIsParent(_FolderPidl(), ppidl[0], TRUE))
        {
            // move to this folder
            hr = _HandleFSNotifyForDefView(SHCNE_CREATE, &ppidl[1], pszBuf);
        }
        else if (!ILIsParent(_FolderPidl(), ppidl[1], TRUE))
        {
            // move from this folder
            hr = _HandleFSNotifyForDefView(SHCNE_DELETE, &ppidl[0], pszBuf);
        }
        else
        {
            // have the defview handle it
            _pfolder->_CachedNameIsStale(ppidl[0], TRUE);
            hr = NOERROR;
        }
        break;
        
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        _pfolder->_CachedNameIsStale(ppidl[0], TRUE);
        hr = NOERROR;
        break;
        
    default:
        hr = NOERROR;
        break;
    }
    
    return hr;
}

// Converts a shell change notify event to a briefcase storage event.
LONG NOEFromSHCNE(LPARAM lEvent)
{
    switch (lEvent)
    {
    case SHCNE_RENAMEITEM:      return NOE_RENAME;
    case SHCNE_RENAMEFOLDER:    return NOE_RENAMEFOLDER;
    case SHCNE_CREATE:          return NOE_CREATE;
    case SHCNE_MKDIR:           return NOE_CREATEFOLDER;
    case SHCNE_DELETE:          return NOE_DELETE;
    case SHCNE_RMDIR:           return NOE_DELETEFOLDER;
    case SHCNE_UPDATEITEM:      return NOE_DIRTY;
    case SHCNE_UPDATEDIR:       return NOE_DIRTYFOLDER;
    default:                    return 0;
    }
}

HRESULT CBriefcaseViewCB::OnFSNOTIFY(DWORD pv, LPCITEMIDLIST *ppidl, LPARAM lEvent)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH * 2];
    
    // we are in the process of being freed, but changenotify's can still come in because we are not freed atomically
    if (!_pbrfstg)
    {
        return S_FALSE;
    }

    if (lEvent == SHCNE_UPDATEIMAGE || lEvent == SHCNE_FREESPACE)
    {
        return S_FALSE;
    }
    
    if (ppidl && !ILIsEmpty(ppidl[0]) && SHGetPathFromIDList(ppidl[0], szPath))
    {
        UINT uFlags;
        LONG lEventNOE;
        
        if ((SHCNE_RENAMEFOLDER == lEvent) || (SHCNE_RENAMEITEM == lEvent))
        {
            ASSERT(ppidl[1]);
            ASSERT(ARRAYSIZE(szPath) >= lstrlen(szPath)*2);    // rough estimate
            
            // Tack the new name after the old name, separated by the null
            SHGetPathFromIDList(ppidl[1], &szPath[lstrlen(szPath)+1]);
        }
        
        // Tell the briefcase the path has potentially changed
        lEventNOE = NOEFromSHCNE(lEvent);
        _pbrfstg->Notify(szPath, lEventNOE, &uFlags, _hwndMain);
        
        // Was this item marked?
        if (uFlags & NF_ITEMMARKED)
        {
            // Yes; mark it stale in the expensive cache
            _pfolder->_CachedNameIsStale(ppidl[0], FALSE);
        }
        
        // Does the window need to be refreshed?
        if (uFlags & NF_REDRAWWINDOW)
        {
            // Yes
            IShellView *psv;
            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IShellView, &psv))))
            {
                psv->Refresh();
                psv->Release();
            }
        }
        
        // Did this event occur in this folder?
        if (NULL == ppidl ||
            ILIsParent(_FolderPidl(), ppidl[0], TRUE) ||
            (((SHCNE_RENAMEITEM == lEvent) || (SHCNE_RENAMEFOLDER == lEvent)) && ILIsParent(_FolderPidl(), ppidl[1], TRUE)) ||
            (SHCNE_UPDATEDIR == lEvent && ILIsEqual(_FolderPidl(), ppidl[0])))
        {
            // Yes; deal with it
            hr = _HandleFSNotifyForDefView(lEvent, ppidl, szPath);
        }
        else
        {
            // No
            hr = S_FALSE;
        }
    }
    else
    {
        // ASSERT(0);
        hr = S_FALSE;
    }
    return hr;
}

HRESULT CBriefcaseViewCB::OnQUERYCOPYHOOK(DWORD pv)
{
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnNOTIFYCOPYHOOK(DWORD pv, COPYHOOKINFO *pchi)
{
    HRESULT hr = NOERROR;
    
    // Is this a pertinent operation?
    if (FO_MOVE == pchi->wFunc ||
        FO_RENAME == pchi->wFunc ||
        FO_DELETE == pchi->wFunc)
    {
        // Yes; don't allow the briefcase root or a parent folder to get moved
        // while the briefcase is still open.  (The database is locked while
        // the briefcase is open, and will fail the move/rename operation
        // in an ugly way.)
        LPITEMIDLIST pidl = ILCreateFromPath(pchi->pszSrcFile);
        if (pidl)
        {
            // Is the folder that is being moved or renamed a parent or equal
            // of the Briefcase root?
            if (ILIsParent(pidl, _pidlRoot, FALSE) ||
                ILIsEqual(pidl, _pidlRoot))
            {
                // Yes; don't allow it until the briefcase is closed.
                int ids;
                
                if (FO_MOVE == pchi->wFunc ||
                    FO_RENAME == pchi->wFunc)
                {
                    ids = IDS_MOVEBRIEFCASE;
                }
                else
                {
                    ASSERT(FO_DELETE == pchi->wFunc);
                    ids = IDS_DELETEBRIEFCASE;
                }
                
                ShellMessageBox(HINST_THISDLL, _hwndMain,
                    MAKEINTRESOURCE(ids), NULL, MB_OK | MB_ICONINFORMATION);
                hr = IDCANCEL;
            }
            ILFree(pidl);
        }
    }
    return hr;
}

HRESULT CBriefcaseViewCB::OnINSERTITEM(DWORD pv, LPCITEMIDLIST pidl)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    
    if (SHGetPathFromIDList(pidl, szPath))
    {
        // Always hide the desktop.ini and the database file.
        LPTSTR pszName = PathFindFileName(szPath);
        
        if (0 == lstrcmpi(pszName, c_szDesktopIni) ||
            0 == lstrcmpi(pszName, _szDBName))
            hr = S_FALSE; // don't add
        else
            hr = S_OK;
    }
    else
        hr = S_OK;        // Let it be added...
    
    return hr;
}

HRESULT CBriefcaseViewCB::OnDEFVIEWMODE(DWORD pv, FOLDERVIEWMODE*lP)
{
    *lP = FVM_DETAILS;
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA * phtd)
{
    HRESULT hr;
    if (IsOS(OS_ANYSERVER))
    {
        hr = StringCchCopy(phtd->wszHelpFile, ARRAYSIZE(phtd->wszHelpFile), L"brief.chm");
    }
    else
    {
        hr = StringCchCopy(phtd->wszHelpTopic, ARRAYSIZE(phtd->wszHelpTopic), L"hcp://services/subsite?node=Unmapped/Briefcase");
    }
    return hr;
}

CBriefcaseViewCB::CBriefcaseViewCB(CBriefcase *pfolder) : CBaseShellFolderViewCB(pfolder->_pidl, BRFVIEW_EVENTS), _pfolder(pfolder)
{ 
    _pfolder->AddRef();
}

CBriefcaseViewCB::~CBriefcaseViewCB()
{
    if (_pbrfstg)
        _pbrfstg->Release();

    if (_pidlRoot)
        ILFree(_pidlRoot);

    _pfolder->Release();
}

HRESULT CBriefcaseViewCB::_InitStgForDetails()
{
    ASSERT(NULL == _pbrfstg);

    HRESULT hr = CreateBrfStgFromIDList(_FolderPidl(), _hwndMain, &_pbrfstg);
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL == _hMutexDelay);
        _pbrfstg->GetExtraInfo(NULL, GEI_DELAYHANDLE, 0, (LPARAM)&_hMutexDelay);
        ASSERT(0 == _szDBName[0]);
        _pbrfstg->GetExtraInfo(NULL, GEI_DATABASENAME, ARRAYSIZE(_szDBName), (LPARAM)_szDBName);

        TCHAR szPath[MAX_PATH];
        hr = _pbrfstg->GetExtraInfo(NULL, GEI_ROOT, (WPARAM)ARRAYSIZE(szPath), (LPARAM)szPath);
        if (SUCCEEDED(hr))
            hr = SHILCreateFromPath(szPath, &_pidlRoot, NULL);
    }
    return hr;
}

STDMETHODIMP CBriefcaseViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_WINDOWCREATED, OnWINDOWCREATED);
    HANDLE_MSG(0, SFVM_WINDOWDESTROY, OnWINDOWDESTROY);
    HANDLE_MSG(0, SFVM_MERGEMENU, OnMergeMenu);
    HANDLE_MSG(0, SFVM_INVOKECOMMAND, OnINVOKECOMMAND);
    HANDLE_MSG(TRUE , SFVM_GETHELPTEXT   , OnGetHelpOrTooltipText);
    HANDLE_MSG(FALSE, SFVM_GETTOOLTIPTEXT, OnGetHelpOrTooltipText);
    HANDLE_MSG(0, SFVM_INITMENUPOPUP, OnINITMENUPOPUP);
    HANDLE_MSG(0, SFVM_GETBUTTONINFO, OnGETBUTTONINFO);
    HANDLE_MSG(0, SFVM_GETBUTTONS, OnGETBUTTONS);
    HANDLE_MSG(0, SFVM_SELCHANGE, OnSELCHANGE);
    HANDLE_MSG(0, SFVM_QUERYFSNOTIFY, OnQUERYFSNOTIFY);
    HANDLE_MSG(0, SFVM_FSNOTIFY, OnFSNOTIFY);
    HANDLE_MSG(0, SFVM_QUERYCOPYHOOK, OnQUERYCOPYHOOK);
    HANDLE_MSG(0, SFVM_NOTIFYCOPYHOOK, OnNOTIFYCOPYHOOK);
    HANDLE_MSG(0, SFVM_INSERTITEM, OnINSERTITEM);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDEFVIEWMODE);
    HANDLE_MSG(0, SFVM_ADDPROPERTYPAGES, SFVCB_OnAddPropertyPages);
    HANDLE_MSG(0, SFVM_GETHELPTOPIC, OnGetHelpTopic);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);
    HANDLE_MSG(0, SFVM_DELAYWINDOWCREATE, OnDELAYWINDOWCREATE);

    default:
        return E_FAIL;
    }

    return NOERROR;
}


STDAPI CreateBrfStgFromPath(LPCTSTR pszPath, HWND hwnd, IBriefcaseStg **ppbs)
{
    IBriefcaseStg *pbrfstg;
    HRESULT hr = CoCreateInstance(CLSID_Briefcase, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBriefcaseStg, &pbrfstg));
    if (SUCCEEDED(hr))
    {
        hr = pbrfstg->Initialize(pszPath, hwnd);
        if (SUCCEEDED(hr))
        {
            hr = pbrfstg->QueryInterface(IID_PPV_ARG(IBriefcaseStg, ppbs));
        }
        pbrfstg->Release();
    }
    return hr;
}

STDAPI CreateBrfStgFromIDList(LPCITEMIDLIST pidl, HWND hwnd, IBriefcaseStg **ppbs)
{
    HRESULT hr = E_FAIL;
    
    // Create an instance of IBriefcaseStg
    TCHAR szFolder[MAX_PATH];
    if (SHGetPathFromIDList(pidl, szFolder))
    {
        hr = CreateBrfStgFromPath(szFolder, hwnd, ppbs);
    }
    return hr;
}

HRESULT CBriefcaseViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL | SFVMWVL_FILES;
    return S_OK;
}

HRESULT CBriefcaseViewCB::_OnUpdate(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CBriefcaseViewCB* pThis = (CBriefcaseViewCB*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = S_OK;

    if (!psiItemArray)
    {
        IFolderView *pfv;
        hr = IUnknown_QueryService(pThis->_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
        if (SUCCEEDED(hr))
        {
            hr = pfv->Items(SVGIO_ALLVIEW, IID_PPV_ARG(IDataObject, &pdo));
            pfv->Release();
        }
    }
    else
    {
        hr = psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo));
    }

    if (SUCCEEDED(hr))
    {
        hr = SHInvokeCommandOnDataObject(pThis->_hwndMain, NULL, pdo, 0, "update");
        pdo->Release();
    }

    return hr;
}

const WVTASKITEM c_BriefcaseTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_BRIEFCASE, IDS_HEADER_BRIEFCASE_TT);
const WVTASKITEM c_BriefcaseTaskList[] =
{
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL, L"shell32.dll", IDS_TASK_UPDATE_ALL, IDS_TASK_UPDATE_ITEM, IDS_TASK_UPDATE_ITEM, IDS_TASK_UPDATE_ITEMS, IDS_TASK_UPDATE_ITEM_TT, IDI_TASK_UPDATEITEMS, NULL, CBriefcaseViewCB::_OnUpdate),
};

HRESULT CBriefcaseViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    Create_IUIElement(&c_BriefcaseTaskHeader, &(pData->pSpecialTaskHeader));

    return S_OK;
}

HRESULT CBriefcaseViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    Create_IEnumUICommand((IUnknown*)(void*)this, c_BriefcaseTaskList, ARRAYSIZE(c_BriefcaseTaskList), &pTasks->penumSpecialTasks);

    return S_OK;
}

HRESULT CBriefcaseViewCB::OnDELAYWINDOWCREATE(DWORD pv, HWND hwnd)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];

    _pfolder->_GetPath(szPath, ARRAYSIZE(szPath));
    if (!PathAppend(szPath, c_szDesktopIni))
    {
        hr = E_FAIL;
    }
    else
    {
        BOOL bRunWizard = GetPrivateProfileInt(STRINI_CLASSINFO, TEXT("RunWizard"), 0, szPath);    
        // Run the wizard?
        if (bRunWizard)
        {
            // work around old bug where FILE_ATTRIBUTE_READONLY was set
            SetFileAttributes(szPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

            // Delete the .ini entry
            WritePrivateProfileString(STRINI_CLASSINFO, TEXT("RunWizard"), NULL, szPath);

            SHRunDLLThread(hwnd, TEXT("SYNCUI.DLL,Briefcase_Intro"), SW_SHOW);
        }
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cdburn.h ===
#ifndef __CDBURN_H__
#define __CDBURN_H__


#define INVALID_JOLIETNAME_CHARS L"\\/:*?|<>;"

EXTERN_C const CLSID CLSID_StagingFolder;

HRESULT CDBurn_GetCDInfo(LPCTSTR pszVolume, DWORD *pdwDriveCapabilities, DWORD *pdwMediaCapabilities);

HRESULT CDBurn_OnDeviceChange(BOOL fAdd, LPCWSTR pszDrive);
HRESULT CDBurn_OnMediaChange(BOOL fInsert, LPCWSTR pszDrive);
HRESULT CDBurn_OnEject(HWND hwnd, INT iDrive);

HRESULT CDBurn_GetExtensionObject(DWORD dwType, IDataObject *pdo, REFIID riid, void **ppv);
STDAPI CheckStagingArea();
STDAPI CDBurn_GetRecorderDriveLetter(LPWSTR pszDrive, UINT cch);
void CDBurn_GetUDFState(BOOL *pfUDF);


#endif // __CDBURN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cdmedia.h ===
// karencar
// file for cd burning help ids

#define CDBURN_HELPFILE         TEXT("cdmedia.hlp")

#define IDH_CDMEDIA_ENABLERECORDING      	 1001
#define IDH_CDMEDIA_STOREDISCIMAGE         	 1010
#define IDH_CDMEDIA_WRITESPEED             	 1020
#define IDH_CDMEDIA_EJECT                	 1030
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\category.h ===
#ifndef CATEGORY_H
#define CATEGORY_H

#define BEGIN_CATEGORY_LIST(name)   const CATLIST name[] = {
#define CATEGORY_ENTRY_GUID(guid)  {(const GUID*)&guid, (const SHCOLUMNID*)NULL},
#define CATEGORY_ENTRY_SCIDMAP(scid, guid)  {(const GUID*)&guid, (const SHCOLUMNID*)&scid},
#define END_CATEGORY_LIST()     {(const GUID*)&GUID_NULL, (const SHCOLUMNID*)NULL}};

STDAPI CCategoryProvider_Create(const GUID* pguid, const SHCOLUMNID* pscid, HKEY hkey, const CATLIST* pcl, IShellFolder* psf, REFIID riid, void **ppv);
STDAPI CDetailCategorizer_Create(const SHCOLUMNID& pscid, IShellFolder2* psf2, REFIID riid, void **ppv);
STDAPI CSizeCategorizer_Create(IShellFolder2* psf2, REFIID riid, void **ppv);
STDAPI CTimeCategorizer_Create(IShellFolder2* psf2, const SHCOLUMNID* pscid, REFIID riid, void **ppv);
STDAPI CAlphaCategorizer_Create(IShellFolder2* psf2, REFIID riid, void **ppv);

EXTERN_C const GUID CLSID_DetailCategorizer;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\category.cpp ===
#include "shellprv.h"
#include "category.h"
#include "prop.h"
#include "ids.h"
#include "clsobj.h"
#include "comcat.h" // for IEnumGUID
#include "ole2dup.h"

#define GROUPID_UNSPECIFIED (-10)
#define GROUPID_FOLDER      (-11)
#define GROUPID_OTHER       (-12)

#define STRINGID_FROM_GROUPID(id)  ((id) == GROUPID_UNSPECIFIED)? IDS_UNSPECIFIED : (((id) == GROUPID_FOLDER)?IDS_GROUPFOLDERS: IDS_GROUPOTHERCHAR)

typedef struct tagCATCACHE
{
    GUID guid;
    SHCOLUMNID scid;
    IUnknown* punk;
} CATCACHE;

// {3E373E22-DA99-4cb7-A886-754EAE984CB4}
static const GUID CLSID_DetailCategorizer = 
{ 0x3e373e22, 0xda99, 0x4cb7, { 0xa8, 0x86, 0x75, 0x4e, 0xae, 0x98, 0x4c, 0xb4 } };



class CTimeCategorizer : public ICategorizer,
                         public IShellExtInit
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

    CTimeCategorizer(const SHCOLUMNID* pscid, IShellFolder2* psf);
    CTimeCategorizer();
private:
    ~CTimeCategorizer();
    long _cRef;
    IShellFolder2* _psf;
    SHCOLUMNID     _scid;
};

class CSizeCategorizer : public ICategorizer,
                         public IShellExtInit
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

    CSizeCategorizer(IShellFolder2* psf);
    CSizeCategorizer(BOOL fLarge);
private:
    ~CSizeCategorizer();
    long _cRef;
    IShellFolder2* _psf;
    BOOL _fLarge;
};

class CDriveTypeCategorizer : public ICategorizer,
                              public IShellExtInit
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

    CDriveTypeCategorizer(IShellFolder2* psf);
    CDriveTypeCategorizer();
private:
    ~CDriveTypeCategorizer();
    long _cRef;
    IShellFolder2* _psf;
};

class CAlphaCategorizer : public ICategorizer
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    CAlphaCategorizer(IShellFolder2* psf);
private:
    ~CAlphaCategorizer();
    long _cRef;
    IShellFolder2* _psf;
};

class CFreeSpaceCategorizer : public ICategorizer,
                              public IShellExtInit
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

    CFreeSpaceCategorizer();
private:
    ~CFreeSpaceCategorizer();
    long _cRef;
    IShellFolder2* _psf;
};


class CDetailCategorizer : public ICategorizer
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    CDetailCategorizer(IShellFolder2* psf, const SHCOLUMNID& scid);
private:
    ~CDetailCategorizer();
    long _cRef;
    IShellFolder2*  _psf;
    SHCOLUMNID      _scid;
    HHASHTABLE      _hash;
    HDPA            _hdpaKeys;
};


class CEnumCategoryGUID : public IEnumGUID
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; }
    STDMETHODIMP Reset()    { _iIndex = 0; return S_OK;}
    STDMETHODIMP Clone(IEnumGUID **ppenum) { return E_NOTIMPL; };

    CEnumCategoryGUID(HDSA hdsa);
private:

    long            _cRef;
    HDSA            _hda;
    int             _iIndex;
};

CEnumCategoryGUID::CEnumCategoryGUID(HDSA hda): _cRef(1)
{
    _hda = hda;
}

HRESULT CEnumCategoryGUID::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CEnumCategoryGUID, IEnumGUID),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CEnumCategoryGUID::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CEnumCategoryGUID::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CEnumCategoryGUID::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;
    if (celt > 1)
        return E_INVALIDARG;

    if (_hda == NULL)
        return hr;

    while (hr != S_OK &&
           _iIndex < DSA_GetItemCount(_hda))
    {
        CATCACHE* pcat = (CATCACHE*)DSA_GetItemPtr(_hda, _iIndex);

        // Is this a scid map entry instead of an external categorizer?
        if (pcat->scid.fmtid == GUID_NULL)
        {
            // Nope. then we can enum it.
            if (pceltFetched)
                *pceltFetched = 1;

            *rgelt = pcat->guid;

            hr = S_OK;
        }
        _iIndex++;
    }

    return hr;

}

class CCategoryProvider : public ICategoryProvider, public IDefCategoryProvider
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategoryProvider
    STDMETHODIMP CanCategorizeOnSCID(SHCOLUMNID* pscid);
    STDMETHODIMP GetDefaultCategory(GUID* pguid, SHCOLUMNID* pscid);
    STDMETHODIMP GetCategoryForSCID(SHCOLUMNID* pscid, GUID* pguid);
    STDMETHODIMP EnumCategories(IEnumGUID** penum);
    STDMETHODIMP GetCategoryName(GUID* pguid, LPWSTR pszName, UINT cch);
    STDMETHODIMP CreateCategory(GUID* pguid, REFIID riid, void** ppv);

    // IDefCategoryProvider
    STDMETHODIMP Initialize(const GUID* pguid, const SHCOLUMNID* pscid, const SHCOLUMNID* pscidExlude, HKEY hkey, const CATLIST* pcl, IShellFolder* psf);

    CCategoryProvider();
private:
    ~CCategoryProvider();
    BOOL            _BuildCategoryList(HKEY hkey, const CATLIST* pcl);
    friend int      DestroyCache(void *pv, void *unused);
    HRESULT CreateInstance(GUID* pguid, REFIID riid, void** ppv);


    long            _cRef;
    LPITEMIDLIST    _pidlFolder;
    IShellFolder2*  _psf;
    HDSA            _hdaCat;

    GUID            _guidDefault;
    SHCOLUMNID      _scidDefault;
    HDSA            _hdaExcludeSCIDs;

};

STDAPI CCategoryProvider_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CCategoryProvider* p = new CCategoryProvider();
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}


BOOL CCategoryProvider::_BuildCategoryList(HKEY hkey, const CATLIST* pcl)
{
    int i = 0;
    _hdaCat = DSA_Create(sizeof(CATCACHE), 3);

    if (!_hdaCat)
        return FALSE;

    // Enumerate static
    while(!IsEqualGUID(*pcl[i].pguid, GUID_NULL))
    {
        CATCACHE cc = {0};
        cc.guid = *pcl[i].pguid;
        if (pcl[i].pscid)
        {
            cc.scid = *pcl[i].pscid;
        }

        DSA_AppendItem(_hdaCat, (void*)&cc);
        i++;
    }

    // Enumerate hkey
    TCHAR szHandlerCLSID[GUIDSTR_MAX];
    int iHandler = 0;

    while (ERROR_SUCCESS == RegEnumKey(hkey, iHandler++, szHandlerCLSID, ARRAYSIZE(szHandlerCLSID)))
    {
        CLSID clsid;
        if (SUCCEEDED(SHCLSIDFromString(szHandlerCLSID, &clsid)))
        {
            CATCACHE cc = {0};
            cc.guid = clsid;

            DSA_AppendItem(_hdaCat, (void*)&cc);
            i++;
        }
    }

    return TRUE;
}


CCategoryProvider::CCategoryProvider() : _cRef(1)
{
    DllAddRef();
}

int DestroyCache(void *pv, void *unused)
{
    CATCACHE* pcat = (CATCACHE*)pv;
    ATOMICRELEASE(pcat->punk);
    return 1;
}

CCategoryProvider::~CCategoryProvider()
{
    ATOMICRELEASE(_psf);
    ILFree(_pidlFolder);
    if (_hdaExcludeSCIDs)
    {
        DSA_Destroy(_hdaExcludeSCIDs);
    }

    if (_hdaCat)
    {
        DSA_DestroyCallback(_hdaCat, DestroyCache, NULL);
    }
    DllRelease();
}


HRESULT CCategoryProvider::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CCategoryProvider, IDefCategoryProvider),
        QITABENT(CCategoryProvider, ICategoryProvider),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CCategoryProvider::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CCategoryProvider::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CCategoryProvider::Initialize(const GUID* pguid, const SHCOLUMNID* pscid, const SHCOLUMNID* pscidExclude, HKEY hkey, const CATLIST* pcl, IShellFolder* psf)
{
    if (!psf)
        return E_INVALIDARG;

    HRESULT hr = SHGetIDListFromUnk(psf, &_pidlFolder);

    if (SUCCEEDED(hr))
    {
        if (pcl && !_BuildCategoryList(hkey, pcl))
            return E_OUTOFMEMORY;

        if (pguid)
            _guidDefault = *pguid;

        if (pscid)
            _scidDefault = *pscid;

        if (pscidExclude)
        {
            _hdaExcludeSCIDs = DSA_Create(sizeof(SHCOLUMNID), 3);
            if (_hdaExcludeSCIDs)
            {
                int i = 0;
                while(pscidExclude[i].fmtid != GUID_NULL)
                {
                    DSA_AppendItem(_hdaExcludeSCIDs, (void*)&pscidExclude[i]);
                    i++;
                }

            }
        }

        hr = psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf));
    }

    return hr;
}

STDMETHODIMP CCategoryProvider::CanCategorizeOnSCID(SHCOLUMNID* pscid)
{
    if (_hdaExcludeSCIDs)
    {
        for (int i=0; i < DSA_GetItemCount(_hdaExcludeSCIDs); i++)
        {
            SHCOLUMNID* pscidExclude = (SHCOLUMNID*)DSA_GetItemPtr(_hdaExcludeSCIDs, i);
            if (IsEqualSCID(*pscidExclude, *pscid))
                return S_FALSE;
        }

    }
    return S_OK;
}

STDMETHODIMP CCategoryProvider::GetDefaultCategory(GUID* pguid, SHCOLUMNID* pscid)
{
    *pguid = _guidDefault;
    *pscid = _scidDefault;

    if (_guidDefault == GUID_NULL && _scidDefault.fmtid == GUID_NULL)
        return S_FALSE;

    return S_OK;
}

STDMETHODIMP CCategoryProvider::GetCategoryForSCID(SHCOLUMNID* pscid, GUID* pguid)
{
    HRESULT hr = S_FALSE;
    if (_hdaCat == NULL || pscid == NULL)
        return hr;

    int c = DSA_GetItemCount(_hdaCat);
    for (int i = 0; i < c; i++)
    {
        CATCACHE* pcc = (CATCACHE*)DSA_GetItemPtr(_hdaCat, i);
        ASSERT(pcc != NULL);

        if (IsEqualSCID(pcc->scid, *pscid))
        {
            *pguid = pcc->guid;
            hr = S_OK;
            break;
        }
    }

    return hr;
}


STDMETHODIMP CCategoryProvider::EnumCategories(IEnumGUID** penum)
{
    HRESULT hr = E_NOINTERFACE;
    if (_hdaCat)
    {
        *penum = (IEnumGUID*)new CEnumCategoryGUID(_hdaCat);

        if (!*penum)
            hr = E_OUTOFMEMORY;

        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CCategoryProvider::GetCategoryName(GUID* pguid, LPWSTR pszName, UINT cch)
{
    ICategorizer* pcat;
    HRESULT hr = CreateCategory(pguid, IID_PPV_ARG(ICategorizer, &pcat));
    
    if (SUCCEEDED(hr))
    {
        hr = pcat->GetDescription(pszName, cch);
        pcat->Release();
    }

    return hr;

}

HRESULT CCategoryProvider::CreateInstance(GUID* pguid, REFIID riid, void** ppv)
{
    IShellExtInit* psei;
    // These come from HKCR hence must go through approval
    HRESULT hr = SHExtCoCreateInstance(NULL, pguid, NULL, IID_PPV_ARG(IShellExtInit, &psei));
    if (SUCCEEDED(hr))
    {
        psei->Initialize(_pidlFolder, NULL, NULL);
        hr = psei->QueryInterface(riid, ppv);
        psei->Release();
    }

    return hr;
}


STDMETHODIMP CCategoryProvider::CreateCategory(GUID* pguid, REFIID riid, void** ppv)
{
    HRESULT hr = E_NOINTERFACE;
    if (_hdaCat != NULL)
    {
        int c = DSA_GetItemCount(_hdaCat);
        for (int i = 0; i < c; i++)
        {
            CATCACHE* pcc = (CATCACHE*)DSA_GetItemPtr(_hdaCat, i);
            ASSERT(pcc != NULL);

            if (IsEqualGUID(pcc->guid, *pguid))
            {
                if (!pcc->punk)
                {
                    hr = CreateInstance(pguid, IID_PPV_ARG(IUnknown, &pcc->punk));
                }

                if (pcc->punk)
                {
                    hr = pcc->punk->QueryInterface(riid, ppv);
                }
                break;
            }
        }
    }

    if (FAILED(hr))
    {
        // Not in the cache? Just try a create
        hr = CreateInstance(pguid, riid, ppv);
    }

    return hr;
}

STDAPI CCategoryProvider_Create(const GUID* pguid, const SHCOLUMNID* pscid, HKEY hkey, const CATLIST* pcl, IShellFolder* psf, REFIID riid, void **ppv)
{
    HRESULT hr;
    CCategoryProvider *pdext = new CCategoryProvider();
    if (pdext)
    {
        hr = pdext->Initialize(pguid, pscid, NULL, hkey, pcl, psf);
        if (SUCCEEDED(hr))
            hr = pdext->QueryInterface(riid, ppv);

        pdext->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


/////////////////////////////////////////////////////////
//  Time Categorizer

STDAPI CTimeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CTimeCategorizer* p = new CTimeCategorizer();
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

STDAPI CTimeCategorizer_Create(IShellFolder2* psf2, const SHCOLUMNID* pscid, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CTimeCategorizer* p = new CTimeCategorizer(pscid, psf2);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}


CTimeCategorizer::CTimeCategorizer(const SHCOLUMNID* pscid, IShellFolder2* psf) : _cRef(1)
{
    _psf = psf;
    ASSERT(psf);
    psf->AddRef();
    _scid = *pscid;
}

CTimeCategorizer::CTimeCategorizer() : _cRef(1)
{
    _scid = SCID_WRITETIME;
}

CTimeCategorizer::~CTimeCategorizer()
{
    ATOMICRELEASE(_psf);

}

HRESULT CTimeCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CTimeCategorizer, ICategorizer),
        QITABENT(CTimeCategorizer, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CTimeCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTimeCategorizer::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CTimeCategorizer::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)
{
    ATOMICRELEASE(_psf);
    return SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidlFolder, &_psf));
}

HRESULT CTimeCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_GROUPBYTIME, pszDesc, cch);
    return S_OK;
}



static const int mpcdymoAccum[13] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };

int GetDaysForMonth(int yr, int mo)
{
    int cdy;

    if (yr == 1752 && mo == 9)
        return 19;

    cdy = mpcdymoAccum[mo] - mpcdymoAccum[mo - 1];
    if (mo == 2 && (yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
        cdy++;

    return cdy;
}

int GetDaysForLastMonth(int year, int month)
{
    if (month == 1)
    {
        year--;
        month = 12;
    }
    else
        month--;

    return GetDaysForMonth(year, month);

}

HRESULT CTimeCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds)
{
    SYSTEMTIME stCur;
    GetLocalTime(&stCur);

    for (UINT i = 0; i < cidl; i++)
    {
        FILETIME ft;

        // Get the time data
        if (SUCCEEDED(GetDateProperty(_psf, apidl[i], &_scid, &ft)))
        {
            // Convert it to a usable format
            SYSTEMTIME stFile;
            FileTimeToLocalFileTime(&ft, &ft);
            FileTimeToSystemTime(&ft, &stFile);

            if (stFile.wYear == stCur.wYear)
            {
                if (stFile.wMonth > stCur.wMonth)
                {
                    if (stFile.wMonth == stCur.wMonth + 1)
                    {
                        rgCategoryIds[i] = IDS_NEXTMONTH;
                    }
                    else
                    {
                        rgCategoryIds[i] = IDS_LATERTHISYEAR;
                    }
                }
                else if (stFile.wMonth == stCur.wMonth)
                {
                    if (stFile.wDay == stCur.wDay + 1)
                    {
                        rgCategoryIds[i] = IDS_TOMORROW;
                    }
                    else if (stFile.wDay == stCur.wDay + 2)
                    {
                        rgCategoryIds[i] = IDS_TWODAYSFROMNOW;
                    }
                    else if (stFile.wDay == stCur.wDay)
                    {
                        rgCategoryIds[i] = IDS_TODAY;
                    }
                    else if (stFile.wDay == stCur.wDay - 1)
                    {
                        rgCategoryIds[i] = IDS_YESTERDAY;
                    }
                    else if (stFile.wDayOfWeek < stCur.wDayOfWeek && 
                             stFile.wDay < stCur.wDay &&
                             stCur.wDay - stCur.wDayOfWeek > 0 &&
                             stFile.wDay >= stCur.wDay - stCur.wDayOfWeek)
                    {
                        rgCategoryIds[i] = IDS_EARLIERTHISWEEK;
                    }
                    else if (stFile.wDayOfWeek > stCur.wDayOfWeek && 
                             stFile.wDay > stCur.wDay &&
                             stFile.wDay <= stCur.wDay + (7 - stCur.wDayOfWeek))
                    {
                        rgCategoryIds[i] = IDS_LATERTHISWEEK;
                    }
                    else if (stFile.wDay > stCur.wDay)
                    {
                        rgCategoryIds[i] = IDS_LATERTHISMONTH;
                    }
                    else
                    {
                        int fileDays = GetDaysForLastMonth(stFile.wYear, stFile.wMonth - 1) + stFile.wDay;
                        int curDays = GetDaysForLastMonth(stCur.wYear, stCur.wMonth - 1) + stCur.wDay;

                        if (fileDays < (curDays - stCur.wDayOfWeek) && 
                            fileDays > (curDays - stCur.wDayOfWeek - 7))
                        {
                            rgCategoryIds[i] = IDS_LASTWEEK;
                        }
                        else if (fileDays < (curDays - stCur.wDayOfWeek - 7) && 
                                 fileDays > (curDays - stCur.wDayOfWeek - 14))
                        {
                            rgCategoryIds[i] = IDS_TWOWEEKSAGO;
                        }
                        else
                        {
                            rgCategoryIds[i] = IDS_EARLIERTHISMONTH;
                        }
                    }
                }
                else if (stFile.wMonth == stCur.wMonth - 1 || 
                         (stFile.wMonth == 12 && 
                          stCur.wMonth == 1))
                {
                    rgCategoryIds[i] = IDS_LASTMONTH;
                }
                else if (stFile.wMonth == stCur.wMonth - 2 || 
                    (stFile.wMonth == 12 && stCur.wMonth == 2) || 
                    (stFile.wMonth == 11 && stCur.wMonth == 1))
                {
                    rgCategoryIds[i] = IDS_TWOMONTHSAGO;
                }
                else
                {
                    rgCategoryIds[i] = IDS_EARLIERTHISYEAR;
                }
            }
            else if (stFile.wYear == stCur.wYear - 1)
            {
                rgCategoryIds[i] = IDS_LASTYEAR;
            }
            else if (stFile.wYear == stCur.wYear - 2)
            {
                rgCategoryIds[i] = IDS_TWOYEARSAGO;
            }
            else if (stFile.wYear < stCur.wYear - 2)
            {
                rgCategoryIds[i] = IDS_LONGTIMEAGO;
            }
            else if (stFile.wYear == stCur.wYear + 1)
            {
                rgCategoryIds[i] = IDS_NEXTYEAR;
            }
            else if (stFile.wYear > stCur.wYear + 2)
            {
                rgCategoryIds[i] = IDS_SOMETIMETHISMILLENNIA;
            }
            else if (stFile.wYear > (stCur.wYear / 1000) * 1000 + 1000) // 2050 / 1000 = 2. 2 * 1000 = 2000. 2000 + 1000 = 3000 i.e. next millennium
            {
                rgCategoryIds[i] = IDS_SOMEFUTUREDATE;
            }
        }
        else
        {
            rgCategoryIds[i] = IDS_UNSPECIFIED;
        }
    }

    return S_OK;
}

HRESULT CTimeCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    LoadString(HINST_THISDLL, dwCategoryId, pci->wszName, ARRAYSIZE(pci->wszName));
    return S_OK;
}

HRESULT CTimeCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
        return ResultFromShort(0);
    else if (dwCategoryId1 == IDS_GROUPFOLDERS)
        return ResultFromShort(-1);
    else if (dwCategoryId2 == IDS_GROUPFOLDERS)
        return ResultFromShort(1);
    else if (dwCategoryId1 < dwCategoryId2)
        return ResultFromShort(-1);
    else
        return ResultFromShort(1);
}



/////////////////////////////////////////////////////////
//  Size Categorizer

STDAPI CDriveSizeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CSizeCategorizer* p = new CSizeCategorizer(TRUE);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

STDAPI CSizeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CSizeCategorizer* p = new CSizeCategorizer(FALSE);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

STDAPI CSizeCategorizer_Create(IShellFolder2* psf2, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CSizeCategorizer* p = new CSizeCategorizer(psf2);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

CSizeCategorizer::CSizeCategorizer(IShellFolder2* psf) : _cRef(1)
{
    _psf = psf;
    ASSERT(psf);
    psf->AddRef();
}

CSizeCategorizer::CSizeCategorizer(BOOL fLarge) : _cRef(1), _fLarge(fLarge)
{
}

CSizeCategorizer::~CSizeCategorizer()
{
    ATOMICRELEASE(_psf);

}

HRESULT CSizeCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSizeCategorizer, ICategorizer),
        QITABENT(CSizeCategorizer, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CSizeCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CSizeCategorizer::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CSizeCategorizer::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)
{
    ATOMICRELEASE(_psf);
    return SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidlFolder, &_psf));
}

HRESULT CSizeCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_GROUPBYSIZE, pszDesc, cch);
    return S_OK;
}

const static ULONGLONG s_rgSizesSmall[] = 
{
    // 130mb      16mb         1mb        100k         10l
    134217728,   16777216,    1048576,    131072,     32768,     0
};

const static ULONGLONG s_rgSizesLarge[] = 
{
    // 80gig      25gig        10gig        2gig        500mb
    80000000000, 25000000000, 10000000000, 2000000000, 500000000, 0
};


HRESULT CSizeCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds)
{
    if (_psf == NULL)
        return E_ACCESSDENIED;  // Not initialized yet.

    for (UINT i = 0; i < cidl; i++)
    {
        const ULONGLONG* pll = _fLarge? s_rgSizesLarge : s_rgSizesSmall;

        // Get the size data
        ULONGLONG ullSize;
        if (SUCCEEDED(GetLongProperty(_psf, apidl[i], _fLarge?&SCID_CAPACITY:&SCID_SIZE, &ullSize)))
        {
            if (ullSize >= pll[0])      
                rgCategoryIds[i] = IDS_GIGANTIC;
            if (ullSize < pll[0])
                rgCategoryIds[i] = IDS_HUGE;
            if (ullSize < pll[1])        // Under 16mb
                rgCategoryIds[i] = IDS_LARGE;
            if (ullSize < pll[2])         // Under 1mb
                rgCategoryIds[i] = IDS_MEDIUM;
            if (ullSize < pll[3])          // Under 100k
                rgCategoryIds[i] = IDS_SMALL;
            if (ullSize < pll[4])           // Under 10k
                rgCategoryIds[i] = IDS_TINY;
            if (ullSize == pll[5])              // Zero sized files
            {
                if (SHGetAttributes(_psf, apidl[i], SFGAO_FOLDER))
                {
                    rgCategoryIds[i] = IDS_FOLDERS;
                }
                else
                {
                    rgCategoryIds[i] = IDS_ZERO;
                }
            }
        }
        else
        {
            rgCategoryIds[i] = IDS_UNSPECIFIED;
        }        
    }

    return S_OK;
}

HRESULT CSizeCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    LoadString(HINST_THISDLL, dwCategoryId, pci->wszName, ARRAYSIZE(pci->wszName));
    return S_OK;
}

HRESULT CSizeCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
        return ResultFromShort(0);
    else if (dwCategoryId1 == IDS_GROUPFOLDERS)
        return ResultFromShort(-1);
    else if (dwCategoryId2 == IDS_GROUPFOLDERS)
        return ResultFromShort(1);
    else if (dwCategoryId1 < dwCategoryId2)
        return ResultFromShort(-1);
    else
        return ResultFromShort(1);
}

/////////////////////////////////////////////////////////
//  Type Categorizer

STDAPI CDriveTypeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    CDriveTypeCategorizer *p = new CDriveTypeCategorizer();
    if (!p)
        return E_OUTOFMEMORY;

    HRESULT hr = p->QueryInterface(riid, ppv);
    p->Release();
    return hr;
}

CDriveTypeCategorizer::CDriveTypeCategorizer(IShellFolder2* psf) : 
    _cRef(1)
{
    _psf = psf;
    ASSERT(psf);
    psf->AddRef();
}

CDriveTypeCategorizer::CDriveTypeCategorizer() : 
    _cRef(1)
{
}

CDriveTypeCategorizer::~CDriveTypeCategorizer()
{
    ATOMICRELEASE(_psf);
}

HRESULT CDriveTypeCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDriveTypeCategorizer, ICategorizer),
        QITABENT(CDriveTypeCategorizer, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CDriveTypeCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDriveTypeCategorizer::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDriveTypeCategorizer::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)
{
    ATOMICRELEASE(_psf);
    return SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidlFolder, &_psf));
}

HRESULT CDriveTypeCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_GROUPBYDRIVETYPE, pszDesc, cch);
    return S_OK;
}

const struct { DWORD dwDescriptionId; UINT uIDGroup; } c_drives_mapping[] = 
{
    { SHDID_COMPUTER_FIXED     , IDS_DRIVES_FIXED_GROUP     },
    { SHDID_COMPUTER_DRIVE35   , IDS_DRIVES_REMOVABLE_GROUP },
    { SHDID_COMPUTER_REMOVABLE , IDS_DRIVES_REMOVABLE_GROUP },
    { SHDID_COMPUTER_CDROM     , IDS_DRIVES_REMOVABLE_GROUP },
    { SHDID_COMPUTER_NETDRIVE  , IDS_DRIVES_NETDRIVE_GROUP  },
    { SHDID_COMPUTER_OTHER     , IDS_DRIVES_OTHER_GROUP     },
    { SHDID_COMPUTER_DRIVE525  , IDS_DRIVES_REMOVABLE_GROUP },
    { SHDID_COMPUTER_RAMDISK   , IDS_DRIVES_OTHER_GROUP     },
    { SHDID_COMPUTER_IMAGING   , IDS_DRIVES_IMAGING_GROUP   },
    { SHDID_COMPUTER_AUDIO     , IDS_DRIVES_AUDIO_GROUP     },
    { SHDID_COMPUTER_SHAREDDOCS, IDS_DRIVES_SHAREDDOCS_GROUP},
};

HRESULT CDriveTypeCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds)
{
    HRESULT hr;

    if (_psf == NULL)
    {
        hr = E_ACCESSDENIED;  // Not initialized yet.
    }
    else
    {
        for (UINT i = 0; i < cidl; i++)
        {
            rgCategoryIds[i] = IDS_DRIVES_OTHER_GROUP;

            VARIANT v;
            // Get the type data
            hr = _psf->GetDetailsEx(apidl[i], &SCID_DESCRIPTIONID, &v);
            if (SUCCEEDED(hr))
            {
                SHDESCRIPTIONID did;
                if (VariantToBuffer(&v, &did, sizeof(did)))
                {
                    for (int j = 0; j < ARRAYSIZE(c_drives_mapping); j++)
                    {
                        if (did.dwDescriptionId == c_drives_mapping[j].dwDescriptionId)
                        {
                            rgCategoryIds[i] = c_drives_mapping[j].uIDGroup;
                            break;
                        }
                    }
                }
                VariantClear(&v);
            }            
        }

        hr = S_OK;
    }

    return hr;
}

HRESULT CDriveTypeCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    LoadString(HINST_THISDLL, dwCategoryId, pci->wszName, ARRAYSIZE(pci->wszName));
    return S_OK;
}

HRESULT CDriveTypeCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
        return ResultFromShort(0);
    else if (dwCategoryId1 < dwCategoryId2)
        return ResultFromShort(-1);
    else
        return ResultFromShort(1);
}

/////////////////////////////////////////////////////////
//  FreeSpace Categorizer

CFreeSpaceCategorizer::CFreeSpaceCategorizer() : _cRef(1)
{
}

CFreeSpaceCategorizer::~CFreeSpaceCategorizer()
{
    ATOMICRELEASE(_psf);

}

HRESULT CFreeSpaceCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CFreeSpaceCategorizer, ICategorizer),
        QITABENT(CFreeSpaceCategorizer, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CFreeSpaceCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFreeSpaceCategorizer::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CFreeSpaceCategorizer::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)
{
    ATOMICRELEASE(_psf);
    return SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidlFolder, &_psf));
}

HRESULT CFreeSpaceCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_GROUPBYFREESPACE, pszDesc, cch);
    return S_OK;
}

HRESULT CFreeSpaceCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST* apidl, DWORD* rgCategoryIds)
{
    if (_psf == NULL)
        return E_ACCESSDENIED;  // Not initialized yet.

    for (UINT i = 0; i < cidl; i++)
    {
        rgCategoryIds[i] = IDS_UNSPECIFIED;

        // Get the total size and free space
        ULONGLONG ullSize;
        if (SUCCEEDED(GetLongProperty(_psf, apidl[i], &SCID_CAPACITY, &ullSize)))
        {
            ULONGLONG ullFree;
            if (SUCCEEDED(GetLongProperty(_psf, apidl[i], &SCID_FREESPACE, &ullFree)))
            {
                // Prevent divide by zero
                if (ullSize == 0)
                {
                    rgCategoryIds[i] = IDS_UNSPECIFIED;
                }
                else
                {
                    // Turning this into a percent. DWORD cast is ok.
                    rgCategoryIds[i] = (static_cast<DWORD>((ullFree * 100) / ullSize)  / 10) * 10;
                }
            }
        }
    }

    return S_OK;
}

HRESULT CFreeSpaceCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    if (dwCategoryId == IDS_UNSPECIFIED)
    {
        LoadString(HINST_THISDLL, IDS_UNSPECIFIED, pci->wszName, ARRAYSIZE(pci->wszName));
        return S_OK;
    }
    else 
    {
        TCHAR szName[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_FREESPACEPERCENT, szName, ARRAYSIZE(szName));
        wnsprintf(pci->wszName, ARRAYSIZE(pci->wszName), szName, dwCategoryId);
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CFreeSpaceCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == IDS_UNSPECIFIED)
        return ResultFromShort(1);
    else if (dwCategoryId2 == IDS_UNSPECIFIED)
        return ResultFromShort(-1);
    else if (dwCategoryId1 == dwCategoryId2)
        return ResultFromShort(0);
    else if (dwCategoryId1 < dwCategoryId2)
        return ResultFromShort(-1);
    else
        return ResultFromShort(1);
}

STDAPI CFreeSpaceCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFreeSpaceCategorizer* p = new CFreeSpaceCategorizer();
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}


/////////////////////////////////////////////////////////
//  Detail Categorizer
STDAPI CDetailCategorizer_Create(const SHCOLUMNID& pscid, IShellFolder2* psf2, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CDetailCategorizer* p = new CDetailCategorizer(psf2, pscid);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

CDetailCategorizer::CDetailCategorizer(IShellFolder2* psf, const SHCOLUMNID& scid) : _cRef(1)
{
    _psf = psf;
    psf->AddRef();
    _scid = scid;

    _hash = CreateHashItemTable(10, sizeof(DWORD));
    _hdpaKeys = DPA_Create(10);

}

CDetailCategorizer::~CDetailCategorizer()
{
    _psf->Release();
    DestroyHashItemTable(_hash);
    DPA_Destroy(_hdpaKeys);
}

HRESULT CDetailCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDetailCategorizer, ICategorizer),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CDetailCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDetailCategorizer::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDetailCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    return E_FAIL;
}

HRESULT CDetailCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds)
{
    if (!_hash || !_hdpaKeys)
        return E_OUTOFMEMORY;

    for (UINT i = 0; i < cidl; i++)
    {
        VARIANT v;

        rgCategoryIds[i] = GROUPID_UNSPECIFIED;

        HRESULT hr = _psf->GetDetailsEx(apidl[i], &_scid, &v);
        if (hr == S_OK)     // GetDetails returns S_FALSE for failure.
        {
            WCHAR szValue[MAX_PATH];
            if (SUCCEEDED(SHFormatForDisplay(_scid.fmtid, _scid.pid, (PROPVARIANT*)&v, PUIFFDF_DEFAULT, szValue, ARRAYSIZE(szValue))))
            {
                LPCTSTR pszKey = FindHashItem(_hash, szValue);
                if (pszKey)
                {
                    rgCategoryIds[i] = (DWORD)GetHashItemData(_hash, pszKey, 0);
                }
                else
                {
                    pszKey = AddHashItem(_hash, szValue);
                    if (pszKey)
                    {
                        rgCategoryIds[i] = DPA_AppendPtr(_hdpaKeys, (void*)pszKey);
                        SetHashItemData(_hash, pszKey, 0, rgCategoryIds[i]);
                    }
                }
            }

            VariantClear(&v);
        }
    }
    return S_OK;
}

HRESULT CDetailCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (_hash|| _hdpaKeys)
    {
        if (dwCategoryId == GROUPID_UNSPECIFIED || dwCategoryId == GROUPID_FOLDER)
        {
            LoadString(HINST_THISDLL, STRINGID_FROM_GROUPID(dwCategoryId), pci->wszName, ARRAYSIZE(pci->wszName));
            hr = S_OK;
        }
        else
        {
            LPCTSTR pszKey = (LPCTSTR)DPA_FastGetPtr(_hdpaKeys, dwCategoryId);
            if (pszKey)
            {
                LPCTSTR psz = FindHashItem(_hash, pszKey);
                if (psz)
                {
                    StrCpyN(pci->wszName, psz, ARRAYSIZE(pci->wszName));
                    hr =  S_OK;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }
    return hr;
}

HRESULT CDetailCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
    {
        return ResultFromShort(0);
    }
    else if (dwCategoryId1 == GROUPID_UNSPECIFIED ||
        dwCategoryId2 == GROUPID_UNSPECIFIED)
    {
        return ResultFromShort((dwCategoryId1 == GROUPID_UNSPECIFIED)? 1 : -1);
    }
    else if (dwCategoryId1 == GROUPID_FOLDER)
    {
        return ResultFromShort(-1);
    }
    else if (dwCategoryId2 == GROUPID_FOLDER)
    {
        return ResultFromShort(1);
    }
    else
    {
        LPCTSTR pszKey1 = (LPCTSTR)DPA_FastGetPtr(_hdpaKeys, dwCategoryId1);
        LPCTSTR pszKey2 = (LPCTSTR)DPA_FastGetPtr(_hdpaKeys, dwCategoryId2);
        LPCTSTR psz1 = FindHashItem(_hash, pszKey1);
        LPCTSTR psz2 = FindHashItem(_hash, pszKey2);

        return ResultFromShort(lstrcmpi(psz1, psz2));
    }
}


/////////////////////////////////////////////////////////
//  Alphanumeric Categorizer

STDAPI CAlphaCategorizer_Create(IShellFolder2* psf2, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CAlphaCategorizer* p = new CAlphaCategorizer(psf2);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

CAlphaCategorizer::CAlphaCategorizer(IShellFolder2* psf) : _cRef(1)
{
    _psf = psf;
    ASSERT(psf);
    psf->AddRef();
}

CAlphaCategorizer::~CAlphaCategorizer()
{
    _psf->Release();

}

HRESULT CAlphaCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAlphaCategorizer, ICategorizer),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CAlphaCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CAlphaCategorizer::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CAlphaCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_GROUPALPHABETICALLY, pszDesc, cch);
    return S_OK;
}

HRESULT CAlphaCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds)
{
    if (_psf == NULL)
        return E_ACCESSDENIED;  // Not initialized yet.

    for (UINT i = 0; i < cidl; i++)
    {
        TCHAR szName[MAX_PATH];
        HRESULT hr = DisplayNameOf(_psf, apidl[i], SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            if (StrChr(TEXT("~`!@#$%^&*()_-+=1234567890<,>.;:'[]{}|"), szName[0]) != NULL)
            {
                rgCategoryIds[i] = GROUPID_OTHER;

            }
            else
            {
                CharUpperBuff(szName, 1);
                rgCategoryIds[i]  = (DWORD)szName[0];
            }
        }

        if (FAILED(hr))
            rgCategoryIds[i] = GROUPID_UNSPECIFIED;
    }

    return S_OK;
}

HRESULT CAlphaCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    if (GROUPID_UNSPECIFIED == dwCategoryId || 
        GROUPID_OTHER == dwCategoryId       || 
        GROUPID_FOLDER == dwCategoryId)
    {
        LoadString(HINST_THISDLL, STRINGID_FROM_GROUPID(dwCategoryId), pci->wszName, ARRAYSIZE(pci->wszName));
        return S_OK;
    }
    else
    {
        pci->wszName[0] = (WCHAR)dwCategoryId;
        pci->wszName[1] = 0;

        return S_OK;
    }
}

HRESULT CAlphaCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
    {
        return ResultFromShort(0);
    }
    else if (IDS_UNSPECIFIED == dwCategoryId1 || IDS_GROUPOTHERCHAR == dwCategoryId1)
    {
        return ResultFromShort(1);
    }
    else if (IDS_UNSPECIFIED == dwCategoryId2 || IDS_GROUPOTHERCHAR == dwCategoryId2)
    {
        return ResultFromShort(-1);
    }
    else if (dwCategoryId1 == IDS_GROUPFOLDERS)
        return ResultFromShort(-1);
    else if (dwCategoryId2 == IDS_GROUPFOLDERS)
        return ResultFromShort(1);
    else
    {
        TCHAR szName1[2] = {(WCHAR)dwCategoryId1, 0};
        TCHAR szName2[2] = {(WCHAR)dwCategoryId2, 0};

        return ResultFromShort(lstrcmpi(szName1, szName2));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cdburn.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "views.h"
#include "stgutil.h"
#include "imapi.h"
#include "propsht.h"
#include "mtpt.h"
#include "shcombox.h"
#include "datautil.h"
#include "fstreex.h"
#include <imapierror.h>
#include <imapi/imapiregistry.h>
#include "cowsite.h"
#include <cfgmgr32.h>
#include "cdmedia.h"
#include <lmcons.h>
#include "prop.h"
#include "clsobj.h"
#include "filetbl.h"
#include "cdburn.h"
#include "setupapi.h"
#include "isproc.h"
#include "ole2dup.h"
#include "copy.h"
#pragma hdrstop

#define REGSTR_PATH_CDBURNING   REGSTR_PATH_EXPLORER   TEXT("\\CD Burning")
#define REGSTR_PATH_DRIVES      REGSTR_PATH_CDBURNING  TEXT("\\Drives")
#define REGSTR_PATH_HANDLERS    REGSTR_PATH_CDBURNING  TEXT("\\Extensions")
#define REGSTR_PATH_PERMEDIA    REGSTR_PATH_CDBURNING  TEXT("\\Current Media")
#define REGSTR_PATH_EXCLUDE     REGSTR_PATH_CDBURNING  TEXT("\\ExcludedFS")

#define REGSTR_PATH_AUDIOEXTS   REGSTR_PATH_CDBURNING  TEXT("\\AudioBurnHandlers")
#define REGVALUE_FILEEXTS       TEXT("SupportedFileTypes")

#define REGVALUE_CURRENTDRIVE   TEXT("CD Recorder Drive")
#define REGVALUE_AUTOEJECT      TEXT("Auto Eject")
#define REGVALUE_AUTOCLOSE      TEXT("Auto Close")
#define REGVALUE_FIRSTHANDLER   TEXT("FirstHandler")
#define REGVALUE_CLSID          TEXT("CLSID")
#define REGVALUE_VERB           TEXT("verb")
#define REGVALUE_CACHEDINDEX    TEXT("DriveIndex")

#define REGVALUE_DRIVETYPE      TEXT("Drive Type")
#define REGVALUE_CURRENTSPEED   TEXT("CurrentCDWriteSpeed")
#define REGVALUE_MAXSPEED       TEXT("MaxCDWriteSpeed")
#define REGVALUE_TOTALBYTES     TEXT("TotalBytes")
#define REGVALUE_FREEBYTES      TEXT("FreeBytes")
#define REGVALUE_MEDIATYPE      TEXT("Media Type")
#define REGVALUE_UDF            TEXT("UDF")
#define REGVALUE_DISCLABEL      TEXT("Disc Label")
#define REGVALUE_SET            TEXT("Set")

#define REGVALUE_ERASETIME      TEXT("Erase Time")
#define REGVALUE_STAGERATE      TEXT("Stage Rate")
#define REGVALUE_BURNRATE       TEXT("Burn Rate")
#define REGVALUE_CLOSEFACTOR    TEXT("Close Factor")

#define WRITESPEED_FASTEST      0xFFFFFFFF
#define JOLIET_MAX_LABEL        16

#define PROPSTR_EJECT           TEXT("Eject")
#define PROPSTR_ERASE           TEXT("Erase")
#define PROPSTR_HR              TEXT("HR")
#define PROPSTR_DISCLABEL       REGVALUE_DISCLABEL
#define PROPSTR_AUTOCLOSE       REGVALUE_AUTOCLOSE
#define PROPSTR_DISCFULLTEXT    TEXT("DiscFullText")
#define PROPSTR_CURRENTEXT      TEXT("CurrentExt")
#define PROPSTR_FAILSILENTLY    TEXT("FailSilently")
#define PROPSTR_STATUSTEXT      TEXT("StatusText")

#define INDEX_DLG_BURNWIZ_MAX   30

#define PROGRESS_INCREMENTS 1000

enum {
    DRIVE_USEEXISTING = 0,
    DRIVE_CDR = RECORDER_CDR,
    DRIVE_CDRW = RECORDER_CDRW,
    DRIVE_NOTSUPPORTED
};

#define SUPPORTED(x) ((x) && !((x) == DRIVE_NOTSUPPORTED))

typedef struct
{
    INT idPage;
    INT idHeading;
    INT idSubHeading;
    DWORD dwFlags;
    DLGPROC dlgproc;
} WIZPAGE;

typedef struct
{
    DWORD dwSecStaging, dwTickStagingStart, dwTickStagingEnd;
    DWORD dwSecBurn, dwTickBurnStart, dwTickBurnEnd;
    DWORD dwSecClose, dwTickCloseStart, dwTickCloseEnd;
    DWORD dwSecErase, dwTickEraseStart, dwTickEraseEnd;
    DWORD dwSecRemaining, dwSecTotal;
} TIMESTATS;

class CCDBurn;
typedef struct
{
    CCDBurn *pcdb;
    IStream *pstmDataObj;
    BOOL     fMove;
} CDDROPPARAMS;

// CLSIDs used for merged namespace for CD mastering

/* 00da2f99-f2a6-40c2-b770-a920f8e44abc */
const CLSID CLSID_StagingFolder = {0x00da2f99, 0xf2a6, 0x40c2, {0xb7, 0x70, 0xa9, 0x20, 0xf8, 0xe4, 0x4a, 0xbc}};

// CDBurn - object which performs the CDBurning and displaying the progress etc.
class CCDBurn : public CObjectWithSite,
                public IShellExtInit,
                public IContextMenu,
                public IShellPropSheetExt,
                public IDiscMasterProgressEvents,
                public IDropTarget,
                public IPersistFile,
                public IOleCommandTarget,
                public ICDBurn,
                public ICDBurnPriv,
                public IPersistPropertyBag,
                public IDriveFolderExt,
                public INamespaceWalkCB,
                public IWizardSite,
                public IServiceProvider,
                public ITransferAdviseSink,
                public IQueryCancelAutoPlay
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPersist methods
    STDMETHOD(GetClassID)(CLSID *pClassID)
        { *pClassID = CLSID_CDBurn; return S_OK; };

    // IPersistFile methods
    STDMETHOD(IsDirty)(void)
        { return S_FALSE; };
    STDMETHOD(Load)(LPCOLESTR pszFileName, DWORD dwMode)
        { return S_OK; };
    STDMETHOD(Save)(LPCOLESTR pszFileName, BOOL fRemember)
        { return S_OK; };
    STDMETHOD(SaveCompleted)(LPCOLESTR pszFileName)
        { return S_OK; };
    STDMETHOD(GetCurFile)(LPOLESTR *ppszFileName)
        { *ppszFileName = NULL; return S_OK; };

    // IDropTarget methods
    STDMETHOD(DragEnter)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)(void);
    STDMETHOD(Drop)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IShellExtInit methods
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IContextMenu methods
    STDMETHOD(QueryContextMenu)(HMENU hMenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(GetCommandString)(UINT_PTR idCommand, UINT uFlags, LPUINT lpReserved, LPSTR pszName, UINT uMaxNameLen);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpcmi);

    // IShellPropSheetExt methods
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE pReplacePageFunc, LPARAM lParam)
        { return S_OK; };

    // IDiscMasterProgressEvents methods
    STDMETHOD(QueryCancel)(boolean *pbCancel);
    STDMETHOD(NotifyPnPActivity)();
    STDMETHOD(NotifyAddProgress)(long nCompletedSteps, long nTotalSteps);
    STDMETHOD(NotifyBlockProgress)(long nCompleted, long nTotal);
    STDMETHOD(NotifyTrackProgress)(long nCurrentTrack, long nTotalTracks);
    STDMETHOD(NotifyPreparingBurn)(long nEstimatedSeconds);
    STDMETHOD(NotifyClosingDisc)(long nEstimatedSeconds);
    STDMETHOD(NotifyBurnComplete)(HRESULT status);
    STDMETHOD(NotifyEraseComplete)(HRESULT status);

    // IOleCommandTarget methods
    STDMETHOD(QueryStatus)(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText);
    STDMETHOD(Exec)(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut);

    // ICDBurn methods
    STDMETHOD(GetRecorderDriveLetter)(LPWSTR pszDrive, UINT cch);
    STDMETHOD(Burn)(HWND hwnd);
    STDMETHOD(HasRecordableDrive)(BOOL *pfHasRecorder);

    // ICDBurnPriv methods
    STDMETHOD(GetMediaCapabilities)(DWORD *pdwCaps, BOOL *pfUDF);
    STDMETHOD(GetContentState)(BOOL *pfStagingHasFiles, BOOL *pfDiscHasFiles);
    STDMETHOD(IsWizardUp)();

    // IPersistPropertyBag methods
    STDMETHOD(InitNew)();
    STDMETHOD(Load)(IPropertyBag *ppb, IErrorLog *pErr);
    STDMETHOD(Save)(IPropertyBag *ppb, BOOL fClearDirty, BOOL fSaveAll)
        { return E_NOTIMPL; }

    // IDriveFolderExt methods
    STDMETHOD(DriveMatches)(int iDrive);
    STDMETHOD(Bind)(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv);
    STDMETHOD(GetSpace)(ULONGLONG *pcbTotal, ULONGLONG *pcbFree);

    // INamespaceWalkCB methods
    STDMETHOD(FoundItem)(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHOD(EnterFolder)(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHOD(LeaveFolder)(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHOD(InitializeProgressDialog)(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
        { *ppszTitle = NULL; *ppszCancel = NULL; return E_NOTIMPL; }

    // IWizardSite methods
    STDMETHOD(GetNextPage)(HPROPSHEETPAGE *phPage);
    STDMETHOD(GetPreviousPage)(HPROPSHEETPAGE *phPage);
    STDMETHOD(GetCancelledPage)(HPROPSHEETPAGE *phPage)
        { return E_NOTIMPL; }

    // IServiceProvider methods
    STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void **ppv);

    // IQueryCancelAutoPlay methods
    STDMETHOD(AllowAutoPlay)(LPCWSTR pszPath, DWORD dwContentType, LPCWSTR pszLabel, DWORD dwSerialNumber);

    // ITransferAdviseSink methods
    STDMETHOD(PreOperation)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest)
        { return S_OK; }
    STDMETHOD(ConfirmOperation)(IShellItem *psiSource, IShellItem *psiDest, STGTRANSCONFIRMATION stc, LPCUSTOMCONFIRMATION pcc);
    STDMETHOD(OperationProgress)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, ULONGLONG ullTotal, ULONGLONG ullComplete)
        { return S_OK; }
    STDMETHOD(PostOperation)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, HRESULT hrResult)
        { return S_OK; }
    STDMETHOD(QueryContinue)()
        { return S_OK; }

    // exposed for the static tables 
    static INT_PTR s_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_WelcomeDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_EjectDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_EjectDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_ProgressDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_DoneDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_WaitForMediaDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_WaitForMediaDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_StartEraseDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_StartEraseDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_DiskFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_DiskFullDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_EarlyExitDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_EarlyExitDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_HDFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_HDFullDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_NoFilesDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_NoFilesDlgProc(hwnd, uMsg, wParam, lParam); }

private:
    CCDBurn();
    ~CCDBurn();

    LONG _cRef;
    TCHAR _szVolumeName[MAX_PATH];  // device path of the drive that we were invoked on

    IDataObject *_pdo;              // IDataObject (from IShellExtInit::Initialize)
    LPITEMIDLIST _pidl;             // pidl we're sited on (only for droptarget, through IShellExtInit::Initialize)

    BOOL _fCancelled;
    BOOL _fRecording;
    BOOL _fIsRecordingDrive;        // if this is the current recording drive (on init)
    BOOL _fPropSheetDirty;

    IDropTarget *_pdt;              // IDropTarget object that we wrap
    DWORD _dwDropEffect;            // drop effect chosen in dragenter

    IPropertyBag *_ppb;             // propertybag to track state in wizard
    HWND _hwndWizardPage;           // hwnd of the wizard page (used in progress)
    HWND _hwndBrowser;              // browser hwnd, used to parent error dialogs
    
    ULONGLONG _cbStagedSize;        // total size of staged files
    DWORD _dwCurSpeed;              // current burning speed
    DWORD _dwTimeSet, _dwLastTime;  // state variables for showing estimated time remaining
    TIMESTATS _ts;

    HDPA _hdpaExts;                 // pointers to the extensibility objects
    HPROPSHEETPAGE _rgWizPages[INDEX_DLG_BURNWIZ_MAX];

    HANDLE _hMutexBurning;          // this tells us if we're burning or not.
    static HWND s_hwndWiz;          // we can call SetForegroundWindow on this to bring up the wizard if its already up
    static BOOL s_fDriveInUse;

    DWORD _dwROTRegister;           // DWORD to track our moniker stuff for autoplay cancellation

    // namespace
    static HRESULT _GetPidlForDriveIndex(int iDrive, LPITEMIDLIST *ppidl);
    static HRESULT _GetPidlForVolumeName(LPCTSTR pszVolume, LPITEMIDLIST *ppidl);
    static HRESULT _GetFolderPidl(LPITEMIDLIST *ppidl);
    static HRESULT _GetBurnStagingPath(LPTSTR pszPath, UINT cchBuf);
    static HRESULT _GetPlainCDPidl(LPITEMIDLIST *ppidl);
    static BOOL _HasFiles(LPCITEMIDLIST pidl);
    static BOOL _StagingAreaHasFiles();
    static BOOL _DiscHasFiles();
    static HRESULT _GetStagingFolder(LPCITEMIDLIST pidlDrive, REFIID riid, void **ppv);

    // drop / transfer engine
    HRESULT _EnsureDropTarget();
    static void _FreeDropParams(CDDROPPARAMS *pcddp);
    static DWORD WINAPI _DropThread(void *pv);
    HRESULT _GetDropPidl(LPITEMIDLIST *ppidl);
    HRESULT _StorageDrop(IDataObject *pdtobj, BOOL fMove);
    BOOL    _IsStagingAreaSource(IDataObject *pdtobj, LPCITEMIDLIST pidlDrop);
    HRESULT _StagingPidlFromMerged(LPCITEMIDLIST pidlDrop, LPITEMIDLIST *ppidlDest);

    static HRESULT _LockCurrentDrive(BOOL fLock, BOOL fForce = FALSE);

    // initialization helpers
    static DWORD WINAPI _ExecThread(void *pv);

    // registry and cached info management
    static HRESULT _GetCurrentBurnVolumeName(LPTSTR pszVolumeName, UINT cchBuf);
    static HRESULT _SetCurrentBurnVolumeName(LPCTSTR pszVolumeName, BOOL fDelete);
    static BOOL _BurningIsEnabled();
    static HRESULT _GetStashFile(LPTSTR pszFile, UINT cchBuf);
    static HRESULT _GetCurrentStashDrive(LPTSTR pszDrive, UINT cchBuf);
    static HRESULT _SetCurrentStashDrive(LPCTSTR pszDrive);
    static HRESULT _DumpDiscInfo();
    static HRESULT _GetDiscInfoUsingIMAPI(IJolietDiscMaster *pjdm, IDiscRecorder *pdr, ULONGLONG *pcbFree);
    static HRESULT _GetDiscInfoUsingFilesystem(ULONGLONG *pcbTotal, ULONGLONG *pcbFree, BOOL *pfUDF);
    static HRESULT _StoreDiscInfo();
    static HRESULT _GetDiscRecorderInfo(IDiscRecorder *pdr, DWORD *pdwCurrentWriteSpeed, DWORD *pdwMaxWriteSpeed, DWORD *pdwDriveType);
    HRESULT _SetRecorderProps(IDiscRecorder *pdr, DWORD dwWriteSpeed);
    HRESULT _SetJolietProps(IJolietDiscMaster *pjdm);
    static HRESULT _GetCachedDriveInfo(LPCTSTR pszVolumeName, DWORD *pdwDriveType, DWORD *pdwCurWrite, DWORD *pdwMaxWrite);
    static HRESULT _SetCachedDriveInfo(LPCTSTR pszVolumeName, DWORD dwDriveType, DWORD dwCurWrite, DWORD dwMaxWrite);
    HRESULT _GetEjectSetting(BOOL *pfEject);
    HRESULT _SetEjectSetting(BOOL fEject);
    static HRESULT _GetRecorderPath(IDiscRecorder *pdr, LPTSTR pszPath, UINT cchBuf);
    static void _PruneRemovedDevices();

    // drive helpers
    static HRESULT _GetMediaCapabilities(DWORD *pdwCaps, BOOL *pfUDF);
    static HRESULT _GetVolumeNameForDriveIndex(int iDrive, LPTSTR pszVolumeName, UINT cchBuf);
    static HRESULT _GetDriveIndexForVolumeName(LPCTSTR pszVolumeName, int *piDrive);
    static HRESULT _GetCurrentDriveIndex(int *piDrive);
    static HRESULT _GetVolumeNameForDevicePath(LPCTSTR pszDevice, LPTSTR pszVolumeName, UINT cchBuf);
    static BOOL _DevicePathMatchesVolumeName(LPCTSTR pszDevice, LPCTSTR pszVolumeName);
    static DWORD _ExecSyncIoctl(HANDLE hDriver, DWORD dwIoctl, void *pbuf, DWORD cbBuf);
    static BOOL _CouldPossiblySupport(LPCWSTR pszVolume);
    HRESULT _GetVolumeNameFromDataObject(BOOL fCheckIsConfiguredDrive, LPTSTR pszVolumeName, UINT cchBuf);
    HRESULT _CheckTotal();
    HRESULT _Validate();
    static BOOL _HasMedia();

    // main IMAPI helpers
    HRESULT _GetDriveInfo(LPCTSTR pszVolumeName, DWORD *pdwDriveType, DWORD *pdwCurWrite, DWORD *pdwMaxWrite);
    HRESULT _GetDiscMasters(IDiscMaster **ppdm, IJolietDiscMaster **ppjdm);
    HRESULT _GetDiscRecorderForDrive(IDiscMaster *pdm, LPCTSTR pszVolumeName, IDiscRecorder **ppdr);
    HRESULT _FindAndSetRecorder(LPCTSTR pszVolumeName, IDiscMaster *pdm, BOOL fSetActive, IDiscRecorder **ppdr);
    HRESULT _FindAndSetDefaultRecorder(IDiscMaster *pdm, BOOL fSetActive, IDiscRecorder **ppdr);
    HRESULT _AddData(IJolietDiscMaster *pjdm);
    static BOOL _IsBurningNow();
    BOOL _EnterExclusiveBurning();
    void _LeaveExclusiveBurning();
    static void _HandleBookkeeping();

    // property sheet stuff
    void _MarkDirty(HWND hDlg);
    static BOOL_PTR CALLBACK s_DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    void _EnableRecordingDlgArea(HWND hwnd, BOOL fEnable);
    void _RecordingPrshtInit(HWND hDlg);
    BOOL _HandleApply(HWND hDlg);

    // UI
    HRESULT _Balloon();
    static BOOL CALLBACK _EnumProc(HWND hwnd, LPCITEMIDLIST pidl, LPARAM lParam);
    static BOOL _BurningFolderOpen();
    static DWORD CALLBACK _NotifyThreadProc(void *pv);
    void _CheckStagingArea();

    // wizard
    void _SetStatus(UINT uID);
    HRESULT _CreateDefaultPropBag(REFIID riid, void **ppv);
    static CCDBurn* s_GetCDBurn(HWND hwnd, UINT uMsg, LPARAM lParam);
    void _SetupFirstPage(HWND hwnd, BOOL fSubclass);
    static LRESULT CALLBACK _WizSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, DWORD_PTR dwRefData);
    HRESULT _GetBurnHR();
    void _ShowRoxio();
    INT_PTR _WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _EjectDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _WaitForMediaDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _StartEraseDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _DiskFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _EarlyExitDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _HDFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _NoFilesDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _HDFullSetText(HWND hwnd);
    void _InitProgressPage(HWND hwnd);
    void _SetEstimatedTime(DWORD dwSeconds);
    void _ConstructTimeString(DWORD dwEstTime, LPTSTR psz, UINT cch);
    void _DisplayEstimatedTime(HWND hwnd);
    void _InitTimeStats(BOOL fErase);
    void _SaveTimeStats(BOOL fErase);
    void _SetUpStartPage(HWND hwnd);
    void _LeaveStartPage(HWND hwnd);
    void _DisplayMediaErrorOnNext(HWND hwnd, UINT idMsg, UINT idMsgInsert);
    void _SetNextPage(HWND hwnd, int iIndex);
    HRESULT _PostOperation();
    HRESULT _ShowWizard();
    HRESULT _ShowWizardOnSeparateThread();
    static DWORD WINAPI _WizardThreadWrapper(void *pv);
    HRESULT _WizardThreadProc();
    void _RegisterAutoplayCanceller();
    void _UnregisterAutoplayCanceller();

    // verbs
    HRESULT _GetVerb(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL bUnicode);
    static INT_PTR CALLBACK _ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _CleanUp(LPCMINVOKECOMMANDINFO lpcmi, BOOL fRecycle);
    HRESULT _PrepWiz(LPCMINVOKECOMMANDINFO lpcmi, BOOL fErase, BOOL fFailSilently);
    static DWORD WINAPI _BurnThread(void *pv);
    static DWORD WINAPI _EraseThread(void *pv);
    
    // extensibility
    void _PruneExts();
    static HRESULT _TryCLSID(REFCLSID clsid, DWORD dwExtType, REFIID riid, void **ppv);
    static HRESULT _TryKey(LPTSTR pszKey, DWORD dwExtType, REFIID riid, void **ppv);
    static HRESULT _TestDropEffect(IDropTarget *pdt, IDataObject *pdo, REFIID riid, void **ppv);
    static HRESULT _TryCLSIDWithDropEffect(REFCLSID clsid, DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv);
    static HRESULT _TryKeyWithDropEffect(LPTSTR pszKey, DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv);
    void _AddExtensionToDPA(IWizardExtension *pwe, HPROPSHEETPAGE *rgPages, UINT cNumPages, UINT *pcPagesAdded);
    HRESULT _FillExtensionDPA(HPROPSHEETPAGE *rgPages, UINT cNumPages, UINT *pcPagesAdded);
    HRESULT _GetExtPage(int nExt, BOOL fNext, HPROPSHEETPAGE *phpage);
    HRESULT _GetExtPageFromPropBag(BOOL fNext, HPROPSHEETPAGE *phpage);
    void _SetExtPageFromPropBag(HWND hwnd, BOOL fNext);

    // "exports"
    friend HRESULT CCDBurn_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
    friend HRESULT CDBurn_OnEject(HWND hwnd, INT iDrive);
    friend HRESULT CDBurn_OnDeviceAdded(DWORD dwDriveMask, BOOL fFullRefresh, BOOL fPickNewDrive);
    friend HRESULT CDBurn_OnDeviceRemoved(DWORD dwDriveMask);
    friend HRESULT CDBurn_GetCDInfo(LPCTSTR pszVolume, DWORD *pdwDriveCapabilities, DWORD *pdwMediaCapabilities);
    friend HRESULT CDBurn_OnMediaChange(BOOL fInsert, LPCWSTR pszDrive);
    friend HRESULT CDBurn_GetExtensionObject(DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv);
    friend HRESULT CheckStagingArea();
};
HWND CCDBurn::s_hwndWiz = NULL;
BOOL CCDBurn::s_fDriveInUse = FALSE;

const static DWORD aPrshtHelpIDs[] = 
{
    IDC_RECORD_ENABLE,     IDH_CDMEDIA_ENABLERECORDING,
    IDC_RECORD_TEXTIMAGE,  IDH_CDMEDIA_STOREDISCIMAGE,
    IDC_RECORD_IMAGELOC,   IDH_CDMEDIA_STOREDISCIMAGE,
    IDC_RECORD_TEXTWRITE,  IDH_CDMEDIA_WRITESPEED,
    IDC_RECORD_WRITESPEED, IDH_CDMEDIA_WRITESPEED,
    IDC_RECORD_EJECT,      IDH_CDMEDIA_EJECT,
    0, 0
};


CCDBurn::CCDBurn() :
    _cRef(1)
{
    DllAddRef();
}

CCDBurn::~CCDBurn()
{
    if (_pdo)
    {
        _pdo->Release();
    }
    if (_pdt)
    {
        _pdt->Release();
    }
    ILFree(_pidl);
    if (_hMutexBurning)
    {
        CloseHandle(_hMutexBurning);
    }
    DllRelease();
}

// IUnknown

STDMETHODIMP_(ULONG) CCDBurn::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CCDBurn::Release()
{
    ASSERT(0 != _cRef);
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}

HRESULT CCDBurn::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CCDBurn, IObjectWithSite),
        QITABENT(CCDBurn, IContextMenu),
        QITABENT(CCDBurn, IShellExtInit),
        QITABENT(CCDBurn, IShellPropSheetExt),
        QITABENT(CCDBurn, IDiscMasterProgressEvents),
        QITABENT(CCDBurn, IDropTarget),
        QITABENT(CCDBurn, IPersistFile),
        QITABENT(CCDBurn, IOleCommandTarget),
        QITABENT(CCDBurn, ICDBurn),
        QITABENT(CCDBurn, ICDBurnPriv),
        QITABENT(CCDBurn, IPersistPropertyBag),
        QITABENT(CCDBurn, IDriveFolderExt),
        QITABENT(CCDBurn, INamespaceWalkCB),
        QITABENT(CCDBurn, IWizardSite),
        QITABENT(CCDBurn, IServiceProvider),
        QITABENT(CCDBurn, IQueryCancelAutoPlay),
        QITABENT(CCDBurn, ITransferAdviseSink),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CCDBurn_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    if (SHRestricted(REST_NOCDBURNING))
        return E_FAIL;

    CCDBurn *pcdb = new CCDBurn();
    if (!pcdb)
        return E_OUTOFMEMORY;

    HRESULT hr = pcdb->QueryInterface(riid, ppv);
    pcdb->Release();
    return hr;
}


// IShellExtInit

STDMETHODIMP CCDBurn::Initialize(LPCITEMIDLIST pidlFolder, IDataObject* pdo, HKEY hkeyProgID)
{
    if (!pdo && !pidlFolder)
        return E_INVALIDARG;

    IUnknown_Set((IUnknown **)&_pdo, (IUnknown *)pdo);
    Pidl_Set(&_pidl, pidlFolder);

    return (_pidl || _pdo) ? S_OK : E_FAIL;
}

HRESULT CCDBurn::_GetVolumeNameFromDataObject(BOOL fCheckIsConfiguredDrive, LPTSTR pszVolumeName, UINT cchBuf)
{
    HRESULT hr = E_FAIL;
    if (!SHRestricted(REST_NOCDBURNING) && _pdo)
    {
        STGMEDIUM medium;
        LPIDA pida = DataObj_GetHIDA(_pdo, &medium);
        if (pida)
        {
            // we only display the page if there is a single item selected
            if (pida->cidl == 1)
            {
                // get the IDLIST an try to determine the drive we are showing this for
                LPITEMIDLIST pidl = IDA_ILClone(pida, 0);
                if (pidl)
                {
                    TCHAR szPath[MAX_PATH];
                    SHGetPathFromIDList(pidl, szPath);

                    // only go farther if the drive is a CD ROM
                    if ((GetDriveType(szPath) == DRIVE_CDROM) &&
                        (GetVolumeNameForVolumeMountPoint(szPath, pszVolumeName, cchBuf)))
                    {
                        hr = S_OK;
                        if (fCheckIsConfiguredDrive)
                        {
                            TCHAR szCurrent[MAX_PATH];
                            hr = _GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent));
                            if (SUCCEEDED(hr))
                            {
                                hr = (lstrcmpi(szCurrent, pszVolumeName) == 0) ? S_OK : E_FAIL;
                            }
                        }
                    }
                    ILFree(pidl);
                }
            }
            HIDA_ReleaseStgMedium(pida, &medium);       
        }
    }
    return hr;
}


// Property sheet code (for configuring the burnable drive)

HRESULT CCDBurn::_GetCurrentBurnVolumeName(LPTSTR pszVolumeName, UINT cchBuf)
{
    HRESULT hr = E_FAIL;            // failed == no drive.
    if (!SHRestricted(REST_NOCDBURNING))
    {
        ULONG cb = cchBuf * sizeof(*pszVolumeName);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CURRENTDRIVE, NULL, pszVolumeName, &cb))
        {
            // we encode an empty string as a special failure case as well.
            hr = (lstrlen(pszVolumeName) > 0) ? S_OK : E_UNEXPECTED;
        }
    }
    return hr;
}

BOOL CCDBurn::_BurningIsEnabled()
{
    TCHAR szDummy[MAX_PATH];
    return SUCCEEDED(_GetCurrentBurnVolumeName(szDummy, ARRAYSIZE(szDummy)));
}

HRESULT CCDBurn::_SetCurrentBurnVolumeName(LPCTSTR pszVolumeName, BOOL fDelete)
{
    // setcurrentburnvolumename is called when the burning drive is getting switched,
    // whether because were turning off burning or moving it to a different drive.
    // whenever this changes, that means drivefolder's Parse() and Enum() will start returning
    // different stuff for the affected drive letters.
    // so we issue SHCNE_DRIVEADD and SHCNE_DRIVEREMOVED for the changes.
    LPITEMIDLIST pidlBeforeOld = NULL, pidlBeforeNew = NULL, pidlAfterOld = NULL, pidlAfterNew = NULL;

    DWORD dwDriveOld = 0, cb = sizeof(dwDriveOld);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX, NULL, &dwDriveOld, &cb))
    {
        _GetPidlForDriveIndex(dwDriveOld, &pidlBeforeOld);
    }
    _GetPidlForVolumeName(pszVolumeName, &pidlAfterOld);

    SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX);
    DWORD dwRet;
    if (!fDelete)
    {
        cb = (lstrlen(pszVolumeName) + 1) * sizeof(TCHAR);
        dwRet = SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CURRENTDRIVE, REG_SZ, pszVolumeName, cb);

        int iDrive;
        if ((ERROR_SUCCESS == dwRet) && SUCCEEDED(_GetDriveIndexForVolumeName(pszVolumeName, &iDrive)))
        {
            dwRet = SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX, REG_DWORD, &iDrive, sizeof(iDrive));
        }
    }
    else
    {
        dwRet = SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CURRENTDRIVE);
    }
    
    HRESULT hr = (ERROR_SUCCESS == dwRet) ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        if (dwDriveOld)
        {
            _GetPidlForDriveIndex(dwDriveOld, &pidlBeforeNew);
        }
        _GetPidlForVolumeName(pszVolumeName, &pidlAfterNew);
        if (pidlBeforeOld && pidlBeforeNew && !ILIsEqual(pidlBeforeOld, pidlBeforeNew))
        {
            SHChangeNotify(SHCNE_DRIVEREMOVED, SHCNF_IDLIST, pidlBeforeOld, NULL);
            SHChangeNotify(SHCNE_DRIVEADD, SHCNF_IDLIST, pidlBeforeNew, NULL);
        }
        if (pidlAfterOld && pidlAfterNew && !ILIsEqual(pidlAfterOld, pidlAfterNew))
        {
            SHChangeNotify(SHCNE_DRIVEREMOVED, SHCNF_IDLIST, pidlAfterOld, NULL);
            SHChangeNotify(SHCNE_DRIVEADD, SHCNF_IDLIST, pidlAfterNew, NULL);
        }
    }

    ILFree(pidlBeforeOld);
    ILFree(pidlBeforeNew);
    ILFree(pidlAfterOld);
    ILFree(pidlAfterNew);
    return hr;
}

HRESULT CCDBurn::_GetBurnStagingPath(LPTSTR pszPath, UINT cchBuf)
{
    ASSERTMSG(cchBuf >= MAX_PATH, "caller needs to pass bigger buffer");
    return (cchBuf < MAX_PATH) ? E_FAIL : SHGetFolderPath(NULL, CSIDL_CDBURN_AREA | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, pszPath);
}

HRESULT CCDBurn::_GetStashFile(LPTSTR pszFile, UINT cchBuf)
{
    TCHAR szPath[MAX_PATH];
    ULONG cb = sizeof(szPath);
    DWORD dwRet = SHGetValue(HKEY_LOCAL_MACHINE, TEXT(IMAPI_REGKEY_STASHFILE2), TEXT(IMAPI_REGVAL_PATH), NULL, szPath, &cb);

    HRESULT hr = E_FAIL;
    if (dwRet == ERROR_SUCCESS)
    {
        lstrcpyn(pszFile, szPath, cchBuf);
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::_GetCurrentStashDrive(LPTSTR pszDrive, UINT cchBuf)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = _GetStashFile(szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr) && PathStripToRoot(szPath))
    {
        lstrcpyn(pszDrive, szPath, cchBuf);
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::_SetCurrentStashDrive(LPCTSTR pszDrive)
{
    // we're using the root of the hard drive.

    UINT cbStashFile = (lstrlen(pszDrive) + 1) * sizeof(TCHAR);
    DWORD dwRet = SHSetValue(HKEY_LOCAL_MACHINE, TEXT(IMAPI_REGKEY_STASHFILE2), TEXT(IMAPI_REGVAL_PATH), REG_SZ, pszDrive, cbStashFile);
    return (dwRet == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CCDBurn::_GetEjectSetting(BOOL *pfEject)
{
    DWORD dwEject, cb = sizeof(dwEject);
    DWORD dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_AUTOEJECT, NULL, &dwEject, &cb);

    HRESULT hr = E_FAIL;
    if (dwRet == ERROR_SUCCESS)
    {
        *pfEject = dwEject;
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::_SetEjectSetting(BOOL fEject)
{
    DWORD dwEject = fEject;
    DWORD dwRet = SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_AUTOEJECT, REG_DWORD, &dwEject, sizeof(dwEject));
    return (dwRet == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CCDBurn::_GetCachedDriveInfo(LPCTSTR pszVolumeName, DWORD *pdwDriveType, DWORD *pdwCurrentWriteSpeed, DWORD *pdwMaxWriteSpeed)
{
    HRESULT hr = S_OK;
    
    TCHAR szRegPath[MAX_PATH];
    lstrcpyn(szRegPath, REGSTR_PATH_DRIVES, ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, TEXT("\\"), ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, PathFindFileName(pszVolumeName), ARRAYSIZE(szRegPath));

    if (pdwDriveType)
    {
        DWORD dwTemp;
        ULONG cb = sizeof(dwTemp);
        DWORD dwRet = SHGetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_DRIVETYPE, NULL, &dwTemp, &cb);
        if (dwRet == ERROR_SUCCESS)
        {
            *pdwDriveType = dwTemp;
        }
        else
        {
            // this is the one value that should always be present if the key is there,
            // so fail if it's not there yet.
            hr = E_FAIL;
        }
    }

    if (pdwCurrentWriteSpeed)
    {
        DWORD dwTemp;
        ULONG cb = sizeof(dwTemp);
        DWORD dwRet = SHGetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_CURRENTSPEED, NULL, &dwTemp, &cb);
        if (dwRet == ERROR_SUCCESS)
        {
            *pdwCurrentWriteSpeed = dwTemp;
        }
    }

    if (pdwMaxWriteSpeed)
    {
        DWORD dwTemp;
        ULONG cb = sizeof(dwTemp);
        DWORD dwRet = SHGetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_MAXSPEED, NULL, &dwTemp, &cb);
        if (dwRet == ERROR_SUCCESS)
        {
            *pdwMaxWriteSpeed = dwTemp;
        }
    }
    return hr;
}

HRESULT CCDBurn::_SetCachedDriveInfo(LPCTSTR pszVolumeName, DWORD dwDriveType, DWORD dwWriteSpeed, DWORD dwMaxWriteSpeed)
{
    TCHAR szRegPath[MAX_PATH];
    lstrcpyn(szRegPath, REGSTR_PATH_DRIVES, ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, TEXT("\\"), ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, PathFindFileName(pszVolumeName), ARRAYSIZE(szRegPath));

    if (dwDriveType > 0)
    {
        SHSetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_DRIVETYPE, REG_DWORD, &dwDriveType, sizeof(dwDriveType));
    }

    if (dwWriteSpeed > 0)
    {
        SHSetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_CURRENTSPEED, REG_DWORD, &dwWriteSpeed, sizeof(dwWriteSpeed));
    }

    if (dwMaxWriteSpeed > 0)
    {
        SHSetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_MAXSPEED, REG_DWORD, &dwMaxWriteSpeed, sizeof(dwMaxWriteSpeed));
    }
    return S_OK;
}

HRESULT CCDBurn::_GetDiscRecorderInfo(IDiscRecorder *pdr, DWORD *pdwCurrentWriteSpeed, DWORD *pdwMaxWriteSpeed, DWORD *pdwDriveType)
{
    IPropertyStorage *pps;
    HRESULT hr = pdr->GetRecorderProperties(&pps);
    if (SUCCEEDED(hr))
    {
        PROPSPEC rgpspec[2];

        rgpspec[0].ulKind = PRSPEC_LPWSTR;
        rgpspec[0].lpwstr = L"WriteSpeed";

        rgpspec[1].ulKind = PRSPEC_LPWSTR;
        rgpspec[1].lpwstr = L"MaxWriteSpeed";

        PROPVARIANT rgvar[2];
        hr = pps->ReadMultiple(2, rgpspec, rgvar);
        if (SUCCEEDED(hr))
        {
            if ((V_VT(&rgvar[0]) == VT_I4) &&
                (V_VT(&rgvar[1]) == VT_I4))
            {
                if (pdwCurrentWriteSpeed)
                    *pdwCurrentWriteSpeed = rgvar[0].lVal;
                if (pdwMaxWriteSpeed)
                    *pdwMaxWriteSpeed = rgvar[1].lVal;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        pps->Release();
    }

    if (SUCCEEDED(hr) && pdwDriveType)
    {
        long lType;
        hr = pdr->GetRecorderType(&lType);
        if (SUCCEEDED(hr))
        {
            *pdwDriveType = lType;
        }
    }

    return hr;
}

HRESULT CCDBurn::_SetRecorderProps(IDiscRecorder *pdr, DWORD dwWriteSpeed)
{
    IPropertyStorage *pps;
    HRESULT hr = pdr->GetRecorderProperties(&pps);
    if (SUCCEEDED(hr))
    {
        PROPSPEC rgpspec[1];
        PROPVARIANT rgvar[1];

        rgpspec[0].ulKind = PRSPEC_LPWSTR;
        rgpspec[0].lpwstr = L"WriteSpeed";

        rgvar[0].vt       = VT_I4;
        rgvar[0].lVal     = dwWriteSpeed;

        hr = pps->WriteMultiple(1, rgpspec, rgvar, PID_FIRST_USABLE);
        if (SUCCEEDED(hr))
        {
            // commit propertystorage to the discrecorder
            hr = pdr->SetRecorderProperties(pps);
        }

        pps->Release();
    }
    return hr;
}

HRESULT CCDBurn::_SetJolietProps(IJolietDiscMaster *pjdm)
{
    IPropertyStorage *pps;
    HRESULT hr = pjdm->GetJolietProperties(&pps);
    if (SUCCEEDED(hr))
    {
        WCHAR szLabel[JOLIET_MAX_LABEL + 1];
        szLabel[0] = 0;
        SHPropertyBag_ReadStr(_ppb, PROPSTR_DISCLABEL, szLabel, ARRAYSIZE(szLabel));

        PROPSPEC rgpspec[1];
        PROPVARIANT rgvar[1];

        rgpspec[0].ulKind = PRSPEC_LPWSTR;
        rgpspec[0].lpwstr = L"VolumeName";

        rgvar[0].vt       = VT_BSTR;
        rgvar[0].bstrVal  = SysAllocString(szLabel);

        hr = pps->WriteMultiple(1, rgpspec, rgvar, PID_FIRST_USABLE);
        if (SUCCEEDED(hr))
        {
            // commit propertystorage to the joliet disc master
            hr = pjdm->SetJolietProperties(pps);
        }

        PropVariantClear(&rgvar[0]);

        pps->Release();
    }
    return hr;
}

HRESULT CCDBurn::_GetDriveInfo(LPCTSTR pszVolumeName, DWORD *pdwDriveType, DWORD *pdwCurWrite, DWORD *pdwMaxWrite)
{
    HRESULT hr = _GetCachedDriveInfo(pszVolumeName, pdwDriveType, pdwCurWrite, pdwMaxWrite);
    if (FAILED(hr))
    {
        IDiscMaster *pdm;
        IJolietDiscMaster *pjdm;
        hr = _GetDiscMasters(&pdm, &pjdm);
        if (SUCCEEDED(hr))
        {
            IDiscRecorder *pdr;
            hr = _GetDiscRecorderForDrive(pdm, pszVolumeName, &pdr);
            if (SUCCEEDED(hr))
            {
                if (S_OK == hr)
                {
                    DWORD dwMaxWrite, dwDriveType;
                    hr = _GetDiscRecorderInfo(pdr, NULL, &dwMaxWrite, &dwDriveType);
                    if (SUCCEEDED(hr))
                    {
                        // default to fastest speed
                        _SetCachedDriveInfo(pszVolumeName, dwDriveType, WRITESPEED_FASTEST, dwMaxWrite);
                        if (pdwMaxWrite)
                        {
                            *pdwMaxWrite = dwMaxWrite;
                        }
                        if (pdwCurWrite)
                        {
                            *pdwCurWrite = dwMaxWrite;
                        }
                        if (pdwDriveType)
                        {
                            *pdwDriveType = dwDriveType;
                        }
                    }
                    pdr->Release();
                }
                else
                {
                    if (pdwDriveType)
                    {
                        *pdwDriveType = DRIVE_NOTSUPPORTED;
                    }
                    _SetCachedDriveInfo(pszVolumeName, DRIVE_NOTSUPPORTED, 0, 0);
                }
            }
            pdm->Release();
            pjdm->Release();
        }
    }
    return hr;
}

STDMETHODIMP CCDBurn::AddPages(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam)
{
    // get the destination burn drive from the IDataObject we recieved during initialization
    HRESULT hr = _GetVolumeNameFromDataObject(FALSE, _szVolumeName, ARRAYSIZE(_szVolumeName));
    if (SUCCEEDED(hr))
    {
        DWORD dwDriveType;
        // only add page if we're supported by IMAPI.
        if (SUCCEEDED(_GetDriveInfo(_szVolumeName, &dwDriveType, NULL, NULL)) && SUPPORTED(dwDriveType))
        {
            // is this drive configured to be the recording drive?
            _fIsRecordingDrive = FALSE;
            TCHAR szCurrent[MAX_PATH];
            if (SUCCEEDED(_GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent))))
            {
                _fIsRecordingDrive = (lstrcmpi(szCurrent, _szVolumeName) == 0);
            }

            PROPSHEETPAGE psp = { 0 };
            psp.dwSize = sizeof(psp);    // extra data
            psp.dwFlags = PSP_DEFAULT;
            psp.hInstance = HINST_THISDLL;
            psp.pszTemplate = MAKEINTRESOURCE(DLG_DRV_RECORDINGTAB);
            psp.pfnDlgProc = s_DlgProc;

            psp.lParam = (LPARAM)this;          // pass out a reference to our object
            AddRef();

            // create the page, and add it using the cb function they gave us
            hr = E_OUTOFMEMORY;
            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&psp);
            if (hPage)
            {
                if (!pAddPageProc(hPage, lParam))
                {
                    DestroyPropertySheetPage(hPage);
                }
                else
                {
                    hr = S_OK;              // success
                }
            }

            if (FAILED(hr))
            {
                Release();
            }
        }
    }
    return hr;
}

void CCDBurn::_EnableRecordingDlgArea(HWND hwnd, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hwnd, IDC_RECORD_IMAGELOC), IsUserAnAdmin() ? fEnable : FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_RECORD_WRITESPEED), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_RECORD_TEXTIMAGE), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_RECORD_TEXTWRITE), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_RECORD_EJECT), fEnable);
}

void CCDBurn::_RecordingPrshtInit(HWND hDlg)
{
    DECLAREWAITCURSOR;
    SetWaitCursor();

    HWND hwndWriteSpeed = GetDlgItem(hDlg, IDC_RECORD_WRITESPEED);
    HWND hwndImageLoc = GetDlgItem(hDlg, IDC_RECORD_IMAGELOC);

    // get the icon for the drive
    HICON hIcon = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDI_DRIVECD));
    ReplaceDlgIcon(hDlg, IDC_RECORD_ICON, hIcon);

    // set the "we are the recording drive" flag

    CheckDlgButton(hDlg, IDC_RECORD_ENABLE, _fIsRecordingDrive);
    _EnableRecordingDlgArea(hDlg, _fIsRecordingDrive);

    BOOL fAutoEject = TRUE;
    _GetEjectSetting(&fAutoEject);
    CheckDlgButton(hDlg, IDC_RECORD_EJECT, fAutoEject);

    // populate the controls for the write speed

    TCHAR szTemp[MAX_PATH];
    LoadString(HINST_THISDLL, IDS_BURN_WRITESPEED_NX, szTemp, ARRAYSIZE(szTemp));

    // if the registry info is missing
    // then default to 1x.
    DWORD dwMaxSpeed = 1;
    DWORD dwCurSpeed = 1;
    _GetDriveInfo(_szVolumeName, NULL, &dwCurSpeed, &dwMaxSpeed);

    int iCurSel = 0, iSelIndex = 0;

    TCHAR szSpeed[20];
    LoadString(HINST_THISDLL, IDS_BURN_WRITESPEED_FASTEST, szSpeed, ARRAYSIZE(szSpeed));
    ComboBox_AddString(hwndWriteSpeed, szSpeed);
    ComboBox_SetItemData(hwndWriteSpeed, iSelIndex, WRITESPEED_FASTEST);
    iSelIndex++;

    // we want the following:
    // 8x drive: 8, 4, 2, 1
    // 10x drive: 10, 8, 4, 2, 1
    for (DWORD dwSpeed = dwMaxSpeed; dwSpeed >= 1; iSelIndex++)
    {
        if (dwSpeed == dwCurSpeed)
        {
            iCurSel = iSelIndex;
        }

        _sntprintf(szSpeed, ARRAYSIZE(szSpeed), szTemp, dwSpeed);
        ComboBox_AddString(hwndWriteSpeed, szSpeed);
        ComboBox_SetItemData(hwndWriteSpeed, iSelIndex, dwSpeed);

        // so if we just added the max speed, set dwSpeed to the lowest
        // power of two greater than the max speed.
        // then divide by two.
        // thus 10->8, 8->4, etc.
        if (dwSpeed == dwMaxSpeed)
        {
            for (dwSpeed = 1; dwSpeed < dwMaxSpeed; dwSpeed *= 2);
        }
        dwSpeed /= 2;
    }
    ComboBox_SetCurSel(hwndWriteSpeed, iCurSel);

    // populate the staging drive information, and try and set the drive

    SendMessage(hwndImageLoc, CBEM_SETIMAGELIST, 0, (LPARAM)GetSystemImageListSmallIcons());
    PopulateLocalDrivesCombo(hwndImageLoc, NULL, (LPARAM)hwndImageLoc);

    BOOL fSetAlready = FALSE;
    if (SUCCEEDED(_GetCurrentStashDrive(szTemp, ARRAYSIZE(szTemp))))
    {
        for (int i = 0; (i < ComboBox_GetCount(hwndImageLoc)) && !fSetAlready; i++)
        {
            LPTSTR pszData = (LPTSTR)ComboBox_GetItemData(hwndImageLoc, i);
            if (lstrcmpi(szTemp, pszData) == 0)
            {
                ComboBox_SetCurSel(hwndImageLoc, i);
                fSetAlready = TRUE;
            }
        }
    }

    if (!fSetAlready)
        ComboBox_SetCurSel(hwndImageLoc, 0);

    // if we're not an admin, the user wont be able to change the stash location due to kernel security
    // issues.  thus disable that part.
    if (!IsUserAnAdmin())
    {
        EnableWindow(hwndImageLoc, FALSE);
        WCHAR szText[200];
        LoadString(HINST_THISDLL, IDS_BURN_USERBLOCK, szText, ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(hDlg, IDC_RECORD_TEXTIMAGE), szText);
    }

    _fPropSheetDirty = FALSE;

    ResetWaitCursor();
}

BOOL CCDBurn::_HandleApply(HWND hDlg)
{
    BOOL fGoAhead = TRUE;
    if (_fPropSheetDirty)
    {
        if (IsDlgButtonChecked(hDlg, IDC_RECORD_ENABLE) == BST_CHECKED)
        {
            _fIsRecordingDrive = TRUE;

            // get the stash drive setup
            HWND hwndStash = GetDlgItem(hDlg, IDC_RECORD_IMAGELOC);
            int iItem = ComboBox_GetCurSel(hwndStash);
            if (iItem != (int)CB_ERR)
            {
                LPTSTR pszStashDrive = (LPTSTR)ComboBox_GetItemData(hwndStash, iItem);

                // set the stash drive
                _SetCurrentStashDrive(pszStashDrive);
            
                // mark the drive we are going to burn to
                _SetCurrentBurnVolumeName(_szVolumeName, FALSE);

                // set speed
                HWND hwndSpeed = GetDlgItem(hDlg, IDC_RECORD_WRITESPEED);
                iItem = ComboBox_GetCurSel(hwndSpeed);
                if (iItem != (int)CB_ERR)
                {
                    DWORD dwSpeed = (DWORD)ComboBox_GetItemData(hwndSpeed, iItem);
                    _SetCachedDriveInfo(_szVolumeName, DRIVE_USEEXISTING, dwSpeed, 0);
                }

                // set autoeject
                BOOL fAutoEject = (IsDlgButtonChecked(hDlg, IDC_RECORD_EJECT) == BST_CHECKED);
                _SetEjectSetting(fAutoEject);

                // redo free space
                _HandleBookkeeping();
            }
            _fPropSheetDirty = FALSE;
        }
        else if (_fIsRecordingDrive)
        {
            if (!_StagingAreaHasFiles() ||
                (IDYES == ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_BURN_CONFIRM_DISABLE), MAKEINTRESOURCE(IDS_BURN),
                                          MB_YESNO | MB_ICONQUESTION)))
            {
                // clear out any trash, we're disabling the cd burning now.
                _SetCurrentBurnVolumeName(TEXT(""), FALSE); // there is no recording drive now

                _fPropSheetDirty = FALSE;
            }
            else
            {
                fGoAhead = FALSE;
            }
        }
    }
    return fGoAhead;
}

void CCDBurn::_MarkDirty(HWND hDlg)
{
    PropSheet_Changed(GetParent(hDlg), hDlg);
    _fPropSheetDirty = TRUE;
}

BOOL_PTR CCDBurn::s_DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    if (uMessage == WM_INITDIALOG)
    {
        PROPSHEETPAGE *psp = (PROPSHEETPAGE*)lParam;
        CCDBurn *pcdb = (CCDBurn*)psp->lParam;
        SetWindowLongPtr(hDlg, GWLP_USERDATA, psp->lParam);
        pcdb->_RecordingPrshtInit(hDlg);
    }
    else
    {
        CCDBurn *pcdb = (CCDBurn*)GetWindowLongPtr(hDlg, GWLP_USERDATA);
        switch (uMessage) 
        {
            case WM_DESTROY:
                ReplaceDlgIcon(hDlg, IDC_RECORD_ICON, NULL);
                SetWindowLongPtr(hDlg, GWLP_USERDATA, 0x0);
                pcdb->Release();
                break;

            case WM_HELP:
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, CDBURN_HELPFILE, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aPrshtHelpIDs);
                break;

            case WM_CONTEXTMENU:
                WinHelp((HWND)wParam, CDBURN_HELPFILE, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aPrshtHelpIDs);
                break;

            case WM_COMMAND:
                switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                    case IDC_RECORD_ENABLE:
                        {
                            BOOL fRecordingEnabled = (IsDlgButtonChecked(hDlg, IDC_RECORD_ENABLE) == BST_CHECKED);
                            pcdb->_EnableRecordingDlgArea(hDlg, fRecordingEnabled);
                            pcdb->_MarkDirty(hDlg);
                        }
                        break;

                    case IDC_RECORD_IMAGELOC:
                    case IDC_RECORD_WRITESPEED:
                        if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE)
                        {
                            pcdb->_MarkDirty(hDlg);
                        }
                        break;

                    case IDC_RECORD_EJECT:
                        pcdb->_MarkDirty(hDlg);
                        break;

                    default:
                        return TRUE;
                }
                break;

            case WM_NOTIFY:
                switch (((NMHDR *)lParam)->code) 
                {
                    case PSN_SETACTIVE:
                        break;

                    case PSN_APPLY:
                        if (!pcdb->_HandleApply(hDlg))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        }
                        else
                        {
                            PropSheet_UnChanged(GetParent(hDlg), hDlg);
                        }
                        return TRUE;

                    default:
                        return FALSE;
                }
                break;

            default:
                return FALSE;
        }
    }
    return TRUE;
}


// IContextMenu

STDMETHODIMP CCDBurn::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    INT idMax = idCmdFirst;

    // only display this if we are invoked on the currently configured burn drive
    TCHAR szDummy[MAX_PATH];
    if (SUCCEEDED(_GetVolumeNameFromDataObject(TRUE, szDummy, ARRAYSIZE(szDummy))))
    {
        // load and merge the context menu with the current menu
        HMENU hmMerge = SHLoadPopupMenu(HINST_THISDLL, POPUP_BURN_POPUPMERGE);
        if (hmMerge)
        {
            idMax = Shell_MergeMenus(hmenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, 0);

            BOOL fInStaging, fOnMedia;
            if (SUCCEEDED(GetContentState(&fInStaging, &fOnMedia)))
            {
                DWORD dwCaps = 0;
                BOOL fUDF = FALSE;
                _GetMediaCapabilities(&dwCaps, &fUDF); // this will fail if there is no media in the drive.

                // delete write to cd if it's UDF
                if (fUDF)
                    DeleteMenu(hmenu, idCmdFirst + FSIDM_BURN, MF_BYCOMMAND);

                // delete clear staging area if no files to burn or it's UDF
                if (!fInStaging || fUDF)
                    DeleteMenu(hmenu, idCmdFirst + FSIDM_CLEANUP, MF_BYCOMMAND);

                // delete erase if it's not UDF and no cd-rw or no files on disc
                if (!(dwCaps & HWDMC_CDREWRITABLE) || (!fOnMedia && !fUDF))
                    DeleteMenu(hmenu, idCmdFirst + FSIDM_ERASE, MF_BYCOMMAND);
            }
            DestroyMenu(hmMerge);
        }
    }

    return ResultFromShort(idMax - idCmdFirst);
}

const ICIVERBTOIDMAP c_CDBurnMap[] =
{
    { L"burn",    "burn",    FSIDM_BURN,    FSIDM_BURN,    },
    { L"cleanup", "cleanup", FSIDM_CLEANUP, FSIDM_CLEANUP, },
    { L"erase",   "erase",   FSIDM_ERASE,   FSIDM_ERASE,   },
};

STDMETHODIMP CCDBurn::GetCommandString(UINT_PTR idCmd, UINT uFlags, LPUINT lpReserved, LPSTR pszName, UINT cchMax)
{
    HRESULT hr;
    
    switch(uFlags)
    {
        case GCS_VERBA:
        case GCS_VERBW:
            hr = SHMapCmdIDToVerb(idCmd, c_CDBurnMap, ARRAYSIZE(c_CDBurnMap), pszName, cchMax, uFlags == GCS_VERBW);
            break;
   
        default:
            hr = E_NOTIMPL;
            break; 
    }
    return hr;
}

STDMETHODIMP CCDBurn::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    UINT uID;
    HRESULT hr = SHMapICIVerbToCmdID(lpcmi, c_CDBurnMap, ARRAYSIZE(c_CDBurnMap), &uID);
    if (SUCCEEDED(hr))
    {
        switch (uID)
        {
            case FSIDM_BURN:
            case FSIDM_ERASE:
                hr = InitNew();
                if (SUCCEEDED(hr))
                {
                    hr = _PrepWiz(lpcmi, (uID == FSIDM_ERASE), FALSE);
                }
                break;

            case FSIDM_CLEANUP:
                hr = _CleanUp(lpcmi, TRUE);
                break;

            default:
                hr = E_FAIL;
                break;
        }
    }
    return hr;
} 


// IMAPI Advise Sink

STDMETHODIMP CCDBurn::QueryCancel(boolean *pbCancel)
{
    *pbCancel = (boolean)_fCancelled;
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyPnPActivity()
{
    return E_NOTIMPL;
}

STDMETHODIMP CCDBurn::NotifyAddProgress(long nCompletedSteps, long nTotalSteps)
{
    if (nTotalSteps != 0)
    {
        _SetEstimatedTime((DWORD)((float) _ts.dwSecStaging * (nTotalSteps - nCompletedSteps) / nTotalSteps + _ts.dwSecBurn + _ts.dwSecClose));
    }
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyBlockProgress(long nCompleted, long nTotal)
{
    // Unfortunately we need to set the "burning" text here,
    // because we get this notification immediately after the NotifyPreparingBurn.
    if (!_fRecording)
    {
        _SetStatus(IDS_BURN_RECORDING);
        _ts.dwTickBurnStart = GetTickCount();
        _fRecording = TRUE;
    }
    if (nTotal != 0)
    {
        _SetEstimatedTime((DWORD)((float) _ts.dwSecBurn * (nTotal - nCompleted) / nTotal + _ts.dwSecClose));
    }
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyTrackProgress(long nCurrentTrack, long nTotalTracks)
{
    // audio cd only
    return E_NOTIMPL;
}

STDMETHODIMP CCDBurn::NotifyPreparingBurn(long nEstimatedSeconds)
{
    _SetStatus(IDS_BURN_PREPARINGBURN);
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyClosingDisc(long nEstimatedSeconds)
{
    _ts.dwTickBurnEnd = _ts.dwTickCloseStart = GetTickCount();
    _SetEstimatedTime(_ts.dwSecClose);
    _SetStatus(IDS_BURN_CLOSINGDISC);
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyBurnComplete(HRESULT status)
{
    _ts.dwTickCloseEnd = GetTickCount();
    _SetEstimatedTime(0);
    _SetStatus(IDS_BURN_COMPLETE);
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyEraseComplete(HRESULT status)
{
    _ts.dwTickEraseEnd = GetTickCount();
    _SetEstimatedTime(0);
    _SetStatus(IDS_BURN_COMPLETE);
    return S_OK;
}

HRESULT CCDBurn::_LockCurrentDrive(BOOL fLock, BOOL fForce)
{
    HRESULT hr = S_OK;
    // fForce defaults to FALSE
    if (fForce || (fLock != s_fDriveInUse))
    {
        TCHAR szVolume[MAX_PATH];
        hr = _GetCurrentBurnVolumeName(szVolume, ARRAYSIZE(szVolume));
        if (SUCCEEDED(hr))
        {
            // strip trailing backslash (always there)
            ASSERT(szVolume[lstrlen(szVolume) - 1] == TEXT('\\'));
            szVolume[lstrlen(szVolume) - 1] = 0;

            hr = E_FAIL;
            HANDLE hDevice = CreateFile(szVolume, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, 0, NULL);
            if (hDevice != INVALID_HANDLE_VALUE)
            {
                PREVENT_MEDIA_REMOVAL pmr = {0};
                pmr.PreventMediaRemoval = BOOLIFY(fLock);

                DWORD dwDummy;
                if (DeviceIoControl(hDevice, IOCTL_STORAGE_MEDIA_REMOVAL, &pmr, sizeof(pmr), NULL, 0, &dwDummy, NULL))
                {
                    // we're sealed up tight now, set the state var.
                    s_fDriveInUse = fLock;
                    hr = S_OK;
                }
                CloseHandle(hDevice);
            }
        }
    }
    return hr;
}

BOOL CCDBurn::_HasFiles(LPCITEMIDLIST pidl)
{
    BOOL fHasFiles = FALSE;

    IBindCtx *pbc;
    HRESULT hr = SHCreateSkipBindCtx(NULL, &pbc);
    if (SUCCEEDED(hr))
    {
        IStorage *pstg;
        hr = SHBindToObjectEx(NULL, pidl, pbc, IID_PPV_ARG(IStorage, &pstg));
        if (SUCCEEDED(hr))
        {
            IEnumSTATSTG *penum;
            hr = pstg->EnumElements(0, NULL, 0, &penum);
            if (SUCCEEDED(hr))
            {
                STATSTG stat;
                hr = penum->Next(1, &stat, NULL);
                if (hr == S_OK)
                {
                    fHasFiles = TRUE;
                    CoTaskMemFree(stat.pwcsName);
                }
                penum->Release();
            }
            pstg->Release();
        }
        pbc->Release();
    }
    return fHasFiles;
}

BOOL CCDBurn::_StagingAreaHasFiles()
{
    BOOL fHasFiles = FALSE;
    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_CDBURN_AREA, NULL, 0, &pidl)))
    {
        fHasFiles = _HasFiles(pidl);
        ILFree(pidl);
    }
    return fHasFiles;
}

BOOL CCDBurn::_DiscHasFiles()
{
    BOOL fHasFiles = FALSE;
    LPITEMIDLIST pidl;
    if (SUCCEEDED(_GetPlainCDPidl(&pidl)))
    {
        fHasFiles = _HasFiles(pidl);
        ILFree(pidl);
    }
    return fHasFiles;
}

HRESULT CCDBurn::GetContentState(BOOL *pfStagingHasFiles, BOOL *pfDiscHasFiles)
{
    if (pfStagingHasFiles)
        *pfStagingHasFiles = _StagingAreaHasFiles();
    if (pfDiscHasFiles)
        *pfDiscHasFiles = _DiscHasFiles();

    return S_OK;
}

HRESULT CCDBurn::IsWizardUp()
{
    HRESULT hr;
    CCDBurn *pcdb = new CCDBurn();
    if (pcdb)
    {
        // check if the wizard is currently running.
        // the reason why we have to do both the s_hwndWiz and the exclusive mutex check is that
        // there could be other explorer.exe's that are running.  the s_hwndWiz is a shortcut for
        // the typical case where we're the only one.
        if (!pcdb->s_hwndWiz && pcdb->_EnterExclusiveBurning())
        {
            // if we could get the exclusive mutex, we werent up yet, so release it.
            pcdb->_LeaveExclusiveBurning();
            hr = S_FALSE;
        }
        else
        {
            // the window is up or we couldn't get the mutex so we're definitely burning now.
            hr = S_OK;
        }
        pcdb->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CCDBurn::_GetRecorderPath(IDiscRecorder *pdr, LPTSTR pszPath, UINT cchBuf)
{
    BSTR bstr;
    HRESULT hr = pdr->GetPath(&bstr);
    if (SUCCEEDED(hr))
    {
        lstrcpyn(pszPath, bstr, cchBuf);
        SysFreeString(bstr);
    }
    return hr;
}

HRESULT CCDBurn::_GetVolumeNameForDriveIndex(int iDrive, LPTSTR pszVolumeName, UINT cchBuf)
{
    HRESULT hr = E_FAIL;
    TCHAR szDriveLetter[4];
    if (PathBuildRoot(szDriveLetter, iDrive) &&
        GetVolumeNameForVolumeMountPoint(szDriveLetter, pszVolumeName, cchBuf))
    {
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::_GetDriveIndexForVolumeName(LPCTSTR pszVolumeName, int *piDrive)
{
    HRESULT hr = E_FAIL;
    DWORD cchLen;
    BOOL fRet = GetVolumePathNamesForVolumeName(pszVolumeName, NULL, 0, &cchLen);
    if (fRet || (GetLastError() == ERROR_MORE_DATA))
    {
        LPWSTR pszBuf = new WCHAR[cchLen];
        if (pszBuf)
        {
            hr = E_FAIL;
            if (GetVolumePathNamesForVolumeName(pszVolumeName, pszBuf, cchLen, NULL))
            {
                for (PWSTR pszPath = pszBuf; *pszPath; pszPath += lstrlenW(pszPath) + 1)
                {
                    // if it's mounted at more than one root, take the first one.
                    if (PathIsRoot(pszPath))
                    {
                        *piDrive = PathGetDriveNumber(pszBuf);
                        hr = S_OK;
                        break;
                    }
                }
            }
            delete [] pszBuf;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CCDBurn::_GetCurrentDriveIndex(int *piDrive)
{
    TCHAR szCurrent[MAX_PATH];
    HRESULT hr = _GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent));
    if (SUCCEEDED(hr))
    {
        hr = _GetDriveIndexForVolumeName(szCurrent, piDrive);
    }
    return hr;
}

HRESULT CCDBurn::_GetVolumeNameForDevicePath(LPCTSTR pszDevice, LPTSTR pszVolumeName, UINT cchBuf)
{
    TCHAR szMountPoint[MAX_PATH];
    lstrcpyn(szMountPoint, TEXT("\\\\?\\GLOBALROOT"), ARRAYSIZE(szMountPoint));
    StrCatBuff(szMountPoint, pszDevice, ARRAYSIZE(szMountPoint));
    StrCatBuff(szMountPoint, TEXT("\\"), ARRAYSIZE(szMountPoint));
    return GetVolumeNameForVolumeMountPoint(szMountPoint, pszVolumeName, cchBuf) ? S_OK : E_FAIL;
}

BOOL CCDBurn::_DevicePathMatchesVolumeName(LPCTSTR pszDevice, LPCTSTR pszVolumeName)
{
    BOOL fRet = FALSE;

    TCHAR szVolumeNameTest[MAX_PATH];
    if (SUCCEEDED(_GetVolumeNameForDevicePath(pszDevice, szVolumeNameTest, ARRAYSIZE(szVolumeNameTest))))
    {
        fRet = (lstrcmpi(pszVolumeName, szVolumeNameTest) == 0);
    }
    return fRet;
}

// can return S_FALSE and not fill up ppdr
HRESULT CCDBurn::_GetDiscRecorderForDrive(IDiscMaster *pdm, LPCTSTR pszVolumeName, IDiscRecorder **ppdr)
{
    IEnumDiscRecorders *penumdr;
    HRESULT hr = pdm->EnumDiscRecorders(&penumdr);
    if (SUCCEEDED(hr))
    {
        BOOL fDone = FALSE;
        do
        {
            ULONG celt;
            IDiscRecorder *pdr;
            hr = penumdr->Next(1, &pdr, &celt);
            if (hr == S_OK)
            {
                TCHAR szPath[MAX_PATH];
                hr = _GetRecorderPath(pdr, szPath, ARRAYSIZE(szPath));
                if (SUCCEEDED(hr))
                {
                    if (_DevicePathMatchesVolumeName(szPath, pszVolumeName))
                    {
                        if (ppdr)
                        {
                            pdr->AddRef();
                            *ppdr = pdr;
                        }
                        fDone = TRUE;
                    }
                }
                pdr->Release();
            }
            else
            {
                fDone = TRUE;
            }
        } while (!fDone);
        penumdr->Release();
    }
    return hr;
}

HRESULT CCDBurn::_FindAndSetRecorder(LPCTSTR pszVolumeName, IDiscMaster *pdm, BOOL fSetActive, IDiscRecorder **ppdr)
{
    IDiscRecorder *pdr;
    HRESULT hr = _GetDiscRecorderForDrive(pdm, pszVolumeName, &pdr);
    if (S_OK == hr)
    {
        DWORD dwCurSpeed = 1, dwMaxSpeed = 1;
        _GetCachedDriveInfo(pszVolumeName, NULL, &dwCurSpeed, &dwMaxSpeed);
        if (fSetActive)
        {
            hr = pdm->SetActiveDiscRecorder(pdr);
            if (SUCCEEDED(hr))
            {
                hr = _SetRecorderProps(pdr, dwCurSpeed);
            }
        }
        // _dwCurSpeed is used only for timing, so if it's 0xFFFFFFFF we need to scale
        // it back down to what we think is the max speed.
        // this may be incorrect for certain drives that have an actual speed different
        // from what they report but it's the best we can do (and it'll be compensated for
        // in the next burn).
        _dwCurSpeed = (WRITESPEED_FASTEST == dwCurSpeed) ? dwMaxSpeed : dwCurSpeed;

        if (SUCCEEDED(hr))
        {
            *ppdr = pdr;
            pdr->AddRef();
        }
        pdr->Release();
    }
    else
    {
        // munge S_FALSE into E_FAIL (i.e. we got through the whole enumerator without
        // finding a match, so that's bad)
        if (hr == S_FALSE)
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CCDBurn::_FindAndSetDefaultRecorder(IDiscMaster *pdm, BOOL fSetActive, IDiscRecorder **ppdr)
{
    TCHAR szCurrent[MAX_PATH];
    HRESULT hr = _GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent));
    if (SUCCEEDED(hr))
    {
        hr = _FindAndSetRecorder(szCurrent, pdm, fSetActive, ppdr);
    }
    return hr;
}

INT_PTR CALLBACK CCDBurn::_ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            {
                LPITEMIDLIST pidl;
                if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_BITBUCKET, &pidl)))
                {
                    SHFILEINFO fi;
                    if (SHGetFileInfo((LPCTSTR)pidl, 0, &fi, sizeof(fi), SHGFI_PIDL | SHGFI_ICON | SHGFI_LARGEICON))
                    {
                        ReplaceDlgIcon(hwndDlg, IDD_ICON, fi.hIcon);
                    }
                    ILFree(pidl);
                }
            }
            break;

        case WM_DESTROY:
            ReplaceDlgIcon(hwndDlg, IDD_ICON, NULL);
            break;

        case WM_COMMAND:        
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
                case IDNO:
                    EndDialog(hwndDlg, IDNO);
                    break;

                case IDYES:
                    EndDialog(hwndDlg, IDYES);
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

HRESULT CCDBurn::_CleanUp(LPCMINVOKECOMMANDINFO lpcmi, BOOL fRecycle)
{
    // delete the files in the staging area, by deleting the entire staging area

    TCHAR szStaging[MAX_PATH + 1]; // a little room for double-null
    HRESULT hr = _GetBurnStagingPath(szStaging, MAX_PATH);
    if (SUCCEEDED(hr) && PathFileExists(szStaging))
    {
        // cant use shfileop confirmation because its too hacky.
        if ((lpcmi->fMask & CMIC_MASK_FLAG_NO_UI) ||
            (IDYES == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_DELETE_STAGING), lpcmi->hwnd, _ConfirmDialogProc, NULL)))
        {
            PathAppend(szStaging, c_szStarDotStar);
            // double-null
            szStaging[lstrlen(szStaging) + 1] = 0;

            SHFILEOPSTRUCT fo = {0};
            fo.wFunc = FO_DELETE;
            fo.pFrom = szStaging;
            fo.fFlags = FOF_NOCONFIRMATION;
            if (fRecycle)
            {
                fo.fFlags |= FOF_ALLOWUNDO;
            }
            fo.hwnd = lpcmi->hwnd;

            hr = (SHFileOperation(&fo) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        }
    }
    return hr;
}

HRESULT CCDBurn::_CreateDefaultPropBag(REFIID riid, void **ppv)
{
    IPropertyBag *ppb;
    HRESULT hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        // default to think we didn't hit eject
        SHPropertyBag_WriteBOOL(ppb, PROPSTR_EJECT, FALSE);

        // do volume name
        TCHAR szDiscLabel[JOLIET_MAX_LABEL + 1];
        ULONG cb = sizeof(szDiscLabel);
        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_DISCLABEL, NULL, szDiscLabel, &cb))
        {
            // make a default string like "Feb 02 2001"
            TCHAR szFormat[JOLIET_MAX_LABEL + 1];
            LoadString(HINST_THISDLL, IDS_BURN_FORMAT_DISCLABEL, szFormat, ARRAYSIZE(szFormat));
            if (!GetDateFormat(LOCALE_USER_DEFAULT, 0, NULL, szFormat, szDiscLabel, ARRAYSIZE(szDiscLabel)))
            {
                szDiscLabel[0] = 0;
            }
        }
        SHPropertyBag_WriteStr(ppb, PROPSTR_DISCLABEL, szDiscLabel);

        // do autoclose
        DWORD dwClose;
        cb = sizeof(dwClose);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_AUTOCLOSE, NULL, &dwClose, &cb) && dwClose)
        {
            SHPropertyBag_WriteBOOL(ppb, PROPSTR_AUTOCLOSE, TRUE);
        }

        hr = ppb->QueryInterface(riid, ppv);

        ppb->Release();
    }
    return hr;
}

HRESULT CCDBurn::_PrepWiz(LPCMINVOKECOMMANDINFO lpcmi, BOOL fErase, BOOL fFailSilently)
{
    HRESULT hr = E_FAIL;
    if (s_hwndWiz)
    {
        // if we know the shell is burning and we have an hwnd to the wizard, pop it up.
        SetForegroundWindow(s_hwndWiz);
        hr = S_OK;
    }
    else
    {
        SHPropertyBag_WriteBOOL(_ppb, PROPSTR_ERASE, fErase);
        SHPropertyBag_WriteBOOL(_ppb, PROPSTR_FAILSILENTLY, fFailSilently);
        hr = _ShowWizardOnSeparateThread();
    }
    return hr;
}

void CCDBurn::_SetStatus(UINT uID)
{
    TCHAR szBuf[MAX_PATH];
    LoadString(HINST_THISDLL, uID, szBuf, ARRAYSIZE(szBuf));
    SetDlgItemText(_hwndWizardPage, IDC_BURNWIZ_STATUSTEXT, szBuf);
}

HRESULT CCDBurn::_GetDiscMasters(IDiscMaster **ppdm, IJolietDiscMaster **ppjdm)
{
    *ppdm = NULL;
    *ppjdm = NULL;

    HRESULT hr = CoCreateInstance(CLSID_MSDiscMasterObj, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IDiscMaster, ppdm));
    if (SUCCEEDED(hr))
    {
        // open() takes some time, so set up the progress dialog
        _SetStatus(IDS_BURN_INITIALIZESTASH);
        hr = (*ppdm)->Open();
        if (SUCCEEDED(hr))
        {
            hr = (*ppdm)->SetActiveDiscMasterFormat(IID_PPV_ARG(IJolietDiscMaster, ppjdm));
        }

        // clean up if we couldn't get the joliet disc master.
        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppdm);
        }
    }

    ASSERT(SUCCEEDED(hr) ? ((*ppdm != NULL) && (*ppjdm != NULL)) : ((*ppdm == NULL) && (*ppjdm == NULL)));
    return hr;
}


HRESULT CCDBurn::_AddData(IJolietDiscMaster *pjdm)
{
    _SetStatus(IDS_BURN_ADDDATA);

    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_CDBURN_AREA, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        IStorage *pstg;
        hr = SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IStorage, &pstg));
        if (SUCCEEDED(hr))
        {
            _ts.dwTickStagingStart = GetTickCount();
            hr = pjdm->AddData(pstg, 1);
            _ts.dwTickStagingEnd = GetTickCount();
            pstg->Release();
        }
        ILFree(pidl);
    }
    return hr;
}

BOOL CCDBurn::_IsBurningNow()
{
    BOOL fBurning = TRUE;
    CCDBurn *pcdb = new CCDBurn();
    if (pcdb)
    {
        // if the shell is burning, we know it for sure.  otherwise we have to check imapi to see if any other
        // process is using imapi to burn.
        if (!pcdb->s_hwndWiz && pcdb->_EnterExclusiveBurning())
        {
            pcdb->_LeaveExclusiveBurning();
            // if we can get the mutex, we're not burning.
            fBurning = FALSE;

            IDiscMaster *pdm;
            IJolietDiscMaster *pjdm;
            if (SUCCEEDED(pcdb->_GetDiscMasters(&pdm, &pjdm)))
            {
                IDiscRecorder *pdr;
                if (SUCCEEDED(pcdb->_FindAndSetDefaultRecorder(pdm, FALSE, &pdr)))
                {
                    ULONG ulState;
                    if (SUCCEEDED(pdr->GetRecorderState(&ulState)))
                    {
                        fBurning = (ulState & (RECORDER_BURNING | RECORDER_OPENED));
                    }
                    pdr->Release();
                }
                pdm->Release();
                pjdm->Release();
            }
        }
        pcdb->Release();
    }
    return fBurning;
}

// handy stuff from lowdisk
BOOL CCDBurn::_EnterExclusiveBurning()
{
    if (NULL == _hMutexBurning)
    {
        SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
        
        if (psa)
        {
            // since imapi runs in the system context and only one client can use it at a time,
            // make the mutex in the global namespace.
            _hMutexBurning = CreateMutex(psa, FALSE, L"Global\\CDBurnExclusive");
            if (!_hMutexBurning)
            {
                // we'll get here if we're running as a limited user.
                // we don't have access to the global namespace so create it in the current session.
                // this will look normal within the session but across users it'll be more bogus since we'll let the
                // user start the burn from the wizard but we'll fail later.  that's good enough.
                _hMutexBurning = CreateMutex(psa, FALSE, L"CDBurnExclusive");
            }
        }
    }
    return _hMutexBurning && (WAIT_OBJECT_0 == WaitForSingleObject(_hMutexBurning, 0));    // zero timeout
}

void CCDBurn::_LeaveExclusiveBurning()
{
    ASSERT(_hMutexBurning);
    ReleaseMutex(_hMutexBurning);
}

HRESULT CCDBurn::_Balloon()
{
    WCHAR szTitle[50];
    LoadString(HINST_THISDLL, IDS_BURN_NOTIFY_TITLE, szTitle, ARRAYSIZE(szTitle));
    WCHAR szMsg[100];
    LoadString(HINST_THISDLL, IDS_BURN_NOTIFY, szMsg, ARRAYSIZE(szMsg));

    HICON hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_DRIVECD));

    IUserNotification *pun;
    // usernotification has to go over to the main explorer.exe and we might not be it...?
    HRESULT hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_ALL, IID_PPV_ARG(IUserNotification, &pun));
    if (SUCCEEDED(hr))
    {
        pun->SetBalloonRetry(30 * 1000, -1, 0);
        pun->SetIconInfo(hIcon, szTitle);
        pun->SetBalloonInfo(szTitle, szMsg, NIIF_INFO);

        hr = pun->Show(NULL, 0);

        pun->Release();
    }

    if (hIcon)
    {
        DestroyIcon(hIcon);
    }

    return hr;
}

typedef struct
{
    LPCITEMIDLIST pidlFolder;
    BOOL fRet;
} CDBURNENUMSTRUCT;

BOOL CALLBACK CCDBurn::_EnumProc(HWND hwnd, LPCITEMIDLIST pidl, LPARAM lParam)
{
    CDBURNENUMSTRUCT *pes = (CDBURNENUMSTRUCT*)lParam;

    if (ILIsParent(pes->pidlFolder, pidl, FALSE))
    {
        pes->fRet = TRUE;
        return FALSE;  // stop enumerating, we know we got it.
    }
    return TRUE;
}

BOOL CCDBurn::_BurningFolderOpen()
{
    BOOL fRet = FALSE;

    LPITEMIDLIST pidlFolder;
    if (SUCCEEDED(_GetFolderPidl(&pidlFolder)))
    {
        CDBURNENUMSTRUCT es = { 0 };
        es.pidlFolder = pidlFolder;

        EnumShellWindows(_EnumProc, (LPARAM)&es);
        fRet = es.fRet;

        ILFree(pidlFolder);
    }
    return fRet;
}

DWORD CALLBACK CCDBurn::_NotifyThreadProc(void *pv)
{
    CCDBurn *pcdb = (CCDBurn *)pv;
    SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();

    if (psa)
    {
        HANDLE hMutexNotify = CreateMutex(psa, FALSE, L"CDBurnNotify");
        if (hMutexNotify)
        {
            if (WAIT_OBJECT_0 == WaitForSingleObject(hMutexNotify, 0))
            {
                if (!_BurningFolderOpen() && !_IsBurningNow())
                {
                    if (S_OK == pcdb->_Balloon())
                    {
                        LPITEMIDLIST pidl;
                        if (SUCCEEDED(_GetFolderPidl(&pidl)))
                        {
                            // Use shellexecuteex to open a view folder
                            SHELLEXECUTEINFO sei = { 0 };
                            sei.cbSize = sizeof(sei);
                            sei.lpIDList = pidl;
                            sei.fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_IDLIST;
                            sei.nShow = SW_SHOWNORMAL;
                            sei.lpVerb = c_szOpen;

                            ShellExecuteEx(&sei); // hardcoded to "open" on a pidl.

                            ILFree(pidl);
                        }
                    }
                }
                ReleaseMutex(hMutexNotify);
            }
            CloseHandle(hMutexNotify);
        }
    }
    pcdb->Release();
    return 0;
}

void CCDBurn::_CheckStagingArea()
{
    // only do stuff if we're enabled.
    int iCurrent;
    if (SUCCEEDED(_GetCurrentDriveIndex(&iCurrent)) && _StagingAreaHasFiles())
    {
        AddRef();
        if (!SHCreateThread(_NotifyThreadProc, this, CTF_COINIT, NULL))
        {
            Release();
        }
    }
}

STDAPI CheckStagingArea()
{
    CCDBurn *pcdb = new CCDBurn();
    if (pcdb)
    {
        pcdb->_CheckStagingArea();
        pcdb->Release();
    }
    return S_OK;
}

HRESULT _CreateDataObject(IDataObject **ppdo)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_CDBURN_AREA, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = SHGetUIObjectOf(pidl, NULL, IID_PPV_ARG(IDataObject, ppdo));
        ILFree(pidl);
    }
    return hr;
}

// this will eventually put up confirmation UI.  for now just tally size.
HRESULT CCDBurn::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    IShellFolder2 *psf2;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        ULONGLONG cbItemSize;
        if (SUCCEEDED(GetLongProperty(psf2, pidl, &SCID_SIZE, &cbItemSize)))
        {
            _cbStagedSize += cbItemSize;
        }
        psf2->Release();
    }
    return S_OK;
}

HRESULT CCDBurn::_CheckTotal()
{
    ULONGLONG cbTotal, cbFree;
    HRESULT hr = GetSpace(&cbTotal, &cbFree);
    if (SUCCEEDED(hr))
    {
        if (_cbStagedSize > cbFree)
        {
            hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);

            TCHAR szStaged[40], szFree[40], szOver[40];
            StrFormatByteSize64(_cbStagedSize, szStaged, ARRAYSIZE(szStaged));
            StrFormatByteSize64(cbFree, szFree, ARRAYSIZE(szFree));
            StrFormatByteSize64(_cbStagedSize - cbFree, szOver, ARRAYSIZE(szOver));

            LPTSTR pszMessage = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_BURN_DISCFULLTEXT), szFree, szStaged, szOver);
            if (pszMessage)
            {
                SHPropertyBag_WriteStr(_ppb, PROPSTR_DISCFULLTEXT, pszMessage);
                LocalFree(pszMessage);
            }
        }
    }
    return hr;
}

HRESULT CCDBurn::_Validate()
{
    INamespaceWalk *pnsw;
    HRESULT hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(INamespaceWalk, &pnsw));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlStaging;
        hr = SHGetFolderLocation(NULL, CSIDL_CDBURN_AREA, NULL, 0, &pidlStaging);
        if (SUCCEEDED(hr))
        {
            IShellFolder *psf;
            hr = SHBindToObjectEx(NULL, pidlStaging, NULL, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                _cbStagedSize = 0;
                // walk 15 levels deep, TODO figure out what Joliet's limitations are.
                hr = pnsw->Walk(psf, NSWF_DONT_TRAVERSE_LINKS, 15, this);
                if (SUCCEEDED(hr))
                {
                    hr = _CheckTotal();
                }
                psf->Release();
            }
            ILFree(pidlStaging);
        }
        pnsw->Release();
    }
    return hr;
}

DWORD WINAPI CCDBurn::_BurnThread(void *pv)
{
    CCDBurn *pcdb = (CCDBurn *) pv;

    HRESULT hr = pcdb->_Validate();
    if (SUCCEEDED(hr))
    {
        IDiscMaster *pdm;
        IJolietDiscMaster *pjdm;
        hr = pcdb->_GetDiscMasters(&pdm, &pjdm);
        if (SUCCEEDED(hr))
        {
            hr = pcdb->_SetJolietProps(pjdm);
            if (SUCCEEDED(hr))
            {
                UINT_PTR lCookie;
                hr = pdm->ProgressAdvise(pcdb, &lCookie);
                if (SUCCEEDED(hr))
                {
                    IDiscRecorder *pdr;
                    hr = pcdb->_FindAndSetDefaultRecorder(pdm, TRUE, &pdr);
                    if (SUCCEEDED(hr))
                    {
                        pcdb->_InitTimeStats(FALSE);
                        hr = pcdb->_AddData(pjdm);
                        boolean bCancelled;
                        pcdb->QueryCancel(&bCancelled);
                        if (SUCCEEDED(hr) && !bCancelled)
                        {
                            BOOL fAutoEject = TRUE;
                            pcdb->_GetEjectSetting(&fAutoEject);

                            // false is to make a real recording instead of a simulated one
                            hr = pdm->RecordDisc(FALSE, (boolean)fAutoEject);
                            if (SUCCEEDED(hr))
                            {
                                // bug: recorddisc doesnt call back into NotifyBurnComplete so this has to be done here
                                pcdb->_ts.dwTickCloseEnd = GetTickCount();
                                pcdb->_SaveTimeStats(FALSE);
                            }
                        }
                        pdr->Release();
                    }
                    pdm->ProgressUnadvise(lCookie);
                }
            }
            pdm->Release();
            pjdm->Release();
        }
    }

    _LockCurrentDrive(FALSE);

    if (!pcdb->_fCancelled)
    {
        SHPropertyBag_WriteDWORD(pcdb->_ppb, PROPSTR_HR, hr);
        PropSheet_SetWizButtons(GetParent(pcdb->_hwndWizardPage), PSWIZB_NEXT);
        PropSheet_PressButton(GetParent(pcdb->_hwndWizardPage), PSBTN_NEXT);
    }

    pcdb->Release();
    return 0;
}

DWORD WINAPI CCDBurn::_EraseThread(void *pv)
{
    CCDBurn *pcdb = (CCDBurn *) pv;

    IDiscMaster *pdm;
    IJolietDiscMaster *pjdm;
    HRESULT hr = pcdb->_GetDiscMasters(&pdm, &pjdm);
    if (SUCCEEDED(hr))
    {
        IDiscRecorder *pdr;
        hr = pcdb->_FindAndSetDefaultRecorder(pdm, FALSE, &pdr);
        if (SUCCEEDED(hr))
        {
            pcdb->_SetStatus(IDS_BURN_ERASEDISC);
            hr = pdr->OpenExclusive();
            if (SUCCEEDED(hr))
            {
                pcdb->_InitTimeStats(TRUE);
                pcdb->_ts.dwTickEraseStart = GetTickCount();
                hr = pdr->Erase(FALSE);   // do quick erase
                if (SUCCEEDED(hr))
                {
                    hr = pdr->Close();
                    // bug: this is here only because Erase doesn't call NotifyEraseComplete
                    pcdb->_ts.dwTickEraseEnd = GetTickCount();
                    pcdb->_SaveTimeStats(TRUE);
                }
            }
            pdr->Release();
        }
        pdm->Release();
        pjdm->Release();
    }

    _LockCurrentDrive(FALSE);

    if (!pcdb->_fCancelled)
    {
        SHPropertyBag_WriteDWORD(pcdb->_ppb, PROPSTR_HR, hr);
        PropSheet_SetWizButtons(GetParent(pcdb->_hwndWizardPage), PSWIZB_NEXT);
        PropSheet_PressButton(GetParent(pcdb->_hwndWizardPage), PSBTN_NEXT);
    }

    pcdb->Release();
    return 0;
}

HRESULT CCDBurn::_GetPidlForDriveIndex(int iDrive, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;

    TCHAR szPath[4];
    if (PathBuildRoot(szPath, iDrive))
    {
        hr = SHILCreateFromPath(szPath, ppidl, NULL);
    }
    return hr;
}

HRESULT CCDBurn::_GetPidlForVolumeName(LPCTSTR pszVolume, LPITEMIDLIST *ppidl)
{
    int iDrive;
    HRESULT hr = _GetDriveIndexForVolumeName(pszVolume, &iDrive);
    if (SUCCEEDED(hr))
    {
        WCHAR szRoot[4];
        hr = PathBuildRoot(szRoot, iDrive) ? S_OK : E_FAIL;
        if (SUCCEEDED(hr))
        {
            hr = SHILCreateFromPath(szRoot, ppidl, NULL);
        }
    }
    return hr;
}

HRESULT CCDBurn::_GetFolderPidl(LPITEMIDLIST *ppidl)
{
    TCHAR szCurrent[MAX_PATH];
    HRESULT hr = _GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent));
    if (SUCCEEDED(hr))
    {
        hr = _GetPidlForVolumeName(szCurrent, ppidl);
    }
    return hr;
}

void CCDBurn::_HandleBookkeeping()
{
    _DumpDiscInfo();
    _StoreDiscInfo();
}

// IDropTarget handling
//  This code forwards to drop target folder for the currently configured burn drive.

// merged folder hands off to ccdburn because otherwise it'd be doing too much
// cd burning specific stuff (media detection on drop, etc.)

HRESULT CCDBurn::_EnsureDropTarget()
{
    HRESULT hr = S_OK;
    if (!_pdt)
    {
        if (_BurningIsEnabled())
        {
            TCHAR szStaging[MAX_PATH];
            hr = _GetBurnStagingPath(szStaging, ARRAYSIZE(szStaging));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidl;
                hr = SHILCreateFromPath(szStaging, &pidl, NULL);
                if (SUCCEEDED(hr))
                {
                    IShellFolder *psf;
                    hr = SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IShellFolder, &psf));
                    if (SUCCEEDED(hr))
                    {
                        hr = psf->CreateViewObject(NULL, IID_PPV_ARG(IDropTarget, &_pdt));
                        psf->Release();
                    }
                    ILFree(pidl);
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CCDBurn::_GetDropPidl(LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    if (!_pidl)
    {
        // in the sendto case we aren't called through Initialize, so get default root pidl.
        hr = _GetFolderPidl(ppidl);
    }
    else
    {
        hr = SHILClone(_pidl, ppidl);
    }
    return hr;
}

HRESULT CCDBurn::_StagingPidlFromMerged(LPCITEMIDLIST pidlDrop, LPITEMIDLIST *ppidlDest)
{
    IAugmentedShellFolder *pasf;
    HRESULT hr = SHBindToObjectEx(NULL, pidlDrop, NULL, IID_PPV_ARG(IAugmentedShellFolder, &pasf));
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        
        DWORD dwNSId;
        GUID guid;
        IShellFolder *psf;
        BOOL fDone = FALSE;
        for (DWORD dwIndex = 0; 
             !fDone && SUCCEEDED(pasf->EnumNameSpace(dwIndex, &dwNSId)) && SUCCEEDED(pasf->QueryNameSpace(dwNSId, &guid, &psf));
             dwIndex++)
        {
            if (IsEqualGUID(guid, CLSID_StagingFolder))
            {
                IPersistFolder3 *ppf3;
                hr = psf->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf3));
                if (SUCCEEDED(hr))
                {
                    PERSIST_FOLDER_TARGET_INFO pfti = {0};
                    hr = ppf3->GetFolderTargetInfo(&pfti);
                    if (SUCCEEDED(hr))
                    {
                        *ppidlDest = pfti.pidlTargetFolder;
                    }
                    ppf3->Release();
                }
                fDone = TRUE;
            }                
            psf->Release();
        }
        pasf->Release();
    }
    return hr;
}

BOOL CCDBurn::_IsStagingAreaSource(IDataObject *pdtobj, LPCITEMIDLIST pidlDrop)
{
    BOOL fParent = FALSE; //source is parent of destination
    BOOL fSame = FALSE; //source and destination are the same
    // in UDF case we skip staging area so no need to do this work
    BOOL fUDF = FALSE;
    _GetMediaCapabilities(NULL, &fUDF);
    if (!fUDF)
    {
        LPITEMIDLIST pidlDest;
        if (SUCCEEDED(_StagingPidlFromMerged(pidlDrop, &pidlDest)))
        {
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                LPCITEMIDLIST pidlSource = IDA_GetIDListPtr(pida, -1);
                if (pidlSource)
                {
                    if (!ILIsEmpty(pidlSource))
                    {
                        fSame = ILIsEqual(pidlSource, pidlDest);
                        if (!fSame && ILIsParent(pidlSource, pidlDest, FALSE))
                        {
                            LPCITEMIDLIST pidl;
                            for (UINT i = 0; !fSame && !fParent && (pidl = IDA_GetIDListPtr(pida, i)); i++)
                            {
                                LPITEMIDLIST pidlFull = ILCombine(pidlSource, pidl);
                                if (pidlFull)
                                {
                                    fSame = ILIsEqual(pidlFull, pidlDest);
                                    if (!fSame)
                                        fParent = ILIsParent(pidlFull, pidlDest, FALSE);
                                    ILFree(pidlFull);
                                }
                            }
                        }                        
                    }
                    else //find folder has full pidls and empty one for a source
                    {
                        LPCITEMIDLIST pidl;
                        for (UINT i = 0; !fSame && !fParent && (pidl = IDA_GetIDListPtr(pida, i)); i++)
                        {
                            LPITEMIDLIST pidlParent = ILCloneParent(pidl);
                            if (pidlParent)
                            {
                                fSame = ILIsEqual(pidlParent, pidlDest) || ILIsEqual(pidl, pidlDest);
                                if (!fSame)
                                    fParent = ILIsParent(pidl, pidlDest, FALSE);
                                ILFree(pidlParent);
                            }
                        }
                    }
                }
                HIDA_ReleaseStgMedium(pida, &medium);
            }
            ILFree(pidlDest);
        }
    }

    if (fSame || fParent)
    {
        UINT idMessage = fSame ? IDS_REASONS_DESTSAMETREE : IDS_REASONS_DESTSUBTREE;
        ShellMessageBox(g_hinst, _hwndBrowser, MAKEINTRESOURCE(idMessage), MAKEINTRESOURCE(IDS_BURN), MB_ICONEXCLAMATION | MB_OK);
    }
    return (fSame || fParent);
}

HRESULT CCDBurn::_StorageDrop(IDataObject *pdtobj, BOOL fMove)
{
    LPITEMIDLIST pidlDrop;
    HRESULT hr = _GetDropPidl(&pidlDrop);
    if (SUCCEEDED(hr))
    {
        if (!_IsStagingAreaSource(pdtobj, pidlDrop))
        {
            IShellItem *psiDest;
            hr = SHCreateShellItem(NULL, NULL, pidlDrop, &psiDest);
            if (SUCCEEDED(hr))
            {
                hr = TransferDataObject(pdtobj, psiDest, fMove ? STGOP_MOVE : STGOP_COPY_PREFERHARDLINK, 0, this);
                psiDest->Release();
            }
        }
        else
        {
            hr = E_FAIL;
        }
        ILFree(pidlDrop);
    }
    return hr;
}

HRESULT CCDBurn::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // lets get the drop object for the folder that is configured for the
    // burn drive.  to do this we need to get the staging folder.

    // this also determines if we show up in sendto or not.
    HRESULT hr = _EnsureDropTarget();
    if (SUCCEEDED(hr) && _pdt)
    {
        hr = _pdt->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
    }
    else
    {
        // there was no drop target, therefore there is no burn drive, therefore we shouldn't
        // offer the ability to drag drop onto our object.
        *pdwEffect = DROPEFFECT_NONE;
    }
    _dwDropEffect = *pdwEffect;
    return hr;
}

HRESULT CCDBurn::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_FAIL;
    if (_pdt)
    {
        hr = _pdt->DragOver(grfKeyState, pt, pdwEffect);
        _dwDropEffect = *pdwEffect;
    }
    return hr;
}

HRESULT CCDBurn::DragLeave(void)
{
    if (!_pdt)
        return E_FAIL;

    return _pdt->DragLeave();
}

void CCDBurn::_FreeDropParams(CDDROPPARAMS *pcddp)
{
    pcddp->pcdb->Release();
    ATOMICRELEASE(pcddp->pstmDataObj);
    delete pcddp;
}

DWORD WINAPI CCDBurn::_DropThread(void *pv)
{
    CDDROPPARAMS *pcddp = (CDDROPPARAMS*)pv;

    IDataObject *pdtobj;
    if (SUCCEEDED(CoGetInterfaceAndReleaseStream(pcddp->pstmDataObj, IID_PPV_ARG(IDataObject, &pdtobj))))
    {
        pcddp->pcdb->_StorageDrop(pdtobj, pcddp->fMove);
        pdtobj->Release();
    }
    pcddp->pstmDataObj = NULL; // released by CoGetInterfaceAndReleaseStream

    _FreeDropParams(pcddp);
    return 0;
}

HRESULT CCDBurn::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_OUTOFMEMORY;
    CDDROPPARAMS *pcddp = new CDDROPPARAMS;
    if (pcddp)
    {
        // get the hwnd from the site while we're on this thread so that we
        // don't get SetSite(NULL) before we check it later.
        IOleWindow *pow;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pow))))
        {
            pow->GetWindow(&_hwndBrowser);
            pow->Release();
        }

        pcddp->pcdb = this;
        AddRef();

        CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdtobj, &pcddp->pstmDataObj);

        pcddp->fMove = (_dwDropEffect == DROPEFFECT_MOVE);
        if (pcddp->fMove)
        {
            _dwDropEffect = DROPEFFECT_NONE; // other thread will take care of move, so caller should take no action
        }
        *pdwEffect = _dwDropEffect;

        if (SHCreateThread(_DropThread, pcddp, CTF_COINIT, NULL))
        {
            hr = S_OK;
        }
        else
        {
            _FreeDropParams(pcddp);
            hr = E_OUTOFMEMORY;
        }
    }
    DragLeave();
    return hr;
}

// Helper function to get an IShellFolder object for the staging folder

HRESULT CCDBurn::_GetStagingFolder(LPCITEMIDLIST pidlDrive, REFIID riid, void **ppv)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = CCDBurn::_GetBurnStagingPath(szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr))
    {
        // fake up a directory object simple IDLIST          
        WIN32_FIND_DATA fd = {0};
        fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;        

        LPITEMIDLIST pidlStg;
        hr = SHSimpleIDListFromFindData(szPath, &fd, &pidlStg);
        if (SUCCEEDED(hr))
        {
            // now initialize the folder with it
            PERSIST_FOLDER_TARGET_INFO pfti = {0};

            pfti.pidlTargetFolder = (LPITEMIDLIST)pidlStg;
            SHTCharToUnicode(szPath, pfti.szTargetParsingName, ARRAYSIZE(pfti.szTargetParsingName));
            pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY; // maybe add system?
            pfti.csidl = -1;

            hr = CFSFolder_CreateFolder(NULL, NULL, pidlDrive, &pfti, riid, ppv);
            ILFree(pidlStg);
        }
    }
    return hr;
}

// ripped from IMAPI.
DWORD CCDBurn::_ExecSyncIoctl(HANDLE hDriver, DWORD dwIoctl, void *pbuf, DWORD cbBuf)
{
    DWORD dwResult = NO_ERROR;
    OVERLAPPED ol = { 0 };
    ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ol.hEvent)
    {
        DWORD dwBytes;
        BOOL bStatus = DeviceIoControl(hDriver, dwIoctl, pbuf, cbBuf, pbuf, cbBuf, &dwBytes, &ol);
        if (!bStatus)
        {
            dwResult = GetLastError();
            if (ERROR_IO_PENDING == dwResult)
            {
                bStatus = GetOverlappedResult(hDriver, &ol, &dwBytes, TRUE);
                dwResult = bStatus ? NO_ERROR : GetLastError();
            }
        }
        CloseHandle(ol.hEvent);
    }
    else
    {
        dwResult = ERROR_OUTOFMEMORY;
    }
    return dwResult;
}

// {1186654D-47B8-48b9-BEB9-7DF113AE3C67}
static const GUID IMAPIDeviceInterfaceGUID = { 0x1186654d, 0x47b8, 0x48b9, { 0xbe, 0xb9, 0x7d, 0xf1, 0x13, 0xae, 0x3c, 0x67 } };
// this is a first approximation to see if the drive is supported or not to avoid loading imapi at boot
// whenever possible.  if this passes, then we still have to use imapi to make sure, but if this returns
// false, theres no way imapi will support it.
// note that this mimics the logic in imapi's CMSEnumDiscRecordersObj::Next enumerator function.
BOOL CCDBurn::_CouldPossiblySupport(LPCWSTR pszVolume)
{
    // if the user isnt an admin, then these checks wont work.
    // just assume that we could support it, and let imapi do the privileged stuff since its a service.
    // perfwise this isnt such a big hit since the admin home user is the main scenario.
    if (!IsUserAnAdmin())
        return TRUE;

    BOOL fSupported = FALSE;
    HDEVINFO hDevInfo = SetupDiGetClassDevs(&IMAPIDeviceInterfaceGUID, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
    if (INVALID_HANDLE_VALUE != hDevInfo)
    {
        SP_DEVICE_INTERFACE_DATA did = { 0 };
        did.cbSize = sizeof(did);
        for (int i = 0; !fSupported && SetupDiEnumDeviceInterfaces(hDevInfo, 0, &IMAPIDeviceInterfaceGUID, i, &did); i++)
        {
            ULONG cbRequired = 0;
            SetupDiGetDeviceInterfaceDetail(hDevInfo, &did, NULL, 0, &cbRequired, NULL);
            if (cbRequired > 0)
            {
                cbRequired += sizeof(WCHAR);
                PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LPTR, cbRequired);
                if (pdidd)
                {
                    pdidd->cbSize = sizeof(*pdidd);
                    SP_DEVINFO_DATA dd = { 0 };
                    dd.cbSize = sizeof(dd);
                    if (SetupDiGetDeviceInterfaceDetail(hDevInfo, &did, pdidd, cbRequired, NULL, &dd))
                    {
                        WCHAR szLower[100];
                        BOOL fHasFilter = FALSE;
                        if (SetupDiGetDeviceRegistryProperty(hDevInfo, &dd, SPDRP_LOWERFILTERS, NULL, (BYTE*)szLower, sizeof(szLower), NULL))
                        {
                            PCWSTR psz = szLower;
                            while (*psz && !fHasFilter)
                            {
                                if (StrCmpI(psz, L"imapi") == 0)
                                {
                                    fHasFilter = TRUE;
                                }
                                psz += lstrlenW(psz) + 1;
                            }
                        }

                        if (fHasFilter)
                        {
                            HANDLE hDriver = CreateFile(pdidd->DevicePath, GENERIC_READ | GENERIC_WRITE,
                                                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                                                        FILE_FLAG_OVERLAPPED, NULL);
                            if (INVALID_HANDLE_VALUE != hDriver)
                            {
                                STORAGE_DEVICE_NUMBER sdn = { 0 };
                                if (NO_ERROR == _ExecSyncIoctl(hDriver, IOCTL_STORAGE_GET_DEVICE_NUMBER, &sdn, sizeof(sdn)))
                                {
                                    WCHAR szDevicePath[50];
                                    wnsprintf(szDevicePath, ARRAYSIZE(szDevicePath), L"\\Device\\CdRom%d", sdn.DeviceNumber);
                                    fSupported = _DevicePathMatchesVolumeName(szDevicePath, pszVolume);
                                }
                                CloseHandle(hDriver);
                            }
                        }
                    }
                    LocalFree(pdidd);
                }
            }
        }
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    return fSupported;
}

HRESULT CDBurn_OnDeviceAdded(DWORD dwDriveMask, BOOL fFullRefresh, BOOL fPickNewDrive)
{
    HRESULT hr = S_OK;

    // only do stuff if the user doesn't have a drive configured already
    TCHAR szDummy[MAX_PATH];
    HRESULT hrCheck = CCDBurn::_GetCurrentBurnVolumeName(szDummy, ARRAYSIZE(szDummy));
    // if hr == E_UNEXPECTED, then there's already a empty string in the registry for the current
    // burn drive.  that means the user disabled the functionality so don't put it back.
    if (fFullRefresh || (FAILED(hrCheck) && (hrCheck != E_UNEXPECTED)))
    {
        hr = E_OUTOFMEMORY;
        CCDBurn *pcdb = new CCDBurn();
        if (pcdb)
        {
            // keep track of the fastest drive in the system to default to.
            DWORD dwBestWrite = 0;
            TCHAR szNewBurnVolume[MAX_PATH];

            // only run through this if the device that just got added is a cd.
            // this drive letter stuff is weak but it's what comes from base's notification.
            BOOL fCheck = FALSE;
            for (int i = 0; i < 26; i++)
            {
                TCHAR szDriveLetter[4];
                if (PathBuildRoot(szDriveLetter, i) &&
                    (GetDriveType(szDriveLetter) == DRIVE_CDROM))
                {
                    TCHAR szVolumeName[MAX_PATH];
                    if (SUCCEEDED(CCDBurn::_GetVolumeNameForDriveIndex(i, szVolumeName, ARRAYSIZE(szVolumeName))))
                    {
                        DWORD dwMaxWrite, dwDriveType;
                        // if we already have info on the drive, we don't need to worry about it.
                        // if we dont have info, check it.
                        // if we're doing a full refresh then always recheck if it wasnt supported before --
                        // this could happen if a driver update across a reboot caused a drive to get supported.
                        if (FAILED(CCDBurn::_GetCachedDriveInfo(szVolumeName, &dwDriveType, NULL, &dwMaxWrite)) ||
                            (fFullRefresh && !SUPPORTED(dwDriveType)))
                        {
                            if (CCDBurn::_CouldPossiblySupport(szVolumeName))
                            {
                                // all new cd-rom drives need to be checked with IMAPI.
                                fCheck = TRUE;
                            }
                            // default to unsupported.  this is so we don't have to hit IMAPI on
                            // the property sheet later.
                            CCDBurn::_SetCachedDriveInfo(szVolumeName, DRIVE_NOTSUPPORTED, 0, 0);
                        }
                        else
                        {
                            if (SUPPORTED(dwDriveType) && (dwMaxWrite > dwBestWrite))
                            {
                                // we'll always take the fastest one
                                dwBestWrite = dwMaxWrite;
                                lstrcpyn(szNewBurnVolume, szVolumeName, ARRAYSIZE(szNewBurnVolume));
                            }
                        }
                    }
                }
            }

            // okay we have to enumerate through IMAPI.
            if (fCheck)
            {
                IDiscMaster *pdm;
                IJolietDiscMaster *pjdm;
                hr = pcdb->_GetDiscMasters(&pdm, &pjdm);
                if (SUCCEEDED(hr))
                {
                    IEnumDiscRecorders *penumdr;
                    hr = pdm->EnumDiscRecorders(&penumdr);
                    if (SUCCEEDED(hr))
                    {
                        ULONG celt;
                        IDiscRecorder *pdr;
                        while (S_OK == penumdr->Next(1, &pdr, &celt))
                        {
                            TCHAR szDevicePath[MAX_PATH];
                            if (SUCCEEDED(pcdb->_GetRecorderPath(pdr, szDevicePath, ARRAYSIZE(szDevicePath))))
                            {
                                DWORD dwMaxWrite, dwDriveType;
                                if (SUCCEEDED(pcdb->_GetDiscRecorderInfo(pdr, NULL, &dwMaxWrite, &dwDriveType)))
                                {
                                    TCHAR szVolumeName[MAX_PATH];
                                    if (SUCCEEDED(pcdb->_GetVolumeNameForDevicePath(szDevicePath, szVolumeName, ARRAYSIZE(szVolumeName))))
                                    {
                                        if (dwMaxWrite > dwBestWrite)
                                        {
                                            // we'll always take the fastest one
                                            dwBestWrite = dwMaxWrite;
                                            lstrcpyn(szNewBurnVolume, szVolumeName, ARRAYSIZE(szNewBurnVolume));
                                        }
                                        // default to fastest speed for the drive
                                        pcdb->_SetCachedDriveInfo(szVolumeName, dwDriveType, WRITESPEED_FASTEST, dwMaxWrite);
                                    }
                                }
                            }
                            pdr->Release();
                        }
                        penumdr->Release();
                    }
                    pdm->Release();
                    pjdm->Release();
                }
            }

            if (fPickNewDrive && (dwBestWrite > 0))
            {
                pcdb->_SetCurrentBurnVolumeName(szNewBurnVolume, FALSE);
            }
            pcdb->Release();
        }
    }
    return hr;
}

void CCDBurn::_PruneRemovedDevices()
{
    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DRIVES, 0, KEY_READ, &hk))
    {
        // since we're deleting as we're moving along, walk backwards.
        DWORD dwLast;
        if (ERROR_SUCCESS == RegQueryInfoKey(hk, NULL, NULL, NULL, &dwLast, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
        {
            TCHAR szVolKey[MAX_PATH];
            for (int i = dwLast - 1; (i >= 0) && ERROR_SUCCESS == RegEnumKey(hk, i, szVolKey, ARRAYSIZE(szVolKey)); i--)
            {
                TCHAR szCachedVol[MAX_PATH];
                lstrcpyn(szCachedVol, L"\\\\?\\", ARRAYSIZE(szCachedVol));
                StrCatBuff(szCachedVol, szVolKey, ARRAYSIZE(szCachedVol));
                StrCatBuff(szCachedVol, L"\\", ARRAYSIZE(szCachedVol));

                int iDrive;
                if (FAILED(CCDBurn::_GetDriveIndexForVolumeName(szCachedVol, &iDrive)))
                {
                    // this drive is dead, remove its cached info
                    TCHAR szRegPath[MAX_PATH];
                    lstrcpyn(szRegPath, REGSTR_PATH_DRIVES, ARRAYSIZE(szRegPath));
                    StrCatBuff(szRegPath, L"\\", ARRAYSIZE(szRegPath));
                    StrCatBuff(szRegPath, szVolKey, ARRAYSIZE(szRegPath));
                    SHDeleteKey(HKEY_CURRENT_USER, szRegPath);
                }
            }
        }
        RegCloseKey(hk);
    }
}

HRESULT CDBurn_OnDeviceRemoved(DWORD dwDriveMask)
{
    HRESULT hr = S_OK;

    // see if the selected drive just got removed.
    TCHAR szVolumeName[MAX_PATH];
    HRESULT hrCheck = CCDBurn::_GetCurrentBurnVolumeName(szVolumeName, ARRAYSIZE(szVolumeName));

    CCDBurn::_PruneRemovedDevices();

    BOOL fFound = FALSE;
    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DRIVES, 0, KEY_READ, &hk))
    {
        TCHAR szVolKey[MAX_PATH];
        for (int i = 0; ERROR_SUCCESS == RegEnumKey(hk, i, szVolKey, ARRAYSIZE(szVolKey)); i++)
        {
            TCHAR szCachedVol[MAX_PATH];
            lstrcpyn(szCachedVol, L"\\\\?\\", ARRAYSIZE(szCachedVol));
            StrCatBuff(szCachedVol, szVolKey, ARRAYSIZE(szCachedVol));
            StrCatBuff(szCachedVol, L"\\", ARRAYSIZE(szCachedVol));

            int iDrive;
            if (SUCCEEDED(CCDBurn::_GetDriveIndexForVolumeName(szCachedVol, &iDrive)) &&
                SUCCEEDED(hrCheck) && (lstrcmpi(szCachedVol, szVolumeName) == 0))
            {
                // we found the drive that's currently enabled.
                // this means it's still currently mounted.

                // now check if either we dont have a cached index, or if the cached index is still the
                // same as it is now.  then we really didn't change.
                DWORD dwIndex, cb = sizeof(dwIndex);
                if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX, NULL, &dwIndex, &cb)) ||
                    (dwIndex == iDrive))
                {
                    fFound = TRUE;
                }
            }
        }
        RegCloseKey(hk);
    }

    if (SUCCEEDED(hrCheck) && !fFound)
    {
        // zonk the currently selected drive, we'll pick a new one from the rest.
        // this is all because the drive letter scheme doesn't let us get back to the volume name
        // since the drive letter is gone at this point.
        CCDBurn::_SetCurrentBurnVolumeName(TEXT(""), TRUE);
        hr = CDBurn_OnDeviceAdded(0, FALSE, TRUE);
    }
    return hr;
}

HRESULT CDBurn_OnDeviceChange(BOOL fAdd, LPCWSTR pszDrive)
{
    int iDriveIndex = PathGetDriveNumber(pszDrive);
    if (fAdd)
        CDBurn_OnDeviceAdded(1 << iDriveIndex, FALSE, TRUE);
    else
        CDBurn_OnDeviceRemoved(1 << iDriveIndex);
    return S_OK;
}

BOOL CCDBurn::_HasMedia()
{
    // unfortunately we have to assume there's media unless we find otherwise.
    BOOL fHasMedia = TRUE;

    CCDBurn *pcdb = new CCDBurn();
    if (pcdb)
    {
        IDiscMaster *pdm;
        IJolietDiscMaster *pjdm;
        if (SUCCEEDED(pcdb->_GetDiscMasters(&pdm, &pjdm)))
        {
            IDiscRecorder *pdr;
            if (SUCCEEDED(pcdb->_FindAndSetDefaultRecorder(pdm, FALSE, &pdr)))
            {
                if (SUCCEEDED(pdr->OpenExclusive()))
                {
                    long lMediaType, lMediaFlags;
                    if (SUCCEEDED(pdr->QueryMediaType(&lMediaType, &lMediaFlags)))
                    {
                        if (!lMediaType && !lMediaFlags)
                        {
                            fHasMedia = FALSE;
                        }
                    }
                    pdr->Close();
                }
                pdr->Release();
            }
            pdm->Release();
            pjdm->Release();
        }
        pcdb->Release();
    }
    return fHasMedia;
}

// this is called by mountpoint code BEFORE sending off the SHCNE_MEDIA events
// checking stuff on the media has to be done synchronously because it uses
// IMAPI and IMAPI can only have one caller at a time.
// autorun and things responding to SHCNE_MEDIA may also use IMAPI so we need to
// get this out of the way ASAP when media is inserted.
HRESULT CDBurn_OnMediaChange(BOOL fInsert, LPCWSTR pszDrive)
{
    int iCurrent;
    HRESULT hr = CCDBurn::_GetCurrentDriveIndex(&iCurrent);
    if (SUCCEEDED(hr) && (PathGetDriveNumber(pszDrive) == iCurrent))
    {
        if (fInsert)
        {
            CCDBurn::_HandleBookkeeping();
        }
        else if (!CCDBurn::_HasMedia())
        {
            CDBurn_OnEject(NULL, iCurrent);
        }
    }
    return hr;
}

HRESULT CDBurn_OnEject(HWND hwnd, INT iDrive)
{
    int iCurrent;
    HRESULT hr = CCDBurn::_GetCurrentDriveIndex(&iCurrent);
    if (SUCCEEDED(hr))
    {
        CCDBurn *pcdb = new CCDBurn();
        if (pcdb)
        {
            // we need to know whether to put up the dialog or not based on if the last
            // media was writable.  we cant check the media now since in the non-MMC2 case
            // the media is already ejected at this point, so we hit up our cache.
            DWORD dwMediaCap;
            DWORD cb = sizeof(dwMediaCap);
            if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_MEDIATYPE, NULL, &dwMediaCap, &cb) &&
                (dwMediaCap & HWDMC_CDRECORDABLE))
            {
                pcdb->_DumpDiscInfo();
                if ((iDrive == iCurrent) && CCDBurn::_StagingAreaHasFiles())
                {
                    IPropertyBag *ppb;
                    hr = pcdb->_CreateDefaultPropBag(IID_PPV_ARG(IPropertyBag, &ppb));
                    if (SUCCEEDED(hr))
                    {
                        SHPropertyBag_WriteBOOL(ppb, PROPSTR_EJECT, TRUE);
                        hr = pcdb->Load(ppb, NULL);
                        if (SUCCEEDED(hr))
                        {
                            CMINVOKECOMMANDINFO cmi = { 0 };
                            hr = pcdb->_PrepWiz(&cmi, FALSE, TRUE);
                        }
                        ppb->Release();
                    }
                }
            }
            else
            {
                pcdb->_DumpDiscInfo();
                hr = S_OK;
            }
            pcdb->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

// IOleCommandTarget implementation

HRESULT CCDBurn::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        // We like Shell Service Object notifications...
        hr = S_OK;
    }

    return hr;
}

DWORD WINAPI CCDBurn::_ExecThread(void *pv)
{
    CCDBurn *pcdb = (CCDBurn *)pv;

    // just in case explorer AV'd while holding the lock, unlock the next time we come up.
    // there's no way to guard against this.
    pcdb->_LockCurrentDrive(FALSE, TRUE);

    // hardware may have been added while we were powered down, and it won't generate
    // a notification event so we have to assume that anything could have changed
    // (inf registration for existing drives too, usually ones that require reboot to update).

    pcdb->_PruneRemovedDevices();

    // save off the currently selected drive and its write speed
    TCHAR szCurrent[MAX_PATH];
    DWORD dwCurWrite;
    HRESULT hrName = pcdb->_GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent));
    if (SUCCEEDED(hrName))
    {
        DWORD dwType;
        hrName = pcdb->_GetCachedDriveInfo(szCurrent, &dwType, &dwCurWrite, NULL);
        // if the drive has become unsupported, we need to drop our currently selected
        // drive.
        if (SUCCEEDED(hrName) && !SUPPORTED(dwType))
        {
            hrName = E_FAIL;
        }
    }

    BOOL fSet = SUCCEEDED(hrName);
    // if it's E_UNEXPECTED then the user has disabled the burning feature completely.
    BOOL fDisabled = (hrName == E_UNEXPECTED);

    // readd devices, syncro
    CDBurn_OnDeviceAdded(0xFFFFFFFF, TRUE, !fSet);

    DWORD dwDriveType;
    if (fDisabled)
    {
        // if we're disabled, stay disabled
        pcdb->_SetCurrentBurnVolumeName(L"", FALSE);
    }
    else if (fSet && SUCCEEDED(pcdb->_GetCachedDriveInfo(szCurrent, &dwDriveType, NULL, NULL)) && SUPPORTED(dwDriveType))
    {
        // if the device we were using before is still supported, use the previous write speed
        pcdb->_SetCachedDriveInfo(szCurrent, DRIVE_USEEXISTING, dwCurWrite, 0);
    }

    if (pcdb->_BurningIsEnabled())
    {
        pcdb->_HandleBookkeeping();

        int iDrive;
        if (SUCCEEDED(pcdb->_GetCurrentDriveIndex(&iDrive)))
        {
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX, REG_DWORD, &iDrive, sizeof(iDrive));
        }
        else
        {
            SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX);
        }
    }

    pcdb->Release();
    return 0;
}

HRESULT CCDBurn::Exec(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        hr = S_OK; // Any ol' notification is ok with us
        // Handle Shell Service Object notifications here.
        switch (nCmdID)
        {
            case SSOCMDID_OPEN:
                // we're on the tray's thread as a service object so lets create our own thread.
                // this is fine since our thread is bound by IOCTLs to the CD-R etc.
                AddRef();
                if (SHCreateThread(_ExecThread, this, CTF_COINIT, NULL))
                    break;

                Release();
                break;

            default:
                break;
        }
    }

    return hr;
}

HRESULT CCDBurn::GetRecorderDriveLetter(LPWSTR pszDrive, UINT cch)
{
    if (cch < 4)
        return E_INVALIDARG;

    int iDrive;
    HRESULT hr = _GetCurrentDriveIndex(&iDrive);
    if (SUCCEEDED(hr))
    {
        // pathbuildroot assumes cch >= 4
        hr = PathBuildRoot(pszDrive, iDrive) ? S_OK : E_FAIL;
    }
    return hr;
}

// helper for lazy callers within shell32
STDAPI CDBurn_GetRecorderDriveLetter(LPWSTR pszDrive, UINT cch)
{
    ICDBurn *pcdb;
    HRESULT hr = CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICDBurn, &pcdb));
    if (SUCCEEDED(hr))
    {
        hr = pcdb->GetRecorderDriveLetter(pszDrive, cch);
        pcdb->Release();
    }
    return hr;
}

HRESULT CCDBurn::Burn(HWND hwnd)
{
    HRESULT hr = InitNew();
    if (SUCCEEDED(hr))
    {
        // do this synchronously, callers will handle putting it on a separate thread.
        // this is easier than making a callback to tell them when its done.
        hr = _WizardThreadProc();
    }
    return hr;
}

HRESULT CCDBurn::HasRecordableDrive(BOOL *pfHasRecorder)
{
    *pfHasRecorder = FALSE;

    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DRIVES, 0, KEY_READ, &hk))
    {
        TCHAR szVolKey[MAX_PATH];
        for (int i = 0; !*pfHasRecorder && (ERROR_SUCCESS == RegEnumKey(hk, i, szVolKey, ARRAYSIZE(szVolKey))); i++)
        {
            TCHAR szRegPath[MAX_PATH];
            lstrcpyn(szRegPath, REGSTR_PATH_DRIVES, ARRAYSIZE(szRegPath));
            StrCatBuff(szRegPath, L"\\", ARRAYSIZE(szRegPath));
            StrCatBuff(szRegPath, szVolKey, ARRAYSIZE(szRegPath));

            DWORD dwType;
            ULONG cb = sizeof(dwType);
            if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_DRIVETYPE, NULL, &dwType, &cb))
            {
                *pfHasRecorder = SUPPORTED(dwType);
            }
        }
        RegCloseKey(hk);
    }
    return S_OK;
}

HRESULT CCDBurn::_DumpDiscInfo()
{
    SHDeleteKey(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA);
    return S_OK;
}

HRESULT CCDBurn::_GetDiscInfoUsingIMAPI(IJolietDiscMaster *pjdm, IDiscRecorder *pdr, ULONGLONG *pcbFree)
{
    HRESULT hr = E_FAIL;
    BYTE bSessions, bLastTrack;
    LONG nBlockBytes;
    ULONG ulStartAddress, ulNextWritable, ulFreeBlocks;
    if (SUCCEEDED(pjdm->GetDataBlockSize(&nBlockBytes)) &&
        SUCCEEDED(pdr->QueryMediaInfo(&bSessions, &bLastTrack, &ulStartAddress, &ulNextWritable, &ulFreeBlocks)))
    {
        hr = S_OK;
        *pcbFree = (ULONGLONG) ulFreeBlocks * nBlockBytes;
    }
    return hr;
}

HRESULT CCDBurn::_GetDiscInfoUsingFilesystem(ULONGLONG *pcbTotal, ULONGLONG *pcbFree, BOOL *pfUDF)
{
    int iCurrent;
    HRESULT hr = _GetCurrentDriveIndex(&iCurrent);
    if (SUCCEEDED(hr))
    {
        *pcbTotal = 0;
        *pcbFree = 0;
        ULARGE_INTEGER ulTotal, ulFree;
        TCHAR szRoot[4];
        if (PathBuildRoot(szRoot, iCurrent) && SHGetDiskFreeSpace(szRoot, &ulFree, &ulTotal, NULL))
        {
            *pcbTotal = ulTotal.QuadPart;
            *pcbFree = ulFree.QuadPart;
        }

        *pfUDF = FALSE;
        TCHAR szFilesystem[30];
        if (GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, NULL, szFilesystem, ARRAYSIZE(szFilesystem)))
        {
            HUSKEY huskeyExclude;
            if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_EXCLUDE, KEY_READ, NULL, &huskeyExclude, FALSE))
            {
                DWORD dwIndex = 0;
                TCHAR szKey[30];
                DWORD cchKey = ARRAYSIZE(szKey);
                while (!*pfUDF && (ERROR_SUCCESS == SHRegEnumUSValue(huskeyExclude, dwIndex, szKey, &cchKey, NULL, NULL, NULL, SHREGENUM_DEFAULT)))
                {
                    *pfUDF = (lstrcmpi(szFilesystem, szKey) == 0);

                    dwIndex++;
                    cchKey = ARRAYSIZE(szKey);
                }
                SHRegCloseUSKey(huskeyExclude);
            }
        }
    }
    return hr;
}

HRESULT CDBurn_GetCDInfo(LPCTSTR pszVolume, DWORD *pdwDriveCapabilities, DWORD *pdwMediaCapabilities)
{
    *pdwDriveCapabilities = 0;
    *pdwMediaCapabilities = 0;

    DWORD dwDriveType;
    HRESULT hr = CCDBurn::_GetCachedDriveInfo(pszVolume, &dwDriveType, NULL, NULL);
    if (SUCCEEDED(hr))
    {
        switch (dwDriveType)
        {
        case RECORDER_CDR:
            *pdwDriveCapabilities = HWDDC_CDROM | HWDDC_CDRECORDABLE;
            break;
        case RECORDER_CDRW:
            *pdwDriveCapabilities = HWDDC_CDROM | HWDDC_CDRECORDABLE | HWDDC_CDREWRITABLE;
            break;
        default:
            *pdwDriveCapabilities = HWDDC_CDROM;
            break;
        }

        DWORD dwMediaCap;
        DWORD cb = sizeof(dwMediaCap);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_MEDIATYPE, NULL, &dwMediaCap, &cb))
        {
            *pdwMediaCapabilities = dwMediaCap;
        }
    }
    return hr;
}

void CDBurn_GetUDFState(BOOL *pfUDF)
{
    *pfUDF = FALSE;

    DWORD dw, cb = sizeof(dw);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_UDF, NULL, &dw, &cb))
    {
        *pfUDF = dw;
    }
}

HRESULT CCDBurn::_GetMediaCapabilities(DWORD *pdwCap, BOOL *pfUDF)
{
    HRESULT hr = S_OK;

    if (pfUDF)
    {
        CDBurn_GetUDFState(pfUDF);
    }

    if (pdwCap)
    {
        *pdwCap = 0;

        TCHAR szVolumeName[MAX_PATH];
        hr = CCDBurn::_GetCurrentBurnVolumeName(szVolumeName, ARRAYSIZE(szVolumeName));
        if (SUCCEEDED(hr))
        {
            DWORD dwDriveCap;
            CDBurn_GetCDInfo(szVolumeName, &dwDriveCap, pdwCap);
        }
    }
    return hr;
}

HRESULT CCDBurn::GetMediaCapabilities(DWORD *pdwCap, BOOL *pfUDF)
{
    return _GetMediaCapabilities(pdwCap, pfUDF);
}

HRESULT CCDBurn::_StoreDiscInfo()
{
    HRESULT hr = E_FAIL;
    BOOL fDone = FALSE;
    int iRetryCount = 0;
    // retry up to a max of 5 times.
    // we can get into a state where we failed to pick up the disc information, if IMAPI
    // is around and in use by somebody else.  in that case just wait and loop around until we can
    // get it.
    while (!fDone && (iRetryCount < 5))
    {
        iRetryCount++;

        // these are the values we're going to pick up.
        ULONGLONG cbTotal, cbFree;
        DWORD dwMediaCaps;
        BOOL fUDF;

        hr = E_OUTOFMEMORY;
        CCDBurn *pcdb = new CCDBurn();
        if (pcdb)
        {
            IDiscMaster *pdm;
            IJolietDiscMaster *pjdm;
            hr = pcdb->_GetDiscMasters(&pdm, &pjdm);
            if (SUCCEEDED(hr))
            {
                IDiscRecorder *pdr;
                // dont call SetActiveDiscRecorder unless absolutely necessary -- it returns random errors
                // if there's UDF media.
                hr = pcdb->_FindAndSetDefaultRecorder(pdm, FALSE, &pdr);
                if (SUCCEEDED(hr))
                {
                    hr = pdr->OpenExclusive();
                    if (SUCCEEDED(hr))
                    {
                        // don't use the mountpoint layer to determine capabilities.
                        dwMediaCaps = HWDMC_CDROM;

                        long lMediaType, lMediaFlags;
                        hr = pdr->QueryMediaType(&lMediaType, &lMediaFlags);
                        if (SUCCEEDED(hr) && !lMediaType && !lMediaFlags)
                        {
                            hr = E_FAIL;
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (lMediaFlags & MEDIA_WRITABLE)
                            {
                                dwMediaCaps |= HWDMC_CDRECORDABLE;
                            }
                            if (lMediaFlags & MEDIA_RW)
                            {
                                dwMediaCaps |= HWDMC_CDREWRITABLE;
                            }

                            hr = _GetDiscInfoUsingFilesystem(&cbTotal, &cbFree, &fUDF);

                            // also adjust the fUDF bit to include unusable media.
                            if (lMediaFlags & MEDIA_FORMAT_UNUSABLE_BY_IMAPI)
                            {
                                fUDF = TRUE;
                            }

                            if (SUCCEEDED(hr) && (dwMediaCaps & (HWDMC_CDRECORDABLE | HWDMC_CDREWRITABLE)) && !fUDF)
                            {
                                ULONGLONG cbFreeIMAPI;
                                hr = _GetDiscInfoUsingIMAPI(pjdm, pdr, &cbFreeIMAPI);
                                if (SUCCEEDED(hr))
                                {
                                    cbTotal += cbFreeIMAPI;
                                    cbFree += cbFreeIMAPI;
                                }
                            }
                        }
                        pdr->Close();
                    }

                    // pick up the write speed, it might have changed.  don't worry about
                    // failure since this is a bonus perk anyway.
                    DWORD dwMaxWrite;
                    TCHAR szDevicePath[MAX_PATH], szVolumeName[MAX_PATH];
                    if (SUCCEEDED(_GetDiscRecorderInfo(pdr, NULL, &dwMaxWrite, NULL)) &&
                        SUCCEEDED(_GetRecorderPath(pdr, szDevicePath, ARRAYSIZE(szDevicePath))) &&
                        SUCCEEDED(_GetVolumeNameForDevicePath(szDevicePath, szVolumeName, ARRAYSIZE(szVolumeName))))
                    {
                        // update max speed
                        _SetCachedDriveInfo(szVolumeName, DRIVE_USEEXISTING, 0, dwMaxWrite);
                    }
                    pdr->Release();
                }
                pdm->Release();
                pjdm->Release();
            }
            pcdb->Release();
        }

        if (SUCCEEDED(hr))
        {
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_TOTALBYTES, REG_BINARY, &cbTotal, sizeof(cbTotal));
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_FREEBYTES, REG_BINARY, &cbFree, sizeof(cbFree));
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_MEDIATYPE, REG_DWORD, &dwMediaCaps, sizeof(dwMediaCaps));
            DWORD dw = fUDF;
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_UDF, REG_DWORD, &dw, sizeof(dw));

            int iCurrent;
            if (SUCCEEDED(_GetCurrentDriveIndex(&iCurrent)))
            {
                TCHAR szRoot[4];
                TCHAR szVolName[MAX_PATH];
                if (PathBuildRoot(szRoot, iCurrent) &&
                    GetVolumeInformation(szRoot, szVolName, ARRAYSIZE(szVolName), NULL, NULL, NULL, NULL, 0))
                {
                    UINT cb = (lstrlen(szVolName) + 1) * sizeof(TCHAR);
                    SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_DISCLABEL, REG_SZ, szVolName, cb);
                }
            }

            DWORD dwSet = 1;
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_SET, REG_DWORD, &dwSet, sizeof(dwSet));

            LPITEMIDLIST pidl;
            if (SUCCEEDED(_GetFolderPidl(&pidl)))
            {
                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, pidl, NULL);
                ILFree(pidl);
            }
            fDone = TRUE;
        }
        else if ((IMAPI_E_STASHINUSE == hr) ||         // IMAPI is being used by somebody else.
                 (IMAPI_E_DEVICE_NOTACCESSIBLE == hr)) // CD has not spun up.
        {
            // wait and try again.
            SHProcessMessagesUntilEvent(NULL, NULL, 5 * 1000); // 5 seconds
        }
        else
        {
            // there was some other error, bail out anyway.
            fDone = TRUE;
        }
    }

    return hr;
}

HRESULT CCDBurn::GetSpace(ULONGLONG *pcbTotal, ULONGLONG *pcbFree)
{
    HRESULT hr = E_FAIL;
    ULONGLONG cbTotal, cbFree;
    DWORD cbReg1 = sizeof(cbTotal), cbReg2 = sizeof(cbFree);
    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_TOTALBYTES, NULL, &cbTotal, &cbReg1)) &&
        (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_FREEBYTES, NULL, &cbFree, &cbReg2)))
    {
        if (pcbTotal)
            *pcbTotal = cbTotal;
        if (pcbFree)
            *pcbFree = cbFree;
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::InitNew()
{
    IPropertyBag *ppb;
    // load up the default property bag for peruser perfolder
    // may have problems down the line with thumbs.db being alluser.
    HRESULT hr = _CreateDefaultPropBag(IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        IUnknown_Set((IUnknown**)&_ppb, ppb);
        ppb->Release();
    }
    return hr;
}

HRESULT CCDBurn::Load(IPropertyBag *ppb, IErrorLog *pErr)
{
    IUnknown_Set((IUnknown**)&_ppb, ppb);
    return S_OK;
}

STDAPI SHCreateQueryCancelAutoPlayMoniker(IMoniker** ppmoniker); // mtptarun2.cpp

void CCDBurn::_RegisterAutoplayCanceller()
{
    IMoniker *pmoniker;
    if (SUCCEEDED(SHCreateQueryCancelAutoPlayMoniker(&pmoniker)))
    {
        IRunningObjectTable *prot;
        if (SUCCEEDED(GetRunningObjectTable(0, &prot)))
        {
            IUnknown *punkThis;
            if (SUCCEEDED(QueryInterface(IID_PPV_ARG(IUnknown, &punkThis))))
            {
                prot->Register(ROTFLAGS_REGISTRATIONKEEPSALIVE, punkThis, pmoniker, &_dwROTRegister);
                punkThis->Release();
            }
            prot->Release();
        }
        pmoniker->Release();
    }
}

void CCDBurn::_UnregisterAutoplayCanceller()
{
    if (_dwROTRegister)
    {
        IRunningObjectTable *prot;
        if (SUCCEEDED(GetRunningObjectTable(0, &prot)))
        {
            prot->Revoke(_dwROTRegister);
            _dwROTRegister = 0;
            prot->Release();
        }
    }
}

HRESULT CCDBurn::_WizardThreadProc()
{
    HRESULT hr = E_FAIL;
    BOOL fWizardShown = FALSE;
    // the burningnow check does an additional call into IMAPI -- this may be slow so do it while
    // we're on the background thread instead of the duiview one.
    if (!_IsBurningNow())
    {
        if (_EnterExclusiveBurning())
        {
            _RegisterAutoplayCanceller();
            hr = _ShowWizard();

            if (SUCCEEDED(_GetBurnHR()) && SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_AUTOCLOSE, FALSE))
            {
                // if we auto-closed the wizard, leave this thread going for a few more seconds
                // to cancel any spurious autoplays that come in.
                SHProcessMessagesUntilEvent(NULL, NULL, 3 * 1000);
            }

            _UnregisterAutoplayCanceller();

            fWizardShown = TRUE;
            _LeaveExclusiveBurning();
        }
    }

    if (!fWizardShown && !SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_FAILSILENTLY, FALSE))
    {
        // put up UI so we dont silently fail.
        ShellMessageBox(HINST_THISDLL, NULL, MAKEINTRESOURCE(IDS_BURN_CANTBURN), MAKEINTRESOURCE(IDS_BURN),
                        MB_OK | MB_ICONEXCLAMATION);
    }

    return hr;
}

DWORD WINAPI CCDBurn::_WizardThreadWrapper(void *pv)
{
    CCDBurn *pcdb = (CCDBurn*)pv;
    pcdb->_WizardThreadProc();
    pcdb->Release();
    return 0;
}

HRESULT CCDBurn::_ShowWizardOnSeparateThread()
{
    HRESULT hr = S_OK;
    AddRef();
    if (!SHCreateThread(_WizardThreadWrapper, this, CTF_COINIT, NULL))
    {
        Release();
        hr = E_FAIL;
    }
    return hr;
}


// match this with below
#define INDEX_DLG_BURNWIZ_WELCOME        0
#define INDEX_DLG_BURNWIZ_EJECT          1
#define INDEX_DLG_BURNWIZ_BURN_PROGRESS  2
#define INDEX_DLG_BURNWIZ_BURN_SUCCESS   3
#define INDEX_DLG_BURNWIZ_BURN_FAILURE   4
#define INDEX_DLG_BURNWIZ_WAITFORMEDIA   5
#define INDEX_DLG_BURNWIZ_STARTERASE     6
#define INDEX_DLG_BURNWIZ_ERASE_PROGRESS 7
#define INDEX_DLG_BURNWIZ_ERASE_SUCCESS  8
#define INDEX_DLG_BURNWIZ_ERASE_FAILURE  9
#define INDEX_DLG_BURNWIZ_DISCFULL       10
#define INDEX_DLG_BURNWIZ_EARLYEXIT      11
#define INDEX_DLG_BURNWIZ_HDFULL         12
#define INDEX_DLG_BURNWIZ_NOFILES        13

const WIZPAGE c_wpPages[] =
{
    {DLG_BURNWIZ_WELCOME,        0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_WelcomeDlgProc},
    {DLG_BURNWIZ_EJECT,          0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_EjectDlgProc},
    {DLG_BURNWIZ_PROGRESS,       IDS_BURNWIZ_PROGRESS_BURN_HEAD,  IDS_BURNWIZ_PROGRESS_BURN_SUB,  0,              CCDBurn::s_ProgressDlgProc},
    {DLG_BURNWIZ_BURN_SUCCESS,   0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_DoneDlgProc},
    {DLG_BURNWIZ_BURN_FAILURE,   0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_DoneDlgProc},
    {DLG_BURNWIZ_WAITFORMEDIA,   IDS_BURNWIZ_WAIT_HEAD,           IDS_BURNWIZ_WAIT_SUB,           0,              CCDBurn::s_WaitForMediaDlgProc},
    {DLG_BURNWIZ_STARTERASE,     0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_StartEraseDlgProc},
    {DLG_BURNWIZ_PROGRESS,       IDS_BURNWIZ_PROGRESS_ERASE_HEAD, IDS_BURNWIZ_PROGRESS_ERASE_SUB, 0,              CCDBurn::s_ProgressDlgProc},
    {DLG_BURNWIZ_ERASE_SUCCESS,  0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_DoneDlgProc},
    {DLG_BURNWIZ_ERASE_FAILURE,  0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_DoneDlgProc},
    {DLG_BURNWIZ_DISCFULL,       0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_DiskFullDlgProc},
    {DLG_BURNWIZ_PROGRESS,       0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_EarlyExitDlgProc},
    {DLG_BURNWIZ_HDFULL,         0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_HDFullDlgProc},
    {DLG_BURNWIZ_NOFILES,        0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_NoFilesDlgProc},
};

HPROPSHEETPAGE _CreatePropPageFromInfo(const WIZPAGE *pwp, LPARAM lParam)
{
    PROPSHEETPAGE psp = { 0 };
    psp.dwSize = sizeof(psp);
    psp.hInstance = HINST_THISDLL;
    psp.lParam = lParam;
    psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | pwp->dwFlags;
    psp.pszTemplate = MAKEINTRESOURCE(pwp->idPage);
    psp.pfnDlgProc = pwp->dlgproc;
    psp.pszTitle = MAKEINTRESOURCE(IDS_BURN_WIZTITLE);
    psp.pszHeaderTitle = MAKEINTRESOURCE(pwp->idHeading);
    psp.pszHeaderSubTitle = MAKEINTRESOURCE(pwp->idSubHeading);
    return CreatePropertySheetPage(&psp);
}

int ReleaseCallback(void *pv, void *)
{
    IWizardExtension *pwe = (IWizardExtension*)pv;
    IUnknown_SetSite(pwe, NULL);
    pwe->Release();
    return 1;
}

HRESULT CCDBurn::_ShowWizard()
{
    LinkWindow_RegisterClass();

    _fCancelled = FALSE;

    // create the page array

    int nStartPage;
    if (SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_EJECT, FALSE))
    {
        // we want the eject page
        nStartPage = INDEX_DLG_BURNWIZ_EJECT;
    }
    else
    {
        // normal entry point
        if (SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_ERASE, FALSE))
        {
            nStartPage = INDEX_DLG_BURNWIZ_STARTERASE;
        }
        else
        {
            nStartPage = _StagingAreaHasFiles() ? INDEX_DLG_BURNWIZ_WELCOME : INDEX_DLG_BURNWIZ_NOFILES;
        }
    }

    // wtf?  if i dont include a propsheet without PSP_HIDEHEADER the sizing gets messed up.
    for (int i = 0; i < ARRAYSIZE(c_wpPages); i++)
    {
        _rgWizPages[i] = _CreatePropPageFromInfo(&c_wpPages[i], (LPARAM)this);
    }

    UINT cTotalExtPages;
    HRESULT hr = _FillExtensionDPA(_rgWizPages + ARRAYSIZE(c_wpPages), ARRAYSIZE(_rgWizPages) - ARRAYSIZE(c_wpPages), &cTotalExtPages);
    if (SUCCEEDED(hr))
    {
        PROPSHEETHEADER psh = { 0 };
        psh.dwSize = sizeof(psh);
        psh.hInstance = HINST_THISDLL;
        psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER | PSH_USEICONID;
        psh.pszbmHeader = MAKEINTRESOURCE(IDB_BURNWIZ_HEADER);
        psh.pszbmWatermark = MAKEINTRESOURCE(IDB_BURNWIZ_WATERMARK);
        psh.pszIcon = MAKEINTRESOURCE(IDI_DRIVECD);
        psh.phpage = _rgWizPages;
        psh.nPages = ARRAYSIZE(c_wpPages) + cTotalExtPages;
        psh.nStartPage = nStartPage;
        PropertySheet(&psh);
        
        HRESULT hrOp = E_FAIL;
        DWORD dwHR;
        if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_HR, &dwHR)))
        {
            hrOp = dwHR;
        }

        hr = SUCCEEDED(hrOp) ? S_OK : S_FALSE;
    }

    if (_hdpaExts)
    {
        DPA_DestroyCallback(_hdpaExts, ReleaseCallback, 0);
    }

    s_hwndWiz = NULL;
    // the drive could have been locked after the wait for media page.
    _LockCurrentDrive(FALSE);

    return hr;
}

CCDBurn* CCDBurn::s_GetCDBurn(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CCDBurn*)ppsp->lParam;
    }
    return (CCDBurn*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}

HFONT GetIntroFont(HWND hwnd)
{
    static HFONT _hfontIntro = NULL;

    if (!_hfontIntro)
    {
        TCHAR szBuffer[64];
        NONCLIENTMETRICS ncm = { 0 };
        LOGFONT lf;

        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        lf = ncm.lfMessageFont;
        LoadString(g_hinst, IDS_BURNWIZ_TITLEFONTNAME, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName));
        lf.lfWeight = FW_BOLD;

        LoadString(g_hinst, IDS_BURNWIZ_TITLEFONTSIZE, szBuffer, ARRAYSIZE(szBuffer));
        lf.lfHeight = 0 - (GetDeviceCaps(NULL, LOGPIXELSY) * StrToInt(szBuffer) / 72);

        _hfontIntro = CreateFontIndirect(&lf);
    }

    return _hfontIntro;
}

void CCDBurn::_SetNextPage(HWND hwnd, int iIndex)
{
    PropSheet_SetCurSel(GetParent(hwnd), _rgWizPages[iIndex], -1);
    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
}

void CCDBurn::_SetUpStartPage(HWND hwnd)
{
    TCHAR szDiscLabel[JOLIET_MAX_LABEL + 1];
    szDiscLabel[0] = 0;
    SHPropertyBag_ReadStr(_ppb, PROPSTR_DISCLABEL, szDiscLabel, ARRAYSIZE(szDiscLabel));
    SetDlgItemText(hwnd, IDC_BURNWIZ_DISCLABEL, szDiscLabel);
    Edit_LimitText(GetDlgItem(hwnd, IDC_BURNWIZ_DISCLABEL), JOLIET_MAX_LABEL);
    SHLimitInputEditChars(GetDlgItem(hwnd, IDC_BURNWIZ_DISCLABEL), NULL, INVALID_JOLIETNAME_CHARS);

    BOOL fClose = SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_AUTOCLOSE, FALSE);
    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_AUTOCLOSEWIZ), fClose ? BST_CHECKED : BST_UNCHECKED);
}

void CCDBurn::_LeaveStartPage(HWND hwnd)
{
    BOOL fClose = (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_AUTOCLOSEWIZ) == BST_CHECKED);
    SHPropertyBag_WriteBOOL(_ppb, PROPSTR_AUTOCLOSE, fClose);
    DWORD dwClose = fClose;
    SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_AUTOCLOSE, REG_DWORD, &dwClose, sizeof(dwClose));
}

#define CDBURNWM_SHOWSHUTDOWNMESSAGE WM_APP

LRESULT CALLBACK CCDBurn::_WizSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, DWORD_PTR dwRefData)
{
    LRESULT lres;

    switch (uMsg)
    {
        case WM_NCDESTROY:
            // Clean up subclass
            RemoveWindowSubclass(hwnd, _WizSubclassProc, 0);
            lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            break;

        case WM_QUERYENDSESSION:
            lres = TRUE;
            if (s_fDriveInUse)
            {
                // post so we return to user quickly
                PostMessage(hwnd, CDBURNWM_SHOWSHUTDOWNMESSAGE, 0, 0);
                // always bail if the drive is in use.
                lres = FALSE;
            }
            break;

        case CDBURNWM_SHOWSHUTDOWNMESSAGE:
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_BURN_CANTSHUTDOWN), MAKEINTRESOURCE(IDS_BURN),
                            MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
            lres = TRUE;
            break;

        default:
            lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            break;
    }

    return lres;
}

void CCDBurn::_SetupFirstPage(HWND hwnd, BOOL fSubclass)
{
    s_hwndWiz = GetParent(hwnd);
    SendDlgItemMessage(hwnd, IDC_BURNWIZ_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
    if (fSubclass)
    {
        SetWindowSubclass(s_hwndWiz, _WizSubclassProc, 0, 0);
    }
}

INT_PTR CCDBurn::_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _SetupFirstPage(hwnd, TRUE);
            fRet = TRUE;
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT);
                    _SetUpStartPage(hwnd);
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                    TCHAR szDiscLabel[JOLIET_MAX_LABEL + 1];
                    szDiscLabel[0] = 0;
                    // GetDlgItemText helpfully returns 0 for error and 0 for the empty string, so dont use
                    // its return value.
                    GetDlgItemText(hwnd, IDC_BURNWIZ_DISCLABEL, szDiscLabel, ARRAYSIZE(szDiscLabel));
                    SHPropertyBag_WriteStr(_ppb, PROPSTR_DISCLABEL, szDiscLabel);
                    _SetNextPage(hwnd, INDEX_DLG_BURNWIZ_WAITFORMEDIA);
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    _LeaveStartPage(hwnd);
                    break;
            }
            break;
        }
    }
    return fRet;
}

INT_PTR CCDBurn::_StartEraseDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _SetupFirstPage(hwnd, TRUE);
            fRet = TRUE;
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT);
                    _SetUpStartPage(hwnd);
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                    // the erase progress page will almost immediately lock the drive -- this call is for
                    // consistency and to set the state variable used in shutdown prevention.
                    _LockCurrentDrive(TRUE);
                    _SetNextPage(hwnd, INDEX_DLG_BURNWIZ_ERASE_PROGRESS);
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    _LeaveStartPage(hwnd);
                    break;
            }
            break;
        }
    }
    return fRet;
}

INT_PTR CCDBurn::_EjectDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _SetupFirstPage(hwnd, TRUE);
            fRet = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_BURNWIZ_BURNDATA:
                case IDC_BURNWIZ_CLEAR:
                case IDC_BURNWIZ_EJECT:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNDATA) == BST_CHECKED)
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);
                    }
                    else
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH);
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT);
                    _SetUpStartPage(hwnd);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNDATA), BST_CHECKED);
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                {
                    TCHAR szDiscLabel[JOLIET_MAX_LABEL + 1];
                    if (GetDlgItemText(hwnd, IDC_BURNWIZ_DISCLABEL, szDiscLabel, ARRAYSIZE(szDiscLabel)))
                    {
                        SHPropertyBag_WriteStr(_ppb, PROPSTR_DISCLABEL, szDiscLabel);
                    }
                    _SetNextPage(hwnd, INDEX_DLG_BURNWIZ_WAITFORMEDIA);
                    fRet = TRUE;
                    break;
                }

                case PSN_WIZFINISH:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_CLEAR) == BST_CHECKED)
                    {
                        CMINVOKECOMMANDINFO cmi = {0};
                        cmi.fMask = CMIC_MASK_FLAG_NO_UI;
                        _CleanUp(&cmi, TRUE);
                    }
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    _LeaveStartPage(hwnd);
                    break;
            }
            break;
        }
    }
    return fRet;
}

void CCDBurn::_InitTimeStats(BOOL fErase)
{
    ZeroMemory(&_ts, sizeof(_ts));

    DWORD cb;
    if (fErase)
    {
        DWORD dwEraseTime;
        cb = sizeof(dwEraseTime);
        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_ERASETIME, NULL, &dwEraseTime, &cb))
        {
            // default to 3 minutes or so.
            dwEraseTime = 180;
        }
        _ts.dwSecErase = dwEraseTime / _dwCurSpeed;
        _ts.dwSecTotal = _ts.dwSecErase;
    }
    else
    {
        _fRecording = FALSE;

        ULONGLONG ullStageRate;
        cb = sizeof(ullStageRate);
        if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_STAGERATE, NULL, &ullStageRate, &cb)) ||
            (0 == ullStageRate))
        {
            // default to staging approx. 2MB/s.
            ullStageRate = 2000000;
        }
        _ts.dwSecStaging = (DWORD) (_cbStagedSize / ullStageRate);

        ULONGLONG ullBurnRate;
        cb = sizeof(ullBurnRate);
        if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_BURNRATE, NULL, &ullBurnRate, &cb)) ||
            (0 == ullBurnRate))
        {
            // default, single speed.
            ullBurnRate = 150000;
        }
        _ts.dwSecBurn = (DWORD) (_cbStagedSize / (ullBurnRate * _dwCurSpeed));

        DWORD dwCloseFactor;
        cb = sizeof(dwCloseFactor);
        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CLOSEFACTOR, NULL, &dwCloseFactor, &cb))
        {
            // default to ~2 min, single speed.
            dwCloseFactor = 120;
        }
        _ts.dwSecClose = dwCloseFactor / _dwCurSpeed;

        _ts.dwSecTotal = _ts.dwSecStaging + _ts.dwSecBurn + _ts.dwSecClose;
    }
    if (0 == _ts.dwSecTotal)
        _ts.dwSecTotal = 1;
    _dwLastTime = 0;
    _SetEstimatedTime(_ts.dwSecTotal);
}

void CCDBurn::_SaveTimeStats(BOOL fErase)
{
    if (fErase)
    {
        // if we didnt fill in one of our timing fields, IMAPI called us wrong and we throw out all our data.
        if (_ts.dwTickEraseStart && _ts.dwTickEraseEnd)
        {
            DWORD dwEraseTime = (_ts.dwTickEraseEnd - _ts.dwTickEraseStart) / 1000 * _dwCurSpeed;
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_ERASETIME, REG_DWORD, &dwEraseTime, sizeof(dwEraseTime));
        }
    }
    else
    {
        // if we didnt fill in one of our timing fields, IMAPI called us wrong and we throw out all our data.
        if (_ts.dwTickStagingStart && _ts.dwTickStagingEnd &&
            _ts.dwTickBurnStart && _ts.dwTickBurnEnd &&
            _ts.dwTickCloseStart && _ts.dwTickCloseEnd)
        {
            // only tally results from burns of more than 1MB (arbitrary, but good enough).
            // 1MB is about 8s on a 1x drive and 1s on an 8x drive.
            // the main danger is people burning a few text files that total 1k, then the burn phase takes 1 second
            // (rather, the time between our IMAPI notifications is 1s) and we get stuck with some measly transfer rate
            // that doesnt make any sense and makes the next burn's estimated time up in the gazillions of minutes.
            if (_cbStagedSize > 1000000)
            {
                ULONGLONG ullStageRate = _cbStagedSize * 1000 / (_ts.dwTickStagingEnd - _ts.dwTickStagingStart);
                SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_STAGERATE, REG_BINARY, &ullStageRate, sizeof(ullStageRate));

                ULONGLONG ullBurnRate = _cbStagedSize * 1000 / (_ts.dwTickBurnEnd - _ts.dwTickBurnStart) / _dwCurSpeed;
                SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_BURNRATE, REG_BINARY, &ullBurnRate, sizeof(ullBurnRate));
            }

            DWORD dwCloseFactor = (_ts.dwTickCloseEnd - _ts.dwTickCloseStart) / 1000 * _dwCurSpeed;
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CLOSEFACTOR, REG_DWORD, &dwCloseFactor, sizeof(dwCloseFactor));
        }
    }
}

void CCDBurn::_ConstructTimeString(DWORD dwEstTime, LPTSTR psz, UINT cch)
{
    TCHAR szBuf[100];
    if (dwEstTime >= 60)
    {
        LoadString(HINST_THISDLL, IDS_TIMEEST_MINUTES2, szBuf, ARRAYSIZE(szBuf));
        wnsprintf(psz, cch, szBuf, dwEstTime / 60 + 1);
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_TIMEEST_SECONDS2, szBuf, ARRAYSIZE(szBuf));
        wnsprintf(psz, cch, szBuf, (dwEstTime / 5 + 1) * 5); // round off to 5sec increments
    }
}

void CCDBurn::_SetEstimatedTime(DWORD dwSeconds)
{
    _ts.dwSecRemaining = dwSeconds;
    _dwTimeSet = GetTickCount();
}

void CCDBurn::_DisplayEstimatedTime(HWND hwnd)
{
    if (_ts.dwSecRemaining)
    {
        // we know when we last made an estimate, so show time based on that.
        // however, our estimate could have easily been wrong, so skew it so it never quite reaches 0,
        // and instead sit at a few seconds remaining (hopefully for not too long).

        DWORD dwElapsedTime = (GetTickCount() - _dwTimeSet) / 1000;
        DWORD dwEstTime = 0;
        if (_ts.dwSecRemaining > dwElapsedTime + 5)
        {
            dwEstTime = _ts.dwSecRemaining - dwElapsedTime;
        }

        if (!_dwLastTime || (dwEstTime < _dwLastTime))
        {
            TCHAR szTime[100];
            _ConstructTimeString(dwEstTime, szTime, ARRAYSIZE(szTime));
            SetDlgItemText(hwnd, IDC_BURNWIZ_ESTTIME, szTime);

            SendMessage(GetDlgItem(_hwndWizardPage, IDC_BURNWIZ_PROGRESS), PBM_SETPOS, (WPARAM) (PROGRESS_INCREMENTS * (_ts.dwSecTotal - dwEstTime) / _ts.dwSecTotal), 0);
            _dwLastTime = dwEstTime;
        }
    }
}

void CCDBurn::_InitProgressPage(HWND hwnd)
{
    SendMessage(GetDlgItem(hwnd, IDC_BURNWIZ_PROGRESS), PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, PROGRESS_INCREMENTS));
    SendMessage(GetDlgItem(hwnd, IDC_BURNWIZ_PROGRESS), PBM_SETPOS, (WPARAM)0, 0);
    SetDlgItemText(hwnd, IDC_BURNWIZ_ESTTIME, L"");
    SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT, L"");
}

#define IDT_SHOWTIME 1

INT_PTR CCDBurn::_ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    _InitProgressPage(hwnd);
                    _hwndWizardPage = hwnd;
                    PropSheet_SetWizButtons(pnmh->hwndFrom, 0);

                    // start up a timer to periodically refresh the time remaining
                    _ts.dwSecRemaining = 0;
                    SetTimer(hwnd, IDT_SHOWTIME, 1000, NULL);

                    AddRef();
                    if (!SHCreateThread(SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_ERASE, FALSE) ? _EraseThread : _BurnThread,
                                        this, CTF_COINIT, NULL))
                    {
                        Release();
                    }
                    fRet = TRUE;
                    break;

                case PSN_QUERYCANCEL:
                    if (IDYES == ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_BURN_CONFIRM_CANCEL), MAKEINTRESOURCE(IDS_BURN),
                                                 MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2))
                    {
                        _fCancelled = TRUE;
                    }
                    else
                    {
                        // TRUE means don't cancel
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
                        fRet = TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    _PostOperation();
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    KillTimer(hwnd, IDT_SHOWTIME);
                    break;
            }
            break;
        }

        case WM_TIMER:
            switch (wParam)
            {
                case IDT_SHOWTIME:
                    _DisplayEstimatedTime(hwnd);
                    break;
            }
            break;
    }
    return fRet;
}

void CCDBurn::_DisplayMediaErrorOnNext(HWND hwnd, UINT idMsg, UINT idMsgInsert)
{
    WCHAR sz[100];
    LoadString(HINST_THISDLL, idMsg, sz, ARRAYSIZE(sz));
    SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT, sz);

    int iIndex;
    if (SUCCEEDED(_GetCurrentDriveIndex(&iIndex)) && PathBuildRoot(sz, iIndex))
    {
        LPWSTR pszInsertDisc = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(idMsgInsert), sz);
        if (pszInsertDisc)
        {
            SetDlgItemText(hwnd, IDC_BURNWIZ_PLEASEINSERT, pszInsertDisc);
            LocalFree(pszInsertDisc);
        }
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
}

// to make the wizard happy, we load all of the extensions' pages at the beginning.
// however, not all will be used, since some behavior is dependent on the media that's
// inserted -- which can only be known AFTER _WaitForMediaDlgProc.
void CCDBurn::_PruneExts()
{
    IDataObject *pdo;
    if (SUCCEEDED(_CreateDataObject(&pdo)))
    {
        int i = DPA_GetPtrCount(_hdpaExts);
        // count down and remove from the end of the DPA.
        while (i--)
        {
            BOOL fKeep = FALSE;

            IWizardExtension *pwe = (IWizardExtension*)DPA_GetPtr(_hdpaExts, i);
            ASSERT(pwe);
            IDropTarget *pdt;
            if (SUCCEEDED(pwe->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt))))
            {
                DWORD dwEffect;
                POINTL pt = { 0 };
                if (SUCCEEDED(pdt->DragEnter(pdo, 0, pt, &dwEffect)))
                {
                    if (DROPEFFECT_NONE != dwEffect)
                    {
                        fKeep = TRUE;
                    }
                    pdt->DragLeave();
                }
                pdt->Release();
            }

            if (!fKeep)
            {
                DPA_DeletePtr(_hdpaExts, i);
                IUnknown_SetSite(pwe, NULL);
                pwe->Release();
            }
        }
        pdo->Release();
    }
}

// timer for our retries
#define IDT_CLICKNEXT 1

INT_PTR CCDBurn::_WaitForMediaDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    {
                        PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);

                        // kick off a trial to see if media is here already
                        PropSheet_PressButton(GetParent(hwnd), PSBTN_NEXT);

                        // start up a timer too -- we could also register the window for notification
                        // but this is a cheap operation and its less code
                        SetTimer(hwnd, IDT_CLICKNEXT, 250, NULL);
                        fRet = TRUE;
                    }
                    break;

                case PSN_WIZBACK:
                    _SetNextPage(hwnd, SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_EJECT, FALSE) ? INDEX_DLG_BURNWIZ_EJECT : INDEX_DLG_BURNWIZ_WELCOME);
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                {
                    // used to check if our media-insert thread is done with using IMAPI.
                    DWORD dwDummy, cb = sizeof(dwDummy);
                    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_SET, NULL, &dwDummy, &cb))
                    {
                        DWORD dwCaps;
                        BOOL fUDF;
                        if (SUCCEEDED(_GetMediaCapabilities(&dwCaps, &fUDF)) && (dwCaps & HWDMC_CDRECORDABLE) && !fUDF)
                        {
                            _LockCurrentDrive(TRUE);
                            _PruneExts();
                            SHPropertyBag_WriteDWORD(_ppb, PROPSTR_CURRENTEXT, 1);
                            _SetExtPageFromPropBag(hwnd, TRUE);
                        }
                        else
                        {
                            _DisplayMediaErrorOnNext(hwnd, IDS_BURN_FAILURE_MEDIUM_INVALIDTYPE, IDS_BURN_INSERTDISCFULL);
                        }
                    }
                    else
                    {
                        _DisplayMediaErrorOnNext(hwnd, IDS_BURN_FAILURE_MEDIUM_NOTPRESENT, IDS_BURN_INSERTDISC);
                    }
                    fRet = TRUE;
                    break;
                }

                case PSN_KILLACTIVE:
                    KillTimer(hwnd, IDT_CLICKNEXT);
                    break;
            }
            break;
        }

        case WM_TIMER:
            switch (wParam)
            {
                case IDT_CLICKNEXT:
                    PropSheet_PressButton(GetParent(hwnd), PSBTN_NEXT);
                    break;
            }
            break;
    }
    return fRet;
}

HRESULT CCDBurn::_PostOperation()
{
    HRESULT hrOp = E_FAIL;
    DWORD dwHR;
    if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_HR, &dwHR)))
    {
        hrOp = dwHR;
    }

    if (SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_ERASE, FALSE))
    {
        _SetNextPage(_hwndWizardPage, SUCCEEDED(hrOp) ? INDEX_DLG_BURNWIZ_ERASE_SUCCESS : INDEX_DLG_BURNWIZ_ERASE_FAILURE);
    }
    else
    {
        switch (hrOp)
        {
            case IMAPI_E_DISCFULL:
            {
                TCHAR szDiscFull[200];
                LoadString(HINST_THISDLL, IDS_BURN_DISCFULL, szDiscFull, ARRAYSIZE(szDiscFull));
                SHPropertyBag_WriteStr(_ppb, PROPSTR_DISCFULLTEXT, szDiscFull);
                _SetNextPage(_hwndWizardPage, INDEX_DLG_BURNWIZ_DISCFULL);
                break;
            }

            case IMAPI_E_NOTENOUGHDISKFORSTASH:
                _SetNextPage(_hwndWizardPage, INDEX_DLG_BURNWIZ_HDFULL);
                break;

            case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
                // diskfulltext has already been set by _CheckTotal.
                _SetNextPage(_hwndWizardPage, INDEX_DLG_BURNWIZ_DISCFULL);
                break;

            case IMAPI_E_LOSS_OF_STREAMING:
            {
                // slow down the speed by one step
                TCHAR szVolume[MAX_PATH];
                if (SUCCEEDED(_GetCurrentBurnVolumeName(szVolume, ARRAYSIZE(szVolume))))
                {
                    DWORD dwCurSpeed, dwMaxSpeed;
                    if (SUCCEEDED(_GetCachedDriveInfo(szVolume, NULL, &dwCurSpeed, &dwMaxSpeed)))
                    {
                        if (WRITESPEED_FASTEST == dwCurSpeed)
                        {
                            // if we're set at the fastest speed, tone down to dwMaxSpeed
                            dwCurSpeed = dwMaxSpeed;
                        }

                        DWORD dwNewSpeed = 1;
                        // find the highest power of 2 smaller than dwSpeed
                        while (dwNewSpeed * 2 < dwCurSpeed)
                        {
                            dwNewSpeed *= 2;
                        }
                        _SetCachedDriveInfo(szVolume, DRIVE_USEEXISTING, dwNewSpeed, 0);
                    }
                }
                _SetNextPage(_hwndWizardPage, INDEX_DLG_BURNWIZ_BURN_FAILURE);
                break;
            }

            case IMAPI_E_CANNOT_WRITE_TO_MEDIA:
            {
                WCHAR szText[300];
                LoadString(HINST_THISDLL, IDS_BURN_CANTWRITETOMEDIA, szText, ARRAYSIZE(szText));
                SHPropertyBag_WriteStr(_ppb, PROPSTR_STATUSTEXT, szText);
                _SetNextPage(_hwndWizardPage, INDEX_DLG_BURNWIZ_BURN_FAILURE);
            }

            default:
                _SetNextPage(_hwndWizardPage, SUCCEEDED(hrOp) ? INDEX_DLG_BURNWIZ_BURN_SUCCESS : INDEX_DLG_BURNWIZ_BURN_FAILURE);
                break;
        }
    }

    return S_OK;
}

HRESULT CCDBurn::_GetBurnHR()
{
    HRESULT hrBurn = E_FAIL;
    DWORD dwHR;
    if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_HR, &dwHR)))
    {
        hrBurn = dwHR;
    }
    return hrBurn;
}

void CCDBurn::_ShowRoxio()
{
    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(sei);
    sei.lpFile = L"http://go.microsoft.com/fwlink/?LinkId=932"; // http://www.roxio.com/
    ShellExecuteEx(&sei); // fully hardcoded
}

INT_PTR CCDBurn::_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_BURNWIZ_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            fRet = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_BURNWIZ_BURNAGAIN:
                case IDC_BURNWIZ_CLEAR:
                case IDC_BURNWIZ_EXIT:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNAGAIN) == BST_CHECKED)
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);
                    }
                    else
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH);
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), FALSE);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNAGAIN), BST_UNCHECKED);
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_FINISH);

                    WCHAR szStatus[300];
                    if (SUCCEEDED(SHPropertyBag_ReadStr(_ppb, PROPSTR_STATUSTEXT, szStatus, ARRAYSIZE(szStatus))))
                    {
                        SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT, szStatus);
                    }

                    if (SUCCEEDED(_GetBurnHR()))
                    {
                        if (SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_AUTOCLOSE, FALSE))
                        {
                            PropSheet_PressButton(GetParent(hwnd), PSBTN_FINISH);
                        }
                    }
                    else
                    {
                        Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNAGAIN), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_CLEAR), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_EXIT), BST_CHECKED);

                        if (IMAPI_E_LOSS_OF_STREAMING != _GetBurnHR())
                        {
                            ShowWindow(GetDlgItem(hwnd, IDC_BURNWIZ_LOWERED), FALSE);
                        }
                    }
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                {
                    // dump stored info since we're ejecting
                    _DumpDiscInfo();
                    // eject media
                    int iCurrent;
                    if (SUCCEEDED(CCDBurn::_GetCurrentDriveIndex(&iCurrent)))
                    {
                        CMountPoint *pmtpt = CMountPoint::GetMountPoint(iCurrent);
                        if (pmtpt)
                        {
                            pmtpt->Eject(hwnd);
                            pmtpt->Release();
                        }
                    }
                    // go back to the beginning
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), TRUE);
                    _SetNextPage(hwnd, INDEX_DLG_BURNWIZ_WAITFORMEDIA);
                    fRet = TRUE;
                    break;
                }

                case PSN_WIZFINISH:
                    if (!SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_ERASE, FALSE))
                    {
                        if (SUCCEEDED(_GetBurnHR()) ||
                            (pnmh->code == PSN_WIZFINISH) && (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_CLEAR) == BST_CHECKED))
                        {
                            // clean up staging area, the files are already on the cd.
                            CMINVOKECOMMANDINFO cmi = {0};
                            cmi.fMask = CMIC_MASK_FLAG_NO_UI;
                            _CleanUp(&cmi, FAILED(_GetBurnHR()));
                        }
                    }
                    fRet = TRUE;
                    break;

                case NM_CLICK:
                case NM_RETURN:
                    switch (pnmh->idFrom)
                    {
                    case IDC_BURNWIZ_LOWERED:
                        {
                            SHELLEXECUTEINFO sei = {0};
                            sei.cbSize = sizeof(sei);
                            sei.lpFile = L"hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Ccdmedia.chm%3A%3A/cdmedia_fail2_moreinfo_buffer_underrun.htm&select=TopLevelBucket_4/Hardware/CDs_and_other_storage_devices";
                            ShellExecuteEx(&sei); // fully hardcoded
                            fRet = TRUE;
                        }
                        break;

                    case IDC_BURNWIZ_ATTRIB:
                        _ShowRoxio();
                        fRet = TRUE;
                        break;
                    }
                    break;
            }
            break;
        }
    }
    return fRet;
}

INT_PTR CCDBurn::_DiskFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_BURNWIZ_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            fRet = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_BURNWIZ_BURNAGAIN:
                case IDC_BURNWIZ_EXIT:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNAGAIN) == BST_CHECKED)
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);
                    }
                    else
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH);
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), FALSE);
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_FINISH);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNAGAIN), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_EXIT), BST_CHECKED);

                    TCHAR szText[200];
                    if (SUCCEEDED(SHPropertyBag_ReadStr(_ppb, PROPSTR_DISCFULLTEXT, szText, ARRAYSIZE(szText))))
                    {
                        SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT, szText);
                    }
                    fRet = TRUE;
                    break;
                }

                case PSN_WIZNEXT:
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), TRUE);
                    _SetNextPage(hwnd, INDEX_DLG_BURNWIZ_WAITFORMEDIA);
                    fRet = TRUE;
                    break;

                case NM_CLICK:
                case NM_RETURN:
                    if (IDC_BURNWIZ_ATTRIB == pnmh->idFrom)
                    {
                        _ShowRoxio();
                        fRet = TRUE;
                    }
                    break;
            }
            break;
        }
    }
    return fRet;
}

// a stub page just to bail on the wizard when an extension says "dont run any more".
INT_PTR CCDBurn::_EarlyExitDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            PropSheet_PressButton(GetParent(hwnd), PSBTN_CANCEL);
            fRet = TRUE;
            break;
    }
    return fRet;
}

void CCDBurn::_HDFullSetText(HWND hwnd)
{
    TCHAR szStashDrive[4] = {0};
    if (FAILED(_GetCurrentStashDrive(szStashDrive, ARRAYSIZE(szStashDrive))))
    {
        // fall back to temp drive if path doesnt exist in registry
        TCHAR szTempPath[MAX_PATH];
        if (GetTempPath(ARRAYSIZE(szTempPath), szTempPath))
        {
            PathStripToRoot(szTempPath);
            StringCchCopy(szStashDrive, ARRAYSIZE(szStashDrive), szTempPath);
        }
    }

    if (szStashDrive[0])
    {
        LPTSTR pszMessage1 = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_BURN_HDFULL1), szStashDrive);
        if (pszMessage1)
        {
            SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT, pszMessage1);
            LocalFree(pszMessage1);
        }

        // 50 MB overhead fudge factor.  this is the best estimate we have.
        ULONGLONG cbStash = _cbStagedSize + 50 * 1024 * 1024;

        ULARGE_INTEGER ulFree;
        if (SHGetDiskFreeSpaceEx(szStashDrive, &ulFree, NULL, NULL) &&
            (ulFree.QuadPart < cbStash))
        {
            TCHAR szNeed[40], szToDelete[40];
            StrFormatByteSize64(cbStash, szNeed, ARRAYSIZE(szNeed));
            StrFormatByteSize64(cbStash - ulFree.QuadPart, szToDelete, ARRAYSIZE(szToDelete));

            LPTSTR pszMessage2 = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_BURN_HDFULL2), szNeed, szStashDrive, szToDelete);
            if (pszMessage2)
            {
                SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT2, pszMessage2);
                LocalFree(pszMessage2);
            }
        }
    }
}

INT_PTR CCDBurn::_HDFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_BURNWIZ_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            fRet = TRUE;
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), FALSE);
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_FINISH);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_CLEAR), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_EXIT), BST_CHECKED);

                    _HDFullSetText(hwnd);

                    fRet = TRUE;
                    break;
                }

                case PSN_WIZFINISH:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_CLEAR) == BST_CHECKED)
                    {
                        TCHAR szStash[4];
                        if (SUCCEEDED(_GetCurrentStashDrive(szStash, ARRAYSIZE(szStash))))
                        {
                            LaunchDiskCleanup(NULL, DRIVEID(szStash), DISKCLEANUP_NOFLAG);
                        }
                    }
                    fRet = TRUE;
                    break;

                case NM_CLICK:
                case NM_RETURN:
                    switch (pnmh->idFrom)
                    {
                    case IDC_BURNWIZ_STATUSTEXT:
                        {
                            SHELLEXECUTEINFO sei = {0};
                            sei.cbSize = sizeof(sei);
                            sei.lpFile = L"hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Ccdmedia.chm%3A%3A/cdmedia_fail3_moreinfo_disk_full.htm&select=TopLevelBucket_4/Hardware/CDs_and_other_storage_devices";
                            ShellExecuteEx(&sei); // fully hardcoded
                            fRet = TRUE;
                        }
                        break;

                    case IDC_BURNWIZ_ATTRIB:
                        _ShowRoxio();
                        fRet = TRUE;
                        break;
                    }
                    break;
            }
            break;
        }
    }
    return fRet;
}

INT_PTR CCDBurn::_NoFilesDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _SetupFirstPage(hwnd, FALSE);
            fRet = TRUE;
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), FALSE);
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_FINISH);
                    fRet = TRUE;
                    break;
                }

                case PSN_WIZFINISH:
                    fRet = TRUE;
                    break;
            }
            break;
        }
    }
    return fRet;
}

HRESULT CCDBurn::DriveMatches(int iDrive)
{
    HRESULT hr = E_FAIL;

    // check if the drive index matches what we stored off last time.
    // this lets us keep parsing the drive correctly if its been recently unmounted.
    DWORD dwDrive, cb = sizeof(dwDrive);
    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX, NULL, &dwDrive, &cb)) &&
        (iDrive == dwDrive))
    {
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::_GetPlainCDPidl(LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    HRESULT hr = E_FAIL;

    WCHAR szDrive[4];
    int iCurrent;
    if (SUCCEEDED(_GetCurrentDriveIndex(&iCurrent)) &&
        PathBuildRoot(szDrive, iCurrent))
    {
        hr = ILCreateFromPathEx(szDrive, NULL, ILCFP_FLAG_SKIPJUNCTIONS, ppidl, NULL);
    }
    return hr;
}

HRESULT CCDBurn::Bind(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv)
{
    IShellFolder *psfStg;
    HRESULT hr = _GetStagingFolder(pidl, IID_PPV_ARG(IShellFolder, &psfStg));
    if (SUCCEEDED(hr))
    {
        IAugmentedShellFolder *pasf;
        hr = SHCoCreateInstance(NULL, &CLSID_CDBurnFolder, NULL, IID_PPV_ARG(IAugmentedShellFolder, &pasf));
        if (SUCCEEDED(hr))
        {
            // initialize with its point in the shell namespace
            // NOTE: worry about IPersistFolder3?

            IPersistFolder *ppf;
            hr = pasf->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Initialize(pidl);
                ppf->Release();
            }

            if (SUCCEEDED(hr))
            {
                IBindCtx *pbcNoForce;
                if (pbc)
                {
                    // tack on to existing bind context if available
                    pbcNoForce = pbc;
                    pbc->AddRef();
                }
                else
                {
                    // otherwise make a new one
                    hr = CreateBindCtx(0, &pbcNoForce);
                }

                if (SUCCEEDED(hr))
                {
                    // this is the drive shellfolder for cd burning --
                    // in this case we want to ensure that new files specified by comdlg are created
                    // in the staging area, so we tell the drive shellfolder that it can't
                    // succeed on parsedisplayname if the file doesnt exist.
                    hr = pbcNoForce->RegisterObjectParam(STR_DONT_FORCE_CREATE, psfStg); // just need a non-null object to register
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlCD;
                        hr = _GetPlainCDPidl(&pidlCD);
                        if (SUCCEEDED(hr))
                        {
                            IShellFolder *psf;
                            hr = CFSFolder_CreateFolder(NULL, pbcNoForce, pidlCD, NULL, IID_PPV_ARG(IShellFolder, &psf));
                            if (SUCCEEDED(hr))
                            {
                                hr = pasf->AddNameSpace(&CLSID_CDBurn, psf, NULL, ASFF_COMMON);
                                psf->Release();
                            }
                            ILFree(pidlCD);
                        }

                        // clean up after ourselves
                        pbcNoForce->RevokeObjectParam(STR_DONT_FORCE_CREATE);
                    }
                    pbcNoForce->Release();
                }
            }


            // lets add the namespace that represents the storage

            if (SUCCEEDED(hr))
            {
                hr = pasf->AddNameSpace(&CLSID_StagingFolder, psfStg, NULL, ASFF_DEFNAMESPACE_ALL);
            }

            // tell the namespace its CLSID so we can get the correct views of the
            // web view etc.

            if (SUCCEEDED(hr))
            {
                IPropertyBag *ppb;
                hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb));
                if (SUCCEEDED(hr))
                {
                    // store the class ID for the CD mastering folder
                    SHPropertyBag_WriteGUID(ppb, L"MergedFolder\\CLSID", &CLSID_CDBurn);                    

                    // store the default effect for this folder.
                    SHPropertyBag_WriteInt(ppb, L"MergedFolder\\DropEffect", DROPEFFECT_COPY);       // sets the default

                    // say it's in a shellview.
                    SHPropertyBag_WriteBOOL(ppb, L"MergedFolder\\ShellView", TRUE);

                    SHLoadFromPropertyBag(pasf, ppb);

                    ppb->Release();
                }
            }

            if (SUCCEEDED(hr))
                hr = pasf->QueryInterface(riid, ppv);

            pasf->Release();
        }
        psfStg->Release();
    }
    return hr;
}

// IWizardSite

// note: these two methods change state -- the alternative is to have the
// extensions themselves manage which extension goes next.  we have to track
// which extension we're in with state because we dont get ownership of the
// wizard back until the extensions are done.
STDMETHODIMP CCDBurn::GetNextPage(HPROPSHEETPAGE *phPage)
{
    DWORD dwExtNum;
    if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_CURRENTEXT, &dwExtNum)))
    {
        SHPropertyBag_WriteDWORD(_ppb, PROPSTR_CURRENTEXT, dwExtNum + 1);
    }
    return _GetExtPageFromPropBag(FALSE, phPage);
}

STDMETHODIMP CCDBurn::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    DWORD dwExtNum;
    if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_CURRENTEXT, &dwExtNum)))
    {
        SHPropertyBag_WriteDWORD(_ppb, PROPSTR_CURRENTEXT, dwExtNum - 1);
    }
    return _GetExtPageFromPropBag(FALSE, phPage);
}

HRESULT CCDBurn::_GetExtPage(int nExt, BOOL fNext, HPROPSHEETPAGE *phpage)
{
    HRESULT hr = E_FAIL;
    // nExt is 1-based
    IWizardExtension *pwe = (IWizardExtension*)DPA_GetPtr(_hdpaExts, nExt - 1);
    if (pwe)
    {
        if (fNext)
        {
            hr = pwe->GetFirstPage(phpage);
        }
        else
        {
            hr = pwe->GetLastPage(phpage);
        }
    }
    return hr;
}

HRESULT CCDBurn::_GetExtPageFromPropBag(BOOL fNext, HPROPSHEETPAGE *phpage)
{
    HRESULT hr = S_OK;
    *phpage = NULL;

    // an extension could have completed, in which case check its return state to see if
    // we should be running more of them.
    DWORD dwState;
    if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_EXTENSIONCOMPLETIONSTATE, &dwState)))
    {
        if (dwState & CDBE_RET_STOPWIZARD)
        {
            // leave the wizard.
            *phpage = _rgWizPages[INDEX_DLG_BURNWIZ_EARLYEXIT];
        }
        else if (dwState & CDBE_RET_DONTRUNOTHEREXTS)
        {
            // we're done with extensions, go to the burn.
            *phpage = _rgWizPages[INDEX_DLG_BURNWIZ_BURN_PROGRESS];
        }
    }
    
    if (!*phpage)
    {
        DWORD dwExt;
        hr = SHPropertyBag_ReadDWORD(_ppb, PROPSTR_CURRENTEXT, &dwExt);
        if (SUCCEEDED(hr))
        {
            if ((int)dwExt > DPA_GetPtrCount(_hdpaExts))
            {
                // we're done with extensions, go to the burn.
                *phpage = _rgWizPages[INDEX_DLG_BURNWIZ_BURN_PROGRESS];
            }
            else if (dwExt == 0)
            {
                // we went 'back' through all extensions, put us at the start page.
                int nIndex = SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_ERASE, FALSE) ? INDEX_DLG_BURNWIZ_STARTERASE : INDEX_DLG_BURNWIZ_WELCOME;
                *phpage = _rgWizPages[nIndex];
            }
            else
            {
                hr = _GetExtPage(dwExt, fNext, phpage);
            }
        }
    }
    return hr;
}

void CCDBurn::_SetExtPageFromPropBag(HWND hwnd, BOOL fNext)
{
    HPROPSHEETPAGE hpage;
    if (SUCCEEDED(_GetExtPageFromPropBag(fNext, &hpage)))
    {
        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
    }
}

HRESULT CCDBurn::_TryCLSID(REFCLSID clsid, DWORD dwExtType, REFIID riid, void **ppv)
{
    *ppv = NULL;

    ICDBurnExt *pcdbe;
    // Use SHExtCoCreateInstance to go through approval checking and app compat checking
    HRESULT hr = SHExtCoCreateInstance2(NULL, &clsid, NULL, CLSCTX_ALL, IID_PPV_ARG(ICDBurnExt, &pcdbe));
    if (SUCCEEDED(hr))
    {
        DWORD dw;
        hr = pcdbe->GetSupportedActionTypes(&dw);
        if (SUCCEEDED(hr))
        {
            if (dw & dwExtType)
            {
                hr = pcdbe->QueryInterface(riid, ppv);
            }
            else
            {
                hr = E_NOTIMPL;
            }
        }
        pcdbe->Release();
    }
    ASSERT(SUCCEEDED(hr) ? (*ppv != NULL) : (*ppv == NULL));
    return hr;
}

HRESULT CCDBurn::_TryKey(LPTSTR pszKey, DWORD dwExtType, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;

    TCHAR szFullKey[MAX_PATH];
    lstrcpyn(szFullKey, REGSTR_PATH_HANDLERS, ARRAYSIZE(szFullKey));
    PathAppend(szFullKey, pszKey);

    TCHAR szCLSID[MAX_GUID_STRING_LEN];
    DWORD cbCLSID = sizeof(szCLSID);
    CLSID clsid;
    if ((ERROR_SUCCESS == SHRegGetUSValue(szFullKey, REGVALUE_CLSID, NULL, szCLSID, &cbCLSID, FALSE, NULL, 0)) &&
        GUIDFromString(szCLSID, &clsid))
    {
        hr = _TryCLSID(clsid, dwExtType, riid, ppv);
    }
    ASSERT(SUCCEEDED(hr) ? (*ppv != NULL) : (*ppv == NULL));
    return hr;
}

HRESULT CCDBurn::_TestDropEffect(IDropTarget *pdt, IDataObject *pdo, REFIID riid, void **ppv)
{
    *ppv = NULL;

    DWORD dwEffect;
    POINTL pt = {0};
    HRESULT hr = pdt->DragEnter(pdo, 0, pt, &dwEffect);
    if (SUCCEEDED(hr))
    {
        if (dwEffect != DROPEFFECT_NONE)
        {
            hr = pdt->QueryInterface(riid, ppv);
        }
        else
        {
            hr = E_FAIL;
        }
        pdt->DragLeave();
    }
    ASSERT(SUCCEEDED(hr) ? (*ppv != NULL) : (*ppv == NULL));
    return hr;
}

HRESULT CCDBurn::_TryKeyWithDropEffect(LPTSTR pszKey, DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IDropTarget *pdt;
    HRESULT hr = _TryKey(pszKey, dwExtType, IID_PPV_ARG(IDropTarget, &pdt));
    if (SUCCEEDED(hr))
    {
        hr = _TestDropEffect(pdt, pdo, riid, ppv);
        pdt->Release();
    }
    ASSERT(SUCCEEDED(hr) ? (*ppv != NULL) : (*ppv == NULL));
    return hr;
}

HRESULT CCDBurn::_TryCLSIDWithDropEffect(REFCLSID clsid, DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IDropTarget *pdt;
    HRESULT hr = _TryCLSID(clsid, dwExtType, IID_PPV_ARG(IDropTarget, &pdt));
    if (SUCCEEDED(hr))
    {
        hr = _TestDropEffect(pdt, pdo, riid, ppv);
        pdt->Release();
    }
    ASSERT(SUCCEEDED(hr) ? (*ppv != NULL) : (*ppv == NULL));
    return hr;
}

void CCDBurn::_AddExtensionToDPA(IWizardExtension *pwe, HPROPSHEETPAGE *rgPages, UINT cNumPages, UINT *pcPagesAdded)
{
    IUnknown_SetSite(pwe, SAFECAST(this, IWizardSite *));

    BOOL fAdded = FALSE;
    UINT cExtPages;
    if (SUCCEEDED(pwe->AddPages(rgPages + *pcPagesAdded, cNumPages - *pcPagesAdded, &cExtPages)) && cExtPages)
    {
        if (-1 != DPA_AppendPtr(_hdpaExts, pwe))
        {
            fAdded = TRUE;
            *pcPagesAdded += cExtPages;
            pwe->AddRef();
        }
        else
        {
            for (UINT i = 0; i < cExtPages; i++)
            {
                DestroyPropertySheetPage(rgPages[*pcPagesAdded + i]);
            }
        }
    }

    if (!fAdded)
    {
        // if it's in the dpa, it gets the setsite(NULL) later.
        IUnknown_SetSite(pwe, NULL);
    }
}

// does the enumRegFlags == SHREGENUM_BOTH case.
DWORD MySHRegEnumUSKey(HUSKEY hUSKey, DWORD dwIndex, LPWSTR pszName, DWORD *pcchName)
{
    // start with HKCU if possible.
    DWORD cKeys;
    DWORD dwRet = SHRegQueryInfoUSKey(hUSKey, &cKeys, NULL, NULL, NULL, SHREGENUM_HKCU);
    if (ERROR_SUCCESS == dwRet)
    {
        // HKCU is present.
        if (dwIndex < cKeys)
        {
            // enum from HKCU first
            dwRet = SHRegEnumUSKey(hUSKey, dwIndex, pszName, pcchName, SHREGENUM_HKCU);
        }
        else
        {
            // and next, HKLM
            dwRet = SHRegEnumUSKey(hUSKey, dwIndex - cKeys, pszName, pcchName, SHREGENUM_HKLM);
        }
    }
    else
    {
        // go only with HKLM.
        dwRet = SHRegEnumUSKey(hUSKey, dwIndex, pszName, pcchName, SHREGENUM_HKLM);
    }
    return dwRet;
}

HRESULT CCDBurn::_FillExtensionDPA(HPROPSHEETPAGE *rgPages, UINT cNumPages, UINT *pcPagesAdded)
{
    _hdpaExts = DPA_Create(4);
    HRESULT hr = _hdpaExts ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        *pcPagesAdded = 0;
        // first up is the burn audio cd extension
        IWizardExtension *pwe;
        if (SUCCEEDED(_TryCLSID(CLSID_BurnAudioCDExtension, CDBE_TYPE_ALL, IID_PPV_ARG(IWizardExtension, &pwe))))
        {
            _AddExtensionToDPA(pwe, rgPages, cNumPages, pcPagesAdded);
            pwe->Release();
        }

        HUSKEY huskeyHandlers;
        if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_HANDLERS, KEY_READ, NULL, &huskeyHandlers, FALSE))
        {
            DWORD dwIndex = 0;
            TCHAR szKey[50];
            DWORD cchKey = ARRAYSIZE(szKey);
            while (ERROR_SUCCESS == SHRegEnumUSKey(huskeyHandlers, dwIndex, szKey, &cchKey, SHREGENUM_DEFAULT))
            {
                if (SUCCEEDED(_TryKey(szKey, CDBE_TYPE_ALL, IID_PPV_ARG(IWizardExtension, &pwe))))
                {
                    _AddExtensionToDPA(pwe, rgPages, cNumPages, pcPagesAdded);
                    pwe->Release();
                }
                dwIndex++;
                cchKey = ARRAYSIZE(szKey);
            }
            SHRegCloseUSKey(huskeyHandlers);
        }
    }
    return hr;
}

HRESULT CDBurn_GetExtensionObject(DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv)
{
    *ppv = NULL;

    TCHAR szDefault[50];
    DWORD cb = sizeof(szDefault);
    HRESULT hr = (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_HANDLERS, REGVALUE_FIRSTHANDLER,
                                                   NULL, szDefault, &cb, FALSE, NULL, 0)) ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        hr = CCDBurn::_TryKeyWithDropEffect(szDefault, dwExtType, pdo, riid, ppv);
    }
    else
    {
        szDefault[0] = 0;
    }

    // if we're not overridden by the FIRSTHANDLER value, try the burn audio cd extension.
    if (FAILED(hr))
    {
        hr = CCDBurn::_TryCLSIDWithDropEffect(CLSID_BurnAudioCDExtension, dwExtType, pdo, riid, ppv);
    }

    if (FAILED(hr))
    {
        HUSKEY huskeyHandlers;
        if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_HANDLERS, KEY_READ, NULL, &huskeyHandlers, FALSE))
        {
            DWORD dwIndex = 0;
            TCHAR szKey[50];
            DWORD cchKey = ARRAYSIZE(szKey);
            while (FAILED(hr) && (ERROR_SUCCESS == MySHRegEnumUSKey(huskeyHandlers, dwIndex, szKey, &cchKey)))
            {
                if (StrCmpI(szDefault, szKey) != 0)
                {
                    hr = CCDBurn::_TryKeyWithDropEffect(szKey, dwExtType, pdo, riid, ppv);
                }

                dwIndex++;
                cchKey = ARRAYSIZE(szKey);
            }
            SHRegCloseUSKey(huskeyHandlers);
        }
    }
    return hr;
}

STDMETHODIMP CCDBurn::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_FAIL;
    if (IsEqualGUID(guidService, SID_CDWizardHost))
    {
        if (IsEqualIID(riid, IID_IPropertyBag) && _ppb)
        {
            hr = _ppb->QueryInterface(riid, ppv);
        }
    }
    return hr;
}

STDMETHODIMP CCDBurn::AllowAutoPlay(LPCWSTR pszPath, DWORD dwContentType, LPCWSTR pszLabel, DWORD dwSerialNumber)
{
    HRESULT hr = S_OK; // default to allow autoplay
    int iDrive;
    if (SUCCEEDED(_GetCurrentDriveIndex(&iDrive)) &&
        (iDrive == DRIVEID(pszPath)))
    {
        // while we're registered in the running object table the wizard is always running, so dont autoplay.
        hr = S_FALSE;
    }
    return hr;
}

HRESULT CCDBurn::ConfirmOperation(IShellItem *psiSource, IShellItem *psiDest, STGTRANSCONFIRMATION stc, LPCUSTOMCONFIRMATION pcc)
{
    HRESULT hr = STRESPONSE_CONTINUE;  // use default postop handling.

    // null psiitem means this is postop for the entire operation.
    if (psiSource && IsEqualGUID(STCONFIRM_ACCESS_DENIED, stc))
    {
        DWORD dwCaps;
        BOOL fUDF;
        if (SUCCEEDED(_GetMediaCapabilities(&dwCaps, &fUDF)) && fUDF)
        {
            int id = (dwCaps & HWDMC_CDREWRITABLE) ? IDS_BURN_CANTWRITEMEDIACDRW : IDS_BURN_CANTWRITEMEDIACDR;
            ShellMessageBox(HINST_THISDLL, NULL, MAKEINTRESOURCE(id),
                            MAKEINTRESOURCE(IDS_BURN), MB_OK | MB_ICONSTOP);
            hr = E_FAIL; // stop the operation
        }
    }
    return hr;
}

typedef struct
{
    WCHAR szExts[MAX_PATH]; // PathMatchSpec list ("*.wma;*.mp3")
} FILE_EXTS;

// handles the audio cd burner extensions
class CBurnAudioCDExtension : public CObjectWithSite,
                              public ICDBurnExt,
                              public IDropTarget,
                              public IWizardExtension,
                              public INamespaceWalkCB
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ICDBurnExt methods
    STDMETHOD(GetSupportedActionTypes)(DWORD *pdwActions);

    // IDropTarget methods
    STDMETHOD(DragEnter)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { return E_NOTIMPL; }
    STDMETHOD(DragLeave)(void)
        { return E_NOTIMPL; }
    STDMETHOD(Drop)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IWizardExtension
    STDMETHOD(AddPages)(HPROPSHEETPAGE *aPages, UINT cPages, UINT *pnPages);
    STDMETHOD(GetFirstPage)(HPROPSHEETPAGE *phPage);
    STDMETHOD(GetLastPage)(HPROPSHEETPAGE *phPage);

    // INamespaceWalkCB
    STDMETHOD(FoundItem)(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHOD(EnterFolder)(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHOD(LeaveFolder)(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHOD(InitializeProgressDialog)(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
        { *ppszTitle = NULL; *ppszCancel = NULL; return E_NOTIMPL; }

    static INT_PTR s_MusicDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CBurnAudioCDExtension *pwe = s_GetBurnAudioCDExtension(hwnd, uMsg, lParam); return pwe->_MusicDlgProc(hwnd, uMsg, wParam, lParam); }

private:
    CBurnAudioCDExtension();
    ~CBurnAudioCDExtension();

    LONG _cRef;

    DWORD _cFiles, _cAudioFiles, _cNonAudioFiles; // state vars for walk callback
    BOOL _fBreakOnNonAudioFiles;
    HPROPSHEETPAGE _hpage;

    BOOL _fSelectMusic;
    HDSA _hdsaExtensions;  // bunch of FILE_EXTS.  we keep them individually for each extension and don't strcat them all
                           // together so if one registry entry is hopelessly bad it wont hurt everyone else.

    // hook stuff
    void _AddFileExtsForCLSID(REFCLSID clsid);
    void _AddFileExtsForKey(PCWSTR pszKey);
    void _AddAllExts();
    BOOL _HasAudioExtension(LPCTSTR pszName);
    BOOL _DataObjectHasAllAudioFiles(IDataObject *pdo);
    DWORD _CountOfAudioFilesForHandler(IDataObject *pdo, REFCLSID clsid);
    CLSID _GetDefaultCLSID();
    HRESULT _GetVerbForCLSID(REFCLSID clsid, PWSTR psz, UINT cch);
    BOOL _CanCreate(REFCLSID clsid);
    HRESULT _DropOnHandler(REFCLSID clsid, IDataObject *pdo);
    HRESULT _PickHandler(IDataObject *pdo, CLSID *pclsid);

    // wizard page
    static CBurnAudioCDExtension* s_GetBurnAudioCDExtension(HWND hwnd, UINT uMsg, LPARAM lParam);
    INT_PTR _MusicDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _SetCompletionState();

    // "exports"
    friend HRESULT CBurnAudioCDExtension_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
};

CBurnAudioCDExtension::CBurnAudioCDExtension() :
    _cRef(1)
{
    _fSelectMusic = TRUE;
}

CBurnAudioCDExtension::~CBurnAudioCDExtension()
{
    ASSERT(!_punkSite);
    DSA_Destroy(_hdsaExtensions);
}

// IUnknown

STDMETHODIMP_(ULONG) CBurnAudioCDExtension::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBurnAudioCDExtension::Release()
{
    ASSERT(0 != _cRef);
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}

HRESULT CBurnAudioCDExtension::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CBurnAudioCDExtension, ICDBurnExt),
        QITABENT(CBurnAudioCDExtension, IDropTarget),
        QITABENT(CBurnAudioCDExtension, IWizardExtension),
        QITABENT(CBurnAudioCDExtension, IObjectWithSite),
        QITABENT(CBurnAudioCDExtension, INamespaceWalkCB),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CBurnAudioCDExtension_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    if (punkOuter)
        return CLASS_E_NOAGGREGATION; 

    CBurnAudioCDExtension *pbe = new CBurnAudioCDExtension();
    if (!pbe)
        return E_OUTOFMEMORY;

    HRESULT hr = pbe->QueryInterface(riid, ppv);
    pbe->Release();
    return hr;
}

CBurnAudioCDExtension* CBurnAudioCDExtension::s_GetBurnAudioCDExtension(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CBurnAudioCDExtension*)ppsp->lParam;
    }
    return (CBurnAudioCDExtension*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}

HRESULT CBurnAudioCDExtension::GetSupportedActionTypes(DWORD *pdwActions)
{
    *pdwActions = CDBE_TYPE_MUSIC;
    return S_OK;
}

void CBurnAudioCDExtension::_AddFileExtsForKey(PCWSTR pszKey)
{
    ASSERT(_hdsaExtensions);

    FILE_EXTS fileexts;
    DWORD cb = sizeof(fileexts.szExts);
    if (ERROR_SUCCESS == SHRegGetUSValue(pszKey, REGVALUE_FILEEXTS, NULL, fileexts.szExts, &cb, FALSE, NULL, 0))
    {
        DSA_AppendItem(_hdsaExtensions, &fileexts);
    }
}

void CBurnAudioCDExtension::_AddFileExtsForCLSID(REFCLSID clsid)
{
    ASSERT(_hdsaExtensions);

    if (_CanCreate(clsid))
    {
        WCHAR szCLSID[GUIDSTR_MAX];
        SHStringFromGUID(clsid, szCLSID, ARRAYSIZE(szCLSID));

        WCHAR szExtKey[MAX_PATH];
        StrCpyN(szExtKey, REGSTR_PATH_AUDIOEXTS, ARRAYSIZE(szExtKey));
        PathAppend(szExtKey, szCLSID);

        _AddFileExtsForKey(szExtKey);
    }
}

void CBurnAudioCDExtension::_AddAllExts()
{
    HUSKEY huskeyExts;
    if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_AUDIOEXTS, KEY_READ, NULL, &huskeyExts, FALSE))
    {
        DWORD dwIndex = 0;
        WCHAR szCLSID[GUIDSTR_MAX];
        DWORD cchCLSID = ARRAYSIZE(szCLSID);
        while (ERROR_SUCCESS == MySHRegEnumUSKey(huskeyExts, dwIndex, szCLSID, &cchCLSID))
        {
            CLSID clsid;
            if (GUIDFromString(szCLSID, &clsid))
            {
                _AddFileExtsForCLSID(clsid);
            }

            cchCLSID = ARRAYSIZE(szCLSID);
            dwIndex++;
        }
        SHRegCloseUSKey(huskeyExts);
    }
}

BOOL CBurnAudioCDExtension::_HasAudioExtension(LPCTSTR pszName)
{
    // this list of extensions is based on what files the extension can BURN, not just play.
    // (so we cant do a check for generic audio type.)
    BOOL fRet = FALSE;
    if (_hdsaExtensions)
    {
        for (int i = 0; !fRet && (i < DSA_GetItemCount(_hdsaExtensions)); i++)
        {
            FILE_EXTS *pfileexts = (FILE_EXTS *)DSA_GetItemPtr(_hdsaExtensions, i);
            fRet = PathMatchSpec(pszName, pfileexts->szExts);
        }
    }
    return fRet;
}

HRESULT CBurnAudioCDExtension::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    // early-out if we are checking that ALL files are audio files and we've found one that's not.
    if (_fBreakOnNonAudioFiles && (_cNonAudioFiles > 0))
        return E_FAIL;

    // break if we've seen enough files.
    if (_cFiles > 50)
        return E_FAIL;

    _cFiles++;

    TCHAR szName[MAX_PATH];
    HRESULT hr = DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName));
    if (SUCCEEDED(hr))
    {
        if (_HasAudioExtension(szName))
        {
            _cAudioFiles++;
        }
        else
        {
            _cNonAudioFiles++;
        }
    }
    return hr;
}

BOOL CBurnAudioCDExtension::_DataObjectHasAllAudioFiles(IDataObject *pdo)
{
    _cFiles = _cAudioFiles = _cNonAudioFiles = 0;
    _fBreakOnNonAudioFiles = TRUE;

    if (_hdsaExtensions)
        DSA_Destroy(_hdsaExtensions);
    _hdsaExtensions = DSA_Create(sizeof(FILE_EXTS), 4);
    if (_hdsaExtensions)
    {
        _AddAllExts();

        INamespaceWalk *pnsw;
        if (SUCCEEDED(CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(INamespaceWalk, &pnsw))))
        {
            pnsw->Walk(pdo, NSWF_DONT_ACCUMULATE_RESULT, 4, this);
            pnsw->Release();
        }
    }

    return ((_cFiles > 0) && (_cNonAudioFiles == 0));
}

DWORD CBurnAudioCDExtension::_CountOfAudioFilesForHandler(IDataObject *pdo, REFCLSID clsid)
{
    _cFiles = _cAudioFiles = _cNonAudioFiles = 0;
    if (pdo)
    {
        _fBreakOnNonAudioFiles = FALSE;

        if (_hdsaExtensions)
            DSA_Destroy(_hdsaExtensions);
        _hdsaExtensions = DSA_Create(sizeof(FILE_EXTS), 4);
        if (_hdsaExtensions)
        {
            _AddFileExtsForCLSID(clsid);

            INamespaceWalk *pnsw;
            if (SUCCEEDED(CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw))))
            {
                pnsw->Walk(pdo, NSWF_DONT_ACCUMULATE_RESULT, 4, this);
                pnsw->Release();
            }
        }
    }
    else
    {
        // if we're not given a data object, we're being polled just to see if we can create
        if (_CanCreate(clsid))
        {
            _cAudioFiles = 1;
        }
    }
    return _cAudioFiles;
}

BOOL CBurnAudioCDExtension::_CanCreate(REFCLSID clsid)
{
    // Use SHExtCoCreateInstance to go through approval checking and app compat checking
    IUnknown *punk;
    HRESULT hr = SHExtCoCreateInstance2(NULL, &clsid, NULL, CLSCTX_ALL, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        punk->Release();
    }
    return SUCCEEDED(hr);
}

// if pdo is NULL, only test which extensions can be cocreated.
HRESULT CBurnAudioCDExtension::_PickHandler(IDataObject *pdo, CLSID *pclsid)
{
    HRESULT hr;

    *pclsid = _GetDefaultCLSID();
    if (_CountOfAudioFilesForHandler(pdo, *pclsid) > 0)
    {
        // if the default handler supports any of the files, let it take over and we're done.
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;

        CLSID clsidBestSoFar;
        DWORD dwCountBestSoFar = 0;

        HUSKEY huskeyExts;
        if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_AUDIOEXTS, KEY_READ, NULL, &huskeyExts, FALSE))
        {
            DWORD dwIndex = 0;
            WCHAR szCLSID[GUIDSTR_MAX];
            DWORD cchKey = ARRAYSIZE(szCLSID);
            while (ERROR_SUCCESS == MySHRegEnumUSKey(huskeyExts, dwIndex, szCLSID, &cchKey))
            {
                CLSID clsidExt;
                if (GUIDFromString(szCLSID, &clsidExt))
                {
                    DWORD dwCountExt = _CountOfAudioFilesForHandler(pdo, clsidExt);
                    if (dwCountExt > dwCountBestSoFar)
                    {
                        hr = S_OK;
                        dwCountBestSoFar = dwCountExt;
                        clsidBestSoFar = clsidExt;
                    }
                }
                cchKey = ARRAYSIZE(szCLSID);
                dwIndex++;
            }
            SHRegCloseUSKey(huskeyExts);
        }

        if (SUCCEEDED(hr))
        {
            *pclsid = clsidBestSoFar;
        }
    }
    return hr;
}

HRESULT CBurnAudioCDExtension::DragEnter(IDataObject *pdo, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_NONE;

    // on DTC even the default handler may or may not be installed, so do an early check if we can create the object.
    // cache it since this DragEnter is hit determining if the "burn audio cd" task show up.
    static int s_fBurnHandlerAvailable = -1;
    if (s_fBurnHandlerAvailable == -1)
    {
        CLSID clsid;
        if (SUCCEEDED(_PickHandler(NULL, &clsid)))
        {
            s_fBurnHandlerAvailable = 1;
        }
        else
        {
            s_fBurnHandlerAvailable = 0;
        }
    }

    ICDBurnPriv *pcdbp;
    if (s_fBurnHandlerAvailable && SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_CDBurn, NULL, IID_PPV_ARG(ICDBurnPriv, &pcdbp))))
    {
        // mini-hack: we want the web view task "copy to audio cd" to always show up no matter what
        // the current state of the media is, however we only want to show the wizard page if it's blank.
        // so we check against if the wizard is active or not now.
        // this has the added effect of disabling the "copy to audio cd" task if we're burning in
        // the wizard -- which is probably what we want so its okay.
        if (_DataObjectHasAllAudioFiles(pdo))
        {
            BOOL fOnMedia;
            // if we're not running the wizard, go for it.
            // if we are running the wizard, make sure there are no files on the media.
            if ((S_OK != pcdbp->IsWizardUp()) || (SUCCEEDED(pcdbp->GetContentState(NULL, &fOnMedia)) && !fOnMedia))
            {
                *pdwEffect = DROPEFFECT_COPY;
            }
        }
        pcdbp->Release();
    }    
    return S_OK;
}

CLSID CBurnAudioCDExtension::_GetDefaultCLSID()
{
    WCHAR szCLSID[GUIDSTR_MAX];
    DWORD cb = sizeof(szCLSID);
    CLSID clsid;
    if ((ERROR_SUCCESS != SHRegGetUSValue(REGSTR_PATH_AUDIOEXTS, L"", NULL, szCLSID, &cb, FALSE, NULL, 0)) ||
        (!GUIDFromString(szCLSID, &clsid)))
    {
        clsid = CLSID_NULL; // default to this, if registry entry is not there or erroneous
    }
    return clsid;
}

HRESULT CBurnAudioCDExtension::_GetVerbForCLSID(REFCLSID clsid, PWSTR psz, UINT cch)
{
    WCHAR szCLSID[GUIDSTR_MAX];
    SHStringFromGUID(clsid, szCLSID, ARRAYSIZE(szCLSID));

    WCHAR szExtensionRegPath[MAX_PATH];
    lstrcpyn(szExtensionRegPath, REGSTR_PATH_AUDIOEXTS, ARRAYSIZE(szExtensionRegPath));
    PathAppend(szExtensionRegPath, szCLSID);

    DWORD cbVerb = cch * sizeof(*psz);
    return (ERROR_SUCCESS == SHRegGetUSValue(szExtensionRegPath, REGVALUE_VERB, NULL, psz, &cbVerb, FALSE, NULL, 0)) ? S_OK : E_FAIL;
}

HRESULT CBurnAudioCDExtension::_DropOnHandler(REFCLSID clsid, IDataObject *pdo)
{
    WCHAR wzVerb[20];
    HRESULT hr = _GetVerbForCLSID(clsid, wzVerb, ARRAYSIZE(wzVerb));
    if (SUCCEEDED(hr))
    {
        IShellExtInit *psei;
        hr = SHExtCoCreateInstance2(NULL, &clsid, NULL, CLSCTX_ALL, IID_PPV_ARG(IShellExtInit, &psei));
        if (SUCCEEDED(hr))
        {
            hr = psei->Initialize(NULL, pdo, NULL);
            if (SUCCEEDED(hr))
            {
                IContextMenu *pcm;
                hr = psei->QueryInterface(IID_PPV_ARG(IContextMenu, &pcm));
                if (SUCCEEDED(hr))
                {
                    HMENU hmenu = CreatePopupMenu();
                    if (hmenu)
                    {
                        hr = pcm->QueryContextMenu(hmenu, 0, 0x1, 0x7fff, 0);
                        if (SUCCEEDED(hr))
                        {
                            CMINVOKECOMMANDINFOEX ici = { 0 };
                            ici.cbSize = sizeof(CMINVOKECOMMANDINFOEX);

                            ici.fMask = CMIC_MASK_UNICODE;
                            ici.lpVerbW = wzVerb;

                            CHAR szVerbAnsi[20];
                            SHTCharToAnsi(wzVerb, szVerbAnsi, ARRAYSIZE(szVerbAnsi));
                            ici.lpVerb = szVerbAnsi;
                            ici.nShow = SW_NORMAL;

                            hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)(&ici));
                        }
                        DestroyMenu(hmenu);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    pcm->Release();
                }
            }
            psei->Release();
        }
    }
    return hr;
}

HRESULT CBurnAudioCDExtension::Drop(IDataObject *pdo, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    CLSID clsid;
    HRESULT hr = _PickHandler(pdo, &clsid);
    if (SUCCEEDED(hr))
    {
        _DropOnHandler(clsid, pdo);
    }
    return hr;
}

HRESULT CBurnAudioCDExtension::GetLastPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _hpage;
    return S_OK;
}

HRESULT CBurnAudioCDExtension::GetFirstPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _hpage;
    return S_OK;
}

HRESULT CBurnAudioCDExtension::AddPages(HPROPSHEETPAGE *aPages, UINT cPages, UINT *pnPages)
{
    *pnPages = 0;

    WIZPAGE c_wp =
        {DLG_BURNWIZ_MUSIC, IDS_BURNWIZ_MUSIC_HEAD, IDS_BURNWIZ_MUSIC_SUB, 0, CBurnAudioCDExtension::s_MusicDlgProc};

    _hpage = _CreatePropPageFromInfo(&c_wp, (LPARAM)this);
    if (cPages > 0)
    {
        aPages[0] = _hpage;
        *pnPages = 1;
    }
    return S_OK;
}

// pushes the return state back to the main wizard
void CBurnAudioCDExtension::_SetCompletionState()
{
    IPropertyBag *ppb;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_CDWizardHost, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        SHPropertyBag_WriteDWORD(ppb, PROPSTR_EXTENSIONCOMPLETIONSTATE, CDBE_RET_STOPWIZARD);
        ppb->Release();
    }
}

INT_PTR CBurnAudioCDExtension::_MusicDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNAUDIO), _fSelectMusic ? BST_CHECKED : BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNDATA), _fSelectMusic ? BST_UNCHECKED : BST_CHECKED);
                    fRet = TRUE;
                    break;

                case PSN_WIZBACK:
                    if (_punkSite) 
                    {
                        IWizardSite *pws;
                        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                        {
                            HPROPSHEETPAGE hpage;
                            if (SUCCEEDED(pws->GetPreviousPage(&hpage)))
                            {
                                PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                            }
                            pws->Release();
                        }
                    }
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNAUDIO) == BST_CHECKED)
                    {
                        IDataObject *pdo;
                        if (SUCCEEDED(_CreateDataObject(&pdo)))
                        {
                            POINTL pt = {0};
                            if (SUCCEEDED(Drop(pdo, 0, pt, NULL)))
                            {
                                _SetCompletionState();
                            }
                            pdo->Release();
                        }
                    }
                    if (_punkSite) 
                    {
                        IWizardSite *pws;
                        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                        {
                            HPROPSHEETPAGE hpage;
                            if (SUCCEEDED(pws->GetNextPage(&hpage)))
                            {
                                PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                            }
                            pws->Release();
                        }
                    }
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    _fSelectMusic = (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNAUDIO) == BST_CHECKED);
                    break;
            }
            break;
        }
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\clientxi.cpp ===
#include "shellprv.h"
#include "defcm.h"
#include "datautil.h"

/////////////////////////////////////////////////////////////////////////////
// CClientExtractIcon

class CClientExtractIconCB;

class ATL_NO_VTABLE CClientExtractIcon
    : public IShellExtInit
    , public IExtractIconW
    , public IExtractIconA
    , public IContextMenu
    , public IPersistPropertyBag
    , public IServiceProvider
    , public CComObjectRootEx<CComSingleThreadModel>
    , public CComCoClass<CClientExtractIcon, &CLSID_ClientExtractIcon>
{
public:

BEGIN_COM_MAP(CClientExtractIcon)
    COM_INTERFACE_ENTRY(IShellExtInit)
    // Need to use COM_INTERFACE_ENTRY_IID for the interfaces
    // that don't have an idl
    COM_INTERFACE_ENTRY_IID(IID_IExtractIconA, IExtractIconA)
    COM_INTERFACE_ENTRY_IID(IID_IExtractIconW, IExtractIconW)
    COM_INTERFACE_ENTRY_IID(IID_IContextMenu,  IContextMenu)
    COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IServiceProvider)
END_COM_MAP()

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CClientExtractIcon)

public:
    // *** IShellExtInit ***
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder,
                            IDataObject *pdto,
                            HKEY hkProgID);

    // *** IExtractIconA ***
    STDMETHODIMP GetIconLocation(UINT uFlags,
                                 LPSTR szIconFile,
                                 UINT cchMax,
                                 int *piIndex,
                                 UINT *pwFlags);
    STDMETHODIMP Extract(LPCSTR pszFile,
                         UINT nIconIndex,
                         HICON *phiconLarge,
                         HICON *phiconSmall,
                         UINT nIconSize);

    // *** IExtractIconW ***
    STDMETHODIMP GetIconLocation(UINT uFlags,
                                 LPWSTR szIconFile,
                                 UINT cchMax,
                                 int *piIndex,
                                 UINT *pwFlags);
    STDMETHODIMP Extract(LPCWSTR pszFile,
                         UINT nIconIndex,
                         HICON *phiconLarge,
                         HICON *phiconSmall,
                         UINT nIconSize);

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO pici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax);

    // *** IPersist methods ***
    STDMETHOD(GetClassID)(CLSID *pclsid)
        { *pclsid = CLSID_ClientExtractIcon; return S_OK; }

    // *** IPersistPropertyBag methods ***
    STDMETHOD(InitNew)();
    STDMETHOD(Load)(IPropertyBag *pbg,
                    IErrorLog *plog);
    STDMETHOD(Save)(IPropertyBag *pbg,
                    BOOL fClearDirty,
                    BOOL FSaveAllProperties) { return E_NOTIMPL; }

    // *** IServiceProvider methods ***
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

public:
    CClientExtractIcon() : _idmProperties(-1) { }
    ~CClientExtractIcon();

    // *** IContextMenuCB forwarded back to us ***
    HRESULT CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

public:
    IContextMenu *          _pcmInner;
    IAssociationElement *   _pae;
    IPropertyBag *          _pbag;
    LPITEMIDLIST            _pidlObject;
    CComObject<CClientExtractIconCB> *  _pcb;
    HKEY                    _hkClass;
    UINT                    _idmProperties;
    UINT                    _idCmdFirst;
};


/////////////////////////////////////////////////////////////////////////////
// CClientExtractIconCB - DefCM callback
//
class ATL_NO_VTABLE CClientExtractIconCB
    : public IContextMenuCB
    , public CComObjectRootEx<CComSingleThreadModel>
    , public CComCoClass<CClientExtractIconCB>
{
public:

BEGIN_COM_MAP(CClientExtractIconCB)
    // Need to use COM_INTERFACE_ENTRY_IID for the interfaces
    // that don't have an idl
    COM_INTERFACE_ENTRY_IID(IID_IContextMenuCB, IContextMenuCB)
END_COM_MAP()

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CClientExtractIconCB)

    void Attach(CClientExtractIcon *pcxi) { _pcxi = pcxi; }

public:
    // *** IContextMenuCB ***
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        if (_pcxi)
            return _pcxi->CallBack(psf, hwnd, pdtobj, uMsg, wParam, lParam);

        return E_FAIL;
    }

public:
    CClientExtractIcon *_pcxi;
};

/////////////////////////////////////////////////////////////////////////////

STDAPI CClientExtractIcon_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppunk)
{
    return CClientExtractIcon::_CreatorClass::CreateInstance(punkOuter, riid, ppunk);
}

CClientExtractIcon::~CClientExtractIcon()
{
    InitNew();
}


// *** IPersistPropertyBag::InitNew ***
HRESULT CClientExtractIcon::InitNew()
{
    ATOMICRELEASE(_pcmInner);
    ATOMICRELEASE(_pae);
    ATOMICRELEASE(_pbag);
    ILFree(_pidlObject);
    if (_hkClass) RegCloseKey(_hkClass);
    if (_pcb)
    {
        _pcb->Attach(NULL); // break circular reference
        _pcb->Release();
        _pcb = NULL;
    }

    return S_OK;
}

//
//  Property bag items:
//
//  Element = CLSID_Assoc* element to create
//  InitString = string to IPersistString2::SetString with
//  opentext = display name for "open" command (if not overridden)
//
//  If the client did not customize a "properties" command, then we
//  also use these values:
//
//      properties = program to execute for "properties"
//      propertiestext = name for the "properties" command
//

// *** IPersistPropertyBag::Load ***
HRESULT CClientExtractIcon::Load(IPropertyBag *pbag, IErrorLog *plog)
{
    HRESULT hr;

    // Erase any old state
    InitNew();

    // Save the property bag so we can mess with him later
    _pbag = pbag;
    if (_pbag)
    {
        _pbag->AddRef();
    }

    // Get the CLSID we are dispatching through and initialize it
    // with the InitString.
    CLSID clsid;
    hr = SHPropertyBag_ReadGUID(pbag, L"Element", &clsid);
    if (SUCCEEDED(hr))
    {
        BSTR bs;
        hr = SHPropertyBag_ReadBSTR(pbag, L"InitString", &bs);
        if (SUCCEEDED(hr))
        {
            hr = THR(AssocElemCreateForClass(&clsid, bs, &_pae));
            ::SysFreeString(bs);

            // Ignore failure of AssocElemCreateForClass
            // It can fail if the user's default client got uninstalled
            hr = S_OK;
        }
    }

    return hr;
}

// *** IServiceProvider::QueryService ***
//
//  We cheat and use ISericeProvider::QueryService as a sort of
//  "QueryInterface that's allowed to break COM identity rules".
//

HRESULT CClientExtractIcon::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (guidService == IID_IAssociationElement && _pae)
    {
        return _pae->QueryInterface(riid, ppvObj);
    }
    *ppvObj = NULL;
    return E_FAIL;
}

// *** IShellExtInit::Initialize
//
//  Only if the HKEY specifies a ClientType.
//
HRESULT CClientExtractIcon::Initialize(LPCITEMIDLIST, IDataObject *pdto, HKEY hkClass)
{
    ILFree(_pidlObject);

    HRESULT hr = PidlFromDataObject(pdto, &_pidlObject);

    if (_hkClass)
    {
        RegCloseKey(_hkClass);
    }
    if (hkClass)
    {
        _hkClass = SHRegDuplicateHKey(hkClass);
    }
    return hr;
}

// *** IExtractIconA::GetIconLocation

HRESULT CClientExtractIcon::GetIconLocation(
            UINT uFlags, LPSTR szIconFile, UINT cchMax,
            int *piIndex, UINT *pwFlags)
{
    WCHAR wszPath[MAX_PATH];
    HRESULT hr = GetIconLocation(uFlags, wszPath, ARRAYSIZE(wszPath), piIndex, pwFlags);
    if (SUCCEEDED(hr))
    {
        SHUnicodeToAnsi(wszPath, szIconFile, cchMax);
    }
    return hr;
}

// *** IExtractIconA::Extract

HRESULT CClientExtractIcon::Extract(
            LPCSTR pszFile, UINT nIconIndex,
            HICON *phiconLarge, HICON *phiconSmall,
            UINT nIconSize)
{
    return S_FALSE;
}

// *** IExtractIconW::GetIconLocation

HRESULT CClientExtractIcon::GetIconLocation(
            UINT uFlags, LPWSTR szIconFile, UINT cchMax,
            int *piIndex, UINT *pwFlags)
{
    szIconFile[0] = L'\0';

    if (_pae)
    {
        LPWSTR pszIcon;
        HRESULT hr = _pae->QueryString(AQS_DEFAULTICON, NULL, &pszIcon);
        if (SUCCEEDED(hr))
        {
            lstrcpynW(szIconFile, pszIcon, cchMax);
            SHFree(pszIcon);
        }
    }


    if (!szIconFile[0] && _hkClass)
    {
        LONG cb = cchMax * sizeof(TCHAR);
        RegQueryValueW(_hkClass, L"DefaultIcon", szIconFile, &cb);
    }

    if (szIconFile[0])
    {
        *pwFlags = GIL_PERCLASS;
        *piIndex = PathParseIconLocationW(szIconFile);
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

// *** IExtractIconW::Extract

HRESULT CClientExtractIcon::Extract(
            LPCWSTR pszFile, UINT nIconIndex,
            HICON *phiconLarge, HICON *phiconSmall,
            UINT nIconSize)
{
    return S_FALSE;
}

// *** IContextMenuCB forwarded back to us ***
HRESULT CClientExtractIcon::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    WCHAR wszBuf[MAX_PATH];

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        {
            QCMINFO *pqcm = (QCMINFO *)lParam;
            //  Add a "Properties" command in case we end up needing one.
            //  (And if not, we'll remove it afterwards.)

            if (SUCCEEDED(SHPropertyBag_ReadStr(_pbag, L"propertiestext", wszBuf, ARRAYSIZE(wszBuf))))
            {
                SHLoadIndirectString(wszBuf, wszBuf, ARRAYSIZE(wszBuf), NULL);
                InsertMenuW(pqcm->hmenu, pqcm->indexMenu, MF_BYPOSITION | MF_STRING, pqcm->idCmdFirst, wszBuf);
                _idmProperties = pqcm->idCmdFirst++;
            }
            return S_OK;            // Please merge the HKEY\shell stuff
        }

    case DFM_MERGECONTEXTMENU_TOP:
        // The app has added its menu items; see what needs to be cleaned up
        {
            QCMINFO *pqcm = (QCMINFO *)lParam;

            // See if they added a "Properties" item.
            // If so, then delete ours.
            if (GetMenuIndexForCanonicalVerb(pqcm->hmenu, _pcmInner, _idCmdFirst, L"properties") != 0xFFFFFFFF)
            {
                // Yes they do, so delete our bogus one
                DeleteMenu(pqcm->hmenu, _idmProperties, MF_BYCOMMAND);
                _idmProperties = -1;
            }

            // Now see if their "open" command uses the default name.
            // If so, then we replace it with a friendlier name.
            BOOL fCustomOpenString = FALSE;
            IAssociationElement *paeOpen;
            if (_pae && SUCCEEDED(_pae->QueryObject(AQVO_SHELLVERB_DELEGATE, L"open", IID_PPV_ARG(IAssociationElement, &paeOpen))))
            {
                if (SUCCEEDED(paeOpen->QueryExists(AQN_NAMED_VALUE, L"MUIVerb")) ||
                    SUCCEEDED(paeOpen->QueryExists(AQN_NAMED_VALUE, NULL)))
                {
                    fCustomOpenString = TRUE;
                }
                paeOpen->Release();
            }

            if (!fCustomOpenString)
            {
                UINT idm = GetMenuIndexForCanonicalVerb(pqcm->hmenu, _pcmInner, _idCmdFirst, L"open");
                if (idm != 0xFFFFFFFF)
                {
                    if (SUCCEEDED(SHPropertyBag_ReadStr(_pbag, L"opentext", wszBuf, ARRAYSIZE(wszBuf))) &&
                        wszBuf[0])
                    {
                        SHLoadIndirectString(wszBuf, wszBuf, ARRAYSIZE(wszBuf), NULL);
                        MENUITEMINFO mii;
                        mii.cbSize = sizeof(mii);
                        mii.fMask = MIIM_STRING;
                        mii.dwTypeData = wszBuf;
                        SetMenuItemInfo(pqcm->hmenu, idm, TRUE, &mii);
                    }
                }
            }
        }
        return S_OK;


    case DFM_INVOKECOMMANDEX:
        switch (wParam)
        {
        case 0:     // Properties
            if (SUCCEEDED(SHPropertyBag_ReadStr(_pbag, L"properties", wszBuf, ARRAYSIZE(wszBuf))))
            {
                DFMICS *pdfmics = (DFMICS *)lParam;
                if (ShellExecCmdLine(pdfmics->pici->hwnd, wszBuf, NULL, SW_SHOWNORMAL, NULL, 0))
                {
                    return S_OK;
                }
                else
                {
                    return E_FAIL;
                }
            }
            break;

        default:
            ASSERT(!"Unexpected DFM_INVOKECOMMAND");
            break;
        }
        return E_FAIL;

    default:
        return E_NOTIMPL;
    }
}

// *** IContextMenu::QueryContextMenu ***
HRESULT CClientExtractIcon::QueryContextMenu(
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags)
{
    HRESULT hr;
    if (!_pcmInner)
    {
        HKEY hk = NULL;
        if (_pae)
        {
            // If this fails, we continue with a NULL key
            AssocKeyFromElement(_pae, &hk);
        }

        if (!_pcb)
        {
            hr = CComObject<CClientExtractIconCB>::CreateInstance(&_pcb);
            if (SUCCEEDED(hr))
            {
                _pcb->Attach(this);
                _pcb->AddRef();
            }
        }
        else
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            IShellFolder *psf;
            hr = SHGetDesktopFolder(&psf);
            if (SUCCEEDED(hr))
            {
                DEFCONTEXTMENU dcm = {
                    NULL,                       // hwnd
                    _pcb,                       // pcmcb
                    NULL,                       // pidlFolder
                    psf,                        // IShellFolder
                    1,                          // cidl
                    (LPCITEMIDLIST*)&_pidlObject, // apidl
                    NULL,                       // paa
                    1,                          // cKeys
                    &hk,                        // aKeys
                };
                hr = CreateDefaultContextMenu(&dcm, &_pcmInner);
                psf->Release();
            }
        }

        if (hk)
        {
            RegCloseKey(hk);
        }

        if (!_pcmInner)
        {
            return E_FAIL;
        }
    }

    if (_pcmInner)
    {
        _idCmdFirst = idCmdFirst;
        uFlags |= CMF_VERBSONLY; // Don't do cut/copy/paste/link
        hr = _pcmInner->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// *** IContextMenu::InvokeCommand ***
HRESULT CClientExtractIcon::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;
    if (_pcmInner)
    {
        hr = _pcmInner->InvokeCommand(pici);
    }

    return hr;
}

// *** IContextMenu::GetCommandString ***
HRESULT CClientExtractIcon::GetCommandString(
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax)
{
    if (!_pcmInner) return E_FAIL;

    return _pcmInner->GetCommandString(idCmd, uType, pwReserved, pszName, cchMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\clsobj.h ===
#include "unicpp\deskhtm.h"

#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0

EXTERN_C IClassFactory* g_cfWebViewPluggableProtocol;

STDAPI CActiveDesktop_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDeskMovr_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CCopyToMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CMoveToMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CWebViewMimeFilter_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CWebViewPluggableProtocol_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDeskHtmlProp_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellDispatch_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CShellFolderView_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CShellFolderViewOC_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CWebViewFolderContents_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFolderOptionsPsx_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CStartMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellCmdFileIcon_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI CSendToMenu_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CNewMenu_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CFolderShortcut_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CFileSearchBand_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMountedVolume_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMTAInjector_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CFileTypes_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CDelegateFolder_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CDragImages_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CExeDropTarget_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellMonikerHelper_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFolderItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFolderItemsFDF_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CNetCrawler_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CWorkgroupCrawler_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CEncryptionContextMenuHandler_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
STDAPI CPropertyUI_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CTimeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CSizeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFreeSpaceCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDriveSizeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDriveTypeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CQueryAssociations_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CLocalCopyHelper_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDynamicStorage_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CCDBurn_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CBurnAudioCDExtension_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMergedFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CCDBurnFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CCompositeFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CTripleD_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CStartMenuFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CProgramsFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
// STDAPI CSystemRestoreCleaner_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CVerColProvider_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellFileDefExt_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellDrvDefExt_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CShellNetDefExt_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDrives_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CTray_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDesktop_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CBriefcase_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CRecycleBin_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CNetwork_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CCopyHook_CreateInstance(IUnknown *, REFIID , void **);
STDAPI CShellLink_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CControlPanel_CreateInstance(IUnknown *, REFIID , void **);
STDAPI CPrinters_CreateInstance(IUnknown *, REFIID , void **);
STDAPI CBitBucket_CreateInstance(IUnknown *, REFIID , void **);
STDAPI CProxyPage_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CScrapData_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFSFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CInetRoot_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDocFindFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFindPersistHistory_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDefViewPersistHistory_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CComputerFindFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDocFindCommand_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFSBrfFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CURLExec_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CRecycleBinCleaner_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CDocFileColumns_CreateInstance(IUnknown *punk, REFIID riid, void **);
STDAPI CLinkColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **);
STDAPI CFileSysColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **);
STDAPI CHWShellExecute_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CDeviceEventHandler_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CUserNotification_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CStorageProcessor_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);      // isproc.*
STDAPI CVirtualStorageEnum_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv);   // vstgenum.*
STDAPI CVirtualStorage_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv);       // virtualstorage.*
STDAPI CTransferConfirmation_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv); // confirmationui.*
STDAPI CAutomationCM_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv);
STDAPI CThumbStore_CreateInstance(IUnknown* punkOther, REFIID riid, void **ppv);
STDAPI CCategoryProvider_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CSharedDocFolder_CreateInstance(IUnknown *punkOut, REFIID riid, void **ppv);
STDAPI CPostBootReminder_CreateInstance(IUnknown *punkOut, REFIID riid, void **ppv);
STDAPI CISFBand_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMenuBand_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CTrackShellMenu_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CMenuBandSite_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppv);
STDAPI CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppv);
STDAPI CQuickLinks_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CUserEventTimer_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CThumbnail_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CStartMenuPin_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);
STDAPI CClientExtractIcon_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);
STDAPI CMyDocsFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CMergedCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFolderCustomize_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CWebViewRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CThemesRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CWirelessDevices_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
STDAPI CNamespaceWalk_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CWebWizardPage_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI CPersonalStartMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CFadeTask_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
STDAPI CAutoPlayVerb_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI CHWMixedContent_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI CFolderViewHost_CreateInstance(IUnknown *punkOut, REFIID riid, void **ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\clsobj.c ===
//
// This file contains the DllGetClassObject for the shell32.dll COM objects
//
#include "shellprv.h"
#pragma  hdrstop

#include <shguidp.h>    // get the CLSID definitions, the bits are built into shguidp.lib
#include <shlguid.h>
#include <shldisp.h>

#include "actdesk.h"
#include "ovrlaymn.h"
#include "treewalk.h"
#include "openwith.h"
#include "clsobj.h"

#define DllAddRef()     // once we implement DllCanUnloadNow we need these
#define DllRelease()    


// static class factory (no allocs!)

typedef struct {
    const IClassFactoryVtbl *cf;
    REFCLSID rclsid;
    HRESULT (*pfnCreate)(IUnknown *, REFIID, void **);
    ULONG flags;
} OBJ_ENTRY;

// flags:
#define OBJ_AGGREGATABLE 1

extern const IClassFactoryVtbl c_CFVtbl;        // forward

//
// we always do a linear search here so put your most often used things first
//
// we save code by checking aggregation on our side (have a bit in this const table)
// instead of having each CreateInstance function do it (since most are not aggregatable)
//
const OBJ_ENTRY c_clsmap[] = {
    { &c_CFVtbl, &CLSID_QueryAssociations,          CQueryAssociations_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_MyDocuments,                CMyDocsFolder_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellDesktop,               CDesktop_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellFSFolder,              CFSFolder_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_MyComputer,                 CDrives_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_NetworkPlaces,              CNetwork_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellFileDefExt,            CShellFileDefExt_CreateInstance, OBJ_AGGREGATABLE },

    { &c_CFVtbl, &CLSID_ShellItem,                  CShellItem_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_OpenWithMenu,               COpenWithMenu_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ShellLink,                  CShellLink_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellDrvDefExt,             CShellDrvDefExt_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_ShellNetDefExt,             CShellDrvDefExt_CreateInstance, OBJ_AGGREGATABLE },

    { &c_CFVtbl, &CLSID_ShellCopyHook,              CCopyHook_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ControlPanel,               CControlPanel_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_Printers,                   CPrinters_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_RecycleBin,                 CBitBucket_CreateInstance, 0 },

    { &c_CFVtbl, &CLSID_CFSIconOverlayManager,      CFSIconOverlayManager_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_RecycleBinCleaner,          CRecycleBinCleaner_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DocFindFolder,              CDocFindFolder_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DocFindPersistHistory,      CFindPersistHistory_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DefViewPersistHistory,      CDefViewPersistHistory_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ComputerFindFolder,         CComputerFindFolder_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DocFindCommand,             CDocFindCommand_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_CShellTreeWalker,           CShellTreeWalker_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_BriefcaseFolder,            CFSBrfFolder_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DocFileColumnProvider,      CDocFileColumns_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_LinkColumnProvider,         CLinkColumnProvider_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_FileSysColumnProvider,      CFileSysColumnProvider_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_FileSearchBand,             CFileSearchBand_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_FolderShortcut,             CFolderShortcut_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_MountedVolume,              CMountedVolume_CreateInstance, 0 },
    // menuband objects
    { &c_CFVtbl, &CLSID_MenuBand,                   CMenuBand_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ISFBand,                    CISFBand_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_QuickLinks,                 CQuickLinks_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_TrackShellMenu,             CTrackShellMenu_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_MenuBandSite,               CMenuBandSite_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_MenuDeskBar,                CMenuDeskBar_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ActiveDesktop,              CActiveDesktop_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DeskMovr,                   CDeskMovr_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_CopyToMenu,                 CCopyToMenu_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_MoveToMenu,                 CMoveToMenu_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_CDeskHtmlProp,              CDeskHtmlProp_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellFldSetExt,             CFolderOptionsPsx_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_Shell,                      CShellDispatch_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellFolderView,            CShellFolderView_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_ShellFolderViewOC,          CShellFolderViewOC_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_WebViewFolderContents,      CWebViewFolderContents_CreateInstance, OBJ_AGGREGATABLE },
    { &c_CFVtbl, &CLSID_StartMenu,                  CStartMenu_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_CmdFileIcon,                CShellCmdFileIcon_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_NewMenu,                    CNewMenu_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_SendToMenu,                 CSendToMenu_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_FileTypes,                  CFileTypes_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_MIMEFileTypesHook,          CFileTypes_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_DragDropHelper,             CDragImages_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ExeDropTarget,              CExeDropTarget_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_FolderItem,                 CFolderItem_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_FolderItemsFDF,             CFolderItemsFDF_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_NetCrawler,                 CNetCrawler_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_WorkgroupNetCrawler,        CWorkgroupCrawler_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_EncryptionContextMenuHandler, CEncryptionContextMenuHandler_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_PropertiesUI,               CPropertyUI_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_TimeCategorizer,            CTimeCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_SizeCategorizer,            CSizeCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_DriveSizeCategorizer,       CDriveSizeCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_DriveTypeCategorizer,       CDriveTypeCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_FreeSpaceCategorizer,       CFreeSpaceCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_MergedCategorizer,          CMergedCategorizer_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_DynamicStorage,             CDynamicStorage_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_CDBurn,                     CCDBurn_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_BurnAudioCDExtension,       CBurnAudioCDExtension_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_LocalCopyHelper,            CLocalCopyHelper_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_MergedFolder,               CMergedFolder_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_CDBurnFolder,               CCDBurnFolder_CreateInstance, 0},
//  { &c_CFVtbl, &CLSID_TripleD,                    CTripleD_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_CompositeFolder,            CCompositeFolder_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_StartMenuFolder,            CStartMenuFolder_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ProgramsFolder,             CProgramsFolder_CreateInstance, 0},
//  { &c_CFVtbl, &CLSID_SyreCleaner,                CSystemRestoreCleaner_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_VersionColProvider,         CVerColProvider_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_HWShellExecute,             CHWShellExecute_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ShellAutoplay,              CDeviceEventHandler_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_AutoPlayVerb,               CAutoPlayVerb_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_UserNotification,           CUserNotification_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_UserEventTimer,             CUserEventTimer_CreateInstance, 0},    
    { &c_CFVtbl, &CLSID_StorageProcessor,           CStorageProcessor_CreateInstance,   0},
    { &c_CFVtbl, &CLSID_TransferConfirmationUI,     CTransferConfirmation_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_AutomationCM,               CAutomationCM_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ShellThumbnailDiskCache,    CThumbStore_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_DefCategoryProvider,        CCategoryProvider_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_SharedDocuments,            CSharedDocFolder_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_PostBootReminder,           CPostBootReminder_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_Thumbnail,                  CThumbnail_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_StartMenuPin,               CStartMenuPin_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ClientExtractIcon,          CClientExtractIcon_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_FolderCustomize,            CFolderCustomize_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_CWebViewMimeFilter,         CWebViewMimeFilter_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_WebViewRegTreeItem,         CWebViewRegTreeItem_CreateInstance, 0},
    { &c_CFVtbl, &CLSID_ThemesRegTreeItem,          CThemesRegTreeItem_CreateInstance, 0},
//    { &c_CFVtbl, &CLSID_WirelessDevices,            CWirelessDevices_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_NamespaceWalker,            CNamespaceWalk_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_WebWizardHost,              CWebWizardPage_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_PersonalStartMenu,          CPersonalStartMenu_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_FadeTask,                   CFadeTask_CreateInstance, 0 },
    { &c_CFVtbl, &CLSID_FolderViewHost,             CFolderViewHost_CreateInstance, 0 },
#ifdef _X86_
    { &c_CFVtbl, &CLSID_PifProperties,              CProxyPage_CreateInstance, 0 },
#endif
    { NULL, NULL, NULL }
};


STDMETHODIMP CCF_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    // OBJ_ENTRY *this = IToClass(OBJ_ENTRY, cf, pcf);
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = (void *)pcf;
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CCF_AddRef(IClassFactory *pcf)
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CCF_Release(IClassFactory *pcf)
{
    DllRelease();
    return 1;
}

STDMETHODIMP CCF_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter, REFIID riid, void **ppvObject)
{
    OBJ_ENTRY *this = IToClass(OBJ_ENTRY, cf, pcf);

    *ppvObject = NULL; // to avoid nulling it out in every create function...

    if (punkOuter && !(this->flags & OBJ_AGGREGATABLE))
        return CLASS_E_NOAGGREGATION;

    return this->pfnCreate(punkOuter, riid, ppvObject);
}

STDMETHODIMP CCF_LockServer(IClassFactory *pcf, BOOL fLock)
{
/*  SHELL32.DLL does not implement DllCanUnloadNow, thus does not have a DLL refcount
    This means we can never unload!

    if (fLock)
        DllAddRef();
    else
        DllRelease();
*/
    return S_OK;
}

const IClassFactoryVtbl c_CFVtbl = {
    CCF_QueryInterface, CCF_AddRef, CCF_Release,
    CCF_CreateInstance,
    CCF_LockServer
};

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        const OBJ_ENTRY *pcls;
        for (pcls = c_clsmap; pcls->rclsid; pcls++)
        {
            if (IsEqualIID(rclsid, pcls->rclsid))
            {
                *ppv = (void *)&(pcls->cf);
                DllAddRef();
                return NOERROR;
            }
        }
#ifdef DEBUG
        {
            TCHAR szClass[GUIDSTR_MAX];
            SHStringFromGUID(rclsid, szClass, ARRAYSIZE(szClass));
            AssertMsg(TF_ERROR,
                      TEXT("DllGetClassObject !!! %s not in shell32; ")
                      TEXT("corrupted registry?"), szClass);
        }
#endif
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cdburnfldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include "basefvcb.h"
#include "mergfldr.h"
#include "enumidlist.h"
#include "ids.h"
#include "cdburn.h"
#include "contextmenu.h"
#include "datautil.h"

STDAPI CCDBurnFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);

class CCDBurnFolder;
HRESULT CCDBurnFolder_CreateSFVCB(CCDBurnFolder* pcdsf, IShellFolderViewCB** ppsfvcb);

class CCDBurnFolder : public CMergedFolder
{
public:
    // IUnknown
    STDMETHOD (QueryInterface)(REFIID riid, void **ppv) { return CMergedFolder::QueryInterface(riid,ppv); }
    STDMETHOD_(ULONG, AddRef)() { return CMergedFolder::AddRef(); }
    STDMETHOD_(ULONG, Release)() { return CMergedFolder::Release(); }

    // IShellFolder
    STDMETHOD(CreateViewObject)(HWND hwndOwner, REFIID riid, void **ppvOut);

    // IItemNameLimits
    STDMETHOD(GetValidCharacters)(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars);
    STDMETHOD(GetMaxLength)(LPCWSTR pszName, int *piMaxNameLen);

protected:
    CCDBurnFolder(CMergedFolder *pmfParent) : CMergedFolder(pmfParent, CLSID_CDBurnFolder) {};
    friend HRESULT CCDBurnFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
    virtual HRESULT _CreateWithCLSID(CLSID clsid, CMergedFolder **ppmf);
    virtual BOOL _ShouldSuspend(REFGUID rguid);

private:
    HRESULT _CreateContextMenu(IContextMenu **ppcm);
};


STDAPI CCDBurnFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    // class factory enforces non-aggregation for us
    HRESULT hr = E_OUTOFMEMORY;
    CCDBurnFolder *p = new CCDBurnFolder(NULL);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }
    return hr;
}

HRESULT CCDBurnFolder::_CreateContextMenu(IContextMenu **ppcm)
{
    IShellExtInit *psei;
    HRESULT hr = CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellExtInit, &psei));
    if (SUCCEEDED(hr))
    {
        IDataObject *pdo;
        hr = SHGetUIObjectOf(_pidl, NULL, IID_PPV_ARG(IDataObject, &pdo));
        if (SUCCEEDED(hr))
        {
            hr = psei->Initialize(NULL, pdo, NULL);
            if (SUCCEEDED(hr))
            {
                hr = psei->QueryInterface(IID_PPV_ARG(IContextMenu, ppcm));
            }
            pdo->Release();
        }
        psei->Release();
    }
    return hr;
}

STDMETHODIMP CCDBurnFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;
    
    if (IsEqualIID(riid, IID_IShellView))
    {
        IShellFolderViewCB* psfvcb;
        hr = CCDBurnFolder_CreateSFVCB(this, &psfvcb);
        if (SUCCEEDED(hr))
        {
            SFV_CREATE csfv = {0};
            csfv.cbSize = sizeof(csfv);
            csfv.pshf = SAFECAST(this, IAugmentedShellFolder2*);
            csfv.psfvcb = psfvcb;

            hr = SHCreateShellFolderView(&csfv, (IShellView **)ppv);

            psfvcb->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        IContextMenu *pcmBase;
        hr = CMergedFolder::CreateViewObject(hwnd, IID_PPV_ARG(IContextMenu, &pcmBase));
        if (SUCCEEDED(hr))
        {
            IContextMenu *pcmCD;
            hr = _CreateContextMenu(&pcmCD);
            if (SUCCEEDED(hr))
            {
                IContextMenu* rgpcm[] = { pcmCD, pcmBase };
                hr = Create_ContextMenuOnContextMenuArray(rgpcm, ARRAYSIZE(rgpcm), riid, ppv);
                pcmCD->Release();
            }
            pcmBase->Release();
        }
    }
    else
    {
        hr = CMergedFolder::CreateViewObject(hwnd, riid, ppv);
    }

    return hr;
}


// IItemNameLimits

HRESULT CCDBurnFolder::GetValidCharacters(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars)
{
    *ppwszValidChars = NULL;
    return SHStrDup(INVALID_JOLIETNAME_CHARS, ppwszInvalidChars);
}

HRESULT CCDBurnFolder::GetMaxLength(LPCWSTR pszName, int *piMaxNameLen)
{
    *piMaxNameLen = 64;
    return S_OK;
}

HRESULT CCDBurnFolder::_CreateWithCLSID(CLSID clsid, CMergedFolder **ppmf)
{
    *ppmf = new CCDBurnFolder(this);
    return *ppmf ? S_OK : E_OUTOFMEMORY;
}

HRESULT _CDGetState(DWORD *pdwCaps, BOOL *pfUDF, BOOL *pfInStaging, BOOL *pfOnMedia)
{
    ICDBurnPriv *pcdbp;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_CDBurn, NULL, IID_PPV_ARG(ICDBurnPriv, &pcdbp));
    if (SUCCEEDED(hr))
    {
        hr = pcdbp->GetMediaCapabilities(pdwCaps, pfUDF);
        if (SUCCEEDED(hr))
        {
            hr = pcdbp->GetContentState(pfInStaging, pfOnMedia);
        }
        pcdbp->Release();
    }
    return hr;
}

BOOL CCDBurnFolder::_ShouldSuspend(REFGUID rguid)
{
    BOOL fShouldSuspend = FALSE;
    if (IsEqualGUID(rguid, CLSID_StagingFolder))
    {
        // this gets called a lot, short circuit the cocreate and go direct to the data.
        CDBurn_GetUDFState(&fShouldSuspend);
    }
    return fShouldSuspend;
}

class CCDBurnFolderViewCB : public CMergedFolderViewCB
{
public:
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return CMergedFolderViewCB::QueryInterface(riid,ppv); }
    STDMETHODIMP_(ULONG) AddRef(void) { return CMergedFolderViewCB::AddRef(); }
    STDMETHODIMP_(ULONG) Release(void) { return CMergedFolderViewCB::Release(); }

private:
    CCDBurnFolderViewCB(CCDBurnFolder* pcdsf);
    ~CCDBurnFolderViewCB();
    friend HRESULT CCDBurnFolder_CreateSFVCB(CCDBurnFolder* pcdsf, IShellFolderViewCB** ppsfvcb);

    CCDBurnFolder* _pcdsf;

    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
    HRESULT OnGetWorkingDir(DWORD pv, UINT cch, PWSTR pszDir);

public:
    // Web View Task implementations
    static HRESULT _CanBurn(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanClear(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanErase(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);

    static HRESULT _OnCDBurn(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnCDClearStaging(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnCDErase(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
};

CCDBurnFolderViewCB::CCDBurnFolderViewCB(CCDBurnFolder* pcdsf) : CMergedFolderViewCB((CMergedFolder*)pcdsf)
{
    _pcdsf = pcdsf;
    _pcdsf->AddRef();
}

CCDBurnFolderViewCB::~CCDBurnFolderViewCB()
{
    _pcdsf->Release();
}

HRESULT CCDBurnFolder_CreateSFVCB(CCDBurnFolder* pcdsf, IShellFolderViewCB** ppsfvcb)
{
    HRESULT hr;
    CCDBurnFolderViewCB* p = new CCDBurnFolderViewCB(pcdsf);
    if (p)
    {
        *ppsfvcb = SAFECAST(p, IShellFolderViewCB*);
        hr = S_OK;
    }
    else
    {
        *ppsfvcb = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CCDBurnFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);
    HANDLE_MSG(0, SFVM_GETWORKINGDIR, OnGetWorkingDir);

    default:
        return CMergedFolderViewCB::RealMessage(uMsg, wParam, lParam);
    }

    return S_OK;
}

HRESULT CCDBurnFolderViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL | SFVMWVL_FILES;
    return S_OK;
}

HRESULT CCDBurnFolderViewCB::_CanBurn(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;

    BOOL fUDF;
    if (SUCCEEDED(_CDGetState(NULL, &fUDF, NULL, NULL)))
    {
        // UDF is the only thing we check for now, we allow burn wizard to kick off without media or files
        if (!fUDF)
        {
            *puisState = UIS_ENABLED;
        }
    }
    return S_OK;
}

HRESULT CCDBurnFolderViewCB::_CanClear(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;

    BOOL fInStaging, fUDF;
    if (SUCCEEDED(_CDGetState(NULL, &fUDF, &fInStaging, NULL)))
    {
        if (fInStaging && !fUDF)
        {
            *puisState = UIS_ENABLED;
        }
    }
    return S_OK;
}

HRESULT CCDBurnFolderViewCB::_CanErase(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;

    DWORD dwCaps;
    BOOL fOnMedia, fUDF;
    if (SUCCEEDED(_CDGetState(&dwCaps, &fUDF, NULL, &fOnMedia)))
    {
        if ((dwCaps & HWDMC_CDREWRITABLE) && (fOnMedia || fUDF))
        {
            *puisState = UIS_ENABLED;
        }
    }
    return S_OK;
}

HRESULT _InvokeVerbOnCDBurn(HWND hwnd, LPCSTR pszVerb)
{
    IContextMenu *pcm;
    HRESULT hr = CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        hr = SHInvokeCommandOnContextMenu(hwnd, NULL, pcm, 0, pszVerb);
        pcm->Release();
    }
    return hr;
}

HRESULT CCDBurnFolderViewCB::_OnCDBurn(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CCDBurnFolderViewCB* pThis = (CCDBurnFolderViewCB*)(void*)pv;
    return _InvokeVerbOnCDBurn(pThis->_hwndMain, "burn");
}
HRESULT CCDBurnFolderViewCB::_OnCDClearStaging(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CCDBurnFolderViewCB* pThis = (CCDBurnFolderViewCB*)(void*)pv;
    return _InvokeVerbOnCDBurn(pThis->_hwndMain, "cleanup");
}
HRESULT CCDBurnFolderViewCB::_OnCDErase(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CCDBurnFolderViewCB* pThis = (CCDBurnFolderViewCB*)(void*)pv;
    return _InvokeVerbOnCDBurn(pThis->_hwndMain, "erase");
}

const WVTASKITEM c_CDBurnTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_CDBURN, IDS_HEADER_CDBURN_TT);
const WVTASKITEM c_CDBurnTaskList[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_BURNCD,        IDS_TASK_BURNCD_TT,        IDI_TASK_BURNCD,        CCDBurnFolderViewCB::_CanBurn,  CCDBurnFolderViewCB::_OnCDBurn),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_CLEARBURNAREA, IDS_TASK_CLEARBURNAREA_TT, IDI_TASK_CLEARBURNAREA, CCDBurnFolderViewCB::_CanClear, CCDBurnFolderViewCB::_OnCDClearStaging),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_ERASECDFILES,  IDS_TASK_ERASECDFILES_TT,  IDI_TASK_ERASECDFILES,  CCDBurnFolderViewCB::_CanErase, CCDBurnFolderViewCB::_OnCDErase),
};

HRESULT CCDBurnFolderViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    Create_IUIElement(&c_CDBurnTaskHeader, &(pData->pSpecialTaskHeader));
    return S_OK;
}

HRESULT CCDBurnFolderViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));
    pTasks->dwUpdateFlags = SFVMWVTSDF_CONTENTSCHANGE;
    Create_IEnumUICommand((IUnknown*)(void*)this, c_CDBurnTaskList, ARRAYSIZE(c_CDBurnTaskList), &pTasks->penumSpecialTasks);
    return S_OK;
}

HRESULT CCDBurnFolderViewCB::OnGetWorkingDir(DWORD pv, UINT cch, PWSTR pszDir)
{
    HRESULT hr = E_FAIL;
    DWORD dwNSId;
    GUID guid;
    IShellFolder *psf;
    BOOL fDone = FALSE;
    for (DWORD dwIndex = 0; 
         !fDone && SUCCEEDED(_pmf->EnumNameSpace(dwIndex, &dwNSId)) && SUCCEEDED(_pmf->QueryNameSpace(dwNSId, &guid, &psf));
         dwIndex++)
    {
        if (IsEqualGUID(guid, CLSID_CDBurn))
        {
            LPITEMIDLIST pidl;
            hr = SHGetIDListFromUnk(psf, &pidl);
            if (SUCCEEDED(hr))
            {
                WCHAR sz[MAX_PATH];
                hr = SHGetPathFromIDList(pidl, sz) ? S_OK : E_FAIL;
                if (SUCCEEDED(hr))
                {
                    lstrcpyn(pszDir, sz, cch);
                }
                ILFree(pidl);
            }
            fDone = TRUE;
        }                
        psf->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\colhndlr.cpp ===
#include "shellprv.h"

#include "intshcut.h"
#include "ids.h"
#include <ntquery.h>    // defines some values used for fmtid and pid
#include <sddl.h>       // For ConvertSidToStringSid()
#include "prop.h"       // SCID_ stuff
#include "netview.h"    // SHWNetGetConnection
#include "clsobj.h"

HRESULT ReadProperty(IPropertySetStorage *ppss, REFFMTID fmtid, PROPID pid, VARIANT *pVar)
{
    VariantInit(pVar);

    IPropertyStorage *pps;
    HRESULT hr = ppss->Open(fmtid, STGM_READ | STGM_SHARE_EXCLUSIVE, &pps);
    if (SUCCEEDED(hr))
    {
        PROPSPEC PropSpec;
        PROPVARIANT PropVar = {0};

        PropSpec.ulKind = PRSPEC_PROPID;
        PropSpec.propid = pid;

        hr = SHPropStgReadMultiple( pps, 0, 1, &PropSpec, &PropVar );
        if (SUCCEEDED(hr))
        {
            hr = PropVariantToVariant(&PropVar, pVar);
            PropVariantClear(&PropVar);
        }
        pps->Release();
    }
    return hr;
}

BOOL IsSlowProperty(IPropertySetStorage *ppss, REFFMTID fmtid, PROPID pid)
{
    IPropertyStorage *pps;
    BOOL bRet = FALSE;

    if (SUCCEEDED(ppss->Open(fmtid, STGM_READ | STGM_SHARE_EXCLUSIVE, &pps)))
    {
        IQueryPropertyFlags *pqsp;
        if (SUCCEEDED(pps->QueryInterface(IID_PPV_ARG(IQueryPropertyFlags, &pqsp))))
        {
            PROPSPEC PropSpec;
            PROPVARIANT PropVar = {0};

            PropSpec.ulKind = PRSPEC_PROPID;
            PropSpec.propid = pid;

            SHCOLSTATEF csFlags;
            if (SUCCEEDED(pqsp->GetFlags(&PropSpec, &csFlags)))
            {
                bRet = ((csFlags & SHCOLSTATE_SLOW) == SHCOLSTATE_SLOW);
            }

            // If the property isn't part of this property set, IsSlowProperty will return fairlure,
            // which we'll treat as a fast property.

            pqsp->Release();
        }

        pps->Release();
    }
    return bRet;  
}

class CBaseColumnProvider : public IPersist, public IColumnProvider
{
    // IUnknown methods
public:
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        static const QITAB qit[] = {
            QITABENT(CBaseColumnProvider, IColumnProvider),     // IID_IColumnProvider
            QITABENT(CBaseColumnProvider, IPersist),            // IID_IPersist
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    };
    
    STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&_cRef);
    };

    STDMETHODIMP_(ULONG) Release()
    {
        ASSERT( 0 != _cRef );
        ULONG cRef = InterlockedDecrement(&_cRef);
        if ( 0 == cRef )
        {
            delete this;
        }
        return cRef;
    };

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID) { *pClassID = *_pclsid; return S_OK; };

    // IColumnProvider
    STDMETHODIMP Initialize(LPCSHCOLUMNINIT psci)    { return S_OK ; }
    STDMETHODIMP GetColumnInfo(DWORD dwIndex, LPSHCOLUMNINFO psci);

    CBaseColumnProvider(const CLSID *pclsid, const COLUMN_INFO rgColMap[], int iCount, const LPCWSTR rgExts[]) : 
       _cRef(1), _pclsid(pclsid), _rgColumns(rgColMap), _iCount(iCount), _rgExts(rgExts)
    {
        DllAddRef();
    }

protected:
    virtual ~CBaseColumnProvider()
    {
        DllRelease();
    }

    BOOL _IsHandled(LPCWSTR pszExt);
    int _iCount;
    const COLUMN_INFO *_rgColumns;

private:
    long _cRef;
    const CLSID * _pclsid;
    const LPCWSTR *_rgExts;
};

// the index is an arbitrary zero based index used for enumeration

STDMETHODIMP CBaseColumnProvider::GetColumnInfo(DWORD dwIndex, SHCOLUMNINFO *psci)
{
    ZeroMemory(psci, sizeof(*psci));

    if (dwIndex < (UINT) _iCount)
    {
        psci->scid = *_rgColumns[dwIndex].pscid;
        psci->cChars = _rgColumns[dwIndex].cChars;
        psci->vt = _rgColumns[dwIndex].vt;
        psci->fmt = _rgColumns[dwIndex].fmt;
        psci->csFlags = _rgColumns[dwIndex].csFlags;

        TCHAR szTemp[MAX_COLUMN_NAME_LEN];
        LoadString(HINST_THISDLL, _rgColumns[dwIndex].idTitle, szTemp, ARRAYSIZE(szTemp));
        SHTCharToUnicode(szTemp, psci->wszTitle, ARRAYSIZE(psci->wszTitle));      

        return S_OK;
    }
    return S_FALSE;
}

// see if this file type is one we are interested in
BOOL CBaseColumnProvider::_IsHandled(LPCWSTR pszExt)
{
    if (_rgExts)
    {
        for (int i = 0; _rgExts[i]; i++)
        {
            if (0 == StrCmpIW(pszExt, _rgExts[i]))
                return TRUE;
        }
        return FALSE;
    }
    return TRUE;
}

// col handler that works over IPropertySetStorage handlers

const COLUMN_INFO c_rgDocObjColumns[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_Author,           20, IDS_EXCOL_AUTHOR),
    DEFINE_COL_STR_ENTRY(SCID_Title,            20, IDS_EXCOL_TITLE),
    DEFINE_COL_STR_DLG_ENTRY(SCID_Subject,      20, IDS_EXCOL_SUBJECT),
    DEFINE_COL_STR_DLG_ENTRY(SCID_Category,     20, IDS_EXCOL_CATEGORY),
    DEFINE_COL_INT_DLG_ENTRY(SCID_PageCount,    10, IDS_EXCOL_PAGECOUNT),
    DEFINE_COL_STR_ENTRY(SCID_Comment,          30, IDS_EXCOL_COMMENT),
    DEFINE_COL_STR_DLG_ENTRY(SCID_Copyright,    30, IDS_EXCOL_COPYRIGHT),
    DEFINE_COL_STR_ENTRY(SCID_MUSIC_Artist,     15, IDS_EXCOL_ARTIST),
    DEFINE_COL_STR_ENTRY(SCID_MUSIC_Album,      15, IDS_EXCOL_ALBUM),
    DEFINE_COL_STR_ENTRY(SCID_MUSIC_Year,       10, IDS_EXCOL_YEAR),
    DEFINE_COL_INT_ENTRY(SCID_MUSIC_Track,      5,  IDS_EXCOL_TRACK),
    DEFINE_COL_STR_ENTRY(SCID_MUSIC_Genre,      20, IDS_EXCOL_GENRE),
    DEFINE_COL_STR_ENTRY(SCID_AUDIO_Duration,   15, IDS_EXCOL_DURATION),
    DEFINE_COL_STR_ENTRY(SCID_AUDIO_Bitrate,    15, IDS_EXCOL_BITRATE),
    DEFINE_COL_STR_ENTRY(SCID_DRM_Protected,    10, IDS_EXCOL_PROTECTED),
    DEFINE_COL_STR_ENTRY(SCID_CameraModel,      20, IDS_EXCOL_CAMERAMODEL),
    DEFINE_COL_STR_ENTRY(SCID_WhenTaken,        20, IDS_EXCOL_WHENTAKEN),

    DEFINE_COL_STR_ENTRY(SCID_ImageDimensions,  20, IDS_EXCOL_DIMENSIONS),
    DEFINE_COL_INT_HIDDEN_ENTRY(SCID_ImageCX),
    DEFINE_COL_INT_HIDDEN_ENTRY(SCID_ImageCY),

    DEFINE_COL_DATE_HIDDEN_ENTRY(SCID_DocCreated),
};

class CPropStgColumns : public CBaseColumnProvider
{
    STDMETHODIMP GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData);

private:
    // help on initializing base classes: mk:@ivt:vclang/FB/DD/S44B5E.HTM
    CPropStgColumns() : 
       CBaseColumnProvider(&CLSID_DocFileColumnProvider, c_rgDocObjColumns, ARRAYSIZE(c_rgDocObjColumns), NULL)
    {
        ASSERT(_wszLastFile[0] == 0);
        ASSERT(_bSlowPropertiesCached == FALSE);
    };
    
    ~CPropStgColumns()
    {
        _FreeCache();
    }
    
    // for the cache
    VARIANT _rgvCache[ARRAYSIZE(c_rgDocObjColumns)]; // zero'ing allocator will fill with VT_EMPTY
    BOOL _rgbSlow[ARRAYSIZE(c_rgDocObjColumns)]; // Store if each property is "slow".
    WCHAR _wszLastFile[MAX_PATH];
    HRESULT _hrCache;
    BOOL _bSlowPropertiesCached;

#ifdef DEBUG
    int deb_dwTotal, deb_dwMiss;
#endif
    
    void _FreeCache();

    friend HRESULT CDocFileColumns_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
};

void CPropStgColumns::_FreeCache()
{
    for (int i = 0; i < ARRAYSIZE(_rgvCache); i++)
        VariantClear(&_rgvCache[i]);

    _hrCache = S_OK;
}

STDMETHODIMP CPropStgColumns::GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData)
{
    HRESULT hr;

    // VariantCopy requires input to be initialized, and we handle failure case
    VariantInit(pvarData);

    // is this even a property we support?
    for (int iProp = 0; iProp < _iCount; iProp++)
    {
        if (IsEqualSCID(*_rgColumns[iProp].pscid, *pscid))
        {
            goto found;
        }
    }

    // Unknown property
    return S_FALSE;

found:

#ifdef DEBUG
    deb_dwTotal++;
#endif

    // Three cases here:
    // 1) We need to update the cache. Fetch the properties again (and only get fast props if we asked for a fast prop)
    // 2) We've only cached fast properties so far, and we asked for a slow property, so now we need to get slow props.
    // 3) The property we want is cached.

    if ((pscd->dwFlags & SHCDF_UPDATEITEM) || (StrCmpW(_wszLastFile, pscd->wszFile) != 0))
    {
        // 1) Cache is no good - item has been updated, or this is a different file.

        // SHCDF_UPDATEITEM flag is a hint
        // that the file for which we are getting data has changed since the last call.  This flag
        // is only passed once per filename, not once per column per filename so update the entire
        // cache if this flag is set.

        // sanity check our caching.  If the shell thread pool is > 1, we will thrash like mad, and should change this
#ifdef DEBUG
        deb_dwMiss++;
        if ((deb_dwTotal > 3) && (deb_dwTotal / deb_dwMiss <= 3))
            TraceMsg(TF_DEFVIEW, "Column data caching is ineffective (%d misses for %d access)", deb_dwMiss, deb_dwTotal);
#endif
        _FreeCache();

        hr = StringCchCopy(_wszLastFile, ARRAYSIZE(_wszLastFile), pscd->wszFile);
        if (SUCCEEDED(hr))
        {
            IPropertySetStorage *ppss;
            hr = SHFileSysBindToStorage(pscd->wszFile, pscd->dwFileAttributes, STGM_READ | STGM_SHARE_DENY_WRITE, 0, 
                                        IID_PPV_ARG(IPropertySetStorage, &ppss));

            _hrCache = hr;

            if (SUCCEEDED(hr))
            {
                // Did we ask for a slow property?
                BOOL bSlowProperty = IsSlowProperty(ppss, _rgColumns[iProp].pscid->fmtid, _rgColumns[iProp].pscid->pid);

                hr = E_INVALIDARG; // normally overwritten by hrT below
                for (int i = 0; i < _iCount; i++)
                {
                    // For every property, take note if it is "slow"
                    _rgbSlow[i] = IsSlowProperty(ppss, _rgColumns[i].pscid->fmtid, _rgColumns[i].pscid->pid);

                    // Only retrieve a value right now if we asked for a slow property, or this is not a slow property.
                    if (bSlowProperty || (!_rgbSlow[i]))
                    {
                        // it would be slightly more efficient, but more code, to set up the propid array to call ReadMultiple
                        HRESULT hrT = ReadProperty(ppss, _rgColumns[i].pscid->fmtid, _rgColumns[i].pscid->pid, &_rgvCache[i]);
                        if (i == iProp)
                        {
                            hr = (SUCCEEDED(hrT) ? VariantCopy(pvarData, &_rgvCache[i]) : hrT);
                        }
                    }
                }

                ppss->Release();
                _bSlowPropertiesCached = bSlowProperty;
            }
        }
    }
    else if (_rgbSlow[iProp] && !_bSlowPropertiesCached)
    {
        // 2) We asked for a slow property, but slow properties haven't been cached yet.

        // Bind to the storage a second time.  This is a perf hit, but should be
        // minor compared to getting slow properties.
        IPropertySetStorage *ppss;
        hr = SHFileSysBindToStorage(pscd->wszFile, pscd->dwFileAttributes, STGM_READ | STGM_SHARE_DENY_WRITE, 0, 
                                    IID_PPV_ARG(IPropertySetStorage, &ppss));

        _hrCache = hr;

        if (SUCCEEDED(hr))
        {
            hr = E_INVALIDARG; // normally overwritten by hrT below
            for (int i = 0; i < _iCount; i++)
            {
                if (_rgbSlow[i]) // If it's slow, get it.
                {
                    ASSERT(_rgvCache[i].vt == VT_EMPTY); // Because we haven't retrieved it yet.

                    HRESULT hrT = ReadProperty(ppss, _rgColumns[i].pscid->fmtid, _rgColumns[i].pscid->pid, &_rgvCache[i]);
                    if (i == iProp)
                    {
                        hr = (SUCCEEDED(hrT) ? VariantCopy(pvarData, &_rgvCache[i]) : hrT);
                    }
                }
            }
            ppss->Release();

            _bSlowPropertiesCached = TRUE;
        }

    }
    else 
    {
        // 3) It's not a slow property, or slow properties are already cached.
        ASSERT(!_rgbSlow[iProp] || _bSlowPropertiesCached);

        hr = S_FALSE;       // assume we don't have it

        if (SUCCEEDED(_hrCache))
        {
            if (_rgvCache[iProp].vt != VT_EMPTY)
            {
                hr = VariantCopy(pvarData, &_rgvCache[iProp]);
            }
        }
    }

    return hr;
}


STDAPI CDocFileColumns_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    CPropStgColumns *pdocp = new CPropStgColumns;
    if (pdocp)
    {
        hr = pdocp->QueryInterface(riid, ppv);
        pdocp->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// Shortcut handler

// W because pidl is always converted to widechar filename
const LPCWSTR c_szURLExtensions[] = {
    L".URL", 
    L".LNK", 
    NULL
};

const COLUMN_INFO c_rgURLColumns[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_Author,           20, IDS_EXCOL_AUTHOR),
    DEFINE_COL_STR_ENTRY(SCID_Title,            20, IDS_EXCOL_TITLE),
    DEFINE_COL_STR_ENTRY(SCID_Comment,          30, IDS_EXCOL_COMMENT),
};

class CLinkColumnProvider : public CBaseColumnProvider
{
    STDMETHODIMP GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData);

private:
    // help on initializing base classes: mk:@ivt:vclang/FB/DD/S44B5E.HTM
    CLinkColumnProvider() : CBaseColumnProvider(&CLSID_LinkColumnProvider, c_rgURLColumns, ARRAYSIZE(c_rgURLColumns), c_szURLExtensions)
    {};

    // friends
    friend HRESULT CLinkColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
};

const struct 
{
    DWORD dwSummaryPid;
    DWORD dwURLPid;
} c_URLMap[] =  {
    { PIDSI_AUTHOR,   PID_INTSITE_AUTHOR },
    { PIDSI_TITLE,    PID_INTSITE_TITLE },
    { PIDSI_COMMENTS, PID_INTSITE_COMMENT },
};

DWORD _MapSummaryToSitePID(DWORD pid)
{
    for (int i = 0; i < ARRAYSIZE(c_URLMap); i++)
    {
        if (c_URLMap[i].dwSummaryPid == pid)
            return c_URLMap[i].dwURLPid;
    }
    return -1;
}

STDMETHODIMP CLinkColumnProvider::GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData)
{
    HRESULT hr;
    const CLSID *pclsidLink = &CLSID_ShellLink;

    // Some of the code-paths below assume pvarData is initialized
    VariantInit(pvarData);

    // should we match against a list of known extensions, or always try to open?

    if (FILE_ATTRIBUTE_DIRECTORY & pscd->dwFileAttributes)
    {
        if (PathIsShortcut(pscd->wszFile, pscd->dwFileAttributes))
        {
            pclsidLink = &CLSID_FolderShortcut;     // we are dealing with a folder shortcut now
        }
        else
        {
            return S_FALSE;
        }
    }
    else
    {
        if (!_IsHandled(pscd->pwszExt))
        {
            return S_FALSE;
        }
    }

    if (StrCmpIW(pscd->pwszExt, L".URL") == 0)
    {
        //
        // its a .URL so lets handle it by creating the Internet Shortcut object, loading
        // the file and then reading the properties from it.
        //
        IPropertySetStorage *ppss;
        hr = LoadFromFile(CLSID_InternetShortcut, pscd->wszFile, IID_PPV_ARG(IPropertySetStorage, &ppss));
        if (SUCCEEDED(hr))
        {
            UINT pid;
            GUID fmtid;

            if (IsEqualGUID(pscid->fmtid, FMTID_SummaryInformation))
            {
                fmtid = FMTID_InternetSite;
                pid = _MapSummaryToSitePID(pscid->pid);
            }
            else
            {
                fmtid = pscid->fmtid;
                pid = pscid->pid;
            }

            hr = ReadProperty(ppss, fmtid, pid, pvarData);
            ppss->Release();
        }
    }
    else
    {
        //
        // open the .LNK file, load it and then read the description for it.  we then
        // return this a the comment for this object.
        //

        if (IsEqualSCID(*pscid, SCID_Comment))
        {
            IShellLink *psl;
            hr = LoadFromFile(*pclsidLink, pscd->wszFile, IID_PPV_ARG(IShellLink, &psl));
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[MAX_PATH];

                hr = psl->GetDescription(szBuffer, ARRAYSIZE(szBuffer));            
                if (SUCCEEDED(hr) && szBuffer[0])
                {
                    hr = InitVariantFromStr(pvarData, szBuffer);
                }
                else
                {
                    IQueryInfo *pqi;
                    if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IQueryInfo, &pqi))))
                    {
                        WCHAR *pwszTip;

                        if (SUCCEEDED(pqi->GetInfoTip(0, &pwszTip)) && pwszTip)
                        {
                            hr = InitVariantFromStr(pvarData, pwszTip);
                            SHFree(pwszTip);
                        }
                        pqi->Release();
                    }
                }

                psl->Release();
            }
        }
        else
            hr = S_FALSE;
    }

    return hr;
}

STDAPI CLinkColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    CLinkColumnProvider *pdocp = new CLinkColumnProvider;
    if (pdocp)
    {
        hr = pdocp->QueryInterface(riid, ppv);
        pdocp->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

const COLUMN_INFO c_rgFileSysColumns[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_OWNER,            20, IDS_EXCOL_OWNER),
};

class COwnerColumnProvider : public CBaseColumnProvider
{
    STDMETHODIMP GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData);

private:
    COwnerColumnProvider() : CBaseColumnProvider(&CLSID_FileSysColumnProvider, c_rgFileSysColumns, ARRAYSIZE(c_rgFileSysColumns), NULL)
    {
        ASSERT(_wszLastFile[0] == 0);
        ASSERT(_psid==NULL && _pwszName==NULL && _psd==NULL);
        LoadString(HINST_THISDLL, IDS_BUILTIN_DOMAIN, _szBuiltin, ARRAYSIZE(_szBuiltin));
    };

    ~COwnerColumnProvider() { _CacheSidName(NULL, NULL, NULL); }

    WCHAR _wszLastFile[MAX_PATH];

    //  Since we typically get pinged for files all in the same folder,
    //  cache the "folder to server" mapping to avoid calling
    //  WNetGetConnection five million times.
    //
    //  Since files in the same directory tend to have the same owner,
    //  we cache the SID/Name mapping.
    //
    //  Column providers do not have to support multithreaded clients,
    //  so we won't take any critical sections.
    //

    HRESULT _LookupOwnerName(LPCTSTR pszFile, VARIANT *pvar);
    void _CacheSidName(PSECURITY_DESCRIPTOR psd, void *psid, LPCWSTR pwszName);

    void                *_psid;
    LPWSTR               _pwszName;
    PSECURITY_DESCRIPTOR _psd;          // _psid points into here

    int                  _iCachedDrive; // What drive letter is cached in _pszServer?
    LPTSTR               _pszServer;    // What server to use (NULL = local machine)
    TCHAR                _szBuiltin[MAX_COMPUTERNAME_LENGTH + 1];

    friend HRESULT CFileSysColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
};

//
//  _CacheSidName takes ownership of the psd.  (psid points into the psd)
//
void COwnerColumnProvider::_CacheSidName(PSECURITY_DESCRIPTOR psd, void *psid, LPCWSTR pwszName)
{
    LocalFree(_psd);
    _psd = psd;
    _psid = psid;

    Str_SetPtrW(&_pwszName, pwszName);
}

//
//  Given a string of the form \\server\share\blah\blah, stomps the
//  inner backslash (if necessary) and returns a pointer to "server".
//
STDAPI_(LPTSTR) PathExtractServer(LPTSTR pszUNC)
{
    if (PathIsUNC(pszUNC))
    {
        pszUNC += 2;            // Skip over the two leading backslashes
        LPTSTR pszEnd = StrChr(pszUNC, TEXT('\\'));
        if (pszEnd) 
            *pszEnd = TEXT('\0'); // nuke the backslash
    }
    else
    {
        pszUNC = NULL;
    }
    return pszUNC;
}

HRESULT COwnerColumnProvider::_LookupOwnerName(LPCTSTR pszFile, VARIANT *pvar)
{
    pvar->vt = VT_BSTR;
    pvar->bstrVal = NULL;

    PSECURITY_DESCRIPTOR psd;
    void *psid;

    DWORD err = GetNamedSecurityInfo(const_cast<LPTSTR>(pszFile),
                               SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION,
                               &psid, NULL, NULL, NULL, &psd);
    if (err == ERROR_SUCCESS)
    {
        if (_psid && EqualSid(psid, _psid) && _pwszName)
        {
            pvar->bstrVal = SysAllocString(_pwszName);
            LocalFree(psd);
            err = ERROR_SUCCESS;
        }
        else
        {
            LPTSTR pszServer;
            TCHAR szServer[MAX_PATH];

            //
            //  Now go figure out which server to resolve the SID against.
            //
            if (PathIsUNC(pszFile))
            {
                //   don't care if it is truncated or not.
                StringCchCopy(szServer, ARRAYSIZE(szServer), pszFile);
                pszServer = PathExtractServer(szServer);
            }
            else if (pszFile[0] == _iCachedDrive)
            {
                // Local drive letter already in cache -- use it
                pszServer = _pszServer;
            }
            else
            {
                // Local drive not cached -- cache it
                _iCachedDrive = pszFile[0];
                DWORD cch = ARRAYSIZE(szServer);
                if (SHWNetGetConnection(pszFile, szServer, &cch) == NO_ERROR)
                    pszServer = PathExtractServer(szServer);
                else
                    pszServer = NULL;
                Str_SetPtr(&_pszServer, pszServer);
            }

            TCHAR szName[MAX_PATH];
            DWORD cchName = ARRAYSIZE(szName);
            TCHAR szDomain[MAX_COMPUTERNAME_LENGTH + 1];
            DWORD cchDomain = ARRAYSIZE(szDomain);
            SID_NAME_USE snu;
            LPTSTR pszName;
            BOOL fFreeName = FALSE; // Do we need to LocalFree(pszName)?

            if (LookupAccountSid(pszServer, psid, szName, &cchName,
                                 szDomain, &cchDomain, &snu))
            {
                //
                //  If the domain is the bogus "BUILTIN" or we don't have a domain
                //  at all, then just use the name.  Otherwise, use domain\userid.
                //
                if (!szDomain[0] || StrCmpC(szDomain, _szBuiltin) == 0)
                {
                    pszName = szName;
                }
                else
                {
                    // Borrow szServer as a scratch buffer
                    StringCchPrintf(szServer, ARRAYSIZE(szServer), TEXT("%s\\%s"), szDomain, szName);
                    pszName = szServer;
                }
                err = ERROR_SUCCESS;
            }
            else
            {
                err = GetLastError();

                // Couldn't map the SID to a name.  Use the horrid raw version
                // if available.
                if (ConvertSidToStringSid(psid, &pszName))
                {
                    fFreeName = TRUE;
                    err = ERROR_SUCCESS;
                }
                else
                    pszName = NULL;
            }

            // Even on error, cache the result so we don't keep trying over and over
            // on the same SID.

            _CacheSidName(psd, psid, pszName);
            pvar->bstrVal = SysAllocString(pszName);

            if (fFreeName)
                LocalFree(pszName);
        }
    }

    if (err == ERROR_SUCCESS && pvar->bstrVal == NULL)
        err = ERROR_OUTOFMEMORY;

    return HRESULT_FROM_WIN32(err);
}

STDMETHODIMP COwnerColumnProvider::GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData)
{
    HRESULT hr = S_FALSE;   // return S_FALSE on failure
    VariantInit(pvarData);

    if (IsEqualSCID(SCID_OWNER, *pscid))
    {
        hr = _LookupOwnerName(pscd->wszFile, pvarData);
    }

    return hr;
}

STDAPI CFileSysColumnProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    COwnerColumnProvider *pfcp = new COwnerColumnProvider;
    if (pfcp)
    {
        hr = pfcp->QueryInterface(riid, ppv);
        pfcp->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//  FMTID_ExeDllInformation,
//// {0CEF7D53-FA64-11d1-A203-0000F81FEDEE}
#define PSFMTID_VERSION { 0xcef7d53, 0xfa64, 0x11d1, 0xa2, 0x3, 0x0, 0x0, 0xf8, 0x1f, 0xed, 0xee }

#define PIDVSI_FileDescription   0x003
#define PIDVSI_FileVersion       0x004
#define PIDVSI_InternalName      0x005
#define PIDVSI_OriginalFileName  0x006
#define PIDVSI_ProductName       0x007
#define PIDVSI_ProductVersion    0x008

//  Win32 PE (exe, dll) Version Information column identifier defs...
DEFINE_SCID(SCID_FileDescription,   PSFMTID_VERSION, PIDVSI_FileDescription);
DEFINE_SCID(SCID_FileVersion,       PSFMTID_VERSION, PIDVSI_FileVersion);
DEFINE_SCID(SCID_InternalName,      PSFMTID_VERSION, PIDVSI_InternalName);
DEFINE_SCID(SCID_OriginalFileName,  PSFMTID_VERSION, PIDVSI_OriginalFileName);
DEFINE_SCID(SCID_ProductName,       PSFMTID_VERSION, PIDVSI_ProductName);
DEFINE_SCID(SCID_ProductVersion,    PSFMTID_VERSION, PIDVSI_ProductVersion);

const COLUMN_INFO c_rgExeDllColumns[] =
{
    DEFINE_COL_STR_ENTRY(SCID_CompanyName,        30, IDS_VN_COMPANYNAME),
    DEFINE_COL_STR_ENTRY(SCID_FileDescription,    30, IDS_VN_FILEDESCRIPTION),
    DEFINE_COL_STR_ENTRY(SCID_FileVersion,        20, IDS_VN_FILEVERSION),
    DEFINE_COL_STR_MENU_ENTRY(SCID_ProductName,   30, IDS_VN_PRODUCTNAME),
    DEFINE_COL_STR_MENU_ENTRY(SCID_ProductVersion,20, IDS_VN_PRODUCTVERSION),
};


class CVersionColProvider : public CBaseColumnProvider
{
    STDMETHODIMP GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData);

private:
    CVersionColProvider() : 
       CBaseColumnProvider(&CLSID_VersionColProvider, c_rgExeDllColumns, ARRAYSIZE(c_rgExeDllColumns), NULL)
    {
        _pvAllTheInfo = NULL;
        _szFileCache[0] = 0;
    };

    virtual ~CVersionColProvider() 
    {
        _ClearCache();
    }

    FARPROC _GetVerProc(LPCSTR pszName);
    HRESULT _CacheFileVerInfo(LPCWSTR pszFile);
    void _ClearCache();

    WCHAR _szFileCache[MAX_PATH];
    void  *_pvAllTheInfo;
    HRESULT _hrCache;

    friend HRESULT CVerColProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
};

void CVersionColProvider::_ClearCache()
{
    if (_pvAllTheInfo)
    {
        delete [] _pvAllTheInfo;
        _pvAllTheInfo = NULL;
    }
    _szFileCache[0] = 0;
}

HRESULT CVersionColProvider::_CacheFileVerInfo(LPCWSTR pszFile)
{
    if (StrCmpW(_szFileCache, pszFile))
    {
        HRESULT hr;
        _ClearCache();

        DWORD dwVestigial;
        DWORD versionISize = GetFileVersionInfoSizeW((LPWSTR)pszFile, &dwVestigial); // cast for bad API design
        if (versionISize)
        {
            _pvAllTheInfo = new BYTE[versionISize];
            if (_pvAllTheInfo)
            {
                // read the data
                if (GetFileVersionInfoW((LPWSTR)pszFile, dwVestigial, versionISize, _pvAllTheInfo))
                {
                    hr = S_OK;
                }
                else
                {
                    _ClearCache();
                    hr = E_FAIL;
                }
            }
            else
                hr = E_OUTOFMEMORY; // error, out of memory.
        }
        else
            hr = S_FALSE;

        //  don't care if it is truncated - will only cause a slight perf problem
        //  on network shares.
        StringCchCopy(_szFileCache, ARRAYSIZE(_szFileCache), pszFile);
        _hrCache = hr;
    }
    return _hrCache;
}

STDMETHODIMP CVersionColProvider::GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData)
{
    VariantInit(pvarData);

    if (pscd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        return S_FALSE;

    HRESULT hr = _CacheFileVerInfo(pscd->wszFile);
    if (hr != S_OK)
        return hr;

    TCHAR szString[128], *pszVersionInfo = NULL; //A pointer to the specific version info I am looking for
    LPCTSTR pszVersionField = NULL;

    switch (pscid->pid)
    {
    case PIDVSI_FileVersion:
        {
            VS_FIXEDFILEINFO *pffi;
            UINT uInfoSize;
            if (VerQueryValue(_pvAllTheInfo, TEXT("\\"), (void **)&pffi, &uInfoSize))
            {
                StringCchPrintf(szString, ARRAYSIZE(szString), TEXT("%d.%d.%d.%d"), 
                    HIWORD(pffi->dwFileVersionMS),
                    LOWORD(pffi->dwFileVersionMS),
                    HIWORD(pffi->dwFileVersionLS),
                    LOWORD(pffi->dwFileVersionLS));

                pszVersionInfo = szString;
            }
            else
                pszVersionField = TEXT("FileVersion");      
        }
        break;

    case PIDDSI_COMPANY:            pszVersionField = TEXT("CompanyName");      break;
    case PIDVSI_FileDescription:    pszVersionField = TEXT("FileDescription");  break;
    case PIDVSI_InternalName:       pszVersionField = TEXT("InternalName");     break;
    case PIDVSI_OriginalFileName:   pszVersionField = TEXT("OriginalFileName"); break;
    case PIDVSI_ProductName:        pszVersionField = TEXT("ProductName");      break;
    case PIDVSI_ProductVersion:     pszVersionField = TEXT("ProductVersion");   break;
    default: 
        return E_FAIL;
    }
    //look for the intended language in the examined object.

    if (pszVersionInfo == NULL)
    {
        struct _VERXLATE
        {
            WORD wLanguage;
            WORD wCodePage;
        } *pxlate;                     /* ptr to translations data */

        //this is a fallthrough set of if statements.
        //on a failure, it just tries the next one, until it runs out of tries.
        UINT uInfoSize;
        if (VerQueryValue(_pvAllTheInfo, TEXT("\\VarFileInfo\\Translation"), (void **)&pxlate, &uInfoSize))
        {
            TCHAR szVersionKey[60];   //a string to hold all the format string for VerQueryValue
            StringCchPrintf(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\%04X%04X\\%s"),
                                                pxlate[0].wLanguage, pxlate[0].wCodePage, pszVersionField);
            if (!VerQueryValue(_pvAllTheInfo, szVersionKey, (void **) &pszVersionInfo, &uInfoSize))
            {
                StringCchPrintf(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\040904B0\\%s"), pszVersionField);
                if (!VerQueryValue(_pvAllTheInfo, szVersionKey, (void **) &pszVersionInfo, &uInfoSize))
                {
                    StringCchPrintf(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\040904E4\\%s"), pszVersionField);
                    if (!VerQueryValue(_pvAllTheInfo, szVersionKey, (void **) &pszVersionInfo, &uInfoSize))
                    {
                        StringCchPrintf(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\04090000\\%s"), pszVersionField);
                        if (!VerQueryValue(_pvAllTheInfo, szVersionKey, (void **) &pszVersionInfo, &uInfoSize))
                        {
                            pszVersionInfo = NULL;
                        }
                    }
                }
            }
        }
    }
    
    if (pszVersionInfo)
    {
        PathRemoveBlanks(pszVersionInfo);
        hr = InitVariantFromStr(pvarData, pszVersionInfo);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDAPI CVerColProvider_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    CVersionColProvider *pvcp = new CVersionColProvider;
    if (pvcp)
    {
        hr = pvcp->QueryInterface(riid, ppv);
        pvcp->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\confirmationui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File: ConfirmationUI.h
//
//  Contents: Confirmation UI for storage based copy engine
//
//  History:  20-Mar-2000 ToddB
//
//--------------------------------------------------------------------------

#pragma once

// these heights are in Dialog Uints, they get converted to pixels before use
#define CX_DIALOG_PADDING       6
#define CY_DIALOG_PADDING       6
#define CY_STATIC_TEXT_HEIGHT   10

// This is the max string length of the attribute fields for an item
#define CCH_DESC_LENGTH     MAX_PATH


class CTransferConfirmation :
    public ITransferConfirmation,
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTransferConfirmation, &CLSID_TransferConfirmationUI>
{
public:
    typedef struct tagITEMINFO
    {
        LPWSTR pwszIntro;           // resource ID of the intro string, or 0 if there is none
        LPWSTR pwszDisplayName;     // The display name of the item
        LPWSTR pwszAttribs;         // The attributes for this item.  Can be a variable number of lines in length
        HBITMAP hBitmap;
        HICON hIcon;
    } ITEMINFO, * LPITEMINFO;

    BEGIN_COM_MAP(CTransferConfirmation)
        COM_INTERFACE_ENTRY(ITransferConfirmation)
    END_COM_MAP()

    // IStorageProcessor
    STDMETHOD(Confirm)(CONFIRMOP * pcop, LPCONFIRMATIONRESPONSE pcr, BOOL * pbAll);

protected:
    CTransferConfirmation();
    ~CTransferConfirmation();

    static INT_PTR CALLBACK s_ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwndDlg, WPARAM wParam, LPARAM lParam);
    BOOL OnCommand(HWND hwndDlg, int wID, HWND hwndCtl);

    HRESULT _Init();
    HRESULT _ClearSettings();
    HRESULT _GetDialogSettings();
    HRESULT _FreeDialogSettings();
    HRESULT _AddItem(IShellItem *psi, int idIntro=0);
    BOOL _CalculateMetrics(HWND hwndDlg);
    DWORD _DisplayItem(int iItem, HWND hwndDlg, int x, int y);
    int _WindowWidthFromString(HWND hwnd, LPTSTR psz);
    int _WindowHeightFromString(HWND hwnd, int cx, LPTSTR psz);
    BOOL _IsCopyOperation(STGOP stgop);

    // Input information
    CONFIRMOP m_cop;
    IPropertyUI * m_pPropUI;

    // Output results
    CONFIRMATIONRESPONSE m_crResult;
    BOOL m_fApplyToAll;

    // Stuff to control the display of the dialog
    int     m_cxControlPadding;
    int     m_cyControlPadding;
    int     m_cyText;               // the height of a static text control (10 dialog units converted into pixels)
    RECT    m_rcDlg;                // we remember the size of the dialog's client area since we use this a lot
    HFONT   m_hfont;                // the font used by the dialog, used to calculate sizes

    TCHAR * m_pszTitle;
    HICON m_hIcon;
    TCHAR * m_pszDescription;

    int m_idDialog;

    ITEMINFO m_rgItemInfo[2];
    int m_cItems;

    BOOL m_fSingle;
    BOOL m_fShowARPLink;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\confirmationui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File: ConfirmationUI.cpp
//
//  Contents: Confirmation UI for storage based copy engine
//
//  History:  20-Mar-2000 ToddB
//
//--------------------------------------------------------------------------

#include "shellprv.h"
#pragma  hdrstop

#include "ConfirmationUI.h"
#include "resource.h"
#include "ntquery.h"
#include "ids.h"

#include <initguid.h>

#define TF_DLGDISPLAY   0x00010000  // messages related to display of the confirmation dialog
#define TF_DLGSTORAGE   0x00020000  // messages related to using the legacy IStorage to get dialog info
#define TF_DLGISF       0x00040000  // messages related to using IShellFolder to get dialog info

#define RECT_WIDTH(rc)  ((rc).right - (rc).left)
#define RECT_HEIGHT(rc) ((rc).bottom - (rc).top)

GUID guidStorage = PSGUID_STORAGE;


// prototype some functions that are local to this file:
void ShiftDialogItem(HWND hDlg, int id, int cx, int cy);
BOOL CALLBACK ShiftLeftProc(HWND hwnd, LPARAM lParam);


STDAPI CTransferConfirmation_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    if (!ppv)
        return E_POINTER;

    CComObject<CTransferConfirmation> *pObj = NULL;
    // created with ref count of 0
    if (SUCCEEDED(CComObject<CTransferConfirmation>::CreateInstance(&pObj)))
    {
        // QueryInterface ups the refcount to 1
        if (SUCCEEDED(pObj->QueryInterface(riid, ppv)))
        {
            return S_OK;
        }

        // failed to get the right interface, delete the object.
        delete pObj;
    }

    *ppv = NULL;
    return E_FAIL;
}

CTransferConfirmation::CTransferConfirmation() :
    m_fSingle(TRUE)
{
    ASSERT(NULL == m_pszDescription);
    ASSERT(NULL == m_pszTitle);
    ASSERT(NULL == m_hIcon);
    ASSERT(NULL == m_pPropUI);
    ASSERT(NULL == m_cItems);
}

CTransferConfirmation::~CTransferConfirmation()
{
    if (m_pPropUI)
        m_pPropUI->Release();
}

BOOL CTransferConfirmation::_IsCopyOperation(STGOP stgop)
{
    return (stgop == STGOP_COPY) || (stgop == STGOP_COPY_PREFERHARDLINK);
}

// TODO: Get better icons for "Nuke File" and "Nuke Folder" from design.
// TODO: Get better icons for "Move File" and "Move Folder" from design.
// TODO: Get better icons for "Secondary Attribute loss" from design (stream loss, encrypt loss, ACL loss, etc)
HRESULT CTransferConfirmation::_GetDialogSettings()
{
    _FreeDialogSettings();

    ASSERT(NULL == m_pszDescription);
    ASSERT(NULL == m_pszTitle);
    ASSERT(NULL == m_hIcon);
    ASSERT(NULL == m_cItems);

    m_fSingle = (m_cop.cRemaining<=1);
    // Set the default values of m_crResult so that if the dialog is killed or
    // some error occurs we give a valid default response.
    m_crResult = CONFRES_CANCEL;
    
    if (m_cop.pcc)
    {
        // we already have the strings to use

        switch (m_cop.pcc->dwButtons)
        {
        case CCB_YES_SKIP_CANCEL:
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            break;

        case CCB_RENAME_SKIP_CANCEL:
            m_idDialog = IDD_CONFIRM_RENAMESKIPCANCEL;
            break;

        case CCB_YES_SKIP_RENAME_CANCEL:
            m_idDialog = IDD_CONFIRM_YESSKIPRENAMECANCEL;
            break;

        case CCB_RETRY_SKIP_CANCEL:
            m_idDialog = IDD_CONFIRM_RETRYSKIPCANCEL;
            break;
            
        case CCB_OK:
            m_idDialog = IDD_CONFIRM_OK;
            break;
            
        default:
            return E_INVALIDARG; // REVIEW: should we define more specific error codes like STG_E_INVALIDBUTTONOPTIONS?
        }

        if (m_cop.pcc->dwFlags & CCF_SHOW_SOURCE_INFO)
        {
            _AddItem(m_cop.psiItem);
        }
        
        if (m_cop.pcc->dwFlags & CCF_SHOW_DESTINATION_INFO)
        {
            _AddItem(m_cop.psiDest);
        }
    }
    else
    {
        TCHAR szBuf[2048];    
        int idTitle = 0;
        int idIcon = 0;
        int idDescription = 0;

        ////////////////////////////////////////////////////////////////////////////////
        // These are "confirmations", i.e. conditions the user can choose to ignore.
        // You can typically answer "Yes", "Skip", or "Cancel"
        ////////////////////////////////////////////////////////////////////////////////
    
        if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_DELETE_FILE;
            idDescription = IDS_DELETE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_DELETE;
            idIcon = IDI_DELETE_FOLDER;
            idDescription = IDS_DELETE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_READONLY_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_DELETE_FILE;
            idDescription = IDS_DELETE_READONLY_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_READONLY_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_DELETE;
            idIcon = IDI_DELETE_FOLDER;
            idDescription = IDS_DELETE_READONLY_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_SYSTEM_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_DELETE_FILE;
            idDescription = IDS_DELETE_SYSTEM_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_SYSTEM_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_DELETE;
            idIcon = IDI_DELETE_FOLDER;
            idDescription = IDS_DELETE_SYSTEM_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_TOOLARGE_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_NUKE_FILE;
            idDescription = IDS_DELETE_TOOBIG_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_TOOLARGE_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_DELETE;
            idIcon = IDI_NUKE_FOLDER;
            idDescription = IDS_DELETE_TOOBIG_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_WONT_RECYCLE_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_NUKE_FILE;
            idDescription = IDS_NUKE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_WONT_RECYCLE_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_DELETE;
            idIcon = IDI_NUKE_FOLDER;
            idDescription = IDS_NUKE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_DELETE_PROGRAM_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_DELETE;
            idIcon = IDI_DELETE_FILE;
            idDescription = IDS_DELETE_PROGRAM_FILE;
            m_fShowARPLink = TRUE;  // TODO)) implement ShowARPLink
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_MOVE_SYSTEM_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_MOVE;
            idIcon = IDI_MOVE;
            idDescription = IDS_MOVE_SYSTEM_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_MOVE_SYSTEM_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_MOVE;
            idIcon = IDI_MOVE;
            idDescription = IDS_MOVE_SYSTEM_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_RENAME_SYSTEM_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_RENAME;
            idIcon = IDI_RENAME;
            idDescription = IDS_RENAME_SYSTEM_FILE;  // Two Arg
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_RENAME_SYSTEM_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_RENAME;
            idIcon = IDI_RENAME;
            idDescription = IDS_RENAME_SYSTEM_FOLDER;  // Two Arg
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_STREAM_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_STREAM_LOSS;
            idIcon = IDI_NUKE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_STREAM_LOSS_COPY_FILE : IDS_STREAM_LOSS_MOVE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_STREAM_LOSS_STORAGE))
        {
            idTitle = IDS_CONFIRM_STREAM_LOSS;
            idIcon = IDI_NUKE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_STREAM_LOSS_COPY_FOLDER : IDS_STREAM_LOSS_MOVE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_METADATA_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_METADATA_LOSS;
            idIcon = IDI_NUKE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_METADATA_LOSS_COPY_FILE : IDS_METADATA_LOSS_MOVE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_METADATA_LOSS_STORAGE))
        {
            idTitle = IDS_CONFIRM_METADATA_LOSS;
            idIcon = IDI_NUKE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_METADATA_LOSS_COPY_FOLDER : IDS_METADATA_LOSS_MOVE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_COMPRESSION_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_COMPRESSION_LOSS;
            idIcon = IDI_ATTRIBS_FILE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_COMPRESSION_LOSS_COPY_FILE : IDS_COMPRESSION_LOSS_MOVE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_COMPRESSION_LOSS_STORAGE))
        {
            idTitle = IDS_CONFIRM_COMPRESSION_LOSS;
            idIcon = IDI_ATTRIBS_FOLDER;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_COMPRESSION_LOSS_COPY_FOLDER : IDS_COMPRESSION_LOSS_MOVE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_SPARSEDATA_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_COMPRESSION_LOSS;
            idIcon = IDI_ATTRIBS_FILE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_SPARSE_LOSS_COPY_FILE : IDS_SPARSE_LOSS_MOVE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_ENCRYPTION_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_ENCRYPTION_LOSS;
            idIcon = IDI_ATTRIBS_FILE;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_ENCRYPTION_LOSS_COPY_FILE : IDS_ENCRYPTION_LOSS_MOVE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            // is it on purpose that we are not adding item here
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_ENCRYPTION_LOSS_STORAGE))
        {
            idTitle = IDS_CONFIRM_ENCRYPTION_LOSS;
            idIcon = IDI_ATTRIBS_FOLDER;
            idDescription = _IsCopyOperation(m_cop.dwOperation) ? IDS_ENCRYPTION_LOSS_COPY_FOLDER : IDS_ENCRYPTION_LOSS_MOVE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }

        else if (IsEqualIID(m_cop.stc, STCONFIRM_ACCESSCONTROL_LOSS_STREAM))
        {
            idTitle = IDS_CONFIRM_ACL_LOSS;
            idIcon = IDI_ATTRIBS_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_ACCESSCONTROL_LOSS_STORAGE))
        {
            idTitle = IDS_CONFIRM_ACL_LOSS;
            idIcon = IDI_ATTRIBS_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_LFNTOFAT_STREAM))
        {
            idTitle = IDS_SELECT_FILE_NAME;
            idIcon = IDI_RENAME;
            m_idDialog = IDD_CONFIRM_RENAMESKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_LFNTOFAT_STORAGE))
        {
            idTitle = IDS_SELECT_FOLDER_NAME;
            idIcon = IDI_RENAME;
            m_idDialog = IDD_CONFIRM_RENAMESKIPCANCEL;
            _AddItem(m_cop.psiItem);
        }
    
        ////////////////////////////////////////////////////////////////////////////////
        // These are the "do you want to replace something" cases, they are special in
        // that you can answer "Yes", "Skip", "Rename", or "Cancel"
        ////////////////////////////////////////////////////////////////////////////////
    
        else if (IsEqualIID(m_cop.stc, STCONFIRM_REPLACE_STREAM))
        {
            idTitle = IDS_CONFIRM_FILE_REPLACE;
            idIcon = IDI_REPLACE_FILE;
            idDescription = IDS_REPLACE_FILE;
            m_idDialog = IDD_CONFIRM_YESSKIPRENAMECANCEL;
            _AddItem(m_cop.psiDest, IDS_REPLACEEXISTING_FILE);
            _AddItem(m_cop.psiItem, IDS_WITHTHIS);
        }
        else if (IsEqualIID(m_cop.stc, STCONFIRM_REPLACE_STORAGE))
        {
            idTitle = IDS_CONFIRM_FOLDER_REPLACE;
            idIcon = IDI_REPLACE_FOLDER;
            idDescription = IDS_REPLACE_FOLDER;
            m_idDialog = IDD_CONFIRM_YESSKIPRENAMECANCEL;
            _AddItem(m_cop.psiDest, IDS_REPLACEEXISTING_FOLDER);
            _AddItem(m_cop.psiItem, IDS_INTOTHIS);
        }
    
        ////////////////////////////////////////////////////////////////////////////////
        // This group is "error messages", you can typically reply with "Skip",
        // "Retry", or "Cancel"
        ////////////////////////////////////////////////////////////////////////////////
        else
        {
            // See if the guid is one of our phony guids that's really just an HRESULT and a bunch of zeros.
            // To do this we treat the guid like an array of 4 DWORDS and check the last 3 DWORDs against 0.
            AssertMsg(sizeof(m_cop.stc) == 4*sizeof(DWORD), TEXT("Size of STGTRANSCONFIRMATION is not 128 bytes!"));
            DWORD *pdw = (DWORD*)&m_cop.stc;
            if (pdw[1] == 0 && pdw[2] == 0 && pdw[3] == 0)
            {
                HRESULT hrErr = pdw[0];
                switch (hrErr)
                {
                case STG_E_FILENOTFOUND:
                case STG_E_PATHNOTFOUND:

                case STG_E_ACCESSDENIED:

                case STG_E_INUSE:
                case STG_E_SHAREVIOLATION:
                case STG_E_LOCKVIOLATION:

                case STG_E_DOCFILETOOLARGE:
                case STG_E_MEDIUMFULL:

                case STG_E_INSUFFICIENTMEMORY:

                case STG_E_DISKISWRITEPROTECTED:

                case STG_E_FILEALREADYEXISTS:

                case STG_E_INVALIDNAME:

                case STG_E_REVERTED:

                case STG_E_DOCFILECORRUPT:

                    // these are expected errors for which we should have custom friendly strings:

                    // TODO: Get friendly messages for these errors from UA
                    idTitle = IDS_DEFAULTTITLE;
                    idIcon = IDI_DEFAULTICON;
                    idDescription = IDS_DEFAULTDESC;
                    m_idDialog = IDD_CONFIRM_RETRYSKIPCANCEL;
                    break;

                // these are errors I don't think we should ever see, so I'm asserting but then falling through to the
                // default case anyway.  In most cases I simply don't know what these mean.
                case E_PENDING:
                case STG_E_CANTSAVE:
                case STG_E_SHAREREQUIRED:
                case STG_E_NOTCURRENT:
                case STG_E_WRITEFAULT:
                case STG_E_READFAULT:
                case STG_E_SEEKERROR:
                case STG_E_NOTFILEBASEDSTORAGE:
                case STG_E_NOTSIMPLEFORMAT:
                case STG_E_INCOMPLETE:
                case STG_E_TERMINATED:
                case STG_E_BADBASEADDRESS:
                case STG_E_EXTANTMARSHALLINGS:
                case STG_E_OLDFORMAT:
                case STG_E_OLDDLL:
                case STG_E_UNKNOWN:
                case STG_E_UNIMPLEMENTEDFUNCTION:
                case STG_E_INVALIDFLAG:
                case STG_E_PROPSETMISMATCHED:
                case STG_E_ABNORMALAPIEXIT:
                case STG_E_INVALIDHEADER:
                case STG_E_INVALIDPARAMETER:
                case STG_E_INVALIDFUNCTION:
                case STG_E_TOOMANYOPENFILES:
                case STG_E_INVALIDHANDLE:
                case STG_E_INVALIDPOINTER:
                case STG_E_NOMOREFILES:

                    TraceMsg(TF_ERROR, "We should never be asked to confirm this error (%08x)", hrErr);
                  
                    // fall through...

                default:
                    // Use FormatMessage to get the default description for this error message.  Sure that's totally
                    // useless to the end user, but its more useful that nothing which is the altnerative.

                    idTitle = IDS_DEFAULTTITLE;
                    idIcon = IDI_DEFAULTICON;
                    if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hrErr, 0, szBuf, ARRAYSIZE(szBuf), NULL))
                    {
                        m_pszDescription = StrDup(szBuf);
                    }
                    else
                    {
                        idDescription = IDS_DEFAULTDESC;
                    }
                    m_idDialog = IDD_CONFIRM_RETRYSKIPCANCEL;
                    break;
                }
            }
            else
            {
                // for the default case we show an "unknown error" message and offer
                // "skip", "retry", and "cancel".  We should never get to this code path.
                TraceMsg(TF_ERROR, "An unknown non-custom error is being display in CTransferConfirmation!");
        
                idTitle = IDS_DEFAULTTITLE;
                idIcon = IDI_DEFAULTICON;
                idDescription = IDS_DEFAULTDESC;
                m_idDialog = IDD_CONFIRM_RETRYSKIPCANCEL;
            }
        }

        if (idTitle && LoadString(_Module.GetResourceInstance(), idTitle, szBuf, ARRAYSIZE(szBuf)))
        {
            m_pszTitle = StrDup(szBuf);
        }
        if (idIcon)
        {
            m_hIcon = (HICON)LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(idIcon), IMAGE_ICON, 0,0, LR_DEFAULTSIZE);
        }
        if (idDescription && LoadString(_Module.GetResourceInstance(), idDescription, szBuf, ARRAYSIZE(szBuf)))
        {
            m_pszDescription = StrDup(szBuf);
        }
    }

    if (m_fSingle)
    {
        // we don't show the "skip" button if only a single item is being moved.
        switch(m_idDialog)
        {
            case IDD_CONFIRM_RETRYSKIPCANCEL:
                m_idDialog = IDD_CONFIRM_RETRYCANCEL;
                break;
            case IDD_CONFIRM_YESSKIPCANCEL:
                m_idDialog = IDD_CONFIRM_YESCANCEL;
                break;
            case IDD_CONFIRM_RENAMESKIPCANCEL:
                m_idDialog = IDD_CONFIRM_RENAMECANCEL;
                break;
            case IDD_CONFIRM_YESSKIPRENAMECANCEL:
                m_idDialog = IDD_CONFIRM_YESRENAMECANCEL;
                break;
            default:
                break;      // unknown dialog
        }
    }

    // rename - not really implemented yet
    switch(m_idDialog)
    {
        case IDD_CONFIRM_RENAMESKIPCANCEL:
            m_idDialog = IDD_CONFIRM_SKIPCANCEL;
            break;
        case IDD_CONFIRM_RENAMECANCEL:
            m_idDialog = IDD_CONFIRM_CANCEL;
            break;
        case IDD_CONFIRM_YESSKIPRENAMECANCEL:
            m_idDialog = IDD_CONFIRM_YESSKIPCANCEL;
            break;
        case IDD_CONFIRM_YESRENAMECANCEL:
            m_idDialog = IDD_CONFIRM_YESCANCEL;
            break;
        default:
            break;      // Non-rename dialog
    }

    return S_OK;
}

// free everything loaded or allocated in _GetDialogSetttings.
HRESULT CTransferConfirmation::_FreeDialogSettings()
{
    if (m_pszTitle)
    {
        LocalFree(m_pszTitle);
        m_pszTitle = NULL;
    }
    if (m_hIcon)
    {
        DestroyIcon(m_hIcon);
        m_hIcon = NULL;
    }
    if (m_pszDescription)
    {
        LocalFree(m_pszDescription);
        m_pszDescription = NULL;
    }

    // This array is zeroed before usage, anything that's no longer zero needs to
    // be freed in the appropriate mannor.
    for (int i=0; i<ARRAYSIZE(m_rgItemInfo); i++)
    {
        if (m_rgItemInfo[i].pwszIntro)
        {
            delete [] m_rgItemInfo[i].pwszIntro;
            m_rgItemInfo[i].pwszIntro = NULL;
        }
        if (m_rgItemInfo[i].pwszDisplayName)
        {
            CoTaskMemFree(m_rgItemInfo[i].pwszDisplayName);
            m_rgItemInfo[i].pwszDisplayName = NULL;
        }
        if (m_rgItemInfo[i].pwszAttribs)
        {
            SHFree(m_rgItemInfo[i].pwszAttribs);
            m_rgItemInfo[i].pwszAttribs = NULL;
        }
        if (m_rgItemInfo[i].hBitmap)
        {
            DeleteObject(m_rgItemInfo[i].hBitmap);
            m_rgItemInfo[i].hBitmap = NULL;
        }
        if (m_rgItemInfo[i].hIcon)
        {
            DestroyIcon(m_rgItemInfo[i].hIcon);
            m_rgItemInfo[i].hIcon = NULL;
        }
    }
    m_cItems = 0;

    return S_OK;
}

HRESULT CTransferConfirmation::_ClearSettings()
{
    m_idDialog = IDD_CONFIRM_RETRYSKIPCANCEL;
    m_fShowARPLink = 0;
    m_fApplyToAll = 0;
    m_cItems = 0;
    m_hfont = 0;
    ZeroMemory(m_rgItemInfo, sizeof(m_rgItemInfo));

    return S_OK;
}

HRESULT CTransferConfirmation::_Init()
{
    HRESULT hr = S_OK;

    ASSERT(m_pszTitle == NULL);
    ASSERT(m_hIcon == NULL);
    ASSERT(m_pszDescription == NULL);

    _ClearSettings();

    if (!m_pPropUI)
    {
        hr = CoCreateInstance(CLSID_PropertiesUI, NULL, CLSCTX_INPROC_SERVER,
                                IID_PPV_ARG(IPropertyUI, &m_pPropUI));
    }

    return hr;
}

STDMETHODIMP CTransferConfirmation::Confirm(CONFIRMOP *pcop, LPCONFIRMATIONRESPONSE pcr, BOOL *pbAll)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pcop && pcr)
    {
        hr = _Init();
        if (SUCCEEDED(hr))
        {
            m_cop = *pcop;
            hr = _GetDialogSettings();
            if (SUCCEEDED(hr))
            {
                HWND hwnd;
                IUnknown_GetWindow(pcop->punkSite, &hwnd);

                int res = (int)DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(m_idDialog), hwnd, s_ConfirmDialogProc, (LPARAM)this);
            
                if (pbAll)
                    *pbAll = m_fApplyToAll;
        
                *pcr = m_crResult;
            }

            _FreeDialogSettings();
        }
    }
    return hr;
}

INT_PTR CALLBACK CTransferConfirmation::s_ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CTransferConfirmation *pThis;
    if (WM_INITDIALOG == uMsg)
    {
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
        pThis = (CTransferConfirmation *)lParam;
    }
    else
    {
        pThis = (CTransferConfirmation *)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    }

    if (!pThis)
        return 0;

    return pThis->ConfirmDialogProc(hwndDlg, uMsg, wParam, lParam);
}

BOOL CTransferConfirmation::ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return OnInitDialog(hwndDlg, wParam, lParam);

    case WM_COMMAND:
        return OnCommand(hwndDlg, LOWORD(wParam), (HWND)lParam);

    // TODO: In WM_DESTROY I need to free the icon in IDD_ICON
    }

    return 0;
}

BOOL CTransferConfirmation::OnInitDialog(HWND hwndDlg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf[1024];
    
    _CalculateMetrics(hwndDlg);

    int cxShift = 0;
    int cyShift = 0;
    int i;

    GetWindowRect(hwndDlg, &m_rcDlg);

    // We have one or more items that are part of this confirmation, we must get more
    // information about these items.  For example, we want to use full path names instead
    // of just the file name, we need to know file size, modifided data, and if possible
    // the two "most important" attributes of the file.

    // set the title
    if (m_cop.pcc)
    {
        SetWindowTextW(hwndDlg, m_cop.pcc->pwszTitle);
    }
    else if (m_pszTitle)
    {
        SetWindowText(hwndDlg, m_pszTitle);
    }

    // set the icon
    HICON hicon = NULL;
    if (m_cop.pcc)
    {
        hicon = m_cop.pcc->hicon;
    }
    else
    {
        hicon = m_hIcon;
    }
    if (hicon)
    {
        SendDlgItemMessage(hwndDlg, IDD_ICON, STM_SETICON, (LPARAM)hicon, 0);
    }
    else
    {
        HWND hwnd = GetDlgItem(hwndDlg, IDD_ICON);
        RECT rc;
        GetClientRect(hwnd, &rc);
        ShowWindow(hwnd, SW_HIDE);
        cxShift -= rc.right + m_cxControlPadding;
    }

    // Set the description text.  We need to remember the size and position of this window
    // so that we can position other controls under this text
    HWND hwndDesc = GetDlgItem(hwndDlg, ID_CONDITION_TEXT);
    RECT rcDesc;
    GetClientRect(hwndDesc, &rcDesc);

    USES_CONVERSION;
    szBuf[0] = NULL;
    if (m_cop.pcc)
    {
        StrCpyN(szBuf, m_cop.pcc->pwszDescription, ARRAYSIZE(szBuf));
    }
    else if (m_pszDescription)
    {
        DWORD_PTR rg[2];
        rg[0] = (DWORD_PTR)m_rgItemInfo[0].pwszDisplayName;
        rg[1] = (DWORD_PTR)m_rgItemInfo[1].pwszDisplayName;
        FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  m_pszDescription, 0, 0, szBuf, ARRAYSIZE(szBuf),
                  (va_list*)rg);
    }

    if (szBuf[0])
    {
        int cyWndHeight = _WindowHeightFromString(hwndDesc, RECT_WIDTH(rcDesc), szBuf);

        cyShift += (cyWndHeight - rcDesc.bottom);
        SetWindowPos(hwndDesc, NULL, 0,0, RECT_WIDTH(rcDesc), cyWndHeight, SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);
        SetWindowText(hwndDesc, szBuf);
    }

    // We need to convert from the client coordinates of hwndDesc to the client coordinates of hwndDlg.
    // We do this converstion after adjusting the size of hwndDesc to fit the description text.
    MapWindowPoints(hwndDesc, hwndDlg, (LPPOINT)&rcDesc, 2);

    // Create the folder item(s).  The first one starts at cyShift+2*cyControlPadding
    // The begining insertion point is one spaceing below the description text
    rcDesc.bottom += cyShift + m_cyControlPadding;
    AssertMsg(m_cItems<=2, TEXT("Illegal m_cItems value (%d) should never be larger than 2."), m_cItems);
    for (i=0; i<m_cItems; i++)
    {
        int cyHeightOtItem = _DisplayItem(i, hwndDlg, rcDesc.left,  rcDesc.bottom);
        cyShift += cyHeightOtItem;
        rcDesc.bottom += cyHeightOtItem;
        TraceMsg(TF_DLGDISPLAY, "_DisplayItem returned a height of: %d", cyHeightOtItem);
    }

    if (m_cop.pcc && m_cop.pcc->pwszAdvancedDetails)
    {
        // TODO: if there is "advanced text" create a read-only edit control and put the text in it.
    }

    if (m_fSingle)
    {
        HWND hwnd = GetDlgItem(hwndDlg, IDD_REPEAT);
        if (hwnd)
        {
            RECT rc;
            GetClientRect(hwnd, &rc);
            ShowWindow(hwnd, SW_HIDE);
            m_rcDlg.bottom -= rc.bottom + m_cyControlPadding;
        }
    }

    if (cxShift)
    {
        // shift all child windows by cxShift pixels
        EnumChildWindows(hwndDlg, ShiftLeftProc, cxShift);
        // don't ask!  SetWindowPos in ShiftLeftProc, for some reason, does not do anything on mirrored builds
        if (!(GetWindowLong(hwndDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL))
            m_rcDlg.right += cxShift;
    }

    if (cyShift)
    {
        ShiftDialogItem(hwndDlg, IDCANCEL, 0, cyShift);
        ShiftDialogItem(hwndDlg, IDYES, 0, cyShift);
        ShiftDialogItem(hwndDlg, IDNO, 0, cyShift);
        ShiftDialogItem(hwndDlg, IDRETRY, 0, cyShift);
        ShiftDialogItem(hwndDlg, IDOK, 0, cyShift);

        if (!m_fSingle)
            ShiftDialogItem(hwndDlg, IDD_REPEAT, 0, cyShift);

        m_rcDlg.bottom += cyShift;
    }

    // now adjust the dialog size to account for all the things we've added and position it properly
    int x = 0;
    int y = 0;
    UINT uFlags = SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE;
    HMONITOR hMonitor = MonitorFromWindow(GetParent(hwndDlg), MONITOR_DEFAULTTONEAREST);
    if (hMonitor)
    {
        MONITORINFO mi;
        mi.cbSize = sizeof(mi);
        if (GetMonitorInfo(hMonitor, &mi))
        {
            RECT rcMonitor = mi.rcMonitor;
            x = max((RECT_WIDTH(rcMonitor)-RECT_WIDTH(m_rcDlg))/2, 0);
            y = max((RECT_HEIGHT(rcMonitor)-RECT_HEIGHT(m_rcDlg))/2, 0);
            uFlags &= ~SWP_NOMOVE;
        }
    }

    TraceMsg(TF_DLGDISPLAY, "Setting dialog size to %dx%d", RECT_WIDTH(m_rcDlg), RECT_HEIGHT(m_rcDlg));
    SetWindowPos(hwndDlg, NULL, x, y, RECT_WIDTH(m_rcDlg), RECT_HEIGHT(m_rcDlg), uFlags);

    return 1;
}

BOOL CTransferConfirmation::OnCommand(HWND hwndDlg, int wID, HWND hwndCtl)
{
    BOOL fFinish = TRUE;

    switch (wID)
    {
    case IDD_REPEAT:
        fFinish = FALSE;
        break;

    case IDRETRY:       // "Retry"
        m_crResult = CONFRES_RETRY;
        break;

    case IDOK:
    case IDYES:         // "Yes"
        m_crResult = CONFRES_CONTINUE;
        break;

    case IDNO:          // "Skip"
        m_crResult = CONFRES_SKIP;
        break;

    case IDCANCEL:      // "Cancel"
        m_crResult = CONFRES_CANCEL;
        break;

    default:
        // if we get to here, then the command ID was not one of our buttons, and since the
        // only command IDs we have our the buttons this should not happen.

        AssertMsg(0, TEXT("Invalid command recieved in CTransferConfirmation::OnCommand."));
        fFinish = FALSE;
        break;
    }

    if (fFinish)
    {
        // ignore apply to all for retry case or we can have infinite loop
        m_fApplyToAll = (m_crResult != CONFRES_RETRY && BST_CHECKED == SendDlgItemMessage(hwndDlg, IDD_REPEAT, BM_GETCHECK, 0, 0));
        EndDialog(hwndDlg, wID);
        return 1;
    }

    return 0;
}

HRESULT CTransferConfirmation::_AddItem(IShellItem *psi, int idIntro)
{
    if (idIntro)
    {
        TCHAR szBuf[1024];
        if (LoadString(_Module.GetResourceInstance(), idIntro, szBuf, ARRAYSIZE(szBuf)))
        {
            m_rgItemInfo[m_cItems].pwszIntro = StrDup(szBuf);
        }
    }

    HRESULT hr = psi->GetDisplayName(SIGDN_NORMALDISPLAY, &m_rgItemInfo[m_cItems].pwszDisplayName);
    if (SUCCEEDED(hr))
    {
        IQueryInfo *pqi;
        hr = psi->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IQueryInfo, &pqi));
        if (SUCCEEDED(hr))
        {
            hr = pqi->GetInfoTip(0, &m_rgItemInfo[m_cItems].pwszAttribs);
            pqi->Release();
        }

        IExtractImage *pImg;
        hr = psi->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IExtractImage, &pImg));
        if (SUCCEEDED(hr))
        {
            WCHAR szImage[MAX_PATH];
            SIZE sz = {120, 120};
            DWORD dwFlags = 0;
            hr = pImg->GetLocation(szImage, ARRAYSIZE(szImage), NULL, &sz, 24, &dwFlags);
            if (SUCCEEDED(hr))
            {
                hr = pImg->Extract(&m_rgItemInfo[m_cItems].hBitmap);
            }
            pImg->Release();
        }

        if (FAILED(hr))
        {
            IExtractIcon *pIcon;
            hr = psi->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IExtractIcon, &pIcon));
            if (SUCCEEDED(hr))
            {
                TCHAR szIconName[MAX_PATH];
                int iIconIndex = 0;
                UINT dwFlags = 0;
                hr = pIcon->GetIconLocation(0, szIconName, ARRAYSIZE(szIconName), &iIconIndex, &dwFlags);
                if (SUCCEEDED(hr))
                {
                    hr = pIcon->Extract(szIconName, iIconIndex, &m_rgItemInfo[m_cItems].hIcon, NULL, GetSystemMetrics(SM_CXICON));
                }
                pIcon->Release();
            }
        }

        if (FAILED(hr))
        {
            IQueryAssociations *pAssoc;
            hr = CoCreateInstance(CLSID_QueryAssociations, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IQueryAssociations, &pAssoc));
            if (SUCCEEDED(hr))
            {
                WCHAR wszAssocInit[MAX_PATH];
                DWORD dwFlags = 0;
                SFGAOF flags = SFGAO_STREAM;
                if (SUCCEEDED(psi->GetAttributes(flags, &flags)) && (flags & SFGAO_STREAM))
                {
                    dwFlags = ASSOCF_INIT_DEFAULTTOSTAR;
                    StrCpyNW(wszAssocInit, PathFindExtensionW(m_rgItemInfo[m_cItems].pwszDisplayName), ARRAYSIZE(wszAssocInit));
                }
                else
                {
                    dwFlags = ASSOCF_INIT_DEFAULTTOFOLDER;
                    StrCpyNW(wszAssocInit, L"Directory", ARRAYSIZE(wszAssocInit));    // NB: "Directory is a cannonical name and should not be localized
                }

                hr = pAssoc->Init(dwFlags, wszAssocInit, NULL,NULL);
                if (SUCCEEDED(hr))
                {
                    WCHAR wszIconPath[MAX_PATH];
                    DWORD dwSize = ARRAYSIZE(wszIconPath);
                    hr = pAssoc->GetString(0, ASSOCSTR_DEFAULTICON, NULL, wszIconPath, &dwSize);
                    if (SUCCEEDED(hr))
                    {
                        int iIndex = 0;
                        LPWSTR pszArg = StrChrW(wszIconPath, L',');
                        if (pszArg)
                        {
                            *pszArg = NULL;
                            pszArg++;
                            iIndex = StrToIntW(pszArg);
                        }

                        ExtractIconEx(wszIconPath, iIndex, &m_rgItemInfo[m_cItems].hIcon, NULL, 1);
                        if (!m_rgItemInfo[m_cItems].hIcon)
                        {
                            TraceMsg(TF_WARNING, "LoadImage(%S) failed", wszIconPath);
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "pAssoc->GetString() failed");
                    }
                }
                else
                {
                    TraceMsg(TF_WARNING, "pAssoc->Init(%S) failed", wszAssocInit);
                }

                pAssoc->Release();
            }
        }

        // if we fail to extract an image then we show the remaining info anyway:
        if (FAILED(hr))
            hr = S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
        m_cItems++;
    }

    return hr;
}

BOOL CTransferConfirmation::_CalculateMetrics(HWND hwndDlg)
{
    // We space the controls 6 dialog units apart, convert that to pixels
    // REVIEW: Is it valid to hardcode this, or does the height in dialog units need to be localized?
    RECT rc = {CX_DIALOG_PADDING, CY_DIALOG_PADDING, 0, CY_STATIC_TEXT_HEIGHT};
    BOOL bRes = MapDialogRect(hwndDlg, &rc);
    m_cxControlPadding = rc.left;
    m_cyControlPadding = rc.top;
    m_cyText = rc.bottom;

    m_hfont = (HFONT)SendMessage(hwndDlg, WM_GETFONT, 0,0);

    return bRes;
}

DWORD CTransferConfirmation::_DisplayItem(int iItem, HWND hwndDlg, int x, int y)
{
    // We are told what X coordinate to place our left edge, we calculate from that how much room
    // we have available for our controls.
    int cxAvailable = RECT_WIDTH(m_rcDlg) - x - 2 * m_cxControlPadding;
    int yOrig = y;
    USES_CONVERSION;
    HWND hwnd;

    TraceMsg(TF_DLGDISPLAY, "_DisplayItem %d at location (%d,%d) in dialog %08x", iItem, x, y, hwndDlg);

    if (m_rgItemInfo[iItem].pwszIntro)
    {
            TraceMsg(TF_DLGDISPLAY, "CreateWindowEx(0, TEXT(\"STATIC\"), %s, WS_CHILD|WS_VISIBLE, %d,%d, %d,%d, %08x, NULL, %08x, 0);",
                        m_rgItemInfo[iItem].pwszIntro,
                        x,y,cxAvailable,m_cyText, hwndDlg, _Module.GetModuleInstance());
            hwnd = CreateWindowEx(0, TEXT("STATIC"), m_rgItemInfo[iItem].pwszIntro,
                                        WS_CHILD|WS_VISIBLE,
                                        x,y, cxAvailable,m_cyText,
                                        hwndDlg, NULL,
                                        _Module.GetModuleInstance(), 0);
            if (hwnd)
            {
                // we successfully added the title string for the item
                SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hfont, 0);
                x += m_cxControlPadding;
                y += m_cyText+m_cyControlPadding;
            }
    }

    RECT rcImg = {0};
    if (m_rgItemInfo[iItem].hBitmap)
    {
        TraceMsg(TF_DLGDISPLAY, "CreateWindowEx(0, TEXT(\"STATIC\"), %s, WS_CHILD|WS_VISIBLE, %d,%d, %d,%d, %08x, NULL, %08x, 0);",
                    "_Icon Window_",
                    x,y,cxAvailable,m_cyText, hwndDlg, _Module.GetModuleInstance());
        hwnd = CreateWindowEx(0, TEXT("STATIC"), NULL,
                WS_CHILD|WS_VISIBLE|SS_BITMAP,
                x,y,
                120,120,
                hwndDlg, NULL,
                _Module.GetModuleInstance(), 0);

        if (hwnd)
        {
            SendMessage(hwnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)m_rgItemInfo[iItem].hBitmap);
            GetClientRect(hwnd, &rcImg);
            x += rcImg.right + m_cxControlPadding;
            cxAvailable -= rcImg.right + m_cxControlPadding;
            rcImg.bottom += y;
        }
    }
    else if (m_rgItemInfo[iItem].hIcon)
    {
        TraceMsg(TF_DLGDISPLAY, "CreateWindowEx(0, TEXT(\"STATIC\"), %s, WS_CHILD|WS_VISIBLE, %d,%d, %d,%d, %08x, NULL, %08x, 0);",
                    "_Icon Window_",
                    x,y,cxAvailable,m_cyText, hwndDlg, _Module.GetModuleInstance());
        hwnd = CreateWindowEx(0, TEXT("STATIC"), NULL,
                WS_CHILD|WS_VISIBLE|SS_ICON,
                x,y,
                GetSystemMetrics(SM_CXICON),GetSystemMetrics(SM_CYICON),
                hwndDlg, NULL,
                _Module.GetModuleInstance(), 0);

        if (hwnd)
        {
            SendMessage(hwnd, STM_SETICON, (WPARAM)m_rgItemInfo[iItem].hIcon, NULL);
            GetClientRect(hwnd, &rcImg);
            x += rcImg.right + m_cxControlPadding;
            cxAvailable -= rcImg.right + m_cxControlPadding;
            rcImg.bottom += y;
        }
    }
    else
    {
        TraceMsg(TF_DLGDISPLAY, "Not using an image for item %d.", iItem);
    }

    TraceMsg(TF_DLGDISPLAY, "CreateWindowEx(0, TEXT(\"STATIC\"), %s, WS_CHILD|WS_VISIBLE, %d,%d, %d,%d, %08x, NULL, %08x, 0);",
                m_rgItemInfo[iItem].pwszDisplayName,
                x,y,cxAvailable,m_cyText, hwndDlg, _Module.GetModuleInstance());

    int cyWnd = _WindowHeightFromString(hwndDlg, cxAvailable, m_rgItemInfo[iItem].pwszDisplayName);
    hwnd = CreateWindowEx(0, TEXT("STATIC"), m_rgItemInfo[iItem].pwszDisplayName,
                          WS_CHILD|WS_VISIBLE,
                          x,y, cxAvailable,cyWnd,
                          hwndDlg, NULL,
                          _Module.GetModuleInstance(), 0);
    if (hwnd)
    {
        SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hfont, 0);
        y += cyWnd;
    }
    else
    {
        TraceMsg(TF_DLGDISPLAY, "CreateWindowEx for display name failed.");
    }

    TraceMsg(TF_DLGDISPLAY, "CreateWindowEx(0, TEXT(\"STATIC\"), %s, WS_CHILD|WS_VISIBLE, %d,%d, %d,%d, %08x, NULL, %08x, 0);",
                m_rgItemInfo[iItem].pwszAttribs,
                x,y,cxAvailable,m_cyText, hwndDlg, _Module.GetModuleInstance());

    cyWnd = _WindowHeightFromString(hwndDlg, cxAvailable, m_rgItemInfo[iItem].pwszAttribs);
    hwnd = CreateWindowEx(0, TEXT("STATIC"), m_rgItemInfo[iItem].pwszAttribs,
                          WS_CHILD|WS_VISIBLE|SS_LEFT,
                          x,y, cxAvailable,cyWnd,
                          hwndDlg, NULL,
                          _Module.GetModuleInstance(), 0);
    if (hwnd)
    {
        SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hfont, 0);
        y += cyWnd;
    }
    else
    {
        TraceMsg(TF_DLGDISPLAY, "CreateWindowEx for attribs failed.");
    }

    if (rcImg.bottom > y)
        y = rcImg.bottom;

    return (y-yOrig) + m_cyControlPadding;
}

int CTransferConfirmation::_WindowHeightFromString(HWND hwnd, int cx, LPTSTR psz)
{
    RECT rc = {0,0, cx,0 };
    HDC hdc = GetDC(hwnd);
    HFONT hfontOld = NULL;
    DWORD dtFlags = DT_CALCRECT|DT_WORDBREAK;
    if (m_hfont)
    {
        // We need to select the font that the dialog will use so that we calculate the correct size
        hfontOld = (HFONT)SelectObject(hdc, m_hfont);
    }
    else
    {
        // a NULL m_hfont means we are using the system font, using DT_INTERNAL should do the
        // calculation based on the system font.
        dtFlags |= DT_INTERNAL;
    }
    DrawText(hdc, psz, -1, &rc, dtFlags);
    if (hfontOld)
        SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);

    return rc.bottom;
}

void ShiftWindow(HWND hwnd, int cx, int cy)
{
    RECT rc;

    // rect in screen coordinates
    GetWindowRect(hwnd, &rc);
    // shift it over
    if (GetWindowLong(GetParent(hwnd), GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
        rc.left -= cx;
    else
        rc.left += cx;

    rc.top += cy;
    // convert to parent windows coords
    MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rc, 2);
    // and move the window
    SetWindowPos(hwnd, NULL, rc.left, rc.top, 0,0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
}


void ShiftDialogItem(HWND hDlg, int id, int cx, int cy)
{
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, id);
    if (NULL != hwnd)
    {
        ShiftWindow(hwnd, cx, cy);
    }
}

BOOL CALLBACK ShiftLeftProc(HWND hwnd, LPARAM lParam)
{
    ShiftWindow(hwnd, (int)(INT_PTR)lParam, 0);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\contextmenu.cpp ===
#include "shellprv.h"
#include "cowsite.h"
#include "contextmenu.h"

// Context Menu Forwarding base class, desinged to delegate
// to a real IContextMenu, and provide inheriting class
// an easy way to override minor bits of functionality
//
CContextMenuForwarder::CContextMenuForwarder(IUnknown* punk) : _cRef(1)
{
    _punk = punk;
    _punk->AddRef();

    _punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &_pows));
    _punk->QueryInterface(IID_PPV_ARG(IContextMenu, &_pcm));
    _punk->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pcm2));
    _punk->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm3));
}

CContextMenuForwarder::~CContextMenuForwarder()
{
    if (_pows) _pows->Release();
    if (_pcm)  _pcm->Release();
    if (_pcm2) _pcm2->Release();
    if (_pcm3) _pcm3->Release();
    _punk->Release();
}

STDMETHODIMP CContextMenuForwarder::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = _punk->QueryInterface(riid, ppv);

    if (SUCCEEDED(hr))
    {
        IUnknown* punkTmp = (IUnknown*)(*ppv);

        static const QITAB qit[] = {
            QITABENT(CContextMenuForwarder, IObjectWithSite),                     // IID_IObjectWithSite
            QITABENT(CContextMenuForwarder, IContextMenu3),                       // IID_IContextMenu3
            QITABENTMULTI(CContextMenuForwarder, IContextMenu2, IContextMenu3),   // IID_IContextMenu2
            QITABENTMULTI(CContextMenuForwarder, IContextMenu, IContextMenu3),    // IID_IContextMenu
            { 0 },
        };

        HRESULT hrTmp = QISearch(this, qit, riid, ppv);

        if (SUCCEEDED(hrTmp))
        {
            punkTmp->Release();
        }
        else
        {
            RIPMSG(FALSE, "CContextMenuForwarder asked for an interface it doesn't support");
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }
    }

    return hr;
}

STDMETHODIMP_(ULONG) CContextMenuForwarder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CContextMenuForwarder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// A context menu implementation on an array of context menus
//
// use the Create_ContextMenuOnContextMenuArray construction function
//

#define MAX_CM_WRAP 5
class CContextMenuOnContextMenuArray : public IContextMenu3, public CObjectWithSite
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // IContextMenu2
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHODIMP HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punkSite); // override

    BOOL IsEmpty() { return 0 == _count; }

protected:
    CContextMenuOnContextMenuArray(IContextMenu* rgpcm[], UINT cpcm);
    ~CContextMenuOnContextMenuArray();

    friend HRESULT Create_ContextMenuOnContextMenuArray(IContextMenu* rgpcm[], UINT cpcm, REFIID riid, void** ppv);

private:
    LONG                _cRef;

    UINT                _count;
    UINT                _idFirst;                       // The begining of the first range is _idFirst
    UINT                _idOffsets[MAX_CM_WRAP];        // The END of each range (BEGINing of next range is +1)
    IContextMenu        *_pcmItem[MAX_CM_WRAP];         // The contextmenu for the item
    IContextMenu2       *_pcm2Item[MAX_CM_WRAP];        // The contextmenu for the item
    IContextMenu3       *_pcm3Item[MAX_CM_WRAP];        // The contextmenu for the item
};

CContextMenuOnContextMenuArray::CContextMenuOnContextMenuArray(IContextMenu* rgpcm[], UINT cpcm) : _cRef(1)
{
    ASSERT(cpcm <= MAX_CM_WRAP);
    // its the callers fault, but make sure we don't overrun anyway.
    if (cpcm > MAX_CM_WRAP)
    {
        cpcm = MAX_CM_WRAP;
    }

    ASSERT(0 == _count);

    for (UINT i = 0 ; i < cpcm ; i++)
    {
        if (rgpcm[i])
        {
            rgpcm[i]->QueryInterface(IID_PPV_ARG(IContextMenu, &_pcmItem[_count]));
            ASSERT(_pcmItem[_count]);
            rgpcm[i]->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pcm2Item[_count]));
            rgpcm[i]->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm3Item[_count]));

            _count++;
        }
    }
}

HRESULT Create_ContextMenuOnContextMenuArray(IContextMenu* rgpcm[], UINT cpcm, REFIID riid, void** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (cpcm < MAX_CM_WRAP)
    {
        CContextMenuOnContextMenuArray* p = new CContextMenuOnContextMenuArray(rgpcm, cpcm);
        if (p)
        {
            if (p->IsEmpty())
            {
                hr = E_OUTOFMEMORY; // caller didn't check the array it gave us?
            }
            else
            {
                hr = p->QueryInterface(riid, ppv);
            }
            p->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        RIPMSG(FALSE, "Create_ContextMenuOnContextMenuArray with too many items!");
        hr = E_INVALIDARG;
    }

    return hr;
}

CContextMenuOnContextMenuArray::~CContextMenuOnContextMenuArray()
{
    for (UINT i = 0 ; i < _count ; i++)
    {
        _pcmItem[i]->Release();
        if (_pcm2Item[i])
            _pcm2Item[i]->Release();
        if (_pcm3Item[i])
            _pcm3Item[i]->Release();
    }
}

STDMETHODIMP CContextMenuOnContextMenuArray::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CContextMenuOnContextMenuArray, IContextMenu, IContextMenu3),    // IID_IContextMenu
        QITABENTMULTI(CContextMenuOnContextMenuArray, IContextMenu2, IContextMenu3),   // IID_IContextMenu2
        QITABENT(CContextMenuOnContextMenuArray, IContextMenu3),                       // IID_IContextMenu3
        QITABENT(CContextMenuOnContextMenuArray, IObjectWithSite),                     // IID_IObjectWithSite
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CContextMenuOnContextMenuArray::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CContextMenuOnContextMenuArray::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CContextMenuOnContextMenuArray::SetSite(IUnknown *punkSite)
{
    // let all the kids know
    for (UINT i = 0; i < _count; i++)
    {
        IUnknown_SetSite(_pcmItem[i], punkSite);
    }

    return CObjectWithSite::SetSite(punkSite);
}

STDMETHODIMP CContextMenuOnContextMenuArray::QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    _idFirst = idCmdFirst;
    
    // We need the placeholder for the below to work
    if (InsertMenu(hmenu, indexMenu, MF_BYPOSITION|MF_STRING, 0, L"{44075D61-2050-4DF4-BC5D-CBA88A84E75B}"))
    {
        BOOL fIndexMenuIsPlaceholder = TRUE;

        // For each of our context menus...
        for (UINT i = 0; i < _count  && idCmdFirst < idCmdLast; i++)
        {
            HRESULT hr = _pcmItem[i]->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
            if (SUCCEEDED(hr))
            {
                fIndexMenuIsPlaceholder = FALSE;

                _idOffsets[i] = idCmdFirst - _idFirst + (UINT)ShortFromResult(hr);
                idCmdFirst = idCmdFirst + (UINT)ShortFromResult(hr) + 1;

                // Find the placeholder so we know where to insert the next menu
                int cMenuItems = GetMenuItemCount(hmenu);
                for (int iItem = 0; iItem < cMenuItems; iItem++)
                {
                    WCHAR szName[60];
                    if (GetMenuString(hmenu, (iItem + indexMenu) % cMenuItems, szName, ARRAYSIZE(szName), MF_BYPOSITION)
                    &&  !lstrcmp(szName, L"{44075D61-2050-4DF4-BC5D-CBA88A84E75B}"))
                    {
                        indexMenu = (iItem + indexMenu) % cMenuItems;
                        fIndexMenuIsPlaceholder = TRUE;
                        break;
                    }
                }

                RIPMSG(fIndexMenuIsPlaceholder, "CContextMenuOnContextMenuArray::QueryContextMenu - some context menu removed our placeholder string");
            }
            else
            {
                if (0 == i)
                    _idOffsets[i] = 0;
                else
                    _idOffsets[i] = _idOffsets[i-1];
            }
        }

        // Remove the placeholder
        if (fIndexMenuIsPlaceholder)
        {
            DeleteMenu(hmenu, indexMenu, MF_BYPOSITION);
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "CContextMenuOnContextMenuArray::QueryContextMenu - could not add placeholder element");
    }

    return idCmdFirst - _idFirst;
}

STDMETHODIMP CContextMenuOnContextMenuArray::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    HRESULT hr;
    
    for (UINT i = 0; i < _count; i++)
    {
        if (IS_INTRESOURCE(lpici->lpVerb))
        {
            UINT idCmd = (UINT)LOWORD((DWORD_PTR)lpici->lpVerb);
            if (idCmd <= _idOffsets[i])
            {
                // adjust id to be in proper range for this pcm
                if (i > 0)
                {
                    lpici->lpVerb = MAKEINTRESOURCEA(idCmd - _idOffsets[i-1] - 1);
                }
                hr = _pcmItem[i]->InvokeCommand(lpici);
                return hr;
            }
        }
        else
        {
            // I guess we try until it works
            hr = _pcmItem[i]->InvokeCommand(lpici);
            if (SUCCEEDED(hr))
                return hr;
        }
    }
    
    TraceMsg(TF_ERROR, "Someone's passing CContextMenuOnContextMenuArray::InvokeCommand an id we didn't insert...");
    return E_FAIL;
}

STDMETHODIMP CContextMenuOnContextMenuArray::GetCommandString(UINT_PTR idCmd, UINT wFlags, UINT * pmf, LPSTR pszName, UINT  cchMax)
{
    for (UINT i = 0; i < _count; i++)
    {
        if (idCmd <= _idOffsets[i])
        {
            // adjust id to be in proper range for this pcm
            if (i>0)
            {
                idCmd = idCmd - _idOffsets[i-1] - 1;
            }
        
            return _pcmItem[i]->GetCommandString(idCmd, wFlags, pmf, pszName, cchMax);
        }
    }

    TraceMsg(TF_ERROR, "Someone's passing CContextMenuOnContextMenuArray::GetCommandString an id we didn't insert...");
    return E_FAIL;
}

STDMETHODIMP CContextMenuOnContextMenuArray::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}

STDMETHODIMP CContextMenuOnContextMenuArray::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = E_FAIL;
    UINT idCmd;

    // Find the menu command id -- it's packed differently depending on the message
    //
    switch (uMsg) 
    {
    case WM_MEASUREITEM:
        idCmd = ((MEASUREITEMSTRUCT *)lParam)->itemID;
        break;

    case WM_DRAWITEM:
        idCmd = ((LPDRAWITEMSTRUCT)lParam)->itemID;
        break;

    case WM_INITMENUPOPUP:
        idCmd = GetMenuItemID((HMENU)wParam, 0);
        break;

    case WM_MENUSELECT:
        {
            idCmd = GET_WM_MENUSELECT_CMD(wParam, lParam);
            UINT wFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);

            // if idCmd is an offset, convert it to a menu id
            if (wFlags & MF_POPUP)
            {
                MENUITEMINFO miiSubMenu = { 0 };

                miiSubMenu.cbSize = sizeof(MENUITEMINFO);
                miiSubMenu.fMask = MIIM_ID;

                if (GetMenuItemInfo(GET_WM_MENUSELECT_HMENU(wParam, lParam), idCmd, TRUE, &miiSubMenu))
                {
                    idCmd = miiSubMenu.wID;
                }
                else
                {
                    return E_FAIL;
                }
            }
        }
        break;

    case WM_MENUCHAR:
        if (NULL != plResult)
        {
            for (UINT i = 0; i < _count; i++)
            {
                if (_pcm3Item[i])
                {
                    hr = _pcm3Item[i]->HandleMenuMsg2(uMsg, wParam, lParam, plResult);
                    if (S_OK == hr)
                        return hr;
                }
            }
        }
        return E_FAIL;

    default:
        return E_FAIL;
    }

    // make sure it's in our range
    if (idCmd >= _idFirst)
    {
        idCmd -= _idFirst;
        
        for (UINT i = 0; i < _count; i++)
        {
            if (idCmd <= _idOffsets[i])
            {
                if (_pcm3Item[i])
                    hr = _pcm3Item[i]->HandleMenuMsg2(uMsg, wParam, lParam, plResult);
                else if (_pcm2Item[i] && NULL == plResult)
                    hr = _pcm2Item[i]->HandleMenuMsg(uMsg, wParam, lParam);
                break;
            }
        }
    }

    return hr;
}

// CContextMenuOnHMENU takes ownership of HMENU and creates
// an IContextMenu implementation out of it, forwarding all
// messages to hwndOwner.
//
class CContextMenuOnHMENU : IContextMenu3
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // IContextMenu2
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHODIMP HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

protected:
    CContextMenuOnHMENU(HMENU hmenu, HWND hwndOwner);
    virtual ~CContextMenuOnHMENU();
    friend HRESULT Create_ContextMenuOnHMENU(HMENU hmenu, HWND hwndOwner, REFIID iid, void** ppv);

private:
    LONG _cRef;

    HMENU _hmenu;    // menu to wrap
    HWND  _hwndOwner;// window to forward menu messages to

    UINT  _idCmdFirst;

    UINT  _rgid[200]; // mapping of context menu ids to the original hmenu command ids (arbitrary limit to the size of an hmenu we support)
    UINT  _crgid;

    void _RebaseMenu(HMENU hmenu, UINT uFlags); // maps _hmenu's ids such that _rgid[newid-1]=oldid
    BOOL _IsValidID(UINT wID) { return (wID > 0 && wID <= _crgid); } // can we index _rgid[] with [wID-1]?
};

CContextMenuOnHMENU::CContextMenuOnHMENU(HMENU hmenu, HWND hwndOwner) : _cRef(1)
{
    _hmenu = hmenu;
    _hwndOwner = hwndOwner;
}

// takes ownership of hmenu
HRESULT Create_ContextMenuOnHMENU(HMENU hmenu, HWND hwndOwner, REFIID riid, void** ppv)
{
    HRESULT hr;

    *ppv = NULL;
    
    if (hmenu)
    {
        CContextMenuOnHMENU* p = new CContextMenuOnHMENU(hmenu, hwndOwner);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
        else
        {
            DestroyMenu(hmenu);
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY; // caller probably just didn't check for this error case
    }

    return hr;
}

CContextMenuOnHMENU::~CContextMenuOnHMENU()
{
    DestroyMenu(_hmenu);
}

STDMETHODIMP CContextMenuOnHMENU::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CContextMenuOnHMENU, IContextMenu3),                       // IID_IContextMenu3
        QITABENTMULTI(CContextMenuOnHMENU, IContextMenu2, IContextMenu3),   // IID_IContextMenu2
        QITABENTMULTI(CContextMenuOnHMENU, IContextMenu, IContextMenu3),    // IID_IContextMenu
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CContextMenuOnHMENU::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CContextMenuOnHMENU::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// What is the lowest menu id used in hmenu?
// (Note that "-1" is often used for separators,
// but that is a very LARGE number...)
//
void CContextMenuOnHMENU::_RebaseMenu(HMENU hmenu, UINT uFlags)
{
    for (int nItem = GetMenuItemCount(hmenu) - 1; nItem >= 0; nItem--)
    {
        MENUITEMINFO mii = {0};

        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_SUBMENU;

        if (!GetMenuItemInfo(hmenu, nItem, TRUE, &mii))
        {
            continue;
        }

        if (!mii.hSubMenu || (uFlags & MM_SUBMENUSHAVEIDS))
        {
            if (_crgid < ARRAYSIZE(_rgid))
            {
                _rgid[_crgid] = mii.wID;
                mii.wID = ++_crgid;
                SetMenuItemInfo(hmenu, nItem, TRUE, &mii);
            }
            else
            {
                RIPMSG(FALSE, "CContextMenuOnHMENU::_RebaseMenu() - Someone is using an HMENU that's too big...");
                DeleteMenu(hmenu, nItem, MF_BYPOSITION);
                continue;
            }
        }

        if (mii.hSubMenu)
        {
            _RebaseMenu(mii.hSubMenu, uFlags);
        }
    }
}

HRESULT CContextMenuOnHMENU::QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    _idCmdFirst = idCmdFirst;

    _RebaseMenu(_hmenu, uFlags);
    
    UINT idMax = Shell_MergeMenus(hmenu, _hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);

    return idMax - _idCmdFirst;
}

HRESULT CContextMenuOnHMENU::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    if (IS_INTRESOURCE(lpici->lpVerb))
    {
        UINT wID = LOWORD((UINT_PTR)lpici->lpVerb);

        RIPMSG(_IsValidID(wID), "CContextMenuOnHMENU::InvokeCommand() received invalid wID");

        if (_IsValidID(wID))
        {
            wID = _rgid[wID-1];

            SendMessage(_hwndOwner, WM_COMMAND, GET_WM_COMMAND_MPS(wID, 0, 0));

            return S_OK;
        }
    }

    return E_INVALIDARG;
}

HRESULT CContextMenuOnHMENU::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    if (cchMax)
        pszName[0] = 0;

    if (IS_INTRESOURCE(idCmd))
    {
        RIPMSG(_IsValidID(idCmd), "CContextMenuOnHMENU::InvokeCommand() received invalid idCmd");

        if (_IsValidID(idCmd))
        {
            UINT wID = _rgid[idCmd - 1];

            switch (uType)
            {
            case GCS_HELPTEXT:
                // The only time this seems to be called is in response to a WM_MENUSELECT,
                // so forward it back to _hwndOwner so it can be the real WM_MENUSELECT
                SendMessage(_hwndOwner, WM_MENUSELECT, GET_WM_MENUSELECT_MPS(wID, 0, _hmenu));
                return E_FAIL;
            }

            return E_NOTIMPL;
        }
    }

    return E_INVALIDARG;
}

HRESULT CContextMenuOnHMENU::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg,wParam,lParam,NULL);
}

HRESULT CContextMenuOnHMENU::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = E_FAIL;
    LRESULT lRes = 0;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        lRes = SendMessage(_hwndOwner, uMsg, (WPARAM)_hmenu, lParam);
        hr = S_OK;
        break;

    case WM_DRAWITEM:
    {
        LPDRAWITEMSTRUCT pdi = ((LPDRAWITEMSTRUCT)lParam);
        DRAWITEMSTRUCT di = *pdi;
        RIPMSG(_IsValidID(di.itemID - _idCmdFirst), "CContextMenuOnHMENU::HandleMenuMsg2(WM_DRAWITEM) received invalid itemID");
        if (_IsValidID(di.itemID - _idCmdFirst))
        {
            di.itemID = _rgid[di.itemID - _idCmdFirst - 1];
            lRes = SendMessage(_hwndOwner, uMsg, wParam, (LPARAM)&di);
            hr = S_OK;
        }
        else
            hr = E_INVALIDARG;
        break;
    }

    case WM_MEASUREITEM:
    {
        LPMEASUREITEMSTRUCT pmi =((LPMEASUREITEMSTRUCT)lParam);
        MEASUREITEMSTRUCT mi = *pmi;
        RIPMSG(_IsValidID(mi.itemID - _idCmdFirst), "CContextMenuOnHMENU::HandleMenuMsg2(WM_MEASUREITEM) received invalid itemID");
        if (_IsValidID(mi.itemID - _idCmdFirst))
        {
            mi.itemID = _rgid[mi.itemID - _idCmdFirst - 1];
            lRes = SendMessage(_hwndOwner, uMsg, wParam, (LPARAM)&mi);
            hr = S_OK;
        }
        else
            hr = E_INVALIDARG;
        break;
    }

    case WM_MENUSELECT:
    {
        UINT wID = GET_WM_MENUSELECT_CMD(wParam, lParam);
        UINT wFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);

        if (!(wFlags & MF_POPUP))
        {
            RIPMSG(_IsValidID(wID - _idCmdFirst), "CContextMenuOnHMENU::HandleMenuMsg2(WM_MENUSELECT) received invalid wID");
            if (_IsValidID(wID - _idCmdFirst))
            {
                wID = _rgid[wID - _idCmdFirst - 1];
            }
            else
            {
                hr = E_INVALIDARG;
                break;
            }
        }

        lRes = SendMessage(_hwndOwner, uMsg, GET_WM_MENUSELECT_MPS(wID, wFlags, _hmenu));
        hr = S_OK;
        break;
    }

    case WM_MENUCHAR:
        // should probably be SendMessage(_hwndOwner, uMsg, wParam, (LPARAM)_hmenu)
        // but our WM_MENUCHAR forwarding doesn't find the correct owner...
        //
        lRes = DefWindowProc(_hwndOwner, uMsg, wParam, (LPARAM)_hmenu);
        hr = (0 == lRes) ? S_FALSE : S_OK;
        break;

    default:
        RIPMSG(FALSE, "CContextMenuOnHMENU::HandleMenuMsg2 was forwarded an unexpected window message");
        lRes = 0;
        hr = E_FAIL;
        break;
    }

    if (plResult)
        *plResult = lRes;

    return hr;
}


// Forward everything to the given context menu,
// but remove menu items with the canonical verbs
// given in the semicolon-separated list of canonical verbs
//
class CContextMenuWithoutVerbs : CContextMenuForwarder
{
public:
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);

protected:
    CContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList);

    friend HRESULT Create_ContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList, REFIID riid, void **ppv);

private:
    LPCWSTR _pszVerbList;
};

CContextMenuWithoutVerbs::CContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList) : CContextMenuForwarder(punk) 
{
    _pszVerbList = pszVerbList; // no reference - this should be a pointer to the code segment
}

HRESULT Create_ContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    if (pszVerbList)
    {
        CContextMenuWithoutVerbs* p = new CContextMenuWithoutVerbs(punk, pszVerbList);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
    }

    return hr;
}

HRESULT CContextMenuWithoutVerbs::QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    HRESULT hr = CContextMenuForwarder::QueryContextMenu(hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags);
    if (SUCCEEDED(hr))
    {
        LPCWSTR pszVerb = _pszVerbList;

        while (*pszVerb)
        {
            WCHAR szVerb[64];

            LPCWSTR pszNext = StrChrW(pszVerb, L';');

            if (pszNext)
            {
                UINT cch = (UINT)(pszNext - pszVerb) + 1;

                ASSERT(0 < cch && cch < ARRAYSIZE(szVerb)); // we should be large enough for all the canonical verbs we use

                StrCpyN(szVerb, pszVerb, min(cch, ARRAYSIZE(szVerb)));

                pszVerb = pszNext + 1;
            }
            else
            {
                UINT cch = lstrlen(pszVerb) + 1;

                ASSERT(0 < cch && cch < ARRAYSIZE(szVerb)); // we should be large enough for all the canonical verbs we use

                StrCpyN(szVerb, pszVerb, min(cch, ARRAYSIZE(szVerb)));

                pszVerb += cch - 1; // point at NULL
            }

            ContextMenu_DeleteCommandByName(_pcm, hmenu, idCmdFirst, szVerb);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\combview.cpp ===
#include "shellprv.h"
#include <regstr.h>
#include <shellp.h>
#include "ole2dup.h"
#include "ids.h"
#include "defview.h"
#include "lvutil.h"
#include "idlcomm.h"
#include "filetbl.h"
#include "undo.h"
#include "cnctnpt.h"
#include "mshtml.h"
#include <sfview.h>
#include "defviewp.h"
#include "shellp.h"

#define LISTVIEW_PROP   TEXT("CombView_listview_subclass")
#define ISMOUSEDOWN(msg) ((msg) == WM_LBUTTONDOWN || (msg) == WM_RBUTTONDOWN || (msg) == WM_MBUTTONDOWN)
#define HWNDLISTVIEW (g_pdsvlvp->pdsv->_hwndListview)
#define COMBVIEW_SUBCLASS_ID  42

typedef struct  
{
    CDefView   *pdsv;
    BOOL       fInPaint;
    HHOOK      hHookMouse;
    HHOOK      hHookGetMsg;
} DVLVPROP;

//
// We need this global (g_pdsvlvp) for the mouse hook we need to implement the combined
// view.  Since we only have one combined view at this point it is sufficient to have
// a single global, but if we end up with more than one combined view then
// there needs to be some additional code added so the hook(s) can figure out
// which combined view(s) it is associated with.
// 
DVLVPROP * g_pdsvlvp = NULL;

const LPCTSTR c_rgElements[] = {   
    TEXT("A"),
    TEXT("ANCHOR"),   // ???
    TEXT("PLUGINS"),  // ???
    TEXT("APPLET"),
    TEXT("EMBED"),
    TEXT("FORM"),
    TEXT("IFRAME"),
    TEXT("BUTTON"),
    TEXT("INPUT"),
    TEXT("OBJECT") 
};                              

BOOL CombView_EnableAnimations(BOOL fEnable);

// Returns the first sibling window of the passed in window
HWND GetSpecialSibling(HWND hwnd)
{
    HWND hwndT = GetWindow(hwnd, GW_HWNDFIRST);

    while (hwnd == hwndT)
        hwndT = GetWindow(hwndT, GW_HWNDNEXT);

    return hwndT;
}

LRESULT CALLBACK CombView_LV_SubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    DVLVPROP *pdsvlvp = (DVLVPROP *)dwRefData;

    //  2000-07-11 vtan: First check g_pdsvlvp for NULL. If this is NULL then the dwRefData
    //  has already been released in EnableCombinedView. There is only one DVLVPROP stored
    //  in the entire process in g_pdsvlvp. This seems like a problem. lamadio should fix
    //  this properly in the future.

    if ((g_pdsvlvp != NULL) &&
        pdsvlvp && 
        pdsvlvp->pdsv->_fCombinedView && 
        !pdsvlvp->fInPaint && 
        uMsg == WM_PAINT) 
    {
        // This code works well for general painting, like minimizing a window or
        // or surfacing the desktop.  However, it doesn't help the drag full windows
        // scenario very much.
        HRGN hrgn, hrgn2;
        RECT rc;
        HWND hwndT = GetSpecialSibling(hwnd);

        // Turn on animations!
        CombView_EnableAnimations(TRUE);

        if (hwndT && (hrgn = CreateRectRgn(0, 0, 0, 0))) 
        {
            if (hrgn2 = CreateRectRgn(0, 0, 0, 0)) 
            {
                pdsvlvp->fInPaint = TRUE;

                if (!GetClassLongPtr(hwndT, GCLP_HBRBACKGROUND))
                    SetClassLongPtr(hwndT, GCLP_HBRBACKGROUND, (LPARAM)GetStockObject(HOLLOW_BRUSH));

                if (GetUpdateRect(hwndT, &rc, FALSE)) 
                {
                    RECT rcLV = rc;
                    MapWindowPoints(hwndT, hwnd, (LPPOINT)&rcLV, 2);

                    SetRectRgn(hrgn2, rcLV.left, rcLV.top, rcLV.right, rcLV.bottom);
                    GetWindowRgn(hwnd, hrgn);
                    CombineRgn(hrgn2, hrgn, hrgn2, RGN_DIFF);
                    SetWindowRgn(hwnd, hrgn2, FALSE);
                    InvalidateRect(hwndT, &rc, FALSE);
                    UpdateWindow(hwndT);
                    SetWindowRgn(hwnd, hrgn, FALSE);
                    InvalidateRect(hwnd, &rcLV, FALSE);
                }
                else
                {
                    DeleteObject(hrgn);
                    DeleteObject(hrgn2);
                }

                pdsvlvp->fInPaint = FALSE;
            }
            else 
            {
                DeleteObject(hrgn);
            }
        }
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

// We need to set capture while we are stealing the mouse so that the
// window manager won't send WM_SETCURSOR messages to the wrong window.
// This function will also, as a side effect, send the WM_SETCURSOR to the
// listview so that it will set the hand cursor when it needs to.
void StealMouse(DVLVPROP * pdvlvp, BOOL fSteal, UINT msg)
{
    HWND hwndCapture = GetCapture();

    if (fSteal && (hwndCapture == NULL || hwndCapture == HWNDLISTVIEW)) 
    {
        // We need to set capture so that the window manager will not
        // try to send the w_setcursor message to the wrong window, and we
        // send it here ourself to the listview.
        SetCapture(HWNDLISTVIEW);
        SendMessage(HWNDLISTVIEW, WM_SETCURSOR, (WPARAM)HWNDLISTVIEW,
            MAKELPARAM(HTCLIENT, LOWORD(msg)));
    }
    else
    {
        // If the listview still has capture release it now
        if (HWNDLISTVIEW == hwndCapture)
            ReleaseCapture();
    }
}

LRESULT CALLBACK CombView_GetMsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    #define LPMSG ((LPMSG)lParam)
    HHOOK hHookNext = NULL;

    if (g_pdsvlvp) 
    {
        if (LPMSG->message >= WM_MOUSEFIRST && LPMSG->message <= WM_MOUSELAST) 
        {
            POINT pt;

            pt.x = GET_X_LPARAM(LPMSG->lParam);
            pt.y = GET_Y_LPARAM(LPMSG->lParam);

            MapWindowPoints(LPMSG->hwnd, HWNDLISTVIEW, &pt, 1);
            int iHit = g_pdsvlvp->pdsv->_HitTest(&pt);

            // Unhook our hook when all of the mouse buttons are up and we're not over
            // an item in the listview
            if (GetKeyState(VK_LBUTTON) >= 0 &&
                GetKeyState(VK_RBUTTON) >= 0 &&
                GetKeyState(VK_MBUTTON) >= 0 &&
                iHit == -1) 
            {
                UnhookWindowsHookEx(g_pdsvlvp->hHookGetMsg);
                g_pdsvlvp->hHookGetMsg = NULL;
            } 
            else 
            {
                hHookNext = g_pdsvlvp->hHookGetMsg;
            }
                       
            if (IsChildOrSelf(GetSpecialSibling(HWNDLISTVIEW), LPMSG->hwnd) == S_OK) 
            {
                // If we have grabbed the mouse, give it to the listview
                LPMSG->hwnd = HWNDLISTVIEW;
                LPMSG->lParam = MAKELPARAM(LOWORD(pt.x), LOWORD(pt.y));
            }
        }
        else
        {
            hHookNext = g_pdsvlvp->hHookGetMsg;
        }

        // If we've just unhooked, or the hover is coming through to the listview and
        // no mouse button is down then clear our ownership of the mouse
        #define MK_BUTTON (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON)
        if (!hHookNext ||
            // We need to special case the WM_MOUSEHOVER here so that the listview
            // is able to implement hover select.  If we have capture set when the
            // hover select message goes through then it will ignore the message, so
            // clear the capture now.
            (LPMSG->message == WM_MOUSEHOVER && LPMSG->hwnd == HWNDLISTVIEW && !(LPMSG->wParam & MK_BUTTON)))
            StealMouse(g_pdsvlvp, FALSE, 0);
    }

    if (hHookNext)
        CallNextHookEx(hHookNext, nCode, wParam, lParam);

    return 0;

    #undef LPMSG
}

BOOL DoesElementNeedMouse (LPTSTR psz)
{
    for (int i = 0; i < ARRAYSIZE(c_rgElements); i++) 
    {
        if (lstrcmpi(c_rgElements[i], psz) == 0)
            return TRUE;
    }
    return FALSE;
}

BOOL ShouldStealMouseClick(POINT * ppt, DVLVPROP * pdsvlvp)
{
    IHTMLDocument2 *pihtmldoc2;
    IHTMLElement *pielem;
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(pdsvlvp->pdsv->GetItemObject(SVGIO_BACKGROUND, IID_IHTMLDocument2, (void **)&pihtmldoc2))) 
    {
        // Work around for Trident issue - 
        // elementFromPoint is returning success here even though pielem is
        // still NULL.
        if (SUCCEEDED(pihtmldoc2->elementFromPoint(ppt->x, ppt->y, &pielem)) && pielem) 
        {
            IHTMLElement *pielemT;

            do {
                BSTR bstr = NULL;
                TCHAR sz[MAX_PATH];

                pielem->get_tagName(&bstr);

                SHUnicodeToTChar(bstr, sz, ARRAYSIZE(sz));

                SysFreeString(bstr);

                if (DoesElementNeedMouse(sz))
                {
                    hr = E_FAIL;
                }
                else
                {
                    if (SUCCEEDED(hr = pielem->get_parentElement(&pielemT)))
                    {
                        pielem->Release();
                        pielem = pielemT;
                    }
                    else
                    {
                        hr = S_OK;
                        pielem->Release();
                        pielem = NULL;
                    }
                }
            } while (SUCCEEDED(hr) && pielem);

            if (pielem)
                pielem->Release();
        }
        pihtmldoc2->Release();
    }

    return SUCCEEDED(hr);
}

LRESULT CALLBACK CombView_MouseHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    #define PMHS ((MOUSEHOOKSTRUCT *)lParam)

    if ((nCode == HC_ACTION) && g_pdsvlvp && (PMHS->hwnd != HWNDLISTVIEW) && IsWindowVisible(HWNDLISTVIEW)) 
    {
        // If it isn't over the listview and the button is going down or we're
        // moving over an area that would hit a listview icon then
        // we need to start hooking mouse events.  Install the GetMessage hook
        // so that we can do what we need to do.
        HWND hwndParent = GetSpecialSibling(HWNDLISTVIEW);
        POINT ptLV = PMHS->pt;

        HWND hwndHittest = WindowFromPoint(PMHS->pt);

        ScreenToClient(HWNDLISTVIEW, &ptLV);
        int iHit = g_pdsvlvp->pdsv->_HitTest(&ptLV);
        ScreenToClient(hwndParent, &(PMHS->pt));

        BOOL fStealMouse = (ISMOUSEDOWN(wParam) && ShouldStealMouseClick(&(PMHS->pt), g_pdsvlvp)) ||
                           (!GetCapture() && (iHit != -1) && (!hwndHittest || (hwndHittest == HWNDLISTVIEW)));

        if (!g_pdsvlvp->hHookGetMsg) 
        {
            if (hwndHittest && (IsChildOrSelf(hwndParent, hwndHittest) == S_OK)) 
            {
                if (fStealMouse) 
                {
                    // Note:  We have to steal the mouse at this point and use the
                    // GetMessage hook to redirect the mouse messages to our listview
                    // window.  If we do something different like swallow the message here
                    // and then PostMessage faked up events to the listview then all
                    // of the hover select functionality will break because the system
                    // won't detect the mouse as being over the listview.
                    StealMouse(g_pdsvlvp, TRUE, (UINT) wParam);
                    g_pdsvlvp->hHookGetMsg = SetWindowsHookEx(WH_GETMESSAGE, CombView_GetMsgHook,
                                                NULL, GetCurrentThreadId());
                }
            }                                          
        }
        else
        {
            if (fStealMouse) 
                StealMouse(g_pdsvlvp, TRUE, (UINT) wParam);
            else
                SendMessage(HWNDLISTVIEW, WM_SETCURSOR, (WPARAM)HWNDLISTVIEW, MAKELPARAM(HTCLIENT, LOWORD((UINT) wParam)));
        }
    }

    if (g_pdsvlvp)
        return CallNextHookEx(g_pdsvlvp->hHookMouse, nCode, wParam, lParam);
    else
        return 0;

    #undef PMHS
}

/*
 * This is the main entry point where a defview can be turned into a combined
 * view.  The effect of a combined view is to layer an extended view under
 * the listview icons (via a regional listview) of a normal defview.
 *
 * Warnings:
 * 1) This is currently only used by the "Active Desktop", it is optimized
 * to only support one instance.  Multiple combined views are not currently supported.
 * 2) Disabling the combined view doesn't completely unhook itself from the defview
 */
void EnableCombinedView(CDefView *pdsv, BOOL fEnable)
{
    DVLVPROP * pdsvlvp = g_pdsvlvp;

    if (pdsvlvp) 
    {
        if (!fEnable) 
        {
            // Unhook ourselves
            UnhookWindowsHookEx(pdsvlvp->hHookMouse);
            if (pdsvlvp->hHookGetMsg) 
            {
                UnhookWindowsHookEx(pdsvlvp->hHookGetMsg);
                StealMouse(pdsvlvp, FALSE, 0);
            }
            g_pdsvlvp = NULL;
            RemoveWindowSubclass(pdsv->_hwndListview, CombView_LV_SubclassProc, COMBVIEW_SUBCLASS_ID);

            LocalFree((HLOCAL)pdsvlvp);
        }
    }
    else
    {
        if (fEnable) 
        {
            pdsvlvp = (DVLVPROP *)LocalAlloc(LPTR, sizeof(DVLVPROP));
            if (pdsvlvp) 
            {
                // We are only expecting one combined view
                ASSERT(g_pdsvlvp == NULL);

                // Get ourself hooked in
                pdsvlvp->pdsv = pdsv;
                SetWindowSubclass(pdsv->_hwndListview, CombView_LV_SubclassProc, COMBVIEW_SUBCLASS_ID, (DWORD_PTR)pdsvlvp);
                pdsvlvp->hHookMouse = SetWindowsHookEx(WH_MOUSE, CombView_MouseHook, NULL, GetCurrentThreadId());
                g_pdsvlvp = pdsvlvp;
            }
        }
    }
}

/*
 * This function is used to optimize the combined view ("Active Desktop") by turning
 * off any animated html elements or embeddings when it is completely obscured.
 *
 * Note that we always honor enabling animations if they aren't already enabled. 
 * To make the client code easier though we only disable animations if we know
 * the desktop is obscured.
 *
 * Returns: The state of animation after the call
 */
BOOL CombView_EnableAnimations(BOOL fEnable)
{
    static BOOL fEnabled = TRUE;

    if ((fEnable != fEnabled) && g_pdsvlvp)
    {
        IOleCommandTarget* pct;
        BOOL fChangeAnimationState = fEnable;

        if (!fEnable)
        {
            HDC hdc;
            RECT rc;
            HWND hwnd;

            if ((hwnd = GetSpecialSibling(HWNDLISTVIEW)) && (hdc = GetDC(hwnd)))
            {
                fChangeAnimationState = (GetClipBox(hdc, &rc) == NULLREGION);
                ReleaseDC(hwnd, hdc);
            }
        }

        if (fChangeAnimationState &&
            SUCCEEDED(g_pdsvlvp->pdsv->_psb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct))))
        {
            VARIANT var = { 0 };

            TraceMsg(DM_TRACE, "Active Desktop: Animation state is changing:%d", fEnable);

            var.vt = VT_I4;
            var.lVal = fEnable;
            pct->Exec(NULL, OLECMDID_ENABLE_INTERACTION, OLECMDEXECOPT_DONTPROMPTUSER, &var, NULL);
            pct->Release();
            fEnabled = fEnable;
        }
    }
    return fEnabled;
}

// IDocHostUIHandler
// This is implemented by the combined view so that we can support various
// Win95 desktop functionality in a compatible way in the extended view.
// Some examples include picking off context menu invocations, configuring the
// host to display the way we want it too, and modifying drag/drop behavior.

HRESULT CSFVSite::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    // For Web View's w/o DVOC, it might be nice to let Trident's menu through...
    if ((dwID == CONTEXT_MENU_DEFAULT || dwID == CONTEXT_MENU_IMAGE) && pView->_hwndListview) 
    {
        // we used to unselect everything first, but that's bogus because it breaks the app key trying
        // to get a context menu on the currently selected items
        
        // BOGUS - Trident blows up if we send the message here and the user
        // turns off webview.  Post it for now.
        PostMessage(pView->_hwndListview, WM_CONTEXTMENU,
            (WPARAM)pView->_hwndListview, MAKELPARAM((short)LOWORD(ppt->x), (short)LOWORD(ppt->y)));
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

// IDocHostUIHandler
HRESULT CSFVSite::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    pInfo->cbSize = sizeof(*pInfo);

    if (pView->_fCombinedView)
    {
        pInfo->dwFlags = DOCHOSTUIFLAG_DISABLE_HELP_MENU |  // We don't want Trident's help
                         DOCHOSTUIFLAG_NO3DBORDER |         // Desktop should be borderless
                         DOCHOSTUIFLAG_SCROLL_NO; // |          // Desktop should never scroll
                         // DOCHOSTUIFLAG_DIALOG;              // Prevent selection in Trident
    }
    else
    {
        pInfo->dwFlags = DOCHOSTUIFLAG_DISABLE_HELP_MENU |
                         DOCHOSTUIFLAG_DIALOG |
                         DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE;
    }

    if (SHIsLowMemoryMachine(ILMM_IE4))
        pInfo->dwFlags = pInfo->dwFlags | DOCHOSTUIFLAG_DISABLE_OFFSCREEN;
    
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;     // default
    return S_OK;
}

HRESULT CSFVSite::ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
                         IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc)
{
    // Host did not display its own UI. Trident will proceed to display its own. 
    return S_OK;
}

HRESULT CSFVSite::HideUI(void)
{
    // This one is paired with ShowUI
    return S_FALSE;
}

HRESULT CSFVSite::UpdateUI(void)
{
    // LATER: Isn't this equivalent to OLECMDID_UPDATECOMMANDS?
    return S_FALSE;
}

HRESULT CSFVSite::EnableModeless(BOOL fEnable)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CSFVSite::OnDocWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CSFVSite::OnFrameWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CSFVSite::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CSFVSite::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame.

    // Trap F5 alone and handle the refresh ourselves!
    // Note:This code-path will be hit for desktop only if the active desktop
    // is turned on.
    //
    // And probably if focus is on Trident. It's probably good to
    // pick this off for Web View too.
    //
    if ((lpMsg->message == WM_KEYDOWN) && (lpMsg->wParam == VK_F5))
    {
        CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
        CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

        pView->Refresh();

        return S_OK;
    }
    return S_FALSE; // The message was not translated
}

HRESULT CSFVSite::GetOptionKeyPath(BSTR *pbstrKey, DWORD dw)
{
    // Trident will default to its own user options.
    *pbstrKey = NULL;
    return S_FALSE;
}

HRESULT CSFVSite::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    HRESULT hr;

    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    if (!pView->_IsDesktop())
    {
        hr = S_FALSE;  // Let trident delegate in webview folders
    }
    else
    {
        if (_dt._pdtFrame == NULL) 
        {
            pView->_psb->QueryInterface(IID_PPV_ARG(IDropTarget, &_dt._pdtFrame));
        }

        if (_dt._pdtFrame) 
        {
            *ppDropTarget = &_dt;
            AddRef();

            hr = S_OK;
        }
        else
        {
            ASSERT(0);
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

HRESULT CSFVSite::GetExternal(IDispatch **ppDisp)
{
    HRESULT hr;

    if (ppDisp)
    {
        *ppDisp = NULL;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CSFVSite::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    HRESULT hr;

    if (ppchURLOut)
    {
        *ppchURLOut = NULL;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CSFVSite::FilterDataObject(IDataObject *pdtobj, IDataObject **ppdtobjRet)
{
    HRESULT hr;

    if (ppdtobjRet)
    {
        *ppdtobjRet = NULL;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\control.h ===
#ifdef __cplusplus
extern "C" {
#endif

#include <cpl.h>
#include "shell32p.h"

extern TCHAR const c_szCPLCache[];
extern TCHAR const c_szCPLData[];

// Structures used to enumerate CPLs.
//
typedef struct
{
    HDSA    haminst;        // MINST for each loaded dll
    
    HDSA    hamiModule;     // Array of MODULEINFOs of modules in system
    int     cModules;       // size of hamiModule
    
    LPBYTE  pRegCPLBuffer;  // Buffer for hRegCPLs (read from registry)
    HDPA    hRegCPLs;       // Array of RegCPLInfo structs from registry
    int     cRegCPLs;       // size of hRegCPLs
    BOOL    fRegCPLChanged; // TRUE iff hRegCPLs changed
} ControlData, *PControlData;

typedef struct
{
    LPTSTR  pszModule;      // Name of .cpl module
    LPTSTR  pszModuleName;  // points into pszModule to the name sans path
    
    BOOL    flags;          // MI_ flags defined below
    
    FILETIME ftCreationTime;// WIN32_FIND_DATA.ftCreationTime
    DWORD   nFileSizeHigh;  // WIN32_FIND_DATA.nFileSizeHigh
    DWORD   nFileSizeLow;   // WIN32_FIND_DATA.nFileSizeLow
} MODULEINFO, *PMODULEINFO;
// flags:
#define MI_FIND_FILE    1 // WIN32_FIND_FILE info filled in
#define MI_REG_ENUM     2 // Module already enumerated thru registry
#define MI_CPL_LOADED   4 // CPLD_InitModule called for this module
#define MI_REG_INVALID  8 // Cached info in registry is invalid

//
//  These values are larger than the NEWCPLINFO structure because some
//  languages (German, for example) can't fit "Scanners and Cameras" into
//  just 32 characters of NEWCPLINFO.szName, and even in English,
//  you can't fit very much helptext into only 64 characters of
//  NEWCPLINFO.szInfo.  (The Network applet writes a small novel for its
//  helptext.)
//
#define MAX_CCH_CPLNAME     MAX_PATH    // Arbitrary
#define MAX_CCH_CPLINFO     512         // Arbitrary


typedef struct
{
    UINT    cbSize;         // We write the first cbSize bytes of this
    // structure to the registry.  This saves about
    // 250 bytes per structure in the registry.
    BOOL    flags;
    
    // what file does this CPL come from?
    //      UINT    oFileName;      // file name // always 0, so don't need it
    FILETIME ftCreationTime;// WIN32_FIND_DATA.ftCreationTime
    DWORD   nFileSizeHigh;  // WIN32_FIND_DATA.nFileSizeHigh
    DWORD   nFileSizeLow;   // WIN32_FIND_DATA.nFileSizeLow
    
    // what's the display info for this CPL?
    int     idIcon;
    UINT    oName;          // (icon title) short name
    UINT    oInfo;          // (details view) description
    
    // buffer for information
    TCHAR   buf[MAX_PATH +  // oFileName
        MAX_CCH_CPLNAME +   // oName
        MAX_CCH_CPLINFO];   // oInfo
} REG_CPL_INFO;

// flags:
#define REGCPL_FROMREG     0x0001  // this REG_CPL_INFO was loaded from the registry
                                   // (used to optimize reading from registry)
#define REGCPL_POST_102001 0x0002  // Record created after October 2001.


// helper defines:
#define REGCPL_FILENAME(pRegCPLInfo) ((pRegCPLInfo)->buf)
#define REGCPL_CPLNAME(pRegCPLInfo)  (&((pRegCPLInfo)->buf[(pRegCPLInfo)->oName]))
#define REGCPL_CPLINFO(pRegCPLInfo)  (&((pRegCPLInfo)->buf[(pRegCPLInfo)->oInfo]))

// Information about control modules and individual controls
//
typedef struct // cpli
{
    int     idControl;      // control index
    HICON   hIcon;          // handle of icon
    int     idIcon;         // ID of the icon (used for links)
    LPTSTR  pszName;        // ptr to name string
    LPTSTR  pszInfo;        // ptr to info string
    LPTSTR  pszHelpFile;    // help file
    LONG_PTR lData;         // user supplied data
    DWORD   dwContext;      // help context
} CPLITEM, *LPCPLITEM;

typedef struct // minst
{
    HINSTANCE   hinst;          // either a 16 or 32 bit HINSTANCE (fIs16bit)
    DWORD       idOwner;        // process id of owner (system unique)
    HANDLE      hOwner;         // keeps id valid (against reuse)
} MINST;

typedef struct // cplm
{
    int             cRef;
    MINST           minst;
    TCHAR           szModule[MAX_PATH];
    union
    {
        APPLET_PROC lpfnCPL32;      // minst.fIs16bit=FALSE
        FARPROC     lpfnCPL;        // for opaque operation
    };
    HDSA            hacpli;         // array of CPLITEM structs
    HANDLE          hActCtx;
} CPLMODULE, *PCPLMODULE, *LPCPLMODULE;


LRESULT CPL_CallEntry(LPCPLMODULE, HWND, UINT, LPARAM, LPARAM);

void CPL_StripAmpersand(LPTSTR szBuffer);
BOOL CPL_Init(HINSTANCE hinst);
int _FindCPLModuleByName(LPCTSTR pszModule);

LPCPLMODULE CPL_LoadCPLModule(LPCTSTR szModule);
int CPL_FreeCPLModule(LPCPLMODULE pcplm);

void CPLD_Destroy(PControlData lpData);
BOOL CPLD_GetModules(PControlData lpData);
void CPLD_GetRegModules(PControlData lpData);
int CPLD_InitModule(PControlData lpData, int nModule, MINST *lphModule);
BOOL CPLD_AddControlToReg(PControlData lpData, const MINST * pminst, int nControl);
void CPLD_FlushRegModules(PControlData lpData);

STDAPI_(HRESULT) MakeCPLCommandLine(LPCTSTR pszModule, LPCTSTR pszName, LPTSTR pszCommandLine, DWORD cchCommandLine);

HRESULT CALLBACK CControls_DFMCallBackBG(LPSHELLFOLDER psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
IShellFolderViewCB* Controls_CreateSFVCB(IShellFolder* psf, LPCITEMIDLIST pidl);

LPCPLMODULE FindCPLModule(const MINST * pminst);

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\contextmenu.h ===
// An IContextMenu on an array of context menus
HRESULT Create_ContextMenuOnContextMenuArray(IContextMenu* rgpcm[], UINT cpcm, REFIID riid, void** ppv);


// An IContextMenu on an existing HMENU
// NOTE: always takes ownership of the HMENU (in success and failure)
HRESULT Create_ContextMenuOnHMENU(HMENU hmenu, HWND hwndOwner, REFIID riid, void** ppv);


// An IContextMenu on an existing IContextMenu, which removes the ';'-separated list of verbs from the resulting menu
HRESULT Create_ContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList, REFIID riid, void **ppv);


// CContextMenuForwarder is designed as a base class that forwards all
// context menu stuff to another IContextMenu implementation.  You override
// whatever functions you want to modify.  (Like QueryContextMenu - delegate then modify the results)
// For example, CContextMenuWithoutVerbs inherits from this class.
//
class CContextMenuForwarder : IContextMenu3, IObjectWithSite
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenu3
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags) { return _pcm->QueryContextMenu(hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags); }
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici) { return _pcm->InvokeCommand(lpici); }
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax) { return _pcm->GetCommandString(idCmd,uType,pwReserved,pszName,cchMax); }

    // IContextMenu2
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam) { return _pcm2->HandleMenuMsg(uMsg,wParam,lParam); }

    // IContextMenu3
    STDMETHODIMP HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult) { return _pcm3->HandleMenuMsg2(uMsg,wParam,lParam,plResult); }

    // IObjectWithSite
    STDMETHOD(SetSite)(IUnknown *punkSite) { return _pows->SetSite(punkSite); }
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite) { return _pows->GetSite(riid,ppvSite); }

protected:
    CContextMenuForwarder(IUnknown* punk);
    virtual ~CContextMenuForwarder();

private:
    LONG _cRef;

protected:
    IUnknown*        _punk;

    IObjectWithSite* _pows;
    IContextMenu*    _pcm;
    IContextMenu2*   _pcm2;
    IContextMenu3*   _pcm3;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\copyfgd.cpp ===
/*****************************************************************************\
    FILE: copyfgd.cpp

    DESCRIPTION:
        Copy a FileGroupDescriptor.
\*****************************************************************************/

#include "shellprv.h"

#include <ynlist.h>
#include "ids.h"
#include "pidl.h"
#include "fstreex.h"
#include "copy.h"
#include <shldisp.h>
#include <shlwapi.h>
#include <wininet.h>    // InternetGetLastResponseInfo
#include "ynlist.h"
#include "datautil.h"

class CCopyThread;
HRESULT CreateInstance_CopyThread(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, DWORD *pdwEffect, BOOL fIsBkDropTarget, CCopyThread ** ppct);

extern "C" {
    #include "undo.h"
    #include "defview.h"
};

BOOL GetWininetError(DWORD dwError, BOOL fCopy, LPTSTR pszErrorMsg, DWORD cchSize)
{
    TCHAR szErrorMsg[MAX_PATH];
    BOOL fIsWininetError = ((dwError >= INTERNET_ERROR_BASE) && (dwError <= INTERNET_ERROR_LAST));

    // Default message if FormatMessage doesn't recognize hres
    szErrorMsg[0] = 0;
    LoadString(HINST_THISDLL, (fCopy ? IDS_COPYERROR : IDS_MOVEERROR), szErrorMsg, ARRAYSIZE(szErrorMsg));

    BOOL fCopyOut = TRUE;
    if (fIsWininetError)
    {
        static HINSTANCE s_hinst = NULL;

        if (!s_hinst)
            s_hinst = GetModuleHandle(TEXT("WININET")); // It's okay if we leak it.

        // Can wininet give us extended error messages?
        // We ignore them because it's too late to call InternetGetLastResponseInfo.
        if (ERROR_INTERNET_EXTENDED_ERROR != dwError)
        {
            DWORD dwResult;
            TCHAR szDetails[MAX_PATH*2];

            dwResult = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, (LPCVOID)s_hinst, dwError, 0, szDetails, ARRAYSIZE(szDetails), NULL);
            if (dwResult != 0)
            {
                HRESULT hr = StringCchCat(szErrorMsg, ARRAYSIZE(szErrorMsg), TEXT("%s"));

                if (SUCCEEDED(hr))
                {
                    hr = StringCchPrintf(pszErrorMsg, cchSize, szErrorMsg, szDetails);
                    if (SUCCEEDED(hr))
                    {
                        fCopyOut = FALSE;
                    }
                }
            }
        }
    }

    if (fCopyOut)
    {
        StringCchCopy(pszErrorMsg, cchSize, szErrorMsg);
    }

    return TRUE;
}


// thunk A/W funciton to access A/W FILEGROUPDESCRIPTOR
// this relies on the fact that the first part of the A/W structures are
// identical. only the string buffer part is different. so all accesses to the
// cFileName field need to go through this function.
//

FILEDESCRIPTOR *GetFileDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, int nIndex, LPTSTR pszName)
{
    if (fUnicode)
    {
        // Yes, so grab the data because it matches.
        FILEGROUPDESCRIPTORW * pfgdW = (FILEGROUPDESCRIPTORW *)pfgd;    // cast to what this really is

        // If the filename starts with a leading / we're going to be in trouble, since the rest
        // of the code assumes its going to be a \.  Web folders does the leading /, so just lop it
        // off right here.

        WCHAR *pwz = pfgdW->fgd[nIndex].cFileName;
        if (pfgdW->fgd[nIndex].cFileName[0] == '/')
        {
            memmove(pwz, pwz+1, sizeof(pfgdW->fgd[nIndex].cFileName) - sizeof(WCHAR));
        }

        // Now flip all the /'s to \'s.  No dbcs issues, we're unicode!
        for (; *pwz; ++pwz)
        {
            if (*pwz == '/')
            {
                *pwz = '\\';
            }
        }

        if (pszName)
            SHUnicodeToTChar(pfgdW->fgd[nIndex].cFileName, pszName, MAX_PATH);

        return (FILEDESCRIPTOR *)&pfgdW->fgd[nIndex];   // cast assume the non string parts are the same!
    }
    else
    {
        FILEGROUPDESCRIPTORA *pfgdA = (FILEGROUPDESCRIPTORA *)pfgd;     // cast to what this really is

        if (pfgdA->fgd[nIndex].cFileName[0] == '/' &&
            CharNextA(pfgdA->fgd[nIndex].cFileName) == pfgdA->fgd[nIndex].cFileName+1)
        {
            memmove (pfgdA->fgd[nIndex].cFileName, pfgdA->fgd[nIndex].cFileName+1, sizeof(pfgdA->fgd[nIndex].cFileName)-sizeof(char));
        }

        if (pszName)
            SHAnsiToTChar(pfgdA->fgd[nIndex].cFileName, pszName, MAX_PATH);

        return (FILEDESCRIPTOR *)&pfgdA->fgd[nIndex];   // cast assume the non string parts are the same!
    }
}


void CreateProgressStatusStr(LPCTSTR pszDirTo, LPWSTR pwzProgressStr, DWORD cchSize)
{
    // IDS_COPYTO also works in move operations. (It doesn't use the work "Copy")
    LPTSTR pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_COPYTO), pszDirTo);

    if (pszMsg)
    {
        SHTCharToUnicode(pszMsg, pwzProgressStr, cchSize);
        LocalFree(pszMsg);
    }
    else
        pwzProgressStr[0] = 0;
}


void CalcBytesInFileGrpDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, ULARGE_INTEGER * puliTotal)
{
    puliTotal->QuadPart = 0; // Init.
    for (UINT i = 0; i < pfgd->cItems; i++)
    {
        // WARNING: This may point to a FILEDESCRIPTOR *A or W, but that's ok as long as we ignore the filename.
        ULARGE_INTEGER uliFileSize;
        FILEDESCRIPTOR *pfd = GetFileDescriptor(pfgd, fUnicode, i, NULL);

        if (pfd->dwFlags & FD_FILESIZE)
        {
            uliFileSize.HighPart = pfd->nFileSizeHigh;
            uliFileSize.LowPart = pfd->nFileSizeLow;
            puliTotal->QuadPart += uliFileSize.QuadPart;
        }
    }
}

BOOL IsNameInDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, LPCTSTR pszName, UINT iMax)
{
    for (UINT i = 0; i < iMax; i++)
    {
        TCHAR szName[MAX_PATH];
        // WARNING: This may point to a FILEDESCRIPTOR *A or W, but that's ok as long as we ignore the filename.
        FILEDESCRIPTOR *pfd = GetFileDescriptor(pfgd, fUnicode, i, szName);
        if (lstrcmpi(szName, pszName) == 0)
            return TRUE;
    }
    return FALSE;
}


BOOL ShowProgressUI(FILEGROUPDESCRIPTOR *pfgd)
{
    return (0 < pfgd->cItems) && (FD_PROGRESSUI & pfgd->fgd->dwFlags);
}


class CCopyThread
                : public IUnknown
{
public:
    // *** IUnknown ***
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);

    HRESULT DoCopy(void) {return _DoCopy(_pdtobj);};
    HRESULT DoAsynchCopy(void);
    HRESULT GetEffect(DWORD *pdwEffect) {*pdwEffect = _dwEffect; return S_OK;}; // For synchronous case only.

    friend HRESULT CreateInstance_CopyThread(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, DWORD *pdwEffect, BOOL fIsBkDropTarget, CCopyThread ** ppct);

protected:
    CCopyThread(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, DWORD *pdwEffect, BOOL fIsBkDropTarget);
    ~CCopyThread();

private:
    HRESULT _CopyThreadProc(void);
    static DWORD CALLBACK CopyThreadProc(void *pvThis) { return ((CCopyThread *) pvThis)->_CopyThreadProc(); };
    HRESULT _DoCopy(IDataObject * pdo);

    LONG                _cRef;

    HWND                _hwnd;
    LPCTSTR             _pszPath;
    IDataObject *       _pdtobj;        // Unmarshalled
    IStream *           _pstmDataObjMarshal;  // Carrying the IDataObject across threads
    DWORD               _dwEffect;
    BOOL                _fWindowIsTarget;
};


CCopyThread::CCopyThread(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, DWORD *pdwEffect, BOOL fIsBkDropTarget) : _cRef(1)
{
    DllAddRef();

    // Assert this class was zero inited.
    ASSERT(!_pdtobj);
    ASSERT(!_pstmDataObjMarshal);
    ASSERT(!_dwEffect);
    ASSERT(!_hwnd);
    ASSERT(!_pszPath);

    _hwnd = hwnd;

    // If we are dropping onto the background of the window, we can assume that the window we
    // are passed is the target window of the copy.
    _fWindowIsTarget = fIsBkDropTarget;

    Str_SetPtr((LPTSTR *) &_pszPath, pszPath);
    IUnknown_Set((IUnknown **)&_pdtobj, (IUnknown *)pdtobj);

    // The caller doesn't get the return value in pdwEffect because it happens on a background thread.
    // take these out of this because we don't want a cancel operation to not make it back to a caller
    // and have them delete the files anyway.  We also need to make sure moves are done in such a way that the
    // destination (us) moves the files and not the caller.  This is the caller will return from ::Drop() before
    // the files finish copying (moving).
    _dwEffect = *pdwEffect;
}


CCopyThread::~CCopyThread()
{
    IUnknown_Set((IUnknown **)&_pdtobj, NULL);
    IUnknown_Set((IUnknown **)&_pstmDataObjMarshal, NULL);
    Str_SetPtr((LPTSTR *) &_pszPath, NULL);

    DllRelease();
}

HRESULT CCopyThread::DoAsynchCopy(void)
{
    HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, _pdtobj, &_pstmDataObjMarshal);
    if (SUCCEEDED(hr))
    {
        IUnknown_Set((IUnknown **)&_pdtobj, NULL);

        AddRef();   // pass to thread

        if (SHCreateThread(CCopyThread::CopyThreadProc, this, CTF_COINIT, NULL))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            Release();  // thread did not take, we need to release
        }
    }

    return hr;
}

HRESULT CCopyThread::_CopyThreadProc(void)
{
    IDataObject * pdo;
    HRESULT hr = CoGetInterfaceAndReleaseStream(_pstmDataObjMarshal, IID_PPV_ARG(IDataObject, &pdo));

    _pstmDataObjMarshal = NULL; // CoGetInterfaceAndReleaseStream() released the ref.
    if (S_OK == hr)
    {
        hr = _DoCopy(pdo);

        IAsyncOperation * pao;
        if (SUCCEEDED(pdo->QueryInterface(IID_PPV_ARG(IAsyncOperation, &pao))))
        {
            pao->EndOperation(hr, NULL, _dwEffect);
            pao->Release();
        }

        pdo->Release();
    }

    Release();      // Releae the background thread's ref.
    return hr;
}


HRESULT ConvertCallerFDToTCharFD(const FILEDESCRIPTOR * pfdSource, BOOL fUnicode, FILEDESCRIPTOR * pfdDest)
{
#ifdef UNICODE
    if (fUnicode)
    {
        *pfdDest = *pfdSource;
    }
    else
    {
        // pfdSource is really ansi.
        const FILEDESCRIPTORA * pfdSourceA = (const FILEDESCRIPTORA *) pfdSource;

        // We need to convert, so copy the small part.
        *(FILEDESCRIPTORA *)pfdDest = *pfdSourceA;
        SHAnsiToUnicode(pfdSourceA->cFileName, pfdDest->cFileName, ARRAYSIZE(pfdDest->cFileName));
    }
#else // UNICODE
    if (fUnicode)
    {
        // pfdSource is really unicode.
        const FILEDESCRIPTORW * pfdSourceW = (const FILEDESCRIPTORW *) pfdSource;

        // We need to convert, so copy the small part.
        *(FILEDESCRIPTORA *)pfdDest = *(const FILEDESCRIPTORA *)pfdSource;
        SHUnicodeToAnsi(pfdSourceW->cFileName, pfdDest->cFileName, ARRAYSIZE(pfdDest->cFileName));
    }
    else
    {
        *pfdDest = *pfdSource;
    }
#endif // UNICODE

    return S_OK;
}


BOOL IsWininetHRESULT(IN HRESULT hr)
{
    // One way to tell if the error is from wininet is to check for the FACILITY_INTERNET
    // facility.
    BOOL fIsWininet = (FACILITY_INTERNET == HRESULT_FACILITY(hr));
    DWORD dwError = HRESULT_CODE(hr);

    // However, sometimes that facility won't be set but it will still be a wininet error.
    if (!fIsWininet &&
        (FACILITY_WIN32 == HRESULT_FACILITY(hr)) &&
        ((dwError >= INTERNET_ERROR_BASE) && (dwError <= INTERNET_ERROR_LAST)))
    {
        // Win #147295.  The root of the problem is that an API that returns a dwError can only
        // return error numbers in one FACILITY.  However, wininet APIs will return error values
        // in the FACILITY_INTERNET facility (ERROR_INTERNET_* which is 12000 to INTERNET_ERROR_LAST)
        // AND from the FACILITY_WIN32 facility (like ERROR_NO_MORE_FILES).  Therefore the caller
        // can't just blindly set the FACILITY_INTERNET facility when converting the dwError to an
        // HRESULT.
        //
        // If wininet was smart, they would just use the WIN32 facility since they reserved the 12000
        // range.
        fIsWininet = TRUE;
    }

    return fIsWininet;
}


// Puts up a message box if necessary.
// we don't want to see any error with FACILITY_ITF, since we
// can't make sense of those errors anyway.
void MessageBoxIfNecessary(HRESULT hr, DWORD dwEffect, HWND hwndDlgParent)
{
    TCHAR szTitle[MAX_PATH];
    LoadString(HINST_THISDLL, ((DROPEFFECT_COPY == dwEffect) ? IDS_FILEERRORCOPY : IDS_FILEERRORCOPY), szTitle, ARRAYSIZE(szTitle));

    if (IsWininetHRESULT(hr))
    {
        TCHAR szErrorMsg[MAX_PATH];

        if (GetWininetError(HRESULT_CODE(hr), (DROPEFFECT_COPY == dwEffect),
                            szErrorMsg, ARRAYSIZE(szErrorMsg)))
        {
            MessageBox(hwndDlgParent, szErrorMsg, szTitle, (MB_ICONERROR | MB_OK | MB_SYSTEMMODAL));
        }
    }
    else if (HRESULT_FACILITY(hr) != FACILITY_ITF)
    {
        // dont display an error if caused by a user cancel.
        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
        {
            TCHAR szErrorMsg[MAX_PATH];

            if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                              NULL, HRESULT_CODE(hr),
                              0L, szErrorMsg, ARRAYSIZE(szErrorMsg), NULL))
            {
                MessageBox(hwndDlgParent, szErrorMsg, szTitle, (MB_ICONERROR | MB_OK | MB_SYSTEMMODAL));
            }
        }
    }
    // All other errors don't make any sense to the user, so don't put
    // up any UI.
}


HRESULT CCopyThread::_DoCopy(IDataObject * pdo)
{
    HRESULT hr = S_OK;
    FORMATETC fmteA = {g_cfFileGroupDescriptorA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC fmteW = {g_cfFileGroupDescriptorW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC fmteOffset = {g_cfOFFSETS, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM mediumFGD = {0}, mediumOffset = {0};
    BOOL fUnicode = FALSE;
    PROGRESSINFO progInfo = {0};

    // We should have only one bit set.
    ASSERT(_dwEffect==DROPEFFECT_COPY || _dwEffect==DROPEFFECT_LINK || _dwEffect==DROPEFFECT_MOVE);

    // Display the progress now because pdo->GetData may be slow, especially if we have to call it
    // twice.IDA_FILEMOVE
    progInfo.ppd = CProgressDialog_CreateInstance(((DROPEFFECT_COPY == _dwEffect) ? IDS_ACTIONTITLECOPY : IDS_ACTIONTITLEMOVE), ((DROPEFFECT_COPY == _dwEffect) ? IDA_FILECOPY : IDA_FILEMOVE), g_hinst);
    if (progInfo.ppd)
    {
        WCHAR wzCalcTime[MAX_PATH];

        progInfo.uliBytesCompleted.QuadPart = progInfo.uliBytesTotal.QuadPart = 0;
        progInfo.ppd->StartProgressDialog(_hwnd, NULL, PROGDLG_AUTOTIME, NULL);
        
        LoadStringW(HINST_THISDLL, ((DROPEFFECT_COPY == _dwEffect) ? IDS_CALCCOPYTIME : IDS_CALCMOVETIME), wzCalcTime, ARRAYSIZE(wzCalcTime));
        progInfo.ppd->SetLine(2, wzCalcTime, FALSE, NULL);
    }


    // First try to massage the IDataObject into a virtual storage that we can use as the
    // source of a storage engine copy

    bool bPerformManually = true;

    if (bPerformManually)
    {
        // Try for UNICODE group descriptor first.  If that succeeds, we won't bother trying to
        // ASCII since UNICODE is the "preferred" format.  For ANSI builds, we only try for ANSI
        hr = pdo->GetData(&fmteW, &mediumFGD);
        if (SUCCEEDED(hr))
            fUnicode = TRUE;
        else
            hr = pdo->GetData(&fmteA, &mediumFGD);

        if (SUCCEEDED(hr))
        {
            UINT i, iConflict = 1;
            UINT iTopLevelItem = 0;
            YNLIST ynl;
            DROPHISTORY dh = {0};

            // WARNING: pfgd is really an A or W struct. to deal with this all code needs to use
            // the GetFileDescriptor() function

            FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalLock(mediumFGD.hGlobal);  
            DECLAREWAITCURSOR;

            SetWaitCursor();
            BOOL fCantUseDialogHWND = FALSE;
            if (progInfo.ppd)
            {
                CalcBytesInFileGrpDescriptor(pfgd, fUnicode, &progInfo.uliBytesTotal);
                // We displayed progress above because pdo->GetData() and CalcBytesInFileGrpDescriptor are slow, but most likely it
                // was just eating into the delay time before the progress appears.  If the caller
                // didn't want UI, we will close it down now.
                if (!ShowProgressUI(pfgd))
                {
                    progInfo.ppd->StopProgressDialog();
                    fCantUseDialogHWND = TRUE;
                }
                else
                    progInfo.ppd->Timer(PDTIMER_RESET, NULL);
            }

            CreateYesNoList(&ynl);

            // Try & get the offsets too.
            HRESULT hrOffset = pdo->GetData(&fmteOffset, &mediumOffset);
            if (SUCCEEDED(hrOffset))
            {
                dh.pptOffset = (POINT *)GlobalLock(mediumOffset.hGlobal);
                dh.pptOffset++;  // First item is the anchor
            }

            for (i = 0; i < pfgd->cItems; i++)
            {
                BOOL fTopLevel;
                TCHAR szFullPath[MAX_PATH], szFileName[MAX_PATH];
                FILEDESCRIPTOR *pfd = GetFileDescriptor(pfgd, fUnicode, i, szFileName);
                HRESULT hr;

                hr = StringCchCopy(szFullPath, ARRAYSIZE(szFullPath), _pszPath);
                if (FAILED(hr))
                {
                    // skip files which might cause problems
                    continue;
                }

                // if the source gave us duplicate file names we make them unique here
                // foo (1).txt, foo (2).txt, etc
                // name conflicts with targets still get the replace file confirm UI
                if (IsNameInDescriptor(pfgd, fUnicode, szFileName, i))
                {
                    TCHAR szBuf[MAX_PATH], *pszExt = PathFindExtension(szFileName);

                    hr = StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT(" (%d)%s"), iConflict++, pszExt);  // " (xxx).msg"
                    if (FAILED(hr))
                    {
                        // skip files which might cause problems
                        continue;
                    }

                    // make sure it will fit
                    if (((int)ARRAYSIZE(szFileName) - lstrlen(szFileName)) > (lstrlen(szBuf) - lstrlen(pszExt))) 
                    {
                        hr = StringCchCopy(pszExt, szFileName + ARRAYSIZE(szFileName) - pszExt, szBuf);
                        if (FAILED(hr))
                        {
                            // skip files which might cause problems
                            continue;
                        }

                    }
                }

                // do PathCleanupSpec on the filespec part of the filename because names
                // can be relative paths "Folder\foo.txt", "Folder\Folder2\foo.txt"
                PathCleanupSpec(szFullPath, PathFindFileName(szFileName));

                // the filename in the descriptor should not be a fully qualified path
                if (PathIsRelative(szFileName))
                {
                    if (!PathAppend(szFullPath, szFileName))
                    {
                        // skip files which might cause problems
                        continue;
                    }
                    fTopLevel = (StrChr(szFileName, TEXT('\\')) == NULL &&
                                    StrChr(szFileName, TEXT('/')) == NULL);
                }
                else
                {
                    TraceMsg(TF_WARNING, "CopyFGD: FGD contains full path - ignoring path");
                    if (!PathAppend(szFullPath, PathFindFileName(szFileName)))
                    {
                        // skip files which might cause problems
                        continue;
                    }
                    fTopLevel = TRUE;
                }

                if (IsInNoList(&ynl, szFullPath))
                {
                    continue;
                }

                HWND hwndDlgParent;
                if (fCantUseDialogHWND || FAILED(IUnknown_GetWindow(progInfo.ppd, &hwndDlgParent)))
                {
                    hwndDlgParent = _hwnd;
                }

                BOOL fDirectory = (pfd->dwFlags & FD_ATTRIBUTES) && (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);

                // NOTE: SHPathPrepareForWrite() was moved here to insure that we check for replace operations
                // against a real directory (not an empty a: drive, for example).  However, the result is not checked
                // until later - make sure that we don't overwrite 'hr' between here and there.
                hr = SHPathPrepareForWrite(hwndDlgParent, NULL, szFullPath, SHPPFW_DEFAULT | SHPPFW_IGNOREFILENAME);

                FILEDESCRIPTOR fd = {0};

                ConvertCallerFDToTCharFD(pfd, fUnicode, &fd);
                switch (ValidateCreateFileFromClip(hwndDlgParent, &fd, szFullPath, &ynl))
                {
                case IDYES:
                    break;

                case IDNO:
                    // mil bug 127038
                    // when somebody says "no don't overwrite", we don't want the performed
                    // drop effect to get set to DROPEFFECT_MOVE, so we set it to DROPEFFECT_NONE
                    // here.
                    _dwEffect = 0;
                    continue;

                case IDCANCEL:
                    // NOTE: This doesn't do anything because the caller never gets this back
                    //       in the asynch case.
                    _dwEffect = 0;
                    i = (int)pfgd->cItems - 1;
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    continue;
                }

                if (progInfo.ppd)
                {
                    WCHAR wzFileName[MAX_PATH];
                    WCHAR wzTemplateStr[MAX_PATH];
                    WCHAR wzProgressStr[MAX_PATH];

                    if (DROPEFFECT_COPY == _dwEffect)
                        LoadStringW(HINST_THISDLL, IDS_COPYING, wzTemplateStr, ARRAYSIZE(wzTemplateStr));
                    else
                        LoadStringW(HINST_THISDLL, IDS_MOVING, wzTemplateStr, ARRAYSIZE(wzTemplateStr));

                    // Display "Copying 'filename'" or "Moving 'filename'" on line 1
                    SHTCharToUnicode(szFileName, wzFileName, ARRAYSIZE(wzFileName));

                    StringCchPrintf(wzProgressStr, ARRAYSIZE(wzProgressStr), wzTemplateStr, wzFileName);    // ok to truncate
                    progInfo.ppd->SetLine(1, wzProgressStr, FALSE, NULL);

                    // Display the dir on line 2
                    CreateProgressStatusStr(_pszPath, wzProgressStr, ARRAYSIZE(wzProgressStr));
                    progInfo.ppd->SetLine(2, wzProgressStr, FALSE, NULL);
                }


                if (fDirectory)
                {
                    // Call SHPathPrepareForWrite() again without SHPPFW_IGNOREFILENAME so that it
                    // will create the directory if it doesn't already exist.
                    hr = SHPathPrepareForWrite(hwndDlgParent, NULL, szFullPath, SHPPFW_DEFAULT);
                
                    if (FAILED(hr))
                    {
                        // NOTE: This doesn't do anything because the caller never gets this back
                        //       in the asynch case.
                        _dwEffect = 0;
                        break;
                    }
                }
                else
                {
                    // We want to prepare the path both before and after errors in order to catch different cases.
                
                    // NOTE: We should be checking the result of SHPathPrepareForWrite() here
                    if (SUCCEEDED(hr))
                    {
                        hr = DataObj_SaveToFile(pdo, g_cfFileContents, i, szFullPath, pfd, &progInfo);
                    }

                    if (FAILED(hr))
                    {
                        MessageBoxIfNecessary(hr, _dwEffect, hwndDlgParent);

                        // NOTE: This doesn't do anything because the caller never gets this back
                        //       in the asynch case.
                        _dwEffect = 0;
                        break;
                    }
                }

                // Only position item if it was created successfully
                // and it is not tucked in a subdir.

                // The last condition is because there is some confusion about whether _hwnd is the
                // target window of the copy or not. If it is, we should tell the window
                // to position the item we just dropped.
                if (SUCCEEDED(hr) && fTopLevel && _fWindowIsTarget)
                {
                    dh.iItem = iTopLevelItem;

                    if (SUCCEEDED(hrOffset) && dh.pptOffset)
                    {
                        // need to range check the points in case # of items in the list does not match the #
                        // of points. this happens when defview does not know the right number of items
                        // in the data object.
                        SIZE_T cbSize = GlobalSize(mediumOffset.hGlobal);
                        if (((dh.iItem + 1) * sizeof(dh.pptOffset[0])) > cbSize)
                        {
                            dh.pptOffset = NULL;
                            ReleaseStgMediumHGLOBAL(NULL, &mediumOffset);
                            hrOffset = E_FAIL;    // for test below
                        }
                    }

                    PositionFileFromDrop(_hwnd, szFullPath, &dh);
                    iTopLevelItem++;
                }

                if (progInfo.ppd)
                {
                    ULARGE_INTEGER uliFileSize;
                    uliFileSize.HighPart = pfd->nFileSizeHigh;
                    uliFileSize.LowPart = pfd->nFileSizeLow;
                    progInfo.uliBytesCompleted.QuadPart += uliFileSize.QuadPart;
                    progInfo.ppd->SetProgress64(progInfo.uliBytesCompleted.QuadPart, progInfo.uliBytesTotal.QuadPart);

                    if (progInfo.ppd->HasUserCancelled())
                        break;   // Cancel the copy.
                }
            }

            DestroyYesNoList(&ynl);

            if (SUCCEEDED(hrOffset))
                ReleaseStgMediumHGLOBAL(NULL, &mediumOffset);

            ResetWaitCursor();
            ReleaseStgMediumHGLOBAL(pfgd, &mediumFGD);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Inform the caller of what we did.  We don't do optimized moves
        // so the caller is responsible for the delete half of the move and
        // this is now we notify them of that.
        DataObj_SetDWORD(pdo, g_cfPerformedDropEffect, _dwEffect);
        DataObj_SetDWORD(pdo, g_cfLogicalPerformedDropEffect, _dwEffect);
    }

    if (progInfo.ppd)
    {
        progInfo.ppd->StopProgressDialog();
        progInfo.ppd->Release();
    }

    return hr;
}


//===========================
// *** IUnknown Interface ***
HRESULT CCopyThread::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CCopyThread, IUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CCopyThread::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CCopyThread::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CreateInstance_CopyThread(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, DWORD *pdwEffect, BOOL fIsBkDropTarget, CCopyThread ** ppct)
{
    *ppct = new CCopyThread(hwnd, pszPath, pdtobj, pdwEffect, fIsBkDropTarget);
    return (*ppct ? S_OK : E_FAIL);
}

/*****************************************************************************\
        We know that the IDataObject (pdo) supports the CF_FILEGROUPDESCRIPTOR
    clipboard format, so copy that data to the file system directory pszPath.
    The caller will want to know if this completed or if it was cancelled or
    errored out.  This result will come in the DROPEFFECT out param (pdwEffect).
    Zero (0) will indicate either error or cancel and this code will take care
    of displaying error messages.
\*****************************************************************************/
HRESULT CFSFolder_AsyncCreateFileFromClip(HWND hwnd, LPCTSTR pszPath, IDataObject *pdo, 
                                          POINTL pt, DWORD *pdwEffect, BOOL fIsBkDropTarget)
{
    CCopyThread * pct;
    HRESULT hr = CreateInstance_CopyThread(hwnd, pszPath, pdo, pdwEffect, fIsBkDropTarget, &pct);
    if (SUCCEEDED(hr))
    {
        if (DataObj_CanGoAsync(pdo))
            hr = pct->DoAsynchCopy();
        else
            hr = pct->DoCopy();

        pct->Release();
    }

    if (FAILED(hr))
        *pdwEffect = DROPEFFECT_NONE;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\copy.c ===
// Copyright (c) <1995-1999> Microsoft Corporation

#include "shellprv.h"
#pragma  hdrstop

#include <msi.h>
#include <msip.h>

#include <aclapi.h>     // for TreeResetNamedSecurityInfo

#include "shlwapip.h" // for SHGlobalCounterDecrement
#include "ynlist.h"

#define INTERNAL_COPY_ENGINE
#include "copy.h"
#include "shell32p.h"
#include "control.h"
#include "cdburn.h"
#include "propsht.h"
#include "prshtcpp.h"

#define REG_VAL_GENERAL_RENAMEHTMLFILE  TEXT("RenameHtmlFile")

#define TF_DEBUGCOPY 0x00800000

#define VERBOSE_STATUS

// REVIEW, we should tune this size down as small as we can
// to get smoother multitasking (without effecting performance)
#define COPYMAXBUFFERSIZE       0x10000 // 0xFFFF this is 32-bit code!
#define MIN_MINTIME4FEEDBACK    5       // is it worth showing estimated time to completion feedback?
#define MS_RUNAVG               10000   // ms, window for running average time to completion estimate
#define MS_TIMESLICE             2000    // ms, (MUST be > 1000!) first average time to completion estimate

#define MAXDIRDEPTH             128     // # of directories we will deal with recursivly

#define SHOW_PROGRESS_TIMEOUT   1000    // 1 second
#define MINSHOWTIME             1000    // 1 sec

// progress dialog message
#define PDM_SHUTDOWN     WM_APP
#define PDM_NOOP        (WM_APP + 1)
#define PDM_UPDATE      (WM_APP + 2)


#define OPER_MASK           0x0F00
#define OPER_ENTERDIR       0x0100
#define OPER_LEAVEDIR       0x0200
#define OPER_DOFILE         0x0300
#define OPER_ERROR          0x0400

#define FOFuncToStringID(wFunc) (IDS_UNDO_FILEOP + wFunc)

//
//  The following is a list of folder suffixes in all international languages. This list is NOT
// read from a resource because we do NOT want the strings in this list to be mistakenly localized.
// This list will allow NT5 shell to operate on files created by any international version of 
// office 9.
//  This list is taken from "http://officeweb/specs/webclient/files.htm"
//
//  WARNING: Do not localize the strings in this table. Do not make any changes to this table 
//  without consulting AlanRa (Office9 PM)
//
static const LPCTSTR c_apszSuffixes[] = 
{
    TEXT(".files"),
    TEXT("_files"),
    TEXT("-Dateien"),
    TEXT("_fichiers"),
    TEXT("_bestanden"),
    TEXT("_file"),
    TEXT("_archivos"),
    TEXT("-filer"),
    TEXT("_tiedostot"),
    TEXT("_pliki"),
    TEXT("_soubory"),
    TEXT("_elemei"),
    TEXT("_ficheiros"),
    TEXT("_arquivos"),
    TEXT("_dosyalar"),
    TEXT("_datoteke"),
    TEXT("_fitxers"),
    TEXT("_failid"),
    TEXT("_fails"),
    TEXT("_bylos"),
    TEXT("_fajlovi"),
    TEXT("_fitxategiak"),
};

// The reg value under HKCU\REGSTR_PATH_EXPLORER that specifies Connection ON/OFF switch
#define REG_VALUE_NO_FILEFOLDER_CONNECTION  TEXT("NoFileFolderConnection")

////////////////////////////////////////////////////////////////////////////
///// directory tree cache.


// this is set if pdtnChild has not been traversed (as opposed to NULL which means
// there are no children
#define DTN_DELAYED ((PDIRTREENODE)-1)


// DIRTREENODE is a node in a linked list/tree cache of the directory structure.
// except for the top level (which is specified by the caller of the api), the order
// are all files first, then all directories.

typedef struct _dirtreenode {

    struct _dirtreenode *pdtnNext; // sibling
    struct _dirtreenode *pdtnChild; // head of children linked list
    struct _dirtreenode *pdtnParent;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeLow;
    DWORD nFileSizeHigh;

    LARGE_INTEGER liFileSizeCopied;
    BOOL  fNewRoot : 1;
    BOOL  fDummy : 1;   // this marks the node as a dummy node (a wildcard that didn't match anything)
    BOOL  fConnectedElement : 1; // this marks the node as an element that was implicitly added
    // to the Move/Copy source list because of an office9 type of
    // connection established in the registry.

    //The following is a union because not all nodes need all the fields.
    union {
        // The following is valid only if fConnectedElement is FALSE.
        struct  _dirtreenode *pdtnConnected;  

        // The following structure is valid only if fConnectedElemet is TRUE.
        struct  {
            LPTSTR  pFromConnected;     // if fNewRoot && fConnectedElement, then these two elements
            LPTSTR  pToConnected;       // have the pFrom and pTo.
            DWORD   dwConfirmation;     // The result of confirnation given by end-user
        } ConnectedInfo;
    };

    TCHAR szShortName[14];
    TCHAR szName[1]; // this struct is dynamic

} DIRTREENODE, *PDIRTREENODE;

typedef struct {
    BOOL  fChanged;
    DWORD dwFiles; // number of files
    DWORD dwFolders; // number of folders
    LARGE_INTEGER liSize; // total size of all files
} DIRTOTALS, *PDIRTOTALS;

typedef struct {
    UINT oper;
    DIRTOTALS dtAll; // totals for all files
    DIRTOTALS dtDone; // totals of what's done
    BOOL fChangePosted;

    PDIRTREENODE pdtn; // first directory tree node
    PDIRTREENODE pdtnCurrent;
    PDIRTREENODE pdtnConnectedItems;  //Pointer to the begining of connected elements node.
    TCHAR    bDiskCheck[26];

    // how much does each operation cost in the progress...
    int iFilePoints;
    int iFolderPoints;
    int iSizePoints;


    LPTSTR pTo;  // this holds the top level target list
    LPTSTR pFrom; // this holds the top level source list
    BOOL    fMultiDest;

    TCHAR szSrcPath[MAX_PATH];
    TCHAR szDestPath[MAX_PATH]; // this is the current destination for pdtn and all it's children (not siblings)
    // lpszDestPath includes pdtn's first path component

    HDSA hdsaRenamePairs;

} DIRTREEHEADER, *PDIRTREEHEADER;

//  We spend a lot of time creating simple PIDLs, so use this cache
//  to speed things up.
typedef struct SIMPLEPIDLCACHE {
    IBindCtx *pbcFile;          // Empty filesys bind context for files
    IBindCtx *pbcFolder;        // Empty filesys bind context for folders
    IShellFolder *psfDesktop;   // Desktop folder (for ParseDisplayName)
    int iInit;                  // 0 = not inited; 1 = inited; -1 = init failed
    IShellFolder *psf;          // Current folder
    LPITEMIDLIST pidlFolder;    // Current folder
    TCHAR szFolder[MAX_PATH];   // Current folder
} SIMPLEPIDLCACHE, *PSIMPLEPIDLCACHE;

typedef struct {
    int          nRef;          // struct reference count

    int          nSourceFiles;
    LPTSTR       lpCopyBuffer; // global file copy buffer
    UINT         uSize;         // size of this buffer
    FILEOP_FLAGS fFlags;        // from SHFILEOPSTRUCT
    HWND         hwndProgress;  // dialog/progress window
    HWND         hwndDlgParent; // parent window for message boxes
    CONFIRM_DATA cd;            // confirmation stuff

    UNDOATOM    *lpua;           // the undo atom that this file operation will make
    BOOL        fNoConfirmRecycle;
    BOOL        bAbort;
    BOOL        fMerge;   // are we doing a merge of folders

    BOOL        fDone;
    BOOL        fProgressOk;
    BOOL        fDTBuilt;
    BOOL        fFromCDRom;         // Clear readonly bits if copying from CDRom

    // folowing fields are used for giving estimated time for completion
    // feedback to the user during longer than MINTIME4FEEDBACK operations
    BOOL  fFlushWrites;     // Should we flush writes for destinations on slow links

    DWORD dwPreviousTime;       // calculate transfer rate
    int  iLastProgressPoints;   // how many progress points we had the last time we updated the time est
    DWORD dwPointsPerSec;
    LPCTSTR lpszProgressTitle;
    LPSHFILEOPSTRUCT lpfo;

    DIRTREEHEADER dth;
    BOOL        fInitialize;
    const WIN32_FIND_DATA* pfd;
    BOOL        bStreamLossPossible;    // Could stream loss happen in this directory?

    SIMPLEPIDLCACHE spc;
} COPY_STATE, *LPCOPY_STATE;

// we have a seperate struct that we pass off to the FOUIThread so that he can get to the pcs,
// but since the FOUIThread can outlive the main thread (!!) in some cases, we can't let him have a
// ref to pcs->lpfo since it is owned by SHFileOperations caller and we crash if we try to refrence
// it after SHFileOperation returns and the caller has freed the memory. The only two things the 
// FOUIThread uses out of the pcs->lpfo are the wFunc and the lpszProgressTitle (to see if the
// recycle bin was being emptied or not), so we make private copies of that info for the thread.
typedef struct {
    COPY_STATE* pcs;
    UINT wFunc;
    BOOL bIsEmptyRBOp;
} FOUITHREADINFO, *PFOUITHREADINFO;

// Information to determine folder's movability to the recycle bin
typedef struct {
    BOOL            bProcessedRoot; // tells if we are the first call in the recursive chain and we need to do root-specific processing
    int             cchBBDir;       // count of characters in the recycle bin dir (eg "C:\Recycler\<sid>")
    int             cchDelta;       // count of characters that the path will increase (or decrease if negative) by when moved under the recycle bin directory
    ULONGLONG       cbSize;         // size of the folder
    TCHAR           szNonDeletableFile[MAX_PATH];   // an output buffer that holds the name of the file that cannot be deleted, if one exists
    TCHAR           szDir[MAX_PATH];    // input & scratch buffer for stack savings when recursing
    TCHAR           szPath[MAX_PATH];   // scratch buffer for stack savings when recursing
    WIN32_FIND_DATA fd;             // also for stack savings
} FOLDERDELETEINFO;


// function declarations
void _ProcessNameMappings(LPTSTR pszTarget, UINT cchTarget, HDSA hdsaRenamePairs);
int GetNameDialog(HWND hwnd, COPY_STATE *pcs, BOOL fMultiple,UINT wOp, LPTSTR pFrom, LPTSTR pTo);
void AddRenamePairToHDSA(LPCTSTR pszOldPath, LPCTSTR pszNewPath, HDSA* phdsaRenamePairs);
BOOL FOQueryAbort(COPY_STATE *pcs);
UINT DTAllocConnectedItemNodes(PDIRTREEHEADER pdth, COPY_STATE *pcs, WIN32_FIND_DATA *pfd, LPTSTR pszPath, BOOL fRecurse, PDIRTREENODE *ppdtnConnectedItems);
void CALLBACK FOUndo_Invoke(UNDOATOM *lpua);
LONG CheckFolderSizeAndDeleteability(FOLDERDELETEINFO* pfdi, LPCOPY_STATE pcs);
BOOL DeleteFileBB(LPTSTR pszFile, UINT cchFile, INT *piReturn, COPY_STATE *pcs, BOOL fIsDir, WIN32_FIND_DATA *pfd, HDPA *phdpaDeletedFiles);


BOOL DTDiskCheck(PDIRTREEHEADER pdth, COPY_STATE *pcs, LPTSTR pszPath)
{
    int iDrive = PathGetDriveNumber(pszPath);

    if (iDrive != -1)
    {
        if (!pdth->bDiskCheck[iDrive])
        {
            HWND hwnd = pcs->hwndDlgParent;
            TCHAR szDrive[] = TEXT("A:\\");
            szDrive[0] += (CHAR)iDrive;

            // Sometimes pszPath is a dir and sometimes it's a file.  All we really care about is if the
            // drive is ready (inserted, formated, net path mapped, etc).  We know that we don't have a
            // UNC path because PathGetDriveNumber would have failed and we are already busted in terms
            // of mounted volumes, again because we use PathGetDriveNumber, so we don't have to worry about
            // these two cases.  As such we build the root path and use that instead.
            pdth->bDiskCheck[iDrive] = SUCCEEDED(SHPathPrepareForWrite(((pcs->fFlags & FOF_NOERRORUI) ? NULL : hwnd), NULL, szDrive, 0));
        }
        return pdth->bDiskCheck[iDrive];
    }

    return TRUE;    // always succeed for net drives
}


//--------------------------------------------------------------------------------------------
// Simple pidl cache stuff
//--------------------------------------------------------------------------------------------

void SimplePidlCache_Release(SIMPLEPIDLCACHE *pspc)
{
    ATOMICRELEASE(pspc->pbcFile);
    ATOMICRELEASE(pspc->pbcFolder);
    ATOMICRELEASE(pspc->psfDesktop);
    ATOMICRELEASE(pspc->psf);
    ILFree(pspc->pidlFolder);
}

const WIN32_FIND_DATA c_fdFolder = { FILE_ATTRIBUTE_DIRECTORY };

BOOL SimplePidlCache_Init(SIMPLEPIDLCACHE *pspc)
{
    ASSERT(pspc->iInit == 0);

    if (SUCCEEDED(SHCreateFileSysBindCtx(NULL, &pspc->pbcFile)) &&
            SUCCEEDED(SHCreateFileSysBindCtx(&c_fdFolder, &pspc->pbcFolder)) &&
            SUCCEEDED(SHGetDesktopFolder(&pspc->psfDesktop)))
    {
        pspc->psf = pspc->psfDesktop;
        pspc->psf->lpVtbl->AddRef(pspc->psf);
        // It's okay to leave pidlFolder as NULL; ILCombine won't barf

        pspc->iInit = 1;
        return TRUE;
    }
    else
    {
        pspc->iInit = -1;
        return FALSE;
    }
}

LPITEMIDLIST SimplePidlCache_GetFilePidl(SIMPLEPIDLCACHE *pspc, LPCTSTR pszFile)
{
    LPITEMIDLIST pidlChild;
    LPITEMIDLIST pidlRet;
    LPTSTR pszFileName;
    TCHAR szFolder[MAX_PATH];
    HRESULT hr;

    if (pspc->iInit < 0)
        return NULL;                // Initialization failed

    if (!pspc->iInit && !SimplePidlCache_Init(pspc))
        return NULL;

    // If this file is in a different folder from the one we cached,
    // need to dump the old one and get a new one.

    hr = StringCchCopy(szFolder, ARRAYSIZE(szFolder), pszFile);
    if (FAILED(hr))
        return NULL;

    PathRemoveFileSpec(szFolder);

    // We use StrCmpC instead of lstrcmpi because the vast majority
    // of the time, the path will match even in case, and if we get
    // it wrong, it's no big whoop: we just don't use the cache.

    if (StrCmpC(pspc->szFolder, szFolder) != 0)
    {
        LPITEMIDLIST pidlFolder = NULL; // In case it's on the desktop
        IShellFolder *psf;

        if (szFolder[0])            // An actual folder
        {
            // Get a simple pidl to the folder.
            if (FAILED(pspc->psfDesktop->lpVtbl->ParseDisplayName(pspc->psfDesktop, NULL,
                                            pspc->pbcFolder, szFolder, NULL, &pidlFolder, NULL)))
                return NULL;
        }
        else                        // Going for the desktop
        {
            /* pidlFolder already preinitialized to NULL */
        }

        // Bind to that folder
        if (FAILED(SHBindToObject(pspc->psfDesktop, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf))))
        {
            ILFree(pidlFolder);
            return NULL;
        }

        hr = StringCchCopy(pspc->szFolder, ARRAYSIZE(pspc->szFolder), szFolder);
        if (FAILED(hr))
        {
            ILFree(pidlFolder);
            ATOMICRELEASE(psf);
            return NULL;
        }

        // Woo-hoo, everybody is happy.  Save the results into our cache.

        ATOMICRELEASE(pspc->psf);
        pspc->psf = psf;

        ILFree(pspc->pidlFolder);
        pspc->pidlFolder = pidlFolder;

    }

    // Get a simple pidl to the filename
    pszFileName = PathFindFileName(pszFile);        // T2W is a macro with multiple evaluation
    if (FAILED(pspc->psf->lpVtbl->ParseDisplayName(pspc->psf, NULL, pspc->pbcFile,
                        pszFileName, NULL, &pidlChild, NULL)))
        return NULL;

    // Combine it with the parent
    pidlRet = ILCombine(pspc->pidlFolder, pidlChild);
    ILFree(pidlChild);

    return pidlRet;
}

//--------------------------------------------------------------------------------------------
// ConvertToConnectedItemname:
//      Given a file/folder name, this function checks to see if it has any connection and if 
// there is a connection, then it will convert the given name to that of the connected element
// and return length of the prefix. If no connection exists, it returns zero.
//  The fDirectory parameter specifies if the given filename is a FOLDER or not!
//
//  dwBuffSize: The size of pszFileName buffer in CHARACTERS.
//
//  Examples:
//      "foo.htm"   =>  "foo*"  (returns 3 because the prefix("foo") length is 3)
//      "foobar files" =>  "foobar.htm?"  (returns 6 as the prefix length)
//                                          
//--------------------------------------------------------------------------------------------
int ConvertToConnectedItemName(LPTSTR pszFileName, DWORD dwBuffSize, BOOL fDirectory)
{
    LPTSTR  pszDest, pszConnectedElemSuffix;
    int     iPrefixLength;
    HRESULT hr;

    if (fDirectory)
    {
        // Look for a suffix which is one of the standard suffixes.
        if (!(pszDest = (LPTSTR)PathFindSuffixArray(pszFileName, c_apszSuffixes, ARRAYSIZE(c_apszSuffixes))))
            return 0;
        
        // " files" suffix is found. Replace it with ".htm?"
        pszConnectedElemSuffix = TEXT(".htm?");
    }
    else
    {
        // Look for the extension ".htm" or ".html" and replace it with "*".
        if (!(pszDest = PathFindExtension(pszFileName)))
            return 0;
        
        if (lstrcmpi(pszDest, TEXT(".htm")) && (lstrcmpi(pszDest, TEXT(".html"))))
            return 0;
        
        // Extension ".htm" or ".html" is found. Replace it with "*"
        pszConnectedElemSuffix = (LPTSTR)c_szStar;
    }

    iPrefixLength = (int)(pszDest - pszFileName);
    
    //Replace the source suffix with the connected element's suffix.
    hr = StringCchCopy(pszDest, dwBuffSize - iPrefixLength, pszConnectedElemSuffix);
    if (FAILED(hr))
        return 0;
    
    return(iPrefixLength);
}

PDIRTREENODE DTAllocNode(PDIRTREEHEADER pdth, WIN32_FIND_DATA* pfd, PDIRTREENODE pdtnParent, PDIRTREENODE pdtnNext, BOOL fConnectedElement)
{
    int iLen = pfd ? lstrlen(pfd->cFileName) * sizeof(TCHAR) : 0;
    PDIRTREENODE pdtn = (PDIRTREENODE)LocalAlloc(LPTR, sizeof(DIRTREENODE) + iLen);
    if (pdtn)
    {
        pdtn->fConnectedElement = fConnectedElement;

        // Initializing the following to NULL is not needed because of the LPTR (zero init) done
        // above.
        // if (fConnectedElement)
        //{
        //    pdtn->ConnectedInfo.pFromConnected = pdtn->ConnectedInfo.pToConnected = NULL;
        //    pdtn->ConnectedInfo.dwConfirmation = 0;
        //}
        //else
        //    pdtn->pdtnConnected = NULL;

        pdtn->pdtnParent = pdtnParent;
        pdtn->pdtnNext   = pdtnNext;

        if (pfd)
        {
            HRESULT hr;
            BOOL fOk = TRUE;

            hr = StringCchCopy(pdtn->szShortName, ARRAYSIZE(pdtn->szShortName), pfd->cAlternateFileName);
            if (FAILED(hr))
            {
                fOk = FALSE;
            }

            hr = StringCchCopy(pdtn->szName, iLen + 1, pfd->cFileName);
            if (FAILED(hr))
            {
                fOk = FALSE;
            }
            
            if (fOk)
            {
                pdtn->dwFileAttributes = pfd->dwFileAttributes;
                pdtn->ftCreationTime   = pfd->ftCreationTime;
                pdtn->ftLastWriteTime  = pfd->ftLastWriteTime;
                pdtn->nFileSizeLow     = pfd->nFileSizeLow;
                pdtn->nFileSizeHigh    = pfd->nFileSizeHigh;

                // only the stuff we care about
                if (ISDIRFINDDATA(*pfd))
                {
                    pdth->dtAll.dwFolders++;
                    pdtn->pdtnChild = DTN_DELAYED;
                }
                else
                {
                    LARGE_INTEGER li;

                    li.LowPart = pfd->nFileSizeLow;
                    li.HighPart = pfd->nFileSizeHigh;

                    pdth->dtAll.liSize.QuadPart += li.QuadPart;
                    pdth->dtAll.dwFiles++;
                }
                // increment the header stats
                pdth->dtAll.fChanged = TRUE;
            }
            else
            {
                LocalFree(pdtn);
                pdtn = NULL;
            }
        }
    }

    return pdtn;
}

#if defined(DEBUG)  /// && defined(DEBUGCOPY)
void DebugDumpPDTN(PDIRTREENODE pdtn, LPTSTR ptext)
{
    DebugMsg(TF_DEBUGCOPY, TEXT("***** PDTN %x  (%s)"), pdtn, ptext);
    //Safe-guard against pdtn being NULL!
    if (pdtn)
    {
        DebugMsg(TF_DEBUGCOPY, TEXT("** %s %s"), pdtn->szShortName, pdtn->szName);
        DebugMsg(TF_DEBUGCOPY, TEXT("** %x %d"), pdtn->dwFileAttributes, pdtn->nFileSizeLow);
        DebugMsg(TF_DEBUGCOPY, TEXT("** %x %x %x"), pdtn->pdtnParent, pdtn->pdtnNext, pdtn->pdtnChild);
        DebugMsg(TF_DEBUGCOPY, TEXT("** NewRoot:%x, Connected:%x, Dummy:%x"), pdtn->fNewRoot, pdtn->fConnectedElement, pdtn->fDummy);
        if (pdtn->fConnectedElement)
        {
            DebugMsg(TF_DEBUGCOPY, TEXT("**** Connected: pFromConnected:%s, pToConnected:%s, dwConfirmation:%x"), pdtn->ConnectedInfo.pFromConnected, 
                    pdtn->ConnectedInfo.pToConnected, pdtn->ConnectedInfo.dwConfirmation);
        }
        else
        {
            DebugMsg(TF_DEBUGCOPY, TEXT("**** Origin: pdtnConnected:%x"), pdtn->pdtnConnected);
        }
    }
    else
    {
        DebugMsg(TF_DEBUGCOPY, TEXT("** NULL pointer(PDTN)"));
    }
}
#else
#define DebugDumpPDTN(p, x) 0
#endif

BOOL  DoesSuffixMatch(LPTSTR  lpSuffix, const LPCTSTR *apSuffixes, int iArraySize)
{
    while (iArraySize--)
    {
        // Note: This must be a case sensitive compare, because we don't want to pickup 
        // "Program Files".
        if (!lstrcmp(lpSuffix, *apSuffixes++))
            return TRUE;
    }

    return FALSE;
}


//--------------------------------------------------------------------------------------------
//
//  DTPathToDTNode:
//      This function is used to build a list of nodes that correspond to the given pszPath.
// This list is built under "ppdtn".  If ppdtnConnectedItems is given, another list of nodes that
// correspond to the connected elements(files/folders) of the nodes in the first list is also built
// under "ppdtnConnectedItems".
//
// WARNING: This parties directly on pszPath and pfd so that it doesn't need to allocate
// on the stack.  This recurses, so we want to use as little stack as possible
//
// this will wack off one component from pszPath
//
//
// ppdtn: Points to where the header of the list being built will be stored.
// ppdtnConnectedItems: If this is NULL, then we are not interested in finding and building the 
//                      connected elements. If this is NOT null, it points to where the header of
//                      the connected items list will be stored.
// fConnectedElement: Each node being built under ppdtn needs to be marked with this bit.
// iPrefixLength: This parameter is zero if fConnectedElement is FALSE. Otherwise, it contains the
//              Length of the prefix part of the file or foldername (path is NOT included).
//              For example, if "c:\windows\foo*" is passed in, iPrefixLength is 3 (length of "foo")
//
// dwFilesOrFolders parameter can specify if we need to look for only FILES or FOLDERs or BOTH.

#define     DTF_FILES_ONLY      0x00000001      //Operate only on Files.
#define     DTF_FOLDERS_ONLY    0x00000002      //Operate only on Folders.
#define     DTF_FILES_AND_FOLDERS  (DTF_FILES_ONLY | DTF_FOLDERS_ONLY)  //Operate on files AND folders.

UINT DTPathToDTNode(PDIRTREEHEADER pdth, COPY_STATE *pcs, LPTSTR pszPath, BOOL fRecurse,
        DWORD dwFilesOrFolders, PDIRTREENODE* ppdtn, WIN32_FIND_DATA *pfd,
        PDIRTREENODE pdtnParent, PDIRTREENODE* ppdtnConnectedItems, BOOL fConnectedElement,
        int iPrefixLength)
{
    int iError = 0;

    // this points to the var where all items are inserted.
    // folders are placed after it, files are placed before

    // keep the stack vars to a minimum because this is recursive
    PDIRTREENODE *ppdtnMiddle = ppdtn;
    BOOL fNeedToFindNext = TRUE;
    HANDLE hfind = FindFirstFile(pszPath, pfd);

    DebugMsg(TF_DEBUGCOPY, TEXT("DTPathToDTNode Entering %s"), pszPath);
    *ppdtnMiddle = NULL; // in case there are no children

    if (hfind == INVALID_HANDLE_VALUE)
    {
        // this is allowable only if the path is wild...
        // and the parent exists
        if (PathIsWild(pszPath))
        {
            PathRemoveFileSpec(pszPath);
            if (PathFileExists(pszPath))
            {
                return 0;
            }
        }
        return OPER_ERROR | ERROR_FILE_NOT_FOUND;
    }

    //Remove the filespec before passing it onto DTAllocConnectedItemNodes.
    PathRemoveFileSpec(pszPath);

    do
    {
        // We skip the following files:
        //      "." and ".." filenames
        //      Folders when DTF_FILES_ONLY is set
        //      Files when DTF_FOLDERS_ONLY is set

        if (!PathIsDotOrDotDot(pfd->cFileName) &&
                (((dwFilesOrFolders & DTF_FILES_ONLY) && !ISDIRFINDDATA(*pfd)) || 
                 ((dwFilesOrFolders & DTF_FOLDERS_ONLY) && ISDIRFINDDATA(*pfd)))) 
        {
            //Check if we are looking for connected elements
            if ((!pdtnParent) && fConnectedElement)
            {
                // We found what we are looking for. If we are looking for a top-level connected item and 
                // if it is a folder, then we need to make sure that the suffix exactly matches one of the
                // suffixes in the array c_apszSuffixes[].
                LPTSTR  lpSuffix = (LPTSTR)(pfd->cFileName + iPrefixLength);

                if (ISDIRFINDDATA(*pfd))  
                {
                    // What we found is a directory!
                    // See if it has one of the standard suffixes for connected folders.
                    if (!DoesSuffixMatch(lpSuffix, c_apszSuffixes, ARRAYSIZE(c_apszSuffixes)))
                        continue; //This is not what we look for. So, find next.
                }
                else
                {
                    // What we found is a file (i.e Not a directory)
                    // See if it has one of the standard suffixes for html files.
                    if (lstrcmpi(lpSuffix, TEXT(".htm")) && lstrcmpi(lpSuffix, TEXT(".html")))
                        continue; //This is not what we look for. So, find next.
                }

                // Now we know that we found the connected element that we looked for.
                // So, no need to FindNext again. We can get out of the loop after processing
                // it once.
                fNeedToFindNext = FALSE;
            }

            *ppdtnMiddle = DTAllocNode(pdth, pfd, pdtnParent, *ppdtnMiddle, fConnectedElement);

            if (!*ppdtnMiddle)
            {
                FindClose(hfind);
                return OPER_ERROR | ERROR_NOT_ENOUGH_MEMORY;
            }

            // make sure that the parent's pointer always points to the head of
            // this linked list
            if (*ppdtn == (*ppdtnMiddle)->pdtnNext)
                *ppdtn = (*ppdtnMiddle);

            DebugDumpPDTN(*ppdtnMiddle, TEXT("DTPathToDTNode, DTAllocNode"));

            //We need to check for Connected elements only for the top level items
            if ((!(pcs->fFlags & FOF_NO_CONNECTED_ELEMENTS)) && ppdtnConnectedItems)
            {
                //Make sure this is a top level item
                ASSERT(!pdtnParent);

                //Create a list of connected items and attach it to the head of the list.
                iError = DTAllocConnectedItemNodes(pdth, pcs, pfd, pszPath, fRecurse, ppdtnConnectedItems);

                DebugDumpPDTN(*ppdtnConnectedItems, TEXT("DTPathToDTNode, DTAllocConnectedNodes"));

                // It is possible that the connected files do not exist. That condition is not really
                // an error. So, we check for insufficient memory error condition alone here.
                if (iError == (OPER_ERROR | ERROR_NOT_ENOUGH_MEMORY))
                {
                    FindClose(hfind);
                    return(iError);
                }

                //If a connected item exists, then make the origin item point to this connected item.
                if (*ppdtnConnectedItems)
                {
                    (*ppdtnMiddle)->pdtnConnected = *ppdtnConnectedItems;
                    // Also by default, set the Confirmation result to NO so that the connected element
                    // will not be copied/moved etc., in case of a conflict. However, if the origin had
                    // a conflict, we would put up a confirmation dlg and the result of that dlg will 
                    // over-write this value.
                    (*ppdtnConnectedItems)->ConnectedInfo.dwConfirmation = IDNO;
                }

                //Move to the last node in the connected items list.
                while (*ppdtnConnectedItems)
                    ppdtnConnectedItems = &((*ppdtnConnectedItems)->pdtnNext);
            }
            else
            {
                // This should have been initialized to zero during allocation, but lets be paranoid
                ASSERT(NULL == (*ppdtnMiddle)->pdtnConnected);
            }

            // if this is not a directory, move the ppdtnMiddle up one
            if (!ISDIRFINDDATA(*pfd))
            {
                ppdtnMiddle = &(*ppdtnMiddle)->pdtnNext;
            }

        }

    } while (fNeedToFindNext && !FOQueryAbort(pcs) && FindNextFile(hfind, pfd));

    iError = 0;  //It is possible that iError contains other errors value now! So, reset it!

    FindClose(hfind);

    // now go and recurse into folders (if desired)
    // we don't have to check to see if these pdtn's are dirs, because the
    // way we inserted them above ensures that everything in from of
    // ppdtnMiddle are folders

    // we're going to tack on a specific child
    // then add the *.* after that

    while (!FOQueryAbort(pcs) && *ppdtnMiddle)
    {
        BOOL fRecurseThisItem = fRecurse;

        if ((*ppdtnMiddle)->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
        {
            // Recurse into reparse points unless they asked not to
            if (pcs->fFlags & FOF_NORECURSEREPARSE)
            {
                fRecurseThisItem = FALSE;
            }
        }

        if (fRecurseThisItem)
        {
            if (PathAppend(pszPath, (*ppdtnMiddle)->szName))
            {
                if (PathAppend(pszPath, c_szStarDotStar))
                {

                    // NULL indicates that we do not want to get the connected elements.
                    // This is because we want the connected elements only for the top-level items.
                    iError = DTPathToDTNode(pdth, pcs, pszPath, TRUE, DTF_FILES_AND_FOLDERS,
                            &((*ppdtnMiddle)->pdtnChild), pfd, *ppdtnMiddle, NULL, fConnectedElement, 0);

                }
                else
                {
                    iError = OPER_ERROR | DE_INVALIDFILES;
                }

                PathRemoveFileSpec(pszPath);
            }
            else
            {
                iError = OPER_ERROR | DE_INVALIDFILES;
            }
        }
        else
        {
            // if we don't want to recurse, just mark them all as having no children
            (*ppdtnMiddle)->pdtnChild = NULL;
        }

        if (iError)
        {
            return iError;
        }

        ppdtnMiddle = &(*ppdtnMiddle)->pdtnNext;
    }

    return 0;
}

UINT DTAllocConnectedItemNodes(PDIRTREEHEADER pdth, COPY_STATE *pcs, WIN32_FIND_DATA *pfd, LPTSTR pszPath, BOOL fRecurse, PDIRTREENODE *ppdtnConnectedItems)
{
    // Since DTAllocConnectedItemNodes() gets called only for the top-level items in the src list,
    // there is no danger of this function getting called recursively. Hence, I didn't worry about
    // allocating the following on the stack.
    // If "too-much-stack-is-used" problem arises, we can optimize the stack usage by splitting
    // the following function into two such that the most common case (of no connection) 
    // doesn't use much stack. 
    DWORD   dwFileOrFolder;
    TCHAR   szFullPath[MAX_PATH];
    TCHAR   szFileName[MAX_PATH];
    WIN32_FIND_DATA  fd;
    int     iPrefixLength;  //This is the length of "foo" if the filename is "foo.htm" or "foo files"
    HRESULT hr;

    //Make a copy of the filename; This copy will get munged by ConvertToConnectedItemName().
    hr = StringCchCopy(szFileName, ARRAYSIZE(szFileName), pfd->cFileName);
    if (FAILED(hr))
        return 0;   // No connection exist for too big names

    // Convert the given file/foder name into the connected item's name with wild card characters.
    iPrefixLength = ConvertToConnectedItemName(szFileName, ARRAYSIZE(szFileName), ISDIRFINDDATA(*pfd));
    if (iPrefixLength == 0)
        return 0; //No connections exist for the given folder/file.

    // Now szFileName has the name of connected element with wildcard character.

    // If the given element is a directory, we want to look for connected FILES only  and
    // if the given element is a file, we want to look for connected FOLDERS only.
    dwFileOrFolder = ISDIRFINDDATA(*pfd) ? DTF_FILES_ONLY : DTF_FOLDERS_ONLY;

    // Form the file/folder name with the complete path!
    hr = StringCchCopy(szFullPath, ARRAYSIZE(szFullPath), pszPath);
    if (FAILED(hr))
        return 0;

    if (!PathAppend(szFullPath, szFileName))
        return 0;
    
    // The file-element has some "connected" items.
    DebugMsg(TF_DEBUGCOPY, TEXT("DTAllocConnectedItemNodes Looking for %s"), szFullPath);

    return(DTPathToDTNode(pdth, pcs, szFullPath, fRecurse, dwFileOrFolder, ppdtnConnectedItems, &fd, NULL, NULL, TRUE, iPrefixLength));
}

void DTInitProgressPoints(PDIRTREEHEADER pdth, COPY_STATE *pcs)
{
    pdth->iFilePoints = 1;
    pdth->iFolderPoints = 1;

    switch (pcs->lpfo->wFunc)
    {
        case FO_RENAME:
        case FO_DELETE:
            pdth->iSizePoints = 0;
            break;

        case FO_COPY:
            pdth->iSizePoints = 1;
            break;

        case FO_MOVE:
            if (PathIsSameRoot(pcs->lpfo->pFrom, pcs->lpfo->pTo))
            {
                pdth->iSizePoints = 0;
            }
            else
            {
                // if it's across volumes, these points increase
                // because we need to nuke the source as well as
                // create the target...
                // whereas we don't need to nuke the "size" of the source
                pdth->iFilePoints = 2;
                pdth->iFolderPoints = 2;
                pdth->iSizePoints = 1;
            }
            break;
    }
}

UINT DTBuild(COPY_STATE* pcs)
{
    PDIRTREEHEADER pdth = &pcs->dth;
    WIN32_FIND_DATA fd;
    TCHAR szPath[MAX_PATH];
    PDIRTREENODE *ppdtn;
    PDIRTREENODE *ppdtnConnectedItems;
    int iError = 0;
    HRESULT hr;

    pcs->dth.pFrom = (LPTSTR)pcs->lpfo->pFrom;
    pcs->dth.pTo = (LPTSTR)pcs->lpfo->pTo;
    // A tree of original items will be built under ppdtn.
    ppdtn = &pdth->pdtn;
    // A tree of items "connected" to the orginal items will be built under ppdtnConnectedItems.
    ppdtnConnectedItems = &pdth->pdtnConnectedItems;

    DTInitProgressPoints(pdth, pcs);
    while (!FOQueryAbort(pcs) && *pdth->pFrom)
    {
        BOOL fRecurse = TRUE;

        switch (pcs->lpfo->wFunc)
        {
            case FO_MOVE:
                // The move operation doesn't need to recurse if we are moving from and to the same
                // volume.  In this case we know that we don't need to display any warnings for
                // things like LFN to 8.3 filename conversion or stream loss.  Instead, we can do
                // the operation with one single win32 file operation that just does a rename.

                // NTRAID89119-2000/02/25-toddb
                // This is only true if we don't cross a mount point!  If we cross
                // a mount point then we might have to warn about these things.

                if ((pcs->fFlags & FOF_NORECURSION) || PathIsSameRoot(pdth->pFrom, pdth->pTo))
                {
                    fRecurse = FALSE;
                }
                break;

            case FO_COPY:
                // For a copy we always recurse unless we're told not to.
                if (pcs->fFlags & FOF_NORECURSION)
                {
                    fRecurse = FALSE;
                }
                break;

            case FO_RENAME:
                // for a rename we never recurse
                fRecurse = FALSE;
                break;

            case FO_DELETE:
                // for a delete we don't need to recurse IF the recycle bin will be able to handle
                // the given item.  If the recycle bin handles the delete then we can undo from
                // the recycle bin if we need to.
                if ((pcs->fFlags & FOF_ALLOWUNDO) && BBWillRecycle(pdth->pFrom, NULL))
                {
                    fRecurse = FALSE;
                }
                break;
        }

        hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pdth->pFrom);
        if (FAILED(hr))
        {
            iError = OPER_ERROR | DE_INVALIDFILES;
            break;
        }

        DebugMsg(TF_DEBUGCOPY, TEXT("DTBuild: %s"), szPath);

        // If the file is on removable media, we need to check for media in the drive.
        // Prompt the user to insert the media if it's missing.
        if (!DTDiskCheck(pdth, pcs, szPath))
        {
            iError = ERROR_CANCELLED;
            break;
        }

        iError = DTPathToDTNode(pdth, pcs, szPath, fRecurse,
                ((PathIsWild(pdth->pFrom) && (pcs->lpfo->fFlags & FOF_FILESONLY)) ? DTF_FILES_ONLY : DTF_FILES_AND_FOLDERS), 
                ppdtn,&fd, NULL, ppdtnConnectedItems, FALSE, 0);

        DebugMsg(TF_DEBUGCOPY, TEXT("DTBuild: returned %d"), iError);

        // FEATURE: If an error occured we should allow the user to skip the file that caused the error.  That way
        // if one of the source files doesn't exists the rest will still get copied.  Do this only in the multi-
        // source case, blah blah blah.  This helps in the case where one of the source files cannot be moved or
        // copied (usually due to Access Denied, could be insuffecent permissions or file is in use, etc).

        if (iError)
            break;

        if (!(*ppdtn) && PathIsWild(pdth->pFrom))
        {
            // no files are associated with this path... this
            // can happen when we have wildcards...
            // alloc a dummy node
            *ppdtn = DTAllocNode(pdth, NULL, NULL, NULL, FALSE);
            if (*ppdtn)
            {
                (*ppdtn)->fDummy = TRUE;
            }
        }


        if (*ppdtn)
        {
            // mark this as the start of a root spec... this is
            // necessary in case we have several wild specs
            (*ppdtn)->fNewRoot = TRUE;
        }

        if (*ppdtnConnectedItems)
        {
            // Mark this as the start of a root spec.
            (*ppdtnConnectedItems)->fNewRoot = TRUE;
            // For connected items, we need to remember the path.
            (*ppdtnConnectedItems)->ConnectedInfo.pFromConnected = pdth->pFrom;
            (*ppdtnConnectedItems)->ConnectedInfo.pToConnected = pdth->pTo;
        }


        while (*ppdtn)
        {
            ppdtn = &(*ppdtn)->pdtnNext;
        }

        while (*ppdtnConnectedItems)
        {
            ppdtnConnectedItems = &(*ppdtnConnectedItems)->pdtnNext;
        }

        pdth->pFrom += lstrlen(pdth->pFrom) + 1;
        if (pcs->lpfo->wFunc != FO_DELETE && (pcs->lpfo->fFlags & FOF_MULTIDESTFILES))
        {
            pdth->pTo += lstrlen(pdth->pTo) + 1;
        }
    }

    //Attach the "ConnectedElements" Tree to the end of the source element tree.
    *ppdtn = pcs->dth.pdtnConnectedItems;

    pcs->dth.pFrom = (LPTSTR)pcs->lpfo->pFrom;
    pcs->dth.pTo = (LPTSTR)pcs->lpfo->pTo;
    pcs->fDTBuilt = TRUE;

    // set up the initial time information
    pcs->dwPreviousTime = GetTickCount();
    pcs->dwPointsPerSec = 0;
    pcs->iLastProgressPoints = 0;
    return iError;
}

#define DTNIsRootNode(pdtn) ((pdtn)->pdtnParent == NULL)
#define DTNIsDirectory(pdtn) (pdtn->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
// This macro determines if the given node is an "Origin" of a connection. i.e. Does this node 
// point to a connected element that needs to be moved/copied etc., along with it?
// For example, if "foo.htm" is moved, "foo files" is also moved. 
// Here, "foo.htm" is the "Connect origin" (fConnectedElement = FALSE; pdtnConnected is valid)
// and "foo files" is the "connected element". (fConnectedElement = TRUE;)
#define DTNIsConnectOrigin(pdtn) ((!pdtn->fConnectedElement) && (pdtn->pdtnConnected != NULL))
#define DTNIsConnected(pdtn)    (pdtn && (pdtn->fConnectedElement))

//
UINT DTEnumChildren(PDIRTREEHEADER pdth, COPY_STATE *pcs, BOOL fRecurse, DWORD dwFileOrFolder)
{
    int iError = 0;
    if (pdth->pdtnCurrent->pdtnChild == DTN_DELAYED)
    {
        WIN32_FIND_DATA fd;

        // fill in all the children and update the stats in pdth
        TCHAR szPath[MAX_PATH];
        if (PathCombine(szPath, pdth->szSrcPath, c_szStarDotStar))
        {
            iError = DTPathToDTNode(pdth, pcs, szPath, fRecurse, dwFileOrFolder,
                    &pdth->pdtnCurrent->pdtnChild, &fd, pdth->pdtnCurrent, NULL, pdth->pdtnCurrent->fConnectedElement, 0);
        }
        else
        {
            iError = OPER_ERROR | DE_INVALIDFILES;
        }


        // If we get "File Not Found" Error now and if it is a connected item, then this item 
        // must have already been moved/renamed/deleted etc., So, this is not really an error. 
        // All this means is that this connected item was also explicitly selected and hence appeared
        // as or "Origin" item earlier in the list and it had already been operated upon.
        // So, reset the error here.
        // (Example: If end-user selects "foo.htm" AND "foo files" folder and moves them, then we
        // will get a file-not-found error when we attempt to move the connected items. To avoid
        // this error dialog, we reset the error here.)

        if (DTNIsConnected(pdth->pdtnCurrent) && (iError == (OPER_ERROR | ERROR_FILE_NOT_FOUND)))
            iError = 0;  
    }
    return iError;
}

//
// DTNGetConfirmationResult:
//    When a file("foo.htm") is moved/copied, we may put up a confirmation dialog in case 
// of a conflict and the end-user might have responded saying "Yes", "no" etc., When the 
// corresponding connected element ("foo files") is also moved/copied etc., we should NOT put up
// a confirmation dialog again. We must simply store the answer to the original confirmation and
// use it later. 
//  This function retries the result of the original confirmation from the top-level connected 
// element.
int  DTNGetConfirmationResult(PDIRTREENODE pdtn)
{
    //Confirmation results are saved only for Connected items; Not for Connection Origins.
    if (!pdtn || !DTNIsConnected(pdtn))
        return 0;

    //Confirmation results are stored only at the top-level node. So, go there.
    while (pdtn->pdtnParent)
        pdtn = pdtn->pdtnParent;

    return(pdtn->ConnectedInfo.dwConfirmation);
}

BOOL DTGetWin32FindData(PDIRTREENODE pdtn, WIN32_FIND_DATA* pfd)
{
    HRESULT hr;
    BOOL fOk = TRUE;

    // only the stuff we care about
    hr = StringCchCopy(pfd->cAlternateFileName, ARRAYSIZE(pfd->cAlternateFileName), pdtn->szShortName);
    if (FAILED(hr))
    {
        fOk = FALSE;
    }

    hr = StringCchCopy(pfd->cFileName, ARRAYSIZE(pfd->cFileName), pdtn->szName);
    if (FAILED(hr))
    {
        fOk = FALSE;
    }
    
    pfd->dwFileAttributes = pdtn->dwFileAttributes;
    pfd->ftCreationTime   = pdtn->ftCreationTime;
    pfd->ftLastWriteTime  = pdtn->ftLastWriteTime;
    pfd->nFileSizeLow     = pdtn->nFileSizeLow;
    pfd->nFileSizeHigh     = pdtn->nFileSizeHigh;

    return fOk;
}

void DTSetFileCopyProgress(PDIRTREEHEADER pdth, LARGE_INTEGER liRead)
{
    LARGE_INTEGER liDelta;

    liDelta.QuadPart = (liRead.QuadPart - pdth->pdtnCurrent->liFileSizeCopied.QuadPart);

    DebugMsg(TF_DEBUGCOPY, TEXT("DTSetFileCopyProgress %d %d %d"), liDelta.LowPart, liRead.LowPart, pdth->dtDone.liSize.QuadPart);
    pdth->pdtnCurrent->liFileSizeCopied.QuadPart += liDelta.QuadPart;
    pdth->dtDone.liSize.QuadPart += liDelta.QuadPart;
    DebugMsg(TF_DEBUGCOPY, TEXT("DTSetFileCopyProgress %d %d"), liDelta.LowPart, pdth->dtDone.liSize.LowPart);
    pdth->dtDone.fChanged = TRUE;
}

void DTFreeNode(PDIRTREEHEADER pdth, PDIRTREENODE pdtn)
{
    if (pdth)
    {
        ASSERT(pdtn->pdtnChild == NULL || pdtn->pdtnChild == DTN_DELAYED);

        // we're done with this node..  update the header totals
        if (DTNIsDirectory(pdtn))
        {
            pdth->dtDone.dwFolders++;
        }
        else
        {
            LARGE_INTEGER li;

            li.LowPart = pdtn->nFileSizeLow;
            li.HighPart = pdtn->nFileSizeHigh;

            pdth->dtDone.dwFiles++;
            pdth->dtDone.liSize.QuadPart += (li.QuadPart - pdtn->liFileSizeCopied.QuadPart);
        }

        pdth->dtDone.fChanged = TRUE;

        // repoint parent pointer
        if (!pdtn->pdtnParent)
        {

            // no parent... must be a root type thing
            ASSERT(pdth->pdtn == pdtn);
            pdth->pdtn = pdtn->pdtnNext;

        }
        else
        {

            ASSERT(pdtn->pdtnParent->pdtnChild == pdtn);
            if (pdtn->pdtnParent->pdtnChild == pdtn)
            {
                // if my parent was pointing to me, point him to my sib
                pdtn->pdtnParent->pdtnChild = pdtn->pdtnNext;
            }
        }
    }

    LocalFree(pdtn);
}

// this frees all children of (but NOT including) the current node.
// it doesn' free the current node because it's assumed that
// DTGoToNextNode will be called right afterwards, and that will
// free the current node
void DTFreeChildrenNodes(PDIRTREEHEADER pdth, PDIRTREENODE pdtn)
{
    PDIRTREENODE pdtnChild = pdtn->pdtnChild;
    while (pdtnChild && pdtnChild != DTN_DELAYED)
    {
        PDIRTREENODE pdtnNext = pdtnChild->pdtnNext;

        // recurse and free these children
        if (DTNIsDirectory(pdtnChild))
        {
            DTFreeChildrenNodes(pdth, pdtnChild);
        }

        DTFreeNode(pdth, pdtnChild);
        pdtnChild = pdtnNext;
    }

    pdtn->pdtnChild = NULL;
}

void DTForceEnumChildren(PDIRTREEHEADER pdth)
{
    if (!pdth->pdtnCurrent->pdtnChild)
        pdth->pdtnCurrent->pdtnChild = DTN_DELAYED;
}

void DTAbortCurrentNode(PDIRTREEHEADER pdth)
{
    DTFreeChildrenNodes((pdth), (pdth)->pdtnCurrent);
    if (pdth->oper == OPER_ENTERDIR)
        pdth->oper = OPER_LEAVEDIR;
}

void DTCleanup(PDIRTREEHEADER pdth)
{
    PDIRTREENODE pdtn;

    while (pdth->pdtnCurrent && pdth->pdtnCurrent->pdtnParent)
    {
        // in case we bailed deep in a tree
        pdth->pdtnCurrent = pdth->pdtnCurrent->pdtnParent;
    }

    while (pdth->pdtnCurrent)
    {
        pdtn = pdth->pdtnCurrent;
        pdth->pdtnCurrent = pdtn->pdtnNext;
        DTFreeChildrenNodes(NULL, pdtn);
        DTFreeNode(NULL, pdtn);
    }
}

BOOL DTInitializePaths(PDIRTREEHEADER pdth, COPY_STATE *pcs)
{
    HRESULT hr;
    TCHAR szTemp[MAX_PATH];

    ASSERT(pdth->pdtnCurrent);    // If we have no current node then how can we Initialize its paths?
    
    hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pdth->pFrom);
    if (FAILED(hr))
    {
        return FALSE;
    }
    
    // For the "Origins" we need to do this only if a wild card exists. However, for connected elements,
    // we need to do this everytime because connected elements may not exist for every "Origins"
    if (PathIsWild(pdth->pFrom) || (pdth->pdtnCurrent->fNewRoot && DTNIsConnected(pdth->pdtnCurrent)))
    {
        PathRemoveFileSpec(szTemp);
        if (!PathAppend(szTemp, pdth->pdtnCurrent->szName))
            return FALSE;
    }

    hr = StringCchCopy(pdth->szSrcPath, ARRAYSIZE(pdth->szSrcPath), szTemp);
    if (FAILED(hr))
    {
        // This should never fail because pdth->szSrcPath is the same size (MAX_PATH) as szTemp
        return FALSE;
    }

    if (!pdth->pTo)
    {
        // no dest, make it the same as the source and we're done
        hr = StringCchCopy(pdth->szDestPath, ARRAYSIZE(pdth->szDestPath), pdth->szSrcPath);
        if (FAILED(hr))
        {
            return FALSE;
        }
        return TRUE;
    }

    hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pdth->pTo);
    if (FAILED(hr))
    {
        return FALSE;
    }

    if (!pdth->fMultiDest)
    {
        if (!PathAppend(szTemp, pdth->pdtnCurrent->szName))
            return FALSE;
    }
    else
    {
        //When undo of a move operation is done, fMultiDest is set.
        // When fMultiDest is set, we need to strip out the filename given by pTo and 
        // append the current filename.
        // For RENAME operations, the source and destination names are different. This is handled 
        // seperately below. So, we handle only other operations here where source and dest names are the same.
        if ((pcs->lpfo->wFunc != FO_RENAME) && pdth->pdtnCurrent->fNewRoot && DTNIsConnected(pdth->pdtnCurrent))
        {
            PathRemoveFileSpec(szTemp);
            if (!PathAppend(szTemp, pdth->pdtnCurrent->szName))
                return FALSE;
        }
    }

    hr = StringCchCopy(pdth->szDestPath, ARRAYSIZE(pdth->szDestPath), szTemp);
    if (FAILED(hr))
    {
        // This should never fail because pdth->szDestPath is the same size (MAX_PATH) as szTemp
        return FALSE;
    }

    //We will never try to rename a connected element! Make sure we don't hit this!
    ASSERT(!((pcs->lpfo->wFunc == FO_RENAME) && DTNIsConnected(pdth->pdtnCurrent)));

    return TRUE;

}

UINT DTValidatePathNames(PDIRTREEHEADER pdth, UINT operation, COPY_STATE * pcs)
{
    if (pcs->lpfo->wFunc != FO_DELETE)
    {
        // Why process name mappings?  Here's why.  If we are asked to copy directory "c:\foo" and
        // file "c:\foo\file" to another directory (say "d:\") we might have a name confilct when
        // we copy "c:\foo" so instead we create "d:\Copy Of foo".  Later, we walk to the second
        // dirtree node and we are asked to copy "c:\foo\file" to "d:\foo", all of which is valid.
        // HOWEVER, it's not what we want to do.  We use _ProccessNameMappings to convert
        // "d:\foo\file" into "d:\Copy of foo\file".
        _ProcessNameMappings(pdth->szDestPath, ARRAYSIZE(pdth->szDestPath), pdth->hdsaRenamePairs);
        
        // REVIEW, do we need to do the name mapping here or just let the
        // VFAT do it?  if vfat does it we need to rip out all of the GetNameDialog() stuff.

        if ((operation != OPER_LEAVEDIR) &&
                !IsLFNDrive(pdth->szDestPath) &&
                PathIsLFNFileSpec(PathFindFileName(pdth->szSrcPath)) &&
                PathIsLFNFileSpec(PathFindFileName(pdth->szDestPath)))
        {

            int iRet;
            TCHAR szOldDest[MAX_PATH];
            HRESULT hr;
            hr = StringCchCopy(szOldDest, ARRAYSIZE(szOldDest), pdth->szDestPath);
            if (FAILED(hr))
            {
                return OPER_ERROR | DE_INVALIDFILES;
            }

            iRet = GetNameDialog(pcs->hwndDlgParent, pcs,
                    (pcs->nSourceFiles != 1) || !DTNIsRootNode(pdth->pdtnCurrent), // if we're entering a dir, multiple spec, or not at root
                    operation, pdth->szSrcPath, pdth->szDestPath);

            switch (iRet)
            {
                case IDNO:
                case IDCANCEL:
                    return iRet;

                default:
                    AddRenamePairToHDSA(szOldDest, pdth->szDestPath, &pcs->dth.hdsaRenamePairs);
                    break;
            }
        }

        if (operation == OPER_ENTERDIR)
        {
            // Make sure the new directory is not a subdir of the original...

            int cchFrom = lstrlen(pdth->szSrcPath);

            // NTRAID89511-2000/02/25-KishoreP
            // Shouldn't we get the short names for both these directories and compair those?
            // Otherwise I can copy "C:\Long Directory Name" to "C:\LongDi~1\foo" without error.

            if (!(pcs->fFlags & FOF_RENAMEONCOLLISION) &&
                    !StrCmpNI(pdth->szSrcPath, pdth->szDestPath, cchFrom))
            {
                TCHAR chNext = pdth->szDestPath[cchFrom]; // Get the next char in the dest.

                if (!chNext)
                {
                    return OPER_ERROR | DE_DESTSAMETREE;
                }
                else if (chNext == TEXT('\\'))
                {
                    // The two fully qualified strings are equal up to the end
                    // of the source directory ==> the destination is a subdir.
                    // Must return an error.

                    // if, stripping the last file name and the backslash give the same length, they are the
                    // same file/folder
                    if ((PathFindFileName(pdth->szDestPath) - pdth->szDestPath - 1) ==
                            lstrlen(pdth->szSrcPath))
                    {
                        return OPER_ERROR | DE_DESTSAMETREE;
                    }
                    else
                    {
                        return OPER_ERROR | DE_DESTSUBTREE;
                    }
                }
            }
        }
    }
    return 0;
}

// this moves to the next node (child, sib, parent) and sets up the
// directory path info and oper state
UINT DTGoToNextNode(PDIRTREEHEADER pdth, COPY_STATE *pcs)
{
    UINT oper = OPER_ENTERDIR; // the default
    int iError;

    if (!pdth->pdtnCurrent)
    {
        pdth->pdtnCurrent = pdth->pdtn;

        if (pdth->pdtnCurrent)
        {
            if (pdth->pdtnCurrent->fDummy)
            {
                // if this is just a placeholder... go on to the next one
                return DTGoToNextNode(pdth, pcs);
            }

            if (!DTInitializePaths(pdth, pcs))
            {
                return OPER_ERROR | DE_INVALIDFILES;
            }
        }
        else
        {
            // Our tree is completely empty.

            // REVIEW: What do we do here?  If pdtnCurrent is still NULL then our list is completely empty.
            // Is that a bug or what?  My hunch is that we should return an error code here, most likely
            // OPER_ERROR | DE_INVALIDFILES.  If we do nothing here then we will fail silently.
            return OPER_ERROR | DE_INVALIDFILES;
        }
    }
    else
    {
        UINT iError;
        BOOL fFreeLastNode = TRUE;
        PDIRTREENODE pdtnLastCurrent = pdth->pdtnCurrent;
        TCHAR szTemp[MAX_PATH];
        HRESULT hr;

        if (iError = DTEnumChildren(pdth, pcs, FALSE, DTF_FILES_AND_FOLDERS))
            return iError;

        if (pdth->pdtnCurrent->pdtnChild)
        {

            fFreeLastNode = FALSE;
            pdth->pdtnCurrent = pdth->pdtnCurrent->pdtnChild;

            // if the source long name is too long, try the short name
            if (!PathCombine(szTemp, pdth->szSrcPath, pdth->pdtnCurrent->szName))
            {
                if (!PathCombine(szTemp, pdth->szSrcPath, pdth->pdtnCurrent->szShortName))
                {
                    return OPER_ERROR | DE_INVALIDFILES;
                }
            }
            hr = StringCchCopy(pdth->szSrcPath, ARRAYSIZE(pdth->szSrcPath), szTemp);
            if (FAILED(hr))
            {
                return OPER_ERROR | DE_INVALIDFILES;
            }

            // if the dest long name is too long, try the short name
            if (!PathCombine(szTemp, pdth->szDestPath, pdth->pdtnCurrent->szName))
            {
                if (!PathCombine(szTemp, pdth->szDestPath, pdth->pdtnCurrent->szShortName))
                {
                    return OPER_ERROR | DE_INVALIDFILES;
                }
            }
            hr = StringCchCopy(pdth->szDestPath, ARRAYSIZE(pdth->szDestPath), szTemp);
            if (FAILED(hr))
            {
                return OPER_ERROR | DE_INVALIDFILES;
            }
        }
        else if (pdth->oper == OPER_ENTERDIR)
        {
            // if the last operation was an enterdir and it has no children
            // (because it failed the above test
            // then we should do a leave dir on it now
            oper = OPER_LEAVEDIR;
            fFreeLastNode = FALSE;

        }
        else if (pdth->pdtnCurrent->pdtnNext)
        {
            pdth->pdtnCurrent = pdth->pdtnCurrent->pdtnNext;

            if (!pdth->pdtnCurrent->pdtnParent)
            {
                // if this was the top, we need to build the next path info
                // from scratch

                if (pdth->pdtnCurrent->fNewRoot)
                {
                    if (pdth->pdtnCurrent->fConnectedElement)
                    {
                        // Since this is a new root in a Connected list, the pFrom and pTo are
                        // stored in the node itself. This is needed because Connected elements may
                        // not exist for every item in the source list and we do not want to create dummy
                        // nodes for each one of them. So, pFrom and pTo are stored for every NewRoot of
                        // connected elements and we use these here.
                        pdth->pFrom = pdth->pdtnCurrent->ConnectedInfo.pFromConnected;
                        pdth->pTo = pdth->pdtnCurrent->ConnectedInfo.pToConnected;
                    }
                    else
                    {
                        // go to the next path pair
                        pdth->pFrom += lstrlen(pdth->pFrom) + 1;
                        if (pdth->pTo)
                        {
                            if (pdth->fMultiDest)
                            {
                                pdth->pTo += lstrlen(pdth->pTo) + 1;
                            }
                        }
                    }
                }

                if (pdth->pdtnCurrent->fDummy)
                {
                    // if this is just a placeholder... go on to the next one
                    if (fFreeLastNode)
                    {
                        DTFreeNode(pdth, pdtnLastCurrent);
                    }
                    return DTGoToNextNode(pdth, pcs);
                }

                DTInitializePaths(pdth, pcs);
            }
            else
            {

                PathRemoveFileSpec(pdth->szSrcPath);
                PathRemoveFileSpec(pdth->szDestPath);

                // if the source long name is too long, try the short name
                if (!PathCombine(szTemp, pdth->szSrcPath, pdth->pdtnCurrent->szName))
                {
                    if (!PathCombine(szTemp, pdth->szSrcPath, pdth->pdtnCurrent->szShortName))
                    {
                        return OPER_ERROR | DE_INVALIDFILES;
                    }
                }
                hr = StringCchCopy(pdth->szSrcPath, ARRAYSIZE(pdth->szSrcPath), szTemp);
                if (FAILED(hr))
                {
                    return OPER_ERROR | DE_INVALIDFILES;
                }

                // if the dest long name is too long, try the short name
                if (!PathCombine(szTemp, pdth->szDestPath, pdth->pdtnCurrent->szName))
                {
                    if (!PathCombine(szTemp, pdth->szDestPath, pdth->pdtnCurrent->szShortName))
                    {
                        return OPER_ERROR | DE_INVALIDFILES;
                    }
                }
                hr = StringCchCopy(pdth->szDestPath, ARRAYSIZE(pdth->szDestPath), szTemp);
                if (FAILED(hr))
                {
                    return OPER_ERROR | DE_INVALIDFILES;
                }
            }
        }
        else
        {
            oper = OPER_LEAVEDIR;
            PathRemoveFileSpec(pdth->szSrcPath);
            PathRemoveFileSpec(pdth->szDestPath);
            pdth->pdtnCurrent = pdth->pdtnCurrent->pdtnParent;
        }

        if (fFreeLastNode)
        {
            DTFreeNode(pdth, pdtnLastCurrent);
        }
    }

    if (!pdth->pdtnCurrent)
    {
        // no more!  we're done!
        return 0;
    }

    DebugDumpPDTN(pdth->pdtnCurrent, TEXT("PDTNCurrent"));

    if (oper == OPER_ENTERDIR)
    {
        if (pcs->lpfo->wFunc == FO_RENAME || !DTNIsDirectory(pdth->pdtnCurrent))
        {
            oper = OPER_DOFILE;
        }
    }

    if (DTNIsRootNode(pdth->pdtnCurrent))
    {
        // we need to diskcheck the source and target because this might
        // be the first time we've seen this drive
        if (!DTDiskCheck(pdth, pcs, pdth->szSrcPath) ||
                !DTDiskCheck(pdth, pcs, pdth->szDestPath))
        {
            pcs->bAbort = TRUE;
            return 0;
        }
    }

    iError = DTValidatePathNames(pdth, oper, pcs);
    if (iError)
    {
        if (iError & OPER_ERROR)
        {
            //For connected nodes, ignore the error and silently abort the node!
            if (DTNIsConnected(pdth->pdtnCurrent))
            {
                DTAbortCurrentNode(pdth);
                return DTGoToNextNode(pdth, pcs);
            }
            else
                return iError;
        }
        else
        {
            switch (iError) 
            {
                case IDNO:
                    DTAbortCurrentNode(pdth);
                    pcs->lpfo->fAnyOperationsAborted = TRUE;
                    return DTGoToNextNode(pdth, pcs);

                case IDCANCEL:
                    // User cancelled the operation
                    pcs->bAbort = TRUE;
                    return 0;
            }
        }
    }

    pdth->oper = oper;
    return oper;
}

int  CopyMoveRetry(COPY_STATE *pcs, LPCTSTR pszDest, int error, ULARGE_INTEGER* puliFileSize);
void CopyError(LPCOPY_STATE, LPCTSTR, LPCTSTR, int, UINT, int);

void SetProgressTime(COPY_STATE *pcs);
void SetProgressText(COPY_STATE *pcs, LPCTSTR pszFrom, LPCTSTR pszTo);
void FOUndo_AddInfo(UNDOATOM *lpua, LPTSTR lpszSrc, LPTSTR lpszDest, DWORD dwAttributes);
void CALLBACK FOUndo_Release(UNDOATOM *lpua);
void FOUndo_FileReallyDeleted(LPTSTR lpszFile);
void AddRenamePairToHDSA(LPCTSTR pszOldPath, LPCTSTR pszNewPath, HDSA* phdsaRenamePairs);
BOOL_PTR CALLBACK FOFProgressDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

typedef struct {
    LPTSTR lpszName;
    DWORD dwAttributes;
} FOUNDO_DELETEDFILEINFO, *LPFOUNDO_DELETEDFILEINFO;

typedef struct {
    HDPA hdpa;
    HDSA hdsa;
} FOUNDODATA, *LPFOUNDODATA;


void ReleasePCS(COPY_STATE *pcs)
{
    ASSERT( 0 != pcs->nRef );
    if (0 == InterlockedDecrement(&pcs->nRef))
    {
        SimplePidlCache_Release(&pcs->spc);
        LocalFree(pcs);
    }
}

DWORD CALLBACK AddRefPCS(COPY_STATE *pcs)
{
    return InterlockedIncrement(&pcs->nRef);
}

DWORD CALLBACK FOUIThreadProc(COPY_STATE *pcs)
{
    DebugMsg(TF_DEBUGCOPY, TEXT("FOUIThreadProc -- Begin"));

    Sleep(SHOW_PROGRESS_TIMEOUT);

    if (!pcs->fDone)
    {
        HWND hwndParent;
        FOUITHREADINFO fouiti = {0};

        ENTERCRITICAL;
        if (!pcs->fDone)
        {
            // need to check again within the critsec to make sure that pcs->lpfo is still valid
            fouiti.pcs = pcs;
            fouiti.wFunc = pcs->lpfo->wFunc;
            fouiti.bIsEmptyRBOp = ((pcs->lpfo->lpszProgressTitle == MAKEINTRESOURCE(IDS_BB_EMPTYINGWASTEBASKET)) ||
                    (pcs->lpfo->lpszProgressTitle == MAKEINTRESOURCE(IDS_BB_DELETINGWASTEBASKETFILES)));

            hwndParent = pcs->lpfo->hwnd;
        }
        LEAVECRITICAL;

        if (fouiti.pcs)
        {
            HWND hwnd = CreateDialogParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_MOVECOPYPROGRESS),
                    hwndParent, FOFProgressDlgProc, (LPARAM)&fouiti);
            if (hwnd)
            {
                MSG msg;
                DWORD dwShowTime;
                int iShowTimeLeft;

                // crit section to sync with main thread termination
                ENTERCRITICAL;
                if (!pcs->fDone)
                {
                    pcs->hwndProgress = hwnd;
                }
                LEAVECRITICAL;

                dwShowTime = GetTickCount();
                while (!pcs->fDone && GetMessage(&msg, NULL, 0, 0)) 
                {
                    if (!pcs->fDone && !IsDialogMessage(pcs->hwndProgress, &msg)) 
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                // if we've put it up, we need to keep it up for at least some minimal amount of time
                iShowTimeLeft = MINSHOWTIME - (GetTickCount() - dwShowTime);
                if (iShowTimeLeft > 0) 
                {
                    DebugMsg(TF_DEBUGCOPY, TEXT("FOUIThreadProc -- doing an extra sleep"));
                    Sleep(iShowTimeLeft);
                }

                // Keep us from doing this while other thread processing...
                ENTERCRITICAL;
                pcs->hwndProgress = NULL;
                LEAVECRITICAL;

                DestroyWindow(hwnd);
            }
        }
        else
        {
            // main thread must have finished
            ASSERT(pcs->fDone);
        }
    }
    ReleasePCS(pcs);

    DebugMsg(TF_DEBUGCOPY, TEXT("FOUIThreadProc -- End . Completed"));
    return 0;
}


// this queries the progress dialog for a cancel and yields.
// it also will show the progress dialog if a certain amount of time has passed
//
// returns:
//    TRUE      cacnel was pressed, abort the operation
//    FALSE     continue
BOOL FOQueryAbort(COPY_STATE *pcs)
{
    if (!pcs->bAbort && pcs->hwndProgress) 
    {
        if (pcs->hwndProgress != pcs->hwndDlgParent) 
        {
            // do this here rather than on the FOUIThreadProc so that we don't have
            // synchronization problems with this thread popping up a dialog on
            // hwndDlgParent then the progress dialog coming up afterwards on top.
            pcs->hwndDlgParent = pcs->hwndProgress;
            ShowWindow(pcs->hwndProgress, SW_SHOW);
            SetForegroundWindow(pcs->hwndProgress);
            SetFocus(GetDlgItem(pcs->hwndProgress, IDCANCEL));

            SetProgressText(pcs, pcs->dth.szSrcPath,
                    pcs->lpfo->wFunc == FO_DELETE ? NULL : pcs->dth.szDestPath);
        } 
        else 
        {
            MSG msg;

            // win95 handled messages in here.
            // we need to do the same in order to flush the input queue as well as
            // for backwards compatability.

            // we need to flush the input queue now because hwndProgress is
            // on a different thread... which means it has attached thread inputs
            // inorder to unlock the attached threads, we need to remove some
            // sort of message until there's none left... any type of message..
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (!IsDialogMessage(pcs->hwndProgress, &msg)) 
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        if (pcs->dth.dtAll.fChanged || pcs->dth.dtDone.fChanged) 
        {
            if (!pcs->dth.fChangePosted) 
            {
                // set the flag first because with async threads
                // the progress window could handle it and clear the
                // bit before we set it.. then we'd lose further messages
                // thinking that one was still pending
                pcs->dth.fChangePosted = TRUE;
                if (!PostMessage(pcs->hwndProgress, PDM_UPDATE, 0, 0))
                    pcs->dth.fChangePosted = FALSE;
            }
        }
    }

    return pcs->bAbort;
}




typedef struct _confdlg_data {
    LPCTSTR pFileDest;
    LPCTSTR pFileSource;
    LPCTSTR pStreamNames;
    const WIN32_FIND_DATA *pfdDest;
    const WIN32_FIND_DATA *pfdSource;

    BOOL bShowCancel;           // allow cancel out of this operation
    BOOL bShowDates;            // use date/size info in message
    UINT uDeleteWarning;        // warn that the delete's not going to the wastebasket
    BOOL bFireIcon;
    BOOL bShrinkDialog;         // should we move the buttons up to the text?
    int  nSourceFiles;          // if != 1 used to build "n files" string
    int idText;                 // if != 0 use to override string in dlg template
    CONFIRM_FLAG fConfirm;      // we will confirm things set here
    CONFIRM_FLAG fYesMask;      // these bits are cleared in fConfirm on "yes"
    // Only use fYesMask for things that should be confirmed once per operation
    CONFIRM_FLAG fYesToAllMask; // these bits are cleared in fConfirm on "yes to all"
    //COPY_STATE *pcs;
    CONFIRM_DATA *pcd;
    void (*InitConfirmDlg)(HWND hDlg, struct _confdlg_data *pcd);  // routine to initialize dialog
    BOOL bARPWarning; 
} CONFDLG_DATA;


BOOL BuildDateLine(LPTSTR pszDateLine, UINT cchDateLine, const WIN32_FIND_DATA *pFind, LPCTSTR pFileName)
{
    TCHAR szTemplate[64];
    TCHAR szNum[32], szTmp[64];
    WIN32_FIND_DATA fd;
    ULARGE_INTEGER liFileSize;

    if (!pFind) 
    {
        HANDLE hfind = FindFirstFile(pFileName, &fd);
        ASSERT(hfind != INVALID_HANDLE_VALUE);
        FindClose(hfind);
        pFind = &fd;
    }

    liFileSize.LowPart  = pFind->nFileSizeLow;
    liFileSize.HighPart = pFind->nFileSizeHigh;

    // There are cases where the date is 0, this is especially true when the 
    // source is from a file contents...
    if (pFind->ftLastWriteTime.dwLowDateTime || pFind->ftLastWriteTime.dwHighDateTime)
    {
        DWORD dwFlags = FDTF_LONGDATE | FDTF_RELATIVE | FDTF_LONGTIME;

        SHFormatDateTime(&pFind->ftLastWriteTime, &dwFlags, szTmp, SIZECHARS(szTmp));

        LoadString(HINST_THISDLL, IDS_DATESIZELINE, szTemplate, ARRAYSIZE(szTemplate));
        StringCchPrintf(pszDateLine, cchDateLine, szTemplate, StrFormatByteSize64(liFileSize.QuadPart, szNum, ARRAYSIZE(szNum)), szTmp);
    }
    else
    {
        // Simpy output the number to the string
        StrFormatByteSize64(liFileSize.QuadPart, pszDateLine, cchDateLine);
        if (liFileSize.QuadPart == 0)
            return FALSE;
    }
    return TRUE;    // valid data in the strings
}


// hide the cancel button and move "Yes" and "No" over to the right positions.
//
// "Yes" is IDYES
// "No"  is IDNO
//

#define HideYesToAllAndCancel(hdlg) HideConfirmButtons(hdlg, IDCANCEL)
#define HideYesToAllAndNo(hdlg) HideConfirmButtons(hdlg, IDNO)

void HideConfirmButtons(HWND hdlg, int idHide)
{
    HWND hwndCancel = GetDlgItem(hdlg, IDCANCEL);
    HWND hwndYesToAll = GetDlgItem(hdlg, IDD_YESTOALL);
    if (hwndCancel)
    {
        RECT rcCancel;
        HWND hwndNo;
        GetWindowRect(hwndCancel, &rcCancel);

        hwndNo = GetDlgItem(hdlg, IDNO);
        if (hwndNo)
        {
            RECT rcNo;
            HWND hwndYes;

            GetWindowRect(hwndNo, &rcNo);

            MapWindowRect(NULL, hdlg, &rcCancel);

            SetWindowPos(hwndNo, NULL, rcCancel.left, rcCancel.top,
                    0, 0, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE);

            hwndYes = GetDlgItem(hdlg, IDYES);
            if (hwndYes)
            {
                MapWindowRect(NULL, hdlg, &rcNo);

                SetWindowPos(hwndYes, NULL, rcNo.left, rcNo.top,
                        0, 0, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE);
            }
        }

        // Although the function is called "Hide", we actually destroy
        // the windows, because keyboard accelerators for hidden windows
        // are still active!
        if (hwndYesToAll)
            DestroyWindow(hwndYesToAll);
        DestroyWindow(GetDlgItem(hdlg, idHide));
    }
}

int MoveDlgItem(HWND hDlg, UINT id, int y)
{
    RECT rc;
    HWND hwnd = GetDlgItem(hDlg, id);
    if (hwnd)
    {
        GetWindowRect(hwnd, &rc);
        MapWindowRect(NULL, hDlg, &rc);
        SetWindowPos(hwnd, NULL, rc.left, y, 0,0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        return rc.top - y; // return how much it moved
    }
    return 0;
}

void ShrinkDialog(HWND hDlg, UINT idText)
{
    RECT rc;
    int y;
    HWND hwnd;
    hwnd = GetDlgItem(hDlg, idText);
    ASSERT(hwnd);
    GetWindowRect(hwnd, &rc);
    MapWindowRect(NULL, hDlg, &rc);
    y = rc.bottom + 12;

    // move all the buttons
    MoveDlgItem(hDlg, IDNO, y);
    MoveDlgItem(hDlg, IDCANCEL, y);
    MoveDlgItem(hDlg, IDD_YESTOALL, y);
    y = MoveDlgItem(hDlg, IDYES, y);

    // now resize the entire dialog
    GetWindowRect(hDlg, &rc);
    SetWindowPos(hDlg, NULL, 0, 0, rc.right - rc.left, rc.bottom - y - rc.top, SWP_NOMOVE | SWP_NOZORDER |SWP_NOACTIVATE);
}

void InitConfirmDlg(HWND hDlg, CONFDLG_DATA *pcd)
{
    TCHAR szMessage[255];
    TCHAR szDeleteWarning[80];
    TCHAR szSrc[32];
    TCHAR szFriendlyName[MAX_PATH];
    SHFILEINFO  sfi;
    SHFILEINFO sfiDest;
    LPTSTR pszFileDest = NULL;
    LPTSTR pszMsg, pszSource;
    int i;
    int cxWidth;
    RECT rc;
    HDC hdc;
    HFONT hfont;
    HFONT hfontSave;
    SIZE size;

    BOOL bIsARPWarning = pcd->bARPWarning;

    ASSERT((bIsARPWarning && (pcd->nSourceFiles == 1)) || (!bIsARPWarning));

    hdc = GetDC(hDlg);
    hfont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0);
    hfontSave = (HFONT)SelectObject(hdc, hfont);

    // get the size of the text boxes
    GetWindowRect(GetDlgItem(hDlg, pcd->idText), &rc);
    cxWidth = rc.right - rc.left;

    //
    // There are cases where, if the filename has no spaces, the static text
    // control will put the entire file name with our quote character down
    // on the 2nd line.  To account for this, we subtract off the width of a
    // the quote character. Since the quote character comes from the resource
    // string, it could really be just about an character, with just about
    // any width.  So we assume its about the width of the letter 0, which
    // should be more than wide enough.
    size.cx = 0;
    GetTextExtentPoint(hdc, TEXT("0"), 1, &size);
    cxWidth -= size.cx * 2;

    if (!bIsARPWarning && !pcd->bShowCancel)
        HideYesToAllAndCancel(hDlg);

    switch (pcd->nSourceFiles) 
    {
        case -1:
            LoadString(HINST_THISDLL, IDS_SELECTEDFILES, szSrc, ARRAYSIZE(szSrc));
            pszSource = szSrc;
            break;

        case 1:
            if (bIsARPWarning)
            {
                TCHAR szTarget[MAX_PATH];
                DWORD cchFriendlyName = ARRAYSIZE(szFriendlyName);
                HRESULT hres = GetPathFromLinkFile(pcd->pFileSource, szTarget, ARRAYSIZE(szTarget));
                if (S_OK == hres)
                {
                    if (SUCCEEDED(AssocQueryString(ASSOCF_VERIFY | ASSOCF_OPEN_BYEXENAME, ASSOCSTR_FRIENDLYAPPNAME,
                                    szTarget, NULL, szFriendlyName, &cchFriendlyName)))
                    {
                        pszSource = szFriendlyName;
                    }
                    else
                    {
                        pszSource = PathFindFileName(szTarget);
                    }
                }
                else if (S_FALSE == hres)
                {
                    TCHAR szProductCode[MAX_PATH];
                    szProductCode[0] = 0;

                    if ((ERROR_SUCCESS == MsiDecomposeDescriptor(szTarget, szProductCode, NULL, NULL, NULL)) && 
                            (ERROR_SUCCESS == MsiGetProductInfo(szProductCode, INSTALLPROPERTY_PRODUCTNAME, szFriendlyName, &cchFriendlyName)))
                    {
                        pszSource = szFriendlyName;
                    }
                    else
                        goto UNKNOWNAPP;

                }
                else
                {
UNKNOWNAPP:
                    LoadString(HINST_THISDLL, IDS_UNKNOWNAPPLICATION, szSrc, ARRAYSIZE(szSrc));
                    pszSource = szSrc;
                }
            }
            else
            {
                SHGetFileInfo(pcd->pFileSource,
                        (pcd->fConfirm==CONFIRM_DELETE_FOLDER || pcd->fConfirm==CONFIRM_WONT_RECYCLE_FOLDER)? FILE_ATTRIBUTE_DIRECTORY : 0,
                        &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES);
                pszSource = sfi.szDisplayName;
                PathCompactPath(hdc, pszSource, cxWidth);
            }
            break;

        default:
            pszSource = AddCommas(pcd->nSourceFiles, szSrc, ARRAYSIZE(szSrc));
            break;
    }

    // if we're supposed to show the date info, grab the icons and format the date string
    if (pcd->bShowDates) 
    {
        SHFILEINFO  sfi2;
        TCHAR szDateSrc[64], szDateDest[64];
        
        BuildDateLine(szDateSrc, ARRAYSIZE(szDateSrc), pcd->pfdSource, pcd->pFileSource);
        SetDlgItemText(hDlg, IDD_FILEINFO_NEW,  szDateSrc);
        
        BuildDateLine(szDateDest, ARRAYSIZE(szDateSrc), pcd->pfdDest, pcd->pFileDest);
        SetDlgItemText(hDlg, IDD_FILEINFO_OLD,  szDateDest);

        SHGetFileInfo(pcd->pFileDest, pcd->pfdDest ? pcd->pfdDest->dwFileAttributes : 0, &sfi2, sizeof(sfi2),
                pcd->pfdDest ? (SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_LARGEICON) : (SHGFI_ICON|SHGFI_LARGEICON));
        ReplaceDlgIcon(hDlg, IDD_ICON_OLD, sfi2.hIcon);

        SHGetFileInfo(pcd->pFileSource, pcd->pfdSource ? pcd->pfdSource->dwFileAttributes : 0, &sfi2, sizeof(sfi2),
                pcd->pfdSource ? (SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_LARGEICON) : (SHGFI_ICON|SHGFI_LARGEICON));
        ReplaceDlgIcon(hDlg, IDD_ICON_NEW, sfi2.hIcon);
    }


    if (!bIsARPWarning)
    {
        // there are multiple controls:
        // IDD_TEXT contains regular text (normal file/folder)
        // IDD_TEXT1 - IDD_TEXT4 contain optional secondary text

        for (i = IDD_TEXT; i <= IDD_TEXT4; i++) 
        {
            if (i == pcd->idText) 
            {
                szMessage[0] = 0;
                GetDlgItemText(hDlg, i, szMessage, ARRAYSIZE(szMessage));
            } 
            else 
            {
                HWND hwndCtl = GetDlgItem(hDlg, i);
                if (hwndCtl)
                    ShowWindow(hwndCtl, SW_HIDE);
            }
        }
    }
    else
    {
        GetDlgItemText(hDlg, IDD_ARPWARNINGTEXT, szMessage, ARRAYSIZE(szMessage));
    }

    // REVIEW Is there some better way?  The code above always hides
    // this control, and I don't see a way around this

    if (pcd->pStreamNames) 
    {
        SetDlgItemText(hDlg, IDD_TEXT1, pcd->pStreamNames);
        ShowWindow(GetDlgItem(hDlg, IDD_TEXT1), SW_SHOW);
    }

    if (pcd->bShrinkDialog)
        ShrinkDialog(hDlg, pcd->idText);

    if (pcd->pFileDest) 
    {
        SHGetFileInfo(pcd->pFileDest, 0,
                &sfiDest, sizeof(sfiDest), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES);
        pszFileDest = sfiDest.szDisplayName;
        PathCompactPath(hdc, pszFileDest, cxWidth);
    }

    if (pcd->uDeleteWarning) 
    {
        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_BITBUCKET, &pidl)))
        {
            SHFILEINFO fi;

            if (SHGetFileInfo((LPCTSTR)pidl, 0, &fi, sizeof(fi), SHGFI_PIDL | SHGFI_ICON |SHGFI_LARGEICON))
            {
                ReplaceDlgIcon(hDlg, IDD_ICON_WASTEBASKET, fi.hIcon);
            }
            ILFree(pidl);
        }
        LoadString(HINST_THISDLL, pcd->uDeleteWarning, szDeleteWarning, ARRAYSIZE(szDeleteWarning));
    } 
    else
        szDeleteWarning[0] = 0;

    if (pcd->bFireIcon) 
    {
        ReplaceDlgIcon(hDlg, IDD_ICON_WASTEBASKET, LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_NUKEFILE), IMAGE_ICON, 0, 0, LR_LOADMAP3DCOLORS));
    }

    pszMsg = ShellConstructMessageString(HINST_THISDLL, szMessage,
            pszSource, pszFileDest, szDeleteWarning);

    if (pszMsg) 
    {
        SetDlgItemText(hDlg, pcd->idText, pszMsg);
        LocalFree(pszMsg);
    }


    SelectObject(hdc, hfontSave);
    ReleaseDC(hDlg, hdc);
}


BOOL_PTR CALLBACK ConfirmDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CONFDLG_DATA *pcd = (CONFDLG_DATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            pcd = (CONFDLG_DATA *)lParam;
            pcd->InitConfirmDlg(hDlg, pcd);
            break;

        case WM_DESTROY:
            // Handle case where the allocation of the PCD failed.
            if (!pcd)
                break;

            if (pcd->bShowDates) 
            {
                ReplaceDlgIcon(hDlg, IDD_ICON_NEW, NULL);
                ReplaceDlgIcon(hDlg, IDD_ICON_OLD, NULL);
            }

            ReplaceDlgIcon(hDlg, IDD_ICON_WASTEBASKET, NULL);
            break;

        case WM_COMMAND:
            if (!pcd)
                break;

            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
                case IDNO:
                    if (GetKeyState(VK_SHIFT) < 0)      // force NOTOALL
                    {
                        // I use the fYesToAllMask here.  There used to be a fNoToAllMask but I
                        // removed it.  When you select "No To All" what you are saying is that
                        // anything I would be saying yes to all for I am actually saying "no to
                        // all" for.  I feel that it is confusing and unnecessary to have both.
                        pcd->pcd->fNoToAll |= pcd->fYesToAllMask;
                    }
                    EndDialog(hDlg, IDNO);
                    break;

                case IDD_YESTOALL:
                    // pcd is the confirmation data for just this file/folder.  pcd->pcd is the
                    // confirm data for the entire copy operation.  When we get a Yes To All we
                    // remove the coresponding bits from the entire operation.
                    pcd->pcd->fConfirm &= ~pcd->fYesToAllMask;
                    EndDialog(hDlg, IDYES);
                    break;

                case IDYES:
                    // There are some messages that we only want to tell the use once even if they
                    // select Yes instead of Yes To All.  As such we sometimes remove bits from the
                    // global confirm state even on a simple Yes.  This mask is usually zero.
                    pcd->pcd->fConfirm &= ~pcd->fYesMask;
                    EndDialog(hDlg, IDYES);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code)
            {
                case NM_RETURN:
                case NM_CLICK:
                    {
                        TCHAR szModule[MAX_PATH];
                        if (GetSystemDirectory(szModule, ARRAYSIZE(szModule)))
                        {
                            if (PathAppend(szModule, TEXT("appwiz.cpl")))
                            {
                                TCHAR szParam[1 + MAX_PATH + 2 + MAX_CCH_CPLNAME]; // See MakeCPLCommandLine function
                                TCHAR szAppwiz[64];

                                LoadString(g_hinst, IDS_APPWIZCPL, szAppwiz, SIZECHARS(szAppwiz));
                                MakeCPLCommandLine(szModule, szAppwiz, szParam, ARRAYSIZE(szParam));
                                SHRunControlPanelEx(szParam, NULL, FALSE);
                            }
                        }
                        EndDialog(hDlg, IDNO);
                    }
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

void SetConfirmMaskAndText(CONFDLG_DATA *pcd, DWORD dwFileAttributes, LPCTSTR pszFile)
{
    if (IS_SYSTEM_HIDDEN(dwFileAttributes) && !ShowSuperHidden())
    {
        dwFileAttributes &= ~FILE_ATTRIBUTE_SUPERHIDDEN;
    }

    // we used to have a desktop.ini "ConfirmFileOp" flag that was set
    // to avoid this case, but there are no folders that are marked READONLY
    // or SYSTEM for a reason other than the shell, so don't consider any as such
    if ((dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)) &&
            (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        dwFileAttributes &= ~(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY);
    }

    if (dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
    {
        pcd->fConfirm = CONFIRM_SYSTEM_FILE;
        pcd->fYesToAllMask |= CONFIRM_SYSTEM_FILE;
        pcd->idText = IDD_TEXT2;
    }
    else if (dwFileAttributes & FILE_ATTRIBUTE_READONLY)
    {
        pcd->fConfirm = CONFIRM_READONLY_FILE;
        pcd->fYesToAllMask |= CONFIRM_READONLY_FILE;
        pcd->idText = IDD_TEXT1;
    }
    else if (pszFile && ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
            PathIsRegisteredProgram(pszFile))
    {
        pcd->fConfirm = CONFIRM_PROGRAM_FILE;
        pcd->fYesToAllMask |= CONFIRM_PROGRAM_FILE;
        pcd->idText = IDD_TEXT3;
    }
}


void PauseAnimation(COPY_STATE *pcs, BOOL bStop)
{
    // only called from within the hwndProgress wndproc so assum it's there
    if (bStop)
        Animate_Stop(GetDlgItem(pcs->hwndProgress, IDD_ANIMATE));
    else
        Animate_Play(GetDlgItem(pcs->hwndProgress, IDD_ANIMATE), -1, -1, -1);
}

// confirm a file operation UI.
//
// this routine uses the CONFIRM_DATA in the copy state structure to
// decide if it needs to put up a dailog to confirm the given file operation.
//
// in:
//    pcs           current copy state (confirm flags, hwnd)
//    fConfirm      only one bit may be set! (operation to confirm)
//    pFileSource   source file
//    pFileDest     optional destination file
//    pfdSource
//    pfdDest       find data describing the destination
//
// returns:
//      IDYES
//      IDNO
//      IDCANCEL
//      ERROR_ (DE_) error codes (DE_MEMORY)
//
int ConfirmFileOp(HWND hwnd, COPY_STATE *pcs, CONFIRM_DATA *pcd,
        int nSourceFiles, int cDepth, CONFIRM_FLAG fConfirm,
        LPCTSTR pFileSource, const WIN32_FIND_DATA *pfdSource,
        LPCTSTR pFileDest,   const WIN32_FIND_DATA *pfdDest,
        LPCTSTR pStreamNames)
{
    int dlg;
    int ret;
    CONFDLG_DATA cdd;
    CONFIRM_FLAG fConfirmType;

    if (pcs)
        nSourceFiles = pcs->nSourceFiles;

    cdd.pfdSource = pfdSource;
    cdd.pfdDest = NULL; // pfdDest is only partially filed in
    cdd.pFileSource = pFileSource;
    cdd.pFileDest = pFileDest;
    cdd.pcd = pcd;
    cdd.fConfirm      = fConfirm;       // default, changed below
    cdd.fYesMask      = 0;
    cdd.fYesToAllMask = 0;
    cdd.nSourceFiles = 1;               // default to individual file names in message
    cdd.idText = IDD_TEXT;              // default string from the dlg template
    cdd.bShowCancel = ((nSourceFiles != 1) || cDepth);
    cdd.uDeleteWarning = 0;
    cdd.bFireIcon = FALSE;
    cdd.bShowDates = FALSE;
    cdd.bShrinkDialog = FALSE;
    cdd.InitConfirmDlg = InitConfirmDlg;
    cdd.pStreamNames   = NULL;
    cdd.bARPWarning    = FALSE;

    fConfirmType = fConfirm & CONFIRM_FLAG_TYPE_MASK;

    switch (fConfirmType)
    {
        case CONFIRM_DELETE_FILE:
        case CONFIRM_DELETE_FOLDER:
            {
                BOOL bIsFolderShortcut = FALSE;

                cdd.bShrinkDialog = TRUE;
                // find data for source is in pdfDest
                if ((nSourceFiles != 1) && (pcd->fConfirm & CONFIRM_MULTIPLE))
                {
                    // this is the special CONFIRM_MULTIPLE case (usuall SHIFT+DELETE, or
                    // SHIFT+DRAG to Recycle Bin). if the user says yes to this, they 
                    // basically get no more warnings.
                    cdd.nSourceFiles = nSourceFiles;
                    if ((fConfirm & CONFIRM_WASTEBASKET_PURGE) ||
                            (!pcs || !(pcs->fFlags & FOF_ALLOWUNDO)) ||
                            !BBWillRecycle(cdd.pFileSource, NULL))
                    {
                        // have the fire icon and the REALLY delete warning
                        cdd.uDeleteWarning = IDS_FOLDERDELETEWARNING;
                        cdd.bFireIcon = TRUE;
                        if (pcs)
                            pcs->fFlags &= ~FOF_ALLOWUNDO;

                        if (nSourceFiles == -1)
                        {
                            // -1 indicates that there were >= MAX_EMPTY_FILES files, so we stoped counting
                            // them all up for perf. We use the more generic message in this case.
                            cdd.idText = IDD_TEXT3;
                        }
                        else
                        {
                            // use the "are you sure you want to nuke XX files?" message
                            cdd.idText = IDD_TEXT4;
                        }
                    }
                    else
                    {
                        // uDeleteWarning must be set for the proper recycle icon to be loaded.
                        cdd.uDeleteWarning = IDS_FOLDERDELETEWARNING;
                    }

                    if (!pcs || !pcs->fNoConfirmRecycle)
                    {
                        POINT ptInvoke;
                        HWND hwndPos = NULL;

                        if ((GetNumberOfMonitors() > 1) && GetCursorPos(&ptInvoke))
                        {
                            HMONITOR hMon = MonitorFromPoint(ptInvoke, MONITOR_DEFAULTTONULL);
                            if (hMon)
                            {
                                hwndPos = _CreateStubWindow(&ptInvoke, hwnd);
                            }
                        }

                        ret = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_DELETE_MULTIPLE), hwndPos ? hwndPos : hwnd, ConfirmDlgProc, (LPARAM)&cdd);

                        if (hwndPos)
                        {
                            DestroyWindow(hwndPos);
                        }

                        if (ret != IDYES)
                        {
                            return IDCANCEL;
                        }
                    }

                    // clear all other possible warnings
                    pcd->fConfirm &= ~(CONFIRM_MULTIPLE | CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER);
                    cdd.fConfirm &= ~(CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER);
                    cdd.nSourceFiles = 1;       // use individual file name
                }

                SetConfirmMaskAndText(&cdd, pfdDest->dwFileAttributes, cdd.pFileSource);

                if ((pfdDest->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && 
                        PathIsShortcut(cdd.pFileSource, pfdDest->dwFileAttributes))
                {
                    // Its a folder and its a shortcut... must be a FolderShortcut!
                    bIsFolderShortcut = TRUE;

                    // since its a folder, we need to clear out all of these warnings
                    cdd.fYesMask      |= CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_MULTIPLE;
                    cdd.fYesToAllMask |= CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_MULTIPLE;
                }

                // we want to treat FolderShortcuts as "files" instead of folders. We do this so we don't display dialogs
                // that say stuff like "do you want to delete this and all of its contents" when to the user, this looks like
                // an item instead of a folder (eg nethood shortcut).
                if ((fConfirmType == CONFIRM_DELETE_FILE) || bIsFolderShortcut)
                {
                    dlg = DLG_DELETE_FILE;
                    if ((nSourceFiles == 1) && PathIsShortcutToProgram(cdd.pFileSource))
                    {
                        dlg = DLG_DELETE_FILE_ARP;
                        cdd.idText = IDD_ARPWARNINGTEXT;
                        cdd.bShrinkDialog = FALSE;
                        cdd.bARPWarning = TRUE;
                    }

                    if ((fConfirm & CONFIRM_WASTEBASKET_PURGE)      ||
                            (!pcs || !(pcs->fFlags & FOF_ALLOWUNDO))    ||
                            !BBWillRecycle(cdd.pFileSource, NULL))
                    {
                        // we are really nuking it, so show the appropriate icon/dialog
                        cdd.bFireIcon = TRUE;

                        if (pcs)
                        {
                            pcs->fFlags &= ~FOF_ALLOWUNDO;
                        }

                        cdd.uDeleteWarning = IDS_FILEDELETEWARNING;

                        if (cdd.idText == IDD_TEXT)
                        {
                            cdd.idText = IDD_TEXT4;
                        }
                    }
                    else
                    {
                        // we are recycling it
                        cdd.uDeleteWarning = IDS_FILERECYCLEWARNING;
                    }

                }
                else
                {
                    // fConfirmType == CONFIRM_DELETE_FOLDER
                    if (pcs)
                    {
                        // show cancel on NEXT confirm dialog
                        pcs->nSourceFiles = -1;
                    }

                    cdd.fYesMask      |= CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_MULTIPLE;
                    cdd.fYesToAllMask |= CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_MULTIPLE;

                    dlg = DLG_DELETE_FOLDER;

                    if ((fConfirm & CONFIRM_WASTEBASKET_PURGE)      ||
                            (!pcs || !(pcs->fFlags & FOF_ALLOWUNDO))    ||
                            !BBWillRecycle(cdd.pFileSource, NULL))
                    {
                        // we are really nuking it, so show the appropriate icon/dialog
                        cdd.bFireIcon = TRUE;

                        if (pcs)
                        {
                            pcs->fFlags &= ~FOF_ALLOWUNDO;
                        }

                        cdd.uDeleteWarning = IDS_FOLDERDELETEWARNING;
                    }
                    else
                    {
                        // we are recycling it
                        cdd.uDeleteWarning = IDS_FOLDERRECYCLEWARNING;
                    }
                }

                //
                // NTRAID#NTBUG9-100335-2001/01/03-jeffreys
                // See also #128485 in the OSR v 4.1 database
                //
                // The fix for 128485 added the BBWillRecycle check below, but this
                // caused NTBUG9-100335.  These 2 bugs say the opposite things.
                // We've had several customer complaints (see dupes of 100335)
                // so I'm putting it back to the way it worked in Windows 2000.
                //
                if (pcs && pcs->fNoConfirmRecycle /*&& BBWillRecycle(cdd.pFileSource, NULL)*/)
                {
                    cdd.fConfirm = 0;
                }
            }
            break;

        case CONFIRM_WONT_RECYCLE_FILE:
        case CONFIRM_WONT_RECYCLE_FOLDER:
            cdd.bShrinkDialog = TRUE;
            cdd.nSourceFiles = 1;
            cdd.bFireIcon = TRUE;
            cdd.idText = IDD_TEXT;
            cdd.fYesMask = CONFIRM_MULTIPLE;
            cdd.fConfirm = fConfirmType;
            cdd.fYesToAllMask = fConfirmType | CONFIRM_MULTIPLE;

            // set the dialog to be file or folder
            if (fConfirmType == CONFIRM_WONT_RECYCLE_FOLDER)
            {
                dlg = DLG_WONT_RECYCLE_FOLDER;
            }
            else
            {
                dlg = DLG_WONT_RECYCLE_FILE;
            }
            break;

        case CONFIRM_PATH_TOO_LONG:
            cdd.bShrinkDialog = TRUE;
            cdd.nSourceFiles = 1;
            cdd.bFireIcon = TRUE;
            cdd.idText = IDD_TEXT;
            cdd.fYesMask = CONFIRM_MULTIPLE;
            cdd.fConfirm = CONFIRM_PATH_TOO_LONG;
            cdd.fYesToAllMask = CONFIRM_PATH_TOO_LONG | CONFIRM_MULTIPLE;
            dlg = DLG_PATH_TOO_LONG;
            break;

        case CONFIRM_WONT_RECYCLE_OFFLINE:
            cdd.bShrinkDialog = TRUE;
            cdd.nSourceFiles = 1;
            cdd.bFireIcon = TRUE;
            cdd.idText = IDD_TEXT;
            cdd.fYesMask = CONFIRM_MULTIPLE;
            cdd.fConfirm = fConfirmType;
            cdd.fYesToAllMask = fConfirmType | CONFIRM_MULTIPLE;
            dlg = DLG_WONT_RECYCLE_OFFLINE;
            break;

        case CONFIRM_STREAMLOSS:
            cdd.bShrinkDialog = FALSE;
            cdd.nSourceFiles  = 1;
            cdd.idText        = IDD_TEXT;
            cdd.fConfirm      = CONFIRM_STREAMLOSS;
            cdd.fYesToAllMask = CONFIRM_STREAMLOSS;
            cdd.pStreamNames  = pStreamNames;
            dlg = DLG_STREAMLOSS_ON_COPY;
            break;

        case CONFIRM_FAILED_ENCRYPT:
            cdd.bShrinkDialog = FALSE;
            cdd.nSourceFiles = 1;
            cdd.idText = IDD_TEXT;
            cdd.bShowCancel = TRUE;
            cdd.fConfirm = CONFIRM_FAILED_ENCRYPT;
            cdd.fYesToAllMask = CONFIRM_FAILED_ENCRYPT;
            dlg = DLG_FAILED_ENCRYPT;
            break;

        case CONFIRM_LOST_ENCRYPT_FILE:
        case CONFIRM_LOST_ENCRYPT_FOLDER:
            cdd.bShrinkDialog = FALSE;
            cdd.nSourceFiles = 1;
            cdd.idText = IDD_TEXT;
            cdd.bShowCancel = TRUE;
            cdd.fConfirm = CONFIRM_LOST_ENCRYPT_FILE | CONFIRM_LOST_ENCRYPT_FOLDER;
            cdd.fYesToAllMask = CONFIRM_LOST_ENCRYPT_FILE | CONFIRM_LOST_ENCRYPT_FOLDER;
            if (fConfirmType == CONFIRM_LOST_ENCRYPT_FILE)
            {
                dlg = DLG_LOST_ENCRYPT_FILE;
            }
            else
            {
                dlg = DLG_LOST_ENCRYPT_FOLDER;
            }
            break;

        case CONFIRM_REPLACE_FILE:
            cdd.bShowDates = TRUE;
            cdd.fYesToAllMask = CONFIRM_REPLACE_FILE;
            SetConfirmMaskAndText(&cdd, pfdDest->dwFileAttributes, NULL);
            dlg = DLG_REPLACE_FILE;
            break;

        case CONFIRM_REPLACE_FOLDER:
            cdd.bShowCancel = TRUE;
            if (pcs) pcs->nSourceFiles = -1;        // show cancel on NEXT confirm dialog
            // this implies operations on the files
            cdd.fYesMask = CONFIRM_REPLACE_FILE;
            cdd.fYesToAllMask = CONFIRM_REPLACE_FILE | CONFIRM_REPLACE_FOLDER;
            dlg = DLG_REPLACE_FOLDER;
            break;

        case CONFIRM_MOVE_FILE:
            cdd.fYesToAllMask = CONFIRM_MOVE_FILE;
            SetConfirmMaskAndText(&cdd, pfdSource->dwFileAttributes, NULL);
            dlg = DLG_MOVE_FILE;
            break;

        case CONFIRM_MOVE_FOLDER:
            cdd.bShowCancel = TRUE;
            cdd.fYesToAllMask = CONFIRM_MOVE_FOLDER;
            SetConfirmMaskAndText(&cdd, pfdSource->dwFileAttributes, cdd.pFileSource);
            dlg = DLG_MOVE_FOLDER;
            break;

        case CONFIRM_RENAME_FILE:
            SetConfirmMaskAndText(&cdd, pfdSource->dwFileAttributes, NULL);
            dlg = DLG_RENAME_FILE;
            break;

        case CONFIRM_RENAME_FOLDER:
            cdd.bShowCancel = TRUE;
            if (pcs) pcs->nSourceFiles = -1;        // show cancel on NEXT confirm dialog
            SetConfirmMaskAndText(&cdd, pfdSource->dwFileAttributes, cdd.pFileSource);
            dlg = DLG_RENAME_FOLDER;
            break;

        default:
            DebugMsg(DM_WARNING, TEXT("bogus confirm option"));
            return IDCANCEL;
    }

    // Does this operation need to be confirmed?
    if (pcd->fConfirm & cdd.fConfirm)
    {
        // Has the user already said "No To All" for this operation?
        if ((pcd->fNoToAll & cdd.fConfirm) == cdd.fConfirm)
        {
            ret = IDNO;
        }
        else
        {
            // HACK for multimon, make sure the file operation dialog box comes
            // up on the correct monitor
            POINT ptInvoke;
            HWND hwndPos = NULL;

            if ((GetNumberOfMonitors() > 1) && GetCursorPos(&ptInvoke))
            {
                HMONITOR hMon = MonitorFromPoint(ptInvoke, MONITOR_DEFAULTTONULL);
                if (hMon)
                {
                    hwndPos = _CreateStubWindow(&ptInvoke, hwnd);
                }
            }
            ret = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(dlg), (hwndPos ? hwndPos : hwnd), ConfirmDlgProc, (LPARAM)&cdd);

            if (hwndPos)
                DestroyWindow(hwndPos);

            if (ret == -1)
                ret = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        ret = IDYES;
    }

    return ret;
}

//
//  DTNIsParentConnectOrigin()
//
//      When a folder ("c:\foo files") is moved to a different drive ("a:\"), the source and the
//  destinations have different roots, and therefore the "fRecursive" flag is turned ON by default.
//  This results in confirmations obtained for the individual files ("c:\foo files\aaa.gif") 
// rather than the folder itself. We need to first find the parent and then save the confirmation 
// in the connected element of it's parent. This function gets the top-most parent and then
// checks to see if it is a connect origin and if so returns that parent pointer.
//

PDIRTREENODE DTNGetConnectOrigin(PDIRTREENODE pdtn)
{
    PDIRTREENODE    pdtnParent = pdtn;

    //Get the top-level parent of the given node.
    while (pdtn)
    {
        pdtnParent = pdtn;
        pdtn = pdtn->pdtnParent;
    }

    //Now check if the parent is a connect origin.
    if (pdtnParent && DTNIsConnectOrigin(pdtnParent))
        return pdtnParent; //If so, return him.
    else
        return NULL;
}

//
// CachedConfirmFileOp()
//
//    When a file("foo.htm") is moved/copied, we may put up a confirmation dialog in case 
// of a conflict and the end-user might have responded saying "Yes", "no" etc., When the 
// corresponding connected element ("foo files") is also moved/copied etc., we should NOT put up
// a confirmation dialog again. We must simply store the answer to the original confirmation and
// use it later. 
//  
//  What this function does is: if the given node is a connected element, it simply retrieves the
// confirmation for the original operation and returns.  If the given element is NOT a connected 
// element, then this function calls the ConfirmFileOp and stores the confirmation result in 
// it's connected element sothat, it later it can be used by the connected element.
//

int CachedConfirmFileOp(HWND hwnd, COPY_STATE *pcs, CONFIRM_DATA *pcd,
        int nSourceFiles, int cDepth, CONFIRM_FLAG fConfirm,
        LPCTSTR pFileSource, const WIN32_FIND_DATA *pfdSource,
        LPCTSTR pFileDest,   const WIN32_FIND_DATA *pfdDest,
        LPCTSTR pStreamNames)

{
    int result;

    //See if this is a connected item.
    if (DTNIsConnected(pcs->dth.pdtnCurrent))
    {
        // Since this is a connected item, the confirmation must already have been obtained from
        // the user and get it from the cache!
        result = DTNGetConfirmationResult(pcs->dth.pdtnCurrent);
    }
    else
    {
        PDIRTREENODE    pdtnConnectOrigin;

        result = ConfirmFileOp(hwnd, pcs, pcd, nSourceFiles, cDepth, fConfirm, pFileSource, 
                pfdSource, pFileDest, pfdDest, pStreamNames);

        //Check if this node has a connection.
        if (pdtnConnectOrigin = DTNGetConnectOrigin(pcs->dth.pdtnCurrent))
        {
            pdtnConnectOrigin->pdtnConnected->ConnectedInfo.dwConfirmation = result;

            // PERF: Can we check for the result to be IDCANCEL or IDNO and if so make the
            // connected node a Dummy? Currently this won't work because current code assumes
            // that dummy nodes do not have children. This connected node might have some children.
            // if ((result == IDCANCEL) || (result == IDNO))
            //    pdtnConnectOrigin->pdtnConnected->fDummy = TRUE;
        }

    }

    return result;
}

void GuessAShortName(LPCTSTR p, LPTSTR szT)
{
    int i, j, fDot, cMax;

    for (i = j = fDot = 0, cMax = 8; *p; p++)
    {
        if (*p == TEXT('.'))
        {
            // if there was a previous dot, step back to it
            // this way, we get the last extension
            if (fDot)
                i -= j+1;

            // set number of chars to 0, put the dot in
            j = 0;
            szT[i++] = TEXT('.');

            // remember we saw a dot and set max 3 chars.
            fDot = TRUE;
            cMax = 3;
        }
        else if (j < cMax && (PathGetCharType(*p) & GCT_SHORTCHAR))
        {
            // if *p is a lead byte, we move forward one more
            if (IsDBCSLeadByte(*p))
            {
                szT[i] = *p++;
                if (++j >= cMax)
                    continue;
                ++i;
            }
            j++;
            szT[i++] = *p;
        }
    }
    szT[i] = 0;
}

/* GetNameDialog
 *
 *  Runs the dialog box to prompt the user for a new filename when copying
 *  or moving from HPFS to FAT.
 */

typedef struct {
    LPTSTR pszDialogFrom;
    LPTSTR pszDialogTo;
    BOOL bShowCancel;
} GETNAME_DATA;

BOOL_PTR CALLBACK GetNameDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szT[14];
    TCHAR szTo[MAX_PATH];
    GETNAME_DATA * pgn = (GETNAME_DATA *)GetWindowLongPtr(hDlg, DWLP_USER);
    HRESULT hr;
    BOOL fOk;

    switch (wMsg) 
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            pgn = (GETNAME_DATA *)lParam;

            // inform the user of the old name
            PathSetDlgItemPath(hDlg, IDD_FROM, pgn->pszDialogFrom);

            // directory the file will go into
            PathRemoveFileSpec(pgn->pszDialogTo);
            PathSetDlgItemPath(hDlg, IDD_DIR, pgn->pszDialogTo);

            // generate a guess for the new name
            GuessAShortName(PathFindFileName(pgn->pszDialogFrom), szT);

            fOk = FALSE;
            hr = StringCchCopy(szTo, ARRAYSIZE(szTo), pgn->pszDialogTo);
            if (SUCCEEDED(hr))
            {
                if (PathAppend(szTo, szT))
                {
                    // make sure that name is unique
                    if (PathYetAnotherMakeUniqueName(szTo, szTo, NULL, NULL))
                    {
                        fOk = TRUE;
                    }
                }
            }
            SetDlgItemText(hDlg, IDD_TO, fOk ? PathFindFileName(szTo) : TEXT(""));

            SendDlgItemMessage(hDlg, IDD_TO, EM_LIMITTEXT, 13, 0L);

            SHAutoComplete(GetDlgItem(hDlg, IDD_TO), 0);

            if (!pgn->bShowCancel)
                HideYesToAllAndNo(hDlg);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDD_YESTOALL:
                case IDYES:
                    GetDlgItemText(hDlg, IDD_TO, szT, ARRAYSIZE(szT));
                    if (szT[0] == TEXT('\0') || !PathCombine(szTo, pgn->pszDialogTo, szT))
                    {
                        // ignore the button press, since we can't use the name
                        break;
                    }
                    hr = StringCchCopy(pgn->pszDialogTo, MAX_PATH, szTo);
                    if (FAILED(hr))
                    {
                        // This should never fail because pdth->pszDestPath (what is passed to GetNameDialog as the pTo parameter)
                        // is the same size (MAX_PATH) as szTo
                        break;
                    }
                    PathQualify(pgn->pszDialogTo);
                    // fall through
                case IDNO:
                case IDCANCEL:
                    EndDialog(hDlg,GET_WM_COMMAND_ID(wParam, lParam));
                    break;

                case IDD_TO:
                    {
                        LPCTSTR p;
                        GetDlgItemText(hDlg, IDD_TO, szT, ARRAYSIZE(szT));
                        for (p = szT; *p; p = CharNext(p))
                        {
                            if (!(PathGetCharType(*p) & GCT_SHORTCHAR))
                                break;
                        }

                        EnableWindow(GetDlgItem(hDlg,IDYES), ((!*p) && (p != szT)));
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int GetNameDialog(HWND hwnd, COPY_STATE *pcs, BOOL fMultiple,UINT wOp, LPTSTR pFrom, LPTSTR pTo)
{
    int iRet;

    // if we don't want to confirm this, just mock up a string and return ok
    if (!(pcs->cd.fConfirm & CONFIRM_LFNTOFAT)) 
    {
        TCHAR szTemp[MAX_PATH];
        TCHAR szTo[MAX_PATH];
        HRESULT hr;

        GuessAShortName(PathFindFileName(pFrom), szTemp);
        hr = StringCchCopy(szTo, ARRAYSIZE(szTo), pTo);
        if (SUCCEEDED(hr))
        {
            PathRemoveFileSpec(szTo);
            if (PathAppend(szTo, szTemp))
            {
                HRESULT hr;

                // make sure that name is unique
                PathYetAnotherMakeUniqueName(szTo, szTo, NULL, NULL);
                iRet = IDYES;
                hr = StringCchCopy(pTo, MAX_PATH, szTo);
                if (FAILED(hr))
                {
                    // This should never fail because pdth->szDestPath (what is passed to GetNameDialog as the pTo parameter)
                    // is the same size (MAX_PATH) as szTo
                    iRet = IDCANCEL;
                }
            }
            else
            {
                // can't do this operation on a long path, cancel the operation
                iRet = IDCANCEL;
            }
        }
        else
        {
            iRet = IDCANCEL;
        }
    } 
    else 
    {
        GETNAME_DATA gn;
        gn.pszDialogFrom = pFrom;
        gn.pszDialogTo = pTo;
        gn.bShowCancel = fMultiple;

        iRet = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_LFNTOFAT), hwnd, GetNameDlgProc, (LPARAM)(GETNAME_DATA *)&gn);
        if (iRet == IDD_YESTOALL)
            pcs->cd.fConfirm &= ~CONFIRM_LFNTOFAT;
    }
    return iRet;
}

STDAPI_(void) SHFreeNameMappings(void *hNameMappings)
{
    HDSA hdsaRenamePairs = (HDSA)hNameMappings;
    int i;

    if (!hdsaRenamePairs)
        return;

    i = DSA_GetItemCount(hdsaRenamePairs) - 1;
    for (; i >= 0; i--)
    {
        SHNAMEMAPPING FAR* prp = DSA_GetItemPtr(hdsaRenamePairs, i);

        LocalFree(prp->pszOldPath);
        LocalFree(prp->pszNewPath);
    }

    DSA_Destroy(hdsaRenamePairs);
}

void _ProcessNameMappings(LPTSTR pszTarget, UINT cchTarget, HDSA hdsaRenamePairs)
{
    int i;

    if (!hdsaRenamePairs)
        return;

    for (i = DSA_GetItemCount(hdsaRenamePairs) - 1; i >= 0; i--)
    {
        TCHAR  cTemp;
        SHNAMEMAPPING FAR* prp = DSA_GetItemPtr(hdsaRenamePairs, i);

        //  I don't call StrCmpNI 'cause I already know cchOldPath, and
        //  it has to do a couple of lstrlen()s to calculate it.
        cTemp = pszTarget[prp->cchOldPath];
        pszTarget[prp->cchOldPath] = 0;

        //  Does the target match this collision renaming entry?
        // NOTE: We are trying to compare a path to a path.  prp->pszOldPath
        // does not have a trailing "\" character, so this isn't covered
        // by the lstrcmpi below.  As such, cTemp had best be the path
        // seperator character to ensure that the modified pszTarget is actually
        // a path and not a filename or a longer path name that doesn't match
        // but happens to start with the same characters as prp->pszOldPath.
        if ((cTemp == TEXT('\\')) && !lstrcmpi(pszTarget, prp->pszOldPath))
        {
            // Get subtree string of the target.
            TCHAR *pszSubTree = &(pszTarget[prp->cchOldPath + 1]);
            TCHAR szNewTarget[MAX_PATH];

            // Generate the new target path.
            if (PathCombine(szNewTarget, prp->pszNewPath, pszSubTree))
            {
                StringCchCopy(pszTarget, cchTarget, szNewTarget);    // Ok should never truncate
            }
            
            break;
        }
        else
        {
            // Restore the trounced character.
            pszTarget[prp->cchOldPath] = cTemp;
        }
    }
}

/* Sets the status dialog item in the modeless status dialog box. */

// used for both the drag drop status dialogs and the manual user
// entry dialogs so be careful what you change

void SetProgressText(COPY_STATE *pcs, LPCTSTR pszFrom, LPCTSTR pszTo)
{
    HWND hwndProgress = pcs->hwndProgress;

    if (hwndProgress && !(pcs->fFlags & FOF_SIMPLEPROGRESS))
    {
        TCHAR szFrom[MAX_PATH], szTo[MAX_PATH];
        LPTSTR pszMsg = NULL;

        HDC hdc;
        HFONT hfont;
        HFONT hfontSave;
        RECT rc;
        int cxWidth;
        SIZE size;
        HRESULT hr;

        //
        // Compute the size we can use for our file names (REVIEW: Cache this result?)
        //
        hdc = GetDC(hwndProgress);
        hfont = (HFONT)SendMessage(hwndProgress, WM_GETFONT, 0, 0);
        hfontSave = (HFONT)SelectObject(hdc, hfont);

        GetWindowRect(GetDlgItem(hwndProgress, IDD_TONAME), &rc);
        cxWidth = rc.right - rc.left;

        if (NULL != pszTo && pcs->fFlags & FOF_MULTIDESTFILES)
        {
            hr = StringCchCopy(szFrom, ARRAYSIZE(szFrom), pszTo);
        }
        else
        {
            hr = StringCchCopy(szFrom, ARRAYSIZE(szFrom), pszFrom);
        }

        if (SUCCEEDED(hr) || hr == STRSAFE_E_INSUFFICIENT_BUFFER)
        {
            PathStripPath(szFrom);
            PathCompactPath(hdc, szFrom, cxWidth);
        }
        else
        {
            szFrom[0] = TEXT('\0');
        }

        SetDlgItemText(hwndProgress, IDD_NAME, szFrom);

        hr = StringCchCopy(szFrom, ARRAYSIZE(szFrom), pszFrom);
        if (SUCCEEDED(hr) && szFrom[0] != TEXT('\0'))
        {
            LPTSTR pszResource = MAKEINTRESOURCE(IDS_FROM);
            LPTSTR pszToUsable = NULL;

            szTo[0] = TEXT('\0');
            if (pszTo)
            {
                pszToUsable = szTo;
                pszResource = MAKEINTRESOURCE(IDS_FROMTO);
            }

            pszMsg = ShellConstructMessageString(HINST_THISDLL,
                    pszResource, "", pszToUsable);

            if (NULL != pszMsg)
            {
                GetTextExtentPoint(hdc, pszMsg, lstrlen(pszMsg), &size);
                cxWidth -= size.cx;
                LocalFree(pszMsg);
            }

            //
            // Now build the file names
            //
            PathRemoveFileSpec(szFrom);
            PathStripPath(szFrom);

            if (pszTo)
            {
                PathCompactPath(hdc, szFrom, cxWidth/2);

                hr = StringCchCopy(szTo, ARRAYSIZE(szTo), pszTo);
                if (SUCCEEDED(hr) || hr == STRSAFE_E_INSUFFICIENT_BUFFER)
                {
                    PathRemoveFileSpec(szTo);
                    PathStripPath(szTo);

                    PathCompactPath(hdc, szTo, cxWidth/2);
                }
                else
                {
                    szTo[0] = TEXT('\0');
                }

            }
            else
            {
                PathCompactPath(hdc, szFrom, cxWidth);
            }

            //
            // Now create the real message
            //
            pszMsg = ShellConstructMessageString(HINST_THISDLL,
                    pszResource, szFrom, pszToUsable);

        } 
        else if (!pcs->fDTBuilt) 
        {
            TCHAR szFunc[80];
            if (LoadString(HINST_THISDLL, FOFuncToStringID(pcs->lpfo->wFunc),
                        szFunc, ARRAYSIZE(szFunc))) 
            {
                pszMsg = ShellConstructMessageString(HINST_THISDLL,
                        MAKEINTRESOURCE(IDS_PREPARINGTO), szFunc);
            }
        }

        if (pszMsg)
        {
            SetDlgItemText(hwndProgress, IDD_TONAME, pszMsg);
            LocalFree(pszMsg);
        }

        SelectObject(hdc, hfontSave);
        ReleaseDC(hwndProgress, hdc);

    }
}

void SetProgressTimeEst(COPY_STATE *pcs, DWORD dwTimeLeft)
{
    TCHAR szFmt[60];
    TCHAR szOut[70];
    DWORD dwTime;

    if (pcs->hwndProgress) 
    {
        if (dwTimeLeft > 4*60*60)           // 4 hours and over you get no text
        {
            szFmt[0] = TEXT('\0');
        }
        else if (dwTimeLeft > 60)
        {
            // Note that dwTime is at least 2, so we only need a plural form
            LoadString(HINST_THISDLL, IDS_TIMEEST_MINUTES, szFmt, ARRAYSIZE(szFmt));
            dwTime = (dwTimeLeft / 60) + 1;
        }
        else
        {
            LoadString(HINST_THISDLL, IDS_TIMEEST_SECONDS, szFmt, ARRAYSIZE(szFmt));
            // Round up to 5 seconds so it doesn't look so random
            dwTime = ((dwTimeLeft+4) / 5) * 5;
        }
        
        StringCchPrintf(szOut, ARRAYSIZE(szOut), szFmt, dwTime);
        SetDlgItemText(pcs->hwndProgress, IDD_TIMEEST, szOut);
    }
}


// this updates the animation, which could change because we could switch between 
// doing a move to recycle bin and really nuke if the file/folder was bigger that
// the allowable size of the recycle bin.
void UpdateProgressAnimation(COPY_STATE *pcs)
{
    if (pcs->hwndProgress && pcs->lpfo)
    {
        INT_PTR idAni, idAniCurrent;
        HWND hwndAnimation;
        switch (pcs->lpfo->wFunc) 
        {
            case FO_DELETE:
                if ((pcs->lpfo->lpszProgressTitle == MAKEINTRESOURCE(IDS_BB_EMPTYINGWASTEBASKET)) ||
                        (pcs->lpfo->lpszProgressTitle == MAKEINTRESOURCE(IDS_BB_DELETINGWASTEBASKETFILES))) 
                {
                    idAni = IDA_FILENUKE;
                    break;
                } 
                else if (!(pcs->fFlags & FOF_ALLOWUNDO)) 
                {
                    idAni = IDA_FILEDELREAL;
                    break;
                } // else fall through to default

            default:
                idAni = (IDA_FILEMOVE + (int)pcs->lpfo->wFunc - FO_MOVE);
        }

        hwndAnimation = GetDlgItem(pcs->hwndProgress,IDD_ANIMATE);

        idAniCurrent = (INT_PTR) GetProp(hwndAnimation, TEXT("AnimationID"));

        if (idAni != idAniCurrent)
        {
            // the one we should be using is different from the one we have, 
            // so update it

            // close the old clip
            Animate_Close(hwndAnimation);

            // open the new one
            Animate_Open(hwndAnimation, idAni);

            // if the window is enabled, start the new animation playing
            if (IsWindowEnabled(pcs->hwndProgress))
                Animate_Play(hwndAnimation, -1, -1, -1);

            // set the current idAni
            SetProp(hwndAnimation, TEXT("AnimationID"), (HANDLE)idAni);

            // at the same time we update the animation, we also update the text,
            // so that the two will always be in sync
            SetProgressText(pcs, pcs->dth.szSrcPath, pcs->lpfo->wFunc == FO_DELETE ? NULL : pcs->dth.szDestPath);
        }
    }
}


void SendProgressMessage(COPY_STATE *pcs, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (pcs->hwndProgress)
        SendDlgItemMessage(pcs->hwndProgress, IDD_PROBAR, uMsg, wParam, lParam);
}


//
// creates folder and all parts of the path if necessary (parent does not need
// to exists) and verifies that the contents of the folder will be visibile.
//
// in:
//    hwnd      hwnd to post UI on
//    pszPath   full path to create
//    psa       security attributes
//
// returns:
//      ERROR_SUCCESS (0)   success
//      ERROR_              failure
//

STDAPI_(int) SHCreateDirectoryEx(HWND hwnd, LPCTSTR pszPath, SECURITY_ATTRIBUTES *psa)
{
    int ret = ERROR_SUCCESS;

    if (PathIsRelative(pszPath))
    {
        // if not a "full" path bail
        // to ensure that we dont create a dir in the current working directory
        SetLastError(ERROR_BAD_PATHNAME);
        return ERROR_BAD_PATHNAME;
    }

    if (!Win32CreateDirectory(pszPath, psa)) 
    {
        TCHAR *pEnd, *pSlash, szTemp[MAX_PATH];
        HRESULT hr;

        ret = GetLastError();

        // There are certain error codes that we should bail out here
        // before going through and walking up the tree...
        switch (ret)
        {
            case ERROR_FILENAME_EXCED_RANGE:
            case ERROR_FILE_EXISTS:
            case ERROR_ALREADY_EXISTS:
                return ret;
        }
        
        hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszPath);
        if (FAILED(hr))
        {
            return ERROR_FILENAME_EXCED_RANGE;
        }

        pEnd = PathAddBackslash(szTemp); // for the loop below
        if (pEnd == NULL)
        {
            return ERROR_FILENAME_EXCED_RANGE;
        }

        // assume we have 'X:\' to start this should even work
        // on UNC names because will will ignore the first error

        pSlash = szTemp + 3;

        // create each part of the dir in order

        while (*pSlash) 
        {
            while (*pSlash && *pSlash != TEXT('\\'))
                pSlash = CharNext(pSlash);

            if (*pSlash) 
            {
                ASSERT(*pSlash == TEXT('\\'));

                *pSlash = 0;    // terminate path at seperator

                ret = Win32CreateDirectory(szTemp, pSlash + 1 == pEnd ? psa : NULL) ? ERROR_SUCCESS : GetLastError();

            }
            *pSlash++ = TEXT('\\');     // put the seperator back
        }
    }

    if (ERROR_SUCCESS != ret)
    {
        // We failed, so let's try to display error UI.
        if (hwnd && ERROR_CANCELLED != ret)
        {               
            SHSysErrorMessageBox(hwnd, NULL, IDS_CANNOTCREATEFOLDER, ret,
                    pszPath ? PathFindFileName(pszPath) : NULL, 
                    MB_OK | MB_ICONEXCLAMATION);

            ret = ERROR_CANCELLED; // Indicate we already displayed Error UI.
        }
    }   
    return ret;
}

STDAPI_(int) SHCreateDirectory(HWND hwnd, LPCTSTR pszPath)
{
    return SHCreateDirectoryEx(hwnd, pszPath, NULL);
}

#ifdef UNICODE
STDAPI_(int) SHCreateDirectoryExA(HWND hwnd, LPCSTR pszPath, SECURITY_ATTRIBUTES *psa)
{
    WCHAR wsz[MAX_PATH];
    SHAnsiToUnicode(pszPath, wsz, SIZECHARS(wsz));
    return SHCreateDirectoryEx(hwnd, wsz, psa);
}
#else
STDAPI_(int) SHCreateDirectoryExW(HWND hwnd, LPCWSTR pszPath, SECURITY_ATTRIBUTES *psa)
{
    char sz[MAX_PATH];
    SHUnicodeToAnsi(pszPath, sz, SIZECHARS(sz));
    return SHCreateDirectoryEx(hwnd, sz, psa);
}
#endif

// this function will move a file by copying it and then deleting it
// with proper error propagation and cleanup
BOOL MoveFileAsCopyAndDelete(LPCTSTR pszSource, LPCTSTR pszDest, LPPROGRESS_ROUTINE lpProgressRoutine,
                             void *lpData, BOOL *pbCancel, DWORD dwCopyFlags)
{
    BOOL bRet = FALSE;
    if (CopyFileEx(pszSource, pszDest, lpProgressRoutine, lpData, pbCancel, dwCopyFlags))
    {
        if (DeleteFile(pszSource))
        {
            // all is well in the world
            bRet = TRUE;
        }
        else
        {
            // couldn't delete the source - save the current GLE value, delete the dest, and return FALSE
            int iGLE = GetLastError();
            DeleteFile(pszDest);    // if this fails, life is hopeless
            SetLastError(iGLE);
        }
    }
    return bRet;
}

// call MPR to find out the speed of a given path
//
// returns
//        0 for unknown
//      144 for 14.4 modems
//       96 for 9600
//       24 for 2400
//
// if the device does not return a speed we return 0
//

DWORD GetPathSpeed(LPCTSTR pszPath)
{
    NETCONNECTINFOSTRUCT nci;
    NETRESOURCE nr;
    TCHAR szPath[MAX_PATH];
    HRESULT hr;

    hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath);
    if (FAILED(hr))
    {
        return 0;
    }

    PathStripToRoot(szPath);    // get a root to this path

    memset(&nci, 0, sizeof(nci));
    nci.cbStructure = sizeof(nci);

    memset(&nr, 0, sizeof(nr));
    if (PathIsUNC(szPath))
        nr.lpRemoteName = szPath;
    else
    {
        // Don't bother for local drives
        if (!IsRemoteDrive(DRIVEID(szPath)))
            return 0;

        // we are passing in a local drive and MPR does not like us to pass a
        // local name as Z:\ but only wants Z:
        szPath[2] = 0;   // Strip off after character and :
        nr.lpLocalName = szPath;
    }

    // dwSpeed is returned by MultinetGetConnectionPerformance
    MultinetGetConnectionPerformance(&nr, &nci);

    return nci.dwSpeed;
}


DWORD CopyCallbackProc(LARGE_INTEGER liTotSize, LARGE_INTEGER liBytes,
        LARGE_INTEGER liStreamSize, LARGE_INTEGER liStreamBytes,
        DWORD dwStream, DWORD dwCallback,
        HANDLE hSource, HANDLE hDest, void *pv)
{
    COPY_STATE *pcs = (COPY_STATE *)pv;

    DebugMsg(DM_TRACE, TEXT("CopyCallbackProc[%08lX], totsize=%08lX, bytes=%08lX"),
            dwCallback,  liTotSize.LowPart, liBytes.LowPart);

    if (FOQueryAbort(pcs))
        return PROGRESS_CANCEL;

    DTSetFileCopyProgress(&pcs->dth, liBytes);

    if (pcs->fInitialize)
    {
        // preserve the create date when moving across volumes, otherwise use the
        // create date the file system picked when we did the CreateFile()
        // always preserve modified date (ftLastWriteTime)
        // bummer is we loose accuracy when going to VFAT compared to NT servers

        SetFileTime((HANDLE)hDest, (pcs->lpfo->wFunc == FO_MOVE) ? &pcs->pfd->ftCreationTime : NULL,
                NULL, &pcs->pfd->ftLastWriteTime);

        pcs->fInitialize = FALSE;
    }

    switch (dwCallback)
    {
        case CALLBACK_STREAM_SWITCH:
            break;
        case CALLBACK_CHUNK_FINISHED:
            break;
        default:
            break;
    }
    return PROGRESS_CONTINUE;
}

// copy the SECURITY_DESCRIPTOR for two files
//
// in:
//      pszSource       fully qualified source path
//      pszDest         fully qualified destination path
//
// returns:
//      0       ERROR_SUCCESS
//      WIN32 error codes
//

    DWORD 
CopyFileSecurity(LPCTSTR pszSource, LPCTSTR pszDest)
{
    DWORD err = ERROR_SUCCESS;
    BOOL fRet = TRUE;
    BYTE buf[512];

    //    arbitrarily saying do everything we can
    //    except SACL_SECURITY_INFORMATION because
    SECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) buf;
    DWORD cbPsd = sizeof(buf);

    if (!SHRestricted(REST_FORCECOPYACLWITHFILE))
    {
        // shell restriction so return access denied?
        return ERROR_ACCESS_DENIED;
    }    

    fRet = GetFileSecurity(pszSource, si, psd, cbPsd, &cbPsd);
    if (!fRet)
    {
        err = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == err)
        {
            // just need to resize the buffer and try again

            psd = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, cbPsd);
            if (psd)
            {
                fRet = GetFileSecurity(pszSource, si, psd, cbPsd, &cbPsd);
            }
            else
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if (fRet)
    {
        fRet = SetFileSecurity(pszDest, si, psd);
        if (!fRet)
            err = GetLastError();
    }

    if (psd && psd != buf)
        LocalFree(psd);

    if (fRet)
        return ERROR_SUCCESS;

    return err;
}

// reset the SECURITY_DESCRIPTOR on a file or directory
//
// in:
//      pszDest         fully qualified destination path
//
// returns:
//      0       ERROR_SUCCESS
//      WIN32 error codes
//

    DWORD 
ResetFileSecurity(LPCTSTR pszDest)
{
    DWORD err = ERROR_SUCCESS;

    if (!SHRestricted(REST_FORCECOPYACLWITHFILE))
    {
        ACL acl;
        InitializeAcl(&acl, sizeof(acl), ACL_REVISION);

        // TreeResetNamedSecurityInfo has a callback mechanism, but
        // we currently don't use it. Note that the paths passed to
        // the callback look like
        //     "\Device\HarddiskVolume1\dir\name"

        err = TreeResetNamedSecurityInfo((LPTSTR)pszDest,
                SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                &acl,
                NULL,
                FALSE, // KeepExplicit (perms on children)
                NULL,
                ProgressInvokeNever,
                NULL);
    }

    return err;
}

//
// in:
//      hwnd            Window to report things to.
//      pszSource       fully qualified source path
//      pszDest         fully qualified destination path
//      pfd             source file find data (size/date/time/attribs)
//
// returns:
//      ERROR_SUCCESS (0)
//      other Win32 ERROR_ codes
//

UINT FileCopy(COPY_STATE *pcs, LPCTSTR pszSource, LPCTSTR pszDest, const WIN32_FIND_DATA *pfd, BOOL fCreateAlways)
{
    UINT iRet = ERROR_CANCELLED;
    BOOL fRetryPath = FALSE;
    BOOL fRetryAttr = FALSE;
    BOOL fCopyOrMoveSucceeded = FALSE;
    BOOL fSecurityObtained = FALSE;
    DWORD dwCopyFlags;
    BOOL fLostEncryptOk = FALSE;

    // Buffers for security info

    BYTE rgbSecurityDescriptor[512];
    SECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) rgbSecurityDescriptor;
    DWORD cbPsd = sizeof(rgbSecurityDescriptor);

    // Make sure we can start
    if (FOQueryAbort(pcs))
        return ERROR_CANCELLED;

    //
    // Now do the file copy/move
    //

    // Get the security info from the source file.  If there is a problem
    // (e.g. the file is on FAT) we ignore it and proceed with the copy/move.

    if (!(pcs->fFlags & FOF_NOCOPYSECURITYATTRIBS))
    {
        if (SHRestricted(REST_FORCECOPYACLWITHFILE))
        {
            if (GetFileSecurity(pszSource, si, psd, cbPsd, &cbPsd))
            {
                fSecurityObtained = TRUE;
            }
            else
            {
                if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
                {
                    psd = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, cbPsd);
                    if (psd)
                    {
                        if (GetFileSecurity(pszSource, si, psd, cbPsd, &cbPsd))
                        {
                            fSecurityObtained = TRUE;
                        }
                    }
                }
            }
        }
    }

TryCopyAgain:

    pcs->fInitialize = TRUE;
    pcs->pfd = pfd;
    SetProgressText(pcs, pszSource, pszDest);

    dwCopyFlags = 0;
    if (fLostEncryptOk)
    {
        dwCopyFlags |= COPY_FILE_ALLOW_DECRYPTED_DESTINATION;
    }
    if (!fCreateAlways)
    {
        dwCopyFlags |= COPY_FILE_FAIL_IF_EXISTS;
    }

    if (FO_MOVE == pcs->lpfo->wFunc)
    {
        fCopyOrMoveSucceeded = MoveFileWithProgress(pszSource, pszDest, CopyCallbackProc, pcs, MOVEFILE_COPY_ALLOWED | (fCreateAlways ? MOVEFILE_REPLACE_EXISTING : 0));

        if (!fCopyOrMoveSucceeded && 
            (dwCopyFlags & COPY_FILE_ALLOW_DECRYPTED_DESTINATION) && // this flag will only be set if we've already come through here once, then accepted the prompt below
            (GetLastError() == ERROR_ENCRYPTION_FAILED))
        {
            fCopyOrMoveSucceeded = 
                MoveFileAsCopyAndDelete(pszSource, pszDest, CopyCallbackProc, pcs, &pcs->bAbort, dwCopyFlags);
        }
    }
    else
    {
        fCopyOrMoveSucceeded = CopyFileEx(pszSource, pszDest, CopyCallbackProc, pcs, &pcs->bAbort, dwCopyFlags);
    }

    if (!fCopyOrMoveSucceeded)  
    {
        int iLastError = (int)GetLastError();

        DebugMsg(TF_DEBUGCOPY, TEXT("FileCopy() failed, get last error returned 0x%08x"), iLastError);

        switch (iLastError)
        {
            // Let the caller handle this one
            case ERROR_FILE_EXISTS:
            case ERROR_ALREADY_EXISTS: // nt5 221893 CopyFileEx now returns this for some reason...
                iRet = ERROR_FILE_EXISTS;
                goto Exit;

            case ERROR_DISK_FULL:
                if (PathIsUNC(pszDest) || !IsRemovableDrive(DRIVEID(pszDest)) || PathIsSameRoot(pszDest,pszSource))
                {
                    break;
                }

                iLastError = ERROR_DISK_FULL;
                // Fall through

            case ERROR_PATH_NOT_FOUND:
                if (!fRetryPath)
                {
                    // ask the user to stick in another disk or empty wastebasket
                    ULARGE_INTEGER ulFileSize;
                    ulFileSize.LowPart = pfd->nFileSizeLow;
                    ulFileSize.HighPart = pfd->nFileSizeHigh;
                    iLastError = CopyMoveRetry(pcs, pszDest, iLastError, &ulFileSize);
                    if (!iLastError)
                    {
                        fRetryPath = TRUE;
                        goto TryCopyAgain;
                    }
                    CopyError(pcs, pszSource, pszDest, (UINT)iLastError | ERRORONDEST, FO_COPY, OPER_DOFILE);
                    iRet = ERROR_CANCELLED;
                    goto Exit;
                }
                break;

            case ERROR_ENCRYPTION_FAILED:
                if (pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED && FALSE == fLostEncryptOk)
                {
                    int result;
                    result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs,
                            &pcs->cd, pcs->nSourceFiles,
                            FALSE,
                            CONFIRM_LOST_ENCRYPT_FILE,
                            pszSource, pfd, pszDest, NULL, NULL);

                    switch (result)
                    {
                        case IDYES:
                            fLostEncryptOk = TRUE;
                            goto TryCopyAgain;

                        case IDNO:
                        case IDCANCEL:
                            pcs->bAbort = TRUE;
                            iRet = result;
                            break;

                        default:
                            iRet = result;
                            break;
                    }
                }
                break;

            case ERROR_ACCESS_DENIED:
                // check if the filename is too long
                if (lstrlen(PathFindFileName(pszSource)) + lstrlen(pszDest) >= MAX_PATH)
                {
                    iLastError = DE_FILENAMETOOLONG;
                }
                else if (!fRetryAttr)
                {
                    // If the file is readonly, reset the readonly attribute
                    // and have another go at it
                    DWORD dwAttributes = GetFileAttributes(pszDest);
                    if (0xFFFFFFFF != dwAttributes)
                    {
                        dwAttributes &= ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
                        if (SetFileAttributes(pszDest, dwAttributes))
                        {
                            fRetryAttr = TRUE;
                            goto TryCopyAgain;
                        }
                    }

                    // GetFileAttributes() 10 lines above clobers GetLastError() and CopyError()
                    // needs it.
                    SetLastError(iLastError);
                }
                break;
        }

        if (!pcs->bAbort)
        {
            CopyError(pcs, pszSource, pszDest, iLastError, FO_COPY, OPER_DOFILE);
        }

        iRet = ERROR_CANCELLED;  // error already reported
        goto Exit;
    }

    // If copying from a CDRom - clear the read-only bit
    if (pcs->fFromCDRom)
    {
        SetFileAttributes(pszDest, pfd->dwFileAttributes & ~FILE_ATTRIBUTE_READONLY);
    }

    // Set the source's security on the destination, ignoring any error.
    if (fSecurityObtained)
    {
        SetFileSecurity(pszDest, si, psd);
    }


    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, pszDest, NULL);

    if (FO_MOVE == pcs->lpfo->wFunc)
    {
        // Let windows waiting on notifications of Source know of change.  We have to check
        // to see if the file is actually gone in order to tell if it actually moved or not.

        if (!PathFileExists(pszSource))
            SHChangeNotify(SHCNE_DELETE, SHCNF_PATH, pszSource, NULL);
    }
    else if (0 == StrCmpIC(pfd->cFileName, TEXT("desktop.ini")))
    {
        // clean out stuff from the desktop.ini
        WritePrivateProfileSection(TEXT("DeleteOnCopy"), NULL, pszDest);
    }

    iRet = ERROR_SUCCESS;   // 0

Exit:

    // If we had to alloc a buffer for the security descriptor,
    // free it now.

    if (psd && (rgbSecurityDescriptor != psd))
        LocalFree(psd);

    return iRet;
}

// note: this is a very slow call
DWORD GetFreeClusters(LPCTSTR szPath)
{
    DWORD dwFreeClus;
    DWORD dwTemp;

    if (GetDiskFreeSpace(szPath, &dwTemp, &dwTemp, &dwFreeClus, &dwTemp))
        return dwFreeClus;
    else
        return (DWORD)-1;
}

// note: this is a very slow call
BOOL TotalCapacity(LPCTSTR szPath, ULARGE_INTEGER *puliDiskSize)
{
    int idDrive = PathGetDriveNumber(szPath);
    if (idDrive != -1) 
    {
        TCHAR szDrive[5];
        ULARGE_INTEGER ullDiskFreeForUser;

        PathBuildRoot(szDrive, idDrive);

        return GetDiskFreeSpaceEx(szDrive, &ullDiskFreeForUser, puliDiskSize, NULL);
    }

    return FALSE;
}


typedef struct
{
    LPTSTR pszTitle;
    LPTSTR pszText;
} DISKERRORPARAM;

BOOL_PTR CALLBACK DiskErrDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
        case WM_INITDIALOG:
            {
                DISKERRORPARAM *pDiskError = (DISKERRORPARAM *) lParam;
                if (pDiskError)
                {
                    SetWindowText(hDlg, pDiskError->pszTitle);
                    SetDlgItemText(hDlg, IDC_DISKERR_EXPLAIN, pDiskError->pszText);
                }
                Static_SetIcon(GetDlgItem(hDlg, IDC_DISKERR_STOPICON), 
                        LoadIcon(NULL, IDI_HAND));
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                case IDC_DISKERR_LAUNCHCLEANUP:
                    EndDialog (hDlg, LOWORD(wParam));
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


void DisplayFileOperationError(HWND hParent, int idVerb, int wFunc, int nError, LPCTSTR pszReason, LPCTSTR pszPath, LPCTSTR pszDest)
{
    TCHAR szBuffer[80];
    DISKERRORPARAM diskparams;

    // Grab title from resource 
    if (LoadString(HINST_THISDLL, IDS_FILEERROR + wFunc, szBuffer, ARRAYSIZE(szBuffer)))
    {
        diskparams.pszTitle = szBuffer;
    }
    else
    { 
        diskparams.pszTitle = NULL;
    }

    // Build Message to display
    diskparams.pszText = ShellConstructMessageString(HINST_THISDLL, 
            MAKEINTRESOURCE(idVerb), pszReason, PathFindFileName(pszPath));

    if (diskparams.pszText)
    {
        int idDrive = DriveIDFromBBPath(pszDest);
        //if we want to show Disk cleanup do our stuff, otherwise do MessageBox
        if (nError == ERROR_DISK_FULL && 
                IsBitBucketableDrive(idDrive) &&
                !PathIsUNC(pszDest) &&
                GetDiskCleanupPath(NULL, 0))
        {
            if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_DISKERR), hParent,
                        DiskErrDlgProc, (LPARAM)&diskparams) == IDC_DISKERR_LAUNCHCLEANUP)
            {
                LaunchDiskCleanup(hParent, idDrive, DISKCLEANUP_NOFLAG);
            }
        }
        else
        {
            MessageBox(hParent, diskparams.pszText, diskparams.pszTitle, 
                    MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
        }
        LocalFree(diskparams.pszText);
    }
}


/***********************************************************************\
DESCRIPTION:
We received an SHARINGVIOLATION or ACCESSDENIED error.  We want
to generate the most accruate error message for the user to inform
them better.  These are the cases we care about:

ERROR_ACCESS_DENIED: This is the legacy case with the message:
"Access is denied. The source file may be in use."
DE_DEST_IS_CDROM:  This is displayed in case the user copies a file to
their cd-rom drive.
DE_DEST_IS_CDRECORD: user deletes from CD recordable drive, we need an error
message that isn't so scary about "cant copy files to CD".
DE_DEST_IS_DVD:  This is displayed in case the user copies a file to
their DVD drive
DE_SHARING_VIOLATION: The file can't be copied because it's open by someone
who doesn't allow others to read the file while they
use it.
DE_PERMISSIONDENIED:  This should be displayed if the user doesn't have
the ACLs (security permissions) to read/copy the file.
\***********************************************************************/
int GenAccessDeniedError(LPCTSTR pszSource, LPCTSTR pszDest, int nError)
{
    int nErrorMsg = ERROR_ACCESS_DENIED;
    int iDrive = PathGetDriveNumber(pszDest);

    if (iDrive != -1)
    {
        if (IsCDRomDrive(iDrive))
        {
            WCHAR szDrive[4];
            // check if user is deleting from cd-r drive.  error message saying "cant copy or move files to cd drive"
            // doesn't apply.  since we're about to put up ui its not like we have to be super fast here, call into cdburning code.
            if (SUCCEEDED(CDBurn_GetRecorderDriveLetter(szDrive, ARRAYSIZE(szDrive))) &&
                    (DRIVEID(szDrive) == iDrive))
            {
                nErrorMsg = DE_DEST_IS_CDRECORD;
            }
            else
            {
                nErrorMsg = DE_DEST_IS_CDROM;
            }
        }

        if (DriveIsDVD(iDrive))
            nErrorMsg = DE_DEST_IS_DVD;
    }

    // TODO: DE_SHARING_VIOLATION, DE_PERMISSIONDENIED
    return nErrorMsg;
}


//
// The following function reports errors for the copy engine
//
// Parameters
//      pszSource       source file name
//      pszDest         destination file name
//      nError          dos (or our exteneded) error code
//                      0xFFFF for special case NET error
//      wFunc           FO_* values
//      nOper           OPER_* values, operation being performed
//

void CopyError(LPCOPY_STATE pcs, LPCTSTR pszSource, LPCTSTR pszDest, int nError, UINT wFunc, int nOper)
{
    TCHAR szReason[200];
    TCHAR szFile[MAX_PATH];
    int idVerb;
    BOOL bDest;
    BOOL fSysError = FALSE;
    DWORD dwError = GetLastError();       // get Extended error now before we blow it away.
    HRESULT hr;

    if (!pcs || (pcs->fFlags & FOF_NOERRORUI))
        return;      // caller doesn't want to report errors

    bDest = nError & ERRORONDEST;        // was dest file cause of error
    nError &= ~ERRORONDEST;              // clear the dest bit

    // We also may need to remap some new error codes into old error codes
    //
    if (nError == ERROR_BAD_PATHNAME)
        nError = DE_INVALIDFILES;

    if (nError == ERROR_CANCELLED)        // user abort
        return;
    
    hr = StringCchCopy(szFile, ARRAYSIZE(szFile), bDest ? pszDest : pszSource);
    if (FAILED(hr) || szFile[0] == TEXT('\0'))
    {
        LoadString(HINST_THISDLL, IDS_FILE, szFile, ARRAYSIZE(szFile));
    }
    else
    {
        // make the path fits on the screen
        RECT rcMonitor;
        HWND hwnd = pcs->hwndProgress ? pcs->hwndProgress : pcs->hwndDlgParent;
        GetMonitorRect(MonitorFromWindow(hwnd, TRUE), &rcMonitor);

        PathCompactPath(NULL, szFile, (rcMonitor.right - rcMonitor.left) / 3);
    }

    // get the verb string
    // since we now recycle folders as well as files, added OPER_ENTERDIR check here
    if ((nOper == OPER_DOFILE) || (nOper == OPER_ENTERDIR) || (nOper == 0))
    {
        if ((nError != -1) && bDest)
        {
            idVerb = IDS_REPLACING;
        }
        else
        {
            idVerb = IDS_VERBS + wFunc;
        }
    }
    else
    {
        idVerb = IDS_ACTIONS + (nOper >> 8);
    }

    // get the reason string
    if (nError == 0xFFFF)
    {
        DWORD dw;
        WNetGetLastError(&dw, szReason, ARRAYSIZE(szReason), NULL, 0);
    }
    else
    {
        // transform some error cases

        if (bDest)
        {
            // This caseing of error codes is error prone.. it would
            // be better to find the explicit ones we wish to map to
            // this one instead of trying to guess all the ones
            // we don't want to map...
            if ((nError == ERROR_DISK_FULL) ||
                    ((nError != ERROR_ACCESS_DENIED) &&
                     (nError != ERROR_NETWORK_ACCESS_DENIED) &&
                     (nError != ERROR_WRITE_PROTECT) &&
                     (nError != ERROR_BAD_NET_NAME) &&
                     (GetFreeClusters(pszDest) == 0L)))
            {
                nError = ERROR_DISK_FULL;
            }
            else if (dwError == ERROR_WRITE_FAULT)
            {
                nError = ERROR_WRITE_FAULT;
            }
            else if (dwError == ERROR_INVALID_NAME)
            {
                nError = ERROR_INVALID_NAME;
            }
        }
        else
        {
            if (nError == ERROR_ACCESS_DENIED)
            {
                // Check the extended error for more info about the error...
                // We just map these errors to something generic that
                // tells the user something weird is going on.
                switch (dwError)
                {
                    case ERROR_CRC:
                    case ERROR_SEEK:
                    case ERROR_SECTOR_NOT_FOUND:
                    case ERROR_READ_FAULT:
                    case ERROR_GEN_FAILURE:
                        nError = ERROR_GEN_FAILURE;
                        break;


                        // We can't test for ERROR_FILE_NOT_FOUND because in the case where we copy to
                        // a write-protected dest we check to see if the reason we got access denied was
                        // because there's already a read-only file there.  If there isn't _that_ test is
                        // going to SetLastError() to ERROR_FILE_NOT_FOUND and that's what we're going to
                        // report as an error. [davepl]
                        // 
                        // case ERROR_FILE_NOT_FOUND:
                        //    nError = ERROR_GEN_FAILURE;
                        //    break;

                    case ERROR_SHARING_VIOLATION:
                    case ERROR_ACCESS_DENIED:
                        nError = GenAccessDeniedError(pszSource, pszDest, nError);
                        break;
                    default:
                        TraceMsg(TF_WARNING, "CopyEngine: hit error %x , not currently special cased", dwError);
                        break;
                }
            }
            else
            {
                // This error occures when a user drags & drops a file from point a to
                // point b twice.  The second time fails because the first time hasn't finished.
                if (nError == (OPER_ERROR | ERROR_FILE_NOT_FOUND))
                {
                    nError = ERROR_GEN_FAILURE;
                }
            }
        }
    }

    // the error munging above is in several places, but there are some errors that we
    // know for SURE the user will never want to see so zap them to generic failures.
    // this whole thing needs a redesign... we shouldnt depend generally on errors getting
    // UI ("There is not enough space on the disk.") because then we get crap like this.
    // but everybody already knows that.
    switch (nError)
    {
        case ERROR_SWAPERROR:             //  Error performing inpage operation.
            nError = ERROR_GEN_FAILURE;
            break;
    }

    if (nError <= DE_ERROR_MAX)
    {
        BOOL fOverridden = FALSE;

        if (nError == ERROR_SHARING_VIOLATION)
        {
            // in the sharing violation case we can try to be a little better in the error UI by
            // going through the running object table and seeing if the file is registered in there.
            // if it's not in there, no biggie, just use our normal handling.
            PWSTR pszApp;
            if (SUCCEEDED(FindAppForFileInUse(bDest ? pszDest : pszSource, &pszApp)))
            {
                PWSTR pszMessage = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_SHAREVIOLATION_HINT), pszApp);
                if (pszMessage)
                {
                    StringCchCopy(szReason, ARRAYSIZE(szReason), pszMessage);   // ok to truncate, for display only
                    fOverridden = TRUE;
                    LocalFree(pszMessage);
                }
                LocalFree(pszApp);
            }
        }

        if (!fOverridden)
        {
            fSysError = !LoadString(HINST_THISDLL, IDS_REASONS + nError, szReason, ARRAYSIZE(szReason));
        }
    }

    if (nOper == OPER_DOFILE)
    {
        PathRemoveExtension(szFile);
    }

    if (fSysError)
    {
        SHSysErrorMessageBox(pcs->hwndDlgParent, MAKEINTRESOURCE(IDS_FILEERROR + wFunc),
                idVerb, nError, PathFindFileName(szFile),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
    }
    else
    {
        if (nError > DE_ERROR_MAX &&
                0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                                   NULL,
                                   nError,
                                   0,
                                   szReason,
                                   ARRAYSIZE(szReason),
                                   NULL))
        {
            szReason[0] = 0;
        }

        DisplayFileOperationError(pcs->hwndDlgParent, idVerb, wFunc, nError, szReason, szFile, pszDest);
    }
}


//
// The following function is used to retry failed move/copy operations
// due to out of disk situations or path not found errors
// on the destination.
//
// parameters:
//      pszDest         Fully qualified path to destination file (ANSI)
//      nError          type of error: ERROR_DISK_FULL or ERROR_PATH_NOT_FOUND
//      dwFileSize      amount of space needed for this file if ERROR_DISK_FULL
//
// returns:
//      0       success (destination path has been created)
//      != 0    dos error code including ERROR_CANCELLED
//

int CopyMoveRetry(COPY_STATE *pcs, LPCTSTR pszDest, int nError, ULARGE_INTEGER* pulFileSize)
{
    UINT wFlags;
    int  result;
    LPCTSTR wID;
    TCHAR szTemp[MAX_PATH];
    BOOL fFirstRetry = TRUE;
    HRESULT hr;

    if (pcs->fFlags & FOF_NOERRORUI)
    {
        result = ERROR_CANCELLED;
        goto ErrorExit;
    }
    
    hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszDest);
    if (SUCCEEDED(hr))
    {
        PathRemoveFileSpec(szTemp);
    }
    else
    {
        szTemp[0] = TEXT('\0');
    }
    
    do
    {
        // until the destination path has been created
        if (nError == ERROR_PATH_NOT_FOUND)
        {
            if (!(pcs->fFlags & FOF_NOCONFIRMMKDIR))
            {
                wID = MAKEINTRESOURCE(IDS_PATHNOTTHERE);
                wFlags = MB_ICONEXCLAMATION | MB_YESNO;
            }
            else
            {
                wID = 0;
            }
        }
        else  // ERROR_DISK_FULL
        {
            ULARGE_INTEGER ulDiskSize;

            wFlags = MB_ICONEXCLAMATION | MB_RETRYCANCEL;
            if (pulFileSize && TotalCapacity(pszDest, &ulDiskSize) && pulFileSize->QuadPart > ulDiskSize.QuadPart)
            {
                wID = MAKEINTRESOURCE(IDS_FILEWONTFIT);
            }
            else
            {
                wID = MAKEINTRESOURCE(IDS_DESTFULL);
            }
        }

        if (wID)
        {
            // szTemp will be ignored if there's no %1%s in the string.
            result = ShellMessageBox(HINST_THISDLL, pcs->hwndDlgParent, wID, MAKEINTRESOURCE(IDS_UNDO_FILEOP + pcs->lpfo->wFunc), wFlags, (LPTSTR)szTemp);
        }
        else
        {
            result = IDYES;
        }

        if (result == IDRETRY || result == IDYES)
        {
            TCHAR szDrive[5];
            int idDrive;

            // Allow the disk to be formatted
            // REVIEW, could this be FO_MOVE as well?
            if (FAILED(SHPathPrepareForWrite(((pcs->fFlags & FOF_NOERRORUI) ? NULL : pcs->hwndDlgParent), NULL, szTemp, SHPPFW_DEFAULT)))
                return ERROR_CANCELLED;

            idDrive = PathGetDriveNumber(szTemp);
            if (idDrive != -1)
                PathBuildRoot(szDrive, idDrive);
            else
                szDrive[0] = 0;

            // if we're not copying to the root
            if (lstrcmpi(szTemp, szDrive))
            {
                result = SHCreateDirectory(pcs->hwndDlgParent, szTemp);

                if (result == ERROR_CANCELLED)
                    goto ErrorExit;
                if (result == ERROR_ALREADY_EXISTS)
                {
                    // if SHPathPrepareForWrite created the directory we shouldn't treat this as an error
                    result = 0;
                }
                else if (result && (nError == ERROR_PATH_NOT_FOUND))
                {
                    result |= ERRORONDEST;

                    //  We try twice to allow the recyclebin to be flushed.
                    if (fFirstRetry)
                        fFirstRetry = FALSE;
                    else
                        goto ErrorExit;
                }
            }
            else
            {
                result = 0;
            }
        }
        else
        {
            result = ERROR_CANCELLED;
            goto ErrorExit;
        }
    } while (result);

ErrorExit:
    return result;            // success
}


BOOL ValidFilenames(LPCTSTR pList)
{
    if (!*pList)
        return FALSE;

    for (; *pList; pList += lstrlen(pList) + 1)
    {
        if (PathIsInvalid(pList))
        {
            return FALSE;
        }
    }

    return TRUE;
}

void AddRenamePairToHDSA(LPCTSTR pszOldPath, LPCTSTR pszNewPath, HDSA* phdsaRenamePairs)
{
    //
    //  Update our collision mapping table
    //
    if (!*phdsaRenamePairs)
        *phdsaRenamePairs = DSA_Create(sizeof(SHNAMEMAPPING), 4);

    if (*phdsaRenamePairs)
    {
        SHNAMEMAPPING rp;
        rp.cchOldPath = lstrlen(pszOldPath);
        rp.cchNewPath = lstrlen(pszNewPath);

        rp.pszOldPath = StrDup(pszOldPath);
        if (rp.pszOldPath)
        {
            rp.pszNewPath = StrDup(pszNewPath);
            if (rp.pszNewPath)
            {
                if (DSA_AppendItem(*phdsaRenamePairs, &rp) == -1)
                {
                    LocalFree(rp.pszOldPath);
                    LocalFree(rp.pszNewPath);
                }
            }
            else
            {
                LocalFree(rp.pszOldPath);
            }
        }
    }
}

BOOL _HandleRename(LPCTSTR pszSource, LPTSTR pszDest, UINT cchDest, FILEOP_FLAGS fFlags, COPY_STATE * pcs)
{
    TCHAR *pszConflictingName = PathFindFileName(pszSource);
    TCHAR szTemp[MAX_PATH];
    TCHAR szTemplate[MAX_PATH];
    LPTSTR lpszLongPlate;

    PathRemoveFileSpec(pszDest);

    if (LoadString(HINST_THISDLL, IDS_COPYLONGPLATE, szTemplate, ARRAYSIZE(szTemplate)))
    {
        LPTSTR lpsz;
        lpsz = pszConflictingName;
        lpszLongPlate = szTemplate;
        // see if the first part of the template is the same as the name "Copy #"
        while (*lpsz && *lpszLongPlate &&
                *lpsz == *lpszLongPlate &&
                *lpszLongPlate != TEXT('('))
        {
            lpsz++;
            lpszLongPlate++;
        }

        if (*lpsz == TEXT('(') && *lpszLongPlate == TEXT('('))
        {
            // conflicting name already in the template, use it instead
            lpszLongPlate = pszConflictingName;
        }
        else
        {
            // otherwise build our own
            // We need to make sure not to overflow a max buffer.
            int ichFixed = lstrlen(szTemplate) + lstrlen(pszDest) + 5;
            lpszLongPlate = szTemplate;

            if ((ichFixed + lstrlen(pszConflictingName)) <= MAX_PATH)
            {
                StringCchCat(szTemplate, ARRAYSIZE(szTemplate), pszConflictingName);
            }
            else
            {
                // Need to remove some of the name
                LPTSTR pszExt = StrRChr(pszConflictingName, NULL, TEXT('.'));
                if (pszExt)
                {
                    // ok to truncate here
                    StringCchCat(szTemplate,
                                 ARRAYSIZE(szTemplate) - lstrlen(pszExt),
                                 pszConflictingName);

                    // use as much of the buffer as possible
                    StringCchCat(szTemplate, ARRAYSIZE(szTemplate), pszExt);
                }
                else
                {
                    StringCchCat(szTemplate, ARRAYSIZE(szTemplate), pszConflictingName);
                }
            }
        }
    }
    else
    {
        lpszLongPlate = NULL;
    }

    if (PathYetAnotherMakeUniqueName(szTemp, pszDest, pszConflictingName, lpszLongPlate))
    {
        //
        //  If there are any other files in the queue which are to
        //  be copied into a subtree of pszDest, we must update them
        //  as well.
        //

        //  Put the new (renamed) target in pszDest.
        HRESULT hr = StringCchCopy(pszDest, cchDest, szTemp);
        if (SUCCEEDED(hr))
        {
            //  Rebuild the old dest name and put it in szTemp.
            //  I'm going for minimum stack usage here, so I don't want more
            //  than one MAX_PATH lying around.
            PathRemoveFileSpec(szTemp);

            if (PathAppend(szTemp, pszConflictingName))
            {
                AddRenamePairToHDSA(szTemp, pszDest, &pcs->dth.hdsaRenamePairs);
            }
            return TRUE;
        }
    }

    return FALSE;
}

// test input for "multiple" filespec
//
// examples:
//      1       foo.bar                 (single non directory file)
//      -1      *.exe                   (wild card on any of the files)
//      n       foo.bar bletch.txt      (number of files)
//

int CountFiles(LPCTSTR pInput)
{
    int count;
    for (count = 0; *pInput; pInput += lstrlen(pInput) + 1, count++)
    {
        // wild cards imply multiple files
        if (PathIsWild(pInput))
            return -1;
    }
    return count;

}

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

BOOL IsCompressedVolume(LPCTSTR pszSource, DWORD dwAttributes)
{
    int i;
    LPTSTR pszFileName, pszExtension;
    TCHAR szPath[MAX_PATH];
    HRESULT hr;

    // must be marked system and hidden
    if (!IS_SYSTEM_HIDDEN(dwAttributes))
        return FALSE;
    
    hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszSource);
    if (FAILED(hr))
        return FALSE;

    pszFileName = PathFindFileName(szPath);
    pszExtension = PathFindExtension(pszFileName);

    // make sure the extension is a 3 digit number
    if (!*pszExtension)
        return FALSE;       // no extension

    for (i = 1; i < 4; i++) 
    {
        if (!pszExtension[i] || !ISDIGIT(pszExtension[i]))
            return FALSE;
    }

    // make sure it's null terminated here
    if (pszExtension[4])
        return FALSE;

    // now knock off the extension and make sure the stem matches
    *pszExtension = 0;
    if (lstrcmpi(pszFileName, TEXT("DRVSPACE")) &&
            lstrcmpi(pszFileName, TEXT("DBLSPACE"))) 
    {
        return FALSE;
    }

    // make sure it's in the root
    PathRemoveFileSpec(szPath);
    if (!PathIsRoot(szPath)) 
    {
        return FALSE;
    }

    return TRUE;        // passed all tests!
}

void _DeferMoveDlgItem(HDWP hdwp, HWND hDlg, int nItem, int x, int y)
{
    RECT rc;
    HWND hwnd = GetDlgItem(hDlg, nItem);

    GetClientRect(hwnd, &rc);
    MapWindowPoints(hwnd, hDlg, (LPPOINT) &rc, 2);

    DeferWindowPos(hdwp, hwnd, 0, rc.left + x, rc.top + y, 0, 0,
            SWP_NOZORDER | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE);
}

void _RecalcWindowHeight(HWND hWnd, LPTSTR lpszText)
{
    HDC hdc = GetDC(hWnd);
    RECT rc;
    HWND hwndText = GetDlgItem(hWnd,IDC_MBC_TEXT);
    HDWP hdwp;
    int iHeightDelta, cx;

    // Get the starting rect of the text area (for the width)
    GetClientRect(hwndText, &rc);
    MapWindowPoints(hwndText, hWnd, (LPPOINT) &rc, 2);

    // Calc how high the static text area needs to be, given the above width
    iHeightDelta = RECTHEIGHT(rc);
    cx = RECTWIDTH(rc);
    DrawText(hdc, lpszText, -1, &rc, DT_CALCRECT | DT_WORDBREAK | DT_LEFT | DT_INTERNAL | DT_EDITCONTROL);

    iHeightDelta = RECTHEIGHT(rc) - iHeightDelta;
    cx = RECTWIDTH(rc) - cx; // Should only change for really long words w/o spaces
    if (cx < 0)
        cx = 0;

    ReleaseDC(hWnd, hdc);

    hdwp = BeginDeferWindowPos(4);
    if (hdwp)
    {
        hdwp = DeferWindowPos(hdwp, hwndText, 0, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_NOACTIVATE);
        if (hdwp)
        {
            _DeferMoveDlgItem(hdwp, hWnd, IDC_MESSAGEBOXCHECKEX, 0, iHeightDelta);
            _DeferMoveDlgItem(hdwp, hWnd, IDYES, cx, iHeightDelta);
            _DeferMoveDlgItem(hdwp, hWnd, IDNO, cx, iHeightDelta);

            EndDeferWindowPos(hdwp);
        }
    }

    GetWindowRect(hWnd, &rc);
    SetWindowPos(hWnd, 0, rc.left - (cx/2), rc.top - (iHeightDelta/2), RECTWIDTH(rc)+cx, RECTHEIGHT(rc)+iHeightDelta, SWP_NOZORDER | SWP_NOACTIVATE);
    return;
}

BOOL_PTR CALLBACK RenameMsgBoxCheckDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        // we only handle the WM_INITDIALOG so that we can resize the dialog
        // approprately and to set the default button to IDNO
        case WM_INITDIALOG:
            {
                HWND hwndNO = GetDlgItem(hDlg, IDNO);

                _RecalcWindowHeight(hDlg, (LPTSTR)lParam);

                SetDlgItemText(hDlg,IDC_MBC_TEXT,(LPTSTR)lParam);

                SendMessage(hDlg, DM_SETDEFID, IDNO, 0);
                SetFocus(hwndNO);

                return FALSE; // we set the focus, so return false
            }
    }

    // didnt handle this message
    return FALSE;
}

int ConfirmRenameOfConnectedItem(COPY_STATE *pcs, WIN32_FIND_DATA *pfd, LPTSTR szSource)
{
    int result = IDYES; //For non-connected elements, the default is IDYES!
    LPTSTR  pszMessage;
    LPTSTR  lpConnectedItem, lpConnectOrigin;
    LPTSTR  lpStringID;

    //Check if this item being renamed has a connected item.
    if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
    {
        //Yes! It has a connected element! Form the strings to create the confirmation dialog!

        //Get the name of the connected element
        lpConnectedItem = PathFindFileName(pcs->dth.pdtnCurrent->pdtnConnected->szName);
        lpConnectOrigin = PathFindFileName(pcs->dth.pFrom);

        // Mark the connected item as dummy as this will never get renamed.
        // (Note that this connected node could be a folder. It is still OK to mark it as 
        // dummy because for rename operation, a folder is treated just like a file in 
        // DTGotoNextNode()).
        pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;

        if (pfd && (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            lpStringID = MAKEINTRESOURCE(IDS_HTML_FOLDER_RENAME);
        else
            lpStringID = MAKEINTRESOURCE(IDS_HTML_FILE_RENAME);

        //Load the confirmation message and format it!
        pszMessage = ShellConstructMessageString(HINST_THISDLL, lpStringID, 
                lpConnectedItem, lpConnectOrigin);

        if (pszMessage)
        {
            //Get the confirmation from the end-user;
            result = SHMessageBoxCheckEx(pcs->hwndDlgParent, HINST_THISDLL, 
                    MAKEINTRESOURCE(DLG_RENAME_MESSAGEBOXCHECK), 
                    RenameMsgBoxCheckDlgProc,
                    (void *)pszMessage,
                    IDYES, 
                    REG_VAL_GENERAL_RENAMEHTMLFILE);
            //It is possible we get IDCANCEL if the "X" in the caption is clicked to clost
            // the dialog. The following code makes sure we get one of the return code that we want.
            if ((result != IDYES) && (result != IDNO))
                result = IDNO;

            SHFree(pszMessage);
        }
        else
            result = IDNO;  //For connected elements, the default is "Don't rename";
    }
    else
    {
        if (DTNIsConnected(pcs->dth.pdtnCurrent))
            result = IDNO;  //Connected elements, do not get renamed.
    }

    return result;
}

int AllConfirmations(COPY_STATE *pcs, WIN32_FIND_DATA *pfd, UINT oper, UINT wFunc,
        LPTSTR szSource, LPTSTR szDest, BOOL bTimeToUpdate, 
        WIN32_FIND_DATA *pfdDest, LPINT lpret)
{
    int result = IDYES;
    LPTSTR p;
    LPTSTR pszStatusDest = NULL;
    CONFIRM_FLAG fConfirm;
    WIN32_FIND_DATA *pfdUse1 = NULL;
    WIN32_FIND_DATA *pfdUse2;
    BOOL fSetProgress = FALSE;
    BOOL fShowConfirm = FALSE;

    switch (oper | wFunc)
    {
        case OPER_ENTERDIR | FO_MOVE:
            if (PathIsSameRoot(szSource, szDest))
            {
                fConfirm = CONFIRM_MOVE_FOLDER;
                pfdUse1 = pfd;
                pfdUse2 = pfdDest;
                fShowConfirm = TRUE;
            }
            break;

        case OPER_ENTERDIR | FO_DELETE:
            // Confirm removal of directory on this pass.  The directories
            // are actually removed on the OPER_LEAVEDIR pass
            if (DTNIsRootNode(pcs->dth.pdtnCurrent))
                fSetProgress = TRUE;        

            if (!PathIsRoot(szSource))
            {
                fShowConfirm = TRUE;
                pfdUse2 = pfd;
                fConfirm = CONFIRM_DELETE_FOLDER;
                szDest = NULL;
            }

            break;

        case OPER_DOFILE | FO_RENAME:
            // pszStatusDest = szDest;
            fSetProgress = TRUE;

            p = PathFindFileName(szSource);
            if (!IntlStrEqNI(szSource, szDest, (int)(p - szSource)))
            {
                result = DE_DIFFDIR;
            }
            else
            {
                if (pfd && (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                    fConfirm = CONFIRM_RENAME_FOLDER;
                else
                    fConfirm =  CONFIRM_RENAME_FILE;

                if (PathIsRoot(szSource) || (PathIsRoot(szDest)))
                {
                    result = DE_ROOTDIR | ERRORONDEST;
                }
                else
                {
                    // We need to bring up a special confirmation dialog if this file/folder being
                    // renamed has a connected element (if "foo.htm" or "foo files" is renamed that
                    // will break the links).
                    result = ConfirmRenameOfConnectedItem(pcs, pfd, szSource);

                    if (result != IDNO)
                    {
                        fShowConfirm = TRUE;
                        pfdUse2 = pfdDest;
                        pfdUse1 = pfd;
                    }
                }
            }
            break;

        case OPER_DOFILE | FO_MOVE:

            fSetProgress = TRUE;
            pszStatusDest = szDest;
            if (PathIsRoot(szSource))
            {
                result = DE_ROOTDIR;
            }
            else if (PathIsRoot(szDest))
            {
                result = DE_ROOTDIR | ERRORONDEST;
            }
            else
            {
                fConfirm = CONFIRM_MOVE_FILE;
                fShowConfirm = TRUE;
                pfdUse2 = pfdDest;
                pfdUse1 = pfd;
            }
            break;

        case OPER_DOFILE | FO_DELETE:
            fSetProgress = TRUE;

            if (IsCompressedVolume(szSource, pfd->dwFileAttributes))
            {
                CopyError(pcs, szSource, szDest, DE_COMPRESSEDVOLUME, wFunc, oper);
                result = IDNO;
            }
            else
            {
                fShowConfirm = TRUE;
                szDest = NULL;
                pfdUse2 = pfd;
                fConfirm = CONFIRM_DELETE_FILE;
            }
            break;

    }

    if (fShowConfirm)
    {
        result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs, &pcs->cd, pcs->nSourceFiles, !DTNIsRootNode(pcs->dth.pdtnCurrent), fConfirm,
                szSource, pfdUse1, szDest, pfdUse2, NULL);
    }

    if (oper == OPER_DOFILE || oper == OPER_ENTERDIR)
    {
        if ((wFunc == FO_MOVE) || (wFunc == FO_COPY))
        {
            if ((result != IDNO) && (result != IDCANCEL))
            {   
                LPTSTR pszDataToBeLost;
                WCHAR wszDestDir[MAX_PATH];
                BOOL  bNoStreamLossThisDir = FALSE;

                HRESULT hr = StringCchCopy(wszDestDir, ARRAYSIZE(wszDestDir), szDest);
                if (SUCCEEDED(hr))
                {
                    PathRemoveFileSpec(wszDestDir);
                
                    // Files with multiple streams will suffer stream loss on a downlevel
                    // copy, but CopyFile special-cases native structure storage.

                    pszDataToBeLost = GetDownlevelCopyDataLossText(szSource, wszDestDir, (oper == OPER_ENTERDIR), &bNoStreamLossThisDir);
                    if (pszDataToBeLost)
                    {
                        fConfirm     = CONFIRM_STREAMLOSS;
                        pfdUse2      = pfd;

                        result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs, &pcs->cd, pcs->nSourceFiles, !DTNIsRootNode(pcs->dth.pdtnCurrent), fConfirm,
                            szSource, pfdUse1, szDest, pfdUse2, pszDataToBeLost);
                        LocalFree(pszDataToBeLost);
                    }
                    else if (bNoStreamLossThisDir)
                    {
                        // pcs->bStreamLossPossible = FALSE;
                    }
                }
            }
        }   
    }

    // We only really care about OPER_ENTERDIR when deleting and
    // OPER_DOFILE when renaming, but I guess the hook will figure it out

    if ((result == IDYES) &&
            ISDIRFINDDATA(*pfd) &&
            (oper==OPER_ENTERDIR || oper==OPER_DOFILE))
    {

        result = CallFileCopyHooks(pcs->hwndDlgParent, wFunc, pcs->fFlags,
                szSource, pfd->dwFileAttributes,
                szDest, pfdDest->dwFileAttributes);
    }

    if ((result != IDCANCEL) && (result != IDNO) && fSetProgress && bTimeToUpdate)
        SetProgressText(pcs, szSource, pszStatusDest);

    return result;
}


// return TRUE if they're the same file
// assumes that given two file specs, the short name will
// be identical (except case)
BOOL SameFile(LPTSTR pszSource, LPTSTR pszDest)
{
    TCHAR szShortSrc[MAX_PATH];
    if (GetShortPathName(pszSource, szShortSrc, ARRAYSIZE(szShortSrc)))
    {
        TCHAR szShortDest[MAX_PATH];
        if (GetShortPathName(pszDest, szShortDest, ARRAYSIZE(szShortDest)))
            return !lstrcmpi(szShortSrc, szShortDest);
    }

    return FALSE;
}


// make sure we aren't operating on the current dir to avoid
// ERROR_CURRENT_DIRECTORY kinda errors

void AvoidCurrentDirectory(LPCTSTR p)
{
    TCHAR szTemp[MAX_PATH];

    GetCurrentDirectory(ARRAYSIZE(szTemp), szTemp);
    if (lstrcmpi(szTemp, p) == 0)
    {
        DebugMsg(TF_DEBUGCOPY, TEXT("operating on current dir(%s), cd .."), p);
        PathRemoveFileSpec(szTemp);
        SetCurrentDirectory(szTemp);
    }
}

// this resolves short/long name collisions such as moving
// "NewFolde" onto a dir with "New Folder" whose short name is "NEWFOLDE"
//
// we resolve this by renaming "New Folder" to a unique short name (like TMP1)
//
// making a temporary file of name "NEWFOLDE"
//
// renaming TMP1 back to "New Folder"  (at which point it will have a new short
// name like "NEWFOL~1"

// PERF: it'd be faster if we didn't make the temporary file, but that
// would require that we rename the file back to the long name at the
// end of the operation.. which would mean we'd need to queue them all up..
// too much for right now.
BOOL ResolveShortNameCollisions(LPCTSTR lpszDest, WIN32_FIND_DATA *pfd)
{
    BOOL fRet = FALSE;

    // first verify that we're in the name collision.
    // we are if lpszDest is the same as the pfd's short name which is different
    // than it's long name.

    if (!lstrcmpi(PathFindFileName(lpszDest), pfd->cAlternateFileName) &&
            lstrcmpi(pfd->cAlternateFileName, pfd->cFileName))
    {
        // yes... do the renaming
        TCHAR szTemp[MAX_PATH];
        TCHAR szLongName[MAX_PATH];
        
        HRESULT hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), lpszDest);
        if (SUCCEEDED(hr))
        {
            PathRemoveFileSpec(szTemp);

            // build the original long name
            hr = StringCchCopy(szLongName, ARRAYSIZE(szLongName), szTemp);
            if (SUCCEEDED(hr))
            {
                if (PathAppend(szLongName, pfd->cFileName))
                {
                    GetTempFileName(szTemp, c_szNULL, 1, szTemp);
                    DebugMsg(TF_DEBUGCOPY, TEXT("Got %s as a temp file"), szTemp);
                    // rename "New Folder" to "tmp1"
                    if (Win32MoveFile(szLongName, szTemp, ISDIRFINDDATA(*pfd)))
                    {
                        // make a temporary "NewFolde"
                        fRet = CreateWriteCloseFile(NULL, lpszDest, NULL, 0);
                        ASSERT(fRet);

                        // move it back...

                        if (!Win32MoveFile(szTemp, szLongName, ISDIRFINDDATA(*pfd)))
                        {
                            //
                            //  Can't move it back, so delete the empty dir and then
                            //  move it back.  Return FALSE to denote failure.
                            //
                            DeleteFile(lpszDest);
                            Win32MoveFile(szTemp, szLongName, ISDIRFINDDATA(*pfd));
                            fRet = FALSE;
                        }
                        else
                        {
                            // send this out because we could have confused views
                            // with this swapping files around...  by the time they get the first
                            // move file notification, the temp file is likely gone
                            // so they could blow that off.. which would mess up the rest of this.
                            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szLongName, NULL);
                            //
                            //  We've now created an empty dir entry of this name type.
                            //
                            Win32DeleteFile(lpszDest);
                        }

                        DebugMsg(TF_DEBUGCOPY, TEXT("ResolveShortNameCollision: %s = original, %s = destination,\n %s = temp file, %d = return"), szLongName, lpszDest, szTemp, fRet);
                    }
                }
            }
        }
    }
    return fRet;
}

typedef struct { LPTSTR szFilename; int iResult; } RENAMEEXEMPTIONINFO;
RENAMEEXEMPTIONINFO g_rgExemptions[] = {
    { TEXT("thumbs.db"), IDYES }
};
    
// return values.
//
// IDCANCEL = bail out of all operations
// IDNO = skip this one
// IDRETRY = try operation again
// IDUNKNOWN = this (collision) is not the problem
#define IDUNKNOWN IDOK
int CheckForRenameCollision(COPY_STATE *pcs, UINT oper, LPTSTR pszSource, LPTSTR pszDest, UINT cchDest,
                            WIN32_FIND_DATA *pfdDest, WIN32_FIND_DATA* pfd)
{
    int iRet = IDUNKNOWN;

    ASSERT((pcs->lpfo->wFunc != FO_DELETE) && (oper != OPER_LEAVEDIR));


    /* Check to see if we are overwriting an existing file or
       directory.  If so, better confirm */

    if ((oper == OPER_DOFILE) ||
            ((oper == OPER_ENTERDIR) && (pcs->fFlags & FOF_RENAMEONCOLLISION)))
    {
        HANDLE  hfindT;

        // REVIEW this slows things down checking for the dest file
        if ((hfindT = FindFirstFile(pszDest, pfdDest)) != INVALID_HANDLE_VALUE)
        {
            FindClose(hfindT);

            iRet = IDCANCEL;

            if (pcs->lpfo->wFunc != FO_RENAME || !SameFile(pszSource, pszDest))
            {

                if (!ResolveShortNameCollisions(pszDest, pfdDest))
                {
                    if (pcs->fFlags & FOF_RENAMEONCOLLISION)
                    {
                        //  The client wants us to generate a new name for the
                        //  source file to avoid a collision at the destination
                        //  dir.  Must also update the current queue and the
                        //  copy root.
                        _HandleRename(pszSource, pszDest, cchDest, pcs->fFlags, pcs);
                        iRet = IDRETRY;
                    }
                    else
                    {
                        int result = IDRETRY;

                        if (pcs->lpfo->wFunc == FO_RENAME)
                        {
                            return ERROR_ALREADY_EXISTS;
                        }

                        // Is this a super-hidden file we don't want to prompt the
                        // user regarding?
                        if (IS_SYSTEM_HIDDEN(pfd->dwFileAttributes) &&
                            IS_SYSTEM_HIDDEN(pfdDest->dwFileAttributes) && 
                            !ShowSuperHidden())
                        {
                            int cExempt = 0;
                            for (; cExempt < ARRAYSIZE(g_rgExemptions); cExempt++)
                            {
                                if (0 == StrCmpI(g_rgExemptions[cExempt].szFilename, PathFindFileName(pszSource)))
                                {
                                    result = g_rgExemptions[cExempt].iResult;
                                    break;
                                }
                            }
                        }
                        
                        // REVIEW, if the destination file we are copying over
                        // is actually a directory we are doomed.  we can
                        // try to remove the dir but that will fail if there
                        // are files there.  we probably need a special error message
                        // for this case.

                        if (result == IDRETRY)
                        {
                            result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs,
                                    &pcs->cd, pcs->nSourceFiles,
                                    !DTNIsRootNode(pcs->dth.pdtnCurrent),
                                    CONFIRM_REPLACE_FILE,
                                    pszSource, pfd, pszDest, pfdDest, NULL);
                        }
                        switch (result)
                        {
                            case IDYES:

                                if ((pcs->lpfo->wFunc == FO_MOVE) && (PathIsSameRoot(pszSource, pszDest)))
                                {
                                    int ret;
                                    // For FO_MOVE we need to delete the
                                    // destination first.  Do that now.

                                    // FEATURE this replace options should be undable
                                    ret = Win32DeleteFile(pszDest) ? 0 : GetLastError();

                                    if (ret)
                                    {
                                        ret |= ERRORONDEST;
                                        result = ret;
                                    }
                                }
                                if (pcs->lpua)
                                    FOUndo_Release(pcs->lpua);
                                iRet = IDRETRY;
                                break;

                            case IDNO:
                            case IDCANCEL:
                                pcs->lpfo->fAnyOperationsAborted = TRUE;
                                iRet = result;
                                break;

                            default:
                                iRet = result;
                                break;
                        }
                    }
                }
                else
                {
                    iRet = IDRETRY;
                }
            }
        }
    }

    return iRet;
}

int LeaveDir_Delete(COPY_STATE *pcs, LPTSTR pszSource)
{
    int ret;
    if (PathIsRoot(pszSource))
        return 0;

    AvoidCurrentDirectory(pszSource);

    // We already confirmed the delete at MKDIR time, so attempt
    // to delete the directory

    ret = Win32RemoveDirectory(pszSource) ? 0 : GetLastError();
    if (!ret)
    {
        FOUndo_FileReallyDeleted(pszSource);
    }
    return ret;
}


int EnterDir_Copy(COPY_STATE* pcs, LPTSTR pszSource, LPTSTR pszDest, UINT cchDest,
                  WIN32_FIND_DATA *pfd, WIN32_FIND_DATA * pfdDest, BOOL fRenameTried, BOOL fLostEncryptOk)
{
    int ret;
    int result;
    BOOL fSetDestAttributes = FALSE;
    DWORD dwDesiredAttributes = pfd->dwFileAttributes;
    BOOL fWithoutTemplate = FALSE;

    // Whenever we enter a directory, we need to reset the bStreamLossPossible flag,
    // since we could have stepped out from an NTFS->NTFS to NTFS->FAT scenario via
    // a junction point

    pcs->bStreamLossPossible = TRUE;

TryCreateAgain:

    // SHMoveFile restricts the based on path length. To be consistent, we make the same
    // restricton on Copy directory also.
    if (IsDirPathTooLongForCreateDir(pszDest))
    {
        ret = ERROR_FILENAME_EXCED_RANGE;
    }
    else
    {

        if (fLostEncryptOk)
        {
            dwDesiredAttributes &= ~FILE_ATTRIBUTE_ENCRYPTED;     // Pretend its not encrypted
            fSetDestAttributes = TRUE;
            fWithoutTemplate = TRUE;
        }

        if (pfd->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
        {
            if (!(pcs->fFlags & FOF_NORECURSEREPARSE))
            {
                dwDesiredAttributes &= ~FILE_ATTRIBUTE_REPARSE_POINT;  // Pretend like its just a folder
                fSetDestAttributes = TRUE;
                fWithoutTemplate = TRUE;
            }
        }

        if (fWithoutTemplate)
        {
            ret = (CreateDirectory(pszDest, NULL) ? 0 : GetLastError());

            // Since we didn't call CreateDirectoryEx, we need to manually
            // propogate the attributes to the dest directory.
            fSetDestAttributes = TRUE;
        }
        else
        {
            ret = (CreateDirectoryEx(pszSource, pszDest, NULL) ? 0 : GetLastError());
        }

        if (ret == ERROR_SUCCESS)
        {
            SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, pszDest, NULL);
        }
    }

    switch (ret)
    {
        case 0:     // successful folder creation (or it already exists)
            // propogate the attributes (if there are any)

            if (pcs->fFromCDRom)
            {
                // Don't propogate read-only from CDRoms
                dwDesiredAttributes &= ~FILE_ATTRIBUTE_READONLY;
                fSetDestAttributes = TRUE;
            }

            if (fSetDestAttributes)
            {
                // Avoid setting FILE_ATTRIBUTE_DIRECTORY, since its
                // already a directory, and is less error prone.
                SetFileAttributes(pszDest, dwDesiredAttributes);
            }

            //  we should set the security ACLs here on NT
            //  we ignore any kind of failure though, is that OK?
            //
            CopyFileSecurity(pszSource, pszDest);

            // add to the undo atom
            if (pcs->lpua)
            {
                if (DTNIsRootNode(pcs->dth.pdtnCurrent) && !DTNIsConnected(pcs->dth.pdtnCurrent))
                    FOUndo_AddInfo(pcs->lpua, pszSource, pszDest, 0);
            }
            break;

        case ERROR_ALREADY_EXISTS:
        case ERROR_DISK_FULL:
        case ERROR_ACCESS_DENIED:
        case ERROR_INVALID_NAME:
            {
                DWORD dwFileAttributes;

                if (!fRenameTried)
                {
                    int result = CheckForRenameCollision(pcs, OPER_ENTERDIR, pszSource, pszDest, cchDest, pfdDest, pfd);
                    switch (result)
                    {
                        case IDUNKNOWN:
                            break;

                        case IDRETRY:
                            return EnterDir_Copy(pcs, pszSource, pszDest, cchDest, pfd, pfdDest, TRUE, fLostEncryptOk);

                        case IDCANCEL:
                            pcs->bAbort = TRUE;
                            return result;

                        case IDNO:
                            return result;

                        default:
                            return result;
                    }
                }

                dwFileAttributes = GetFileAttributes(pszDest);

                if (dwFileAttributes == (DWORD)-1)
                {
                    // The dir does not exist, so it looks like a problem
                    // with a read-only drive or disk full

                    if (ret == ERROR_DISK_FULL &&
                            IsRemovableDrive(DRIVEID(pszDest)) &&
                            !PathIsSameRoot(pszDest, pszSource))
                    {
                        ret = CopyMoveRetry(pcs, pszDest, ERROR_DISK_FULL, NULL);
                        if (!ret)
                        {
                            return EnterDir_Copy(pcs, pszSource, pszDest, cchDest, pfd, pfdDest, fRenameTried, fLostEncryptOk);
                        }
                        else
                        {
                            pcs->bAbort = TRUE;
                            return ret;
                        }
                    }

                    // Maybe its an encrypted folder thats losing its encryption?
                    // If fLostEncryptOk is TRUE then we are already trying to recover from an Encrypted Folder, so
                    // don't recursively try again
                    if ((fLostEncryptOk == FALSE) && (pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED))
                    {
                        int result;
                        result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs,
                                &pcs->cd, pcs->nSourceFiles,
                                FALSE,
                                CONFIRM_LOST_ENCRYPT_FOLDER,
                                pszSource, pfd, pszDest, NULL, NULL);

                        switch (result)
                        {
                            case IDYES:
                                fLostEncryptOk = TRUE;
                                return EnterDir_Copy(pcs, pszSource, pszDest, cchDest, pfd, pfdDest, fRenameTried, fLostEncryptOk);

                            case IDNO:
                            case IDCANCEL:
                                pcs->bAbort = TRUE;
                                ret = result;
                                break;

                            default:
                                ret = result;
                                break;
                        }
                        return ret;
                    }

                    CopyError(pcs, pszSource, pszDest, ERROR_ACCESS_DENIED | ERRORONDEST, FO_COPY, OPER_DOFILE);
                    pcs->bAbort = TRUE;
                    return ret;
                }

                if (!(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    // A file with this name already exists
                    CopyError(pcs, pszSource, pszDest, DE_FLDDESTISFILE | ERRORONDEST, FO_COPY, OPER_DOFILE);
                    pcs->bAbort = TRUE;
                    return ret;
                }

                result = CachedConfirmFileOp(pcs->hwndDlgParent, pcs, &pcs->cd,
                        pcs->nSourceFiles,
                        !DTNIsRootNode(pcs->dth.pdtnCurrent),
                        CONFIRM_REPLACE_FOLDER,
                        pszSource, pfd, pszDest, pfdDest, NULL);
                switch (result)
                {
                    case IDYES:
                        ret = 0;    // convert to no error
                        pcs->fMerge = TRUE;
                        if (pcs->lpua)
                            FOUndo_Release(pcs->lpua);
                        break;

                    case IDNO:
                        DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder
                        pcs->lpfo->fAnyOperationsAborted = TRUE;
                        ret = IDNO;  // Don't put up error message on this one...
                        // Since the end-user cancelled the copy operation on this folder, we can cancel the 
                        // copy operation on the corresponding connected file too!
                        if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
                            pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;
                        break;

                    case IDCANCEL:
                        pcs->lpfo->fAnyOperationsAborted = TRUE;
                        pcs->bAbort = TRUE;
                        // Since the end-user cancelled the copy operation on this folder, we can cancel the 
                        // copy operation on the corresponding connected file too!
                        if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
                            pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;
                        break;

                    default:
                        result = ret;
                        break;
                }
                break;
            }

        case ERROR_CANCELLED:
            pcs->bAbort = TRUE;
            break;

        case ERROR_FILENAME_EXCED_RANGE:
            DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder
            break;

        case ERROR_EAS_NOT_SUPPORTED:
        case ERROR_NOT_SUPPORTED:
            // Directories with EAs are identified here.
            if (!fWithoutTemplate)
            {
                fWithoutTemplate = TRUE;
                goto TryCreateAgain;
            }
            // fall through

        default:    // ret != 0 (dos error code)
            ret |= ERRORONDEST;
            break;
    }

    return ret;
}

int EnterDir_Move(COPY_STATE* pcs, LPTSTR pszSource, LPTSTR pszDest, UINT cchDest,
                  WIN32_FIND_DATA *pfd, WIN32_FIND_DATA * pfdDest, BOOL fRenameTried)
{
    int ret;

    // Whenever we enter a directory, we need to reset the bStreamLossPossible flag,
    // since we could have stepped out from an NTFS->NTFS to NTFS->FAT scenario via
    // a junction point

    pcs->bStreamLossPossible = TRUE;

    // if these are in the same drive, try using MoveFile on it.
    // if that fails then fail through to the copy

    if (PathIsSameRoot(pszSource, pszDest))
    {
        AvoidCurrentDirectory(pszSource);

        ret = Win32MoveFile(pszSource, pszDest, TRUE) ? 0 : GetLastError();

        switch (ret)
        {
            case 0:

                DebugMsg(TF_DEBUGCOPY, TEXT("Move Folder worked!"));

                DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder

                // add to the undo atom
                if (pcs->lpua && DTNIsRootNode(pcs->dth.pdtnCurrent) && !DTNIsConnected(pcs->dth.pdtnCurrent))
                    FOUndo_AddInfo(pcs->lpua, pszSource, pszDest, 0);

                if (!SHRestricted(REST_NOENCRYPTONMOVE) &&
                        !(pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED))
                {
                    TCHAR szDestDir[MAX_PATH];
                    DWORD dwAttribs;

                    if (SUCCEEDED(StringCchCopy(szDestDir, ARRAYSIZE(szDestDir), pszDest)))
                    {
                        PathRemoveFileSpec(szDestDir);
                        dwAttribs = GetFileAttributes(szDestDir);

                        if ((dwAttribs != -1) && (dwAttribs & FILE_ATTRIBUTE_ENCRYPTED))
                        {
                            // Encrypt the directory by pretending we are the
                            // property sheet properties->Advanced.  Fill in the fake 
                            // information and call the helper.
                            FILEPROPSHEETPAGE fpsp;
                            FOLDERCONTENTSINFO fci;
                            fci.fIsCompressionAvailable = FALSE; 
                            fci.fMultipleFiles = TRUE;          
                            ZeroMemory(&fpsp, SIZEOF(fpsp));
                            fpsp.hDlg = GetWindow(pcs->hwndDlgParent, GW_CHILD);
                            fpsp.fRecursive = TRUE;
                            fpsp.fIsDirectory = TRUE;
                            fpsp.pfci = &fci;
                            // As long as asInitial.* == asCurrent.* it won't be changed 
                            fpsp.asInitial.fReadOnly = BST_INDETERMINATE;
                            fpsp.asInitial.fHidden   = BST_INDETERMINATE;
                            fpsp.asInitial.fIndex    = BST_INDETERMINATE;
                            fpsp.asInitial.fArchive  = BST_INDETERMINATE;
                            fpsp.asInitial.fCompress = BST_INDETERMINATE;
                            fpsp.asInitial.fEncrypt  = BST_UNCHECKED; // Not encrypted yet
                            fpsp.asInitial.fRecordingEnabled = BST_INDETERMINATE;
                            fpsp.asCurrent.fReadOnly = BST_INDETERMINATE;
                            fpsp.asCurrent.fHidden   = BST_INDETERMINATE;
                            fpsp.asCurrent.fIndex    = BST_INDETERMINATE;
                            fpsp.asCurrent.fArchive  = BST_INDETERMINATE;
                            fpsp.asCurrent.fCompress = BST_INDETERMINATE;
                            fpsp.asCurrent.fEncrypt  = BST_CHECKED;  // Now encrypt
                            fpsp.asCurrent.fRecordingEnabled = BST_INDETERMINATE;
                            ApplyRecursiveFolderAttribs(pszDest, &fpsp);
                        }
                    }
                }

                // Win32MoveFile on a single-volume leaves the original ACL
                // intact.  If necessary, pick up perms from the destination.
                if (pcs->fFlags & FOF_NOCOPYSECURITYATTRIBS)
                {
                    ResetFileSecurity(pszDest);
                }
                return 0;

            case ERROR_PATH_NOT_FOUND:
                ret = CopyMoveRetry(pcs, pszDest, ret, NULL);
                if (!ret)
                    return EnterDir_Move(pcs, pszSource, pszDest, cchDest, pfd, pfdDest, fRenameTried);
                return ret;

            case ERROR_ALREADY_EXISTS:
            case ERROR_FILE_EXISTS:
                if (!fRenameTried)
                {
                    int result = CheckForRenameCollision(pcs, OPER_ENTERDIR, pszSource, pszDest, cchDest, pfdDest, pfd);
                    switch (result)
                    {
                        case IDUNKNOWN:
                            break;
                        case IDRETRY:
                            return EnterDir_Move(pcs, pszSource, pszDest, cchDest, pfd, pfdDest, TRUE);

                        case IDCANCEL:
                            pcs->bAbort = TRUE;
                            return result;

                        case IDNO:
                            return result;

                        default:
                            return result;
                    }
                }
                break;

            case ERROR_FILENAME_EXCED_RANGE:
            case ERROR_ONLY_IF_CONNECTED:
                DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder
                return ret;
        }
    }

    // we're going to recurse in.... if we've not enumerated the children for
    // this folder, set it for delayed enumeration now.
    if (!pcs->dth.pdtnCurrent->pdtnChild)
    {
        pcs->dth.pdtnCurrent->pdtnChild = DTN_DELAYED;
    }

    if (DTNIsConnected(pcs->dth.pdtnCurrent) && !PathFileExists(pszSource))
    {
        // This can happen if the end-user moved "foo.htm" AND "foo files" together.
        // As a result the connected element "foo files" has already been moved.
        DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder
        return(0); //No error! This connected element seems to have been moved.
    }
    
    return EnterDir_Copy(pcs, pszSource, pszDest, cchDest, pfd, pfdDest, FALSE, FALSE);
}

int EnterDir_Delete(COPY_STATE * pcs, WIN32_FIND_DATA *pfdSrc, LPTSTR pszSource, UINT cchSource, HDPA *phdpaDeletedFiles)
{
    int iRet = 0;

    if (!DTNIsRootNode(pcs->dth.pdtnCurrent))
    {
        // we are not at a root node... when doing a delete this can only mean
        // that we are really nuking the folder. we dont need to enum children
        // because we already did a non-lazy enum at the root node.
        return iRet;
    }
    else if (!pcs->lpua)
    {
NukeFolder:
        // we are at a root node and we have no undo atom, this means that we
        // really want to nuke this whole dir, so enum the children
        DTForceEnumChildren(&pcs->dth);
        // do a non-layz enum of the children to prevent the progress
        // bar from going back and forth as we recurse down into any subdirs.
        DTEnumChildren(&pcs->dth, pcs, TRUE, DTF_FILES_AND_FOLDERS);
        return iRet;
    }
    
    if (DeleteFileBB(pszSource, cchSource, &iRet, pcs, TRUE, pfdSrc, phdpaDeletedFiles))
    {
        DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder
    } 
    else 
    {
        // DeleteFileBB failed, check iRet to find out why

        switch (iRet)
        {
            case BBDELETE_PATH_TOO_LONG:
            case BBDELETE_SIZE_TOO_BIG:
            case BBDELETE_NUKE_OFFLINE:
                {
                    // This is the case where the folder is too big to fit in the Recycle Bin or the folder
                    // is offline. We have no choice but to really nuke it, but we warn the user first since
                    // they may have thought that it was being sent to the recycle bin.
                    int result = CachedConfirmFileOp(pcs->hwndDlgParent, 
                            pcs,
                            &pcs->cd, 
                            pcs->nSourceFiles, 
                            FALSE, 
                            (iRet == BBDELETE_SIZE_TOO_BIG) ?
                            CONFIRM_WONT_RECYCLE_FOLDER :
                            ((iRet == BBDELETE_NUKE_OFFLINE) ?
                             CONFIRM_WONT_RECYCLE_OFFLINE :
                             CONFIRM_PATH_TOO_LONG), 
                            pszSource, 
                            pfdSrc, 
                            NULL, 
                            NULL,
                            NULL);
                    switch (result) 
                    {
                        case IDNO:
                            // user said "please dont really nuke the file"
                            DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder

                            pcs->lpfo->fAnyOperationsAborted = TRUE;

                            iRet = IDNO;  // Don't put up error message for this case

                            //Because the Delete on this FOLDER is aborted, we can cancel the "Delete"
                            // on the corresponding FILE too!
                            if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
                            {
                                pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;
                            }
                            break;

                        case IDCANCEL:
                            // user canceled the operation
                            pcs->lpfo->fAnyOperationsAborted = TRUE;

                            pcs->bAbort = TRUE;

                            //Because the Delete on this FOLDER is cancelled, we can cancel the "Delete"
                            // on the corresponding FILE too!
                            if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
                            {
                                pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;
                            }
                            break;

                        case IDYES:
                        default:
                            // user said "please nuke the file"
                            // assume noerror
                            iRet = 0;

                            // set this so the is correct progress animation is displayed
                            if (pcs)
                            {
                                pcs->fFlags &= ~FOF_ALLOWUNDO;
                            }

                            // dont allow undo since we are really nuking it (cant bring it back...)
                            if (pcs->lpua)
                            {
                                FOUndo_Release(pcs->lpua);
                            }

                            UpdateProgressAnimation(pcs);
                            goto NukeFolder;
                            break;
                    }
                }
                break;

            case BBDELETE_CANNOT_DELETE:
                {
                    // This is the non-deletable file case. Note: this is an NT only case, and
                    // it could be caused by acls or the fact that the file is currently in use.
                    // We attemt to really delete the file (which should fail) so we can generate
                    // the proper error value
                    DWORD dwAttributes = GetFileAttributes(pszSource);

                    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        iRet = Win32RemoveDirectory(pszSource);
                    }
                    else
                    {
                        iRet = Win32DeleteFile(pszSource);
                    }

                    if (!iRet)
                    {
                        // indeed, the file/folder could not be deleted. 
                        // Get last error to find out why
                        iRet = GetLastError();
                    }
                    else
                    {
                        // DeleteFileBB said that it couldn't be deleted, but we just nuked it. We will
                        // end up falling into this case when we hit things like Mounted Volumes.

                        // As Obi-Wan would say: "You don't need to see his identification... these aren't
                        // the droids you are looking for... He can go about his business... Move along."
                        iRet = ERROR_SUCCESS;
                        DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder

                        // dont allow undo since we reall nuked it (cant bring it back...)
                        if (pcs->lpua)
                        {
                            FOUndo_Release(pcs->lpua);
                        }
                    }
                }
                break;

            case BBDELETE_FORCE_NUKE:
                {
                    // This is the catch-all case. If iRet = BDETETE_FORCE_NUKE, then we just nuke the 
                    // file without warning.

                    // return noerror so we recurse into this dir and nuke it
                    iRet = ERROR_SUCCESS;

                    // set this so the is correct progress animation is displayed
                    if (pcs)
                    {
                        pcs->fFlags &= ~FOF_ALLOWUNDO;
                    }

                    // dont allow undo since we are really nuking it (cant bring it back...)
                    if (pcs->lpua)
                    {
                        FOUndo_Release(pcs->lpua);
                    }

                    UpdateProgressAnimation(pcs);

                    goto NukeFolder;
                }
                break;

            case BBDELETE_CANCELLED:
                {
                    // user canceled the operation
                    pcs->lpfo->fAnyOperationsAborted = TRUE;

                    pcs->bAbort = TRUE;

                    //Because the Delete on this FOLDER is cancelled, we can cancel the "Delete"
                    // on the corresponding FILE too!
                    if (DTNIsConnectOrigin(pcs->dth.pdtnCurrent))
                    {
                        pcs->dth.pdtnCurrent->pdtnConnected->fDummy = TRUE;
                    }
                }

            case BBDELETE_UNKNOWN_ERROR:
            default:
                {
                    iRet = GetLastError();
                    ASSERT(iRet != ERROR_SUCCESS);
                }
                break;

        }
    } // DeleteFileBB

    return iRet;
}

BOOL DoFile_Win32DeleteFileWithPidl(LPCTSTR pszFile, SIMPLEPIDLCACHE *pspc)
{
    LPITEMIDLIST pidlFile = NULL;
    int iRet;
    if (pspc)
    {
        pidlFile = SimplePidlCache_GetFilePidl(pspc, pszFile);
    }
    iRet = Win32DeleteFilePidl(pszFile, pidlFile);
    ILFree(pidlFile);
    return iRet;
}

int DoFile_Delete(COPY_STATE* pcs, WIN32_FIND_DATA *pfdSrc, LPTSTR pszSource, UINT cchSource, HDPA *phdpaDeletedFiles, BOOL fShouldSuspendEvents)
{
    int iRet = 0;

    // if we dont have an undo atom or this isint a root node or if this is a network file 
    // then we need to really nuke it
    if (!pcs->lpua || !DTNIsRootNode(pcs->dth.pdtnCurrent) || IsNetDrive(PathGetDriveNumber(pszSource)))
    {
        iRet = DoFile_Win32DeleteFileWithPidl(pszSource, fShouldSuspendEvents ? NULL : &pcs->spc) ? 0 : GetLastError();
        if (!iRet)
        {
            FOUndo_FileReallyDeleted(pszSource);
        }
    }
    else if (!DeleteFileBB(pszSource, cchSource, &iRet, pcs, FALSE, pfdSrc, phdpaDeletedFiles))
    {
        // DeleteFileBB failed, check iRet to find out why

        switch (iRet)
        {
            case BBDELETE_SIZE_TOO_BIG:
            case BBDELETE_NUKE_OFFLINE:
                {
                    // This is the case where the file is too big to fit in the Recycle Bin. We have no
                    // choice but to really nuke it, but we warn the user first since they may have thought
                    // that it was being sent to the recycle bin.
                    int result = CachedConfirmFileOp(pcs->hwndDlgParent, 
                            pcs,
                            &pcs->cd, 
                            pcs->nSourceFiles, 
                            FALSE, 
                            (iRet == BBDELETE_SIZE_TOO_BIG) ?
                            CONFIRM_WONT_RECYCLE_FOLDER :
                            CONFIRM_WONT_RECYCLE_OFFLINE, 
                            pszSource, 
                            pfdSrc, 
                            NULL, 
                            NULL,
                            NULL);

                    switch (result) 
                    {
                        case IDNO:
                            // user said "please dont really nuke the file"
                            pcs->lpfo->fAnyOperationsAborted = TRUE;
                            iRet = IDNO;  // Don't put up error message for this case
                            // WARNING: It is tempting to mark the corresponding connected folder as dummy here.
                            // But, this will not work because currently folders (nodes with children) can not be
                            // marked as dummy.
                            break;

                        case IDCANCEL:
                            // user canceled the operation
                            pcs->lpfo->fAnyOperationsAborted = TRUE;
                            pcs->bAbort = TRUE;
                            // WARNING: It is tempting to mark the corresponding connected folder as dummy here.
                            // But, this will not work because currently folders (nodes with children) can not be
                            // marked as dummy.
                            break;

                        case IDYES:
                        default:
                            // user said "please nuke the file"
                            // set this so the is correct progress animation is displayed
                            if (pcs)
                            {
                                pcs->fFlags &= ~FOF_ALLOWUNDO;
                            }

                            // dont allow undo since we are really nuking it
                            if (pcs->lpua)
                            {
                                FOUndo_Release(pcs->lpua);
                            }

                            UpdateProgressAnimation(pcs);

                            iRet = DoFile_Win32DeleteFileWithPidl(pszSource, &pcs->spc) ? 0 : GetLastError();
                            break;
                    }
                }
                break;

            case BBDELETE_CANNOT_DELETE:
                {
                    // This is the non-deletable file case. Note: this is an NT only case, and
                    // it could be caused by acls or the fact that the file is currently in use.
                    // We attemt to really delete the file (which should fail) so we can generate
                    // the proper error value
                    iRet = Win32DeleteFile(pszSource);

                    if (!iRet)
                    {
                        // indeed, the file/folder could not be deleted.
                        // Get last error to find out why
                        iRet = GetLastError();
                    }
                    else
                    {
                        // DeleteFileBB said that it couldn't be deleted, but we just nuked it. We will
                        // end up falling into this case when we hit things like Mounted Volumes and other
                        // reparse points that we can't "recycle".

                        // As Obi-Wan would say: "You don't need to see his identification... these aren't
                        // the droids you are looking for... He can go about his business... Move along."
                        iRet = ERROR_SUCCESS;
                        DTAbortCurrentNode(&pcs->dth);    // so we don't recurse down this folder

                        // dont allow undo since we really nuked it (cant bring it back...)
                        if (pcs->lpua)
                        {
                            FOUndo_Release(pcs->lpua);
                        }
                    }
                }
                break;

            case BBDELETE_FORCE_NUKE:
                {
                    // This is the catch-all case. If iRet = BDETETE_FORCE_NUKE, then we just nuke the 
                    // file without warning.

                    // set this so the is correct progress animation is displayed
                    if (pcs)
                    {
                        pcs->fFlags &= ~FOF_ALLOWUNDO;
                    }

                    // dont allow undo since we are going to nuke this file
                    if (pcs->lpua)
                    {
                        FOUndo_Release(pcs->lpua);
                    }

                    UpdateProgressAnimation(pcs);

                    iRet = DoFile_Win32DeleteFileWithPidl(pszSource, &pcs->spc) ? 0 : GetLastError();
                }
                break;

            case BBDELETE_CANCELLED:
                {
                    // user canceled the operation
                    pcs->lpfo->fAnyOperationsAborted = TRUE;
                    pcs->bAbort = TRUE;
                }
                break;

            case BBDELETE_UNKNOWN_ERROR:
            default:
                {
                    iRet = GetLastError();
                    ASSERT(iRet != ERROR_SUCCESS);
                }
                break;

        }
    } // !DeleteFileBB

    return iRet;
}

int DoFile_Copy(COPY_STATE* pcs, LPTSTR pszSource, LPTSTR pszDest, UINT cchDest,
                WIN32_FIND_DATA *pfd, WIN32_FIND_DATA * pfdDest, BOOL fRenameTried)
{
    /* Now try to copy the file.  Do extra error processing only
       in 2 cases:
       1) If a removeable drive is full let the user stick in a new disk
       2) If the path doesn't exist (the user typed in
       and explicit path that doesn't exits) ask if
       we should create it for him. */

    int ret = FileCopy(pcs, pszSource, pszDest, pfd, fRenameTried);

    if (ret == ERROR_CANCELLED)
    {
        pcs->bAbort = TRUE;
        return ret;
    }

    if ((ret & ~ERRORONDEST) == ERROR_FILE_EXISTS)
    {
        if (!fRenameTried)
        {
            int result = CheckForRenameCollision(pcs, OPER_DOFILE, pszSource, pszDest, cchDest, pfdDest, pfd);
            switch (result)
            {
                case IDUNKNOWN:
                    break;

                case IDRETRY:
                    return DoFile_Copy(pcs, pszSource, pszDest, cchDest, pfd, pfdDest, TRUE);

                case IDCANCEL:
                    pcs->bAbort = TRUE;
                    return result;

                case IDNO:
                    return result;

                default:
                    return result;
            }
        }
    }


    if ((((ret & ~ERRORONDEST) == ERROR_DISK_FULL) &&
                IsRemovableDrive(DRIVEID(pszDest))) ||
            ((ret & ~ERRORONDEST) == ERROR_PATH_NOT_FOUND))
    {
        ULARGE_INTEGER ulFileSize;
        ulFileSize.LowPart = pfd->nFileSizeLow;
        ulFileSize.HighPart = pfd->nFileSizeHigh;
        ret = CopyMoveRetry(pcs, pszDest, ret & ~ERRORONDEST, &ulFileSize);
        if (!ret)
        {
            return DoFile_Copy(pcs, pszSource, pszDest, cchDest, pfd, pfdDest, fRenameTried);
        }
        else
        {
            pcs->bAbort = TRUE;
            return ret;
        }
    }

    if (!ret)
    {
        // add to the undo atom
        // if we're doing a copy, only keep track of the highest most
        // level.. unless we're doing a merge sort of copy
        if (pcs->lpua)
        {
            if (DTNIsRootNode(pcs->dth.pdtnCurrent) && !DTNIsConnected(pcs->dth.pdtnCurrent))
                FOUndo_AddInfo(pcs->lpua, pszSource, pszDest, 0);
        }

        // if we copied in a new desktop ini, send out an update event for the paretn
        if (!lstrcmpi(PathFindFileName(pszDest), c_szDesktopIni))
        {
            TCHAR szDest[MAX_PATH];
            HRESULT hr = StringCchCopy(szDest, ARRAYSIZE(szDest), pszDest);
            if (SUCCEEDED(hr))
            {
                PathRemoveFileSpec(szDest);
                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szDest, NULL);
            }
        }
    }

    return ret;
}

int DoFile_Move(COPY_STATE* pcs, LPTSTR pszSource, LPTSTR pszDest, UINT cchDest,
                WIN32_FIND_DATA *pfd, WIN32_FIND_DATA * pfdDest, BOOL fRenameTried)
{
    int ret = 0;
    if (PathIsRoot(pszSource))
    {
        return DE_ROOTDIR;
    }
    if (PathIsRoot(pszDest))
    {
        return DE_ROOTDIR | ERRORONDEST;
    }

    AvoidCurrentDirectory(pszSource);

    if (PathIsSameRoot(pszSource, pszDest))
    {
TryAgain:
        ret = Win32MoveFile(pszSource, pszDest, ISDIRFINDDATA(*pfd)) ? 0 : GetLastError();

        // try to create the destination if it is not there
        if (ret == ERROR_PATH_NOT_FOUND)
        {
            ret = CopyMoveRetry(pcs, pszDest, ret, NULL);
            if (!ret)
            {
                goto TryAgain;
            }
        }

        if (ret == ERROR_ALREADY_EXISTS)
        {
            if (!fRenameTried)
            {
                int result = CheckForRenameCollision(pcs, OPER_DOFILE, pszSource, pszDest, cchDest, pfdDest, pfd);
                switch (result)
                {
                    case IDUNKNOWN:
                        break;
                    case IDRETRY:
                        fRenameTried = TRUE;
                        goto TryAgain;

                    case IDCANCEL:
                        pcs->bAbort = TRUE;
                        return result;

                    case IDNO:
                        return result;

                    default:
                        return result;
                }
            }
        }

        if ((ret == ERROR_SUCCESS)                              &&
                !SHRestricted(REST_NOENCRYPTONMOVE)                 &&
                !(pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                !(pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED))
        {
            TCHAR szDestDir[MAX_PATH];
            DWORD dwAttribs;

            // We are moving a file that is NOT encrypted. On Win2k, we need to check to see if this was a move to 
            // an encrypted folder. If so, we automatically encrypt the file.

            HRESULT hr = StringCchCopy(szDestDir, ARRAYSIZE(szDestDir), pszDest);
            if (SUCCEEDED(hr))
            {
                PathRemoveFileSpec(szDestDir);
                dwAttribs = GetFileAttributes(szDestDir);

                if ((dwAttribs != -1) && (dwAttribs & FILE_ATTRIBUTE_ENCRYPTED))
                {
                    // sanity check
                    ASSERT(dwAttribs & FILE_ATTRIBUTE_DIRECTORY);

                    // attempt to encrypt the file
                    if (!SHEncryptFile(pszDest, TRUE))
                    {
                        int result = CachedConfirmFileOp(pcs->hwndDlgParent,
                                                         pcs,
                                                         &pcs->cd,
                                                         pcs->nSourceFiles,
                                                         FALSE,
                                                         CONFIRM_FAILED_ENCRYPT,
                                                         pszDest,
                                                         pfd,   // since we just moved it, the attibs should be the same as the src
                                                         NULL,
                                                         NULL,
                                                         NULL);
                        switch (result)
                        {
                            case IDCANCEL:
                                // user canceled the operation
                                pcs->lpfo->fAnyOperationsAborted = TRUE;
                                pcs->bAbort = TRUE;
                                break;

                            case IDNO:
                                // user choose to "restore" the file to its original location
                                ret = Win32MoveFile(pszDest, pszSource, ISDIRFINDDATA(*pfd)) ? 0 : GetLastError();

                            case IDYES:
                            default:
                                // user ignored the error
                                break;
                        }
                    }
                }
            }
        }

        if (ret == ERROR_SUCCESS)
        {
            if (pcs->lpua && DTNIsRootNode(pcs->dth.pdtnCurrent) && !DTNIsConnected(pcs->dth.pdtnCurrent))
            {
                // add to the undo atom
                FOUndo_AddInfo(pcs->lpua, pszSource, pszDest, 0);
            }

            // Win32MoveFile on a single-volume leaves the original ACL
            // intact.  If necessary, pick up perms from the destination.
            if (pcs->fFlags & FOF_NOCOPYSECURITYATTRIBS)
            {
                ResetFileSecurity(pszDest);
            }

            // if we copied in a new desktop ini, send out an update event for the paretn
            if (!lstrcmpi(PathFindFileName(pszDest), c_szDesktopIni))
            {
                TCHAR szDest[MAX_PATH];
                HRESULT hr = StringCchCopy(szDest, ARRAYSIZE(szDest), pszDest);
                if (SUCCEEDED(hr))
                {
                    PathRemoveFileSpec(szDest);
                    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szDest, NULL);
                }
            }
        }
    }
    else
    {
        // we must force all copies to go through
        // straight so we can remove the source
        if (DTNIsConnected(pcs->dth.pdtnCurrent) && !PathFileExists(pszSource))
        {
            //This can happen if "foo.htm" and "foo files" were moved by the end-user.
            // The connected file had already been moved and hence this is not an error!
            ret = 0; //No error! That file has been moved already!
        }
        else
        {
            ret = DoFile_Copy(pcs, pszSource, pszDest, cchDest, pfd, pfdDest, FALSE);
        }
    }

    return ret;
}

int DoFile_Rename(COPY_STATE* pcs, LPTSTR pszSource, LPTSTR pszDest, UINT cchDest,
                  WIN32_FIND_DATA *pfd, WIN32_FIND_DATA * pfdDest, BOOL fRenameTried)
{
    LPTSTR p = PathFindFileName(pszSource);

    /* Get raw source and dest paths.  Check to make sure the
       paths are the same */
    int ret = !IntlStrEqNI(pszSource, pszDest, (int)(p - pszSource));
    if (ret)
    {
        return DE_DIFFDIR;
    }
    
    return DoFile_Move(pcs, pszSource, pszDest, cchDest, pfd, pfdDest, fRenameTried);
}


int MoveCopyInitPCS(COPY_STATE * pcs)
{
    BOOL fMultiDest = FALSE;
    int ret = 0;
    LPTSTR p = NULL;
    TCHAR szDestPath[MAX_PATH];

    pcs->nSourceFiles = CountFiles(pcs->lpfo->pFrom);      // multiple source files?

    pcs->fProgressOk = TRUE;

    // skip destination processing if we are deleting files
    if (pcs->lpfo->wFunc != FO_DELETE)
    {
        HRESULT hr = S_OK;
        if (pcs->lpfo->pTo == NULL)
        {
            szDestPath[0] = 0;
        }
        else
        {
            hr = StringCchCopy(szDestPath, ARRAYSIZE(szDestPath), pcs->lpfo->pTo);
        }

        if (SUCCEEDED(hr))
        {
            if (!szDestPath[0])           // NULL dest is same as "."
            {
                szDestPath[0] = TEXT('.');
                szDestPath[1] = 0;
            }
        }

        if (FAILED(hr) || PathIsInvalid(szDestPath))
        {
            CopyError(pcs, c_szNULL, c_szNULL, DE_INVALIDFILES | ERRORONDEST, pcs->lpfo->wFunc, 0);
            return ERROR_ACCESS_DENIED;
        }

        if (pcs->lpfo->wFunc == FO_RENAME)
        {
            // don't let them rename multiple files to one single file

            if ((pcs->nSourceFiles != 1) && !PathIsWild(szDestPath))
            {
                CopyError(pcs, c_szNULL, c_szNULL, DE_MANYSRC1DEST, pcs->lpfo->wFunc, 0);
                return DE_MANYSRC1DEST;
            }
            fMultiDest = TRUE;
        }
        else    // FO_COPY or FO_MOVE at this point
        {
            fMultiDest = ((pcs->fFlags & FOF_MULTIDESTFILES) &&
                    (pcs->nSourceFiles == CountFiles(pcs->lpfo->pTo)));

            if (!fMultiDest)
            {
                // for backwards compat.
                // copy c:\foo.bar c:\folder\foo.bar  means
                // multi dest if foo.bar doesn't exist.
                // Hack if it is a root we special case this for the offline 
                // floppy case...
                if (pcs->nSourceFiles == 1 && !PathIsRoot(szDestPath) && 
                        !PathIsDirectory(szDestPath))
                {
                    fMultiDest = TRUE;
                }
            }

        }
    }

    pcs->dth.fMultiDest = fMultiDest;

    return 0;
}


DWORD   g_dwStopWatchMode = 0xffffffff;  // Shell performance mode

// actually this does move/copy/rename/delete
int MoveCopyDriver(COPY_STATE *pcs)
{
    int ret;
    WIN32_FIND_DATA fdSrc;
    WIN32_FIND_DATA fdDest;
    HDPA hdpaDeletedFiles = NULL;
    LPSHFILEOPSTRUCT lpfo = pcs->lpfo;
    TCHAR szText[28];
    BOOL bInitialAllowUndo = FALSE;
    DWORD dwLastUpdateTime = 0;
    BOOL fShouldSuspendEvents = FALSE;
    HANDLE hEventRunning;

    if (g_dwStopWatchMode)
    {
        if (g_dwStopWatchMode == 0xffffffff)
        {
            g_dwStopWatchMode = StopWatchMode();    // Since the stopwatch funcs live in shdocvw, delay this call so we don't load shdocvw until we need to
        }

        if (g_dwStopWatchMode)
        {
            StringCchCopy(szText, ARRAYSIZE(szText), TEXT("Shell "));
            switch (lpfo->wFunc)
            {
                case FO_COPY:
                    StringCchCat(szText, ARRAYSIZE(szText), TEXT("Copy  "));
                    break;
                case FO_MOVE:
                    StringCchCat(szText, ARRAYSIZE(szText), TEXT("Move  "));
                    break;
                case FO_DELETE:
                    StringCchCat(szText, ARRAYSIZE(szText), TEXT("Delete"));
                    break;
                case FO_RENAME:
                    StringCchCat(szText, ARRAYSIZE(szText), TEXT("Rename"));
                    break;
                default:
                    StringCchCat(szText, ARRAYSIZE(szText), TEXT("Copy? "));
                    break;
            }
            StringCchCat(szText, ARRAYSIZE(szText), TEXT(": Start"));
            StopWatch_Start(SWID_COPY, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
        }
    }

    // start by assuming an error.  Non-zero means an error has occured.  If we don't
    // start with this assumption then we will return success if MoveCopyInitPCS fails.
    ret = ERROR_GEN_FAILURE;

    if (!ValidFilenames(lpfo->pFrom))
    {
        CopyError(pcs, c_szNULL, c_szNULL, DE_INVALIDFILES, lpfo->wFunc, 0);
        return ERROR_ACCESS_DENIED;
    }

    StartCopyEngine(&hEventRunning);

    // Check the pcs destination directory to make sure it is valid for the given source file list
    if (MoveCopyInitPCS(pcs))
    {
        goto ExitLoop;          // Destination is invalid so we bail out
    }

    // Build a tree where each node is a source file, a dest file, and an operation to perform
    ret = DTBuild(pcs);
    if (ret)
    {
        goto ShowMessageBox;
    }

    // Speed optimization: for a delete, sending all FSNotifies really bogs down the system,
    // so we skip it and rely on the file system notifies.
    if (((lpfo->wFunc == FO_DELETE) || (lpfo->wFunc == FO_MOVE)) && (pcs->dth.dtAll.dwFiles > 100))
    {
        // Only suspend notifies for local moves
        if (lpfo->wFunc == FO_MOVE)
        {
            if (lpfo->pTo)
            {
                int idDrive = PathGetDriveNumber(lpfo->pFrom);
                if (idDrive == PathGetDriveNumber(lpfo->pTo) && !IsNetDrive(idDrive))
                {
                    fShouldSuspendEvents = TRUE;
                }
            }
        }
        else
        {
            fShouldSuspendEvents = TRUE;
        }
    }

    if (fShouldSuspendEvents)
    {
        // SuspendSHNotify can fail if another thread is using it. Only one thread at a time can suspend notify.
        fShouldSuspendEvents = SuspendSHNotify();
    }


    // save off the initial state of the allowundo flag
    if (pcs->fFlags & FOF_ALLOWUNDO)
    {
        bInitialAllowUndo = TRUE;
    }

    // When first starting, we assume that stream loss is possible until we prove
    // otherwise for the current directory.  This gets reset to true each time we
    // enter a new dir via EnterDir_Move or EnterDir_Copy

    pcs->bStreamLossPossible = TRUE;

    for (;;)
    {
        BOOL bUpdateAnimation = FALSE;
        int result;
        DWORD dwTickCount;
        BOOL bTimeToUpdate = FALSE;
        BOOL fOk;

        pcs->dth.oper = DTGoToNextNode(&pcs->dth,pcs);

        dwTickCount = GetTickCount();
        if ((dwTickCount - dwLastUpdateTime) > 10)
        {
            dwLastUpdateTime = dwTickCount;
            bTimeToUpdate = TRUE;
        }

        if ((pcs->dth.oper & OPER_MASK) == OPER_ERROR)
        {
            CopyError(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, LOBYTE(pcs->dth.oper), pcs->lpfo->wFunc, OPER_DOFILE);
            // If the directory is copied but a file inside that directory could not 
            // be copied because of long filename, check to see if this is
            // a connected element. If so, invoke undo, sothat we getback the orginal html file 
            // in the same place as the associated folder.
            if ((pcs->dth.oper == (OPER_ERROR | DE_INVALIDFILES)) &&
                    (DTNIsConnected(pcs->dth.pdtnCurrent)))
            {
                if (pcs->lpua)
                {
                    pcs->lpua->foFlags |= FOF_NOCONFIRMATION;
                    FOUndo_Invoke(pcs->lpua);
                    pcs->lpua = NULL;
                }
            }
            break;
        }

        if (!pcs->dth.oper || pcs->bAbort)     // all done?
        {
            break;
        }

        if (DTNIsRootNode(pcs->dth.pdtnCurrent) && (pcs->dth.oper != OPER_LEAVEDIR))
        {
            int iDrive;

            // check to see if we switched between doing a move to
            // recycle bin and a true delete (this would happen when
            // there was an object that was too big for the recycle bin)
            if (!(pcs->fFlags & FOF_ALLOWUNDO) && bInitialAllowUndo)
            {
                // reset the allowundo flag since we have a new root node, and we
                // want to attempt to send it to the recycle bin
                pcs->fFlags |= FOF_ALLOWUNDO;

                // we delay to update the progress animation till we are basically
                // done, which allows us to keep the progress and animation in sync
                bUpdateAnimation = TRUE;
            }

            pcs->fMerge = FALSE;
            pcs->fFromCDRom = FALSE;

            // Check source for being a CDRom
            iDrive = PathGetDriveNumber(pcs->dth.szSrcPath);
            if (-1 != iDrive)
            {
                TCHAR szDrive[4];
                if (DRIVE_CDROM == GetDriveType(PathBuildRoot(szDrive, iDrive)))
                {
                    pcs->fFromCDRom = TRUE;
                }
            }
        }
        
        fOk = DTGetWin32FindData(pcs->dth.pdtnCurrent, &fdSrc);
        if (!fOk)
        {
            ret = ERROR_FILENAME_EXCED_RANGE;
            goto ShowMessageBox;
        }

        fdDest.dwFileAttributes = 0;

        DebugMsg(TF_DEBUGCOPY, TEXT("MoveCopyDriver(): Oper %x From(%s) To(%s)"), pcs->dth.oper, (LPCTSTR)pcs->dth.szSrcPath, (LPCTSTR)pcs->dth.szDestPath);

        // some operation that may effect the destination (have a collision)
        if ((pcs->lpfo->wFunc != FO_DELETE) && (pcs->dth.oper != OPER_LEAVEDIR))
        {
            // this compare needs to be case sensitive, and locale insensitive
            if (!StrCmpC(pcs->dth.szSrcPath, pcs->dth.szDestPath) &&
                    !(pcs->fFlags & FOF_RENAMEONCOLLISION))
            {
                // Source and dest are the same file, and name collision
                // resolution is not turned on, so we just return an error.

                // TODO: Show the error dialog here and allow for SKIP

                ret = DE_SAMEFILE;
                goto ShowMessageBox;
            }
        }

        result = AllConfirmations(pcs, &fdSrc, pcs->dth.oper, pcs->lpfo->wFunc, pcs->dth.szSrcPath, 
                pcs->dth.szDestPath, bTimeToUpdate, &fdDest, &ret);
        switch (result)
        {
            case IDNO:
                DTAbortCurrentNode(&pcs->dth);
                lpfo->fAnyOperationsAborted = TRUE;
                continue;

            case IDCANCEL:
                pcs->bAbort = TRUE;
                goto ExitLoop;

            case IDYES:
                break;

            default:
                ret = result;
                goto ShowMessageBox;
        }

        /* Now determine which operation to perform */

        switch (pcs->dth.oper | pcs->lpfo->wFunc)
        {
            // Note that ENTERDIR is not done for a root, even though LEAVEDIR is
            case OPER_ENTERDIR | FO_MOVE:  // Create dest, verify source delete
                ret = EnterDir_Move(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, ARRAYSIZE(pcs->dth.szDestPath), &fdSrc, &fdDest, FALSE);
                break;

            case OPER_ENTERDIR | FO_COPY:  // Create destination directory
                ret = EnterDir_Copy(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, ARRAYSIZE(pcs->dth.szDestPath), &fdSrc, &fdDest, FALSE, FALSE);
                break;

            case OPER_LEAVEDIR | FO_MOVE:
            case OPER_LEAVEDIR | FO_DELETE:
                ret = LeaveDir_Delete(pcs, pcs->dth.szSrcPath);
                break;

            case OPER_LEAVEDIR | FO_COPY:
                break;

            case OPER_DOFILE | FO_COPY:
                ret = DoFile_Copy(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, ARRAYSIZE(pcs->dth.szDestPath), &fdSrc, &fdDest, FALSE);
                break;

            case OPER_DOFILE | FO_RENAME:
                ret = DoFile_Rename(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, ARRAYSIZE(pcs->dth.szDestPath), &fdSrc, &fdDest, FALSE);
                break;

            case OPER_DOFILE | FO_MOVE:
                ret = DoFile_Move(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, ARRAYSIZE(pcs->dth.szDestPath), &fdSrc, &fdDest, FALSE);
                break;

            case OPER_ENTERDIR | FO_DELETE:
                ret = EnterDir_Delete(pcs, &fdSrc, pcs->dth.szSrcPath, ARRAYSIZE(pcs->dth.szSrcPath), &hdpaDeletedFiles);
                break;

            case OPER_DOFILE | FO_DELETE:
                ret = DoFile_Delete(pcs, &fdSrc, pcs->dth.szSrcPath, ARRAYSIZE(pcs->dth.szSrcPath), &hdpaDeletedFiles, fShouldSuspendEvents);
                break;

            default:
                DebugMsg(DM_ERROR, TEXT("Invalid file operation"));
                ret = 0;         // internal error
                break;
        } // switch (pcs->dth.oper | pcs->lpfo->wFunc)

        if (pcs->bAbort)
            break;

        if (ret == IDNO)
        {
            pcs->lpfo->fAnyOperationsAborted = TRUE;
        }
        else if (ret)
        {      // any errors?
ShowMessageBox:
            // If source file is a connected item and is not found, that means that
            // we have already moved/deleted/renamed it. So, don't report that as error!
            if ((!pcs->dth.pdtnCurrent) || (!pcs->dth.pdtnCurrent->fConnectedElement) || 
                    ((ret != ERROR_FILE_NOT_FOUND) && (ret != ERROR_PATH_NOT_FOUND)))
            {
                CopyError(pcs, pcs->dth.szSrcPath, pcs->dth.szDestPath, ret, pcs->lpfo->wFunc, pcs->dth.oper);

                // If the directory is copied but a file inside that directory could not 
                // be copied because of long filename, check to see if this is
                // a connected element. If so, invoke undo, sothat we getback the orginal html file 
                // in the same place as the associated folder.
                if ((ret == ERROR_FILENAME_EXCED_RANGE) &&
                        (DTNIsConnected(pcs->dth.pdtnCurrent)))
                {
                    if (pcs->lpua)
                    {
                        pcs->lpua->foFlags |= FOF_NOCONFIRMATION;
                        FOUndo_Invoke(pcs->lpua);
                        pcs->lpua = NULL;
                    }
                }
                break;
            }
        }

        if (bTimeToUpdate)
        {
            // perform the delayed update of the dialog
            if (bUpdateAnimation)
            {
                UpdateProgressAnimation(pcs);
                bUpdateAnimation = FALSE;
            }
            // We check to see if we are finished here (instead of at the
            // start) since we want to keep the progress a step behind what
            // we are doing to ensure we have the correct progress animation
            // and text (since FOQueryAbort updates the progress text)
            if (FOQueryAbort(pcs))
                break;
        }
    }

ExitLoop:

    // this happens in error cases where we broke out of the pcr loop
    // without hitting the end

    lpfo->hNameMappings = pcs->dth.hdsaRenamePairs;

    DTCleanup(&pcs->dth);
    BBFinishDelete(hdpaDeletedFiles);

    if (fShouldSuspendEvents)
    {
        ResumeSHNotify();

        if (lpfo->wFunc == FO_DELETE)
        {
            TCHAR szNotifyPath[MAX_PATH];
            int iDrive;

            // Since we probably blew away any chance at having the FSNotify work, make sure
            // we update dir for this path...  we can send the message on any drive since
            // the bitbucket listens for changes on all drives.

            iDrive = DriveIDFromBBPath(lpfo->pFrom);
            if ((iDrive == -1) || !DriveIDToBBPath(iDrive, szNotifyPath))
            {
                StringCchCopy(szNotifyPath, ARRAYSIZE(szNotifyPath), lpfo->pFrom);  // failure ok since only use for changenotify
                PathRemoveFileSpec(szNotifyPath);
            }

            SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, szNotifyPath, NULL);
        }
    }


    if (g_dwStopWatchMode)
    {
        StringCchCopy(&szText[12], ARRAYSIZE(szText)-12, TEXT(": Stop "));
        StopWatch_Stop(SWID_COPY, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
    }

    EndCopyEngine(hEventRunning);
    
    return ret;
}



void SetWindowTextFromRes(HWND hwnd, int id)
{
    TCHAR szTemp[80];

    LoadString(HINST_THISDLL, id, szTemp, ARRAYSIZE(szTemp));
    SetWindowText(hwnd, szTemp);
}

int CountProgressPoints(COPY_STATE *pcs, PDIRTOTALS pdt)
{
    // point value for each item
    int iTotal = 0;
    UINT uSize = pcs->uSize;

    if (!uSize)
    {
        uSize = 32*1024;
    }
    // now add it up.
    iTotal += (UINT)((pdt->liSize.QuadPart/uSize) * pcs->dth.iSizePoints);
    iTotal += pdt->dwFiles * pcs->dth.iFilePoints;
    iTotal += pdt->dwFolders * pcs->dth.iFolderPoints;

    return iTotal;
}

void UpdateProgressDialog(COPY_STATE* pcs)
{
    int iRange;  // from 0 to iRange
    int iPos;  // how much is done.

    if (pcs->fProgressOk)
    {

        if (pcs->dth.dtAll.fChanged)
        {
            pcs->dth.dtAll.fChanged = FALSE;
            iRange = CountProgressPoints(pcs, &pcs->dth.dtAll);
            SendProgressMessage(pcs, PBM_SETRANGE32, 0, iRange);
            DebugMsg(TF_DEBUGCOPY, TEXT("UpdateProgressDialog iRange = %d "), iRange);
        }

        if (pcs->dth.dtDone.fChanged)
        {
            pcs->dth.dtDone.fChanged = FALSE;
            iPos = CountProgressPoints(pcs, &pcs->dth.dtDone);
            SendProgressMessage(pcs, PBM_SETPOS, iPos, 0);
            DebugMsg(TF_DEBUGCOPY, TEXT("UpdateProgressDialog iPos = %d "), iPos);
        }
    }
}

// NOTE: !! do NOT refrence pcs->lpfo anywhere in this dialog proc !! 
//
// It can be freed while we are still running. If you need to get information from it, 
// add a new member to the FOUITHREADINFO struct and copy the value from the pcs->lpfo
// into the member (while holding the critsec) right before we create this dlg.
BOOL_PTR CALLBACK FOFProgressDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    FOUITHREADINFO* pfouiti = (FOUITHREADINFO*)GetWindowLongPtr(hDlg, DWLP_USER);
    COPY_STATE *pcs = (pfouiti ? pfouiti->pcs : NULL);

    if (WM_INITDIALOG == wMsg)
    {
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        pfouiti = (FOUITHREADINFO*)lParam;
        pcs = pfouiti->pcs;

        SetWindowTextFromRes(hDlg, IDS_ACTIONTITLE + pfouiti->wFunc);

        if (pcs->fFlags & FOF_SIMPLEPROGRESS)
        {
            TCHAR szFrom[MAX_PATH];
            if (pcs->lpszProgressTitle)
            {
                if (IS_INTRESOURCE(pcs->lpszProgressTitle))
                {
                    LoadString(HINST_THISDLL, PtrToUlong(pcs->lpszProgressTitle), szFrom, ARRAYSIZE(szFrom));
                    pcs->lpszProgressTitle = szFrom;
                }
                SetDlgItemText(hDlg, IDD_NAME, pcs->lpszProgressTitle);
                // null it so we only set it once
                pcs->lpszProgressTitle = NULL;
            }
        }

        return FALSE;
    }

    if (pcs)
    {
        switch (wMsg)
        {
            case WM_TIMER:
                if (IsWindowEnabled(hDlg))
                    SetProgressTime(pcs);
                break;

            case WM_SHOWWINDOW:
                if (wParam)
                {
                    int idAni;
                    HWND hwndAnimation;

                    ASSERT(pfouiti->wFunc >= FO_MOVE && pfouiti->wFunc <= FO_DELETE);
                    ASSERT(FO_COPY==FO_MOVE+1);
                    ASSERT(FO_DELETE==FO_COPY+1);
                    ASSERT(IDA_FILECOPY==IDA_FILEMOVE+1);
                    ASSERT(IDA_FILEDEL ==IDA_FILECOPY+1);

                    switch (pfouiti->wFunc)
                    {
                        case FO_DELETE:
                            if (pfouiti->bIsEmptyRBOp)
                            {
                                idAni = IDA_FILENUKE;
                                break;
                            }
                            else if (!(pcs->fFlags & FOF_ALLOWUNDO))
                            {
                                idAni = IDA_FILEDELREAL;
                                break;
                            }
                            // else fall through

                        default:
                            idAni = (IDA_FILEMOVE + (int)pfouiti->wFunc - FO_MOVE);
                    }

                    hwndAnimation = GetDlgItem(hDlg,IDD_ANIMATE);

                    Animate_Open(hwndAnimation, IntToPtr(idAni));

                    SetProp(hwndAnimation, TEXT("AnimationID"), IntToPtr(idAni));

                    // a timer every MS_TIMESLICE seconds to update the progress time estimate
                    SetTimer(hDlg, 1, MS_TIMESLICE, NULL);
                }
                break;

            case WM_ENABLE:
                if (wParam)
                {
                    if (pcs->dwPreviousTime)
                    {
                        // if we're enabling it, set the previous time to now
                        // because no action has happened while we were disabled
                        pcs->dwPreviousTime = GetTickCount();
                    }
                }
                else
                {
                    SetProgressTime(pcs);
                }
                PauseAnimation(pcs, wParam == 0);
                break;

            case WM_COMMAND:
                switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                    case IDCANCEL:
                        pcs->bAbort = TRUE;
                        ShowWindow(hDlg, SW_HIDE);
                        break;
                }
                break;

            case PDM_SHUTDOWN:
                // Make sure this window is shown before telling the user there
                // is a problem
                // ignore FOF_NOERRORUI here because of the nature of the situation
                ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_CANTSHUTDOWN),
                        NULL, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
                break;

            case PDM_NOOP:
                // a dummy id that we can take so that folks can post to us and make
                // us go through the main loop
                break;

            case PDM_UPDATE:
                pcs->dth.fChangePosted = FALSE;
                UpdateProgressDialog(pcs);
                break;

            case WM_QUERYENDSESSION:
                // Post a message telling the dialog to show the "We can't shutdown now"
                // dialog and return to USER right away, so we don't have to worry about
                // the user not clicking the OK button before USER puts up its "this
                // app didn't respond" dialog
                PostMessage(hDlg, PDM_SHUTDOWN, 0, 0);

                // Make sure the dialog box procedure returns FALSE
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                return TRUE;

            default:
                return FALSE;
        }
    }
    return TRUE;
}

int CALLBACK FOUndo_FileReallyDeletedCallback(UNDOATOM *lpua, LPARAM lParam)
{
    LPTSTR * ppsz = (LPTSTR*)lParam;
    // this is our signal to nuke the rest
    if (!*ppsz)
        return EUA_DELETE;

    switch (lpua->uType) 
    {
        case IDS_RENAME:
        case IDS_COPY:
        case IDS_MOVE:
        case IDS_DELETE: 
            {
                LPFOUNDODATA lpud = (LPFOUNDODATA)lpua->lpData;
                HDPA hdpa = lpud->hdpa;
                // only the destinations matter.
                int i, iMax = DPA_GetPtrCount(hdpa);
                for (i = 1; i <= iMax; i += 2) 
                {
                    LPTSTR lpsz = DPA_GetPtr(hdpa, i);
                    if (lstrcmpi(lpsz, *ppsz) == 0) 
                    {
                        *ppsz = NULL;
                        break;
                    }
                }
            }
            break;
    }

    // this is our signal to nuke the rest
    if (!*ppsz)
        return EUA_DELETE;
    else
        return EUA_DONOTHING;
}

// someone really really deleted a file.  make sure we no longer have
// any undo information pointing to it.
void FOUndo_FileReallyDeleted(LPTSTR lpszFile)
{
    EnumUndoAtoms(FOUndo_FileReallyDeletedCallback, (LPARAM)&lpszFile);
}


int CALLBACK FOUndo_FileRestoredCallback(UNDOATOM *lpua, LPARAM lParam)
{
    LPTSTR psz = (LPTSTR)lParam;

    switch (lpua->uType) 
    {
        case IDS_DELETE: 
            {
                LPFOUNDODATA lpud = (LPFOUNDODATA)lpua->lpData;
                HDPA hdpa = lpud->hdpa;
                LPTSTR lpsz;
                int i, iMax;

                ASSERT(hdpa);
                // only the destinations matter.
                iMax = DPA_GetPtrCount(hdpa);
                for (i = 1; i <= iMax; i += 2) 
                {
                    lpsz = DPA_GetPtr(hdpa, i);
                    if (lstrcmpi(lpsz, psz) == 0) 
                    {
                        ENTERCRITICAL;

                        Str_SetPtr(&lpsz, NULL);
                        lpsz = DPA_GetPtr(hdpa, i - 1);
                        Str_SetPtr(&lpsz, NULL);
                        DPA_DeletePtr(hdpa, i);
                        DPA_DeletePtr(hdpa, i - 1);

                        LEAVECRITICAL;

                        if (DPA_GetPtrCount(hdpa))
                            return EUA_ABORT;
                        else
                            return EUA_DELETEABORT;
                    }
                }
            }
            break;
    }
    return EUA_DONOTHING;
}

// this means someone restored a file (via ui in the bitbucket)
// so we need to clean up the undo info.
void FOUndo_FileRestored(LPCTSTR lpszFile)
{
    EnumUndoAtoms(FOUndo_FileRestoredCallback, (LPARAM)lpszFile);
}


void FOUndo_AddInfo(UNDOATOM *lpua, LPTSTR lpszSrc, LPTSTR lpszDest, DWORD dwAttributes)
{
    HDPA hdpa;
    LPTSTR lpsz = NULL;
    int i;
    LPFOUNDODATA lpud;

    if (lpua->lpData == (void *)-1)
        return;

    if (!lpua->lpData) 
    {
        lpua->lpData = LocalAlloc(LPTR, sizeof(FOUNDODATA));
        if (!lpua->lpData)
            return;

        ((LPFOUNDODATA)lpua->lpData)->hdpa = (void *)DPA_Create(4);
    }

    lpud = lpua->lpData;

    hdpa = lpud->hdpa;
    if (!hdpa)
        return;

    // if it's a directory that got deleted, we're just going to save it's
    // attributes so that we can recreate it later.
    // directories do NOT get moved into the wastebasket
    if ((lpua->uType == IDS_DELETE) && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        FOUNDO_DELETEDFILEINFO dfi;
        if (!lpud->hdsa)
        {
            lpud->hdsa = DSA_Create(sizeof(FOUNDO_DELETEDFILEINFO),  4);
            if (!lpud->hdsa)
                return;
        }

        Str_SetPtr(&lpsz, lpszSrc);
        dfi.lpszName = lpsz;
        dfi.dwAttributes = dwAttributes;
        DSA_AppendItem(lpud->hdsa, &dfi);
    }
    else
    {    
        Str_SetPtr(&lpsz, lpszSrc);
        if (!lpsz)
            return;

        if ((i = DPA_AppendPtr(hdpa, lpsz)) == -1)
        {
            return;
        }

        lpsz = NULL;
        Str_SetPtr(&lpsz, lpszDest);
        if (!lpsz ||
                DPA_AppendPtr(hdpa, lpsz) == -1)
        {
            DPA_DeletePtr(hdpa, i);
        }
    }
}


LPTSTR DPA_ToFileList(HDPA hdpa, int iStart, int iEnd, int iIncr)
{
    LPTSTR lpsz;
    LPTSTR lpszReturn;
    int ichSize;
    int ichTemp;
    int i;

    // undo copy by deleting destinations
    lpszReturn = (LPTSTR)LocalAlloc(LPTR, 1);
    if (!lpszReturn)
    {
        return NULL;
    }

    ichSize = 1;
    // build the NULL separated file list
    // go from the end to the front.. restore in reverse order!
    for (i = iEnd; i >= iStart ; i -= iIncr)
    {
        LPTSTR psz;
        HRESULT hr;
        UINT cchLen;
        lpsz = DPA_GetPtr(hdpa, i);
        ASSERT(lpsz);

        ichTemp  = ichSize - 1;
        cchLen = lstrlen(lpsz);
        ichSize += (cchLen + 1);
        psz = (LPTSTR)LocalReAlloc((HLOCAL)lpszReturn, ichSize * sizeof(TCHAR),
            LMEM_MOVEABLE|LMEM_ZEROINIT);
        if (!psz)
        {
            break;
        }
        lpszReturn = psz;
        hr = StringCchCopyN(lpszReturn + ichTemp, ichSize - ichTemp, lpsz, cchLen);
        if (FAILED(hr))
        {
            break;
        }
    }

    if ((i + iIncr) != iStart)
    {
        LocalFree((HLOCAL)lpszReturn);
        lpszReturn = NULL;
    }
    return lpszReturn;
}

// from dpa to:
// 'file 1', 'file 2' and 'file 3'
LPTSTR DPA_ToQuotedFileList(HDPA hdpa, int iStart, int iEnd, int iIncr)
{
    LPTSTR lpsz;
    LPTSTR lpszReturn;
    TCHAR szFile[MAX_PATH];
    int ichSize;
    int ichTemp;
    int i;
    SHELLSTATE ss;

    // undo copy by deleting destinations
    lpszReturn = (LPTSTR)(void*)LocalAlloc(LPTR, 1);
    if (!lpszReturn)
    {
        return NULL;
    }

    SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS|SSF_SHOWALLOBJECTS, FALSE);

    ichSize = 1;
    // build the quoted file list
    for (i = iStart; i < iEnd ; i += iIncr)
    {
        LPTSTR psz;
        HRESULT hr;
        ichTemp  = ichSize - 1;

        // get the name (filename only without extension)
        lpsz = DPA_GetPtr(hdpa, i);
        hr = StringCchCopy(szFile, ARRAYSIZE(szFile), PathFindFileName(lpsz));
        if (FAILED(hr))
        {
            LocalFree(lpszReturn);
            lpszReturn = NULL;
            break;
        }

        if (!ss.fShowExtensions)
        {
            PathRemoveExtension(szFile);
        }

        // grow the buffer and add it in
        ichSize += lstrlen(szFile) + 2;
        psz = (LPTSTR)LocalReAlloc((HLOCAL)lpszReturn, ichSize * sizeof(TCHAR),
            LMEM_MOVEABLE|LMEM_ZEROINIT);
        if (!psz)
        {
            LocalFree(lpszReturn);
            lpszReturn = NULL;
            break;
        }
        lpszReturn = psz;

        // is it too long?
        if (ichSize >= MAX_PATH)
        {
            StringCchCat(lpszReturn, ichSize, c_szEllipses);
            return lpszReturn;
        }
        else
        {
            StringCchCat(lpszReturn, ichSize, TEXT("'")); //A single quote BEFORE the filename. - should fit because of realloc above
            StringCchCat(lpszReturn, ichSize, szFile);  // should fit because of realloc above
            StringCchCat(lpszReturn, ichSize, TEXT("'")); //A single quote AFTER the filename. - should fit because of realloc above
        }

        ASSERT(ichSize == ichTemp + (lstrlen(lpszReturn + ichTemp) + 1));
        ichTemp  = ichSize - 1;

        // check to see if we need the "and"
        if ((i + iIncr) < iEnd)
        {
            TCHAR szTemp[40];
            int id;

            ichSize += 40;

            if ((i + (iIncr*2)) >= iEnd)
            {
                id = IDS_SPACEANDSPACE;
            }
            else
            {
                id = IDS_COMMASPACE;
            }

            psz = (LPTSTR)LocalReAlloc((HLOCAL)lpszReturn, ichSize * sizeof(TCHAR),
                    LMEM_MOVEABLE|LMEM_ZEROINIT);
            if (!psz)
            {
                LocalFree(lpszReturn);
                lpszReturn = NULL;
                break;
            }
            lpszReturn = psz;
            LoadString(HINST_THISDLL, id, szTemp, ARRAYSIZE(szTemp));
            StringCchCat(lpszReturn, ichSize, szTemp);      // should fit because of realloc above
            ichSize = ichTemp + (lstrlen(lpszReturn + ichTemp) + 1);
        }
    }
    return lpszReturn;
}


void CALLBACK FOUndo_GetText(UNDOATOM *lpua, TCHAR * buffer, UINT cchBuffer, int type)
{
    LPFOUNDODATA lpud = (LPFOUNDODATA)lpua->lpData;
    HDPA hdpa = lpud->hdpa;

    if (type == UNDO_MENUTEXT)
    {
        LoadString(HINST_THISDLL, lpua->uType, buffer, MAX_PATH);
    }
    else
    {
        TCHAR szTemplate[80];
        // thank god for growable stacks..
        TCHAR szFile1[MAX_PATH];
        TCHAR szFile2[MAX_PATH];
        TCHAR szFile1Short[30];
        TCHAR szFile2Short[30];
        TCHAR *lpszFile1;
        TCHAR *lpszFile2;

        // get the template
        LoadString(HINST_THISDLL, lpua->uType + (IDS_UNDO_FILEOPHELP - IDS_UNDO_FILEOP), szTemplate, ARRAYSIZE(szTemplate));

        if (lpua->uType == IDS_RENAME)
        {
            SHELLSTATE ss;
            LPTSTR pszTemp;
            HRESULT hr;

            // fill in the file names
            lpszFile1 = DPA_GetPtr(hdpa, 0);
            lpszFile2 = DPA_GetPtr(hdpa, 1);
            hr = StringCchCopy(szFile1, ARRAYSIZE(szFile1), PathFindFileName(lpszFile1));
            if (FAILED(hr))
            {
                szFile1[0] = TEXT('\0');
            }
            hr = StringCchCopy(szFile2, ARRAYSIZE(szFile2), PathFindFileName(lpszFile2));
            if (FAILED(hr))
            {
                szFile2[0] = TEXT('\0');
            }
            
            SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);
            if (!ss.fShowExtensions)
            {
                PathRemoveExtension(szFile1);
                PathRemoveExtension(szFile2);
            }

            // length sanity check
            // don't just whack "..." at 30 bytes into szFile1 since that may be a dbcs character...
            PathCompactPathEx(szFile1Short, szFile1, ARRAYSIZE(szFile1Short), 0);
            PathCompactPathEx(szFile2Short, szFile2, ARRAYSIZE(szFile2Short), 0);

            pszTemp = ShellConstructMessageString(HINST_THISDLL, szTemplate, szFile1Short, szFile2Short);
            if (pszTemp)
            {
                hr = StringCchCopy(buffer, cchBuffer, pszTemp); // ok to truncate, just a message
                LocalFree(pszTemp);
            }
        }
        else
        {
            TCHAR *lpszFile1;
            HDPA hdpaFull = hdpa;
            // in the case of delete (where ther's an hdsa)
            // we need to add in the names of folders deleted
            // we do this by cloning the hdpa and tacking on our names.
            if (lpud->hdsa)
            {
                hdpaFull = DPA_Clone(hdpa, NULL);
                if (hdpaFull)
                {
                    int iMax;
                    int i;
                    LPFOUNDO_DELETEDFILEINFO lpdfi;
                    iMax = DSA_GetItemCount(lpud->hdsa);
                    for (i = 0; i < iMax; i++)
                    {
                        lpdfi = DSA_GetItemPtr(lpud->hdsa, i);
                        DPA_AppendPtr(hdpaFull, lpdfi->lpszName);
                        DPA_AppendPtr(hdpaFull, lpdfi->lpszName);
                    }
                }
                else
                {
                    hdpaFull = hdpa;
                }
            }
            lpszFile1 = DPA_ToQuotedFileList(hdpaFull, 0, DPA_GetPtrCount(hdpaFull), 2);
            StringCchPrintf(buffer, cchBuffer, szTemplate, lpszFile1); // ok to truncate, just a message
            LocalFree((HLOCAL)lpszFile1);
            if (hdpaFull != hdpa)
            {
                DPA_Destroy(hdpaFull);
            }
        }
    }
}


void CALLBACK FOUndo_Release(UNDOATOM *lpua)
{
    LPFOUNDODATA lpud = (LPFOUNDODATA)lpua->lpData;
    int i;
    LPTSTR lpsz;
    if (lpud && (lpud != (void *)-1))
    {
        HDPA hdpa = lpud->hdpa;
        HDSA hdsa = lpud->hdsa;
        if (hdpa)
        {
            i = DPA_GetPtrCount(hdpa) - 1;
            for (; i >= 0; i--)
            {
                lpsz = DPA_FastGetPtr(hdpa, i);
                Str_SetPtr(&lpsz, NULL);
            }
            DPA_Destroy(hdpa);
        }

        if (hdsa)
        {
            LPFOUNDO_DELETEDFILEINFO lpdfi;
            i = DSA_GetItemCount(hdsa) - 1;
            for (; i >= 0 ; i--)
            {
                lpdfi = DSA_GetItemPtr(hdsa, i);
                Str_SetPtr(&lpdfi->lpszName, NULL);
            }
            DSA_Destroy(hdsa);
        }
        LocalFree(lpud);
        lpua->lpData = (void *)-1;
    }
}

DWORD WINAPI FOUndo_InvokeThreadInit(UNDOATOM *lpua)
{
    LPFOUNDODATA lpud = (LPFOUNDODATA)lpua->lpData;
    HDPA hdpa = lpud->hdpa;
    HWND hwnd = lpua->hwnd;
    BOOL fNukeAtom = TRUE;
    SHFILEOPSTRUCT sFileOp =
    {
        hwnd,
        0,
        NULL,
        NULL,
        0,
    } ;
    int iMax;

    SuspendUndo(TRUE);
    iMax = DPA_GetPtrCount(hdpa);
    switch (lpua->uType)
    {
        case IDS_RENAME:
            {
                TCHAR szFromPath[MAX_PATH + 1];
                if (iMax < 2)
                    goto Exit;

                sFileOp.wFunc = FO_RENAME;
                sFileOp.pFrom = DPA_GetPtr(hdpa, 1);
                sFileOp.pTo = DPA_GetPtr(hdpa, 0);
                if (sFileOp.pFrom && sFileOp.pTo)
                {
                    HRESULT hr = StringCchCopy(szFromPath, ARRAYSIZE(szFromPath), sFileOp.pFrom);
                    if (SUCCEEDED(hr))
                    {
                        szFromPath[lstrlen(sFileOp.pFrom) + 1] = 0;
                        sFileOp.pFrom = szFromPath;
                        SHFileOperation(&sFileOp);
                        if (sFileOp.fAnyOperationsAborted)
                        {
                            fNukeAtom = FALSE;
                        }
                    }
                }
                // In the rename case the DPA owns these pointers, in all other cases
                // they must be freed below.  To prevent freeing these during a rename
                // we NULL them out when we're done with them
                sFileOp.pFrom = NULL;
                sFileOp.pTo = NULL;
            }
            break;

        case IDS_COPY:
            sFileOp.pFrom = DPA_ToFileList(hdpa, 1, iMax - 1, 2);
            if (!sFileOp.pFrom)
                goto Exit;
            sFileOp.wFunc = FO_DELETE;
            //
            // If this delete is occuring because of an automatic undo caused by
            // connected files, then do not ask for confirmation.
            //
            if (lpua->foFlags & FOF_NOCONFIRMATION)
                sFileOp.fFlags |= FOF_NOCONFIRMATION;

            SHFileOperation(&sFileOp);
            if (sFileOp.fAnyOperationsAborted)
            {
                fNukeAtom = FALSE;
            }
            break;

        case IDS_MOVE:
            sFileOp.pFrom = DPA_ToFileList(hdpa, 1, iMax-1, 2);
            sFileOp.pTo = DPA_ToFileList(hdpa, 0, iMax-2, 2);
            if (!sFileOp.pFrom || !sFileOp.pTo)
                goto Exit;
            sFileOp.wFunc = FO_MOVE;
            sFileOp.fFlags = FOF_MULTIDESTFILES;
            if (lpua->foFlags & FOF_NOCOPYSECURITYATTRIBS)
            {
                sFileOp.fFlags |= FOF_NOCOPYSECURITYATTRIBS;
            }
            SHFileOperation(&sFileOp);
            if (sFileOp.fAnyOperationsAborted)
            {
                fNukeAtom = FALSE;
            }
            break;

        case IDS_DELETE:
            {
                // first create any directories
                if (lpud->hdsa)
                {
                    HDSA hdsa = lpud->hdsa;
                    int i;
                    // do it in reverse order to get the parentage right
                    for (i = DSA_GetItemCount(hdsa) - 1; i >= 0; i--)
                    {
                        LPFOUNDO_DELETEDFILEINFO lpdfi = DSA_GetItemPtr(hdsa, i);
                        if (lpdfi)
                        {
                            if (Win32CreateDirectory(lpdfi->lpszName, NULL))
                            {
                                SetFileAttributes(lpdfi->lpszName, lpdfi->dwAttributes & ~FILE_ATTRIBUTE_DIRECTORY);
                            }
                        }
                    }
                }

                if (iMax)
                {
                    sFileOp.pFrom = DPA_ToFileList(hdpa, 1, iMax-1, 2);
                    sFileOp.pTo = DPA_ToFileList(hdpa, 0, iMax-2, 2);
                    if (!sFileOp.pFrom || !sFileOp.pTo)
                        goto Exit;
                    UndoBBFileDelete(sFileOp.pTo, sFileOp.pFrom);
                }
                break;
            }
    }
    SHChangeNotify(0, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, NULL, NULL);

Exit:
    if (sFileOp.pFrom)
        LocalFree((HLOCAL)sFileOp.pFrom);
    if (sFileOp.pTo)
        LocalFree((HLOCAL)sFileOp.pTo);

    SuspendUndo(FALSE);
    if (fNukeAtom)
        NukeUndoAtom(lpua);
    return 1;
}

void CALLBACK FOUndo_Invoke(UNDOATOM *lpua)
{
    DWORD idThread;
    HANDLE hthread = CreateThread(NULL, 0, FOUndo_InvokeThreadInit, lpua, 0, &idThread);
    if (hthread) 
        CloseHandle(hthread);
}

UNDOATOM *FOAllocUndoAtom(LPSHFILEOPSTRUCT lpfo)
{
    UNDOATOM *lpua = (UNDOATOM *)LocalAlloc(LPTR, sizeof(*lpua));
    if (lpua)
    {
        lpua->uType = FOFuncToStringID(lpfo->wFunc);
        lpua->GetText = FOUndo_GetText;
        lpua->Invoke = FOUndo_Invoke;
        lpua->Release = FOUndo_Release;
        lpua->foFlags = 0;

        if (lpfo->fFlags & FOF_NOCOPYSECURITYATTRIBS)
        {
            lpua->foFlags |= FOF_NOCOPYSECURITYATTRIBS;
        }
    }
    return lpua;
}

//============================================================================
//
// The following function is the mainline function for COPYing, RENAMEing,
// DELETEing, and MOVEing single or multiple files.
//
// in:
// hwnd         the parent to create the progress dialog from if FOF_CREATEPROGRESSDLG is set.
//
//
// wFunc        operation to be performed:
//              FO_DELETE - Delete files in pFrom (pTo unused)
//              FO_RENAME - Rename files
//              FO_MOVE   - Move files in pFrom to pTo
//              FO_COPY   - Copy files in pFrom to pTo
//
// pFrom        list of source file specs either qualified or
//              unqualified.  unqualified names will be qualified based on the current
//              global current directories.  examples include
//              "foo.txt bar.txt *.bak ..\*.old dir_name"
//
// pTo          destination file spec.
//
// fFlags       flags that control the operation
//
// returns:
//      0 indicates success
//      != 0 is the DE_ (dos error code) of last failed operation
//
//
//===========================================================================

int WINAPI SHFileOperation(LPSHFILEOPSTRUCT lpfo)
{
    int ret;
    BOOL bRecycledStuff = FALSE;
    COPY_STATE *pcs; 

    if (!lpfo || !lpfo->pFrom)
    {
        // return an error instead of waiting to AV
        return ERROR_INVALID_PARAMETER;
    }

    lpfo->fAnyOperationsAborted = FALSE;
    lpfo->hNameMappings = NULL;

    if (lpfo->wFunc < FO_MOVE || lpfo->wFunc > FO_RENAME)   // validate
    {
        // NOTE: We used to return 0 here (win95gold -> IE401). 
        //
        // If we run into app compat bugs because they were relying on the old 
        // buggy return value, then add an app hack here.
        // 
        // this is not a DE_ error, and I don't care!
        return ERROR_INVALID_PARAMETER;
    }

    pcs = (COPY_STATE*)LocalAlloc(LPTR, sizeof(COPY_STATE));
    if (!pcs)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pcs->nRef = 1;

    //
    //  REVIEW:  We want to allow copying of a file within a given directory
    //           by having default renaming on collisions within a directory.
    //
    if (!(lpfo->fFlags & FOF_NOCONFIRMATION))
    {
        pcs->cd.fConfirm =
            CONFIRM_DELETE_FILE         |
            CONFIRM_DELETE_FOLDER       |
            CONFIRM_REPLACE_FILE        |
            CONFIRM_REPLACE_FOLDER      |
            CONFIRM_WONT_RECYCLE_FILE   |
            CONFIRM_WONT_RECYCLE_FOLDER |
            CONFIRM_PATH_TOO_LONG       |
            //          CONFIRM_MOVE_FILE           |
            //          CONFIRM_MOVE_FOLDER         |
            //          CONFIRM_RENAME_FILE         |
            //          CONFIRM_RENAME_FOLDER       |
            CONFIRM_SYSTEM_FILE         |
            CONFIRM_READONLY_FILE       |
            CONFIRM_MULTIPLE            |
            CONFIRM_PROGRAM_FILE        |
            CONFIRM_STREAMLOSS          |
            CONFIRM_FAILED_ENCRYPT      |
            CONFIRM_LFNTOFAT            |
            CONFIRM_WONT_RECYCLE_OFFLINE |
            CONFIRM_LOST_ENCRYPT_FILE |
            CONFIRM_LOST_ENCRYPT_FOLDER;
    }

    if (lpfo->fFlags & FOF_WANTNUKEWARNING)
    {
        // We will warn the user that the thing they thought was going to be recycled is
        // now really going to be nuked. (eg drag-drop folder on recycle bin, but it turns
        // out that the folder is too big for the bitbucket, so we confirm on the wont-recycle
        // cases).
        // 
        // Also, we keep the system file / readonly file / progran file warnings around for good
        // measure.
        pcs->cd.fConfirm |= CONFIRM_WONT_RECYCLE_FILE   |
            CONFIRM_WONT_RECYCLE_FOLDER |
            CONFIRM_PATH_TOO_LONG       |
            CONFIRM_SYSTEM_FILE         |
            CONFIRM_READONLY_FILE       |
            CONFIRM_PROGRAM_FILE        |
            CONFIRM_WONT_RECYCLE_OFFLINE;
    }


    pcs->fFlags = lpfo->fFlags;   // duplicate some stuff here
    pcs->lpszProgressTitle = lpfo->lpszProgressTitle;
    pcs->lpfo = lpfo;

    // Check to see if we need to operate on the "connected" files and folders too!
    if (!(pcs->fFlags & FOF_NO_CONNECTED_ELEMENTS))
    {
        DWORD   dwFileFolderConnection = 0;
        DWORD   dwSize = sizeof(dwFileFolderConnection);
        DWORD   dwType = REG_DWORD;

        if (SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, 
                    REG_VALUE_NO_FILEFOLDER_CONNECTION, &dwType, &dwFileFolderConnection, 
                    &dwSize) == ERROR_SUCCESS)
        {
            //If the registry says "No connection", then set the flags accordingly.
            if (dwFileFolderConnection == 1)
            {
                pcs->fFlags = pcs->fFlags | FOF_NO_CONNECTED_ELEMENTS;
            }
        }
    }

    // Always create a progress dialog
    // Note that it will be created invisible, and will be shown if the
    // operation takes longer than a second to perform
    // Note the parent of this window is NULL so it will get the QUERYENDSESSION
    // message
    if (!(pcs->fFlags & FOF_SILENT))
    {
        SHCreateThread(FOUIThreadProc, pcs, 0, AddRefPCS);
    }
    else 
    {
        // To be compatible with Win95 semantics...
        if (!lpfo->hwnd)
        {
            pcs->fFlags |= FOF_NOERRORUI;
        }
    }

    if (lpfo->hwnd)
    {
        // The caller will be disabled if we ever show the progress window
        // We need to make sure this is not disabled now because if it is and
        // another dialog uses this as its parent, USER code will tell this
        // window it got the focus while it is still disabled, which keeps it
        // from passing that focus down to its children
        // EnableWindow(lpfo->hwnd, FALSE);
        pcs->hwndDlgParent = lpfo->hwnd;
    }

    // do this always.. even if this is not an undoable op, we could be
    // affecting something that is.
    SuspendUndo(TRUE);

    if (lpfo->fFlags & FOF_ALLOWUNDO)
    {
        pcs->lpua = FOAllocUndoAtom(lpfo);
        if (lpfo->wFunc == FO_DELETE)
        {
            // We check the shell state to see if the user has turned on the
            // "Don't confirm deleting recycle bin contents" flag.  If yes,
            // then we store this flag and check against it if this case occures.
            // Review: Not a super common case, why not just check when the
            // flag is actually needed?
            SHELLSTATE ss;
            SHGetSetSettings(&ss, SSF_NOCONFIRMRECYCLE, FALSE);
            pcs->fNoConfirmRecycle = ss.fNoConfirmRecycle;

            if (InitBBGlobals())
            {
                // since we are going to be recycling stuff, we add ourselves to the
                // global list of threads who are recycling
                SHGlobalCounterIncrement(g_hgcNumDeleters);
                bRecycledStuff = TRUE;
            }
            else
            {
                // this shouldnt happen, but if it does we can't send stuff to the Recycle
                // Bin, instead we remove the undo flag so that everything is really nuked.
                lpfo->fFlags &= ~FOF_ALLOWUNDO;
                LocalFree(pcs->lpua);
                pcs->lpua = NULL;
            }
        }

    }

    // While doing the file operation, tell PnP not to suspend
    // the machine.  Otherwise, you could be copying a lot of files
    // over the network and have the laptop suddenly hibernate on you
    // because PnP thought you were idle.
    //
    // Indicate that we only need the system.  It's okay if the display
    // goes into low-power mode, as long as we can keep copying.
    //

    SetThreadExecutionState(ES_CONTINUOUS | ES_SYSTEM_REQUIRED);

    ret = MoveCopyDriver(pcs);

    SetThreadExecutionState(ES_CONTINUOUS);

    if (pcs->bAbort)
    {
        ASSERT(pcs->lpfo == lpfo);
        lpfo->fAnyOperationsAborted = TRUE;
    }

    if (bRecycledStuff)
    {
        SHUpdateRecycleBinIcon();

        if (0 == SHGlobalCounterDecrement(g_hgcNumDeleters))
        {
            // We were the last guy who was deleting stuff. Thus, we need to
            // check to see if any of the bitbuckets info files neeed compacting or purging
            CheckCompactAndPurge();
        }
    }

    if (pcs->lpCopyBuffer)
    {
        LocalFree((HLOCAL)pcs->lpCopyBuffer);
        pcs->lpCopyBuffer = NULL;
    }

    if (pcs->lpua)
    {
        if (pcs->lpua->lpData && (pcs->lpua->lpData != (void *)-1))
        {
            AddUndoAtom(pcs->lpua);
        }
        else
        {
            FOUndo_Release(pcs->lpua);
            NukeUndoAtom(pcs->lpua);
        }
    }

    // NTRAID89119 (toddb): This code is totally busted in respect to mounted volumes.
    // We will send a change notify for the drive on which your volume is mounted
    // instead of on the volume which actually had a free space change.  We need
    // to update PathGetDriveNumber to handle mounted volumes

    // notify of freespace changes
    // rename doesn't change drive usage
    if (lpfo->wFunc != FO_RENAME)
    {
        int idDriveSrc;
        int idDriveDest = -1;
        DWORD dwDrives = 0; // bitfield for drives

        if (lpfo->wFunc == FO_COPY)
        {
            // nothing changes on the source
            idDriveSrc = -1;
        }
        else
        {
            idDriveSrc = PathGetDriveNumber(lpfo->pFrom);
        }

        if (lpfo->pTo)
        {
            idDriveDest = PathGetDriveNumber(lpfo->pTo);
        }

        if ((lpfo->wFunc == FO_MOVE) && (idDriveDest == idDriveSrc))
        {
            // no freespace nothing changes
            idDriveSrc = -1;
            idDriveDest = -1;
        }

        // NTRAID89119: What if idDriveSrc or idDriveDest are > 32?  This is totally
        // possible under NT by using mounted volumes.  SHChangeNotify is busted
        // in this respect.

        if (idDriveSrc != -1)
        {
            dwDrives |= (1 << idDriveSrc);
        }

        if (idDriveDest != -1)
        {
            dwDrives |= (1 << idDriveDest);
        }

        if (dwDrives)
        {
            SHChangeNotify(SHCNE_FREESPACE, SHCNF_DWORD, IntToPtr(dwDrives), 0);
        }
    }

    SuspendUndo(FALSE);

    if (!(lpfo->fFlags & FOF_WANTMAPPINGHANDLE))
    {
        SHFreeNameMappings(lpfo->hNameMappings);
        lpfo->hNameMappings = NULL;
    }

    // shut down the progress dialog
    //    
    // this is necessary so that the ui thread won't block
    pcs->fProgressOk = TRUE;

    ENTERCRITICAL;  // need to take critsec to sync w/ the UI thread
    pcs->fDone = TRUE;
    if (pcs->hwndProgress)
    {
        PostMessage(pcs->hwndProgress, PDM_NOOP, 0, 0);
    }
    LEAVECRITICAL;

    if (lpfo->hwnd)
    {
        EnableWindow(lpfo->hwnd, TRUE);
    }

    ReleasePCS(pcs);

    return ret;
}

#ifdef UNICODE
int WINAPI SHFileOperationA(LPSHFILEOPSTRUCTA lpfo)
{
    int iResult;
    UINT uTotalSize;
    UINT uSize;
    UINT uSizeTitle;
    UINT uSizeW;
    SHFILEOPSTRUCTW shop;
    LPCSTR lpAnsi;
    LPWSTR lpBuffer;
    LPWSTR lpTemp;

    COMPILETIME_ASSERT(sizeof(SHFILEOPSTRUCTW) == sizeof(SHFILEOPSTRUCTA));

    hmemcpy(&shop, lpfo, sizeof(SHFILEOPSTRUCTW));

    //
    // Thunk the strings as appropriate
    //
    uTotalSize = 0;
    if (lpfo->pFrom)
    {
        lpAnsi = lpfo->pFrom;
        do {
            uSize = lstrlenA(lpAnsi) + 1;
            uTotalSize += uSize;
            lpAnsi += uSize;
        } while (uSize != 1);
    }

    if (lpfo->pTo)
    {
        lpAnsi = lpfo->pTo;
        do {
            uSize = lstrlenA(lpAnsi) + 1;
            uTotalSize += uSize;
            lpAnsi += uSize;
        } while (uSize != 1);
    }

    if ((lpfo->fFlags & FOF_SIMPLEPROGRESS) && lpfo->lpszProgressTitle != NULL)
    {
        uSizeTitle = lstrlenA(lpfo->lpszProgressTitle) + 1;
        uTotalSize += uSizeTitle;
    }

    if (uTotalSize != 0)
    {
        lpTemp = lpBuffer = LocalAlloc(LPTR, uTotalSize*sizeof(WCHAR));
        if (!lpBuffer)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        lpBuffer = NULL;
    }

    //
    // Now convert the strings
    //
    if (lpfo->pFrom)
    {
        shop.pFrom = lpTemp;
        lpAnsi = lpfo->pFrom;
        do
        {
            uSize = lstrlenA(lpAnsi) + 1;
            uSizeW = MultiByteToWideChar(CP_ACP, 0,
                    lpAnsi, uSize,
                    lpTemp, uSize);
            lpAnsi += uSize;
            lpTemp += uSizeW;
        } while (uSize != 1);
    }
    else
    {
        shop.pFrom = NULL;
    }

    if (lpfo->pTo)
    {
        shop.pTo = lpTemp;
        lpAnsi = lpfo->pTo;
        do
        {
            uSize = lstrlenA(lpAnsi) + 1;
            uSizeW = MultiByteToWideChar(CP_ACP, 0,
                    lpAnsi, uSize,
                    lpTemp, uSize);
            lpAnsi += uSize;
            lpTemp += uSizeW;
        } while (uSize != 1);
    }
    else
    {
        shop.pTo = NULL;
    }


    if ((lpfo->fFlags & FOF_SIMPLEPROGRESS) && lpfo->lpszProgressTitle != NULL)
    {
        shop.lpszProgressTitle = lpTemp;
        MultiByteToWideChar(CP_ACP, 0,
                lpfo->lpszProgressTitle, uSizeTitle,
                lpTemp, uSizeTitle);
    }
    else
    {
        shop.lpszProgressTitle = NULL;
    }

    iResult = SHFileOperationW(&shop);

    // link up the two things in the SHFILEOPSTRUCT that could have changed
    lpfo->fAnyOperationsAborted = shop.fAnyOperationsAborted;
    lpfo->hNameMappings = shop.hNameMappings;

    if (lpBuffer)
        LocalFree(lpBuffer);

    return iResult;
}

#else

int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpfo)
{
    return E_NOTIMPL;   
}
#endif


// In:
//      pcs:  copy_state structure containing the state of the copy
//
// feedback: If the estimated time to copmplete a copy is larger than
//   MINTIME4FEEDBACK, the user is given a time to completion estimate in minutes.
//   The estimate is calculated using a MS_RUNAVG seconds running average.  The
//   initial estimate is done after MS_TIMESLICE

void SetProgressTime(COPY_STATE *pcs)
{
    DWORD dwNow = GetTickCount();

    if (pcs->dwPreviousTime)
    {

        int iPointsTotal = CountProgressPoints(pcs, &pcs->dth.dtAll);
        int iPointsDone = CountProgressPoints(pcs, &pcs->dth.dtDone);
        int iPointsDelta = iPointsDone - pcs->iLastProgressPoints;
        DWORD dwTimeLeft;

        //
        // A couple of times the shell has reported bad time remaining
        // we need to find out why.
        //
        ASSERT(iPointsTotal >= 0);
        ASSERT(iPointsDone >= 0);
        ASSERT(iPointsTotal >= iPointsDone);
        ASSERT(iPointsDelta >= 0);

        // has enough time elapsed to update the display
        // We do this every 10 seconds, but we'll do the first one after
        // only a few seconds

        if (iPointsDelta && (iPointsDone > 0) && (dwNow - pcs->dwPreviousTime))
        {
            DWORD dwPointsPerSec;
            DWORD dwTime; // how many tenths of a second have gone by

            // We take 10 times the number of Points and divide by the number of
            // tenths of a second to minimize both overflow and roundoff
            dwTime = (dwNow - pcs->dwPreviousTime)/100;
            if (dwTime == 0)
                dwTime = 1;
            dwPointsPerSec = iPointsDelta * 10 / dwTime;
            if (!dwPointsPerSec)
            {
                // This could happen if the net went to sleep for a couple
                // minutes while trying to copy a small (512 byte) buffer
                dwPointsPerSec = 1;
            }

            // if we didn't have enough time to get a good sample,
            // don't use this last bit as a time estimater
            if ((dwNow - pcs->dwPreviousTime) < (MS_TIMESLICE/2))
            {
                dwPointsPerSec = pcs->dwPointsPerSec;
            }

            if (pcs->dwPointsPerSec)
            {
                // Take a weighted average of the current transfer rate and the
                // previously computed one, just to try to smooth out
                // some random fluctuations

                dwPointsPerSec = (dwPointsPerSec + (pcs->dwPointsPerSec * 2)) / 3;
            }

            // never allow 0 points per second.. just tack it on to next time
            if (dwPointsPerSec)
            {
                pcs->dwPointsPerSec = dwPointsPerSec;

                // Calculate time remaining (round up by adding 1)
                // We only get here every 10 seconds, so always update
                dwTimeLeft = ((iPointsTotal - iPointsDone) / dwPointsPerSec) + 1;

                // It would be odd to show "1 second left" and then immediately
                // clear it
                if (dwTimeLeft >= MIN_MINTIME4FEEDBACK)
                {
                    // display new estimate of time left
                    SetProgressTimeEst(pcs, dwTimeLeft);
                }
            }

        }
        // Reset previous time and # of Points read
        pcs->dwPreviousTime = dwNow;
        pcs->iLastProgressPoints = iPointsDone;
    }
}

void InitClipConfirmDlg(HWND hDlg, CONFDLG_DATA *pcd)
{
    TCHAR szMessage[255];
    TCHAR szDeleteWarning[80];
    SHFILEINFO sfiDest;
    LPTSTR pszFileDest = NULL;
    LPTSTR pszMsg, pszSource;
    int i;
    int cxWidth;
    RECT rc;

    // get the size of the text boxes
    GetWindowRect(GetDlgItem(hDlg, pcd->idText), &rc);
    cxWidth = rc.right - rc.left;

    // get the source display name
    pszSource = PathFindFileName(pcd->pFileSource);
    PathCompactPath(NULL, pszSource, cxWidth);

    // get the dest display name
    SHGetFileInfo(pcd->pFileDest, 0,
            &sfiDest, sizeof(sfiDest), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES);
    pszFileDest = sfiDest.szDisplayName;
    PathCompactPath(NULL, pszFileDest, cxWidth);

    // if we're supposed to show the date info, grab the icons and format the date string
    if (pcd->bShowDates) 
    {
        SHFILEINFO sfi2;
        TCHAR szDateSrc[64], szDateDest[64];

        // likely that this data may be incomplete... leave it saying "Unknown date and size"
        if (BuildDateLine(szDateSrc, ARRAYSIZE(szDateSrc), pcd->pfdSource, pcd->pFileSource))
            SetDlgItemText(hDlg, IDD_FILEINFO_NEW,  szDateSrc);
        
        BuildDateLine(szDateDest, ARRAYSIZE(szDateSrc), pcd->pfdDest, pcd->pFileDest);
        SetDlgItemText(hDlg, IDD_FILEINFO_OLD,  szDateDest);

        SHGetFileInfo(pcd->pFileSource, pcd->pfdSource ? pcd->pfdSource->dwFileAttributes : 0, &sfi2, sizeof(sfi2),
                pcd->pfdSource ? (SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_LARGEICON) : (SHGFI_ICON|SHGFI_LARGEICON));
        ReplaceDlgIcon(hDlg, IDD_ICON_NEW, sfi2.hIcon);

        SHGetFileInfo(pcd->pFileDest, pcd->pfdDest ? pcd->pfdDest->dwFileAttributes : 0, &sfi2, sizeof(sfi2),
                pcd->pfdDest ? (SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_LARGEICON) : (SHGFI_ICON|SHGFI_LARGEICON));
        ReplaceDlgIcon(hDlg, IDD_ICON_OLD, sfi2.hIcon);
    }

    // there are 5 controls:
    // IDD_TEXT contains regular text (normal file/folder)
    // IDD_TEXT1 through IDD_TEXT4 contain optional secondary text
    for (i = IDD_TEXT; i <= IDD_TEXT4; i++)
    {
        if (i == pcd->idText)
        {
            szMessage[0] = 0;
            GetDlgItemText(hDlg, i, szMessage, ARRAYSIZE(szMessage));
        }
        else
        {
            HWND hwndCtl = GetDlgItem(hDlg, i);
            if (hwndCtl)
            {
                ShowWindow(hwndCtl, SW_HIDE);
            }
        }
    }

    szDeleteWarning[0] = 0;

    pszMsg = ShellConstructMessageString(HINST_THISDLL, szMessage,
            pszSource, pszFileDest, szDeleteWarning);

    if (pszMsg)
    {
        SetDlgItemText(hDlg, pcd->idText, pszMsg);
        LocalFree(pszMsg);
    }
}

HRESULT FileDescToWin32FileData(LPFILEDESCRIPTOR pfdsc, LPWIN32_FIND_DATA pwfd)
{
    ZeroMemory(pwfd, sizeof(*pwfd));

    if (pfdsc->dwFlags & FD_ATTRIBUTES)
        pwfd->dwFileAttributes = pfdsc->dwFileAttributes;
    if (pfdsc->dwFlags & FD_CREATETIME)
        hmemcpy(&pwfd->ftCreationTime, &pfdsc->ftCreationTime, sizeof(FILETIME));
    if (pfdsc->dwFlags & FD_ACCESSTIME)
        hmemcpy(&pwfd->ftLastAccessTime, &pfdsc->ftLastAccessTime, sizeof(FILETIME));
    if (pfdsc->dwFlags & FD_WRITESTIME)
        hmemcpy(&pwfd->ftLastWriteTime, &pfdsc->ftLastWriteTime, sizeof(FILETIME));
    if (pfdsc->dwFlags & FD_FILESIZE)
    {
        pwfd->nFileSizeHigh = pfdsc->nFileSizeHigh;
        pwfd->nFileSizeLow = pfdsc->nFileSizeLow;
    }
    return StringCchCopy(pwfd->cFileName, ARRAYSIZE(pwfd->cFileName), pfdsc->cFileName);
}

INT_PTR ValidateCreateFileFromClip(HWND hwnd, LPFILEDESCRIPTOR pfdscSrc, TCHAR *pszPathDest, PYNLIST pynl)
{
    WIN32_FIND_DATA wfdSrc, wfdDest;
    CONFDLG_DATA cdd;
    CONFIRM_DATA cd;
    COPY_STATE cs;
    INT_PTR result;
    HRESULT hr;

    //
    // If the destination does not exist, we are done.
    //
    HANDLE hff = FindFirstFile(pszPathDest, &wfdDest);
    if (hff == INVALID_HANDLE_VALUE)
    {
        return IDYES;
    }
    FindClose(hff);

    //
    // Maybe this was just a short name collision and
    // we can quickly get out of here.
    //
    if (ResolveShortNameCollisions(pszPathDest, &wfdDest))
    {
        return IDYES;
    }

    //
    // Most of the helper functions want a WIN32_FILE_DATA
    // and not a FILEDESCRIPTOR, so we create wfd for the
    // source file on the fly.
    //
    hr = FileDescToWin32FileData(pfdscSrc, &wfdSrc);
    if (FAILED(hr))
    {
        return IDNO;
    }

    //
    // Take care of the easy cases - can't copy a file to a dir
    // or a dir to a file.
    //
    if ((wfdDest.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            ((wfdSrc.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
    {
        ZeroMemory(&cs, sizeof(cs));
        cs.hwndDlgParent = hwnd;

        CopyError(&cs, wfdSrc.cFileName, pszPathDest, DE_FILEDESTISFLD | ERRORONDEST, FO_COPY, OPER_DOFILE);
        return IDNO;
    }
    else if (((wfdDest.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
            (wfdSrc.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        ZeroMemory(&cs, sizeof(cs));
        cs.hwndDlgParent = hwnd;

        CopyError(&cs, wfdSrc.cFileName, pszPathDest, DE_FLDDESTISFILE | ERRORONDEST, FO_COPY, OPER_DOFILE);

        AddToNoList(pynl, pszPathDest);

        return IDNO;
    }

    //
    // We need a confirmation dialog.  Fill in the
    // ConfirmDialogData (cdd) here.
    //

    ZeroMemory(&cdd, sizeof(cdd));

    cdd.InitConfirmDlg = InitClipConfirmDlg;
    cdd.idText = IDD_TEXT;
    cdd.pFileSource = pfdscSrc->cFileName;
    cdd.pfdSource = &wfdSrc;
    cdd.pFileDest = pszPathDest;
    cdd.pfdDest = &wfdDest;
    cdd.bShowDates = FALSE;
    cdd.pcd = &cd;

    ZeroMemory(&cd, sizeof(cd));
    cd.fConfirm = CONFIRM_REPLACE_FILE;
    cdd.fYesToAllMask = CONFIRM_REPLACE_FILE;

    if (((wfdDest.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
            (wfdDest.dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)))
    {
        if (wfdDest.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
        {
            cdd.idText = IDD_TEXT2;
        }
        else if (wfdDest.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
        {
            cdd.idText = IDD_TEXT1;
        }
    }

    //
    // What we do now depends on whether we are processing a directory
    // or a file.
    //
    if (wfdDest.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        //
        // If this directory is already in the yes list,
        // the parent directory must have already conflicted
        // and the user said "yes, move the dir contents over".
        //
        if (IsInYesList(pynl, pszPathDest))
        {
            result = IDYES;
        }
        else
        {
            //
            // Copying directory to a destination with the same directory.
            //
            result = DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_REPLACE_FOLDER), hwnd, ConfirmDlgProc, (LPARAM)&cdd);

            if (result == IDYES)
            {
                if (cd.fConfirm & CONFIRM_REPLACE_FILE)
                {
                    AddToYesList(pynl, pszPathDest);
                }
                else
                {
                    SetYesToAll(pynl);
                }
            }
            else if (result == IDNO)
            {
                AddToNoList(pynl, pszPathDest);
            }
        }
    }
    else
    {
        if (IsInYesList(pynl, pszPathDest))
        {
            result = IDYES;
        }
        else
        {
            //
            // Copying a file to a destination with the same file.
            //
            cdd.bShowDates = TRUE;

            result = DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_REPLACE_FILE), hwnd, ConfirmDlgProc, (LPARAM)&cdd);

            if (result == IDYES)
            {
                if ((cd.fConfirm & CONFIRM_REPLACE_FILE) == 0)
                {
                    SetYesToAll(pynl);
                }
            }
        }
    }

    return result;
}


// We can get transient file locks for moving files, for example extracting a thumbnail on a background task
// so we wrap our single check in a loop of multiple checks with a short nap between.  We'd expect
// to get the ERROR_SHARING_VIOLATION, but in practice we also say ERROR_ACCESS_DENIED, so we'll try that
// as well

#define MAX_DELETE_ATTEMPTS  5
#define SLEEP_DELETE_ATTEMPT 1000

BOOL _IsFileDeletable(LPCTSTR pszFile)
{
    int iAttempt = 0;
    BOOL bRet;
    while (!(bRet = IsFileDeletable(pszFile)) && (iAttempt < MAX_DELETE_ATTEMPTS))
    {
        DWORD dwError = GetLastError();

        if ((dwError == ERROR_ACCESS_DENIED) || (dwError == ERROR_SHARING_VIOLATION))
        {
            iAttempt++;
            Sleep(SLEEP_DELETE_ATTEMPT);
        }
        else
        {
            break;
        }
    }

    return (bRet);
}

BOOL _IsDirectoryDeletable(LPCTSTR pszDir)
{
    int iAttempt = 0;
    BOOL bRet;
    while (!(bRet = IsDirectoryDeletable(pszDir)) && (iAttempt < MAX_DELETE_ATTEMPTS))
    {
        DWORD dwError = GetLastError();

        if ((dwError == ERROR_ACCESS_DENIED) || (dwError == ERROR_SHARING_VIOLATION))
        {
            iAttempt++;
            Sleep(SLEEP_DELETE_ATTEMPT);
        }
        else
        {
            break;
        }
    }

    return (bRet);
}

// This function adds up the sizes of the files in pszDir, and
// also makes sure that all those files are "delete-able"
//
// return:  ERROR_SUCCESS - everything is fine, all the files in the dir are deleteable
//          else          - the dir cant be deleted because something inside is non-deletable
//
// NOTE: other in-out params are in the pfdi
//
LONG CheckFolderSizeAndDeleteability(FOLDERDELETEINFO* pfdi, LPCOPY_STATE pcs)
{
    LONG lRet = ERROR_SUCCESS;  // keep stack to a minimum as this is a recursive function!
    BOOL bHasChildren = FALSE;

    if (FOQueryAbort(pcs))
        return ERROR_CANCELLED;

    // do the root specific processing
    if (!pfdi->bProcessedRoot)
    {
        // since the the destination folder could be something like "DC100000.oldext", calculate how many characters are
        // going to be in the new destination directory: "C:\recycler\sid" + "\" + "DC100000.oldext" == the new root directory length
        pfdi->cchDelta = (pfdi->cchBBDir + 1 + 8 + 1 + lstrlen(PathFindExtension(pfdi->szDir))) - lstrlen(pfdi->szDir);

        // set this so that we only do the above processing for the root folder
        pfdi->bProcessedRoot = TRUE;
    }

    if (PathCombine(pfdi->szPath, pfdi->szDir, c_szStarDotStar))
    {
        HANDLE hfind = FindFirstFile(pfdi->szPath, &pfdi->fd);
        if (hfind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (!PathIsDotOrDotDot(pfdi->fd.cFileName))
                {
                    bHasChildren = TRUE;

                    // append the subfile/subfolder to the parent path
                    if (!PathCombine(pfdi->szPath, pfdi->szDir, pfdi->fd.cFileName))
                    {
                        // PathAppend failed, try to append the short name
                        if (!pfdi->fd.cAlternateFileName[0] || !PathCombine(pfdi->szPath, pfdi->szDir, pfdi->fd.cAlternateFileName))
                        {
                            // no alternate name or we failed to append that as well, assume we failed because the path is too long
                            lRet = ERROR_FILENAME_EXCED_RANGE;

                            // pass back the name of the non-deleteable file/folder in pfdi->szNonDeletableFile
                            StringCchCopy(pfdi->szNonDeletableFile, ARRAYSIZE(pfdi->szNonDeletableFile), pfdi->szPath); // truncation ok
                        }
                    }

                    if (lRet == ERROR_SUCCESS)
                    {
                        // we have to check to see if the path will exceed MAX_PATH if we were to move this file to the recycle
                        // bin (C:\Recycler\<sid>). the increase in path length due to the recycle bin dir could be enough to 
                        // put us over MAX_PATH and we would have problems later.
                        if ((lstrlen(pfdi->szPath) + pfdi->cchDelta + 1) > MAX_PATH) // +1 for NULL
                        {
                            TraceMsg(TF_BITBUCKET, "CheckFolderSizeAndDeleteability: path '%s' would exceed MAX_PATH if moved to the recycle bin!", pfdi->szPath);
                            lRet = ERROR_FILENAME_EXCED_RANGE;

                            // pass back the name of the non-deleteable file/folder in pfdi->szNonDeletableFile
                            StringCchCopy(pfdi->szNonDeletableFile, ARRAYSIZE(pfdi->szNonDeletableFile), pfdi->szPath); // truncation ok
                        }
                        else
                        {
                            if (pfdi->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                            {
                                HRESULT hr = StringCchCopy(pfdi->szDir, ARRAYSIZE(pfdi->szDir), pfdi->szPath);
                                if (SUCCEEDED(hr))
                                {
                                    // its a directory, so recurse
                                    lRet = CheckFolderSizeAndDeleteability(pfdi, pcs);
                                    PathRemoveFileSpec(pfdi->szDir);
                                }
                                else
                                {
                                    lRet = ERROR_FILENAME_EXCED_RANGE;
                                    StringCchCopy(pfdi->szNonDeletableFile, ARRAYSIZE(pfdi->szNonDeletableFile), pfdi->szPath); // truncation ok
                                }
                            }
                            else 
                            {
                                // its a file.
                                ULARGE_INTEGER ulTemp;

                                if (!_IsFileDeletable(pfdi->szPath))
                                {
                                    // we cant delete this file, find out why
                                    lRet = GetLastError();
                                    ASSERT(lRet != ERROR_SUCCESS);

                                    // pass back the name of the non-deleteable file in pfdi->szNonDeletableFile
                                    StringCchCopy(pfdi->szNonDeletableFile, ARRAYSIZE(pfdi->szNonDeletableFile), pfdi->szPath); // truncation ok
                                }

                                ulTemp.LowPart  = pfdi->fd.nFileSizeLow;
                                ulTemp.HighPart = pfdi->fd.nFileSizeHigh;
                                pfdi->cbSize += ulTemp.QuadPart;
                            }
                        }
                    }
                }

            } while ((lRet == ERROR_SUCCESS) && FindNextFile(hfind, &pfdi->fd));

            FindClose(hfind);

            // if this dir has no children, see if we can simply delete it
            if (!bHasChildren && !_IsDirectoryDeletable(pfdi->szDir))
            {
                lRet = GetLastError();
                ASSERT(lRet != ERROR_SUCCESS);

                // pass back the name of the non-deleteable file in pfdi->szNonDeletableFile
                StringCchCopy(pfdi->szNonDeletableFile, ARRAYSIZE(pfdi->szNonDeletableFile), pfdi->szDir); // truncation ok
            }
        }
        else
        {
            // if FindFirstFile fails, check to see if the directory itself is deleteable
            if (!_IsDirectoryDeletable(pfdi->szDir))
            {
                lRet = GetLastError();
                ASSERT(lRet != ERROR_SUCCESS);

                // pass back the name of the non-deleteable file in pfdi->szNonDeletableFile
                StringCchCopy(pfdi->szNonDeletableFile, ARRAYSIZE(pfdi->szNonDeletableFile), pfdi->szDir); // truncation ok
            }
        }
    }
    else
    {
        // if PathCombine fails, assume its because the path is too long
        lRet = ERROR_FILENAME_EXCED_RANGE;

        // pass back the name of the non-deleteable file in pfdi->szNonDeletableFile
        StringCchCopy(pfdi->szNonDeletableFile, ARRAYSIZE(pfdi->szNonDeletableFile), pfdi->szDir); // truncation ok
    }

    return lRet;
}

// This takes over for what BBDeleteFile used to do (init, check, delete)... but does it with the ability to cancel
BOOL DeleteFileBB(LPTSTR pszFile, UINT cchFile, INT *piRet, COPY_STATE *pcs, BOOL fIsDir, WIN32_FIND_DATA *pfd, HDPA *phdpaDeletedFiles)
{
    ULARGE_INTEGER ulSize;
    int idDrive = DriveIDFromBBPath(pszFile);

    // Init
    if (!BBDeleteFileInit(pszFile, piRet))
        return FALSE;

    // Check if we can delete this properly
    if (fIsDir) 
    {
        DWORD dwError;
        HRESULT hr;
        FOLDERDELETEINFO fdi = {0};

        fdi.cchBBDir = BBRecyclePathLength(idDrive);

        hr = StringCchCopy(fdi.szDir, ARRAYSIZE(fdi.szDir), pszFile);
        if (FAILED(hr))
        {
            *piRet = BBDELETE_PATH_TOO_LONG;
            return FALSE;
        }

        dwError = CheckFolderSizeAndDeleteability(&fdi, pcs);

        if (dwError != ERROR_SUCCESS) 
        {
            // if CheckFolderSizeAndDeleteability can fail if a file cant be recycled.
            // In this case, it appends the name of the file to pszFile, so we know who 
            // the undeletable file is. 
            if ((dwError == ERROR_FILENAME_EXCED_RANGE) ||
                    (dwError == ERROR_BUFFER_OVERFLOW))
            {
                // it failed because a new path would be to long after being moveed under the "C:\recycler\sid" directory
                *piRet = BBDELETE_PATH_TOO_LONG;
            }
            else if (dwError == ERROR_CANCELLED)
            {
                // user hit the cancel button
                *piRet = BBDELETE_CANCELLED;
            }
            else
            {
                // must be a non-deletable directory, so set piRet = BBDELETE_CANNOT_DELETE so our caller
                // can detect this case, also pass the name of the non-deletable file back out so we can give
                // a better error message to the user
                *piRet = BBDELETE_CANNOT_DELETE;
                ASSERT(*fdi.szPath);
                StringCchCopy(pszFile, cchFile, fdi.szNonDeletableFile); // truncation ok
            }

            TraceMsg(TF_BITBUCKET, "DeleteFileBB : early error (%x) on file (%s)", dwError, pszFile);
            return FALSE;
        }

        ulSize.QuadPart = fdi.cbSize;
    }
    else 
    {
        if (!_IsFileDeletable(pszFile))
        {
            // We set piRet = BBDELETE_CANNOT_DELETE so our caller can detect
            // that this file cant be recycled.
            *piRet = BBDELETE_CANNOT_DELETE;
            return FALSE;
        }

        ulSize.LowPart  = pfd->nFileSizeLow;
        ulSize.HighPart = pfd->nFileSizeHigh;
    }

    // check to make sure it's not bigger than the allowed wastebasket..
    if (!BBCheckDeleteFileSize(idDrive, ulSize)) 
    {
        // we set piRet = BBDELETE_SIZE_TOO_BIG so our caller can 
        // detect the "file/folder too big" case
        *piRet = BBDELETE_SIZE_TOO_BIG;

        return FALSE;
    }

    return BBDeleteFile(pszFile, piRet, pcs->lpua, fIsDir, phdpaDeletedFiles, ulSize);
}

void StartCopyEngine(HANDLE *phEventRunning)
{
    SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();       
    if (psa)
    {
        *phEventRunning = CreateEvent(psa, TRUE, FALSE, L"ShellCopyEngineRunning");
        if (*phEventRunning)
        {
            SetEvent(*phEventRunning);
        }
    }
}

void EndCopyEngine(HANDLE hEventRunning)
{
    // signal that we're done.  this will always trigger so there will be some weirdness if the
    // user does simultaneous copies, but it's not worth making a semaphore to keep track.
    SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();       
    if (psa)
    {
        HANDLE hEventFinished = CreateEvent(psa, TRUE, FALSE, L"ShellCopyEngineFinished");
        if (hEventFinished)
        {
            SetEvent(hEventFinished);
            CloseHandle(hEventFinished);
        }
    }

    if (hEventRunning)
    {
        // close out the event that says we're running.
        ResetEvent(hEventRunning);
        CloseHandle(hEventRunning);
    }
}

BOOL IsCopyEngineRunning()
{
    BOOL bRet=FALSE;
    SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();       
    if (psa)
    {
        HANDLE hEventCopyRunning = OpenEvent(SYNCHRONIZE, FALSE, L"ShellCopyEngineRunning");
        if (hEventCopyRunning)
        {
            // probe the event with a wait, if it times out the copy engine isn't running so we're done.
            bRet = (WAIT_OBJECT_0 == WaitForSingleObject(hEventCopyRunning, 0));
            CloseHandle(hEventCopyRunning);
        }
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\control1.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "control.h"

HDSA g_hacplmLoaded = NULL;

void ConvertCplInfo(void * lpv)
{
   NEWCPLINFOA   CplInfoA;
   LPNEWCPLINFOW lpCplInfoW = (LPNEWCPLINFOW)lpv;

   memcpy(&CplInfoA, lpv, sizeof(CplInfoA));

   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                        CplInfoA.szName, ARRAYSIZE(CplInfoA.szName),
                        lpCplInfoW->szName, ARRAYSIZE(lpCplInfoW->szName));
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                        CplInfoA.szInfo, ARRAYSIZE(CplInfoA.szInfo),
                        lpCplInfoW->szInfo, ARRAYSIZE(lpCplInfoW->szInfo));
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                        CplInfoA.szHelpFile, ARRAYSIZE(CplInfoA.szHelpFile),
                        lpCplInfoW->szHelpFile, ARRAYSIZE(lpCplInfoW->szHelpFile));
   lpCplInfoW->dwSize = sizeof(NEWCPLINFOW);
}

//  See if pszShort is a truncated version of the string referred to by
//  hinst/id.  If so, then use the long string.  This is to work around
//  a "bad design feature" of CPL_NEWINQUIRE where the app returns a buffer
//  (which is only 32 or 64 chars long) rather than a resource id
//  like CPL_INQUIRE.  So if the app responds to both messages, and the
//  NEWINQUIRE string is a truncated version of the INQUIRE string, then
//  switch to the INQUIRE string.

LPTSTR _RestoreTruncatedCplString(
        HINSTANCE hinst,
        int id,
        LPTSTR pszShort,
        LPTSTR pszBuf,
        int cchBufMax)
{
    int cchLenShort, cchLen;

    cchLenShort = lstrlen(pszShort);
    cchLen = LoadString(hinst, id, pszBuf, cchBufMax);

    // Don't use SHTruncateString since KERNEL32 doesn't either
    if (StrCmpNC(pszShort, pszBuf, cchLenShort) == 0)
    {
        pszShort = pszBuf;
    }
    return pszShort;
}

//
//  Initializes *pcpli.
//
// Requires:
//  *pcpli is filled with 0 & NULL's.
//
BOOL _InitializeControl(LPCPLMODULE pcplm, LPCPLITEM pcpli)
{
    BOOL fSucceed = TRUE;
    union {
        NEWCPLINFO  Native;
        NEWCPLINFOA NewCplInfoA;
        NEWCPLINFOW NewCplInfoW;
    } Newcpl;
    CPLINFO cpl;
    TCHAR szName[MAX_CCH_CPLNAME];
    TCHAR szInfo[MAX_CCH_CPLINFO];
    LPTSTR pszName = Newcpl.Native.szName, pszInfo = Newcpl.Native.szInfo;
    HICON hIconTemp = NULL;

    //
    // always do the old method to get the icon ID
    //
    cpl.idIcon = 0;

    CPL_CallEntry(pcplm, NULL, CPL_INQUIRE, (LONG)pcpli->idControl, (LONG_PTR)(LPCPLINFO)&cpl);

    //
    // if this is a 32bit CPL and it gave us an ID then validate it
    // this fixes ODBC32 which gives back a bogus ID but a correct HICON
    // note that the next load of the same icon should be very fast
    //
    if (cpl.idIcon)
    {
        hIconTemp = LoadImage(pcplm->minst.hinst, MAKEINTRESOURCE(cpl.idIcon),
            IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);

        if (!hIconTemp)
        {
            // the id was bogus, make it a negative number (invalid resource)...
            cpl.idIcon = -1;
            TraceMsg(TF_GENERAL, "_InitializaControl: %s returned an invalid icon id, ignoring", pcplm->szModule);
        }
    }

    pcpli->idIcon = cpl.idIcon;

    //
    //  Try the new method first and call it with the largest structure
    //  so it doesn't overwrite anything on the stack.  If you put a
    //  Unicode applet on Windows '95 it will kill the Explorer because
    //  it trashes memory by overwriting the stack.
    //
    memset(&Newcpl,0,sizeof(Newcpl));

    CPL_CallEntry(pcplm, NULL, CPL_NEWINQUIRE, (LONG)pcpli->idControl,
                    (LONG_PTR)(LPCPLINFO)&Newcpl);

    //
    //  If the call is to an ANSI applet, convert strings to Unicode
    //
    // I'm leaving this ANSI-only code as it helps explain
    // the way some of the subsequent code works - or why it was
    // written the way it was. [brianau - 03/07/02]
    //
#ifdef UNICODE
#define UNNATIVE_SIZE   sizeof(NEWCPLINFOA)
#else
#define UNNATIVE_SIZE   sizeof(NEWCPLINFOW)
#endif

    if (Newcpl.Native.dwSize == UNNATIVE_SIZE)
    {
        ConvertCplInfo(&Newcpl);        // This will set Newcpl.Native.dwSize
    }

    if (Newcpl.Native.dwSize == sizeof(NEWCPLINFO))
    {
       pszName = _RestoreTruncatedCplString(pcplm->minst.hinst, cpl.idName, pszName, szName, ARRAYSIZE(szName));
       pszInfo = _RestoreTruncatedCplString(pcplm->minst.hinst, cpl.idInfo, pszInfo, szInfo, ARRAYSIZE(szInfo));
    }
    else
    {
        Newcpl.Native.hIcon = LoadImage(pcplm->minst.hinst, MAKEINTRESOURCE(cpl.idIcon), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
        pszName = szName;
        LoadString(pcplm->minst.hinst, cpl.idName, szName, ARRAYSIZE(szName));
        pszInfo = szInfo;
        LoadString(pcplm->minst.hinst, cpl.idInfo, szInfo, ARRAYSIZE(szInfo));
        Newcpl.Native.szHelpFile[0] = 0;
        Newcpl.Native.lData = cpl.lData;
        Newcpl.Native.dwHelpContext = 0;
    }

    pcpli->hIcon = Newcpl.Native.hIcon;

    if (hIconTemp)
        DestroyIcon(hIconTemp);

    fSucceed = Str_SetPtr(&pcpli->pszName, pszName)
            && Str_SetPtr(&pcpli->pszInfo, pszInfo)
            && Str_SetPtr(&pcpli->pszHelpFile, Newcpl.Native.szHelpFile);

    pcpli->lData = Newcpl.Native.lData;
    pcpli->dwContext = Newcpl.Native.dwHelpContext;

#ifdef DEBUG
    if (!pcpli->idIcon)
        TraceMsg(TF_GENERAL, "PERFORMANCE: cannot cache %s because no icon ID for <%s>", pcplm->szModule, pcpli->pszName);
#endif

    return fSucceed;
}


//
// Terminate the control
//
void _TerminateControl(LPCPLMODULE pcplm, LPCPLITEM pcpli)
{
    if (pcpli->hIcon)
    {
        DestroyIcon(pcpli->hIcon);
        pcpli->hIcon = NULL;
    }

    Str_SetPtr(&pcpli->pszName, NULL);
    Str_SetPtr(&pcpli->pszInfo, NULL);
    Str_SetPtr(&pcpli->pszHelpFile, NULL);
    CPL_CallEntry(pcplm, NULL, CPL_STOP, pcpli->idControl, pcpli->lData);
}


void _FreeLibraryForControlPanel(MINST *pminst)
{
    FreeLibrary(pminst->hinst);
}

//
//  For each control of the specified CPL module, call the control entry
//  with CPL_STOP. Then, call it with CPL_EXIT.
//
void _TerminateCPLModule(LPCPLMODULE pcplm)
{
    if (pcplm->minst.hinst)
    {
        ULONG_PTR dwCookie = 0;

        if (pcplm->lpfnCPL)
        {
            if (pcplm->hacpli)
            {
                int cControls, i;

                for (i = 0, cControls = DSA_GetItemCount(pcplm->hacpli); i < cControls; ++i)
                {
                    LPCPLITEM pcpli = DSA_GetItemPtr(pcplm->hacpli, i);
                    _TerminateControl(pcplm, pcpli);
                }

                DSA_DeleteAllItems(pcplm->hacpli);
                DSA_Destroy(pcplm->hacpli);
                pcplm->hacpli=NULL;
            }

            CPL_CallEntry(pcplm, NULL, CPL_EXIT, 0, 0);
            pcplm->lpfnCPL=NULL;
        }

        ActivateActCtx(pcplm->hActCtx, &dwCookie);
        _FreeLibraryForControlPanel(&pcplm->minst);
        if (dwCookie != 0)
            DeactivateActCtx(0, dwCookie);

        pcplm->minst.hinst = NULL;
    }

    pcplm->minst.idOwner = (DWORD)-1;

    if (pcplm->hActCtx != NULL)
    {
        ReleaseActCtx(pcplm->hActCtx);
        pcplm->hActCtx = NULL;
    }

    if (pcplm->minst.hOwner)
    {
        CloseHandle(pcplm->minst.hOwner);
        pcplm->minst.hOwner = NULL;
    }
}


//
// Initializes the CPL Module.
//
// Requires:
//  *pcplm should be initialized appropriately.
//
//
BOOL _InitializeCPLModule(LPCPLMODULE pcplm)
{
    BOOL fSuccess = FALSE;

    pcplm->lpfnCPL32 = (APPLET_PROC)GetProcAddress(pcplm->minst.hinst, "CPlApplet");

    //
    // Initialize the CPL
    if (pcplm->lpfnCPL &&
        CPL_CallEntry(pcplm, NULL, CPL_INIT, 0, 0))
    {
        int cControls = (int)CPL_CallEntry(pcplm, NULL, CPL_GETCOUNT, 0, 0);

        if (cControls>0)
        {
            //
            // By passing in the number of applets, we should speed up allocation
            // of this array.
            //

            pcplm->hacpli = DSA_Create(sizeof(CPLITEM), cControls);

            if (pcplm->hacpli)
            {
                int i;

                fSuccess = TRUE; // succeded, so far.

                // Go through the applets and load the information about them

                for (i = 0; i < cControls; ++i)
                {
                    CPLITEM control = {i, 0};

                    if (_InitializeControl(pcplm, &control))
                    {
                        // removing this now saves us from doing it later

                        CPL_StripAmpersand(control.pszName);

                        if (DSA_AppendItem(pcplm->hacpli, &control) >= 0)
                        {
                            continue;
                        }
                    }

                    _TerminateControl(pcplm, &control);
                    fSuccess=FALSE;
                    break;
                }
            }
        }
    }
    else
    {
        // don't ever call it again if we couldn't CPL_INIT
        pcplm->lpfnCPL = NULL;
    }

    return fSuccess;
}


//
// Returns:
//   The index to the g_hacplmLoaded, if the specified DLL is already
//  loaded; -1 otherwise.
//
int _FindCPLModule(const MINST * pminst)
{
    int i = -1; // Assumes error

    ENTERCRITICAL;
    if (g_hacplmLoaded)
    {
        for (i=DSA_GetItemCount(g_hacplmLoaded)-1; i>=0; --i)
        {
            LPCPLMODULE pcplm = DSA_GetItemPtr(g_hacplmLoaded, i);

            //
            // owner id tested last since hinst is more varied
            //

            if ((pcplm->minst.hinst == pminst->hinst) &&
                (pcplm->minst.idOwner == pminst->idOwner))
            {
                break;
            }
        }
    }
    LEAVECRITICAL;
    return i;
}

LPCPLMODULE FindCPLModule(const MINST * pminst)
{
    return (LPCPLMODULE) DSA_GetItemPtr(g_hacplmLoaded, _FindCPLModule(pminst));
}


//
// Adds the specified CPL module to g_hacplmLoaded.
//
// Requires:
//  The specified CPL module is not in g_hacplmLoaded yet.
//
// Returns:
//  The index to the CPL module if succeeded; -1 otherwise.
//
int _AddModule(LPCPLMODULE pcplm)
{
    int     result;

    //
    // Create the Loaded Modules guy if necessary
    //
    ENTERCRITICAL;
    if (g_hacplmLoaded == NULL)
        g_hacplmLoaded = DSA_Create(sizeof(CPLMODULE), 4);
    //
    // Add this CPL to our list
    //
    if (g_hacplmLoaded == NULL)
        result = -1;
    else
        result = DSA_AppendItem(g_hacplmLoaded, pcplm);
    LEAVECRITICAL;
    return(result);
}


#define SZ_RUNDLL32_NOEXCEPT_ARGS       TEXT("/d ")
BOOL CatchCPLExceptions(UINT msg)
{
    LPCTSTR pszCmdLine = GetCommandLine();
    BOOL fCatch = TRUE;

    // Some callers don't want to run and have exceptions caught.
    // This will allow crashes to be uploaded to PCHealth.
    if (((CPL_STARTWPARMSA == msg) || (CPL_STARTWPARMS == msg) || (CPL_DBLCLK == msg)) &&
        StrCmpNI(pszCmdLine, SZ_RUNDLL32_NOEXCEPT_ARGS, (ARRAYSIZE(SZ_RUNDLL32_NOEXCEPT_ARGS) - 1)))
    {
        fCatch = FALSE;
    }

    return fCatch;
}


LRESULT CPL_CallEntry(LPCPLMODULE pcplm, HWND hwnd, UINT msg, LPARAM lParam1, LPARAM lParam2)
{
    LRESULT lres;
    ULONG_PTR dwCookie = 0;

    ActivateActCtx(pcplm->hActCtx, &dwCookie);

    if (!CatchCPLExceptions(msg))
    {
        lres = pcplm->lpfnCPL32(hwnd, msg, lParam1, lParam2);
    }
    else
    {
        __try
        {
            lres = pcplm->lpfnCPL32(hwnd, msg, lParam1, lParam2);
        }
        __except(SetErrorMode(SEM_NOGPFAULTERRORBOX),UnhandledExceptionFilter(GetExceptionInformation()))
        {
            TraceMsg(TF_ERROR, "CPL: Exception calling CPL module: %s", pcplm->szModule);
            ShellMessageBox(HINST_THISDLL, NULL, MAKEINTRESOURCE(IDS_CPL_EXCEPTION),
                    MAKEINTRESOURCE(IDS_CONTROLPANEL),
                    MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL,
                    (LPTSTR)pcplm->szModule);
            lres = 0;
        }
    }

    if (dwCookie != 0)
        DeactivateActCtx(0, dwCookie);

    return lres;
}

EXTERN_C DECLSPEC_IMPORT BOOL STDAPICALLTYPE
ApphelpCheckExe(
     LPCWSTR lpApplicationName,
     BOOL    bApphelp,
     BOOL    bShim,
     BOOL    bUseModuleName
     );
//
// Loads the specified CPL module and returns the index to g_hacplmLoaded.
//
int _LoadCPLModule(LPCTSTR pszModule)
{
    TCHAR szManifest[MAX_PATH];
    HANDLE hActCtx = NULL;
    MINST minst;
    int iModule;
    ULONG_PTR dwCookie;
    ACTCTX act = {0};
#ifndef UNICODE
    WCHAR wszModuleName[MAX_PATH];
#endif
    LPWSTR pwszModuleName = NULL;

    if (FAILED(StringCchPrintf(szManifest, ARRAYSIZE(szManifest), TEXT("%s.manifest"), pszModule)))
    {
        return -1;
    }

    minst.idOwner = GetCurrentProcessId();
    minst.hOwner = OpenProcess(SYNCHRONIZE,FALSE,minst.idOwner);
    if (NULL == minst.hOwner)
    {
        return -1;
    }

    // See if this application has a context
    if (PathFileExists(szManifest))
    {
        act.cbSize = sizeof(act);
        act.dwFlags = 0;
        act.lpSource = szManifest;
        hActCtx = CreateActCtx(&act);
    }
    else
    {
        act.cbSize = sizeof(act);
        act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        act.lpSource = pszModule;
        act.lpResourceName = MAKEINTRESOURCE(123);

        hActCtx = CreateActCtx(&act);
    }

    if (hActCtx == INVALID_HANDLE_VALUE)
        hActCtx = NULL;

    ActivateActCtx(hActCtx, &dwCookie);

    //
    // check and [possibly] fix this module
    //

#ifdef UNICODE
    pwszModuleName = (LPWSTR)pszModule;

#else  // if !defined(UNICODE)
    if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                            pszModule, -1,
                            wszModuleName, ARRAYSIZE(wszModuleName)) != 0) {
        pwszModuleName = wszModuleName;
    }

#endif // UNICODE

    if (!ApphelpCheckExe(pwszModuleName, TRUE, TRUE, TRUE)) {
        minst.hinst = NULL;
    } else {
        minst.hinst = LoadLibrary(pszModule);
    }

    if (dwCookie != 0)
        DeactivateActCtx(0, dwCookie);


    if (!ISVALIDHINSTANCE(minst.hinst))
    {
        if (hActCtx != NULL) {
            ReleaseActCtx(hActCtx);
        }

        CloseHandle(minst.hOwner);

        return -1;
    }

    //
    // Check if this module is already in the list.
    //

    iModule = _FindCPLModule(&minst);

    if (iModule >= 0)
    {
        //
        // Yes. Increment the reference count and return the ID.
        //
        LPCPLMODULE pcplm;

        ENTERCRITICAL;
        pcplm = DSA_GetItemPtr(g_hacplmLoaded, iModule);
        ++pcplm->cRef;
        LEAVECRITICAL;

        ActivateActCtx(hActCtx, &dwCookie);
        //
        // Decrement KERNELs reference count
        //
        _FreeLibraryForControlPanel(&minst);
        if (dwCookie != 0)
            DeactivateActCtx(0, dwCookie);

        if (hActCtx != NULL)
            ReleaseActCtx(hActCtx);

        CloseHandle(minst.hOwner);
    }
    else
    {
        CPLMODULE sModule = {0};


        //
        // No. Append it.
        //

        sModule.cRef = 1;
        sModule.minst = minst;
        sModule.hActCtx = hActCtx;

        GetModuleFileName(minst.hinst, sModule.szModule, ARRAYSIZE(sModule.szModule));

        if (_InitializeCPLModule(&sModule))
        {
            iModule = _AddModule(&sModule);
        }

        if (iModule < 0)
        {
            _TerminateCPLModule(&sModule);
        }
    }
    return iModule;
}


int _FreeCPLModuleIndex(int iModule)
{
    LPCPLMODULE pcplm;

    ENTERCRITICAL;
    pcplm = DSA_GetItemPtr(g_hacplmLoaded, iModule);

    if (!pcplm)
    {
        LEAVECRITICAL;
        return(-1);
    }

    //
    // Dec the ref count; return if not 0
    //

    --pcplm->cRef;

    if (pcplm->cRef)
    {
        LEAVECRITICAL;
        return(pcplm->cRef);
    }

    //
    // Free up the whole thing and return 0
    //

    _TerminateCPLModule(pcplm);

    DSA_DeleteItem(g_hacplmLoaded, iModule);

    //
    // Destroy this when all CPLs have been removed
    //

    if (DSA_GetItemCount(g_hacplmLoaded) == 0)
    {
        DSA_Destroy(g_hacplmLoaded);
        g_hacplmLoaded = NULL;
    }
    LEAVECRITICAL;
    return(0);
}


int _FreeCPLModuleHandle(const MINST * pminst)
{
    int iModule;

    //
    // Check if the module is actually loaded (major error if not)
    //

    iModule = _FindCPLModule(pminst);

    if (iModule < 0)
    {
        return(-1);
    }

    return _FreeCPLModuleIndex(iModule);
}

int CPL_FreeCPLModule(LPCPLMODULE pcplm)
{
    return _FreeCPLModuleHandle(&pcplm->minst);
}


void CPL_StripAmpersand(LPTSTR szBuffer)
{
    LPTSTR pIn, pOut;

    //
    // copy the name sans '&' chars
    //

    pIn = pOut = szBuffer;
    do
    {
        //
        // strip FE accelerators with parentheses.  e.g. "foo(&F)" -> "foo"
        //
        if (*pIn == TEXT('(') && *(pIn+1) == TEXT('&') &&
            *(pIn+2) && *(pIn+3) == TEXT(')')) {
            pIn += 4;
        }

#ifdef DBCS
        // Also strip FE accelerators in old win31 cpl, i.e, 01EH/01FH.
        if (*pIn == 0x1e && *++pIn) {


            // Assumes a character right before the mnemonic
            // is a parenthesis or something to be removed as well.
            //
            pOut=CharPrev(szBuffer, pOut);

            // Skip Alphabet accelerator.
            pIn = CharNext(pIn);

            if (*pIn) {
                if (*pIn == 0x1f && *++pIn) {

                    // Skip FE accelelator
                    //
                    pIn = CharNext(pIn);
                }
                // Skip second parenthesis.
                //
                pIn = CharNext(pIn);
            }
        }
#endif
        if (*pIn != TEXT('&')) {
            *pOut++ = *pIn;
        }
        if (IsDBCSLeadByte(*pIn)) {
            *pOut++ = *++pIn;
        }
    } while (*pIn++) ;
}


//
// filter out bogus old ini keys... we may be able to blow this off
BOOL IsValidCplKey(LPCTSTR pszKey)
{
    return lstrcmpi(pszKey, TEXT("NumApps")) &&
        !((*(pszKey+1) == 0) &&
        ((*pszKey == TEXT('X')) || (*pszKey == TEXT('Y')) || (*pszKey == TEXT('W')) || (*pszKey == TEXT('H'))));
}


LPCPLMODULE CPL_LoadCPLModule(LPCTSTR szModule)
{
    LPCPLMODULE result;

    int iModule = _LoadCPLModule(szModule);

    if (iModule < 0)
        result = NULL;
    else
    {
        ENTERCRITICAL;
        result = DSA_GetItemPtr(g_hacplmLoaded, iModule);
        LEAVECRITICAL;
    }
    return result;
}

BOOL DontLoadCPL(LPCTSTR pszName)
{
    // the first reg location is the old alias for control.ini [don't load]
    // entries that map into the registry on NT. the next is for per
    // machine support to hide cpls, new for whistler
    return (SHGetValue(HKEY_CURRENT_USER,  TEXT("Control Panel\\don't load"), pszName, NULL, NULL, NULL) == ERROR_SUCCESS) ||
           (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\don't load"), pszName, NULL, NULL, NULL) == ERROR_SUCCESS);
}

// Called for each CPL module file which we may want to load
void _InsertModuleName(ControlData *lpData, LPCTSTR szPath, PMODULEINFO pmi)
{
    pmi->pszModule = NULL;
    Str_SetPtr(&pmi->pszModule, szPath);

    if (pmi->pszModule)
    {
        int i;

        pmi->pszModuleName = PathFindFileName(pmi->pszModule);

        if (DontLoadCPL(pmi->pszModuleName))
        {
            Str_SetPtr(&pmi->pszModule, NULL);
            goto skip;
        }

        // don't insert the module if it's already in the list!

        for (i = DSA_GetItemCount(lpData->hamiModule)-1 ; i >= 0 ; i--)
        {
            PMODULEINFO pmi1 = DSA_GetItemPtr(lpData->hamiModule, i);

            if (!lstrcmpi(pmi1->pszModuleName, pmi->pszModuleName))
            {
                Str_SetPtr(&pmi->pszModule, NULL);
                goto skip;
            }
        }

        DSA_AppendItem(lpData->hamiModule, pmi);
skip:
        ;
    }
}

#define GETMODULE(haminst,i)     ((MINST *)DSA_GetItemPtr(haminst, i))
#define ADDMODULE(haminst,pminst) DSA_AppendItem(haminst, (void *)pminst)

int _LoadCPLModuleAndAdd(ControlData *lpData, LPCTSTR szModule)
{
    int iModule, i;
    LPCPLMODULE pcplm;

    //
    // Load the module and controls (or get the previous one if already
    // loaded).
    //

    iModule = _LoadCPLModule(szModule);

    if (iModule < 0)
    {
        TraceMsg(TF_WARNING, "_LoadCPLModuleAndAdd: _LoadControls refused %s", szModule);
        return -1;
    }

    pcplm = DSA_GetItemPtr(g_hacplmLoaded, iModule);

    if (pcplm == NULL)
    {
        TraceMsg(TF_WARNING, "_LoadCPLModuleAndAdd: DSA returned NULL structure");
        return -1;
    }

    //
    // Check if this guy has already loaded this module
    //

    for (i = DSA_GetItemCount(lpData->haminst) - 1; i >= 0; --i)
    {
        const MINST * pminst = GETMODULE(lpData->haminst,i);

        //
        // note: owner id tested last since hinst is more varied
        //

        if ((pminst->hinst == pcplm->minst.hinst) &&
            (pminst->idOwner == pcplm->minst.idOwner))
        {
FreeThisModule:

            //
            // This guy already loaded this module, so dec
            // the reference and return failure
            //

            _FreeCPLModuleIndex(iModule);
            return(-1);
        }
    }

    //
    // this is a new module, so add it to the list
    //

    if (ADDMODULE(lpData->haminst, &pcplm->minst) < 0)
    {
        goto FreeThisModule;
    }

    return iModule;
}


void _AddItemsFromKey(ControlData *pcd, HKEY hkRoot)
{
    HKEY hkey;
    MODULEINFO mi = {0};

    mi.flags = MI_FIND_FILE;

    if (ERROR_SUCCESS == RegOpenKeyEx(hkRoot,
                                      TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\CPLs"),
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hkey))
    {
        TCHAR szData[MAX_PATH], szValue[128];
        DWORD dwSizeData, dwValue, dwIndex;

        for (dwIndex = 0;
            ERROR_SUCCESS == (dwValue = ARRAYSIZE(szValue), dwSizeData = sizeof(szData),
                RegEnumValue(hkey, dwIndex, szValue, &dwValue, NULL, NULL, (BYTE *)szData, &dwSizeData));
            dwIndex++)
        {
            TCHAR szPath[MAX_PATH];
            if (SHExpandEnvironmentStrings(szData, szPath, ARRAYSIZE(szPath)))
            {
                WIN32_FIND_DATA fd;
                HANDLE hfind = FindFirstFile(szPath, &fd);
                if (hfind != INVALID_HANDLE_VALUE)
                {
                    mi.ftCreationTime = fd.ftCreationTime;
                    mi.nFileSizeHigh = fd.nFileSizeHigh;
                    mi.nFileSizeLow = fd.nFileSizeLow;
                    FindClose(hfind);

                    _InsertModuleName(pcd, szPath, &mi);
                }
            }
        }
        RegCloseKey(hkey);
    }
}


/* Get the keynames under [MMCPL] in CONTROL.INI and cycle
   through all such keys to load their applets into our
   list box.  Also allocate the array of CPLMODULE structs.
   Returns early if can't load old WIN3 applets.
*/
BOOL CPLD_GetModules(ControlData *lpData)
{
    LPTSTR       pStr;
    HANDLE   hFindFile;
    WIN32_FIND_DATA findData;
    MODULEINFO mi;
    TCHAR szPath[MAX_PATH], szSysDir[MAX_PATH], szName[MAX_PATH];

    ASSERT(lpData->hamiModule == NULL);

    lpData->hamiModule = DSA_Create(sizeof(mi), 4);

    if (!lpData->hamiModule)
    {
        return FALSE;
    }

    lpData->haminst = DSA_Create(sizeof(MINST), 4);

    if (!lpData->haminst)
    {
        DSA_Destroy(lpData->hamiModule);
        lpData->hamiModule = NULL; // no one is freeing hamiModule in the caller if this fails, but just to make sure ...
        return FALSE;
    }

    //
    // So here's the deal:
    // We have this global list of all modules that have been loaded, along
    // with a reference count for each.  This is so that we don't need to
    // load a CPL file again when the user double clicks on it.
    // We still need to keep a list for each window that is open, so that
    // we will not load the same CPL twice in a single window.  Therefore,
    // we need to keep a list of all modules that are loaded (note that
    // we cannot just keep indexes, since the global list can move around).
    //
    // hamiModule contains the module name, the instance info if loaded,
    // and some other information for comparing with cached information
    //

    ZeroMemory(&mi, sizeof(mi));

    //
    // don't special case main, instead sort the data by title
    //

    GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir));

    // load the modules specified in CONTROL.INI under [MMCPL]
    {
        TCHAR szKeys[512];    // from section of extra cpls to load
        GetPrivateProfileString(TEXT("MMCPL"), NULL, c_szNULL, szKeys, ARRAYSIZE(szKeys), TEXT("control.ini"));

        for (pStr = szKeys; *pStr; pStr += lstrlen(pStr) + 1)
        {
            GetPrivateProfileString(TEXT("MMCPL"), pStr, c_szNULL, szName, ARRAYSIZE(szName), TEXT("control.ini"));
            if (IsValidCplKey(pStr))
            {
                _InsertModuleName(lpData, szName, &mi);
            }
        }
    }

    // load applets from the system directory

    if (PathCombine(szPath, szSysDir, TEXT("*.CPL")))
    {
        mi.flags |= MI_FIND_FILE;

        hFindFile = FindFirstFile(szPath, &findData);

        if (hFindFile != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (!(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    BOOL fOkToUse = TRUE;

                    if (IsOS(OS_WOW6432))
                    {
                        GetWindowsDirectory(szPath,ARRAYSIZE(szPath));
                        if (PathCombine(szPath, szPath, TEXT("system32")) &&
                            PathCombine(szPath, szPath, findData.cFileName))
                        {
                            //
                            // Don't use any CPLs which exist in the real system32
                            // directory, since we only have them in the fake system
                            // directory for compatibility reasons.
                            //
                            if (PathFileExists(szPath))
                            {
                                fOkToUse = FALSE;
                            }
                        }
                    }

                    if (fOkToUse)
                    {
                        if (PathCombine(szPath, szSysDir, findData.cFileName))
                        {
                            mi.ftCreationTime = findData.ftCreationTime;
                            mi.nFileSizeHigh = findData.nFileSizeHigh;
                            mi.nFileSizeLow = findData.nFileSizeLow;

                            _InsertModuleName(lpData, szPath, &mi);
                        }
                    }
                }
            } while (FindNextFile(hFindFile, &findData));

            FindClose(hFindFile);
        }
    }

    _AddItemsFromKey(lpData, HKEY_CURRENT_USER);
    _AddItemsFromKey(lpData, HKEY_LOCAL_MACHINE);

    lpData->cModules = DPA_GetPtrCount(lpData->hamiModule);

    return TRUE;
}



//
// A bug has existed in Control Panel for as long as I can tell that,
// under the right conditions involving roaming user profiles, could
// prevent a control panel item from appearing in the folder.  The
// problem description is too long for a comment but the MI_REG_INVALID
// flag was added to solve it.  See it's use in CControlPanelEnum::Next.
// However, presentation caches created prior to this fix under the
// problem scenario may still result in affected CPL items not appearing.
// In those cases, refreshing the presentation cache using the new code
// corrects the problem.  Therefore, any cache created prior to the date
// of this new code's introduction must be discarded and refreshed.
// The presence of the REGCPL_POST_102001 (oct 2001) flag in a cache entry
// indicates the cache was created after this new code was introduced and may
// be safely used.  This function reports the presence/absence of this
// flag in the cache buffer.  [brianau - 10/03/01]
//
BOOL _IsPresentationCachePostOctober2001(LPBYTE pbData, DWORD cbData)
{
    BOOL bPostOct2001 = FALSE;
    if (cbData >= sizeof(REG_CPL_INFO))
    {
        if (REGCPL_POST_102001 & ((REG_CPL_INFO *)pbData)->flags)
        {
            bPostOct2001 = TRUE;
        }
    }
    return bPostOct2001;
}


//  Read the registry for cached CPL info.
//  If this info is up-to-date with current modules (from CPLD_GetModules),
//  then we can enumerate these without loading the CPLs.

void CPLD_GetRegModules(ControlData *lpData)
{
    HKEY hkey;
    LPCTSTR lpszRegKey;

    // dont cache any-thing in clean boot.
    if (GetSystemMetrics(SM_CLEANBOOT))
        return;

    if (IsOS(OS_WOW6432))
    {
        lpszRegKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder (Wow64)");
    }
    else
    {
        lpszRegKey = REGSTR_PATH_CONTROLSFOLDER;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      lpszRegKey,
                                      0,
                                      KEY_READ,
                                      &hkey))
    {
        DWORD cbSize;
        DWORD dwLCID = 0;
        cbSize = sizeof(dwLCID);

        // fail if this cache is not tagged with the UI language ID, or we are not in
        // the language ID that the cache was saved in.
        if (ERROR_SUCCESS != SHQueryValueEx(hkey, TEXT("Presentation LCID"),
                NULL, NULL, (LPBYTE) &dwLCID, &cbSize) || dwLCID != GetUserDefaultUILanguage())
        {
            RegCloseKey(hkey);
            return;
        }
        if (ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("Presentation Cache"),
                NULL, NULL, NULL, &cbSize))
        {
            lpData->pRegCPLBuffer = LocalAlloc(LPTR, cbSize);

            if (lpData->pRegCPLBuffer)
            {
                if (ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("Presentation Cache"),
                        NULL, NULL, lpData->pRegCPLBuffer, &cbSize))
                {
                    if (!_IsPresentationCachePostOctober2001(lpData->pRegCPLBuffer, cbSize))
                    {
                        TraceMsg(TF_WARNING, "CPLD_GetRegModules: Presentation cache pre Oct 2001.");
                        LocalFree(lpData->pRegCPLBuffer);
                        lpData->pRegCPLBuffer = NULL;
                    }
                    else
                    {
                        lpData->hRegCPLs = DPA_Create(4);
                        if (lpData->hRegCPLs)
                        {
                            REG_CPL_INFO * p;
                            DWORD cbOffset;

                            for (cbOffset = 0          ;
                                  cbOffset < cbSize     ;
                                  cbOffset += p->cbSize)
                            {
                                p = (REG_CPL_INFO *)&(lpData->pRegCPLBuffer[cbOffset]);
                                p->flags |= REGCPL_FROMREG;
                                DPA_AppendPtr(lpData->hRegCPLs, p);

                                //DebugMsg(DM_TRACE,"sh CPLD_GetRegModules: %s (%s)", REGCPL_FILENAME(p), REGCPL_CPLNAME(p));
                            }

                            lpData->cRegCPLs = DPA_GetPtrCount(lpData->hRegCPLs);
                        }
                    }
                }
                else
                {
                    TraceMsg(TF_WARNING, "CPLD_GetRegModules: failed read!");
                }
            } // Alloc
        } // SHQueryValueEx for size

        RegCloseKey(hkey);

    } // RegOpenKey
}


//
// On a typical system, we will successfully cache all the CPLs.  So this
// function will write out the data only once.
//

void CPLD_FlushRegModules(ControlData *lpData)
{
    if (lpData->fRegCPLChanged)
    {
        int         num = DPA_GetPtrCount(lpData->hRegCPLs);
        DWORD       cbSize = num * sizeof(REG_CPL_INFO);

        REG_CPL_INFO * prcpli = LocalAlloc(LPTR, cbSize);
        LPCTSTR lpszRegKey;

        if (IsOS(OS_WOW6432))
        {
            lpszRegKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder (Wow64)");
        }
        else
        {
            lpszRegKey = REGSTR_PATH_CONTROLSFOLDER;
        }

        if (prcpli)
        {
            REG_CPL_INFO * pDest;
            HKEY hkey;
            int i;

            //
            // 0<=i<=num && CPLs 0..i-1 have been copied to prcpli or skipped
            //

            for (i = 0, pDest = prcpli; i < num ;)
            {
                REG_CPL_INFO * p = DPA_GetPtr(lpData->hRegCPLs, i);
                int j;

                //
                // if any CPL in this module has a dynamic icon, we cannot cache
                // any of this module's CPLs.
                //
                // i<=j<=num && CPLs i..j-1 are in same module
                //

                for (j = i; j < num; j++)
                {
                    REG_CPL_INFO * q = DPA_GetPtr(lpData->hRegCPLs, j);

                    if (lstrcmp(REGCPL_FILENAME(p), REGCPL_FILENAME(q)))
                    {
                        // all CPLs in this module are okay, save 'em
                        break;
                    }

                    if (q->idIcon == 0)
                    {
                        TraceMsg(TF_GENERAL, "CPLD_FlushRegModules: SKIPPING %s (%s) [dynamic icon]",REGCPL_FILENAME(p),REGCPL_CPLNAME(p));

                        // this module has a dynamic icon, skip it
                        for (j++ ; j < num ; j++)
                        {
                            q = DPA_GetPtr(lpData->hRegCPLs, j);
                            if (lstrcmp(REGCPL_FILENAME(p), REGCPL_FILENAME(q)))
                                break;
                        }
                        i = j;
                        break;
                    }
                }

                // CPLs i..j-1 are in the same module and need to be saved
                // (if j<num, CPL j is in the next module)
                for (; i < j ; i++)
                {
                    p = DPA_GetPtr(lpData->hRegCPLs, i);

                    hmemcpy(pDest, p, p->cbSize);
                    //
                    // Set the post-Oct 2001 flag.
                    //
                    pDest->flags |= REGCPL_POST_102001;

                    pDest = (REG_CPL_INFO *)(((LPBYTE)pDest) + pDest->cbSize);
                    //DebugMsg(DM_TRACE,"CPLD_FlushRegModules: %s (%s)",REGCPL_FILENAME(p),REGCPL_CPLNAME(p));
                }
            } // for (i=0,pDest=prcpli


            // prcpli contains packed REG_CPL_INFO structures to save to the registry

            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                                lpszRegKey,
                                                0,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE,
                                                KEY_WRITE,
                                                NULL,      // default security
                                                &hkey,
                                                NULL))
            {
                DWORD dwLCID;
                DWORD dwSize = sizeof(dwLCID);
                dwLCID = GetUserDefaultUILanguage();

                if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("Presentation LCID"), 0, REG_DWORD, (LPBYTE) &dwLCID, dwSize))
                {
                    TraceMsg(TF_WARNING, "CPLD_FLushRegModules: failed to write the LCID!");
                }
                if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("Presentation Cache"), 0, REG_BINARY, (LPBYTE)prcpli, (DWORD) ((LPBYTE)pDest-(LPBYTE)prcpli)))
                {
                    TraceMsg(TF_WARNING, "CPLD_FLushRegModules: failed write!");
                }
                RegCloseKey(hkey);
            }

            LocalFree((HLOCAL)prcpli);

            lpData->fRegCPLChanged = FALSE; // no longer dirty
        } // if (prcpli)
    } // if dirty
}


//---------------------------------------------------------------------------
void CPLD_Destroy(ControlData *lpData)
{
    int i;

    if (lpData->haminst)
    {
        for (i=DSA_GetItemCount(lpData->haminst)-1 ; i>=0 ; --i)
            _FreeCPLModuleHandle(DSA_GetItemPtr(lpData->haminst, i));

        DSA_Destroy(lpData->haminst);
    }

    if (lpData->hamiModule)
    {
        for (i=DSA_GetItemCount(lpData->hamiModule)-1 ; i>=0 ; --i)
        {
            PMODULEINFO pmi = DSA_GetItemPtr(lpData->hamiModule, i);

            Str_SetPtr(&pmi->pszModule, NULL);
        }

        DSA_Destroy(lpData->hamiModule);
    }

    if (lpData->hRegCPLs)
    {
        CPLD_FlushRegModules(lpData);

        for (i = DPA_GetPtrCount(lpData->hRegCPLs)-1 ; i >= 0 ; i--)
        {
            REG_CPL_INFO * p = DPA_GetPtr(lpData->hRegCPLs, i);
            if (!(p->flags & REGCPL_FROMREG))
                LocalFree((HLOCAL)p);
        }
        DPA_Destroy(lpData->hRegCPLs);
    }
    if (lpData->pRegCPLBuffer)
        LocalFree((HLOCAL)lpData->pRegCPLBuffer);
}


//
// Loads module lpData->hamiModule[nModule] and returns # cpls in module
int CPLD_InitModule(ControlData *lpData, int nModule, MINST *pminst)
{
    PMODULEINFO pmi;
    LPCPLMODULE pcplm;
    int iModule;

    pmi = DSA_GetItemPtr(lpData->hamiModule, nModule);

    if (pmi == NULL)
    {
        TraceMsg(TF_WARNING, "CPLD_InitModule: DSA returned NULL structure");
        return 0;
    }

    iModule = _LoadCPLModuleAndAdd(lpData, pmi->pszModule);

    if (iModule < 0)
    {
        return(0);
    }

    pcplm = DSA_GetItemPtr(g_hacplmLoaded, iModule);
    *pminst = pcplm->minst;

    return DSA_GetItemCount(pcplm->hacpli);
}

BOOL CPLD_AddControlToReg(ControlData *lpData, const MINST * pminst, int nControl)
{
    int iModule;
    LPCPLMODULE pcplm;
    LPCPLITEM  pcpli = NULL;

    TCHAR buf[MAX_PATH];
    HANDLE hFindFile;
    WIN32_FIND_DATA findData;

    iModule = _FindCPLModule(pminst);
    if (iModule >= 0)
    {
        pcplm = DSA_GetItemPtr(g_hacplmLoaded, iModule);
        if (pcplm != NULL)
            pcpli = DSA_GetItemPtr(pcplm->hacpli, nControl);
    }
    if (pcpli == NULL)
        return FALSE;

    //
    // PERF: Why are we using GetModuleFileName instead of the name
    // of the file we used to load this module?  (We have the name both
    // in the calling function and in lpData.)
    //

    GetModuleFileName(pcplm->minst.hinst, buf, MAX_PATH);

    if (*buf != 0)
        hFindFile = FindFirstFile(buf, &findData);
    else
        hFindFile = INVALID_HANDLE_VALUE;

    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        REG_CPL_INFO * prcpli = LocalAlloc(LPTR, sizeof(REG_CPL_INFO));

        FindClose(hFindFile);

        if (prcpli)
        {
            if (SUCCEEDED(StringCchCopy(REGCPL_FILENAME(prcpli), MAX_PATH, buf)))
            {
                prcpli->flags = FALSE;
                prcpli->ftCreationTime = findData.ftCreationTime;
                prcpli->nFileSizeHigh = findData.nFileSizeHigh;
                prcpli->nFileSizeLow = findData.nFileSizeLow;

                prcpli->idIcon = pcpli->idIcon;

                prcpli->oName = lstrlen(REGCPL_FILENAME(prcpli)) + 1;
                //
                // We don't check return values from StringCchCopy because we
                // don't care if the CPL display name or info text are truncated.
                // We do care that the file name is complete (above).
                //
                StringCchCopy(REGCPL_CPLNAME(prcpli),  MAX_CCH_CPLNAME, pcpli->pszName);

                prcpli->oInfo = prcpli->oName + lstrlen(REGCPL_CPLNAME(prcpli)) + 1;

                StringCchCopy(REGCPL_CPLINFO(prcpli), MAX_CCH_CPLINFO, pcpli->pszInfo);

                prcpli->cbSize = FIELD_OFFSET(REG_CPL_INFO, buf) + (prcpli->oInfo
                                                + lstrlen(REGCPL_CPLINFO(prcpli))
                                                + 1) * sizeof(TCHAR);

                //
                // Force struct size to be DWORD aligned since these are packed
                // together in registry, then read and accessed after reading
                // cache from registry.
                //

                if (prcpli->cbSize & 3)
                    prcpli->cbSize += sizeof(DWORD) - (prcpli->cbSize & 3);

                if (!lpData->hRegCPLs)
                {
                    lpData->hRegCPLs = DPA_Create(4);
                }
                if (lpData->hRegCPLs)
                {
                    DPA_AppendPtr(lpData->hRegCPLs, prcpli);

                    //
                    // don't update cRegCPLs.  We don't need it any more, and
                    // it is also the upper-end counter for ESF_Next registry enum.
                    //lpData->cRegCPLs++;
                    //

                    lpData->fRegCPLChanged = TRUE;
                }
                else
                    LocalFree((HLOCAL)prcpli);
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\copy.h ===
#ifndef _COPY_H
#define _COPY_H

#include "ynlist.h"

#define ISDIRFINDDATA(finddata) ((finddata).dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
#define ISREPARSEFINDDATA(finddata) ((finddata).dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)

#define DE_SAMEFILE         0x71    // aahhh! these overlap winerror.h values
#define DE_MANYSRC1DEST     0x72
#define DE_DIFFDIR          0x73
#define DE_ROOTDIR          0x74

#define DE_DESTSUBTREE      0x76
#define DE_WINDOWSFILE      0x77
#define DE_ACCESSDENIEDSRC  0x78
#define DE_PATHTODEEP       0x79
#define DE_MANYDEST         0x7A
// DE_RENAMREPLACE (0x7B) collided with ERROR_INVALID_NAME - but luckily was not used
#define DE_INVALIDFILES     0x7C        // dos device name or too long
#define DE_DESTSAMETREE     0x7D
#define DE_FLDDESTISFILE    0x7E
#define DE_COMPRESSEDVOLUME 0x7F
#define DE_FILEDESTISFLD    0x80
#define DE_FILENAMETOOLONG  0x81
#define DE_DEST_IS_CDROM    0x82
#define DE_DEST_IS_DVD      0x83
#define DE_DEST_IS_CDRECORD 0x84
#define DE_ERROR_MAX        0xB7 

#define ERRORONDEST         0x10000     // indicate error on destination file

STDAPI_(int) CallFileCopyHooks(HWND hwnd, UINT wFunc, FILEOP_FLAGS fFlags,
                                LPCTSTR pszSrcFile, DWORD dwSrcAttribs,
                                LPCTSTR pszDestFile, DWORD dwDestAttribs);
STDAPI_(int) CallPrinterCopyHooks(HWND hwnd, UINT wFunc, PRINTEROP_FLAGS fFlags,
                                LPCTSTR pszSrcPrinter, DWORD dwSrcAttribs,
                                LPCTSTR pszDestPrinter, DWORD dwDestAttribs);
STDAPI_(void) CopyHooksTerminate(void);


#define CONFIRM_DELETE_FILE             0x00000001
#define CONFIRM_DELETE_FOLDER           0x00000002
#define CONFIRM_REPLACE_FILE            0x00000004
#define CONFIRM_WONT_RECYCLE_FILE       0x00000008
#define CONFIRM_REPLACE_FOLDER          0x00000010
#define CONFIRM_MOVE_FILE               0x00000020
#define CONFIRM_MOVE_FOLDER             0x00000040
#define CONFIRM_WONT_RECYCLE_FOLDER     0x00000080
#define CONFIRM_RENAME_FILE             0x00000100
#define CONFIRM_RENAME_FOLDER           0x00000200
#define CONFIRM_SYSTEM_FILE             0x00000400       // any destructive op on a system file
#define CONFIRM_READONLY_FILE           0x00001000       // any destructive op on a read-only file
#define CONFIRM_PROGRAM_FILE            0x00002000       // any destructive op on a program
#define CONFIRM_MULTIPLE                0x00004000       // multiple file/folder confirm setting
#define CONFIRM_LFNTOFAT                0x00008000
#define CONFIRM_STREAMLOSS              0x00010000       // Multi-stream file copied from NTFS -> FAT
#define CONFIRM_PATH_TOO_LONG           0x00020000       // give warning before really nuking paths that are too long to move to recycle bin
#define CONFIRM_FAILED_ENCRYPT          0x00040000       // we failed to encrypt a file that we were moving into an encrypted directory
#define CONFIRM_WONT_RECYCLE_OFFLINE    0x00080000       // give warning before really nuking paths that are offline and can't be recycled
#define CONFIRM_LOST_ENCRYPT_FILE       0x00100000       // Can't move over encryption flag
#define CONFIRM_LOST_ENCRYPT_FOLDER     0x00200000       // Can't move over encryption flag

    /// these parts below are true flags, those above are pseudo enums
#define CONFIRM_WASTEBASKET_PURGE       0x01000000

typedef LONG CONFIRM_FLAG;

#define CONFIRM_FLAG_FLAG_MASK    0xFF000000
#define CONFIRM_FLAG_TYPE_MASK    0x00FFFFFF

typedef struct {
    CONFIRM_FLAG   fConfirm;    // confirm things with their bits set here
    CONFIRM_FLAG   fNoToAll;    // do "no to all" on things with these bits set
} CONFIRM_DATA;


//
// BBDeleteFile returns one of the flags below in a out variable so that
// the caller can detect why BBDeleteFile succeeded/failed.
//
#define BBDELETE_SUCCESS        0x00000000
#define BBDELETE_UNKNOWN_ERROR  0x00000001
#define BBDELETE_FORCE_NUKE     0x00000002
#define BBDELETE_CANNOT_DELETE  0x00000004
#define BBDELETE_SIZE_TOO_BIG   0x00000008
#define BBDELETE_PATH_TOO_LONG  0x00000010
#define BBDELETE_NUKE_OFFLINE   0x00000020
#define BBDELETE_CANCELLED      0x00000040


#ifndef INTERNAL_COPY_ENGINE
STDAPI_(INT_PTR) ConfirmFileOp(HWND hwnd, LPVOID pcs, CONFIRM_DATA *pcd,
                              int nSourceFiles, int cDepth, CONFIRM_FLAG fConfirm,
                              LPCTSTR pFileSource, const WIN32_FIND_DATA *pfdSource,
                              LPCTSTR pFileDest,   const WIN32_FIND_DATA *pfdDest,
                              LPCTSTR pStreamNames);
STDAPI_(int) CountFiles(LPCTSTR pInput);
#endif

STDAPI_(INT_PTR) ValidateCreateFileFromClip(HWND hwnd, LPFILEDESCRIPTOR pfdSrc, TCHAR *szPathDest, PYNLIST pynl);

STDAPI_(void) StartCopyEngine(HANDLE *phEventRunning);
STDAPI_(void) EndCopyEngine(HANDLE hEventRunning);
STDAPI_(BOOL) IsCopyEngineRunning();

#endif  // _COPY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpaction.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpaction.cpp
//
//  This module implements the various 'action' objects used by the 
//  Control Panel's 'category' view.  Each 'link' in the UI has an 
//  associated 'action'.  The action objects are defined in cpnamespc.cpp.
//  All 'action' objects are designed so that object construction is 
//  very cheap and that minimal processing is performed until the action
//  is invoked.  
//  
//--------------------------------------------------------------------------
#include "shellprv.h"

#include <idhidden.h> 

#include "cpviewp.h"
#include "cpaction.h"
#include "cpguids.h"
#include "cpuiele.h"
#include "cputil.h"


//// from shell\sdspatch\sdfolder.cpp
VARIANT_BOOL GetBarricadeStatus(LPCTSTR pszValueName);


//
// Disable warning.  ShellExecute uses SEH.
//  "nonstandard extension used: 'Execute' uses SEH and 'se' has destructor".
//
#pragma warning( push )
#pragma warning( disable:4509 )


using namespace CPL;


//
// Helper to append a bare file name to the system directory.
//
HRESULT
AppendToSysDir(
    LPCWSTR pszToAppend,   // Append this
    LPWSTR pszPath,        // [out] Contains concatenated result
    size_t cchPath
    )
{
    HRESULT hr = E_FAIL;
    WCHAR szTemp[MAX_PATH];
    if (0 != GetSystemDirectory(szTemp, ARRAYSIZE(szTemp)))
    {
        if (PathAppend(szTemp, pszToAppend))
        {
            hr = StringCchCopy(pszPath, cchPath, szTemp);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = ResultFromLastError();
    }
    return THR(hr);
}



HRESULT 
CRestrictApplet::IsRestricted(
    ICplNamespace *pns
    ) const
{
    UNREFERENCED_PARAMETER(pns);
    
    DBG_ENTER(FTF_CPANEL, "RestrictApplet");

    HRESULT hr = S_FALSE;
    if (!IsAppletEnabled(m_pszFile, m_pszApplet))
    {
        hr = S_OK;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "RestrictApplet", hr);
    return hr;
}



//--------------------------------------------------------------------------
// CAction implementation
//--------------------------------------------------------------------------

CAction::CAction(
    const CPL::IRestrict *pRestrict  // optional.  default = NULL
    ) : m_pRestrict(pRestrict)
{


}


//
// Returns:
//     S_FALSE    - Not restricted.
//     S_OK       - Restricted.
//     Failure    - Cannot determine.
//
HRESULT
CAction::IsRestricted(
    ICplNamespace *pns
    ) const
{
    HRESULT hr = S_FALSE;  // Assume not restricted.

    if (NULL != m_pRestrict)
    {
        hr = m_pRestrict->IsRestricted(pns);
    }
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenUserMgrApplet implementation
//--------------------------------------------------------------------------

COpenUserMgrApplet::COpenUserMgrApplet(
    const CPL::IRestrict *pRestrict  // optional.  default = NULL
    ): CAction(pRestrict)
{

}


HRESULT
COpenUserMgrApplet::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenUserMgrApplet::Execute");

    HRESULT hr = E_FAIL;
    if (IsOsServer())
    {
        CShellExecuteSysDir action(L"lusrmgr.msc");
        hr = action.Execute(hwndParent, punkSite);
    }
    else
    {
        COpenCplAppletSysDir action(L"nusrmgr.cpl");
        hr = action.Execute(hwndParent, punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "COpenUserMgrApplet::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenCplApplet implementation
//--------------------------------------------------------------------------

COpenCplApplet::COpenCplApplet(
    LPCWSTR pszApplet,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_pszApplet(pszApplet)
{
    ASSERT(NULL != pszApplet);
}


HRESULT
COpenCplApplet::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenCplApplet::Execute");

    ASSERT(NULL != m_pszApplet);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    //
    // Build a path consisting of the system directory, the
    // "%SystemDir%\shell32,Control_RunDLL" string and the 
    // applet name.  i.e.:
    //
    //  "c:\windows\system32\shell32,Control_RundLL desk.cpl"
    //
    WCHAR szArgs[MAX_PATH * 2];
    HRESULT hr = AppendToSysDir(L"shell32.dll,Control_RunDLL ", szArgs, ARRAYSIZE(szArgs));
    if (SUCCEEDED(hr))
    {
        hr = StringCchCat(szArgs, ARRAYSIZE(szArgs), m_pszApplet);
        if (SUCCEEDED(hr))
        {
            //
            // Build a path to rundll32.exe.
            // i.e.:
            //        "c:\windows\system32\rundll32.exe"
            //
            WCHAR szRunDll32[MAX_PATH];
            hr = AppendToSysDir(L"rundll32.exe", szRunDll32, ARRAYSIZE(szRunDll32));
            if (SUCCEEDED(hr))
            {
                TraceMsg(TF_CPANEL, "Executing: \"%s %s\"", szRunDll32, szArgs);

                SHELLEXECUTEINFOW sei = {
                    sizeof(sei),           // cbSize;
                    0,                     // fMask
                    hwndParent,            // hwnd
                    NULL,                  // lpVerb
                    szRunDll32,            // lpFile
                    szArgs,                // lpParameters
                    NULL,                  // lpDirectory
                    SW_SHOWNORMAL,         // nShow
                    0,                     // hInstApp
                    NULL,                  // lpIDList
                    NULL,                  // lpClass
                    NULL,                  // hkeyClass
                    0,                     // dwHotKey
                    NULL,                  // hIcon
                    NULL                   // hProcess
                };
                if (!ShellExecuteExW(&sei))
                {
                    hr = ResultFromLastError();
                }
            }
        }
    }

    DBG_EXIT_HRES(FTF_CPANEL, "COpenCplApplet::Execute", hr);
    return THR(hr);
}


//--------------------------------------------------------------------------
// COpenCplAppletSysDir implementation
//
// Minor extension of COpenCplApplet that assumes the applet is in 
// %SystemRoot%\System32 directory.
//
//--------------------------------------------------------------------------
COpenCplAppletSysDir::COpenCplAppletSysDir(
    LPCWSTR pszApplet,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : COpenCplApplet(pszApplet, pRestrict)
{
    ASSERT(NULL != pszApplet);
}


HRESULT
COpenCplAppletSysDir::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenCplAppletSysDir::Execute");

    ASSERT(NULL != m_pszApplet);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    //
    // Build a path consisting of the system directory and the 
    // applet name.  i.e.:
    //
    //  "c:\windows\system32\desk.cpl"
    //
    WCHAR szAppletPath[MAX_PATH];
    HRESULT hr = AppendToSysDir(m_pszApplet, szAppletPath, ARRAYSIZE(szAppletPath));
    if (SUCCEEDED(hr))
    {
        COpenCplApplet oca(szAppletPath);
        hr = oca.Execute(hwndParent, punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "COpenCplAppletSysDir::Execute", hr);
    return THR(hr);
}


//--------------------------------------------------------------------------
// COpenDeskCpl implementation
//--------------------------------------------------------------------------

COpenDeskCpl::COpenDeskCpl(
    eDESKCPLTAB eCplTab,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_eCplTab(eCplTab)
{

}


HRESULT
COpenDeskCpl::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenDeskCpl::Execute");
    TraceMsg(TF_CPANEL, "Desk CPL tab ID = %d", m_eCplTab);

    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    HRESULT hr = E_FAIL;
    WCHAR szTab[MAX_PATH];

    const int iTab = CPL::DeskCPL_GetTabIndex(m_eCplTab, szTab, ARRAYSIZE(szTab));
    if (CPLTAB_ABSENT != iTab)
    {
        WCHAR szArgs[MAX_PATH];

        hr = StringCchPrintfW(szArgs, ARRAYSIZE(szArgs), L"desk.cpl ,@%ls", szTab);
        if (SUCCEEDED(hr))
        {
            COpenCplAppletSysDir oca(szArgs);
            hr = oca.Execute(hwndParent, punkSite);
        }
    }

    DBG_EXIT_HRES(FTF_CPANEL, "COpenDeskCpl::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// CNavigateURL implementation
//--------------------------------------------------------------------------

CNavigateURL::CNavigateURL(
    LPCWSTR pszURL,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_pszURL(pszURL)
{
    ASSERT(NULL != pszURL);
}


HRESULT
CNavigateURL::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CNavigateURL::Execute");

    ASSERT(NULL != m_pszURL);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(hwndParent);

    TraceMsg(TF_CPANEL, "URL = \"%s\"", m_pszURL);

    IWebBrowser2 *pwb;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SWebBrowserApp, IID_IWebBrowser2, (void **)&pwb);
    if (SUCCEEDED(hr))
    {
        LPTSTR pszExpanded;
        hr = CPL::ExpandEnvironmentVars(m_pszURL, &pszExpanded);
        if (SUCCEEDED(hr))
        {
            VARIANT varURL;
            hr = InitVariantFromStr(&varURL, pszExpanded);
            if (SUCCEEDED(hr))
            {
                VARIANT varEmpty;
                VariantInit(&varEmpty);
                
                VARIANT varFlags;
                varFlags.vt      = VT_UINT;
                varFlags.uintVal = 0;
                
                hr = pwb->Navigate2(&varURL, &varFlags, &varEmpty, &varEmpty, &varEmpty);
                VariantClear(&varURL);
            }
            LocalFree(pszExpanded);
        }
        pwb->Release();
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CNavigateURL::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenTroubleshooter implementation
//--------------------------------------------------------------------------

COpenTroubleshooter::COpenTroubleshooter(
    LPCWSTR pszTs,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_pszTs(pszTs)
{
    ASSERT(NULL != pszTs);
}


HRESULT
COpenTroubleshooter::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenTroubleshooter::Execute");

    ASSERT(NULL != m_pszTs);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    WCHAR szPath[MAX_PATH];
    HRESULT hr = StringCchPrintfW(szPath, ARRAYSIZE(szPath), L"hcp://help/tshoot/%s", m_pszTs);
    if (SUCCEEDED(hr))
    {
        CNavigateURL actionURL(szPath);

        hr = actionURL.Execute(hwndParent, punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "COpenTroubleshooter::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// CShellExecute implementation
//--------------------------------------------------------------------------

CShellExecute::CShellExecute(
    LPCWSTR pszExe,
    LPCWSTR pszArgs,                // optional.  default = NULL.
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_pszExe(pszExe),
        m_pszArgs(pszArgs)
{
    ASSERT(NULL != pszExe);
}


HRESULT
CShellExecute::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CShellExecute::Execute");

    ASSERT(NULL != m_pszExe);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    TraceMsg(TF_CPANEL, "ShellExecute: \"%s %s\"", m_pszExe, m_pszArgs ? m_pszArgs : L"<no args>");

    SHELLEXECUTEINFOW sei = {
        sizeof(sei),           // cbSize;
        SEE_MASK_DOENVSUBST,   // fMask
        hwndParent,            // hwnd
        L"open",               // lpVerb
        m_pszExe,              // lpFile
        m_pszArgs,             // lpParameters
        NULL,                  // lpDirectory
        SW_SHOWNORMAL,         // nShow
        0,                     // hInstApp
        NULL,                  // lpIDList
        NULL,                  // lpClass
        NULL,                  // hkeyClass
        0,                     // dwHotKey
        NULL,                  // hIcon
        NULL                   // hProcess
    };

    HRESULT hr = S_OK;
    if (!ShellExecuteExW(&sei))
    {
        hr = ResultFromLastError();
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CShellExecute::Execute", hr);
    return THR(hr);
}


//--------------------------------------------------------------------------
// CShellExecuteSysDir implementation
// Simply wraps CShellExecute assuming that the EXE exists in the
// SYSTEM32 directory.
//--------------------------------------------------------------------------

CShellExecuteSysDir::CShellExecuteSysDir(
    LPCWSTR pszExe,
    LPCWSTR pszArgs,                // optional.  default = NULL.
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CShellExecute(pszExe, pszArgs, pRestrict)
{
    ASSERT(NULL != pszExe);
}


HRESULT
CShellExecuteSysDir::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CShellExecuteSysDir::Execute");

    ASSERT(NULL != m_pszExe);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    TraceMsg(TF_CPANEL, "ShellExecuteSysDir: \"%s %s\"", m_pszExe, m_pszArgs ? m_pszArgs : L"<no args>");

    //
    // Build a path consisting of the system directory and the 
    // EXE name.  i.e.:
    //
    //  "c:\windows\system32\myapp.exe"
    //
    WCHAR szExePath[MAX_PATH];
    HRESULT hr = AppendToSysDir(m_pszExe, szExePath, ARRAYSIZE(szExePath));
    if (SUCCEEDED(hr))
    {
        CShellExecute se(szExePath, m_pszArgs);
        hr = se.Execute(hwndParent, punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CShellExecuteSysDir::Execute", hr);
    return THR(hr);
}




//--------------------------------------------------------------------------
// CRundll32 implementation
// This is a simple wrapper around CShellExecute that saves an instance
// definition from having to type L"%SystemRoot%\\system32\\rundll32.exe".
//--------------------------------------------------------------------------

CRunDll32::CRunDll32(
    LPCWSTR pszArgs,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_pszArgs(pszArgs)
{
    ASSERT(NULL != pszArgs);
}


HRESULT
CRunDll32::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CRunDll32::Execute");

    ASSERT(NULL != m_pszArgs);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    TraceMsg(TF_CPANEL, "CRunDll32: \"%s\"", m_pszArgs);

    WCHAR szPath[MAX_PATH];
    HRESULT hr = AppendToSysDir(L"rundll32.exe", szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr))
    {
        CShellExecute se(szPath, m_pszArgs);
        hr = se.Execute(hwndParent, punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CRunDll32::Execute", hr);
    return THR(hr);
}



    
//--------------------------------------------------------------------------
// CExecDiskUtil implementation
//--------------------------------------------------------------------------

CExecDiskUtil::CExecDiskUtil(
    eDISKUTILS eUtil,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_eUtil(eUtil)
{
    ASSERT(eDISKUTIL_NUMUTILS > m_eUtil);
}


HRESULT
CExecDiskUtil::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CExecDiskUtil::Execute");
    TCHAR szValue[MAX_PATH];
    DWORD dwType;
    DWORD cbValue = sizeof(szValue);

    //
    // These strings must remain in sync with the eDISKUTILS enumeration.
    //
    static LPCTSTR rgpszRegNames[] = {
        TEXT("MyComputer\\backuppath"),  // eDISKUTIL_BACKUP
        TEXT("MyComputer\\defragpath"),  // eDISKUTIL_DEFRAG
        TEXT("MyComputer\\cleanuppath"), // eDISKUTIL_CLEANUP
    };

    HRESULT hr = SKGetValue(SHELLKEY_HKLM_EXPLORER, 
                            rgpszRegNames[int(m_eUtil)], 
                            NULL, 
                            &dwType, 
                            szValue, 
                            &cbValue);
    if (SUCCEEDED(hr))
    {
        LPTSTR pszExpanded = NULL;
        //
        // Expand environment strings.
        // According to the code in shell32\drvx.cpp, some apps
        // use embedded env vars even if the value type is REG_SZ.
        //
        hr = CPL::ExpandEnvironmentVars(szValue, &pszExpanded);
        if (SUCCEEDED(hr))
        {
            //
            // The drive utility command strings were designed to be
            // invoked from the drives property page.  They therefore
            // accept a drive letter.  Since control panel launches
            // the utilities for no particular drive, we need to remove
            // the "%c:" format specifier.
            //
            hr = _RemoveDriveLetterFmtSpec(pszExpanded);
            if (SUCCEEDED(hr))
            {
                TCHAR szArgs[MAX_PATH] = {0};
                PathRemoveBlanks(pszExpanded);
                hr = PathSeperateArgs(pszExpanded, szArgs, ARRAYSIZE(szArgs), NULL);
                if (SUCCEEDED(hr))
                {
                    //
                    // Note that it's valid to use a NULL restriction here.
                    // If there's a restriction on the CExecDiskUtil object
                    // we won't get this far (i.e. Execute isn't called).
                    //
                    CShellExecute exec(pszExpanded, szArgs);
                    hr = exec.Execute(hwndParent, punkSite);
                }
            }
            LocalFree(pszExpanded);
        }
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CExecDiskUtil::Execute", hr);
    return THR(hr);
}


//
// The command line strings for the backup, defrag and disk cleanup utilities 
// can contain a format specifier for the drive letter.  That's because
// they're designed to be opened from a particular volume's "Tools" property
// page.  Control Panel launches these from outside the context of any particular
// volume.  Therefore, the drive letter is not available and the the format
// specifier is unused.  This function removes that format specifier if it exists.
//
// i.e.:  "c:\windows\system32\ntbackup.exe"        -> "c:\windows\system32\ntbackpu.exe"
//        "c:\windows\system32\cleanmgr.exe /D %c:" -> "c:\windows\system32\cleanmgr.exe"
//        "c:\windows\system32\defrg.msc %c:"       -> "c:\windows\system32\defrg.msc"
//
HRESULT
CExecDiskUtil::_RemoveDriveLetterFmtSpec(  // [static]
    LPTSTR pszCmdLine
    )
{
    LPCTSTR pszRead = pszCmdLine;
    LPTSTR pszWrite = pszCmdLine;

    while(*pszRead)
    {
        if (TEXT('%') == *pszRead && TEXT('c') == *(pszRead + 1))
        {
            //
            // Skip over the "%c" or "%c:" fmt specifier.
            //
            pszRead += 2;
            if (TEXT(':') == *pszRead)
            {
                pszRead++;
            }
        }
        if (*pszRead)
        {
            *pszWrite++ = *pszRead++;
        }
    }
    *pszWrite = *pszRead; // pick up null terminator.
    return S_OK;
}



//--------------------------------------------------------------------------
// COpenCplCategory implementation
//--------------------------------------------------------------------------

COpenCplCategory::COpenCplCategory(
    eCPCAT eCategory,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_eCategory(eCategory)
{

}



HRESULT
COpenCplCategory::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenCplCategory::Execute");
    TraceMsg(TF_CPANEL, "Category ID = %d", m_eCategory);

    ASSERT(NULL != punkSite);

    UNREFERENCED_PARAMETER(hwndParent);

    IShellBrowser *psb;
    HRESULT hr = CPL::ShellBrowserFromSite(punkSite, &psb);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFolder;
        hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlFolder);
        if (SUCCEEDED(hr))
        {
            WCHAR szCategory[10];
            hr = StringCchPrintfW(szCategory, ARRAYSIZE(szCategory), L"%d", m_eCategory);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlTemp = ILAppendHiddenStringW(pidlFolder, IDLHID_NAVIGATEMARKER, szCategory);
                if (NULL == pidlTemp)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pidlFolder = pidlTemp;
                    pidlTemp   = NULL;

                    hr = CPL::BrowseIDListInPlace(pidlFolder, psb);
                }
                ILFree(pidlFolder);
            }
        }
        psb->Release();
    }
    DBG_EXIT_HRES(FTF_CPANEL, "COpenCplCategory::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenCplCategory2 implementation
//--------------------------------------------------------------------------

COpenCplCategory2::COpenCplCategory2(
    eCPCAT eCategory,
    const IAction *pDefAction,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_eCategory(eCategory),
        m_pDefAction(pDefAction)
{

}



HRESULT
COpenCplCategory2::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenCplCategory2::Execute");
    TraceMsg(TF_CPANEL, "Category ID = %d", m_eCategory);

    ASSERT(NULL != punkSite);

    bool bOpenCategory = false;
    HRESULT hr = _ExecuteActionOnSingleCplApplet(hwndParent, punkSite, &bOpenCategory);
    if (SUCCEEDED(hr))
    {
        if (bOpenCategory)
        {
            //
            // Category has more than one CPL.
            // Open the category page.
            //
            COpenCplCategory action(m_eCategory);
            hr = action.Execute(hwndParent, punkSite);
        }
    }
    DBG_EXIT_HRES(FTF_CPANEL, "COpenCplCategory2::Execute", hr);
    return THR(hr);
}



HRESULT
COpenCplCategory2::_ExecuteActionOnSingleCplApplet(
    HWND hwndParent,
    IUnknown *punkSite,
    bool *pbOpenCategory    // optional.  Can be NULL
    ) const
{
    DBG_ENTER(FTF_CPANEL, "COpenCplCategory2::_ExecuteActionOnSingleCplApplet");

    bool bOpenCategory = true;
    ICplView *pview;
    HRESULT hr = CPL::ControlPanelViewFromSite(punkSite, &pview);
    if (SUCCEEDED(hr))
    {   
        IServiceProvider *psp;
        hr = pview->QueryInterface(IID_IServiceProvider, (void **)&psp);
        if (SUCCEEDED(hr))
        {
            ICplNamespace *pns;
            hr = psp->QueryService(SID_SControlPanelView, IID_ICplNamespace, (void **)&pns);
            if (SUCCEEDED(hr))
            {
                ICplCategory *pCategory;
                hr = pns->GetCategory(m_eCategory, &pCategory);
                if (SUCCEEDED(hr))
                {
                    IEnumUICommand *penum;
                    hr = pCategory->EnumCplApplets(&penum);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // See if the category has more than one CPL applet
                        // assigned to it.  
                        //
                        ULONG cApplets = 0;
                        IUICommand *rgpuic[2] = {0};
                        if (SUCCEEDED(hr = penum->Next(ARRAYSIZE(rgpuic), rgpuic, &cApplets)))
                        {
                            for (int i = 0; i < ARRAYSIZE(rgpuic); i++)
                            {
                                ATOMICRELEASE(rgpuic[i]);
                            }
                            if (2 > cApplets)
                            {
                                //
                                // There's zero or one CPLs registered for this category.
                                // Simply execute the default action.  If there's one
                                // we assume it's the "default" applet (i.e. ARP or
                                // User Accounts).
                                //
                                hr =  m_pDefAction->IsRestricted(pns);
                                if (SUCCEEDED(hr))
                                {
                                    if (S_FALSE == hr)
                                    {
                                        bOpenCategory = false;
                                        hr = m_pDefAction->Execute(hwndParent, punkSite);
                                    }
                                    else
                                    {
                                        //
                                        // Default action is restricted.  
                                        // Open the category page.  Note that the
                                        // category page may be displayed as a 'barrier'
                                        // if no tasks or CPL applets are available.
                                        //
                                        ASSERT(bOpenCategory);
                                    }
                                }
                            }
                        }
                        penum->Release();
                    }
                    pCategory->Release();
                }
                pns->Release();
            }
            psp->Release();
        }
        pview->Release();
    }
    if (NULL != pbOpenCategory)
    {
        *pbOpenCategory = bOpenCategory;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "COpenCplCategory2::_ExecuteActionOnSingleCplApplet", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// COpenCplView implementation
//--------------------------------------------------------------------------

COpenCplView::COpenCplView(
    eCPVIEWTYPE eViewType,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_eViewType(eViewType)
{

}


HRESULT
COpenCplView::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    UNREFERENCED_PARAMETER(hwndParent);

    ASSERT(NULL != punkSite);

    HRESULT hr = _SetFolderBarricadeStatus();
    if (SUCCEEDED(hr))
    {
        IShellBrowser *psb;
        hr = CPL::ShellBrowserFromSite(punkSite, &psb);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlFolder;
            hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlFolder);
            if (SUCCEEDED(hr))
            {
                hr = CPL::BrowseIDListInPlace(pidlFolder, psb);
                ILFree(pidlFolder);
            }
            psb->Release();
        }
    }
    return THR(hr);
}


HRESULT
COpenCplView::_SetFolderBarricadeStatus(
    void
    ) const
{
    VARIANT_BOOL vtb = VARIANT_FALSE;
    if (eCPVIEWTYPE_CATEGORY == m_eViewType)
    {
        vtb = VARIANT_TRUE;
    }
    else
    {
        ASSERT(eCPVIEWTYPE_CLASSIC == m_eViewType);
    }

    HRESULT hr = CPL::SetControlPanelBarricadeStatus(vtb);
    return THR(hr);
}



//--------------------------------------------------------------------------
// CAddPrinter implementation
//--------------------------------------------------------------------------

CAddPrinter::CAddPrinter(
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict)
{

}



HRESULT
CAddPrinter::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    DBG_ENTER(FTF_CPANEL, "CAddPrinter::Execute");

    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    HRESULT hr = E_FAIL;
    if (SHInvokePrinterCommandW(hwndParent, 
                               PRINTACTION_OPEN, 
                               L"WinUtils_NewObject", 
                               NULL, 
                               FALSE))
    {
        //
        // Navigate to the printers folder after invoking the add-printer wizard.
        // This gives the user visual feedback when a printer is added.  We navigate
        // even if the user cancels the wizard because we cannot determine if the
        // wizard was cancelled.  We've determined this is acceptable.
        //
        CNavigateURL prnfldr(L"shell:::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{2227A280-3AEA-1069-A2DE-08002B30309D}");
        hr = prnfldr.Execute(hwndParent, punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CAddPrinter::Execute", hr);
    return THR(hr);
}



//--------------------------------------------------------------------------
// CTrayCommand implementation
//--------------------------------------------------------------------------

CTrayCommand::CTrayCommand(
    UINT idm,
    const CPL::IRestrict *pRestrict      // optional.  default = NULL
    ) : CAction(pRestrict),
        m_idm(idm)
{

}


HRESULT
CTrayCommand::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(punkSite);

    // APPHACK!  221008 DesktopX creates their own window with class
    // name "Shell_TrayWnd", so if we're not careful we will end
    // posting the messages to the wrong window.  They create their
    // window with the title "CTrayServer"; ours has a null title.
    // Use the null title to find the correct window.

    HWND hwndTray = FindWindowA(WNDCLASS_TRAYNOTIFY, "");
    if (hwndTray)
    {
        PostMessage(hwndTray, WM_COMMAND, m_idm, 0);
    }
    return S_OK;
}



//--------------------------------------------------------------------------
// CActionNYI implementation
//--------------------------------------------------------------------------

CActionNYI::CActionNYI(
    LPCWSTR pszText
    ) : m_pszText(pszText)
{

}


HRESULT
CActionNYI::Execute(
    HWND hwndParent,
    IUnknown *punkSite
    ) const
{
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    UNREFERENCED_PARAMETER(punkSite);

    HRESULT hr = E_OUTOFMEMORY;
    if (NULL != m_pszText)
    {
        MessageBoxW(hwndParent, m_pszText, L"Action Not Yet Implemented", MB_OK);
        hr = S_OK;
    }
    return THR(hr);
}



#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpaction.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpaction.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_ACTION_H
#define __CONTROLPANEL_ACTION_H


#include "cputil.h"
#include "cpnamespc.h"


namespace CPL {


//
// Restriction function must return an HRESULT with the following semantics.
//
//     S_FALSE    - Action not restricted.
//     S_OK       - Action restricted.
//     Failure    - Cannot determine.
//
typedef HRESULT (*PFNRESTRICT)(ICplNamespace *pns);


class IRestrict
{
    public:
        virtual ~IRestrict(void) { }

        virtual HRESULT IsRestricted(ICplNamespace *pns) const = 0;

};


class CRestrictFunc : public IRestrict
{
    public:
        CRestrictFunc(PFNRESTRICT pfnRestrict)
            : m_pfnRestrict(pfnRestrict) { }

        HRESULT IsRestricted(ICplNamespace *pns) const
            { return (*m_pfnRestrict)(pns); }

    private:
        PFNRESTRICT m_pfnRestrict;
};



class CRestrictApplet : public IRestrict
{
    public:
        CRestrictApplet(LPCWSTR pszFile, LPCWSTR pszApplet)
            : m_pszFile(pszFile),
              m_pszApplet(pszApplet) { }

        HRESULT IsRestricted(ICplNamespace *pns) const;

    private:
        LPCWSTR m_pszFile;
        LPCWSTR m_pszApplet;
};


//
// Class IAction abstractly represents an action to perform.
//
// The intent is to associate an action object with a particular link
// object in the Control Panel UI.  This decoupling makes it easy to 
// change the action associated with a link.  It also allows us to 
// easily associate an action with multiple links as well as a 
// 'restriction' with a particular action.  As a result of this
// Link->Action->Restriction relationship, we can hide a link if it's
// action is restricted.  The link needs to know only about the 
// action and nothing about the restriction.
//
class IAction
{
    public:
        virtual HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const = 0;
        virtual HRESULT IsRestricted(ICplNamespace *pns) const = 0;
};


class CAction : public IAction
{
    public:
        CAction(const IRestrict *pRestrict = NULL);
        HRESULT IsRestricted(ICplNamespace *pns) const;

    private:
        const IRestrict *m_pRestrict;
};


class COpenCplCategory : public CAction
{
    public:
        explicit COpenCplCategory(eCPCAT eCategory, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        eCPCAT m_eCategory;
};


//
// This class is similar to COpenCplCategory except that it first checks to see if
// the category has only one CPL applet and no tasks.  If this is the case,
// the action is automatically forwarded to the single CPL applet.  The initial
// requirement for this is to support the addition of keymgr.cpl to the "User Accounts"
// category, however keymgr may not be present on all SKUs.  Therefore, when keymgr
// is present, we will display the category page containing both the User Accounts CPL
// and the KeyMgr CPL.  If User Accounts CPL is the only CPL in this category, we simply
// launch it.
//
class COpenCplCategory2 : public CAction
{
    public:
        explicit COpenCplCategory2(eCPCAT eCategory, const IAction *pDefAction, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        eCPCAT         m_eCategory;
        const IAction *m_pDefAction;

        HRESULT _ExecuteActionOnSingleCplApplet(HWND hwndParent, IUnknown *punkSite, bool *pbOpenCategory) const;
};


class COpenUserMgrApplet : public CAction
{
    public:
        explicit COpenUserMgrApplet(const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;
};


class COpenCplApplet : public CAction
{
    public:
        explicit COpenCplApplet(LPCWSTR pszApplet, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    protected:
        LPCWSTR m_pszApplet;
};

//
// Minor extension of COpenCplApplet that assumes the applet is in 
// %SystemRoot%\System32 directory.
//
class COpenCplAppletSysDir : public COpenCplApplet
{
    public:
        explicit COpenCplAppletSysDir(LPCWSTR pszApplet, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;
};


class COpenDeskCpl : public CAction
{
    public:
        explicit COpenDeskCpl(eDESKCPLTAB eCplTab, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        eDESKCPLTAB m_eCplTab;
};


class CShellExecute : public CAction
{
    public:
        explicit CShellExecute(LPCWSTR pszExe, LPCWSTR pszArgs = NULL, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    protected:
        LPCWSTR m_pszExe;
        LPCWSTR m_pszArgs;
};


//
// Minor extension of CShellExecute that assumes the EXE is in 
// %SystemRoot%\System32 directory.
//
class CShellExecuteSysDir : public CShellExecute
{
    public:
        explicit CShellExecuteSysDir(LPCWSTR pszExe, LPCWSTR pszArgs = NULL, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;
};


class CRunDll32 : public CAction
{
    public:
        explicit CRunDll32(LPCWSTR pszArgs, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        LPCWSTR m_pszArgs;
};


enum eDISKUTILS { 
    eDISKUTIL_BACKUP, 
    eDISKUTIL_DEFRAG, 
    eDISKUTIL_CLEANUP,
    eDISKUTIL_NUMUTILS 
    };
    
class CExecDiskUtil : public CAction
{
    public:
        explicit CExecDiskUtil(eDISKUTILS util, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        eDISKUTILS m_eUtil;

        static HRESULT _RemoveDriveLetterFmtSpec(LPTSTR pszCmdLine);
};


class CNavigateURL : public CAction
{
    public:
        explicit CNavigateURL(LPCWSTR pszURL, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        LPCWSTR m_pszURL;
};


class COpenTroubleshooter : public CAction
{
    public:
        explicit COpenTroubleshooter(LPCWSTR pszTs, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        LPCWSTR m_pszTs;
};

class COpenCplView : public CAction
{
    public:
        explicit COpenCplView(eCPVIEWTYPE eViewType, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        eCPVIEWTYPE m_eViewType;

        HRESULT _SetFolderBarricadeStatus(void) const;

};


class CTrayCommand : public CAction
{
    public:
        explicit CTrayCommand(UINT idm, const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        UINT m_idm;
};


class CAddPrinter : public CAction
{
    public:
        explicit CAddPrinter(const IRestrict *pRestrict = NULL);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;
};


class CActionNYI : public CAction
{
    public:
        explicit CActionNYI(LPCWSTR pszText);
        HRESULT Execute(HWND hwndParent, IUnknown *punkSite) const;

    private:
        LPCWSTR m_pszText;
};


} // namespace CPL





#endif // __CONTROLPANEL_ACTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\copyhook.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "copy.h"

UINT DefView_CopyHook(const COPYHOOKINFO *pchi);
int PathCopyHookCallback(HWND hwnd, UINT wFunc, LPCTSTR pszSrc, LPCTSTR pszDest);

void _CopyHookTerminate(HDSA hdsaCopyHooks, BOOL fProcessDetach);

typedef struct {
    ICopyHook * pcphk;              // Either ICopyHookA *or LPCOPYHOOK
    BOOL        fAnsiCrossOver;     // TRUE for ICopyHookA *on UNICODE build
} CALLABLECOPYHOOK;

typedef struct
{
    ICopyHook           cphk;
    ICopyHookA          cphkA;
    LONG                cRef;
} CCopyHook;

STDMETHODIMP_(ULONG) CCopyHook_AddRef(ICopyHook *pcphk);	// forward


STDMETHODIMP CCopyHook_QueryInterface(ICopyHook *pcphk, REFIID riid, void **ppvObj)
{
    CCopyHook *this = IToClass(CCopyHook, cphk, pcphk);
    if (IsEqualIID(riid, &IID_IShellCopyHook) || 
        IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = pcphk;
    }
    else if (IsEqualIID(riid, &IID_IShellCopyHookA))
    {
        *ppvObj = &this->cphkA;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    CCopyHook_AddRef(&this->cphk);
    return NOERROR;
}

STDMETHODIMP_(ULONG) CCopyHook_AddRef(ICopyHook *pcphk)
{
    CCopyHook *this = IToClass(CCopyHook, cphk, pcphk);
    return InterlockedIncrement(&this->cRef);
}

STDMETHODIMP_(ULONG) CCopyHook_Release(ICopyHook *pcphk)
{
    CCopyHook *this = IToClass(CCopyHook, cphk, pcphk);
    ULONG cRef;

    ASSERT( 0 != this->cRef );
    cRef = InterlockedDecrement(&this->cRef);
    if ( 0 == cRef )
    {
        LocalFree((HLOCAL)this);
    }
    return cRef;
}

STDMETHODIMP_(UINT) CCopyHook_CopyCallback(ICopyHook *pcphk, HWND hwnd, UINT wFunc, UINT wFlags, 
    LPCTSTR pszSrcFile, DWORD dwSrcAttribs, LPCTSTR pszDestFile, DWORD dwDestAttribs)
{
    COPYHOOKINFO chi = { hwnd, wFunc, wFlags, pszSrcFile, dwSrcAttribs, pszDestFile, dwDestAttribs };
    
    DebugMsg(DM_TRACE, TEXT("Event = %d, File = %s , %s"), wFunc, pszSrcFile,
        Dbg_SafeStr(pszDestFile));
    
    // check Special Folders first...
    if (PathCopyHookCallback(hwnd, wFunc, pszSrcFile, pszDestFile) == IDNO)
    {
        return IDNO;
    }
    
    if (wFunc != FO_COPY && !(wFlags & FOF_NOCONFIRMATION))
    {
        TCHAR szShortName[MAX_PATH];
        BOOL fInReg = (RLIsPathInList(pszSrcFile) != -1);
        BOOL fInBitBucket = IsFileInBitBucket(pszSrcFile);
        UINT iLength = GetShortPathName(pszSrcFile, szShortName, ARRAYSIZE(szShortName));
        
        // Don't double search for names that are the same (or already found)
        if (iLength != 0 && lstrcmpi(pszSrcFile, szShortName) != 0)
        {
            if (!fInReg)
                fInReg = (RLIsPathInList(szShortName) != -1);
            if (!fInBitBucket)
                fInBitBucket = IsFileInBitBucket(szShortName);
        }
        
        if (fInReg && !fInBitBucket)
        {
            LPCTSTR pszSpec = PathFindFileName(pszSrcFile);
            return ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_RENAMEFILESINREG),
                pszSpec, MB_YESNO | MB_ICONEXCLAMATION, pszSpec);
        }
    }
    return DefView_CopyHook(&chi);
}

ICopyHookVtbl c_CCopyHookVtbl = {
    CCopyHook_QueryInterface, CCopyHook_AddRef, CCopyHook_Release,
    CCopyHook_CopyCallback,
};

STDMETHODIMP CCopyHookA_QueryInterface(ICopyHookA *pcphkA, REFIID riid, void **ppvObj)
{
    CCopyHook *this = IToClass(CCopyHook, cphkA, pcphkA);
    return CCopyHook_QueryInterface(&this->cphk,riid,ppvObj);
}

STDMETHODIMP_(ULONG) CCopyHookA_AddRef(ICopyHookA *pcphkA)
{
    CCopyHook *this = IToClass(CCopyHook, cphkA, pcphkA);
    return CCopyHook_AddRef(&this->cphk);
}

STDMETHODIMP_(ULONG) CCopyHookA_Release(ICopyHookA *pcphkA)
{
    CCopyHook *this = IToClass(CCopyHook, cphkA, pcphkA);
    return CCopyHook_Release(&this->cphk);
}

STDMETHODIMP_(UINT) CCopyHookA_CopyCallback(ICopyHookA *pcphkA, HWND hwnd, UINT wFunc, UINT wFlags, 
    LPCSTR pszSrcFile, DWORD dwSrcAttribs, LPCSTR pszDestFile, DWORD dwDestAttribs)
{
    WCHAR szSrcFileW[MAX_PATH];
    WCHAR szDestFileW[MAX_PATH];
    LPWSTR pszSrcFileW = NULL;
    LPWSTR pszDestFileW = NULL;
    CCopyHook *this = IToClass(CCopyHook, cphkA, pcphkA);

    if (pszSrcFile)
    {
        SHAnsiToUnicode(pszSrcFile, szSrcFileW, ARRAYSIZE(szSrcFileW));
        pszSrcFileW = szSrcFileW;
    }

    if (pszDestFile)
    {
        SHAnsiToUnicode(pszDestFile, szDestFileW, ARRAYSIZE(szDestFileW));
        pszDestFileW = szDestFileW;
    }

    return CCopyHook_CopyCallback(&this->cphk, hwnd, wFunc, wFlags,
                                         pszSrcFileW, dwSrcAttribs,
                                         pszDestFileW, dwDestAttribs);
}

ICopyHookAVtbl c_CCopyHookAVtbl = {
    CCopyHookA_QueryInterface, CCopyHookA_AddRef, CCopyHookA_Release,
    CCopyHookA_CopyCallback,
};


STDAPI SHCreateShellCopyHook(ICopyHook **pcphkOut, REFIID riid)
{
    HRESULT hres = E_OUTOFMEMORY;      // assume error;
    CCopyHook *pcphk = (void*)LocalAlloc(LPTR, SIZEOF(CCopyHook));
    if (pcphk)
    {
        pcphk->cphk.lpVtbl = &c_CCopyHookVtbl;
        pcphk->cphkA.lpVtbl = &c_CCopyHookAVtbl;
        pcphk->cRef = 1;
        hres = CCopyHook_QueryInterface(&pcphk->cphk, riid, pcphkOut);
        CCopyHook_Release(&pcphk->cphk);
    }
    return hres;
}

HRESULT CCopyHook_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return SHCreateShellCopyHook((ICopyHook **)ppv, riid);
}


// create the HDSA of copyhook objects

HDSA CreateCopyHooks(LPCTSTR pszKey)
{
    HDSA hdsaCopyHooks = DSA_Create(SIZEOF(CALLABLECOPYHOOK), 4);
    if (hdsaCopyHooks)
    {
        HKEY hk;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, pszKey, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hk))
        {
            int i;
            TCHAR szKey[128];

            // iterate through the subkeys
            for (i = 0; RegEnumKey(hk, i, szKey, ARRAYSIZE(szKey)) == ERROR_SUCCESS; ++i) 
            {
                TCHAR szCLSID[128];
                DWORD cb = sizeof(szCLSID);

                // for each subkey, get the class id and do a cocreateinstance
                if (SHRegGetValue(hk, szKey, NULL, SRRF_RT_REG_SZ, NULL, szCLSID, &cb) == ERROR_SUCCESS)
                {
                    IUnknown *punk;
                    HRESULT hres = SHExtCoCreateInstance(szCLSID, NULL, NULL, &IID_IUnknown, &punk);
                    if (SUCCEEDED(hres)) 
                    {
                        CALLABLECOPYHOOK cc;

                        SHPinDllOfCLSIDStr(szCLSID);

                        cc.pcphk = NULL;
                        cc.fAnsiCrossOver = FALSE;
                        hres = punk->lpVtbl->QueryInterface(punk, &IID_IShellCopyHook, &cc.pcphk);
                        if (SUCCEEDED(hres))
                        {
                            DSA_AppendItem(hdsaCopyHooks, &cc);
                        }
                        else
                        {
                            hres = punk->lpVtbl->QueryInterface(punk, &IID_IShellCopyHookA, &cc.pcphk);
                            if (SUCCEEDED(hres))
                            {
                                cc.fAnsiCrossOver = TRUE;
                                DSA_AppendItem(hdsaCopyHooks, &cc);
                            }
                        }
                        punk->lpVtbl->Release(punk);
                    }
                }
            }
            RegCloseKey(hk);
        }
    }
    return hdsaCopyHooks;
}

int CallCopyHooks(HDSA *phdsaHooks, LPCTSTR pszKey, HWND hwnd, UINT wFunc, FILEOP_FLAGS fFlags,
    LPCTSTR pszSrcFile, DWORD dwSrcAttribs, LPCTSTR pszDestFile, DWORD dwDestAttribs)
{
    int i;

    if (!*phdsaHooks)
    {
        HDSA hdsaTemp = CreateCopyHooks(pszKey);
        if (hdsaTemp == NULL)
            return IDYES;

        // we don't hold a CritSection when doing the above to avoid deadlocks,
        // now we need to atomicaly store our results. if someone beat us to this
        // we free the hdsa we created. SHInterlockedCompareExchange does this for us
        // letting us know where there is a race condition so we can free the dup copy
        if (SHInterlockedCompareExchange((void **)phdsaHooks, hdsaTemp, 0))
        {
            // some other thread raced with us, blow this away now
            _CopyHookTerminate(hdsaTemp, FALSE);
        }
    }

    for (i = DSA_GetItemCount(*phdsaHooks) - 1; i >= 0; i--) 
    {
        int iReturn;
        CALLABLECOPYHOOK *pcc = (CALLABLECOPYHOOK *)DSA_GetItemPtr(*phdsaHooks, i);
        if (!pcc->fAnsiCrossOver)
        {
            iReturn = pcc->pcphk->lpVtbl->CopyCallback(pcc->pcphk,
                hwnd, wFunc, fFlags, pszSrcFile, dwSrcAttribs, pszDestFile, dwDestAttribs);
        }
        else
        {
            CHAR szSrcFileA[MAX_PATH];
            CHAR szDestFileA[MAX_PATH];
            LPSTR pszSrcFileA = NULL;
            LPSTR pszDestFileA = NULL;
            ICopyHookA *pcphkA = (LPCOPYHOOKA)pcc->pcphk;

            if (pszSrcFile)
            {
                SHUnicodeToAnsi(pszSrcFile, szSrcFileA, ARRAYSIZE(szSrcFileA));
                pszSrcFileA = szSrcFileA;
            }
            if (pszDestFile)
            {
                SHUnicodeToAnsi(pszDestFile, szDestFileA, ARRAYSIZE(szDestFileA));
                pszDestFileA = szDestFileA;
            }
            iReturn = pcphkA->lpVtbl->CopyCallback(pcphkA,
                                       hwnd, wFunc, fFlags,
                                       pszSrcFileA, dwSrcAttribs,
                                       pszDestFileA, dwDestAttribs);
        }
        if (iReturn != IDYES)
            return iReturn;
    }
    return IDYES;
}

// These need to be per-instance since we are storing interfaces pointers
HDSA g_hdsaFileCopyHooks = NULL;
HDSA g_hdsaPrinterCopyHooks = NULL;

int CallFileCopyHooks(HWND hwnd, UINT wFunc, FILEOP_FLAGS fFlags,
    LPCTSTR pszSrcFile, DWORD dwSrcAttribs, LPCTSTR pszDestFile, DWORD dwDestAttribs)
{
    return CallCopyHooks(&g_hdsaFileCopyHooks, STRREG_SHEX_COPYHOOK, hwnd, 
        wFunc, fFlags, pszSrcFile, dwSrcAttribs, pszDestFile, dwDestAttribs);
}

int CallPrinterCopyHooks(HWND hwnd, UINT wFunc, PRINTEROP_FLAGS fFlags,
    LPCTSTR pszSrcPrinter, DWORD dwSrcAttribs, LPCTSTR pszDestPrinter, DWORD dwDestAttribs)
{
    return CallCopyHooks(&g_hdsaPrinterCopyHooks, STRREG_SHEX_PRNCOPYHOOK, hwnd, 
        wFunc, fFlags, pszSrcPrinter, dwSrcAttribs, pszDestPrinter, dwDestAttribs);
}

//
// We will only call this on process detach, and these are per-process
// globals, so we do not need a critical section here
//
//  This function is also called from CreateCopyHooks when the second
// thread is cleaning up its local hdsaCopyHoos, which does not require
// a critical section either.
//
void _CopyHookTerminate(HDSA hdsaCopyHooks, BOOL fProcessDetach)
{
    //  Note that we must no call any of virtual functions when we are
    // processing PROCESS_DETACH signal, because the DLL might have been
    // already unloaded before shell32. We just hope that they don't
    // allocate any global thing to be cleaned. USER does the same thing
    // with undestroyed window. It does not send call its window procedure
    // when it is destroying an undestroyed window within its PROCESS_DETACH
    // code. (SatoNa/DavidDS)
    //
    if (!fProcessDetach)
    {
        int i;
        for (i = DSA_GetItemCount(hdsaCopyHooks) - 1; i >= 0; i--) 
        {
            CALLABLECOPYHOOK *pcc = (CALLABLECOPYHOOK *)DSA_GetItemPtr(hdsaCopyHooks, i);
            pcc->pcphk->lpVtbl->Release(pcc->pcphk);
        }
    }

    DSA_Destroy(hdsaCopyHooks);
}


// called from ProcessDetatch
// NOTE: we are seralized at this point, don't need critical sections

void CopyHooksTerminate(void)
{
    ASSERTDLLENTRY;      // does not require a critical section

    if (g_hdsaFileCopyHooks)
    {
        _CopyHookTerminate(g_hdsaFileCopyHooks, TRUE);
        g_hdsaFileCopyHooks = NULL;
    }

    if (g_hdsaPrinterCopyHooks)
    {
        _CopyHookTerminate(g_hdsaPrinterCopyHooks, TRUE);
        g_hdsaPrinterCopyHooks = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpduihlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpduihlp.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_DUIHELPERS_H
#define __CONTROLPANEL_DUIHELPERS_H

#include "cpviewp.h"

namespace CPL {


HRESULT Dui_FindDescendent(DUI::Element *pe, LPCWSTR pszDescendent, DUI::Element **ppeDescendent);
HRESULT Dui_GetStyleSheet(DUI::Parser *pParser, LPCWSTR pszSheet, DUI::Value **ppvSheet);
HRESULT Dui_SetElementText(DUI::Element *peElement, LPCWSTR pszText);
HRESULT Dui_SetDescendentElementText(DUI::Element *peElement, LPCWSTR pszDescendent, LPCWSTR pszText);
HRESULT Dui_SetDescendentElementIcon(DUI::Element *peElement, LPCWSTR pszDescendent, HICON hIcon);
HRESULT Dui_CreateElement(DUI::Parser *pParser, LPCWSTR pszTemplate, DUI::Element *peSubstitute, DUI::Element **ppe);
HRESULT Dui_DestroyDescendentElement(DUI::Element *pe, LPCWSTR pszDescendent);
HRESULT Dui_CreateString(LPCWSTR pszText, DUI::Value **ppvString);
HRESULT Dui_CreateGraphic(HICON hIcon, DUI::Value **ppValue);
HRESULT Dui_GetElementExtent(DUI::Element *pe, SIZE *pext);
HRESULT Dui_GetElementRootHWND(DUI::Element *pe, HWND *phwnd);
HRESULT Dui_SetElementIcon(DUI::Element *pe, HICON hIcon);
HRESULT Dui_MapElementPointToRootHWND(DUI::Element *pe, const POINT& ptElement, POINT *pptRoot, HWND *phwndRoot = NULL);
HRESULT Dui_CreateParser(const char *pszUiFile, int cchUiFile, HINSTANCE hInstance, DUI::Parser **ppParser);


inline HRESULT
Dui_SetValue(
    DUI::Element *pe,
    DUI::PropertyInfo *ppi,
    DUI::Value *pv
    )
{
    return pe->SetValue(ppi, PI_Local, pv);
}

#define Dui_SetElementProperty(pe, prop, pv) Dui_SetValue((pe), DUI::Element::##prop, (pv))

inline HRESULT 
Dui_SetElementStyleSheet(
    DUI::Element *pe, 
    DUI::Value *pvSheet
    )
{
    return Dui_SetElementProperty(pe, SheetProp, pvSheet);
}


struct ATOMINFO
{
    LPCWSTR pszName;
    ATOM *pAtom;
};


HRESULT Dui_AddAtom(LPCWSTR pszName, ATOM *pAtom);
HRESULT Dui_DeleteAtom(ATOM atom);
HRESULT Dui_AddOrDeleteAtoms(struct ATOMINFO *pAtomInfo, UINT cEntries, bool bAdd);
inline HRESULT Dui_AddAtoms(struct ATOMINFO *pAtomInfo, UINT cEntries)
{
    return Dui_AddOrDeleteAtoms(pAtomInfo, cEntries, true);
}
inline HRESULT Dui_DeleteAtoms(struct ATOMINFO *pAtomInfo, UINT cEntries)
{
    return Dui_AddOrDeleteAtoms(pAtomInfo, cEntries, true);
}



//
// This is a simple smart-pointer class for DUI::Value pointers.
// It's important that the referenced DUI::Value object be released when the
// pointer is no longer needed.  Use of this class ensures proper cleanup
// when the object goes out of scope.
//
class CDuiValuePtr
{
    public:
        CDuiValuePtr(DUI::Value *pv = NULL)
            : m_pv(pv),
              m_bOwns(true) { }

        CDuiValuePtr(const CDuiValuePtr& rhs)
            : m_bOwns(false),
              m_pv(NULL) { Attach(rhs.Detach()); }

        CDuiValuePtr& operator = (const CDuiValuePtr& rhs);

        ~CDuiValuePtr(void)
            { _Release(); }

        DUI::Value *Detach(void) const;

        void Attach(DUI::Value *pv);

        DUI::Value **operator & ()
            { ASSERTMSG(NULL == m_pv, "Attempt to overwrite non-NULL pointer value"); 
               m_bOwns = true; 
               return &m_pv; 
            }

        operator !() const
            { return NULL == m_pv; }

        bool IsNULL(void) const
            { return NULL == m_pv; }

        operator const DUI::Value*() const
            { return m_pv; }

        operator DUI::Value*()
            { return m_pv; }

    private:
        mutable DUI::Value *m_pv;
        mutable bool       m_bOwns;

        void _Release(void);
};


} // namespace CPL


#endif // __CONTROLPANEL_DUIHELPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpduihlp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpduihlp.cpp
//
//--------------------------------------------------------------------------
#include "shellprv.h"
#include <uxtheme.h>
#include "cpviewp.h"
#include "cpduihlp.h"
#include "cputil.h"


HRESULT 
CPL::Dui_AddAtom(
    LPCWSTR pszName, 
    ATOM *pAtom
    )
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pAtom);
    ASSERT(!IsBadWritePtr(pAtom, sizeof(*pAtom)));

    HRESULT hr = S_OK;
    *pAtom = AddAtomW(pszName);
    if (0 == *pAtom)
    {
        hr = ResultFromLastError();
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_DeleteAtom(
    ATOM atom
    )
{
    HRESULT hr = S_OK;
    if (0 != atom)
    {
        if (0 != DeleteAtom(atom))
        {
            hr = ResultFromLastError();
        }
    }
    return THR(hr);
}



HRESULT
CPL::Dui_AddOrDeleteAtoms(
    struct CPL::ATOMINFO *pAtomInfo,
    UINT cEntries,
    bool bAdd
    )
{
    ASSERT(NULL != pAtomInfo);
    HRESULT hr = S_OK;
    for (UINT i = 0; i < cEntries && SUCCEEDED(hr); i++)
    {
        if (bAdd)
        {
            ASSERT(0 == *(pAtomInfo->pAtom));
            hr = Dui_AddAtom(pAtomInfo->pszName, pAtomInfo->pAtom);
        }
        else
        {
            if (0 != *(pAtomInfo->pAtom))
            {
                Dui_DeleteAtom(*(pAtomInfo->pAtom));
            }
        }
        pAtomInfo++;
    }
    return THR(hr);
}



HRESULT
CPL::Dui_FindDescendent(
    DUI::Element *pe,
    LPCWSTR pszDescendent,
    DUI::Element **ppeDescendent
    )
{
    HRESULT hr = E_FAIL;
    DUI::Element *peDescendent = pe->FindDescendent(DUI::StrToID(pszDescendent));
    if (NULL != peDescendent)
    {
        *ppeDescendent = peDescendent;
        hr = S_OK;
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_DestroyDescendentElement(
    DUI::Element *pe, 
    LPCWSTR pszDescendent
    )
{
    HRESULT hr = E_FAIL;
    DUI::Element *peDescendent = pe->FindDescendent(DUI::StrToID(pszDescendent));
    if (NULL != peDescendent)
    {
        hr = peDescendent->Destroy();
    }
    return THR(hr);
}


HRESULT
CPL::Dui_CreateElement(
    DUI::Parser *pParser,
    LPCWSTR pszTemplate,
    DUI::Element *peSubstitute,
    DUI::Element **ppe
    )
{
    DUI::Element *pe = NULL;
    HRESULT hr = pParser->CreateElement(pszTemplate, peSubstitute, &pe);
    if (SUCCEEDED(hr))
    {
        //
        // ISSUE-2000/12/22-BrianAu  DUI bug.
        //   DUI::Parser::CreateElement will return S_OK if 
        //   the element doesn't exist.  I've notified MarkFi
        //   about the issue.  I think he'll fix it.
        //
        if (NULL == pe)
        {
            ASSERT(0 && "DUI::Parser::CreateElement returned S_OK for non-existent element");
            hr = E_FAIL;
        }
    }
    *ppe = pe;
    return THR(hr);
}



HRESULT 
CPL::Dui_GetStyleSheet(
    DUI::Parser *pParser, 
    LPCWSTR pszSheet,
    DUI::Value **ppvSheet
    )
{
    HRESULT hr = E_FAIL;
    DUI::Value *pvSheet = pParser->GetSheet(pszSheet);
    if (NULL != pvSheet)
    {
        *ppvSheet = pvSheet;
        hr = S_OK;
    }
    return THR(hr);
}



HRESULT
CPL::Dui_CreateString(
    LPCWSTR pszText,
    DUI::Value **ppvString
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    HINSTANCE hInstance = NULL;
    if (IS_INTRESOURCE(pszText))
    {
        hInstance = HINST_THISDLL;
    }
    DUI::Value *pvString = DUI::Value::CreateString(pszText, hInstance);
    if (NULL != pvString)
    {
        *ppvString = pvString;
        hr = S_OK;
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_SetElementText(
    DUI::Element *peElement,
    LPCWSTR pszText
    )
{
    CPL::CDuiValuePtr  pvString;
    HRESULT hr = CPL::Dui_CreateString(pszText, &pvString);
    if (SUCCEEDED(hr))
    {
        hr = CPL::Dui_SetElementProperty(peElement, ContentProp, pvString);
    }
    return THR(hr);
}



HRESULT 
CPL::Dui_SetDescendentElementText(
    DUI::Element *peElement, 
    LPCWSTR pszDescendent,
    LPCWSTR pszText
    )
{
    DUI::Element *peDescendent;
    HRESULT hr = CPL::Dui_FindDescendent(peElement, pszDescendent, &peDescendent);
    if (SUCCEEDED(hr))
    {
        hr = CPL::Dui_SetElementText(peDescendent, pszText);
    }
    return THR(hr);
}


//
// Retrieve the width and height of an element.
//
HRESULT
CPL::Dui_GetElementExtent(
    DUI::Element *pe,
    SIZE *pext
    )
{
    HRESULT hr = E_FAIL;
    CPL::CDuiValuePtr pv;
    *pext = *(pe->GetExtent(&pv));
    if (!pv.IsNULL())
    {
        hr = S_OK;
    }
    return THR(hr);
}

HRESULT 
CPL::Dui_CreateGraphic(
    HICON hIcon, 
    DUI::Value **ppValue
    )
{
    HRESULT hr = E_OUTOFMEMORY;

    DUI::Value *pvGraphic;
    pvGraphic = DUI::Value::CreateGraphic(hIcon);
    if (NULL != pvGraphic)
    {
        *ppValue = pvGraphic;
        hr = S_OK;
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_SetElementIcon(
    DUI::Element *pe, 
    HICON hIcon
    )
{
    CPL::CDuiValuePtr pvGraphic;
    HRESULT hr = CPL::Dui_CreateGraphic(hIcon, &pvGraphic);
    if (SUCCEEDED(hr))
    {
        hr = CPL::Dui_SetElementProperty(pe, ContentProp, pvGraphic);
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_SetDescendentElementIcon(
    DUI::Element *peElement, 
    LPCWSTR pszDescendent, 
    HICON hIcon
    )
{
    DUI::Element *peDescendent;
    HRESULT hr = CPL::Dui_FindDescendent(peElement, pszDescendent, &peDescendent);
    if (SUCCEEDED(hr))
    {
        hr = CPL::Dui_SetElementIcon(peDescendent, hIcon);
    }
    return THR(hr);
}


HRESULT 
CPL::Dui_GetElementRootHWND(
    DUI::Element *pe, 
    HWND *phwnd
    )
{
    HRESULT hr = E_FAIL;
    const HWND hwnd = ((DUI::HWNDElement *)pe->GetRoot())->GetHWND();
    if (NULL != hwnd)
    {
        hr = S_OK;
    }
    *phwnd = hwnd;
    return THR(hr);
}


HRESULT
CPL::Dui_MapElementPointToRootHWND(
    DUI::Element *pe,
    const POINT& ptElement,
    POINT *pptRoot,
    HWND *phwndRoot            // Optional.  Default == NULL;
    )
{
    HWND hwndRoot;
    HRESULT hr = CPL::Dui_GetElementRootHWND(pe, &hwndRoot);
    if (SUCCEEDED(hr))
    {
        pe->GetRoot()->MapElementPoint(pe, &ptElement, pptRoot);
        if (NULL != phwndRoot)
        {
            *phwndRoot = hwndRoot;
        }
        hr = S_OK;
    }
    return THR(hr);
}


void CALLBACK
Dui_ParserErrorCallback(
    LPCWSTR pszError,
    LPCWSTR pszToken,
    int iLine
    )
{
    WCHAR szBuffer[1024];
    if (-1 != iLine)
    {
        StringCchPrintfW(szBuffer, ARRAYSIZE(szBuffer), L"%s '%s' at line %d.", pszError, pszToken, iLine);
    }
    else
    {
        StringCchPrintfW(szBuffer, ARRAYSIZE(szBuffer), L"%s '%s'", pszError, pszToken);
    }
    MessageBoxW(NULL, szBuffer, L"DUI Parser Message", MB_OK | MB_ICONERROR);
}



HRESULT
CPL::Dui_CreateParser(
    const char *pszUiFile,
    int cchUiFile,
    HINSTANCE hInstance,
    DUI::Parser **ppParser
    )
{
    ASSERT(NULL != pszUiFile);
    ASSERT(!IsBadStringPtrA(pszUiFile, cchUiFile));
    ASSERT(NULL != ppParser);
    ASSERT(!IsBadWritePtr(ppParser, sizeof(*ppParser)));

    HRESULT hr = E_FAIL;
    DUI::Parser *pParser;
    HANDLE arHandles[2];

    arHandles[0] = hInstance;
    arHandles[1] = OpenThemeData(NULL, L"Scrollbar");

    DUI::Parser::Create(pszUiFile, cchUiFile, arHandles, Dui_ParserErrorCallback, &pParser);

    if (NULL != pParser)
    {
        if (!pParser->WasParseError())
        {
            hr = S_OK;
        }
        else
        {
            pParser->Destroy();
            pParser = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (arHandles[1])
    {
        CloseThemeData (arHandles[1]);
    }

    *ppParser = pParser;
    return THR(hr);
}




//-----------------------------------------------------------------------------
// CDuiValuePtr
//-----------------------------------------------------------------------------

CPL::CDuiValuePtr& 
CPL::CDuiValuePtr::operator = (
    const CDuiValuePtr& rhs
    )
{
    if (this != &rhs)
    {
        Attach(rhs.Detach());
    }
    return *this;
}


void 
CPL::CDuiValuePtr::Attach(
    DUI::Value *pv
    )
{
    _Release();
    m_pv    = pv;
    m_bOwns = true;
}


DUI::Value *
CPL::CDuiValuePtr::Detach(
    void
    ) const
{ 
    DUI::Value *pv = m_pv;
    m_pv    = NULL;
    m_bOwns = false; 
    return pv; 
}


void 
CPL::CDuiValuePtr::_Release(
    void
    )
{
    if (NULL != m_pv && m_bOwns) 
    {
        m_pv->Release(); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpguids.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpguids.cpp
//
//--------------------------------------------------------------------------
#include "shellprv.h"

#include <initguid.h>
#include "cpguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpguids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpguids.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_GUIDS_H
#define __CONTROLPANEL_GUIDS_H

namespace CPL {


// {3BE962E5-C533-4602-9E7D-B785EDA0B9D4}
DEFINE_GUID(IID_ICpUiCommand, 
0x3be962e5, 0xc533, 0x4602, 0x9e, 0x7d, 0xb7, 0x85, 0xed, 0xa0, 0xb9, 0xd4);

// {E75C5E43-D6D1-4336-8504-0E8E55A2ACCD}
DEFINE_GUID(IID_ICpUiElementInfo, 
0xe75c5e43, 0xd6d1, 0x4336, 0x85, 0x4, 0xe, 0x8e, 0x55, 0xa2, 0xac, 0xcd);

// {B46CBBCD-3F6B-433c-9422-BF9BEE5125C1}
DEFINE_GUID(IID_ICplWebViewInfo, 
0xb46cbbcd, 0x3f6b, 0x433c, 0x94, 0x22, 0xbf, 0x9b, 0xee, 0x51, 0x25, 0xc1);

// {A4AFCDE8-175A-4735-A7AE-2310C3AF247B}
DEFINE_GUID(IID_IEnumCplWebViewInfo, 
0xa4afcde8, 0x175a, 0x4735, 0xa7, 0xae, 0x23, 0x10, 0xc3, 0xaf, 0x24, 0x7b);

// {EE031859-D046-4103-9C02-94CBA01F76F1}
DEFINE_GUID(IID_ICplView, 
0xee031859, 0xd046, 0x4103, 0x9c, 0x2, 0x94, 0xcb, 0xa0, 0x1f, 0x76, 0xf1);

// {029CF875-6FE7-4d1c-AF72-2CCE925B5AB6}
DEFINE_GUID(IID_ICplCategory, 
0x29cf875, 0x6fe7, 0x4d1c, 0xaf, 0x72, 0x2c, 0xce, 0x92, 0x5b, 0x5a, 0xb6);

// {A9D37997-77AD-4b32-A6BF-CF8306A94060}
DEFINE_GUID(IID_ICplNamespace, 
0xa9d37997, 0x77ad, 0x4b32, 0xa6, 0xbf, 0xcf, 0x83, 0x6, 0xa9, 0x40, 0x60);

// {5581A2AD-6F46-42d6-92CC-6A35786D7E92}
DEFINE_GUID(SID_SControlPanelView, 
0x5581a2ad, 0x6f46, 0x42d6, 0x92, 0xcc, 0x6a, 0x35, 0x78, 0x6d, 0x7e, 0x92);



} // namespace CPL


#endif //__CONTROLPANEL_GUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cplnkele.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cplnkele.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_LINKELEM_H
#define __CONTROLPANEL_LINKELEM_H

#include "cpviewp.h"
#include "cpuiele.h"
#include "cputil.h"

namespace CPL {


class CLinkElement : public DUI::Button
{
    public:
        virtual ~CLinkElement(void);

        void OnEvent(DUI::Event *pev);

        void OnInput(DUI::InputEvent *pev);

        void OnPropertyChanged(DUI::PropertyInfo *ppi, int iIndex, DUI::Value *pvOld, DUI::Value *pvNew);

        void OnDestroy(void);
        
        static HRESULT Create(DUI::Element **ppElement);

        HRESULT Initialize(IUICommand *pUiCommand, eCPIMGSIZE eIconSize);

        //
        // ClassInfo accessors (static and virtual instance-based)
        //
        static DUI::IClassInfo *Class;

        virtual DUI::IClassInfo *GetClassInfo(void)
            { return Class; }
        static HRESULT Register();

    private:
        //
        // These are the 3 states of a drag operation that we transition
        // through.  See the OnInput() method for usage and description.
        //
        enum { DRAG_IDLE, DRAG_HITTESTING, DRAG_DRAGGING };
        
        IUICommand    *m_pUiCommand;     // Link command object associated with element.
        eCPIMGSIZE     m_eIconSize;
        HWND           m_hwndInfotip;    // Infotip window.
        ATOM           m_idTitle;
        ATOM           m_idIcon;
        int            m_iDragState;
        RECT           m_rcDragBegin;

        //
        // Prevent copy.
        //
        CLinkElement(const CLinkElement& rhs);              // not implemented.
        CLinkElement& operator = (const CLinkElement& rhs); // not implemented.

    public:
        CLinkElement(void);

    private:
        HRESULT _Initialize(void);
        HRESULT _InitializeAccessibility(void);
        HRESULT _CreateElementTitle(void);
        HRESULT _CreateElementIcon(void);
        HRESULT _GetElementIcon(HICON *phIcon);
        HRESULT _AddOrDeleteAtoms(bool bAdd);
    
        HRESULT _OnContextMenu(DUI::ButtonContextEvent *peButton);
        HRESULT _OnSelected(void);

        void _Destroy(void);
        void _OnElementResized(DUI::Value *pvNewExtent);
        void _OnElementMoved(DUI::Value *pvNewLocation);
        void _OnMouseOver(DUI::Value *pvNewMouseWithin);

        HRESULT _GetInfotipText(LPWSTR *ppszInfotip);
        HRESULT _GetTitleText(LPWSTR *ppszTitle);
        HRESULT _ShowInfotipWindow(bool bShow);
        HRESULT _GetDragDropData(IDataObject **ppdtobj);
        HRESULT _BeginDrag(int iClickPosX, int iClickPosY);
        HRESULT _SetPreferredDropEffect(IDataObject *pdtobj, DWORD dwEffect);
        HRESULT _GetDragImageBitmap(HBITMAP *phbm, LONG *plWidth, LONG *plHeight);
        HRESULT _SetDragImage(IDataObject *pdtobj, int iClickPosX, int iClickPosY);
};


} // namespace CPL



#endif // __CONTROLPANEL_LINKELEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cplobj.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "control.h"
#include "uemapp.h"

#include <limits.h>

#define TF_CPL TF_CUSTOM2

typedef struct
{
    ATOM aCPL;     // CPL name atom (so we can match requests)
    ATOM aApplet;  // applet name atom (so we can match requests, may be zero)
    HWND hwndStub; // window for this dude (so we can switch to it)
    UINT flags;    // see PCPLIF_ flags below
} CPLAPPLETID;

//
// PCPLIF_DEFAULT_APPLET
// There are two ways of getting the default applet, asking for it my name
// and passing an empty applet name.  This flag should be set regardless,
// so that the code which switches to an already-active applet can always
// find a previous instance if it exists.
//

#define PCPLIF_DEFAULT_APPLET   (0x1)

typedef struct
{
    int icon;
    TCHAR cpl[ CCHPATHMAX ];
    TCHAR applet[ MAX_CCH_CPLNAME ];
    TCHAR *params;
} CPLEXECINFO;

ATOM aCPLName = (ATOM)0;
ATOM aCPLFlags = (ATOM)0;

void CPL_ParseCommandLine (CPLEXECINFO *info, LPTSTR pszCmdLine, BOOL extract_icon);
BOOL CPL_LoadAndFindApplet (LPCPLMODULE *pcplm, HICON *phIcon, UINT *puControl, CPLEXECINFO *info);

BOOL CPL_FindCPLInfo(LPTSTR pszCmdLine, HICON *phIcon, UINT *ppapl, LPTSTR *pparm)
{
    LPCPLMODULE pmod;
    CPLEXECINFO info;

    CPL_ParseCommandLine(&info, pszCmdLine, TRUE);

    if (CPL_LoadAndFindApplet(&pmod, phIcon, ppapl, &info))
    {
        *pparm = info.params;
        CPL_FreeCPLModule(pmod);
        return TRUE;
    }

    *pparm = NULL;
    return FALSE;
}

typedef struct _fcc {
    LPTSTR      lpszClassStub;
    CPLAPPLETID *target;
    HWND        hwndMatch;
} FCC, *LPFCC;


BOOL _FindCPLCallback(HWND hwnd, LPARAM lParam)
{
    LPFCC lpfcc = (LPFCC)lParam;
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));

    if (lstrcmp(szClass, lpfcc->lpszClassStub) == 0)    // Must be same class...
    {
        // Found a stub window
        if (lpfcc->target->aCPL != 0)
        {
            HANDLE hHandle;

            ATOM aCPL;
            hHandle = GetProp(hwnd, (LPCTSTR)(DWORD_PTR)aCPLName);

            ASSERT((DWORD_PTR) hHandle < USHRT_MAX);
            aCPL = (ATOM)(DWORD_PTR) hHandle;

            if (aCPL != 0 && aCPL == lpfcc->target->aCPL)
            {
                ATOM aApplet;
                hHandle = GetProp(hwnd, (LPCTSTR)(DWORD_PTR)aCPL);
                aApplet = (ATOM)(DWORD_PTR) hHandle;
                ASSERT((DWORD_PTR) hHandle < USHRT_MAX);

                // users may request any applet by name
                if (aApplet != 0 && aApplet == lpfcc->target->aApplet)
                {
                    lpfcc->hwndMatch = hwnd;
                    return FALSE;
                }
                //
                // Users may request the default w/o specifying a name
                //
                if (lpfcc->target->flags & PCPLIF_DEFAULT_APPLET)
                {
                    UINT flags = HandleToUlong(GetProp(hwnd, MAKEINTATOM(aCPLFlags)));

                    if (flags & PCPLIF_DEFAULT_APPLET)
                    {
                        lpfcc->hwndMatch = hwnd;
                        return FALSE;
                    }
                }
            }
        }
    }
    return TRUE;
}

HWND FindCPL(HWND hwndStub, CPLAPPLETID *target)
{
    FCC fcc;
    TCHAR szClassStub[32];

    if (aCPLName == (ATOM)0)
    {
        aCPLName = GlobalAddAtom(TEXT("CPLName"));
        aCPLFlags = GlobalAddAtom(TEXT("CPLFlags"));

        if (aCPLName == (ATOM)0 || aCPLFlags == (ATOM)0)
            return NULL;        // This should never happen... didn't find hwnd
    }

    szClassStub[0] = '\0'; // a NULL hwnd has no class
    if (hwndStub)
    {
        GetClassName(hwndStub, szClassStub, ARRAYSIZE(szClassStub));
    }
    fcc.lpszClassStub = szClassStub;
    fcc.target = target;
    fcc.hwndMatch = (HWND)0;

    EnumWindows(_FindCPLCallback, (LPARAM)&fcc);

    return fcc.hwndMatch;
}

//----------------------------------------------------------------------------
// parsing helper for comma lists
//

TCHAR *CPL_ParseToSeparator(TCHAR *dst, TCHAR *psrc, size_t dstmax, BOOL spacedelimits)
{
    if (psrc)
    {
        TCHAR source[CCHPATHMAX], *src;
        TCHAR *delimiter, *closingquote = NULL;

        StringCchCopy(source, ((dstmax < ARRAYSIZE(source)) ? dstmax : ARRAYSIZE(source)), psrc);
        src = source;

        //
        // eat whitespace
        //

        while(*src == TEXT(' '))
            src++;

        delimiter = src;

        //
        // ignore stuff inside quoted strings
        //

        if (*src == TEXT('"'))
        {
            //
            // start after first quote, advance src past quote
            //

            closingquote = ++src;

            while(*closingquote && *closingquote != TEXT('"'))
                closingquote++;

            //
            // see if loop above ended on a quote
            //

            if (*closingquote)
            {
                //
                // temporary NULL termination
                //

                *closingquote = 0;

                //
                // start looking for delimiter again after quotes
                //

                delimiter = closingquote + 1;
            }
            else
                closingquote = NULL;
        }

        if (spacedelimits)
        {
            delimiter += StrCSpn(delimiter, TEXT(", "));

            if (!*delimiter)
                delimiter = NULL;
        }
        else
            delimiter = StrChr(delimiter, TEXT(','));

        //
        // temporary NULL termination
        //

        if (delimiter)
            *delimiter = 0;

        if (dst)
        {
            StringCchCopy(dst, dstmax, src);
            dst[ dstmax - 1 ] = 0;
        }

        //
        // put back stuff we terminated above
        //

        if (delimiter)
            *delimiter = TEXT(',');

        if (closingquote)
            *closingquote = TEXT('"');

        //
        // return start of next string
        //

        psrc = (delimiter ? (psrc + ((delimiter + 1) - source)) : NULL);
    }
    else if (dst)
    {
        *dst = 0;
    }

    //
    // new source location
    //

    return psrc;
}


// parse the Control_RunDLL command line
// format: "CPL name, applet name, extra params"
// format: "CPL name, icon index, applet name, extra params"
//
//  NOTE: [stevecat]  3/10/95
//
//         The 'extra params' do not have to be delimited by a ","
//         in NT for the case "CPL name applet name extra params"
//
//         A workaround for applet names that include a space
//         in their name would be to enclose that value in
//         double quotes (see the CPL_ParseToSeparator routine.)
//

void CPL_ParseCommandLine(CPLEXECINFO *info, LPTSTR pszCmdLine, BOOL extract_icon)
{
    //
    // parse out the CPL name, spaces are valid separators
    //

    pszCmdLine = CPL_ParseToSeparator(info->cpl, pszCmdLine, CCHPATHMAX, TRUE);

    if (extract_icon)
    {
        TCHAR icon[ 8 ];

        //
        // parse out the icon id/index, spaces are not valid separators
        //

        pszCmdLine = CPL_ParseToSeparator(icon, pszCmdLine, ARRAYSIZE(icon), FALSE);

        info->icon = StrToInt(icon);
    }
    else
        info->icon = 0;

    //
    // parse out the applet name, spaces are not valid separators
    //

    info->params = CPL_ParseToSeparator(info->applet, pszCmdLine,
                                         MAX_CCH_CPLNAME, FALSE);

    CPL_StripAmpersand(info->applet);
}

BOOL CPL_LoadAndFindApplet(LPCPLMODULE *ppcplm, HICON *phIcon, UINT *puControl, CPLEXECINFO *info)
{
    TCHAR szControl[MAX_CCH_CPLNAME];
    LPCPLMODULE pcplm;
    LPCPLITEM pcpli;
    int nControl = 0;   // fall thru to default
    int NumControls;

    ENTERCRITICAL;

    pcplm = CPL_LoadCPLModule(info->cpl);

    if (!pcplm || !pcplm->hacpli)
    {
        DebugMsg(DM_ERROR, TEXT("Control_RunDLL: ") TEXT("CPL_LoadCPLModule failed \"%s\""), info->cpl);
        LEAVECRITICAL;
        goto Error0;
    }

    //
    // Look for the specified applet
    // no applet specified selects applet 0
    //

    if (*info->applet)
    {
        NumControls = DSA_GetItemCount(pcplm->hacpli);

        if (info->applet[0] == TEXT('@'))
        {
            nControl = StrToLong(info->applet+1);

            if (nControl >= 0 && nControl < NumControls)
            {
                goto GotControl;
            }
        }

        //
        //  Check for the "Setup" argument and send the special CPL_SETUP
        //  message to the applet to tell it we are running under Setup.
        //

        if (!lstrcmpi (TEXT("Setup"), info->params))
            CPL_CallEntry(pcplm, NULL, CPL_SETUP, 0L, 0L);

        for (nControl=0; nControl < NumControls; nControl++)
        {
            pcpli = DSA_GetItemPtr(pcplm->hacpli, nControl);
            StringCchCopy(szControl, ARRAYSIZE(szControl), pcpli->pszName);
            CPL_StripAmpersand(szControl);

            // if there is only one control, then use it.  This solves
            // some compat issues with CP names changing.
            if (lstrcmpi(info->applet, szControl) == 0 || 1 == NumControls)
                break;
        }

        //
        // If we get to the end of the list, bail out
        //

        // LEGACY WARNING: It might be necessary to handle some old applet names in a special
        // way.  This would be bad because the names are localized.  We would need to somehow
        // call into the CPL's to ask them if they support the given name.  Only the CPL
        // itself would know the correct legacy name mapping.  Adding a new CPL message might
        // cause as many legacy CPL problems as it solves so we would need to do something tricky
        // like adding an exported function.  We could then GetProcAddress on this exported function.
        // If the export exists, we would pass it the legacy name and it would return a number.
        //
        // Example: "control mmsys.cpl,Sounds" must work even though mmsys.cpl no longer contains
        //      an applet called "Sounds".  "control mmsys.cpl,Multimedia" must work even though
        //      mmsys.cpl no longer contains an applet called "Multimedia".  You can't simply
        //      rename the applet becuase these two CPL's were both merged into one CPL.  Renaming
        //      could never solve more than half the problem.

        if (nControl >= NumControls)
        {
            DebugMsg(DM_ERROR, TEXT("Control_RunDLL: ") TEXT("Cannot find specified applet"));
            LEAVECRITICAL;
            goto Error1;
        }
    }

GotControl:
    if (phIcon != NULL)
    {
        pcpli = DSA_GetItemPtr(pcplm->hacpli, nControl);
        *phIcon = CopyIcon(pcpli->hIcon);
    }

    LEAVECRITICAL;
    //
    // yes, we really do want to pass negative indices through...
    //

    *puControl = (UINT)nControl;
    *ppcplm = pcplm;

    return TRUE;

Error1:
    CPL_FreeCPLModule(pcplm);
Error0:
    return FALSE;
}

BOOL CPL_Identify(CPLAPPLETID *identity, CPLEXECINFO *info, HWND stub)
{
    identity->aApplet = (ATOM)0;
    identity->hwndStub = stub;
    identity->flags = 0;

    if ((identity->aCPL = GlobalAddAtom(info->cpl)) == (ATOM)0)
        return FALSE;

    if (*info->applet)
    {
        if ((identity->aApplet = GlobalAddAtom(info->applet)) == (ATOM)0)
            return FALSE;
    }
    else
    {
        //
        // no applet name means use the default
        //

        identity->flags = PCPLIF_DEFAULT_APPLET;
    }

    return TRUE;
}


void CPL_UnIdentify(CPLAPPLETID *identity)
{
    if (identity->aCPL)
    {
        GlobalDeleteAtom(identity->aCPL);
        identity->aCPL = (ATOM)0;
    }

    if (identity->aApplet)
    {
        GlobalDeleteAtom(identity->aApplet);
        identity->aApplet = (ATOM)0;
    }

    identity->hwndStub = NULL;
    identity->flags = 0;
}


// It's time for Legacy Mode!!!  In NT5 we removed a bunch of CPL files
// from the product.  These files are used by name by many programs.  As a result,
// the old names need to keep working even though the files no longer exist.
// We handle this by checking if the file exists.  If it does not exist, we run
// the cpl name through a mapping table and then try again.  The mapping table can
// potentially change the CPL name, the applet number, and the params.
typedef struct
{
    LPTSTR oldInfo_cpl;
    LPTSTR oldInfo_applet;
    LPTSTR oldInfo_params;
    LPTSTR newInfo_cpl;
    LPTSTR newInfo_applet;
    LPTSTR newInfo_params;
} RUNDLLCPLMAPPING;

// For the oldInfo member, a NULL means to match any value from the pinfo structure.
// If the oldInfo structure mathces the pinfo structure then it will be updated using
// the data from newInfo structure. For the newInfo member, a NULL means to leave the
// corresponding pinfo member unchanged.
const RUNDLLCPLMAPPING g_rgRunDllCPLMapping[] = 
{
    { TEXT("MODEM.CPL"),    NULL, NULL,    TEXT("TELEPHON.CPL"), TEXT("@0"), TEXT("1") },
    { TEXT("UPS.CPL"),      NULL, NULL,    TEXT("POWERCFG.CPL"), NULL, NULL }
};

BOOL CPL_CheckLegacyMappings(CPLEXECINFO * pinfo)
{
    LPTSTR p;
    int i;

    TraceMsg(TF_CPL, "Attempting Legacy CPL conversion on %s", pinfo->cpl);

    // we want only the filename, strip off any path information
    p = PathFindFileName(pinfo->cpl);
    StringCchCopy(pinfo->cpl, ARRAYSIZE(pinfo->cpl), p);

    for (i = 0; i < ARRAYSIZE(g_rgRunDllCPLMapping); i++)
    {
        if (0 == StrCmpI(pinfo->cpl, g_rgRunDllCPLMapping[i].oldInfo_cpl))
        {
            if (!g_rgRunDllCPLMapping[i].oldInfo_applet ||
                 0 == StrCmpI(pinfo->applet, g_rgRunDllCPLMapping[i].oldInfo_applet))
            {
                if (!g_rgRunDllCPLMapping[i].oldInfo_params ||
                     (pinfo->params &&
                       0 == StrCmpI(pinfo->params, g_rgRunDllCPLMapping[i].oldInfo_params)
                    )
                  )
                {
                    if (pinfo->params)
                    {
                        TraceMsg(TF_CPL, "%s,%s,%s matches item %d", pinfo->cpl, pinfo->applet, pinfo->params, i);
                    }
                    else
                    {
                        TraceMsg(TF_CPL, "%s,%s matches item %d", pinfo->cpl, pinfo->applet, i);
                    }

                    // The current entry matches the request.  Map to the new info and then
                    // ensure the new CPL exists.
                    StringCchCopy(pinfo->cpl, ARRAYSIZE(pinfo->cpl), g_rgRunDllCPLMapping[i].newInfo_cpl);

                    if (g_rgRunDllCPLMapping[i].newInfo_applet)
                    {
                        StringCchCopy(pinfo->applet, ARRAYSIZE(pinfo->applet), g_rgRunDllCPLMapping[i].newInfo_applet);
                    }

                    if (g_rgRunDllCPLMapping[i].newInfo_params)
                    {
                        // the params pointer is normally a pointer into the remaining chunk of a string
                        // buffer.  As such, we don't need to delete the memory it points to.  Also, this
                        // argument is read only so it should be safe for us to point it at our constant
                        // data.
                        pinfo->params = g_rgRunDllCPLMapping[i].newInfo_params;
                    }

                    if (pinfo->params)
                    {
                        TraceMsg(TF_CPL, "CPL mapped to %s,%s,%s", pinfo->cpl, pinfo->applet, pinfo->params);
                    }
                    else
                    {
                        TraceMsg(TF_CPL, "CPL mapped to %s,%s", pinfo->cpl, pinfo->applet);
                    }

                    return PathFindOnPath(pinfo->cpl, NULL);
                }
            }
        }
    }

    return FALSE;
}

// Goes through all of the work of identifying and starting a control
// applet.  Accepts a flag specifying whether or not to load a new DLL if it
// is not already present.  This code will ALLWAYS switch to an existing
// instance of the applet if bFindExisting is specified.
//
// WARNING: this function butchers the command line you pass in!

BOOL CPL_RunMeBaby(HWND hwndStub, HINSTANCE hAppInstance, LPTSTR pszCmdLine, int nCmdShow, BOOL bAllowLoad, BOOL bFindExisting)
{
    int nApplet;
    LPCPLMODULE pcplm;
    LPCPLITEM pcpli;
    CPLEXECINFO info;
    CPLAPPLETID identity;
    TCHAR szApplet[ MAX_CCH_CPLNAME ];
    BOOL bResult = FALSE;
    HWND hwndOtherStub;
    HRESULT hrInit;

    if (SHRestricted(REST_NOCONTROLPANEL))
    {
        ShellMessageBox(HINST_THISDLL, hwndStub, MAKEINTRESOURCE(IDS_RESTRICTIONS),
                        MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE), MB_OK|MB_ICONSTOP);
        return FALSE;
    }

    hrInit = SHCoInitialize();

    //
    // parse the command line we got
    //

    CPL_ParseCommandLine(&info, pszCmdLine, FALSE);

    //
    // no applet to run means open the controls folder
    //

    if (!*info.cpl)
    {
        InvokeFolderPidl(MAKEINTIDLIST(CSIDL_CONTROLS), nCmdShow);
        bResult = TRUE;
        goto Error0;
    }

    // expand CPL name to a full path if it isn't already
    if (PathIsFileSpec(info.cpl))
    {
        if (!PathFindOnPath(info.cpl, NULL))
        {
            if (!CPL_CheckLegacyMappings(&info))
                goto Error0;
        }
    }
    else if (!PathFileExists(info.cpl))
    {
        if (!CPL_CheckLegacyMappings(&info))
            goto Error0;
    }

    if (!CPL_Identify(&identity, &info, hwndStub))
        goto Error0;

    //
    // If we have already loaded this CPL, then jump to the existing window
    //
    
    hwndOtherStub = FindCPL(hwndStub, &identity);

    //
    // If we found a window and the caller says its ok to find an existing
    // window then set the focus to it
    //
    if (bFindExisting && hwndOtherStub)
    {
        //
        // try to find a CPL window on top of it
        //

        HWND hwndTarget = GetLastActivePopup(hwndOtherStub);

        if (hwndTarget && IsWindow(hwndTarget))
        {

            DebugMsg(DM_WARNING, TEXT("Control_RunDLL: ") TEXT("Switching to already loaded CPL applet"));
            SetForegroundWindow(hwndTarget);
            bResult = TRUE;
            goto Error1;
        }

        //
        // couldn't find it, must be exiting or some sort of error...
        // so ignore it.
        //

        DebugMsg(DM_WARNING, TEXT("Control_RunDLL: ") TEXT("Bogus CPL identity in array; purging after (presumed) RunDLL crash"));
    }

    //
    // stop here if we're not allowed to load the cpl
    //

    if (!bAllowLoad)
        goto Error1;

    //
    // i guess we didn't stop up there
    //

    if (!CPL_LoadAndFindApplet(&pcplm, NULL, &nApplet, &info))
        goto Error1;

    //
    // get the name that the applet thinks it should have
    //

    pcpli = DSA_GetItemPtr(pcplm->hacpli, nApplet);

    if (FAILED(StringCchCopy(szApplet, ARRAYSIZE(szApplet), pcpli->pszName)))
        goto Error2;

    CPL_StripAmpersand(szApplet);

    // handle "default applet" cases before running anything
    if (identity.aApplet)
    {
        // we were started with an explicitly named applet
        if (!nApplet)
        {
            // we were started with the name of the default applet
            identity.flags |= PCPLIF_DEFAULT_APPLET;
        }
    }
    else
    {
        // we were started without a name, assume the default applet
        identity.flags |= PCPLIF_DEFAULT_APPLET;

        // get the applet's name (now that we've loaded it's CPL)
        if ((identity.aApplet = GlobalAddAtom(szApplet)) == (ATOM)0)
        {
            // bail 'cause we could nuke a CPL if we don't have this
            goto Error2;
        }
    }

    // mark the window so we'll be able to verify that it's really ours
    if (aCPLName == (ATOM)0)
    {
        aCPLName = GlobalAddAtom(TEXT("CPLName"));
        aCPLFlags = GlobalAddAtom(TEXT("CPLFlags"));

        if (aCPLName == (ATOM)0 || aCPLFlags == (ATOM)0)
            goto Error2;        // This should never happen... blow off applet
    }

    if (!SetProp(hwndStub,                 // Mark its name
        MAKEINTATOM(aCPLName), (HANDLE)(DWORD_PTR)identity.aCPL))
    {
        goto Error2;
    }

    if (!SetProp(hwndStub,                 // Mark its applet
        MAKEINTATOM(identity.aCPL), (HANDLE)(DWORD_PTR)identity.aApplet))
    {
        goto Error2;
    }
    if (identity.flags)
    {
        if (aCPLFlags == (ATOM)0)
            aCPLFlags = GlobalAddAtom(TEXT("CPLFlags"));
                                            // Mark its flags
        SetProp(hwndStub, MAKEINTATOM(aCPLFlags), (HANDLE)UIntToPtr(identity.flags));
    }

    //
    // Send the stub window a message so it will have the correct title and
    // icon in the alt-tab window, etc...
    //

    if (hwndStub) {
        DWORD dwPID;
        SendMessage(hwndStub, STUBM_SETICONTITLE, (WPARAM)pcpli->hIcon, (LPARAM)szApplet);
        GetWindowThreadProcessId(hwndStub, &dwPID);
        if (dwPID == GetCurrentProcessId()) {
            RUNDLL_NOTIFY sNotify;

            sNotify.hIcon = pcpli->hIcon;
            sNotify.lpszTitle = szApplet;

            // HACK: It will look like the stub window is sending itself
            // a WM_NOTIFY message.  Oh well.
            //
            SendNotify(hwndStub, hwndStub, RDN_TASKINFO, (NMHDR FAR*)&sNotify);
        }
    }

    if (info.params)
    {
        DebugMsg(DM_TRACE, TEXT("Control_RunDLL: ") TEXT("Sending CPL_STARTWPARAMS to applet with: %s"), info.params);

        bResult = BOOLFROMPTR(CPL_CallEntry(pcplm, hwndStub, CPL_STARTWPARMS, (LONG)nApplet, (LPARAM)info.params));
    }

    // Check whether we need to run as a different windows version
    {
        PPEB Peb = NtCurrentPeb();
        PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pcplm->minst.hinst;
        PIMAGE_NT_HEADERS pHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)pcplm->minst.hinst + pDosHeader->e_lfanew);

        if (pHeader->FileHeader.SizeOfOptionalHeader != 0 &&
            pHeader->OptionalHeader.Win32VersionValue != 0)
        {
            //
            // Stolen from ntos\mm\procsup.c
            //
            Peb->OSMajorVersion = pHeader->OptionalHeader.Win32VersionValue & 0xFF;
            Peb->OSMinorVersion = (pHeader->OptionalHeader.Win32VersionValue >> 8) & 0xFF;
            Peb->OSBuildNumber  = (USHORT) ((pHeader->OptionalHeader.Win32VersionValue >> 16) & 0x3FFF);
            Peb->OSPlatformId   = (pHeader->OptionalHeader.Win32VersionValue >> 30) ^ 0x2;
        }
    }

#ifdef UNICODE
    //
    // If the cpl didn't respond to CPL_STARTWPARMSW (unicode version),
    // maybe it is an ANSI only CPL
    //
    if (info.params && (!bResult))
    {
        int cchParams = WideCharToMultiByte(CP_ACP, 0, info.params, -1, NULL, 0, NULL, NULL);
        LPSTR lpstrParams = LocalAlloc(LMEM_FIXED, sizeof(*lpstrParams) * cchParams);
        if (lpstrParams != NULL) 
        {
            WideCharToMultiByte(CP_ACP, 0, info.params, -1, lpstrParams, cchParams, NULL, NULL);

            DebugMsg(DM_TRACE, TEXT("Control_RunDLL: ") TEXT("Sending CPL_STARTWPARAMSA to applet with: %hs"), lpstrParams);

            bResult = BOOLFROMPTR(CPL_CallEntry(pcplm, hwndStub, CPL_STARTWPARMSA, (LONG)nApplet, (LPARAM)lpstrParams));

            LocalFree(lpstrParams);
        }
    }
#endif

    if (!bResult)
    {
        DebugMsg(DM_TRACE, TEXT("Control_RunDLL: ") TEXT("Sending CPL_DBLCLK to applet"));

        CPL_CallEntry(pcplm, hwndStub, CPL_DBLCLK, (LONG)nApplet, pcpli->lData);

        // some 3x applets return the wrong value so we can't fail here
        bResult = TRUE;
    }

    bResult = TRUE; // make it!

    RemoveProp(hwndStub, (LPCTSTR)(UINT_PTR)identity.aCPL);
Error2:
    CPL_FreeCPLModule(pcplm);
Error1:
    CPL_UnIdentify(&identity);
Error0:

    SHCoUninitialize(hrInit);

    return bResult;
}

//
// Check the following reg location and see if this CPL is registered to run in proc:
// HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ControlPanel\\InProcCPLs
//
STDAPI_(BOOL) CPL_IsInProc(LPCTSTR pszCmdLine)
{
    BOOL bInProcCPL = FALSE;
    TCHAR szTempCmdLine[2 * MAX_PATH];
    CPLEXECINFO info = {0};
    LPTSTR pszCPLFile = NULL;
    
    ASSERT(pszCmdLine);

    // Make a copy of the command line
    StringCchCopy(szTempCmdLine, ARRAYSIZE(szTempCmdLine), pszCmdLine);

    // Parse the command line using standard parsing function
    CPL_ParseCommandLine(&info, szTempCmdLine, FALSE);

    // Find the file name of this cpl
    pszCPLFile = PathFindFileName(info.cpl);
    if (pszCPLFile)
    {
        // Open the reg key
        HKEY hkeyInProcCPL = NULL;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ControlPanel\\InProcCPLs"), 0, KEY_READ, &hkeyInProcCPL))
        {
            // Look up in the registry for this cpl name
            LONG cbData;
            if (ERROR_SUCCESS == SHQueryValueEx(hkeyInProcCPL, pszCPLFile, NULL, NULL, NULL, &cbData))
                bInProcCPL = TRUE;

            RegCloseKey(hkeyInProcCPL);
        }
    }
    return bInProcCPL;
}


BOOL UsePCHealthFaultUploading(LPCTSTR pszCmdLine)
{
    // Do we want exceptions to go unhandled so PCHealth will upload the faults?
    BOOL fUsePCHealth = FALSE;      // By default no, because
    LPCTSTR pszFilename = PathFindFileName(pszCmdLine);

    if (pszFilename)
    {
        DWORD dwType;
        DWORD dwFlags;
        DWORD cbSize = sizeof(dwFlags);

        DWORD dwError = SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ControlPanel\\Flags"), 
                        pszFilename, &dwType, (void *)&dwFlags, &cbSize);
        if ((ERROR_SUCCESS == dwError) && (REG_DWORD == dwType))
        {
            // The 0x00000001 bit will indicate if they want to not have exceptions caught for them.
            if (0x00000001 & dwFlags)
            {
                fUsePCHealth = TRUE;
            }
        }
    }

    return fUsePCHealth;
}


//
// Starts a remote control applet on a new RunDLL process
// Or on another thread InProcess 
//
STDAPI_(BOOL) CPL_RunRemote(LPCTSTR pszCmdLine, HWND hwnd, BOOL fRunAsNewUser)
{
    BOOL bRet = FALSE;
    TCHAR szShell32[MAX_PATH];
    //
    // First build a path to shell32.dll in SYSTEM32.
    //
    if (0 != GetSystemDirectory(szShell32, ARRAYSIZE(szShell32)))
    {
        if (PathAppend(szShell32, TEXT("shell32.dll")))
        {
            TCHAR szRunParams[2 * MAX_PATH];
            BOOL fUsePCHealth = UsePCHealthFaultUploading(pszCmdLine);
            HRESULT hr;

            hr = StringCchPrintf(szRunParams, 
                                 ARRAYSIZE(szRunParams),
                                 TEXT("%s%s,Control_RunDLL%s %s"),
                                 (fUsePCHealth ? TEXT("/d ") : TEXT("")),
                                 szShell32,
                                 (fRunAsNewUser ? TEXT("AsUser") : TEXT("")),
                                 pszCmdLine);

            if (SUCCEEDED(hr))
            {
                if (!fRunAsNewUser && CPL_IsInProc(pszCmdLine))
                {
                    // launch this cpl in process from another thread
                    bRet = SHRunDLLThread(hwnd, szRunParams, SW_SHOWNORMAL);
                }
                else
                {
                    // launch this cpl on another thread
                    bRet = SHRunDLLProcess(hwnd, szRunParams, SW_SHOWNORMAL, IDS_CONTROLPANEL, fRunAsNewUser);
                }
            }
        }
    }
    return bRet;
}

//
// Attempts to open the specified control applet.
// Tries to switch to an existing instance before starting a new one, unless the user 
// specifies the fRunAsNewUser in which case we always launch a new process.
//
STDAPI_(BOOL) SHRunControlPanelEx(LPCTSTR pszOrigCmdLine, HWND hwnd, BOOL fRunAsNewUser)
{
    BOOL bRes = FALSE;
    LPTSTR pszCmdLine = NULL;

    // check to see if the caller passed a resource id instead of a string

    if (!IS_INTRESOURCE(pszOrigCmdLine))
    {
        pszCmdLine = StrDup(pszOrigCmdLine);
    }
    else
    {
        TCHAR szCmdLine[MAX_PATH];

        if (LoadString(HINST_THISDLL, PtrToUlong((void *)pszOrigCmdLine), szCmdLine, ARRAYSIZE(szCmdLine)))
            pszCmdLine = StrDup(szCmdLine);
    }

    //
    // CPL_RunMeBaby whacks on the command line while parsing...use a dup
    //
    if (pszCmdLine)
    {

        if (!fRunAsNewUser)
        {
            // if fRunAsNewUser is NOT specified, then try to switch to an active CPL 
            // which matches our pszCmdLine
            bRes = CPL_RunMeBaby(NULL, NULL, pszCmdLine, SW_SHOWNORMAL, FALSE, TRUE);
        }

        if (!bRes)
        {
            // launch a new cpl in a separate process
            bRes = CPL_RunRemote(pszCmdLine, hwnd, fRunAsNewUser);
        }
        LocalFree(pszCmdLine);
    }

    if (bRes && UEMIsLoaded() && !IS_INTRESOURCE(pszOrigCmdLine)) 
    {
        UEMFireEvent(&UEMIID_SHELL, UEME_RUNCPL, UEMF_XEVENT, -1, (LPARAM)pszOrigCmdLine);
    }

    return bRes;
}

// This function is a TCHAR export from shell32 (header defn is in shsemip.h)
//
// UNDOCUMENTED: You may pass a shell32 resource ID in place of a pszCmdLine
//
STDAPI_(BOOL) SHRunControlPanel(LPCTSTR pszOrigCmdLine, HWND hwnd)
{
    return SHRunControlPanelEx(pszOrigCmdLine, hwnd, FALSE);
}


//
// Attempts to open the specified control applet.
// This function is intended to be called by RunDLL for isolating applets.
// Tries to switch to an existing instance before starting a new one.
//
// The command lines for Control_RunDLL are as follows:
//
//  1)      rundll32 shell32.dll,Control_RunDLL fred.cpl,@n,arguments
//
//  This launches the (n+1)th applet in fred.cpl.
//
//  If "@n" is not supplied, the default is @0.
//
//  2)      rundll32 shell32.dll,Control_RunDLL fred.cpl,Ba&rney,arguments
//
//  This launches the applet in fred.cpl named "Barney".  Ampersands are
//  stripped from the name.
//
//  3)      rundll32 shell32.dll,Control_RunDLL fred.cpl,Setup
//
//  This loads fred.cpl and sends it a CPL_SETUP message.
//
//  In cases (1) and (2), the "arguments" are passed to the applet via
//  the CPL_STARTWPARAMS (start with parameters) message.  It is the
//  applet's job to parse the arguments and do something interesting.
//
//  It is traditional for the command line of a cpl to be the index of
//  the page that should initially be shown to the user, but that's just
//  tradition.
//

STDAPI_(void) Control_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    TCHAR szCmdLine[MAX_PATH * 2];
    SHAnsiToTChar(pszCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));

    CPL_RunMeBaby(hwndStub, hAppInstance, szCmdLine, nCmdShow, TRUE, TRUE);
}

STDAPI_(void) Control_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    TCHAR szCmdLine[MAX_PATH * 2];
    SHUnicodeToTChar(lpwszCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));

    CPL_RunMeBaby(hwndStub, hAppInstance, szCmdLine, nCmdShow, TRUE, TRUE);
}

// This is the entry that gets called when we run a cpl as a new user. 
//
STDAPI_(void) Control_RunDLLAsUserW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    CPL_RunMeBaby(hwndStub, hAppInstance, lpwszCmdLine, nCmdShow, TRUE, FALSE);
}

// data passed around dialog and worker thread for Control_FillCache_RunDLL

typedef struct
{
    IShellFolder *  psfControl;
    IEnumIDList *   penumControl;
    HWND            dialog;
} FillCacheData;


//
// important work of Control_FillCache_RunDLL
// jogs the control panel enumerator so it will fill the presentation cache
// also forces the applet icons to be extracted into the shell icon cache
//

DWORD CALLBACK Control_FillCacheThreadProc(void *pv)
{
    FillCacheData *data = (FillCacheData *)pv;
    LPITEMIDLIST pidlApplet;
    ULONG dummy;

    while(data->penumControl->lpVtbl->Next(data->penumControl, 1, &pidlApplet, &dummy) == NOERROR)
    {
        SHMapPIDLToSystemImageListIndex(data->psfControl, pidlApplet, NULL);
        ILFree(pidlApplet);
    }

    if (data->dialog)
        EndDialog(data->dialog, 0);

    return 0;
}


//
// dlgproc for Control_FillCache_RunDLL UI
// just something to keep the user entertained while we load a billion DLLs
//

BOOL_PTR CALLBACK _Control_FillCacheDlg(HWND dialog, UINT message, WPARAM wparam, LPARAM lparam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            DWORD dummy;
            HANDLE thread;
            
            ((FillCacheData *)lparam)->dialog = dialog;
            
            thread = CreateThread(NULL, 0, Control_FillCacheThreadProc, (void*)lparam, 0, &dummy);
            if (thread)
                CloseHandle(thread);
            else
                EndDialog(dialog, -1);
        }
        break;
        
    case WM_COMMAND:
        break;
        
    default:
        return FALSE;
    }
    
    return TRUE;
}


//
// enumerates control applets in a manner that fills the presentation cache
// this is so the first time a user opens the control panel it comes up fast
// intended to be called at final setup on first boot
//
// FUNCTION WORKS FOR BOTH ANSI/UNICODE, it never uses pszCmdLine
//

STDAPI_(void) Control_FillCache_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    IShellFolder *psfDesktop;
    HKEY hk;
    
    // nuke the old data so that any bogus cached info from a beta goes away
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     REGSTR_PATH_CONTROLSFOLDER, 
                     0,
                     KEY_WRITE,
                     &hk) == ERROR_SUCCESS)
    {
        RegDeleteValue(hk, TEXT("Presentation Cache"));
        RegCloseKey(hk);
    }
    
    SHGetDesktopFolder(&psfDesktop);
    Shell_GetImageLists(NULL, NULL); // make sure icon cache is around
    
    if (psfDesktop)
    {
        LPITEMIDLIST pidlControl = SHCloneSpecialIDList(hwndStub, CSIDL_CONTROLS, FALSE);
        if (pidlControl)
        {
            FillCacheData data = {0};
            
            if (SUCCEEDED(psfDesktop->lpVtbl->BindToObject(psfDesktop,
                pidlControl, NULL, &IID_IShellFolder, &data.psfControl)))
            {
                if (S_OK == data.psfControl->lpVtbl->EnumObjects(
                    data.psfControl, NULL, SHCONTF_NONFOLDERS, &data.penumControl))
                {
                    if (nCmdShow == SW_HIDE || DialogBoxParam(HINST_THISDLL,
                        MAKEINTRESOURCE(DLG_CPL_FILLCACHE), hwndStub,
                        _Control_FillCacheDlg, (LPARAM)&data) == -1)
                    {
                        Control_FillCacheThreadProc(&data);
                    }
                    
                    data.penumControl->lpVtbl->Release(data.penumControl);
                }
                
                data.psfControl->lpVtbl->Release(data.psfControl);
            }
            
            ILFree(pidlControl);
        }
    }
}

STDAPI_(void) Control_FillCache_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    Control_FillCache_RunDLL(hwndStub,hAppInstance,NULL,nCmdShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpnamespc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpnamespc.cpp
//
//  This is a rather large module but it's not all that difficult.  The 
//  primary purpose is to provide the 'data' associated with the new
//  'categorized' Control Panel user interface.  Therefore, the visual
//  work is done in cpview.cpp and the data is provided by cpnamespc.cpp.
//  Through the implementation of ICplNamespace, the 'view' object obtains 
//  it's display information.  All of this 'namespace' information is 
//  defined and made accessible through this module.  
//
//  The 'namespace' can be broken down into these concepts:
//
//     1. Links - title, icon & infotip
//     2. Actions
//     3. Restrictions
//
//  Each link has a title, icon, infotip and an associated action.  The
//  action is 'invoked' when the user selects the link in the user interface.
//  Actions may optionally be associated with a 'restriction'.  If a 
//  restriction is enforced (usually based on some system state) the 
//  link associated with the action that is associated with the restriction
//  is not made available to the user interface.  Using this indirection
//  mechanism, any link related to a restricted action is not displayed.
//
//  At first glance one might be concerned with the amount of global data
//  used (and being initialized).  Note however that all of the information 
//  is defined as constant such that it can be resolved at compile and link 
//  time.  Several goals drove the design of this module:
//
//     1. Easy maintenance of Control Panel content.  It must be easy
//        to add/remove/modify links in the UI.
//
//     2. Fast initialization.  Everything is defined as constant data.
//
//     3. Logical separation of links, actions and restrictions
//        to facilitate the one-to-many and many-to-many relationships
//        that might occur in the namespace.
//
//  Following the namespace initialization code, the remainder of the 
//  module implements ICplNamespace to make the data available to the view
//  in a COM-friendly way.
//
//--------------------------------------------------------------------------
#include "shellprv.h"

#include <cowsite.h>
#include <startids.h>

#include "cpviewp.h"
#include "cpaction.h"
#include "cpguids.h"
#include "cpnamespc.h"
#include "cpuiele.h"
#include "cputil.h"
#include "ids.h"
#include "securent.h"
#include "prop.h"


//
// These icons are currently all the same image.  
// Use separate macro names in the code in case the designers 
// decide to use different icons for one or more.
// 
#define IDI_CPTASK_SEEALSO        IDI_CPTASK_ASSISTANCE
#define IDI_CPTASK_TROUBLESHOOTER IDI_CPTASK_ASSISTANCE
#define IDI_CPTASK_HELPANDSUPPORT IDI_CPTASK_ASSISTANCE
#define IDI_CPTASK_LEARNABOUT     IDI_CPTASK_ASSISTANCE


namespace CPL {


typedef CDpa<UNALIGNED ITEMIDLIST, CDpaDestroyer_ILFree<UNALIGNED ITEMIDLIST> >  CDpaItemIDList;
typedef CDpa<IUICommand, CDpaDestroyer_Release<IUICommand> >  CDpaUiCommand;


//
// WebView info type enumeration.
//
enum eCPWVTYPE
{
    eCPWVTYPE_CPANEL,       // The 'Control Panel' item.
    eCPWVTYPE_SEEALSO,      // The 'See Also' list.
    eCPWVTYPE_TROUBLESHOOT, // The 'Troubleshooters' list.
    eCPWVTYPE_LEARNABOUT,   // The 'Learn About' list.
    eCPWVTYPE_NUMTYPES
};


//
// Define the SCID identifying the control panel category.
//

DEFINE_SCID(SCID_CONTROLPANELCATEGORY, PSGUID_CONTROLPANEL, PID_CONTROLPANEL_CATEGORY);

//-----------------------------------------------------------------------------
// Resource source classes
//
// The purpose of this trivial class is to abstract away the implementation
// of obtaining a resource identifier.  The reason for this comes from needing
// different text resources (i.e. infotips) for different retail SKUs.  
// For example, on Personal SKU, the Users & Passwords applet provides the 
// ability to associate a picture with a user's account.  On Server, it 
// does not.  Therefore, the infotip on Personal can include text about 
// the user's picture while on Server it cannot.  By introducing this level
// of abstraction, we can provide resource information through a resource
// function that can select the appropriate resource at runtime.  Most 
// links will still use fixed resources but with this abstraction, the calling
// code is none the wiser.
//-----------------------------------------------------------------------------

//
// Resource source function must return an LPCWSTR for the resource.
//
typedef LPCWSTR (*PFNRESOURCE)(ICplNamespace *pns);


class IResSrc
{
    public:
        virtual LPCWSTR GetResource(ICplNamespace *pns) const = 0;
};


class CResSrcStatic : public IResSrc
{
    public:
        CResSrcStatic(LPCWSTR pszResource)
            : m_pszResource(pszResource) { }

        LPCWSTR GetResource(ICplNamespace *pns) const
            {   UNREFERENCED_PARAMETER(pns);
                TraceMsg(TF_CPANEL, "CResSrc::GetResource - m_pszResource = 0x%08X", m_pszResource);
                return m_pszResource; }

    private:
        const LPCWSTR m_pszResource;
};


class CResSrcFunc : public IResSrc
{
    public:
        CResSrcFunc(PFNRESOURCE pfnResource)
            : m_pfnResource(pfnResource) { }


        LPCWSTR GetResource(ICplNamespace *pns) const
            {   TraceMsg(TF_CPANEL, "CResSrcFunc::GetResource - m_pfnResource = 0x%08X", m_pfnResource);
                return (*m_pfnResource)(pns); }

    private:
        const PFNRESOURCE m_pfnResource;
};


//
// This resource type represents "no resource".  It simply 
// returns a NULL value when the resource is requested.  Clients
// that call this must be ready to handle this NULL pointer 
// value.  It was originally created to handle the no-tooltip
// behavior of Learn-About links.
//
class CResSrcNone : public IResSrc
{
    public:
        CResSrcNone(void) { }

        LPCWSTR GetResource(ICplNamespace *pns) const
        { UNREFERENCED_PARAMETER(pns);
          return NULL; }
};
           


// ----------------------------------------------------------------------------
// Information describing links.
// ----------------------------------------------------------------------------
//
//
// 'Link' descriptor.
//
struct CPLINK_DESC
{
    const IResSrc *prsrcIcon;     // Icon resource identifier
    const IResSrc *prsrcName;     // The link's title resource ID.
    const IResSrc *prsrcInfotip;  // The link's infotip resource ID.
    const IAction *pAction;       // The link's action when clicked.
};

//
// Set of 'support' links.
//
struct CPLINK_SUPPORT
{
    const CPLINK_DESC  **ppSeeAlsoLinks;      // 'See Also' links for the category.
    const CPLINK_DESC  **ppTroubleshootLinks; // 'Troubleshoot' links for the category.
    const CPLINK_DESC  **ppLearnAboutLinks;   // 'Learn About' links for the category.
};

//
// 'Category' descriptor.  One defined for each category.
//
struct CPCAT_DESC
{
    eCPCAT              idCategory;         // The category's ID.
    LPCWSTR             pszHelpSelection;   // Selection part of HSS help URL.
    const CPLINK_DESC  *pLink;              // The category's display info and action
    const CPLINK_DESC **ppTaskLinks;        // The category's task list.
    CPLINK_SUPPORT      slinks;             // Support links.
};


// ----------------------------------------------------------------------------
// Restrictions
//
// Restrictions are an important part of the control panel display logic.
// Each link element in the UI can be restricted from view based on one or
// more system conditions at the time of display.  To ensure the correct
// logic is used, it is critical to have a method of describing these restrictions
// that is easily readable and verifiable against a specification.  Testing
// all of the possible scenarios is a difficult task, therefore the code must
// be written in a manner conducive to finding errors by inspection as well.
// This means, keep it simple.  Each link action object can be optionally associated 
// with a 'restriction' object.  Restriction objects implement CPL::IRestrict.
// The most common restriction object CRestrictFunc simply calls a function
// provided to the object's constructor.  The function is called when the
// restriction status (restricted/allowed) is desired.  There is also 
// class CRestrictApplet for tasks who's presence is directly linked to 
// the presence/restriction of a particular CPL applet based on policy alone.
//
// Since there may be many task links on a given Control Panel page that
// means there will be multiple restriction expressions evaluated each 
// time the page is displayed.  Often the expressions across a set of 
// actions are evaluating many of the same terms.  Some of these terms require
// registry lookups.  To help performance, a simple caching mechanism 
// has been introduced into the 'namespace' object.  Each restriction function
// is passed a pointer to the current 'namespace' object.  As the namespace
// object remains alive the entire time the page is being constructed, it
// is an appropriate place to cache frequently used data.  You'll see
// many instances below where the namespace object is queried for restriction
// data.  The members of the namespace object associated with this restriction
// data are of type CTriState.  This simple class implements the concept of 
// an 'uninitialized boolean' value, allowing the code to determine if a given
// boolean member has yet to be initialized with a valid boolean value.  If
// the namespace is asked for the value of one of these tri-state booleans
// and that member has not yet been initialized, the namespace calls the 
// appropriate system functions and initializes the boolean value.  From that
// time forward, the member's value is returned immediately.  This ensures that
// for any given restriction term, we do the expensive stuff only once.
// Being an on-demand mechanism, we also gather only the information that is 
// needed.
//
// [brianau - 03/18/01]
//


HRESULT Restrict32CtrlPanel(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
#if !defined(_WIN64)
    hr = S_OK; // restricted.
#endif
    return hr;
}


HRESULT RestrictAlways(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    return S_OK;  // Always restricted.
}

HRESULT RestrictDisplayCpl(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowDeskCpl())
    {
        hr = S_OK;
    }
    return hr;
}    

HRESULT RestrictThemes(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowDeskCpl() || 
        SHRestricted(REST_NOTHEMESTAB) ||
        SHRestricted(REST_NODISPLAYAPPEARANCEPAGE))
    {
        hr = S_OK;
    }
    return hr;
}


HRESULT RestrictWallpaper(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowDeskCpl() ||
        SHRestricted(REST_NOCHANGINGWALLPAPER) ||
        !pns->AllowDeskCplTab_Background())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictScreenSaver(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowDeskCpl() ||
        !pns->AllowDeskCplTab_Screensaver())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictResolution(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowDeskCpl() ||
        !pns->AllowDeskCplTab_Settings())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}
    

HRESULT RestrictAddPrinter(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;
    if (SHRestricted(REST_NOPRINTERADD) ||
        !IsAppletEnabled(NULL, MAKEINTRESOURCEW(IDS_PRNANDFAXFOLDER)))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictRemoteDesktop(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->IsUserAdmin() ||     // Admins only.
         pns->IsPersonal() ||      // Not available on personal.
        !IsAppletEnabled(L"sysdm.cpl", MAKEINTRESOURCEW(IDS_CPL_SYSTEM)))   // Respect sysdm.cpl policy.
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictHomeNetwork(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;

    if (!pns->IsX86() ||           // x86 only.
         pns->IsOnDomain() ||      // Not available on domains.
         pns->IsServer() ||        // Not available on server.
        !pns->IsUserAdmin() ||     // Admins only.
        !IsAppletEnabled(L"hnetwiz.dll", NULL)) // Respect hnetwiz.dll policy.
    {
        hr = S_OK; // restricted.
    }
    return hr;
}
                

HRESULT RestrictTsNetworking(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Available on personal and professional only.
    //
    if (!(pns->IsPersonal() || pns->IsProfessional()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictTsInetExplorer(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Available on personal and professional only.
    //
    if (!(pns->IsPersonal() || pns->IsProfessional()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictTsModem(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Available on server only.
    //
    if (!pns->IsServer())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictTsSharing(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Available on server only.
    //
    if (!pns->IsServer())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


bool ShellKeyExists(SHELLKEY skey, LPCWSTR pszRegName)
{
    TCHAR szValue[MAX_PATH];

    DWORD cbValue = sizeof(szValue);
    return SUCCEEDED(SKGetValue(skey, 
                                pszRegName, 
                                NULL, 
                                NULL, 
                                szValue, 
                                &cbValue));
}    


HRESULT RestrictBackupData(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Not available if the 'backuppath' shell key is missing.
    //    This logic is the same as that used by the "Tools" page
    //    in a volume property sheet.
    //
    if (!ShellKeyExists(SHELLKEY_HKLM_EXPLORER, TEXT("MyComputer\\BackupPath")))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictDefrag(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    HRESULT hr = S_FALSE;
    //
    // Not available if the 'defragpath' shell key is missing.
    //    This logic is the same as that used by the "Tools" page
    //    in a volume property sheet.
    //
    if (!ShellKeyExists(SHELLKEY_HKLM_EXPLORER, TEXT("MyComputer\\DefragPath")))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictCleanUpDisk(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Not available if the 'cleanuppath' shell key is missing.
    //
    if (!ShellKeyExists(SHELLKEY_HKLM_EXPLORER, TEXT("MyComputer\\CleanupPath")))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictSystemRestore(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    //
    // Available only on x86.
    //
    if (!pns->IsX86() ||
        pns->IsServer() ||
        CPL::IsSystemRestoreRestricted())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictServerUserManager(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
         pns->UsePersonalUserManager())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictFolderOptions(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;
    if (SHRestricted(REST_NOFOLDEROPTIONS) ||
        !IsAppletEnabled(NULL, MAKEINTRESOURCEW(IDS_LOCALGDN_NS_FOLDEROPTIONS)))
    {
        hr = S_OK;
    }
    return hr;
}


HRESULT RestrictIfNoAppletsInCplCategory(ICplNamespace *pns, eCPCAT eCategory)
{
    int cCplApplets = 0;
    HRESULT hr = THR(CplNamespace_GetCategoryAppletCount(pns, eCategory, &cCplApplets));
    if (SUCCEEDED(hr))
    {
        if (0 == cCplApplets)
        {
            hr = S_OK; // 0 applets means we don't show the link.
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;
}

//
// If there are no CPL applets categorized under "Other",
// we hide the "Other CPL Options" link in the UI.
//
HRESULT RestrictOtherCplOptions(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!CPL::CategoryViewIsActive() ||
        S_OK == RestrictIfNoAppletsInCplCategory(pns, eCPCAT_OTHER))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictWindowsUpdate(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;
    //
    // First check the shell's restriction for the "Windows Update"
    // item in the start menu.  If the admin doesn't want access from
    // the start menu, they most likely don't want it from Control Panel either.
    //
    if (SHRestricted(REST_NOUPDATEWINDOWS))
    {
        hr = S_OK;
    }
    if (S_FALSE == hr)
    {
        //
        // Not restricted in start menu.
        // How about the global "Disable Windows Update" policy?
        //
        DWORD dwType;
        DWORD dwData;
        DWORD cbData = sizeof(dwData);
        
        if (ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER,
                                         L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\WindowsUpdate",
                                         L"DisableWindowsUpdateAccess",
                                         &dwType,
                                         &dwData,
                                         &cbData))
        {
            if (REG_DWORD == dwType && 1 == dwData)
            {
                hr = S_OK; // restricted.
            }
        }
    }
    return hr;
}


HRESULT RestrictAddLanguage(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->IsUserAdmin() || !IsAppletEnabled(L"intl.cpl", MAKEINTRESOURCEW(IDS_CPL_REGIONALOPTIONS)))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictAccountsCreate(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
        !pns->UsePersonalUserManager() ||
        !(pns->IsUserOwner() || pns->IsUserStandard()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictAccountsCreate2(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
         pns->UsePersonalUserManager() ||
        !(pns->IsUserOwner() || pns->IsUserStandard()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictAccountsChange(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
        !pns->UsePersonalUserManager() ||
        !(pns->IsUserOwner() || pns->IsUserStandard()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictAccountsPicture(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() || !pns->UsePersonalUserManager())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictLearnAboutAccounts(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() || !pns->UsePersonalUserManager())
    {
        hr = S_OK;
    }
    return hr;
}


HRESULT RestrictLearnAboutAccountTypes(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() || 
        !pns->UsePersonalUserManager() ||
        !IsUserAdmin())               // topic is for non-admins only.
    {
        hr = S_OK;  // restricted.
    }
    return hr;
}


HRESULT RestrictLearnAboutChangeName(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
        !pns->UsePersonalUserManager() ||
        !(pns->IsUserLimited() || pns->IsUserGuest()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictLearnAboutCreateAccount(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() ||
        !pns->UsePersonalUserManager() ||
        !(pns->IsUserLimited() || pns->IsUserGuest()))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictLearnAboutFUS(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->AllowUserManager() || !pns->UsePersonalUserManager())
    {
        hr = S_OK;
    }
    return hr;
}


HRESULT RestrictHardwareWizard(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->IsUserAdmin() ||
        !IsAppletEnabled(L"hdwwiz.cpl", MAKEINTRESOURCEW(IDS_CPL_ADDHARDWARE)))
    {
        hr = S_OK; // restricted.
    }
    return hr;
}

HRESULT RestrictVpnConnections(ICplNamespace *pns)
{
    HRESULT hr = S_FALSE;
    if (!pns->IsUserAdmin())
    {
        hr = S_OK; // restricted.
    }
    return hr;
}


HRESULT RestrictArp(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;

    //
    // Why we don't check SHRestricted(REST_ARP_NOARP)?
    //
    // 1. We don't hide category links for any reason.
    // 2. If that policy is enabled and appwiz.cpl is allowed,
    //    (remember, those are different policies)
    //    we'll display the ARP category page and it will still
    //    show the ARP applet icon.  Since there is at least one
    //    task link or icon, we don't display the "content disabled
    //    by your admin" barricade.  Then the user will click on the
    //    applet icon and get ARP's "I've been disabled" messagebox.
    // 
    // By not checking this policy, clicking on the category link
    // will invoke ARP and ARP will display it's message.
    // I think this is a better user experience.
    //
    if (!IsAppletEnabled(L"appwiz.cpl", MAKEINTRESOURCEW(IDS_CPL_ADDREMOVEPROGRAMS)))
    {
        hr = S_OK;  // restricted.
    }
    return hr;
}


//
// The ARP category (and it's tasks) are displayed only when there
// are 2+ applets registered for that category (ARP and one or more
// other applets).  Unlike RestrictArp() above, we DO want to consider
// SHRestricted(REST_ARP_NOARP).  This way if ARP is restricted in 
// ANY way, it's related tasks will not appear.  
//
HRESULT RestrictArpAddProgram(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;

    if (SHRestricted(REST_ARP_NOARP) ||
        SHRestricted(REST_ARP_NOADDPAGE) ||
        !IsAppletEnabled(L"appwiz.cpl", MAKEINTRESOURCEW(IDS_CPL_ADDREMOVEPROGRAMS)))
    {
        hr = S_OK;  // restricted.
    }
    return hr;
}

HRESULT RestrictArpRemoveProgram(ICplNamespace *pns)
{
    UNREFERENCED_PARAMETER(pns);
    
    HRESULT hr = S_FALSE;

    if (SHRestricted(REST_ARP_NOARP) ||
        SHRestricted(REST_ARP_NOREMOVEPAGE) ||
        !IsAppletEnabled(L"appwiz.cpl", MAKEINTRESOURCEW(IDS_CPL_ADDREMOVEPROGRAMS)))
    {
        hr = S_OK;  // restricted.
    }
    return hr;
}



//-----------------------------------------------------------------------------
// Restriction objects (alphabetical order please)
//-----------------------------------------------------------------------------
//
// To restrict an action, create a restriction object and associate it with the
// action in the Action object declarations below.
//
const CRestrictFunc   g_Restrict32CtrlPanel      (Restrict32CtrlPanel);
const CRestrictApplet g_RestrictAccessibility    (L"access.cpl", MAKEINTRESOURCEW(IDS_CPL_ACCESSIBILITYOPTIONS));
const CRestrictApplet g_RestrictAccessWizard     (L"accwiz.exe", NULL);
const CRestrictFunc   g_RestrictAccountsCreate   (RestrictAccountsCreate);
const CRestrictFunc   g_RestrictAccountsCreate2  (RestrictAccountsCreate2);
const CRestrictFunc   g_RestrictAccountsChange   (RestrictAccountsChange);
const CRestrictFunc   g_RestrictAccountsPicture  (RestrictAccountsPicture);
const CRestrictFunc   g_RestrictAccountsServer   (RestrictServerUserManager);
const CRestrictFunc   g_RestrictAddLanguage      (RestrictAddLanguage);
const CRestrictFunc   g_RestrictAddPrinter       (RestrictAddPrinter);
const CRestrictApplet g_RestrictAdminTools       (NULL, MAKEINTRESOURCEW(IDS_LOCALGDN_NS_ADMIN_TOOLS));
const CRestrictFunc   g_RestrictAlways           (RestrictAlways);
const CRestrictFunc   g_RestrictArp              (RestrictArp);
const CRestrictFunc   g_RestrictArpAddProgram    (RestrictArpAddProgram);
const CRestrictFunc   g_RestrictArpRemoveProgram (RestrictArpRemoveProgram);
const CRestrictFunc   g_RestrictBackupData       (RestrictBackupData);
const CRestrictFunc   g_RestrictCleanUpDisk      (RestrictCleanUpDisk);
const CRestrictApplet g_RestrictDateTime         (L"timedate.cpl", MAKEINTRESOURCEW(IDS_CPL_DATETIME));
const CRestrictFunc   g_RestrictDefrag           (RestrictDefrag);
const CRestrictFunc   g_RestrictDisplayCpl       (RestrictDisplayCpl);
const CRestrictFunc   g_RestrictFolderOptions    (RestrictFolderOptions);
const CRestrictApplet g_RestrictFontsFolder      (NULL, MAKEINTRESOURCEW(IDS_LOCALGDN_NS_FONTS));
const CRestrictFunc   g_RestrictHomeNetwork      (RestrictHomeNetwork);
const CRestrictFunc   g_RestrictHardwareWizard   (RestrictHardwareWizard);
const CRestrictApplet g_RestrictInternational    (L"intl.cpl", MAKEINTRESOURCEW(IDS_CPL_REGIONALOPTIONS));
const CRestrictFunc   g_RestrictLearnAboutAccounts     (RestrictLearnAboutAccounts);
const CRestrictFunc   g_RestrictLearnAboutAccountTypes (RestrictLearnAboutAccountTypes);
const CRestrictFunc   g_RestrictLearnAboutChangeName   (RestrictLearnAboutChangeName);
const CRestrictFunc   g_RestrictLearnAboutCreateAccount(RestrictLearnAboutCreateAccount);
const CRestrictFunc   g_RestrictLearnAboutFUS          (RestrictLearnAboutFUS);
const CRestrictApplet g_RestrictMousePointers    (L"main.cpl", MAKEINTRESOURCEW(IDS_CPL_MOUSE));
const CRestrictApplet g_RestrictNetConnections   (L"inetcpl.cpl", MAKEINTRESOURCEW(IDS_CPL_INTERNETOPTIONS));
const CRestrictFunc   g_RestrictOtherCplOptions  (RestrictOtherCplOptions);
const CRestrictApplet g_RestrictPhoneModemCpl    (L"telephon.cpl", MAKEINTRESOURCEW(IDS_CPL_PHONEANDMODEMOPTIONS));
const CRestrictApplet g_RestrictPowerOptions     (L"powercfg.cpl", MAKEINTRESOURCEW(IDS_CPL_POWEROPTIONS));
const CRestrictApplet g_RestrictPrinters         (NULL, MAKEINTRESOURCEW(IDS_PRNANDFAXFOLDER));
const CRestrictFunc   g_RestrictRemoteDesktop    (RestrictRemoteDesktop);
const CRestrictFunc   g_RestrictResolution       (RestrictResolution);
const CRestrictApplet g_RestrictScannersCameras  (NULL, MAKEINTRESOURCEW(IDS_CPL_SCANNERSANDCAMERAS));
const CRestrictFunc   g_RestrictScreenSaver      (RestrictScreenSaver);
const CRestrictApplet g_RestrictScheduledTasks   (NULL, MAKEINTRESOURCEW(IDS_LOCALGDN_LNK_SCHEDULED_TASKS));
const CRestrictApplet g_RestrictSounds           (L"mmsys.cpl", MAKEINTRESOURCEW(IDS_CPL_SOUNDSANDAUDIO));
const CRestrictApplet g_RestrictSystemCpl        (L"sysdm.cpl", MAKEINTRESOURCEW(IDS_CPL_SYSTEM));
const CRestrictFunc   g_RestrictSystemRestore    (RestrictSystemRestore);
const CRestrictApplet g_RestrictTaskbarProps     (NULL, MAKEINTRESOURCEW(IDS_CP_TASKBARANDSTARTMENU));
const CRestrictFunc   g_RestrictThemes           (RestrictThemes);
const CRestrictFunc   g_RestrictTsModem          (RestrictTsModem);
const CRestrictFunc   g_RestrictTsInetExplorer   (RestrictTsInetExplorer);
const CRestrictFunc   g_RestrictTsNetworking     (RestrictTsNetworking);
const CRestrictFunc   g_RestrictTsSharing        (RestrictTsSharing);
const CRestrictApplet g_RestrictUserManager      (L"nusrmgr.cpl", MAKEINTRESOURCEW(IDS_CPL_USERACCOUNTS));
const CRestrictFunc   g_RestrictVpnConnections   (RestrictVpnConnections);
const CRestrictFunc   g_RestrictWallpaper        (RestrictWallpaper);
const CRestrictFunc   g_RestrictWindowsUpdate    (RestrictWindowsUpdate);


//-----------------------------------------------------------------------------
// Resource functions
//-----------------------------------------------------------------------------

//
// The tooltip for the accounts manager varies based upon the capabilities
// of the application used.  On Personal we provide the ability to associate
// a user's picture with their account.  The tooltip mentions this.  On server
// this capability is not present.  Therefore, the tooltip must not mention
// this.
//
LPCWSTR GetCatAccountsInfotip(ICplNamespace *pns)
{
    if (pns->AllowUserManager() && pns->UsePersonalUserManager())
    {
        return MAKEINTRESOURCEW(IDS_CPCAT_ACCOUNTS_INFOTIP);
    }
    else
    {
        //
        // Personal user manager is restricted.  Display the 
        // infotip without the term "picture".
        //
        return MAKEINTRESOURCEW(IDS_CPCAT_ACCOUNTS_INFOTIP2);
    }
}


LPCWSTR GetAccountsInfotip(ICplNamespace *pns)
{
    if (pns->AllowUserManager() && pns->UsePersonalUserManager()) 
    {
        return MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSMANAGE_INFOTIP);
    }
    else
    {
        //
        // Personal user manager is restricted.  Display the 
        // infotip without the term "picture".
        //
        return MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSMANAGE_INFOTIP2);
    }
}


LPCWSTR GetTsNetworkTitle(ICplNamespace *pns)
{
    if ((pns->IsPersonal() || pns->IsProfessional()) && !pns->IsOnDomain())
    {
        return MAKEINTRESOURCE(IDS_CPTASK_TSHOMENETWORKING_TITLE);
    }
    else
    {
        return MAKEINTRESOURCE(IDS_CPTASK_TSNETWORK_TITLE);
    }
}


//-----------------------------------------------------------------------------
// Action objects (alphabetical order please)
//-----------------------------------------------------------------------------
//
// Each object represents some action taken when a link in Control Panel is 
// selected.  Actions are associated with links in the g_Link_XXXX declarations below.
//
const CShellExecute        g_LinkAction_32CtrlPanel       (L"%SystemRoot%\\SysWOW64\\explorer.exe", L"/N,/SEPARATE,\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\"", &g_Restrict32CtrlPanel);
const CShellExecuteSysDir  g_LinkAction_AccessWizard      (L"accwiz.exe", NULL, &g_RestrictAccessWizard);
const COpenUserMgrApplet   g_LinkAction_Accounts          (&g_RestrictUserManager);
const COpenCplAppletSysDir g_LinkAction_AccountsChange    (L"nusrmgr.cpl ,initialTask=ChangeAccount", &g_RestrictAccountsChange);
const COpenCplAppletSysDir g_LinkAction_AccountsCreate    (L"nusrmgr.cpl ,initialTask=CreateAccount", &g_RestrictAccountsCreate);
const COpenCplAppletSysDir g_LinkAction_AccountsCreate2   (L"nusrmgr.cpl", &g_RestrictAccountsCreate2);
const COpenCplAppletSysDir g_LinkAction_AccountsPict      (L"nusrmgr.cpl ,initialTask=ChangePicture", &g_RestrictAccountsPicture);
const CAddPrinter          g_LinkAction_AddPrinter        (&g_RestrictAddPrinter);
const COpenCplAppletSysDir g_LinkAction_AddProgram        (L"appwiz.cpl ,1", &g_RestrictArpAddProgram);
const COpenCplAppletSysDir g_LinkAction_Arp               (L"appwiz.cpl", &g_RestrictArp);
const COpenCplAppletSysDir g_LinkAction_AutoUpdate        (L"sysdm.cpl ,@wuaueng.dll,10000", &g_RestrictSystemCpl);
const CExecDiskUtil        g_LinkAction_BackupData        (eDISKUTIL_BACKUP, &g_RestrictBackupData);
const COpenCplCategory     g_LinkAction_CatAccessibility  (eCPCAT_ACCESSIBILITY);
const COpenCplCategory2    g_LinkAction_CatAccounts       (eCPCAT_ACCOUNTS, &g_LinkAction_Accounts);
const COpenCplCategory     g_LinkAction_CatAppearance     (eCPCAT_APPEARANCE);
const COpenCplCategory2    g_LinkAction_CatArp            (eCPCAT_ARP, &g_LinkAction_Arp);
const COpenCplCategory     g_LinkAction_CatHardware       (eCPCAT_HARDWARE);
const COpenCplCategory     g_LinkAction_CatNetwork        (eCPCAT_NETWORK);
const COpenCplCategory     g_LinkAction_CatOther          (eCPCAT_OTHER, &g_RestrictAlways);
const COpenCplCategory     g_LinkAction_CatPerfMaint      (eCPCAT_PERFMAINT);
const COpenCplCategory     g_LinkAction_CatRegional       (eCPCAT_REGIONAL);
const COpenCplCategory     g_LinkAction_CatSound          (eCPCAT_SOUND);
const CExecDiskUtil        g_LinkAction_CleanUpDisk       (eDISKUTIL_CLEANUP, &g_RestrictCleanUpDisk);
const COpenCplAppletSysDir g_LinkAction_DateTime          (L"timedate.cpl", &g_RestrictDateTime);
const CExecDiskUtil        g_LinkAction_Defrag            (eDISKUTIL_DEFRAG, &g_RestrictDefrag);
const COpenCplAppletSysDir g_LinkAction_DisplayCpl        (L"desk.cpl", &g_RestrictDisplayCpl);
const COpenDeskCpl         g_LinkAction_DisplayRes        (CPLTAB_DESK_SETTINGS, &g_RestrictResolution);
const COpenCplAppletSysDir g_LinkAction_DisplayTheme      (L"desk.cpl", &g_RestrictThemes);
const CRunDll32            g_LinkAction_FolderOptions     (L"shell32.dll,Options_RunDLL 0", &g_RestrictFolderOptions);
const CNavigateURL         g_LinkAction_FontsFolder       (L"shell:::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{D20EA4E1-3957-11d2-A40B-0C5020524152}", &g_RestrictFontsFolder);
const COpenCplAppletSysDir g_LinkAction_HardwareWizard    (L"hdwwiz.cpl", &g_RestrictHardwareWizard);
const CTrayCommand         g_LinkAction_HelpAndSupport    (IDM_HELPSEARCH);
const COpenCplAppletSysDir g_LinkAction_HighContrast      (L"access.cpl ,3", &g_RestrictAccessibility);
const CRunDll32            g_LinkAction_HomeNetWizard     (L"hnetwiz.dll,HomeNetWizardRunDll", &g_RestrictHomeNetwork);
const CShellExecuteSysDir  g_LinkAction_Magnifier         (L"magnify.exe");
const COpenCplAppletSysDir g_LinkAction_Language          (L"intl.cpl ,1", &g_RestrictAddLanguage);
const CNavigateURL         g_LinkAction_LearnAccounts            (L"ms-its:%windir%\\help\\nusrmgr.chm::/HelpWindowsAccounts.htm", &g_RestrictLearnAboutAccounts);
const CNavigateURL         g_LinkAction_LearnAccountsTypes       (L"ms-its:%windir%\\help\\nusrmgr.chm::/HelpAccountTypes.htm", &g_RestrictLearnAboutAccountTypes);
const CNavigateURL         g_LinkAction_LearnAccountsChangeName  (L"ms-its:%windir%\\help\\nusrmgr.chm::/HelpChangeNonAdmin.htm", &g_RestrictLearnAboutChangeName);
const CNavigateURL         g_LinkAction_LearnAccountsCreate      (L"ms-its:%windir%\\help\\nusrmgr.chm::/HelpCreateAccount.htm", &g_RestrictLearnAboutCreateAccount);
const CNavigateURL         g_LinkAction_LearnSwitchUsers         (L"ms-its:%windir%\\help\\nusrmgr.chm::/HelpFUS.htm", &g_RestrictLearnAboutFUS);
const COpenCplAppletSysDir g_LinkAction_MousePointers     (L"main.cpl ,2", &g_RestrictMousePointers);
const CNavigateURL         g_LinkAction_MyComputer        (L"shell:DriveFolder");
const CNavigateURL         g_LinkAction_MyNetPlaces       (L"shell:::{208D2C60-3AEA-1069-A2D7-08002B30309D}");
const COpenCplAppletSysDir g_LinkAction_NetConnections    (L"inetcpl.cpl ,4", &g_RestrictNetConnections);
const CActionNYI           g_LinkAction_NotYetImpl        (L"Under construction");
const CShellExecuteSysDir  g_LinkAction_OnScreenKbd       (L"osk.exe");
const COpenCplCategory     g_LinkAction_OtherCplOptions   (eCPCAT_OTHER, &g_RestrictOtherCplOptions);
const COpenCplAppletSysDir g_LinkAction_PhoneModemCpl     (L"telephon.cpl", &g_RestrictPhoneModemCpl);
const COpenCplAppletSysDir g_LinkAction_PowerCpl          (L"powercfg.cpl", &g_RestrictPowerOptions);
const COpenCplAppletSysDir g_LinkAction_Region            (L"intl.cpl", &g_RestrictInternational);
const COpenCplAppletSysDir g_LinkAction_RemoteDesktop     (L"sysdm.cpl ,@remotepg.dll,10000", &g_RestrictRemoteDesktop);
const COpenCplAppletSysDir g_LinkAction_RemoveProgram     (L"appwiz.cpl ,0", &g_RestrictArpRemoveProgram);
const CNavigateURL         g_LinkAction_ScheduledTasks    (L"shell:::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{D6277990-4C6A-11CF-8D87-00AA0060F5BF}", &g_RestrictScheduledTasks);
const COpenDeskCpl         g_LinkAction_ScreenSaver       (CPLTAB_DESK_SCREENSAVER, &g_RestrictScreenSaver);
const COpenCplAppletSysDir g_LinkAction_SoundAccessibility(L"access.cpl ,2", &g_RestrictAccessibility);
const COpenCplCategory     g_LinkAction_Sounds            (eCPCAT_SOUND);
const COpenCplAppletSysDir g_LinkAction_SoundSchemes      (L"mmsys.cpl ,1", &g_RestrictSounds);
const COpenCplAppletSysDir g_LinkAction_SoundVolume       (L"mmsys.cpl ,0", &g_RestrictSounds);
const CShellExecuteSysDir  g_LinkAction_SoundVolumeAdv    (L"sndvol32.exe", NULL, &g_RestrictSounds);
const COpenCplView         g_LinkAction_SwToClassicView   (eCPVIEWTYPE_CLASSIC);
const COpenCplView         g_LinkAction_SwToCategoryView  (eCPVIEWTYPE_CATEGORY);
const COpenCplAppletSysDir g_LinkAction_SystemCpl         (L"sysdm.cpl ,@sysdm.cpl,10000", &g_RestrictSystemCpl);
const CShellExecuteSysDir  g_LinkAction_SystemRestore     (L"restore\\rstrui.exe", NULL, &g_RestrictSystemRestore);
const COpenTroubleshooter  g_LinkAction_TsDisplay         (L"tsdisp.htm");
const COpenTroubleshooter  g_LinkAction_TsDvd             (L"ts_dvd.htm");
const COpenTroubleshooter  g_LinkAction_TsHardware        (L"tshardw.htm");
const COpenTroubleshooter  g_LinkAction_TsInetExplorer    (L"tsie.htm", &g_RestrictTsInetExplorer);
const COpenTroubleshooter  g_LinkAction_TsModem           (L"tsmodem.htm", &g_RestrictTsModem);
const COpenTroubleshooter  g_LinkAction_TsNetwork         (L"tshomenet.htm", &g_RestrictTsNetworking);
const CNavigateURL         g_LinkAction_TsNetDiags        (L"hcp://system/netdiag/dglogs.htm");
const COpenTroubleshooter  g_LinkAction_TsPrinting        (L"tsprint.htm");
const COpenTroubleshooter  g_LinkAction_TsSharing         (L"tsnetwrk.htm", &g_RestrictTsSharing);
const COpenTroubleshooter  g_LinkAction_TsStartup         (L"tsstartup.htm");
const COpenTroubleshooter  g_LinkAction_TsSound           (L"tssound.htm");
const CNavigateURL         g_LinkAction_ViewPrinters      (L"shell:::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{2227A280-3AEA-1069-A2DE-08002B30309D}", &g_RestrictPrinters);
const COpenCplAppletSysDir g_LinkAction_VisualPerf        (L"sysdm.cpl ,-1", &g_RestrictSystemCpl);
const CRunDll32            g_LinkAction_VpnConnections    (L"netshell.dll,StartNCW 21010", &g_RestrictVpnConnections);
const COpenDeskCpl         g_LinkAction_Wallpaper         (CPLTAB_DESK_BACKGROUND, &g_RestrictWallpaper);
const CNavigateURL         g_LinkAction_WindowsUpdate     (L"http://www.microsoft.com/isapi/redir.dll?prd=Win2000&ar=WinUpdate", &g_RestrictWindowsUpdate);


//-----------------------------------------------------------------------------
// Link object initialization data (alphabetical order please)
//-----------------------------------------------------------------------------
//
// Each g_Link_XXXX variable represents a link in the Control Panel namespace.
// Note that if a particular link is displayed in multiple places in the Control Panel,
// only one instance of a g_Link_XXXX variable is required.
//
// The 'S' and 'T' in g_SLink and g_TLink mean "Support" and "Task" respectively.
// I've used the generic term "support" to refer to items that appear in one
// of the webview lists in the left-hand pane.
// We may have a link in a support list and in a category task list that essentially
// do the same thing but they have different icons and titles.  The 'S' and 'T'
// help differentiate.
//

const CResSrcStatic g_SLinkRes_32CtrlPanel_Icon(MAKEINTRESOURCEW(IDI_CPTASK_32CPLS));
const CResSrcStatic g_SLinkRes_32CtrlPanel_Title(MAKEINTRESOURCEW(IDS_CPTASK_32CPLS_TITLE));
const CResSrcStatic g_SLinkRes_32CtrlPanel_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_32CPLS_INFOTIP));
const CPLINK_DESC g_SLink_32CtrlPanel = {
    &g_SLinkRes_32CtrlPanel_Icon,
    &g_SLinkRes_32CtrlPanel_Title,
    &g_SLinkRes_32CtrlPanel_Infotip,
    &g_LinkAction_32CtrlPanel
    };

const CResSrcStatic g_TLinkRes_AccessWizard_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AccessWizard_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCESSWIZARD_TITLE));
const CResSrcStatic g_TLinkRes_AccessWizard_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ACCESSWIZARD_INFOTIP));
const CPLINK_DESC g_TLink_AccessWizard = {
    &g_TLinkRes_AccessWizard_Icon,
    &g_TLinkRes_AccessWizard_Title,
    &g_TLinkRes_AccessWizard_Infotip,
    &g_LinkAction_AccessWizard
    };   

const CResSrcStatic g_TLinkRes_AccountsChange_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AccountsChange_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSMANAGE_TITLE));
const CResSrcFunc   g_TLinkRes_AccountsChange_Infotip(GetAccountsInfotip);
const CPLINK_DESC g_TLink_AccountsChange = {
    &g_TLinkRes_AccountsChange_Icon,
    &g_TLinkRes_AccountsChange_Title,
    &g_TLinkRes_AccountsChange_Infotip,
    &g_LinkAction_AccountsChange
    };

const CResSrcStatic g_TLinkRes_AccountsCreate_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AccountsCreate_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSCREATE_TITLE));
const CResSrcStatic g_TLinkRes_AccountsCreate_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSCREATE_INFOTIP));
const CPLINK_DESC g_TLink_AccountsCreate = {
    &g_TLinkRes_AccountsCreate_Icon,
    &g_TLinkRes_AccountsCreate_Title,
    &g_TLinkRes_AccountsCreate_Infotip,
    &g_LinkAction_AccountsCreate
    };

//
// This link uses the same visual information as g_TLink_AccountsCreate above.
// The difference is in the action performed on selection.
//
const CPLINK_DESC g_TLink_AccountsCreate2 = {
    &g_TLinkRes_AccountsCreate_Icon,
    &g_TLinkRes_AccountsCreate_Title,
    &g_TLinkRes_AccountsCreate_Infotip,
    &g_LinkAction_AccountsCreate2
    };

const CResSrcStatic g_SLinkRes_AccountsPict_Icon(L"nusrmgr.cpl,-205");
const CResSrcStatic g_SLinkRes_AccountsPict_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSPICT_TITLE));
const CResSrcStatic g_SLinkRes_AccountsPict_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSPICT_INFOTIP));
const CPLINK_DESC g_SLink_AccountsPict = {
    &g_SLinkRes_AccountsPict_Icon,
    &g_SLinkRes_AccountsPict_Title,
    &g_SLinkRes_AccountsPict_Infotip,
    &g_LinkAction_AccountsPict
    };

const CResSrcStatic g_TLinkRes_AccountsPict_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AccountsPict_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSPICT2_TITLE));
const CResSrcStatic g_TLinkRes_AccountsPict_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSPICT2_INFOTIP));
const CPLINK_DESC g_TLink_AccountsPict = {
    &g_TLinkRes_AccountsPict_Icon,
    &g_TLinkRes_AccountsPict_Title,
    &g_TLinkRes_AccountsPict_Infotip,
    &g_LinkAction_AccountsPict
    };

const CResSrcStatic g_TLinkRes_Accounts_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_Accounts_Title(MAKEINTRESOURCEW(IDS_CPTASK_ACCOUNTSMANAGE_TITLE));
const CResSrcFunc   g_TLinkRes_Accounts_Infotip(GetAccountsInfotip);
const CPLINK_DESC g_TLink_Accounts = {
    &g_TLinkRes_Accounts_Icon,
    &g_TLinkRes_Accounts_Title,
    &g_TLinkRes_Accounts_Infotip,
    &g_LinkAction_Accounts
    };

const CResSrcStatic g_TLinkRes_AddPrinter_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AddPrinter_Title(MAKEINTRESOURCEW(IDS_CPTASK_ADDPRINTER_TITLE));
const CResSrcStatic g_TLinkRes_AddPrinter_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ADDPRINTER_INFOTIP));
const CPLINK_DESC g_TLink_AddPrinter = {
    &g_TLinkRes_AddPrinter_Icon,
    &g_TLinkRes_AddPrinter_Title,
    &g_TLinkRes_AddPrinter_Infotip,
    &g_LinkAction_AddPrinter
    };

const CResSrcStatic g_TLinkRes_AddProgram_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_AddProgram_Title(MAKEINTRESOURCEW(IDS_CPTASK_ADDPROGRAM_TITLE));
const CResSrcStatic g_TLinkRes_AddProgram_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ADDPROGRAM_INFOTIP));
const CPLINK_DESC g_TLink_AddProgram = {
    &g_TLinkRes_AddProgram_Icon,
    &g_TLinkRes_AddProgram_Title,
    &g_TLinkRes_AddProgram_Infotip,
    &g_LinkAction_AddProgram
    };

//
// Note that the "Auto Updates" icon is the same as the "Windows Update" icon.
// This is the way the Windows Update folks want it.
//
const CResSrcStatic g_SLinkRes_AutoUpdate_Icon(MAKEINTRESOURCEW(IDI_WINUPDATE));
const CResSrcStatic g_SLinkRes_AutoUpdate_Title(MAKEINTRESOURCEW(IDS_CPTASK_AUTOUPDATE_TITLE));
const CResSrcStatic g_SLinkRes_AutoUpdate_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_AUTOUPDATE_INFOTIP));
const CPLINK_DESC g_SLink_AutoUpdate = {
    &g_SLinkRes_AutoUpdate_Icon,
    &g_SLinkRes_AutoUpdate_Title,
    &g_SLinkRes_AutoUpdate_Infotip,
    &g_LinkAction_AutoUpdate
    };

const CResSrcStatic g_TLinkRes_BackupData_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_BackupData_Title(MAKEINTRESOURCEW(IDS_CPTASK_BACKUPDATA_TITLE));
const CResSrcStatic g_TLinkRes_BackupData_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_BACKUPDATA_INFOTIP));
const CPLINK_DESC g_TLink_BackupData = {
    &g_TLinkRes_BackupData_Icon,
    &g_TLinkRes_BackupData_Title,
    &g_TLinkRes_BackupData_Infotip,
    &g_LinkAction_BackupData
    };

const CResSrcStatic g_TLinkRes_CatAccessibility_Icon(MAKEINTRESOURCEW(IDI_CPCAT_ACCESSIBILITY));
const CResSrcStatic g_TLinkRes_CatAccessibility_Title(MAKEINTRESOURCEW(IDS_CPCAT_ACCESSIBILITY_TITLE));
const CResSrcStatic g_TLinkRes_CatAccessibility_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_ACCESSIBILITY_INFOTIP));
const CPLINK_DESC g_TLink_CatAccessibility = { 
    &g_TLinkRes_CatAccessibility_Icon,
    &g_TLinkRes_CatAccessibility_Title,
    &g_TLinkRes_CatAccessibility_Infotip,
    &g_LinkAction_CatAccessibility
    };

const CResSrcStatic g_TLinkRes_CatAccounts_Icon(MAKEINTRESOURCEW(IDI_CPCAT_ACCOUNTS));
const CResSrcStatic g_TLinkRes_CatAccounts_Title(MAKEINTRESOURCEW(IDS_CPCAT_ACCOUNTS_TITLE));
const CResSrcFunc   g_TLinkRes_CatAccounts_Infotip(GetCatAccountsInfotip);
const CPLINK_DESC g_TLink_CatAccounts = {
    &g_TLinkRes_CatAccounts_Icon,
    &g_TLinkRes_CatAccounts_Title,
    &g_TLinkRes_CatAccounts_Infotip,
    &g_LinkAction_CatAccounts
    };

const CResSrcStatic g_TLinkRes_CatAppearance_Icon(MAKEINTRESOURCEW(IDI_CPCAT_APPEARANCE));
const CResSrcStatic g_TLinkRes_CatAppearance_Title(MAKEINTRESOURCEW(IDS_CPCAT_APPEARANCE_TITLE));
const CResSrcStatic g_TLinkRes_CatAppearance_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_APPEARANCE_INFOTIP));
const CPLINK_DESC g_TLink_CatAppearance = {
    &g_TLinkRes_CatAppearance_Icon,
    &g_TLinkRes_CatAppearance_Title,
    &g_TLinkRes_CatAppearance_Infotip,
    &g_LinkAction_CatAppearance
    };

const CResSrcStatic g_TLinkRes_CatArp_Icon(MAKEINTRESOURCEW(IDI_CPCAT_ARP));
const CResSrcStatic g_TLinkRes_CatArp_Title(MAKEINTRESOURCEW(IDS_CPCAT_ARP_TITLE));
const CResSrcStatic g_TLinkRes_CatArp_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_ARP_INFOTIP));
const CPLINK_DESC g_TLink_CatArp = {
    &g_TLinkRes_CatArp_Icon,
    &g_TLinkRes_CatArp_Title,
    &g_TLinkRes_CatArp_Infotip,
    &g_LinkAction_CatArp
    };

const CResSrcStatic g_TLinkRes_CatHardware_Icon(MAKEINTRESOURCEW(IDI_CPCAT_HARDWARE));
const CResSrcStatic g_TLinkRes_CatHardware_Title(MAKEINTRESOURCEW(IDS_CPCAT_HARDWARE_TITLE));
const CResSrcStatic g_TLinkRes_CatHardware_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_HARDWARE_INFOTIP));
const CPLINK_DESC g_TLink_CatHardware = {
    &g_TLinkRes_CatHardware_Icon,
    &g_TLinkRes_CatHardware_Title,
    &g_TLinkRes_CatHardware_Infotip,
    &g_LinkAction_CatHardware
    };

const CResSrcStatic g_TLinkRes_CatNetwork_Icon(MAKEINTRESOURCEW(IDI_CPCAT_NETWORK));
const CResSrcStatic g_TLinkRes_CatNetwork_Title(MAKEINTRESOURCEW(IDS_CPCAT_NETWORK_TITLE));
const CResSrcStatic g_TLinkRes_CatNetwork_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_NETWORK_INFOTIP));
const CPLINK_DESC g_TLink_CatNetwork = {
    &g_TLinkRes_CatNetwork_Icon,
    &g_TLinkRes_CatNetwork_Title,
    &g_TLinkRes_CatNetwork_Infotip,
    &g_LinkAction_CatNetwork
    };

const CResSrcStatic g_TLinkRes_CatOther_Icon(MAKEINTRESOURCEW(IDI_CPCAT_OTHERCPLS));
const CResSrcStatic g_TLinkRes_CatOther_Title(MAKEINTRESOURCEW(IDS_CPCAT_OTHERCPLS_TITLE));
const CResSrcStatic g_TLinkRes_CatOther_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_OTHERCPLS_INFOTIP));
const CPLINK_DESC g_TLink_CatOther = {
    &g_TLinkRes_CatOther_Icon,
    &g_TLinkRes_CatOther_Title,
    &g_TLinkRes_CatOther_Infotip,
    &g_LinkAction_CatOther
    };

const CResSrcStatic g_TLinkRes_CatPerfMaint_Icon(MAKEINTRESOURCEW(IDI_CPCAT_PERFMAINT));
const CResSrcStatic g_TLinkRes_CatPerfMaint_Title(MAKEINTRESOURCEW(IDS_CPCAT_PERFMAINT_TITLE));
const CResSrcStatic g_TLinkRes_CatPerfMaint_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_PERFMAINT_INFOTIP));
const CPLINK_DESC g_TLink_CatPerfMaint = {
    &g_TLinkRes_CatPerfMaint_Icon,
    &g_TLinkRes_CatPerfMaint_Title,
    &g_TLinkRes_CatPerfMaint_Infotip,
    &g_LinkAction_CatPerfMaint
    };

const CResSrcStatic g_TLinkRes_CatRegional_Icon(MAKEINTRESOURCEW(IDI_CPCAT_REGIONAL));
const CResSrcStatic g_TLinkRes_CatRegional_Title(MAKEINTRESOURCEW(IDS_CPCAT_REGIONAL_TITLE));
const CResSrcStatic g_TLinkRes_CatRegional_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_REGIONAL_INFOTIP));
const CPLINK_DESC g_TLink_CatRegional = {
    &g_TLinkRes_CatRegional_Icon,
    &g_TLinkRes_CatRegional_Title,
    &g_TLinkRes_CatRegional_Infotip,
    &g_LinkAction_CatRegional
    };

const CResSrcStatic g_TLinkRes_CatSound_Icon(MAKEINTRESOURCEW(IDI_CPCAT_SOUNDS));
const CResSrcStatic g_TLinkRes_CatSound_Title(MAKEINTRESOURCEW(IDS_CPCAT_SOUNDS_TITLE));
const CResSrcStatic g_TLinkRes_CatSound_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_SOUNDS_INFOTIP));
const CPLINK_DESC g_TLink_CatSound = {
    &g_TLinkRes_CatSound_Icon,
    &g_TLinkRes_CatSound_Title,
    &g_TLinkRes_CatSound_Infotip,
    &g_LinkAction_CatSound
    };

const CResSrcStatic g_TLinkRes_CleanUpDisk_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_CleanUpDisk_Title(MAKEINTRESOURCEW(IDS_CPTASK_CLEANUPDISK_TITLE));
const CResSrcStatic g_TLinkRes_CleanUpDisk_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_CLEANUPDISK_INFOTIP));
const CPLINK_DESC g_TLink_CleanUpDisk = {
    &g_TLinkRes_CleanUpDisk_Icon,
    &g_TLinkRes_CleanUpDisk_Title,
    &g_TLinkRes_CleanUpDisk_Infotip,
    &g_LinkAction_CleanUpDisk
    };

const CResSrcStatic g_TLinkRes_DateTime_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_DateTime_Title(MAKEINTRESOURCEW(IDS_CPTASK_DATETIME_TITLE));
const CResSrcStatic g_TLinkRes_DateTime_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_DATETIME_INFOTIP));
const CPLINK_DESC g_TLink_DateTime = {
    &g_TLinkRes_DateTime_Icon,
    &g_TLinkRes_DateTime_Title,
    &g_TLinkRes_DateTime_Infotip,
    &g_LinkAction_DateTime
    };

const CResSrcStatic g_TLinkRes_Defrag_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_Defrag_Title(MAKEINTRESOURCEW(IDS_CPTASK_DEFRAG_TITLE));
const CResSrcStatic g_TLinkRes_Defrag_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_DEFRAG_INFOTIP));
const CPLINK_DESC g_TLink_Defrag = {
    &g_TLinkRes_Defrag_Icon,
    &g_TLinkRes_Defrag_Title,
    &g_TLinkRes_Defrag_Infotip,
    &g_LinkAction_Defrag
    };

const CResSrcStatic g_SLinkRes_DisplayCpl_Icon(L"desk.cpl,0");
const CResSrcStatic g_SLinkRes_DisplayCpl_Title(MAKEINTRESOURCEW(IDS_CPTASK_DISPLAYCPL_TITLE));
const CResSrcStatic g_SLinkRes_DisplayCpl_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_DISPLAYCPL_INFOTIP));
const CPLINK_DESC g_SLink_DisplayCpl = {
    &g_SLinkRes_DisplayCpl_Icon,
    &g_SLinkRes_DisplayCpl_Title,
    &g_SLinkRes_DisplayCpl_Infotip,
    &g_LinkAction_DisplayCpl
    };

const CResSrcStatic g_TLinkRes_DisplayRes_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_DisplayRes_Title(MAKEINTRESOURCEW(IDS_CPTASK_RESOLUTION_TITLE));
const CResSrcStatic g_TLinkRes_DisplayRes_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_RESOLUTION_INFOTIP));
const CPLINK_DESC g_TLink_DisplayRes = {
    &g_TLinkRes_DisplayRes_Icon,
    &g_TLinkRes_DisplayRes_Title,
    &g_TLinkRes_DisplayRes_Infotip,
    &g_LinkAction_DisplayRes
    };

const CResSrcStatic g_TLinkRes_DisplayTheme_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_DisplayTheme_Title(MAKEINTRESOURCEW(IDS_CPTASK_THEME_TITLE));
const CResSrcStatic g_TLinkRes_DisplayTheme_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_THEME_INFOTIP));
const CPLINK_DESC g_TLink_DisplayTheme = {
    &g_TLinkRes_DisplayTheme_Icon,
    &g_TLinkRes_DisplayTheme_Title,
    &g_TLinkRes_DisplayTheme_Infotip,
    &g_LinkAction_DisplayTheme
    };

const CResSrcStatic g_SLinkRes_FileTypes_Icon(MAKEINTRESOURCEW(IDI_FOLDEROPTIONS));
const CResSrcStatic g_SLinkRes_FileTypes_Title(MAKEINTRESOURCEW(IDS_CPTASK_FILETYPES_TITLE));
const CResSrcStatic g_SLinkRes_FileTypes_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_FILETYPES_INFOTIP));
const CPLINK_DESC g_SLink_FileTypes = {
    &g_SLinkRes_FileTypes_Icon,
    &g_SLinkRes_FileTypes_Title,
    &g_SLinkRes_FileTypes_Infotip,
    &g_LinkAction_FolderOptions
    };

const CResSrcStatic g_TLinkRes_FolderOptions_Icon(MAKEINTRESOURCEW(IDI_FOLDEROPTIONS));
const CResSrcStatic g_TLinkRes_FolderOptions_Title(MAKEINTRESOURCEW(IDS_CPTASK_FOLDEROPTIONS_TITLE));
const CResSrcStatic g_TLinkRes_FolderOptions_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_FOLDEROPTIONS_INFOTIP));
const CPLINK_DESC g_SLink_FolderOptions = {
    &g_TLinkRes_FolderOptions_Icon,
    &g_TLinkRes_FolderOptions_Title,
    &g_TLinkRes_FolderOptions_Infotip,
    &g_LinkAction_FolderOptions
    };

const CResSrcStatic g_SLinkRes_FontsFolder_Icon(MAKEINTRESOURCEW(IDI_STFONTS));
const CResSrcStatic g_SLinkRes_FontsFolder_Title(MAKEINTRESOURCEW(IDS_CPTASK_FONTS_TITLE));
const CResSrcStatic g_SLinkRes_FontsFolder_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_FONTS_INFOTIP));
const CPLINK_DESC g_SLink_FontsFolder = {
    &g_SLinkRes_FontsFolder_Icon,
    &g_SLinkRes_FontsFolder_Title,
    &g_SLinkRes_FontsFolder_Infotip,
    &g_LinkAction_FontsFolder
    };

const CResSrcStatic g_SLinkRes_Hardware_Icon(MAKEINTRESOURCEW(IDI_CPCAT_HARDWARE));
const CResSrcStatic g_SLinkRes_Hardware_Title(MAKEINTRESOURCEW(IDS_CPCAT_HARDWARE_TITLE));
const CResSrcStatic g_SLinkRes_Hardware_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_HARDWARE_INFOTIP));
const CPLINK_DESC g_SLink_Hardware = {
    &g_SLinkRes_Hardware_Icon,
    &g_SLinkRes_Hardware_Title,
    &g_SLinkRes_Hardware_Infotip,
    &g_LinkAction_CatHardware
    };

const CResSrcStatic g_SLinkRes_HardwareWizard_Icon(L"hdwwiz.cpl,0");
const CResSrcStatic g_SLinkRes_HardwareWizard_Title(MAKEINTRESOURCEW(IDS_CPTASK_HARDWAREWIZ_TITLE));
const CResSrcStatic g_SLinkRes_HardwareWizard_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_HARDWAREWIZ_INFOTIP));
const CPLINK_DESC g_SLink_HardwareWizard = {
    &g_SLinkRes_HardwareWizard_Icon,
    &g_SLinkRes_HardwareWizard_Title,
    &g_SLinkRes_HardwareWizard_Infotip,
    &g_LinkAction_HardwareWizard
    };

const CResSrcStatic g_SLinkRes_HelpAndSupport_Icon(MAKEINTRESOURCEW(IDI_STHELP));
const CResSrcStatic g_SLinkRes_HelpAndSupport_Title(MAKEINTRESOURCEW(IDS_CPTASK_HELPANDSUPPORT_TITLE));
const CResSrcStatic g_SLinkRes_HelpAndSupport_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_HELPANDSUPPORT_INFOTIP));
const CPLINK_DESC g_SLink_HelpAndSupport = {
    &g_SLinkRes_HelpAndSupport_Icon,
    &g_SLinkRes_HelpAndSupport_Title,
    &g_SLinkRes_HelpAndSupport_Infotip,
    &g_LinkAction_HelpAndSupport
    };

const CResSrcStatic g_SLinkRes_HighContrast_Icon(MAKEINTRESOURCEW(IDI_CPTASK_HIGHCONTRAST));
const CResSrcStatic g_SLinkRes_HighContrast_Title(MAKEINTRESOURCEW(IDS_CPTASK_HIGHCONTRAST_TITLE));
const CResSrcStatic g_SLinkRes_HighContrast_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_HIGHCONTRAST_INFOTIP));
const CPLINK_DESC g_SLink_HighContrast = {
    &g_SLinkRes_HighContrast_Icon,
    &g_SLinkRes_HighContrast_Title,
    &g_SLinkRes_HighContrast_Infotip,
    &g_LinkAction_HighContrast
    };

const CResSrcStatic g_TLinkRes_HighContrast_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_HighContrast_Title(MAKEINTRESOURCEW(IDS_CPTASK_TURNONHIGHCONTRAST_TITLE));
const CResSrcStatic g_TLinkRes_HighContrast_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TURNONHIGHCONTRAST_INFOTIP));
const CPLINK_DESC g_TLink_HighContrast = {
    &g_TLinkRes_HighContrast_Icon,
    &g_TLinkRes_HighContrast_Title,
    &g_TLinkRes_HighContrast_Infotip,
    &g_LinkAction_HighContrast
    };

const CResSrcStatic g_TLinkRes_HomeNetWizard_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_HomeNetWizard_Title(MAKEINTRESOURCEW(IDS_CPTASK_HOMENETWORK_TITLE));
const CResSrcStatic g_TLinkRes_HomeNetWizard_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_HOMENETWORK_INFOTIP));
const CPLINK_DESC g_TLink_HomeNetWizard = {
    &g_TLinkRes_HomeNetWizard_Icon,
    &g_TLinkRes_HomeNetWizard_Title,
    &g_TLinkRes_HomeNetWizard_Infotip,
    &g_LinkAction_HomeNetWizard
    };

const CResSrcStatic g_TLinkRes_Language_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_Language_Title(MAKEINTRESOURCEW(IDS_CPTASK_LANGUAGE_TITLE));
const CResSrcStatic g_TLinkRes_Language_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_LANGUAGE_INFOTIP));
const CPLINK_DESC g_TLink_Language = {
    &g_TLinkRes_Language_Icon,
    &g_TLinkRes_Language_Title,
    &g_TLinkRes_Language_Infotip,
    &g_LinkAction_Language
    };

//
// Learn-about topics use a standard icon and have no infotip.
//
const CResSrcStatic g_SLinkRes_LearnAbout_Icon(MAKEINTRESOURCE(IDI_CPTASK_LEARNABOUT));
const CResSrcNone g_SLinkRes_LearnAbout_Infotip;

const CResSrcStatic g_SLinkRes_LearnAccounts_Title(MAKEINTRESOURCE(IDS_CPTASK_LEARNACCOUNTS_TITLE));
const CPLINK_DESC g_SLink_LearnAccounts = {
    &g_SLinkRes_LearnAbout_Icon,
    &g_SLinkRes_LearnAccounts_Title,
    &g_SLinkRes_LearnAbout_Infotip,
    &g_LinkAction_LearnAccounts
    };

const CResSrcStatic g_SLinkRes_LearnAccountsTypes_Title(MAKEINTRESOURCE(IDS_CPTASK_LEARNACCOUNTSTYPES_TITLE));
const CPLINK_DESC g_SLink_LearnAccountsTypes = {
    &g_SLinkRes_LearnAbout_Icon,
    &g_SLinkRes_LearnAccountsTypes_Title,
    &g_SLinkRes_LearnAbout_Infotip,
    &g_LinkAction_LearnAccountsTypes
    };

const CResSrcStatic g_SLinkRes_LearnAccountsChangeName_Title(MAKEINTRESOURCE(IDS_CPTASK_LEARNACCOUNTSCHANGENAME_TITLE));
const CPLINK_DESC g_SLink_LearnAccountsChangeName = {
    &g_SLinkRes_LearnAbout_Icon,
    &g_SLinkRes_LearnAccountsChangeName_Title,
    &g_SLinkRes_LearnAbout_Infotip,
    &g_LinkAction_LearnAccountsChangeName
    };

const CResSrcStatic g_SLinkRes_LearnAccountsCreate_Title(MAKEINTRESOURCE(IDS_CPTASK_LEARNACCOUNTSCREATE_TITLE));
const CPLINK_DESC g_SLink_LearnAccountsCreate = {
    &g_SLinkRes_LearnAbout_Icon,
    &g_SLinkRes_LearnAccountsCreate_Title,
    &g_SLinkRes_LearnAbout_Infotip,
    &g_LinkAction_LearnAccountsCreate
    };

const CResSrcStatic g_SLinkRes_LearnSwitchUsers_Title(MAKEINTRESOURCE(IDS_CPTASK_LEARNSWITCHUSERS_TITLE));
const CPLINK_DESC g_SLink_LearnSwitchUsers = {
    &g_SLinkRes_LearnAbout_Icon,
    &g_SLinkRes_LearnSwitchUsers_Title,
    &g_SLinkRes_LearnAbout_Infotip,
    &g_LinkAction_LearnSwitchUsers
    };

const CResSrcStatic g_SLinkRes_Magnifier_Icon(MAKEINTRESOURCEW(IDI_CPTASK_MAGNIFIER));
const CResSrcStatic g_SLinkRes_Magnifier_Title(MAKEINTRESOURCEW(IDS_CPTASK_MAGNIFIER_TITLE));
const CResSrcStatic g_SLinkRes_Magnifier_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_MAGNIFIER_INFOTIP));
const CPLINK_DESC g_SLink_Magnifier = {
    &g_SLinkRes_Magnifier_Icon,
    &g_SLinkRes_Magnifier_Title,
    &g_SLinkRes_Magnifier_Infotip,
    &g_LinkAction_Magnifier
    };

const CResSrcStatic g_SLinkRes_MousePointers_Icon(L"main.cpl,0");
const CResSrcStatic g_SLinkRes_MousePointers_Title(MAKEINTRESOURCEW(IDS_CPTASK_MOUSEPOINTERS_TITLE));
const CResSrcStatic g_SLinkRes_MousePointers_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_MOUSEPOINTERS_INFOTIP));
const CPLINK_DESC g_SLink_MousePointers = {
    &g_SLinkRes_MousePointers_Icon,
    &g_SLinkRes_MousePointers_Title,
    &g_SLinkRes_MousePointers_Infotip,
    &g_LinkAction_MousePointers
    };

const CResSrcStatic g_SLinkRes_MyComputer_Icon(L"explorer.exe,0");
const CResSrcStatic g_SLinkRes_MyComputer_Title(MAKEINTRESOURCEW(IDS_CPTASK_MYCOMPUTER_TITLE));
const CResSrcStatic g_SLinkRes_MyComputer_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_MYCOMPUTER_INFOTIP));
const CPLINK_DESC g_SLink_MyComputer = {
    &g_SLinkRes_MyComputer_Icon,
    &g_SLinkRes_MyComputer_Title,
    &g_SLinkRes_MyComputer_Infotip,
    &g_LinkAction_MyComputer
    };

const CResSrcStatic g_SLinkRes_MyNetPlaces_Icon(MAKEINTRESOURCEW(IDI_NETCONNECT));
const CResSrcStatic g_SLinkRes_MyNetPlaces_Title(MAKEINTRESOURCEW(IDS_CPTASK_MYNETPLACES_TITLE));
const CResSrcStatic g_SLinkRes_MyNetPlaces_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_MYNETPLACES_INFOTIP));
const CPLINK_DESC g_SLink_MyNetPlaces = {
    &g_SLinkRes_MyNetPlaces_Icon,
    &g_SLinkRes_MyNetPlaces_Title,
    &g_SLinkRes_MyNetPlaces_Infotip,
    &g_LinkAction_MyNetPlaces
    };

const CResSrcStatic g_TLinkRes_NetConnections_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_NetConnections_Title(MAKEINTRESOURCEW(IDS_CPTASK_NETCONNECTION_TITLE));
const CResSrcStatic g_TLinkRes_NetConnections_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_NETCONNECTION_INFOTIP));
const CPLINK_DESC g_TLink_NetConnections = {
    &g_TLinkRes_NetConnections_Icon,
    &g_TLinkRes_NetConnections_Title,
    &g_TLinkRes_NetConnections_Infotip,
    &g_LinkAction_NetConnections
    };

const CResSrcStatic g_SLinkRes_OnScreenKbd_Icon(MAKEINTRESOURCEW(IDI_CPTASK_ONSCREENKBD));
const CResSrcStatic g_SLinkRes_OnScreenKbd_Title(MAKEINTRESOURCEW(IDS_CPTASK_ONSCREENKBD_TITLE));
const CResSrcStatic g_SLinkRes_OnScreenKbd_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_ONSCREENKBD_INFOTIP));
const CPLINK_DESC g_SLink_OnScreenKbd = {
    &g_SLinkRes_OnScreenKbd_Icon,
    &g_SLinkRes_OnScreenKbd_Title,
    &g_SLinkRes_OnScreenKbd_Infotip,
    &g_LinkAction_OnScreenKbd
    };

const CResSrcStatic g_SLinkRes_OtherCplOptions_Icon(MAKEINTRESOURCEW(IDI_CPCAT_OTHERCPLS));
const CResSrcStatic g_SLinkRes_OtherCplOptions_Title(MAKEINTRESOURCEW(IDS_CPCAT_OTHERCPLS_TITLE));
const CResSrcStatic g_SLinkRes_OtherCplOptions_Infotip(MAKEINTRESOURCEW(IDS_CPCAT_OTHERCPLS_INFOTIP));
const CPLINK_DESC g_SLink_OtherCplOptions = {
    &g_SLinkRes_OtherCplOptions_Icon,
    &g_SLinkRes_OtherCplOptions_Title,
    &g_SLinkRes_OtherCplOptions_Infotip,
    &g_LinkAction_OtherCplOptions
    };

const CResSrcStatic g_SLinkRes_PhoneModemCpl_Icon(L"telephon.cpl,0");
const CResSrcStatic g_SLinkRes_PhoneModemCpl_Title(MAKEINTRESOURCEW(IDS_CPTASK_PHONEMODEMCPL_TITLE));
const CResSrcStatic g_SLinkRes_PhoneModemCpl_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_PHONEMODEMCPL_INFOTIP));
const CPLINK_DESC g_SLink_PhoneModemCpl = {
    &g_SLinkRes_PhoneModemCpl_Icon,
    &g_SLinkRes_PhoneModemCpl_Title,
    &g_SLinkRes_PhoneModemCpl_Infotip,
    &g_LinkAction_PhoneModemCpl
    };

const CResSrcStatic g_SLinkRes_PowerCpl_Icon(L"powercfg.cpl,-202");
const CResSrcStatic g_SLinkRes_PowerCpl_Title(MAKEINTRESOURCEW(IDS_CPTASK_POWERCPL_TITLE));
const CResSrcStatic g_SLinkRes_PowerCpl_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_POWERCPL_INFOTIP));
const CPLINK_DESC g_SLink_PowerCpl = {
    &g_SLinkRes_PowerCpl_Icon,
    &g_SLinkRes_PowerCpl_Title,
    &g_SLinkRes_PowerCpl_Infotip,
    &g_LinkAction_PowerCpl
    };

const CResSrcStatic g_TLinkRes_Region_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_Region_Title(MAKEINTRESOURCEW(IDS_CPTASK_CHANGEREGION_TITLE));
const CResSrcStatic g_TLinkRes_Region_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_CHANGEREGION_INFOTIP));
const CPLINK_DESC g_TLink_Region = {
    &g_TLinkRes_Region_Icon,
    &g_TLinkRes_Region_Title,
    &g_TLinkRes_Region_Infotip,
    &g_LinkAction_Region
    };

const CResSrcStatic g_SLinkRes_RemoteDesktop_Icon(L"remotepg.dll,0");
const CResSrcStatic g_SLinkRes_RemoteDesktop_Title(MAKEINTRESOURCEW(IDS_CPTASK_REMOTEDESKTOP_TITLE));
const CResSrcStatic g_SLinkRes_RemoteDesktop_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_REMOTEDESKTOP_INFOTIP));
const CPLINK_DESC g_SLink_RemoteDesktop = {
    &g_SLinkRes_RemoteDesktop_Icon,
    &g_SLinkRes_RemoteDesktop_Title,
    &g_SLinkRes_RemoteDesktop_Infotip,
    &g_LinkAction_RemoteDesktop
    };

const CResSrcStatic g_TLinkRes_RemoveProgram_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_RemoveProgram_Title(MAKEINTRESOURCEW(IDS_CPTASK_REMOVEPROGRAM_TITLE));
const CResSrcStatic g_TLinkRes_RemoveProgram_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_REMOVEPROGRAM_INFOTIP));
const CPLINK_DESC g_TLink_RemoveProgram = {
    &g_TLinkRes_RemoveProgram_Icon,
    &g_TLinkRes_RemoveProgram_Title,
    &g_TLinkRes_RemoveProgram_Infotip,
    &g_LinkAction_RemoveProgram
    };

const CResSrcStatic g_TLinkRes_ScreenSaver_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_ScreenSaver_Title(MAKEINTRESOURCE(IDS_CPTASK_SCREENSAVER_TITLE));
const CResSrcStatic g_TLinkRes_ScreenSaver_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SCREENSAVER_INFOTIP));
const CPLINK_DESC g_TLink_ScreenSaver = {
    &g_TLinkRes_ScreenSaver_Icon,
    &g_TLinkRes_ScreenSaver_Title,
    &g_TLinkRes_ScreenSaver_Infotip,
    &g_LinkAction_ScreenSaver
    };

const CResSrcStatic g_SLinkRes_ScheduledTasks_Icon(L"mstask.dll,-100");
const CResSrcStatic g_SLinkRes_ScheduledTasks_Title(MAKEINTRESOURCEW(IDS_CPTASK_SCHEDULEDTASKS_TITLE));
const CResSrcStatic g_SLinkRes_ScheduledTasks_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SCHEDULEDTASKS_INFOTIP));
const CPLINK_DESC g_SLink_ScheduledTasks = {
    &g_SLinkRes_ScheduledTasks_Icon,
    &g_SLinkRes_ScheduledTasks_Title,
    &g_SLinkRes_ScheduledTasks_Infotip,
    &g_LinkAction_ScheduledTasks
    };

const CResSrcStatic g_SLinkRes_Sounds_Icon(L"mmsys.cpl,0");
const CResSrcStatic g_SLinkRes_Sounds_Title(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDSCPL_TITLE));
const CResSrcStatic g_SLinkRes_Sounds_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDSCPL_INFOTIP));
const CPLINK_DESC g_SLink_Sounds = {
    &g_SLinkRes_Sounds_Icon,
    &g_SLinkRes_Sounds_Title,
    &g_SLinkRes_Sounds_Infotip,
    &g_LinkAction_Sounds
    };

const CResSrcStatic g_SLinkRes_SoundAccessibility_Icon(L"mmsys.cpl,0");
const CResSrcStatic g_SLinkRes_SoundAccessibility_Title(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDACCESSIBILITY_TITLE));
const CResSrcStatic g_SLinkRes_SoundAccessibility_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDACCESSIBILITY_INFOTIP));
const CPLINK_DESC g_SLink_SoundAccessibility = {
    &g_SLinkRes_SoundAccessibility_Icon,
    &g_SLinkRes_SoundAccessibility_Title,
    &g_SLinkRes_SoundAccessibility_Infotip,
    &g_LinkAction_SoundAccessibility
    };

const CResSrcStatic g_TLinkRes_SoundSchemes_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_SoundSchemes_Title(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDSCHEMES_TITLE));
const CResSrcStatic g_TLinkRes_SoundSchemes_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDSCHEMES_INFOTIP));
const CPLINK_DESC g_TLink_SoundSchemes = {
    &g_TLinkRes_SoundSchemes_Icon,
    &g_TLinkRes_SoundSchemes_Title,
    &g_TLinkRes_SoundSchemes_Infotip,
    &g_LinkAction_SoundSchemes
    };

const CResSrcStatic g_TLinkRes_SoundVolume_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_SoundVolume_Title(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDVOLUME_TITLE));
const CResSrcStatic g_TLinkRes_SoundVolume_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDVOLUME_INFOTIP));
const CPLINK_DESC g_TLink_SoundVolume = {
    &g_TLinkRes_SoundVolume_Icon,
    &g_TLinkRes_SoundVolume_Title,
    &g_TLinkRes_SoundVolume_Infotip,
    &g_LinkAction_SoundVolume
    };

const CResSrcStatic g_SLinkRes_SoundVolumeAdv_Icon(L"sndvol32.exe,-300");
const CResSrcStatic g_SLinkRes_SoundVolumeAdv_Title(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDVOLUMEADV_TITLE));
const CResSrcStatic g_SLinkRes_SoundVolumeAdv_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SOUNDVOLUMEADV_INFOTIP));
const CPLINK_DESC g_SLink_SoundVolumeAdv = {
    &g_SLinkRes_SoundVolumeAdv_Icon,
    &g_SLinkRes_SoundVolumeAdv_Title,
    &g_SLinkRes_SoundVolumeAdv_Infotip,
    &g_LinkAction_SoundVolumeAdv
    };

const CResSrcStatic g_TLinkRes_SpeakerSettings_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_SpeakerSettings_Title(MAKEINTRESOURCEW(IDS_CPTASK_SPEAKERSETTINGS_TITLE));
const CResSrcStatic g_TLinkRes_SpeakerSettings_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SPEAKERSETTINGS_INFOTIP));
const CPLINK_DESC g_TLink_SpeakerSettings = {
    &g_TLinkRes_SpeakerSettings_Icon,
    &g_TLinkRes_SpeakerSettings_Title,
    &g_TLinkRes_SpeakerSettings_Infotip,
    &g_LinkAction_SoundVolume
    };

const CResSrcStatic g_SLinkRes_SystemCpl_Icon(L"sysdm.cpl,0");
const CResSrcStatic g_SLinkRes_SystemCpl_Title(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMCPL_TITLE));
const CResSrcStatic g_SLinkRes_SystemCpl_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMCPL_INFOTIP));
const CPLINK_DESC g_SLink_SystemCpl = {
    &g_SLinkRes_SystemCpl_Icon,
    &g_SLinkRes_SystemCpl_Title,
    &g_SLinkRes_SystemCpl_Infotip,
    &g_LinkAction_SystemCpl
    };

const CResSrcStatic g_TLinkRes_SystemCpl_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_SystemCpl_Title(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMCPL_TITLE2));
const CResSrcStatic g_TLinkRes_SystemCpl_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMCPL_INFOTIP2));
const CPLINK_DESC g_TLink_SystemCpl = {
    &g_TLinkRes_SystemCpl_Icon,
    &g_TLinkRes_SystemCpl_Title,
    &g_TLinkRes_SystemCpl_Infotip,
    &g_LinkAction_SystemCpl
    };

const CResSrcStatic g_SLinkRes_SystemRestore_Icon(L"%systemroot%\\system32\\restore\\rstrui.exe,0");
const CResSrcStatic g_SLinkRes_SystemRestore_Title(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMRESTORE_TITLE));
const CResSrcStatic g_SLinkRes_SystemRestore_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SYSTEMRESTORE_INFOTIP));
const CPLINK_DESC g_SLink_SystemRestore = {
    &g_SLinkRes_SystemRestore_Icon,
    &g_SLinkRes_SystemRestore_Title,
    &g_SLinkRes_SystemRestore_Infotip,
    &g_LinkAction_SystemRestore
    };

const CResSrcStatic g_SLinkRes_SwToCategoryView_Icon(MAKEINTRESOURCEW(IDI_CPLFLD));
const CResSrcStatic g_SLinkRes_SwToCategoryView_Title(MAKEINTRESOURCEW(IDS_CPTASK_SWITCHTOCATEGORYVIEW_TITLE));
const CResSrcStatic g_SLinkRes_SwToCategoryView_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SWITCHTOCATEGORYVIEW_INFOTIP));
const CPLINK_DESC g_SLink_SwToCategoryView = {
    &g_SLinkRes_SwToCategoryView_Icon,
    &g_SLinkRes_SwToCategoryView_Title,
    &g_SLinkRes_SwToCategoryView_Infotip,
    &g_LinkAction_SwToCategoryView
    };

const CResSrcStatic g_SLinkRes_SwToClassicView_Icon(MAKEINTRESOURCEW(IDI_CPLFLD));
const CResSrcStatic g_SLinkRes_SwToClassicView_Title(MAKEINTRESOURCEW(IDS_CPTASK_SWITCHTOCLASSICVIEW_TITLE));
const CResSrcStatic g_SLinkRes_SwToClassicView_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_SWITCHTOCLASSICVIEW_INFOTIP));
const CPLINK_DESC g_SLink_SwToClassicView = {
    &g_SLinkRes_SwToClassicView_Icon,
    &g_SLinkRes_SwToClassicView_Title,
    &g_SLinkRes_SwToClassicView_Infotip,
    &g_LinkAction_SwToClassicView
    };

const CResSrcStatic g_SLinkRes_TsDisplay_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsDisplay_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSDISPLAY_TITLE));
const CResSrcStatic g_SLinkRes_TsDisplay_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSDISPLAY_INFOTIP));
const CPLINK_DESC g_SLink_TsDisplay = {
    &g_SLinkRes_TsDisplay_Icon,
    &g_SLinkRes_TsDisplay_Title,
    &g_SLinkRes_TsDisplay_Infotip,
    &g_LinkAction_TsDisplay
    };

const CResSrcStatic g_SLinkRes_TsDvd_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsDvd_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSDVD_TITLE));
const CResSrcStatic g_SLinkRes_TsDvd_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSDVD_INFOTIP));
const CPLINK_DESC g_SLink_TsDvd = {
    &g_SLinkRes_TsDvd_Icon,
    &g_SLinkRes_TsDvd_Title,
    &g_SLinkRes_TsDvd_Infotip,
    &g_LinkAction_TsDvd
    };

const CResSrcStatic g_SLinkRes_TsHardware_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsHardware_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSHARDWARE_TITLE));
const CResSrcStatic g_SLinkRes_TsHardware_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSHARDWARE_INFOTIP));
const CPLINK_DESC g_SLink_TsHardware = {
    &g_SLinkRes_TsHardware_Icon,
    &g_SLinkRes_TsHardware_Title,
    &g_SLinkRes_TsHardware_Infotip,
    &g_LinkAction_TsHardware
    };

const CResSrcStatic g_SLinkRes_TsInetExplorer_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsInetExplorer_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSINETEXPLORER_TITLE));
const CResSrcStatic g_SLinkRes_TsInetExplorer_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSINETEXPLORER_INFOTIP));
const CPLINK_DESC g_SLink_TsInetExplorer = {
    &g_SLinkRes_TsInetExplorer_Icon,
    &g_SLinkRes_TsInetExplorer_Title,
    &g_SLinkRes_TsInetExplorer_Infotip,
    &g_LinkAction_TsInetExplorer
    };

const CResSrcStatic g_SLinkRes_TsModem_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsModem_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSMODEM_TITLE));
const CResSrcStatic g_SLinkRes_TsModem_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSMODEM_INFOTIP));
const CPLINK_DESC g_SLink_TsModem = {
    &g_SLinkRes_TsModem_Icon,
    &g_SLinkRes_TsModem_Title,
    &g_SLinkRes_TsModem_Infotip,
    &g_LinkAction_TsModem
    };

const CResSrcStatic g_SLinkRes_TsNetDiags_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsNetDiags_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSNETDIAGS_TITLE));
const CResSrcStatic g_SLinkRes_TsNetDiags_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSNETDIAGS_INFOTIP));
const CPLINK_DESC g_SLink_TsNetDiags = {
    &g_SLinkRes_TsNetDiags_Icon,
    &g_SLinkRes_TsNetDiags_Title,
    &g_SLinkRes_TsNetDiags_Infotip,
    &g_LinkAction_TsNetDiags
    };

const CResSrcStatic g_SLinkRes_TsNetwork_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcFunc   g_SLinkRes_TsNetwork_Title(GetTsNetworkTitle);
const CResSrcStatic g_SLinkRes_TsNetwork_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSNETWORK_INFOTIP));
const CPLINK_DESC g_SLink_TsNetwork = {
    &g_SLinkRes_TsNetwork_Icon,
    &g_SLinkRes_TsNetwork_Title,
    &g_SLinkRes_TsNetwork_Infotip,
    &g_LinkAction_TsNetwork
    };

const CResSrcStatic g_SLinkRes_TsPrinting_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsPrinting_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSPRINTING_TITLE));
const CResSrcStatic g_SLinkRes_TsPrinting_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSPRINTING_INFOTIP));
const CPLINK_DESC g_SLink_TsPrinting = {
    &g_SLinkRes_TsPrinting_Icon,
    &g_SLinkRes_TsPrinting_Title,
    &g_SLinkRes_TsPrinting_Infotip,
    &g_LinkAction_TsPrinting
    };

const CResSrcStatic g_SLinkRes_TsSharing_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsSharing_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSFILESHARING_TITLE));
const CResSrcStatic g_SLinkRes_TsSharing_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSFILESHARING_INFOTIP));
const CPLINK_DESC g_SLink_TsSharing = {
    &g_SLinkRes_TsSharing_Icon,
    &g_SLinkRes_TsSharing_Title,
    &g_SLinkRes_TsSharing_Infotip,
    &g_LinkAction_TsSharing
    };

const CResSrcStatic g_SLinkRes_TsSound_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsSound_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSSOUND_TITLE));
const CResSrcStatic g_SLinkRes_TsSound_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSSOUND_INFOTIP));
const CPLINK_DESC g_SLink_TsSound = {
    &g_SLinkRes_TsSound_Icon,
    &g_SLinkRes_TsSound_Title,
    &g_SLinkRes_TsSound_Infotip,
    &g_LinkAction_TsSound
    };

const CResSrcStatic g_SLinkRes_TsStartup_Icon(MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER));
const CResSrcStatic g_SLinkRes_TsStartup_Title(MAKEINTRESOURCEW(IDS_CPTASK_TSSTARTUP_TITLE));
const CResSrcStatic g_SLinkRes_TsStartup_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_TSSTARTUP_INFOTIP));
const CPLINK_DESC g_SLink_TsStartup = {
    &g_SLinkRes_TsStartup_Icon,
    &g_SLinkRes_TsStartup_Title,
    &g_SLinkRes_TsStartup_Infotip,
    &g_LinkAction_TsStartup
    };

const CResSrcStatic g_TLinkRes_ViewPrinters_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_ViewPrinters_Title(MAKEINTRESOURCEW(IDS_CPTASK_VIEWPRINTERS_TITLE));
const CResSrcStatic g_TLinkRes_ViewPrinters_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_VIEWPRINTERS_INFOTIP));
const CPLINK_DESC g_TLink_ViewPrinters = {
    &g_TLinkRes_ViewPrinters_Icon,
    &g_TLinkRes_ViewPrinters_Title,
    &g_TLinkRes_ViewPrinters_Infotip,
    &g_LinkAction_ViewPrinters
    };



const CResSrcStatic g_TLinkRes_VisualPerf_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_VisualPerf_Title(MAKEINTRESOURCEW(IDS_CPTASK_VISUALPERF_TITLE));
const CResSrcStatic g_TLinkRes_VisualPerf_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_VISUALPERF_INFOTIP));
const CPLINK_DESC g_TLink_VisualPerf = {
    &g_TLinkRes_VisualPerf_Icon,
    &g_TLinkRes_VisualPerf_Title,
    &g_TLinkRes_VisualPerf_Infotip,
    &g_LinkAction_VisualPerf
    };

const CResSrcStatic g_TLinkRes_VpnConnections_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_VpnConnections_Title(MAKEINTRESOURCEW(IDS_CPTASK_VPNCONNECTION_TITLE));
const CResSrcStatic g_TLinkRes_VpnConnections_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_VPNCONNECTION_INFOTIP));
const CPLINK_DESC g_TLink_VpnConnections = {
    &g_TLinkRes_VpnConnections_Icon,
    &g_TLinkRes_VpnConnections_Title,
    &g_TLinkRes_VpnConnections_Infotip,
    &g_LinkAction_VpnConnections
    };

const CResSrcStatic g_TLinkRes_Wallpaper_Icon(MAKEINTRESOURCEW(IDI_CP_CATEGORYTASK));
const CResSrcStatic g_TLinkRes_Wallpaper_Title(MAKEINTRESOURCEW(IDS_CPTASK_WALLPAPER_TITLE));
const CResSrcStatic g_TLinkRes_Wallpaper_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_WALLPAPER_INFOTIP));
const CPLINK_DESC g_TLink_Wallpaper = {
    &g_TLinkRes_Wallpaper_Icon,
    &g_TLinkRes_Wallpaper_Title,
    &g_TLinkRes_Wallpaper_Infotip,
    &g_LinkAction_Wallpaper
    };

const CResSrcStatic g_SLinkRes_WindowsUpdate_Icon(MAKEINTRESOURCEW(IDI_WINUPDATE));
const CResSrcStatic g_SLinkRes_WindowsUpdate_Title(MAKEINTRESOURCEW(IDS_CPTASK_WINDOWSUPDATE_TITLE));
const CResSrcStatic g_SLinkRes_WindowsUpdate_Infotip(MAKEINTRESOURCEW(IDS_CPTASK_WINDOWSUPDATE_INFOTIP));
const CPLINK_DESC g_SLink_WindowsUpdate = {
    &g_SLinkRes_WindowsUpdate_Icon,
    &g_SLinkRes_WindowsUpdate_Title,
    &g_SLinkRes_WindowsUpdate_Infotip,
    &g_LinkAction_WindowsUpdate
    };



//-----------------------------------------------------------------------------
// View page definitions.
//-----------------------------------------------------------------------------

//
// Main Control Panel page.
//

const CPLINK_DESC *g_rgpLink_Cpl_SeeAlso[] = {
    &g_SLink_WindowsUpdate,
    &g_SLink_HelpAndSupport,
    &g_SLink_32CtrlPanel,
    &g_SLink_OtherCplOptions,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Cpl_SwToClassicView[] = {
    &g_SLink_SwToClassicView,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Cpl_SwToCategoryView[] = {
    &g_SLink_SwToCategoryView,
    NULL
    };


//
// Accounts category
//

const CPLINK_DESC *g_rgpLink_Accounts_Tasks[] = {
    &g_TLink_AccountsChange,
    &g_TLink_AccountsCreate,  // Active on non-server SKU
    &g_TLink_AccountsCreate2, // Active on server SKU
    &g_TLink_AccountsPict,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Accounts_SeeAlso[] = {
    &g_TLink_CatAppearance,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Accounts_LearnAbout[] = {
    &g_SLink_LearnAccounts,
    &g_SLink_LearnAccountsTypes,
    &g_SLink_LearnAccountsChangeName,
    &g_SLink_LearnAccountsCreate,
    &g_SLink_LearnSwitchUsers,
    NULL
    };

const CPCAT_DESC g_Category_Accounts = {
    eCPCAT_ACCOUNTS,
    L"Security_and_User_Accounts",
    &g_TLink_CatAccounts,
    g_rgpLink_Accounts_Tasks,
    { g_rgpLink_Accounts_SeeAlso, NULL, g_rgpLink_Accounts_LearnAbout }
    };



//
// Accessibility category
//

const CPLINK_DESC *g_rgpLink_Accessibility_Tasks[] = {
    &g_TLink_HighContrast,
    &g_TLink_AccessWizard,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Accessibility_SeeAlso[] = {
    &g_SLink_Magnifier,
    &g_SLink_OnScreenKbd,
    NULL
    };

const CPCAT_DESC g_Category_Accessibility = {
    eCPCAT_ACCESSIBILITY,
    L"Accessibility",
    &g_TLink_CatAccessibility,
    g_rgpLink_Accessibility_Tasks,
    { g_rgpLink_Accessibility_SeeAlso, NULL, NULL },
    };


//
// Appearance category
//

const CPLINK_DESC *g_rgpLink_Appearance_Tasks[] = {
    &g_TLink_DisplayTheme,
    &g_TLink_Wallpaper,
    &g_TLink_ScreenSaver,
    &g_TLink_DisplayRes,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Appearance_SeeAlso[] = {
    &g_SLink_FontsFolder,
    &g_SLink_MousePointers,
    &g_SLink_HighContrast,
    &g_SLink_AccountsPict,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Appearance_Troubleshoot[] = {
    &g_SLink_TsDisplay,
    &g_SLink_TsSound,
    NULL
    };

const CPCAT_DESC g_Category_Appearance = {
    eCPCAT_APPEARANCE,
    L"Appearance_and_Themes",
    &g_TLink_CatAppearance,
    g_rgpLink_Appearance_Tasks,
    { g_rgpLink_Appearance_SeeAlso, g_rgpLink_Appearance_Troubleshoot, NULL }
    };


//
// Add/Remove Programs (aka ARP) category
//

const CPLINK_DESC *g_rgpLink_Arp_SeeAlso[] = {
    &g_SLink_WindowsUpdate,
    &g_SLink_AutoUpdate,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Arp_Tasks[] = {
    &g_TLink_AddProgram,
    &g_TLink_RemoveProgram,
    NULL
    };

const CPCAT_DESC g_Category_Arp = {
    eCPCAT_ARP,
    L"Add_or_Remove_Programs",
    &g_TLink_CatArp,
    g_rgpLink_Arp_Tasks,
    { g_rgpLink_Arp_SeeAlso, NULL, NULL },
    };


//
// Hardware category
//

const CPLINK_DESC *g_rgpLink_Hardware_Tasks[] = {
    &g_TLink_ViewPrinters,
    &g_TLink_AddPrinter,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Hardware_SeeAlso[] = {
    &g_SLink_HardwareWizard,
    &g_SLink_DisplayCpl,
    &g_SLink_Sounds,
    &g_SLink_PowerCpl,
    &g_SLink_SystemCpl,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Hardware_Troubleshoot[] = {
    &g_SLink_TsHardware,
    &g_SLink_TsPrinting,
    &g_SLink_TsNetwork,
    NULL
    };

const CPCAT_DESC g_Category_Hardware = {
    eCPCAT_HARDWARE,
    L"Printers_and_Other_Hardware",
    &g_TLink_CatHardware,
    g_rgpLink_Hardware_Tasks,
    { g_rgpLink_Hardware_SeeAlso, g_rgpLink_Hardware_Troubleshoot, NULL }
    };


//
// Network category
//

const CPLINK_DESC *g_rgpLink_Network_Tasks[] = {
    &g_TLink_NetConnections,
    &g_TLink_VpnConnections,
    &g_TLink_HomeNetWizard,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Network_SeeAlso[] = {
    &g_SLink_MyNetPlaces,
    &g_SLink_Hardware,
    &g_SLink_RemoteDesktop,
    &g_SLink_PhoneModemCpl,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Network_Troubleshoot[] = {
    &g_SLink_TsNetwork,       // Pro/Personal only.
    &g_SLink_TsInetExplorer,  // Pro/Personal only.
    &g_SLink_TsSharing,       // Server only.
    &g_SLink_TsModem,         // Server only.
    &g_SLink_TsNetDiags,      // All SKUs.
    NULL
    };

const CPCAT_DESC g_Category_Network = {
    eCPCAT_NETWORK,
    L"Network_Connections",
    &g_TLink_CatNetwork,
    g_rgpLink_Network_Tasks,
    { g_rgpLink_Network_SeeAlso, g_rgpLink_Network_Troubleshoot, NULL }
    };


//
// Other CPLs category
//

const CPLINK_DESC *g_rgpLink_Other_SeeAlso[] = {
    &g_SLink_WindowsUpdate,
    &g_SLink_HelpAndSupport,
    NULL
    };

const CPCAT_DESC g_Category_Other = {
    eCPCAT_OTHER,
    NULL,   // "Other" uses std Control Panel help topic.
    &g_TLink_CatOther,
    NULL,
    { g_rgpLink_Other_SeeAlso, NULL, NULL }
    };

//
// PerfMaint category
//

const CPLINK_DESC *g_rgpLink_PerfMaint_Tasks[] = {
    &g_TLink_SystemCpl,
    &g_TLink_VisualPerf,
    &g_TLink_CleanUpDisk,
    &g_TLink_BackupData,
    &g_TLink_Defrag,
    NULL
    };

const CPLINK_DESC *g_rgpLink_PerfMaint_SeeAlso[] = {
    &g_SLink_FileTypes,
    &g_SLink_SystemRestore,
    NULL
    };

const CPLINK_DESC *g_rgpLink_PerfMaint_Troubleshoot[] = {
    &g_SLink_TsStartup,
    NULL
    };

const CPCAT_DESC g_Category_PerfMaint = {
    eCPCAT_PERFMAINT,
    L"Performance_and_Maintenance",
    &g_TLink_CatPerfMaint, 
    g_rgpLink_PerfMaint_Tasks,
    { g_rgpLink_PerfMaint_SeeAlso, g_rgpLink_PerfMaint_Troubleshoot, NULL },
    };


//
// Regional category
//

const CPLINK_DESC *g_rgpLink_Regional_Tasks[] = {
    &g_TLink_DateTime,
    &g_TLink_Region,
    &g_TLink_Language,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Regional_SeeAlso[] = {
    &g_SLink_ScheduledTasks,
    NULL
    };

const CPCAT_DESC g_Category_Regional = {
    eCPCAT_REGIONAL,
    L"Date__Time__Language_and_Regional_Settings",
    &g_TLink_CatRegional,
    g_rgpLink_Regional_Tasks,
    { g_rgpLink_Regional_SeeAlso, NULL, NULL },
    };


//
// Sound category
//

const CPLINK_DESC *g_rgpLink_Sound_Tasks[] = {
    &g_TLink_SoundVolume,
    &g_TLink_SoundSchemes,
    &g_TLink_SpeakerSettings,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Sound_SeeAlso[] = {
    &g_SLink_SoundAccessibility,
    &g_SLink_SoundVolumeAdv,
    NULL
    };

const CPLINK_DESC *g_rgpLink_Sound_Troubleshoot[] = {
    &g_SLink_TsSound,
    &g_SLink_TsDvd,
    NULL
    };

const CPCAT_DESC g_Category_Sound = {
    eCPCAT_SOUND,
    L"Sounds__Speech_and_Audio_Devices",
    &g_TLink_CatSound,
    g_rgpLink_Sound_Tasks,
    { g_rgpLink_Sound_SeeAlso, g_rgpLink_Sound_Troubleshoot, NULL }
    };



//
//              ********* IMPORTANT **********
//
// The order of these entries MUST match up with the category ID
// values in the cCPCAT enumeration.  These IDs also map directly
// to the SCID_CONTROLPANELCATEGORY value stored for each CPL
// applet in the registry.
//
// Code using a category ID will map directly to this array.
// Order of display in the Category selection view is handled 
// by the function CCplView::_DisplayIndexToCategoryIndex in
// cpview.cpp.
//
const CPCAT_DESC *g_rgpCplCatInfo[] = {
    &g_Category_Other,
    &g_Category_Appearance,
    &g_Category_Hardware,
    &g_Category_Network,
    &g_Category_Sound,
    &g_Category_PerfMaint,
    &g_Category_Regional,
    &g_Category_Accessibility,
    &g_Category_Arp,
    &g_Category_Accounts,
    NULL,
    };



//-----------------------------------------------------------------------------
// Helper functions used in support of the namespace.
//-----------------------------------------------------------------------------

//
// Copy one DPA of IUICommand ptrs to another.
// Returns:
//      S_OK   - All items copied.
//      Error  - Something failed.
//
HRESULT
CplNamespace_CopyCommandArray(
    const CDpaUiCommand& rgFrom,
    CDpaUiCommand *prgTo
    )
{
    ASSERT(NULL != prgTo);
    ASSERT(0 == prgTo->Count());

    HRESULT hr = S_OK;
    const int cCommands = rgFrom.Count();
    for (int i = 0; i < cCommands && SUCCEEDED(hr); i++)
    {
        IUICommand *pc = const_cast<IUICommand *>(rgFrom.Get(i));
        ASSERT(NULL != pc);

        if (-1 != prgTo->Append(pc))
        {
            pc->AddRef();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return THR(hr);
}


//
// Create a new IUICommand object from a CPLINK_DESC structure.
//
HRESULT
CplNamespace_CreateUiCommand(
    IUnknown *punkSite,
    const CPLINK_DESC& ld,
    IUICommand **ppc
    )
{
    ASSERT(NULL != ppc);
    ASSERT(!IsBadWritePtr(ppc, sizeof(*ppc)));

    *ppc = NULL;

    ICplNamespace *pns;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SControlPanelView, IID_ICplNamespace, (void **)&pns);
    if (SUCCEEDED(hr))
    {
        hr = CPL::Create_CplUiCommand(ld.prsrcName->GetResource(pns),
                                      ld.prsrcInfotip->GetResource(pns),
                                      ld.prsrcIcon->GetResource(pns),
                                      ld.pAction,
                                      IID_IUICommand,
                                      (void **)ppc);
        pns->Release();
    }
    return THR(hr);
}


//
// Create a new IUIElement object for a given webview type.
// The returned IUIElement object represents the header for
// the requested webview menu.
//
HRESULT
CplNamespace_CreateWebViewHeaderElement(
    eCPWVTYPE eType, 
    IUIElement **ppele
    )
{
    ASSERT(0 <= eType && eCPWVTYPE_NUMTYPES > eType);
    ASSERT(NULL != ppele);
    ASSERT(!IsBadWritePtr(ppele, sizeof(*ppele)));

    static const struct
    {
        LPCWSTR pszName;
        LPCWSTR pszInfotip;
        LPCWSTR pszIcon;

    } rgHeaderInfo[] = {
        //
        // eCPWVTYPE_CPANEL
        //
        {
            MAKEINTRESOURCEW(IDS_CONTROLPANEL),
            MAKEINTRESOURCEW(IDS_CPTASK_CONTROLPANEL_INFOTIP),
            MAKEINTRESOURCEW(IDI_CPLFLD)
        },
        //
        // eCPWVTYPE_SEEALSO
        //
        { 
            MAKEINTRESOURCEW(IDS_CPTASK_SEEALSO_TITLE),
            MAKEINTRESOURCEW(IDS_CPTASK_SEEALSO_INFOTIP),
            MAKEINTRESOURCEW(IDI_CPTASK_SEEALSO)
        },   
        //
        // eCPWVTYPE_TROUBLESHOOTER
        //
        { 
            MAKEINTRESOURCEW(IDS_CPTASK_TROUBLESHOOTER_TITLE),
            MAKEINTRESOURCEW(IDS_CPTASK_TROUBLESHOOTER_INFOTIP),
            MAKEINTRESOURCEW(IDI_CPTASK_TROUBLESHOOTER)
        },
        //
        // eCPWVTYPE_LEARNABOUT
        //
        { 
            MAKEINTRESOURCEW(IDS_CPTASK_LEARNABOUT_TITLE),
            MAKEINTRESOURCEW(IDS_CPTASK_LEARNABOUT_INFOTIP),
            MAKEINTRESOURCEW(IDI_CPTASK_LEARNABOUT)
        }
    };

    *ppele = NULL;

    HRESULT hr = Create_CplUiElement(rgHeaderInfo[eType].pszName,
                                     rgHeaderInfo[eType].pszInfotip,
                                     rgHeaderInfo[eType].pszIcon,
                                     IID_IUIElement,
                                     (void **)ppele);
    
    return THR(hr);
}



//-----------------------------------------------------------------------------
// UI Command Enumeration
//-----------------------------------------------------------------------------

class IEnumCommandBase
{
    public:
        virtual ~IEnumCommandBase() { }
        virtual HRESULT Next(IUnknown *punkSite, IUICommand **ppc) = 0;
        virtual HRESULT Skip(ULONG n) = 0;
        virtual HRESULT Reset(void) = 0;
        virtual HRESULT Clone(IEnumCommandBase **ppEnum) = 0;
};

//
// Used to enumerate UI Command objects that originate from static
// initialization information in the CPL namespace.
//
class CEnumCommand_LinkDesc : public IEnumCommandBase
{
    public:
        CEnumCommand_LinkDesc(const CPLINK_DESC **ppld);
        ~CEnumCommand_LinkDesc(void);

        HRESULT Next(IUnknown *punkSite, IUICommand **ppc);
        HRESULT Skip(ULONG n);
        HRESULT Reset(void);
        HRESULT Clone(IEnumCommandBase **ppEnum);

    private:
        const CPLINK_DESC ** const m_ppldFirst;  // First item in descriptor array.
        const CPLINK_DESC **m_ppldCurrent;       // 'Current' item referenced.
};


//
// Used to enumerate UI Command objects that already exist in
// a DPA of IUICommand pointers.  In particular, this is used
// to enumerate the UICommand objects that represent CPL applets
// in the user interface.
//
class CEnumCommand_Array : public IEnumCommandBase
{
    public:
        CEnumCommand_Array(void);
        ~CEnumCommand_Array(void);

        HRESULT Next(IUnknown *punkSite, IUICommand **ppc);
        HRESULT Skip(ULONG n);
        HRESULT Reset(void);
        HRESULT Clone(IEnumCommandBase **ppEnum);
        HRESULT Initialize(const CDpaUiCommand& rgCommands);

    private:
        CDpaUiCommand  m_rgCommands; // DPA of IUICommand ptrs.
        int            m_iCurrent;   // 'Current' item in enumeration.

        //
        // Prevent copy.
        //
        CEnumCommand_Array(const CEnumCommand_Array& rhs);              // not implemented.
        CEnumCommand_Array& operator = (const CEnumCommand_Array& rhs); // not implemented.
};




//-----------------------------------------------------------------------------
// CEnumCommand_LinkDesc implementation.
//-----------------------------------------------------------------------------

CEnumCommand_LinkDesc::CEnumCommand_LinkDesc(
    const CPLINK_DESC **ppld
    ) : m_ppldFirst(ppld),
        m_ppldCurrent(ppld)
{
    TraceMsg(TF_LIFE, "CEnumCommand_LinkDesc::CEnumCommand_LinkDesc, this = 0x%x", this);
}


CEnumCommand_LinkDesc::~CEnumCommand_LinkDesc(
    void
    )
{
    TraceMsg(TF_LIFE, "CEnumCommand_LinkDesc::~CEnumCommand_LinkDesc, this = 0x%x", this);
}


HRESULT
CEnumCommand_LinkDesc::Next(
    IUnknown *punkSite,
    IUICommand **ppc
    )
{
    ASSERT(NULL != ppc);
    ASSERT(!IsBadWritePtr(ppc, sizeof(*ppc)));

    HRESULT hr = S_FALSE;
    if (NULL != m_ppldCurrent && NULL != *m_ppldCurrent)
    {
        hr = CplNamespace_CreateUiCommand(punkSite, **m_ppldCurrent, ppc);
        m_ppldCurrent++;
    }
    return THR(hr);
}


HRESULT
CEnumCommand_LinkDesc::Reset(
    void
    )
{
    m_ppldCurrent = m_ppldFirst;
    return S_OK;
}


HRESULT
CEnumCommand_LinkDesc::Skip(
    ULONG n
    )
{
    if (NULL != m_ppldCurrent)
    {
        while(0 < n-- && NULL != *m_ppldCurrent)
        {
            m_ppldCurrent++;
        }
    }
    return 0 == n ? S_OK : S_FALSE;
}


HRESULT
CEnumCommand_LinkDesc::Clone(
    IEnumCommandBase **ppenum
    )
{
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = new CEnumCommand_LinkDesc(m_ppldFirst);
    if (NULL != *ppenum)
    {
        hr = S_OK;
    }
    return THR(hr);
}




//-----------------------------------------------------------------------------
// CEnumCommand_Array implementation.
//-----------------------------------------------------------------------------

CEnumCommand_Array::CEnumCommand_Array(
    void
    ) : m_iCurrent(0)
{
    TraceMsg(TF_LIFE, "CEnumCommand_Array::CEnumCommand_Array, this = 0x%x", this);
}

CEnumCommand_Array::~CEnumCommand_Array(
    void
    )
{
    TraceMsg(TF_LIFE, "CEnumCommand_Array::~CEnumCommand_Array, this = 0x%x", this);
}


HRESULT
CEnumCommand_Array::Initialize(
    const CDpaUiCommand& rgCommands
    )
{
    ASSERT(0 == m_rgCommands.Count());
    ASSERT(0 == m_iCurrent);
 
    HRESULT hr = CplNamespace_CopyCommandArray(rgCommands, &m_rgCommands);
    return THR(hr);
}
 
 
HRESULT
CEnumCommand_Array::Next(
    IUnknown *punkSite,
    IUICommand **ppc
    )
{
    ASSERT(NULL != ppc);
    ASSERT(!IsBadWritePtr(ppc, sizeof(*ppc)));

    UNREFERENCED_PARAMETER(punkSite);
    
    HRESULT hr = S_FALSE;
    if (m_iCurrent < m_rgCommands.Count())
    {
        *ppc = m_rgCommands.Get(m_iCurrent++);
        ASSERT(NULL != *ppc);

        (*ppc)->AddRef();
        hr = S_OK;
    }
    return THR(hr);
}



HRESULT
CEnumCommand_Array::Reset(
    void
    )
{
    m_iCurrent = 0;
    return S_OK;
}


HRESULT
CEnumCommand_Array::Skip(
    ULONG n
    )
{
    while(0 < n-- && m_iCurrent < m_rgCommands.Count())
    {
        m_iCurrent++;
    }
    return 0 == n ? S_OK : S_FALSE;
}


HRESULT
CEnumCommand_Array::Clone(
    IEnumCommandBase **ppenum
    )
{
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = new CEnumCommand_Array();
    if (NULL != *ppenum)
    {
        hr = static_cast<CEnumCommand_Array *>(*ppenum)->Initialize(m_rgCommands);
        if (FAILED(hr))
        {
            delete *ppenum;
            *ppenum = NULL;
        }
    }
    return THR(hr);
}



//-----------------------------------------------------------------------------
// CEnumCommand
//-----------------------------------------------------------------------------
//
// Enumerates IUICommand pointers for UICommand objects in the
// Control Panel namespace.
//
class CEnumCommand : public CObjectWithSite,
                     public IEnumUICommand
{
    public:
        ~CEnumCommand(void);
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IEnumUICommand
        //
        STDMETHOD(Next)(ULONG celt, IUICommand **pUICommand, ULONG *pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)(void);
        STDMETHOD(Clone)(IEnumUICommand **ppenum);

        static HRESULT CreateInstance(IUnknown *punkSite, const CPLINK_DESC **ppld, REFIID riid, void **ppvEnum);
        static HRESULT CreateInstance(IUnknown *punkSite, const CDpaUiCommand& rgCommands, REFIID riid, void **ppvEnum);

    private:
        LONG              m_cRef;
        IEnumCommandBase *m_pImpl; // Ptr to actual implementation.

        CEnumCommand(void);
        //
        // Prevent copy.
        //
        CEnumCommand(const CEnumCommand& rhs);              // not implemented.
        CEnumCommand& operator = (const CEnumCommand& rhs); // not implemented.

        bool _IsRestricted(IUICommand *puic);
};


CEnumCommand::CEnumCommand(
    void
    ) : m_cRef(1),
        m_pImpl(NULL)
{
    TraceMsg(TF_LIFE, "CEnumCommand::CEnumCommand, this = 0x%x", this);
}

CEnumCommand::~CEnumCommand(
    void
    )
{
    TraceMsg(TF_LIFE, "CEnumCommand::~CEnumCommand, this = 0x%x", this);
    delete m_pImpl;
}


//
// Creates a command enumerator from an array of link descriptions
// in the CPL namespace.
//
HRESULT
CEnumCommand::CreateInstance(
    IUnknown *punkSite,
    const CPLINK_DESC **ppld,
    REFIID riid,
    void **ppvOut
    )
{
    //
    // Note that ppld can be NULL.  It simply results in an 
    // empty enumerator.
    //
    ASSERT(NULL != punkSite);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumCommand *pec = new CEnumCommand();
    if (NULL != pec)
    {
        pec->m_pImpl = new CEnumCommand_LinkDesc(ppld);
        if (NULL != pec->m_pImpl)
        {
            hr = pec->QueryInterface(riid, ppvOut);
            if (SUCCEEDED(hr))
            {
                hr = IUnknown_SetSite(static_cast<IUnknown *>(*ppvOut), punkSite);
            }
        }
        pec->Release();
    }
    return THR(hr);
}



//
// Creates a command enumerator from a DPA of IUICommand ptrs.
//
HRESULT
CEnumCommand::CreateInstance(
    IUnknown *punkSite,
    const CDpaUiCommand& rgCommands,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != punkSite);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumCommand *pec = new CEnumCommand();
    if (NULL != pec)
    {
        pec->m_pImpl = new CEnumCommand_Array();
        if (NULL != pec->m_pImpl)
        {
            hr = static_cast<CEnumCommand_Array *>(pec->m_pImpl)->Initialize(rgCommands);
            if (SUCCEEDED(hr))
            {
                hr = pec->QueryInterface(riid, ppvOut);
                if (SUCCEEDED(hr))
                {
                    hr = IUnknown_SetSite(static_cast<IUnknown *>(*ppvOut), punkSite);
                }
            }
        }
        pec->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CEnumCommand::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CEnumCommand, IEnumUICommand),
        QITABENT(CEnumCommand, IObjectWithSite),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CEnumCommand::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CEnumCommand::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


STDMETHODIMP
CEnumCommand::Next(
    ULONG celt,
    IUICommand **ppUICommand,
    ULONG *pceltFetched
    )
{   
    ASSERT(NULL != ppUICommand);
    ASSERT(!IsBadWritePtr(ppUICommand, sizeof(*ppUICommand) * celt));
    ASSERT(NULL != m_pImpl);

    HRESULT hr = S_OK;

    ULONG celtFetched = 0;
    while(S_OK == hr && 0 < celt)
    {
        ASSERT(NULL != CObjectWithSite::_punkSite);
        
        IUICommand *puic;
        //
        // This is a little weird.  I pass the site ptr to the 
        // Next() method but then also set the returned object's
        // site when it's returned by Next().  Why not just set
        // the site in the Next() implementation?  Next() needs the site
        // ptr to pass through to any IResSrc::GetResource implementation
        // when retrieving the resources for any given UI command object.
        // This is because the resource used can vary depending upon state
        // information stored in the namespace.  However, to simplify 
        // lifetime management, I want to 'set' the site on the returned
        // objects in only one place; this place.  That way, the derived
        // enumerator instance attached to m_pImpl doesn't need to worry 
        // about setting the site.  We do it in one place for all 
        // implementations.  [brianau - 3/16/01]
        //
        hr = m_pImpl->Next(CObjectWithSite::_punkSite, &puic);
        if (S_OK == hr)
        {
            //
            // It's important that we set the object's 'site' before
            // checking the restriction.  The restriction checking
            // code requires access to the CplNamespace which is obtained
            // through the site.
            //
            hr = IUnknown_SetSite(puic, CObjectWithSite::_punkSite);
            if (SUCCEEDED(hr))
            {
                if (!_IsRestricted(puic))
                {
                    celt--;
                    celtFetched++;
                    (*ppUICommand++ = puic)->AddRef();  
                }
            }
            puic->Release();
        }
    }
    if (NULL != pceltFetched)
    {
        *pceltFetched = celtFetched;
    }
    return THR(hr);
}


STDMETHODIMP
CEnumCommand::Skip(
    ULONG celt
    )
{
    ASSERT(NULL != m_pImpl);

    HRESULT hr = m_pImpl->Skip(celt);
    return THR(hr);
}
    

STDMETHODIMP
CEnumCommand::Reset(
    void
    )
{
    ASSERT(NULL != m_pImpl);

    HRESULT hr = m_pImpl->Reset();
    return THR(hr);
}


STDMETHODIMP
CEnumCommand::Clone(
    IEnumUICommand **ppenum
    )
{
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));
    ASSERT(NULL != m_pImpl);

    *ppenum = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumCommand *pe = new CEnumCommand();
    if (NULL != pe)
    {
        hr = m_pImpl->Clone(&(pe->m_pImpl));
        if (SUCCEEDED(hr))
        {
            hr = pe->QueryInterface(IID_IEnumUICommand, (void **)ppenum);
        }
        pe->Release();
    }
    return THR(hr);
}


bool
CEnumCommand::_IsRestricted(
    IUICommand *puic
    )
{
    ASSERT(NULL != puic);

    bool bRestricted = false;

    UISTATE uis;
    HRESULT hr = puic->get_State(NULL, TRUE, &uis);
    if (SUCCEEDED(hr))
    {
        if (UIS_HIDDEN == uis)
        {
            bRestricted = true;
        }
    }
    return bRestricted;
}


//-----------------------------------------------------------------------------
// CCplWebViewInfo
//-----------------------------------------------------------------------------

class CCplWebViewInfo : public ICplWebViewInfo
{
    public:
        ~CCplWebViewInfo(void);
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IEnumCplWebViewInfo
        //
        STDMETHOD(get_Header)(IUIElement **ppele);
        STDMETHOD(get_Style)(DWORD *pdwFlags);
        STDMETHOD(EnumTasks)(IEnumUICommand **ppenum);

        static HRESULT CreateInstance(IUIElement *peHeader, IEnumUICommand *penum, DWORD dwStyle, REFIID riid, void **ppvOut);

    private:
        LONG            m_cRef;
        IUIElement     *m_peHeader;        // The webview menu header.
        IEnumUICommand *m_penumUiCommand;  // The webview menu tasks.
        DWORD           m_dwStyle;         // Style flags.

        CCplWebViewInfo(void);
};


CCplWebViewInfo::CCplWebViewInfo(
    void
    ) : m_cRef(1),
        m_peHeader(NULL),
        m_penumUiCommand(NULL),
        m_dwStyle(0)
{
    TraceMsg(TF_LIFE, "CCplWebViewInfo::CCplWebViewInfo, this = 0x%x", this);
}


CCplWebViewInfo::~CCplWebViewInfo(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplWebViewInfo::~CCplWebViewInfo, this = 0x%x", this);
    ATOMICRELEASE(m_peHeader);
    ATOMICRELEASE(m_penumUiCommand);
}


HRESULT 
CCplWebViewInfo::CreateInstance( // [static]
    IUIElement *peHeader, 
    IEnumUICommand *penum, 
    DWORD dwStyle,
    REFIID riid, 
    void **ppvOut
    )
{
    ASSERT(NULL != peHeader);
    ASSERT(NULL != penum);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplWebViewInfo *pwvi = new CCplWebViewInfo();
    if (NULL != pwvi)
    {
        hr = pwvi->QueryInterface(riid, ppvOut);
        if (SUCCEEDED(hr))
        {
            (pwvi->m_peHeader = peHeader)->AddRef();
            (pwvi->m_penumUiCommand = penum)->AddRef();

            pwvi->m_dwStyle = dwStyle;
        }
        pwvi->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplWebViewInfo::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplWebViewInfo, ICplWebViewInfo),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CCplWebViewInfo::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CCplWebViewInfo::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


STDMETHODIMP
CCplWebViewInfo::get_Header(
    IUIElement **ppele
    )
{
    ASSERT(NULL != ppele);
    ASSERT(!IsBadWritePtr(ppele, sizeof(*ppele)));

    HRESULT hr = S_OK;

    (*ppele = m_peHeader)->AddRef();

    return THR(hr);
}



STDMETHODIMP
CCplWebViewInfo::get_Style(
    DWORD *pdwStyle
    )
{
    ASSERT(NULL != pdwStyle);
    ASSERT(!IsBadWritePtr(pdwStyle, sizeof(*pdwStyle)));

    *pdwStyle = m_dwStyle;
    return S_OK;
}


STDMETHODIMP
CCplWebViewInfo::EnumTasks(
    IEnumUICommand **ppenum
    )
{
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    HRESULT hr = S_OK;

    (*ppenum = m_penumUiCommand)->AddRef();

    return THR(hr);
}



//-----------------------------------------------------------------------------
// CEnumCplWebViewInfo
//-----------------------------------------------------------------------------

struct ECWVI_ITEM
{
    eCPWVTYPE           eType;
    const CPLINK_DESC **rgpDesc;         // Ptr to nul-term array of link desc ptrs.
    bool                bRestricted;     // Is item restricted from usage?
    bool                bEnhancedMenu;   // Render as a 'special' list in webview?
};



class CEnumCplWebViewInfo : public CObjectWithSite,
                            public IEnumCplWebViewInfo
{
    public:
        ~CEnumCplWebViewInfo(void);
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IEnumCplWebViewInfo
        //
        STDMETHOD(Next)(ULONG celt, ICplWebViewInfo **ppwvi, ULONG *pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)(void);
        STDMETHOD(Clone)(IEnumCplWebViewInfo **ppenum);

        static HRESULT CreateInstance(IUnknown *punkSite, const ECWVI_ITEM *prgwvi, UINT cItems, REFIID riid, void **ppvOut);

    private:
        LONG m_cRef;
        int  m_iCurrent;
        CDpa<ICplWebViewInfo, CDpaDestroyer_Release<ICplWebViewInfo> > m_rgwvi;

        CEnumCplWebViewInfo(void);
        HRESULT _Initialize(IUnknown *punkSite, const ECWVI_ITEM *prgwvi, UINT cItems);

        //
        // Prevent copy.
        //
        CEnumCplWebViewInfo(const CEnumCplWebViewInfo& rhs);              // not implemented.
        CEnumCplWebViewInfo& operator = (const CEnumCplWebViewInfo& rhs); // not implemented.
};



CEnumCplWebViewInfo::CEnumCplWebViewInfo(
    void
    ) : m_cRef(1),
        m_iCurrent(0)
{
    TraceMsg(TF_LIFE, "CEnumCplWebViewInfo::CEnumCplWebViewInfo, this = 0x%x", this);
}

CEnumCplWebViewInfo::~CEnumCplWebViewInfo(
    void
    )
{
    TraceMsg(TF_LIFE, "CEnumCplWebViewInfo::~CEnumCplWebViewInfo, this = 0x%x", this);
}



HRESULT 
CEnumCplWebViewInfo::CreateInstance(
    IUnknown *punkSite,
    const ECWVI_ITEM *prgwvi,
    UINT cItems,
    REFIID riid, 
    void **ppvOut
    )
{
    ASSERT(NULL != punkSite);
    ASSERT(NULL != prgwvi);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumCplWebViewInfo *pewvi = new CEnumCplWebViewInfo();
    if (NULL != pewvi)
    {
        hr = pewvi->_Initialize(punkSite, prgwvi, cItems);
        if (SUCCEEDED(hr))
        {
            hr = pewvi->QueryInterface(riid, ppvOut);
        }
        pewvi->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CEnumCplWebViewInfo::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CEnumCplWebViewInfo, IEnumCplWebViewInfo),
        QITABENT(CEnumCplWebViewInfo, IObjectWithSite),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CEnumCplWebViewInfo::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CEnumCplWebViewInfo::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


STDMETHODIMP
CEnumCplWebViewInfo::Next(
    ULONG celt, 
    ICplWebViewInfo **ppwvi, 
    ULONG *pceltFetched
    )
{
    ASSERT(NULL != ppwvi);
    ASSERT(!IsBadWritePtr(ppwvi, sizeof(*ppwvi) * celt));

    ULONG celtFetched = 0;
    while(m_iCurrent < m_rgwvi.Count() && 0 < celt)
    {
        *ppwvi = m_rgwvi.Get(m_iCurrent++);

        ASSERT(NULL != *ppwvi);
        (*ppwvi)->AddRef();

        celt--;
        celtFetched++;
        ppwvi++;
    }
    if (NULL != pceltFetched)
    {
        *pceltFetched = celtFetched;
    }
    return 0 == celt ? S_OK : S_FALSE;
}



STDMETHODIMP
CEnumCplWebViewInfo::Reset(
    void
    )
{
    m_iCurrent = 0;
    return S_OK;
}


STDMETHODIMP
CEnumCplWebViewInfo::Skip(
    ULONG n
    )
{
    while(0 < n-- && m_iCurrent < m_rgwvi.Count())
    {
        m_iCurrent++;
    }
    return 0 == n ? S_OK : S_FALSE;
}


STDMETHODIMP
CEnumCplWebViewInfo::Clone(
    IEnumCplWebViewInfo **ppenum
    )
{
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    *ppenum = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumCplWebViewInfo *penum = new CEnumCplWebViewInfo();
    if (NULL != *ppenum)
    {
        for (int i = 0; SUCCEEDED(hr) && i < m_rgwvi.Count(); i++)
        {
            ICplWebViewInfo *pwvi = m_rgwvi.Get(i);
            ASSERT(NULL != pwvi);

            if (-1 != penum->m_rgwvi.Append(pwvi))
            {
                pwvi->AddRef();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = penum->QueryInterface(IID_IEnumCplWebViewInfo, (void **)ppenum);
        }
        penum->Release();
    }
    return THR(hr);
}



HRESULT
CEnumCplWebViewInfo::_Initialize(
    IUnknown *punkSite,
    const ECWVI_ITEM *prgwvi,
    UINT cItems
    )
{
    ASSERT(NULL != punkSite);
    ASSERT(NULL != prgwvi);

    IUnknown *punk;
    HRESULT hr = QueryInterface(IID_IUnknown, (void **)&punk);
    if (SUCCEEDED(hr))
    {
        hr = IUnknown_SetSite(punk, punkSite);
        if (SUCCEEDED(hr))
        {
            for (UINT i = 0; i < cItems; i++)
            {
                if (!prgwvi[i].bRestricted)
                {
                    IEnumUICommand *penum;

                    hr = CEnumCommand::CreateInstance(CObjectWithSite::_punkSite,
                                                      prgwvi[i].rgpDesc, 
                                                      IID_IEnumUICommand, 
                                                      (void **)&penum);
                    if (SUCCEEDED(hr))
                    {
                        IUIElement *peHeader;
                        hr = CplNamespace_CreateWebViewHeaderElement(prgwvi[i].eType, &peHeader);
                        if (SUCCEEDED(hr))
                        {
                            DWORD dwStyle = 0;
                            if (prgwvi[i].bEnhancedMenu)
                            {
                                dwStyle |= SFVMWVF_SPECIALTASK;
                            }
                            ICplWebViewInfo *pwvi;
                            hr = CCplWebViewInfo::CreateInstance(peHeader, penum, dwStyle, IID_ICplWebViewInfo, (void **)&pwvi);
                            if (SUCCEEDED(hr))
                            {
                                if (-1 == m_rgwvi.Append(pwvi))
                                {
                                    pwvi->Release();
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            peHeader->Release();
                        }
                        penum->Release();
                    }
                }
            }
        }
        punk->Release();
    }
    return THR(hr);
}





//-----------------------------------------------------------------------------
// CCplCategory
//-----------------------------------------------------------------------------

class CCplCategory : public CObjectWithSite,
                     public ICplCategory
{
    public:
        ~CCplCategory(void);
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // ICplCategory
        //
        STDMETHOD(GetCategoryID)(eCPCAT *pID);
        STDMETHOD(GetUiCommand)(IUICommand **ppele);
        STDMETHOD(EnumTasks)(IEnumUICommand **ppenum);
        STDMETHOD(EnumCplApplets)(IEnumUICommand **ppenum);
        STDMETHOD(EnumWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(GetHelpURL)(LPWSTR pszURL, UINT cchURL);

        static HRESULT CreateInstance(const CPCAT_DESC *pDesc, const CDpaUiCommand& rgCplApplets, REFIID riid, void **ppvOut);

    private:
        LONG              m_cRef;
        const CPCAT_DESC *m_pDesc;        // Initialization data.
        CDpaUiCommand     m_rgCplApplets; // Cached list of CPL applet links.

        CCplCategory(void);
        //
        // Prevent copy.
        //
        CCplCategory(const CCplCategory& rhs);              // not implemented.
        CCplCategory& operator = (const CCplCategory& rhs); // not implemented.

        HRESULT _Initialize(const CPCAT_DESC *pDesc, const CDpaUiCommand& rgCplApplets);
        bool _CplAppletsLoaded(void) const;
};



CCplCategory::CCplCategory(
    void
    ) : m_cRef(1),
        m_pDesc(NULL)
{    
    TraceMsg(TF_LIFE, "CCplCategory::CCplCategory, this = 0x%x", this);
}


CCplCategory::~CCplCategory(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplCategory::~CCplCategory, this = 0x%x", this);
}


HRESULT
CCplCategory::CreateInstance(
    const CPCAT_DESC *pDesc,
    const CDpaUiCommand& rgCplApplets,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != pDesc);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplCategory *pc = new CCplCategory();
    if (NULL != pc)
    {
        hr = pc->_Initialize(pDesc, rgCplApplets);
        if (SUCCEEDED(hr))
        {
            hr = pc->QueryInterface(riid, ppvOut);
        }
        pc->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplCategory::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplCategory, ICplCategory),
        QITABENT(CCplCategory, IObjectWithSite),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CCplCategory::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CCplCategory::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


STDMETHODIMP
CCplCategory::GetUiCommand(
    IUICommand **ppc
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplCategory::GetUiCommand");

    ASSERT(NULL != m_pDesc);
    ASSERT(NULL != m_pDesc->pLink);
    ASSERT(NULL != ppc);
    ASSERT(!IsBadWritePtr(ppc, sizeof(*ppc)));

    HRESULT hr = CplNamespace_CreateUiCommand(CObjectWithSite::_punkSite, 
                                              *(m_pDesc->pLink), 
                                              ppc);
    if (SUCCEEDED(hr))
    {
        hr = IUnknown_SetSite(*ppc, CObjectWithSite::_punkSite);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplCategory::GetUiCommand", hr);
    return THR(hr);
}


STDMETHODIMP
CCplCategory::EnumWebViewInfo(
    DWORD dwFlags,
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplCategory::EnumWebViewInfo");

    ASSERT(NULL != m_pDesc);
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    UNREFERENCED_PARAMETER(dwFlags);

    const ECWVI_ITEM rgItems[] = {
        { eCPWVTYPE_SEEALSO,      m_pDesc->slinks.ppSeeAlsoLinks,      false, false },
        { eCPWVTYPE_TROUBLESHOOT, m_pDesc->slinks.ppTroubleshootLinks, false, false },
        { eCPWVTYPE_LEARNABOUT,   m_pDesc->slinks.ppLearnAboutLinks,   false, false }
        };

    HRESULT hr = CEnumCplWebViewInfo::CreateInstance(CObjectWithSite::_punkSite,
                                                     rgItems, 
                                                     ARRAYSIZE(rgItems),
                                                     IID_IEnumCplWebViewInfo, 
                                                     (void **)ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplCategory::EnumWebViewInfo", hr);
    return THR(hr);
}



STDMETHODIMP
CCplCategory::EnumTasks(
    IEnumUICommand **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplCategory::EnumTasks");

    ASSERT(NULL != m_pDesc);
    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    HRESULT hr = CEnumCommand::CreateInstance(CObjectWithSite::_punkSite,
                                              m_pDesc->ppTaskLinks, 
                                              IID_IEnumUICommand, 
                                              (void **)ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplCategory::EnumTasks", hr);
    return THR(hr);
}


STDMETHODIMP
CCplCategory::EnumCplApplets(
    IEnumUICommand **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplCategory::EnumCplApplets");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    HRESULT hr = CEnumCommand::CreateInstance(CObjectWithSite::_punkSite,
                                              m_rgCplApplets, 
                                              IID_IEnumUICommand, 
                                              (void **)ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplCategory::EnumCplApplets", hr);
    return THR(hr);
}



STDMETHODIMP
CCplCategory::GetCategoryID(
    eCPCAT *pID
    )
{
    ASSERT(NULL != pID);
    ASSERT(!IsBadWritePtr(pID, sizeof(*pID)));

    *pID = m_pDesc->idCategory;
    return S_OK;
}


STDMETHODIMP
CCplCategory::GetHelpURL(
    LPWSTR pszURL, 
    UINT cchURL
    )
{
    ASSERT(NULL != pszURL);
    ASSERT(!IsBadWritePtr(pszURL, cchURL * sizeof(*pszURL)));
    
    return CPL::BuildHssHelpURL(m_pDesc->pszHelpSelection, pszURL, cchURL);
}



HRESULT
CCplCategory::_Initialize(
    const CPCAT_DESC *pDesc,
    const CDpaUiCommand& rgCplApplets
    )
{
    ASSERT(NULL != pDesc);
    ASSERT(NULL == m_pDesc);

    m_pDesc = pDesc;
    HRESULT hr = CplNamespace_CopyCommandArray(rgCplApplets, &m_rgCplApplets);

    return THR(hr);
}


//-----------------------------------------------------------------------------
// CTriState
// This is a trivial class to allow representation of a uninitialized boolean
// value.  Used by CCplNamespace for it's storage of cached 'restriction'
// values.  Internally, -1 == 'uninitialized, 0 == false and 1 == true.
//-----------------------------------------------------------------------------

class CTriState
{
    public:
        CTriState(void)
            : m_iVal(-1) { }

        operator bool() const
            { ASSERT(!_Invalid()); return (!_Invalid() ? !!m_iVal : false); }

        CTriState& operator = (bool bValue)
            { m_iVal = bValue ? 1 : 0; return *this; }

        bool IsInvalid(void) const
            { return _Invalid(); }
            
    private:
        int m_iVal;

        void _Set(bool bValue)
            { m_iVal = bValue ? 1 : 0; }

        bool _Invalid(void) const
            { return (-1 == m_iVal); }
};



//-----------------------------------------------------------------------------
// CCplNamespace
//-----------------------------------------------------------------------------

class CCplNamespace : public CObjectWithSite,
                      public ICplNamespace
                      
{
    public:
        ~CCplNamespace(void);

        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // ICplNamespace
        //
        STDMETHOD(GetCategory)(eCPCAT eCategory, ICplCategory **ppcat);
        STDMETHOD(EnumWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(EnumClassicWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(RefreshIDs)(IEnumIDList *penumIDs);
        STDMETHOD_(BOOL, IsServer)(void);
        STDMETHOD_(BOOL, IsProfessional)(void);
        STDMETHOD_(BOOL, IsPersonal)(void);
        STDMETHOD_(BOOL, IsUserAdmin)(void);
        STDMETHOD_(BOOL, IsUserOwner)(void);
        STDMETHOD_(BOOL, IsUserStandard)(void);
        STDMETHOD_(BOOL, IsUserLimited)(void);
        STDMETHOD_(BOOL, IsUserGuest)(void);
        STDMETHOD_(BOOL, IsOnDomain)(void);
        STDMETHOD_(BOOL, IsX86)(void);
        STDMETHOD_(BOOL, AllowUserManager)(void);
        STDMETHOD_(BOOL, UsePersonalUserManager)(void);
        STDMETHOD_(BOOL, AllowDeskCpl)(void);
        STDMETHOD_(BOOL, AllowDeskCplTab_Background)(void);
        STDMETHOD_(BOOL, AllowDeskCplTab_Screensaver)(void);
        STDMETHOD_(BOOL, AllowDeskCplTab_Appearance)(void);
        STDMETHOD_(BOOL, AllowDeskCplTab_Settings)(void);

        static HRESULT CreateInstance(IEnumIDList *penumIDs, REFIID riid, void **ppvOut);

    private:
        LONG           m_cRef;
        ICplCategory  *m_rgpCategories[eCPCAT_NUMCATEGORIES];
        CDpaUiCommand  m_rgCplApplets[eCPCAT_NUMCATEGORIES];
        IEnumIDList   *m_penumIDs;
        CTriState      m_SkuSvr;
        CTriState      m_SkuPro;
        CTriState      m_SkuPer;
        CTriState      m_Admin;
        CTriState      m_UserOwner;
        CTriState      m_UserStandard;
        CTriState      m_UserLimited;
        CTriState      m_UserGuest;
        CTriState      m_Domain;
        CTriState      m_AllowUserManager;
        CTriState      m_PersonalUserManager;
        CTriState      m_AllowDeskCpl;
        CTriState      m_rgAllowDeskCplTabs[CPLTAB_DESK_MAX];

        CCplNamespace(void);
        //
        // Prevent copy.
        //
        CCplNamespace(const CCplNamespace& rhs);              // not implemented.
        CCplNamespace& operator = (const CCplNamespace& rhs); // not implemented.

        HRESULT _Initialize(IEnumIDList *penumIDs);
        HRESULT _SetIDList(IEnumIDList *penumIDs);
        HRESULT _IsValidCategoryID(int iCategory) const;
        HRESULT _CategorizeCplApplets(void);
        HRESULT _LoadSeeAlsoLinks(void);
        HRESULT _AddSeeAlso(IUICommand *pc);
        HRESULT _CategorizeCplApplet(IShellFolder2 *psf2Cpanel, LPCITEMIDLIST pidlItem);
        BOOL  _UserAcctType(CTriState *pts);
        void  _GetUserAccountType(void);
        BOOL _AllowDeskCplTab(eDESKCPLTAB eTab);
        void _DestroyCategories(void);
        void _ClearCplApplets(void);
};


CCplNamespace::CCplNamespace(
    void
    ) : m_cRef(1),
        m_penumIDs(NULL)
{
    TraceMsg(TF_LIFE, "CCplNamespace::CCplNamespace, this = 0x%x", this);
    ZeroMemory(m_rgpCategories, sizeof(m_rgpCategories));
}

CCplNamespace::~CCplNamespace(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplNamespace::~CCplNamespace, this = 0x%x", this);
    _DestroyCategories();
    ATOMICRELEASE(m_penumIDs);
}


HRESULT
CCplNamespace::CreateInstance(
    IEnumIDList *penumIDs,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != penumIDs);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplNamespace *pns = new CCplNamespace();
    if (NULL != pns)
    {
        hr = pns->_Initialize(penumIDs);
        if (SUCCEEDED(hr))
        {
            hr = pns->QueryInterface(riid, ppvOut);
        }
        pns->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplNamespace::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplNamespace, ICplNamespace),
        QITABENT(CCplNamespace, IObjectWithSite),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CCplNamespace::AddRef(
    void
    )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    TraceMsg(TF_LIFE, "CCplNamespace::AddRef %d->%d", cRef - 1, cRef);
    return cRef;
}



STDMETHODIMP_(ULONG)
CCplNamespace::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    TraceMsg(TF_LIFE, "CCplNamespace::Release %d<-%d", cRef, cRef+1);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


STDMETHODIMP
CCplNamespace::EnumWebViewInfo(
    DWORD dwFlags,
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::EnumWebViewInfo");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    const bool bNoViewSwitch = (0 != (CPVIEW_EF_NOVIEWSWITCH & dwFlags));

    const ECWVI_ITEM rgItems[] = {
        { eCPWVTYPE_CPANEL,  g_rgpLink_Cpl_SwToClassicView, bNoViewSwitch, true  },
        { eCPWVTYPE_SEEALSO, g_rgpLink_Cpl_SeeAlso,         false,         false }
        }; 

    HRESULT hr = CEnumCplWebViewInfo::CreateInstance(CObjectWithSite::_punkSite,
                                                     rgItems,
                                                     ARRAYSIZE(rgItems),
                                                     IID_IEnumCplWebViewInfo, 
                                                     (void **)ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplNamespace::EnumWebViewInfo", hr);
    return THR(hr);
}


STDMETHODIMP
CCplNamespace::EnumClassicWebViewInfo(
    DWORD dwFlags,
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::EnumClassicWebViewInfo");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));

    const bool bNoViewSwitch = (0 != (CPVIEW_EF_NOVIEWSWITCH & dwFlags));

    const ECWVI_ITEM rgItems[] = {
        { eCPWVTYPE_CPANEL,  g_rgpLink_Cpl_SwToCategoryView, bNoViewSwitch, true  },
        { eCPWVTYPE_SEEALSO, g_rgpLink_Cpl_SeeAlso,          false,         false }
        }; 

    HRESULT hr = CEnumCplWebViewInfo::CreateInstance(CObjectWithSite::_punkSite, 
                                                     rgItems, 
                                                     ARRAYSIZE(rgItems),
                                                     IID_IEnumCplWebViewInfo, 
                                                     (void **)ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplNamespace::EnumClassicWebViewInfo", hr);
    return THR(hr);
}
    

STDMETHODIMP
CCplNamespace::GetCategory(
    eCPCAT eCategory, 
    ICplCategory **ppcat
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::GetCategory");
    TraceMsg(FTF_CPANEL, "Category ID = %d", eCategory);

    ASSERT(S_OK == _IsValidCategoryID(eCategory));
    ASSERT(NULL != ppcat);
    ASSERT(!IsBadWritePtr(ppcat, sizeof(*ppcat)));

    HRESULT hr = S_OK;

    *ppcat = NULL;

    if (NULL == m_rgpCategories[eCategory])
    {
        hr = CCplCategory::CreateInstance(g_rgpCplCatInfo[eCategory], 
                                          m_rgCplApplets[eCategory], 
                                          IID_ICplCategory, 
                                          (void **)&m_rgpCategories[eCategory]);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != CObjectWithSite::_punkSite);
            hr = IUnknown_SetSite(m_rgpCategories[eCategory], CObjectWithSite::_punkSite);
        }
    }
    if (SUCCEEDED(hr))
    {
        *ppcat = m_rgpCategories[eCategory];
        (*ppcat)->AddRef();
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplNamespace::GetCategory", hr);
    return THR(hr);
}


STDMETHODIMP
CCplNamespace::RefreshIDs(
    IEnumIDList *penumIDs
    )
{
    return _SetIDList(penumIDs);
}


BOOL CCplNamespace::IsX86(void)
{
#ifdef _X86_
    return true;
#else
    return false;
#endif
}


BOOL CCplNamespace::IsServer(void)
{
    if (m_SkuSvr.IsInvalid())
    {
        m_SkuSvr = !!IsOsServer();
    }
    return m_SkuSvr;
}

BOOL CCplNamespace::IsPersonal(void)
{
    if (m_SkuPer.IsInvalid())
    {
        m_SkuPer = !!IsOsPersonal();
    }
    return m_SkuPer;
}

BOOL CCplNamespace::IsProfessional(void)
{
    if (m_SkuPro.IsInvalid())
    {
        m_SkuPro = !!IsOsProfessional();
    }
    return m_SkuPro;
}

BOOL CCplNamespace::IsOnDomain(void)
{
    if (m_Domain.IsInvalid())
    {
        m_Domain = !!IsConnectedToDomain();
    }
    return m_Domain;
}

BOOL CCplNamespace::IsUserAdmin(void)
{
    if (m_Admin.IsInvalid())
    {
        m_Admin = !!CPL::IsUserAdmin();
    }
    return m_Admin;
}

BOOL CCplNamespace::IsUserOwner(void)
{
    return _UserAcctType(&m_UserOwner);
}

BOOL CCplNamespace::IsUserStandard(void)
{
    return _UserAcctType(&m_UserStandard);
}

BOOL CCplNamespace::IsUserLimited(void)
{
    return _UserAcctType(&m_UserLimited);
}

BOOL CCplNamespace::IsUserGuest(void)
{
    return _UserAcctType(&m_UserGuest);
}

BOOL CCplNamespace::UsePersonalUserManager(void)
{
    if (m_PersonalUserManager.IsInvalid())
    {
        m_PersonalUserManager = (IsX86() && (IsPersonal() || (IsProfessional() && !IsOnDomain())));
    }
    return m_PersonalUserManager;
}

BOOL CCplNamespace::AllowUserManager(void)
{
    if (m_AllowUserManager.IsInvalid())
    {
        m_AllowUserManager = IsAppletEnabled(L"nusrmgr.cpl", MAKEINTRESOURCEW(IDS_CPL_USERACCOUNTS));
    }
    return m_AllowUserManager;
}


BOOL CCplNamespace::_AllowDeskCplTab(eDESKCPLTAB eTab)
{
    if (m_rgAllowDeskCplTabs[eTab].IsInvalid())
    {
        m_rgAllowDeskCplTabs[eTab] = DeskCPL_IsTabPresent(eTab);
    }
    return m_rgAllowDeskCplTabs[eTab];
}

BOOL CCplNamespace::AllowDeskCplTab_Background(void)
{
    return _AllowDeskCplTab(CPLTAB_DESK_BACKGROUND);
}

BOOL CCplNamespace::AllowDeskCplTab_Screensaver(void)
{
    return _AllowDeskCplTab(CPLTAB_DESK_SCREENSAVER);
}

BOOL CCplNamespace::AllowDeskCplTab_Appearance(void)
{
    return _AllowDeskCplTab(CPLTAB_DESK_APPEARANCE);
}

BOOL CCplNamespace::AllowDeskCplTab_Settings(void)
{
    return _AllowDeskCplTab(CPLTAB_DESK_SETTINGS);
}


BOOL CCplNamespace::AllowDeskCpl(void)
{
    if (m_AllowDeskCpl.IsInvalid())
    {
        m_AllowDeskCpl = IsAppletEnabled(L"desk.cpl", MAKEINTRESOURCEW(IDS_CPL_DISPLAY));
    }
    return m_AllowDeskCpl;
}

//
// Retrieves the account type for the current user and updates
// the cached account type members accordingly.
//
void 
CCplNamespace::_GetUserAccountType(void)
{
    eACCOUNTTYPE eType;
    if (SUCCEEDED(THR(CPL::GetUserAccountType(&eType))))
    {
        m_UserLimited  = (eACCOUNTTYPE_LIMITED == eType);
        m_UserStandard = (eACCOUNTTYPE_STANDARD == eType);
        m_UserGuest    = (eACCOUNTTYPE_GUEST == eType);
        m_UserOwner    = (eACCOUNTTYPE_OWNER == eType);
    }
}

//
// Determins the state of a given account type member.
//
BOOL 
CCplNamespace::_UserAcctType(CTriState *pts)
{
    if (pts->IsInvalid())
    {
        _GetUserAccountType();
    }
    return *pts;
}


HRESULT
CCplNamespace::_IsValidCategoryID(
    int iCategory
    ) const
{
    HRESULT hr = E_FAIL;
    if (0 <= iCategory && ARRAYSIZE(m_rgpCategories) > iCategory)
    {
        hr = S_OK;
    }
    return THR(hr);
}



HRESULT
CCplNamespace::_Initialize(
    IEnumIDList *penumIDs
    )
{
    ASSERT(NULL != penumIDs);

    HRESULT hr = _SetIDList(penumIDs);
    return THR(hr);
}


HRESULT
CCplNamespace::_SetIDList(
    IEnumIDList *penumIDs
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::_SetIDList");

    ASSERT(NULL != penumIDs);
    
    ATOMICRELEASE(m_penumIDs);
    (m_penumIDs = penumIDs)->AddRef();
    //
    // We have a new set of IDs so we need to re-categorize them.
    //
    HRESULT hr = _CategorizeCplApplets();

    DBG_EXIT(FTF_CPANEL, "CCplNamespace::_SetIDList");
    return THR(hr);
}    


//
// Destroy all category objects in our array of categories.
//
void
CCplNamespace::_DestroyCategories(
    void
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::_DestroyCategories");

    for (int i = 0; i < ARRAYSIZE(m_rgpCategories); i++)
    {
        ATOMICRELEASE(m_rgpCategories[i]);
    }
    DBG_EXIT(FTF_CPANEL, "CCplNamespace::_DestroyCategories");
}


void
CCplNamespace::_ClearCplApplets(
    void
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::_ClearCplApplets");

    for (int i = 0; i < ARRAYSIZE(m_rgCplApplets); i++)
    {
        m_rgCplApplets[i].Clear();
    }
    DBG_EXIT(FTF_CPANEL, "CCplNamespace::_ClearCplApplets");
}

//
// Load and categorize all of the CPL applets in the Control Panel folder.
//
HRESULT 
CCplNamespace::_CategorizeCplApplets(
    void
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplNamespace::_CategorizeCplApplets");
    //
    // Destroy any existing categories and CPL applets that we have
    // already categorized.
    //
    _DestroyCategories();
    _ClearCplApplets();
    
    LPITEMIDLIST pidlFolder;
    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlFolder);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            IShellFolder2 *psf2Cpanel;
            hr = psfDesktop->BindToObject(pidlFolder, NULL, IID_IShellFolder2, (void **)&psf2Cpanel);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlItem;
                ULONG celt = 0;
                while(S_OK == (hr = m_penumIDs->Next(1, &pidlItem, &celt)))
                {
                    //
                    // Note that we continue the enumeration if loading a 
                    // particular applet fails.
                    //
                    _CategorizeCplApplet(psf2Cpanel, pidlItem);
                    ILFree(pidlItem);
                }
                psf2Cpanel->Release();
            }
            psfDesktop->Release();
        }
        ILFree(pidlFolder);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplNamespace::_CategorizeCplApplets", hr);
    return THR(hr);
}



//
// Load one CPL applet into the category's DPA of associated CPL applets.
//
HRESULT
CCplNamespace::_CategorizeCplApplet(
    IShellFolder2 *psf2Cpanel,
    LPCITEMIDLIST pidlItem
    )
{
    ASSERT(NULL != psf2Cpanel);
    ASSERT(NULL != pidlItem);

    SHCOLUMNID scid = SCID_CONTROLPANELCATEGORY;
    VARIANT var;
    VariantInit(&var);
    DWORD dwCategoryID = 0;  // The default. 0 == "other CPLs" category

    HRESULT hr = psf2Cpanel->GetDetailsEx(pidlItem, &scid, &var);
    if (SUCCEEDED(hr))
    {
        dwCategoryID = var.lVal;
    }
    //
    // -1 is a special category ID meaning "don't categorize".
    //
    if (DWORD(-1) != dwCategoryID)
    {
        IUICommand *pc;
        hr = Create_CplUiCommandOnPidl(pidlItem, IID_IUICommand, (void **)&pc);
        if (SUCCEEDED(hr))
        {
            if (-1 == m_rgCplApplets[dwCategoryID].Append(pc))
            {
                pc->Release();
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return THR(hr);
}



HRESULT
CPL::CplNamespace_CreateInstance(
    IEnumIDList *penumIDs,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != penumIDs);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    HRESULT hr = CCplNamespace::CreateInstance(penumIDs, riid, ppvOut);
    return THR(hr);
}


HRESULT
CPL::CplNamespace_GetCategoryAppletCount(
    ICplNamespace *pns,
    eCPCAT eCategory,
    int *pcApplets
    )
{
    ASSERT(NULL != pns);
    ASSERT(NULL != pcApplets);
    ASSERT(!IsBadWritePtr(pcApplets, sizeof(*pcApplets)));

    *pcApplets = 0;

    ICplCategory *pCategory;
    HRESULT hr = pns->GetCategory(eCategory, &pCategory);
    if (SUCCEEDED(hr))
    {
        IEnumUICommand *peuic;
        hr = pCategory->EnumCplApplets(&peuic);
        if (SUCCEEDED(hr))
        {
            IUICommand *puic;
            while(S_OK == (hr = peuic->Next(1, &puic, NULL)))
            {
                puic->Release();
                (*pcApplets)++;
            }
            peuic->Release();
        }
        pCategory->Release();
    }
    return hr;
}



} // namespace CPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cplnkele.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cplnkele.cpp
//
//  This module implements a 'link' element in the Control Panel's DUI
//  view.  Link elements have a title, infotip, icon and an associated
//  command that is invoked when the link is selected.  The CLinkElement
//  object is an extension of the DUI::Button class.  Direct UI automatically
//  creates an instance of CLinkElement when a 'linkelement' item from 
//  cpview.ui is instantiated.
//
//--------------------------------------------------------------------------
#include "shellprv.h"

#include "cpviewp.h"
#include "cpaction.h"
#include "cpduihlp.h"
#include "cpguids.h"
#include "cpuiele.h"
#include "cplnkele.h"
#include "cputil.h"
#include "defviewp.h"
#include "dobjutil.h"
#include "ids.h"

using namespace CPL;


CLinkElement::CLinkElement(
    void
    ) : m_pUiCommand(NULL),
        m_eIconSize(eCPIMGSIZE(-1)),
        m_hwndInfotip(NULL),
        m_idTitle(0),
        m_idIcon(0),
        m_iDragState(DRAG_IDLE)
{
    TraceMsg(TF_LIFE, "CLinkElement::CLinkElement, this = 0x%x", this);

    SetRect(&m_rcDragBegin, 0, 0, 0, 0);
}



CLinkElement::~CLinkElement(
    void
    )
{
    TraceMsg(TF_LIFE, "CLinkElement::~CLinkElement, this = 0x%x", this);
    _Destroy();
}



//
// This is called by the DUI engine when the link element is 
// created.
//
HRESULT
CLinkElement::Create(    // [static]
    DUI::Element **ppElement
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CLinkElement *ple = DUI::HNewAndZero<CLinkElement>();
    if (NULL != ple)
    {
        hr = ple->_Initialize();
        if (FAILED(hr))
        {
            ple->Destroy();
            ple = NULL;
        }
    }
    *ppElement = ple;
    return THR(hr);
}


//
// This is called by the Control Panel UI code creating 
// the link element.
// 
HRESULT
CLinkElement::Initialize(
    IUICommand *pUiCommand,
    eCPIMGSIZE eIconSize
    )
{
    ASSERT(NULL == m_pUiCommand);
    ASSERT(NULL != pUiCommand);

    (m_pUiCommand = pUiCommand)->AddRef();

    m_eIconSize = eIconSize;

    HRESULT hr = _CreateElementTitle();
    if (SUCCEEDED(hr))
    {
        //
        // We don't fail element creation if the icon
        // cannot be created.  We want to display the
        // title without an icon so that we know there's 
        // a problem retrieving the icon.
        //
        THR(_CreateElementIcon());
    }

    //
    // Note that we don't fail element creation if accessibility
    // initialization fails.
    //
    THR(_InitializeAccessibility());

    if (FAILED(hr))
    {
        ATOMICRELEASE(m_pUiCommand);
    }
    return THR(hr);
}


HRESULT
CLinkElement::_InitializeAccessibility(
    void
    )
{
    HRESULT hr = THR(SetAccessible(true));
    if (SUCCEEDED(hr))
    {
        hr = THR(SetAccRole(ROLE_SYSTEM_LINK));
        if (SUCCEEDED(hr))
        {
            LPWSTR pszTitle;
            hr = THR(_GetTitleText(&pszTitle));
            if (SUCCEEDED(hr))
            {
                hr = THR(SetAccName(pszTitle));
                CoTaskMemFree(pszTitle);
                pszTitle = NULL;
                
                if (SUCCEEDED(hr))
                {
                    LPWSTR pszInfotip;
                    hr = THR(_GetInfotipText(&pszInfotip));
                    if (SUCCEEDED(hr))
                    {
                        hr = THR(SetAccDesc(pszInfotip));
                        CoTaskMemFree(pszInfotip);
                        pszInfotip = NULL;
                        if (SUCCEEDED(hr))
                        {
                            TCHAR szDefAction[80];
                            if (0 < LoadString(HINST_THISDLL, 
                                               IDS_CP_LINK_ACCDEFACTION, 
                                               szDefAction, 
                                               ARRAYSIZE(szDefAction)))
                            {
                                hr = THR(SetAccDefAction(szDefAction));
                            }
                            else
                            {
                                hr = THR(ResultFromLastError());
                            }
                        }
                    }
                }
            }
        }
    }
    return THR(hr);
}


void
CLinkElement::OnDestroy(
    void
    )
{
    _Destroy();
    DUI::Button::OnDestroy();
}


void
CLinkElement::OnInput(
    DUI::InputEvent *pev
    )
{
    if (GINPUT_MOUSE == pev->nDevice)
    {
        //
        // Use a set of states to control our handling of 
        // the mouse inputs for drag/drop.
        // 
        // DRAG_IDLE        - We have not yet detected any drag activity.
        // DRAG_HITTESTING  - Waiting to see if user drags cursor a minimum distance.
        // DRAG_DRAGGING    - User did drag cursor a minimum distance and we're now
        //                    inside the drag loop.
        //
        //
        //  START -+-> DRAG_IDLE --> [ GMOUSE_DRAG ] --> DRAG_HITTESTING --+
        //         |                                                       |
        //         |                                    [ GMOUSE_DRAG +    |
        //         |                                      moved SM_CXDRAG  |
        //         |                                      or SM_CYDRAG ]   |
        //         |                                                       |
        //         +-<--------------- [ GMOUSE_UP ] <--- DRAG_DRAGGING <---+
        //                                          
        DUI::MouseEvent *pmev = (DUI::MouseEvent *)pev;
        switch(pev->nCode)
        {
            case GMOUSE_UP:
                m_iDragState = DRAG_IDLE;
                break;

            case GMOUSE_DRAG:
                switch(m_iDragState)
                {
                    case DRAG_IDLE:
                    {
                        //
                        // This is the same way comctl's listview calculates
                        // the begin-drag rect.
                        //
                        int dxClickRect = GetSystemMetrics(SM_CXDRAG);
                        int dyClickRect = GetSystemMetrics(SM_CYDRAG);

                        if (4 > dxClickRect)
                        {
                            dxClickRect = dyClickRect = 4;
                        }

                        //
                        // Remember where the mouse pointer is on our first
                        // indication that a drag operation is starting.
                        //
                        SetRect(&m_rcDragBegin, 
                                 pmev->ptClientPxl.x - dxClickRect,
                                 pmev->ptClientPxl.y - dyClickRect,
                                 pmev->ptClientPxl.x + dxClickRect,
                                 pmev->ptClientPxl.y + dyClickRect);

                        m_iDragState = DRAG_HITTESTING;
                        break;
                    }

                    case DRAG_HITTESTING:
                        if (!PtInRect(&m_rcDragBegin, pmev->ptClientPxl))
                        {
                            //
                            // Begin the drag/drop operation only if we've moved the mouse
                            // outside the "drag begin" rectangle.  This prevents us from 
                            // confusing a normal click with a drag/drop operation.
                            //
                            m_iDragState = DRAG_DRAGGING;
                            //
                            // Position the drag point at the middle of the item's image.
                            //
                            UINT cxIcon = 32;
                            UINT cyIcon = 32;
                            CPL::ImageDimensionsFromDesiredSize(m_eIconSize, &cxIcon, &cyIcon);
                            
                            _BeginDrag(cxIcon / 2, cyIcon / 2);
                        }
                        break;

                    case DRAG_DRAGGING:
                        break;
                }
                break;
                
            default:
                break;
        }
    }
    Button::OnInput(pev);
}


void
CLinkElement::OnEvent(
    DUI::Event *pev
    )
{
    if (DUI::Button::Click == pev->uidType)
    {
        pev->fHandled = true;

        DUI::ButtonClickEvent * pbe = (DUI::ButtonClickEvent *) pev;
        if (1 != pbe->nCount)   
        {
            return; // ingore additional clicks - don't forward.
        }
        _OnSelected();
    }
    else if (DUI::Button::Context == pev->uidType)
    {
        DUI::ButtonContextEvent *peButton = reinterpret_cast<DUI::ButtonContextEvent *>(pev);
        _OnContextMenu(peButton);
        pev->fHandled = true;
    }
    Button::OnEvent(pev);
}


void 
CLinkElement::OnPropertyChanged(
    DUI::PropertyInfo *ppi, 
    int iIndex, 
    DUI::Value *pvOld, 
    DUI::Value *pvNew
    )
{
    //
    // Don't trace this function.  It's called very often.
    //
    // Perform default processing.
    //
    Button::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(MouseWithin))
    {
        _OnMouseOver(pvNew);
    }
}



//
// Called to begin a drag-drop operation from the control panel.
// This is used for dragging CPL applet icons to shell folders
// for shortcut creation.
//
HRESULT
CLinkElement::_BeginDrag(
    int iClickPosX,
    int iClickPosY
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_BeginDrag");

    HRESULT hr = E_FAIL;
    HRESULT hrCoInit = SHCoInitialize();
    if (SUCCEEDED(hrCoInit))
    {
        hr = hrCoInit;
        
        IDataObject *pdtobj;
        hr = _GetDragDropData(&pdtobj);
        if (SUCCEEDED(hr))
        {
            //
            // Ignore any failure to set the drag image.  Drag images
            // are not supported on some video configurations.
            // In these cases, we still want to be able to create a shortcut.
            //
            THR(_SetDragImage(pdtobj, iClickPosX, iClickPosY));

            HWND hwndRoot;
            hr = THR(Dui_GetElementRootHWND(this, &hwndRoot));
            if (SUCCEEDED(hr))
            {
                DWORD dwEffect = DROPEFFECT_LINK;
                hr = THR(SHDoDragDrop(hwndRoot, pdtobj, NULL, dwEffect, &dwEffect));
            }
            pdtobj->Release();
        }
        SHCoUninitialize(hrCoInit);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_BeginDrag", hr);
    return THR(hr);
}


//
// Get and prepare the data object used in a drag-drop operation.
// The returned data object is suitable for use by SHDoDragDrop.
//
HRESULT
CLinkElement::_GetDragDropData(
    IDataObject **ppdtobj
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_GetDragDropData");
    ASSERT(NULL != ppdtobj);
    ASSERT(!IsBadWritePtr(ppdtobj, sizeof(*ppdtobj)));
    ASSERT(NULL != m_pUiCommand);
    
    *ppdtobj = NULL;
    
    ICpUiCommand *puic;
    HRESULT hr = m_pUiCommand->QueryInterface(IID_PPV_ARG(ICpUiCommand, &puic));
    if (SUCCEEDED(hr))
    {
        //
        // Note that this call will fail with E_NOTIMPL for links that don't
        // provide drag-drop data.  Only CPL applet links provide data.
        // This is how we limit drag-drop to only CPL applets.
        //
        IDataObject *pdtobj;
        hr = THR(puic->GetDataObject(&pdtobj));
        if (SUCCEEDED(hr))
        {
            hr = _SetPreferredDropEffect(pdtobj, DROPEFFECT_LINK);
            if (SUCCEEDED(hr))
            {
                (*ppdtobj = pdtobj)->AddRef();
            }
            pdtobj->Release();
        }
        puic->Release();
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_GetDragDropData", hr);
    return THR(hr);
}


HRESULT
CLinkElement::_SetPreferredDropEffect(
    IDataObject *pdtobj,
    DWORD dwEffect
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_SetPreferredDropEffect");

    HRESULT hr = S_OK;
    static CLIPFORMAT cf;
    if ((CLIPFORMAT)0 == cf)
    {
        cf = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        if ((CLIPFORMAT)0 == cf)
        {
            hr = THR(ResultFromLastError());
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = THR(DataObj_SetDWORD(pdtobj, cf, dwEffect));
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_SetPreferredDropEffect", hr);
    return THR(hr);
}


//
// Set up the drag image in the data object so that our icon is
// displayed during the drag operation.
//
// I took this code from the old webvw project's fldricon.cpp 
// implementation (shell\ext\webvw\fldricon.cpp).  It seems to
// work just fine.
//
HRESULT 
CLinkElement::_SetDragImage(
    IDataObject *pdtobj,
    int iClickPosX, 
    int iClickPosY
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_SetDragImage");

    ASSERT(NULL != pdtobj);

    HRESULT hr = S_OK;
    HDC hdc = CreateCompatibleDC(NULL);
    if (NULL == hdc)
    {
        hr = THR(ResultFromLastError());
    }
    else
    {
        HBITMAP hbm;
        LONG lBitmapWidth;
        LONG lBitmapHeight;
        hr = _GetDragImageBitmap(&hbm, &lBitmapWidth, &lBitmapHeight);
        if (SUCCEEDED(hr))
        {
            IDragSourceHelper *pdsh;
            hr = CoCreateInstance(CLSID_DragDropHelper, 
                                  NULL, 
                                  CLSCTX_INPROC_SERVER, 
                                  IID_PPV_ARG(IDragSourceHelper, &pdsh));
            if (SUCCEEDED(hr))
            {
                BITMAPINFOHEADER bmi = {0};
                BITMAP           bm  = {0};
                UINT uBufferOffset   = 0;
                //
                // This is a screwy procedure to use GetDIBits.  
                // See knowledge base Q80080
                //
                if (GetObject(hbm, sizeof(BITMAP), &bm))
                {
                    bmi.biSize     = sizeof(BITMAPINFOHEADER);
                    bmi.biWidth    = bm.bmWidth;
                    bmi.biHeight   = bm.bmHeight;
                    bmi.biPlanes   = 1;
                    bmi.biBitCount = bm.bmPlanes * bm.bmBitsPixel;
                    //
                    // This needs to be one of these 4 values
                    //
                    if (bmi.biBitCount <= 1)
                        bmi.biBitCount = 1;
                    else if (bmi.biBitCount <= 4)
                        bmi.biBitCount = 4;
                    else if (bmi.biBitCount <= 8)
                        bmi.biBitCount = 8;
                    else
                        bmi.biBitCount = 24;
                    
                    bmi.biCompression = BI_RGB;
                    //
                    // Total size of buffer for info struct and color table
                    //
                    uBufferOffset = sizeof(BITMAPINFOHEADER) + 
                                    ((bmi.biBitCount == 24) ? 0 : ((1 << bmi.biBitCount) * sizeof(RGBQUAD)));
                    //
                    // Buffer for bitmap bits, so we can copy them.
                    //
                    BYTE *psBits = (BYTE *)SHAlloc(uBufferOffset);

                    if (NULL == psBits)
                    {
                        hr = THR(E_OUTOFMEMORY);
                    }
                    else
                    {
                        //
                        // Put bmi into the memory block
                        //
                        CopyMemory(psBits, &bmi, sizeof(BITMAPINFOHEADER));
                        //
                        // Get the size of the buffer needed for bitmap bits
                        //
                        if (!GetDIBits(hdc, hbm, 0, 0, NULL, (BITMAPINFO *) psBits, DIB_RGB_COLORS))
                        {
                            hr = THR(ResultFromLastError());
                        }
                        else
                        {
                            //
                            // Realloc our buffer to be big enough
                            //
                            psBits = (BYTE *)SHRealloc(psBits, uBufferOffset + ((BITMAPINFOHEADER *) psBits)->biSizeImage);

                            if (NULL == psBits)
                            {
                                hr = THR(E_OUTOFMEMORY);
                            }
                            else
                            {
                                //
                                // Fill the buffer
                                //
                                if (!GetDIBits(hdc, 
                                               hbm, 
                                               0, 
                                               bmi.biHeight, 
                                               (void *)(psBits + uBufferOffset), 
                                               (BITMAPINFO *)psBits, 
                                               DIB_RGB_COLORS))
                                {
                                    hr = THR(ResultFromLastError());
                                }
                                else
                                {
                                    SHDRAGIMAGE shdi;  // Drag images struct
                                    
                                    shdi.hbmpDragImage = CreateBitmapIndirect(&bm);
                                    if (NULL == shdi.hbmpDragImage)
                                    {
                                        hr = THR(ResultFromLastError());
                                    }
                                    else
                                    {
                                        //
                                        // Set the drag image bitmap
                                        //
                                        if (SetDIBits(hdc, 
                                                      shdi.hbmpDragImage, 
                                                      0, 
                                                      lBitmapHeight, 
                                                      (void *)(psBits + uBufferOffset), 
                                                      (BITMAPINFO *)psBits, 
                                                      DIB_RGB_COLORS))
                                        {
                                            //
                                            // Populate the drag image structure
                                            //
                                            shdi.sizeDragImage.cx = lBitmapWidth;
                                            shdi.sizeDragImage.cy = lBitmapHeight;
                                            shdi.ptOffset.x       = iClickPosX;
                                            shdi.ptOffset.y       = iClickPosY;
                                            shdi.crColorKey       = 0;
                                            //
                                            // Set the drag image
                                            //
                                            hr = pdsh->InitializeFromBitmap(&shdi, pdtobj); 
                                        }
                                        else
                                        {
                                            hr = THR(ResultFromLastError());
                                        }
                                        if (FAILED(hr))
                                        {
                                            DeleteObject(shdi.hbmpDragImage);
                                        }
                                    }
                                }
                            }
                        }
                        if (NULL != psBits)
                        {
                            SHFree(psBits);
                        }
                    }
                }
                pdsh->Release();
            }
            DeleteObject(hbm);
        }
        DeleteDC(hdc);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_SetDragImage", hr);
    return THR(hr);
}


HRESULT
CLinkElement::_GetDragImageBitmap(
    HBITMAP *phbm,
    LONG *plWidth,
    LONG *plHeight
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_GetDragImageBitmap");

    ASSERT(NULL != phbm);
    ASSERT(!IsBadWritePtr(phbm, sizeof(*phbm)));
    ASSERT(NULL != plWidth);
    ASSERT(!IsBadWritePtr(plWidth, sizeof(*plWidth)));
    ASSERT(NULL != plHeight);
    ASSERT(!IsBadWritePtr(plHeight, sizeof(*plHeight)));
    
    *phbm     = NULL;
    *plWidth  = 0;
    *plHeight = 0;

    HICON hIcon;
    HRESULT hr = _GetElementIcon(&hIcon);
    if (SUCCEEDED(hr))
    {
        ICONINFO iconinfo;

        if (GetIconInfo(hIcon, &iconinfo))
        {
            BITMAP bm;
            if (GetObject(iconinfo.hbmColor, sizeof(bm), &bm))
            {
                *plWidth  = bm.bmWidth;
                *plHeight = bm.bmHeight;
                *phbm     = iconinfo.hbmColor;
            }
            else
            {
                DeleteObject(iconinfo.hbmColor);
                hr = THR(ResultFromLastError());
            }
            DeleteObject(iconinfo.hbmMask);
        }
        else
        {
            hr = THR(ResultFromLastError());
        }
        DestroyIcon(hIcon);
    }    
    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_GetDragImageBitmap", hr);
    return THR(hr);
}



HRESULT
CLinkElement::_Initialize(
    void
    )
{
    HRESULT hr = Button::Initialize(AE_Mouse | AE_Keyboard);
    if (SUCCEEDED(hr))
    {
        hr = _AddOrDeleteAtoms(true);
    }
    return THR(hr);
}


void
CLinkElement::_Destroy(
    void
    )
{
    if (NULL != m_hwndInfotip && IsWindow(m_hwndInfotip))
    {
        SHDestroyInfotipWindow(&m_hwndInfotip);
    }

    ATOMICRELEASE(m_pUiCommand);

    _AddOrDeleteAtoms(false);
}


HRESULT
CLinkElement::_AddOrDeleteAtoms(
    bool bAdd
    )
{
    struct CPL::ATOMINFO rgAtomInfo[] = {
        { L"title", &m_idTitle },
        { L"icon",  &m_idIcon  },
        };

    HRESULT hr = Dui_AddOrDeleteAtoms(rgAtomInfo, ARRAYSIZE(rgAtomInfo), bAdd);
    return THR(hr);
}



HRESULT
CLinkElement::_CreateElementTitle(
    void
    )
{
    LPWSTR pszTitle;
    HRESULT hr = _GetTitleText(&pszTitle);
    if (SUCCEEDED(hr))
    {
        hr = Dui_SetDescendentElementText(this, L"title", pszTitle);
        CoTaskMemFree(pszTitle);
    }
    return THR(hr);
}
    


HRESULT
CLinkElement::_CreateElementIcon(
    void
    )
{
    HICON hIcon;
    HRESULT hr = _GetElementIcon(&hIcon);
    if (SUCCEEDED(hr))
    {
        hr = Dui_SetDescendentElementIcon(this, L"icon", hIcon);
        if (FAILED(hr))
        {
            DestroyIcon(hIcon);
        }
    }
    return THR(hr);
}


HRESULT
CLinkElement::_GetElementIcon(
    HICON *phIcon
    )
{
    ASSERT(NULL != phIcon);
    ASSERT(!IsBadWritePtr(phIcon, sizeof(*phIcon)));
    ASSERT(NULL != m_pUiCommand);

    *phIcon = NULL;
    
    ICpUiElementInfo *pei;
    HRESULT hr = m_pUiCommand->QueryInterface(IID_PPV_ARG(ICpUiElementInfo, &pei));
    if (SUCCEEDED(hr))
    {
        hr = pei->LoadIcon(m_eIconSize, phIcon);
        pei->Release();
    }
    return THR(hr);
}


HRESULT
CLinkElement::_OnContextMenu(
    DUI::ButtonContextEvent *peButton
    )
{
    DBG_ENTER(FTF_CPANEL, "CLinkElement::_OnContextMenu");

    ICpUiCommand *pcmd;
    HRESULT hr = m_pUiCommand->QueryInterface(IID_PPV_ARG(ICpUiCommand, &pcmd));
    if (SUCCEEDED(hr))
    {
        HWND hwndRoot;
        hr = Dui_GetElementRootHWND(this, &hwndRoot);
        if (SUCCEEDED(hr))
        {
            if (-1 == peButton->pt.x)
            {
                //
                // Keyboard context menu.
                //
                SIZE size;
                hr = Dui_GetElementExtent(this, &size);
                if (SUCCEEDED(hr))
                {
                    peButton->pt.x = size.cx / 2;
                    peButton->pt.y = size.cy / 2;
                }
            }
            POINT pt;
            hr = Dui_MapElementPointToRootHWND(this, peButton->pt, &pt);
            if (SUCCEEDED(hr))
            {
                if (ClientToScreen(hwndRoot, &pt))
                {
                    //
                    // InvokeContextMenu returns S_FALSE if the command doesn't 
                    // provide a context menu.
                    //
                    hr = pcmd->InvokeContextMenu(hwndRoot, &pt);
                }
                else
                {
                    hr = ResultFromLastError();
                }
            }
        }
        pcmd->Release();
    }
    else if (E_NOINTERFACE == hr)
    {
        hr = S_FALSE;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CLinkElement::_OnContextMenu", hr);
    return THR(hr);
}



HRESULT
CLinkElement::_OnSelected(
    void
    )
{
    ASSERT(NULL != m_pUiCommand);

    //
    //  Delay navigation until double-click time times out occurs. 
    //
    //  KB: gpease  05-APR-2001     Fix for Whistler Bug #338552 (and others)
    //
    //      Delaying this prevents the "second click" from being applied
    //      to the newly navigated frame. Previously, if there happen to 
    //      be a new link in the new frame at the same mouse point at 
    //      which the previous navigation occured, the new link would have
    //      received the 2nd click and we'd navigate that link as well. This
    //      causes the current frame to get the 2nd click which we ignore
    //      since we only care about the single click (see OnEvent above).
    //

    HWND hwndRoot;
    HRESULT hr = Dui_GetElementRootHWND(this, &hwndRoot);
    if (SUCCEEDED(hr))
    {
        SendMessage(hwndRoot, WM_USER_DELAY_NAVIGATION, (WPARAM) NULL, (LPARAM) m_pUiCommand);
    }

    return THR(hr);
}



void
CLinkElement::_OnMouseOver(
    DUI::Value *pvNewMouseWithin
    )
{
    _ShowInfotipWindow(pvNewMouseWithin->GetBool());
}
    


//
// Retrieve the title text for the element.
// Caller must free returned buffer using CoTaskMemFree.
//
HRESULT
CLinkElement::_GetTitleText(
    LPWSTR *ppszTitle
    )
{
    ASSERT(NULL != m_pUiCommand);
    ASSERT(NULL != ppszTitle);
    ASSERT(!IsBadWritePtr(ppszTitle, sizeof(*ppszTitle)));

    *ppszTitle = NULL;
    
    ICpUiElementInfo *pei;
    HRESULT hr = m_pUiCommand->QueryInterface(IID_PPV_ARG(ICpUiElementInfo, &pei));
    if (SUCCEEDED(hr))
    {
        hr = pei->LoadName(ppszTitle);
        pei->Release();
    }
    return THR(hr);
}


//
// Retrieve the infotip text for the element.
// Caller must free returned buffer using CoTaskMemFree.
//
HRESULT
CLinkElement::_GetInfotipText(
    LPWSTR *ppszInfotip
    )
{
    ASSERT(NULL != m_pUiCommand);
    ASSERT(NULL != ppszInfotip);
    ASSERT(!IsBadWritePtr(ppszInfotip, sizeof(*ppszInfotip)));

    *ppszInfotip = NULL;
    
    ICpUiElementInfo *pei;
    HRESULT hr = m_pUiCommand->QueryInterface(IID_PPV_ARG(ICpUiElementInfo, &pei));
    if (SUCCEEDED(hr))
    {
        hr = pei->LoadTooltip(ppszInfotip);
        pei->Release();
    }
    return THR(hr);
}
    


HRESULT
CLinkElement::_ShowInfotipWindow(
    bool bShow
    )
{
    HRESULT hr = S_OK;
    if (bShow)
    {
        if (NULL == m_hwndInfotip)
        {
            HWND hwndRoot;
            hr = THR(Dui_GetElementRootHWND(this, &hwndRoot));
            if (SUCCEEDED(hr))
            {
                LPWSTR pszInfotip;
                hr = THR(_GetInfotipText(&pszInfotip));
                if (SUCCEEDED(hr))
                {
                    hr = THR(SHCreateInfotipWindow(hwndRoot, pszInfotip, &m_hwndInfotip));
                    CoTaskMemFree(pszInfotip);
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = THR(SHShowInfotipWindow(m_hwndInfotip, TRUE));
        }
    }
    else
    {
        if (NULL != m_hwndInfotip)
        {
            hr = THR(SHDestroyInfotipWindow(&m_hwndInfotip));
        }
    }
    return THR(hr);
}



//
// ClassInfo (must appear after property definitions).
//
DUI::IClassInfo *CLinkElement::Class = NULL;
HRESULT CLinkElement::Register()
{
    return DUI::ClassInfo<CLinkElement,DUI::Button>::Register(L"linkelement", NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpnamespc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpnamespc.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_NAMESPACE_H
#define __CONTROLPANEL_NAMESPACE_H


namespace CPL {

//
// Generates a new namespace object to represent the Control Panel
// categorized namespace.
//
HRESULT CplNamespace_CreateInstance(IEnumIDList *penumIDs, REFIID riid, void **ppvOut);
//
// Retrieve the count of applets in a particular category.
//
HRESULT CplNamespace_GetCategoryAppletCount(ICplNamespace *pns, eCPCAT eCategory, int *pcApplets);


} // namespace CPL


#endif // __CONTROLPANEL_NAMESPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpuiele.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpuiele.cpp
//
//  This module contains the following classes:
//
//    CCplUiElement
//    CCplUiCommand
//    CCplUiCommandOnPidl
//
//    CCplUiElement is an implementation of IUIElement.  This provides
//    the necessary display information for use in the shell's webview
//    implementation.  The class also implements ICpUiElementInfo which
//    is similar to IUIElement but provides the display information in
//    a more 'final' form than a "<module>,<resource>" format.  
//    The ICpUiElementInfo interface is used internally by the Control Panel
//    implementation.
//
//    CCplUiCommand is an implementation of IUICommand.  As with IUIElement,
//    this provides the necessary functions for communicating with webview
//    as a 'command' object (i.e. selectable 'link').  Also as with the
//    previous class, CCplUiCommand implements an internal version of
//    the public interface.  ICplUiCommand provides two things:
//      1. A method to invoke a context menu.
//      2. An invocation method that accepts a site pointer.  This site
//         pointer is passed along to an 'action' object that may need
//         access to the shell browser to perform it's function.  It
//         obtains access to the shell browser through this site ptr.
//
//    CCplUiCommandOnPidl is another implementation of IUICommand that
//    wraps a shell item ID list.  It is used to represent the CPL
//    applet items in a category view.
//    
//--------------------------------------------------------------------------
#include "shellprv.h"

#include "cpviewp.h"
#include "cpguids.h"
#include "cpuiele.h"
#include "cputil.h"
#include "contextmenu.h"
#include "prop.h"

namespace CPL {


//-----------------------------------------------------------------------------
// CCplUiElement
//-----------------------------------------------------------------------------

class CCplUiElement : public IUIElement,
                      public ICpUiElementInfo
{
    public:
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IUIElement (used by shell webview)
        //
        STDMETHOD(get_Name)(IShellItemArray *psiItemArray, LPWSTR *ppszName);
        STDMETHOD(get_Icon)(IShellItemArray *psiItemArray, LPWSTR *ppszIcon);
        STDMETHOD(get_Tooltip)(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip);        
        //
        // ICpUiElementInfo (used internally by Control Panel)
        //
        STDMETHOD(LoadIcon)(eCPIMGSIZE eSize, HICON *phIcon);
        STDMETHOD(LoadName)(LPWSTR *ppszName);
        STDMETHOD(LoadTooltip)(LPWSTR *ppszTooltip);

        static HRESULT CreateInstance(LPCWSTR pszName, LPCWSTR pszInfotip, LPCWSTR pszIcon, REFIID riid, void **ppvOut);


    protected:
        CCplUiElement(LPCWSTR pszName, LPCWSTR pszInfotip, LPCWSTR pszIcon);
        CCplUiElement(void);
        virtual CCplUiElement::~CCplUiElement(void);

    private:
        LONG    m_cRef;
        LPCWSTR m_pszName;
        LPCWSTR m_pszInfotip;
        LPCWSTR m_pszIcon;

        HRESULT _GetResourceString(LPCWSTR pszItem, LPWSTR *ppsz);
        HRESULT _GetIconResource(LPWSTR *ppsz);
        HRESULT _GetNameResource(LPWSTR *ppsz);
        HRESULT _GetInfotipResource(LPWSTR *ppsz);
};


CCplUiElement::CCplUiElement(
    LPCWSTR pszName, 
    LPCWSTR pszInfotip,   // NULL == No Info Tip
    LPCWSTR pszIcon
    ) : m_cRef(1),
        m_pszName(pszName),
        m_pszInfotip(pszInfotip),
        m_pszIcon(pszIcon)
{
    ASSERT(IS_INTRESOURCE(m_pszName)    || !IsBadStringPtr(m_pszName, UINT_PTR(-1)));
    ASSERT((NULL == pszInfotip) || IS_INTRESOURCE(m_pszInfotip) || !IsBadStringPtr(m_pszInfotip, UINT_PTR(-1)));
    ASSERT(IS_INTRESOURCE(m_pszIcon)    || !IsBadStringPtr(m_pszIcon, UINT_PTR(-1)));
}


CCplUiElement::CCplUiElement(
    void
    ) : m_cRef(1),
        m_pszName(NULL),
        m_pszInfotip(NULL),
        m_pszIcon(NULL)
{
    TraceMsg(TF_LIFE, "CCplUiElement::CCplUiElement, this = 0x%x", this);
}


CCplUiElement::~CCplUiElement(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplUiElement::~CCplUiElement, this = 0x%x", this);
    //
    // Note that the member string pointers contain either a resource ID
    // or a pointer to constant memory.
    // Therefore, we do not try to free them.
    //
}


HRESULT 
CCplUiElement::CreateInstance(  // [static]
    LPCWSTR pszName, 
    LPCWSTR pszInfotip, 
    LPCWSTR pszIcon, 
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplUiElement *pe = new CCplUiElement(pszName, pszInfotip, pszIcon);
    if (NULL != pe)
    {
        hr = pe->QueryInterface(riid, ppvOut);
        pe->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplUiElement::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplUiElement, IUIElement),
        QITABENT(CCplUiElement, ICpUiElementInfo),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CCplUiElement::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CCplUiElement::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}



STDMETHODIMP
CCplUiElement::get_Name(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszName
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);

    HRESULT hr = LoadName(ppszName);
    return THR(hr);
}



STDMETHODIMP
CCplUiElement::get_Icon(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszIcon
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);

    HRESULT hr = _GetIconResource(ppszIcon);
    return THR(hr);
}


STDMETHODIMP
CCplUiElement::get_Tooltip(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszInfotip
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);
    HRESULT hr = THR(LoadTooltip(ppszInfotip));
    if (S_FALSE == hr)
    {
        //
        // Tooltips are optional but we need to return a failure
        // code to tell webview that we don't have one.
        //
        hr = E_FAIL;
    }
    return hr;
}


STDMETHODIMP
CCplUiElement::LoadIcon(
    eCPIMGSIZE eSize, 
    HICON *phIcon
    )
{
    *phIcon = NULL;

    LPWSTR pszResource;
    HRESULT hr = _GetIconResource(&pszResource);
    if (SUCCEEDED(hr))
    {
        hr = CPL::LoadIconFromResource(pszResource, eSize, phIcon);
        CoTaskMemFree(pszResource);
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiElement::LoadName(
    LPWSTR *ppszName
    )
{
    LPWSTR pszResource;
    HRESULT hr = _GetNameResource(&pszResource);
    if (SUCCEEDED(hr))
    {
        hr = CPL::LoadStringFromResource(pszResource, ppszName);
        CoTaskMemFree(pszResource);
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiElement::LoadTooltip(
    LPWSTR *ppszTooltip
    )
{
    LPWSTR pszResource;
    HRESULT hr = _GetInfotipResource(&pszResource);
    if (S_OK == hr)
    {
        hr = CPL::LoadStringFromResource(pszResource, ppszTooltip);
        CoTaskMemFree(pszResource);
    }
    return THR(hr);
}


HRESULT 
CCplUiElement::_GetIconResource(
    LPWSTR *ppsz
    )
{
    HRESULT hr = _GetResourceString(m_pszIcon, ppsz);
    return THR(hr);
}


HRESULT 
CCplUiElement::_GetNameResource(
    LPWSTR *ppsz
    )
{
    HRESULT hr = _GetResourceString(m_pszName, ppsz);
    return THR(hr);
}


//
// Returns S_FALSE if tooltip text is not provided.
// Tooltips are optional.  For example, the "learn about"
// tasks in Control Panel's web view pane do not have tooltip
// text.
//
HRESULT 
CCplUiElement::_GetInfotipResource(
    LPWSTR *ppsz
    )
{
    HRESULT hr = S_FALSE;
    if (NULL != m_pszInfotip)
    {
        hr = _GetResourceString(m_pszInfotip, ppsz);
    }
    return THR(hr);
}


//
// On successful return, caller must free returned string using
// CoTaskMemFree.
//
HRESULT
CCplUiElement::_GetResourceString(
    LPCWSTR pszItem,
    LPWSTR *ppsz
    )
{
    ASSERT(NULL != ppsz);
    ASSERT(!IsBadWritePtr(ppsz, sizeof(*ppsz)));

    *ppsz = NULL;
    HRESULT hr = E_FAIL;

    if (IS_INTRESOURCE(pszItem))
    {
        //
        // pszItem is a resource identifier integer.  Create a resource
        // ID string "<module>,<-i>" for the resource.
        //
        WCHAR szModule[MAX_PATH];
        if (GetModuleFileNameW(HINST_THISDLL, szModule, ARRAYSIZE(szModule)))
        {
            const size_t cchResource = lstrlenW(szModule) + 15;
            *ppsz = (LPWSTR)CoTaskMemAlloc(cchResource * sizeof(WCHAR));
            if (NULL != *ppsz)
            {
                //
                // Precede the resource ID with a minus sign so that it will be
                // treated as a resource ID and not an index.
                //
                hr = StringCchPrintfW(*ppsz, cchResource, L"%s,-%u", szModule, PtrToUint(pszItem));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = ResultFromLastError();
        }
    }
    else
    {
        //
        // pszItem is a text string. Assume it's in the form of
        // "<module>,<-i>".  Simply duplicate it.
        //
        ASSERT(!IsBadStringPtr(pszItem, UINT_PTR(-1)));

        hr = SHStrDup(pszItem, ppsz);
    }
    return THR(hr);
}




//-----------------------------------------------------------------------------
// CCplUiCommand
//-----------------------------------------------------------------------------

class CCplUiCommand : public CObjectWithSite,
                      public CCplUiElement,
                      public IUICommand,
                      public ICpUiCommand
                      
{
    public:
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void)
            { return CCplUiElement::AddRef(); }
        STDMETHOD_(ULONG, Release)(void)
            { return CCplUiElement::Release(); }
        //
        // IUICommand
        //
        STDMETHOD(get_Name)(IShellItemArray *psiItemArray, LPWSTR *ppszName)
            { return CCplUiElement::get_Name(psiItemArray, ppszName); }
        STDMETHOD(get_Icon)(IShellItemArray *psiItemArray, LPWSTR *ppszIcon)
            { return CCplUiElement::get_Icon(psiItemArray, ppszIcon); }
        STDMETHOD(get_Tooltip)(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip)
            { return CCplUiElement::get_Tooltip(psiItemArray, ppszInfotip); }
        STDMETHOD(get_CanonicalName)(GUID *pguidCommandName);
        STDMETHOD(get_State)(IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puisState);
        STDMETHOD(Invoke)(IShellItemArray *psiItemArray, IBindCtx *pbc);       
        //
        // ICpUiCommand
        //
        STDMETHOD(InvokeContextMenu)(HWND hwndParent, const POINT *ppt);
        STDMETHOD(Invoke)(HWND hwndParent, IUnknown *punkSite);
        STDMETHOD(GetDataObject)(IDataObject **ppdtobj);
        //
        // ICpUiElementInfo
        //
        STDMETHOD(LoadIcon)(eCPIMGSIZE eSize, HICON *phIcon)
            { return CCplUiElement::LoadIcon(eSize, phIcon); }
        STDMETHOD(LoadName)(LPWSTR *ppszName)
            { return CCplUiElement::LoadName(ppszName); }
        STDMETHOD(LoadTooltip)(LPWSTR *ppszTooltip)
            { return CCplUiElement::LoadTooltip(ppszTooltip); }

        static HRESULT CreateInstance(LPCWSTR pszName, LPCWSTR pszInfotip, LPCWSTR pszIcon, const IAction *pAction, REFIID riid, void **ppvOut);

    protected:
        CCplUiCommand(LPCWSTR pszName, LPCWSTR pszInfotip, LPCWSTR pszIcon, const IAction *pAction);
        CCplUiCommand(void);
        ~CCplUiCommand(void);

    private:
        const IAction *m_pAction;

        HRESULT _IsCommandRestricted(void);
};


CCplUiCommand::CCplUiCommand(
    void
    ) : m_pAction(NULL)
{
    TraceMsg(TF_LIFE, "CCplUiCommand::CCplUiCommand, this = 0x%x", this);
}



CCplUiCommand::CCplUiCommand(
    LPCWSTR pszName, 
    LPCWSTR pszInfotip, 
    LPCWSTR pszIcon, 
    const IAction *pAction
    ) : CCplUiElement(pszName, pszInfotip, pszIcon),
        m_pAction(pAction)
{
    TraceMsg(TF_LIFE, "CCplUiCommand::CCplUiCommand, this = 0x%x", this);
}


CCplUiCommand::~CCplUiCommand(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplUiCommand::~CCplUiCommand, this = 0x%x", this);
    //
    // Note that m_pAction is a pointer to a const object.
    // Therefore, we don't try to free it.
    //
}



HRESULT
CCplUiCommand::CreateInstance(  // [static]
    LPCWSTR pszName, 
    LPCWSTR pszInfotip, 
    LPCWSTR pszIcon, 
    const IAction *pAction,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplUiCommand *pc = new CCplUiCommand(pszName, pszInfotip, pszIcon, pAction);
    if (NULL != pc)
    {
        hr = pc->QueryInterface(riid, ppvOut);
        pc->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplUiCommand::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplUiCommand, IUICommand),
        QITABENT(CCplUiCommand, ICpUiElementInfo),
        QITABENT(CCplUiCommand, ICpUiCommand),
        QITABENT(CCplUiCommand, IObjectWithSite),
        QITABENTMULTI(CCplUiCommand, IUIElement, IUICommand),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP
CCplUiCommand::get_CanonicalName(
    GUID *pguidCommandName
    )
{
    UNREFERENCED_PARAMETER(pguidCommandName);
    //
    // This function is unimplemented.  It is in IUICommand to
    // support generic functionality in the shell.  This functionality
    // is not applicable to the use of IUICommand in the Control
    // Panel.
    //
    return E_NOTIMPL;
}



STDMETHODIMP
CCplUiCommand::get_State(
    IShellItemArray *psiItemArray, 
    BOOL fOkToBeSlow, 
    UISTATE *puisState
    )
{
    ASSERT(NULL != m_pAction);
    ASSERT(NULL != puisState);
    ASSERT(!IsBadWritePtr(puisState, sizeof(*puisState)));

    UNREFERENCED_PARAMETER(psiItemArray);

    *puisState = UIS_DISABLED; // default;

    //
    // If an action is restricted, we hide it's corresponding
    // UI element in the user interface.
    //
    HRESULT hr = _IsCommandRestricted();
    if (SUCCEEDED(hr))
    {
        switch(hr)
        {
            case S_OK:
                *puisState = UIS_HIDDEN;
                break;

            case S_FALSE:
                *puisState = UIS_ENABLED;

            default:
                break;
        }
        //
        // Don't propagate S_FALSE to caller.
        //
        hr = S_OK;
    }
    return THR(hr);
}



//
// IUICommand::Invoke
// This version is called by webview when the user selects an 
// item from a webview menu.
//
STDMETHODIMP
CCplUiCommand::Invoke(
    IShellItemArray *psiItemArray, 
    IBindCtx *pbc
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplUiCommand::Invoke");

    ASSERT(NULL != m_pAction);

    UNREFERENCED_PARAMETER(psiItemArray);
    UNREFERENCED_PARAMETER(pbc);

    HRESULT hr = m_pAction->Execute(NULL, _punkSite);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplUiCommand::Invoke", hr);
    return THR(hr);
}     


//
// ICpUiCommand::Invoke
// This version is called by CLinkElement::_OnSelected when
// the user selects either a category task or a category item
// in the category choice view.
//
STDMETHODIMP
CCplUiCommand::Invoke(
    HWND hwndParent, 
    IUnknown *punkSite
    )
{
    ASSERT(NULL != m_pAction);

    HRESULT hr = m_pAction->Execute(hwndParent, punkSite);
    return THR(hr);
}


STDMETHODIMP
CCplUiCommand::InvokeContextMenu(
    HWND hwndParent, 
    const POINT *ppt
    )
{
    //
    // Only commands on pidls provide a context menu.
    //
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(ppt);
    return E_NOTIMPL;
}


STDMETHODIMP
CCplUiCommand::GetDataObject(
    IDataObject **ppdtobj
    )
{
    //
    // Simple UI commands don't provide a data object.
    //
    return E_NOTIMPL;
}


//
// Returns:
//   S_OK    = Command is restricted.
//   S_FALSE = Command is not restricted.
//
HRESULT
CCplUiCommand::_IsCommandRestricted(
    void
    )
{
    //
    // The ICplNamespace ptr is passed to IsRestricted in case the restriction
    // code needs to inspect contents of the namespace.  The "Other Cpl Options"
    // link command uses this to determine if the "OTHER" category contains any
    // CPL applets or not.  If it contains no applets, the link is hidden (restricted).
    //
    ICplNamespace *pns;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_SControlPanelView, IID_ICplNamespace, (void **)&pns);
    if (SUCCEEDED(hr))
    {
        hr = m_pAction->IsRestricted(pns);
        pns->Release();
    }
    return THR(hr);
}


//-----------------------------------------------------------------------------
// CCplUiCommandOnPidl
//-----------------------------------------------------------------------------

class CCplUiCommandOnPidl : public CObjectWithSite,
                            public IUICommand,
                            public ICpUiCommand,
                            public ICpUiElementInfo,
                            public IDataObject
                            
{
    public:
        ~CCplUiCommandOnPidl(void);

        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IUICommand
        //
        STDMETHOD(get_Name)(IShellItemArray *psiItemArray, LPWSTR *ppszName);
        STDMETHOD(get_Icon)(IShellItemArray *psiItemArray, LPWSTR *ppszIcon);
        STDMETHOD(get_Tooltip)(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip);
        STDMETHOD(get_CanonicalName)(GUID *pguidCommandName);
        STDMETHOD(get_State)(IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puisState);
        STDMETHOD(Invoke)(IShellItemArray *psiItemArray, IBindCtx *pbc);       
        //
        // ICpUiCommand
        //
        STDMETHOD(InvokeContextMenu)(HWND hwndParent, const POINT *ppt);
        STDMETHOD(Invoke)(HWND hwndParent, IUnknown *punkSite);
        STDMETHOD(GetDataObject)(IDataObject **ppdtobj);
        //
        // ICpUiElementInfo
        //
        STDMETHOD(LoadIcon)(eCPIMGSIZE eSize, HICON *phIcon);
        STDMETHOD(LoadName)(LPWSTR *ppszName);
        STDMETHOD(LoadTooltip)(LPWSTR *ppszTooltip);
        //
        // IDataObject
        //
        STDMETHOD(GetData)(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
        STDMETHOD(GetDataHere)(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
        STDMETHOD(QueryGetData)(FORMATETC *pFmtEtc);
        STDMETHOD(GetCanonicalFormatEtc)(FORMATETC *pFmtEtcIn, FORMATETC *pFmtEtcOut);
        STDMETHOD(SetData)(FORMATETC *pFmtEtc, STGMEDIUM *pstm, BOOL fRelease);
        STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
        STDMETHOD(DAdvise)(FORMATETC *pFmtEtc, DWORD grfAdv, LPADVISESINK pAdvSink, DWORD *pdwConnection);
        STDMETHOD(DUnadvise)(DWORD dwConnection);
        STDMETHOD(EnumDAdvise)(LPENUMSTATDATA *ppEnum);        

        static HRESULT CreateInstance(LPCITEMIDLIST pidl, REFIID riid, void **ppvOut);

    private:
        LONG          m_cRef;
        IShellFolder *m_psf;     // Cached Control Panel IShellFolder ptr.
        LPITEMIDLIST  m_pidl;    // Assumed to be relative to Control Panel.
        IDataObject  *m_pdtobj;

        CCplUiCommandOnPidl(void);

        HRESULT _GetControlPanelFolder(IShellFolder **ppsf);
        HRESULT _Initialize(LPCITEMIDLIST pidl);
        HRESULT _GetName(LPWSTR *ppszName);
        HRESULT _GetInfotip(LPWSTR *ppszInfotip);
        HRESULT _GetIconResource(LPWSTR *ppszIcon);
        HRESULT _Invoke(HWND hwndParent, IUnknown *punkSite);
        HRESULT _GetDataObject(IDataObject **ppdtobj);
};


CCplUiCommandOnPidl::CCplUiCommandOnPidl(
    void
    ) : m_cRef(1),
        m_psf(NULL),
        m_pidl(NULL),
        m_pdtobj(NULL)
{
    TraceMsg(TF_LIFE, "CCplUiCommandOnPidl::CCplUiCommandOnPidl, this = 0x%x", this);
}


CCplUiCommandOnPidl::~CCplUiCommandOnPidl(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplUiCommandOnPidl::~CCplUiCommandOnPidl, this = 0x%x", this);
    ATOMICRELEASE(m_psf);
    ATOMICRELEASE(m_pdtobj);
    if (NULL != m_pidl)
    {
        ILFree(m_pidl);
    }
}


HRESULT 
CCplUiCommandOnPidl::CreateInstance(  // [static]
    LPCITEMIDLIST pidl,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));
    ASSERT(NULL != pidl);

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplUiCommandOnPidl *pc = new CCplUiCommandOnPidl();
    if (NULL != pc)
    {
        hr = pc->_Initialize(pidl);
        if (SUCCEEDED(hr))
        {
            hr = pc->QueryInterface(riid, ppvOut);
        }
        pc->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplUiCommandOnPidl::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplUiCommandOnPidl, IUICommand),
        QITABENT(CCplUiCommandOnPidl, ICpUiCommand),
        QITABENT(CCplUiCommandOnPidl, ICpUiElementInfo),
        QITABENT(CCplUiCommandOnPidl, IObjectWithSite),
        QITABENT(CCplUiCommandOnPidl, IDataObject),
        QITABENTMULTI(CCplUiCommandOnPidl, IUIElement, IUICommand),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}


STDMETHODIMP_(ULONG)
CCplUiCommandOnPidl::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CCplUiCommandOnPidl::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


STDMETHODIMP
CCplUiCommandOnPidl::get_Name(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszName
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);

    HRESULT hr = _GetName(ppszName);
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::get_Icon(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszIcon
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);

    HRESULT hr = _GetIconResource(ppszIcon);
    return THR(hr);
}



STDMETHODIMP
CCplUiCommandOnPidl::get_Tooltip(
    IShellItemArray *psiItemArray, 
    LPWSTR *ppszInfotip
    )
{
    UNREFERENCED_PARAMETER(psiItemArray);

    HRESULT hr = _GetInfotip(ppszInfotip);
    return THR(hr);
}



STDMETHODIMP
CCplUiCommandOnPidl::get_CanonicalName(
    GUID *pguidCommandName
    )
{
    UNREFERENCED_PARAMETER(pguidCommandName);
    return E_NOTIMPL;
}



STDMETHODIMP
CCplUiCommandOnPidl::get_State(
    IShellItemArray *psiItemArray, 
    BOOL fOkToBeSlow, 
    UISTATE *puisState
    )
{
    ASSERT(NULL != puisState);
    ASSERT(!IsBadWritePtr(puisState, sizeof(*puisState)));

    UNREFERENCED_PARAMETER(psiItemArray);
    UNREFERENCED_PARAMETER(fOkToBeSlow);

    HRESULT hr = S_OK;
    *puisState = UIS_ENABLED; // default;

    //
    // We do not handle restrictions on CPL applets in the same
    // sense as other 'tasks' in this architecture.
    // CPL applets are restricted by the Control Panel folder's
    // item enumerator.  If the folder enumerates a CPL applet
    // then we assume it's valid to present that applet in the
    // UI.
    //
    return THR(hr);
}



STDMETHODIMP
CCplUiCommandOnPidl::Invoke(
    IShellItemArray *psiItemArray, 
    IBindCtx *pbc
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplUiCommandOnPidl::Invoke");

    UNREFERENCED_PARAMETER(psiItemArray);
    UNREFERENCED_PARAMETER(pbc);

    HRESULT hr = _Invoke(NULL, NULL);
    DBG_EXIT_HRES(FTF_CPANEL, "CCplUiCommandOnPidl::Invoke", hr);
    return THR(hr);
}     


//
// ICpUiCommand::Invoke
//
STDMETHODIMP
CCplUiCommandOnPidl::Invoke(
    HWND hwndParent, 
    IUnknown *punkSite
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplUiCommandOnPidl::Invoke");

    UNREFERENCED_PARAMETER(punkSite);

    HRESULT hr = _Invoke(hwndParent, punkSite);
    DBG_EXIT_HRES(FTF_CPANEL, "CCplUiCommandOnPidl::Invoke", hr);
    return THR(hr);
}


HRESULT 
CCplUiCommandOnPidl::_Invoke(
    HWND hwndParent,
    IUnknown *punkSite
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplUiCommandOnPidl::_Invoke");

    UNREFERENCED_PARAMETER(hwndParent);

    LPITEMIDLIST pidlCpanel;
    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlCpanel);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = ILCombine(pidlCpanel, m_pidl);
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            bool bItemIsBrowsable = false;
            IUnknown *punkSiteToRelease = NULL;
            if (NULL == punkSite)
            {
                //
                // No site provided.  Let's use our site.
                //
                ASSERT(NULL != _punkSite);
                (punkSite = punkSiteToRelease = _punkSite)->AddRef();
            }
            if (NULL != punkSite)
            {
                //
                // If we have a site pointer, try to browse the object in-place
                // if it is indeed browsable.
                //
                WCHAR szName[MAX_PATH];
                ULONG rgfAttrs = SFGAO_BROWSABLE | SFGAO_FOLDER;
                hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szName, ARRAYSIZE(szName), &rgfAttrs);
                if (SUCCEEDED(hr))
                {
                    if ((SFGAO_BROWSABLE | SFGAO_FOLDER) & rgfAttrs)
                    {
                        //
                        // Browse the object in-place.  This is the path taken
                        // by things like the "Printers" folder, "Scheduled Tasks" etc.
                        //
                        bItemIsBrowsable = true;
                        IShellBrowser *psb;
                        hr = CPL::ShellBrowserFromSite(punkSite, &psb);
                        if (SUCCEEDED(hr))
                        {
                            hr = CPL::BrowseIDListInPlace(pidl, psb);
                            psb->Release();
                        }
                    }
                }
            } 

            if (NULL == punkSite || !bItemIsBrowsable)
            {
                //
                // Either we don't have a site ptr (can't get to the browser)
                // or the item is not browsable.  Simply execute it.
                // This is the path taken by conventional CPL applets like
                // Mouse, Power Options, Display etc.
                //
                SHELLEXECUTEINFOW sei = {
                    sizeof(sei),           // cbSize;
                    SEE_MASK_INVOKEIDLIST, // fMask
                    NULL,                  // hwnd
                    NULL,                  // lpVerb
                    NULL,                  // lpFile
                    NULL,                  // lpParameters
                    NULL,                  // lpDirectory
                    SW_SHOWNORMAL,         // nShow
                    0,                     // hInstApp
                    pidl,                  // lpIDList
                    NULL,                  // lpClass
                    NULL,                  // hkeyClass
                    0,                     // dwHotKey
                    NULL,                  // hIcon
                    NULL                   // hProcess
                };
                if (!ShellExecuteExW(&sei))
                {
                    hr = ResultFromLastError();
                }
            }
            ATOMICRELEASE(punkSiteToRelease);
            ILFree(pidl);
        }
        ILFree(pidlCpanel);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplUiCommandOnPidl::_Invoke", hr);
    return THR(hr);
}     



HRESULT 
CCplUiCommandOnPidl::InvokeContextMenu(
    HWND hwndParent, 
    const POINT *ppt
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplUiCommandOnPidl::InvokeContextMenu");

    ASSERT(NULL != ppt);
    ASSERT(NULL == hwndParent || IsWindow(hwndParent));

    //
    // First build a full pidl to the item.
    //
    LPITEMIDLIST pidlCpanel;
    HRESULT hr = SHGetSpecialFolderLocation(hwndParent, CSIDL_CONTROLS, &pidlCpanel);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFull = ILCombine(pidlCpanel, m_pidl);
        if (NULL == pidlFull)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //
            // Get the item's context menu interface from the shell.
            //
            IContextMenu *pcm;
            hr = SHGetUIObjectFromFullPIDL(pidlFull, hwndParent, IID_PPV_ARG(IContextMenu, &pcm));
            if (SUCCEEDED(hr))
            {
                ASSERT(NULL != _punkSite);
                IContextMenu *pcmNoDelete;
                hr = Create_ContextMenuWithoutVerbs(pcm, L"cut;delete", IID_PPV_ARG(IContextMenu, &pcmNoDelete));
                if (SUCCEEDED(hr))
                {
                    hr = IUnknown_DoContextMenuPopup(_punkSite, pcmNoDelete, CMF_NORMAL, *ppt);
                    pcmNoDelete->Release();
                }
                pcm->Release();
            }
            else
            {
                TraceMsg(TF_ERROR, "Shell item does not provide a context menu");
            }
            ILFree(pidlFull);
        }
        ILFree(pidlCpanel);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplUiCommandOnPidl::InvokeContextMenu", hr);
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::GetDataObject(
    IDataObject **ppdtobj
    )
{
    return _GetDataObject(ppdtobj);
}


STDMETHODIMP
CCplUiCommandOnPidl::LoadIcon(
    eCPIMGSIZE eSize, 
    HICON *phIcon
    )
{
    IShellFolder *psf;
    HRESULT hr = CPL::GetControlPanelFolder(&psf);
    if (SUCCEEDED(hr))
    {
        hr = CPL::ExtractIconFromPidl(psf, m_pidl, eSize, phIcon);
        psf->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::LoadName(
    LPWSTR *ppszName
    )
{
    HRESULT hr = _GetName(ppszName);
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::LoadTooltip(
    LPWSTR *ppszTooltip
    )
{
    HRESULT hr = _GetInfotip(ppszTooltip);
    return THR(hr);
}


HRESULT
CCplUiCommandOnPidl::_Initialize(
    LPCITEMIDLIST pidl
    )
{
    ASSERT(NULL == m_pidl);
    ASSERT(NULL != pidl);

    HRESULT hr = E_OUTOFMEMORY;

    m_pidl = ILClone(pidl);
    if (NULL != m_pidl)
    {
        hr = S_OK;
    }
    return THR(hr);
}


HRESULT
CCplUiCommandOnPidl::_GetControlPanelFolder(
    IShellFolder **ppsf
    )
{
    ASSERT(NULL != ppsf);
    ASSERT(!IsBadWritePtr(ppsf, sizeof(*ppsf)));

    HRESULT hr = S_OK;

    if (NULL == m_psf)
    {
        hr = CPL::GetControlPanelFolder(&m_psf);
    }
    *ppsf = m_psf;
    if (NULL != *ppsf)
    {
        (*ppsf)->AddRef();
    }
    return THR(hr);
}


HRESULT 
CCplUiCommandOnPidl::_GetName(
    LPWSTR *ppszName
    )
{
    ASSERT(NULL != m_pidl);
    ASSERT(NULL != ppszName);
    ASSERT(!IsBadWritePtr(ppszName, sizeof(*ppszName)));

    *ppszName = NULL;

    IShellFolder *psf;
    HRESULT hr = _GetControlPanelFolder(&psf);
    if (SUCCEEDED(hr))
    {
        STRRET strret;
        hr = psf->GetDisplayNameOf(m_pidl, SHGDN_INFOLDER, &strret);
        if (SUCCEEDED(hr))
        {
            hr = StrRetToStrW(&strret, m_pidl, ppszName);
        }
        psf->Release();
    }
    return THR(hr);
}



HRESULT 
CCplUiCommandOnPidl::_GetInfotip(
    LPWSTR *ppszInfotip
    )
{
    ASSERT(NULL != ppszInfotip);
    ASSERT(!IsBadWritePtr(ppszInfotip, sizeof(*ppszInfotip)));
    ASSERT(NULL != m_pidl);

    *ppszInfotip = NULL;

    IShellFolder *psf;
    HRESULT hr = _GetControlPanelFolder(&psf);
    if (SUCCEEDED(hr))
    {
        IShellFolder2 *psf2;
        psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2));
        if (SUCCEEDED(hr))
        {
            TCHAR szBuf[256];
            hr = GetStringProperty(psf2, m_pidl, &SCID_Comment, szBuf, ARRAYSIZE(szBuf));
            if (SUCCEEDED(hr))
            {
                hr = SHStrDup(szBuf, ppszInfotip);
            }
            psf2->Release();
        }
        psf->Release();
    }
    return THR(hr);
}


HRESULT 
CCplUiCommandOnPidl::_GetIconResource(
    LPWSTR *ppszIcon
    )
{
    ASSERT(NULL != ppszIcon);
    ASSERT(!IsBadWritePtr(ppszIcon, sizeof(*ppszIcon)));
    ASSERT(NULL != m_pidl);

    LPWSTR pszIconPath = NULL;
    IShellFolder *psf;
    HRESULT hr = _GetControlPanelFolder(&psf);
    if (SUCCEEDED(hr))
    {
        IExtractIconW* pxi;
        hr = psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&m_pidl, IID_PPV_ARG_NULL(IExtractIconW, &pxi));
        if (SUCCEEDED(hr))
        {
            WCHAR szPath[MAX_PATH];
            int iIndex;
            UINT wFlags = 0;

            hr = pxi->GetIconLocation(GIL_FORSHELL, szPath, ARRAYSIZE(szPath), &iIndex, &wFlags);
            if (SUCCEEDED(hr))
            {
                const size_t cchIconPath = lstrlenW(szPath) + 15;
                pszIconPath = (LPWSTR)SHAlloc(cchIconPath * sizeof(WCHAR));
                if (pszIconPath)
                {
                    hr = StringCchPrintfW(pszIconPath, cchIconPath, L"%s,%d", szPath, iIndex);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            pxi->Release();
        }
        psf->Release();
    }
    *ppszIcon = pszIconPath;
    return THR(hr);
}


HRESULT
CCplUiCommandOnPidl::_GetDataObject(
    IDataObject **ppdtobj
    )
{
    ASSERT(NULL != ppdtobj);
    ASSERT(!IsBadWritePtr(ppdtobj, sizeof(*ppdtobj)));
    
    HRESULT hr = S_OK;
    if (NULL == m_pdtobj)
    {
        IShellFolder *psf;
        hr = _GetControlPanelFolder(&psf);
        if (SUCCEEDED(hr))
        {
            hr = THR(psf->GetUIObjectOf(NULL, 
                                        1, 
                                        (LPCITEMIDLIST *)&m_pidl, 
                                        IID_PPV_ARG_NULL(IDataObject, &m_pdtobj)));
            psf->Release();
        }
    }
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != m_pdtobj);
        (*ppdtobj = m_pdtobj)->AddRef();
    }
    return THR(hr);
}
      

STDMETHODIMP
CCplUiCommandOnPidl::GetData(
    FORMATETC *pFmtEtc, 
    STGMEDIUM *pstm
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->GetData(pFmtEtc, pstm);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::GetDataHere(
    FORMATETC *pFmtEtc, 
    STGMEDIUM *pstm
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->GetDataHere(pFmtEtc, pstm);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::QueryGetData(
    FORMATETC *pFmtEtc
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->QueryGetData(pFmtEtc);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::GetCanonicalFormatEtc(
    FORMATETC *pFmtEtcIn, 
    FORMATETC *pFmtEtcOut
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->GetCanonicalFormatEtc(pFmtEtcIn, pFmtEtcOut);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::SetData(
    FORMATETC *pFmtEtc, 
    STGMEDIUM *pstm, 
    BOOL fRelease
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->SetData(pFmtEtc, pstm, fRelease);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::EnumFormatEtc(
    DWORD dwDirection, 
    LPENUMFORMATETC *ppEnum
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->EnumFormatEtc(dwDirection, ppEnum);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::DAdvise(
    FORMATETC *pFmtEtc, 
    DWORD grfAdv, 
    LPADVISESINK pAdvSink, 
    DWORD *pdwConnection
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->DAdvise(pFmtEtc, grfAdv, pAdvSink, pdwConnection);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::DUnadvise(
    DWORD dwConnection
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->DUnadvise(dwConnection);
        pdtobj->Release();
    }
    return THR(hr);
}


STDMETHODIMP
CCplUiCommandOnPidl::EnumDAdvise(
    LPENUMSTATDATA *ppEnum
    )
{
    IDataObject *pdtobj;
    HRESULT hr = _GetDataObject(&pdtobj);
    if (SUCCEEDED(hr))
    {
        hr = pdtobj->EnumDAdvise(ppEnum);
        pdtobj->Release();
    }
    return THR(hr);
}


//-----------------------------------------------------------------------------
// Public instance generators.
//-----------------------------------------------------------------------------

HRESULT
Create_CplUiElement(
    LPCWSTR pszName,
    LPCWSTR pszInfotip,
    LPCWSTR pszIcon,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    return CCplUiElement::CreateInstance(pszName, pszInfotip, pszIcon, riid, ppvOut);
}


HRESULT
Create_CplUiCommand(
    LPCWSTR pszName,
    LPCWSTR pszInfotip,
    LPCWSTR pszIcon,
    const IAction *pAction,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    return CCplUiCommand::CreateInstance(pszName, pszInfotip, pszIcon, pAction, riid, ppvOut);
}

HRESULT 
Create_CplUiCommandOnPidl(
    LPCITEMIDLIST pidl,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));
    ASSERT(NULL != pidl);

    HRESULT hr = CCplUiCommandOnPidl::CreateInstance(pidl, riid, ppvOut);
    return THR(hr);
}



} // namespace CPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpuiele.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpuiele.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_UIELEMENT_H
#define __CONTROLPANEL_UIELEMENT_H


#include <cowsite.h>
#include "cpaction.h"


namespace CPL {

//
// Extension of IUICommand to include the activation of a context menu and
// passing of an IShellBrowser ptr for command invocation.
//
class ICpUiCommand : public IUnknown
{
    public:
        STDMETHOD(InvokeContextMenu)(HWND hwndParent, const POINT *ppt) PURE;
        STDMETHOD(Invoke)(HWND hwndParent, IUnknown *punkSite) PURE;
        STDMETHOD(GetDataObject)(IDataObject **ppdtobj) PURE;
};


//
// Internal interface for obtaining element information.
// Very similar to IUIElementInfo but returns the actual display 
// information rather than a resource identifier string.  Used internally
// only by the Control Panel code.
//
class ICpUiElementInfo : public IUnknown
{
    public:
        STDMETHOD(LoadIcon)(eCPIMGSIZE eSize, HICON *phIcon) PURE;
        STDMETHOD(LoadName)(LPWSTR *ppszName) PURE;
        STDMETHOD(LoadTooltip)(LPWSTR *ppszTooltip) PURE;
};



HRESULT 
Create_CplUiElement(
    LPCWSTR pszName,
    LPCWSTR pszInfotip,
    LPCWSTR pszIcon,
    REFIID riid,
    void **ppvOut);


HRESULT
Create_CplUiCommand(
    LPCWSTR pszName,
    LPCWSTR pszInfotip,
    LPCWSTR pszIcon,
    const IAction *pAction,
    REFIID riid,
    void **ppvOut);


HRESULT 
Create_CplUiCommandOnPidl(
    LPCITEMIDLIST pidl,
    REFIID riid,
    void **ppvOut);


} // namespace CPL

#endif //__CONTROLPANEL_UIELEMENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cputil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cputil.cpp
//
//--------------------------------------------------------------------------
#include "shellprv.h"

#include "cpviewp.h"
#include "cputil.h"


//
//  Loads a string based upon the description.
//    Example:  shell32,42
//
//  lpStrDesc - contains the string description
//
HRESULT
CPL::LoadStringFromResource(
    LPCWSTR pszStrDesc,
    LPWSTR *ppszOut
    )
{
    ASSERT(NULL != pszStrDesc);
    ASSERT(NULL != ppszOut);
    ASSERT(!IsBadWritePtr(ppszOut, sizeof(*ppszOut)));

    *ppszOut = NULL;
    
    WCHAR szFile[MAX_PATH];
    HRESULT hr = StringCchCopyW(szFile, ARRAYSIZE(szFile), pszStrDesc); // the below writes this buffer
    if (SUCCEEDED(hr))
    {
        int iStrID = PathParseIconLocationW(szFile);
        if (iStrID < 0)
        {
            iStrID = -iStrID; // support ",-id" syntax
        }

        HMODULE hLib = LoadLibraryExW(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (hLib)
        {
            WCHAR szTemp[INFOTIPSIZE]; // INFOTIPSIZE is the largest string type we're expected to load
            if (0 < LoadStringW(hLib, (UINT)iStrID, szTemp, ARRAYSIZE(szTemp)))
            {
                hr = SHStrDup(szTemp, ppszOut);
            }
            else
            {
                hr = ResultFromLastError();
            }
            FreeLibrary(hLib);
        }
        else
        {
            hr = ResultFromLastError();
        }
    }

    return THR(hr);
}


//
// Shell icon functions deal in terms of "small" and "large" icons.  
// This function determines which should be used for a 
// given eCPIMGSIZE value.
//
bool
CPL::ShouldUseSmallIconForDesiredSize(
    eCPIMGSIZE eSize
    )
{
    UINT cx;
    UINT cy;
    ImageDimensionsFromDesiredSize(eSize, &cx, &cy);

    if (int(cx) <= GetSystemMetrics(SM_CXSMICON))
    {
        return true;
    }
    return false;
}


//
// This function returns a eCPIMGSIZE value to pixel dimensions.
// This indirection lets us specify image sizes in abstract terms
// then convert to physical pixel dimensions when required.  If 
// you want to change the size of images used for a particular 
// Control Panel UI item type, this is where you change it.
//
void
CPL::ImageDimensionsFromDesiredSize(
    eCPIMGSIZE eSize,
    UINT *pcx,
    UINT *pcy
    )
{
    ASSERT(NULL != pcx);
    ASSERT(!IsBadWritePtr(pcx, sizeof(*pcx)));
    ASSERT(NULL != pcy);
    ASSERT(!IsBadWritePtr(pcy, sizeof(*pcy)));
    
    *pcx = *pcy = 0;

    //
    // This table converts eCPIMGSIZE values into actual
    // image size values.  A couple of things to note:
    //
    // 1. If you want to change the image size associated with
    //    an eIMGSIZE value, simply change these numbers.
    //
    // 2. If actual image size is dependent upon some system
    //    configuration parameter, do the interpretation of
    //    that parameter here making the size a function
    //    of that parameter.
    //
    static const SIZE rgSize[] = {
        { 16, 16 },          // eCPIMGSIZE_WEBVIEW
        { 16, 16 },          // eCPIMGSIZE_TASK
        { 48, 48 },          // eCPIMGSIZE_CATEGORY
        { 32, 32 },          // eCPIMGSIZE_BANNER
        { 32, 32 }           // eCPIMGSIZE_APPLET
        };

    ASSERT(int(eSize) >= 0 && int(eSize) < ARRAYSIZE(rgSize));
    
    *pcx = rgSize[eSize].cx;
    *pcy = rgSize[eSize].cy;
}
    


HRESULT
CPL::LoadIconFromResourceID(
    LPCWSTR pszModule,
    int idIcon,
    eCPIMGSIZE eSize,
    HICON *phIcon
    )
{
    ASSERT(NULL != pszModule);
    ASSERT(NULL != phIcon);
    ASSERT(!IsBadWritePtr(phIcon, sizeof(*phIcon)));
    ASSERT(0 < idIcon);

    HRESULT hr      = E_FAIL;
    HICON hIcon     = NULL;
    HMODULE hModule = LoadLibraryExW(pszModule, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hModule)
    {
        UINT cxIcon;
        UINT cyIcon;

        ImageDimensionsFromDesiredSize(eSize, &cxIcon, &cyIcon);

        hIcon = (HICON)LoadImage(hModule,
                                 MAKEINTRESOURCE(idIcon),
                                 IMAGE_ICON,
                                 cxIcon,
                                 cyIcon,
                                 0);

        if (NULL != hIcon)
        {
            hr = S_OK;
        }
        else
        {
            hr = ResultFromLastError();
        }
        FreeLibrary(hModule);
    }
    else
    {
        hr = ResultFromLastError();
    }

    *phIcon = hIcon;
    return THR(hr);
}



HRESULT
CPL::LoadIconFromResourceIndex(
    LPCWSTR pszModule,
    int iIcon,
    eCPIMGSIZE eSize,
    HICON *phIcon
    )
{
    ASSERT(NULL != pszModule);
    ASSERT(NULL != phIcon);
    ASSERT(!IsBadWritePtr(phIcon, sizeof(*phIcon)));

    if (-1 == iIcon)
    {
        //
        // Special case.  -1 is an invalid icon index/id.
        //
        iIcon = 0;
    }

    HICON hIcon = NULL;
    HRESULT hr = E_FAIL;
    if (CPL::ShouldUseSmallIconForDesiredSize(eSize))
    {
        if (0 < ExtractIconExW(pszModule, iIcon, NULL, &hIcon, 1))
        {
            hr = S_OK;
        }
        else
        {
            TraceMsg(TF_ERROR, "ExtractIconEx failed for small icon (index %d) in module \"%s\"", iIcon, pszModule);
        }
    }
    else
    {
        if (0 < ExtractIconExW(pszModule, iIcon, &hIcon, NULL, 1))
        {
            hr = S_OK;
        }
        else
        {
            TraceMsg(TF_ERROR, "ExtractIconEx failed for large icon (index %d) in module \"%s\"", iIcon, pszModule);
        }
    }
    *phIcon = hIcon;
    return THR(hr);
}



HRESULT
CPL::LoadIconFromResource(
    LPCWSTR pszResource,
    eCPIMGSIZE eSize,
    HICON *phIcon
    )
{
    ASSERT(NULL != pszResource);
    ASSERT(NULL != phIcon);
    ASSERT(!IsBadWritePtr(phIcon, sizeof(*phIcon)));

    *phIcon = NULL;

    //
    // PathParseIconLocation modifies it's input string.
    //
    WCHAR szResource[MAX_PATH];
    HRESULT hr = StringCchCopyW(szResource, ARRAYSIZE(szResource), pszResource);
    if (SUCCEEDED(hr))
    {
        int idIcon = PathParseIconLocationW(szResource);
        if (-1 == idIcon)
        {
            //
            // Special case.  -1 is an invalid icon ID.
            //
            idIcon = 0;
        }

        if (0 > idIcon)
        {
            hr = CPL::LoadIconFromResourceID(szResource, -idIcon, eSize, phIcon);
        }
        else
        {
            hr = CPL::LoadIconFromResourceIndex(szResource, idIcon, eSize, phIcon);
        }
    }
    return THR(hr);
}



HRESULT
CPL::ExtractIconFromPidl(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    eCPIMGSIZE eSize,
    HICON *phIcon
    )
{
    ASSERT(NULL != psf);
    ASSERT(NULL != pidl);
    ASSERT(NULL != phIcon);
    ASSERT(!IsBadWritePtr(phIcon, sizeof(*phIcon)));

    *phIcon = NULL;

    IExtractIcon *pei;
    HRESULT hr = psf->GetUIObjectOf(NULL, 1, &pidl, IID_IExtractIcon, NULL, (void **)&pei);
    if (SUCCEEDED(hr))
    {
        TCHAR szFile[MAX_PATH];
        INT iIcon;
        UINT uFlags = 0;
        hr = pei->GetIconLocation(GIL_FORSHELL, 
                                  szFile, 
                                  ARRAYSIZE(szFile), 
                                  &iIcon, 
                                  &uFlags);
        if (SUCCEEDED(hr))
        {
            if (0 == (GIL_NOTFILENAME & uFlags))
            {
                hr = CPL::LoadIconFromResourceIndex(szFile, iIcon, eSize, phIcon);
            }
            else
            {
                HICON hIconLarge = NULL;
                HICON hIconSmall = NULL;

                const int cxIcon   = GetSystemMetrics(SM_CXICON);
                const int cxSmIcon = GetSystemMetrics(SM_CXSMICON);
                
                hr = pei->Extract(szFile, 
                                  iIcon, 
                                  &hIconLarge, 
                                  &hIconSmall, 
                                  MAKELONG(cxIcon, cxSmIcon));
                if (SUCCEEDED(hr))
                {
                    if (CPL::ShouldUseSmallIconForDesiredSize(eSize))
                    {
                        *phIcon = hIconSmall;
                        hIconSmall = NULL;
                    }
                    else
                    {
                        *phIcon = hIconLarge;
                        hIconLarge = NULL;
                    }
                }
                //
                // Destroy any icons not being returned.
                //
                if (NULL != hIconSmall)
                {
                    DestroyIcon(hIconSmall);
                }
                if (NULL != hIconLarge)
                {
                    DestroyIcon(hIconLarge);
                }
            }
        }
        pei->Release();
    }
    ASSERT(FAILED(hr) || NULL != *phIcon);
    if (NULL == *phIcon)
    {
        //
        // If by-chance a NULL icon handle is retrieved, we don't
        // want to return a success code.
        //
        hr = E_FAIL;
    }
    return THR(hr);
}




//  Checks the given restriction.  Returns TRUE (restricted) if the
//  specified key/value exists and is non-zero, false otherwise
BOOL
DeskCPL_CheckRestriction(
    HKEY hKey,
    LPCWSTR lpszValueName
    )
{
    ASSERT(NULL != lpszValueName);

    DWORD dwData;
    DWORD dwSize = sizeof(dwData);
    
    if ((ERROR_SUCCESS == RegQueryValueExW(hKey,
                                           lpszValueName,
                                           NULL,
                                           NULL,
                                           (BYTE *)&dwData,
                                           &dwSize))
          && dwData)
    {        
        return TRUE;
    }
    return FALSE;
}


//
// Function returns the actual tab index given the default tab index.
// The actual tab index will be different than the default value if there are
// various system policies in effect which disable some tabs
//
// 
// To add further restrictions, modify the aTabMap to include the default tab
// index and the corresponding policy. Also, you should keep the eDESKCPLTAB enum
// in sync with the aTabMap array.
//
//
int
CPL::DeskCPL_GetTabIndex(
    CPL::eDESKCPLTAB iTab,
    OPTIONAL LPWSTR pszCanonicalName,
    OPTIONAL DWORD cchSize
    )
{
    HKEY hKey;
    int iTabActual = CPL::CPLTAB_ABSENT;

    if (iTab >= 0 && iTab < CPL::CPLTAB_DESK_MAX)
    {
        //
        // While adding more tabs, make sure that it is entered in the right position in the
        // the array below. So, for example, if the default tab index of the new tab is 2, it 
        // should be the aTabMap[2] entry (Currently CPLTAB_DESK_APPEARANCE is 
        // the one with tab index = 2). You will have to modify eDESKCPLTAB accordingly too.
        //
        struct 
        {
            int nIndex; // the canonical name of the tab (don't use indexes because they change with policies or revs)
            LPCWSTR pszCanoncialTabName; // the canonical name of the tab (don't use indexes because they change with policies or revs)
            LPCWSTR pszRestriction; // corresponding restriction
        } aTabMap[CPL::CPLTAB_DESK_MAX] = { 
            { 0, SZ_DISPLAYCPL_OPENTO_DESKTOP, REGSTR_VAL_DISPCPL_NOBACKGROUNDPAGE },   // CPLTAB_DESK_BACKGROUND == 0
            { 1, SZ_DISPLAYCPL_OPENTO_SCREENSAVER, REGSTR_VAL_DISPCPL_NOSCRSAVPAGE     },   // CPLTAB_DESK_SCREENSAVER == 1
            { 2, SZ_DISPLAYCPL_OPENTO_APPEARANCE, REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE },   // CPLTAB_DESK_APPEARANCE == 2
            { 3, SZ_DISPLAYCPL_OPENTO_SETTINGS, REGSTR_VAL_DISPCPL_NOSETTINGSPAGE   }    // CPLTAB_DESK_SETTINGS == 3
            };

#ifdef DEBUG
        //
        // Verify proper initialization of the nIndex member of aTabMap[]
        //
        for (int k=0; k < ARRAYSIZE(aTabMap); k++)
        {
            ASSERT(aTabMap[k].nIndex == k);
        }
#endif

        iTabActual = aTabMap[iTab].nIndex;

        //
        // Note, if no policy is configured, the RegOpenKey call below will fail,
        // in that case we return the default tab value, as entered in the 
        // map above.
        //
        if ((ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER,
                                            REGSTR_PATH_POLICIES L"\\" REGSTR_KEY_SYSTEM,
                                            0,
                                            KEY_QUERY_VALUE,
                                            &hKey)))
        {
            //
            // check all tabs to see if there is restriction
            //
            if (DeskCPL_CheckRestriction(hKey, aTabMap[iTab].pszRestriction))
            {
                // this tab does not exist, mark it as such
                iTabActual = CPL::CPLTAB_ABSENT;
            }

            RegCloseKey(hKey);
        }

        if (pszCanonicalName &&
            (iTab >= 0) && (iTab < ARRAYSIZE(aTabMap)))
        {
            StringCchCopyW(pszCanonicalName, cchSize, aTabMap[iTab].pszCanoncialTabName);
        }
    }
    return iTabActual;
}


bool 
CPL::DeskCPL_IsTabPresent(
    eDESKCPLTAB iTab
    )
{
    return CPLTAB_ABSENT != DeskCPL_GetTabIndex(iTab, NULL, 0);
}




//////////////////////////////////////////////////////////////
//
//  Policy checking routines
//
//////////////////////////////////////////////////////////////

#define REGSTR_POLICIES_RESTRICTCPL REGSTR_PATH_POLICIES TEXT("\\Explorer\\RestrictCpl")
#define REGSTR_POLICIES_DISALLOWCPL REGSTR_PATH_POLICIES TEXT("\\Explorer\\DisallowCpl")


//
// Returns true if the specified app is listed under the specified key
//
// pszFileName can be a string resource ID in shell32 for things
// like "Fonts", "Printers and Faxes" etc.
//
//   i.e. IsNameListedUnderKey(MAKEINTRESOURCE(IDS_MY_APPLET_TITLE), hkey);
//
// In this case, if the resource string cannot be loaded, the function
// returns 'false'.
//
bool
IsNameListedUnderKey(
    LPCWSTR pszFileName, 
    LPCWSTR pszKey
    )
{
    bool bResult = FALSE;
    HKEY hkey;
    TCHAR szName[MAX_PATH];

    if (IS_INTRESOURCE(pszFileName))
    {
        //
        // The name is localized so we specify it as a string resource ID.
        // Load it from shell32.dll.
        //
        if (0 < LoadString(HINST_THISDLL, PtrToUint(pszFileName), szName, ARRAYSIZE(szName)))
        {
            pszFileName = szName;
        }
        else
        {
            //
            // If the load fails spit out a debug squirty and return false.
            //
            TW32(GetLastError());
            return false;
        }
    }
    
    if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER, 
                                       pszKey,
                                       0,
                                       KEY_QUERY_VALUE,
                                       &hkey))
    {
        int iValue = 0;
        WCHAR szValue[MAX_PATH];
        WCHAR szData[MAX_PATH];
        DWORD dwType, cbData, cchValue;

        while (cbData = sizeof(szData),
               cchValue = ARRAYSIZE(szValue),
               ERROR_SUCCESS == RegEnumValue(hkey, 
                                             iValue, 
                                             szValue, 
                                             &cchValue, 
                                             NULL, 
                                             &dwType,
                                             (LPBYTE) szData, 
                                             &cbData))
        {
            if (0 == lstrcmpiW(szData, pszFileName))
            {
                bResult = true;
                break;
            }
            iValue++;
        }
        RegCloseKey(hkey);
    }
    return bResult;
}


//
// Method cloned from shell32\ctrlfldr.cpp (DoesCplPolicyAllow)
//
// pszName can be a string resource ID in shell32 for things
// like "Fonts", "Printers and Faxes" etc.
//
//   i.e. IsAppletEnabled(NULL, MAKEINTRESOURCE(IDS_MY_APPLET_TITLE));
//
bool
CPL::IsAppletEnabled(
    LPCWSTR pszFileName,
    LPCWSTR pszName
    )
{
    bool bEnabled = true;
    //
    // It's illegal (and meaningless) for both to be NULL.
    // Trap both with an assert and runtime check.  I don't want any
    // code to erroneously think an applet is enabled when it's not.
    //
    ASSERT(NULL != pszName || NULL != pszFileName);
    if (NULL == pszName && NULL == pszFileName)
    {
        bEnabled = false;
    }
    else
    {
        if (SHRestricted(REST_RESTRICTCPL) && 
            ((NULL == pszName || !IsNameListedUnderKey(pszName, REGSTR_POLICIES_RESTRICTCPL)) &&
             (NULL == pszFileName || !IsNameListedUnderKey(pszFileName, REGSTR_POLICIES_RESTRICTCPL))))
        {
            bEnabled = false;
        }
        if (bEnabled)
        {
            if (SHRestricted(REST_DISALLOWCPL) && 
               ((NULL == pszName || IsNameListedUnderKey(pszName, REGSTR_POLICIES_DISALLOWCPL)) ||
                (NULL == pszFileName || IsNameListedUnderKey(pszFileName, REGSTR_POLICIES_DISALLOWCPL))))
            {
                bEnabled = false;
            }    
        }
    }
    return bEnabled;
}    



HRESULT 
CPL::ControlPanelViewFromSite(
    IUnknown *punkSite, 
    ICplView **ppview
    )
{
    ASSERT(NULL != punkSite);
    ASSERT(NULL != ppview);
    ASSERT(!IsBadWritePtr(ppview, sizeof(*ppview)));

    *ppview = NULL;

    HRESULT hr = IUnknown_QueryService(punkSite, SID_SControlPanelView, IID_ICplView, (void **)ppview);
    return THR(hr);
}



HRESULT
CPL::ShellBrowserFromSite(
    IUnknown *punkSite,
    IShellBrowser **ppsb
    )
{
    ASSERT(NULL != punkSite);
    ASSERT(NULL != ppsb);
    ASSERT(!IsBadWritePtr(ppsb, sizeof(*ppsb)));

    *ppsb = NULL;

    HRESULT hr = IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, ppsb));
    return THR(hr);
}



HRESULT
CPL::BrowseIDListInPlace(
    LPCITEMIDLIST pidl,
    IShellBrowser *psb
    )
{
    ASSERT(NULL != pidl);
    ASSERT(NULL != psb);
    
    const UINT uFlags = SBSP_SAMEBROWSER | SBSP_OPENMODE | SBSP_ABSOLUTE;
    HRESULT hr = psb->BrowseObject(pidl, uFlags);            
    return THR(hr);
}


//
// System Restore is allowed only for admins/owners.
// Also must check policy.
//
bool
CPL::IsSystemRestoreRestricted(
    void
    )
{
    bool bRestricted = false;

    //
    // First check policy.
    //
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue = sizeof(dwValue);

    DWORD dwResult = SHGetValueW(HKEY_LOCAL_MACHINE,
                                 L"Software\\Policies\\Microsoft\\Windows NT\\SystemRestore",
                                 L"DisableSR",
                                 &dwType,
                                 &dwValue,
                                 &cbValue);

    if (ERROR_SUCCESS == dwResult && REG_DWORD == dwType)
    {
        if (1 == dwValue)
        {
            //
            // Sytem Restore is disabled by policy.
            //
            bRestricted = true;
        }
    }

    if (!bRestricted)
    {
        //
        // Not restricted by policy.  Check for admin/owner.
        //
        if (!CPL::IsUserAdmin())
        {
            //
            // User is not an admin.
            //
            bRestricted = true;
        }
    }
    return bRestricted;
}


#ifdef DEBUG

HRESULT
ReadTestConfigurationFlag(
    LPCWSTR pszValue,
    BOOL *pbFlag
    )
{
    HRESULT hr    = S_OK;
    DWORD dwValue = 0;
    DWORD cbValue = sizeof(dwValue);
    DWORD dwType;

    DWORD dwResult = SHGetValueW(HKEY_CURRENT_USER, 
                                 REGSTR_PATH_CONTROLPANEL,
                                 pszValue,
                                 &dwType,
                                 &dwValue,
                                 &cbValue);

    if (ERROR_SUCCESS != dwResult)
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }
    else if (REG_DWORD != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }
    if (SUCCEEDED(hr) && NULL != pbFlag)
    {
        if (0 == dwValue)
        {
            *pbFlag = FALSE;
        }
        else 
        {
            *pbFlag = TRUE;
        }
    }
    return hr;
}

enum eSKU
{
    eSKU_SERVER,
    eSKU_PROFESSIONAL,
    eSKU_PERSONAL,
    eSKU_NUMSKUS
};


HRESULT
ReadTestConfigurationSku(
    eSKU *peSku
    )
{
    HRESULT hr = S_OK;
    WCHAR szValue[MAX_PATH];
    DWORD cbValue = sizeof(szValue);
    DWORD dwType;

    DWORD dwResult = SHGetValueW(HKEY_CURRENT_USER, 
                                 REGSTR_PATH_CONTROLPANEL,
                                 L"SKU",
                                 &dwType,
                                 szValue,
                                 &cbValue);

    if (ERROR_SUCCESS != dwResult)
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }
    else if (REG_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }
    if (SUCCEEDED(hr) && NULL != peSku)
    {
        static const struct
        {
            LPCWSTR pszValue;
            eSKU    sku;

        } rgMap[] = {
            { L"personal",     eSKU_PERSONAL     },
            { L"professional", eSKU_PROFESSIONAL },
            { L"pro",          eSKU_PROFESSIONAL },
            { L"server",       eSKU_SERVER       }
            };

        hr = E_FAIL;
        for (int i = 0; i < ARRAYSIZE(rgMap); i++)
        {
            if (0 == lstrcmpiW(rgMap[i].pszValue, szValue))
            {
                *peSku = rgMap[i].sku;
                hr = S_OK;
                break;
            }
        }
    }
    return hr;
}


#endif



BOOL
CPL::IsOsServer(
    void
    )
{
    BOOL bServer = IsOS(OS_ANYSERVER);

#ifdef DEBUG
    eSKU sku;
    if (SUCCEEDED(ReadTestConfigurationSku(&sku)))
    {
        bServer = (eSKU_SERVER == sku);
    }
#endif

    return bServer;
}



BOOL
CPL::IsOsPersonal(
    void
    )
{
    BOOL bPersonal = IsOS(OS_PERSONAL);

#ifdef DEBUG
    eSKU sku;
    if (SUCCEEDED(ReadTestConfigurationSku(&sku)))
    {
        bPersonal = (eSKU_PERSONAL == sku);
    }
#endif

    return bPersonal;
}


BOOL 
CPL::IsOsProfessional(
    void
    )
{
    BOOL bProfessional = IsOS(OS_PROFESSIONAL);

#ifdef DEBUG
    eSKU sku;
    if (SUCCEEDED(ReadTestConfigurationSku(&sku)))
    {
        bProfessional = (eSKU_PROFESSIONAL == sku);
    }
#endif

    return bProfessional;
}



BOOL 
CPL::IsConnectedToDomain(
    void
    )
{
    BOOL bDomain = IsOS(OS_DOMAINMEMBER);

#ifdef DEBUG
    ReadTestConfigurationFlag(L"Domain", &bDomain);
#endif

    return bDomain;
}



BOOL 
CPL::IsUserAdmin(
    void
    )
{
    BOOL bAdmin = ::IsUserAnAdmin();

#ifdef DEBUG
    ReadTestConfigurationFlag(L"Admin", &bAdmin);
#endif

    return bAdmin;
}


HRESULT
CPL::GetUserAccountType(
    eACCOUNTTYPE *pType
    )
{
    ASSERT(NULL != pType);
    ASSERT(!IsBadWritePtr(pType, sizeof(*pType)));

    HRESULT hr = E_FAIL;
    eACCOUNTTYPE acctype = eACCOUNTTYPE_UNKNOWN;

    static const struct
    {
        DWORD        rid;    // Account relative ID.
        eACCOUNTTYPE eType;  // Type code to return.

    } rgMap[] = {
        { DOMAIN_ALIAS_RID_ADMINS,      eACCOUNTTYPE_OWNER    },
        { DOMAIN_ALIAS_RID_POWER_USERS, eACCOUNTTYPE_STANDARD },
        { DOMAIN_ALIAS_RID_USERS,       eACCOUNTTYPE_LIMITED  },
        { DOMAIN_ALIAS_RID_GUESTS,      eACCOUNTTYPE_GUEST    }
        };

    for (int i = 0; i < ARRAYSIZE(rgMap); i++)
    {
        if (SHTestTokenMembership(NULL, rgMap[i].rid))
        {
            acctype = rgMap[i].eType;
            hr = S_OK;
            break;
        }
    }
    ASSERT(eACCOUNTTYPE_UNKNOWN != acctype);
    *pType = acctype;
    return THR(hr);
}

    
//
// Create a URL to pass to HSS help.
// The URL created references the Control_Panel help topic.
//
HRESULT
CPL::BuildHssHelpURL(
    LPCWSTR pszSelect,  // Optional.  NULL == base CP help.
    LPWSTR pszURL,
    UINT cchURL
    )
{
    ASSERT(NULL != pszURL);
    ASSERT(!IsBadWritePtr(pszURL, cchURL * sizeof(*pszURL)));
    ASSERT(NULL == pszSelect || !IsBadStringPtr(pszSelect, UINT(-1)));

    //
    // HSS has specific help content for 'limited' users.
    // Default to a non-limited user.
    //
    bool bLimitedUser = false;
    CPL::eACCOUNTTYPE accType;
    if (SUCCEEDED(CPL::GetUserAccountType(&accType)))
    {
        bLimitedUser = (eACCOUNTTYPE_LIMITED == accType);
    }
   
    HRESULT hr = S_OK;
    WCHAR szSelect[160];
    szSelect[0] = L'\0';
    if (NULL != pszSelect)
    {
        hr = StringCchPrintfW(szSelect, ARRAYSIZE(szSelect), L"&select=Unmapped/Control_Panel/%s", pszSelect);
    }
    if (SUCCEEDED(hr))
    {
        //
        // The URL can take one of 4 forms depending upon the category and account type.
        //
        // User Account     CP View          Help Content Displayed
        // ---------------- ---------------- -----------------------
        // Non-limited      Category choice  General CP help
        // Non-limited      Category         Category-specific help
        // Limited          Category choice  General CP help
        // Limited          Category         Category-specific help
        //
        hr = StringCchPrintfW(pszURL, 
                              cchURL, 
                              L"hcp://services/subsite?node=Unmapped/%sControl_Panel&topic=MS-ITS%%3A%%25HELP_LOCATION%%25%%5Chs.chm%%3A%%3A/hs_control_panel.htm%s", 
                              bLimitedUser ? L"L/" : L"",
                              szSelect);
    }

    return hr;
}



HRESULT 
CPL::GetControlPanelFolder(
    IShellFolder **ppsf
    )
{
    ASSERT(NULL != ppsf);
    ASSERT(!IsBadWritePtr(ppsf, sizeof(*ppsf)));

    *ppsf = NULL;
    
    LPITEMIDLIST pidlCpanel;
    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlCpanel);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            hr = psfDesktop->BindToObject(pidlCpanel, NULL, IID_IShellFolder, (void **)ppsf);
            ATOMICRELEASE(psfDesktop);
        }
        ILFree(pidlCpanel);
    }
    return THR(hr);
}


//
// On successful return, caller is responsible for freeing 
// returned buffer using LocalFree.
//
HRESULT 
CPL::ExpandEnvironmentVars(
    LPCTSTR psz, 
    LPTSTR *ppszOut
    )
{
    ASSERT(NULL != psz);
    ASSERT(NULL != ppszOut);
    ASSERT(!IsBadWritePtr(ppszOut, sizeof(*ppszOut)));

    HRESULT hr = E_FAIL;
    
    *ppszOut = NULL;

    TCHAR szDummy[1];
    DWORD dwResult = ExpandEnvironmentStrings(psz, szDummy, 0);
    if (0 < dwResult)
    {
        const DWORD cchRequired = dwResult;
        *ppszOut = (LPTSTR)LocalAlloc(LPTR, cchRequired * sizeof(TCHAR));
        if (NULL != *ppszOut)
        {
            dwResult = ExpandEnvironmentStrings(psz, *ppszOut, cchRequired);
            if (0 < dwResult)
            {
                ASSERT(dwResult <= cchRequired);
                hr = S_OK;
            }
            else
            {
                LocalFree(*ppszOut);
                *ppszOut = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (0 == dwResult)
    {
        hr = ResultFromLastError();
    }
    return THR(hr);
}


//// from sdfolder.cpp
VARIANT_BOOL GetBarricadeStatus(LPCTSTR pszValueName);


#define REGSTR_POLICIES_EXPLORER  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")

bool 
CPL::CategoryViewIsActive(
    bool *pbBarricadeFixedByPolicy
    )
{
    DBG_ENTER(FTF_CPANEL, "CPL::CategoryViewIsActive");
    
    bool bActive = false;
    bool bBarricadeFixedByPolicy = false;

    //
    // We don't provide category view when running WOW64.
    //
    if (!IsOS(OS_WOW6432))
    {
        SHELLSTATE ss;
        const DWORD dwMask = SSF_WEBVIEW | SSF_WIN95CLASSIC;
        SHGetSetSettings(&ss, dwMask, FALSE);

        //
        // WebView?     Barricade status   View type
        // -----------  ----------------   ------------------------------
        // Off          On                 Classic view
        // Off          Off                Classic view
        // On           On                 Category view (aka 'simple')
        // On           Off                Classic view
        //
        // Note that these two shellstate settings encompass and are set
        // by the shell restrictions REST_CLASSICSHELL and REST_NOWEBVIEW.
        // Therefore, there is no reason to explicitely check those two restrictions.
        //
        if (ss.fWebView && !ss.fWin95Classic)
        {
            if (VARIANT_TRUE == CPL::GetBarricadeStatus(&bBarricadeFixedByPolicy))
            {
                bActive = true;
            }
        }
    }
    if (NULL != pbBarricadeFixedByPolicy)
    {
        *pbBarricadeFixedByPolicy = bBarricadeFixedByPolicy;
    }
    TraceMsg(TF_CPANEL, "Category view is %s.", bActive ? TEXT("ACTIVE") : TEXT("INACTIVE"));
    DBG_EXIT(FTF_CPANEL, "CPL::CategoryViewIsActive");
    return bActive;
}
    

//
// Control Panel uses the 'barricade status' to determine which view
// 'classic' or 'category' to display.  Yes, this is overloading the
// meaning of 'barricade' as used in the shell.  However, since the
// Control Panel does not use a barricade in it's usual sense, this
// is a reasonable application of the feature.
//
VARIANT_BOOL
CPL::GetBarricadeStatus(
    bool *pbFixedByPolicy    // Optional.  May be NULL.
    )
{
    DBG_ENTER(FTF_CPANEL, "CPL::GetBarricadeStatus");

    VARIANT_BOOL vtb;
    DWORD dwType;
    DWORD dwData;
    DWORD cbData = sizeof(dwData);
    bool bFixedByPolicy = false;
    bool bSetBarricade  = false;
        
    //
    // First handle any OOBE issues.
    //
    if (CPL::IsFirstRunForThisUser())
    {
        TraceMsg(TF_CPANEL, "First time this user has opened Control Panel");
        //
        // Determine the default view to display out-of-box.
        //
        //      Server gets 'classic'.
        //      Non-servers get 'category'.
        //
        if (IsOS(OS_ANYSERVER))
        {
            //
            // Default is 'classic'.
            //
            vtb = VARIANT_FALSE;
            TraceMsg(TF_CPANEL, "Running on server.  Default to 'classic' view Control Panel.");
        }
        else
        {
            //
            // Default is 'category'.
            //
            vtb = VARIANT_TRUE;
            TraceMsg(TF_CPANEL, "Running on non-server.  Default to 'category' view Control Panel.");
        }
        bSetBarricade = true;
    }

    //
    // Apply any 'force view type' policy.  This will override
    // the default out-of-box setting obtained above.
    // 
    if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_POLICIES_EXPLORER,
                                         TEXT("ForceClassicControlPanel"),
                                         &dwType,
                                         &dwData,
                                         &cbData,
                                         FALSE,
                                         NULL,
                                         0)) 
    {
        //
        // policy exists
        //
        bFixedByPolicy = true;
        if (0 == dwData)
        {
            //
            // force the simple (category) view, ie, show barricade
            //
            vtb = VARIANT_TRUE;
            TraceMsg(TF_CPANEL, "Policy forcing use of 'category' view Control Panel.");
        }
        else
        {
            //
            // force the classic (icon) view, ie, no barricade
            //
            vtb = VARIANT_FALSE;
            TraceMsg(TF_CPANEL, "Policy forcing use of 'classic' view Control Panel.");
        }   
        bSetBarricade = true; 
    }

    if (bSetBarricade)
    {
        THR(CPL::SetControlPanelBarricadeStatus(vtb));
    }

    vtb = ::GetBarricadeStatus(TEXT("shell:ControlPanelFolder"));
    if (NULL != pbFixedByPolicy)
    {
        *pbFixedByPolicy = bFixedByPolicy;
    }

    TraceMsg(TF_CPANEL, "Barricade is %s", VARIANT_TRUE == vtb ? TEXT("ON") : TEXT("OFF"));
    DBG_EXIT(FTF_CPANEL, "CPL::GetBarricadeStatus");
    return vtb;
}


//
// Checks for the existance of the "HKCU\Control Panel\Opened" reg value.
// If this value does not exist or it contains a number less than what
// is expected, we assume the control panel has not been opened by this
// user.  The 'expected' value is then written at this location in the
// registry to indicate to subsequent calls that the user has indeed
// already opened Control Panel.  If future versions of the OS need
// to again trigger this "first run" behavior following upgrades,
// simply increment this expected value in the code below.
//
bool
CPL::IsFirstRunForThisUser(
    void
    )
{
    bool bFirstRun = true; // Assume first run.
    HKEY hkey;
    DWORD dwResult = RegOpenKeyEx(HKEY_CURRENT_USER,
                                  REGSTR_PATH_CONTROLPANEL,
                                  0,
                                  KEY_QUERY_VALUE | KEY_SET_VALUE,
                                  &hkey);

    if (ERROR_SUCCESS == dwResult)
    {
        DWORD dwType;
        DWORD dwData;
        DWORD cbData = sizeof(dwData);

        const TCHAR szValueName[] = TEXT("Opened");
        //
        // Increment this value if you want to re-trigger
        // this 'first run' state on future versions.
        //
        const DWORD dwTestValue = 1;

        dwResult = RegQueryValueEx(hkey, 
                                   szValueName,
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&dwData,
                                   &cbData);

        if (ERROR_SUCCESS == dwResult)
        {
            if (REG_DWORD == dwType && dwData >= dwTestValue)
            {
                bFirstRun = false;
            }
        }
        else if (ERROR_FILE_NOT_FOUND != dwResult)
        {
            TraceMsg(TF_ERROR, "Error %d reading Control Panel 'first run' value from registry", dwResult);
        }

        if (bFirstRun)
        {
            //
            // Write our value so we know user has opened
            // Control Panel.
            //
            dwResult = RegSetValueEx(hkey,
                                     szValueName,
                                     0,
                                     REG_DWORD,
                                     (CONST BYTE *)&dwTestValue,
                                     sizeof(dwTestValue));

            if (ERROR_SUCCESS != dwResult)
            {
                TraceMsg(TF_ERROR, "Error %d writing Control Panel 'first run' value to registry", dwResult);
            }
        }

        RegCloseKey(hkey);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error %d opening 'HKCU\\Control Panel' reg key", dwResult);
    }
    return bFirstRun;
}


//
// Use a private version of SetBarricadeStatus so that we don't
// clear the global barricade status whenever we turn on 'category' view
// (i.e. enable our barricade).
//
#define REGSTR_WEBVIEW_BARRICADEDFOLDERS (REGSTR_PATH_EXPLORER TEXT("\\WebView\\BarricadedFolders"))

HRESULT 
CPL::SetControlPanelBarricadeStatus(
    VARIANT_BOOL vtb
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwBarricade = (VARIANT_FALSE == vtb) ? 0 : 1;
  
    if (SHRegSetUSValue(REGSTR_WEBVIEW_BARRICADEDFOLDERS,
                        TEXT("shell:ControlPanelFolder"), 
                        REG_DWORD, 
                        (void *)&dwBarricade, 
                        sizeof(dwBarricade), 
                        SHREGSET_FORCE_HKCU) == ERROR_SUCCESS)
    {
        hr = S_OK;
    }
    return THR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpview.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_VIEW_H
#define __CONTROLPANEL_VIEW_H


#include "cpguids.h"
#include "cputil.h"

namespace DUI = DirectUI;

namespace CPL {

//
// Control Panel category enumeration.
//
// These values MUST remain unchanged.
// They correspond directly to the values stored for the SCID_CONTROLPANELCATEGORY
// value associated with each CPL in the registry.
//
enum eCPCAT
{
    eCPCAT_OTHER,
    eCPCAT_APPEARANCE,
    eCPCAT_HARDWARE,
    eCPCAT_NETWORK,
    eCPCAT_SOUND,
    eCPCAT_PERFMAINT,
    eCPCAT_REGIONAL,
    eCPCAT_ACCESSIBILITY,
    eCPCAT_ARP,
    eCPCAT_ACCOUNTS,
    eCPCAT_NUMCATEGORIES
};


//
// ICplWebViewInfo represents a single menu displayed in the 
// webview left pane.
//
class ICplWebViewInfo : public IUnknown
{
    public:
        //
        // Returns the menu's header.
        //
        STDMETHOD(get_Header)(IUIElement **ppele) PURE;
        //
        // Returns flags governing web view's presentation
        // of the information.
        //
        STDMETHOD(get_Style)(DWORD *pdwStyle) PURE;
        //
        // Returns enumerator representing the menu's items.
        //
        STDMETHOD(EnumTasks)(IEnumUICommand **ppenum) PURE;
};


//
// IEnumCplWebViewInfo represents an enumeration of webview information.
// Each element consists of a header and a list of task command objects.
//
class IEnumCplWebViewInfo : public IUnknown
{
    public:
        STDMETHOD(Next)(ULONG celt, ICplWebViewInfo **ppwvi, ULONG *pceltFetched) PURE;
        STDMETHOD(Skip)(ULONG celt) PURE;
        STDMETHOD(Reset)(void) PURE;
        STDMETHOD(Clone)(IEnumCplWebViewInfo **ppenum) PURE;
};


//
// ICplView represents the view 'factory' for the Control Panel.
// The Control Panel's folder view callback implementation instantiates
// a CplView object and through it's methods obtains the necessary
// display information to drive the Control Panel display.
//
// CPVIEW_EF_XXXX = Enumeration flags.
//
#define CPVIEW_EF_DEFAULT      0x00000000
#define CPVIEW_EF_NOVIEWSWITCH 0x00000001


class ICplView : public IUnknown
{
    public:
        //
        // Get the webview information associated with the 'classic'
        // Control Panel view.
        //
        STDMETHOD(EnumClassicWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Get the webview information associated with the 'choice' page.
        //
        STDMETHOD(EnumCategoryChoiceWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Get the webview information associated with a particular category.
        //
        STDMETHOD(EnumCategoryWebViewInfo)(DWORD dwFlags, eCPCAT eCategory, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Creates a DUI element containing the category choice page.
        //
        STDMETHOD(CreateCategoryChoiceElement)(DirectUI::Element **ppe) PURE;
        //
        // Creates a DUI element containing the tasks and CPL applets
        // for a particular category.
        //
        STDMETHOD(CreateCategoryElement)(eCPCAT eCategory, DirectUI::Element **ppe) PURE;
        //
        // Launch help for a given category.
        //
        STDMETHOD(GetCategoryHelpURL)(eCPCAT eCategory, LPWSTR pszURL, UINT cchURL) PURE;
        //
        // Refresh the view object with a new set of item IDs.
        //
        STDMETHOD(RefreshIDs)(IEnumIDList *penumIDs) PURE;
};


HRESULT CplView_CreateInstance(IEnumIDList *penumIDs, IUnknown *punkSite, REFIID riid, void **ppvOut);
HRESULT CplView_GetCategoryTitle(eCPCAT eCategory, LPWSTR pszTitle, UINT cchTitle);


} // namespace CPL

#endif //__CONTROLPANEL_VIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpview.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpview.cpp
//
//  This module provides the Control Panel user interface information 
//  to the shell through the ICplView interface.  The ICplView implementation
//  instantiates a CCplNamespace object through which it obtains the
//  display information on demand.  CCplView then takes that information 
//  and either makes it available to the shell for display in the webview 
//  left-hand pane or generates a DUI element hierarchy for display in the 
//  right-hand pane.
//
//  The majority of the code is associated with building Direct UI content.
// 
//--------------------------------------------------------------------------
#include "shellprv.h"
#include "cpviewp.h"
#include "cpduihlp.h"
#include "cpguids.h"
#include "cplnkele.h"
#include "cpnamespc.h"
#include "cputil.h"
#include "ids.h"
#include "shstyle.h"
#include <uxtheme.h>

namespace CPL {


class CCplView : public CObjectWithSite,
                 public ICplView,
                 public IServiceProvider
{
    public:
        ~CCplView(void);

        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // ICplView
        //
        STDMETHOD(EnumClassicWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(EnumCategoryChoiceWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(EnumCategoryWebViewInfo)(DWORD dwFlags, eCPCAT eCategory, IEnumCplWebViewInfo **ppenum);
        STDMETHOD(CreateCategoryChoiceElement)(DUI::Element **ppe);
        STDMETHOD(CreateCategoryElement)(eCPCAT eCategory, DUI::Element **ppe);
        STDMETHOD(GetCategoryHelpURL)(eCPCAT eCategory, LPWSTR pszURL, UINT cchURL);
        STDMETHOD(RefreshIDs)(IEnumIDList *penumIDs);
        //
        // IServiceProvider
        //
        STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void **ppv);

        static HRESULT CreateInstance(IEnumIDList *penumIDs, IUnknown *punkSite, REFIID riid, void **ppvOut);

    private:
        LONG              m_cRef;
        ICplNamespace    *m_pns;
        CSafeServiceSite *m_psss;
        ATOM              m_idDirective;
        ATOM              m_idDirective2;
        ATOM              m_idTitle;
        ATOM              m_idIcon;
        ATOM              m_idCategoryList;
        ATOM              m_idCategoryTaskList;
        ATOM              m_idAppletList;
        ATOM              m_idBanner;
        ATOM              m_idBarricadeTitle;
        ATOM              m_idBarricadeMsg;
        ATOM              m_idContainer;

        CCplView::CCplView(void);

        HRESULT _Initialize(IEnumIDList *penumIDs, IUnknown *punkSite);
        HRESULT _CreateCategoryChoiceElement(DUI::Element **ppe);
        HRESULT _CreateCategoryElement(ICplCategory *pCategory, DUI::Element **ppe);
        HRESULT _BuildCategoryBanner(ICplCategory *pCategory, DUI::Element *pePrimaryPane);
        HRESULT _BuildCategoryBarricade(DUI::Element *peRoot);
        HRESULT _BuildCategoryTaskList(DUI::Parser *pParser, ICplCategory *pCategory, DUI::Element *pePrimaryPane, int *pcTasks);
        HRESULT _BuildCategoryAppletList(DUI::Parser *pParser, ICplCategory *pCategory, DUI::Element *pePrimaryPane, int *pcApplets);
        HRESULT _CreateWatermark(DUI::Element *peRoot);
        HRESULT _CreateAndAddListItem(DUI::Parser *pParser, DUI::Element *peList, LPCWSTR pszItemTemplate, DUI::Value *pvSsListItem, IUICommand *puic, eCPIMGSIZE eIconSize);
        HRESULT _IncludeCategory(ICplCategory *pCategory) const;
        HRESULT _AddOrDeleteAtoms(bool bAdd);
        HRESULT _GetStyleModuleAndResId(HINSTANCE *phInstance, UINT *pidStyle);
        HRESULT _LoadUiFileFromResources(HINSTANCE hInstance, int idResource, char **ppUIFile);
        HRESULT _BuildUiFile(char **ppUIFile, int *piCharCount, HINSTANCE *phInstance);
        HRESULT _CreateUiFileParser(DUI::Parser **ppParser);
        eCPCAT _DisplayIndexToCategoryIndex(int iCategory) const;

        //
        // Prevent copy.
        //
        CCplView(const CCplView& rhs);
        CCplView& operator = (const CCplView& rhs);
};



CCplView::CCplView(
    void
    ) : m_cRef(1),
        m_pns(NULL),
        m_idDirective(0),
        m_idDirective2(0),
        m_idTitle(0),
        m_idIcon(0),
        m_idCategoryList(0),
        m_idCategoryTaskList(0),
        m_idAppletList(0),
        m_idBanner(0),
        m_idBarricadeTitle(0),
        m_idBarricadeMsg(0),
        m_idContainer(0),
        m_psss(NULL)
{
    TraceMsg(TF_LIFE, "CCplView::CCplView, this = 0x%x", this);
}


CCplView::~CCplView(
    void
    )
{
    TraceMsg(TF_LIFE, "CCplView::~CCplView, this = 0x%x", this);

    if (NULL != m_psss)
    {
        m_psss->SetProviderWeakRef(NULL);
        m_psss->Release();
    }

    if (NULL != m_pns)
    {
        IUnknown_SetSite(m_pns, NULL);
        m_pns->Release();
    }
    _AddOrDeleteAtoms(false);
}



HRESULT
CCplView::CreateInstance( // [static]
    IEnumIDList *penumIDs, 
    IUnknown *punkSite,
    REFIID riid,
    void **ppvOut
    )
{
    ASSERT(NULL != penumIDs);
    ASSERT(NULL != ppvOut);
    ASSERT(!IsBadWritePtr(ppvOut, sizeof(*ppvOut)));

    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CCplView* pv = new CCplView();
    if (NULL != pv)
    {
        hr = pv->_Initialize(penumIDs, punkSite);
        if (SUCCEEDED(hr))
        {
            hr = pv->QueryInterface(riid, ppvOut);
            if (SUCCEEDED(hr))
            {
                //
                // Set the site of the view to the site passed into the
                // instance generator.  This is most likely the site of
                // the Control Panel folder view callback.
                //
                hr = IUnknown_SetSite(static_cast<IUnknown *>(*ppvOut), punkSite);
            }
        }
        pv->Release();
    }
    return THR(hr);
}



STDMETHODIMP
CCplView::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    ASSERT(NULL != ppv);
    ASSERT(!IsBadWritePtr(ppv, sizeof(*ppv)));

    static const QITAB qit[] = {
        QITABENT(CCplView, ICplView),
        QITABENT(CCplView, IObjectWithSite),
        QITABENT(CCplView, IServiceProvider),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);

    return E_NOINTERFACE == hr ? hr : THR(hr);
}



STDMETHODIMP_(ULONG)
CCplView::AddRef(
    void
    )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    TraceMsg(TF_LIFE, "CCplView::AddRef %d->%d", cRef - 1, cRef);
    return cRef;
}



STDMETHODIMP_(ULONG)
CCplView::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    TraceMsg(TF_LIFE, "CCplView::Release %d<-%d", cRef, cRef+1);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}



STDMETHODIMP
CCplView::QueryService(
    REFGUID guidService, 
    REFIID riid, 
    void **ppv
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::QueryService");

    HRESULT hr = E_NOINTERFACE;
    if (SID_SControlPanelView == guidService)
    {
        TraceMsg(TF_CPANEL, "SID_SControlPanelView service requested");
        if (IID_ICplNamespace == riid)
        {
            TraceMsg(TF_CPANEL, "SID_SControlPanelView::IID_ICplNamespace requested");
            ASSERT(NULL != m_pns);
            hr = m_pns->QueryInterface(IID_ICplNamespace, ppv);
        }
        else if (IID_ICplView == riid)
        {
            TraceMsg(TF_CPANEL, "SID_SControlPanelView::IID_ICplView requested");
            ASSERT(NULL != m_pns);
            hr = this->QueryInterface(IID_ICplView, ppv);
        }
    }
    else
    {
        //
        // Most likely a command object requesting SID_STopLevelBrowser.
        //
        TraceMsg(TF_CPANEL, "Handing service request to view's site.");
        ASSERT(NULL != _punkSite);
        hr = IUnknown_QueryService(_punkSite, guidService, riid, ppv);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::QueryService", hr);
    return THR(hr);
}



STDMETHODIMP
CCplView::EnumClassicWebViewInfo(
    DWORD dwFlags,
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::EnumClassicWebViewInfo");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));
    ASSERT(NULL != m_pns);

    HRESULT hr = m_pns->EnumClassicWebViewInfo(dwFlags, ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::EnumClassicWebViewInfo", hr);
    return THR(hr);
}


//
// Returns an enumerator for webview info associated with
// the category 'choice' page.
//
STDMETHODIMP
CCplView::EnumCategoryChoiceWebViewInfo(
    DWORD dwFlags,
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::EnumCategoryChoiceWebViewInfo");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));
    ASSERT(NULL != m_pns);

    HRESULT hr = m_pns->EnumWebViewInfo(dwFlags, ppenum);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::EnumCategoryChoiceWebViewInfo", hr);
    return THR(hr);
}


//
// Returns an enumerator for webview info associated with
// a given category page.
//
STDMETHODIMP
CCplView::EnumCategoryWebViewInfo(
    DWORD dwFlags,
    eCPCAT eCategory, 
    IEnumCplWebViewInfo **ppenum
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::EnumCategoryWebViewInfo");

    ASSERT(NULL != ppenum);
    ASSERT(!IsBadWritePtr(ppenum, sizeof(*ppenum)));
    ASSERT(NULL != m_pns);

    ICplCategory *pCategory;
    HRESULT hr = m_pns->GetCategory(eCategory, &pCategory);
    if (SUCCEEDED(hr))
    {
        hr = pCategory->EnumWebViewInfo(dwFlags, ppenum);
        ATOMICRELEASE(pCategory);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::EnumCategoryWebViewInfo", hr);
    return THR(hr);
}


//
// Creates the DUI element tree for the category 'choice'
// page.  Returns the root of the tree.
//
STDMETHODIMP
CCplView::CreateCategoryChoiceElement(
    DUI::Element **ppe
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::CreateCategoryChoiceElement");

    ASSERT(NULL != ppe);
    ASSERT(!IsBadWritePtr(ppe, sizeof(*ppe)));

    HRESULT hr = _CreateCategoryChoiceElement(ppe);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::CreateCategoryChoiceElement", hr);
    return THR(hr);
}



//
// Creates the DUI element tree for a given category page.
// Returns the root of the tree.
//
STDMETHODIMP
CCplView::CreateCategoryElement(
    eCPCAT eCategory, 
    DUI::Element **ppe
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::CreateCategoryElement");
    TraceMsg(TF_CPANEL, "Category ID = %d", eCategory);

    ASSERT(NULL != ppe);
    ASSERT(!IsBadWritePtr(ppe, sizeof(*ppe)));
    ASSERT(NULL != m_pns);

    ICplCategory *pCategory;
    HRESULT hr = m_pns->GetCategory(eCategory, &pCategory);
    if (SUCCEEDED(hr))
    {
        hr = _CreateCategoryElement(pCategory, ppe);
        ATOMICRELEASE(pCategory);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::CreateCategoryElement", hr);
    return THR(hr);
}


STDMETHODIMP
CCplView::GetCategoryHelpURL(
    CPL::eCPCAT eCategory,
    LPWSTR pszURL,
    UINT cchURL
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::GetCategoryHelpURL");

    ASSERT(NULL != pszURL);
    ASSERT(!IsBadWritePtr(pszURL, cchURL * sizeof(*pszURL)));
    
    ICplCategory *pCategory;
    HRESULT hr = m_pns->GetCategory(eCategory, &pCategory);
    if (SUCCEEDED(hr))
    {
        hr = pCategory->GetHelpURL(pszURL, cchURL);
        ATOMICRELEASE(pCategory);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::GetCategoryHelpURL", hr);
    return THR(hr);
}


STDMETHODIMP
CCplView::RefreshIDs(
    IEnumIDList *penumIDs
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::RefreshIDs");

    ASSERT(NULL != m_pns);
    //
    // This will cause the namespace object to reset it's internal
    // list of item IDs.  This results in a re-categorization of 
    // applets such that all information returned by the namespace
    // will now reflect the new set of folder items.
    //
    HRESULT hr = m_pns->RefreshIDs(penumIDs);

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::RefreshIDs", hr);
    return THR(hr);
}


HRESULT
CCplView::_Initialize(
    IEnumIDList *penumIDs,
    IUnknown *punkSite
    )
{
    ASSERT(NULL == m_pns);
    ASSERT(NULL != penumIDs);

    HRESULT hr = E_OUTOFMEMORY;

    //
    // We use this weak-reference implementation of IServiceProvider
    // as described by ZekeL in shell\inc\cowsite.h.  A strong reference
    // would create a circular reference cycle between children of the
    // view and the view itself, preventing the view's destruction.
    // This weak-reference implementation is designed specifically
    // for this case.
    //
    ASSERT(NULL == m_psss);
    m_psss = new CSafeServiceSite();
    if (NULL != m_psss)
    {
        hr = m_psss->SetProviderWeakRef(this);
        if (SUCCEEDED(hr))
        {
            hr = CplNamespace_CreateInstance(penumIDs, CPL::IID_ICplNamespace, (void **)&m_pns);
            if (SUCCEEDED(hr))
            {
                IUnknown *punkSafeSite;
                hr = m_psss->QueryInterface(IID_IUnknown, (void **)&punkSafeSite);
                if (SUCCEEDED(hr))
                {
                    //
                    // Site the namespace object to the view.
                    // By doing this, all command objects created by the namespace will
                    // QueryService on the view object.  If the view doesn't support
                    // the requested service, it will query it's site.
                    // We use this so that command objects can query the view for
                    // IID_ICplNamespace and gather information on the namespace
                    // if necessary.  
                    //
                    hr = IUnknown_SetSite(m_pns, punkSafeSite);
                    if (SUCCEEDED(hr))
                    {
                        hr = _AddOrDeleteAtoms(true);
                    }
                    punkSafeSite->Release();
                }
            }
        }
    }
    return THR(hr);
}



HRESULT
CCplView::_AddOrDeleteAtoms(
    bool bAdd
    )
{
    struct CPL::ATOMINFO rgAtomInfo[] = {
        { L"directive",        &m_idDirective        },
        { L"directive2",       &m_idDirective2       },
        { L"title",            &m_idTitle            },
        { L"icon",             &m_idIcon             },
        { L"categorylist",     &m_idCategoryList     },
        { L"categorytasklist", &m_idCategoryTaskList },
        { L"appletlist",       &m_idAppletList       },
        { L"banner",           &m_idBanner           },
        { L"barricadetitle",   &m_idBarricadeTitle   },
        { L"barricademsg",     &m_idBarricadeMsg     },
        { L"container",        &m_idContainer        }
        };

    HRESULT hr = Dui_AddOrDeleteAtoms(rgAtomInfo, ARRAYSIZE(rgAtomInfo), bAdd);
    return THR(hr);
}


//
// Creates the DUI element tree for the category 'choice' page.
// Returns the root element.
//
HRESULT
CCplView::_CreateCategoryChoiceElement(
    DUI::Element **ppe
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_CreateCategoryChoiceElement");

    ASSERT(NULL != ppe);
    ASSERT(!IsBadWritePtr(ppe, sizeof(*ppe)));
    ASSERT(NULL != m_pns);

    DUI::Element *peRoot = NULL;
    DUI::Parser *pParser;
    HRESULT hr = _CreateUiFileParser(&pParser);
    if (SUCCEEDED(hr))
    {
        hr = Dui_CreateElement(pParser, L"CategoryList", NULL, &peRoot);
        if (SUCCEEDED(hr))
        {
            hr = _CreateWatermark(peRoot);
            if (SUCCEEDED(hr))
            {
                CDuiValuePtr pvSsCategoryListItem;
                hr = Dui_GetStyleSheet(pParser, L"CategoryListItemSS", &pvSsCategoryListItem);
                if (SUCCEEDED(hr))
                {
                    //
                    // Set the "Pick a category..." title.
                    //
                    hr = Dui_SetDescendentElementText(peRoot,
                                                      L"directive",
                                                      MAKEINTRESOURCEW(IDS_CP_PICKCATEGORY));
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Build the list of categories.
                        //
                        DUI::Element *peCategoryList;
                        hr = Dui_FindDescendent(peRoot, L"categorylist", &peCategoryList);
                        if (SUCCEEDED(hr))
                        {
                            for (int i = 0; SUCCEEDED(hr) && i < int(eCPCAT_NUMCATEGORIES); i++)
                            {
                                ICplCategory *pCategory;
                                hr = m_pns->GetCategory(_DisplayIndexToCategoryIndex(i), &pCategory);
                                if (SUCCEEDED(hr))
                                {
                                    if (S_OK == _IncludeCategory(pCategory))
                                    {
                                        IUICommand *puic;
                                        hr = pCategory->GetUiCommand(&puic);
                                        if (SUCCEEDED(hr))
                                        {
                                            hr = _CreateAndAddListItem(pParser,
                                                                       peCategoryList, 
                                                                       L"CategoryLink", 
                                                                       pvSsCategoryListItem, 
                                                                       puic,
                                                                       eCPIMGSIZE_CATEGORY);
                                            ATOMICRELEASE(puic);
                                        }
                                    }
                                    ATOMICRELEASE(pCategory);
                                }
                            }
                        }
                    }
                }
            }
        }
        pParser->Destroy();
    }
    *ppe = peRoot;

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_CreateCategoryChoiceElement", hr);
    return THR(hr);
}


//
// Creates the DUI element tree for a given category page.
// Returns the root element.
//
HRESULT
CCplView::_CreateCategoryElement(
    ICplCategory *pCategory,
    DUI::Element **ppe
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_CreateCategoryElement");

    ASSERT(NULL != pCategory);
    ASSERT(NULL != ppe);
    ASSERT(!IsBadWritePtr(ppe, sizeof(*ppe)));
    ASSERT(NULL != m_pns);

    DUI::Element *peRoot = NULL;
    DUI::Parser *pParser;
    HRESULT hr = _CreateUiFileParser(&pParser);
    if (SUCCEEDED(hr))
    {
        hr = Dui_CreateElement(pParser, L"CategoryView", NULL, &peRoot);
        if (SUCCEEDED(hr))
        {
            hr = _CreateWatermark(peRoot);
            if (SUCCEEDED(hr))
            {
                int cTasks   = 0;
                int cApplets = 0;
                hr = _BuildCategoryBanner(pCategory, peRoot);
                if (SUCCEEDED(hr))
                {
                    hr = _BuildCategoryTaskList(pParser, pCategory, peRoot, &cTasks);
                    if (SUCCEEDED(hr))
                    {
                        hr = _BuildCategoryAppletList(pParser, pCategory, peRoot, &cApplets);
                    }
                }
                if (SUCCEEDED(hr))
                {
                    if (0 == cTasks && 0 == cApplets)
                    {
                        //
                        // No tasks or applets.  Display a message explaining
                        // that the content has been made unavailable by the system
                        // administrator.
                        //
                        hr = _BuildCategoryBarricade(peRoot);
                    }
                    else
                    {
                        //
                        // Delete the barricade DUI elements.  They're unused.
                        //
                        THR(Dui_DestroyDescendentElement(peRoot, L"barricadetitle"));
                        THR(Dui_DestroyDescendentElement(peRoot, L"barricademsg"));
                        //
                        // Set the text in the 'directive' text elements.
                        //
                        if (0 < cTasks)
                        {
                            //
                            // We've displayed a list of tasks.
                            // Set the "Pick a task..." title.
                            //
                            hr = Dui_SetDescendentElementText(peRoot,
                                                              L"directive",
                                                              MAKEINTRESOURCEW(IDS_CP_PICKTASK));
                        }

                        if (SUCCEEDED(hr))
                        {
                            if (0 < cApplets)
                            {
                                //
                                // We've displayed a list of applets.  Display one of the
                                // following directives based on the existance of a task 
                                // list above.
                                //
                                // Task list?    Directive
                                // ------------- ---------------------------
                                // Yes           "or pick a Control Panel icon"
                                // No            "Pick a Control Panel icon"
                                //
                                UINT idsDirective2 = IDS_CP_PICKICON;
                                if (0 < cTasks)
                                {
                                    idsDirective2 = IDS_CP_ORPICKICON;
                                }
                                hr = Dui_SetDescendentElementText(peRoot,
                                                                  L"directive2",
                                                                  MAKEINTRESOURCEW(idsDirective2));
                            }
                        }
                    }
                }
            }
        }
        pParser->Destroy();
    }
    *ppe = peRoot;

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_CreateCategoryElement", hr);
    return THR(hr);
}


//
// Builds the 'barricade' that is displayed when a category has no
// tasks or CPL applets to show.
//
HRESULT
CCplView::_BuildCategoryBarricade(
    DUI::Element *peRoot
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_BuildCategoryBarricade");
    HRESULT hr = Dui_SetDescendentElementText(peRoot,
                                              L"barricadetitle",
                                              MAKEINTRESOURCE(IDS_CP_CATEGORY_BARRICADE_TITLE));
    if (SUCCEEDED(hr))
    {
        hr = Dui_SetDescendentElementText(peRoot, 
                                          L"barricademsg",
                                          MAKEINTRESOURCE(IDS_CP_CATEGORY_BARRICADE_MSG));
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_BuildCategoryBarricade", hr);
    return THR(hr);
}


//
// Add the background watermark to the view if user is using a non-classic
// theme.
//
HRESULT
CCplView::_CreateWatermark(
    DUI::Element *peRoot
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_CreateWatermark");

    ASSERT(NULL != peRoot);

    HINSTANCE hStyleModule;
    UINT idStyle;
    HRESULT hr = _GetStyleModuleAndResId(&hStyleModule, &idStyle);
    if (SUCCEEDED(hr))
    {
        HBITMAP hWatermark = (HBITMAP) LoadImage (hStyleModule, MAKEINTRESOURCE(IDB_CPANEL_WATERMARK),
                                                  IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        if (NULL != hWatermark)
        {
            //
            // Set watermark only on non-classic themes.
            //
            DUI::Element *peWatermark;
            hr = Dui_FindDescendent(peRoot, L"watermark", &peWatermark);
            if (SUCCEEDED(hr))
            {
                CDuiValuePtr ptrValue = DUI::Value::CreateGraphic(hWatermark,
                                                                  GRAPHIC_TransColor,
                                                                  255);

                if (!ptrValue.IsNULL())
                {
                    hr = Dui_SetElementProperty(peWatermark, ContentProp, ptrValue);
                         peWatermark->SetContentAlign(CA_BottomRight);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    DeleteObject (hWatermark);
                }
            }
            else
            {
                DeleteObject (hWatermark);
            }

            FreeLibrary(hStyleModule);
        }
        else
        {
            //
            // If 'classic' theme, do nothing.
            //
            hr = S_FALSE;
        }
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_CreateWatermark", hr);
    return THR(hr);
}



//
// Builds the banner for a category page.
//
HRESULT
CCplView::_BuildCategoryBanner(
    ICplCategory *pCategory,
    DUI::Element *pePrimaryPane
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_BuildCategoryBanner");

    ASSERT(NULL != pCategory);
    ASSERT(NULL != pePrimaryPane);

    IUICommand *puic;
    HRESULT hr = pCategory->GetUiCommand(&puic);
    if (SUCCEEDED(hr))
    {
        ICpUiElementInfo *pei;
        hr = puic->QueryInterface(IID_ICpUiElementInfo, (void **)&pei);
        if (SUCCEEDED(hr))
        {
            DUI::Element *peBanner;
            hr = Dui_FindDescendent(pePrimaryPane, L"banner", &peBanner);
            if (SUCCEEDED(hr))
            {
                //
                // Create the title text.
                //
                LPWSTR pszTitle;
                hr = pei->LoadName(&pszTitle);
                if (SUCCEEDED(hr))
                {
                    hr = Dui_SetDescendentElementText(peBanner, L"title", pszTitle);
                    CoTaskMemFree(pszTitle);
                }
                if (SUCCEEDED(hr))
                {
                    //
                    // Create the icon.
                    //
                    HICON hIcon;
                    hr = pei->LoadIcon(eCPIMGSIZE_BANNER, &hIcon);
                    if (SUCCEEDED(hr))
                    {
                        hr = Dui_SetDescendentElementIcon(peBanner, L"icon", hIcon);
                        if (FAILED(hr))
                        {
                            DestroyIcon(hIcon);
                        }
                    }
                }
            }
            ATOMICRELEASE(pei);
        }
        ATOMICRELEASE(puic);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_BuildCategoryBanner", hr);
    return THR(hr);
}



//
// Builds the list of tasks for a category page.
//
HRESULT
CCplView::_BuildCategoryTaskList(
    DUI::Parser *pParser,
    ICplCategory *pCategory,
    DUI::Element *pePrimaryPane,
    int *pcTasks
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_BuildCategoryTaskList");

    ASSERT(NULL != pCategory);
    ASSERT(NULL != pePrimaryPane);
    ASSERT(NULL != m_pns);
    ASSERT(NULL != pParser);

    int cTasks = 0;
    DUI::Element *peCategoryTaskList;
    HRESULT hr = Dui_FindDescendent(pePrimaryPane, L"categorytasklist", &peCategoryTaskList);
    if (SUCCEEDED(hr))
    {
        CDuiValuePtr pvStyleSheet;
        hr = Dui_GetStyleSheet(pParser, L"CategoryTaskListItemSS", &pvStyleSheet);
        if (SUCCEEDED(hr))
        {
            IEnumUICommand *peuic;
            hr = pCategory->EnumTasks(&peuic);
            if (SUCCEEDED(hr))
            {
                IUICommand *puic;
                while(S_OK == (hr = peuic->Next(1, &puic, NULL)))
                {
                    hr = _CreateAndAddListItem(pParser,
                                               peCategoryTaskList, 
                                               L"TaskLink", 
                                               pvStyleSheet, 
                                               puic,
                                               eCPIMGSIZE_TASK);
                    if (SUCCEEDED(hr))
                    {
                        cTasks++;
                    }
                    ATOMICRELEASE(puic);
                }
                ATOMICRELEASE(peuic);
            }
        }
    }
    if (NULL != pcTasks)
    {
        ASSERT(!IsBadWritePtr(pcTasks, sizeof(*pcTasks)));
        *pcTasks = cTasks;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_BuildCategoryTaskList", hr);
    return THR(hr);
}


//
// Builds the list of CPL applets for a category page.
//
HRESULT
CCplView::_BuildCategoryAppletList(
    DUI::Parser *pParser,
    ICplCategory *pCategory,
    DUI::Element *pePrimaryPane,
    int *pcApplets
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_BuildCategoryAppletList");

    ASSERT(NULL != pCategory);
    ASSERT(NULL != pePrimaryPane);
    ASSERT(NULL != pParser);

    int cApplets = 0;

    DUI::Element *peAppletList;
    HRESULT hr = Dui_FindDescendent(pePrimaryPane, L"appletlist", &peAppletList);
    if (SUCCEEDED(hr))
    {
        CDuiValuePtr pvStyleSheet;
        hr = Dui_GetStyleSheet(pParser, L"CategoryTaskListItemSS", &pvStyleSheet);
        if (SUCCEEDED(hr))
        {
            IEnumUICommand *peuicApplets;
            hr = pCategory->EnumCplApplets(&peuicApplets);
            if (SUCCEEDED(hr))
            {
                IUICommand *puicApplet;
                while(S_OK == (hr = peuicApplets->Next(1, &puicApplet, NULL)))
                {
                    hr = _CreateAndAddListItem(pParser,
                                               peAppletList, 
                                               L"AppletLink", 
                                               pvStyleSheet, 
                                               puicApplet,
                                               eCPIMGSIZE_APPLET);
                    if (SUCCEEDED(hr))
                    {
                        cApplets++;
                    }
                    ATOMICRELEASE(puicApplet);
                }
                ATOMICRELEASE(peuicApplets);
            }
        }
    }
    if (NULL != pcApplets)
    {
        ASSERT(!IsBadWritePtr(pcApplets, sizeof(*pcApplets)));
        *pcApplets = cApplets;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_BuildCategoryAppletList", hr);
    return THR(hr);
}


//
// Helper for adding link element to the view.
//
HRESULT
CCplView::_CreateAndAddListItem(
    DUI::Parser *pParser,
    DUI::Element *peList,     // List inserting into.
    LPCWSTR pszItemTemplate,  // Name of template in UI file.
    DUI::Value *pvSsListItem, // Style sheet for new list item
    IUICommand *puic,         // The new item's link object.
    eCPIMGSIZE eIconSize      // Desired size of item icon.
    )
{    
    DBG_ENTER(FTF_CPANEL, "CCplView::_CreateAndAddListItem");

    ASSERT(NULL != pParser);
    ASSERT(NULL != peList);
    ASSERT(NULL != pvSsListItem);
    ASSERT(NULL != puic);
    ASSERT(NULL != pszItemTemplate);

    DUI::Element *peListItem;
    HRESULT hr = Dui_CreateElement(pParser, pszItemTemplate, NULL, &peListItem);
    if (SUCCEEDED(hr))
    {
        if (NULL != pvSsListItem)
        {
            hr = Dui_SetElementStyleSheet(peListItem, pvSsListItem);
        }
        if (SUCCEEDED(hr))
        {
            ASSERTMSG(peListItem->GetClassInfo() == CLinkElement::Class, "CCplView::_CreateAndAddListItem didn't get a CLinkElement::Class object (%s)", peListItem->GetClassInfo()->GetName());
            CLinkElement *pLinkEle = static_cast<CLinkElement *>(peListItem);
            hr = pLinkEle->Initialize(puic, eIconSize);
            if (SUCCEEDED(hr))
            {
                if (SUCCEEDED(hr))
                {
                    hr = peList->Add(peListItem);
                    if (SUCCEEDED(hr))
                    {
                        peListItem = NULL;
                    }
                }
            }
            if (NULL != peListItem)
            {
                peListItem->Destroy();
            }
        }
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_CreateAndAddListItem", hr);
    return THR(hr);
}



//
// Determine if a given category item should be shown in the UI.
//
// Returns:
//      S_OK    - Include the item.
//      S_FALSE - Do not include the item.
//      Error   - Cannot determine.
//
HRESULT
CCplView::_IncludeCategory(
    ICplCategory *pCategory
    ) const
{
    HRESULT hr = S_OK;  // Assume it's included.
    
    //
    // If a category link invokes a restricted operation,
    // hide it from the UI.
    //
    IUICommand *puic;
    hr = pCategory->GetUiCommand(&puic);
    if (SUCCEEDED(hr))
    {
        UISTATE uis;
        hr = puic->get_State(NULL, TRUE, &uis);
        if (SUCCEEDED(hr))
        {
            if (UIS_HIDDEN == uis)
            {
                hr = S_FALSE;
            }
        }
        ATOMICRELEASE(puic);
    }
    return THR(hr);
}


//
// Map a category display index to a category index in the
// namespace.  Categories in the namespace are ordered to match up 
// with the various category IDs.  The view may be (and is) ordered
// differently and is subject to change based on usability feedback.
//
eCPCAT
CCplView::_DisplayIndexToCategoryIndex(
    int iCategory
    ) const
{
    //
    // This array determins the order the categories are displayed
    // in the category selection view.  To change the display order,
    // simply reorder these entries.
    //
    static const eCPCAT rgMap[] = { // Position in DUI grid control
        eCPCAT_APPEARANCE,          // Row 0, Col 0
        eCPCAT_HARDWARE,            // Row 0, Col 1
        eCPCAT_NETWORK,             // Row 1, Col 0
        eCPCAT_ACCOUNTS,            // Row 1, Col 1
        eCPCAT_ARP,                 // Row 2, Col 0
        eCPCAT_REGIONAL,            // Row 2, Col 1
        eCPCAT_SOUND,               // Row 3, Col 0
        eCPCAT_ACCESSIBILITY,       // Row 3, Col 1
        eCPCAT_PERFMAINT,           // Row 4, Col 0
        eCPCAT_OTHER                // Row 4, Col 1
        };

    ASSERT(ARRAYSIZE(rgMap) == eCPCAT_NUMCATEGORIES);
    ASSERT(iCategory >= 0 && iCategory < ARRAYSIZE(rgMap));
    return rgMap[iCategory];
}


HRESULT
CCplView::_CreateUiFileParser(
    DUI::Parser **ppParser
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_CreateUiFileParser");

    ASSERT(NULL != ppParser);
    ASSERT(!IsBadWritePtr(ppParser, sizeof(*ppParser)));

    char *pszUiFile;
    int cchUiFile;
    HINSTANCE hInstance; // Instance containing resources referenced in UI file.

    HRESULT hr = _BuildUiFile(&pszUiFile, &cchUiFile, &hInstance);
    if (SUCCEEDED(hr))
    {
        hr = Dui_CreateParser(pszUiFile, cchUiFile, hInstance, ppParser);   
        LocalFree(pszUiFile);
        if (HINST_THISDLL != hInstance)
        {
            ASSERT(NULL != hInstance);
            FreeLibrary(hInstance);
        }
    }

    DBG_EXIT(FTF_CPANEL, "CCplView::_CreateUiFileParser");
    return THR(hr);
}


//
//  Builds the UI file for this view from the
//  appropriate base template + style sheet
//
//  pUIFile receives a pointer to the ui file in memory
//  piCharCount receives the size of the file
//
HRESULT 
CCplView::_BuildUiFile(
    char **ppUIFile, 
    int *piCharCount,
    HINSTANCE *phInstance
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_BuildUiFile");

    ASSERT(NULL != ppUIFile);
    ASSERT(!IsBadWritePtr(ppUIFile, sizeof(*ppUIFile)));
    ASSERT(NULL != phInstance);
    ASSERT(!IsBadWritePtr(phInstance, sizeof(*phInstance)));

    *phInstance = NULL;

    //
    // Load the 'structure' UI file
    //
    char *pStructure;
    HRESULT hr = _LoadUiFileFromResources(HINST_THISDLL, IDR_DUI_CPVIEW, &pStructure);
    if (SUCCEEDED(hr))
    {
        HINSTANCE hStyleModule;
        UINT idStyle;
        hr = _GetStyleModuleAndResId(&hStyleModule, &idStyle);
        if (SUCCEEDED(hr))
        {
            //
            // Load the style sheet.  First, check if the current theme has a style sheet,
            // if not, use the default style sheet in the resources.
            //
            char *pStyle;
            hr = _LoadUiFileFromResources(hStyleModule, idStyle, &pStyle);
            if (SUCCEEDED(hr))
            {
                const int cbStyle      = lstrlenA(pStyle);
                const int cbStructure  = lstrlenA(pStructure);
                char *pResult = (char *)LocalAlloc(LPTR, cbStyle + cbStructure + 1);
                if (pResult)
                {
                    //
                    // Put the resouces together (style + structure)
                    //
                    CopyMemory(pResult, pStyle, cbStyle);
                    CopyMemory(pResult + cbStyle, pStructure, cbStructure);

                    ASSERT(cbStructure + cbStyle == lstrlenA(pResult));
                    *ppUIFile = pResult;
                    //
                    // This count is ANSI chars so we can use byte counts
                    // directly.
                    //
                    *piCharCount = cbStructure + cbStyle;
                    *phInstance  = hStyleModule;
                    //
                    // Indicate that HINSTANCE is being returned to caller.
                    //
                    hStyleModule = NULL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                LocalFree(pStyle);
            }
            if (NULL != hStyleModule && HINST_THISDLL != hStyleModule)
            {
                //
                // Something failed.  Need to free style module
                // if it's not shell32.dll.
                //
                FreeLibrary(hStyleModule);
            }
        }
        LocalFree(pStructure);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_BuildUiFile", hr);
    return THR(hr);
}



HRESULT
CCplView::_GetStyleModuleAndResId(
    HINSTANCE *phInstance,
    UINT *pidStyle
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_GetStyleModuleAndResId");

    ASSERT(NULL != phInstance);
    ASSERT(!IsBadWritePtr(phInstance, sizeof(*phInstance)));
    ASSERT(NULL != pidStyle);
    ASSERT(!IsBadWritePtr(pidStyle, sizeof(*pidStyle)));

    HRESULT hr = S_OK;
    *phInstance = NULL;
    
    HINSTANCE hThemeModule = SHGetShellStyleHInstance();
    if (NULL != hThemeModule)
    {
        *pidStyle = IDR_DUI_CPSTYLE;
        *phInstance = hThemeModule;
    }
    else
    {
        TraceMsg(TF_CPANEL, "Error %d loading theme file", GetLastError());
        hr = ResultFromLastError();
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_GetStyleModuleAndResId", hr);
    return THR(hr);
}



//
//  Loads the requested UI file from a module's resources.
//
//  iID         - UI file id
//  pUIFile     - receives a pointer to the UI file
//
HRESULT 
CCplView::_LoadUiFileFromResources(
    HINSTANCE hInstance, 
    int idResource, 
    char **ppUIFile
    )
{
    DBG_ENTER(FTF_CPANEL, "CCplView::_LoadUiFileFromResources");

    ASSERT(NULL != ppUIFile);
    ASSERT(!IsBadWritePtr(ppUIFile, sizeof(*ppUIFile)));

    HRESULT hr = E_FAIL;

    *ppUIFile = NULL;

    HRSRC hFile = FindResourceW(hInstance, MAKEINTRESOURCEW(idResource), L"UIFILE");
    if (hFile)
    {
        HGLOBAL hResource = LoadResource(hInstance, hFile);
        if (hResource)
        {
            char *pFile = (char *)LockResource(hResource);
            if (pFile)
            {
                DWORD dwSize = SizeofResource(hInstance, hFile);
                //
                // Include one extra byte for a terminating nul character.
                // We're loading text and want it to be nul-terminated.
                //
                *ppUIFile = (char *)LocalAlloc(LPTR, dwSize + 1);
                if (NULL != *ppUIFile)
                {
                    CopyMemory(*ppUIFile, pFile, dwSize);
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = ResultFromLastError();
            }
        }
        else
        {
            hr = ResultFromLastError();
        }
    }
    else
    {
        hr = ResultFromLastError();
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CCplView::_LoadUiFileFromResources", hr);
    return THR(hr);
}




HRESULT 
CPL::CplView_CreateInstance(
    IEnumIDList *penumIDs, 
    IUnknown *punkSite,
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = CCplView::CreateInstance(penumIDs, punkSite, riid, ppvOut);
    return THR(hr);
}


HRESULT 
CplView_GetCategoryTitle(
    eCPCAT eCategory, 
    LPWSTR pszTitle, 
    UINT cchTitle
    )
{
    ASSERT(NULL != pszTitle);
    ASSERT(!IsBadWritePtr(pszTitle, cchTitle * sizeof(*pszTitle)));

    //
    // These must remain in the same order as the eCPCAT_XXXXX enumeration.
    //
    static const UINT rgid[] = {
        IDS_CPCAT_OTHERCPLS_TITLE,
        IDS_CPCAT_APPEARANCE_TITLE,
        IDS_CPCAT_HARDWARE_TITLE,
        IDS_CPCAT_NETWORK_TITLE,
        IDS_CPCAT_SOUNDS_TITLE,
        IDS_CPCAT_PERFMAINT_TITLE,
        IDS_CPCAT_REGIONAL_TITLE,
        IDS_CPCAT_ACCESSIBILITY_TITLE,
        IDS_CPCAT_ARP_TITLE,
        IDS_CPCAT_ACCOUNTS_TITLE
        };

    HRESULT hr = S_OK;
    ASSERT(eCategory >= 0 && eCategory < eCPCAT_NUMCATEGORIES);
    if (0 == LoadString(HINST_THISDLL, rgid[int(eCategory)], pszTitle, cchTitle))
    {
        hr = ResultFromLastError();
    }
    return THR(hr);
}

} // namespace CPL

HRESULT InitializeCPClasses()
{
    HRESULT hr;

    hr = CPL::CLinkElement::Register();
    if (FAILED(hr))
        goto Failure;

    return S_OK;

Failure:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cputil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cputil.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_UTIL_H
#define __CONTROLPANEL_UTIL_H



namespace CPL {


enum eCPIMGSIZE
{
    eCPIMGSIZE_WEBVIEW,
    eCPIMGSIZE_TASK,
    eCPIMGSIZE_CATEGORY,
    eCPIMGSIZE_BANNER,
    eCPIMGSIZE_APPLET,
    eCPIMGSIZE_NUMSIZES
};

class ICplView; // fwd decl.

void ImageDimensionsFromDesiredSize(eCPIMGSIZE eSize, UINT *pcx, UINT *pcy);
bool ShouldUseSmallIconForDesiredSize(eCPIMGSIZE eSize);

HRESULT LoadIconFromResource(LPCWSTR pszResource, eCPIMGSIZE eSize, HICON *phIcon);
HRESULT LoadIconFromResourceID(LPCWSTR pszModule, int idIcon, eCPIMGSIZE eSize, HICON *phIcon);
HRESULT LoadIconFromResourceIndex(LPCWSTR pszModule, int iIcon, eCPIMGSIZE eSize, HICON *phIcon);
HRESULT ExtractIconFromPidl(IShellFolder *psf, LPCITEMIDLIST pidl, eCPIMGSIZE eSize, HICON *phIcon);
HRESULT LoadStringFromResource(LPCWSTR pszStrDesc, LPWSTR *ppszOut);
HRESULT ShellBrowserFromSite(IUnknown *punkSite, IShellBrowser **ppsb);
HRESULT ControlPanelViewFromSite(IUnknown *punkSite, ICplView **ppview);
HRESULT BrowseIDListInPlace(LPCITEMIDLIST pidl, IShellBrowser *psb);
HRESULT BuildHssHelpURL(LPCWSTR pszSelect, LPWSTR pszURL, UINT cchURL);
HRESULT GetControlPanelFolder(IShellFolder **ppsf);
HRESULT ExpandEnvironmentVars(LPCTSTR psz, LPTSTR *ppszOut);
HRESULT SetControlPanelBarricadeStatus(VARIANT_BOOL vtb);

bool IsAppletEnabled(LPCWSTR pszFilename, LPCWSTR pszName);
bool IsSystemRestoreRestricted(void);

BOOL IsConnectedToDomain(void);
BOOL IsOsServer(void);
BOOL IsOsPersonal(void);
BOOL IsOsProfessional(void);
BOOL IsUserAdmin(void);

VARIANT_BOOL GetBarricadeStatus(bool *pbFixedByPolicy = NULL);
bool IsFirstRunForThisUser(void);
bool CategoryViewIsActive(bool *pbBarricadeFixedByPolicy = NULL);


//
// The default tab indices of the various tabs
// if you add another tab, make sure its in the right position.
// Note that desk.cpl respects these indices. The new themes tab
// does not have an associated index, it is the default tab if
// no index is specified.
//
enum eDESKCPLTAB {  
    CPLTAB_ABSENT = -1,
    CPLTAB_DESK_BACKGROUND,
    CPLTAB_DESK_SCREENSAVER,
    CPLTAB_DESK_APPEARANCE,
    CPLTAB_DESK_SETTINGS,
    CPLTAB_DESK_MAX
    };

int DeskCPL_GetTabIndex(eDESKCPLTAB eTab, OPTIONAL LPWSTR pszCanonicalName, OPTIONAL DWORD cchSize);
bool DeskCPL_IsTabPresent(eDESKCPLTAB eTab);


enum eACCOUNTTYPE
{
    eACCOUNTTYPE_UNKNOWN = -1,
    eACCOUNTTYPE_OWNER,
    eACCOUNTTYPE_STANDARD,
    eACCOUNTTYPE_LIMITED,
    eACCOUNTTYPE_GUEST,
    eACCOUNTTYPE_NUMTYPES
};

HRESULT GetUserAccountType(eACCOUNTTYPE *pType);

//
// Each one of these "CpaDestroyer_XXXX" classes implements a single 
// "Destroy" function to free one item held in a DPA.  Currently there
// are only two flavors, one that calls "delete" and one that calls
// "LocalFree".  By default the CDpa class uses the CDpaDestoyer_Delete
// class as that is the most commont form of freeing required.  To use
// another type, just specify another similar class as the 'D' template
// argument to CDpa.
//
template <typename T>
class CDpaDestroyer_Delete
{
    public:
        static void Destroy(T* p)
            { delete p; }
};

template <typename T>
class CDpaDestroyer_Free
{
    public:
        static void Destroy(T* p)
            { if (p) LocalFree(p); }
};

template <typename T>
class CDpaDestroyer_ILFree
{
    public:
        static void Destroy(T* p)
            { if (p) ILFree(p); }
};

template <typename T>
class CDpaDestroyer_Release
{
    public:
        static void Destroy(T* p)
            { if (p) p->Release(); }
};

class CDpaDestroyer_None
{
    public:
        static void Destroy(void*)
            { }
};



//-----------------------------------------------------------------------------
// CDpa  - Template class.
//
// Simplifies working with a DPA.
//-----------------------------------------------------------------------------

template <typename T, typename D = CDpaDestroyer_Delete<T> >
class CDpa
{
public:
    explicit CDpa(int cGrow = 4)
        : m_hdpa(DPA_Create(cGrow)) { }

    ~CDpa(void) { _Destroy(); }

    bool IsValid(void) const { return NULL != m_hdpa; }

    int Count(void) const
    { 
        return IsValid() ? DPA_GetPtrCount(m_hdpa) : 0;
    }

    const T* Get(int i) const
    {
        ASSERT(IsValid());
        ASSERT(i >= 0 && i < Count());
        return (const T*)DPA_GetPtr(m_hdpa, i);
    }

    T* Get(int i)
    {
        ASSERT(IsValid());
        ASSERT(i >= 0 && i < Count());
        return (T*)DPA_GetPtr(m_hdpa, i);
    }

    const T* operator [](int i) const
    {
        return Get(i);
    }

    T* operator [](int i)
    {
        return Get(i);
    }

    void Set(int i, T* p)
    {
        ASSERT(IsValid());
        ASSERT(i < Count());
        DPA_SetPtr(m_hdpa, i, p);
    }

    int Append(T* p)
    { 
        ASSERT(IsValid());
        return DPA_AppendPtr(m_hdpa, p);
    }

    T* Remove(int i)
    {
        ASSERT(IsValid());
        ASSERT(i >= 0 && i < Count());
        return (T*)DPA_DeletePtr(m_hdpa, i);
    }

    void Clear(void)
    { 

        _DestroyItems(); 
    }

private:
    HDPA m_hdpa;

    void _DestroyItems(void)
    {
        if (NULL != m_hdpa)
        {
            while(0 < Count())
            {
                D::Destroy(Remove(0));
            }
        }
    }

    void _Destroy(void)
    {
        if (NULL != m_hdpa)
        {
            _DestroyItems();
            DPA_Destroy(m_hdpa);
            m_hdpa = NULL;
        }
    }

    //
    // Prevent copy.
    //
    CDpa(const CDpa& rhs);
    CDpa& operator = (const CDpa& rhs);
};
                

} // namespace CPL

#endif // __CONTROLPANEL_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cpviewp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cpviewp.h
//
//--------------------------------------------------------------------------
#ifndef __CONTROLPANEL_VIEW_PRIVATE_H
#define __CONTROLPANEL_VIEW_PRIVATE_H

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#include <duser.h>
#include <directui.h>
#include <dusercore.h>

namespace DUI = DirectUI;


#include "cpview.h"


namespace CPL {


enum eCPVIEWTYPE
{
    eCPVIEWTYPE_CLASSIC,
    eCPVIEWTYPE_CATEGORY,
    eCPVIEWTYPE_NUMTYPES
};


//
// ICplCategory represents a single category withing the cateorized
// Control Panel namespace.
//
extern const GUID IID_ICplCategory;

class ICplCategory : public IUnknown
{
    public:
        //
        // Returns the category's ID number from the eCPCAT enumeration.
        //
        STDMETHOD(GetCategoryID)(eCPCAT *pID) PURE;
        //
        // Returns the command object associated with the category's
        // link.  Used by the category selection page.
        //
        STDMETHOD(GetUiCommand)(IUICommand **ppele) PURE;
        //
        // Returns an enumerator for the task commands associated with
        // the category.
        //
        STDMETHOD(EnumTasks)(IEnumUICommand **ppenum) PURE;
        //
        // Returns an enumerator for the CPL applet links associated
        // with the category.
        //
        STDMETHOD(EnumCplApplets)(IEnumUICommand **ppenum) PURE;
        //
        // Returns an enumerator for the webview information associated
        // with the category.
        //
        STDMETHOD(EnumWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Invoke help for the category.
        //
        STDMETHOD(GetHelpURL)(LPWSTR pszURL, UINT cchURL) PURE;
};


//
// ICplNamespace represents the entire Control Panel namespace for the
// new "Categorized" view introduced in Whistler.
//
extern const GUID IID_ICplNamespace;

class ICplNamespace : public IUnknown
{
    public:
        //
        // Returns a specified category.
        //
        STDMETHOD(GetCategory)(eCPCAT eCategory, ICplCategory **ppcat) PURE;
        //
        // Returns an enumerator for the information displayed
        // in webview on the category selection page.
        //
        STDMETHOD(EnumWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Returns an enumerator for the information displayed
        // in webview on the classic page.
        //
        STDMETHOD(EnumClassicWebViewInfo)(DWORD dwFlags, IEnumCplWebViewInfo **ppenum) PURE;
        //
        // Refresh namespace with new set of item IDs.
        //
        STDMETHOD(RefreshIDs)(IEnumIDList *penumIDs) PURE;
        //
        // Cached system configuration information.  Used by 
        // restriction code in cpnamespc.cpp
        //
        STDMETHOD_(BOOL, IsServer)(void) PURE;
        STDMETHOD_(BOOL, IsProfessional)(void) PURE;
        STDMETHOD_(BOOL, IsPersonal)(void) PURE;
        STDMETHOD_(BOOL, IsUserAdmin)(void) PURE;
        STDMETHOD_(BOOL, IsUserOwner)(void) PURE;
        STDMETHOD_(BOOL, IsUserStandard)(void) PURE;
        STDMETHOD_(BOOL, IsUserLimited)(void) PURE;
        STDMETHOD_(BOOL, IsUserGuest)(void) PURE;
        STDMETHOD_(BOOL, IsOnDomain)(void) PURE;
        STDMETHOD_(BOOL, IsX86)(void) PURE;
        STDMETHOD_(BOOL, AllowUserManager)(void) PURE;
        STDMETHOD_(BOOL, UsePersonalUserManager)(void) PURE;
        STDMETHOD_(BOOL, AllowDeskCpl)(void) PURE;
        STDMETHOD_(BOOL, AllowDeskCplTab_Background)(void) PURE;
        STDMETHOD_(BOOL, AllowDeskCplTab_Screensaver)(void) PURE;
        STDMETHOD_(BOOL, AllowDeskCplTab_Appearance)(void) PURE;
        STDMETHOD_(BOOL, AllowDeskCplTab_Settings)(void) PURE;
        
};


} // namespace CPL

#endif //__CONTROLPANEL_VIEW_PRIVATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ctllogic.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "ctllogic.h"

BOOL _GetListViewSelectedLVITEM(HWND hwndList, LVITEM* plvitem)
{
    BOOL fFound = FALSE;
    int iCount = ListView_GetItemCount(hwndList);

    plvitem->mask |= LVIF_STATE;
    plvitem->stateMask = LVIS_SELECTED;

    for (int j = 0; j < iCount; ++j)
    {
        plvitem->iItem = j;

        ListView_GetItem(hwndList, plvitem);

        if (plvitem->state & LVIS_SELECTED)
        {
            fFound = TRUE;
            break;
        }
    }

    return fFound;
}

HRESULT _GetListViewSelectedLPARAM(HWND hwndList, LPARAM* plparam)
{
    HRESULT hr;
    LVITEM lvitem = {0};

    lvitem.mask = LVIF_PARAM;

    if (_GetListViewSelectedLVITEM(hwndList, &lvitem))
    {
        hr = S_OK;
        *plparam = lvitem.lParam;
    }
    else
    {
        hr = S_FALSE;
        *plparam = NULL;
    }

    return hr;
}

// ComboBox

HRESULT _GetComboBoxSelectedLRESULT(HWND hwndComboBox, LRESULT* plr)
{
    HRESULT hr;

    int iCurSel = ComboBox_GetCurSel(hwndComboBox);

    LRESULT lr = ComboBox_GetItemData(hwndComboBox, iCurSel);

    if (CB_ERR != lr)
    {
        hr = S_OK;
        *plr = lr;
    }
    else
    {
        hr = S_FALSE;
        *plr = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ctllogic.h ===
#ifndef CTLLOGIC_H
#define CTLLOGIC_H

#include "dlglogic.h"

#define MAX_ITEMTEXTLEN   50
#define MAX_TILETEXT      50

HRESULT _GetListViewSelectedLPARAM(HWND hwndList, LPARAM* plparam);
HRESULT _GetComboBoxSelectedLRESULT(HWND hwndComboBox, LRESULT* plr);

// ListView

template<typename TData>
class CDLUIDataLVItem : public CDLUIData<TData>
{
public:
    virtual ~CDLUIDataLVItem() {}

    virtual HRESULT GetText(LPWSTR pszText, DWORD cchText) PURE;
    virtual HRESULT GetIconLocation(LPWSTR pszIconLocation,
        DWORD cchIconLocation) PURE;
    virtual HRESULT GetTileText(int i, LPWSTR pszTileText,
        DWORD cchTileText)
    {
        return E_NOTIMPL;
    }
};

template<typename TData>
class CUILListView
{
public:
    ~CUILListView();
    CUILListView();

    HRESULT Init(HWND hwndListView);
    HRESULT InitTileInfo(const UINT auTileSubItems[], DWORD cTileSubItems);

    HRESULT AddItem(CDLUIDataLVItem<TData>* plvitem);

    // Note: Caller needs to Release *ppdata at some point
    HRESULT GetSelectedItemData(TData** ppdata);

    // Assume Single select listview.  Also assume that no other item is selected
    HRESULT SelectFirstItem();

    HRESULT ResetContent();

protected:
    HWND        _hwndList;

private:    
    const UINT* _auTileSubItems;
    int         _cTileSubItems;
};

template<typename TData, typename TCompareData>
class CUILListViewSelect : public CUILListView<TData>
{
public:
    HRESULT SelectItem(TCompareData comparedata)
    {
        HRESULT hr = E_FAIL;
        LVITEM lvitem = {0};
        int iCount = 0;
        lvitem.mask = LVIF_PARAM;

        iCount = ListView_GetItemCount(_hwndList);

        for (lvitem.iItem = 0; lvitem.iItem < iCount; ++lvitem.iItem)
        {
            if (ListView_GetItem(_hwndList, &lvitem))
            {
                CDLUIDataLVItem<TData>* plvitem = (CDLUIDataLVItem<TData>*)lvitem.lParam;

                TData* pdata = plvitem->GetData();

                if (pdata)
                {
                    int iResult;
                    hr = pdata->Compare(comparedata, &iResult);

                    pdata->Release();

                    if (SUCCEEDED(hr) && !iResult)
                    {
                        break;
                    }
                }
            }
        }

        if (lvitem.iItem == iCount)
        {
            //No Match found, Select first item anyway
            lvitem.iItem = 0;
            hr = S_FALSE;
        }

        lvitem.mask = LVIF_STATE;
        lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
        lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;

        ListView_SetItem(_hwndList, &lvitem);
        ListView_EnsureVisible(_hwndList, lvitem.iItem, FALSE);

        return hr;
    }
};

// ComboBox
template<typename TData>
class CDLUIDataCBItem : public CDLUIData<TData>
{
public:
    virtual ~CDLUIDataCBItem() {}

    virtual HRESULT GetText(LPWSTR pszText, DWORD cchText) PURE;
    virtual HRESULT GetIconLocation(LPWSTR pszIconLocation,
        DWORD cchIconLocation) PURE;
};

template<typename TData>
class CUILComboBox
{
public:
    ~CUILComboBox();

    HRESULT Init(HWND hwndComboBox);

    HRESULT AddItem(CDLUIDataCBItem<TData>* pcbitem);

    // Note: Caller needs to Release *ppdata at some point
    HRESULT GetSelectedItemData(TData** ppdata);

    HRESULT SelectFirstItem();

    HRESULT ResetContent();

private:
    HWND _hwndCombo;
};

template<typename TData>
class CUILComboBoxEx
{
public:
    ~CUILComboBoxEx();

    HRESULT Init(HWND hwndComboBox);

    HRESULT AddItem(CDLUIDataCBItem<TData>* pcbitem);

    // Note: Caller needs to Release *ppdata at some point
    HRESULT GetSelectedItemData(TData** ppdata);

    HRESULT SelectFirstItem();

    HRESULT ResetContent();

private:
    HWND _hwndCombo;
};

// Implementations

template<typename TData>
CUILListView<TData>::CUILListView() : _cTileSubItems(0)
{}

template<typename TData>
CUILListView<TData>::~CUILListView()
{
    ResetContent();
}

template<typename TData>
inline HRESULT CUILListView<TData>::Init(HWND hwndListView)
{
    _hwndList = hwndListView;

    return S_OK;
}

template<typename TData>
inline HRESULT CUILListView<TData>::InitTileInfo(const UINT auTileSubItems[],
    DWORD cTileSubItems)
{
    _auTileSubItems = auTileSubItems;
    _cTileSubItems = cTileSubItems;

    return S_OK;
}

template<typename TData>
inline HRESULT CUILListView<TData>::AddItem(CDLUIDataLVItem<TData>* plvitem)
{
    WCHAR szText[MAX_ITEMTEXTLEN];
    int iImage;
    LVITEM lvitem = {0};

    HRESULT hr = plvitem->GetText(szText, ARRAYSIZE(szText));

    if (SUCCEEDED(hr))
    {
        WCHAR szIconLocation[MAX_PATH + 12];

        hr = plvitem->GetIconLocation(szIconLocation,
            ARRAYSIZE(szIconLocation));

        if (SUCCEEDED(hr))
        {
            int iIcon = PathParseIconLocation(szIconLocation);

            iImage = Shell_GetCachedImageIndex(szIconLocation, iIcon, 0);
        }
    }

    if (SUCCEEDED(hr))
    {
        int iItem;

        lvitem.mask = LVIF_IMAGE | LVIF_TEXT | LVIF_PARAM;
        lvitem.pszText = szText;
        lvitem.iItem = ListView_GetItemCount(_hwndList);
        lvitem.iImage = iImage;
        lvitem.lParam = (LPARAM)plvitem;

        iItem = ListView_InsertItem(_hwndList, &lvitem);

        if (-1 != iItem)
        {
            if (_cTileSubItems)
            {
                LVTILEINFO lvti = {0};
                lvti.cbSize = sizeof(LVTILEINFO);
                lvti.iItem = iItem;
                lvti.cColumns = ARRAYSIZE(_auTileSubItems);
                lvti.puColumns = (UINT*)_auTileSubItems;
                ListView_SetTileInfo(_hwndList, &lvti);

                for (int i = 0; i < _cTileSubItems; ++i)
                {
                    WCHAR szTileText[MAX_TILETEXT];

                    hr = plvitem->GetTileText(i, szTileText,
                        ARRAYSIZE(szTileText));

                    // 1 based
                    ListView_SetItemText(_hwndList, iItem, i + 1, szTileText);
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

template<typename TData>
inline HRESULT CUILListView<TData>::GetSelectedItemData(TData** ppdata)
{
    HRESULT hr;
    BOOL fFound = FALSE;
    int iCount = ListView_GetItemCount(_hwndList);
    LVITEM lvitem = {0};

    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    for (int j = 0; !fFound && (j < iCount); ++j)
    {
        lvitem.iItem = j;

        ListView_GetItem(_hwndList, &lvitem);

        if (lvitem.state & (LVIS_SELECTED | LVIS_FOCUSED))
        {
            fFound = TRUE;
        }
    }

    if (fFound)
    {
        CDLUIDataLVItem<TData>* plvitem = (CDLUIDataLVItem<TData>*)lvitem.lParam;

        *ppdata = plvitem->GetData();

        hr = ((*ppdata) ? S_OK : S_FALSE);
    }
    else
    {
        *ppdata = NULL;

        hr = E_FAIL;
    }

    return hr;
}

template<typename TData>
inline HRESULT CUILListView<TData>::SelectFirstItem()
{
    LVITEM lvitem = {0};

    lvitem.iItem = 0;
    lvitem.mask = LVIF_STATE;
    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;

    ListView_SetItem(_hwndList, &lvitem);
    ListView_EnsureVisible(_hwndList, lvitem.iItem, FALSE);

    return S_OK;
}

template<typename TData>
HRESULT CUILListView<TData>::ResetContent()
{
    int iCount = 0;
    LVITEM lvitem = {0};

    // go through all the items in the listview and delete the strings
    // dynamically allocated
    lvitem.mask = LVIF_PARAM;
    lvitem.iSubItem = 0;

    iCount = ListView_GetItemCount(_hwndList);

    for (lvitem.iItem = 0; lvitem.iItem < iCount; ++lvitem.iItem)
    {
        ListView_GetItem(_hwndList, &lvitem);

        CDLUIDataLVItem<TData>* plvitem = (CDLUIDataLVItem<TData>*)
            lvitem.lParam;

        if (plvitem)
        {
            delete plvitem;
        }
    }

    ListView_DeleteAllItems(_hwndList);

    return S_OK;
}

// CUILComboBox
template<typename TData>
CUILComboBox<TData>::~CUILComboBox()
{
    ResetContent();
}

template<typename TData>
HRESULT CUILComboBox<TData>::Init(HWND hwndComboBox)
{
    _hwndCombo = hwndComboBox;

    return S_OK;
}

template<typename TData>
HRESULT CUILComboBox<TData>::AddItem(CDLUIDataCBItem<TData>* pcbitem)
{
    WCHAR szText[MAX_ITEMTEXTLEN];

    HRESULT hr = pcbitem->GetText(szText, ARRAYSIZE(szText));

    if (SUCCEEDED(hr))
    {
        int i = ComboBox_AddString(_hwndCombo, szText);

        if (CB_ERR != i)
        {
            ComboBox_SetItemData(_hwndCombo, i, pcbitem);
        }
    }

    return hr;
}

template<typename TData>
HRESULT CUILComboBox<TData>::GetSelectedItemData(TData** ppdata)
{
    HRESULT hr;

    int iCurSel = ComboBox_GetCurSel(_hwndCombo);

    LRESULT lr = ComboBox_GetItemData(_hwndCombo, iCurSel);

    if (CB_ERR != lr)
    {
        CDLUIDataCBItem<TData>* pcbitem = (CDLUIDataCBItem<TData>*)lr;

        *ppdata = pcbitem->GetData();

        hr = ((*ppdata) ? S_OK : S_FALSE);
    }
    else
    {
        *ppdata = NULL;
        hr = E_FAIL;
    }

    return hr;
}

template<typename TData>
HRESULT CUILComboBox<TData>::ResetContent()
{
    int c = ComboBox_GetCount(_hwndCombo);

    for (int i = 0; i < c; ++i)
    {
        CDLUIDataCBItem<TData>* pcbitem = (CDLUIDataCBItem<TData>*)
            ComboBox_GetItemData(_hwndCombo, i);
       
        if (pcbitem)
        {
            delete pcbitem;
        }
    }

    ComboBox_ResetContent(_hwndCombo);

    return S_OK;
}

template<typename TData>
HRESULT CUILComboBox<TData>::SelectFirstItem()
{
    ComboBox_SetCurSel(_hwndCombo, 0);

    return S_OK;
}

// CUILComboBoxEx
template<typename TData>
CUILComboBoxEx<TData>::~CUILComboBoxEx()
{
    ResetContent();
}

template<typename TData>
HRESULT CUILComboBoxEx<TData>::Init(HWND hwndComboBox)
{
    _hwndCombo = hwndComboBox;

    return S_OK;
}

template<typename TData>
HRESULT CUILComboBoxEx<TData>::AddItem(CDLUIDataCBItem<TData>* pcbitem)
{
    WCHAR szText[MAX_ITEMTEXTLEN];
    int iImage;
    HRESULT hr = pcbitem->GetText(szText, ARRAYSIZE(szText));

    if (SUCCEEDED(hr))
    {
        WCHAR szIconLocation[MAX_PATH + 12];

        hr = pcbitem->GetIconLocation(szIconLocation,
            ARRAYSIZE(szIconLocation));

        if (SUCCEEDED(hr))
        {
            int iIcon = PathParseIconLocation(szIconLocation);

            iImage = Shell_GetCachedImageIndex(szIconLocation, iIcon, 0);
        }
    }

    if (SUCCEEDED(hr))
    {
        int iItem;
        COMBOBOXEXITEM cbitem = {0};

        cbitem.mask = CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_TEXT | CBEIF_LPARAM;
        cbitem.pszText = szText;
        cbitem.iItem = ComboBox_GetCount(_hwndCombo);
        cbitem.iImage = iImage;
        cbitem.iSelectedImage = iImage;
        cbitem.lParam = (LPARAM)pcbitem;

        iItem = SendMessage(_hwndCombo, CBEM_INSERTITEM, 0, (LPARAM)&cbitem);

        if (-1 != iItem)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

template<typename TData>
HRESULT CUILComboBoxEx<TData>::GetSelectedItemData(TData** ppdata)
{
    HRESULT hr;
    COMBOBOXEXITEM cbitem = {0};

    cbitem.mask = CBEIF_LPARAM;
    cbitem.iItem = ComboBox_GetCurSel(_hwndCombo);

    if (SendMessage(_hwndCombo, CBEM_GETITEM, 0, (LPARAM)&cbitem))
    {
        CDLUIDataCBItem<TData>* pcbitem = (CDLUIDataCBItem<TData>*)cbitem.lParam;

        *ppdata = pcbitem->GetData();

        hr = ((*ppdata) ? S_OK : S_FALSE);
    }
    else
    {
        *ppdata = NULL;
        hr = E_FAIL;
    }

    return hr;
}

template<typename TData>
HRESULT CUILComboBoxEx<TData>::ResetContent()
{
    int c = ComboBox_GetCount(_hwndCombo);

    for (int i = 0; i < c; ++i)
    {
        CDLUIDataCBItem<TData>* pcbitem = (CDLUIDataCBItem<TData>*)
            ComboBox_GetItemData(_hwndCombo, i);
       
        if (pcbitem)
        {
            delete pcbitem;
        }
    }

    ComboBox_ResetContent(_hwndCombo);

    return S_OK;
}

template<typename TData>
HRESULT CUILComboBoxEx<TData>::SelectFirstItem()
{
    ComboBox_SetCurSel(_hwndCombo, 0);

    return S_OK;
}

#endif // CTLLOGIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ctrlfldr.cpp ===
#include "shellprv.h"
#include "caggunk.h"
#include "views.h"
#include "ids.h"
#include "shitemid.h"
#include "datautil.h"
#include "clsobj.h"
#include "control.h"
#include "drives.h"
#include "infotip.h"
#include "prop.h"           // COLUMN_INFO
#include "basefvcb.h"
#include "fstreex.h"
#include "idhidden.h"
#include "shstyle.h"
#include "util.h" // GetVariantFromRegistryValue

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#define GADGET_ENABLE_OLE
#include <duser.h>
#include <directui.h>
#include <duserctrl.h>

#include "cpview.h"
#include "cputil.h"
//
// An array of pidls
//
typedef CPL::CDpa<UNALIGNED ITEMIDLIST, CPL::CDpaDestroyer_ILFree<UNALIGNED ITEMIDLIST> >  CDpaItemIDList;


#define MAX_CPL_EXEC_NAME (1 + MAX_PATH + 2 + MAX_CCH_CPLNAME) //See wnsprintf in GetExecName        

STDAPI_(BOOL) IsNameListedUnderKey(LPCTSTR pszFileName, LPCTSTR pszKey);

#pragma pack(1)
// our pidc type:
typedef struct _IDCONTROL
{
    USHORT  cb;
    USHORT  wDummy;             //  DONT REUSE - was stack garbage pre-XP
    int     idIcon;
    USHORT  oName;              // cBuf[oName] is start of NAME
    USHORT  oInfo;              // cBuf[oInfo] is start of DESCRIPTION
    CHAR    cBuf[MAX_PATH+MAX_CCH_CPLNAME+MAX_CCH_CPLINFO]; // cBuf[0] is the start of FILENAME
} IDCONTROL;
typedef UNALIGNED struct _IDCONTROL *LPIDCONTROL;

typedef struct _IDCONTROLW
{
    USHORT  cb;
    USHORT  wDummy;             //  DONT REUSE - was stack garbage pre-XP
    int     idIcon;
    USHORT  oName;              // if Unicode .cpl, this will be 0
    USHORT  oInfo;              // if Unicode .cpl, this will be 0
    CHAR    cBuf[2];            // if Unicode .cpl, cBuf[0] = '\0', cBuf[1] = magic byte
    USHORT  wDummy2;            //  DONT REUSE - was stack garbage pre-XP
    DWORD   dwFlags;            // Unused; for future expansion
    USHORT  oNameW;             // cBufW[oNameW] is start of NAME
    USHORT  oInfoW;             // cBufW[oInfoW] is start of DESCRIPTION
    WCHAR   cBufW[MAX_PATH+MAX_CCH_CPLNAME+MAX_CCH_CPLINFO]; // cBufW[0] is the start of FILENAME
} IDCONTROLW;
typedef UNALIGNED struct _IDCONTROLW *LPIDCONTROLW;
#pragma pack()

STDAPI ControlExtractIcon_CreateInstance(LPCTSTR pszSubObject, REFIID riid, void **ppv);

class CControlPanelViewCallback;

class CControlPanelFolder : public CAggregatedUnknown, public IShellFolder2, IPersistFolder2
{
    friend CControlPanelViewCallback;

public:
    // IUknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return CAggregatedUnknown::QueryInterface(riid, ppv); };
    STDMETHODIMP_(ULONG) AddRef(void)  { return CAggregatedUnknown::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void)  { return CAggregatedUnknown::Release(); };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, LPENUMIDLIST* ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppv);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, void** ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST* apidl,
                               REFIID riid, UINT* prgfInOut, void** ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD* pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid);

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);
    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl);

protected:
    CControlPanelFolder(IUnknown* punkOuter);
    ~CControlPanelFolder();

    // used by the CAggregatedUnknown stuff
    HRESULT v_InternalQueryInterface(REFIID riid, void** ppv);

    static HRESULT GetExecName(LPIDCONTROL pidc, LPTSTR pszParseName, UINT cchParseName);
    static HRESULT GetModuleMapped(LPIDCONTROL pidc, LPTSTR pszModule, UINT cchModule,
                                   UINT* pidNewIcon, LPTSTR pszApplet, UINT cchApplet);
    static HRESULT GetDisplayName(LPIDCONTROL pidc, LPTSTR pszName, UINT cchName);
    static HRESULT GetModule(LPIDCONTROL pidc, LPTSTR pszModule, UINT cchModule);
    static HRESULT _GetDescription(LPIDCONTROL pidc, LPTSTR pszDesc, UINT cchDesc);
    static HRESULT _GetFullCPLName(LPIDCONTROL pidc, LPTSTR achKeyValName, UINT cchSize);
    HRESULT _GetExtPropRegValName(HKEY hkey, LPTSTR pszExpandedName, LPTSTR pszRegValName, UINT cch);
    static HRESULT _GetExtPropsKey(HKEY hkeyParent, HKEY * pHkey, const SHCOLUMNID * pscid);
    static LPIDCONTROL _IsValid(LPCITEMIDLIST pidl);
    static LPIDCONTROLW _IsUnicodeCPL(LPIDCONTROL pidc);
    LPCITEMIDLIST GetIDList() { return _pidl; }
    
private:
    friend HRESULT CControlPanel_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);

    static HRESULT CALLBACK DFMCallBack(IShellFolder *psf, HWND hwndView,
                                             IDataObject *pdtobj, UINT uMsg,
                                             WPARAM wParam, LPARAM lParam);

    HRESULT _GetDisplayNameForSelf(DWORD dwFlags, STRRET* pstrret);

    LPITEMIDLIST    _pidl;
    IUnknown*       _punkReg;
    HDSA            _hdsaExtPropRegVals; // Array of EPRV_CACHE_ENTRY.

    //
    // An entry in the Extended Property Reg Values cache.
    // This cache is used to minimize the amount of path 'normalization'
    // done when comparing CPL applet paths with the corresponding paths
    // stored for categorization.  
    //
    struct EPRV_CACHE_ENTRY
    {
        LPTSTR pszRegValName;
        LPTSTR pszRegValNameNormalized;
    };

    DWORD _InitExtPropRegValNameCache(HKEY hkey);
    BOOL _LookupExtPropRegValName(HKEY hkey, LPTSTR pszSearchKeyNormalized, LPTSTR pszRegValName, UINT cch);
    DWORD _CacheExtPropRegValName(LPCTSTR pszRegValNameNormalized, LPCTSTR pszRegValName);
    static int CALLBACK _DestroyExtPropsRegValEntry(void *p, void *pData);
    static INT _FilterStackOverflow(INT nException);
    DWORD _NormalizeCplSpec(LPTSTR pszSpecIn, LPTSTR pszSpecOut, UINT cchSpecOut);
    DWORD _NormalizePath(LPCTSTR pszPathIn, LPTSTR pszPathOut, UINT cchPathOut);
    DWORD  _NormalizePathWorker(LPCTSTR pszPathIn, LPTSTR pszPathOut, UINT cchPathOut);
    void _TrimSpaces(LPTSTR psz);

};  

class CControlPanelEnum : public IEnumIDList
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; };
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum) { return E_NOTIMPL; };

    CControlPanelEnum(UINT uFlags);

    HRESULT Init();

private:
    ~CControlPanelEnum();
    BOOL _DoesPolicyAllow(LPCTSTR pszName, LPCTSTR pszFileName);

    LONG _cRef;
    ULONG _uFlags;

    int _iModuleCur;
    int _cControlsOfCurrentModule;
    int _iControlCur;
    int _cControlsTotal;
    int _iRegControls;

    MINST _minstCur;

    ControlData _cplData;
};


//
// This handler isn't defined in shlobjp.h.  
// The only reason I can see is that it references DUI::Element.
//
#define HANDLE_SFVM_GETWEBVIEWBARRICADE(pv, wP, lP, fn) \
    ((fn)((pv), (DUI::Element**)(lP)))

class CControlPanelViewCallback : public CBaseShellFolderViewCB
{
public:
    CControlPanelViewCallback(CControlPanelFolder *pcpf) 
        : _pcpf(pcpf), 
          CBaseShellFolderViewCB(pcpf->GetIDList(), SHCNE_UPDATEITEM),
          _pCplView(NULL),
          _penumWvInfo(NULL)
    { 
        TraceMsg(TF_LIFE, "CControlPanelViewCallback::CControlPanelViewCallback, this = 0x%x", this);
        _pcpf->AddRef();
    }

    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    ~CControlPanelViewCallback()
    {
        TraceMsg(TF_LIFE, "CControlPanelViewCallback::~CControlPanelViewCallback, this = 0x%x", this);
        _pcpf->Release();
        ATOMICRELEASE(_penumWvInfo);
        ATOMICRELEASE(_pCplView);
    }

    HRESULT OnMergeMenu(DWORD pv, QCMINFO*lP)
    {
        return S_OK;
    }

    HRESULT OnSize(DWORD pv, UINT cx, UINT cy)
    {
        ResizeStatus(_punkSite, cx);
        return S_OK;
    }

    HRESULT OnGetPane(DWORD pv, LPARAM dwPaneID, DWORD *pdwPane)
    {
        if (PANE_ZONE == dwPaneID)
            *pdwPane = 2;
        return S_OK;
    }

    HRESULT _OnSFVMGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA * phtd);
    HRESULT _OnSFVMForceWebView(DWORD pv, PBOOL bForceWebView);
    HRESULT _OnSFVMGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT _OnSFVMGetWebViewBarricade(DWORD pv, DUI::Element **ppe);
    HRESULT _OnSFVMGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA *pData);
    HRESULT _OnSFVMEnumWebViewTasks(DWORD pv, SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pData);
    HRESULT _OnSFVMWindowDestroy(DWORD pv, HWND hwnd);
    HRESULT _OnSFVMUpdateStatusBar(DWORD pv, BOOL bInitialize);

    HRESULT _GetCplView(CPL::ICplView **ppView, bool bInitialize = false);
    HRESULT _GetCplCategoryFromFolderIDList(CPL::eCPCAT *peCategory);
    HRESULT _GetWebViewInfoEnumerator(CPL::IEnumCplWebViewInfo **ppewvi);
    HRESULT _EnumFolderViewIDs(IEnumIDList **ppenumIDs);
    
    CControlPanelFolder      *_pcpf;
    CPL::ICplView            *_pCplView;    // The 'categorized' view content
    CPL::IEnumCplWebViewInfo *_penumWvInfo; 
};


STDMETHODIMP CControlPanelViewCallback::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_MERGEMENU, OnMergeMenu);
    HANDLE_MSG(0, SFVM_ADDPROPERTYPAGES, SFVCB_OnAddPropertyPages);
    HANDLE_MSG(0, SFVM_SIZE, OnSize);
    HANDLE_MSG(0, SFVM_GETPANE, OnGetPane);
    HANDLE_MSG(0, SFVM_GETHELPTOPIC, _OnSFVMGetHelpTopic);
    HANDLE_MSG(0, SFVM_FORCEWEBVIEW, _OnSFVMForceWebView);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, _OnSFVMGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWBARRICADE, _OnSFVMGetWebViewBarricade);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, _OnSFVMGetWebViewContent);
    HANDLE_MSG(0, SFVM_ENUMWEBVIEWTASKS, _OnSFVMEnumWebViewTasks);
    HANDLE_MSG(0, SFVM_WINDOWDESTROY, _OnSFVMWindowDestroy);
    HANDLE_MSG(0, SFVM_UPDATESTATUSBAR, _OnSFVMUpdateStatusBar);
    
    default:
        return E_FAIL;
    }

    return S_OK;
}



HRESULT
CControlPanelViewCallback::_OnSFVMGetHelpTopic(
    DWORD pv,
    SFVM_HELPTOPIC_DATA *phtd
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetHelpTopic");

    ASSERT(NULL != phtd);
    ASSERT(!IsBadWritePtr(phtd, sizeof(*phtd)));

    UNREFERENCED_PARAMETER(pv);

    HRESULT hr = E_FAIL;
    
    phtd->wszHelpFile[0]  = L'\0';
    phtd->wszHelpTopic[0] = L'\0';

    if (IsOS(OS_ANYSERVER))
    {
        //
        // Server has a fixed help URL so we can simply
        // copy it.
        //
        hr = StringCchCopyW(phtd->wszHelpTopic,
                            ARRAYSIZE(phtd->wszHelpTopic),
                            L"hcp://services/centers/homepage");
    }
    else
    {
        if (CPL::CategoryViewIsActive(NULL))
        {
            //
            // Category view is active.
            // Retrieve help URL from the view object.
            //
            CPL::ICplView *pView;
            hr = _GetCplView(&pView);
            if (SUCCEEDED(hr))
            {
                CPL::eCPCAT eCategory;
                hr = _GetCplCategoryFromFolderIDList(&eCategory);
                if (S_OK == hr)
                {
                    //
                    // We're viewing a Control Panel category page.
                    // Ask the view for the help URL for this category.
                    //
                    hr = pView->GetCategoryHelpURL(eCategory, 
                                                   phtd->wszHelpTopic,
                                                   ARRAYSIZE(phtd->wszHelpTopic));
                }
                ATOMICRELEASE(pView);
            }
        }

        if (L'\0' == phtd->wszHelpTopic[0])
        {
            //
            // Either we're in 'classic' view, the 'category choice' page
            // or something failed above.  Return the URL for the basic
            // Control Panel help.
            //
            hr = CPL::BuildHssHelpURL(NULL, phtd->wszHelpTopic, ARRAYSIZE(phtd->wszHelpTopic));
        }
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetHelpTopic", hr);
    return THR(hr);
}


//
// Defview sends SFVM_ENUMWEBVIEWTASKS repeatedly until
// we set the SFVMWVF_NOMORETASKS flag in the data.  With each call we
// return data describing a single menu (caption and items) in the 
// webview pane.
//
HRESULT 
CControlPanelViewCallback::_OnSFVMEnumWebViewTasks(
    DWORD pv, 
    SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pData
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMEnumWebViewTasks");

    ASSERT(NULL != pData);
    ASSERT(!IsBadWritePtr(pData, sizeof(*pData)));

    UNREFERENCED_PARAMETER(pv);

    HRESULT hr = S_OK;
    if (NULL == _penumWvInfo)
    {
        hr = _GetWebViewInfoEnumerator(&_penumWvInfo);
    }
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != _penumWvInfo);

        CPL::ICplWebViewInfo *pwvi;
        hr = _penumWvInfo->Next(1, &pwvi, NULL);
        if (S_OK == hr)
        {
            ASSERT(NULL == pData->pHeader);
            hr = pwvi->get_Header(&(pData->pHeader));
            if (SUCCEEDED(hr))
            {
                ASSERT(NULL == pData->penumTasks);
                hr = pwvi->EnumTasks(&(pData->penumTasks));
                if (SUCCEEDED(hr))
                {
                    DWORD dwStyle = 0;
                    hr = pwvi->get_Style(&dwStyle);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // ISSUE-2001/01/02-BrianAu  Revisit this.
                        //   I don't like using an SFVMWVF_XXXXXX flag in the 
                        //   dwStyle returned by get_Style.  That style should
                        //   be defined independently of any SFVMWVF_XXXXX
                        //   flags then translated appropriately here.
                        //
                        pData->idBitmap    = 0; // Default is no bitmap.
                        pData->idWatermark = 0; // No watermark used.
                        if (SFVMWVF_SPECIALTASK & dwStyle)
                        {
                            pData->dwFlags |= SFVMWVF_SPECIALTASK;
                            pData->idBitmap = IDB_CPANEL_ICON_BMP;
                        }
                    }
                }
            }

            ATOMICRELEASE(pwvi);
        }
        else if (S_FALSE == hr)
        {
            //
            // Tell defview the enumeration is complete.
            // Release the info enumerator.
            //
            pData->dwFlags = SFVMWVF_NOMORETASKS;
            ATOMICRELEASE(_penumWvInfo);
        }
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMEnumWebViewTasks", hr);
    return THR(hr);
}


//
// Retrieves the proper enumerator of webview information.
//
HRESULT
CControlPanelViewCallback::_GetWebViewInfoEnumerator(
    CPL::IEnumCplWebViewInfo **ppewvi
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_GetWebViewInfoEnumerator");

    ASSERT(NULL != ppewvi);
    ASSERT(!IsBadWritePtr(ppewvi, sizeof(*ppewvi)));

    CPL::ICplView *pView;
    HRESULT hr = _GetCplView(&pView);
    if (SUCCEEDED(hr))
    {
        DWORD dwFlags = 0;
        bool bBarricadeFixedByPolicy;
        bool bCategoryViewActive = CPL::CategoryViewIsActive(&bBarricadeFixedByPolicy);

        if (bBarricadeFixedByPolicy)
        {
            //
            // If the view type is fixed by policy, we don't present
            // controls that allow the user to switch view types.
            //
            dwFlags |= CPVIEW_EF_NOVIEWSWITCH;
        }
        if (bCategoryViewActive)
        {
            CPL::eCPCAT eCategory;
            hr = _GetCplCategoryFromFolderIDList(&eCategory);
            if (SUCCEEDED(hr))
            {
                if (S_OK == hr)
                {
                    //
                    // Displaying a category page.
                    //
                    hr = pView->EnumCategoryWebViewInfo(dwFlags, eCategory, ppewvi);
                }
                else
                {
                    //
                    // Displaying category choice page.
                    //
                    hr = pView->EnumCategoryChoiceWebViewInfo(dwFlags, ppewvi);
                }
            }
        }
        else
        {
            //
            // Displaying classic view.
            //
            hr = pView->EnumClassicWebViewInfo(dwFlags, ppewvi);
        }
        ATOMICRELEASE(pView);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_GetWebViewInfoEnumerator", hr);
    return THR(hr);
}



//
// Get a pointer to the CCplView object.  If the object is not yet created,
// create one.
//
HRESULT
CControlPanelViewCallback::_GetCplView(
    CPL::ICplView **ppView,
    bool bInitialize
    )
{
    HRESULT hr = S_OK;

    *ppView = NULL;

    IEnumIDList *penumIDs = NULL;
    if (NULL == _pCplView || bInitialize)
    {
        //
        // If creating a new view object or reinitializing an 
        // existing view object, we'll need the most recent list of
        // folder item IDs.
        //
        hr = _EnumFolderViewIDs(&penumIDs);
    }
    if (SUCCEEDED(hr))
    {
        if (NULL == _pCplView)
        {
            //
            // Create a new view object.
            // Give the view CB's site pointer to the CplView object.
            // This is then used to initialize the various command objects
            // contained in the CCplNamespace object.  Some of these command objects
            // need access to the shell browser.  The most generic method of
            // providing this access was to use the site mechanism.
            //
            IUnknown *punkSite;
            hr = GetSite(IID_IUnknown, (void **)&punkSite);
            if (SUCCEEDED(hr))
            {
                hr = CPL::CplView_CreateInstance(penumIDs, punkSite, CPL::IID_ICplView, (void **)&_pCplView);
                ATOMICRELEASE(punkSite);
            }
        }
        else if (bInitialize)
        {
            //
            // Reinitialize the existing view object.
            //
            hr = _pCplView->RefreshIDs(penumIDs);
        }
    }
    if (SUCCEEDED(hr))
    {
        //
        // Create a reference for the caller.
        //
        (*ppView = _pCplView)->AddRef();
    }
    
    ATOMICRELEASE(penumIDs);
    return THR(hr);
}


//
// Get a Category ID number based on the folder's current ID list.
// The Control Panel ID list uses a hidden part to store the
// 'category' ID.  The ID is simply one of the eCPCAT enumeration.
// It is added to the ID list in CPL::COpenCplCategory::Execute().
// This function returns:
//
//     S_OK     - *peCategory contains a valid category ID.
//     S_FALSE  - folder ID list did not contain a category ID.
//     E_FAIL   - folder ID list contains an invalid category ID.
//
HRESULT
CControlPanelViewCallback::_GetCplCategoryFromFolderIDList(
    CPL::eCPCAT *peCategory
    )
{
    ASSERT(NULL != peCategory);
    ASSERT(!IsBadWritePtr(peCategory, sizeof(*peCategory)));

    HRESULT hr = S_FALSE;

    CPL::eCPCAT eCategory = CPL::eCPCAT(-1);
    WCHAR szHidden[10];
    szHidden[0] = L'\0';

    ILGetHiddenStringW(_pcpf->GetIDList(), IDLHID_NAVIGATEMARKER, szHidden, ARRAYSIZE(szHidden));
    if (L'\0' != szHidden[0])
    {
        eCategory = CPL::eCPCAT(StrToInt(szHidden));
        if (CPL::eCPCAT_NUMCATEGORIES > eCategory)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    *peCategory = eCategory;
    return THR(hr);
}


HRESULT
CControlPanelViewCallback::_EnumFolderViewIDs(
    IEnumIDList **ppenumIDs
    )
{
    IUnknown *punkSite;
    HRESULT hr = THR(GetSite(IID_IUnknown, (void **)&punkSite));
    if (SUCCEEDED(hr))
    {
        IDVGetEnum *pdvge;  // private defview interface
        hr = THR(IUnknown_QueryService(punkSite, SID_SFolderView, IID_PPV_ARG(IDVGetEnum, &pdvge)));
        if (SUCCEEDED(hr))
        {
            const DWORD dwEnumFlags = SHCONTF_NONFOLDERS | SHCONTF_FOLDERS;
            hr = THR(pdvge->CreateEnumIDListFromContents(_pidl, dwEnumFlags, ppenumIDs));
            pdvge->Release();
        }
        punkSite->Release();
    }
    return THR(hr);
}



//
// DefView calls this to obtain information about the view CB's webview
// content.
//
HRESULT 
CControlPanelViewCallback::_OnSFVMGetWebViewContent(
    DWORD pv, 
    SFVM_WEBVIEW_CONTENT_DATA *pData
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetWebViewContent");

    ASSERT(NULL != pData);
    ASSERT(!IsBadWritePtr(pData, sizeof(*pData)));

    UNREFERENCED_PARAMETER(pv);

    HRESULT hr = S_OK;
    //
    // Tell defview...
    //
    //   1. We'll provide a 'barricade' if we're in 'category' view mode.
    //      Our 'barricade' is 'category' view.
    //   2. We'll enumerate a set of non-standard webview tasks regardless
    //      of the view mode.  One of these tasks is to switch between 'classic'
    //      view and 'category' view.
    //
    ZeroMemory(pData, sizeof(*pData));
    pData->dwFlags = SFVMWVF_ENUMTASKS | SFVMWVF_CONTENTSCHANGE;

    if (CPL::CategoryViewIsActive(NULL))
    {
        pData->dwFlags |= SFVMWVF_BARRICADE;
    }
    
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetWebViewContent", hr);
    return THR(hr);
}


//
// SFVM_UPDATESTATUSBAR handler.
// In 'Category' view, we want no status bar content.
// In 'Classic' view, we want the standard content produced by defview.
//
HRESULT 
CControlPanelViewCallback::_OnSFVMUpdateStatusBar(
    DWORD pv, 
    BOOL bInitialize
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMUpdateStatusBar");

    HRESULT hr;
    if (CPL::CategoryViewIsActive(NULL))
    {
        //
        // 'Category' view.
        // Simply return S_OK.  DefView has already cleared the statusbar.
        // Returning S_OK tells DefView that we'll set the status text ourselves.
        // Therefore, by not setting anything, the statusbar remains empty.
        //
        hr = S_OK;
    }
    else
    {
        //
        // 'Classic' view.  Returning an error code tells defview
        // to handle all the status bar content.
        //
        hr = E_NOTIMPL;
    }
    ASSERT(S_OK == hr || E_NOTIMPL == hr);
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMUpdateStatusBar", hr);
    return hr;
}


//
// Selectively disable web view for this folder (WOW64 thing for the 32-bit
// control panel.
//
HRESULT 
CControlPanelViewCallback::_OnSFVMForceWebView(
    DWORD pv, 
    PBOOL pfForce
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMForceWebView");

    ASSERT(NULL != pfForce);
    ASSERT(!IsBadWritePtr(pfForce, sizeof(*pfForce)));

    UNREFERENCED_PARAMETER(pv);

    HRESULT hr;

    if (IsOS(OS_WOW6432))
    {
        *pfForce = FALSE;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMForceWebView", hr);
    return hr;
}


//
// Tell defview we're DUI (avoids extra legacy work on defview side)
//
HRESULT
CControlPanelViewCallback::_OnSFVMGetWebViewLayout(
    DWORD pv,
    UINT uViewMode,
    SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    pData->dwLayout = SFVMWVL_NORMAL;

    return S_OK;
}


//
// Provide the barricade DUI element.  In Control Panel, our 'barricade'
// is simply our 'Category' view.  We inspect the folder's pidl to determine
// if we display the 'category choice' view or a view for a specific 
// category.
//
HRESULT 
CControlPanelViewCallback::_OnSFVMGetWebViewBarricade(
    DWORD pv, 
    DUI::Element **ppe
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetWebViewBarricade");

    ASSERT(NULL != ppe);
    ASSERT(!IsBadWritePtr(ppe, sizeof(*ppe)));

    UNREFERENCED_PARAMETER(pv);

    *ppe = NULL;

    CPL::ICplView *pView;
    HRESULT hr = _GetCplView(&pView, true);
    if (SUCCEEDED(hr))
    {
        CPL::eCPCAT eCategory;
        hr = _GetCplCategoryFromFolderIDList(&eCategory);
        if (SUCCEEDED(hr))
        {
            if (S_OK == hr)
            {
                hr = pView->CreateCategoryElement(eCategory, ppe);
            }
            else
            {
                hr = pView->CreateCategoryChoiceElement(ppe);
            }
        }
        ATOMICRELEASE(pView);
    }

    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMGetWebViewBarricade", hr);
    return THR(hr);
}


HRESULT 
CControlPanelViewCallback::_OnSFVMWindowDestroy(
    DWORD pv, 
    HWND hwnd
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMWindowDestroy");

    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(hwnd);

    HRESULT hr = S_OK;
    //
    // Need to destroy these in response to window destruction so
    // we break the site chains.  If we don't do this, the 
    // CDefView dtor is never called because our namespace
    // objects have outstanding references to CDefView.
    //
    ATOMICRELEASE(_penumWvInfo);
    ATOMICRELEASE(_pCplView);
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelViewCallback::_OnSFVMWindowDestroy", hr);
    return THR(hr);
}

   
// column IDs
typedef enum
{
    CPL_ICOL_NAME = 0,
    CPL_ICOL_COMMENT,
};

const COLUMN_INFO c_cpl_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,     20, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_Comment,  20, IDS_EXCOL_COMMENT),
};

#define PRINTERS_SORT_INDEX 45

const REQREGITEM c_asControlPanelReqItems[] =
{
    { &CLSID_Printers, IDS_PRNANDFAXFOLDER, c_szShell32Dll, -IDI_PRNFLD, PRINTERS_SORT_INDEX, SFGAO_DROPTARGET | SFGAO_FOLDER, NULL},
};

CControlPanelFolder::CControlPanelFolder(IUnknown* punkOuter) :
    CAggregatedUnknown  (punkOuter),
    _pidl               (NULL),
    _punkReg            (NULL),
    _hdsaExtPropRegVals (NULL)
{

}

CControlPanelFolder::~CControlPanelFolder()
{
    if (NULL != _hdsaExtPropRegVals)
    {
        DSA_DestroyCallback(_hdsaExtPropRegVals, 
                            _DestroyExtPropsRegValEntry,
                            NULL);
    }
    if (NULL != _pidl)
    {
        ILFree(_pidl);
    }    
    SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), &_punkReg);
}

#define REGSTR_POLICIES_RESTRICTCPL REGSTR_PATH_POLICIES TEXT("\\Explorer\\RestrictCpl")
#define REGSTR_POLICIES_DISALLOWCPL REGSTR_PATH_POLICIES TEXT("\\Explorer\\DisallowCpl")

HRESULT CControlPanel_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppvOut)
{
    CControlPanelFolder* pcpf = new CControlPanelFolder(punkOuter);
    if (NULL != pcpf)
    {
        static REGITEMSPOLICY ripControlPanel =
        {
            REGSTR_POLICIES_RESTRICTCPL,
            REST_RESTRICTCPL,
            REGSTR_POLICIES_DISALLOWCPL,
            REST_DISALLOWCPL
        };
        REGITEMSINFO riiControlPanel =
        {
            REGSTR_PATH_EXPLORER TEXT("\\ControlPanel\\NameSpace"),
            &ripControlPanel,
            TEXT(':'),
            SHID_CONTROLPANEL_REGITEM_EX,  // note, we don't really have a sig
            1,
            SFGAO_CANLINK,
            ARRAYSIZE(c_asControlPanelReqItems),
            c_asControlPanelReqItems,
            RIISA_ALPHABETICAL,
            NULL,
            // we want everything from after IDREGITEM.bOrder to the first 2 cBuf bytes to be filled with 0's
            (FIELD_OFFSET(IDCONTROL, cBuf) + 2) - (FIELD_OFFSET(IDREGITEM, bOrder) + 1),
            SHID_CONTROLPANEL_REGITEM,
        };

        if (IsOS(OS_WOW6432))
        {
            // The crippled 32-bit control panel on IA64 should show less/other stuff
            riiControlPanel.pszRegKey = REGSTR_PATH_EXPLORER TEXT("\\ControlPanelWOW64\\NameSpace");
            riiControlPanel.iReqItems = 0;
        }

        //
        //  we dont want to return a naked 
        //  control panel folder.  this should
        //  only fail with memory probs.
        //
        HRESULT hr = CRegFolder_CreateInstance(&riiControlPanel, (IUnknown*) (IShellFolder2*) pcpf,
                                  IID_IUnknown, (void **) &(pcpf->_punkReg));
        if (SUCCEEDED(hr))                                  
        {                                  
            hr = pcpf->QueryInterface(riid, ppvOut);
        }
        
        pcpf->Release();
        return hr;
    }
    *ppvOut = NULL;
    return E_OUTOFMEMORY;
}

HRESULT CControlPanelFolder::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CControlPanelFolder, IShellFolder2),                        // IID_IShellFolder2
        QITABENTMULTI(CControlPanelFolder, IShellFolder, IShellFolder2),     // IID_IShellFolder
        QITABENT(CControlPanelFolder, IPersistFolder2),                      // IID_IPersistFolder2
        QITABENTMULTI(CControlPanelFolder, IPersistFolder, IPersistFolder2), // IID_IPersistFolder
        QITABENTMULTI(CControlPanelFolder, IPersist, IPersistFolder2),       // IID_IPersist
        { 0 },
    };

    if (_punkReg && RegGetsFirstShot(riid))
    {
        return _punkReg->QueryInterface(riid, ppv);
    }
    else
    {
        return QISearch(this, qit, riid, ppv);
    }
}

// Unicode .cpl's will be flagged by having oName = 0, oInfo = 0,
// cBuf[0] = '\0', and cBuf[1] = UNICODE_CPL_SIGNATURE_BYTE

#define UNICODE_CPL_SIGNATURE_BYTE   (BYTE)0x6a

LPIDCONTROLW CControlPanelFolder::_IsUnicodeCPL(LPIDCONTROL pidc)
{
    ASSERT(_IsValid((LPCITEMIDLIST)pidc));
    
    if ((pidc->oName == 0) && (pidc->oInfo == 0) && (pidc->cBuf[0] == '\0') && (pidc->cBuf[1] == UNICODE_CPL_SIGNATURE_BYTE))
        return (LPIDCONTROLW)pidc;
    return NULL;
}

HRESULT _IDControlCreateW(PCWSTR pszModule, int idIcon, PCWSTR pszName, PCWSTR pszInfo, LPITEMIDLIST *ppidl)
{
    UINT cbModule = CbFromCchW(lstrlen(pszModule) + 1);
    UINT cbName = CbFromCchW(lstrlen(pszName) + 1);
    UINT cbInfo = CbFromCchW(lstrlen(pszInfo) + 1);
    UINT cbIDC = FIELD_OFFSET(IDCONTROLW, cBufW) + cbModule + cbName + cbInfo;

    *ppidl = _ILCreate(cbIDC + sizeof(USHORT));

    if (*ppidl)
    {
        IDCONTROLW *pidc = (IDCONTROLW *) *ppidl;
        //  init the static bits (ILCreate() zero inits)
        pidc->idIcon = idIcon;
        pidc->cBuf[1] = UNICODE_CPL_SIGNATURE_BYTE;

        //  copy module
        ualstrcpy(pidc->cBufW, pszModule);

        //  copy name
        pidc->oNameW = (USHORT)(cbModule / sizeof(pszModule[0]));
        ualstrcpy(pidc->cBufW + pidc->oNameW, pszName);

        //  copy info
        pidc->oInfoW = pidc->oNameW + (USHORT)(cbName / sizeof(pszName[0]));
        ualstrcpy(pidc->cBufW + pidc->oInfoW, pszInfo);

        pidc->cb = (USHORT)cbIDC;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT _IDControlCreateA(PCSTR pszModule, int idIcon, PCSTR pszName, PCSTR pszInfo, LPITEMIDLIST *ppidl)
{
    UINT cbModule = CbFromCchA(lstrlenA(pszModule) + 1);
    UINT cbName = CbFromCchA(lstrlenA(pszName) + 1);
    UINT cbInfo = CbFromCchA(lstrlenA(pszInfo) + 1);
    UINT cbIDC = FIELD_OFFSET(IDCONTROL, cBuf) + cbModule + cbName + cbInfo;

    *ppidl = _ILCreate(cbIDC + sizeof(USHORT));

    if (*ppidl)
    {
        IDCONTROL *pidc = (IDCONTROL *) *ppidl;
        //  init the static bits (ILCreate() zero inits)
        pidc->idIcon = idIcon;

        //  copy module
        lstrcpyA(pidc->cBuf, pszModule);

        //  copy name
        pidc->oName = (USHORT)(cbModule / sizeof(pszModule[0]));
        lstrcpyA(pidc->cBuf + pidc->oName, pszName);

        //  copy info
        pidc->oInfo = pidc->oName + (USHORT)(cbName / sizeof(pszName[0]));
        lstrcpyA(pidc->cBuf + pidc->oInfo, pszInfo);

        pidc->cb = (USHORT)cbIDC;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT IDControlCreate(LPTSTR pszModule, int idIcon, LPTSTR pszName, LPTSTR pszInfo, LPITEMIDLIST *ppidc)
{
    CHAR    szModuleA[MAX_PATH];
    CHAR    szNameA[MAX_CCH_CPLNAME];
    CHAR    szInfoA[MAX_CCH_CPLINFO];

    ASSERT(lstrlen(pszModule) < MAX_PATH);
    ASSERT(lstrlen(pszName) < MAX_CCH_CPLNAME);
    ASSERT(lstrlen(pszInfo) < MAX_CCH_CPLINFO);

    // See if any of the three string inputs cannot be represented as ANSI
    if (DoesStringRoundTrip(pszModule, szModuleA, ARRAYSIZE(szModuleA))
    && DoesStringRoundTrip(pszName, szNameA, ARRAYSIZE(szNameA))
    && DoesStringRoundTrip(pszInfo, szInfoA, ARRAYSIZE(szInfoA)))
    {
        return _IDControlCreateA(szModuleA, idIcon, szNameA, szInfoA, ppidc);
    }
    else
    {
        // Must create a full Unicode IDL
        return _IDControlCreateW(pszModule, idIcon, pszName, pszInfo, ppidc);
    }
}

LPIDCONTROL CControlPanelFolder::_IsValid(LPCITEMIDLIST pidl)
{
    //
    // the original design had no signature
    // so we are left just trying to filter out the regitems that might
    // somehow get to us.  we used to SIL_GetType(pidl) != SHID_CONTROLPANEL_REGITEM)
    // but if somehow we had an icon index that had the low byte equal
    // to SHID_CONTROLPANEL_REGITEM (0x70) we would invalidate it. DUMB!
    //
    // so we will complicate the heuristics a little bit.  lets assume that
    // all icon indeces will range between 0xFF000000 and 0x00FFFFFF
    // (or -16777214 and 16777215, 16 million each way should be plenty).
    // of course this could easily get false positives, but there really 
    // isnt anything else that we can check against.
    //
    // we will also check a minimum size.
    //
    if (pidl && pidl->mkid.cb > FIELD_OFFSET(IDCONTROL, cBuf))
    {
        LPIDCONTROL pidc = (LPIDCONTROL)pidl;
        int i = pidc->idIcon & 0xFF000000;
        if (i == 0 || i == 0xFF000000)
            return pidc;
    }
    return NULL;
}

#define REGVAL_CTRLFLDRITEM_MODULE      TEXT("Module")
#define REGVAL_CTRLFLDRITEM_ICONINDEX   TEXT("IconIndex")
#define REGVAL_CTRLFLDRITEM_NAME        TEXT("Name")
#define REGVAL_CTRLFLDRITEM_INFO        TEXT("Info")

HRESULT GetPidlFromCanonicalName(LPCTSTR pszCanonicalName, LPITEMIDLIST* ppidl)
{
    *ppidl = NULL;
    
    TCHAR szRegPath[MAX_PATH] = REGSTR_PATH_EXPLORER TEXT("\\ControlPanel\\NameSpace\\");
    HRESULT hr = StringCchCat(szRegPath, ARRAYSIZE(szRegPath), pszCanonicalName);
    if (SUCCEEDED(hr))
    {
        HKEY hKey;
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            TCHAR szModule[MAX_PATH], szName[MAX_CCH_CPLNAME], szInfo[MAX_CCH_CPLINFO];
            DWORD dwIconIndex = 0, dwType, cbSize = sizeof(szModule);

            if (SHQueryValueEx(hKey, REGVAL_CTRLFLDRITEM_MODULE, NULL, &dwType, (LPBYTE)szModule, &cbSize) == ERROR_SUCCESS)
            {
                cbSize = sizeof(dwIconIndex);
                if (SHQueryValueEx(hKey, REGVAL_CTRLFLDRITEM_ICONINDEX, NULL, &dwType, (LPBYTE)&dwIconIndex, &cbSize) != ERROR_SUCCESS)
                {
                    dwIconIndex = 0;
                }
                cbSize = sizeof(szName);
                if (SHQueryValueEx(hKey, REGVAL_CTRLFLDRITEM_NAME, NULL, &dwType, (LPBYTE)szName, &cbSize) != ERROR_SUCCESS)
                {
                    szName[0] = TEXT('\0');
                }
                cbSize = sizeof(szInfo);
                if (SHQueryValueEx(hKey, REGVAL_CTRLFLDRITEM_INFO, NULL, &dwType, (LPBYTE)szInfo, &cbSize) != ERROR_SUCCESS)
                {
                    szInfo[0] = TEXT('\0');
                }

                hr = IDControlCreate(szModule, EIRESID(dwIconIndex), szName, szInfo, ppidl);
            }
            RegCloseKey(hKey);
        }
    }
    return hr;
}

STDMETHODIMP CControlPanelFolder::ParseDisplayName(HWND hwnd, LPBC pbc,  WCHAR* pszName, 
                                                   ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttrib)
{
    if (!ppidl)
        return E_INVALIDARG;
    *ppidl = NULL;
    if (!pszName)
        return E_INVALIDARG;

    TCHAR szCanonicalName[MAX_PATH];
    SHUnicodeToTChar(pszName, szCanonicalName, ARRAYSIZE(szCanonicalName));

    HRESULT hr = GetPidlFromCanonicalName(szCanonicalName, ppidl);
    if (SUCCEEDED(hr))
    {
        // First, make sure that the pidl we obtained is valid
        DWORD dwAttrib = SFGAO_VALIDATE;
        hr = GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, &dwAttrib);
        // Now, get the other attributes if they were requested
        if (SUCCEEDED(hr) && pdwAttrib && *pdwAttrib)
        {
            hr = GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttrib);
        }
    }
    return hr;
}

STDMETHODIMP CControlPanelFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* prgfInOut)
{
    if ((*prgfInOut & SFGAO_VALIDATE) && cidl)
    {
        HRESULT hr = E_INVALIDARG;

        LPIDCONTROL pidc = _IsValid(*apidl);
        if (pidc)
        {
            TCHAR szModule[MAX_PATH];
            hr = GetModuleMapped((LPIDCONTROL)*apidl, szModule, ARRAYSIZE(szModule), NULL, NULL, 0);
            if (SUCCEEDED(hr))
            {
                if (PathFileExists(szModule))
                    hr = S_OK;
                else
                    hr = E_FAIL;
            }
        }
        return hr;
    }

    *prgfInOut &= SFGAO_CANLINK;
    return S_OK;
}

STDMETHODIMP CControlPanelFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl,
                                                REFIID riid, UINT *pres, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    LPIDCONTROL pidc = cidl && apidl ? _IsValid(apidl[0]) : NULL;

    *ppv = NULL;

    if (pidc && (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)))
    {
        TCHAR achParams[MAX_PATH+1+32+1+MAX_CCH_CPLNAME]; // See wsprintf below
        TCHAR szModule[MAX_PATH], szName[MAX_CCH_CPLNAME];
        UINT idIcon;

        // Map the icon ID for upgraded win95 shortcuts to CPLs
        hr = GetModuleMapped(pidc, szModule, ARRAYSIZE(szModule), &idIcon, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            // Use the applet name in the pid if we didn't override the name in GetModuleMapped
            if (*szName == 0)
            {
                hr = GetDisplayName(pidc, szName, ARRAYSIZE(szName));
            }
            if (SUCCEEDED(hr))
            {
                hr = StringCchPrintf(achParams, ARRAYSIZE(achParams), TEXT("%s,%d,%s"), szModule, idIcon, szName);
                if (SUCCEEDED(hr))
                {
                    hr = ControlExtractIcon_CreateInstance(achParams, riid, ppv);
                }
            }
        }
    }
    else if (pidc && IsEqualIID(riid, IID_IContextMenu))
    {
        hr = CDefFolderMenu_Create(_pidl, hwnd, cidl, apidl, 
            SAFECAST(this, IShellFolder*), DFMCallBack, NULL, NULL, (IContextMenu**) ppv);
    }
    else if (pidc && IsEqualIID(riid, IID_IDataObject))
    {
        hr = CIDLData_CreateFromIDArray(_pidl, cidl, apidl, (IDataObject**) ppv);
    }
    else if (pidc && IsEqualIID(riid, IID_IQueryInfo))
    {
        TCHAR szTemp[MAX_CCH_CPLINFO];
        hr = _GetDescription(pidc, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))
        {
            hr = CreateInfoTipFromText(szTemp, riid, ppv);
        }
    }
    return hr;
}

STDMETHODIMP CControlPanelFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    *pGuid = SRCID_SFileSearch;
    return S_OK;
}

STDMETHODIMP CControlPanelFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CControlPanelFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    *ppenum = NULL;

    if (!(grfFlags & SHCONTF_NONFOLDERS))
        return S_FALSE;

    HRESULT hr;
    CControlPanelEnum* pesf = new CControlPanelEnum(grfFlags);
    if (pesf)
    {
        // get list of module names
        hr = pesf->Init();
        if (SUCCEEDED(hr))
            pesf->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
            
        pesf->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

STDMETHODIMP CControlPanelFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CControlPanelFolder::CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPIDCONTROL pidc1 = _IsValid(pidl1);
    LPIDCONTROL pidc2 = _IsValid(pidl2);

    if (pidc1 && pidc2)
    {
        TCHAR szName1[max(MAX_CCH_CPLNAME, MAX_CCH_CPLINFO)];
        TCHAR szName2[max(MAX_CCH_CPLNAME, MAX_CCH_CPLINFO)];
        int iCmp;

        switch (iCol)
        {
        case CPL_ICOL_COMMENT:
            _GetDescription(pidc1, szName1, ARRAYSIZE(szName1));
            _GetDescription(pidc2, szName2, ARRAYSIZE(szName2));
                // They're both ANSI, so we can compare directly
            iCmp = StrCmpLogicalRestricted(szName1, szName2);
            if (iCmp != 0)
                return ResultFromShort(iCmp);
            // Fall through if the help field compares the same...
              
        case CPL_ICOL_NAME:
        default:
            GetDisplayName(pidc1, szName1, ARRAYSIZE(szName1));
            GetDisplayName(pidc2, szName2, ARRAYSIZE(szName2));
            return ResultFromShort(StrCmpLogicalRestricted(szName1, szName2));
        }
    }
    
    return E_INVALIDARG;
}

//
// background (no items) context menu callback
//

HRESULT CALLBACK CControls_DFMCallBackBG(IShellFolder *psf, HWND hwnd,
                IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_INVOKECOMMAND:
        hr = S_FALSE;   // view menu items, use the default code.
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

STDMETHODIMP CControlPanelFolder::CreateViewObject(HWND hwnd, REFIID riid, void** ppv)
{
    HRESULT hr;
    if (IsEqualIID(riid, IID_IShellView))
    {
        if (SHRestricted(REST_NOCONTROLPANEL))
        {
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_RESTRICTIONS),
                            MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE), MB_OK|MB_ICONSTOP);
            hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
        }
        else
        {
            SFV_CREATE sSFV;

            sSFV.cbSize   = sizeof(sSFV);
            sSFV.psvOuter = NULL;
            sSFV.psfvcb   = new CControlPanelViewCallback(this);

            QueryInterface(IID_IShellFolder, (void**) &sSFV.pshf);   // in case we are agregated

            hr = SHCreateShellFolderView(&sSFV, (IShellView**) ppv);

            if (sSFV.pshf)
                sSFV.pshf->Release();

            if (sSFV.psfvcb)
                sSFV.psfvcb->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hr = CDefFolderMenu_Create(NULL, hwnd, 0, NULL, 
            SAFECAST(this, IShellFolder*), CControls_DFMCallBackBG, NULL, NULL, (IContextMenu**) ppv);
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP CControlPanelFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET* pstrret)
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelFolder::GetDisplayNameOf");
    HRESULT hr = E_INVALIDARG;
    
    LPIDCONTROL pidc = _IsValid(pidl);
    if (pidc)
    {
        hr = S_OK;
        TCHAR szName[max(MAX_PATH, MAX_CCH_CPLNAME)];
        if ((dwFlags & (SHGDN_FORPARSING | SHGDN_INFOLDER | SHGDN_FORADDRESSBAR)) == ((SHGDN_FORPARSING | SHGDN_INFOLDER)))
        {
            hr = GetModule(pidc, szName, ARRAYSIZE(szName));
        }
        else
        {
            hr = GetDisplayName(pidc, szName, ARRAYSIZE(szName));
        }
        if (SUCCEEDED(hr))
        {
            hr = StringToStrRet(szName, pstrret);
        }
    }
    else if (IsSelf(1, &pidl))
    {
        //
        // Control Panel is registered with "WantsFORDISPLAY".
        //
        hr = _GetDisplayNameForSelf(dwFlags, pstrret);
    }
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelFolder::GetDisplayNameOf", hr);
    return THR(hr);
}


HRESULT
CControlPanelFolder::_GetDisplayNameForSelf(
    DWORD dwFlags, 
    STRRET* pstrret
    )
{
    DBG_ENTER(FTF_CPANEL, "CControlPanelFolder::_GetDisplayNameForSelf");
    //
    // This code only formats the folder name for display purposes.
    //
    const bool bForParsing    = (0 != (SHGDN_FORPARSING & dwFlags));
    const bool bForAddressBar = (0 != (SHGDN_FORADDRESSBAR & dwFlags));
    
    ASSERT(!bForParsing || bForAddressBar);

    HRESULT hr = S_FALSE;
    if (CPL::CategoryViewIsActive(NULL))
    {
        WCHAR szHidden[10];
        szHidden[0] = L'\0';

        ILGetHiddenStringW(_pidl, IDLHID_NAVIGATEMARKER, szHidden, ARRAYSIZE(szHidden));
        if (L'\0' != szHidden[0])
        {
            //
            // The folder pidl has a hidden navigation marker.  For Control Panel,
            // this is a category number.  Translate the category number to
            // the category title and use that in the display name for the folder.
            //
            WCHAR szCategory[MAX_PATH];
            szCategory[0] = L'\0';
            const CPL::eCPCAT eCategory = CPL::eCPCAT(StrToInt(szHidden));
            hr = CPL::CplView_GetCategoryTitle(eCategory, szCategory, ARRAYSIZE(szCategory));
            if (SUCCEEDED(hr))
            {
                //
                // Ex: "Appearance and Themes"
                //
                hr = StringToStrRet(szCategory, pstrret);
            }
        }
    }
    
    DBG_EXIT_HRES(FTF_CPANEL, "CControlPanelFolder::_GetDisplayNameForSelf", hr);
    return THR(hr);
}
    

STDMETHODIMP CControlPanelFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CControlPanelFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName,
                                            DWORD dwReserved, LPITEMIDLIST* ppidlOut)
{
    return E_FAIL;
}

STDMETHODIMP CControlPanelFolder::GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay)
{
    return E_NOTIMPL;
}

STDMETHODIMP CControlPanelFolder::GetDefaultColumnState(UINT iColumn, DWORD* pdwState)
{
    return E_NOTIMPL;
}

//
// Implementing this to handle Categorization of CPL applets.
//

STDMETHODIMP CControlPanelFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv)
{
    HRESULT hr = E_FAIL;

    LPIDCONTROL pidc = _IsValid(pidl);
    if (pidc)
    {
        if (IsEqualSCID(*pscid, SCID_CONTROLPANELCATEGORY))
        {
            HKEY hkey;
            TCHAR achCPLName[MAX_CPL_EXEC_NAME], achRegName[MAX_CPL_EXEC_NAME];      
            hr = _GetFullCPLName(pidc, achCPLName, ARRAYSIZE(achCPLName));
            if (SUCCEEDED(hr))
            {
                hr = _GetExtPropsKey(HKEY_LOCAL_MACHINE, &hkey, pscid);
                if (S_OK == hr)
                {
                    hr = _GetExtPropRegValName(hkey, achCPLName, achRegName, ARRAYSIZE(achRegName));
                    if (SUCCEEDED(hr))
                    {
                        hr = GetVariantFromRegistryValue(hkey, achRegName, pv);
                    }            
                    RegCloseKey(hkey);            
                }
            }
        }            
        else if (IsEqualSCID(*pscid, SCID_Comment))
        {
            TCHAR szDesc[MAX_PATH] = {0};
            hr = _GetDescription(pidc, szDesc, ARRAYSIZE(szDesc));
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromStr(pv, szDesc);
            }
        }
    }
    return hr;
}



//
// This function takes a registry key (hkey) and goes through all the value names under that key. 
// It expands any environment variables in the value names and then compares them to the input value 
// (pszFullName). On finding a match it returns the (unexpanded) key name in pszRegValName. 
//  
// pszFullName is of the form = C:\WINNT\System32\main.cpl,keyboard
//
// The corresponding registry value name would be   = %SystemRoot%\System32\main.cpl,keyboard
// or it could only be the filepath portion         = %SystemRoot%\System32\main.cpl 
// if all the applets in that .cpl file belong to the same category.
//
// Returns:
//    S_OK    = Name found and returned.
//    S_FALSE = Name not found.
//    Error   = Error occured.  Name not returned.
//
HRESULT
CControlPanelFolder::_GetExtPropRegValName(
    HKEY hkey, 
    LPTSTR pszFullName,    // This is modified only temporarily.
    LPTSTR pszRegValName, 
    UINT cch
    )
{                
    ASSERT(NULL != hkey);
    ASSERT(NULL != pszFullName);
    ASSERT(NULL != pszRegValName);
    ASSERT(0 < cch);
    ASSERT(!IsBadWritePtr(pszRegValName, cch * sizeof(*pszRegValName)));

    HRESULT hr = S_FALSE;
    TCHAR szSearchKeyNormalized[MAX_CPL_EXEC_NAME];

    *pszRegValName = 0;
    //
    // Normalize the CPL spec we're comparing with.
    //
    DWORD dwResult = TW32(_NormalizeCplSpec(pszFullName, 
                                            szSearchKeyNormalized, 
                                            ARRAYSIZE(szSearchKeyNormalized)));
    if (ERROR_SUCCESS == dwResult)
    {
        //
        // Look it up in the cache.
        //
        if (_LookupExtPropRegValName(hkey, szSearchKeyNormalized, pszRegValName, cch))
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }
    return hr;  
}

//
// ----------------------------------------------------------------------------
// What is 'normalization' and why do we need this caching?
//
// Starting with Windows XP, CPL applets can be categorized so that they
// appear in one of the several Control Panel categories.  The 'category'
// of an applet is stored in the registry as an 'extended property' value.
// The categorization data in the registry is stored in name-value pairs.
// The 'name' is the CPL's filesystem path with an optional applet name
// appended.  The 'value' is the CPL's category.
//
// When looking up the category for an applet, we build the CPL's 'name'
// from the path and applet name.  See _GetFullCPLName().
// This string is then used as a 'key' to locate the associated category
// 'extended property' value in the registry.
//
// The problem is that it's possible for two filesystem paths to refer
// to the same file yet be lexically different from one another.  Issues
// such as embedded environment variables and long (LFN) vs. short (SFN)
// file names can create these lexical differences.  In order to properly
// compare paths, each path must be 'normalized'.  This is done by expanding
// environment variables, converting any LFN paths to their SFN counterpart
// and removing any leading and trailing spaces.  Only then can the paths
// be correctly compared.  Windows XP bug 328304 illuminated this requirement.
//
// Normalizing a name is a bit expensive, especially the LFN->SFN conversion
// which must hit the filesystem. To minimize the number of normalizations,
// I've added a simple cache.  Nothing fancy.  It's unsorted and lookup
// is linear.  The cache is initialized the first time it is needed and
// it remains available until the CControlPanelFolder object is destroyed.
//
// brianau - 03/08/01
// 
// ----------------------------------------------------------------------------
//
// Retrieve the name of the 'extended property' reg value
// corresponding to a particular CPL.  The 'key' is a 'normalized'
// CPL name string.
//
// Assume a search key: 
//
//      "C:\WINNT\System32\main.cpl,keyboard"
//
// If an 'extended property' reg value with this name is found...
//
//      "C:\WINNT\System32\main.cpl,keyboard"
//
// ...then it is considered a match.  This means that only the "keyboard"
// applet provided by main.cpl is in the category associated with this
// entry.
//
// If an 'extended property' reg value with this name is found...
//
//      "C:\WINNT\System32\main.cpl"
//
// ...then it is also considered a match.  This means that ALL applets
// provided by main.cpl are in the category associated with this
// entry.
//
BOOL
CControlPanelFolder::_LookupExtPropRegValName(
    HKEY hkey,
    LPTSTR pszSearchKeyNormalized,
    LPTSTR pszRegValName,
    UINT cch
    )
{
    ASSERT(NULL != hkey);
    ASSERT(NULL != pszSearchKeyNormalized);
    ASSERT(NULL != pszRegValName);
    ASSERT(!IsBadWritePtr(pszRegValName, cch * sizeof(*pszRegValName)));

    BOOL bFound = FALSE;
    
    if (NULL == _hdsaExtPropRegVals)
    {
        //
        // Create and initialize (fill) the cache.
        //
        TW32(_InitExtPropRegValNameCache(hkey));
    }
    if (NULL != _hdsaExtPropRegVals)
    {
        //
        // Search is simply linear.
        //
        int const cEntries = DSA_GetItemCount(_hdsaExtPropRegVals);
        for (int i = 0; i < cEntries && !bFound; i++)
        {
            EPRV_CACHE_ENTRY *pEntry = (EPRV_CACHE_ENTRY *)DSA_GetItemPtr(_hdsaExtPropRegVals, i);
            TBOOL(NULL != pEntry);
            if (NULL != pEntry)
            {
                //
                // Compare the normalized values.  First do a complete
                // comparison of the entire string.
                //
                if (0 == StrCmpI(pEntry->pszRegValNameNormalized, pszSearchKeyNormalized))
                {
                    bFound = TRUE;
                }
                else
                {
                    LPTSTR pszComma = StrChr(pszSearchKeyNormalized, TEXT(','));
                    if (NULL != pszComma)
                    {
                        //
                        // Compare only the path parts.
                        //
                        const DWORD cchPath = pszComma - pszSearchKeyNormalized;
                        if (0 == StrCmpNI(pEntry->pszRegValNameNormalized, 
                                          pszSearchKeyNormalized, 
                                          cchPath))
                        {
                            bFound = TRUE;
                        }
                    }
                }
                if (bFound)
                {
                    StringCchCopy(pszRegValName, cch, pEntry->pszRegValName);
                }
            }
        }
    }
    return bFound;
}


//
// Create and initialize the 'extended properties' value name
// cache.  The cache is simply a DSA of type EPRV_CACHE_ENTRY.
// Each entry contains the normalized form of the reg value
// name paired with the reg value name as read from the registry
// (not normalized).  The normalized value is the 'key'.
//
DWORD
CControlPanelFolder::_InitExtPropRegValNameCache(
    HKEY hkey
    )
{
    ASSERT(NULL != hkey);
    ASSERT(NULL == _hdsaExtPropRegVals);

    DWORD dwResult = ERROR_SUCCESS;
    _hdsaExtPropRegVals = DSA_Create(sizeof(EPRV_CACHE_ENTRY), 32);
    if (NULL == _hdsaExtPropRegVals)
    {
        dwResult = TW32(ERROR_OUTOFMEMORY);
    }
    else
    {
        TCHAR szRegValName[MAX_CPL_EXEC_NAME];
        DWORD dwIndex = 0;
        while (ERROR_SUCCESS == dwResult)
        {
            DWORD dwType;    
            DWORD dwSize = ARRAYSIZE(szRegValName);
            dwResult = RegEnumValue(hkey, 
                                    dwIndex++, 
                                    szRegValName, 
                                    &dwSize, 
                                    NULL, 
                                    &dwType, 
                                    NULL, 
                                    NULL);
            
            if (ERROR_SUCCESS == dwResult)
            {
                //
                // We are interested in DWORD values only.
                //
                if (REG_DWORD == dwType)
                {
                    //
                    // Normalize the value name to create the 'key'
                    // string then cache the pair.
                    //
                    TCHAR szRegValueNameNormalized[MAX_CPL_EXEC_NAME];
                    dwResult = TW32(_NormalizeCplSpec(szRegValName, 
                                                      szRegValueNameNormalized, 
                                                      ARRAYSIZE(szRegValueNameNormalized)));
                    
                    if (ERROR_SUCCESS == dwResult)
                    {
                        dwResult = TW32(_CacheExtPropRegValName(szRegValueNameNormalized,
                                                                szRegValName));
                    }
                    else if (ERROR_INVALID_NAME == dwResult)
                    {
                        //
                        // If the path read from the registry is invalid,
                        // _NormalizeCplSpec will return ERROR_INVALID_NAME.
                        // This value is originally returned by GetShortPathName().
                        // We don't want an invalid path in one reg entry
                        // to prevent the caching of subsequent valid paths so
                        // we convert this error value to ERROR_SUCCESS.
                        //
                        dwResult = ERROR_SUCCESS;
                    }
                }
            }
        }
        if (ERROR_NO_MORE_ITEMS == dwResult)
        {
            dwResult = ERROR_SUCCESS;
        }
    }
    return TW32(dwResult);
}


//
// Insert an entry into the 'extended properties' reg value name
// cache.
//
DWORD
CControlPanelFolder::_CacheExtPropRegValName(
    LPCTSTR pszRegValNameNormalized,
    LPCTSTR pszRegValName
    )
{
    ASSERT(NULL != _hdsaExtPropRegVals);
    ASSERT(NULL != pszRegValNameNormalized);
    ASSERT(NULL != pszRegValName);

    DWORD dwResult = ERROR_SUCCESS;
    EPRV_CACHE_ENTRY entry = { NULL, NULL };
    
    if (FAILED(SHStrDup(pszRegValNameNormalized, &entry.pszRegValNameNormalized)) ||
        FAILED(SHStrDup(pszRegValName, &entry.pszRegValName)) ||
        (-1 == DSA_AppendItem(_hdsaExtPropRegVals, &entry)))
    {
        _DestroyExtPropsRegValEntry(&entry, NULL);
        dwResult = ERROR_OUTOFMEMORY;
    }
    return TW32(dwResult);
}


//
// Destroy the contents of a EPRV_CACHE_ENTRY structure.
// This is used by DSA_DestroyCallback when the cache is 
// destroyed.
//
int CALLBACK
CControlPanelFolder::_DestroyExtPropsRegValEntry(  // [static]
    void *p,
    void *pData
    )
{
    EPRV_CACHE_ENTRY *pEntry = (EPRV_CACHE_ENTRY *)p;
    ASSERT(NULL != pEntry);
    //
    // Checks for NULL are necessary as we also call this directly
    // from _CacheExtPropRegValName in the case of a failure to
    // add the entry to the cache.
    //
    if (NULL != pEntry->pszRegValName)
    {
        SHFree(pEntry->pszRegValName);
        pEntry->pszRegValName = NULL;
    }
    if (NULL != pEntry->pszRegValNameNormalized)
    {
        SHFree(pEntry->pszRegValNameNormalized);
        pEntry->pszRegValNameNormalized = NULL;
    }
    return 1;
}


//
// Given a CPL applet spec consisting of a path and an optional
// argument, this function returns the spec with the following:
//
//  1. Expands all embedded environment variables.
//  2. Shortens all LFN path strings to their SFN equivalents.
//  3. Removes leading and trailing whitespace from the path.
//  4. Removes leading and trailing whitespace from the arguments.
//
DWORD
CControlPanelFolder::_NormalizeCplSpec(
    LPTSTR pszSpecIn,
    LPTSTR pszSpecOut,
    UINT cchSpecOut
    )
{
    ASSERT(NULL != pszSpecIn);
    ASSERT(!IsBadWritePtr(pszSpecIn, sizeof(*pszSpecIn) * lstrlen(pszSpecIn) + 1));
    ASSERT(NULL != pszSpecOut);
    ASSERT(!IsBadWritePtr(pszSpecOut, cchSpecOut * sizeof(*pszSpecOut)));
    
    //
    // Temporarily truncate the spec at the end of the path part
    // if the spec contains trialing arguments (i.e. an applet name in
    // a multi-applet CPL).  This is why the pszSpecIn argument can't be
    // constant.  I don't want to create a temporary buffer just for this
    // so we modify the input string.  
    //
    LPTSTR pszArgs = StrChr(pszSpecIn, TEXT(','));
    if (NULL != pszArgs)
    {
        *pszArgs = 0;
    }
    DWORD dwResult = TW32(_NormalizePath(pszSpecIn, pszSpecOut, cchSpecOut));
    if (NULL != pszArgs)
    {
        //
        // Quick, put the comma back before anyone notices.
        //
        *pszArgs = TEXT(',');
    }
    if (ERROR_SUCCESS == dwResult)
    {
        //
        // The name contained a comma so we need to copy it and the 
        // trailing argument to the output buffer.
        //
        if (NULL != pszArgs)
        {
            const UINT cchPath = lstrlen(pszSpecOut);
            const UINT cchArgs = lstrlen(pszArgs);
            HRESULT hr = StringCchCopy(pszSpecOut + cchPath,
                                       cchSpecOut - cchPath,
                                       pszArgs);
            if (SUCCEEDED(hr))
            {
                //
                // Trim leading and trailing whitespace around the argument(s).
                // This will convert ", keyboard " to ",keyboard".
                //
                _TrimSpaces(pszSpecOut + cchPath + 1);
            }
            else
            {
                dwResult = TW32(HRESULT_CODE(hr));
            }
        }
    }
    return TW32(dwResult);
}
   

//
// Wraps _NormalizePathWorker to handle the possible stack overflow
// exception generated by the use of _alloca().
//
DWORD
CControlPanelFolder::_NormalizePath(
    LPCTSTR pszPathIn,
    LPTSTR pszPathOut,
    UINT cchPathOut
    )
{
    //
    // NormalizePathWorker uses _alloca() to allocate a stack buffer.
    // Need to handle the case where the stack is all used up.  Unlikely
    // but it could happen.
    //
    DWORD dwResult;
    __try
    {
        dwResult = TW32(_NormalizePathWorker(pszPathIn, pszPathOut, cchPathOut));
    }
    __except(_FilterStackOverflow(GetExceptionCode()))
    {
        dwResult = TW32(ERROR_STACK_OVERFLOW);
    }
    return TW32(dwResult);
}


INT
CControlPanelFolder::_FilterStackOverflow(  // [static]
    INT nException
    )
{
    if (STATUS_STACK_OVERFLOW == nException)
    {
        return EXCEPTION_EXECUTE_HANDLER;
    }
    return EXCEPTION_CONTINUE_SEARCH;
}
        

//
// Given a path string, this function expands all environment variables and
// converts all LFN strings to SFN strings.  This looks like a large function.
// It's really just one call to ExpandEnvironmentStrings() and one call to
// GetShortPathName() wrapped with some extra housekeeping.
//
DWORD 
CControlPanelFolder::_NormalizePathWorker(
    LPCTSTR pszPathIn,
    LPTSTR pszPathOut,
    UINT cchPathOut
    )
{
    ASSERT(NULL != pszPathIn);
    ASSERT(NULL != pszPathOut);
    ASSERT(!IsBadWritePtr(pszPathOut, cchPathOut * sizeof(*pszPathOut)));

    DWORD dwResult = ERROR_SUCCESS;
    //
    // _alloca generates a stack fault exception if insufficient stack space
    // is available.  It is not appropriate to check the return value.
    // This function is wrapped by _NormalizePath to handle the exception.
    //
    const DWORD cchTemp = cchPathOut;
    LPTSTR pszTemp = (LPTSTR)_alloca(cchPathOut * sizeof(*pszPathOut));
    
    //
    // Expand the entire string once to catch any env vars in either the path
    // or in any arguments.
    //
    const DWORD cchExpanded = ExpandEnvironmentStrings(pszPathIn, pszTemp, cchTemp);
    if (0 == cchExpanded)
    {
        dwResult = TW32(GetLastError());
    }
    else if (cchExpanded > cchTemp)
    {
        dwResult = TW32(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        //
        // Trim any leading and trailing spaces.
        //
        _TrimSpaces(pszTemp);
        //
        // Convert the path part to it's short-name equivalent.  This allows
        // us to compare a LFN and a SFN that resolve to the same actual file.
        // Note that this will fail if the file doesn't exist.
        // GetShortPath supports the src and dest ptrs referencing the same memory.
        //
        const DWORD cchShort = GetShortPathName(pszTemp, pszPathOut, cchPathOut);
        if (0 == cchShort)
        {
            dwResult = GetLastError();
            if (ERROR_FILE_NOT_FOUND == dwResult || 
                ERROR_PATH_NOT_FOUND == dwResult ||
                ERROR_ACCESS_DENIED == dwResult)
            {
                //
                // File doesn't exist or we don't have access.
                // We can't get the SFN so simply return the path 
                // with env vars expanded.
                //
                dwResult = TW32(HRESULT_CODE(StringCchCopy(pszPathOut, cchPathOut, pszTemp)));
            }
        }
        else if (cchShort > cchPathOut)
        {
            //
            // Output buffer is too small to hold expanded SFN string.
            // 
            dwResult = TW32(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    return TW32(dwResult);
}


//
// Remove leading and trailing spaces from a text string.
// Modifies the string in-place.
//
void
CControlPanelFolder::_TrimSpaces(
    LPTSTR psz
    )
{
    ASSERT(NULL != psz);
    ASSERT(!IsBadWritePtr(psz, sizeof(*psz) * (lstrlen(psz) + 1)));
    
    LPTSTR pszRead  = psz;
    LPTSTR pszWrite = psz;
    //
    // Skip leading spaces.
    //
    while(0 != *pszRead && TEXT(' ') == *pszRead)
    {
        ++pszRead;
    }

    //
    // Copy remainder up to the terminating nul.
    //
    LPTSTR pszLastNonSpaceChar = NULL;
    while(0 != *pszRead)
    {
        if (TEXT(' ') != *pszRead)
        {
            pszLastNonSpaceChar = pszWrite;
        }
        *pszWrite++ = *pszRead++;
    }
    if (NULL != pszLastNonSpaceChar)
    {
        //
        // The string contained at least one non-space character.
        // Adjust the 'write' ptr so that we terminate the string
        // immediately after the last one found.
        // This trims trailing spaces.
        //
        ASSERT(TEXT(' ') != *pszLastNonSpaceChar && 0 != *pszLastNonSpaceChar);
        pszWrite = pszLastNonSpaceChar + 1;
    }
    *pszWrite = 0;
}


//
// Method returns a string corresponding to what the registry value name should be 
// for this CPL pidl (pidc). This string format is basically the same as the GetExecName
// format with the quotation marks stripped, so all we do is skip the first
// two " marks in the GetExecName string
//
// String in GetExecName format:  "C:\WINNT\System32\main.cpl",keyboard
// String in registry format   :  C:\WINNT\System32\main.cpl,keyboard
//
// 
HRESULT CControlPanelFolder::_GetFullCPLName(LPIDCONTROL pidc, LPTSTR achFullCPLName, UINT cchSize)
{    
    const TCHAR QUOTE = TEXT('\"');

    HRESULT hr = GetExecName(pidc, achFullCPLName,cchSize);
    if (SUCCEEDED(hr))
    {
        // first char must be a quote
        ASSERTMSG ((QUOTE == *achFullCPLName), "CControlPanelFolder::_GetFullCPLName() GetExecName returned an invalid value");

        if (QUOTE == *achFullCPLName) // I know we asserted, just being super paranoid
        {
            LPTSTR pszWrite = achFullCPLName;
            LPCTSTR pszRead = achFullCPLName;
            int cQuotes     = 2;  // we want to skip the first two quotes only
            
            while(*pszRead)
            {
                if (0 < cQuotes && QUOTE == *pszRead)
                {
                    --cQuotes;
                    ++pszRead;
                }
                else
                {
                    *pszWrite++ = *pszRead++;
                }
            }
            *pszWrite = TEXT('\0');
        }        
    }
    return hr;
}


STDMETHODIMP CControlPanelFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails)
{
    HRESULT hr = E_INVALIDARG;
    if (pidl == NULL)
    {
        hr = GetDetailsOfInfo(c_cpl_cols, ARRAYSIZE(c_cpl_cols), iColumn, pDetails);
    }
    else
    {
        LPIDCONTROL pidc = _IsValid(pidl);
        if (pidc)
        {
            TCHAR szTemp[max(max(MAX_PATH, MAX_CCH_CPLNAME), MAX_CCH_CPLINFO)];

            pDetails->str.uType = STRRET_CSTR;
            pDetails->str.cStr[0] = 0;

            switch (iColumn)
            {
            case CPL_ICOL_NAME:
                GetDisplayName(pidc, szTemp, ARRAYSIZE(szTemp));
                break;

            case CPL_ICOL_COMMENT:
                _GetDescription(pidc, szTemp, ARRAYSIZE(szTemp));
                break;
                               
            default:
                szTemp[0] = 0;
                break;
            }
            hr = StringToStrRet(szTemp, &pDetails->str);
        }
    }
    return hr;
}

STDMETHODIMP CControlPanelFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid)
{
    return MapColumnToSCIDImpl(c_cpl_cols, ARRAYSIZE(c_cpl_cols), iColumn, pscid);
}

STDMETHODIMP CControlPanelFolder::GetClassID(CLSID* pCLSID)
{
    *pCLSID = CLSID_ControlPanel;
    return S_OK;
}

STDMETHODIMP CControlPanelFolder::Initialize(LPCITEMIDLIST pidl)
{
    if (NULL != _pidl)
    {
        ILFree(_pidl);
        _pidl = NULL;
    }

    return SHILClone(pidl, &_pidl);
}

STDMETHODIMP CControlPanelFolder::GetCurFolder(LPITEMIDLIST* ppidl)
{
    return GetCurFolderImpl(_pidl, ppidl);
}

//
// list of item context menu callback
//

HRESULT CALLBACK CControlPanelFolder::DFMCallBack(IShellFolder *psf, HWND hwndView,
                                                  IDataObject *pdtobj, UINT uMsg,
                                                  WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_NOTIMPL;

    if (pdtobj)
    {
        STGMEDIUM medium;

        LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
        if (pida)
        {
            hr = S_OK;

            switch(uMsg)
            {
            case DFM_MERGECONTEXTMENU:
            {
                LPQCMINFO pqcm = (LPQCMINFO)lParam;
                int idCmdFirst = pqcm->idCmdFirst;

                if (wParam & CMF_EXTENDEDVERBS)
                {
                    // If the user is holding down shift, on NT5 we load the menu with both "Open" and "Run as..."
                    CDefFolderMenu_MergeMenu(HINST_THISDLL, MENU_GENERIC_CONTROLPANEL_VERBS, 0, pqcm);
                }
                else
                {
                    // Just load the "Open" menu
                    CDefFolderMenu_MergeMenu(HINST_THISDLL, MENU_GENERIC_OPEN_VERBS, 0, pqcm);
                }

                SetMenuDefaultItem(pqcm->hmenu, 0, MF_BYPOSITION);

                //
                //  Returning S_FALSE indicates no need to get verbs from
                // extensions.
                //

                hr = S_FALSE;

                break;
            } // case DFM_MERGECONTEXTMENU

            case DFM_GETHELPTEXT:
                LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
                break;

            case DFM_GETHELPTEXTW:
                LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
                break;

            case DFM_INVOKECOMMAND:
                {
                    for (int i = pida->cidl - 1; i >= 0; i--)
                    {
                        LPIDCONTROL pidc = _IsValid(IDA_GetIDListPtr(pida, i));

                        if (pidc)
                        {
                            switch(wParam)
                            {
                            case FSIDM_OPENPRN:
                            case FSIDM_RUNAS:
                            {
                                TCHAR achParam[MAX_CPL_EXEC_NAME]; // See wnsprintf in GetExecName
                                hr = GetExecName(pidc, achParam, ARRAYSIZE(achParam));
                                if (SUCCEEDED(hr))
                                {
                                    SHRunControlPanelEx(achParam, hwndView, (wParam == FSIDM_RUNAS));
                                    hr = S_OK;
                                }
                                break;
                            }

                            default:
                                hr = S_FALSE;
                            } // switch(wParam)
                        }
                        else
                            hr = E_FAIL;
                    }
                }
                break;

            case DFM_MAPCOMMANDNAME:
                if (lstrcmpi((LPCTSTR)lParam, c_szOpen) == 0)
                {
                    *(UINT_PTR *)wParam = FSIDM_OPENPRN;
                }
                else
                {
                    // command not found
                    hr = E_FAIL;
                }
                break;

            default:
                hr = E_NOTIMPL;
                break;
            } // switch (uMsg)

            HIDA_ReleaseStgMedium(pida, &medium);

        } // if (pida)

    } // if (pdtobj)
    return hr;
}

HRESULT MakeCPLCommandLine(LPCTSTR pszModule, LPCTSTR pszName, LPTSTR pszCommandLine, DWORD cchCommandLine)
{
    RIP(pszCommandLine);
    RIP(pszModule);
    RIP(pszName);
    
    return StringCchPrintf(pszCommandLine, cchCommandLine, TEXT("\"%s\",%s"), pszModule, pszName);
}

HRESULT CControlPanelFolder::GetExecName(LPIDCONTROL pidc, LPTSTR pszParseName, UINT cchParseName)
{
    TCHAR szModule[MAX_PATH], szName[MAX_CCH_CPLNAME];
    
    HRESULT hr = GetModuleMapped(pidc, szModule, ARRAYSIZE(szModule), NULL, szName, ARRAYSIZE(szName));
    if (SUCCEEDED(hr))
    {
        // If our GetModuleMapped call didn't override the applet name, get it the old fashioned way
        if (*szName == 0)
        {
            hr = GetDisplayName(pidc, szName, ARRAYSIZE(szName));
        }

        if (SUCCEEDED(hr))
        {
            hr = MakeCPLCommandLine(szModule, szName, pszParseName, cchParseName);
        }
    }
    return hr;
}

typedef struct _OLDCPLMAPPING
{
    LPCTSTR szOldModule;
    UINT    idOldIcon;
    LPCTSTR szNewModule;
    UINT    idNewIcon;
    LPCTSTR szApplet;
    // Put TEXT("") in szApplet to use the applet name stored in the cpl shortcut
} OLDCPLMAPPING, *LPOLDCPLMAPPING;

const OLDCPLMAPPING g_rgOldCPLMapping[] = 
{
    // Win95 shortcuts that don't work correctly
    // -----------------------------------------

    // Add New Hardware
    {TEXT("SYSDM.CPL"), 0xfffffda6, TEXT("HDWWIZ.CPL"), (UINT) -100, TEXT("@0")},       
    // ODBC 32 bit
    {TEXT("ODBCCP32.CPL"), 0xfffffa61, TEXT("ODBCCP32.CPL"), 0xfffffa61, TEXT("@0")},
    // Mail
    {TEXT("MLCFG32.CPL"), 0xffffff7f, TEXT("MLCFG32.CPL"), 0xffffff7f, TEXT("@0")},
    // Modem
    {TEXT("MODEM.CPL"), 0xfffffc18, TEXT("TELEPHON.CPL"), (UINT) -100, TEXT("")},
    // Multimedia
    {TEXT("MMSYS.CPL"), 0xffffff9d, TEXT("MMSYS.CPL"), (UINT) -110, TEXT("")},
    // Network
    {TEXT("NETCPL.CPL"), 0xffffff9c, TEXT("NCPA.CPL"), 0xfffffc17, TEXT("@0")},
    // Password
    {TEXT("PASSWORD.CPL"), 0xfffffc18, TEXT("PASSWORD.CPL"), 0xfffffc18, TEXT("@0")},
    // Regional Settings
    {TEXT("INTL.CPL"), 0xffffff9b, TEXT("INTL.CPL"), (UINT) -200, TEXT("@0")},
    // System
    {TEXT("SYSDM.CPL"), 0xfffffda8, TEXT("SYSDM.CPL"), (UINT) -6, TEXT("")},
    // Users
    {TEXT("INETCPL.CPL"), 0xfffffad5, TEXT("INETCPL.CPL"), 0xfffffad5, TEXT("@0")},

    // NT4 Shortcuts that don't work
    // -----------------------------

    // Multimedia
    {TEXT("MMSYS.CPL"), 0xfffff444, TEXT("MMSYS.CPL"), 0xfffff444, TEXT("@0")},
    // Network
    {TEXT("NCPA.CPL"), 0xfffffc17, TEXT("NCPA.CPL"), 0xfffffc17, TEXT("@0")},
    // UPS
    {TEXT("UPS.CPL"), 0xffffff9c, TEXT("POWERCFG.CPL"), (UINT) -202, TEXT("@0")},

    // Synonyms for hardware management
    // Devices
    {TEXT("SRVMGR.CPL"), 0xffffff67, TEXT("HDWWIZ.CPL"), (UINT) -100, TEXT("@0")},
    // Ports
    {TEXT("PORTS.CPL"), 0xfffffffe,  TEXT("HDWWIZ.CPL"), (UINT) -100, TEXT("@0")},
    // SCSI Adapters
    {TEXT("DEVAPPS.CPL"), 0xffffff52, TEXT("HDWWIZ.CPL"), (UINT) -100, TEXT("@0")},
    // Tape Devices
    {TEXT("DEVAPPS.CPL"), 0xffffff97, TEXT("HDWWIZ.CPL"), (UINT) -100, TEXT("@0")},
};

HRESULT CControlPanelFolder::GetModuleMapped(LPIDCONTROL pidc, LPTSTR pszModule, UINT cchModule,
                                             UINT* pidNewIcon, LPTSTR pszApplet, UINT cchApplet)
{
    HRESULT hr = GetModule(pidc, pszModule, cchModule);
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;

        // Compare just the .cpl file name, not the full path: Get this file name from the full path
        LPTSTR pszFilename = PathFindFileName(pszModule);

        // Calculate the size of the buffer available for the filename
        UINT cchFilenameBuffer = cchModule - (UINT)(pszFilename - pszModule);

        if (((int) pidc->idIcon <= 0) && (pszFilename))
        {
            for (int i = 0; i < ARRAYSIZE(g_rgOldCPLMapping); i++)
            {
                // See if the module names and old icon IDs match those in this
                // entry of our mapping
                if (((UINT) pidc->idIcon == g_rgOldCPLMapping[i].idOldIcon) &&
                    (lstrcmpi(pszFilename, g_rgOldCPLMapping[i].szOldModule) == 0))
                {
                    hr = S_OK;
                    
                    // Set the return values to those of the found item
                    if (pidNewIcon != NULL)
                        *pidNewIcon = g_rgOldCPLMapping[i].idNewIcon;

                    hr = StringCchCopy(pszFilename, cchFilenameBuffer, g_rgOldCPLMapping[i].szNewModule);
                    if (SUCCEEDED(hr))
                    {
                        if (pszApplet != NULL)
                        {
                            hr = StringCchCopy(pszApplet, cchApplet, g_rgOldCPLMapping[i].szApplet);
                        }
                    }
                    break;
                }
            }
        }

        // Return old values if we didn't require a translation
        if (S_OK != hr)
        {
            if (pidNewIcon != NULL)
                *pidNewIcon = pidc->idIcon;

            if (pszApplet != NULL)
                *pszApplet = 0; //NULL String
        }

        if (SUCCEEDED(hr))
        {
            //  If the .cpl file can't be found, this may be a Win95 shortcut specifying
            //  the old system directory - possibly an upgraded system.  We try to make
            //  this work by changing the directory specified to the actual system
            //  directory.  For example c:\windows\system\foo.cpl will become
            //  c:\winnt\system32\foo.cpl.
            //
            //  Note:   The path substitution is done unconditionally because if we
            //          can't find the file it doesn't matter where we can't find it...

            if (!PathFileExists(pszModule))
            {
                TCHAR szNew[MAX_PATH], szSystem[MAX_PATH];

                GetSystemDirectory(szSystem, ARRAYSIZE(szSystem));
                if (PathCombine(szNew, szSystem, pszFilename))
                {
                    hr = StringCchCopy(pszModule, cchModule, szNew);
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
    }

    return hr;
}

//
//  SHualUnicodeToTChar is like SHUnicodeToTChar except that it accepts
//  an unaligned input string parameter.
//
#ifdef UNICODE
#define SHualUnicodeToTChar(src, dst, cch) ualstrcpyn(dst, src, cch)
#else   // No ANSI platforms require alignment
#define SHualUnicodeToTChar                SHUnicodeToTChar
#endif

HRESULT CControlPanelFolder::GetDisplayName(LPIDCONTROL pidc, LPTSTR pszName, UINT cchName)
{
    LPIDCONTROLW pidcW = _IsUnicodeCPL(pidc);
    if (pidcW)
        SHualUnicodeToTChar(pidcW->cBufW + pidcW->oNameW, pszName, cchName);
    else
        SHAnsiToTChar(pidc->cBuf + pidc->oName, pszName, cchName);

    return S_OK;
}

HRESULT CControlPanelFolder::GetModule(LPIDCONTROL pidc, LPTSTR pszModule, UINT cchModule)
{
    LPIDCONTROLW pidcW = _IsUnicodeCPL(pidc);
    if (pidcW)
    {
        if (!SHualUnicodeToTChar(pidcW->cBufW, pszModule, cchModule))
        {
            *pszModule = TEXT('\0');
        }
    }
    else
    {
        if (!SHAnsiToTChar(pidc->cBuf, pszModule, cchModule))
        {
            *pszModule = TEXT('\0');
        }
    }
    return S_OK;
}

HRESULT CControlPanelFolder::_GetDescription(LPIDCONTROL pidc, LPTSTR pszDesc, UINT cchDesc)
{
    LPIDCONTROLW pidcW = _IsUnicodeCPL(pidc);
    if (pidcW)
        SHualUnicodeToTChar(pidcW->cBufW + pidcW->oInfoW, pszDesc, cchDesc);
    else
        SHAnsiToTChar(pidc->cBuf + pidc->oInfo, pszDesc, cchDesc);

    return S_OK;
}

//
// Method opens a subkey corresponding to a SCID under ExtendedPoperties for control panel 
//
HRESULT CControlPanelFolder::_GetExtPropsKey(HKEY hkeyParent, HKEY * pHkey, const SHCOLUMNID * pscid)
{
    const TCHAR c_szRegPath[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Extended Properties\\");
    const UINT cchRegPath = ARRAYSIZE (c_szRegPath);

    TCHAR achPath[cchRegPath + SCIDSTR_MAX];
    HRESULT hr = StringCchCopy(achPath, ARRAYSIZE(achPath), c_szRegPath);
    if (SUCCEEDED(hr))
    {
        ASSERT (hkeyParent);
        hr = S_FALSE;
        
        if (0 < StringFromSCID(pscid, achPath + cchRegPath - 1, ARRAYSIZE(achPath) - cchRegPath))
        {
            DWORD dwResult = RegOpenKeyEx(hkeyParent, 
                                          achPath,
                                          0,
                                          KEY_QUERY_VALUE,
                                          pHkey);

            if (ERROR_SUCCESS == dwResult)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(dwResult);
            }
        }
    }
    return hr;    
}   

#undef SHualUnicodeToTChar

CControlPanelEnum::CControlPanelEnum(UINT uFlags) :
    _cRef                       (1),
    _uFlags                     (uFlags),
    _iModuleCur                 (0),
    _cControlsOfCurrentModule   (0),
    _iControlCur                (0),
    _cControlsTotal             (0),
    _iRegControls               (0)
{
    ZeroMemory(&_minstCur, sizeof(_minstCur));
    ZeroMemory(&_cplData, sizeof(_cplData));
}

CControlPanelEnum::~CControlPanelEnum()
{
    CPLD_Destroy(&_cplData);
}

HRESULT CControlPanelEnum::Init()
{
    HRESULT hr;
    if (CPLD_GetModules(&_cplData))
    {
        CPLD_GetRegModules(&_cplData);
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

STDMETHODIMP CControlPanelEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = { 
        QITABENT(CControlPanelEnum, IEnumIDList), 
        { 0 } 
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CControlPanelEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CControlPanelEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// for other ways to hide CPLs see control1.c, DontLoadCPL()
BOOL CControlPanelEnum::_DoesPolicyAllow(LPCTSTR pszName, LPCTSTR pszFileName)
{
    BOOL bAllow = TRUE;
    if (SHRestricted(REST_RESTRICTCPL) && 
        !IsNameListedUnderKey(pszName, REGSTR_POLICIES_RESTRICTCPL) &&
        !IsNameListedUnderKey(pszFileName, REGSTR_POLICIES_RESTRICTCPL))
    {
        bAllow = FALSE;
    }
    if (bAllow)
    {
        if (SHRestricted(REST_DISALLOWCPL) && 
            (IsNameListedUnderKey(pszName, REGSTR_POLICIES_DISALLOWCPL) ||
             IsNameListedUnderKey(pszFileName, REGSTR_POLICIES_DISALLOWCPL)))
        {
            bAllow = FALSE;
        }
    }
    return bAllow;
}

STDMETHODIMP CControlPanelEnum::Next(ULONG celt, LPITEMIDLIST* ppidlOut, ULONG* pceltFetched)
{
    ZeroMemory(ppidlOut, sizeof(ppidlOut[0])*celt);
    if (pceltFetched)
        *pceltFetched = 0;

    if (!(_uFlags & SHCONTF_NONFOLDERS))
        return S_FALSE;

    // Loop through lpData->pRegCPLs and use what cached information we can.

    while (_iRegControls < _cplData.cRegCPLs)
    {
        REG_CPL_INFO *pRegCPL = (REG_CPL_INFO *) DPA_GetPtr(_cplData.hRegCPLs, _iRegControls);
        PMODULEINFO pmi;
        TCHAR szFilePath[MAX_PATH];

        StringCchCopy(szFilePath, ARRAYSIZE(szFilePath), REGCPL_FILENAME(pRegCPL));
        LPTSTR pszFileName = PathFindFileName(szFilePath);

        // find this module in the hamiModule list

        for (int i = 0; i < _cplData.cModules; i++)
        {
            pmi = (PMODULEINFO) DSA_GetItemPtr(_cplData.hamiModule, i);

            if (!lstrcmpi(pszFileName, pmi->pszModuleName))
                break;
        }

        if (i < _cplData.cModules)
        {
            LPCTSTR pszDisplayName = REGCPL_CPLNAME(pRegCPL);
            // If this cpl is not supposed to be displayed let's bail
            if (!_DoesPolicyAllow(pszDisplayName, pszFileName))
            {
                _iRegControls++;
                // we have to set this bit, so that the cpl doesn't get reregistered
                pmi->flags |= MI_REG_ENUM;
                continue;
            }

            // Get the module's creation time & size
            if (!(pmi->flags & MI_FIND_FILE))
            {
                WIN32_FIND_DATA findData;
                HANDLE hFindFile = FindFirstFile(pmi->pszModule, &findData);
                if (hFindFile != INVALID_HANDLE_VALUE)
                {
                    pmi->flags |= MI_FIND_FILE;
                    pmi->ftCreationTime = findData.ftCreationTime;
                    pmi->nFileSizeHigh = findData.nFileSizeHigh;
                    pmi->nFileSizeLow = findData.nFileSizeLow;
                    FindClose(hFindFile);
                }
                else
                {
                    // this module no longer exists...  Blow it away.
                    DebugMsg(DM_TRACE,TEXT("sh CPLS: very stange, couldn't get timestamps for %s"), REGCPL_FILENAME(pRegCPL));
                    goto RemoveRegCPL;
                }
            }

            if (0 != CompareFileTime(&pmi->ftCreationTime, &pRegCPL->ftCreationTime) || 
                pmi->nFileSizeHigh != pRegCPL->nFileSizeHigh || 
                pmi->nFileSizeLow != pRegCPL->nFileSizeLow)
            {
                // this doesn't match -- remove it from pRegCPLs; it will
                // get enumerated below.
                DebugMsg(DM_TRACE,TEXT("sh CPLS: timestamps don't match for %s"), REGCPL_FILENAME(pRegCPL));
                pmi->flags |= MI_REG_INVALID;
                goto RemoveRegCPL;
            }

            // we have a match: mark this module so we skip it below
            // and enumerate this cpl now
            pmi->flags |= MI_REG_ENUM;

            IDControlCreate(pmi->pszModule, EIRESID(pRegCPL->idIcon), REGCPL_CPLNAME(pRegCPL), REGCPL_CPLINFO(pRegCPL), ppidlOut);

            _iRegControls++;
            goto return_item;
        }
        else
        {
            DebugMsg(DM_TRACE,TEXT("sh CPLS: %s not in module list!"), REGCPL_FILENAME(pRegCPL));
        }

RemoveRegCPL:
        // Nuke this cpl entry from the registry

        if (!(pRegCPL->flags & REGCPL_FROMREG))
            LocalFree(pRegCPL);

        DPA_DeletePtr(_cplData.hRegCPLs, _iRegControls);

        _cplData.cRegCPLs--;
        _cplData.fRegCPLChanged = TRUE;
    }

    // Have we enumerated all the cpls in this module?
    LPCPLMODULE pcplm;
    LPCPLITEM pcpli;
    do
    {
        while (_iControlCur >= _cControlsOfCurrentModule || // no more
               _cControlsOfCurrentModule < 0) // error getting modules
        {

            // Have we enumerated all the modules?
            if (_iModuleCur >= _cplData.cModules)
            {
                CPLD_FlushRegModules(&_cplData); // flush changes for next guy
                return S_FALSE;
            }

            // Was this module enumerated from the registry?
            // Was the cached registry information found to be valid?
            PMODULEINFO pmi = (PMODULEINFO) DSA_GetItemPtr(_cplData.hamiModule, _iModuleCur);
            if (!(pmi->flags & MI_REG_ENUM) || (pmi->flags & MI_REG_INVALID))
            {
                // No. Load and init the module, set up counters.

                pmi->flags |= MI_CPL_LOADED;
                _cControlsOfCurrentModule = CPLD_InitModule(&_cplData, _iModuleCur, &_minstCur);
                _iControlCur = 0;
            }

            ++_iModuleCur;  // Point to next module
        }

        // We're enumerating the next control in this module
        // Add the control to the registry

        EVAL(CPLD_AddControlToReg(&_cplData, &_minstCur, _iControlCur));
        // This shouldn't fail at all; that would mean that DSA_GetItemPtr() failed, 
        // and we've already called that successfully.

        // Get the control's pidl name

        pcplm = FindCPLModule(&_minstCur);
        pcpli = (LPCPLITEM) DSA_GetItemPtr(pcplm->hacpli, _iControlCur);

        ++_iControlCur;
    } while (!_DoesPolicyAllow(pcpli->pszName, PathFindFileName(pcplm->szModule)));

    IDControlCreate(pcplm->szModule, EIRESID(pcpli->idIcon), pcpli->pszName, pcpli->pszInfo, ppidlOut);
    
return_item:
    HRESULT hr = *ppidlOut ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        ++_cControlsTotal;

        if (pceltFetched)
            *pceltFetched = 1;
    }

    return hr;
}

STDMETHODIMP CControlPanelEnum::Reset()
{
    _iModuleCur  = 0;
    _cControlsOfCurrentModule = 0;
    _iControlCur = 0;
    _cControlsTotal = 0;
    _iRegControls = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cstrings.h ===
// all of the stuf here should go away, use inline strings, the compiler merges them
#include <regstr.h>

extern const TCHAR c_szShell32Dll[];
extern const TCHAR c_szBaseClass[];
extern const TCHAR c_szBriefcase[];
extern const TCHAR c_szStubWindowClass[];
extern const TCHAR c_szConnect[];
extern const TCHAR c_szConv[];
extern const TCHAR c_szDesktopIni[];
extern const TCHAR c_szDotDir[];
extern const TCHAR c_szDotDot[];
extern const TCHAR c_szDotExe[];
extern const TCHAR c_szEllipses[];
extern const TCHAR c_szExplore[];
extern const TCHAR c_szFILEOKSTRING[];
extern const TCHAR c_szFileCabinet[];
extern const TCHAR c_szFolderClass[];
extern const TCHAR c_szHeaderClass[];
extern const TCHAR c_szListViewClass[];
extern const TCHAR c_szMenuHandler[];
extern const TCHAR c_szNetRoot[];
extern const TCHAR c_szNetworkClass[];
extern const TCHAR c_szOpen[];
extern const TCHAR c_szOpenAs[];
extern const TCHAR c_szEdit[];
extern const TCHAR c_szOptions[];
extern const TCHAR c_szPATH[];
extern const TCHAR c_szPrint[];
extern const TCHAR c_szPrintTo[];
extern const TCHAR c_szQuote[];
extern const TCHAR c_szRunConnect[];
extern const TCHAR c_szRunDll[];
extern const TCHAR c_szRunDll16[];
extern const TCHAR c_szRecentDocs[];
extern const TCHAR c_szShellUIHandler[];
extern const TCHAR c_szSlashCommand[];
extern const TCHAR c_szSlashDDEExec[];
extern const TCHAR c_szSpace[];
extern const TCHAR c_szStar[];
extern const TCHAR c_szStarDotStar[];
extern const TCHAR c_szTrayClass[];
extern const TCHAR c_szViewState[];
extern const TCHAR c_szNULL[];
#define szNULL c_szNULL
extern const  CHAR c_szNULLA[];
extern const TCHAR c_szDefaultIcon[];
extern const TCHAR c_szShell[];
extern const TCHAR c_szDesktop[];
extern const TCHAR c_szShellOpenCmd[];

extern const TCHAR c_szShellNew[];
extern const TCHAR c_szData[];
extern const TCHAR c_szFile[];

#define CCHELLIPSES 3

extern const TCHAR c_szSetDefault[];
extern const TCHAR c_szNewObject[];
extern const TCHAR c_szPause[];
extern const TCHAR c_szResume[];
extern const TCHAR c_szPurge[];
extern const TCHAR c_szListView[];
extern const TCHAR c_szPositions[];
extern const TCHAR c_szPrinterIni[];
extern const TCHAR c_szFileColon[];
extern const TCHAR c_szPrinters[];

extern const TCHAR c_szCut[];
extern const TCHAR c_szCopy[];
extern const TCHAR c_szLink[];
extern const TCHAR c_szProperties[];
extern const TCHAR c_szPaste[];
extern const TCHAR c_szPasteLink[];
extern const TCHAR c_szRename[];

extern const TCHAR c_szFind[];
extern const TCHAR c_szNoRun[];
extern const TCHAR c_szNoClose[];
extern const TCHAR c_szNoSaveSettings[];
extern const TCHAR c_szNoFileMenu[];
extern const TCHAR c_szNoSetFolders[];
extern const TCHAR c_szNoSetTaskbar[];
extern const TCHAR c_szNoDesktop[];
extern const TCHAR c_szNoFind[];
extern const TCHAR c_szNoDrives[];
extern const TCHAR c_szNoDriveAutoRun[];
extern const TCHAR c_szNoDriveTypeAutoRun[];
extern const TCHAR c_szNoNetHood[];
extern const TCHAR c_szFontExtDll[];

extern const TCHAR c_szCommand[];

#define SHELL_HLP "shell.hlp" // What help file the shell uses.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ctrlxicon.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "xiconwrap.h"

// From cplobj.c
EXTERN_C BOOL CPL_FindCPLInfo(LPTSTR pszCmdLine, HICON *phIcon, UINT *ppapl, LPTSTR *pparm);

class CCtrlExtIconBase : public CExtractIconBase
{
public:
    HRESULT _GetIconLocationW(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags);
    HRESULT _ExtractW(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);

    CCtrlExtIconBase(LPCWSTR pszSubObject);

protected:
    ~CCtrlExtIconBase();

private:
    TCHAR _szSubObject[MAX_PATH];
    HICON _hIcon;
    UINT  _nControl;
};

CCtrlExtIconBase::CCtrlExtIconBase(LPCWSTR pszSubObject) : CExtractIconBase(), _hIcon(NULL), _nControl(-1) 
{
    lstrcpyn(_szSubObject, pszSubObject, ARRAYSIZE(_szSubObject));
}


CCtrlExtIconBase::~CCtrlExtIconBase()
{
    if (_hIcon)
        DestroyIcon(_hIcon);
}


STDAPI ControlExtractIcon_CreateInstance(LPCTSTR pszSubObject, REFIID riid, void** ppv)
{
    HRESULT hr;
    CCtrlExtIconBase* pceib = new CCtrlExtIconBase(pszSubObject);
    if (pceib)
    {
        hr = pceib->QueryInterface(riid, ppv);
        pceib->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CCtrlExtIconBase::_GetIconLocationW(UINT uFlags, LPWSTR pszIconFile,
    UINT cchMax, int *piIndex, UINT *pwFlags)
{
    HRESULT hr = S_FALSE;

    if (!(uFlags & GIL_OPENICON))
    {
        lstrcpyn(pszIconFile, _szSubObject, cchMax);
        LPTSTR pszComma = StrChr(pszIconFile, TEXT(','));
        if (pszComma)
        {
            *pszComma ++= 0;
            *piIndex = StrToInt(pszComma);
            *pwFlags = GIL_PERINSTANCE;

            //
            // normally the index will be negative (a resource id)
            // check for some special cases like dynamic icons and bogus ids
            //
            if (*piIndex == 0)
            {
                LPTSTR lpExtraParms = NULL;

                // this is a dynamic applet icon
                *pwFlags |= GIL_DONTCACHE | GIL_NOTFILENAME;

                // use the applet index in case there's more than one
                if ((_hIcon != NULL) || CPL_FindCPLInfo(_szSubObject, &_hIcon,
                    &_nControl, &lpExtraParms))
                {
                    *piIndex = _nControl;
                }
                else
                {
                    // we failed to load the applet all of the sudden
                    // use the first icon in the cpl file (*piIndex == 0)
                    //
                    // Assert(FALSE);
                    DebugMsg(DM_ERROR,
                        TEXT("Control Panel CCEIGIL: ") TEXT("Enumeration failed \"%s\""),
                        _szSubObject);
                }
            }
            else if (*piIndex > 0)
            {
                // this is an invalid icon for a control panel
                // use the first icon in the file
                // this may be wrong but it's better than a generic doc icon
                // this fixes ODBC32 which is NOT dynamic but returns bogus ids
                *piIndex = 0;
            }

            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CCtrlExtIconBase::_ExtractW(LPCWSTR pszFile, UINT nIconIndex,
    HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    LPTSTR lpExtraParms = NULL;
    HRESULT hr = S_FALSE;

    //-------------------------------------------------------------------
    // if there is no icon index then we must extract by loading the dude
    // if we have an icon index then it can be extracted with ExtractIcon
    // (which is much faster)
    // only perform a custom extract if we have a dynamic icon
    // otherwise just return S_FALSE and let our caller call ExtractIcon.
    //-------------------------------------------------------------------

    LPCTSTR p = StrChr(_szSubObject, TEXT(','));

    if ((!p || !StrToInt(p+1)) &&
        ((_hIcon != NULL) || CPL_FindCPLInfo(_szSubObject, &_hIcon,
        &_nControl, &lpExtraParms)))
    {
        if (_hIcon)
        {
            *phiconLarge = CopyIcon(_hIcon);
            *phiconSmall = NULL;

            if( *phiconLarge )
                hr = S_OK;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\cstrings.c ===
#include "shellprv.h"
#pragma  hdrstop

const TCHAR c_szShell32Dll[] = TEXT("shell32.dll");
const TCHAR c_szShell16Dll[] = TEXT("shell.dll");
const TCHAR c_szNULL[] = TEXT("");
const TCHAR c_szSpace[] = TEXT(" ");
const TCHAR c_szStar[] = TEXT("*");
const TCHAR c_szStarDotStar[] = TEXT("*.*");
const TCHAR c_szFolderClass[] = TEXT("Folder");
const TCHAR c_szStubWindowClass[] = TEXT("StubWindow32");

const TCHAR c_szExplore[]  = TEXT("Explore");
const TCHAR c_szBaseClass[] = TEXT("*");
const TCHAR c_szEllipses[] = TEXT("...");
const TCHAR c_szPATH[] = TEXT("PATH");
const TCHAR c_szDotExe[] = TEXT(".exe");
const TCHAR c_szOpen[]         = TEXT("open");
const TCHAR c_szEdit[]         = TEXT("edit");
const TCHAR c_szFind[]         = TEXT("find");
const TCHAR c_szPrint[]        = TEXT("print");
const TCHAR c_szPrintTo[]      = TEXT("printto");
const TCHAR c_szOpenAs[]       = TEXT("openas");
const TCHAR c_szDesktopIni[] = STR_DESKTOPINI;   // "desktop.ini"
const TCHAR c_szShell[] = STRREG_SHELL;          // "shell"
const TCHAR c_szDesktop[] = TEXT("Desktop");

// strings for filetypes
const TCHAR c_szCommand[] = TEXT("command");
const TCHAR c_szDefaultIcon[] = TEXT("DefaultIcon");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dataprv.h ===
#ifndef _DATAPRV_H_
#define _DATAPRV_H_
#include "simpdata.h"

// This is the data source object that works from any  IShellFolder.

class CSimpleData : public OLEDBSimpleProvider
{
public:
    CSimpleData(OLEDBSimpleProviderListener **pplisener) : _ppListener(pplisener) { }
    ~CSimpleData();
    
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID, LPVOID FAR*) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // OLEDBSimpleProvider
    STDMETHOD(getRowCount)(DBROWCOUNT *pcRows);
    STDMETHOD(getColumnCount)(DB_LORDINAL *pcColumns);
    STDMETHOD(getRWStatus)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPRW *prwStatus);
    STDMETHOD(getVariant)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT fmt, VARIANT *pVar);
    STDMETHOD(setVariant)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT fmt, VARIANT Var);
    STDMETHOD(getLocale)(BSTR *pbstrLocale);
    STDMETHOD(deleteRows)(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted);
    STDMETHOD(insertRows)(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted);
    STDMETHOD(find)(DBROWCOUNT iRowStart, DB_LORDINAL iColumn, VARIANT val, OSPFIND findFlags, OSPCOMP compType, DBROWCOUNT *piRowFound);
    STDMETHOD(addOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener);
    STDMETHOD(removeOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener);
    STDMETHOD(getEstimatedRows)(DBROWCOUNT *pcRows);
    STDMETHOD(isAsync)(BOOL *pbAsync);
    STDMETHOD(stopTransfer)();

public:
    HRESULT SetShellFolder(IShellFolder *psf);

private:
    HRESULT _DoEnum();

    OLEDBSimpleProviderListener  **_ppListener;
    IShellFolder                 *_psf;
    HDPA                        _hdpa;
};


#endif _DATAPRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dataprv.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "dataprv.h"

// TODO: use IShellDetails instead
const LPCWSTR c_awszColumns[] = 
{
    L"Title",
    L"URL",
};

CSimpleData::~CSimpleData() 
{
    ATOMICRELEASE(_psf);
    DPA_FreeIDArray(_hdpa); // accepts NULL
}

STDMETHODIMP CSimpleData::getRowCount(DBROWCOUNT *pcRows)
{
    *pcRows = 0;

    HRESULT hr = _DoEnum();
    if (SUCCEEDED(hr)) 
        *pcRows = DPA_GetPtrCount(_hdpa);

    return S_OK;
}

STDMETHODIMP CSimpleData::getColumnCount(DB_LORDINAL *pcColumns)
{
    *pcColumns = ARRAYSIZE(c_awszColumns);
    return S_OK;
}

STDMETHODIMP CSimpleData::getRWStatus(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPRW *prwStatus)
{
    *prwStatus = OSPRW_READONLY; 
    return S_OK;
}

STDMETHODIMP CSimpleData::getVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT *pVar)
{
    VariantInit(pVar);
    HRESULT hr = _DoEnum();
    if (FAILED(hr)) 
        return hr;

    hr = E_FAIL;
    if (iColumn > 0 && iColumn <= ARRAYSIZE(c_awszColumns)) 
    {
        if (iRow == 0) 
        {
            pVar->bstrVal = SysAllocString(c_awszColumns[iColumn - 1]);
            pVar->vt = VT_BSTR;
            hr = S_OK;        
        } 
        else if (iRow > 0) 
        {
            if (_psf && _hdpa && ((iRow-1) < DPA_GetPtrCount(_hdpa)))
            {
                LPCITEMIDLIST pidl = (LPCITEMIDLIST)DPA_GetPtr(_hdpa, iRow - 1);
                WCHAR szValue[MAX_PATH];

                switch (iColumn) 
                {
                case 1:
                    hr = DisplayNameOf(_psf, pidl, SHGDN_INFOLDER, szValue, ARRAYSIZE(szValue));
                    break;

                case 2:
                    hr = DisplayNameOf(_psf, pidl, SHGDN_FORPARSING, szValue, ARRAYSIZE(szValue));
                    break;

                default:
                    ASSERT(FAILED(hr));
                    break;
                }

                if (SUCCEEDED(hr))
                {
                    pVar->vt = VT_BSTR;
                    pVar->bstrVal = SysAllocString(szValue);
                }
            }
        }    
    } 

    return hr;
}

STDMETHODIMP CSimpleData::setVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT Var)
{
    return E_NOTIMPL; 
}

STDMETHODIMP CSimpleData::getLocale(BSTR *pbstrLocale)
{
    return E_NOTIMPL;    
}

STDMETHODIMP CSimpleData::deleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSimpleData::insertRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSimpleData::find(DBROWCOUNT iRowStart, DB_LORDINAL iColumn, VARIANT val,
        OSPFIND findFlags, OSPCOMP compType, DBROWCOUNT *piRowFound)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSimpleData::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    IUnknown_Set((IUnknown **)_ppListener, pospIListener);
    return S_OK;    
}

STDMETHODIMP CSimpleData::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    IUnknown_Set((IUnknown **)_ppListener, NULL);
    return S_OK;
}

STDMETHODIMP CSimpleData::getEstimatedRows(DBROWCOUNT *pcRows)
{
    *pcRows = -1;
    return S_OK;
}

STDMETHODIMP CSimpleData::isAsync(BOOL *pbAsync)
{
    *pbAsync = TRUE;
    return S_OK;
}

STDMETHODIMP CSimpleData::stopTransfer()
{
    return E_NOTIMPL;    
}

HRESULT CSimpleData::_DoEnum(void)
{
    HRESULT hr = S_OK;

    if (_hdpa) 
    {
        DPA_FreeIDArray(_hdpa);
        _hdpa = NULL;
    }

    if (_psf) 
    {
        _hdpa = DPA_Create(4);
        if (_hdpa) 
        {
            IEnumIDList* penum;
            hr = _psf->EnumObjects(NULL, SHCONTF_NONFOLDERS | SHCONTF_FOLDERS, &penum);
            if (S_OK == hr) 
            {
                LPITEMIDLIST pidl;
                while (S_OK == penum->Next(1, &pidl, NULL)) 
                {
                    DPA_AppendPtr(_hdpa, pidl);
                }
                penum->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    } 
    else 
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CSimpleData::SetShellFolder(IShellFolder *psf)
{
    IUnknown_Set((IUnknown **)&_psf, psf);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\debug.c ===
#include "shellprv.h"
#pragma  hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shell32"
#define SZ_MODULE           "SHELL32"
#define DECLARE_DEBUG
#include <debug.h>

// Include the standard helper functions to dump common ADTs
#include "..\inc\dump.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defcm.cpp ===
#include "shellprv.h"

#include "ids.h"
#include "pidl.h"
#include "fstreex.h"
#include "views.h"
#include "shlwapip.h"
#include "ole2dup.h"
#include "filetbl.h"
#include "datautil.h"
#include "undo.h"
#include "defview.h"
#include "cowsite.h"
#include "defcm.h"
#include "rpctimeout.h"

#define DEF_FOLDERMENU_MAXHKEYS 16

// used with static defcm elements (pointer from mii.dwItemData)
// and find extensions
typedef struct
{
    WCHAR wszMenuText[MAX_PATH];
    WCHAR wszHelpText[MAX_PATH];
    int   iIcon;
} SEARCHEXTDATA;

typedef struct
{
    SEARCHEXTDATA* psed;
    UINT           idCmd;
} SEARCHINFO;

// Defined in fsmenu.obj
BOOL _MenuCharMatch(LPCTSTR psz, TCHAR ch, BOOL fIgnoreAmpersand);

const ICIVERBTOIDMAP c_sDFMCmdInfo[] = {
    { L"delete",        "delete",       DFM_CMD_DELETE,         DCMIDM_DELETE },
    { c_szCut,          "cut",          DFM_CMD_MOVE,           DCMIDM_CUT },
    { c_szCopy,         "copy",         DFM_CMD_COPY,           DCMIDM_COPY },
    { c_szPaste,        "paste",        DFM_CMD_PASTE,          DCMIDM_PASTE },
    { c_szPaste,        "paste",        DFM_CMD_PASTE,          0 },
    { c_szLink,         "link",         DFM_CMD_LINK,           DCMIDM_LINK },
    { c_szProperties,   "properties",   DFM_CMD_PROPERTIES,     DCMIDM_PROPERTIES },
    { c_szPasteLink,    "pastelink",    DFM_CMD_PASTELINK,      0 },
    { c_szRename,       "rename",       DFM_CMD_RENAME,         DCMIDM_RENAME },
};


CDefBackgroundMenuCB::CDefBackgroundMenuCB(LPCITEMIDLIST pidlFolder) : _cRef(1)
{
    _pidlFolder = ILClone(pidlFolder);  // failure handled in the code 
}

CDefBackgroundMenuCB::~CDefBackgroundMenuCB()
{
    ILFree(_pidlFolder);
}

STDMETHODIMP CDefBackgroundMenuCB::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDefBackgroundMenuCB, IContextMenuCB), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDefBackgroundMenuCB::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDefBackgroundMenuCB::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CDefBackgroundMenuCB::CallBack(IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg) 
    {
    case DFM_MERGECONTEXTMENU_BOTTOM:
        if (!(wParam & (CMF_VERBSONLY | CMF_DVFILE)))
        {
            DWORD dwAttr = SFGAO_HASPROPSHEET;
            if ((NULL == _pidlFolder) ||
                FAILED(SHGetAttributesOf(_pidlFolder, &dwAttr)) ||
                (SFGAO_HASPROPSHEET & dwAttr))
            {
                CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_PROPERTIES_BG, 0, (LPQCMINFO)lParam);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_VALIDATECMD:
        switch (wParam)
        {
        case DFM_CMD_NEWFOLDER:
            break;

        default:
            hr = S_FALSE;
            break;
        }
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_PROPERTIESBG:
            hr = SHPropertiesForUnk(hwndOwner, psf, (LPCTSTR)lParam);
            break;

        default:
            hr = S_FALSE;   // view menu items, use the default
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

class CDefFolderMenu : public CObjectWithSite,
                       public IContextMenu3, 
                       public IServiceProvider,
                       public ISearchProvider,
                       public IShellExtInit
{
    friend HRESULT CDefFolderMenu_CreateHKeyMenu(HWND hwnd, HKEY hkey, IContextMenu **ppcm);
    friend HRESULT CDefFolderMenu_Create2Ex(LPCITEMIDLIST pidlFolder, HWND hwnd,
                             UINT cidl, LPCITEMIDLIST *apidl,
                             IShellFolder *psf, IContextMenuCB *pcmcb, 
                             UINT nKeys, const HKEY *ahkeys, 
                             IContextMenu **ppcm);

public:
    CDefFolderMenu(BOOL fUnderKey);
    HRESULT Init(DEFCONTEXTMENU *pdcm);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType,
                                UINT *pwRes, LPSTR pszName, UINT cchMax);

    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);

    // IServiceProvider
    STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void **ppvObj);

    // ISearchProvider
    STDMETHOD(GetSearchGUID)(GUID *pGuid);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

private:
    ~CDefFolderMenu();

    DWORD   _AttributesOfItems(DWORD dwAttrMask);
    UINT    _AddStatic(HMENU hmenu, UINT idCmd, UINT idCmdLast, HKEY hkey);
    void    _InvokeStatic(UINT iCmd);
    HRESULT _InitDropTarget();
    HRESULT _GetMenuVerb(HMENU hmenu, int idFirst, int idMax, int item, LPWSTR psz, DWORD cch);
    void _UnduplicateVerbs(HMENU hmenu, int idFirst, int idMax);
    void _SetMenuDefault(HMENU hmenu, UINT idCmdFirst, UINT idMax);
    HRESULT _ProcessEditPaste(BOOL fPasteLink);
    HRESULT _ProcessRename();
    void    _DrawItem(DRAWITEMSTRUCT *pdi);
    LRESULT _MeasureItem(MEASUREITEMSTRUCT *pmi);

private:
    LONG            _cRef;           // Reference count
    IDropTarget     *_pdtgt;         // Drop target of selected item
    IContextMenuCB  *_pcmcb;         // Callback object
    IDataObject     *_pdtobj;        // Data object
    IShellFolder    *_psf;           // Shell folder
    HWND            _hwnd;           // Owner window
    UINT            _idCmdFirst;     // base id
    UINT            _idStdMax;       // standard commands (cut/copy/delete/properties) ID MAX
    UINT            _idFolderMax;    // Folder command ID MAX
    UINT            _idVerbMax;      // Add-in command (verbs) ID MAX
    UINT            _idDelayInvokeMax;// extensiosn loaded at invoke time
    UINT            _idFld2Max;      // 2nd range of Folder command ID MAX
    HDSA            _hdsaStatics;    // For static menu items.
    HDXA            _hdxa;           // Dynamic menu array
    HDSA            _hdsaCustomInfo; // array of SEARCHINFO's
    LPITEMIDLIST    _pidlFolder;
    LPITEMIDLIST    *_apidl;
    UINT             _cidl;
    IAssociationArray *_paa;
    
    CSafeServiceSite *_psss;
    
    BOOL            _bUnderKeys;        // Data is directly under key, not
                                        // shellex\ContextMenuHandlers
    UINT            _nKeys;             // Number of class keys
    HKEY            _hkeyClsKeys[DEF_FOLDERMENU_MAXHKEYS];  // Class keys

    HMENU           _hmenu;
    UINT            _uFlags;
    BOOL            _bInitMenuPopup; // true if we received WM_INITMENUPOPUP and _uFlags & CMF_FINDHACK
    int             _iStaticInvoked; // index of the invoked static item

    IDMAPFORQCMINFO _idMap;         // our named separator mapping table
};

#define GetFldFirst(this) (_idStdMax + _idCmdFirst)

HRESULT HDXA_FindByCommand(HDXA hdxa, UINT idCmd, REFIID riid, void **ppv);

STDMETHODIMP CDefFolderMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CDefFolderMenu, IContextMenu, IContextMenu3),
        QITABENTMULTI(CDefFolderMenu, IContextMenu2, IContextMenu3),
        QITABENT(CDefFolderMenu, IContextMenu3), 
        QITABENT(CDefFolderMenu, IObjectWithSite), 
        QITABENT(CDefFolderMenu, IServiceProvider),
        QITABENT(CDefFolderMenu, ISearchProvider),
        QITABENT(CDefFolderMenu, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDefFolderMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

CDefFolderMenu::CDefFolderMenu(BOOL fUnderKey)
{
    _cRef = 1;
    _iStaticInvoked = -1;

    _bUnderKeys = fUnderKey;

    _psss = new CSafeServiceSite;
    if (_psss)
        _psss->SetProviderWeakRef(SAFECAST(this, IServiceProvider *));
        
    
    IDLData_InitializeClipboardFormats();

    ASSERT(_pidlFolder == NULL);
    ASSERT(_punkSite == NULL);
}

HRESULT CDefFolderMenu::Init(DEFCONTEXTMENU *pdcm)
{
    _hwnd = pdcm->hwnd;

    _psf = pdcm->psf;
    if (_psf)
        _psf->AddRef();

    _pcmcb = pdcm->pcmcb;
    if (_pcmcb)
    {
        IUnknown_SetSite(_pcmcb, _psss);
        _pcmcb->AddRef();
        _pcmcb->CallBack(_psf, _hwnd, NULL, DFM_ADDREF, 0, 0);
    }

    _paa = pdcm->paa;
    if (_paa)
        _paa->AddRef();
        
    HRESULT hr = CloneIDListArray(pdcm->cidl, pdcm->apidl, &_cidl, &_apidl);
    if (SUCCEEDED(hr) && pdcm->pidlFolder)
    {
        hr = SHILClone(pdcm->pidlFolder, &_pidlFolder);
    }

    if (SUCCEEDED(hr) && _cidl && _psf)
    {
        hr = _psf->GetUIObjectOf(_hwnd, _cidl, (LPCITEMIDLIST *)_apidl, IID_PPV_ARG_NULL(IDataObject, &_pdtobj));
    }

    if (SUCCEEDED(hr))
    {
        _hdxa = HDXA_Create();
        if (NULL == _hdxa)
            hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        if (pdcm->aKeys)
        {
            ASSERT(pdcm->cKeys <= ARRAYSIZE(_hkeyClsKeys));
            for (UINT i = 0; i < pdcm->cKeys; ++i)
            {
                if (pdcm->aKeys[i])
                {
                    // Make a copy of the key for menu's use
                    _hkeyClsKeys[_nKeys] = SHRegDuplicateHKey(pdcm->aKeys[i]);
                    if (_hkeyClsKeys[_nKeys])
                    {
                        _nKeys++;
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
            }
        }
        else if (_paa)
        {
            //  we can get it from the _paa
            _nKeys = SHGetAssocKeysEx(_paa, ASSOCELEM_MASK_ENUMCONTEXTMENU, _hkeyClsKeys, ARRAYSIZE(_hkeyClsKeys));
        }
    }
    return hr;
}

void ContextMenuInfo_SetSite(ContextMenuInfo *pcmi, IUnknown *pSite)
{
    // APPCOMPAT: PGP50 can only be QIed for IContextMenu, IShellExtInit, and IUnknown.
    if (!(pcmi->dwCompat & OBJCOMPATF_CTXMENU_LIMITEDQI))
        IUnknown_SetSite((IUnknown*)pcmi->pcm, pSite);
}

CDefFolderMenu::~CDefFolderMenu()
{
    if (_psss)
    {
        _psss->SetProviderWeakRef(NULL);
        _psss->Release();
    }
    
    if (_pcmcb) 
    {
        IUnknown_SetSite(_pcmcb, NULL);
        _pcmcb->CallBack(_psf, _hwnd, NULL, DFM_RELEASE, _idStdMax, 0);
        _pcmcb->Release();
    }

    if (_hdxa) 
    {
        for (int i = 0; i < DSA_GetItemCount(_hdxa); i++)
        {
            ContextMenuInfo_SetSite((ContextMenuInfo *)DSA_GetItemPtr(_hdxa, i), NULL);
        }

        HDXA_Destroy(_hdxa);
    }

    ATOMICRELEASE(_psf);
    ATOMICRELEASE(_pdtgt);
    ATOMICRELEASE(_pdtobj);
    ATOMICRELEASE(_paa);

    for (UINT i = 0; i < _nKeys; i++)
    {
        RegCloseKey(_hkeyClsKeys[i]);
    }

    FreeIDListArray(_apidl, _cidl);
    _cidl = 0;
    _apidl = NULL;

    // if _bInitMenuPopup = true then we changed the dwItemData of the non static items
    // so we have to free them. otherwise don't touch them
    if (_hdsaCustomInfo)
    {
        // remove the custom data structures hanging off mii.dwItemData of static menu items
        // or all items if _uFlags & CMF_FINDHACK
        int cItems = DSA_GetItemCount(_hdsaCustomInfo);

        for (int i = 0; i < cItems; i++)
        {
            SEARCHINFO* psinfo = (SEARCHINFO*)DSA_GetItemPtr(_hdsaCustomInfo, i);
            ASSERT(psinfo);
            SEARCHEXTDATA* psed = psinfo->psed;

            if (psed)
                LocalFree(psed);
        }
        DSA_Destroy(_hdsaCustomInfo);
    }

    if (_hdsaStatics)
        DSA_Destroy(_hdsaStatics);

    ILFree(_pidlFolder);
}

STDMETHODIMP_(ULONG) CDefFolderMenu::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

int _SHMergePopupMenus(HMENU hmMain, HMENU hmMerge, int idCmdFirst, int idCmdLast)
{
    int i, idMax = idCmdFirst;

    for (i = GetMenuItemCount(hmMerge) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID|MIIM_SUBMENU;
        mii.cch = 0;     // just in case

        if (GetMenuItemInfo(hmMerge, i, TRUE, &mii))
        {
            int idTemp = Shell_MergeMenus(_GetMenuFromID(hmMain, mii.wID),
                mii.hSubMenu, (UINT)0, idCmdFirst, idCmdLast,
                MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
            if (idMax < idTemp)
                idMax = idTemp;
        }
    }

    return idMax;
}


void CDefFolderMenu_MergeMenu(HINSTANCE hinst, UINT idMainMerge, UINT idPopupMerge, QCMINFO *pqcm)
{
    UINT idMax = pqcm->idCmdFirst;

    if (idMainMerge)
    {
        HMENU hmMerge = SHLoadPopupMenu(hinst, idMainMerge);
        if (hmMerge)
        {
            idMax = Shell_MergeMenus(
                    pqcm->hmenu, hmMerge, pqcm->indexMenu,
                    pqcm->idCmdFirst, pqcm->idCmdLast,
                    MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS | MM_DONTREMOVESEPS);
                
            DestroyMenu(hmMerge);
        }
    }

    if (idPopupMerge)
    {
        HMENU hmMerge = LoadMenu(hinst, MAKEINTRESOURCE(idPopupMerge));
        if (hmMerge)
        {
            UINT idTemp = _SHMergePopupMenus(pqcm->hmenu, hmMerge,
                    pqcm->idCmdFirst, pqcm->idCmdLast);
            if (idMax < idTemp)
                idMax = idTemp;

            DestroyMenu(hmMerge);
        }
    }

    pqcm->idCmdFirst = idMax;
}

DWORD CDefFolderMenu::_AttributesOfItems(DWORD dwAttrMask)
{
    if (!_psf || !_cidl || FAILED(_psf->GetAttributesOf(_cidl, (LPCITEMIDLIST *)_apidl, &dwAttrMask)))
        dwAttrMask = 0;
        
    return dwAttrMask;
}

void _DisableRemoveMenuItem(HMENU hmInit, UINT uID, BOOL bAvail, BOOL bRemoveUnavail)
{
    if (bAvail)
    {
        EnableMenuItem(hmInit, uID, MF_ENABLED|MF_BYCOMMAND);
    }
    else if (bRemoveUnavail)
    {
        DeleteMenu(hmInit, uID, MF_BYCOMMAND);
    }
    else
    {
        EnableMenuItem(hmInit, uID, MF_GRAYED|MF_BYCOMMAND);
    }
}

// Enable/disable menuitems in the "File" & popup context menu

void Def_InitFileCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst, BOOL bContext)
{
    idCmdFirst -= SFVIDM_FIRST;

    _DisableRemoveMenuItem(hmInit, SFVIDM_FILE_RENAME     + idCmdFirst, dwAttr & SFGAO_CANRENAME, bContext);
    _DisableRemoveMenuItem(hmInit, SFVIDM_FILE_DELETE     + idCmdFirst, dwAttr & SFGAO_CANDELETE, bContext);
    _DisableRemoveMenuItem(hmInit, SFVIDM_FILE_LINK       + idCmdFirst, dwAttr & SFGAO_CANLINK,   bContext);
    _DisableRemoveMenuItem(hmInit, SFVIDM_FILE_PROPERTIES + idCmdFirst, dwAttr & SFGAO_HASPROPSHEET, bContext);
}

STDAPI_(BOOL) IsClipboardOwnerHung(DWORD dwTimeout)
{
    HWND hwnd = GetClipboardOwner();
    if (!hwnd)
        return FALSE;

    DWORD_PTR dwResult;
    return !SendMessageTimeout(hwnd, WM_NULL, 0, 0, SMTO_ABORTIFHUNG, dwTimeout, &dwResult);
}

STDAPI_(BOOL) Def_IsPasteAvailable(IDropTarget *pdtgt, DWORD *pdwEffect)
{
    BOOL fRet = FALSE;

    *pdwEffect = 0;     // assume none

    // Count the number of clipboard formats available, if there are none then there
    // is no point making the clipboard available.
    
    if (pdtgt && (CountClipboardFormats() > 0))
    {
        DECLAREWAITCURSOR;

        SetWaitCursor();

        // The clipboard owner might be hung, so time him out if he takes too long.
        // We don't want context menus to hang just because some app is hung.
        CRPCTimeout rpctimeout;

        IDataObject *pdtobj;
        if (!IsClipboardOwnerHung(1000) && SUCCEEDED(OleGetClipboard(&pdtobj)))
        {
            POINTL pt = {0, 0};
            DWORD dwEffectOffered = DataObj_GetDWORD(pdtobj, g_cfPreferredDropEffect, DROPEFFECT_COPY | DROPEFFECT_LINK);

            // Unfortunately, OLE turns RPC errors into generic errors
            // so we can't use the HRESULT from IDataObject::GetData
            // to tell whether the object is alive and doesn't support
            // PreferredDropEffect or is hung and OLE turned the
            // error code into DV_E_FORMATETC.  So see if our timeout fired.
            // This is not foolproof because OLE sometimes caches the "is
            // the data object hung" state and returns error immediately
            // instead of timing out.  But it's better than nothing.
            if (rpctimeout.TimedOut())
            {
                dwEffectOffered = 0;
            }

            // Check if we can paste.
            DWORD dwEffect = (dwEffectOffered & (DROPEFFECT_MOVE | DROPEFFECT_COPY));
            if (dwEffect)
            {
                if (SUCCEEDED(pdtgt->DragEnter(pdtobj, MK_RBUTTON, pt, &dwEffect)))
                {
                    pdtgt->DragLeave();
                }
                else
                {
                    dwEffect = 0;
                }
            }

            // Check if we can past-link.
            DWORD dwEffectLink = (dwEffectOffered & DROPEFFECT_LINK);
            if (dwEffectLink)
            {
                if (SUCCEEDED(pdtgt->DragEnter(pdtobj, MK_RBUTTON, pt, &dwEffectLink)))
                {
                    pdtgt->DragLeave();
                    dwEffect |= dwEffectLink;
                }
            }

            fRet = (dwEffect & (DROPEFFECT_MOVE | DROPEFFECT_COPY));
            *pdwEffect = dwEffect;

            pdtobj->Release();
        }
        ResetWaitCursor();
    }

    return fRet;
}

void Def_InitEditCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst, IDropTarget *pdtgt, UINT fContext)
{
    DWORD dwEffect = 0;
    TCHAR szMenuText[80];

    idCmdFirst -= SFVIDM_FIRST;

    // Do the UNDO stuff only if the menu has an Undo option
    if (GetMenuState(hmInit, SFVIDM_EDIT_UNDO + idCmdFirst, MF_BYCOMMAND) != 0xFFFFFFFF)
    {
        // enable undo if there's an undo history
        BOOL bEnableUndo = IsUndoAvailable();
        if (bEnableUndo)
        {
            GetUndoText(szMenuText, ARRAYSIZE(szMenuText), UNDO_MENUTEXT);
        }
        else
        {
            szMenuText[0] = 0;
            LoadString(HINST_THISDLL, IDS_UNDOMENU, szMenuText, ARRAYSIZE(szMenuText));
        }

        if (szMenuText[0])
        {
            ModifyMenu(hmInit, SFVIDM_EDIT_UNDO + idCmdFirst, MF_BYCOMMAND | MF_STRING,
                       SFVIDM_EDIT_UNDO + idCmdFirst, szMenuText);
        }
        _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_UNDO  + idCmdFirst, bEnableUndo, fContext);
    }

    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_CUT   + idCmdFirst,  dwAttr & SFGAO_CANMOVE, fContext);
    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_COPY  + idCmdFirst, dwAttr & SFGAO_CANCOPY, fContext);

    // Never remove the "Paste" command
    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_PASTE + idCmdFirst, Def_IsPasteAvailable(pdtgt, &dwEffect), fContext & DIEC_SELECTIONCONTEXT);
    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_PASTELINK + idCmdFirst, dwEffect & DROPEFFECT_LINK, fContext & DIEC_SELECTIONCONTEXT);

    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_MOVETO + idCmdFirst, dwAttr & SFGAO_CANMOVE, fContext);
    _DisableRemoveMenuItem(hmInit, SFVIDM_EDIT_COPYTO + idCmdFirst, dwAttr & SFGAO_CANCOPY, fContext);
}

int Static_ExtractIcon(HKEY hkeyMenuItem)
{
    HKEY hkeyDefIcon;
    int iImage = -1;

    if (RegOpenKey(hkeyMenuItem, c_szDefaultIcon, &hkeyDefIcon) == ERROR_SUCCESS)
    {
        TCHAR szDefIcon[MAX_PATH];
        DWORD cb = sizeof(szDefIcon);

        if (SHQueryValueEx(hkeyDefIcon, NULL, NULL, NULL, (BYTE*)szDefIcon, &cb) == ERROR_SUCCESS)
        {
            iImage = Shell_GetCachedImageIndex(szDefIcon, PathParseIconLocation(szDefIcon), 0);
        }
        RegCloseKey(hkeyDefIcon);
    }
    return iImage;
}

typedef struct
{
    CLSID clsid;
    UINT idCmd;
    UINT idMenu;        // used in cleanup
    GUID  guidSearch;   //used with search extensions only
} STATICITEMINFO;

#define LAST_ITEM  (int)0x7FFFFFFF

UINT CDefFolderMenu::_AddStatic(HMENU hmenu, UINT idCmd, UINT idCmdLast, HKEY hkey)
{
    if (idCmd > idCmdLast)
    {
        DebugMsg(DM_ERROR, TEXT("si_a: Out of command ids!"));
        return idCmd;
    }

    ASSERT(!_hdsaStatics);
    ASSERT(!_hdsaCustomInfo);

    HDSA hdsaCustomInfo = DSA_Create(sizeof(SEARCHINFO), 1);
    // Create a hdsaStatics.
    HDSA hdsaStatics = DSA_Create(sizeof(STATICITEMINFO), 1);
    if (hdsaStatics && hdsaCustomInfo)
    {
        HKEY hkeyStatic;
        // Try to open the "Static" subkey.
        if (RegOpenKey(hkey, TEXT("Static"), &hkeyStatic) == ERROR_SUCCESS)
        {
            TCHAR szClass[MAX_PATH];
            BOOL bFindFilesInserted = FALSE;

            // For each subkey of static.
            for (int i = 0; RegEnumKey(hkeyStatic, i, szClass, ARRAYSIZE(szClass)) == ERROR_SUCCESS; i++)
            {
                HKEY hkeyClass;

                // Record the GUID.
                if (RegOpenKey(hkeyStatic, szClass, &hkeyClass) == ERROR_SUCCESS)
                {
                    TCHAR szCLSID[MAX_PATH];
                    DWORD cb = sizeof(szCLSID);
                    // HACKHACK: (together with bWebSearchInserted above
                    // we need to have On the Internet as the first menu item
                    // and Find Files or Folders as second
                    BOOL bWebSearch = lstrcmp(szClass, TEXT("WebSearch")) == 0;
                    BOOL bFindFiles = FALSE;

                    if (SHQueryValueEx(hkeyClass, NULL, NULL, NULL, (BYTE*)szCLSID, &cb) == ERROR_SUCCESS)
                    {
                        HKEY hkeyMenuItem;
                        TCHAR szSubKey[32];

                        // enum the sub keys 0..N
                        for (int iMenuItem = 0; wnsprintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%d"), iMenuItem),
                             RegOpenKey(hkeyClass, szSubKey, &hkeyMenuItem) == ERROR_SUCCESS; 
                             iMenuItem++)
                        {
                            TCHAR szMenuText[MAX_PATH];
                            if (SUCCEEDED(SHLoadLegacyRegUIString(hkeyMenuItem, NULL, szMenuText, ARRAYSIZE(szMenuText))))
                            {
                                STATICITEMINFO sii;
                                SEARCHINFO sinfo;
                                
                                TCHAR szHelpText[MAX_PATH];
                                SHLoadLegacyRegUIString(hkeyMenuItem, TEXT("HelpText"), szHelpText, ARRAYSIZE(szHelpText));

                                SHCLSIDFromString(szCLSID, &sii.clsid); // store it
                                sii.idCmd = iMenuItem;
                                sii.idMenu = idCmd;

                                // get the search guid if any...
                                TCHAR szSearchGUID[MAX_PATH];
                                cb = sizeof(szSearchGUID);
                                if (SHGetValue(hkeyMenuItem, TEXT("SearchGUID"), NULL, NULL, (BYTE*)szSearchGUID, &cb) == ERROR_SUCCESS)
                                    SHCLSIDFromString(szSearchGUID, &sii.guidSearch);
                                else
                                    sii.guidSearch = GUID_NULL;

                                // cleanup -- allow non-static
                                // find extensions to specify a search guid and then we can
                                // remove this static "Find Computer" business...
                                //
                                // if this is FindComputer item and the restriction is not set 
                                // don't add it to the menu
                                if (IsEqualGUID(sii.guidSearch, SRCID_SFindComputer) &&
                                    !SHRestricted(REST_HASFINDCOMPUTERS))
                                    continue;

                                bFindFiles = IsEqualGUID(sii.guidSearch, SRCID_SFileSearch);
                                if (bFindFiles && SHRestricted(REST_NOFIND))
                                    continue;

                                if (IsEqualGUID(sii.guidSearch, SRCID_SFindPrinter))
                                    continue;
                                    
                                DSA_AppendItem(hdsaStatics, &sii);

                                SEARCHEXTDATA *psed = (SEARCHEXTDATA *)LocalAlloc(LPTR, sizeof(*psed));
                                if (psed)
                                {
                                    psed->iIcon = Static_ExtractIcon(hkeyMenuItem);
                                    SHTCharToUnicode(szHelpText, psed->wszHelpText, ARRAYSIZE(psed->wszHelpText));
                                    SHTCharToUnicode(szMenuText, psed->wszMenuText, ARRAYSIZE(psed->wszMenuText));
                                }

                                MENUITEMINFO mii;
                                mii.cbSize = sizeof(mii);
                                mii.fMask  = MIIM_DATA | MIIM_TYPE | MIIM_ID;
                                mii.fType  = MFT_OWNERDRAW;
                                mii.wID    = idCmd;
                                mii.dwItemData = (DWORD_PTR)psed;

                                sinfo.psed = psed;
                                sinfo.idCmd = idCmd;
                                if (DSA_AppendItem(hdsaCustomInfo, &sinfo) != -1)
                                {      
                                    // insert Files or Folders in the first place (see HACKHACK above)
                                    if (!bFindFilesInserted && bFindFiles)
                                        bFindFilesInserted = InsertMenuItem(hmenu, 0, TRUE, &mii);
                                    else
                                    {
                                        UINT uiPos = LAST_ITEM;

                                        // if this is Find Files or Folders insert it after
                                        // On the Internet or in the first place if OtI is
                                        // not inserted yet
                                        if (bWebSearch)
                                            uiPos = bFindFilesInserted ? 1 : 0;
                                        // we don't free psed if Insert fails because it's 
                                        // in dsa and it's going to be freed on destroy
                                        InsertMenuItem(hmenu, uiPos, TRUE, &mii);
                                    }
                                }

                                // Next command.
                                idCmd++;
                                if (idCmd > idCmdLast)
                                {
                                    DebugMsg(DM_ERROR, TEXT("si_a: Out of command ids!"));
                                    break;
                                }
                            }
                            RegCloseKey(hkeyMenuItem);
                        }
                    }
                    RegCloseKey(hkeyClass);
                }
            }
            RegCloseKey(hkeyStatic);
        }
        _hdsaStatics = hdsaStatics;
        _hdsaCustomInfo = hdsaCustomInfo;
    }
    return idCmd;
}


void CDefFolderMenu::_InvokeStatic(UINT iCmd)
{
    if (_hdsaStatics)
    {
        STATICITEMINFO *psii = (STATICITEMINFO *)DSA_GetItemPtr(_hdsaStatics, iCmd);
        if (psii)
        {
            IContextMenu *pcm;
            if (SUCCEEDED(SHExtCoCreateInstance(NULL, &psii->clsid, NULL, IID_PPV_ARG(IContextMenu, &pcm))))
            {
                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    CMINVOKECOMMANDINFO ici;
                    CHAR szSearchGUID[GUIDSTR_MAX];
                    LPSTR psz = NULL;

                    _iStaticInvoked = iCmd;
                    IUnknown_SetSite(pcm, _psss);

                    pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, CMF_NORMAL);
                    ici.cbSize = sizeof(ici);
                    ici.fMask = 0;
                    ici.hwnd = NULL;
                    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(psii->idCmd);
                    if (!IsEqualGUID(psii->guidSearch, GUID_NULL))
                    {
                        SHStringFromGUIDA(psii->guidSearch, szSearchGUID, ARRAYSIZE(szSearchGUID));
                        psz = szSearchGUID;
                    }
                    ici.lpParameters = psz;
                    ici.lpDirectory = NULL;
                    ici.nShow = SW_NORMAL;
                    pcm->InvokeCommand(&ici);
                    DestroyMenu(hmenu);
                    IUnknown_SetSite(pcm, NULL);
                }
                pcm->Release();
            }
        }
    }
}

HRESULT CDefFolderMenu::_InitDropTarget()
{
    HRESULT hr;
    if (_pdtgt)
        hr = S_OK;  // have cached version
    else
    {
        // try to create _pdtgt
        if (_cidl)
        {
            ASSERT(NULL != _psf); // _pdtobj came from _psf
            hr = _psf->GetUIObjectOf(_hwnd, 1, (LPCITEMIDLIST *)_apidl, IID_PPV_ARG_NULL(IDropTarget, &_pdtgt));
        } 
        else if (_psf)
        {
            hr = _psf->CreateViewObject(_hwnd, IID_PPV_ARG(IDropTarget, &_pdtgt));
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

// Note on context menus ranges:
//  Standard Items // DFM_MERGECONTEXTMENU, context menu extensions, DFM_MERGECONTEXTMENU_TOP
//  Separator
//  View Items   // context menu extensions can get here
//  Separator
//  (defcm S_FALSE "default" items, if applicable)
//  Separator
//  Folder Items // context menu extensions can get here
//  Separator
//  Bottom Items // DFM_MERGECONTEXTMENU_BOTTOM
//  Separator
//  ("File" menu, if applicable)
//
// Defcm uses names separators to do this magic.  Unfortunately _SHPrettyMenu
// removes duplicate separators and we don't always control when that happens.
// So we build up the above empty menu first, and then insert into appropriate ranges.
//
// If you call SHPrepareMenuForDefcm, you must call SHPrettyMenuForDefcm before you return/TrackPopupMenu
//
#define DEFCM_RANGE                 5 // the number of FSIDMs belor
#define IS_VALID_DEFCM_RANGE(idCmdFirst, idCmdLast) (((idCmdLast)-(DEFCM_RANGE))>(idCmdFirst))
#define FSIDM_FOLDER_SEP(idCmdLast) ((idCmdLast)-1)
#define FSIDM_VIEW_SEP(idCmdLast)   ((idCmdLast)-2)
#define FSIDM_PLACE_SEP(idCmdLast)  ((idCmdLast)-3)
#define FSIDM_PLACE_VAL(idCmdLast)  ((idCmdLast)-4)
HRESULT SHPrepareMenuForDefcm(HMENU hmenu, UINT indexMenu, UINT uFlags, UINT idCmdFirst, UINT idCmdLast)
{
    HRESULT hr = S_OK;

    if (!(uFlags & CMF_DEFAULTONLY) && IS_VALID_DEFCM_RANGE(idCmdFirst, idCmdLast))
    {
        UINT uPosView = GetMenuPosFromID(hmenu, FSIDM_VIEW_SEP(idCmdLast));
        UINT uPosFolder = GetMenuPosFromID(hmenu, FSIDM_FOLDER_SEP(idCmdLast));

        if (-1 != uPosView && -1 != uPosFolder)
        {
            // Menu is already set up correctly
        }
        else if (-1 == uPosView && -1 == uPosFolder)
        {
            // Insert everything backwords at position indexMenu
            //
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION, FSIDM_PLACE_VAL(idCmdLast), TEXT("placeholder"));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_PLACE_SEP(idCmdLast), TEXT(""));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION, FSIDM_PLACE_VAL(idCmdLast), TEXT("placeholder"));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_FOLDER_SEP(idCmdLast), TEXT(""));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION, FSIDM_PLACE_VAL(idCmdLast), TEXT("placeholder"));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_PLACE_SEP(idCmdLast), TEXT(""));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION, FSIDM_PLACE_VAL(idCmdLast), TEXT("placeholder"));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_VIEW_SEP(idCmdLast), TEXT(""));
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION, FSIDM_PLACE_VAL(idCmdLast), TEXT("placeholder"));

            hr = S_FALSE;
        }
        else
        {
            TraceMsg(TF_ERROR, "Some context menu removed a single named separator, we're in a screwy state");

            if (-1 == uPosFolder)
                InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_FOLDER_SEP(idCmdLast), TEXT(""));
            if (-1 == uPosView)
            {
                InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_PLACE_SEP(idCmdLast), TEXT(""));
                InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, FSIDM_VIEW_SEP(idCmdLast), TEXT(""));
            }
        }
    }

    return hr;
}

HRESULT SHPrettyMenuForDefcm(HMENU hmenu, UINT uFlags, UINT idCmdFirst, UINT idCmdLast, HRESULT hrPrepare)
{
    if (!(uFlags & CMF_DEFAULTONLY) && IS_VALID_DEFCM_RANGE(idCmdFirst, idCmdLast))
    {
        if (S_FALSE == hrPrepare)
        {
            while (DeleteMenu(hmenu, FSIDM_PLACE_VAL(idCmdLast), MF_BYCOMMAND))
            {
                // Remove all our non-separator menu items
            }
        }
    }

    _SHPrettyMenu(hmenu);

    return S_OK;
}

HRESULT SHUnprepareMenuForDefcm(HMENU hmenu, UINT idCmdFirst, UINT idCmdLast)
{
    if (IS_VALID_DEFCM_RANGE(idCmdFirst, idCmdLast))
    {
        // Remove all the named separators we may have added
        DeleteMenu(hmenu, FSIDM_VIEW_SEP(idCmdLast), MF_BYCOMMAND);
        DeleteMenu(hmenu, FSIDM_FOLDER_SEP(idCmdLast), MF_BYCOMMAND);
        while (DeleteMenu(hmenu, FSIDM_PLACE_SEP(idCmdLast), MF_BYCOMMAND))
        {
            // Remove all our placeholder separators
        }
    }

    return S_OK;
}

void CDefFolderMenu::_SetMenuDefault(HMENU hmenu, UINT idCmdFirst, UINT idMax)
{
    // we are about to set the default menu id, give the callback a chance
    // to override and set one of the static entries instead of the
    // first entry in the menu.

    WPARAM idStatic;
    if (_pcmcb && SUCCEEDED(_pcmcb->CallBack(_psf, _hwnd, _pdtobj,
                                             DFM_GETDEFSTATICID, 
                                             0, (LPARAM)&idStatic)))
    {
        for (int i = 0; i < ARRAYSIZE(c_sDFMCmdInfo); i++)
        {
            if (idStatic == c_sDFMCmdInfo[i].idDFMCmd)
            {
                SetMenuDefaultItem(hmenu, idCmdFirst + c_sDFMCmdInfo[i].idDefCmd, MF_BYCOMMAND);
                break;
            }
        }
    }

    if (GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0) == -1)
    {
        int i = 0;
        int cMenu = GetMenuItemCount(hmenu);
        for (; i < cMenu; i++)
        {
            //  fallback to openas so that files that have progids
            //  dont endup using AFSO or * for their default verbs
            WCHAR szi[CCH_KEYMAX];
            HRESULT hr = _GetMenuVerb(hmenu, idCmdFirst, idMax, i, szi, ARRAYSIZE(szi));
            if (hr == S_OK && *szi && 0 == StrCmpI(szi, TEXT("openas")))
            {
                SetMenuDefaultItem(hmenu, i, MF_BYPOSITION);
                break;
            }
        }

        if (i == cMenu)
        {
            ASSERT(GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0) == -1);
            SetMenuDefaultItem(hmenu, 0, MF_BYPOSITION);
        }
    }
}

STDMETHODIMP CDefFolderMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    QCMINFO qcm = { hmenu, indexMenu, idCmdFirst, idCmdLast };
    DECLAREWAITCURSOR;
    BOOL fUseDefExt;

    SetWaitCursor();

    _idCmdFirst = idCmdFirst;
    _hmenu = hmenu;
    _uFlags = uFlags;
    _bInitMenuPopup = FALSE;

    // Set up the menu for defcm
    HRESULT hrPrepare = SHPrepareMenuForDefcm(hmenu, indexMenu, uFlags, idCmdFirst, idCmdLast);

    if (IS_VALID_DEFCM_RANGE(idCmdFirst, idCmdLast))
    {
        _idMap.max = 2;
        _idMap.list[0].id = FSIDM_FOLDER_SEP(idCmdLast);
        _idMap.list[0].fFlags = QCMINFO_PLACE_BEFORE;
        _idMap.list[1].id = FSIDM_VIEW_SEP(idCmdLast);
        _idMap.list[1].fFlags = QCMINFO_PLACE_AFTER;

        qcm.pIdMap = (const QCMINFO_IDMAP *)&_idMap;

        qcm.idCmdLast = idCmdLast - DEFCM_RANGE;
    }

    // first add in the folder commands like cut/copy/paste
    if (_pdtobj && !(uFlags & (CMF_VERBSONLY | CMF_DVFILE)))
    {
        if (!(CMF_DEFAULTONLY & uFlags))
        {
            ATOMICRELEASE(_pdtgt);  // If we previously got the drop target, release it.
            _InitDropTarget();      // ignore failure, NULL _pdtgt is handled below
        }

        // We're going to merge two HMENUs into the context menu,
        // but we want only one id range for them...  Remember the idCmdFirst.
        //
        UINT idCmdFirstTmp = qcm.idCmdFirst;

        UINT indexMenuTmp = qcm.indexMenu;

        UINT uPos = GetMenuPosFromID(hmenu, FSIDM_FOLDER_SEP(idCmdLast));

        // POPUP_DCM_ITEM2 goes after FSIDM_FOLDER_SEP(idCmdLast)
        if (-1 != uPos)
            qcm.indexMenu = uPos + 1;
        CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DCM_ITEM2, 0, &qcm);

        UINT idCmdFirstMax = qcm.idCmdFirst;
        qcm.idCmdFirst = idCmdFirstTmp;

        // POPUP_DCM_ITEM goes TWO before FSIDM_FOLDER_SEP(idCmdLast)
        if (-1 != uPos)
            qcm.indexMenu = uPos - 1;
        CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DCM_ITEM, 0, &qcm);

        qcm.indexMenu = indexMenuTmp;

        qcm.idCmdFirst = max(idCmdFirstTmp, qcm.idCmdFirst);

        ULONG dwAttr = _AttributesOfItems(
                    SFGAO_CANRENAME | SFGAO_CANDELETE |
                    SFGAO_CANLINK   | SFGAO_HASPROPSHEET |
                    SFGAO_CANCOPY   | SFGAO_CANMOVE);

        if (!(uFlags & CMF_CANRENAME))
            dwAttr &= ~SFGAO_CANRENAME;

        Def_InitFileCommands(dwAttr, hmenu, idCmdFirst, TRUE);

        // Don't try to figure out paste if we're just going to invoke the default
        // (Figuring out paste is expensive)
        if (CMF_DEFAULTONLY & uFlags)
        {
            ASSERT(_pdtgt == NULL);
        }

        Def_InitEditCommands(dwAttr, hmenu, idCmdFirst, _pdtgt, DIEC_SELECTIONCONTEXT);
    }

    _idStdMax = qcm.idCmdFirst - idCmdFirst;

    // DFM_MERGECONTEXTMENU returns S_FALSE if we should not add any verbs.
    if (_pcmcb) 
    {
        HRESULT hr = _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_MERGECONTEXTMENU, uFlags, (LPARAM)&qcm);
        fUseDefExt = (hr == S_OK);
        UINT indexMenuTmp = qcm.indexMenu;
        UINT uPos = GetMenuPosFromID(hmenu, FSIDM_FOLDER_SEP(idCmdLast));
        if (-1 != uPos)
            qcm.indexMenu = uPos + 1;
        hr = _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_MERGECONTEXTMENU_BOTTOM, uFlags, (LPARAM)&qcm);
        if (!fUseDefExt)
            fUseDefExt = (hr == S_OK);
        qcm.indexMenu = indexMenuTmp;
    }
    else 
    {
        fUseDefExt = FALSE;
    }

    _idFolderMax = qcm.idCmdFirst - idCmdFirst;
    // add registry verbs
    if ((!(uFlags & CMF_NOVERBS)) ||
        (!_pdtobj && !_psf && _nKeys)) // this second case is for find extensions
    {
        // HACK: Default Extenstions EXPECT a selection, Let's hope all don't
        if (!_pdtobj)
            fUseDefExt = FALSE;

        // Put the separator between container menuitems and object menuitems
        // only if we don't have the separator at the insertion point.
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE;
        mii.fType = MFT_SEPARATOR;              // to avoid ramdom result.
        if (GetMenuItemInfo(hmenu, indexMenu, TRUE, &mii) && !(mii.fType & MFT_SEPARATOR))
        {
            InsertMenu(hmenu, indexMenu, MF_BYPOSITION | MF_SEPARATOR, (UINT)-1, NULL);
        }

        HDCA hdca = DCA_Create();
        if (hdca)
        {
            // Add default extensions, only if the folder callback returned
            // S_OK. The Printer and Control folder returns S_FALSE
            // indicating that they don't need any default extension.

            if (fUseDefExt)
            {
                // Always add this default extention at the top.
                DCA_AddItem(hdca, CLSID_ShellFileDefExt);
            }

            // Append menus for all extensions
            for (UINT nKeys = 0; nKeys < _nKeys; ++nKeys)
            {
                DCA_AddItemsFromKey(hdca, _hkeyClsKeys[nKeys],
                        _bUnderKeys ? NULL : STRREG_SHEX_MENUHANDLER);
            }
            // Work Around:
            // first time we call this _hdxa is empty            
            // after that it has the same items as before but will not add any new ones
            // if user keeps right clicking we will eventually run out of menu item ids
            // read comment in HDXA_AppendMenuItems2. to prevent it we empty _hdxa
            HDXA_DeleteAll(_hdxa);

            // (lamadio) For background context menu handlers, the pidlFolder 
            // should be a valid pidl, but, for backwards compatilility, this 
            // parameter should be NULL, if the Dataobject is NOT NULL.

            qcm.idCmdFirst = HDXA_AppendMenuItems2(_hdxa, _pdtobj,
                            _nKeys, _hkeyClsKeys,
                            !_pdtobj ? _pidlFolder : NULL, 
                            &qcm, uFlags, hdca, _psss);

            DCA_Destroy(hdca);
        }

        _idVerbMax = qcm.idCmdFirst - idCmdFirst;

        // menu extensions that are loaded at invoke time
        if (uFlags & CMF_INCLUDESTATIC)
        {
            qcm.idCmdFirst = _AddStatic(hmenu, qcm.idCmdFirst, qcm.idCmdLast, _hkeyClsKeys[0]);
        }
        _idDelayInvokeMax = qcm.idCmdFirst - idCmdFirst;

        // Remove the separator if we did not add any.
        if (_idDelayInvokeMax == _idFolderMax)
        {
            if (GetMenuState(hmenu, 0, MF_BYPOSITION) & MF_SEPARATOR)
                DeleteMenu(hmenu, 0, MF_BYPOSITION);
        }
    }

    // if no default menu got set, choose the first one.
    if (_pdtobj && !(uFlags & CMF_NODEFAULT) &&
        GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0) == -1)
    {
        _SetMenuDefault(hmenu, idCmdFirst, qcm.idCmdFirst);
    }

    // And now we give the callback the option to put (more) commands on top
    // of everything else
    if (_pcmcb)
        _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_MERGECONTEXTMENU_TOP, uFlags, (LPARAM)&qcm);

    _idFld2Max = qcm.idCmdFirst - idCmdFirst;

    SHPrettyMenuForDefcm(hmenu, uFlags, idCmdFirst, idCmdLast, hrPrepare);

    _UnduplicateVerbs(hmenu, idCmdFirst, qcm.idCmdFirst);
    
    ResetWaitCursor();

    return ResultFromShort(_idFld2Max);
}

HRESULT CDefFolderMenu::_GetMenuVerb(HMENU hmenu, int idFirst, int idMax, int item, LPWSTR psz, DWORD cch)
{
    MENUITEMINFO mii = {0};
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE | MIIM_ID;
    *psz = 0;
    if (GetMenuItemInfo(hmenu, item, TRUE, &mii)
    && ((int)mii.wID >= idFirst && (int)mii.wID < idMax))
    {
        if (mii.fType & MFT_SEPARATOR)
            return S_FALSE;
        else
            return GetCommandString(mii.wID - idFirst, GCS_VERBW, NULL, (LPSTR)psz, cch);
    }
    return E_FAIL;
}

void CDefFolderMenu::_UnduplicateVerbs(HMENU hmenu, int idFirst, int idMax)
{
    HRESULT hr = S_OK;
    int iDefault = GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0);
    for (int i = 0; i < GetMenuItemCount(hmenu); i++)
    {
        WCHAR szi[CCH_KEYMAX];
        hr = _GetMenuVerb(hmenu, idFirst, idMax, i, szi, ARRAYSIZE(szi));
        if (hr == S_OK && *szi)
        {
            for (int j = i + 1; j < GetMenuItemCount(hmenu); j++)
            {
                WCHAR szj[CCH_KEYMAX];
                hr = _GetMenuVerb(hmenu, idFirst, idMax, j, szj, ARRAYSIZE(szj));
                if (hr == S_OK && *szj)
                {
                    if (0 == StrCmpIW(szj, szi))
                    {
                        if (j != iDefault)
                        {
                            DeleteMenu(hmenu, j, MF_BYPOSITION);
                            j--;
                        }
                    }
                }
            }
        }
    }
}

HRESULT CDefFolderMenu::_ProcessEditPaste(BOOL fPasteLink)
{
    DECLAREWAITCURSOR;

    SetWaitCursor();

    HRESULT hr = _InitDropTarget();
    if (SUCCEEDED(hr))
    {
        IDataObject *pdtobj;
        hr = OleGetClipboard(&pdtobj);
        if (SUCCEEDED(hr))
        {
            DWORD grfKeyState;
            DWORD dwEffect = DataObj_GetDWORD(pdtobj, g_cfPreferredDropEffect, DROPEFFECT_COPY | DROPEFFECT_LINK);

            if (fPasteLink) 
            {
                // MK_FAKEDROP to avoid drag/drop pop up menu
                grfKeyState = MK_LBUTTON | MK_CONTROL | MK_SHIFT | MK_FAKEDROP;
                dwEffect &= DROPEFFECT_LINK;
            } 
            else
            {
                grfKeyState = MK_LBUTTON;
                dwEffect &= ~DROPEFFECT_LINK;
            }

            hr = SimulateDropWithPasteSucceeded(_pdtgt, pdtobj, grfKeyState, NULL, dwEffect, _psss, TRUE);

            pdtobj->Release();
        }
    }
    ResetWaitCursor();

    if (FAILED(hr))
        MessageBeep(0);

    return hr;
}

HRESULT CDefFolderMenu::_ProcessRename()
{
    IDefViewFrame3 *dvf3;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_DefView, IID_PPV_ARG(IDefViewFrame3, &dvf3));
    if (SUCCEEDED(hr))
    {
        hr = dvf3->DoRename();
        dvf3->Release();
    }
    return hr;
}

// deal with the versioning of this structure...

void CopyInvokeInfo(CMINVOKECOMMANDINFOEX *pici, const CMINVOKECOMMANDINFO *piciIn)
{
    ASSERT(piciIn->cbSize >= sizeof(*piciIn));

    ZeroMemory(pici, sizeof(*pici));
    memcpy(pici, piciIn, min(sizeof(*pici), piciIn->cbSize));
    pici->cbSize = sizeof(*pici);
}

#ifdef UNICODE        
#define IS_UNICODE_ICI(pici) ((pici->cbSize >= CMICEXSIZE_NT4) && ((pici->fMask & CMIC_MASK_UNICODE) == CMIC_MASK_UNICODE))
#else
#define IS_UNICODE_ICI(pici) (FALSE)
#endif

typedef int (WINAPI * PFN_LSTRCMPIW)(LPCWSTR, LPCWSTR);
HRESULT SHMapICIVerbToCmdID(LPCMINVOKECOMMANDINFO pici, const ICIVERBTOIDMAP* pmap, UINT cmap, UINT* pid)
{
    HRESULT hr = E_FAIL;

    if (!IS_INTRESOURCE(pici->lpVerb))
    {
        PFN_LSTRCMPIW pfnCompare;
        LPCWSTR pszVerb;
        BOOL fUnicode;

        if (IS_UNICODE_ICI(pici) && ((LPCMINVOKECOMMANDINFOEX)pici)->lpVerbW)
        {
            pszVerb = ((LPCMINVOKECOMMANDINFOEX)pici)->lpVerbW;
            pfnCompare = lstrcmpiW;
            fUnicode = TRUE;
        }
        else
        {
            pszVerb = (LPCWSTR)(pici->lpVerb);
            pfnCompare = (PFN_LSTRCMPIW)lstrcmpiA;
            fUnicode = FALSE;
        }
            
        for (UINT i = 0; i < cmap ; i++)
        {
            LPCWSTR pszCompare = (fUnicode) ? pmap[i].pszCmd : (LPCWSTR)(pmap[i].pszCmdA);
            if (!pfnCompare(pszVerb, pszCompare))
            {
                *pid = pmap[i].idDFMCmd;
                hr = S_OK;
                break;
            }
        }
    }
    else
    {
        *pid = LOWORD((UINT_PTR)pici->lpVerb);
        hr = S_OK;
    }
    
    return hr;
}

HRESULT SHMapCmdIDToVerb(UINT_PTR idCmd, const ICIVERBTOIDMAP* pmap, UINT cmap, LPSTR pszName, UINT cchMax, BOOL bUnicode)
{
    LPCWSTR pszNull = L"";
    LPCSTR pszVerb = (LPCSTR)pszNull;

    for (UINT i = 0 ; i < cmap ; i++)
    {
        if (pmap[i].idDefCmd == idCmd)
        {
            pszVerb = (bUnicode) ? (LPCSTR)pmap[i].pszCmd : pmap[i].pszCmdA;
            break;
        }
    }

    if (bUnicode)
        StrCpyNW((LPWSTR)pszName, (LPWSTR)pszVerb, cchMax);
    else
        StrCpyNA(pszName, pszVerb, cchMax);

    return (pszVerb == (LPCSTR)pszNull) ? E_NOTIMPL : S_OK;
}


STDMETHODIMP CDefFolderMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = S_OK;
    UINT idCmd = (UINT)-1;
    UINT idCmdLocal;  // this is used within each if block for the local idCmd value
    LPCMINVOKECOMMANDINFOEX picix = (LPCMINVOKECOMMANDINFOEX)pici; // This value is only usable when fCmdInfoEx is true

    BOOL fUnicode = IS_UNICODE_ICI(pici);

    if (pici->cbSize < sizeof(CMINVOKECOMMANDINFO))
        return E_INVALIDARG;

    if (!IS_INTRESOURCE(pici->lpVerb))
    {
        if (SUCCEEDED(SHMapICIVerbToCmdID(pici, c_sDFMCmdInfo, ARRAYSIZE(c_sDFMCmdInfo), &idCmdLocal)))
        {
            // We need to use goto because idFolderMax might not be initialized
            // yet (QueryContextMenu might have not been called).
            goto ProcessCommand;
        }

        // see if this is a command provided by name by the callback
        LPCTSTR pszVerb;
        WCHAR szVerb[MAX_PATH];
        if (!fUnicode || picix->lpVerbW == NULL)
        {
            SHAnsiToUnicode(picix->lpVerb, szVerb, ARRAYSIZE(szVerb));
            pszVerb = szVerb;
        }
        else
            pszVerb = picix->lpVerbW;
        idCmdLocal = idCmd;

        if (*pszVerb && SUCCEEDED(_pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_MAPCOMMANDNAME, (WPARAM)&idCmdLocal, (LPARAM)pszVerb)))
        {
            goto ProcessCommand;
        }

        // we need to give the verbs a chance in case they asked for it by string
        goto ProcessVerb;
    }
    else
    {
        idCmd = LOWORD((UINT_PTR)pici->lpVerb);
    }

    if (idCmd < _idStdMax)
    {
        idCmdLocal = idCmd;

        for (int i = 0; i < ARRAYSIZE(c_sDFMCmdInfo); i++)
        {
            if (idCmdLocal == c_sDFMCmdInfo[i].idDefCmd)
            {
                idCmdLocal = c_sDFMCmdInfo[i].idDFMCmd;
                goto ProcessCommand;
            }
        }

        hr = E_INVALIDARG;
    }
    else if (idCmd < _idFolderMax)
    {
        DFMICS dfmics;
        LPARAM lParam;
        WCHAR szLParamBuffer[MAX_PATH];

        idCmdLocal = idCmd - _idStdMax;
ProcessCommand:

        if (!fUnicode || picix->lpParametersW == NULL)
        {
            if (pici->lpParameters == NULL)
            {
                lParam = (LPARAM)NULL;
            }
            else
            {
                SHAnsiToUnicode(pici->lpParameters, szLParamBuffer, ARRAYSIZE(szLParamBuffer));
                lParam = (LPARAM)szLParamBuffer;
            }
        }
        else
            lParam = (LPARAM)picix->lpParametersW;

        switch (idCmdLocal) 
        {
        case DFM_CMD_LINK:
            if (!fUnicode || picix->lpDirectoryW == NULL)
            {
                if (pici->lpDirectory == NULL)
                {
                    lParam = (LPARAM)NULL;
                }
                else
                {
                    SHAnsiToUnicode(pici->lpDirectory, szLParamBuffer, ARRAYSIZE(szLParamBuffer));
                    lParam = (LPARAM)szLParamBuffer;
                }
            }
            else
                lParam = (LPARAM)picix->lpDirectoryW;
            break;

        case DFM_CMD_PROPERTIES:
             if (SHRestricted(REST_NOVIEWCONTEXTMENU))
             {
                // This is what the NT4 QFE returned, but I wonder
                // if HRESULT_FROM_WIN32(E_ACCESSDENIED) would be better?
                return hr;
             }
             break;
        }

        // try to use a DFM_INVOKECOMMANDEX first so the callback can see
        // the INVOKECOMMANDINFO struct (for stuff like the 'no ui' flag)
        dfmics.cbSize = sizeof(dfmics);
        dfmics.fMask = pici->fMask;
        dfmics.lParam = lParam;
        dfmics.idCmdFirst = _idCmdFirst;
        dfmics.idDefMax = _idStdMax;
        dfmics.pici = pici;

        // this for the property pages to show up right at
        // the POINT where they were activated. 
        if ((idCmdLocal == DFM_CMD_PROPERTIES) && (pici->fMask & CMIC_MASK_PTINVOKE) && _pdtobj)
        {
            ASSERT(pici->cbSize >= sizeof(CMINVOKECOMMANDINFOEX));
            POINT *ppt = (POINT *)GlobalAlloc(GPTR, sizeof(*ppt));
            if (ppt)
            {
                *ppt = picix->ptInvoke;
                if (FAILED(DataObj_SetGlobal(_pdtobj, g_cfOFFSETS, ppt)))
                    GlobalFree(ppt);
            }
        }

        hr = _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_INVOKECOMMANDEX, idCmdLocal, (LPARAM)&dfmics);
        if (hr == E_NOTIMPL)
        {
            // the callback didn't understand the DFM_INVOKECOMMANDEX
            // fall back to a regular DFM_INVOKECOMMAND instead
            hr = _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_INVOKECOMMAND, idCmdLocal, lParam);
        }

        // Check if we need to execute the default code.
        if (hr == S_FALSE)
        {
            hr = S_OK;     // assume no error

            if (_pdtobj)
            {
                switch (idCmdLocal) 
                {
                case DFM_CMD_MOVE:
                case DFM_CMD_COPY:
                    DataObj_SetDWORD(_pdtobj, g_cfPreferredDropEffect, 
                        (idCmdLocal == DFM_CMD_MOVE) ?
                        DROPEFFECT_MOVE : (DROPEFFECT_COPY | DROPEFFECT_LINK));

                    IShellFolderView *psfv;
                    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IShellFolderView, &psfv))))
                        psfv->SetPoints(_pdtobj);

                    OleSetClipboard(_pdtobj);

                    if (psfv)
                    {
                        // notify view so it can setup itself in the
                        // clipboard viewer chain
                        psfv->SetClipboard(DFM_CMD_MOVE == idCmdLocal);
                        psfv->Release();
                    }
                    break;

                case DFM_CMD_LINK:
                    SHCreateLinks(pici->hwnd, NULL, _pdtobj, lParam ? SHCL_USETEMPLATE | SHCL_USEDESKTOP : SHCL_USETEMPLATE, NULL);
                    break;

                case DFM_CMD_PASTE:
                case DFM_CMD_PASTELINK:
                    hr = _ProcessEditPaste(idCmdLocal == DFM_CMD_PASTELINK);
                    break;

                case DFM_CMD_RENAME:
                    hr = _ProcessRename();
                    break;

                default:
                    DebugMsg(TF_WARNING, TEXT("DefCM item command not processed in %s at %d (%x)"),
                                    __FILE__, __LINE__, idCmdLocal);
                    break;
                }
            }
            else
            {
                // This is a background menu. Process common command ids.
                switch(idCmdLocal)
                {
                case DFM_CMD_PASTE:
                case DFM_CMD_PASTELINK:
                    hr = _ProcessEditPaste(idCmdLocal == DFM_CMD_PASTELINK);
                    break;

                default:
                    // Only our commands should come here
                    DebugMsg(TF_WARNING, TEXT("DefCM background command not processed in %s at %d (%x)"),
                                    __FILE__, __LINE__, idCmdLocal);
                    break;
                }
            }
        }
    }
    else if (idCmd < _idVerbMax)
    {
        idCmdLocal = idCmd - _idFolderMax;
ProcessVerb:
        {
            CMINVOKECOMMANDINFOEX ici;
            UINT_PTR idCmdSave;

            CopyInvokeInfo(&ici, pici);

            if (IS_INTRESOURCE(pici->lpVerb))
                ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmdLocal);

            // One of extension menu is selected.
            idCmdSave = (UINT_PTR)ici.lpVerb;
            UINT_PTR idCmd = 0;

            hr = HDXA_LetHandlerProcessCommandEx(_hdxa, &ici, &idCmd);
            if (SUCCEEDED(hr) && (idCmd == idCmdSave))
            {
                // hdxa failed to handle it
                hr = E_INVALIDARG;
            }
        }
    }
    else if (idCmd < _idDelayInvokeMax)
    {
        _InvokeStatic((UINT)(idCmd-_idVerbMax));
    }
    else if (idCmd < _idFld2Max)
    {
        idCmdLocal = idCmd - _idDelayInvokeMax;
        goto ProcessCommand;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CDefFolderMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    HRESULT hr = E_INVALIDARG;
    UINT_PTR idCmdLocal;
    int i;

    if (!IS_INTRESOURCE(idCmd))
    {
        // This must be a string

        if (HDXA_GetCommandString(_hdxa, idCmd, uType, pwReserved, pszName, cchMax) == S_OK)
        {
            return S_OK;
        }

        // String can either be Ansi or Unicode. Since shell32 is built unicode, we need to compare 
        // idCmd against the ansi version of the verb string.
        LPTSTR pCmd;
        LPSTR  pCmdA;
        pCmd = (LPTSTR)idCmd;
        pCmdA = (LPSTR)idCmd;

        // Convert the string into an ID
        for (i = 0; i < ARRAYSIZE(c_sDFMCmdInfo); i++)
        {
            if (!lstrcmpi(pCmd, c_sDFMCmdInfo[i].pszCmd) || !StrCmpIA(pCmdA, c_sDFMCmdInfo[i].pszCmdA))
            {
                idCmdLocal = (UINT) c_sDFMCmdInfo[i].idDFMCmd;
                goto ProcessCommand;
            }
        }
        return E_INVALIDARG;
    }

    if (idCmd < _idStdMax)
    {
        idCmdLocal = idCmd;

        switch (uType)
        {
        case GCS_HELPTEXTA:
            // HACK: DCM commands are in the same order as SFV commands
            return(LoadStringA(HINST_THISDLL,
                (UINT) idCmdLocal + (UINT)(SFVIDM_FIRST + SFVIDS_MH_FIRST),
                (LPSTR)pszName, cchMax) ? S_OK : E_OUTOFMEMORY);
            break;

        case GCS_HELPTEXTW:
            // HACK: DCM commands are in the same order as SFV commands
            return(LoadStringW(HINST_THISDLL,
                (UINT) idCmdLocal + (UINT)(SFVIDM_FIRST + SFVIDS_MH_FIRST),
                (LPWSTR)pszName, cchMax) ? S_OK : E_OUTOFMEMORY);
            break;

        case GCS_VERBA:
        case GCS_VERBW:
            return SHMapCmdIDToVerb(idCmdLocal, c_sDFMCmdInfo, ARRAYSIZE(c_sDFMCmdInfo), pszName, cchMax, uType == GCS_VERBW);

        case GCS_VALIDATEA:
        case GCS_VALIDATEW:
            
        default:
            return E_NOTIMPL;
        }
    } 
    else if (idCmd < _idFolderMax)
    {
        idCmdLocal = idCmd - _idStdMax;
ProcessCommand:
        if (!_pcmcb)
            return E_NOTIMPL;   // REVIEW: If no callback, how can idFolderMax be > 0?

        // This is a folder menu
        switch (uType)
        {
        case GCS_HELPTEXTA:
            return _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_GETHELPTEXT,
                      (WPARAM)MAKELONG(idCmdLocal, cchMax), (LPARAM)pszName);

        case GCS_HELPTEXTW:
            return _pcmcb->CallBack(_psf, _hwnd, _pdtobj, DFM_GETHELPTEXTW,
                      (WPARAM)MAKELONG(idCmdLocal, cchMax), (LPARAM)pszName);

        case GCS_VALIDATEA:
        case GCS_VALIDATEW:
            return _pcmcb->CallBack(_psf, _hwnd, _pdtobj,
                DFM_VALIDATECMD, idCmdLocal, 0);

        case GCS_VERBA:
            return _pcmcb->CallBack(_psf, _hwnd, _pdtobj,
                DFM_GETVERBA, (WPARAM)MAKELONG(idCmdLocal, cchMax), (LPARAM)pszName);

        case GCS_VERBW:
            return _pcmcb->CallBack(_psf, _hwnd, _pdtobj,
                DFM_GETVERBW, (WPARAM)MAKELONG(idCmdLocal, cchMax), (LPARAM)pszName);

        default:
            return E_NOTIMPL;
        }
    }
    else if (idCmd < _idVerbMax)
    {
        idCmdLocal = idCmd - _idFolderMax;
        // One of extension menu is selected.
        hr = HDXA_GetCommandString(_hdxa, idCmdLocal, uType, pwReserved, pszName, cchMax);
    }
    else if (idCmd < _idDelayInvokeMax)
    {
        // menu extensions that are loaded at invoke time don't support this
    }
    else if (idCmd < _idFld2Max)
    {
        idCmdLocal = idCmd - _idDelayInvokeMax;
        goto ProcessCommand;
    }

    return hr;
}

STDMETHODIMP CDefFolderMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, 
                                           LPARAM lParam,LRESULT* plResult)
{
    UINT uMsgFld = 0; // must zero init these since _pcmb->Callback() call at bottom passes these through even if uMsg doesn't match anything in the switch statement
    WPARAM wParamFld = 0;       // map the folder call back params to these
    LPARAM lParamFld = 0;
    UINT idCmd;
    UINT id; //temp var

    switch (uMsg) {
    case WM_MEASUREITEM:
        idCmd = GET_WM_COMMAND_ID(((MEASUREITEMSTRUCT *)lParam)->itemID, 0);
        // cannot use InRange because _idVerbMax can be equal to _idDelayInvokeMax
        id = idCmd-_idCmdFirst;
        if ((_bInitMenuPopup || (_hdsaStatics && _idVerbMax <= id)) && id < _idDelayInvokeMax)        
        {
            _MeasureItem((MEASUREITEMSTRUCT *)lParam);
            return S_OK;
        }
        
        uMsgFld = DFM_WM_MEASUREITEM;
        wParamFld = GetFldFirst(this);
        lParamFld = lParam;
        break;

    case WM_DRAWITEM:
        idCmd = GET_WM_COMMAND_ID(((LPDRAWITEMSTRUCT)lParam)->itemID, 0);
        // cannot use InRange because _idVerbMax can be equal to _idDelayInvokeMax
        id = idCmd-_idCmdFirst;
        if ((_bInitMenuPopup || (_hdsaStatics && _idVerbMax <= id)) && id < _idDelayInvokeMax)
        {
            _DrawItem((LPDRAWITEMSTRUCT)lParam);
            return S_OK;
        }

        uMsgFld = DFM_WM_DRAWITEM;
        wParamFld = GetFldFirst(this);
        lParamFld = lParam;
        break;

    case WM_INITMENUPOPUP:
        idCmd = GetMenuItemID((HMENU)wParam, 0);
        if (_uFlags & CMF_FINDHACK)
        {
            HMENU hmenu = (HMENU)wParam;
            int cItems = GetMenuItemCount(hmenu);
            
            _bInitMenuPopup = TRUE;
            if (!_hdsaCustomInfo)
                _hdsaCustomInfo = DSA_Create(sizeof(SEARCHINFO), 1);

            if (_hdsaCustomInfo && cItems > 0)
            {
                // need to go bottom up because we may delete some items
                for (int i = cItems - 1; i >= 0; i--)
                {
                    MENUITEMINFO mii = {0};
                    TCHAR szMenuText[MAX_PATH];

                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_TYPE | MIIM_DATA | MIIM_ID;
                    mii.dwTypeData = szMenuText;
                    mii.cch = ARRAYSIZE(szMenuText);
                    
                    if (GetMenuItemInfo(hmenu, i, TRUE, &mii) && (MFT_STRING == mii.fType))
                    {
                        SEARCHINFO sinfo;
                        // static items already have correct dwItemData (pointer to SEARCHEXTDATA added in _AddStatic)
                        // we now have to change other find extension's dwItemData from having an index into the icon
                        // cache to pointer to SEARCHEXTDATA
                        // cannot use InRange because _idVerbMax can be equal to _idDelayInvokeMax
                        id = mii.wID - _idCmdFirst;
                        if (!(_hdsaStatics && _idVerbMax <= id && id < _idDelayInvokeMax))
                        {
                            UINT iIcon = (UINT) mii.dwItemData;
                            SEARCHEXTDATA *psed = (SEARCHEXTDATA *)LocalAlloc(LPTR, sizeof(*psed));
                            if (psed)
                            {
                                psed->iIcon = iIcon;
                                SHTCharToUnicode(szMenuText, psed->wszMenuText, ARRAYSIZE(psed->wszMenuText));
                            }
                            mii.fMask = MIIM_DATA | MIIM_TYPE;
                            mii.fType = MFT_OWNERDRAW;
                            mii.dwItemData = (DWORD_PTR)psed;

                            sinfo.psed = psed;
                            sinfo.idCmd = mii.wID;
                            if (DSA_AppendItem(_hdsaCustomInfo, &sinfo) == -1)
                            {
                                DeleteMenu(hmenu, i, MF_BYPOSITION);
                                if (psed)
                                    LocalFree(psed);
                            }
                            else
                                SetMenuItemInfo(hmenu, i, TRUE, &mii);
                        }
                    }
                }
            }
            else if (!_hdsaCustomInfo)
            {
                // we could not allocate space for _hdsaCustomInfo
                // delete all items because there will be no pointer hanging off dwItemData
                // so start | search will fault
                for (int i = 0; i < cItems; i++)
                    DeleteMenu(hmenu, i, MF_BYPOSITION);
            }
        }
        
        uMsgFld = DFM_WM_INITMENUPOPUP;
        wParamFld = wParam;
        lParamFld = GetFldFirst(this);
        break;

    case WM_MENUSELECT:
        idCmd = (UINT) LOWORD(wParam);
        // cannot use InRange because _idVerbMax can be equal to _idDelayInvokeMax
        id = idCmd-_idCmdFirst;
        if (_punkSite && (_bInitMenuPopup || (_hdsaStatics && _idVerbMax <= id)) && id < _idDelayInvokeMax)
        {
            IShellBrowser *psb;
            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
            {
                MENUITEMINFO mii;

                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_DATA;
                mii.cch = 0; //just in case
                if (GetMenuItemInfo(_hmenu, idCmd, FALSE, &mii))
                {
                    SEARCHEXTDATA *psed = (SEARCHEXTDATA *)mii.dwItemData;
                    psb->SetStatusTextSB(psed->wszHelpText);
                }
                psb->Release();
            }
        }
        return S_OK;
        
      
    case WM_MENUCHAR:
        if ((_uFlags & CMF_FINDHACK) && _hdsaCustomInfo)
        {
            int cItems = DSA_GetItemCount(_hdsaCustomInfo);
            
            for (int i = 0; i < cItems; i++)
            {
                SEARCHINFO* psinfo = (SEARCHINFO*)DSA_GetItemPtr(_hdsaCustomInfo, i);
                ASSERT(psinfo);
                SEARCHEXTDATA* psed = psinfo->psed;
                
                if (psed)
                {
                    TCHAR szMenu[MAX_PATH];
                    SHUnicodeToTChar(psed->wszMenuText, szMenu, ARRAYSIZE(szMenu));
                
                    if (_MenuCharMatch(szMenu, (TCHAR)LOWORD(wParam), FALSE))
                    {
                        if (plResult) 
                            *plResult = MAKELONG(GetMenuPosFromID((HMENU)lParam, psinfo->idCmd), MNC_EXECUTE);
                        return S_OK;
                    }                            
                }
            }
            if (plResult) 
                *plResult = MAKELONG(0, MNC_IGNORE);
                
            return S_FALSE;
        }
        else
        {
            // TODO: this should probably get the idCmd of the MFS_HILITE item so we forward to the correct hdxa...
            idCmd = GetMenuItemID((HMENU)lParam, 0);
        }
        break;
        
    default:
        return E_FAIL;
    }

    // bias this down to the extension range (comes right after the folder range)

    idCmd -= _idCmdFirst + _idFolderMax;

    // Only forward along on IContextMenu3 as some shell extensions say they support
    // IContextMenu2, but fail and bring down the shell...
    IContextMenu3 *pcmItem;
    if (SUCCEEDED(HDXA_FindByCommand(_hdxa, idCmd, IID_PPV_ARG(IContextMenu3, &pcmItem))))
    {
        HRESULT hr = pcmItem->HandleMenuMsg2(uMsg, wParam, lParam, plResult);
        pcmItem->Release();
        return hr;
    }

    // redirect to the folder callback
    if (_pcmcb)
        return _pcmcb->CallBack(_psf, _hwnd, _pdtobj, uMsgFld, wParamFld, lParamFld);

    return E_FAIL;
}

STDMETHODIMP CDefFolderMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg,wParam,lParam,NULL);
}

STDMETHODIMP CDefFolderMenu::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_CtxQueryAssociations))
    {
        if (_paa)
            return _paa->QueryInterface(riid, ppvObj);
        else
        {
            *ppvObj = NULL;
            return E_NOINTERFACE;
        }
    }
    else
        return IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
}

STDMETHODIMP CDefFolderMenu::GetSearchGUID(GUID *pGuid)
{
    HRESULT hr = E_FAIL;
    
    if (_iStaticInvoked != -1)
    {
        STATICITEMINFO *psii = (STATICITEMINFO *)DSA_GetItemPtr(_hdsaStatics, _iStaticInvoked);
        if (psii)
        {
            *pGuid = psii->guidSearch;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CDefFolderMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);    // just grab this guy

    for (int i = 0; i < DSA_GetItemCount(_hdxa); i++)
    {
        ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(_hdxa, i);
        IShellExtInit *psei;
        if (SUCCEEDED(pcmi->pcm->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei))))
        {
            psei->Initialize(pidlFolder, pdtobj, hkeyProgID);
            psei->Release();
        }
    }
    return S_OK;
}


//=============================================================================
// HDXA stuff
//=============================================================================
//
//  This function enumerate all the context menu handlers and let them
// append menuitems. Each context menu handler will create an object
// which support IContextMenu interface. We call QueryContextMenu()
// member function of all those IContextMenu object to let them append
// menuitems. For each IContextMenu object, we create ContextMenuInfo
// struct and append it to hdxa (which is a dynamic array of ContextMenuInfo).
//
//  The caller will release all those IContextMenu objects, by calling
// its Release() member function.
//
// Arguments:
//  hdxa            -- Handler of the dynamic ContextMenuInfo struct array
//  pdata           -- Specifies the selected items (files)
//  hkeyShellEx     -- Specifies the reg.dat class we should enumurate handlers
//  hkeyProgID      -- Specifies the program identifier of the selected file/directory
//  pszHandlerKey   -- Specifies the reg.dat key to the handler list
//  pidlFolder      -- Specifies the folder (drop target)
//  hmenu           -- Specifies the menu to be modified
//  uInsert         -- Specifies the position to be insert menuitems
//  idCmdFirst      -- Specifies the first menuitem ID to be used
//  idCmdLast       -- Specifies the last menuitem ID to be used
//
// Returns:
//  The first menuitem ID which is not used.
//
// History:
//  02-25-93 SatoNa     Created
//
//  06-30-97 lAmadio    Modified to add ID mapping support.

UINT HDXA_AppendMenuItems(HDXA hdxa, IDataObject *pdtobj,
                          UINT nKeys, HKEY *ahkeys, LPCITEMIDLIST pidlFolder,
                          HMENU hmenu, UINT uInsert, UINT idCmdFirst, UINT idCmdLast,
                          UINT fFlags, HDCA hdca)
{
    QCMINFO qcm = {hmenu, uInsert, idCmdFirst, idCmdLast, NULL};
    return HDXA_AppendMenuItems2(hdxa, pdtobj, nKeys, ahkeys, pidlFolder, &qcm, fFlags, hdca, NULL);
}

UINT HDXA_AppendMenuItems2(HDXA hdxa, IDataObject *pdtobj,
                           UINT nKeys, HKEY *ahkeys, LPCITEMIDLIST pidlFolder,
                           QCMINFO* pqcm, UINT fFlags, HDCA hdca, IUnknown* pSite)
{
    const UINT idCmdBase = pqcm->idCmdFirst;
    UINT idCmdFirst = pqcm->idCmdFirst;

    // Apparently, somebody has already called into here with this object.  We
    // need to keep the ID ranges separate, so we'll put the new ones at the
    // end.
    // If QueryContextMenu is called too many times, we will run out of
    // ID range and not add anything.  We could try storing the information
    // used to create each pcm (HKEY, GUID, and fFlags) and reuse some of them,
    // but then we would have to worry about what if the number of commands
    // grows and other details; this is just not worth the effort since
    // probably nobody will ever have a problem.  The rule of thumb is to
    // create an IContextMenu, do the QueryContextMenu and InvokeCommand, and
    // then Release it.
    int idca = DSA_GetItemCount(hdxa);
    if (idca > 0)
    {
        ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(hdxa, idca-1);
        idCmdFirst += pcmi->idCmdMax;
    }

    // Note that we need to reverse the order because each extension
    // will insert menuitems "above" uInsert.
    UINT uInsertOffset = 0;
    for (idca = DCA_GetItemCount(hdca) - 1; idca >= 0; idca--)
    {
        TCHAR szCLSID[GUIDSTR_MAX];
        TCHAR szRegKey[GUIDSTR_MAX + 40];

        CLSID clsid = *DCA_GetItem(hdca, idca);
        SHStringFromGUID(clsid, szCLSID, ARRAYSIZE(szCLSID));

        // avoid creating an instance (loading the DLL) when:
        //  1. fFlags has CMF_DEFAULTONLY and
        //  2. CLSID\clsid\MayChangeDefault does not exist

        if ((fFlags & CMF_DEFAULTONLY) && (clsid != CLSID_ShellFileDefExt))
        {
            wnsprintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("CLSID\\%s\\shellex\\MayChangeDefaultMenu"), szCLSID);

            if (!SHRegSubKeyExists(HKEY_CLASSES_ROOT, szRegKey))
            {
                DebugMsg(TF_MENU, TEXT("HDXA_AppendMenuItems skipping %s"), szCLSID);
                continue;
            }
        }

        IShellExtInit *psei = NULL;
        IContextMenu *pcm = NULL;

        // Try all the class keys in order
        for (UINT nCurKey = 0; nCurKey < nKeys; nCurKey++)
        {
            // These cam from HKCR so need to go through administrator approval
            if (!psei && FAILED(DCA_ExtCreateInstance(hdca, idca, IID_PPV_ARG(IShellExtInit, &psei))))
                break;

            if (FAILED(psei->Initialize(pidlFolder, pdtobj, ahkeys[nCurKey])))
                continue;

            // Only get the pcm after initializing
            if (!pcm && FAILED(psei->QueryInterface(IID_PPV_ARG(IContextMenu, &pcm))))
                continue;
            
            wnsprintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("CLSID\\%s"), szCLSID);

            // Webvw needs the site in order to do its QueryContextMenu
            ContextMenuInfo cmi;
            cmi.pcm = pcm;
            cmi.dwCompat = SHGetObjectCompatFlags(NULL, &clsid);
            ContextMenuInfo_SetSite(&cmi, pSite);

            HRESULT hr;
            int cMenuItemsLast = GetMenuItemCount(pqcm->hmenu);
            DWORD dwExtType, dwType, dwSize = sizeof(dwExtType);
            if (SHGetValue(HKEY_CLASSES_ROOT, szRegKey, TEXT("flags"), &dwType, (BYTE*)&dwExtType, &dwSize) == ERROR_SUCCESS &&
                dwType == REG_DWORD &&
                (NULL != pqcm->pIdMap) &&
                dwExtType < pqcm->pIdMap->nMaxIds)
            {
                //Explanation:
                //Here we are trying to add a context menu extension to an already 
                //existing menu, owned by the sister object of DefView. We used the callback
                //to get a list of extension "types" and their place within the menu, relative
                //to IDs that the sister object inserted already. That object also told us 
                //where to put extensions, before or after the ID. Since they are IDs and not
                //positions, we have to convert using GetMenuPosFromID.
                hr = pcm->QueryContextMenu(
                    pqcm->hmenu, 
                    GetMenuPosFromID(pqcm->hmenu, pqcm->pIdMap->pIdList[dwExtType].id) +
                    ((pqcm->pIdMap->pIdList[dwExtType].fFlags & QCMINFO_PLACE_AFTER) ? 1 : 0),  
                    idCmdFirst, 
                    pqcm->idCmdLast, fFlags);
            }
            else
                hr = pcm->QueryContextMenu(pqcm->hmenu, pqcm->indexMenu + uInsertOffset, idCmdFirst, pqcm->idCmdLast, fFlags);

            UINT citems = HRESULT_CODE(hr);

            if (SUCCEEDED(hr) && citems)
            {
                cmi.idCmdFirst = idCmdFirst - idCmdBase;
                cmi.idCmdMax = cmi.idCmdFirst + citems;
                cmi.clsid = clsid;    // for debugging

                if (DSA_AppendItem(hdxa, &cmi) == -1)
                {
                    // There is no "clean" way to remove menu items, so
                    // we should check the add to the DSA before adding the
                    // menu items
                    DebugMsg(DM_ERROR, TEXT("filemenu.c ERROR: DSA_GetItemPtr failed (memory overflow)"));
                }
                else
                {
                    pcm->AddRef();
                }
                idCmdFirst += citems;

                FullDebugMsg(TF_MENU, TEXT("HDXA_Append: %d, %d"), idCmdFirst, citems);

                // keep going if it is our internal handler
                if (clsid == CLSID_ShellFileDefExt)
                {
                    //
                    //  for static registry verbs, make sure that 
                    //  they are added in priority of their specificity.
                    //
                    //  the first key needs its verbs at the top 
                    //  unless it is not the default handler.
                    //  so if the default hasnt been set,
                    //  then we dont push down the insert position.
                    //  
                    //  like "Directory" is more specific than "Folder" 
                    //  but the default verb is on "Folder".  so "Directory"
                    //  wont set the default verb, but "Folder" will.
                    //
                    if (-1 != GetMenuDefaultItem(pqcm->hmenu, TRUE, 0))
                    {
                        //  a default has been set, so each subsequent 
                        //  key is less important.
                        uInsertOffset += GetMenuItemCount(pqcm->hmenu) - cMenuItemsLast;
                    }
                }
                else
                {
                    //  try to bubble up the default to the top if possible,
                    //  since some apps just invoke the 0th index on the menu
                    //  instead of querying the menu for the default
                    if (0 == uInsertOffset && (0 == GetMenuDefaultItem(pqcm->hmenu, TRUE, 0)))
                        uInsertOffset++;

                    //  only CLSID_ShellFileDefExt gets a shot
                    //  at every key.  the rest are assumed
                    //  to do most of their work from the IDataObject
                    break;
                }

                pcm->Release();
                pcm = NULL;

                psei->Release();
                psei = NULL;

                continue;       // next hkey
            }
        }

        if (pcm)
            pcm->Release();

        if (psei)
            psei->Release();
    }

    return idCmdFirst;
}

//  This function is called after the user select one of add-in menu items.
// This function calls IncokeCommand method of corresponding context menu
// object.
//
//  hdxa            -- Handler of the dynamic ContextMenuInfo struct array
//  idCmd           -- Specifies the menu item ID
//  hwndParent      -- Specifies the parent window.
//  pszWorkingDir   -- Specifies the working directory.
//
// Returns:
//  IDCMD_PROCESSED, if InvokeCommand method is called; idCmd, otherwise

HRESULT HDXA_LetHandlerProcessCommandEx(HDXA hdxa, LPCMINVOKECOMMANDINFOEX pici, UINT_PTR * pidCmd)
{
    HRESULT hr = S_OK;
    UINT_PTR idCmd;

    if (!pidCmd)
        pidCmd = &idCmd;
        
    *pidCmd = (UINT_PTR)pici->lpVerb;

    // try handlers in order, the first to take it wins
    for (int i = 0; i < DSA_GetItemCount(hdxa); i++)
    {
        ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(hdxa, i);
        if (!IS_INTRESOURCE(pici->lpVerb))
        {
            // invoke by cannonical name case

            // app compat: some ctx menu extension always succeed regardless
            // if it is theirs or not.  better to never pass them a string
            if (!(pcmi->dwCompat & OBJCOMPATF_CTXMENU_NOVERBS))
            {
                hr = pcmi->pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)pici);
                if (SUCCEEDED(hr))
                {
                    *pidCmd = IDCMD_PROCESSED;
                    break;
                }
            }
            else
                hr = E_FAIL;
        }
        else if ((*pidCmd >= pcmi->idCmdFirst) && (*pidCmd < pcmi->idCmdMax))
        {
            CMINVOKECOMMANDINFOEX ici;
            CopyInvokeInfo(&ici, (CMINVOKECOMMANDINFO *)pici);
            ici.lpVerb = (LPSTR)MAKEINTRESOURCE(*pidCmd - pcmi->idCmdFirst);

            hr = pcmi->pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
            if (SUCCEEDED(hr))
            {
                *pidCmd = IDCMD_PROCESSED;
            }
            break;
        }
    }

    // It's OK if (idCmd != IDCMD_PROCESSED) because some callers will try to use several
    // IContextMenu implementations in order to get the IContextMenu for the selected items,
    // the IContextMenu for the background, etc.  CBackgrndMenu::InvokeCommand() does this.
    // -BryanSt (04/29/1999)
    return hr;
}


HRESULT HDXA_GetCommandString(HDXA hdxa, UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    HRESULT hr = E_INVALIDARG;
    LPTSTR pCmd = (LPTSTR)idCmd;

    if (!hdxa)
        return E_INVALIDARG;

    //
    // One of add-in menuitems is selected. Let the context
    // menu handler process it.
    //
    for (int i = 0; i < DSA_GetItemCount(hdxa); i++)
    {
        ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(hdxa, i);

        if (!IS_INTRESOURCE(idCmd))
        {
            // This must be a string command; see if this handler wants it
            if (pcmi->pcm->GetCommandString(idCmd, uType,
                                            pwReserved, pszName, cchMax) == S_OK)
            {
                return S_OK;
            }
        }
        //
        // Check if it is for this context menu handler.
        //
        // Notes: We can't use InRange macro because idCmdFirst might
        //  be equal to idCmdLast.
        // if (InRange(idCmd, pcmi->idCmdFirst, pcmi->idCmdMax-1))
        else if (idCmd >= pcmi->idCmdFirst && idCmd < pcmi->idCmdMax)
        {
            //
            // Yes, it is. Let it handle this menuitem.
            //
            hr = pcmi->pcm->GetCommandString(idCmd-pcmi->idCmdFirst, uType, pwReserved, pszName, cchMax);
            break;
        }
    }

    return hr;
}

HRESULT HDXA_FindByCommand(HDXA hdxa, UINT idCmd, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;    // bug nt power toy does not properly null out in error cases...

    if (hdxa)
    {
        for (int i = 0; i < DSA_GetItemCount(hdxa); i++)
        {
            ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(hdxa, i);

            if (idCmd >= pcmi->idCmdFirst && idCmd < pcmi->idCmdMax)
            {
                // APPCOMPAT: PGP50 can only be QIed for IContextMenu, IShellExtInit, and IUnknown.
                if (!(pcmi->dwCompat & OBJCOMPATF_CTXMENU_LIMITEDQI))
                    hr = pcmi->pcm->QueryInterface(riid, ppv);
                else
                    hr = E_FAIL;
                break;
            }
        }
    }
    return hr;
}

//
// This function releases all the IContextMenu objects in the dynamic
// array of ContextMenuInfo,
//
void HDXA_DeleteAll(HDXA hdxa)
{
    if (hdxa)
    {
        //  Release all the IContextMenu objects, then destroy the DSA.
        for (int i = 0; i < DSA_GetItemCount(hdxa); i++)
        {
            ContextMenuInfo *pcmi = (ContextMenuInfo *)DSA_GetItemPtr(hdxa, i);
            if (pcmi->pcm)
            {
                pcmi->pcm->Release();
            }
        }
        DSA_DeleteAllItems(hdxa);
    }
}

// This function releases all the IContextMenu objects in the dynamic
// array of ContextMenuInfo, then destroys the dynamic array.

void HDXA_Destroy(HDXA hdxa)
{
    if (hdxa)
    {
        HDXA_DeleteAll(hdxa);
        DSA_Destroy(hdxa);
    }
}

class CContextMenuCBImpl : public IContextMenuCB 
{
public:
    CContextMenuCBImpl(LPFNDFMCALLBACK pfn) : _pfn(pfn), _cRef(1) {}

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv) 
    {
        static const QITAB qit[] = {
            QITABENT(CContextMenuCBImpl, IContextMenuCB), // IID_IContextMenuCB
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    }

    STDMETHOD_(ULONG,AddRef)() 
    {
        return InterlockedIncrement(&_cRef);
    }

    STDMETHOD_(ULONG,Release)() 
    {
        ASSERT( 0 != _cRef );
        ULONG cRef = InterlockedDecrement(&_cRef);
        if ( 0 == cRef )
        {
            delete this;
        }
        return cRef;
    }

    // IContextMenuCB
    STDMETHOD(CallBack)(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return _pfn ? _pfn(psf, hwnd, pdtobj, uMsg, wParam, lParam) : E_FAIL;
    }

private:
    LONG _cRef;
    LPFNDFMCALLBACK _pfn;
};

STDAPI CreateDefaultContextMenu(DEFCONTEXTMENU *pdcm, IContextMenu **ppcm)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppcm = 0;
    CDefFolderMenu *pmenu = new CDefFolderMenu(FALSE);
    if (pmenu)
    {
        hr = pmenu->Init(pdcm);
        if (SUCCEEDED(hr))
            hr = pmenu->QueryInterface(IID_PPV_ARG(IContextMenu, ppcm));
        pmenu->Release();
    }
    return hr;
}    

STDAPI CDefFolderMenu_CreateHKeyMenu(HWND hwnd, HKEY hkey, IContextMenu **ppcm)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppcm = 0;
    CDefFolderMenu *pmenu = new CDefFolderMenu(TRUE);
    if (pmenu)
    {
        DEFCONTEXTMENU dcm = {0};
        dcm.hwnd = hwnd;
        dcm.aKeys = &hkey;
        dcm.cKeys = 1;
        hr = pmenu->Init(&dcm);
        if (SUCCEEDED(hr))
            hr = pmenu->QueryInterface(IID_PPV_ARG(IContextMenu, ppcm));
        pmenu->Release();
    }
    return hr;
}



STDAPI CDefFolderMenu_Create2Ex(LPCITEMIDLIST pidlFolder, HWND hwnd,
                                UINT cidl, LPCITEMIDLIST *apidl,
                                IShellFolder *psf, IContextMenuCB *pcmcb, 
                                UINT nKeys, const HKEY *ahkeys, 
                                IContextMenu **ppcm)
{
    DEFCONTEXTMENU dcm = {
        hwnd,
        pcmcb,
        pidlFolder,
        psf,
        cidl,
        apidl,
        NULL,
        nKeys,
        ahkeys};

    return CreateDefaultContextMenu(&dcm, ppcm);
}

STDAPI CDefFolderMenu_CreateEx(LPCITEMIDLIST pidlFolder,
                               HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                               IShellFolder *psf, IContextMenuCB *pcmcb, 
                               HKEY hkeyProgID, HKEY hkeyBaseProgID,
                               IContextMenu **ppcm)
{
    HKEY aKeys[2] = { hkeyProgID, hkeyBaseProgID};
    DEFCONTEXTMENU dcm = {
        hwnd,
        pcmcb,
        pidlFolder,
        psf,
        cidl,
        apidl,
        NULL,
        2,
        aKeys};

    return CreateDefaultContextMenu(&dcm, ppcm);
}

//
// old style CDefFolderMenu_Create and CDefFolderMenu_Create2
//

STDAPI CDefFolderMenu_Create(LPCITEMIDLIST pidlFolder,
                             HWND hwndOwner,
                             UINT cidl, LPCITEMIDLIST * apidl,
                             IShellFolder *psf,
                             LPFNDFMCALLBACK pfn,
                             HKEY hkeyProgID, HKEY hkeyBaseProgID,
                             IContextMenu **ppcm)
{
    HRESULT hr;
    IContextMenuCB *pcmcb = new CContextMenuCBImpl(pfn);
    if (pcmcb) 
    {
        HKEY aKeys[2] = { hkeyProgID, hkeyBaseProgID};
        DEFCONTEXTMENU dcm = {
            hwndOwner,
            pcmcb,
            pidlFolder,
            psf,
            cidl,
            apidl,
            NULL,
            2,
            aKeys};

        hr = CreateDefaultContextMenu(&dcm, ppcm);
        pcmcb->Release();
    }
    else
    {
        *ppcm = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI CDefFolderMenu_Create2(LPCITEMIDLIST pidlFolder, HWND hwnd,
                             UINT cidl, LPCITEMIDLIST *apidl,
                             IShellFolder *psf, LPFNDFMCALLBACK pfn,
                             UINT nKeys, const HKEY *ahkeys,
                             IContextMenu **ppcm)
{
    HRESULT hr;
    IContextMenuCB *pcmcb = new CContextMenuCBImpl(pfn);
    if (pcmcb) 
    {
        hr = CDefFolderMenu_Create2Ex(pidlFolder, hwnd, cidl, apidl, psf, pcmcb, 
                                      nKeys, ahkeys, ppcm);
        pcmcb->Release();
    }
    else
    {
        *ppcm = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

#define CXIMAGEGAP      6

void DrawMenuItem(DRAWITEMSTRUCT* pdi, LPCTSTR pszText, UINT iIcon)
{
    if ((pdi->itemAction & ODA_SELECT) || (pdi->itemAction & ODA_DRAWENTIRE))
    {
        int x, y;
        SIZE sz;
        RECT rc;

        // Draw the image (if there is one).

        GetTextExtentPoint(pdi->hDC, pszText, lstrlen(pszText), &sz);
        
        if (pdi->itemState & ODS_SELECTED)
        {
            SetBkColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            FillRect(pdi->hDC,&pdi->rcItem,GetSysColorBrush(COLOR_HIGHLIGHT));
        }
        else
        {
            SetTextColor(pdi->hDC, GetSysColor(COLOR_MENUTEXT));
            FillRect(pdi->hDC,&pdi->rcItem,GetSysColorBrush(COLOR_MENU));
        }
        
        rc = pdi->rcItem;
        rc.left += +2 * CXIMAGEGAP + g_cxSmIcon;
        
        DrawText(pdi->hDC,pszText,lstrlen(pszText), &rc, DT_SINGLELINE | DT_VCENTER);
        if (iIcon != -1)
        {
            x = pdi->rcItem.left + CXIMAGEGAP;
            y = (pdi->rcItem.bottom+pdi->rcItem.top-g_cySmIcon)/2;

            HIMAGELIST himlSmall;
            Shell_GetImageLists(NULL, &himlSmall);
            ImageList_Draw(himlSmall, iIcon, pdi->hDC, x, y, ILD_TRANSPARENT);
        } 
        else 
        {
            x = pdi->rcItem.left + CXIMAGEGAP;
            y = (pdi->rcItem.bottom+pdi->rcItem.top-g_cySmIcon)/2;
        }
    }
}

LRESULT MeasureMenuItem(MEASUREITEMSTRUCT *pmi, LPCTSTR pszText)
{
    LRESULT lres = FALSE;
            
    // Get the rough height of an item so we can work out when to break the
    // menu. User should really do this for us but that would be useful.
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        // REVIEW cache out the menu font?
        NONCLIENTMETRICS ncm;
        ncm.cbSize = sizeof(ncm);
        if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
        {
            HFONT hfont = CreateFontIndirect(&ncm.lfMenuFont);
            if (hfont)
            {
                SIZE sz;
                HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
                GetTextExtentPoint(hdc, pszText, lstrlen(pszText), &sz);
                pmi->itemHeight = max (g_cySmIcon + CXIMAGEGAP / 2, ncm.iMenuHeight);
                pmi->itemWidth = g_cxSmIcon + 2 * CXIMAGEGAP + sz.cx;
                pmi->itemWidth = 2 * CXIMAGEGAP + sz.cx;
                SelectObject(hdc, hfontOld);
                DeleteObject(hfont);
                lres = TRUE;
            }
        }
        ReleaseDC(NULL, hdc);
    }   
    return lres;
}


void CDefFolderMenu::_DrawItem(DRAWITEMSTRUCT *pdi)
{
    SEARCHEXTDATA *psed = (SEARCHEXTDATA *)pdi->itemData;
    if (psed)
    {
        TCHAR szMenuText[MAX_PATH];
        SHUnicodeToTChar(psed->wszMenuText, szMenuText, ARRAYSIZE(szMenuText));
        DrawMenuItem(pdi, szMenuText, psed->iIcon);
    }        
}

LRESULT CDefFolderMenu::_MeasureItem(MEASUREITEMSTRUCT *pmi)
{
    SEARCHEXTDATA *psed = (SEARCHEXTDATA *)pmi->itemData;
    if (psed)
    {
        TCHAR szMenuText[MAX_PATH];
        SHUnicodeToTChar(psed->wszMenuText, szMenuText, ARRAYSIZE(szMenuText));
        return MeasureMenuItem(pmi, szMenuText);
    }
    return FALSE;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\datautil.cpp ===
#include "shellprv.h"
#include "datautil.h"

#include "idlcomm.h"

STDAPI DataObj_SetDropTarget(IDataObject *pdtobj, const CLSID *pclsid)
{
    return DataObj_SetBlob(pdtobj, g_cfTargetCLSID, pclsid, sizeof(*pclsid));
}

STDAPI DataObj_GetDropTarget(IDataObject *pdtobj, CLSID *pclsid)
{
    return DataObj_GetBlob(pdtobj, g_cfTargetCLSID, pclsid, sizeof(*pclsid));
}

STDAPI_(UINT) DataObj_GetHIDACount(IDataObject *pdtobj)
{
    STGMEDIUM medium = {0};
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        UINT count = pida->cidl;

        ASSERT(pida->cidl == HIDA_GetCount(medium.hGlobal));

        HIDA_ReleaseStgMedium(pida, &medium);
        return count;
    }
    return 0;
}

// PERFPERF 
// This routine used to copy 512 bytes at a time, but that had a major negative perf impact.
// I have measured a 2-3x speedup in copy times by increasing this buffer size to 16k.
// Yes, its a lot of stack, but it is memory well spent.                    -saml
#define STREAM_COPY_BUF_SIZE        16384
#define STREAM_PROGRESS_INTERVAL    (100*1024/STREAM_COPY_BUF_SIZE) // display progress after this many blocks

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi)
{
    BYTE buf[STREAM_COPY_BUF_SIZE];
    ULONG cbRead;
    HRESULT hr = S_OK;
    ULARGE_INTEGER uliNewCompleted;
    DWORD dwLastTickCount = 0;

    if (ppi)
    {
        uliNewCompleted.QuadPart = ppi->uliBytesCompleted.QuadPart;
    }

    while (cb.QuadPart)
    {
        if (ppi && ppi->ppd)
        {
            DWORD dwTickCount = GetTickCount();
            
            if ((dwTickCount - dwLastTickCount) > 1000)
            {
                EVAL(SUCCEEDED(ppi->ppd->SetProgress64(uliNewCompleted.QuadPart, ppi->uliBytesTotal.QuadPart)));

                if (ppi->ppd->HasUserCancelled())
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    break;
                }
    
                dwLastTickCount = dwTickCount;
            }
        }

        hr = pstmFrom->Read(buf, min(cb.LowPart, sizeof(buf)), &cbRead);
        if (FAILED(hr) || (cbRead == 0))
        {
            //  sometimes we are just done.
            if (SUCCEEDED(hr))
                hr = S_OK;
            break;
        }


        if (ppi)
        {
            uliNewCompleted.QuadPart += (ULONGLONG) cbRead;
        }

        cb.QuadPart -= cbRead;

        hr = pstmTo->Write(buf, cbRead, &cbRead);
        if (FAILED(hr) || (cbRead == 0))
            break;
    }

    return hr;
}

//
//  APP COMPAT!  Prior versions of the shell used IStream::CopyTo to copy
//  the stream.  New versions of the shell use IStream::Read to copy the
//  stream so we can put up progress UI.  WebFerret 3.0000 implements both
//  IStream::Read and IStream::CopyTo, but their implementation of
//  IStream::Read hangs the system.  So we need to sniff at the data object
//  and stream to see if it is WebFerret.
//
//  WebFerret doesn't implement IPersist (so IPersist::GetClassID won't
//  help) and they don't fill in the CLSID in the FILEDESCRIPTOR
//  and it's an out-of-proc data object, so we have to go completely
//  on circumstantial evidence.
//

STDAPI_(BOOL) IUnknown_SupportsInterface(IUnknown *punk, REFIID riid)
{
    IUnknown *punkOut;
    if (SUCCEEDED(punk->QueryInterface(riid, (void **)&punkOut))) 
    {
        punkOut->Release();
        return TRUE;
    }
    return FALSE;
}

STDAPI_(BOOL) DataObj_ShouldCopyWithProgress(IDataObject *pdtobj, IStream *pstm, PROGRESSINFO * ppi)
{
    //
    //  Optimization:  If there is no progress info, then don't waste your
    //  time with progress UI.
    //
    if (!ppi) return FALSE;

    //
    //  How to detect a WebFerret IDataObject:
    //
    //  The filegroup descriptor gives all objects as size zero.
    //      (Check this first since it is cheap and usually false)
    //  WebFerret app is running (look for their tooltip window).
    //  Their IDataObject doesn't support anything other than IUnknown
    //      (so we use IID_IAsyncOperation to detect shell data objects
    //       and IPersist to allow ISVs to override).
    //  Their IStream doesn't support IStream::Stat.
    //

    STATSTG stat;

    if (ppi->uliBytesTotal.QuadPart == 0 &&
        FindWindow(TEXT("VslToolTipWindow"), NULL) &&
        !IUnknown_SupportsInterface(pdtobj, IID_IAsyncOperation) &&
        !IUnknown_SupportsInterface(pdtobj, IID_IPersist) &&
        pstm->Stat(&stat, STATFLAG_NONAME) == E_NOTIMPL)
    {
        return FALSE;           // WebFerret!
    }

    //  All test passed; go ahead and copy with progress UI

    return TRUE;
}

STDAPI DataObj_SaveToFile(IDataObject *pdtobj, UINT cf, LONG lindex, LPCTSTR pszFile, FILEDESCRIPTOR *pfd, PROGRESSINFO * ppi)
{
    STGMEDIUM medium = {0};
    FORMATETC fmte;
    HRESULT hr;

    fmte.cfFormat = (CLIPFORMAT) cf;
    fmte.ptd = NULL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex = lindex;
    fmte.tymed = TYMED_HGLOBAL | TYMED_ISTREAM | TYMED_ISTORAGE;

    hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        //
        // if the destination file is system or read-only,
        // clear those bits out so we can write anew.
        //
        DWORD dwTargetFileAttributes = GetFileAttributes(pszFile);
        if (dwTargetFileAttributes != -1)
        {
            if (dwTargetFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY))
            {
                SetFileAttributes(pszFile, dwTargetFileAttributes & ~(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY));
            }
        }

        DWORD dwSrcFileAttributes = 0;
        if (pfd->dwFlags & FD_ATTRIBUTES)
        {
            // store the rest of the attributes if passed...
            dwSrcFileAttributes = (pfd->dwFileAttributes & ~FILE_ATTRIBUTE_DIRECTORY);
        }

        switch (medium.tymed) {
        case TYMED_HGLOBAL:
        {
            HANDLE hfile = CreateFile(pszFile, GENERIC_READ | GENERIC_WRITE,
                 FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, dwSrcFileAttributes, NULL);

            if (hfile != INVALID_HANDLE_VALUE)
            {
                DWORD dwWrite;
                // NTRAID89561-2000/02/25-raymondc: what about writes greater than 4 GB?
                if (!WriteFile(hfile, GlobalLock(medium.hGlobal), (pfd->dwFlags & FD_FILESIZE) ? pfd->nFileSizeLow : (DWORD) GlobalSize(medium.hGlobal), &dwWrite, NULL))
                    hr = HRESULT_FROM_WIN32(GetLastError());

                GlobalUnlock(medium.hGlobal);

                if (pfd->dwFlags & (FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME))
                {
                    SetFileTime(hfile,
                                pfd->dwFlags & FD_CREATETIME ? &pfd->ftCreationTime : NULL,
                                pfd->dwFlags & FD_ACCESSTIME ? &pfd->ftLastAccessTime : NULL,
                                pfd->dwFlags & FD_WRITESTIME ? &pfd->ftLastWriteTime : NULL);
                }

                CloseHandle(hfile);

                if (FAILED(hr))
                    EVAL(DeleteFile(pszFile));
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            break;
        }

        case TYMED_ISTREAM:
        {
            IStream *pstm;
            hr = SHCreateStreamOnFile(pszFile, STGM_CREATE | STGM_WRITE | STGM_SHARE_DENY_WRITE, &pstm);
            if (SUCCEEDED(hr))
            {
                //
                // Per the SDK, IDataObject::GetData leaves the stream ptr at 
                // the end of the data in the stream.  To copy the stream we 
                // first must reposition the stream ptr to the begining.  
                // We restore the stream ptr to it's original location when we're done.
                //
                // NOTE:  In case the source stream doesn't support Seek(), 
                //        attempt the copy even if the seek operation fails.
                //
                const LARGE_INTEGER ofsBegin = {0, 0};
                ULARGE_INTEGER ofsOriginal   = {0, 0};
                HRESULT hrSeek = medium.pstm->Seek(ofsBegin, STREAM_SEEK_CUR, &ofsOriginal);
                if (SUCCEEDED(hrSeek))
                {
                    hrSeek = medium.pstm->Seek(ofsBegin, STREAM_SEEK_SET, NULL);
                }
                
                const ULARGE_INTEGER ul = {(UINT)-1, (UINT)-1};    // the whole thing

                if (DataObj_ShouldCopyWithProgress(pdtobj, medium.pstm, ppi))
                {
                    hr = StreamCopyWithProgress(medium.pstm, pstm, ul, ppi);
                }
                else
                {
                    hr = medium.pstm->CopyTo(pstm, ul, NULL, NULL);
                }
                if (SUCCEEDED(hrSeek))
                {
                    //
                    // Restore stream ptr in source to it's original location.
                    //
                    const LARGE_INTEGER ofs = { ofsOriginal.LowPart, (LONG)ofsOriginal.HighPart };
                    medium.pstm->Seek(ofs, STREAM_SEEK_SET, NULL);
                }
                
                pstm->Release();

                if (FAILED(hr))
                    EVAL(DeleteFile(pszFile));

                DebugMsg(TF_FSTREE, TEXT("IStream::CopyTo() -> %x"), hr);
            }
            break;
        }

        case TYMED_ISTORAGE:
        {
            WCHAR wszNewFile[MAX_PATH];
            IStorage *pstg;

            DebugMsg(TF_FSTREE, TEXT("got IStorage"));

            SHTCharToUnicode(pszFile, wszNewFile, ARRAYSIZE(wszNewFile));
            hr = StgCreateDocfile(wszNewFile,
                            STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                            0, &pstg);

            if (SUCCEEDED(hr))
            {
                hr = medium.pstg->CopyTo(0, NULL, NULL, pstg);

                DebugMsg(TF_FSTREE, TEXT("IStorage::CopyTo() -> %x"), hr);

                pstg->Commit(STGC_OVERWRITE);
                pstg->Release();

                if (FAILED(hr))
                    EVAL(DeleteFile(pszFile));
            }
        }
            break;

        default:
            AssertMsg(FALSE, TEXT("got tymed that I didn't ask for %d"), medium.tymed);
        }

        if (SUCCEEDED(hr))
        {
            // in the HGLOBAL case we could take some shortcuts, so the attributes and
            // file times were set earlier in the case statement.
            // otherwise, we need to set the file times and attributes now.
            if (medium.tymed != TYMED_HGLOBAL)
            {
                if (pfd->dwFlags & (FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME))
                {
                    // open with GENERIC_WRITE to let us set the file times,
                    // everybody else can open with SHARE_READ.
                    HANDLE hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
                    if (hFile != INVALID_HANDLE_VALUE)
                    {
                        SetFileTime(hFile,
                                    pfd->dwFlags & FD_CREATETIME ? &pfd->ftCreationTime : NULL,
                                    pfd->dwFlags & FD_ACCESSTIME ? &pfd->ftLastAccessTime : NULL,
                                    pfd->dwFlags & FD_WRITESTIME ? &pfd->ftLastWriteTime : NULL);
                        CloseHandle(hFile);
                    }
                }

                if (dwSrcFileAttributes)
                {
                    SetFileAttributes(pszFile, dwSrcFileAttributes);
                }
            }

            SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, pszFile, NULL);
            SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, pszFile, NULL);
        }

        ReleaseStgMedium(&medium);
    }
    return hr;
}

STDAPI DataObj_GetShellURL(IDataObject *pdtobj, STGMEDIUM *pmedium, LPCSTR *ppszURL)
{
    FORMATETC fmte = {g_cfShellURL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr;

    if (pmedium)
    {
        hr = pdtobj->GetData(&fmte, pmedium);
        if (SUCCEEDED(hr))
            *ppszURL = (LPCSTR)GlobalLock(pmedium->hGlobal);
    }
    else
        hr = pdtobj->QueryGetData(&fmte); // query only

    return hr;
}

STDAPI DataObj_GetOFFSETs(IDataObject *pdtobj, POINT *ppt)
{
    STGMEDIUM medium = {0};

    IDLData_InitializeClipboardFormats( );
    ASSERT(g_cfOFFSETS);

    FORMATETC fmt = {g_cfOFFSETS, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    ASSERT(ppt);
    ppt->x = ppt->y = 0;
    HRESULT hr = pdtobj->GetData(&fmt, &medium);
    if (SUCCEEDED(hr))
    {
        POINT * pptTemp = (POINT *)GlobalLock(medium.hGlobal);
        if (pptTemp)
        {
            *ppt = *pptTemp;
            GlobalUnlock(medium.hGlobal);
        }
        else
            hr = E_UNEXPECTED;
        ReleaseStgMedium(&medium);
    }
    return hr;
}

STDAPI_(BOOL) DataObj_CanGoAsync(IDataObject *pdtobj)
{
    BOOL fDoOpAsynch = FALSE;
    IAsyncOperation * pao;

    if (SUCCEEDED(pdtobj->QueryInterface(IID_PPV_ARG(IAsyncOperation, &pao))))
    {
        BOOL fIsOpAsync;
        if (SUCCEEDED(pao->GetAsyncMode(&fIsOpAsync)) && fIsOpAsync)
        {
            fDoOpAsynch = SUCCEEDED(pao->StartOperation(NULL));
        }
        pao->Release();
    }
    return fDoOpAsynch;
}

//
// HACKHACK: (reinerf) - We used to always do async drag/drop operations on NT4 by cloning the
// dataobject. Some apps (WS_FTP 6.0) rely on the async nature in order for drag/drop to work since
// they stash the return value from DoDragDrop and look at it later when their copy hook is invoked 
// by SHFileOperation(). So, we sniff the HDROP and if it has one path that contains "WS_FTPE\Notify"
// in it, then we do the operation async. 
//
STDAPI_(BOOL) DataObj_GoAsyncForCompat(IDataObject *pdtobj)
{
    BOOL bRet = FALSE;
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
    {
        // is there only one path in the hdrop?
        if (DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0) == 1)
        {
            TCHAR szPath[MAX_PATH];

            // is it the magical WS_FTP path ("%temp%\WS_FTPE\Notify") that WS_FTP sniffs
            // for in their copy hook?
            if (DragQueryFile((HDROP)medium.hGlobal, 0, szPath, ARRAYSIZE(szPath)) &&
                StrStrI(szPath, TEXT("WS_FTPE\\Notify")))
            {
                // yes, we have to do an async operation for app compat
                TraceMsg(TF_WARNING, "DataObj_GoAsyncForCompat: found WS_FTP HDROP, doing async drag-drop");
                bRet = TRUE;
            }
        }

        ReleaseStgMedium(&medium);
    }

    return bRet;
}

// use GlobalFree() to free the handle returned here
STDAPI DataObj_CopyHIDA(IDataObject *pdtobj, HIDA *phida)
{
    *phida = NULL;

    IDLData_InitializeClipboardFormats();

    STGMEDIUM medium;
    FORMATETC fmte = {g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        SIZE_T cb = GlobalSize(medium.hGlobal);
        *phida = (HIDA)GlobalAlloc(GPTR, cb);
        if (*phida)
        {
            void *pv = GlobalLock(medium.hGlobal);
            CopyMemory((void *)*phida, pv, cb);
            GlobalUnlock(medium.hGlobal);
        }
        else
            hr = E_OUTOFMEMORY;
        ReleaseStgMedium(&medium);
    }
    return hr;
}

// Returns an IShellItem for the FIRST item in the data object
HRESULT DataObj_GetIShellItem(IDataObject *pdtobj, IShellItem** ppsi)
{
    LPITEMIDLIST pidl;
    HRESULT hr = PidlFromDataObject(pdtobj, &pidl);
    if (SUCCEEDED(hr))
    {
        // at shome point should find out who is calling this
        // can see if caller already as the info to create the ShellItem
        hr = SHCreateShellItem(NULL, NULL, pidl, ppsi);
        ILFree(pidl);
    }
    return hr;
}

STDAPI PathFromDataObject(IDataObject *pdtobj, LPTSTR pszPath, UINT cchPath)
{
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    HRESULT hr = pdtobj->GetData(&fmte, &medium);

    if (SUCCEEDED(hr))
    {
        if (DragQueryFile((HDROP)medium.hGlobal, 0, pszPath, cchPath))
            hr = S_OK;
        else
            hr = E_FAIL;

        ReleaseStgMedium(&medium);
    }

    return hr;
}

STDAPI PidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidlTarget)
{
    HRESULT hr;

    *ppidlTarget = NULL;

    // If the data object has a HIDA, then use it.  This allows us to
    // access pidls inside data objects that aren't filesystem objects.
    // (It's also faster than extracting the path and converting it back
    // to a pidl.  Difference:  pidls for files on the desktop
    // are returned in original form instead of being converted to
    // a CSIDL_DESKTOPDIRECTORY-relative pidl.  I think this is a good thing.)

    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);

    if (pida)
    {
        *ppidlTarget = HIDA_ILClone(pida, 0);
        HIDA_ReleaseStgMedium(pida, &medium);
        hr = *ppidlTarget ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        // No HIDA available; go for a filename

        // This string is also used to store an URL in case it's an URL file
        TCHAR szPath[MAX_URL_STRING];

        hr = PathFromDataObject(pdtobj, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            *ppidlTarget = ILCreateFromPath(szPath);
            hr = *ppidlTarget ? S_OK : E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\datautil.h ===
#include <dobjutil.h>  // shell\inc (shared stuff)
#include "idlcomm.h"

// helper functions for people working with data objects

typedef struct
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
} PROGRESSINFO;

STDAPI_(UINT)   DataObj_GetHIDACount(IDataObject *pdtobj);
STDAPI          DataObj_SetDropTarget(IDataObject *pdtobj, const CLSID *pclsid);
STDAPI          DataObj_GetDropTarget(IDataObject *pdtobj, CLSID *pclsid);
STDAPI_(void *) DataObj_SaveShellData(IDataObject *pdtobj, BOOL fShared);
STDAPI          DataObj_GetShellURL(IDataObject *pdtobj, STGMEDIUM *pmedium, LPCSTR *ppszURL);
STDAPI_(void)   ReleaseStgMediumHGLOBAL(void *pv, STGMEDIUM *pmedium);
STDAPI          DataObj_SaveToFile(IDataObject *pdtobj, UINT cf, LONG lindex, LPCTSTR pszFile, FILEDESCRIPTOR *pfd, PROGRESSINFO * ppi);
STDAPI          DataObj_GetOFFSETs(IDataObject *pdtobj, POINT * ppt);
STDAPI_(BOOL)   DataObj_CanGoAsync(IDataObject *pdtobj);
STDAPI_(BOOL)   DataObj_GoAsyncForCompat(IDataObject *pdtobj);
STDAPI          DataObj_CopyHIDA(IDataObject * pdtobj, HIDA *phida);    // use GlobalFree() to free it
STDAPI          DataObj_GetIShellItem(IDataObject *pdtobj, IShellItem** ppsi);

STDAPI PathFromDataObject(IDataObject *pdtobj, LPTSTR pszPath, UINT cchPath);
STDAPI PidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidlTarget);

#define HIDA_GetPIDLFolder(pida)        (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])
#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defclsf.c ===
//
// This file contains the implementation of SHCreateDefClassObject
//

#include "shellprv.h"
#pragma  hdrstop

typedef struct
{
    IClassFactory      cf;
    UINT               cRef;            // Reference count
    DWORD              dwFlags;         // Flags to control creation...
    LPFNCREATEINSTANCE pfnCreateInstance;          // CreateInstance callback entry
    UINT *        pcRefDll;     // Reference count of the DLL
} CClassFactory;

STDMETHODIMP CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    CClassFactory *this = IToClass(CClassFactory, cf, pcf);
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        InterlockedIncrement(&this->cRef);
        *ppvObj = (LPVOID) (IClassFactory *) &this->cf;
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory_AddRef(IClassFactory *pcf)
{
    CClassFactory *this = IToClass(CClassFactory, cf, pcf);
    return this->cRef;
}

STDMETHODIMP_(ULONG) CClassFactory_Release(IClassFactory *pcf)
{
    CClassFactory *this = IToClass(CClassFactory, cf, pcf);
    if (--this->cRef > 0)
	return this->cRef;

    LocalFree((HLOCAL)this);

    return 0;
}

STDMETHODIMP CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    CClassFactory *this = IToClass(CClassFactory, cf, pcf);

    *ppvObject = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    return this->pfnCreateInstance(pUnkOuter, riid, ppvObject);
}

STDMETHODIMP CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{
    CClassFactory *this = IToClass(CClassFactory, cf, pcf);
    if (this->pcRefDll)
    {
        if (fLock)
	    this->pcRefDll++;
        else
	    this->pcRefDll--;
    }
    return S_OK;
}

const IClassFactoryVtbl c_vtblAppUIClassFactory = {
    CClassFactory_QueryInterface, CClassFactory_AddRef, CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer
};

//
// creates a simple default implementation of IClassFactory
//
// Parameters:
//  riid     -- Specifies the interface to the class object
//  ppv      -- Specifies the pointer to LPVOID where the class object pointer
//               will be returned.
//  pfnCreateInstance   -- Specifies the callback entry for instanciation.
//  pcRefDll -- Specifies the address to the DLL reference count (optional)
//
// Notes:
//   The riidInst will be specified only if the instance of the class
//  support only one interface.
//
// we would like to get rid of this
// this API called by MMSYS.CPL, RNAUI.DLL, SYNCUI.DLL

STDAPI SHCreateDefClassObject(REFIID riid, void **ppv, LPFNCREATEINSTANCE pfnCreateInstance, UINT *pcRefDll, REFIID riidInst)
{
    *ppv = NULL;

    if (IsEqualIID(riid, &IID_IClassFactory))
    {
        CClassFactory *pacf = (CClassFactory *)LocalAlloc(LPTR, SIZEOF(CClassFactory));
        if (pacf)
        {
            pacf->cf.lpVtbl = &c_vtblAppUIClassFactory;
            pacf->cRef++;  // pacf->cRef=0; (generates smaller code)
            pacf->pcRefDll = pcRefDll;
            pacf->pfnCreateInstance = pfnCreateInstance;

            (IClassFactory *)*ppv = &pacf->cf;
            return NOERROR;
        }
        return E_OUTOFMEMORY;
    }
    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dbcs.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dbcs.c

Abstract:

    This module contains the code for console DBCS font dialog

Author:

    kazum Feb-27-1995

Revision History:

--*/

#include "shellprv.h"
#pragma hdrstop

#include "lnkcon.h"

#ifdef DBCS

// This definition shares in windows\inc\wincon.w file
//
#define MACHINE_REGISTRY_CONSOLE_TTFONT (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont")

#define MACHINE_REGISTRY_CONSOLE_NLS    (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console\\Nls")


NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    )
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    // lpSubKey is one of those #defines up there.
    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    return NtOpenKey(
              phResult,
              KEY_READ,
              &Obja
              );
}

NTSTATUS
MyRegEnumValue(
    IN HANDLE hKey,
    IN DWORD dwIndex,
    OUT DWORD dwValueLength,
    OUT LPWSTR lpValueName,
    OUT DWORD dwDataLength,
    OUT LPBYTE lpData
    )
{
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + dwValueLength + dwDataLength;
    KeyValueInformation = LocalAlloc(LPTR,BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtEnumerateValueKey(
                hKey,
                dwIndex,
                KeyValueFullInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->NameLength <= dwValueLength);
        RtlMoveMemory(lpValueName,
                      KeyValueInformation->Name,
                      min(KeyValueInformation->NameLength, dwValueLength));
        lpValueName[ KeyValueInformation->NameLength >> 1 ] = UNICODE_NULL;


        ASSERT(KeyValueInformation->DataLength <= dwDataLength);
        RtlMoveMemory(lpData,
            (PBYTE)KeyValueInformation + KeyValueInformation->DataOffset,
            min(KeyValueInformation->DataLength, dwDataLength));
        if (KeyValueInformation->Type == REG_SZ ||
            KeyValueInformation->Type == REG_MULTI_SZ
           ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwDataLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            // WTF is this doing?
            if (KeyValueInformation->DataLength < dwDataLength)
                lpData[KeyValueInformation->DataLength++] = 0;
            if (KeyValueInformation->DataLength < dwDataLength)
                lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    LocalFree(KeyValueInformation);
    return Status;
}





WORD
ConvertStringToDec(
    LPWSTR lpch,
    LPWSTR *endptr
    )
{
    WCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != L'\0')
    {
        if (L'0' <= ch && ch <= L'9')
            val = (val * 10) + (ch - L'0');
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}

WORD
ConvertStringToHex(
    LPWSTR lpch,
    LPWSTR *endptr
    )
{
    WCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != L'\0')
    {
        if (L'0' <= ch && ch <= L'9')
            val = (val << 4) + (ch - L'0');
        else if (L'A' <= ch && ch <= L'F')
            val = (val << 4) + (ch - L'A' + 10);
        else if (L'a' <= ch && ch <= L'f')
            val = (val << 4) + (ch - L'a' + 10);
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}


NTSTATUS
MakeAltRasterFont(
    CONSOLEPROP_DATA * pcpd,
    UINT CodePage,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPTSTR AltFaceName,
    UINT cchFaceName
    )
{
    DWORD i;
    DWORD Find;
    ULONG FontIndex;
    COORD FontSize = pcpd->FontInfo[pcpd->DefaultFontIndex].Size;
    COORD FontDelta;
    BOOL  fDbcsCharSet = IS_ANY_DBCS_CHARSET( CodePageToCharSet( CodePage ) );

    FontIndex = 0;
    Find = (DWORD)-1;
    for (i=0; i < pcpd->NumberOfFonts; i++)
    {
        if (!TM_IS_TT_FONT(pcpd->FontInfo[i].Family) &&
            IS_ANY_DBCS_CHARSET(pcpd->FontInfo[i].tmCharSet) == fDbcsCharSet
           )
        {
            FontDelta.X = (SHORT)abs(FontSize.X - pcpd->FontInfo[i].Size.X);
            FontDelta.Y = (SHORT)abs(FontSize.Y - pcpd->FontInfo[i].Size.Y);
            if (Find > (DWORD)(FontDelta.X + FontDelta.Y))
            {
                Find = (DWORD)(FontDelta.X + FontDelta.Y);
                FontIndex = i;
            }
        }
    }

    *AltFontIndex = FontIndex;
    StrCpyN(AltFaceName, pcpd->FontInfo[*AltFontIndex].FaceName, cchFaceName);
    *AltFontSize = pcpd->FontInfo[*AltFontIndex].Size;
    *AltFontFamily = pcpd->FontInfo[*AltFontIndex].Family;

    return STATUS_SUCCESS;
}

NTSTATUS
InitializeDbcsMisc(
    CONSOLEPROP_DATA * pcpd
    )
{
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    DWORD dwIndex;
    LPWSTR pwsz;

    pcpd->gTTFontList.Next = NULL;

    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_TTFONT,
                          &hkRegistry);
    if (NT_SUCCESS( Status )) {
        TTFONTLIST *pTTFontList;

        for( dwIndex = 0; ; dwIndex++) {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status )) {
                break;
            }

            pTTFontList = LocalAlloc(LPTR, sizeof(TTFONTLIST));
            if (pTTFontList == NULL) {
                break;
            }

            pTTFontList->List.Next = NULL;
            pTTFontList->CodePage = ConvertStringToDec(awchValue, NULL);
            pwsz = awchData;
            if (*pwsz == BOLD_MARK) {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            else
                pTTFontList->fDisableBold = FALSE;
            StrCpyN(pTTFontList->FaceName1, pwsz, ARRAYSIZE(pTTFontList->FaceName1));

            pwsz += lstrlenW(pwsz) + 1;
            if (*pwsz == BOLD_MARK)
            {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            StrCpyN(pTTFontList->FaceName2, pwsz, ARRAYSIZE(pTTFontList->FaceName2));

            PushEntryList(&pcpd->gTTFontList, &(pTTFontList->List));
        }

        NtClose(hkRegistry);
    }

    pcpd->fChangeCodePage = FALSE;
    pcpd->uOEMCP = GetOEMCP();

    return STATUS_SUCCESS;
}

BYTE
CodePageToCharSet(
    UINT CodePage
    )
{
    CHARSETINFO csi;

    if (!TranslateCharsetInfo((DWORD *)UIntToPtr( CodePage ), &csi, TCI_SRCCODEPAGE)) // Sundown: valid zero-extension of CodePage for TCI_SRCCOPAGE.
        csi.ciCharset = OEM_CHARSET;

    return (BYTE)csi.ciCharset;
}

TTFONTLIST *SearchTTFont(CONSOLEPROP_DATA * pcpd, LPTSTR ptszFace, BOOL fCodePage, UINT CodePage)
{
    PSINGLE_LIST_ENTRY pTemp = pcpd->gTTFontList.Next;

    if (ptszFace) {
        while (pTemp != NULL) {
            TTFONTLIST *pTTFontList = (TTFONTLIST *)pTemp;

            if (wcscmp(ptszFace, pTTFontList->FaceName1) == 0 ||
                wcscmp(ptszFace, pTTFontList->FaceName2) == 0    ) {
                if (fCodePage)
                    if (pTTFontList->CodePage == CodePage )
                        return pTTFontList;
                    else
                        return NULL;
                else
                    return pTTFontList;
            }

            pTemp = pTemp->Next;
        }
    }

    return NULL;
}

BOOL
IsAvailableTTFont(
    CONSOLEPROP_DATA * pcpd,
    LPTSTR ptszFace
    )
{
    if (SearchTTFont(pcpd, ptszFace, FALSE, 0))
        return TRUE;
    else
        return FALSE;
}

BOOL
IsAvailableTTFontCP(
    CONSOLEPROP_DATA * pcpd,
    LPTSTR ptszFace,
    UINT CodePage
    )
{
    if (SearchTTFont(pcpd, ptszFace, TRUE, CodePage))
        return TRUE;
    else
        return FALSE;
}

BOOL
IsDisableBoldTTFont(
    CONSOLEPROP_DATA * pcpd,
    LPTSTR ptszFace
    )
{
    TTFONTLIST *pTTFontList;

    pTTFontList = SearchTTFont(pcpd, ptszFace, FALSE, 0);
    if (pTTFontList != NULL)
        return pTTFontList->fDisableBold;
    else
        return FALSE;
}

LPTSTR
GetAltFaceName(
    CONSOLEPROP_DATA * pcpd,
    LPTSTR ptszFace
    )
{
    TTFONTLIST *pTTFontList;

    pTTFontList = SearchTTFont(pcpd, ptszFace, FALSE, 0);
    if (pTTFontList) {
        if (wcscmp(ptszFace, pTTFontList->FaceName1) == 0) {
            return pTTFontList->FaceName2;
        }
        if (wcscmp(ptszFace, pTTFontList->FaceName2) == 0) {
            return pTTFontList->FaceName1;
        }
        return NULL;
    }
    else
        return NULL;
}

typedef struct _LC_List {
    struct _LC_List* Next;
    BOOL   FindFlag;
    WCHAR  LC_String[9];
} LC_List, *PLC_List;

static PLC_List LocaleList;

BOOL CALLBACK
EnumProc(
    LPWSTR LC_String
    )
{
    PLC_List TmpList;

    if (lstrlenW(LC_String) <= ARRAYSIZE(LocaleList->LC_String) - 1)
    {
        TmpList = (PLC_List)&LocaleList;

        while (TmpList->Next != NULL)
            TmpList = TmpList->Next;

        TmpList->Next = LocalAlloc(LPTR, sizeof(LC_List));
        if (TmpList->Next != NULL)
        {
            TmpList = TmpList->Next;
            StrCpyN(TmpList->LC_String, LC_String, ARRAYSIZE(TmpList->LC_String));
        }
    }
    return TRUE;
}


int
LanguageListCreate(
    HWND hDlg,
    UINT CodePage
    )

/*++

    Initializes the Language list by enumerating all Locale Information.

    Returns
--*/

{
    HWND hWndLanguageCombo;
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    DWORD dwIndex;
    PLC_List TmpList;
    WORD LangID;
    LCID Locale;
    int  cchData;
    LONG lListIndex;
    UINT cp;

    ENTERCRITICAL;

    /*
     * Enumrate system locale information
     */
    EnumSystemLocalesW( EnumProc, CP_INSTALLED );

    /*
     * Enumrate registory key
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_NLS,
                          &hkRegistry);
    if (NT_SUCCESS( Status )) {
        for( dwIndex = 0; ; dwIndex++)
        {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status ))
            {
                break;
            }

            TmpList = (PLC_List)&LocaleList;
            while(TmpList->Next != NULL)
            {
                TmpList = TmpList->Next;
                if (lstrcmpW(awchValue, TmpList->LC_String) == 0)
                {
                    TmpList->FindFlag = TRUE;
                    break;
                }
            }
        }

        NtClose(hkRegistry);

    }

    /*
     * Create ComboBox items
     */
    hWndLanguageCombo = GetDlgItem(hDlg, IDC_CNSL_LANGUAGELIST);
    SendMessage(hWndLanguageCombo, CB_RESETCONTENT, 0, 0L);

    TmpList = (PLC_List)&LocaleList;
    while(TmpList->Next != NULL)
    {
        TmpList = TmpList->Next;

        if (TmpList->FindFlag)
        {
            LangID = ConvertStringToHex(TmpList->LC_String, NULL);
            Locale = MAKELCID( LangID, SORT_DEFAULT );

            awchValue[0] = L'\0';
            cp = 0;

            {
                #define KERNEL32    _T("KERNEL32.DLL")

                #ifdef UNICODE
                #define GETCPINFOEX "GetCPInfoExW"
                #else
                #define GETCPINFOEX "GetCPInfoExA"
                #endif

                typedef BOOL (CALLBACK *LPFNGETCPINFOEX)(UINT, DWORD, LPCPINFOEX);
                LPFNGETCPINFOEX lpfnGetCPInfoEx;

                BOOL fRet = FALSE;
                CPINFOEX cpinfo;

                HMODULE hMod;

                cchData = GetLocaleInfoW(Locale, LOCALE_IDEFAULTCODEPAGE,
                                         awchData, ARRAYSIZE(awchData));
                if (cchData)
                {
                    cp = ConvertStringToDec(awchData, NULL);

                    hMod = GetModuleHandle(KERNEL32);
                    if (hMod) {
                        lpfnGetCPInfoEx = (LPFNGETCPINFOEX)GetProcAddress(hMod,GETCPINFOEX);
                        if (lpfnGetCPInfoEx)
                            fRet = (*lpfnGetCPInfoEx)(cp, 0, &cpinfo);
                    }
                    if (fRet) {
                        lListIndex = (LONG) SendMessageW(hWndLanguageCombo, CB_ADDSTRING, 0, (LPARAM)cpinfo.CodePageName);
                        SendMessage(hWndLanguageCombo, CB_SETITEMDATA, (DWORD)lListIndex, cp);

                        if (CodePage == cp) {
                            SendMessage(hWndLanguageCombo, CB_SETCURSEL, lListIndex, 0L);
                        }
                    }
                }
            }

            if (CodePage == cp) {
                SendMessage(hWndLanguageCombo, CB_SETCURSEL, lListIndex, 0L);
            }

        }
    }

    {
        PLC_List Tmp;

        TmpList = (PLC_List)&LocaleList;
        while(TmpList->Next != NULL)
        {
            Tmp = TmpList;
            TmpList = TmpList->Next;

            if (Tmp != (PLC_List)&LocaleList)
                LocalFree(Tmp);
        }

        LocaleList = NULL;
    }

    LEAVECRITICAL;

    /*
     * Get the LocaleIndex from the currently selected item.
     * (i will be LB_ERR if no currently selected item).
     */
    lListIndex = (LONG) SendMessage(hWndLanguageCombo, CB_GETCURSEL, 0, 0L);
    return (int) SendMessage(hWndLanguageCombo, CB_GETITEMDATA, lListIndex, 0L);
}
#endif // DBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defcm.h ===
//
//  publics for defcm
//

// Some code that knows defcm will be used likes to prepare the menu first.
// If you do this, you must call SHPrettyMenuForDefcm instead of _SHPrettyMenu
HRESULT SHPrepareMenuForDefcm(HMENU hmenu, UINT indexMenu, UINT uFlags, UINT idCmdFirst, UINT idCmdLast); // sets things up
HRESULT SHPrettyMenuForDefcm(HMENU hmenu, UINT uFlags, UINT idCmdFirst, UINT idCmdLast, HRESULT hrPrepare); // cleans things up part way
HRESULT SHUnprepareMenuForDefcm(HMENU hmenu, UINT idCmdFirst, UINT idCmdLast); // cleans things up the rest of the way (not required if you're just destroying the menu)


STDAPI CDefFolderMenu_CreateHKeyMenu(HWND hwndOwner, HKEY hkey, IContextMenu **ppcm);
STDAPI CDefFolderMenu_Create2Ex(LPCITEMIDLIST pidlFolder, HWND hwnd,
                                UINT cidl, LPCITEMIDLIST *apidl,
                                IShellFolder *psf, IContextMenuCB *pcmcb, 
                                UINT nKeys, const HKEY *ahkeyClsKeys, 
                                IContextMenu **ppcm);
STDAPI CDefFolderMenu_CreateEx(LPCITEMIDLIST pidlFolder,
                             HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                             IShellFolder *psf, IContextMenuCB *pcmcb, 
                             HKEY hkeyProgID, HKEY hkeyBaseProgID,
                             IContextMenu **ppcm);

STDAPI_(void) DrawMenuItem(DRAWITEMSTRUCT* pdi, LPCTSTR pszText, UINT iIcon);
STDAPI_(LRESULT) MeasureMenuItem(MEASUREITEMSTRUCT *pmi, LPCTSTR pszText);

typedef struct {
    UINT max;
    struct {
        UINT id;
        UINT fFlags;
    } list[2];
} IDMAPFORQCMINFO;
extern const IDMAPFORQCMINFO g_idMap;

typedef struct {
    HWND hwnd;
    IContextMenuCB *pcmcb;
    LPCITEMIDLIST pidlFolder;
    IShellFolder *psf;
    UINT cidl;
    LPCITEMIDLIST *apidl;
    IAssociationArray *paa;
    UINT cKeys;
    const HKEY *aKeys;
} DEFCONTEXTMENU;

STDAPI CreateDefaultContextMenu(DEFCONTEXTMENU *pdcm, IContextMenu **ppcm);
    
class CDefBackgroundMenuCB : public IContextMenuCB
{
public:
    CDefBackgroundMenuCB(LPCITEMIDLIST pidlFolder);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    virtual ~CDefBackgroundMenuCB();

    LPITEMIDLIST _pidlFolder;
    LONG         _cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defview.cpp ===
#include "shellprv.h"

#include <regstr.h>
#include <shellp.h>
#include <htmlhelp.h>
#include "ole2dup.h"
#include "ids.h"
#include "defview.h"
#include "lvutil.h"
#include "idlcomm.h"
#include "filetbl.h"
#include "undo.h"
#include "cnctnpt.h"
#include "ovrlaymn.h"
#include "_security.h"
#include "unicpp\dutil.h"
#include "uemapp.h"
#include "unicpp\deskhtm.h"
#include "unicpp\dcomp.h"
#include "datautil.h"
#include "defvphst.h"
#include <shdispid.h>
#include <limits.h>
#include "prop.h"
#include <mshtmcid.h>
#include "dvtasks.h"
#include "category.h"
#include "ViewState.h"
#include <initguid.h>
#include <guids.h>
#include <CommonControls.h>
#include "clsobj.h"
#include <sfview.h>
#include "defviewp.h"
#include "shellp.h"
#include "duiview.h"
#include "enumidlist.h"
#include "util.h"
#include "foldertypes.h"
#include <dpa.h>
#include "views.h"
#include "defcm.h"
#include "contextmenu.h"

// a "default" view to trick the browser into letting us delay viewmode selection
// {6C6720F7-4B22-4CAA-82D6-502BB6F85A9A}
DEFINE_GUID(VID_DefaultView, 0x6C6720F7L, 0x4B22, 0x4CAA, 0x82, 0xD6, 0x50, 0x2B, 0xB6, 0xF8, 0x5A, 0x9A);

void DisableActiveDesktop();
STDAPI_(void) CFSFolder_UpdateIcon(IShellFolder *psf, LPCITEMIDLIST pidl);
STDAPI_(void) SetPositionItemsPoints(IFolderView* psfv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ptDrag);
void UpdateGridSizes(BOOL fDesktop, HWND hwndListview, int nWorkAreas, LPRECT prcWork, BOOL fMinimizeGutterSpace);

#define ID_LISTVIEW     1
#define ID_STATIC       2

extern BOOL g_fDraggingOverSource;

#define IsDefaultState(_dvHead) ((_dvHead).dvState.lParamSort == 0 && \
                                 (_dvHead).dvState.iDirection == 1 && \
                                 (_dvHead).dvState.iLastColumnClick == -1 && \
                                 (_dvHead).ptScroll.x == 0 && (_dvHead).ptScroll.y == 0)

HMODULE g_hmodNTSHRUI = NULL;

typedef struct
{
    POINT pt;
    ITEMIDLIST idl;
} DVITEM;


//
// Note that it returns NULL, if iItem is -1.
//

// determine if color is light or dark
#define COLORISLIGHT(clr) ((5*GetGValue((clr)) + 2*GetRValue((clr)) + GetBValue((clr))) > 8*128)

void EnableCombinedView(CDefView *pdsv, BOOL fEnable);

BOOL IsBarricadeGloballyOff();
VARIANT_BOOL GetBarricadeStatus(LPCTSTR pszValueName);
BOOL GetBarricadeValueNameFromPidl(LPCITEMIDLIST pidl, LPTSTR pszValueName, UINT cch);
HRESULT SetBarricadeStatus(LPCTSTR pszValueName, VARIANT_BOOL bShowBarricade);


// Command Strings
// !! warning. Some ContextMenu handlers do not do a case-insensitive
// check of the command so keep the case the same everywhere

TCHAR const c_szCut[] = TEXT("cut");
TCHAR const c_szCopy[] = TEXT("copy");
TCHAR const c_szLink[] = TEXT("link");
TCHAR const c_szProperties[] = TEXT("properties");
TCHAR const c_szPaste[] = TEXT("paste");
TCHAR const c_szPasteLink[] = TEXT("pastelink");
TCHAR const c_szRename[] = TEXT("rename");
TCHAR const c_szDelete[] = TEXT("delete");
TCHAR const c_szNewFolder[] = TEXT(CMDSTR_NEWFOLDERA);

char const c_szDeleteA[] = "delete";
char const c_szNewFolderA[] = CMDSTR_NEWFOLDERA;
char const c_szPrintA[] = "print";

WCHAR const c_szPrintW[] = L"print";

DWORD CDefView::_Attributes(LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    return SHGetAttributes(_pshf, pidl, dwAttribs);
}


// IDefViewSafety
HRESULT CDefView::IsSafePage()
{
    HRESULT hr = E_ACCESSDENIED;
    WCHAR wszCurrentMoniker[MAX_PATH];
    if (SUCCEEDED(_cFrame._GetCurrentWebViewMoniker(wszCurrentMoniker,
            ARRAYSIZE(wszCurrentMoniker))))
    {
        // Some previous versions of the OS put a "FILE://" in front of the template name and some didn't.
        // SHRegisterValidateTemplate can't handle this prefix, so skip past it.
        LPWSTR pszMoniker = wszCurrentMoniker;
        if (!StrNCmpI(pszMoniker, L"FILE://", 7))
            pszMoniker += 7;

        hr = SHRegisterValidateTemplate(pszMoniker,
                SHRVT_VALIDATE | SHRVT_PROMPTUS